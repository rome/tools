#!/usr/bin/env node

(function(global) {
  'use strict';
  // project-rome/@romejs/ob1/index.ts
function ___R$project$rome$$romejs$ob1$index_ts$add(a, b) {
    // @ts-ignore
    return a + b;
  }

  function ___R$project$rome$$romejs$ob1$index_ts$sub(a, b) {
    // @ts-ignore
    return a - b;
  }

  function ___R$project$rome$$romejs$ob1$index_ts$get0(x) {
    // @ts-ignore
    return x;
  }

  function ___R$project$rome$$romejs$ob1$index_ts$get1(x) {
    // @ts-ignore
    return x;
  }

  function ___R$project$rome$$romejs$ob1$index_ts$coerce0(x) {
    return (x);
  }

  const ___R$project$rome$$romejs$ob1$index_ts$number0 = ___R$project$rome$$romejs$ob1$index_ts$coerce0(0);
  const ___R$project$rome$$romejs$ob1$index_ts$number0Neg1 = ___R$project$rome$$romejs$ob1$index_ts$coerce0(-1);

  function ___R$project$rome$$romejs$ob1$index_ts$coerce1(x) {
    return (x);
  }

  const ___R$project$rome$$romejs$ob1$index_ts$number1 = ___R$project$rome$$romejs$ob1$index_ts$coerce1(1);
  const ___R$project$rome$$romejs$ob1$index_ts$number1Neg1 = ___R$project$rome$$romejs$ob1$index_ts$coerce1(-1);

  function ___R$project$rome$$romejs$ob1$index_ts$coerce0to1(x) {
    // @ts-ignore
    return (x + 1);
  }

  function ___R$project$rome$$romejs$ob1$index_ts$coerce1to0(x) {
    // @ts-ignore
    return (x - 1);
  }

  function ___R$project$rome$$romejs$ob1$index_ts$inc(x) {
    // @ts-ignore
    return x + 1;
  }

  function ___R$project$rome$$romejs$ob1$index_ts$dec(x) {
    // @ts-ignore
    return x - 1;
  }

  // project-rome/@romejs/diagnostics/normalize.ts
const ___R$project$rome$$romejs$diagnostics$normalize_ts = {
    normalizePosition: ___R$project$rome$$romejs$diagnostics$normalize_ts$normalizePosition,
    normalizeDiagnostics: ___R$project$rome$$romejs$diagnostics$normalize_ts$normalizeDiagnostics,
    normalizeDiagnostic: ___R$project$rome$$romejs$diagnostics$normalize_ts$normalizeDiagnostic,
    normalizeDiagnosticAdviceItem: ___R$project$rome$$romejs$diagnostics$normalize_ts$normalizeDiagnosticAdviceItem,
  };
  function ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeLanguage(
    language,
  ) {
    if (language === undefined) {
      return 'unknown';
    } else {
      return language;
    }
  }

  function ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizePositionAssert(position) {
    const normalized = ___R$project$rome$$romejs$diagnostics$normalize_ts$normalizePosition(position);
    if (normalized === undefined) {
      return (
        {
          index: ___R$project$rome$$romejs$ob1$index_ts$number0Neg1,
          line: ___R$project$rome$$romejs$ob1$index_ts$number1,
          column: ___R$project$rome$$romejs$ob1$index_ts$number0,
        }
      );
    } else {
      return normalized;
    }
  }

  function ___R$project$rome$$romejs$diagnostics$normalize_ts$normalizePosition(
    position,
  ) {
    if (position === undefined) {
      return undefined;
    }

    const {line, column, index} = position;

    if (typeof line !== 'number' || typeof column !== 'number' ||
    typeof index !==
    'number') {
      return undefined;
    }

    return (
      {
        index: ___R$project$rome$$romejs$ob1$index_ts$coerce0(Math.max(index, -1)),
        line: ___R$project$rome$$romejs$ob1$index_ts$coerce1(Math.max(line, 1)),
        column: ___R$project$rome$$romejs$ob1$index_ts$coerce0(Math.max(column, 0)),
      }
    );
  }

  function ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeValue(value, def) {
    if (value === undefined) {
      return def;
    } else {
      return value;
    }
  }

  function ___R$project$rome$$romejs$diagnostics$normalize_ts$normalizeDiagnostics(
    diagnostics,
    opts,
  ) {
    return diagnostics.map((diag) => ___R$project$rome$$romejs$diagnostics$normalize_ts$normalizeDiagnostic(diag, opts));
  }

  function ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeFilename(
    filename,
    opts,
  ) {
    if (filename === undefined) {
      return 'unknown';
    } else if (opts.normalizeFilename === undefined) {
      return filename;
    } else {
      return opts.normalizeFilename(filename);
    }
  }

  function ___R$project$rome$$romejs$diagnostics$normalize_ts$normalizeDiagnostic(
    diagnostic,
    opts,
  ) {
    const filename = ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeFilename(diagnostic.filename, opts);
    const mtime = diagnostic.mtime;
    const origins = ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeValue(diagnostic.origins, []);

    const start = ___R$project$rome$$romejs$diagnostics$normalize_ts$normalizePosition(diagnostic.start);
    const end = ___R$project$rome$$romejs$diagnostics$normalize_ts$normalizePosition(diagnostic.end);

    const fixable = ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeValue(diagnostic.fixable, false);
    const sourceText = diagnostic.sourceText;
    const language = ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeLanguage(diagnostic.language);
    const sourceType = ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeValue(diagnostic.sourceType, 'unknown');
    const message = ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeValue(diagnostic.message, 'No message provided');
    const marker = diagnostic.marker;
    const dependencies = ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeDependencies(diagnostic.dependencies, opts);

    const diag = {
      category: diagnostic.category,
      label: diagnostic.label,
      message,
      origins,
      marker,
      language,
      sourceType,
      sourceText,
      fixable,
      dependencies,
      advice: [],
      filename,
      mtime,
      start,
      end,
    };

    const advice = ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeDiagnosticAdvice(diag, diagnostic.advice, opts);

    return (
      Object.assign(
        {
        },
        diag,
        {
          advice,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeDependencies(
    value,
    opts,
  ) {
    if (value === undefined) {
      return [];
    } else {
      const deps = [];

      for (const elem of value) {
        if (typeof elem === 'object' && elem != null &&
          typeof elem.filename ===
          'string' &&
          typeof elem.mtime === 'number') {
          deps.push(
            {
              filename: ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeFilename(elem.filename, opts),
              mtime: elem.mtime,
            },
          );
        }
      }

      return deps;
    }
  }

  function ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeAdviceStackFrame(
    value,
    opts,
  ) {
    return (
      {
        prefix: value.prefix,
        suffix: value.suffix,
        object: value.object,
        property: value.property,
        filename: ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeFilename(value.filename, opts),
        line: value.line,
        column: value.column,
        sourceText: value.sourceText,
        language: ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeLanguage(value.language),
      }
    );
  }

  function ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeAdviceStackFrames(
    value,
    opts,
  ) {
    if (Array.isArray(value)) {
      return value.map((item) => ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeAdviceStackFrame(item, opts));
    } else {
      return [];
    }
  }

  function ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeDiagnosticAdvice(
    diag,
    value,
    opts,
  ) {
    if (Array.isArray(value)) {
      return value.map((item) => ___R$project$rome$$romejs$diagnostics$normalize_ts$normalizeDiagnosticAdviceItem(diag, item, opts));
    } else {
      return [];
    }
  }

  function ___R$project$rome$$romejs$diagnostics$normalize_ts$normalizeDiagnosticAdviceItem(
    diag,
    part,
    opts,
  ) {
    switch (part.type) {
      case 'log':
        return (
          {
            type: 'log',
            category: part.category,
            message: ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeValue(part.message, 'No message provided'),
            compact: ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeValue(part.compact, false),
          }
        );

      case 'list':
        return (
          {
            type: 'list',
            list: part.list,
            truncate: ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeValue(part.truncate, false),
            reverse: ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeValue(part.reverse, false),
            ordered: ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeValue(part.ordered, false),
          }
        );

      case 'code':
        return (
          {
            type: 'code',
            code: ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeValue(part.code, ''),
            language: ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeLanguage(part.language || diag.language),
            sourceType: ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeValue(part.sourceType || diag.sourceType, 'unknown'),
          }
        );

      case 'frame':
        return (
          {
            type: 'frame',
            sourceType: ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeValue(part.sourceType || diag.sourceType, 'unknown'),
            language: ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeLanguage(part.language || diag.language),
            sourceText: part.sourceText,
            marker: part.marker,
            filename: ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeFilename(part.filename, opts),
            mtime: part.mtime,
            start: ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizePositionAssert(part.start),
            end: ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizePositionAssert(part.end),
          }
        );

      case 'diff':
        return (
          {
            type: 'diff',
            diff: part.diff,
            legend: part.legend,
          }
        );

      case 'stacktrace':
        return (
          {
            type: 'stacktrace',
            title: part.title,
            frames: ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeAdviceStackFrames(part.frames, opts),
            truncate: ___R$$priv$project$rome$$romejs$diagnostics$normalize_ts$normalizeValue(part.truncate, false),
          }
        );

      case 'inspect':
        return (
          {
            type: 'inspect',
            // @ts-ignore TODO

            // rome-suppress lint/noExplicitAny
            data: (part.data),
          }
        );
    }
  }

  // project-rome/@romejs/parser-core/types.ts
const ___R$project$rome$$romejs$parser$core$types_ts = {
    get UNKNOWN_POSITION() {
      return (
        ___R$project$rome$$romejs$parser$core$types_ts$UNKNOWN_POSITION
      );
    },
  };

  const ___R$project$rome$$romejs$parser$core$types_ts$UNKNOWN_POSITION = {
    index: ___R$project$rome$$romejs$ob1$index_ts$number0Neg1,
    line: ___R$project$rome$$romejs$ob1$index_ts$coerce1(-1),
    column: ___R$project$rome$$romejs$ob1$index_ts$number0Neg1,
  };

  // project-rome/@romejs/path/collections.ts
const ___R$project$rome$$romejs$path$collections_ts = {
    get AbsoluteFilePathMap() {
      return (
        ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap
      );
    },

    get RelativeFilePathMap() {
      return (
        ___R$project$rome$$romejs$path$collections_ts$RelativeFilePathMap
      );
    },

    get UnknownFilePathMap() {
      return (
        ___R$project$rome$$romejs$path$collections_ts$UnknownFilePathMap
      );
    },

    get AbsoluteFilePathSet() {
      return (
        ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet
      );
    },

    get RelativeFilePathSet() {
      return (
        ___R$project$rome$$romejs$path$collections_ts$RelativeFilePathSet
      );
    },

    get UnknownFilePathSet() {
      return (
        ___R$project$rome$$romejs$path$collections_ts$UnknownFilePathSet
      );
    },
  };
  // Sometimes we don't want to have to deal with what a FilePath serializes into

  // For those purposes we have these wrappers around Map and Set. Here we can add some custom logic

  // to speed up the usage of FilePaths in these scenarios.

  // The API here attempts to match what is expected from the native classes, however we may deviate from it

  // to avoid the usage of getters and generator/symbol indirection for iteration.
  class ___R$$priv$project$rome$$romejs$path$collections_ts$FilePathMap {
    constructor(entries) {
      this.joinedToValue = new Map();
      this.joinedToPath = new Map();
      this.size = 0;

      if (entries !== undefined) {
        for (const [key, value] of entries) {
          this.set(key, value);
        }
      }
    }

    _updateSize() {
      this.size = this.joinedToValue.size;
    }

    *[Symbol.iterator]() {
      for (const [joined, value] of this.joinedToValue) {
        const path = this.joinedToPath.get(joined);
        if (path === undefined) {
          throw new Error('Impossible');
        }

        yield [path, value];
      }
    }

    clear() {
      this.joinedToValue.clear();
      this.joinedToPath.clear();
      this._updateSize();
    }

    keys() {
      return this.joinedToPath.values();
    }

    values() {
      return this.joinedToValue.values();
    }

    delete(path) {
      const joined = path.getUnique().join();
      this.joinedToValue.delete(joined);
      this.joinedToPath.delete(joined);
      this._updateSize();
    }

    has(path) {
      return this.joinedToValue.has(path.getUnique().join());
    }

    get(path) {
      return this.joinedToValue.get(path.getUnique().join());
    }

    set(path, value) {
      const uniq = (path.getUnique());
      const joined = uniq.join();
      this.joinedToValue.set(joined, value);
      this.joinedToPath.set(joined, uniq);
      this._updateSize();
    }
  }

  class ___R$$priv$project$rome$$romejs$path$collections_ts$FilePathSet {
    constructor(entries) {
      this.map = new ___R$$priv$project$rome$$romejs$path$collections_ts$FilePathMap();
      this.size = 0;

      if (entries !== undefined) {
        for (const path of entries) {
          this.add(path);
        }
      }
    }

    _updateSize() {
      this.size = this.map.size;
    }

    [Symbol.iterator]() {
      return this.map.keys()[Symbol.iterator]();
    }

    has(path) {
      return this.map.has(path);
    }

    add(path) {
      this.map.set(path);
      this._updateSize();
    }

    delete(path) {
      this.map.delete(path);
      this._updateSize();
    }

    clear() {
      this.map.clear();
      this._updateSize();
    }
  }

  class ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap extends ___R$$priv$project$rome$$romejs$path$collections_ts$FilePathMap {
    constructor(...args) {
      super(
        ...args,
      );
      this.type =
        'absolute';
    }
  }

  class ___R$project$rome$$romejs$path$collections_ts$RelativeFilePathMap extends ___R$$priv$project$rome$$romejs$path$collections_ts$FilePathMap {
    constructor(...args) {
      super(
        ...args,
      );
      this.type =
        'relative';
    }
  }

  class ___R$project$rome$$romejs$path$collections_ts$UnknownFilePathMap extends ___R$$priv$project$rome$$romejs$path$collections_ts$FilePathMap {
    constructor(...args) {
      super(
        ...args,
      );
      this.type =
        'unknown';
    }
  }

  class ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet extends ___R$$priv$project$rome$$romejs$path$collections_ts$FilePathSet {
    constructor(...args) {
      super(
        ...args,
      );
      this.type =
        'absolute';
    }
  }

  class ___R$project$rome$$romejs$path$collections_ts$RelativeFilePathSet extends ___R$$priv$project$rome$$romejs$path$collections_ts$FilePathSet {
    constructor(...args) {
      super(
        ...args,
      );
      this.type =
        'relative';
    }
  }

  class ___R$project$rome$$romejs$path$collections_ts$UnknownFilePathSet extends ___R$$priv$project$rome$$romejs$path$collections_ts$FilePathSet {
    constructor(...args) {
      super(
        ...args,
      );
      this.type =
        'unknown';
    }
  }

  // project-rome/@romejs/path/index.ts
const ___R$$priv$project$rome$$romejs$path$index_ts$os = require(
    'os',
  );

  function ___R$$priv$project$rome$$romejs$path$index_ts$toFilePath(pathOrString) {
    if (typeof pathOrString === 'string') {
      return ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(pathOrString);
    } else {
      return pathOrString;
    }
  }

  class ___R$$priv$project$rome$$romejs$path$index_ts$BaseFilePath {
    constructor(parsed, opts) {
      if (parsed.segments.length === 0) {
        throw new Error('Cannot construct a FilePath with zero segments');
      }

      this.segments = parsed.segments;
      this.absoluteTarget = parsed.absoluteTarget;
      this.absoluteType = parsed.absoluteType;

      // Memoized
      this.memoizedUnique = undefined;
      this.memoizedParent = opts.parent;
      this.memoizedFilename = opts.filename;
      this.memoizedExtension = opts.ext;
      this.memoizedChildren = new Map();
    }

    getParsed() {
      return (
        {
          segments: this.segments,
          absoluteTarget: this.absoluteTarget,
          absoluteType: this.absoluteType,
        }
      );
    }

    // These methods ensure the correct return classes
    _assert() {
      throw new Error('Unimplemented');
    }

    _fork(parsed, opts) {
      throw new Error('Unimplemented');
    }

    addExtension(ext, clearExt = false) {
      const newBasename = clearExt
        ? this.getExtensionlessBasename() : this.getBasename();
      const newExt = clearExt ? ext : this.memoizedExtension + ext;
      const segments = this.getParentSegments(false).concat(newBasename + ext);

      return (
        this._fork(
          Object.assign(
            {
            },
            this.getParsed(),
            {
              segments,
            },
          ),
          {
            ext: newExt,
            parent: this.memoizedParent,
          },
        )
      );
    }

    changeBasename(newBasename) {
      const segments = this.getParentSegments(false).concat(newBasename);
      return (
        this._fork(
          Object.assign(
            {
            },
            this.getParsed(),
            {
              segments,
            },
          ),
          {
            parent: this.memoizedParent,
          },
        )
      );
    }

    getBasename() {
      const {segments} = this;
      const offset = this.isExplicitFolder() ? 2 : 1;
      return segments[segments.length - offset];
    }

    getExtensionlessBasename() {
      const basename = this.getBasename();
      const ext = this.getExtensions();

      if (ext === '') {
        return basename;
      } else {
        return basename.slice(0, -ext.length);
      }
    }

    getParent() {
      if (this.memoizedParent !== undefined) {
        return this.memoizedParent;
      }

      const parent = this._fork(
        Object.assign(
          {
          },
          this.getParsed(),
          {
            segments: this.getParentSegments(),
          },
        ),
        {},
      );
      this.memoizedParent = parent;
      return parent;
    }

    getParentSegments(explicit = true) {
      // Should we throw an error?
      if (this.isRoot()) {
        return this.segments;
      }

      const segments = this.getSegments().slice(0, -1);
      // Always make this an explicit folder
      if (explicit && segments.length > 0 && segments[0] !== '') {
        segments.push('');
      }
      return segments;
    }

    toExplicitRelative() {
      const relative = this.assertRelative();
      if (relative.isExplicitRelative()) {
        return relative;
      } else {
        return ___R$project$rome$$romejs$path$index_ts$createRelativeFilePath('.').append(relative);
      }
    }

    assertRelative() {
      if (this.isAbsolute()) {
        throw new Error('Expected relative file path but got: ' +
        this.join());
      } else {
        return (
          new ___R$project$rome$$romejs$path$index_ts$RelativeFilePath(
            this.getParsed(),
            {
              ext: this.memoizedExtension,
              filename: this.memoizedFilename,
            },
          )
        );
      }
    }

    assertAbsolute() {
      if (this.isAbsolute()) {
        return (
          new ___R$project$rome$$romejs$path$index_ts$AbsoluteFilePath(
            this.getParsed(),
            {
              ext: this.memoizedExtension,
              filename: this.memoizedFilename,
            },
          )
        );
      } else {
        throw new Error('Expected absolute file path but got: ' +
        this.join());
      }
    }

    assertURL() {
      if (this.isURL()) {
        return (
          new ___R$project$rome$$romejs$path$index_ts$URLFilePath(
            this.getParsed(),
            {
              ext: this.memoizedExtension,
              filename: this.memoizedFilename,
            },
          )
        );
      } else {
        throw new Error('Expected URL file path but got: ' +
        this.join());
      }
    }

    isRoot() {
      if (this.segments.length === 1) {
        return true;
      }

      if (this.segments.length === 2) {
        // Explicit folder reference
        return this.segments[1] === '';
      }

      if (this.segments.length === 3) {
        return this.absoluteType === 'windows-unc';
      }

      return false;
    }

    isWindows() {
      return (
        this.absoluteType === 'windows-drive' ||
        this.absoluteType ===
        'windows-unc'
      );
    }

    isPosix() {
      return !this.isWindows();
    }

    isURL() {
      return this.absoluteType === 'url';
    }

    isAbsolute() {
      return this.absoluteTarget !== undefined && this.absoluteType !== 'url';
    }

    isRelative() {
      return !this.isAbsolute();
    }

    isRelativeTo(otherRaw) {
      const other = ___R$$priv$project$rome$$romejs$path$index_ts$toFilePath(otherRaw);
      const otherSegments = other.getSegments();
      const ourSegments = this.getSegments();

      // We can't be relative to a path with more segments than us
      if (otherSegments.length > ourSegments.length) {
        return false;
      }

      // Check that we start with the same segments as the other
      for (let i = 0;
      i < otherSegments.length;
      i++) {
        if (otherSegments[i] !== ourSegments[i]) {
          return false;
        }
      }

      return true;
    }

    isImplicitRelative() {
      return !this.isExplicitRelative() && !this.isAbsolute() && !this.isURL();
    }

    isExplicitRelative() {
      const [firstSeg] = this.segments;
      return !this.isURL() && (firstSeg === '.' || firstSeg === '..');
    }

    isExplicitFolder() {
      const {segments} = this;
      return segments[segments.length - 1] === '';
    }

    hasEndExtension(ext) {
      return this.getExtensions().endsWith('.' +
      ext);
    }

    hasExtension(ext) {
      return this.hasEndExtension(ext) || this.getExtensions().includes('.' +
      ext +
      '.');
    }

    getExtensions() {
      if (this.memoizedExtension === undefined) {
        const ext = ___R$$priv$project$rome$$romejs$path$index_ts$getExtension(this.getBasename());
        this.memoizedExtension = ext;
        return ext;
      } else {
        return this.memoizedExtension;
      }
    }

    hasExtensions() {
      return this.getExtensions() !== '';
    }

    getSegments() {
      let {segments} = this;

      if (!this.isRoot()) {
        if (this.isExplicitFolder()) {
          segments = segments.slice(0, -1);
        }

        if (segments[0] === '.') {
          segments = segments.slice(1);
        }
      }

      return segments;
    }

    getRawSegments() {
      return this.segments;
    }

    getUnique() {
      if (this.memoizedUnique !== undefined) {
        return this.memoizedUnique;
      }

      let segments;

      if (!this.isRoot()) {
        if (this.isExplicitFolder()) {
          segments = this.getSegments();

          if (this.isExplicitRelative()) {
            segments = segments.slice(1);
          }
        } else if (this.isExplicitRelative()) {
          segments = this.getRawSegments().slice(1);
        }
      }

      if (segments === undefined) {
        return this._assert();
      } else {
        const path = this._fork(___R$$priv$project$rome$$romejs$path$index_ts$parsePathSegments(segments), {});
        this.memoizedUnique = path;
        return path;
      }
    }

    // Support some bad string coercion. Such as serialization in CLI flags.
    toString() {
      return this.join();
    }

    join() {
      if (this.memoizedFilename !== undefined) {
        return this.memoizedFilename;
      }

      const {segments} = this;

      let filename;
      if (this.isWindows()) {
        filename = segments.join('\\');
      } else {
        filename = segments.join('/');
      }
      this.memoizedFilename = filename;
      return filename;
    }

    // This does some weird optimizations to avoid materializing complete filenames

    // Might not be relevant... TODO benchmark this or something lol
    equal(other) {
      // Quick check if we've materalized the filename on both instances
      if (this.memoizedFilename !== undefined &&
        other.memoizedFilename !==
        undefined) {
        return this.memoizedFilename === other.memoizedFilename;
      }

      const a = this.getSegments();
      const b = other.getSegments();

      // Quick check
      if (a.length !== b.length) {
        return false;
      }

      for (let i = 0;
      i < a.length;
      i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }

      return true;
    }

    format(cwd) {
      const filename = this.join();
      const names = [];
      names.push(filename);

      // Get a path relative to HOME
      if (this.isRelativeTo(___R$project$rome$$romejs$path$index_ts$HOME_PATH)) {
        // Path starts with the home directory, so let's trim it off
        const relativeToHome = ___R$project$rome$$romejs$path$index_ts$HOME_PATH.relative(this._assert());

        // Add tilde and push it as a possible name

        // We construct this manually to get around the segment normalization which would explode ~
        names.push(
          new ___R$project$rome$$romejs$path$index_ts$RelativeFilePath(
            {
              segments: ['~', ...relativeToHome.getSegments()],
              absoluteType: 'posix',
              absoluteTarget: undefined,
            },
            {},
          ).join(),
        );
      }

      // Get a path relative to the cwd
      if (cwd !== undefined) {
        names.push(cwd.relative(filename).join());
      }

      // Get the shortest name
      const human = names.sort((a, b) => a.length - b.length)[0];
      if (human === '') {
        return './';
      } else {
        return human;
      }
    }

    append(raw) {
      // Check if we have a memoized instance
      if (typeof raw === 'string') {
        const cached = this.memoizedChildren.get(raw);
        if (cached !== undefined) {
          return cached;
        }
      }

      const items = Array.isArray(raw) ? raw : [raw];

      if (items.length === 0) {
        return this._assert();
      }

      let segments = this.getSegments();

      for (const item of items) {
        segments = segments.concat(___R$$priv$project$rome$$romejs$path$index_ts$toFilePath(item).getSegments());
      }

      const parsed = ___R$$priv$project$rome$$romejs$path$index_ts$parsePathSegments(segments);
      const child = this._fork(parsed, {});

      // Set memoized child if possible
      if (typeof raw === 'string') {
        this.memoizedChildren.set(raw, child);
      }

      return child;
    }
  }

  class ___R$project$rome$$romejs$path$index_ts$RelativeFilePath extends ___R$$priv$project$rome$$romejs$path$index_ts$BaseFilePath {
    constructor(...args) {
      super(
        ...args,
      );
      this.type =
        'relative';
    }

    _assert() {
      return this;
    }

    _fork(parsed, opts) {
      return new ___R$project$rome$$romejs$path$index_ts$RelativeFilePath(parsed, opts);
    }

    assertRelative() {
      return this;
    }
  }

  class ___R$project$rome$$romejs$path$index_ts$AbsoluteFilePath extends ___R$$priv$project$rome$$romejs$path$index_ts$BaseFilePath {
    constructor(...args) {
      super(
        ...args,
      );
      this.type =
        'absolute';
    }

    _assert() {
      return this;
    }

    _fork(parsed, opts) {
      return new ___R$project$rome$$romejs$path$index_ts$AbsoluteFilePath(parsed, opts);
    }

    assertAbsolute() {
      return this;
    }

    getChain() {
      if (this.chain !== undefined) {
        return this.chain;
      }

      const paths = [];
      this.chain = paths;

      // We use getParent here so we can reuse as much memoized information as possible
      let target = this;
      while (true) {
        paths.push(target);
        if (target.isRoot()) {
          break;
        } else {
          target = target.getParent();
        }
      }

      return paths;
    }

    resolveMaybeUrl(otherRaw) {
      const other = ___R$$priv$project$rome$$romejs$path$index_ts$toFilePath(otherRaw);
      if (other.isURL()) {
        return other.assertURL();
      } else {
        return this.resolve(other);
      }
    }

    resolve(otherRaw) {
      const other = ___R$$priv$project$rome$$romejs$path$index_ts$toFilePath(otherRaw);
      if (other.isAbsolute()) {
        return other.assertAbsolute();
      }

      return (
        new ___R$project$rome$$romejs$path$index_ts$AbsoluteFilePath(
          ___R$$priv$project$rome$$romejs$path$index_ts$parsePathSegments(
            [
              ...this.getSegments(),
              ...other.getSegments(),
            ],
          ),
          {},
        )
      );
    }

    relative(otherRaw) {
      const other = this.resolve(___R$$priv$project$rome$$romejs$path$index_ts$toFilePath(otherRaw));

      if (other.equal(this)) {
        return ___R$project$rome$$romejs$path$index_ts$createRelativeFilePath('.');
      }

      const absolute = this.getSegments().slice();
      const relative = other.getSegments().slice();

      // Impossible to relativize two absolute paths with different roots
      if (absolute[0] !== relative[0]) {
        return other;
      }

      // Remove common starting segments
      while (absolute[0] === relative[0]) {
        absolute.shift();
        relative.shift();
      }

      let finalSegments = [];
      for (let i = 0;
      i < absolute.length;
      i++) {
        finalSegments.push('..');
      }
      finalSegments = finalSegments.concat(relative);

      return ___R$$priv$project$rome$$romejs$path$index_ts$createUnknownFilePathFromSegments(___R$$priv$project$rome$$romejs$path$index_ts$parsePathSegments(finalSegments));
    }
  }

  class ___R$project$rome$$romejs$path$index_ts$URLFilePath extends ___R$$priv$project$rome$$romejs$path$index_ts$BaseFilePath {
    constructor(...args) {
      super(
        ...args,
      );
      this.type =
        'url';
    }

    _assert() {
      return this;
    }

    _fork(parsed, opts) {
      return new ___R$project$rome$$romejs$path$index_ts$URLFilePath(parsed, opts);
    }

    assertURL() {
      return this;
    }

    isURL() {
      return true;
    }

    getDomain() {
      return this.segments[2];
    }

    getProtocol() {
      const {absoluteTarget} = this;
      if (absoluteTarget === undefined) {
        throw new Error('Expected a URLFilePath to always have an absoluteTarget');
      }
      return absoluteTarget;
    }

    resolve(path) {
      if (path.isURL()) {
        return path.assertURL();
      } else if (path.isAbsolute()) {
        // Get the segments that include the protocol and domain
        const domainSegments = this.getSegments().slice(0, 3);
        const finalSegments = [...domainSegments, ...path.getSegments()];
        return new ___R$project$rome$$romejs$path$index_ts$URLFilePath(___R$$priv$project$rome$$romejs$path$index_ts$parsePathSegments(finalSegments), {});
      } else {
        return this.append(path);
      }
    }
  }

  const ___R$project$rome$$romejs$path$index_ts$HOME_PATH = ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(___R$$priv$project$rome$$romejs$path$index_ts$os.userInfo().homedir);
  const ___R$project$rome$$romejs$path$index_ts$TEMP_PATH = ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(___R$$priv$project$rome$$romejs$path$index_ts$os.tmpdir());
  const ___R$project$rome$$romejs$path$index_ts$CWD_PATH = ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(process.cwd());

  function ___R$$priv$project$rome$$romejs$path$index_ts$getExtension(basename) {
    const match = basename.match(/\.(.*?)$/);
    if (match == null) {
      return '';
    } else {
      return match[0];
    }
  }

  function ___R$$priv$project$rome$$romejs$path$index_ts$isWindowsDrive(first) {
    return first.length === 2 && first[1] === ':' && /[A-Z]/i.test(first[0]);
  }

  function ___R$$priv$project$rome$$romejs$path$index_ts$parsePathSegments(segments) {
    if (segments.length === 0) {
      throw new Error('Cannot construct a FilePath with zero segments');
    }

    let absoluteType = 'posix';
    let absoluteTarget;
    let firstSeg = segments[0];

    // Detect URL
    if (!___R$$priv$project$rome$$romejs$path$index_ts$isWindowsDrive(firstSeg) && firstSeg[firstSeg.length - 1] === ':' &&
      segments[1] === '') {
      absoluteTarget = firstSeg.slice(0, -1);

      switch (absoluteTarget) {
        case 'file':
          return ___R$$priv$project$rome$$romejs$path$index_ts$parsePathSegments(segments.slice(2));

        default:
          const absoluteSegments = segments.slice(0, 3);
          return (
            {
              segments: ___R$$priv$project$rome$$romejs$path$index_ts$normalizeSegments(
                segments,
                absoluteSegments.length,
                absoluteSegments,
              ),
              absoluteType: 'url',
              absoluteTarget,
            }
          );
      }
    }

    // Explode home directory
    if (firstSeg === '~') {
      segments = [...___R$project$rome$$romejs$path$index_ts$HOME_PATH.getSegments()];
      firstSeg = segments[0];
    }

    let segmentOffset = 0;

    // We first extract the "absolute" portion of a path, this includes any Windows drive letters, UNC hostnames etc
    const absoluteSegments = [];
    if (firstSeg === '') {
      // POSIX path
      absoluteSegments.push('');
      absoluteTarget = 'posix';
      segmentOffset++;

      // Windows UNC
      if (segments[1] === '' && segments.length >= 3 && segments[2] !== '') {
        const name = segments[2];
        segmentOffset += 2;
        absoluteSegments.push('');
        absoluteSegments.push(name);
        absoluteType = 'windows-unc';
        absoluteTarget = 'unc:' +
        name;
      }
    } else if (___R$$priv$project$rome$$romejs$path$index_ts$isWindowsDrive(firstSeg)) {
      const drive = firstSeg.toUpperCase();
      absoluteSegments.push(drive);
      absoluteType = 'windows-drive';
      absoluteTarget = 'drive:' +
      drive;
      segmentOffset++;
    }

    const pathSegments = ___R$$priv$project$rome$$romejs$path$index_ts$normalizeSegments(
      segments,
      segmentOffset,
      absoluteSegments,
    );
    return (
      {
        segments: pathSegments,
        absoluteType,
        absoluteTarget,
      }
    );
  }

  function ___R$$priv$project$rome$$romejs$path$index_ts$normalizeSegments(
    segments,
    offset,
    absoluteSegments,
  ) {
    const relativeSegments = [];
    for (let i = offset;
    i < segments.length;
    i++) {
      let seg = segments[i];

      // Only allow a dot part in the first position, otherwise it's a noop
      if (seg === '.' &&
        (segments[1] === '..' || i > 0 ||
        absoluteSegments.length > 0)) {
        continue;
      }

      // Ignore empty segments
      if (seg === '') {
        continue;
      }

      // Remove the previous segment, as long as it's not also ..
      if (seg === '..' && relativeSegments.length > 0 &&
        relativeSegments[relativeSegments.length - 1] !== '..') {
        relativeSegments.pop();
        continue;
      }

      relativeSegments.push(seg);
    }

    const finalSegments = [...absoluteSegments, ...relativeSegments];

    // Retain explicit folder
    if (segments[segments.length - 1] === '' &&
      finalSegments[finalSegments.length - 1] !== '' &&
      relativeSegments.length !== 0) {
      finalSegments.push('');
    }

    return finalSegments;
  }

  function ___R$$priv$project$rome$$romejs$path$index_ts$createUnknownFilePathFromSegments(parsed) {
    const path = new ___R$$priv$project$rome$$romejs$path$index_ts$BaseFilePath(parsed, {});

    if (path.isAbsolute()) {
      return path.assertAbsolute();
    } else {
      return path.assertRelative();
    }
  }

  function ___R$project$rome$$romejs$path$index_ts$createFilePathFromSegments(
    segments,
  ) {
    const parsed = ___R$$priv$project$rome$$romejs$path$index_ts$parsePathSegments(segments);
    return ___R$$priv$project$rome$$romejs$path$index_ts$createUnknownFilePathFromSegments(parsed);
  }

  function ___R$project$rome$$romejs$path$index_ts$toJoinedFilePath(filename) {
    if (typeof filename === 'string') {
      return filename;
    } else {
      return ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(filename).join();
    }
  }

  function ___R$project$rome$$romejs$path$index_ts$createRelativeFilePath(filename) {
    return ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(filename).assertRelative();
  }

  function ___R$project$rome$$romejs$path$index_ts$createURLFilePath(filename) {
    return ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(filename).assertURL();
  }

  function ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(filename) {
    return ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(filename).assertAbsolute();
  }

  function ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(filename) {
    // Allows using the create methods above to be used in places where strings are more ergonomic (eg. in third-party code)
    if (filename instanceof ___R$$priv$project$rome$$romejs$path$index_ts$BaseFilePath) {
      return filename;
    }

    // Might be better to do a manual loop to detect escaped slashes or some other weirdness
    const segments = filename.split(/[\\\/]/g);
    const parsed = ___R$$priv$project$rome$$romejs$path$index_ts$parsePathSegments(segments);
    return ___R$$priv$project$rome$$romejs$path$index_ts$createUnknownFilePathFromSegments(parsed);
  }

  function ___R$project$rome$$romejs$path$index_ts$maybeCreateURLFilePath(
    filename,
  ) {
    if (filename !== undefined) {
      return ___R$project$rome$$romejs$path$index_ts$createURLFilePath(filename);
    }
  }

  function ___R$project$rome$$romejs$path$index_ts$maybeCreateRelativeFilePath(
    filename,
  ) {
    if (filename !== undefined) {
      return ___R$project$rome$$romejs$path$index_ts$createRelativeFilePath(filename);
    }
  }

  function ___R$project$rome$$romejs$path$index_ts$maybeCreateAbsoluteFilePath(
    filename,
  ) {
    if (filename !== undefined) {
      return ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(filename);
    }
  }

  function ___R$project$rome$$romejs$path$index_ts$maybeCreateUnknownFilePath(
    filename,
  ) {
    if (filename !== undefined) {
      return ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(filename);
    }
  }

  // project-rome/@romejs/parser-core/index.ts
function ___R$project$rome$$romejs$parser$core$index_ts$tryParseWithOptionalOffsetPosition(
    parserOpts,
    opts,
  ) {
    try {
      return opts.parse(parserOpts);
    } catch (err) {
      const diagnostics = ___R$project$rome$$romejs$diagnostics$errors_ts$getDiagnosticsFromError(err);
      if (diagnostics === undefined) {
        throw err;
      } else {
        opts.parse(
          Object.assign(
            {
            },
            parserOpts,
            {
              offsetPosition: opts.getOffsetPosition(),
            },
          ),
        );
        throw new Error('Expected error');
      }
    }
  }

  const ___R$$priv$project$rome$$romejs$parser$core$index_ts$SOF_TOKEN = {
    type: 'SOF',
    start: ___R$project$rome$$romejs$ob1$index_ts$number0,
    end: ___R$project$rome$$romejs$ob1$index_ts$number0,
  };

  class ___R$project$rome$$romejs$parser$core$index_ts$ParserCore {
    constructor(opts, diagnosticCategory, initialState) {
      const {path, mtime, input, offsetPosition} = opts;

      // Input information
      this.path = path === undefined ? undefined : ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(path);
      this.filename = this.path === undefined ? undefined : this.path.join();
      this.mtime = mtime;
      this.input = input === undefined ? '' : input;
      this.length = ___R$project$rome$$romejs$ob1$index_ts$coerce0(this.input.length);

      this.eofToken =
        {
          type: 'EOF',
          start: ___R$project$rome$$romejs$ob1$index_ts$coerce0(this.input.length),
          end: ___R$project$rome$$romejs$ob1$index_ts$coerce0(this.input.length),
        };

      // Parser/tokenizer state
      this.offsetPosition = offsetPosition;
      this.diagnosticCategory = diagnosticCategory;
      this.tokenizing = false;
      this.currLine = offsetPosition === undefined ? ___R$project$rome$$romejs$ob1$index_ts$number1 : offsetPosition.line;
      this.currColumn =
        offsetPosition === undefined
          ? ___R$project$rome$$romejs$ob1$index_ts$number0 : offsetPosition.column;
      this.offsetIndex =
        offsetPosition === undefined
          ? ___R$project$rome$$romejs$ob1$index_ts$number0 : offsetPosition.index;
      this.startLine = this.currLine;
      this.startColumn = this.currColumn;
      this.nextTokenIndex = ___R$project$rome$$romejs$ob1$index_ts$number0;
      this.currentToken = ___R$$priv$project$rome$$romejs$parser$core$index_ts$SOF_TOKEN;
      this.prevToken = ___R$$priv$project$rome$$romejs$parser$core$index_ts$SOF_TOKEN;
      this.state = initialState;
      this.ignoreWhitespaceTokens = false;

      this.latestPosition =
        {
          index: ___R$project$rome$$romejs$ob1$index_ts$number0, // TODO this.offsetIndex
          line: this.currLine,
          column: this.currColumn,
        };
      this.cachedPositions = new Map();
    }

    getPathAssert() {
      const {path} = this;
      if (path === undefined) {
        throw new Error('Path expected but none was passed to this Parser');
      } else {
        return path;
      }
    }

    getFilenameAssert() {
      const {filename} = this;
      if (filename === undefined) {
        throw new Error('Filename expected but none was passed to this Parser');
      } else {
        return filename;
      }
    }

    // Run the tokenizer over all tokens
    tokenizeAll() {
      const tokens = [];
      try {
        while (!this.matchToken('EOF')) {
          tokens.push(this.getToken());
          this.nextToken();
        }
      } catch (err) {
        const diagnostics = ___R$project$rome$$romejs$diagnostics$errors_ts$getDiagnosticsFromError(err);
        if (diagnostics === undefined) {
          throw err;
        } else {
          tokens.push(
            {
              type: 'Invalid',
              start: this.nextTokenIndex,
              end: this.length,
            },
          );
        }
      }
      return tokens;
    }

    // Tokenize method that must be implemented by subclasses
    tokenize(index, input) {
      throw new Error('Unimplemented');
    }

    // Alternate tokenize method to allow that allows the use of state
    tokenizeWithState(
      index,
      input,
      state,
    ) {
      const token = this.tokenize(index, input);
      if (token !== undefined) {
        return {token, state};
      }
    }

    _tokenizeWithState(
      index,
      input,
      state,
    ) {
      if (this.ignoreWhitespaceTokens) {
        switch (input[___R$project$rome$$romejs$ob1$index_ts$get0(index)]) {
          case ' ':
          case '\t':
          case '\r':
          case '\n':
            return this.lookahead(___R$project$rome$$romejs$ob1$index_ts$inc(index));
        }
      }

      return this.tokenizeWithState(index, input, state);
    }

    // Get the current token
    getToken() {
      const {currentToken} = this;
      if (currentToken === ___R$$priv$project$rome$$romejs$parser$core$index_ts$SOF_TOKEN) {
        return this.nextToken();
      } else {
        return currentToken;
      }
    }

    getPrevToken() {
      return this.prevToken;
    }

    save() {
      return (
        {
          nextTokenIndex: this.nextTokenIndex,
          currentToken: this.currentToken,
          prevToken: this.prevToken,
          state: this.state,
        }
      );
    }

    restore(snapshot) {
      this.nextTokenIndex = snapshot.nextTokenIndex;
      this.currentToken = snapshot.currentToken;
      this.prevToken = snapshot.prevToken;
      this.state = snapshot.state;
    }

    // Advance to the next token, returning the new one
    nextToken() {
      if (this.isEOF(this.nextTokenIndex)) {
        this.currentToken = this.eofToken;
        return this.eofToken;
      }

      if (this.tokenizing) {
        throw new Error('Can\'t call nextToken while tokenizing');
      }

      const prevToken = this.currentToken;
      const {token: nextToken, state} = this.lookahead();

      if (nextToken.end === prevToken.end) {
        throw (
          new Error(
            'tokenize() returned a token with the same position as the last - Previous token: ' +
            JSON.stringify(
              prevToken,
            ) +
            '; Next token: ' +
            JSON.stringify(nextToken) +
            '; Input: ' +
            this.input.slice(
              0,
              100,
            ),
          )
        );
      }

      const {line, column} = this.getPositionFromIndex(nextToken.start);
      this.currLine = line;
      this.currColumn = column;

      this.nextTokenIndex = nextToken.end;
      this.prevToken = prevToken;
      this.currentToken = nextToken;
      this.state = state;
      return nextToken;
    }

    // Get the position of the current token
    getPosition() {
      const index = this.currentToken.start;

      const cached = this.cachedPositions.get(index);
      if (cached !== undefined) {
        return cached;
      }

      const pos = {
        index: this.addOffset(index),
        line: this.currLine,
        column: this.currColumn,
      };
      this.cachedPositions.set(index, pos);
      return pos;
    }

    // Get the end position of the current token
    getLastEndPosition() {
      return this.getPositionFromIndex(this.prevToken.end);
    }

    // Return the token that's after this current token without advancing to it
    lookaheadToken(index) {
      return this.lookahead(index).token;
    }

    // Return the token and state that's after the current token without advancing to it
    lookahead(
      index = this.nextTokenIndex,
    ) {
      if (this.isEOF(index)) {
        return {token: this.eofToken, state: this.state};
      }

      // Set the next token index, in the case of a lookahead we'll set it back later
      const prevNextTokenIndex = this.nextTokenIndex;
      this.nextTokenIndex = index;

      // Indicate that we're currently tokenizing to catch some weird recursive tokenizing errors
      const wasTokenizing = this.tokenizing;
      this.tokenizing = true;

      // Tokenize and do some validation
      const nextToken = this._tokenizeWithState(index, this.input, this.state);
      if (nextToken === undefined) {
        throw (
          this.unexpected(
            {
              start: this.getPositionFromIndex(index),
            },
          )
        );
      }

      // Reset to old values
      this.tokenizing = wasTokenizing;
      this.nextTokenIndex = prevNextTokenIndex;

      return nextToken;
    }

    addOffset(index) {
      return ___R$project$rome$$romejs$ob1$index_ts$add(index, this.offsetIndex);
    }

    removeOffset(index) {
      return ___R$project$rome$$romejs$ob1$index_ts$sub(index, this.offsetIndex);
    }

    getPositionFromIndex(index) {
      const cached = this.cachedPositions.get(index);
      if (cached !== undefined) {
        return cached;
      }

      let line = ___R$project$rome$$romejs$ob1$index_ts$number1;
      let column = ___R$project$rome$$romejs$ob1$index_ts$number0;
      let indexSearchOffset = 0;

      const indexWithOffset = this.addOffset(index);

      // Reuse existing line information if possible
      const {latestPosition} = this;
      const currPosition = this.getPosition();
      if (currPosition.index > latestPosition.index &&
        currPosition.index <
        indexWithOffset) {
        line = currPosition.line;
        column = currPosition.column;
        indexSearchOffset = ___R$project$rome$$romejs$ob1$index_ts$get0(this.removeOffset(currPosition.index));
      } else if (latestPosition.index < indexWithOffset) {
        line = latestPosition.line;
        column = latestPosition.column;
        indexSearchOffset = ___R$project$rome$$romejs$ob1$index_ts$get0(this.removeOffset(latestPosition.index));
      }

      // Read the rest of the input until we hit the index
      for (let i = indexSearchOffset;
      i < ___R$project$rome$$romejs$ob1$index_ts$get0(index);
      i++) {
        const char = this.input[i];

        if (char === '\n') {
          line = ___R$project$rome$$romejs$ob1$index_ts$inc(line);
          column = ___R$project$rome$$romejs$ob1$index_ts$number0;
        } else {
          column = ___R$project$rome$$romejs$ob1$index_ts$inc(column);
        }
      }

      const pos = {
        index: indexWithOffset,
        line,
        column,
      };

      if (latestPosition === undefined || pos.index > latestPosition.index) {
        this.latestPosition = pos;
      }

      this.cachedPositions.set(index, pos);
      return pos;
    }

    createDiagnostic(opts = {}) {
      const {currentToken} = this;
      let {message, start, end, loc, token} = opts;

      // Allow passing in a TokenBase
      if (token !== undefined) {
        start = this.getPositionFromIndex(token.start);
        end = this.getPositionFromIndex(token.end);
      }

      // Allow passing in a SourceLocation as an easy way to point to a particular node
      if (loc !== undefined) {
        start = loc.start;
        end = loc.end;
      }

      // When both properties are omitted then we will default to the current token range
      if (start === undefined && end === undefined) {
        end = this.getLastEndPosition();
      }

      if (start === undefined) {
        start = this.getPosition();
      }

      if (end === undefined) {
        end = start;
      }

      // Sometimes the end position may be empty as it hasn't been filled yet
      if (end.index === ___R$project$rome$$romejs$ob1$index_ts$number0) {
        end = start;
      }

      // Normalize message, we need to be defensive here because it could have been called while tokenizing the first token
      if (message === undefined) {
        if (currentToken !== undefined && start !== undefined &&
          start.index ===
          currentToken.start) {
          message = 'Unexpected ' +
          currentToken.type;
        } else {
          if (this.isEOF(start.index)) {
            message = 'Unexpected end of file';
          } else {
            const char = this.input[___R$project$rome$$romejs$ob1$index_ts$get0(start.index)];
            message =
              'Unexpected character <emphasis>' +
              ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(char) +
              '</emphasis>';
          }
        }
      }

      let errMessage = message +
      ' (' +
      start.line +
      ':' +
      start.column +
      ')';
      if (this.path !== undefined) {
        errMessage = this.path +
        ': ' +
        errMessage +
        ' Input: ' +
        this.input;
      }

      return (
        {
          message,
          advice: opts.advice,
          category: this.diagnosticCategory,
          sourceText: this.path === undefined ? this.input : undefined,
          mtime: this.mtime,
          start,
          end,
          filename: this.filename,
        }
      );
    }

    // Return an error to indicate a parser error, this must be thrown at the callsite for refinement
    unexpected(opts = {}) {
      throw ___R$project$rome$$romejs$diagnostics$errors_ts$createSingleDiagnosticError(this.createDiagnostic(opts));
    }

    //# Token utility methods
    assertNoSpace() {
      if (this.currentToken.start !== this.prevToken.end) {
        throw (
          this.unexpected(
            {
              message: 'Expected no space between',
            },
          )
        );
      }
    }

    // If the current token is the specified type then return the next token, otherwise return null
    eatToken(type) {
      if (this.matchToken(type)) {
        return this.nextToken();
      }
    }

    didEatToken(type) {
      return this.eatToken(type) !== undefined;
    }

    // Check if we're at the end of the input
    isEOF(index) {
      return ___R$project$rome$$romejs$ob1$index_ts$get0(index) >= this.input.length;
    }

    // Check if the current token matches the input type
    matchToken(type) {
      return this.getToken().type === type;
    }

    // Get the current token and assert that it's of the specified type, the token stream will also be advanced
    expectToken(type, message) {
      const token = this.getToken();
      if (token.type === type) {
        this.nextToken();
        // @ts-ignore
        return token;
      } else {
        throw (
          this.unexpected(
            {
              message: message === undefined
                ? 'Expected token ' +
                type +
                ' but got ' +
                token.type : message,
            },
          )
        );
      }
    }

    // Read from the input starting at the specified index, until the callback returns false
    readInputFrom(index, callback) {
      const {input} = this;
      let value = '';

      while (true) {
        if (___R$project$rome$$romejs$ob1$index_ts$get0(index) >= input.length) {
          return [value, index, true];
        }

        if (callback === undefined || callback(input[___R$project$rome$$romejs$ob1$index_ts$get0(index)], index, input)) {
          value += input[___R$project$rome$$romejs$ob1$index_ts$get0(index)];
          index = ___R$project$rome$$romejs$ob1$index_ts$inc(index);
        } else {
          break;
        }
      }

      return [value, index, false];
    }

    // Get the string between the specified range
    getRawInput(start, end) {
      return this.input.slice(___R$project$rome$$romejs$ob1$index_ts$get0(start), ___R$project$rome$$romejs$ob1$index_ts$get0(end));
    }

    //# Utility methods to make it easy to construct nodes or tokens
    getLoc(node) {
      if (node === undefined || node.loc === undefined) {
        throw new Error('Tried to fetch node loc start but none found');
      } else {
        return node.loc;
      }
    }

    finishToken(type, end = ___R$project$rome$$romejs$ob1$index_ts$inc(this.nextTokenIndex)) {
      return (
        {
          type,
          start: this.nextTokenIndex,
          end,
        }
      );
    }

    finishValueToken(type, value, end = ___R$project$rome$$romejs$ob1$index_ts$inc(this.nextTokenIndex)) {
      return (
        {
          type,
          value,
          start: this.nextTokenIndex,
          end,
        }
      );
    }

    finishComplexToken(type, data, end = ___R$project$rome$$romejs$ob1$index_ts$inc(this.nextTokenIndex)) {
      return (
        Object.assign(
          {
            type,
          },
          data,
          {
            start: this.nextTokenIndex,
            end,
          },
        )
      );
    }

    finishLocFromToken(token) {
      return (
        this.finishLocAt(
          this.getPositionFromIndex(token.start),
          this.getPositionFromIndex(token.end),
        )
      );
    }

    finishLoc(start) {
      return this.finishLocAt(start, this.getLastEndPosition());
    }

    finishLocAt(start, end) {
      return (
        {
          filename: this.filename,
          start,
          end,
        }
      );
    }

    finalize() {
      if (!this.eatToken('EOF')) {
        throw (
          this.unexpected(
            {
              message: 'Expected end of file',
            },
          )
        );
      }
    }
  }

  class ___R$project$rome$$romejs$parser$core$index_ts$ParserWithRequiredPath extends ___R$project$rome$$romejs$parser$core$index_ts$ParserCore {
    constructor(opts, diagnosticCategory, initialState) {
      super(opts, diagnosticCategory, initialState);
      this.filename = this.getFilenameAssert();
      this.path = this.getPathAssert();
    }
  }

  function ___R$project$rome$$romejs$parser$core$index_ts$isDigit(char) {
    return char !== undefined && /[0-9]/.test(char);
  }

  function ___R$project$rome$$romejs$parser$core$index_ts$isAlpha(char) {
    return char !== undefined && /[A-Za-z]/.test(char);
  }

  function ___R$project$rome$$romejs$parser$core$index_ts$isHexDigit(char) {
    return char !== undefined && /[0-9A-Fa-f]/.test(char);
  }

  function ___R$project$rome$$romejs$parser$core$index_ts$isESIdentifierChar(char) {
    return char !== undefined && /[A-F0-9a-z_$]/.test(char);
  }

  function ___R$project$rome$$romejs$parser$core$index_ts$isESIdentifierStart(char) {
    return char !== undefined && /[A-Fa-z_$]/.test(char);
  }

  function ___R$project$rome$$romejs$parser$core$index_ts$isEscaped(index, input) {
    const prevChar = input[___R$project$rome$$romejs$ob1$index_ts$get0(index) - 1];
    const prevPrevChar = input[___R$project$rome$$romejs$ob1$index_ts$get0(index) - 2];
    const isEscaped = prevChar === '\\' && prevPrevChar !== '\\';
    return isEscaped;
  }

  function ___R$project$rome$$romejs$parser$core$index_ts$readUntilLineBreak(char) {
    return char !== '\n';
  }

  function ___R$project$rome$$romejs$parser$core$index_ts$createParser(
    callback,
  ) {
    let klass;

    return (
      (...args) => {
        if (klass === undefined) {
          klass = callback(___R$project$rome$$romejs$parser$core$index_ts$ParserCore, ___R$project$rome$$romejs$parser$core$index_ts$ParserWithRequiredPath);
        }

        return new klass(...args);
      }
    );
  }

  function ___R$project$rome$$romejs$parser$core$index_ts$extractSourceLocationRangeFromNodes(
    nodes,
  ) {
    if (nodes.length === 0) {
      return undefined;
    }

    let filename = undefined;
    let start = undefined;
    let end = undefined;

    for (const node of nodes) {
      const {loc} = node;
      if (loc === undefined) {
        continue;
      }

      if (start === undefined || loc.start.index < start.index) {
        start = loc.start;
      }

      if (end === undefined || loc.end.index > end.index) {
        end = loc.end;
      }

      if (filename === undefined) {
        filename = loc.filename;
      } else if (filename !== loc.filename) {
        throw (
          new Error(
            'Mixed filenames in node, expected ' +
            filename +
            ' but got ' +
            loc.filename,
          )
        );
      }
    }

    if (start === undefined || end === undefined) {
      return undefined;
    }

    return (
      {
        filename,
        start,
        end,
      }
    );
  }

  // project-rome/@romejs/string-markup/parse.ts
const ___R$project$rome$$romejs$string$markup$parse_ts = {
    isTagChar: ___R$project$rome$$romejs$string$markup$parse_ts$isTagChar,
    parseMarkup: ___R$project$rome$$romejs$string$markup$parse_ts$parseMarkup,
  };
  const ___R$$priv$project$rome$$romejs$string$markup$parse_ts$globalAttributes = ['emphasis', 'dim'];

  const ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags = new Map();
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('emphasis', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('number', ['approx']);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('hyperlink', ['target']);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('filelink', ['target', 'column', 'line']);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('inverse', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('dim', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('filesize', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('duration', ['approx']);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('italic', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('underline', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('strike', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('black', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('brightBlack', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('red', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('brightRed', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('green', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('brightGreen', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('yellow', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('brightYellow', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('blue', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('brightBlue', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('magenta', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('brightMagenta', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('cyan', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('brightCyan', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('white', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('brightWhite', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('bgBlack', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('bgBrightBlack', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('bgRed', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('bgBrightRed', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('bgGreen', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('bgBrightGreen', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('bgYellow', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('bgBrightYellow', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('bgBlue', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('bgBrightBlue', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('bgMagenta', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('bgBrightMagenta', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('bgCyan', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('bgBrightCyan', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('bgWhite', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('bgBrightWhite', []);
  ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set('command', []);

  //
  function ___R$$priv$project$rome$$romejs$string$markup$parse_ts$isStringValueChar(char, index, input) {
    if (char === '"' && !___R$project$rome$$romejs$parser$core$index_ts$isEscaped(index, input)) {
      return false;
    }

    return true;
  }

  function ___R$$priv$project$rome$$romejs$string$markup$parse_ts$isTextChar(char, index, input) {
    return !___R$project$rome$$romejs$string$markup$parse_ts$isTagChar(index, input);
  }

  function ___R$project$rome$$romejs$string$markup$parse_ts$isTagChar(index, input) {
    const i = ___R$project$rome$$romejs$ob1$index_ts$get0(index);
    return (
      input[i] === '<' && !___R$project$rome$$romejs$parser$core$index_ts$isEscaped(index, input) &&
        (___R$project$rome$$romejs$parser$core$index_ts$isAlpha(input[i + 1]) || input[i + 1] === '/')
    );
  }

  const ___R$$priv$project$rome$$romejs$string$markup$parse_ts$createStringMarkupParser = ___R$project$rome$$romejs$parser$core$index_ts$createParser(
    (
      ParserCore,
    ) =>
      class StringMarkupParser extends ParserCore {
        constructor(opts) {
          super(opts, 'parse/stringMarkup', {inTagHead: false});
        }

        tokenizeWithState(
          index,
          input,
          state,
        ) {
          const escaped = ___R$project$rome$$romejs$parser$core$index_ts$isEscaped(index, input);
          const char = input[___R$project$rome$$romejs$ob1$index_ts$get0(index)];

          if (!escaped && state.inTagHead) {
            if (char === ' ') {
              return this.lookahead(___R$project$rome$$romejs$ob1$index_ts$inc(index));
            }

            if (char === '=') {
              return (
                {
                  state,
                  token: this.finishToken('Equals'),
                }
              );
            }

            if (char === '/') {
              return (
                {
                  state,
                  token: this.finishToken('Slash'),
                }
              );
            }

            if (___R$project$rome$$romejs$parser$core$index_ts$isAlpha(char)) {
              const [value, end] = this.readInputFrom(index, ___R$project$rome$$romejs$parser$core$index_ts$isAlpha);
              return (
                {
                  state,
                  token: this.finishValueToken('Word', value, end),
                }
              );
            }

            if (char === '"') {
              const [value, stringValueEnd, unclosed] = this.readInputFrom(
                ___R$project$rome$$romejs$ob1$index_ts$inc(index),
                ___R$$priv$project$rome$$romejs$string$markup$parse_ts$isStringValueChar,
              );

              if (unclosed) {
                throw (
                  this.unexpected(
                    {
                      message: 'Unclosed string',
                      start: this.getPositionFromIndex(stringValueEnd),
                    },
                  )
                );
              }

              const end = ___R$project$rome$$romejs$ob1$index_ts$add(stringValueEnd, 1);
              return (
                {
                  state,
                  token: this.finishValueToken('String', value, end),
                }
              );
            }

            if (char === '>') {
              return (
                {
                  state: {
                    inTagHead: false,
                  },
                  token: this.finishToken('Greater'),
                }
              );
            }
          }

          if (___R$project$rome$$romejs$string$markup$parse_ts$isTagChar(index, input)) {
            return (
              {
                state: {
                  inTagHead: true,
                },
                token: this.finishToken('Less'),
              }
            );
          }

          // Keep eating text until we hit a <
          const [value, end] = this.readInputFrom(index, ___R$$priv$project$rome$$romejs$string$markup$parse_ts$isTextChar);
          return (
            {
              state,
              token: {
                type: 'Text',
                value: ___R$$priv$project$rome$$romejs$string$markup$parse_ts$normalizeTextValue(value),
                start: index,
                end,
              },
            }
          );
        }

        atTagEnd() {
          return this.matchToken('Less') && this.lookahead().token.type === 'Slash';
        }

        parseTag() {
          const nameToken = this.expectToken('Word');
          const rawName = nameToken.value;

          const allowedAttributes = ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.get(rawName);
          if (allowedAttributes === undefined) {
            throw (
              this.unexpected(
                {
                  message: 'Unknown tag name <emphasis>' +
                  rawName +
                  '</emphasis>',
                  start: this.getPositionFromIndex(nameToken.start),
                },
              )
            );
          }

          // rome-suppress lint/noExplicitAny
          const tagName = (rawName);
          const attributes = new Map();
          const children = [];
          let selfClosing = false;

          // Parse attributes
          while (!this.matchToken('EOF') && !this.matchToken('Greater')) {
            const keyToken = this.getToken();

            let key;
            if (keyToken.type === 'Word') {
              key = keyToken.value;

              if (!allowedAttributes.includes(key) && !___R$$priv$project$rome$$romejs$string$markup$parse_ts$globalAttributes.includes(key)) {
                throw (
                  this.unexpected(
                    {
                      message: key +
                      ' is not a valid attribute name for <' +
                      tagName +
                      '>',
                    },
                  )
                );
              }

              this.nextToken();

              // Shorthand properties
              if (this.matchToken('Word') || this.matchToken('Slash') ||
              this.matchToken('Greater')) {
                attributes.set(key, 'true');
                continue;
              }

              this.expectToken('Equals');

              const valueToken = this.expectToken('String');
              if (valueToken.type !== 'String') {
                throw new Error('Expected String');
              }
              const value = valueToken.value;

              attributes.set(key, value);
            } else if (keyToken.type === 'Slash') {
              this.nextToken();
              selfClosing = true;
            } else {
              throw (
                this.unexpected(
                  {
                    message: 'Expected attribute name',
                  },
                )
              );
            }
          }

          this.expectToken('Greater');

          // Verify closing tag
          if (!selfClosing) {
            while ( // Build children
            !this.matchToken('EOF') && !this.atTagEnd()) {
              children.push(this.parseChild());
            }

            if (this.matchToken('EOF')) {
              throw (
                this.unexpected(
                  {
                    message: 'Unclosed ' +
                    tagName +
                    ' tag',
                  },
                )
              );
            } else {
              this.expectToken('Less');
              this.expectToken('Slash');

              const name = this.getToken();
              if (name.type === 'Word') {
                if (name.value !== tagName) {
                  throw (
                    this.unexpected(
                      {
                        message: 'Expected to close ' +
                        tagName +
                        ' but found ' +
                        name.value,
                      },
                    )
                  );
                }

                this.nextToken();
              } else {
                throw (
                  this.unexpected(
                    {
                      message: 'Expected closing tag name',
                    },
                  )
                );
              }

              this.expectToken('Greater');
            }
          }

          return (
            {
              type: 'Tag',
              attributes,
              name: tagName,
              children,
            }
          );
        }

        parseChild() {
          const token = this.getToken();
          this.nextToken();

          if (token.type === 'Text') {
            return (
              {
                type: 'Text',
                value: token.value,
              }
            );
          } else if (token.type === 'Less') {
            return this.parseTag();
          } else {
            throw (
              this.unexpected(
                {
                  message: 'Unknown child start',
                },
              )
            );
          }
        }

        parse() {
          const children = [];
          while (!this.matchToken('EOF')) {
            children.push(this.parseChild());
          }
          return children;
        }
      },
  );

  function ___R$project$rome$$romejs$string$markup$parse_ts$parseMarkup(input) {
    try {
      return ___R$$priv$project$rome$$romejs$string$markup$parse_ts$createStringMarkupParser({input}).parse();
    } catch (err) {
      throw err;
    }
  }

  function ___R$$priv$project$rome$$romejs$string$markup$parse_ts$normalizeTextValue(str) {
    return str.replace(/\\<([a-zA-Z\/])/g, '<$1');
  }

  // project-rome/@romejs/string-utils/orderBySimilarity.ts
const ___R$project$rome$$romejs$string$utils$orderBySimilarity_ts = {
    compareTwoStrings: ___R$project$rome$$romejs$string$utils$orderBySimilarity_ts$compareTwoStrings,
    orderBySimilarity: ___R$project$rome$$romejs$string$utils$orderBySimilarity_ts$orderBySimilarity,
  };
  /**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

  function ___R$$priv$project$rome$$romejs$string$utils$orderBySimilarity_ts$getMap(
    map,
    key,
    defaultValue,
  ) {
    const existing = map.get(key);

    if (existing === undefined) {
      if (defaultValue === undefined) {
        throw new Error('Key didn\'t exist and no defaultValue passed');
      }

      map.set(key, defaultValue);
      return defaultValue;
    } else {
      return existing;
    }
  }

  /**
 * Forked from the project https://github.com/aceakash/string-similarity by Akash K, licensed under ISC
 */
  function ___R$project$rome$$romejs$string$utils$orderBySimilarity_ts$compareTwoStrings(aStr, bStr) {
    const a = aStr.replace(/\s+/g, '');
    const b = bStr.replace(/\s+/g, '');

    // If both are empty strings
    if (!a.length && !b.length) {
      return 1;
    }

    // If only one is empty string
    if (!a.length || !b.length) {
      return 0;
    }

    // Identical
    if (a === b) {
      return 1;
    }

    // Both are 1-letter strings
    if (a.length === 1 && b.length === 1) {
      return 0;
    }

    // If either is a 1-letter string
    if (a.length < 2 || b.length < 2) {
      return 0;
    }

    let firstBigrams = new Map();
    for (let i = 0;
    i < a.length - 1;
    i++) {
      const bigram = a.substring(i, i + 2);

      const count = firstBigrams.has(bigram) ? ___R$$priv$project$rome$$romejs$string$utils$orderBySimilarity_ts$getMap(firstBigrams, bigram) + 1 : 1;
      if (count === undefined) {
        throw new Error('Already used has() above');
      }

      firstBigrams.set(bigram, count);
    }

    let intersectionSize = 0;
    for (let i = 0;
    i < b.length - 1;
    i++) {
      const bigram = b.substring(i, i + 2);

      const count = ___R$$priv$project$rome$$romejs$string$utils$orderBySimilarity_ts$getMap(firstBigrams, bigram, 0);
      if (count === undefined) {
        throw new Error('Already used has() above');
      }

      if (count > 0) {
        firstBigrams.set(bigram, count - 1);
        intersectionSize++;
      }
    }

    return 2 * intersectionSize / (a.length + b.length - 2);
  }

  function ___R$project$rome$$romejs$string$utils$orderBySimilarity_ts$orderBySimilarity(
    compareStr,
    targets,
    {minRating, formatItem, ignoreCase = false} = {},
  ) {
    if (targets.length === 0) {
      return [];
    }

    // Calculate the rating for each target string
    const ratings = Array.from(
      targets,
      (target) => {
        let compareTarget = target;
        if (formatItem !== undefined) {
          compareTarget = formatItem(target);
        }

        if (ignoreCase) {
          return (
            {
              target,
              rating: ___R$project$rome$$romejs$string$utils$orderBySimilarity_ts$compareTwoStrings(
                compareStr.toLowerCase(),
                compareTarget.toLowerCase(),
              ),
            }
          );
        }

        return (
          {
            target,
            rating: ___R$project$rome$$romejs$string$utils$orderBySimilarity_ts$compareTwoStrings(compareStr, compareTarget),
          }
        );
      },
    );

    // Sort ratings, with the highest at the beginning
    const sortedRatings = ratings.sort(
      (a, b) => {
        return b.rating - a.rating;
      },
    ).filter(
      (item) => minRating === undefined || item.rating >= minRating,
    );

    return sortedRatings;
  }

  // project-rome/@romejs/string-charcodes/index.ts
const ___R$project$rome$$romejs$string$charcodes$index_ts = {
    get backSpace() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$backSpace
      );
    },

    get tab() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$tab
      );
    },

    get lineFeed() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lineFeed
      );
    },

    get carriageReturn() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$carriageReturn
      );
    },

    get shiftOut() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$shiftOut
      );
    },

    get space() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$space
      );
    },

    get exclamationMark() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$exclamationMark
      );
    },

    get quotationMark() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$quotationMark
      );
    },

    get numberSign() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$numberSign
      );
    },

    get dollarSign() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$dollarSign
      );
    },

    get percentSign() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$percentSign
      );
    },

    get ampersand() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$ampersand
      );
    },

    get apostrophe() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$apostrophe
      );
    },

    get leftParenthesis() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$leftParenthesis
      );
    },

    get rightParenthesis() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$rightParenthesis
      );
    },

    get asterisk() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$asterisk
      );
    },

    get plusSign() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$plusSign
      );
    },

    get comma() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$comma
      );
    },

    get dash() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$dash
      );
    },

    get dot() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$dot
      );
    },

    get slash() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$slash
      );
    },

    get digit0() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$digit0
      );
    },

    get digit1() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$digit1
      );
    },

    get digit2() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$digit2
      );
    },

    get digit3() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$digit3
      );
    },

    get digit4() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$digit4
      );
    },

    get digit5() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$digit5
      );
    },

    get digit6() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$digit6
      );
    },

    get digit7() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$digit7
      );
    },

    get digit8() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$digit8
      );
    },

    get digit9() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$digit9
      );
    },

    get colon() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$colon
      );
    },

    get semicolon() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$semicolon
      );
    },

    get lessThan() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lessThan
      );
    },

    get equalsTo() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$equalsTo
      );
    },

    get greaterThan() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$greaterThan
      );
    },

    get questionMark() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$questionMark
      );
    },

    get atSign() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$atSign
      );
    },

    get uppercaseA() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseA
      );
    },

    get uppercaseB() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseB
      );
    },

    get uppercaseC() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseC
      );
    },

    get uppercaseD() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseD
      );
    },

    get uppercaseE() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseE
      );
    },

    get uppercaseF() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseF
      );
    },

    get uppercaseG() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseG
      );
    },

    get uppercaseH() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseH
      );
    },

    get uppercaseI() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseI
      );
    },

    get uppercaseJ() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseJ
      );
    },

    get uppercaseK() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseK
      );
    },

    get uppercaseL() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseL
      );
    },

    get uppercaseM() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseM
      );
    },

    get uppercaseN() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseN
      );
    },

    get uppercaseO() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseO
      );
    },

    get uppercaseP() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseP
      );
    },

    get uppercaseQ() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseQ
      );
    },

    get uppercaseR() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseR
      );
    },

    get uppercaseS() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseS
      );
    },

    get uppercaseT() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseT
      );
    },

    get uppercaseU() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseU
      );
    },

    get uppercaseV() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseV
      );
    },

    get uppercaseW() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseW
      );
    },

    get uppercaseX() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseX
      );
    },

    get uppercaseY() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseY
      );
    },

    get uppercaseZ() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseZ
      );
    },

    get leftSquareBracket() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$leftSquareBracket
      );
    },

    get backslash() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$backslash
      );
    },

    get rightSquareBracket() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$rightSquareBracket
      );
    },

    get caret() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$caret
      );
    },

    get underscore() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$underscore
      );
    },

    get graveAccent() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$graveAccent
      );
    },

    get lowercaseA() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseA
      );
    },

    get lowercaseB() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseB
      );
    },

    get lowercaseC() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseC
      );
    },

    get lowercaseD() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseD
      );
    },

    get lowercaseE() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseE
      );
    },

    get lowercaseF() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseF
      );
    },

    get lowercaseG() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseG
      );
    },

    get lowercaseH() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseH
      );
    },

    get lowercaseI() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseI
      );
    },

    get lowercaseJ() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseJ
      );
    },

    get lowercaseK() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseK
      );
    },

    get lowercaseL() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseL
      );
    },

    get lowercaseM() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseM
      );
    },

    get lowercaseN() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseN
      );
    },

    get lowercaseO() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseO
      );
    },

    get lowercaseP() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseP
      );
    },

    get lowercaseQ() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseQ
      );
    },

    get lowercaseR() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseR
      );
    },

    get lowercaseS() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseS
      );
    },

    get lowercaseT() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseT
      );
    },

    get lowercaseU() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseU
      );
    },

    get lowercaseV() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseV
      );
    },

    get lowercaseW() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseW
      );
    },

    get lowercaseX() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseX
      );
    },

    get lowercaseY() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseY
      );
    },

    get lowercaseZ() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseZ
      );
    },

    get leftCurlyBrace() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$leftCurlyBrace
      );
    },

    get verticalBar() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$verticalBar
      );
    },

    get rightCurlyBrace() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$rightCurlyBrace
      );
    },

    get tilde() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$tilde
      );
    },

    get nonBreakingSpace() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$nonBreakingSpace
      );
    },

    get oghamSpaceMark() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$oghamSpaceMark
      );
    },

    get lineSeparator() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$lineSeparator
      );
    },

    get paragraphSeparator() {
      return (
        ___R$project$rome$$romejs$string$charcodes$index_ts$paragraphSeparator
      );
    },

    isDigit: ___R$project$rome$$romejs$string$charcodes$index_ts$isDigit,
  };
  const ___R$project$rome$$romejs$string$charcodes$index_ts$backSpace = 8;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$tab = 9;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lineFeed = 10;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$carriageReturn = 13;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$shiftOut = 14;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$space = 32;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$exclamationMark = 33;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$quotationMark = 34;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$numberSign = 35;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$dollarSign = 36;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$percentSign = 37;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$ampersand = 38;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$apostrophe = 39;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$leftParenthesis = 40;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$rightParenthesis = 41;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$asterisk = 42;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$plusSign = 43;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$comma = 44;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$dash = 45;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$dot = 46;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$slash = 47;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$digit0 = 48;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$digit1 = 49;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$digit2 = 50;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$digit3 = 51;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$digit4 = 52;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$digit5 = 53;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$digit6 = 54;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$digit7 = 55;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$digit8 = 56;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$digit9 = 57;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$colon = 58;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$semicolon = 59;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lessThan = 60;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$equalsTo = 61;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$greaterThan = 62;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$questionMark = 63;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$atSign = 64;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseA = 65;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseB = 66;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseC = 67;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseD = 68;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseE = 69;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseF = 70;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseG = 71;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseH = 72;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseI = 73;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseJ = 74;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseK = 75;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseL = 76;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseM = 77;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseN = 78;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseO = 79;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseP = 80;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseQ = 81;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseR = 82;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseS = 83;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseT = 84;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseU = 85;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseV = 86;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseW = 87;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseX = 88;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseY = 89;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseZ = 90;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$leftSquareBracket = 91;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$backslash = 92;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$rightSquareBracket = 93;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$caret = 94;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$underscore = 95;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$graveAccent = 96;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseA = 97;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseB = 98;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseC = 99;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseD = 100;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseE = 101;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseF = 102;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseG = 103;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseH = 104;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseI = 105;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseJ = 106;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseK = 107;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseL = 108;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseM = 109;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseN = 110;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseO = 111;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseP = 112;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseQ = 113;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseR = 114;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseS = 115;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseT = 116;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseU = 117;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseV = 118;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseW = 119;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseX = 120;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseY = 121;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseZ = 122;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$leftCurlyBrace = 123;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$verticalBar = 124;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$rightCurlyBrace = 125;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$tilde = 126;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$nonBreakingSpace = 160;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$oghamSpaceMark = 5760;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$lineSeparator = 8232;
  const ___R$project$rome$$romejs$string$charcodes$index_ts$paragraphSeparator = 8233;

  function ___R$project$rome$$romejs$string$charcodes$index_ts$isDigit(code) {
    return code >= ___R$project$rome$$romejs$string$charcodes$index_ts$digit0 && code <= ___R$project$rome$$romejs$string$charcodes$index_ts$digit9;
  }

  // project-rome/@romejs/string-utils/naturalCompare.ts
const ___R$project$rome$$romejs$string$utils$naturalCompare_ts = {
    naturalCompare: ___R$project$rome$$romejs$string$utils$naturalCompare_ts$naturalCompare,
  };
  function ___R$project$rome$$romejs$string$utils$naturalCompare_ts$naturalCompare(
    a,
    b,
    insensitive = true,
  ) {
    if (insensitive) {
      a = a.toLowerCase();
      b = b.toLowerCase();
    }

    const lengthA = a.length;
    const lengthB = b.length;

    let aIndex = 0;
    let bIndex = 0;

    while (aIndex < lengthA && bIndex < lengthB) {
      let charCodeA = a.charCodeAt(aIndex);
      let charCodeB = b.charCodeAt(bIndex);

      if (___R$project$rome$$romejs$string$charcodes$index_ts$isDigit(charCodeA)) {
        if (!___R$project$rome$$romejs$string$charcodes$index_ts$isDigit(charCodeB)) {
          return charCodeA - charCodeB;
        }

        let numStartA = aIndex;
        let numStartB = bIndex;

        while (charCodeA === 48 && ++numStartA < lengthA) {
          charCodeA = a.charCodeAt(numStartA);
        }
        while (charCodeB === 48 && ++numStartB < lengthB) {
          charCodeB = b.charCodeAt(numStartB);
        }

        let numEndA = numStartA;
        let numEndB = numStartB;

        while (numEndA < lengthA && ___R$project$rome$$romejs$string$charcodes$index_ts$isDigit(a.charCodeAt(numEndA))) {
          ++numEndA;
        }
        while (numEndB < lengthB && ___R$project$rome$$romejs$string$charcodes$index_ts$isDigit(b.charCodeAt(numEndB))) {
          ++numEndB;
        }

        let difference = numEndA - numStartA - numEndB + numStartB; // numA length - numB length
        if (difference) {
          return difference;
        }

        while (numStartA < numEndA) {
          difference = a.charCodeAt(numStartA++) - b.charCodeAt(numStartB++);
          if (difference) {
            return difference;
          }
        }

        aIndex = numEndA;
        bIndex = numEndB;
        continue;
      }

      if (charCodeA !== charCodeB) {
        return charCodeA - charCodeB;
      }

      ++aIndex;
      ++bIndex;
    }

    return lengthA - lengthB;
  }

  // project-rome/@romejs/string-utils/humanizeNumber.ts
const ___R$project$rome$$romejs$string$utils$humanizeNumber_ts = {
    humanizeNumber: ___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber,
  };
  /**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

  const ___R$$priv$project$rome$$romejs$string$utils$humanizeNumber_ts$SCIENTIFIC_NOTATION = /e/i;

  function ___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(num, sep = '_') {
    let str = String(num);

    if (num < 1000) {
      return str;
    }

    if (___R$$priv$project$rome$$romejs$string$utils$humanizeNumber_ts$SCIENTIFIC_NOTATION.test(str)) {
      return str;
    }

    const decimals = str.split('.');

    let intChars = String(decimals.shift()).split('');
    let intParts = [];

    while (intChars.length > 0) {
      const part = intChars.slice(-3).join('');
      intParts.unshift(part);

      intChars = intChars.slice(0, -3);
    }

    return [intParts.join(sep), ...decimals].join('.');
  }

  // project-rome/@romejs/string-utils/humanizeFileSize.ts
const ___R$project$rome$$romejs$string$utils$humanizeFileSize_ts = {
    humanizeFileSize: ___R$project$rome$$romejs$string$utils$humanizeFileSize_ts$humanizeFileSize,
  };
  const ___R$$priv$project$rome$$romejs$string$utils$humanizeFileSize_ts$UNITS = ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];

  function ___R$project$rome$$romejs$string$utils$humanizeFileSize_ts$humanizeFileSize(bytes) {
    const exponent = Math.min(Math.floor(Math.log10(bytes) / 3), ___R$$priv$project$rome$$romejs$string$utils$humanizeFileSize_ts$UNITS.length - 1);
    const specific = Number((bytes / Math.pow(1000, exponent)).toPrecision(3));
    const unit = ___R$$priv$project$rome$$romejs$string$utils$humanizeFileSize_ts$UNITS[exponent];
    return ___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(specific) + unit;
  }

  // project-rome/@romejs/string-utils/humanizeTime.ts
const ___R$project$rome$$romejs$string$utils$humanizeTime_ts = {
    humanizeTime: ___R$project$rome$$romejs$string$utils$humanizeTime_ts$humanizeTime,
  };
  function ___R$project$rome$$romejs$string$utils$humanizeTime_ts$humanizeTime(
    ms,
    allowMilliseconds = false,
  ) {
    const s = Math.floor(ms / 1000);
    const m = Math.floor(s / 60);
    const h = Math.floor(m / 60);

    if (h === 0 && m === 0 && s === 0) {
      if (allowMilliseconds) {
        return ms +
        'ms';
      } else {
        return (ms / 1000).toFixed(2) +
        's';
      }
    }

    let buf = '';
    if (h > 0) {
      buf += String(h) +
      'h';
    }
    if (m > 0) {
      buf += String(m % 60) +
      'm';
    }
    buf += String(s % 60) +
    's';
    return buf;
  }

  // project-rome/@romejs/string-utils/removeSuffix.ts
const ___R$project$rome$$romejs$string$utils$removeSuffix_ts = {
    removeSuffix: ___R$project$rome$$romejs$string$utils$removeSuffix_ts$removeSuffix,
  };
  function ___R$project$rome$$romejs$string$utils$removeSuffix_ts$removeSuffix(value, suffix) {
    if (value.endsWith(suffix)) {
      return value.slice(0, -suffix.length);
    } else {
      return value;
    }
  }

  // project-rome/@romejs/string-utils/removePrefix.ts
const ___R$project$rome$$romejs$string$utils$removePrefix_ts = {
    removePrefix: ___R$project$rome$$romejs$string$utils$removePrefix_ts$removePrefix,
  };
  function ___R$project$rome$$romejs$string$utils$removePrefix_ts$removePrefix(value, prefix) {
    if (value.startsWith(prefix)) {
      return value.slice(prefix.length);
    } else {
      return value;
    }
  }

  // project-rome/@romejs/string-utils/findClosestStringMatch.ts
const ___R$project$rome$$romejs$string$utils$findClosestStringMatch_ts = {
    findClosestStringMatch: ___R$project$rome$$romejs$string$utils$findClosestStringMatch_ts$findClosestStringMatch,
  };
  function ___R$project$rome$$romejs$string$utils$findClosestStringMatch_ts$findClosestStringMatch(
    name,
    matches,
    minRating = 0.8,
  ) {
    if (matches.length === 0) {
      return undefined;
    }

    if (matches.length === 1) {
      return matches[0];
    }

    const ratings = ___R$project$rome$$romejs$string$utils$orderBySimilarity_ts$orderBySimilarity(name, matches);
    const bestMatch = ratings[0];

    if (bestMatch.rating >= minRating) {
      return bestMatch.target;
    } else {
      return undefined;
    }
  }

  // project-rome/@romejs/string-utils/orderByNatural.ts
const ___R$project$rome$$romejs$string$utils$orderByNatural_ts = {
    orderByNatural: ___R$project$rome$$romejs$string$utils$orderByNatural_ts$orderByNatural,
  };
  function ___R$project$rome$$romejs$string$utils$orderByNatural_ts$orderByNatural(
    strs,
    insensitive = true,
  ) {
    return strs.sort((a, b) => ___R$project$rome$$romejs$string$utils$naturalCompare_ts$naturalCompare(a, b, insensitive));
  }

  // project-rome/@romejs/string-utils/toKebabCase.ts
const ___R$project$rome$$romejs$string$utils$toKebabCase_ts = {
    toKebabCase: ___R$project$rome$$romejs$string$utils$toKebabCase_ts$toKebabCase,
  };
  function ___R$project$rome$$romejs$string$utils$toKebabCase_ts$toKebabCase(str) {
    return (
      str.replace(/([a-z])([A-Z])/g, '$1-$2').replace(/[\s_]+/g, '-').toLowerCase()
    );
  }

  // project-rome/@romejs/string-utils/toCamelCase.ts
const ___R$project$rome$$romejs$string$utils$toCamelCase_ts = {
    toCamelCase: ___R$project$rome$$romejs$string$utils$toCamelCase_ts$toCamelCase,
  };
  function ___R$project$rome$$romejs$string$utils$toCamelCase_ts$toCamelCase(str, forceCapitalize) {
    // Rest of the code expects at least 1 character
    if (str.length === 0) {
      return str;
    }

    // Prepend uppercase letters with a space
    str = str.replace(/([A-Z+])/g, ' $1');

    // We no longer care about the casing
    str = str.toLowerCase();

    // Capitalize all characters after a symbol or space
    str = str.replace(/[_.\- ]+(\w|$)/g, (_, p1) => p1.toUpperCase());

    // Capitalize characters after a number
    str = str.replace(/\d+(\w|$)/g, (m) => m.toUpperCase());

    // Force capitalize if necessary
    if (forceCapitalize) {
      str = str[0].toUpperCase() + str.slice(1);
    }

    return str;
  }

  // project-rome/@romejs/string-utils/index.ts


  // project-rome/@romejs/string-ansi/regex.ts
const ___R$project$rome$$romejs$string$ansi$regex_ts = {
    get pattern() {
      return (
        ___R$project$rome$$romejs$string$ansi$regex_ts$pattern
      );
    },

    get regex() {
      return (
        ___R$project$rome$$romejs$string$ansi$regex_ts$regex
      );
    },

    get colorRegex() {
      return (
        ___R$project$rome$$romejs$string$ansi$regex_ts$colorRegex
      );
    },
  };
  const ___R$project$rome$$romejs$string$ansi$regex_ts$pattern = [
    '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
    '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))',
  ].join(
    '|',
  );

  const ___R$project$rome$$romejs$string$ansi$regex_ts$regex = new RegExp(___R$project$rome$$romejs$string$ansi$regex_ts$pattern, 'g');

  const ___R$project$rome$$romejs$string$ansi$regex_ts$colorRegex = /u001b\[[3-9][0-9]m/g;

  // project-rome/@romejs/string-ansi/format.ts
const ___R$project$rome$$romejs$string$ansi$format_ts = {
    get formatAnsi() {
      return (
        ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi
      );
    },

    stripAnsi: ___R$project$rome$$romejs$string$ansi$format_ts$stripAnsi,
    hasAnsiColor: ___R$project$rome$$romejs$string$ansi$format_ts$hasAnsiColor,
    hasAnsi: ___R$project$rome$$romejs$string$ansi$format_ts$hasAnsi,
  };
  function ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(num) {
    return '\x1b[' +
    String(num) +
    'm';
  }

  const ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi = {
    reset(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(0) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(0);
    },

    fileHyperlink(name, filename) {
      let href = 'file://';
      const {HOSTNAME} = process.env;
      if (HOSTNAME != null) {
        href += HOSTNAME +
        '/';
      }
      href += filename;
      return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.hyperlink(name, href);
    },

    hyperlink(name, href) {
      return '\x1b]8;;' +
      href +
      '\x07' +
      name +
      '\x1b]8;;\x07';
    },

    rgb(str, color) {
      return (
        '\x1b[38;2;' +
        String(color.r) +
        ';' +
        String(color.g) +
        ';' +
        String(color.b) +
        'm' +
        str +
        ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(39)
      );
    },

    bgRgb(str, color) {
      return (
        '\x1b[48;2;' +
        String(color.r) +
        ';' +
        String(color.g) +
        ';' +
        String(color.b) +
        'm' +
        str +
        ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(49)
      );
    },

    bold(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(1) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(22);
    },

    dim(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(2) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(22);
    },

    italic(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(3) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(23);
    },

    underline(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(4) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(24);
    },

    inverse(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(7) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(27);
    },

    hidden(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(8) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(28);
    },

    strikethrough(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(9) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(29);
    },

    black(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(30) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(39);
    },

    brightBlack(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(90) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(39);
    },

    red(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(31) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(39);
    },

    brightRed(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(91) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(39);
    },

    green(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(32) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(39);
    },

    brightGreen(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(92) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(39);
    },

    yellow(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(33) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(39);
    },

    brightYellow(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(93) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(39);
    },

    blue(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(34) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(39);
    },

    brightBlue(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(94) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(39);
    },

    magenta(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(35) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(39);
    },

    brightMagenta(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(95) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(39);
    },

    cyan(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(36) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(39);
    },

    brightCyan(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(96) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(39);
    },

    white(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(37) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(39);
    },

    brightWhite(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(97) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(39);
    },

    bgBlack(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(40) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgBrightBlack(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(100) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgRed(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(41) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgBrightRed(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(101) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgGreen(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(42) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgBrightGreen(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(102) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgYellow(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(43) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgBrightYellow(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(103) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgBlue(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(44) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgBrightBlue(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(104) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgMagenta(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(45) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgBrightMagenta(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(105) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgCyan(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(46) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgBrightCyan(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(106) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgWhite(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(47) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgBrightWhite(str) {
      return ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(107) + str + ___R$$priv$project$rome$$romejs$string$ansi$format_ts$createEscape(49);
    },
  };

  function ___R$project$rome$$romejs$string$ansi$format_ts$stripAnsi(str) {
    return str.replace(___R$project$rome$$romejs$string$ansi$regex_ts$regex, '');
  }

  function ___R$project$rome$$romejs$string$ansi$format_ts$hasAnsiColor(str) {
    return ___R$project$rome$$romejs$string$ansi$regex_ts$colorRegex.test(str);
  }

  function ___R$project$rome$$romejs$string$ansi$format_ts$hasAnsi(str) {
    return ___R$project$rome$$romejs$string$ansi$regex_ts$regex.test(str);
  }

  // project-rome/@romejs/string-ansi/pad.ts
const ___R$project$rome$$romejs$string$ansi$pad_ts = {
    pad: ___R$project$rome$$romejs$string$ansi$pad_ts$pad,
    rightPad: ___R$project$rome$$romejs$string$ansi$pad_ts$rightPad,
    leftPad: ___R$project$rome$$romejs$string$ansi$pad_ts$leftPad,
  };
  const ___R$$priv$project$rome$$romejs$string$ansi$pad_ts$DEFAULT_SPACER = ' ';

  function ___R$project$rome$$romejs$string$ansi$pad_ts$pad(
    side,
    str,
    len,
    spacerChar = ___R$$priv$project$rome$$romejs$string$ansi$pad_ts$DEFAULT_SPACER,
  ) {
    const stripped = ___R$project$rome$$romejs$string$ansi$format_ts$stripAnsi(str);
    const remainder = len - stripped.length;

    if (remainder <= 0) {
      return str;
    }

    const spacer = spacerChar.repeat(remainder);
    if (side === 'left') {
      return spacer + str;
    } else {
      //right
      return str + spacer;
    }
  }

  function ___R$project$rome$$romejs$string$ansi$pad_ts$rightPad(
    str,
    len,
    spacer = ___R$$priv$project$rome$$romejs$string$ansi$pad_ts$DEFAULT_SPACER,
  ) {
    return ___R$project$rome$$romejs$string$ansi$pad_ts$pad('right', str, len, spacer);
  }

  function ___R$project$rome$$romejs$string$ansi$pad_ts$leftPad(
    str,
    len,
    spacer = ___R$$priv$project$rome$$romejs$string$ansi$pad_ts$DEFAULT_SPACER,
  ) {
    return ___R$project$rome$$romejs$string$ansi$pad_ts$pad('left', str, len, spacer);
  }

  // project-rome/@romejs/string-ansi/escapes.ts
const ___R$project$rome$$romejs$string$ansi$escapes_ts = {
    get escapes() {
      return (
        ___R$project$rome$$romejs$string$ansi$escapes_ts$escapes
      );
    },
  };
  /**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

  const ___R$$priv$project$rome$$romejs$string$ansi$escapes_ts$ESC = '\x1b[';

  const ___R$project$rome$$romejs$string$ansi$escapes_ts$escapes = {
    clearScreen: '\x1bc',
    eraseLine: ___R$$priv$project$rome$$romejs$string$ansi$escapes_ts$ESC +
    '2K',

    cursorUp(count = 1) {
      return '' +
      ___R$$priv$project$rome$$romejs$string$ansi$escapes_ts$ESC +
      count +
      'A';
    },

    cursorTo(x, y) {
      if (y === undefined) {
        return '' +
        ___R$$priv$project$rome$$romejs$string$ansi$escapes_ts$ESC +
        (x + 1) +
        'G';
      }

      return '' +
      ___R$$priv$project$rome$$romejs$string$ansi$escapes_ts$ESC +
      (y + 1) +
      ';' +
      (x + 1) +
      'H';
    },
  };

  // project-rome/@romejs/string-ansi/split.ts
const ___R$project$rome$$romejs$string$ansi$split_ts = {
    truncateAnsi: ___R$project$rome$$romejs$string$ansi$split_ts$truncateAnsi,
    mapAnsiString: ___R$project$rome$$romejs$string$ansi$split_ts$mapAnsiString,
    splitAnsiLines: ___R$project$rome$$romejs$string$ansi$split_ts$splitAnsiLines,
  };
  const ___R$$priv$project$rome$$romejs$string$ansi$split_ts$startRegex = new RegExp('^' +
  ___R$project$rome$$romejs$string$ansi$regex_ts$pattern);

  function ___R$$priv$project$rome$$romejs$string$ansi$split_ts$isAnsiStartChar(char) {
    return char === '\x1b' || char === '\x9b';
  }

  const ___R$$priv$project$rome$$romejs$string$ansi$split_ts$HYPERLINK_END = '\x1b]8;;\x07';

  function ___R$$priv$project$rome$$romejs$string$ansi$split_ts$sliceAnsi(input, index) {
    const match = input.slice(index).match(___R$$priv$project$rome$$romejs$string$ansi$split_ts$startRegex);

    if (match == null) {
      return undefined;
    }

    const str = match[0];

    // Hyperlink, try and find the rest
    if (str[0] === '\x1b') {
      const possibleIndex = input.indexOf(___R$$priv$project$rome$$romejs$string$ansi$split_ts$HYPERLINK_END, index + str.length);
      if (possibleIndex > -1) {
        return input.slice(index, possibleIndex + ___R$$priv$project$rome$$romejs$string$ansi$split_ts$HYPERLINK_END.length);
      }
    }

    return str;
  }

  function ___R$project$rome$$romejs$string$ansi$split_ts$truncateAnsi(input, maxWidth) {
    return ___R$project$rome$$romejs$string$ansi$split_ts$splitAnsiLines(input, maxWidth)[0];
  }

  function ___R$project$rome$$romejs$string$ansi$split_ts$mapAnsiString(
    input,
    callback,
  ) {
    let buff = '';
    let fakeIndex = 0;
    let realIndex = 0;

    while (realIndex < input.length) {
      const char = input[realIndex];

      // Skip all ansi sequences, but add them to the current line
      if (___R$$priv$project$rome$$romejs$string$ansi$split_ts$isAnsiStartChar(char)) {
        const match = ___R$$priv$project$rome$$romejs$string$ansi$split_ts$sliceAnsi(input, realIndex);
        if (match !== undefined) {
          const strippedLength = ___R$project$rome$$romejs$string$ansi$format_ts$stripAnsi(match).length;
          buff +=
            callback(
              match,
              {
                isAnsi: true,
                start: fakeIndex,
                end: fakeIndex + strippedLength,
              },
            );
          realIndex += match.length;
          fakeIndex += strippedLength;
          continue;
        }
      }

      buff +=
        callback(
          char,
          {
            isAnsi: false,
            start: fakeIndex,
            end: fakeIndex + 1,
          },
        );
      realIndex++;
      fakeIndex++;
    }

    return buff;
  }

  function ___R$project$rome$$romejs$string$ansi$split_ts$splitAnsiLines(input, maxWidth) {
    const lines = [];

    let column = 0;
    let buff = '';

    function pushLine() {
      lines.push(buff);
      column = 0;
      buff = '';
    }

    let index = 0;

    while (index < input.length) {
      const char = input[index];

      // Skip all ansi sequences, but add them to the current line
      if (___R$$priv$project$rome$$romejs$string$ansi$split_ts$isAnsiStartChar(char)) {
        const match = ___R$$priv$project$rome$$romejs$string$ansi$split_ts$sliceAnsi(input, index);
        if (match !== undefined) {
          buff += match;
          index += match.length;
          continue;
        }
      }

      // Don't allow spaces at the beginning of lines
      if (char === ' ' && column === 0) {
        //index++;

        //continue;
      }

      // Flush the current line
      if (char === '\n') {
        pushLine();
        index++;
        continue;
      }

      // Otherwise, get all the characters until a space for soft wrapping
      let word = char;
      for (let i = index + 1;
      i < input.length && input[i] !== ' ';
      i++) {
        word += input[i];
      }

      // Calculate the word length, this can include ansi color codes
      const wordLength = ___R$project$rome$$romejs$string$ansi$format_ts$stripAnsi(word).length;

      // Push the current line if the addition of this word would overflow
      let pushedLine = false;
      if (maxWidth !== undefined && column + wordLength > maxWidth) {
        pushLine();
        pushedLine = true;
      }

      // Add the word and advance
      column += wordLength;
      buff += pushedLine ? word.trimLeft() : word;
      index += word.length;
    }

    // Flush the current buffer
    if (buff !== '') {
      pushLine();
    }

    return lines;
  }

  // project-rome/@romejs/string-ansi/index.ts


  // project-rome/@romejs/string-markup/format.ts
const ___R$project$rome$$romejs$string$markup$format_ts = {
    stripMarkupTags: ___R$project$rome$$romejs$string$markup$format_ts$stripMarkupTags,
    markupToAnsi: ___R$project$rome$$romejs$string$markup$format_ts$markupToAnsi,
    humanizeMarkupFilename: ___R$project$rome$$romejs$string$markup$format_ts$humanizeMarkupFilename,
  };

  const ___R$$priv$project$rome$$romejs$string$markup$format_ts$EMPTY_ATTRIBUTES = new Map();

  function ___R$$priv$project$rome$$romejs$string$markup$format_ts$formatReduceFromInput(
    input,
    callback,
  ) {
    return ___R$$priv$project$rome$$romejs$string$markup$format_ts$formatReduceFromChildren(___R$project$rome$$romejs$string$markup$parse_ts$parseMarkup(input), callback);
  }

  function ___R$$priv$project$rome$$romejs$string$markup$format_ts$formatReduceFromChildren(
    children,
    callback,
  ) {
    let buff = '';
    for (const child of children) {
      if (child.type === 'Text') {
        buff += child.value;
      } else if (child.type === 'Tag') {
        const {attributes} = child;

        let res = callback(
          child.name,
          attributes,
          ___R$$priv$project$rome$$romejs$string$markup$format_ts$formatReduceFromChildren(
            child.children,
            callback,
          ),
        );

        // Support some concise formatting
        if (attributes.get('emphasis') === 'true') {
          res = callback('emphasis', ___R$$priv$project$rome$$romejs$string$markup$format_ts$EMPTY_ATTRIBUTES, res);
        }
        if (attributes.get('dim') === 'true') {
          res = callback('dim', ___R$$priv$project$rome$$romejs$string$markup$format_ts$EMPTY_ATTRIBUTES, res);
        }

        buff += res;
      } else {
        throw new Error('Unknown child node type');
      }
    }
    return buff;
  }

  function ___R$$priv$project$rome$$romejs$string$markup$format_ts$formatFileLink(
    attributes,
    value,
    opts,
  ) {
    let text = value;

    // Normalize filename
    let filename = attributes.get('target') || '';
    let origFilename = filename;
    if (opts.normalizeFilename !== undefined) {
      filename = opts.normalizeFilename(filename);
    }

    // Default text to a humanized version of the filename
    if (text === '') {
      text = ___R$project$rome$$romejs$string$markup$format_ts$humanizeMarkupFilename([filename, origFilename], opts);

      const line = attributes.get('line');
      if (line !== undefined) {
        text += ':' +
        line;

        const column = attributes.get('column');
        // Ignore a 0 column and just target the line
        if (column !== undefined && column !== '0') {
          text += ':' +
          column;
        }
      }
    }

    return {text, href: 'file://' +
    filename};
  }

  function ___R$$priv$project$rome$$romejs$string$markup$format_ts$formatApprox(attributes, value) {
    if (attributes.get('approx') === 'true') {
      return '~' +
      value;
    } else {
      return value;
    }
  }

  function ___R$project$rome$$romejs$string$markup$format_ts$stripMarkupTags(
    input,
    opts = {},
  ) {
    return (
      ___R$$priv$project$rome$$romejs$string$markup$format_ts$formatReduceFromInput(
        input,
        (tag, attributes, value) => {
          switch (tag) {
            case 'filelink':
              return ___R$$priv$project$rome$$romejs$string$markup$format_ts$formatFileLink(attributes, value, opts).text;

            case 'number':
              return ___R$$priv$project$rome$$romejs$string$markup$format_ts$formatApprox(attributes, value);

            case 'duration':
              return ___R$$priv$project$rome$$romejs$string$markup$format_ts$formatApprox(attributes, ___R$project$rome$$romejs$string$utils$humanizeTime_ts$humanizeTime(Number(value), true));

            case 'filesize':
              return ___R$project$rome$$romejs$string$utils$humanizeFileSize_ts$humanizeFileSize(Number(value));

            case 'command':
              return '`' +
              value +
              '`';

            default:
              return value;
          }
        },
      )
    );
  }

  function ___R$project$rome$$romejs$string$markup$format_ts$markupToAnsi(
    input,
    opts = {},
  ) {
    return (
      ___R$$priv$project$rome$$romejs$string$markup$format_ts$formatReduceFromInput(
        input,
        (tag, attributes, value) => {
          switch (tag) {
            case 'hyperlink':
              {
                let text = value;
                let hyperlink = attributes.get('target');

                if (hyperlink === undefined) {
                  hyperlink = text;
                }

                if (text === '') {
                  text = hyperlink;
                }

                return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.hyperlink(text, hyperlink);
              }

            case 'filelink':
              {
                const {text, href} = ___R$$priv$project$rome$$romejs$string$markup$format_ts$formatFileLink(attributes, value, opts);
                return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.hyperlink(text, href);
              }

            case 'inverse':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.inverse(' ' +
              value +
              ' ');

            case 'emphasis':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bold(value);

            case 'dim':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.dim(value);

            case 'filesize':
              return ___R$project$rome$$romejs$string$utils$humanizeFileSize_ts$humanizeFileSize(Number(value));

            case 'duration':
              return ___R$$priv$project$rome$$romejs$string$markup$format_ts$formatApprox(attributes, ___R$project$rome$$romejs$string$utils$humanizeTime_ts$humanizeTime(Number(value), true));

            case 'number':
              return ___R$$priv$project$rome$$romejs$string$markup$format_ts$formatApprox(attributes, ___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(Number(value)));

            case 'italic':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.italic(value);

            case 'underline':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.underline(value);

            case 'strike':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.strikethrough(value);

            case 'black':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.black(value);

            case 'brightBlack':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.brightBlack(value);

            case 'red':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.red(value);

            case 'brightRed':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.brightRed(value);

            case 'green':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.green(value);

            case 'brightGreen':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.brightGreen(value);

            case 'yellow':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.yellow(value);

            case 'brightYellow':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.brightYellow(value);

            case 'blue':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.blue(value);

            case 'brightBlue':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.brightBlue(value);

            case 'magenta':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.magenta(value);

            case 'brightMagenta':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.brightMagenta(value);

            case 'cyan':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.cyan(value);

            case 'brightCyan':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.brightCyan(value);

            case 'white':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.white(value);

            case 'brightWhite':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.brightWhite(value);

            case 'bgBlack':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bgBlack(value);

            case 'bgBrightBlack':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bgBrightBlack(value);

            case 'bgRed':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bgRed(value);

            case 'bgBrightRed':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bgBrightRed(value);

            case 'bgGreen':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bgGreen(value);

            case 'bgBrightGreen':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bgBrightGreen(value);

            case 'bgYellow':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bgYellow(value);

            case 'bgBrightYellow':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bgBrightYellow(value);

            case 'bgBlue':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bgBlue(value);

            case 'bgBrightBlue':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bgBrightBlue(value);

            case 'bgMagenta':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bgMagenta(value);

            case 'bgBrightMagenta':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bgBrightMagenta(value);

            case 'bgCyan':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bgCyan(value);

            case 'bgBrightCyan':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bgBrightCyan(value);

            case 'bgWhite':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bgWhite(value);

            case 'bgBrightWhite':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bgBrightWhite(value);

            case 'command':
              return '`' + ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.italic(value) + '`';
          }
        },
      )
    );
  }

  function ___R$project$rome$$romejs$string$markup$format_ts$humanizeMarkupFilename(
    filenames,
    opts = {},
  ) {
    if (opts.humanizeFilename !== undefined) {
      const override = opts.humanizeFilename(filenames[0]);
      if (override !== undefined) {
        return override;
      }
    }

    if (filenames.length === 0) {
      return 'unknown';
    }

    const names = [];

    for (const filename of filenames) {
      names.push(___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(filename).format(opts.cwd));
    }

    // Get the shortest name
    return names.sort((a, b) => a.length - b.length)[0];
  }

  // project-rome/@romejs/string-markup/escape.ts
const ___R$project$rome$$romejs$string$markup$escape_ts = {
    markup: ___R$project$rome$$romejs$string$markup$escape_ts$markup,
    safeMarkup: ___R$project$rome$$romejs$string$markup$escape_ts$safeMarkup,
    escapeMarkup: ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup,
  };
  function ___R$project$rome$$romejs$string$markup$escape_ts$markup(
    strs,
  ...values) {
    let out = '';

    for (let i = 0;
    i < strs.length;
    i++) {
      const str = strs[i];
      out += str;

      const interpolated = values[i];

      if (interpolated instanceof ___R$$priv$project$rome$$romejs$string$markup$escape_ts$SafeMarkup) {
        out += interpolated.value;
        continue;
      }

      if (interpolated !== undefined) {
        out += ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(String(interpolated));
      }
    }

    return out;
  }

  class ___R$$priv$project$rome$$romejs$string$markup$escape_ts$SafeMarkup {
    constructor(value) {
      this.value = value;
    }
  }

  function ___R$project$rome$$romejs$string$markup$escape_ts$safeMarkup(input) {
    return new ___R$$priv$project$rome$$romejs$string$markup$escape_ts$SafeMarkup(input);
  }

  function ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(input) {
    let escaped = '';
    for (let i = 0;
    i < input.length;
    i++) {
      const char = input[i];

      if (___R$project$rome$$romejs$string$markup$parse_ts$isTagChar(___R$project$rome$$romejs$ob1$index_ts$coerce0(i), input)) {
        escaped += '\\<';
      } else {
        escaped += char;
      }
    }
    return escaped;
  }

  // project-rome/@romejs/string-markup/index.ts


  // project-rome/@romejs/cli-diagnostics/types.ts
const ___R$project$rome$$romejs$cli$diagnostics$types_ts = {
  };

  // project-rome/@romejs/cli-reporter/Progress.ts
// 30 columns a second
  const ___R$$priv$project$rome$$romejs$cli$reporter$Progress_ts$BOUNCER_INTERVAL = 1000 / 30;
  const ___R$$priv$project$rome$$romejs$cli$reporter$Progress_ts$BOUNCER_WIDTH = 20;

  const ___R$$priv$project$rome$$romejs$cli$reporter$Progress_ts$DEFAULT_PROGRESS_OPTIONS = {
    name: undefined,
    initDelay: undefined,
    elapsed: true,
    eta: true,
    persistent: false,
  };

  class ___R$project$rome$$romejs$cli$reporter$Progress_ts$default {
    constructor(reporter, opts = {}, onEnd) {
      this.reporter = reporter;
      this.opts =
        Object.assign(
          {
          },
          ___R$$priv$project$rome$$romejs$cli$reporter$Progress_ts$DEFAULT_PROGRESS_OPTIONS,
          opts,
        );

      this.textStack = [];
      this.text = undefined;
      this.title = undefined;

      this.pausedStart = undefined;
      this.pausedElapsed = 0;

      this.startTime = Date.now();
      this.lastRenderTime = Date.now();
      this.lastRenderCurrent = 0;

      this.closed = false;
      this.current = 0;
      this.approximateTotal = false;
      this.total = undefined;
      this.approximateETA = undefined;
      this.onEnd = onEnd;

      this.delay = 60;
      this.renderEvery = 0;

      this.paused = false;

      this.streamToBouncerStart = new Map();
      this.startBouncer();

      this.queueRender(opts.initDelay);
      this.initName(opts.name);
    }

    initName(name) {
      if (name === undefined) {
        return;
      }

      // TODO fetch approximate total and eta based on `name`
    }

    processRemoteClientMessage(msg) {
      switch (msg.type) {
        case 'PROGRESS_SET_CURRENT':
          return this.setCurrent(msg.current);

        case 'PROGRESS_SET_TOTAL':
          return this.setTotal(msg.total, msg.approximate);

        case 'PROGRESS_SET_TITLE':
          return this.setTitle(msg.title);

        case 'PROGRESS_SET_TEXT':
          return this.setText(msg.text);

        case 'PROGRESS_PUSH_TEXT':
          return this.pushText(msg.text);

        case 'PROGRESS_POP_TEXT':
          return this.popText(msg.text);

        case 'PROGRESS_SET_APPROXIMATE_ETA':
          return this.setApproximateETA(msg.duration);

        case 'PROGRESS_TICK':
          return this.tick();

        case 'PROGRESS_END':
          return this.end();

        case 'PROGRESS_RESUME':
          return this.resume();

        case 'PROGRESS_PAUSE':
          return this.pause();
      }
    }

    resume() {
      if (!this.paused || this.pausedStart === undefined) {
        return;
      }

      this.pausedElapsed += Date.now() - this.pausedStart;
      this.pausedStart = undefined;
      this.paused = false;
      this.render();
    }

    pause() {
      if (this.paused) {
        return;
      }

      this.pausedStart = Date.now();
      this.paused = true;
      this.render();
    }

    getElapsedTime() {
      return Date.now() - this.startTime - this.pausedElapsed;
    }

    getBouncerPosition(stream) {
      const start = this.streamToBouncerStart.get(stream);
      if (start === undefined) {
        return 0;
      } else {
        return start;
      }
    }

    startBouncer() {
      const queueTick = () => {
        this.bouncerTimer = setTimeout(tick, ___R$$priv$project$rome$$romejs$cli$reporter$Progress_ts$BOUNCER_INTERVAL);
      };

      const tick = this.reporter.wrapCallback(
        () => {
          if (this.paused) {
            queueTick();
            return;
          }

          const elapsedTime = this.getElapsedTime();
          const elapsedFrames = Math.round(elapsedTime / ___R$$priv$project$rome$$romejs$cli$reporter$Progress_ts$BOUNCER_INTERVAL);

          for (const stream of this.reporter.streams) {
            // We remove the bouncer width from the total columns since we'll append it
            const width = stream.columns - ___R$$priv$project$rome$$romejs$cli$reporter$Progress_ts$BOUNCER_WIDTH;

            // Position to place the bouncer
            let position = elapsedFrames % width;

            // Every odd complete bounce should reverse direction
            const totalBounces = Math.floor(elapsedFrames / width);
            if (totalBounces % 2 === 1) {
              position = width - position;
            }

            this.streamToBouncerStart.set(stream, position);
          }

          queueTick();
          this.render();
        },
      );

      queueTick();
    }

    setCurrent(current) {
      if (this.closed) {
        return;
      }

      this.current = current;

      // Schedule render
      if (this.renderTimer === undefined) {
        this.queueRender();
      }

      if (this.isRenderDue()) {
        this.render();
      }

      // Progress complete
      if (this.total !== undefined && this.current >= this.total &&
        !this.opts.persistent) {
        this.end();
      }
    }

    setApproximateETA(duration) {
      this.approximateETA = duration;
    }

    setTotal(total, approximate = false) {
      this.total = total;
      this.approximateTotal = approximate;
      this.renderEvery = Math.round(total / 100);
      this.endBouncer();
      this.queueRender();
    }

    setTitle(title) {
      this.title = this.reporter.stripMarkup(title);
      this.queueRender();
    }

    setText(text) {
      if (this.closed) {
        return;
      }

      this.text = this.reporter.stripMarkup(text);
      this.queueRender();
    }

    pushText(text) {
      this.setText(text);
      this.textStack.push(text);
    }

    popText(text) {
      // Find
      const {textStack} = this;
      const index = textStack.indexOf(text);
      if (index === -1) {
        throw new Error('No pushed text: ' +
        text);
      }

      // Remove
      textStack.splice(index, 1);

      // Set last
      const last = textStack[textStack.length - 1];
      this.setText(last === undefined ? '' : last);
    }

    tick() {
      this.setCurrent(this.current + 1);
    }

    queueRender(delay = this.delay) {
      if (this.closed) {
        // Progress bar has been removed
        return;
      }

      if (this.renderTimer !== undefined) {
        // Render already queued
        return;
      }

      this.renderTimer =
        setTimeout(
          this.reporter.wrapCallback(
            () => {
              this.render();
            },
          ),
          delay,
        );
    }

    endBouncer() {
      if (this.bouncerTimer !== undefined) {
        clearTimeout(this.bouncerTimer);
      }
      this.bouncerTimer = undefined;
    }

    endRender() {
      if (this.renderTimer !== undefined) {
        clearTimeout(this.renderTimer);
      }
      this.renderTimer = undefined;
    }

    end() {
      this.closed = true;
      this.endBouncer();
      this.endRender();
      this.reporter.clearLineAll();

      if (this.onEnd !== undefined) {
        this.onEnd();
      }
    }

    // Ensure that we update the progress bar after a certain amount of ticks

    // This allows us to use the progress bar for sync work where the event loop is always blocked
    isRenderDue() {
      const isDue = this.current >
      this.lastRenderCurrent +
      this.renderEvery;
      if (isDue) {
        // We also make sure that we never force update more often than once a second

        // This is to ensure that the progress bar isn't negatively effecting performance
        const timeSinceLastRender = Date.now() - this.lastRenderTime;
        return timeSinceLastRender > 1000;
      } else {
        return false;
      }
    }

    isBoldCharacter(i, ranges) {
      for (const [start, end] of ranges) {
        if (start >= i && end <= i) {
          return true;
        }
      }

      return false;
    }

    splitCharacters(str, boldRanges) {
      return (
        str.split('').map(
          (char, i) => {
            if (this.isBoldCharacter(i, boldRanges)) {
              return [i, ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bold(char)];
            } else {
              return [i, char];
            }
          },
        )
      );
    }

    buildProgressBouncer(stream, bar) {
      let start = this.getBouncerPosition(stream);
      let fullBar = '';
      for (const [i, char] of bar) {
        const isBounce = i >= start && i < start + ___R$$priv$project$rome$$romejs$cli$reporter$Progress_ts$BOUNCER_WIDTH;

        if (isBounce) {
          if (this.paused) {
            fullBar += ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.inverse(char);
          } else {
            fullBar += ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.white(___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bgYellow(char));
          }
        } else {
          fullBar += char;
        }
      }
      return fullBar;
    }

    buildProgressBar(stream, bar, total) {
      const ratio = Math.min(Math.max(this.current / total, 0), 1);

      const completeLength = Math.round(stream.columns * ratio);
      let fullBar = '';
      for (const [i, char] of bar) {
        if (i < completeLength) {
          if (this.paused) {
            fullBar += ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.inverse(char);
          } else {
            fullBar += ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.white(___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bgGreen(char));
          }
        } else {
          fullBar += char;
        }
      }
      return fullBar;
    }

    buildBar(stream) {
      const {total, current, text, title} = this;

      // Text ranges that we should make bold
      const boldRanges = [];

      // Text to prefix to the bar
      let prefix = '';
      if (title !== undefined) {
        prefix += title;

        // Only the title should be bold, not the subtext
        boldRanges.push([0, prefix.length - 1]);
      }
      if (text !== undefined) {
        // Separate a title and it's text with a colon
        if (title !== undefined) {
          prefix += ': ';
        }
        prefix += text;
      }

      // Text to put at the end of the bar
      let suffix = '';

      // Total time since the progress bar was created
      const elapsed = this.getElapsedTime();

      // Time elapsed eg: elapsed 1m5s
      if (this.opts.elapsed) {
        suffix += 'elapsed ' +
        ___R$project$rome$$romejs$string$utils$humanizeTime_ts$humanizeTime(elapsed) +
        ' ';
      }

      // Don't bother with a suffix if we haven't completed a single item
      if (current > 0) {
        // How many milliseconds spent per total items
        const averagePerItem = elapsed / current;

        // ETA eg: 1m5s
        if (this.opts.eta) {
          if (this.approximateETA !== undefined && elapsed < this.approximateETA) {
            // Approximate ETA
            const left = elapsed - this.approximateETA;
            suffix += 'eta ~' +
            ___R$project$rome$$romejs$string$utils$humanizeTime_ts$humanizeTime(left) +
            ' ';
          } else if (total !== undefined) {
            // How many items we have left
            const itemsLeft = total - current;

            // Total estimated time left
            const eta = itemsLeft * averagePerItem;
            suffix += 'eta ' +
            ___R$project$rome$$romejs$string$utils$humanizeTime_ts$humanizeTime(eta) +
            ' ';
          } else {
            const ops = Math.round(1000 / averagePerItem);
            suffix += ___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(ops) +
            ' op/s ';
          }
        }

        // Counter eg: 5/100
        suffix += ___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(current);
        if (total !== undefined) {
          suffix += '/';
          if (this.approximateTotal) {
            suffix += '~';
          }
          suffix += ___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(total);
        }
      }

      // Get the full width of the bar. We take off 3 for padding.
      const width = stream.columns - 3;

      // The amount of spaces to put between the title and counter
      const spacerLength = Math.max(0, width - prefix.length - suffix.length);
      const spacer = ' '.repeat(spacerLength);

      // Trim the prefix if it will overflow
      prefix = prefix.slice(0, width - spacerLength - suffix.length);

      // The full raw bar without any coloring
      const raw = ' ' +
      prefix +
      spacer +
      ' ' +
      suffix;

      // Make sure the counter is bold
      boldRanges.push([raw.length - suffix.length, raw.length - 1]);

      // Split the raw bar into an array of formatted characters
      const chars = this.splitCharacters(raw, boldRanges);

      if (total === undefined) {
        return this.buildProgressBouncer(stream, chars);
      } else {
        return this.buildProgressBar(stream, chars, total);
      }
    }

    render() {
      if (this.closed) {
        return;
      }

      this.endRender();

      this.lastRenderCurrent = this.current;
      this.lastRenderTime = Date.now();

      for (const stream of this.reporter.getStreams(false)) {
        if (stream.format === 'ansi') {
          stream.write(___R$project$rome$$romejs$string$ansi$escapes_ts$escapes.cursorTo(0));
          stream.write(this.buildBar(stream));
        }
      }
    }
  }

  // project-rome/@romejs/typescript-helpers/index.ts
function ___R$project$rome$$romejs$typescript$helpers$index_ts$isPlainObject(
    obj,
  ) {
    return typeof obj === 'object' && obj !== null && !Array.isArray(obj);
  }

  function ___R$project$rome$$romejs$typescript$helpers$index_ts$isIterable(obj) {
    if (typeof obj === 'object' && obj != null) {
      // @ts-ignore
      return typeof obj[Symbol.iterator] === 'function';
    } else {
      return false;
    }
  }

  // project-rome/@romejs/string-escape/messages.ts
const ___R$project$rome$$romejs$string$escape$messages_ts = {
    get NOT_ENOUGH_CODE_POINTS() {
      return (
        ___R$project$rome$$romejs$string$escape$messages_ts$NOT_ENOUGH_CODE_POINTS
      );
    },

    get INVALID_STRING_CHARACTER() {
      return (
        ___R$project$rome$$romejs$string$escape$messages_ts$INVALID_STRING_CHARACTER
      );
    },

    get INVALID_HEX_DIGIT_FOR_ESCAPE() {
      return (
        ___R$project$rome$$romejs$string$escape$messages_ts$INVALID_HEX_DIGIT_FOR_ESCAPE
      );
    },
  };
  const ___R$project$rome$$romejs$string$escape$messages_ts$NOT_ENOUGH_CODE_POINTS = 'Not enough code point digits';
  const ___R$project$rome$$romejs$string$escape$messages_ts$INVALID_STRING_CHARACTER = 'Invalid string character (U+0000 to U+001F)';
  const ___R$project$rome$$romejs$string$escape$messages_ts$INVALID_HEX_DIGIT_FOR_ESCAPE = 'Invalid hex digit for unicode escape';

  // project-rome/@romejs/string-escape/constants.ts
const ___R$project$rome$$romejs$string$escape$constants_ts = {
    get DOUBLE_QUOTE() {
      return (
        ___R$project$rome$$romejs$string$escape$constants_ts$DOUBLE_QUOTE
      );
    },

    get SINGLE_QUOTE() {
      return (
        ___R$project$rome$$romejs$string$escape$constants_ts$SINGLE_QUOTE
      );
    },

    get TICK_QUOTE() {
      return (
        ___R$project$rome$$romejs$string$escape$constants_ts$TICK_QUOTE
      );
    },
  };
  const ___R$project$rome$$romejs$string$escape$constants_ts$DOUBLE_QUOTE = '"';
  const ___R$project$rome$$romejs$string$escape$constants_ts$SINGLE_QUOTE = '\'';
  const ___R$project$rome$$romejs$string$escape$constants_ts$TICK_QUOTE = '`';

  // project-rome/@romejs/string-escape/escapeString.ts
// This regex represents printable ASCII characters, except the characters: '"\`
  const ___R$$priv$project$rome$$romejs$string$escape$escapeString_ts$PRINTABLE_ASCII = /[ !#-&\(-\[\]-_a-~]/;

  function ___R$$priv$project$rome$$romejs$string$escape$escapeString_ts$escapeChar(
    char,
    ignoreWhitespaceEscapes,
  ) {
    switch (char) {
      case '"':
        return '\\"';

      case '\'':
        return '\\\'';

      case '\b':
        return '\\b';

      case '\f':
        return '\\f';

      case '\\':
        return '\\\\';
    }

    if (ignoreWhitespaceEscapes) {
      return undefined;
    }

    switch (char) {
      case '\n':
        return '\\n';

      case '\r':
        return '\\r';

      case '\t':
        return '\\t';
    }

    return undefined;
  }

  function ___R$project$rome$$romejs$string$escape$escapeString_ts$default(
    str,
    opts = {},
  ) {
    let index = -1;
    let result = '';

    const {
      ignoreWhitespaceEscapes = false,
      quote = '',
      json = false,
      unicodeOnly = false,
    } = opts;

    // Loop over each code unit in the string and escape it
    while (++index < str.length) {
      const char = str[index];

      // Handle surrogate pairs in non-JSON mode
      if (!json) {
        const charCode = str.charCodeAt(index);
        const isHighSurrogate = charCode >= 55296 && charCode <= 56319;
        const hasNextCodePoint = str.length > index + 1;
        const isSurrogatePairStart = isHighSurrogate && hasNextCodePoint;

        if (isSurrogatePairStart) {
          const nextCharCode = str.charCodeAt(index + 1);
          const isLowSurrogate = nextCharCode >= 56320 && nextCharCode <= 57343;
          if (isLowSurrogate) {
            // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            const codePoint = (charCode - 55296) * 1024 + nextCharCode - 56320 + 65536;
            const hex = codePoint.toString(16);
            result += '\\u{' +
            hex +
            '}';
            index++;
            continue;
          }
        }
      }

      //
      if (___R$$priv$project$rome$$romejs$string$escape$escapeString_ts$PRINTABLE_ASCII.test(char)) {
        // Its a printable ASCII character that is not `"`, `'` or `\`,

        // so dont escape it.
        result += char;
        continue;
      }

      // Escape double quotes
      if (char == ___R$project$rome$$romejs$string$escape$constants_ts$DOUBLE_QUOTE) {
        result += quote == char ? '\\"' : char;
        continue;
      }

      // Escape single quotes
      if (char == ___R$project$rome$$romejs$string$escape$constants_ts$SINGLE_QUOTE) {
        result += quote == char ? '\\\'' : char;
        continue;
      }

      // Escape back tick
      if (char == ___R$project$rome$$romejs$string$escape$constants_ts$TICK_QUOTE) {
        result += quote == char ? '\\`' : char;
        continue;
      }

      // Null escape
      if (char == '\0' && !json && !___R$project$rome$$romejs$parser$core$index_ts$isDigit(str[index + 1])) {
        result += '\\0';
        continue;
      }

      // Simple escapes
      if (!unicodeOnly) {
        const replacement = ___R$$priv$project$rome$$romejs$string$escape$escapeString_ts$escapeChar(char, ignoreWhitespaceEscapes);
        if (replacement !== undefined) {
          result += replacement;
          continue;
        }
      }

      // Unicode escape
      const hex = char.charCodeAt(0).toString(16);
      const isLonghand = json || hex.length > 2;
      const modifier = isLonghand ? 'u' : 'x';
      const code = ('0000' +
      hex).slice(isLonghand ? -4 : -2);
      const escaped = '\\' +
      modifier +
      code;
      result += escaped;
      continue;
    }

    return '' +
    quote +
    result +
    quote;
  }

  // project-rome/@romejs/string-escape/unescapeString.ts
function ___R$$priv$project$rome$$romejs$string$escape$unescapeString_ts$unescapeChar(modifier) {
    switch (modifier) {
      case 'b':
        return '\b';

      case 'f':
        return '\f';

      case 'n':
        return '\n';

      case 'r':
        return '\r';

      case 't':
        return '\t';

      case 'v':
        return '\x0b';

      default:
        return modifier;
    }
  }

  const ___R$$priv$project$rome$$romejs$string$escape$unescapeString_ts$UNEXPECTED_DEFAULT_THROWER = (
    message,
    index,
  ) => {
    throw new TypeError(message +
    ' (' +
    String(index) +
    ')');
  };

  function ___R$project$rome$$romejs$string$escape$unescapeString_ts$default(
    input,
    unexpected = ___R$$priv$project$rome$$romejs$string$escape$unescapeString_ts$UNEXPECTED_DEFAULT_THROWER,
  ) {
    let buffer = '';

    let index = 0;

    while (index < input.length) {
      const char = input[index];
      const prevChar = input[index - 1];
      const prevPrevChar = input[index - 2];
      const isEscaped = prevChar === '\\' && prevPrevChar !== '\\';

      // It's verbatim if it's an escaped backslash or not a backslash
      if (isEscaped && char === '\\' || char !== '\\') {
        // Validate that this is a valid character
        const codePoint = char.codePointAt(0);
        if (codePoint === undefined) {
          throw new Error('Already validated that this index exists');
        }
        if (codePoint >= 0 && codePoint <= 31) {
          throw unexpected(___R$project$rome$$romejs$string$escape$messages_ts$INVALID_STRING_CHARACTER, index);
        }

        // Add it verbatim
        buffer += char;
        index++;
        continue;
      }

      const modifierIndex = index + 1;
      const modifier = input[modifierIndex];

      if (modifier === 'u') {
        // Get the next 4 characters as the code point
        const codeStartIndex = modifierIndex + 1;
        const rawCode = input.slice(codeStartIndex, codeStartIndex + 4);

        // Validate that we have at least 4 digits
        if (rawCode.length < 4) {
          // (index of the point start + total point digits)
          const lastDigitIndex = codeStartIndex + rawCode.length - 1;
          throw unexpected(___R$project$rome$$romejs$string$escape$messages_ts$NOT_ENOUGH_CODE_POINTS, lastDigitIndex);
        }

        // Validate that each character is a valid hex digit
        for (let i = 0;
        i < rawCode.length;
        i++) {
          const char = rawCode[i];
          if (!___R$project$rome$$romejs$parser$core$index_ts$isHexDigit(char)) {
            // Get the current source index for this character

            // (code start index + digit index)
            const pos = codeStartIndex + i;
            throw unexpected(___R$project$rome$$romejs$string$escape$messages_ts$INVALID_HEX_DIGIT_FOR_ESCAPE, pos);
          }
        }

        // Validate the code point
        const code = parseInt(rawCode, 16);

        // Get the character for this code point
        buffer += String.fromCodePoint(code);

        // Skip ahead six indexes (1 escape char +  1modifier + 4 hex digits)
        index += 6;
      } else {
        // Unescape a basic modifier like \t
        buffer += ___R$$priv$project$rome$$romejs$string$escape$unescapeString_ts$unescapeChar(modifier);

        // Skip ahead two indexes to also take along the modifier
        index += 2;
      }
    }

    return buffer;
  }

  // project-rome/@romejs/string-escape/index.ts
const ___R$project$rome$$romejs$string$escape$index_ts$messages = ___R$project$rome$$romejs$string$escape$messages_ts

  // project-rome/@romejs/pretty-format/index.ts
const ___R$$priv$project$rome$$romejs$pretty$format$index_ts$DEFAULT_OPTIONS = {
    escapeMarkup: false,
    maxDepth: Infinity,
    color: false,
    indent: '',
    depth: 0,
    stack: [],
    compact: false,
  };

  const ___R$$priv$project$rome$$romejs$pretty$format$index_ts$INDENT = '  ';

  function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$maybeEscapeMarkup(str, opts) {
    if (opts.escapeMarkup) {
      return ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(str);
    } else {
      return str;
    }
  }

  const ___R$project$rome$$romejs$pretty$format$index_ts$CUSTOM_PRETTY_FORMAT = Symbol();

  function ___R$project$rome$$romejs$pretty$format$index_ts$default(
    obj,
    rawOpts = {},
  ) {
    const opts = Object.assign(
      {
      },
      ___R$$priv$project$rome$$romejs$pretty$format$index_ts$DEFAULT_OPTIONS,
      rawOpts,
    );

    if (opts.maxDepth === opts.depth) {
      return '[depth exceeded]';
    }

    switch (typeof obj) {
      case 'symbol':
        {
          const val = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$maybeEscapeMarkup(___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatSymbol(obj), opts);
          return opts.color ? ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.green(val) : val;
        }

      case 'string':
        {
          const val = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$maybeEscapeMarkup(___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatString(obj), opts);
          return opts.color ? ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.green(val) : val;
        }

      case 'bigint':
      case 'number':
        {
          const val = ___R$project$rome$$romejs$pretty$format$index_ts$formatNumber(obj);
          return opts.color ? ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.yellow(val) : val;
        }

      case 'boolean':
        {
          const val = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatBoolean(obj);
          return opts.color ? ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.yellow(val) : val;
        }

      case 'undefined':
        {
          const val = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatUndefined();
          return opts.color ? ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.brightBlack(val) : val;
        }

      case 'function':
        return ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatFunction(obj, opts);

      case 'object':
        return ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatObjectish((obj), opts);

      default:
        throw new Error('Unknown type');
    }
  }

  function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$joinList(items, opts) {
    if (items.length === 0) {
      return '';
    }

    const lines = [];

    for (const item of items) {
      lines.push('' +
      opts.indent +
      item);
    }

    return lines.join('\n');
  }

  function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$isNativeFunction(val) {
    return val.toString().endsWith('{ [native code] }');
  }

  function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatSymbol(val) {
    return String(val);
  }

  function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatString(val) {
    return (
      ___R$project$rome$$romejs$string$escape$escapeString_ts$default(
        val,
        {
          quote: '\'',
        },
      )
    );
  }

  // This function is used by rome-json so make sure it can parse whatever you return here
  function ___R$project$rome$$romejs$pretty$format$index_ts$formatNumber(val) {
    if (typeof val === 'bigint') {
      return ___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(val, '_');
    } else if (isNaN(val)) {
      return 'NaN';
    } else if (Object.is(val, -0)) {
      return '-0';
    } else if (isFinite(val)) {
      return ___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(val, '_');
    } else if (Object.is(val, -Infinity)) {
      return '-Infinity';
    } else if (Object.is(val, +Infinity)) {
      return 'Infinity';
    } else {
      throw new Error('Don\'t know how to format this number');
    }
  }

  function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatUndefined() {
    return 'undefined';
  }

  function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatNull() {
    return 'null';
  }

  function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatBoolean(val) {
    return val === true ? 'true' : 'false';
  }

  function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatFunction(val, opts) {
    const name = val.name === '' ? 'anonymous' : ___R$$priv$project$rome$$romejs$pretty$format$index_ts$maybeEscapeMarkup(val.name, opts);
    let label = 'Function ' +
    name;

    if (___R$$priv$project$rome$$romejs$pretty$format$index_ts$isNativeFunction(val)) {
      label = 'Native' + label;
    }

    if (Object.keys(val).length === 0) {
      return label;
    }

    // rome-suppress lint/noExplicitAny
    return ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatObject(label, (val), opts, []);
  }

  function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$getExtraObjectProps(
    obj,
    opts,
  ) {
    const props = [];
    const ignoreKeys = {};

    if (obj instanceof Map) {
      for (const [key, val] of obj) {
        const formattedKey = typeof key === 'string'
          ? ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatKey(key, opts) : ___R$project$rome$$romejs$pretty$format$index_ts$default(key, opts);
        props.push(formattedKey +
        ' => ' +
        ___R$project$rome$$romejs$pretty$format$index_ts$default(val, opts));
      }
    } else if (___R$project$rome$$romejs$typescript$helpers$index_ts$isIterable(obj)) {
      let i = 0;
      for (const val of obj) {
        ignoreKeys[String(i++)] = val;
        props.push(___R$project$rome$$romejs$pretty$format$index_ts$default(val, opts));
      }
    }

    return {ignoreKeys, props};
  }

  function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatKey(rawKey, opts) {
    const key = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$maybeEscapeMarkup(rawKey, opts);

    // Format as a string if it contains any special characters
    if (/[^A-Za-z0-9_$]/g.test(key)) {
      return ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatString(key);
    } else {
      return key;
    }
  }

  // These are object keys that should always go at the top and ignore any alphabetization

  // This is fairly arbitrary but should include generic identifier keys
  const ___R$project$rome$$romejs$pretty$format$index_ts$PRIORITIZE_KEYS = ['id', 'type', 'kind', 'key', 'name', 'value'];

  function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$sortKeys(obj) {
    const sortedKeys = new Set(Object.keys(obj).sort(___R$project$rome$$romejs$string$utils$naturalCompare_ts$naturalCompare));

    const priorityKeys = [];
    const otherKeys = [];
    const objectKeys = [];

    for (const key of ___R$project$rome$$romejs$pretty$format$index_ts$PRIORITIZE_KEYS) {
      if (sortedKeys.has(key)) {
        priorityKeys.push({key, object: false});
        sortedKeys.delete(key);
      }
    }

    for (const key of sortedKeys) {
      const val = obj[key];

      // Objects with properties should be at the bottom
      let isObject = false;
      if (typeof val === 'object' && val != null && Object.keys(val).length > 0) {
        isObject = true;
      }
      if (Array.isArray(val) && val.length > 0) {
        isObject = true;
      }
      if (isObject) {
        objectKeys.push({key, object: true});
      } else {
        otherKeys.push({key, object: false});
      }
    }

    return [...priorityKeys, ...otherKeys, ...objectKeys];
  }

  function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$lineCount(str) {
    return str.split('\n').length;
    ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatKey;
  }

  function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$lineCountCompare(a, b) {
    return ___R$$priv$project$rome$$romejs$pretty$format$index_ts$lineCount(a) - ___R$$priv$project$rome$$romejs$pretty$format$index_ts$lineCount(b);
  }

  function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatObject(
    label,
    obj,
    opts,
    labelKeys,
  ) {
    // Detect circular references, and create a pointer to the specific value
    const {stack} = opts;
    if (stack.length > 0 && stack.includes(obj)) {
      label = 'Circular ' +
      label +
      ' ' +
      stack.indexOf(obj);
      return opts.color ? ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.cyan(label) : label;
    }

    //
    const nextOpts = Object.assign(
      {
      },
      opts,
      {
        stack: [...stack, obj],
        depth: opts.depth + 1,
        indent: opts.indent + ___R$$priv$project$rome$$romejs$pretty$format$index_ts$INDENT,
      },
    );
    const {ignoreKeys, props} = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$getExtraObjectProps(obj, nextOpts);

    // For props that have object values, we always put them at the end, sorted by line count
    const objProps = [];

    // Get string props
    for (const {key, object} of ___R$$priv$project$rome$$romejs$pretty$format$index_ts$sortKeys(obj)) {
      const val = obj[key];
      if (key in ignoreKeys && ignoreKeys[key] === val) {
        continue;
      }

      if (opts.compact && val === undefined) {
        continue;
      }

      // Ignore any properties already displayed in the label
      if (labelKeys.includes(key)) {
        continue;
      }

      const prop = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatKey(key, opts) +
      ': ' +
      ___R$project$rome$$romejs$pretty$format$index_ts$default(val, nextOpts);
      if (object) {
        objProps.push(prop);
      } else {
        props.push(prop);
      }
    }

    // Sort object props by line count and push them on
    for (const prop of objProps.sort(___R$$priv$project$rome$$romejs$pretty$format$index_ts$lineCountCompare)) {
      props.push(prop);
    }

    // Get symbol props
    for (const sym of Object.getOwnPropertySymbols(obj)) {
      const val = Reflect.get(obj, sym);
      props.push(___R$project$rome$$romejs$pretty$format$index_ts$default(sym, opts) +
      ': ' +
      ___R$project$rome$$romejs$pretty$format$index_ts$default(val, nextOpts));
    }

    //
    let open = '{';
    let close = '}';
    if (___R$project$rome$$romejs$typescript$helpers$index_ts$isIterable(obj)) {
      open = '[';
      close = ']';
    }

    //
    let inner = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$joinList(props, nextOpts);
    if (inner !== '') {
      if (props.length === 1 && !inner.includes('\n')) {
        // Single prop with no newlines shouldn't be indented
        inner = inner.trim();
      } else {
        inner = '\n' +
        inner +
        '\n' +
        opts.indent;
      }
    }

    label = opts.color ? ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.cyan(label) : label;
    return label +
    ' ' +
    open +
    inner +
    close;
  }

  function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatRegExp(val) {
    return String(val);
  }

  function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatDate(val) {
    return val.toISOString();
  }

  function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatObjectish(val, opts) {
    if (val === null) {
      const val = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatNull();
      return opts.color ? ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bold(val) : val;
    }

    if (val instanceof RegExp) {
      const str = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatRegExp(val);
      return opts.color ? ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.red(str) : str;
    }

    if (val instanceof Date) {
      const str = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatDate(val);
      return opts.color ? ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.magenta(str) : str;
    }

    let label = 'null';

    if (val.constructor !== undefined) {
      label = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$maybeEscapeMarkup(val.constructor.name, opts);
    }

    let labelKeys = [];

    // If there's a string type or kind property then use it as the label
    if (typeof val.type === 'string') {
      label = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$maybeEscapeMarkup(val.type, opts);
      labelKeys.push('type');
    } else if (typeof val.kind === 'string') {
      label = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$maybeEscapeMarkup(val.kind, opts);
      labelKeys.push('kind');
    }

    return ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatObject(label, val, opts, labelKeys);
  }

  // project-rome/@romejs/cli-reporter/util.ts
const ___R$$priv$project$rome$$romejs$cli$reporter$util_ts$formatOpts = {
    maxDepth: 5,
  };

  function ___R$project$rome$$romejs$cli$reporter$util_ts$interpolate(msg, args) {
    let argIndex = 0;

    // replace %s in the message with each argument
    let interpolated = msg.replace(
      /%s/g,
      () => {
        return ___R$project$rome$$romejs$pretty$format$index_ts$default(args[argIndex++], ___R$$priv$project$rome$$romejs$cli$reporter$util_ts$formatOpts);
      },
    );

    // add on all other arguments to the end, separate with spaces
    if (argIndex < args.length) {
      interpolated += ' ';
      interpolated +=
        args.slice(argIndex).map(
          (
            arg,
          ) =>
            ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(___R$project$rome$$romejs$pretty$format$index_ts$default(arg, ___R$$priv$project$rome$$romejs$cli$reporter$util_ts$formatOpts)),
        ).join(
          ' ',
        );
    }

    return interpolated;
  }

  // project-rome/@romejs/events/Event.ts
function ___R$$priv$project$rome$$romejs$events$Event_ts$noPromise(ret) {
    if (ret instanceof Promise) {
      throw new Error('Subscription returned promise for a callSync');
    } else {
      return ret;
    }
  }

  class ___R$project$rome$$romejs$events$Event_ts$default {
    constructor(opts) {
      this.subscriptions = new Set();
      this.rootSubscription = undefined;
      this.name = opts.name;
      this.options = opts;
    }

    onSubscriptionChange() {
      // Hook for BridgeEvent
    }

    onError(err) {
      const {onError} = this.options;
      if (onError !== undefined) {
        onError(err);
      }
    }

    clear() {
      this.subscriptions.clear();
    }

    hasSubscribers() {
      return this.hasSubscriptions();
    }

    hasSubscriptions() {
      return this.rootSubscription !== undefined;
    }

    // Dispatch the event without caring about the return values
    send(param) {
      const {rootSubscription} = this;
      if (rootSubscription === undefined) {
        return undefined;
      }

      rootSubscription(param);

      for (const callback of this.subscriptions) {
        callback(param);
      }
    }

    callSync(param) {
      try {
        const {rootSubscription, subscriptions} = this;
        if (rootSubscription === undefined) {
          throw new Error('No subscription for event ' +
          this.name);
        }

        const ret = ___R$$priv$project$rome$$romejs$events$Event_ts$noPromise(rootSubscription(param));
        for (const callback of subscriptions) {
          ___R$$priv$project$rome$$romejs$events$Event_ts$noPromise(callback(param));
        }
        return ret;
      } catch (err) {
        this.onError(err);
        throw err;
      }
    }

    async call(param) {
      const {rootSubscription, subscriptions} = this;
      if (rootSubscription === undefined) {
        throw new Error('No subscription for event ' +
        this.name);
      }

      try {
        if (this.options.serial === true) {
          const ret = await rootSubscription(param);
          for (const callback of subscriptions) {
            await callback(param);
          }
          return ret;
        } else {
          const res = await Promise.all(
            [
              rootSubscription(param),
              ...Array.from(subscriptions, (callback) => callback(param)),
            ],
          );

          // Return the root subscription value
          return res[0];
        }
      } catch (err) {
        this.onError(err);
        throw err;
      }
    }

    wait(val, timeout) {
      return (
        new Promise(
          (resolve, reject) => {
            let timeoutId;
            let timedOut = false;

            if (timeout !== undefined) {
              timeoutId =
                setTimeout(
                  () => {
                    timedOut = true;
                    listener.unsubscribe();
                    reject(
                      new Error(
                        'Timed out after waiting ' +
                        timeout +
                        'ms for ' +
                        this.name,
                      ),
                    );
                  },
                  timeout,
                );
            }

            const listener = this.subscribe(
              (param) => {
                if (timedOut) {
                  return val;
                }

                if (timeoutId !== undefined) {
                  clearTimeout(timeoutId);
                }

                listener.unsubscribe();
                resolve(param);
                return val;
              },
            );
          },
        )
      );
    }

    async callOptional(param) {
      if (this.rootSubscription === undefined) {
        return undefined;
      } else {
        return this.call(param);
      }
    }

    subscribe(callback, makeRoot) {
      if (this.options.unique === true && this.subscriptions.size !== 0) {
        throw new Error('Event ' +
        this.name +
        ' only allows a single subscription');
      }

      if (this.rootSubscription === callback || this.subscriptions.has(callback)) {
        throw new Error('Cannot double subscribe a callback');
      }

      if (this.rootSubscription === undefined) {
        this.rootSubscription = callback;
      } else if (makeRoot === true) {
        this.subscriptions.add(this.rootSubscription);
        this.rootSubscription = callback;
      } else {
        this.subscriptions.add(callback);
      }

      this.onSubscriptionChange();

      return (
        {
          unsubscribe: () => {
            this.unsubscribe(callback);
          },
        }
      );
    }

    unsubscribe(callback) {
      if (this.subscriptions.has(callback)) {
        this.subscriptions.delete(callback);
        this.onSubscriptionChange();
        return undefined;
      }

      // If this callback was the root subscription, then set it to the next one
      if (callback === this.rootSubscription) {
        this.rootSubscription = Array.from(this.subscriptions)[0];
        this.onSubscriptionChange();
        return undefined;
      }

      throw new Error('Not a current subscription');
    }
  }

  // project-rome/@romejs/events/BridgeError.ts
class ___R$project$rome$$romejs$events$BridgeError_ts$default extends Error {
    constructor(message, bridge) {
      super(message);
      this.bridge = bridge;
    }
  }

  // project-rome/@romejs/events/BridgeEvent.ts
function ___R$$priv$project$rome$$romejs$events$BridgeEvent_ts$validateDirection(
    // rome-suppress lint/noExplicitAny
    event,
    eventDirection,
    bridgeType,
    verb,
  ) {
    if (event.direction === eventDirection && event.bridge.type === bridgeType) {
      throw (
        new Error(
          'The ' +
          eventDirection +
          ' event "' +
          event.name +
          '" cannot be ' +
          verb +
          ' by a ' +
          bridgeType +
          ' bridge',
        )
      );
    }
  }

  class ___R$project$rome$$romejs$events$BridgeEvent_ts$default extends ___R$project$rome$$romejs$events$Event_ts$default {
    constructor(opts, bridge) {
      super(opts);

      this.bridge = bridge;
      this.requestCallbacks = new Map();
      this.direction = opts.direction;
    }

    clear() {
      super.clear();
      this.requestCallbacks.clear();
    }

    end(err) {
      for (const {reject} of this.requestCallbacks.values()) {
        reject(err);
      }
    }

    onSubscriptionChange() {
      ___R$$priv$project$rome$$romejs$events$BridgeEvent_ts$validateDirection(this, 'server->client', 'client', 'subscribed');
      ___R$$priv$project$rome$$romejs$events$BridgeEvent_ts$validateDirection(this, 'server<-client', 'server', 'subscribed');
      this.bridge.sendSubscriptions();
    }

    dispatchRequest(param) {
      return super.call(param);
    }

    dispatchResponse(id, data) {
      const callbacks = this.requestCallbacks.get(id);
      if (!callbacks) {
        // ???
        return undefined;
      }

      this.requestCallbacks.delete(id);

      if (data.responseStatus === 'success') {
        // @ts-ignore
        callbacks.resolve(data.value);
      } else if (data.responseStatus === 'error') {
        callbacks.reject(this.bridge.buildError(data.value, data.metadata));
      } else {
        // ???
      }

      if (callbacks.completed !== undefined) {
        callbacks.completed();
      }
    }

    hasSubscribers() {
      return this.bridge.listeners.has(this.name);
    }

    validateCanSend() {
      ___R$$priv$project$rome$$romejs$events$BridgeEvent_ts$validateDirection(this, 'server<-client', 'client', 'called');
      ___R$$priv$project$rome$$romejs$events$BridgeEvent_ts$validateDirection(this, 'server->client', 'server', 'called');
    }

    send(param) {
      if (!this.hasSubscribers()) {
        // No point in sending over a subscription that doesn't have a listener
        return undefined;
      }

      this.validateCanSend();
      this.bridge.assertAlive();
      this.bridge.sendMessage(
        {
          type: 'request',
          event: this.name,
          param,
          priority: false,
        },
      );
    }

    async call(param, opts = {}) {
      const {priority = false, timeout} = opts;
      this.validateCanSend();

      try {
        return (
          await new Promise(
            (resolve, reject) => {
              this.bridge.assertAlive();

              const id = this.bridge.getNextMessageId();

              let completed;
              if (timeout !== undefined) {
                const timeoutId = setTimeout(
                  () => {
                    // Remove the request callback
                    this.requestCallbacks.delete(id);

                    // Reject the promise
                    reject(
                      new ___R$project$rome$$romejs$events$BridgeError_ts$default(
                        'Timeout of ' +
                        String(timeout) +
                        'ms for ' +
                        this.name +
                        '(' +
                        String(
                          JSON.stringify(param),
                        ) +
                        ') event exceeded',
                        this.bridge,
                      ),
                    );
                  },
                  timeout,
                );

                // Cancel the timeout if the response returns before the timer
                completed =
                  () => {
                    clearTimeout(timeoutId);
                  };
              }

              this.requestCallbacks.set(
                id,
                {
                  completed,
                  reject,
                  resolve,
                },
              );

              this.bridge.sendMessage(
                {
                  id,
                  event: this.name,
                  param,
                  type: 'request',
                  priority,
                },
              );
            },
          )
        );
      } catch (err) {
        this.onError(err);
        throw err;
      }
    }
  }

  // project-rome/@romejs/codec-source-map/base64.ts
const ___R$project$rome$$romejs$codec$source$map$base64_ts = {
    encode: ___R$project$rome$$romejs$codec$source$map$base64_ts$encode,
    encodeVLQ: ___R$project$rome$$romejs$codec$source$map$base64_ts$encodeVLQ,
    decode: ___R$project$rome$$romejs$codec$source$map$base64_ts$decode,
    decodeVLQ: ___R$project$rome$$romejs$codec$source$map$base64_ts$decodeVLQ,
  };
  /**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from 'this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * 'AS IS' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

  const ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

  /**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
  function ___R$project$rome$$romejs$codec$source$map$base64_ts$encode(number) {
    if (0 <= number && number < ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$intToCharMap.length) {
      return ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$intToCharMap[number];
    } else {
      throw new TypeError('Must be between 0 and 63: ' +
      number);
    }
  }

  // A single base 64 digit can contain 6 bits of data. For the base 64 variable

  // length quantities we use in the source map spec, the first bit is the sign,

  // the next four bits are the actual value, and the 6th bit is the

  // continuation bit. The continuation bit tells us whether there are more

  // digits in this value following this digit.

  //

  //   Continuation

  //   |    Sign

  //   |    |

  //   V    V

  //   101011
  const ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$VLQ_BASE_SHIFT = 5;

  // binary: 100000
  const ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$VLQ_BASE = 1 << ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$VLQ_BASE_SHIFT;

  // binary: 011111
  const ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$VLQ_BASE_MASK = ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$VLQ_BASE - 1;

  // binary: 100000
  const ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$VLQ_CONTINUATION_BIT = ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$VLQ_BASE;

  /**
 * Converts from 'a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
  function ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }

  /**
 * Converts to a two-complement value from 'a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
  // eslint-disable-next-line no-unused-vars
  function ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$fromVLQSigned(value) {
    const isNegative = (value & 1) === 1;
    const shifted = value >> 1;
    return isNegative ? -shifted : shifted;
  }

  /**
 * Returns the base 64 VLQ encoded value.
 */
  function ___R$project$rome$$romejs$codec$source$map$base64_ts$encodeVLQ(value) {
    let encoded = '';
    let vlq = ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$toVLQSigned(value);

    do {
      let digit = vlq & ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$VLQ_BASE_MASK;
      vlq >>>= ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the

        // continuation bit is marked.
        digit |= ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$VLQ_CONTINUATION_BIT;
      }
      encoded += ___R$project$rome$$romejs$codec$source$map$base64_ts$encode(digit);
    } while (vlq > 0);

    return encoded;
  }

  function ___R$project$rome$$romejs$codec$source$map$base64_ts$decode(charCode) {
    const uppercaseA = 65; // 'A'
    const uppercaseZ = 90; // 'Z'
    const lowercaseA = 97; // 'a'
    const lowercaseZ = 122; // 'z'
    const zero = 48; // '0'
    const nine = 57; // '9'
    const plus = 43; // '+'
    const slash = 47; // '/'
    const lowercaseOffset = 26;
    const numberOffset = 52;

    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
    if (uppercaseA <= charCode && charCode <= uppercaseZ) {
      return charCode - uppercaseA;
    }

    // 26 - 51: abcdefghijklmnopqrstuvwxyz
    if (lowercaseA <= charCode && charCode <= lowercaseZ) {
      return charCode - lowercaseA + lowercaseOffset;
    }

    // 52 - 61: 0123456789
    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }

    // 62: +
    if (charCode === plus) {
      return 62;
    }

    // 63: /
    if (charCode === slash) {
      return 63;
    }

    // Invalid base64 digit.
    return -1;
  }

  function ___R$project$rome$$romejs$codec$source$map$base64_ts$decodeVLQ(aStr, aIndex) {
    let strLen = aStr.length;
    let result = 0;
    let shift = 0;
    let continuation = false;
    let digit;

    do {
      if (aIndex >= strLen) {
        throw new Error('Expected more digits in base 64 VLQ value.');
      }

      digit = ___R$project$rome$$romejs$codec$source$map$base64_ts$decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error('Invalid base64 digit: ' +
        aStr.charAt(aIndex - 1));
      }

      continuation = !!(digit & ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$VLQ_CONTINUATION_BIT);
      digit &= ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$VLQ_BASE_SHIFT;
    } while (continuation);

    return [___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$fromVLQSigned(result), aIndex];
  }

  // project-rome/@romejs/codec-source-map/util.ts
function ___R$$priv$project$rome$$romejs$codec$source$map$util_ts$strcmp(a, b) {
    if (a === b) {
      return 0;
    }

    if (a === undefined) {
      return 1;
    }

    if (b === undefined) {
      return -1;
    }

    if (a > b) {
      return 1;
    }

    return -1;
  }

  /**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
  function ___R$project$rome$$romejs$codec$source$map$util_ts$compareByGeneratedPositionsInflated(
    mappingA,
    mappingB,
  ) {
    let cmp = ___R$project$rome$$romejs$ob1$index_ts$get1(mappingA.generated.line) - ___R$project$rome$$romejs$ob1$index_ts$get1(mappingB.generated.line);
    if (cmp !== 0) {
      return cmp;
    }

    cmp = ___R$project$rome$$romejs$ob1$index_ts$get0(mappingA.generated.column) - ___R$project$rome$$romejs$ob1$index_ts$get0(mappingB.generated.column);
    if (cmp !== 0) {
      return cmp;
    }

    cmp = ___R$$priv$project$rome$$romejs$codec$source$map$util_ts$strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }

    if (mappingA.original == null) {
      if (mappingB.original != null) {
        return 1;
      }
    } else if (mappingB.original == null) {
      return -1;
    } else {
      cmp = ___R$project$rome$$romejs$ob1$index_ts$get1(mappingA.original.line) - ___R$project$rome$$romejs$ob1$index_ts$get1(mappingB.original.line);
      if (cmp !== 0) {
        return cmp;
      }

      cmp = ___R$project$rome$$romejs$ob1$index_ts$get0(mappingA.original.column) - ___R$project$rome$$romejs$ob1$index_ts$get0(mappingB.original.column);
      if (cmp !== 0) {
        return cmp;
      }
    }

    return ___R$$priv$project$rome$$romejs$codec$source$map$util_ts$strcmp(mappingA.name, mappingB.name);
  }

  function ___R$project$rome$$romejs$codec$source$map$util_ts$toRelativeUrl(root, path) {
    if (root === '') {
      root = '.';
    }

    root = root.replace(/\/$/, '');

    // It is possible for the path to be above the root. In this case, simply

    // checking whether the root is a prefix of the path won't work. Instead, we

    // need to remove components from the root one by one, until either we find

    // a prefix that fits, or we run out of components to remove.
    let level = 0;
    while (path.indexOf(root +
    '/') !== 0) {
      const index = root.lastIndexOf('/');
      if (index < 0) {
        return path;
      }

      // If the only part of the root that is left is the scheme (i.e. http://,

      // file:///, etc.), one or more slashes (/), or simply nothing at all, we

      // have exhausted all components, so the path is not relative to the root.
      root = root.slice(0, index);
      if (root.match(/^([^\/]+:\/)?\/*$/)) {
        return path;
      }

      ++level;
    }

    // Make sure we add a '../' for each component we removed from the root.
    return Array(level + 1).join('../') + path.substr(root.length + 1);
  }

  // project-rome/@romejs/codec-source-map/ArraySet.ts
class ___R$project$rome$$romejs$codec$source$map$ArraySet_ts$default {
    constructor() {
      this.array = [];
      this.set = new Map();
    }

    /**
   * Static method for creating ArraySet instances from 'an existing array.
   */
    static fromArray(array, allowDuplicates) {
      const set = new ___R$project$rome$$romejs$codec$source$map$ArraySet_ts$default();
      for (const item of array) {
        set.add(item, allowDuplicates);
      }
      return set;
    }

    /**
   * Add the given string to this set.
   */
    add(str, allowDuplicates) {
      const isDuplicate = this.has(str);
      const idx = this.array.length;

      if (isDuplicate === false || allowDuplicates === true) {
        this.array.push(str);
      }

      if (isDuplicate === false) {
        this.set.set(str, idx);
      }
    }

    /**
   * Is the given string a member of this set?
   */
    has(str) {
      return this.set.has(str);
    }

    /**
   * What is the index of the given string in the array?
   */
    indexOf(str) {
      const idx = this.set.get(str);
      if (idx === undefined || idx < 0) {
        throw new Error(str +
        ' is not in the set');
      }
      return idx;
    }

    /**
   * What is the element at the given index?
   */
    at(idx) {
      if (idx >= 0 && idx < this.array.length) {
        return this.array[idx];
      } else {
        throw new Error('No element indexed by ' +
        idx);
      }
    }

    /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
    toArray() {
      return this.array.slice();
    }
  }

  // project-rome/@romejs/codec-source-map/MappingList.ts
/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
  function ___R$$priv$project$rome$$romejs$codec$source$map$MappingList_ts$generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    const lineA = mappingA.generated.line;
    const lineB = mappingB.generated.line;
    const columnA = mappingA.generated.column;
    const columnB = mappingB.generated.column;
    return (
      lineB > lineA || lineB == lineA && columnB >= columnA ||
      ___R$project$rome$$romejs$codec$source$map$util_ts$compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0
    );
  }

  /**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a negligible overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
  class ___R$project$rome$$romejs$codec$source$map$MappingList_ts$default {
    constructor() {
      this.array = [];
      this.sorted = true;
      this.last =
        {
          generated: {line: ___R$project$rome$$romejs$ob1$index_ts$number1Neg1, column: ___R$project$rome$$romejs$ob1$index_ts$number0},
          // TODO: original: undefined
          original: {line: ___R$project$rome$$romejs$ob1$index_ts$number1Neg1, column: ___R$project$rome$$romejs$ob1$index_ts$number0},
          source: undefined,
          name: undefined,
        };
    }

    /**
   * Add the given source mapping.
   */
    add(mapping) {
      if (___R$$priv$project$rome$$romejs$codec$source$map$MappingList_ts$generatedPositionAfter(this.last, mapping)) {
        this.last = mapping;
        this.array.push(mapping);
      } else {
        this.sorted = false;
        this.array.push(mapping);
      }
    }

    /**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */
    toArray() {
      if (this.sorted === false) {
        this.array.sort(___R$project$rome$$romejs$codec$source$map$util_ts$compareByGeneratedPositionsInflated);
        this.sorted = true;
      }
      return this.array;
    }
  }

  // project-rome/@romejs/codec-source-map/SourceMapGenerator.ts
class ___R$project$rome$$romejs$codec$source$map$SourceMapGenerator_ts$default {
    constructor(args) {
      this.file = args.file;
      this.sourceRoot = args.sourceRoot;

      this.sourcesContents = new Map();
      this.map = undefined;
      this.sources = new ___R$project$rome$$romejs$codec$source$map$ArraySet_ts$default();
      this.names = new ___R$project$rome$$romejs$codec$source$map$ArraySet_ts$default();
      this.mappings = new ___R$project$rome$$romejs$codec$source$map$MappingList_ts$default();
    }

    assertUnlocked() {
      if (this.map !== undefined) {
        throw (
          new Error(
            'Source map has already been materialized, toJSON() should be your final call',
          )
        );
      }
    }

    /**
   * Add a single mapping from 'original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
    addMapping(mapping) {
      this.assertUnlocked();

      const {name, source} = mapping;

      this.validatePosition(
        'generated',
        mapping.generated.line,
        mapping.generated.column,
      );

      if (mapping.original) {
        this.validatePosition(
          'original',
          mapping.original.line,
          mapping.original.column,
        );
      }

      if (source !== undefined) {
        this.sources.add(source);
      }

      if (name !== undefined) {
        this.names.add(name);
      }

      this.mappings.add(mapping);
    }

    /**
   * Set the source content for a source file.
   */
    setSourceContent(source, sourceContent) {
      this.assertUnlocked();

      if (this.sourceRoot !== undefined) {
        source = ___R$project$rome$$romejs$codec$source$map$util_ts$toRelativeUrl(this.sourceRoot, source);
      }

      if (sourceContent !== undefined) {
        // Add the source content to the _sourcesContents map.
        this.sourcesContents.set(source, sourceContent);
      } else {
        // Remove the source file from the _sourcesContents map.
        this.sourcesContents.delete(source);
      }
    }

    validatePosition(key, line, column) {
      if (___R$project$rome$$romejs$ob1$index_ts$get1(line) <= 0) {
        throw new Error(key +
        ' line should be >= 1 but is ' +
        line);
      }

      if (___R$project$rome$$romejs$ob1$index_ts$get0(column) < 0) {
        throw new Error(key +
        ' column should be >= 0 but is ' +
        column);
      }
    }

    /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
    serializeMappings() {
      let previousGeneratedColumn = ___R$project$rome$$romejs$ob1$index_ts$number0;
      let previousGeneratedLine = ___R$project$rome$$romejs$ob1$index_ts$number1;
      let previousOriginalColumn = ___R$project$rome$$romejs$ob1$index_ts$number0;
      let previousOriginalLine = ___R$project$rome$$romejs$ob1$index_ts$number1;
      let previousName = 0;
      let previousSource = 0;
      let result = '';

      const mappings = this.mappings.toArray();
      for (let i = 0;
      i < mappings.length;
      i++) {
        const mapping = mappings[i];
        let next = '';

        if (mapping.generated.line !== previousGeneratedLine) {
          previousGeneratedColumn = ___R$project$rome$$romejs$ob1$index_ts$number0;
          while (mapping.generated.line !== previousGeneratedLine) {
            next += ';';
            previousGeneratedLine = ___R$project$rome$$romejs$ob1$index_ts$inc(previousGeneratedLine);
          }
        } else if (i > 0) {
          if (!___R$project$rome$$romejs$codec$source$map$util_ts$compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }

        next +=
          ___R$project$rome$$romejs$codec$source$map$base64_ts.encodeVLQ(
            ___R$project$rome$$romejs$ob1$index_ts$get0(mapping.generated.column) -
            ___R$project$rome$$romejs$ob1$index_ts$get0(
              previousGeneratedColumn,
            ),
          );
        previousGeneratedColumn = mapping.generated.column;

        if (mapping.source !== undefined) {
          const sourceIdx = this.sources.indexOf(mapping.source);
          next += ___R$project$rome$$romejs$codec$source$map$base64_ts.encodeVLQ(sourceIdx - previousSource);
          previousSource = sourceIdx;

          if (mapping.original) {
            next +=
              ___R$project$rome$$romejs$codec$source$map$base64_ts.encodeVLQ(
                ___R$project$rome$$romejs$ob1$index_ts$get1(mapping.original.line) -
                ___R$project$rome$$romejs$ob1$index_ts$get1(
                  previousOriginalLine,
                ),
              );
            previousOriginalLine = mapping.original.line;

            next +=
              ___R$project$rome$$romejs$codec$source$map$base64_ts.encodeVLQ(
                ___R$project$rome$$romejs$ob1$index_ts$get0(mapping.original.column) -
                ___R$project$rome$$romejs$ob1$index_ts$get0(
                  previousOriginalColumn,
                ),
              );
            previousOriginalColumn = mapping.original.column;

            if (mapping.name !== undefined) {
              const nameIdx = this.names.indexOf(mapping.name);
              next += ___R$project$rome$$romejs$codec$source$map$base64_ts.encodeVLQ(nameIdx - previousName);
              previousName = nameIdx;
            }
          }

          // TODO: else, assert mapping.name is undefined since it can't be encoded without an original position
        }

        // TODO: else, assert mapping.original is undefined since it can't be encoded without a source
        result += next;
      }

      return result;
    }

    generateSourcesContent(sources, sourceRoot) {
      return (
        sources.map(
          (source) => {
            if (sourceRoot !== undefined) {
              source = ___R$project$rome$$romejs$codec$source$map$util_ts$toRelativeUrl(sourceRoot, source);
            }
            const content = this.sourcesContents.get(source);
            if (content === undefined) {
              throw new Error('Expected content');
            }
            return content;
          },
        )
      );
    }

    /**
   * Externalize the source map.
   */
    toJSON() {
      if (this.map !== undefined) {
        return this.map;
      }

      const sources = this.sources.toArray();
      this.map =
        {
          version: 3,
          file: this.file,
          names: this.names.toArray(),
          mappings: this.serializeMappings(),
          sourceRoot: this.sourceRoot,
          sources,
          sourcesContent: this.generateSourcesContent(sources, this.sourceRoot),
        };
      return this.map;
    }

    toComment() {
      const jsonMap = this.toString();
      const base64Map = new Buffer(jsonMap).toString('base64');
      const comment = '//# sourceMappingURL=data:application/json;charset=utf-8;base64,' +
      base64Map;
      return comment;
    }

    /**
   * Render the source map being generated to a string.
   */
    toString() {
      return JSON.stringify(this.toJSON());
    }
  }

  // project-rome/@romejs/codec-source-map/SourceMapConsumer.ts
function ___R$$priv$project$rome$$romejs$codec$source$map$SourceMapConsumer_ts$getCacheKey(line, column) {
    return String(line) +
    ':' +
    String(column);
  }

  class ___R$project$rome$$romejs$codec$source$map$SourceMapConsumer_ts$default {
    constructor(map) {
      this.map = map;
      this.mappings = undefined;
    }

    static charIsMappingSeparator(str, index) {
      const c = str.charAt(index);
      return c === ';' || c === ',';
    }

    static parseMappings(sourceMap) {
      const rawStr = sourceMap.mappings;
      const map = new Map();

      let generatedLine = ___R$project$rome$$romejs$ob1$index_ts$number1;
      let previousGeneratedColumn = ___R$project$rome$$romejs$ob1$index_ts$number0;
      let previousOriginalLine = ___R$project$rome$$romejs$ob1$index_ts$number1;
      let previousOriginalColumn = ___R$project$rome$$romejs$ob1$index_ts$number0;
      let previousSource = 0;
      let previousName = 0;
      let length = rawStr.length;
      let index = 0;
      let cachedSegments = {};
      let value;

      while (index < length) {
        const char = rawStr[index];
        if (char === ';') {
          generatedLine = ___R$project$rome$$romejs$ob1$index_ts$inc(generatedLine);
          index++;
          previousGeneratedColumn = ___R$project$rome$$romejs$ob1$index_ts$number0;
        } else if (char === ',') {
          index++;
        } else {
          const mapping = {
            generatedLine,
            generatedColumn: ___R$project$rome$$romejs$ob1$index_ts$number0,
            source: undefined,
            originalLine: ___R$project$rome$$romejs$ob1$index_ts$number1,
            originalColumn: ___R$project$rome$$romejs$ob1$index_ts$number0,
            name: undefined,
          };

          // Because each offset is encoded relative to the previous one,

          // many segments often have the same encoding. We can exploit this

          // fact by caching the parsed variable length fields of each segment,

          // allowing us to avoid a second parse if we encounter the same

          // segment again.
          let end = index;
          for (;
          end < length;
          end++) {
            if (___R$project$rome$$romejs$codec$source$map$SourceMapConsumer_ts$default.charIsMappingSeparator(rawStr, end)) {
              break;
            }
          }
          const str = rawStr.slice(index, end);

          let segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              [value, index] = ___R$project$rome$$romejs$codec$source$map$base64_ts$decodeVLQ(rawStr, index);
              segment.push(value);
            }

            if (segment.length === 2) {
              throw new Error('Found a source, but no line and column');
            }

            if (segment.length === 3) {
              throw new Error('Found a source and line, but no column');
            }

            cachedSegments[str] = segment;
          }

          // Generated column
          mapping.generatedColumn = ___R$project$rome$$romejs$ob1$index_ts$add(previousGeneratedColumn, segment[0]);
          previousGeneratedColumn = mapping.generatedColumn;

          if (segment.length > 1) {
            // Original source
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];

            // Original line
            const newOriginalLine = ___R$project$rome$$romejs$ob1$index_ts$add(previousOriginalLine, segment[2]);
            previousOriginalLine = newOriginalLine;

            // Lines are stored 0-based
            mapping.originalLine = ___R$project$rome$$romejs$ob1$index_ts$add(newOriginalLine, 1);

            // Original column
            const newOriginalColumn = ___R$project$rome$$romejs$ob1$index_ts$add(previousOriginalColumn, segment[3]);
            mapping.originalColumn = newOriginalColumn;
            previousOriginalColumn = newOriginalColumn;

            if (segment.length > 4) {
              // Original name
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }

          map.set(
            ___R$$priv$project$rome$$romejs$codec$source$map$SourceMapConsumer_ts$getCacheKey(mapping.generatedLine, mapping.generatedColumn),
            mapping,
          );
        }
      }

      return map;
    }

    getMappings() {
      if (this.mappings === undefined) {
        const mappings = ___R$project$rome$$romejs$codec$source$map$SourceMapConsumer_ts$default.parseMappings(this.map);
        this.mappings = mappings;
        return mappings;
      } else {
        return this.mappings;
      }
    }

    approxOriginalPositionFor(line, column) {
      while (___R$project$rome$$romejs$ob1$index_ts$get0(column) >= 0) {
        const mapping = this.exactOriginalPositionFor(line, column);
        if (mapping === undefined) {
          column = ___R$project$rome$$romejs$ob1$index_ts$dec(column);
          continue;
        } else {
          return mapping;
        }
      }

      return undefined;
    }

    exactOriginalPositionFor(line, column) {
      const key = ___R$$priv$project$rome$$romejs$codec$source$map$SourceMapConsumer_ts$getCacheKey(line, column);
      const mapping = this.getMappings().get(key);
      if (mapping === undefined) {
        return undefined;
      }

      const source = mapping.source == undefined
        ? this.map.file : this.map.sources[mapping.source];
      if (source === undefined) {
        throw new Error('Mapping provided unknown source');
      }

      return (
        {
          source,
          line: mapping.originalLine,
          column: mapping.originalColumn,
          name: mapping.name === undefined ? undefined : this.map.names[mapping.name],
        }
      );
    }
  }

  // project-rome/@romejs/codec-source-map/types.ts


  // project-rome/@romejs/codec-source-map/index.ts


  // project-rome/@romejs/v8/types.ts
const ___R$project$rome$$romejs$v8$types_ts = {
  };
  const ___R$$priv$project$rome$$romejs$v8$types_ts$inspector = require(
    'inspector',
  );

  // project-rome/@romejs/v8/errors.ts
const ___R$project$rome$$romejs$v8$errors_ts = {
    get ERROR_FRAMES_PROP() {
      return (
        ___R$project$rome$$romejs$v8$errors_ts$ERROR_FRAMES_PROP
      );
    },

    get ERROR_ADVICE_PROP() {
      return (
        ___R$project$rome$$romejs$v8$errors_ts$ERROR_ADVICE_PROP
      );
    },

    get ERROR_POP_FRAMES_PROP() {
      return (
        ___R$project$rome$$romejs$v8$errors_ts$ERROR_POP_FRAMES_PROP
      );
    },

    get NativeStructuredError() {
      return (
        ___R$project$rome$$romejs$v8$errors_ts$NativeStructuredError
      );
    },

    createErrorFromStructure: ___R$project$rome$$romejs$v8$errors_ts$createErrorFromStructure,
    getErrorStructure: ___R$project$rome$$romejs$v8$errors_ts$getErrorStructure,
    getSourceLocationFromErrorFrame: ___R$project$rome$$romejs$v8$errors_ts$getSourceLocationFromErrorFrame,
  };
  Object.keys(
    ___R$project$rome$$romejs$v8$types_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$v8$errors_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$v8$types_ts[key]
            );
          },
        },
      );
    },
  );
  const ___R$project$rome$$romejs$v8$errors_ts$ERROR_FRAMES_PROP = Symbol();
  const ___R$project$rome$$romejs$v8$errors_ts$ERROR_ADVICE_PROP = Symbol();
  const ___R$project$rome$$romejs$v8$errors_ts$ERROR_POP_FRAMES_PROP = Symbol();

  class ___R$project$rome$$romejs$v8$errors_ts$NativeStructuredError extends Error {
    constructor(struct) {
      super(struct.message);
      this.name = struct.name === undefined ? 'Error' : struct.name;
      this.stack = struct.stack;

      this[___R$project$rome$$romejs$v8$errors_ts$ERROR_FRAMES_PROP] = struct.frames;
      this[___R$project$rome$$romejs$v8$errors_ts$ERROR_ADVICE_PROP] = struct.advice;
      this[___R$project$rome$$romejs$v8$errors_ts$ERROR_POP_FRAMES_PROP] = struct.framesToPop;
    }
  }

  function ___R$project$rome$$romejs$v8$errors_ts$createErrorFromStructure(struct) {
    return new ___R$project$rome$$romejs$v8$errors_ts$NativeStructuredError(struct);
  }

  function ___R$project$rome$$romejs$v8$errors_ts$getErrorStructure(err) {
    let name = 'Error';
    let message = 'Unknown message';
    let stack = undefined;
    let frames = [];
    let advice = [];
    let framesToPop = 0;
    let looksLikeValidError = false;

    if (___R$project$rome$$romejs$typescript$helpers$index_ts$isPlainObject(
      err,
    )) {
      if (typeof err.name === 'string') {
        looksLikeValidError = true;
        name = err.name;
      }

      if (typeof err.message === 'string') {
        looksLikeValidError = true;
        message = err.message;
      }

      if (typeof err.stack === 'string') {
        looksLikeValidError = true;
        stack = err.stack;
      }

      if (Array.isArray(err[___R$project$rome$$romejs$v8$errors_ts$ERROR_FRAMES_PROP])) {
        // @ts-ignore
        frames = err[___R$project$rome$$romejs$v8$errors_ts$ERROR_FRAMES_PROP];
      }

      if (Array.isArray(err[___R$project$rome$$romejs$v8$errors_ts$ERROR_ADVICE_PROP])) {
        // @ts-ignore
        advice = err[___R$project$rome$$romejs$v8$errors_ts$ERROR_ADVICE_PROP];
      }

      const _framesToPop = err[___R$project$rome$$romejs$v8$errors_ts$ERROR_POP_FRAMES_PROP];
      if (typeof _framesToPop === 'number') {
        framesToPop = _framesToPop;
      }
    }

    if (!looksLikeValidError) {
      message = 'Not an error instance: ' +
      String(err);
    }

    return (
      {
        name,
        message,
        stack,
        frames,
        advice,
        framesToPop,
      }
    );
  }

  function ___R$project$rome$$romejs$v8$errors_ts$getSourceLocationFromErrorFrame(
    frame,
  ) {
    const pos = {
      index: ___R$project$rome$$romejs$ob1$index_ts$number0Neg1,
      line: frame.lineNumber === undefined ? ___R$project$rome$$romejs$ob1$index_ts$number1 : frame.lineNumber,
      column: frame.columnNumber === undefined ? ___R$project$rome$$romejs$ob1$index_ts$number0 : frame.columnNumber,
    };

    return (
      {
        filename: frame.filename === undefined ? 'unknown' : frame.filename,
        start: pos,
        end: pos,
      }
    );
  }

  // project-rome/@romejs/v8/sourceMapManager.ts
const ___R$project$rome$$romejs$v8$sourceMapManager_ts = {
    init: ___R$project$rome$$romejs$v8$sourceMapManager_ts$init,
    teardown: ___R$project$rome$$romejs$v8$sourceMapManager_ts$teardown,
    resolveLocation: ___R$project$rome$$romejs$v8$sourceMapManager_ts$resolveLocation,
    addSourceMap: ___R$project$rome$$romejs$v8$sourceMapManager_ts$addSourceMap,
    addSourceMapFactory: ___R$project$rome$$romejs$v8$sourceMapManager_ts$addSourceMapFactory,
    getSourceMap: ___R$project$rome$$romejs$v8$sourceMapManager_ts$getSourceMap,
  };

  let ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$inited = false;
  const ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$maps = new Map();

  // In case we want to defer the reading of a source map completely (parsing is always deferred)
  const ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$factories = new Map();

  function ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$prepareStackTrace(err, frames) {
    try {
      ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$addErrorFrames(err, frames);
      return ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$buildStackString(err);
    } catch (err2) {
      return (
        err.name +
        ': ' +
        err.message +
        '\n  Failed to generate stacktrace: ' +
        err2.message
      );
    }
  }

  function ___R$project$rome$$romejs$v8$sourceMapManager_ts$init() {
    if (!___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$inited) {
      ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$inited = true;
      Error.prepareStackTrace = ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$prepareStackTrace;
    }
  }

  function ___R$project$rome$$romejs$v8$sourceMapManager_ts$teardown() {
    Error.prepareStackTrace = undefined;
  }

  function ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$buildStackString(err) {
    const {frames} = ___R$project$rome$$romejs$v8$errors_ts$getErrorStructure(err);
    const lines = [];

    lines.push(err.name +
    ': ' +
    err.message);

    for (const frame of frames) {
      const {
        resolvedLocation,
        methodName,
        functionName,
        typeName,
        isNative,
        isAsync,
        isEval,
        isConstructor,
        filename,
        lineNumber,
        columnNumber,
      } = frame;
      const parts = [];

      if (isAsync) {
        parts.push('await');
      }

      if (isEval) {
        parts.push('eval');
      }

      if (isConstructor) {
        parts.push('new');
      }

      let name = '<anonymous';
      if (functionName !== undefined) {
        name = functionName;
      }
      if (methodName !== undefined) {
        name = methodName;
      }
      if (typeName !== undefined) {
        parts.push(typeName +
        '.' +
        name);
      } else {
        parts.push(name);
      }

      if (isNative) {
        parts.push('native');
      } else if (filename !== undefined && lineNumber !== undefined &&
        columnNumber !== undefined) {
        parts.push('(' +
        filename +
        ':' +
        lineNumber +
        ':' +
        columnNumber +
        ')');
      }

      if (resolvedLocation === false) {
        parts.push('generated source location');
      }

      lines.push('  at ' +
      parts.join(' '));
    }

    return lines.join('\n');
  }

  function ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$noNull(val) {
    if (val === null) {
      return undefined;
    } else {
      return val;
    }
  }

  function ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$addErrorFrames(
    err,

    frames,
  ) {
    if (err[___R$project$rome$$romejs$v8$errors_ts$ERROR_FRAMES_PROP]) {
      return undefined;
    }

    let builtFrames = frames.map(
      (frameApi) => {
        const filename = frameApi.getFileName();
        const lineNumber = frameApi.getLineNumber();
        const columnNumber = frameApi.getColumnNumber();

        const frame = {
          typeName: ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$noNull(frameApi.getTypeName()),
          functionName: ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$noNull(frameApi.getFunctionName()),
          methodName: ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$noNull(frameApi.getMethodName()),

          isTopLevel: frameApi.isToplevel(),
          isEval: frameApi.isEval(),
          isNative: frameApi.isNative(),
          isConstructor: frameApi.isConstructor(),

          // TODO frameApi.isAsync
          isAsync: false,

          resolvedLocation: true,

          filename: ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$noNull(filename),
          lineNumber: lineNumber == null ? undefined : ___R$project$rome$$romejs$ob1$index_ts$coerce1(lineNumber),

          // Rome expects 0-indexed columns, V8 provides 1-indexed
          columnNumber: columnNumber == null ? undefined : ___R$project$rome$$romejs$ob1$index_ts$coerce1to0(columnNumber),
        };

        if (frame.filename !== undefined && frame.lineNumber !== undefined &&
          frame.columnNumber !== undefined) {
          const {found, line, column, filename, name} = ___R$project$rome$$romejs$v8$sourceMapManager_ts$resolveLocation(
            frame.filename,
            frame.lineNumber,
            frame.columnNumber,
          );

          return (
            Object.assign(
              {
              },
              frame,
              {
                functionName: frame.functionName === undefined
                  ? name : frame.functionName,
                methodName: frame.methodName === undefined ? name : frame.methodName,
                resolvedLocation: found,
                lineNumber: line,
                columnNumber: column,
                filename,
              },
            )
          );
        } else {
          return frame;
        }
      },
    );

    // This is a property that an error object can define that will remove that amount of frames

    // This is useful for removing levels of indirection, for example, an invariant error
    const framesToProp = err[___R$project$rome$$romejs$v8$errors_ts$ERROR_POP_FRAMES_PROP];
    if (typeof framesToProp === 'number') {
      builtFrames = builtFrames.slice(framesToProp);
    }

    err[___R$project$rome$$romejs$v8$errors_ts$ERROR_FRAMES_PROP] = builtFrames;
  }

  function ___R$project$rome$$romejs$v8$sourceMapManager_ts$resolveLocation(
    filename,
    line,
    column,
  ) {
    const map = ___R$project$rome$$romejs$v8$sourceMapManager_ts$getSourceMap(filename);
    if (map === undefined) {
      return (
        {
          found: true,
          filename,
          line,
          column,
          name: undefined,
        }
      );
    }

    const resolved = map.approxOriginalPositionFor(line, column);
    if (resolved === undefined) {
      return (
        {
          found: false,
          filename,
          line,
          column,
          name: undefined,
        }
      );
    }

    return (
      {
        found: true,
        filename: resolved.source,
        line: resolved.line,
        column: resolved.column,
        name: resolved.name,
      }
    );
  }

  function ___R$project$rome$$romejs$v8$sourceMapManager_ts$addSourceMap(filename, map) {
    return ___R$project$rome$$romejs$v8$sourceMapManager_ts$addSourceMapFactory(filename, () => map);
  }

  function ___R$project$rome$$romejs$v8$sourceMapManager_ts$addSourceMapFactory(
    filename,
    factory,
  ) {
    ___R$project$rome$$romejs$v8$sourceMapManager_ts$init();

    let map;
    function factoryCapture() {
      map = factory();
      return map;
    }

    ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$factories.set(filename, factoryCapture);

    return (
      () => {
        if (___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$factories.get(filename) === factoryCapture) {
          ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$factories.delete(filename);
        }

        if (___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$maps.get(filename) === map) {
          ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$maps.delete(filename);
        }
      }
    );
  }

  function ___R$project$rome$$romejs$v8$sourceMapManager_ts$getSourceMap(filename) {
    if (___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$maps.has(filename)) {
      return ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$maps.get(filename);
    }

    const factory = ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$factories.get(filename);
    if (factory !== undefined) {
      ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$factories.delete(filename);
      const map = factory();
      const consumer = new ___R$project$rome$$romejs$codec$source$map$SourceMapConsumer_ts$default(map);
      ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$maps.set(filename, consumer);
      return consumer;
    }
  }

  // project-rome/@romejs/v8/utils.ts
const ___R$project$rome$$romejs$v8$utils_ts = {
    hrTime: ___R$project$rome$$romejs$v8$utils_ts$hrTime,
    urlToFilename: ___R$project$rome$$romejs$v8$utils_ts$urlToFilename,
  };
  function ___R$project$rome$$romejs$v8$utils_ts$hrTime() {
    const hrtime = process.hrtime(); // [seconds, nanoseconds]
    const ts = hrtime[0] * 1000000 + Math.round(hrtime[1] / 1000); // microseconds
    return ts;
  }

  const ___R$$priv$project$rome$$romejs$v8$utils_ts$FILE_PROTOCOL = 'file://';

  function ___R$project$rome$$romejs$v8$utils_ts$urlToFilename(url) {
    if (url.startsWith(___R$$priv$project$rome$$romejs$v8$utils_ts$FILE_PROTOCOL)) {
      return url.slice(___R$$priv$project$rome$$romejs$v8$utils_ts$FILE_PROTOCOL.length);
    } else {
      return url;
    }
  }

  // project-rome/@romejs/v8/Profiler.ts
const ___R$$priv$project$rome$$romejs$v8$Profiler_ts$inspector = require(
    'inspector',
  );
  class ___R$project$rome$$romejs$v8$Profiler_ts$default {
    constructor() {
      this.session = undefined;
      this.memoryInterval = undefined;
      this.memorySamples = [];
    }

    async startProfiling(samplingInterval) {
      this.session = new ___R$$priv$project$rome$$romejs$v8$Profiler_ts$inspector.Session();
      this.session.connect();

      this.memoryInterval =
        setInterval(
          () => {
            const time = ___R$project$rome$$romejs$v8$utils_ts$hrTime();
            const size = process.memoryUsage().heapUsed;
            this.memorySamples.push([time, size]);
          },
          100,
        );

      await Promise.all(
        [
          this.sendCommand(
            'Profiler.setSamplingInterval',
            {
              interval: samplingInterval,
            },
          ),
          this.sendCommand('Profiler.enable'),
          this.sendCommand('Profiler.start'),
        ],
      );
    }

    async sendCommand(method, params) {
      const {session} = this;
      if (session === undefined) {
        return Promise.reject(new Error('No current profiler session'));
      } else {
        return (
          new Promise(
            (resolve, reject) => {
              session.post(
                method,
                params,
                (err) => {
                  if (err === null) {
                    resolve();
                  } else {
                    reject(err);
                  }
                },
              );
            },
          )
        );
      }
    }

    destroy() {
      const {session} = this;
      if (session !== undefined) {
        if (this.memoryInterval !== undefined) {
          clearInterval(this.memoryInterval);
        }
        this.memorySamples = [];
        session.disconnect();
      }
    }

    async stopProfiling() {
      const {session} = this;
      if (session === undefined) {
        return Promise.reject(new Error('No current profiler session'));
      }

      const {memorySamples} = this;

      const res = await new Promise(
        (
          resolve,
          reject,
        ) => {
          session.post(
            'Profiler.stop',
            (err, params) => {
              if (err === null) {
                resolve(params);
              } else {
                reject(err);
              }
            },
          );
        },
      );

      this.destroy();

      return (
        {
          pid: process.pid,
          cpuProfile: res.profile,
          memorySamples,
        }
      );
    }
  }

  // project-rome/@romejs/v8/Trace.ts
class ___R$project$rome$$romejs$v8$Trace_ts$default {
    constructor() {
      this.tid = 0;
      this.eventId = 0;
      this.events = [];
    }

    getEventId() {
      const id = this.eventId;
      this.eventId++;
      return id;
    }

    decodeProfileSourceMap(profile) {
      // This method mutates the profile for performance/ergonomics

      // Nothing else should be relying on this so it doesn't really matter

      for (const node of profile.cpuProfile.nodes) {
        const {callFrame} = node;
        const filename = ___R$project$rome$$romejs$v8$utils_ts$urlToFilename(callFrame.url);
        const sourceMap = ___R$project$rome$$romejs$v8$sourceMapManager_ts.getSourceMap(filename);
        if (sourceMap === undefined) {
          continue;
        }

        // Call frame line numbers are 0-index while Rome is 1-indexed
        const resolved = sourceMap.approxOriginalPositionFor(
          ___R$project$rome$$romejs$ob1$index_ts$coerce0to1(
            ___R$project$rome$$romejs$ob1$index_ts$coerce0(
              callFrame.lineNumber,
            ),
          ),
          ___R$project$rome$$romejs$ob1$index_ts$coerce0(callFrame.columnNumber),
        );
        if (resolved !== undefined) {
          callFrame.url = resolved.source;
          callFrame.lineNumber = ___R$project$rome$$romejs$ob1$index_ts$get0(___R$project$rome$$romejs$ob1$index_ts$coerce1to0(resolved.line));
          callFrame.columnNumber = ___R$project$rome$$romejs$ob1$index_ts$get0(resolved.column);

          if (resolved.name !== undefined) {
            callFrame.functionName = resolved.name;
          }
        }
      }
    }

    addProfile(name, profile) {
      this.decodeProfileSourceMap(profile);

      const {startTime, endTime} = profile.cpuProfile;

      const common = {
        pid: 1,
        tid: profile.pid,
      };

      this.events.push(
        Object.assign(
          {
          },
          common,
          {
            ts: 0,
            ph: 'M',
            cat: '__metadata',
            name: 'thread_name',
            args: {name},
          },
        ),
      );

      this.events.push(
        Object.assign(
          {
          },
          common,
          {
            ph: 'P',
            name: 'CpuProfile',
            id: this.getEventId(),
            cat: 'disabled-by-default-v8.cpu_profiler',
            ts: endTime,
            args: {
              data: {
                cpuProfile: profile.cpuProfile,
              },
            },
          },
        ),
      );

      this.events.push(
        Object.assign(
          {
          },
          common,
          {
            ph: 'X',
            name: 'EvaluateScript',
            id: this.getEventId(),
            cat: 'devtools.timeline',
            ts: startTime,
            dur: endTime - startTime,
            args: {
              data: {
                url: 'rome.js',
                lineNumber: 1,
                columnNumber: 1,
                frame: '0xFFF',
              },
            },
          },
        ),
      );

      for (const [time, size] of profile.memorySamples) {
        this.events.push(
          Object.assign(
            {
            },
            common,
            {
              ts: time,
              ph: 'I',
              cat: 'disabled-by-default-devtools.timeline',
              name: 'UpdateCounters',
              args: {
                data: {
                  jsHeapSizeUsed: size,
                },
              },
              s: 't',
            },
          ),
        );
      }
    }

    build() {
      return this.events;
    }
  }

  // project-rome/@romejs/codec-json/types.ts


  // project-rome/@romejs/messages/index.ts
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

  function ___R$$priv$project$rome$$romejs$messages$index_ts$sprintf(msg, ...args) {
    return (
      msg.replace(
        /\$(\d+)/g,
        (match, num) => {
          return String(args[num]);
        },
      )
    );
  }

  function ___R$project$rome$$romejs$messages$index_ts$createMessageFactory(
    messages,
  ) {
    // @ts-ignore: TS complains about {} not being full of the possible properties in message... which is true

    // but they will be filled it by the time we return
    const obj = {};

    for (const key in messages) {
      const msg = messages[key];

      obj[key] =
        (...args) => {
          return ___R$$priv$project$rome$$romejs$messages$index_ts$sprintf.apply(null, [
            msg,
            ...args,
          ]);
        };
    }

    return obj;
  }

  // project-rome/@romejs/codec-json/messages.ts
const ___R$project$rome$$romejs$codec$json$messages_ts$default = ___R$project$rome$$romejs$messages$index_ts$createMessageFactory(
    {
      SINGLE_QUOTE_USAGE: 'You can only use double quoted strings',
      TRAILING_COMMA_VALUE: 'Trailing comma is only allowed after a value',
      UNCLOSED_STRING: 'Unclosed string',
      UNCLOSED_BLOCK_COMMENT: 'Unclosed block comment',
      MISTAKEN_ARRAY_IDENTITY: 'Trying to use an array element as an object property. Did you mean to make an object?',
      REDUNDANT_COMMA: 'Redundant comma',

      EMPTY_INPUT_IN_JSON: 'Empty input',
      PROPERTY_KEY_UNQUOTED_IN_JSON: 'Property keys must be quoted in JSON',
      IMPLICIT_OBJECT_IN_JSON: 'Objects must be wrapped in curly braces in JSON',
      COMMENTS_IN_JSON: 'Comments aren\'t allowed in JSON',
      TRAILING_COMMA_IN_JSON: 'Trailing commas aren\'t allowed in JSON',
      REGEX_IN_JSON: 'Regular expressions aren\'t allowed in JSON',
      UNKNOWN_WORD_IN_JSON: '$0 isn\'t a valid JSON word',
      STRING_NEWLINES_IN_JSON: 'Newlines aren\'t allowed in JSON, you insert a newline by escaping it like this "\\n"',
      UNDEFINED_IN_JSON: 'undefined isn\'t allowed in JSON, you could use null instead',
      BIGINT_IN_JSON: 'Bigints aren\'t allowed in JSON',
      NUMERIC_SEPARATORS_IN_JSON: 'Numeric separators are not allowed in JSON',
    },
  );

  // project-rome/@romejs/codec-json/parse.ts
// Words can't start with a digit
  function ___R$$priv$project$rome$$romejs$codec$json$parse_ts$isWordStartChar(char) {
    return ___R$project$rome$$romejs$parser$core$index_ts$isAlpha(char) || char === '_' || char === '$';
  }

  // But a digit can appear inside of a word
  function ___R$$priv$project$rome$$romejs$codec$json$parse_ts$isWordChar(char) {
    return ___R$$priv$project$rome$$romejs$codec$json$parse_ts$isWordStartChar(char) || ___R$project$rome$$romejs$parser$core$index_ts$isDigit(char);
  }

  // Check if an input string is a valid word, this is used by the stringifier to

  // determine if a property key should be quoted
  function ___R$project$rome$$romejs$codec$json$parse_ts$isValidWord(word) {
    if (word.length === 0 || ___R$$priv$project$rome$$romejs$codec$json$parse_ts$isWordStartChar(word[0]) === false) {
      return false;
    }

    for (const char of word) {
      if (___R$$priv$project$rome$$romejs$codec$json$parse_ts$isWordChar(char) === false) {
        return false;
      }
    }

    return true;
  }

  // Check if a character is a part of a string, returning false for a newline or unescaped quote char
  function ___R$$priv$project$rome$$romejs$codec$json$parse_ts$isStringValueChar(char, index, input) {
    if (char === '\n') {
      return false;
    }

    if (char === '"' && !___R$project$rome$$romejs$parser$core$index_ts$isEscaped(index, input)) {
      return false;
    }

    return true;
  }

  // Turn a path into a string key we can use
  function ___R$project$rome$$romejs$codec$json$parse_ts$toPathKey(parts) {
    // Right now this could conflict weirdly with properties with dots in them if they cause collisions

    // We have this method abstracted so we can make changes later if it's necessary (probably not worth it)
    return parts.join('.');
  }

  function ___R$$priv$project$rome$$romejs$codec$json$parse_ts$isntNewline(char) {
    return char !== '\n';
  }

  function ___R$$priv$project$rome$$romejs$codec$json$parse_ts$isntBlockCommentEnd(
    char,
    index,
    input,
  ) {
    const nextChar = input[___R$project$rome$$romejs$ob1$index_ts$get0(index) + 1];
    return char !== '*' && nextChar !== '/';
  }

  // Used for Number token validation, allow underscore as a separatore
  function ___R$$priv$project$rome$$romejs$codec$json$parse_ts$isNumberChar(char) {
    return ___R$project$rome$$romejs$parser$core$index_ts$isDigit(char) || char === '_';
  }

  const ___R$project$rome$$romejs$codec$json$parse_ts$default = ___R$project$rome$$romejs$parser$core$index_ts$createParser(
    (
      ParserCore,
    ) =>
      (() => {
        class JSONParser extends ParserCore {
          constructor(opts) {
            super(opts, 'parse/json');
            this.options = opts;
            this.ignoreWhitespaceTokens = true;

            this.hasExtensions =
              this.path !== undefined &&
                this.path.getBasename().endsWith('.rjson');

            this.pathKeys = [];
            this.paths = new Map();
            this.pathToComments = new Map();
            this.consumeDiagnosticCategory =
              opts.consumeDiagnosticCategory ===
              undefined
                ? 'parse/json' : opts.consumeDiagnosticCategory;
          }

          getPathInfo(path) {
            return this.paths.get(path.join('.'));
          }

          setComments(pathComments) {
            const key = this.pathKeys.join('.');

            const existing = this.pathToComments.get(key);
            if (existing === undefined) {
              this.pathToComments.set(key, pathComments);
            } else {
              this.pathToComments.set(
                key,
                {
                  inner: [...existing.inner, ...pathComments.inner],
                  outer: [...existing.outer, ...pathComments.outer],
                },
              );
            }
          }

          setPath(info) {
            this.paths.set(this.pathKeys.join('.'), info);
            this.pathKeys.pop();
          }

          tokenize(index, input) {
            const nextChar = input[___R$project$rome$$romejs$ob1$index_ts$get0(index) + 1];
            const char = input[___R$project$rome$$romejs$ob1$index_ts$get0(index)];

            // Line comment
            if (char === '/' && nextChar === '/') {
              const commentValueIndex = ___R$project$rome$$romejs$ob1$index_ts$add(index, 2);
              const [value] = this.readInputFrom(commentValueIndex, ___R$$priv$project$rome$$romejs$codec$json$parse_ts$isntNewline);
              // (comment content start + comment content length)
              return (
                this.finishValueToken(
                  'LineComment',
                  value,
                  ___R$project$rome$$romejs$ob1$index_ts$add(
                    commentValueIndex,
                    value.length,
                  ),
                )
              );
            }

            // BlockComment
            if (char === '/' && nextChar === '*') {
              const commentValueIndex = ___R$project$rome$$romejs$ob1$index_ts$add(index, 2);
              const [value] = this.readInputFrom(
                commentValueIndex,
                ___R$$priv$project$rome$$romejs$codec$json$parse_ts$isntBlockCommentEnd,
              );

              // (comment content start + comment content length + 2 characters for comment end)
              const endIndex = ___R$project$rome$$romejs$ob1$index_ts$add(___R$project$rome$$romejs$ob1$index_ts$add(commentValueIndex, value.length), 2);

              // Ensure the comment is closed
              if (this.input[___R$project$rome$$romejs$ob1$index_ts$get0(endIndex) - 2] !== '*' ||
              this.input[___R$project$rome$$romejs$ob1$index_ts$get0(endIndex) - 1] !== '/') {
                throw (
                  this.unexpected(
                    {
                      message: ___R$project$rome$$romejs$codec$json$messages_ts$default.UNCLOSED_BLOCK_COMMENT(),
                      start: this.getPositionFromIndex(endIndex),
                    },
                  )
                );
              }

              return this.finishValueToken('BlockComment', value, endIndex);
            }

            // Single character token starters
            switch (char) {
              case '"':
                const [value] = this.readInputFrom(___R$project$rome$$romejs$ob1$index_ts$inc(index), ___R$$priv$project$rome$$romejs$codec$json$parse_ts$isStringValueChar);

                // Check for closed string (index is the current token index + string length + closing quote + 1 for the end char)
                const end = ___R$project$rome$$romejs$ob1$index_ts$add(___R$project$rome$$romejs$ob1$index_ts$add(index, value.length), 2);
                if (input[___R$project$rome$$romejs$ob1$index_ts$get0(end) - 1] !== '"') {
                  throw (
                    this.unexpected(
                      {
                        message: ___R$project$rome$$romejs$codec$json$messages_ts$default.UNCLOSED_STRING(),
                        start: this.getPositionFromIndex(end),
                      },
                    )
                  );
                }

                // Don't allow newlines in JSON
                for (let strIndex = 0;
                strIndex < value.length;
                strIndex++) {
                  const char = value[strIndex];

                  if (char === '\n') {
                    throw (
                      this.unexpected(
                        {
                          message: ___R$project$rome$$romejs$codec$json$messages_ts$default.STRING_NEWLINES_IN_JSON(),
                          start: this.getPositionFromIndex(___R$project$rome$$romejs$ob1$index_ts$add(index, strIndex)),
                        },
                      )
                    );
                  }
                }

                // Unescape the string
                const unescaped = ___R$project$rome$$romejs$string$escape$unescapeString_ts$default(
                  value,
                  (message, strIndex) => {
                    throw (
                      this.unexpected(
                        {
                          message,
                          start: this.getPositionFromIndex(___R$project$rome$$romejs$ob1$index_ts$add(index, strIndex)),
                        },
                      )
                    );
                  },
                );

                return this.finishValueToken('String', unescaped, end);

              case '\'':
                throw (
                  this.unexpected(
                    {
                      message: ___R$project$rome$$romejs$codec$json$messages_ts$default.SINGLE_QUOTE_USAGE(),
                      start: this.getPositionFromIndex(index),
                    },
                  )
                );

              case '/':
                throw (
                  this.unexpected(
                    {
                      message: ___R$project$rome$$romejs$codec$json$messages_ts$default.REGEX_IN_JSON(),
                      start: this.getPositionFromIndex(index),
                    },
                  )
                );

              case ',':
                return this.finishToken('Comma');

              case '.':
                return this.finishToken('Dot');

              case '-':
                return this.finishToken('Minus');

              case '+':
                return this.finishToken('Plus');

              case ':':
                return this.finishToken('Colon');

              case '{':
                return this.finishToken('BraceOpen');

              case '}':
                return this.finishToken('BraceClose');

              case '[':
                return this.finishToken('BracketOpen');

              case ']':
                return this.finishToken('BracketClose');
            }

            // Numbers
            if (___R$project$rome$$romejs$parser$core$index_ts$isDigit(char)) {
              const value = this.removeUnderscores(
                index,
                this.readInputFrom(
                  index,
                  ___R$$priv$project$rome$$romejs$codec$json$parse_ts$isNumberChar,
                )[0],
              );
              const num = Number(value);
              return this.finishValueToken('Number', num, ___R$project$rome$$romejs$ob1$index_ts$add(index, value.length));
            }

            // Word - boolean, undefined etc
            if (___R$$priv$project$rome$$romejs$codec$json$parse_ts$isWordStartChar(char)) {
              const [value] = this.readInputFrom(index, ___R$$priv$project$rome$$romejs$codec$json$parse_ts$isWordChar);
              return this.finishValueToken('Word', value, ___R$project$rome$$romejs$ob1$index_ts$add(index, value.length));
            }

            // Unknown character
            return undefined;
          }

          parseObject(firstKeyStart, firstKey) {
            const obj = {};

            let innerComments = [];
            let isFirstProp = true;

            // These are comments that the next property should take in case the previous accidently took them
            let nextLeadingComments;

            do {
              if (this.matchToken('BraceClose')) {
                break;
              }

              // Eat all the comments that appeared before this property, it's the most common and natural place to put them,

              // and is where we'll print all comments for a property.
              let leadingComments = this.eatComments();

              // Take any leading comments that were left by the previous property
              if (nextLeadingComments !== undefined) {
                leadingComments = [...nextLeadingComments, ...leadingComments];
                nextLeadingComments = undefined;
              }

              // Throw a meainingful error for redundant commas
              if (this.matchToken('Comma')) {
                throw (
                  this.unexpected(
                    {
                      message: ___R$project$rome$$romejs$codec$json$messages_ts$default.REDUNDANT_COMMA(),
                    },
                  )
                );
              }

              // If there's no property key indicator then delegate any comments we have to object
              const hasKey = isFirstProp && firstKey !== undefined;
              if (!hasKey && !this.matchToken('String') && !this.matchToken('Word')) {
                innerComments = [...innerComments, ...leadingComments];
                break;
              }

              const keyStart = isFirstProp && firstKeyStart !== undefined
                ? firstKeyStart : this.getPosition();

              // Parse the property key
              let key;
              if (isFirstProp && firstKey !== undefined) {
                // If this is the first property and we've been given a property key then use it instead
                key = firstKey;
              } else {
                key = this.parsePropertyKey();
              }
              isFirstProp = false;

              const keyEnd = this.getPosition();
              this.expectToken('Colon');

              // Having comments before the value is a really weird place to put them, but we'll handle it

              // anyway to avoid throwing a parser error. When stringified, the comments will all be before

              // the property.
              const leadingValueComments = this.eatComments();

              this.pathKeys.push(key);

              // Parse the value.
              const valueStart = this.getPosition();
              const value = this.parseExpression();
              const valueEnd = this.getLastEndPosition();

              // Eat the comments after the expression and associate the comments with them
              let trailingValueComments = this.eatComments();

              // If the next token isn't a comma or closing brace then we've just stolen

              // the leading comments of the next property
              if (!this.matchToken('Comma') && !this.matchToken('BraceClose')) {
                nextLeadingComments = trailingValueComments;
                trailingValueComments = [];
              }

              this.setComments(
                {
                  inner: [],
                  outer: [
                    ...leadingComments,
                    ...leadingValueComments,
                    ...trailingValueComments,
                  ],
                },
              );

              this.setPath(
                {
                  keyStart,
                  keyEnd,
                  valueStart,
                  valueEnd,
                  originalValue: value,
                },
              );

              // Set the object correctly, accounting for JS weirdness
              if (key === '__proto__') {
                // Need to use defineProperty to avoid triggering the Object.prototype.__proto__ setter
                Object.defineProperty(
                  obj,
                  '__proto__',
                  {
                    value,
                    configurable: true,
                    writable: true,
                    enumerable: true,
                  },
                );
              } else {
                obj[key] = value;
              }
            } while (this.eatPropertySeparator());

            // Take any loose leading comments
            if (nextLeadingComments !== undefined) {
              innerComments = [...innerComments, ...nextLeadingComments];
            }

            // If we were passed a first key then this was an implicit object so there's no end token
            if (firstKey === undefined) {
              this.expectToken('BraceClose');
            }

            this.setComments(
              {
                inner: innerComments,
                outer: [],
              },
            );

            return obj;
          }

          // Remove underscores from 'a string, this is used for numeric separators eg. 100_000
          removeUnderscores(index, raw) {
            let str = '';

            for (let i = 0;
            i < raw.length;
            i++) {
              const char = raw[i];

              if (char === '_') {
                // Don't allow separators in JSON
                if (!this.hasExtensions) {
                  throw (
                    this.unexpected(
                      {
                        message: ___R$project$rome$$romejs$codec$json$messages_ts$default.NUMERIC_SEPARATORS_IN_JSON(),
                        start: this.getPositionFromIndex(___R$project$rome$$romejs$ob1$index_ts$inc(index)),
                      },
                    )
                  );
                }
              } else {
                str += char;
              }
            }

            return str;
          }

          eatComments() {
            const comments = [];

            while (true) {
              const token = this.getToken();

              if (token.type === 'LineComment') {
                comments.push(
                  {
                    type: 'LineComment',
                    value: token.value,
                  },
                );
              } else if (token.type === 'BlockComment') {
                comments.push(
                  {
                    type: 'BlockComment',
                    value: token.value,
                  },
                );
              } else {
                break;
              }

              // Comments aren't allowed in regular JSON
              if (!this.hasExtensions) {
                throw this.unexpected({message: ___R$project$rome$$romejs$codec$json$messages_ts$default.COMMENTS_IN_JSON()});
              }

              this.nextToken();
            }

            return comments;
          }

          parseArray() {
            this.expectToken('BracketOpen');

            const arr = [];
            let innerComments = [];
            let i = 0;

            do {
              if (this.matchToken('BracketClose')) {
                break;
              }

              // Eat all the comments before an element
              const leadingComments = this.eatComments();

              if (this.matchToken('Comma')) {
                throw (
                  this.unexpected(
                    {
                      message: ___R$project$rome$$romejs$codec$json$messages_ts$default.REDUNDANT_COMMA(),
                    },
                  )
                );
              }

              // If we're at the end of the array then associate these comments with the array
              if (this.matchToken('BracketClose')) {
                innerComments = [...innerComments, ...leadingComments];
                break;
              }

              const start = this.getPosition();
              this.pathKeys.push(i);
              i++;

              // Parse the value
              const item = this.parseExpression();
              arr.push(item);
              const end = this.getLastEndPosition();

              // Trailing comments are really weird, but let's handle them just like object properties
              const trailingComments = this.eatComments();

              this.setComments(
                {
                  outer: [...leadingComments, ...trailingComments],
                  inner: [],
                },
              );

              this.setPath(
                {
                  originalValue: item,
                  keyStart: start,
                  keyEnd: end,
                  valueStart: start,
                  valueEnd: end,
                },
              );

              // Have a meaningful error message when an object is incorrectly using brackets: ["foo": "bar"]
              if (this.matchToken('Colon')) {
                throw (
                  this.unexpected(
                    {
                      message: ___R$project$rome$$romejs$codec$json$messages_ts$default.MISTAKEN_ARRAY_IDENTITY(),
                    },
                  )
                );
              }
            } while (this.eatPropertySeparator());

            this.expectToken('BracketClose');

            this.setComments(
              {
                inner: innerComments,
                outer: [],
              },
            );

            return arr;
          }

          // Check if the current token is a property separator and eat it if necessary
          eatPropertySeparator() {
            const token = this.getToken();

            // Implicit commas are only allowed in rjson
            if (this.hasExtensions) {
              // Eat the token, don't care if we're in RJSON
              if (token.type === 'Comma') {
                this.nextToken();
              }

              // An object or array close is an instant failure

              // Doesn't matter what we're parsing since the subsequent tokens will be validated
              if (token.type === 'BraceClose' || token.type === 'BracketClose') {
                return false;
              }

              return true;
            } else {
              if (token.type !== 'Comma') {
                return false;
              }

              // Make sure this isn't a trailing comma
              const lookahead = this.lookaheadToken();
              if (lookahead.type === 'BraceClose' || lookahead.type === 'BracketClose') {
                throw this.unexpected({message: ___R$project$rome$$romejs$codec$json$messages_ts$default.TRAILING_COMMA_IN_JSON()});
              }

              this.nextToken();
              return true;
            }
          }

          parseWord(isStart) {
            const start = this.getPosition();
            const token = this.expectToken('Word');

            switch (token.value) {
              case 'true':
                return true;

              case 'false':
                return false;

              case 'null':
                return null;

              case 'undefined':
                throw this.unexpected({message: ___R$project$rome$$romejs$codec$json$messages_ts$default.UNDEFINED_IN_JSON()});
            }

            if (isStart && this.matchToken('Colon')) {
              if (this.hasExtensions) {
                return this.parseObject(start, token.value);
              } else {
                throw (
                  this.unexpected(
                    {
                      message: ___R$project$rome$$romejs$codec$json$messages_ts$default.IMPLICIT_OBJECT_IN_JSON(),
                    },
                  )
                );
              }
            }

            throw (
              this.unexpected(
                {
                  message: ___R$project$rome$$romejs$codec$json$messages_ts$default.UNKNOWN_WORD_IN_JSON(token.value),
                },
              )
            );
          }

          parseNumber() {
            const isNegative = this.eatToken('Minus') !== undefined;

            // Get a string of the current number that we'll parse later
            const token = this.expectToken('Number');
            let value = String(token.value);

            // Decimals
            if (this.eatToken('Dot')) {
              value += '.';

              const decimal = this.expectToken('Number');
              value += String(decimal.value);
            }

            // Scientific notation
            const nextToken = this.getToken();
            if (nextToken.type === 'Word' &&
              (nextToken.value === 'e' ||
              nextToken.value === 'E')) {
              value += 'e';

              // Operator
              const operator = this.nextToken();
              if (operator.type === 'Minus') {
                value += '-';
              } else if (operator.type === 'Plus') {
                value += '+';
              } else {
                throw this.unexpected();
              }

              // Factor
              this.nextToken();
              const factor = this.expectToken('Number');
              value += String(factor.value);
            }

            // BigInt
            const nextToken2 = this.getToken();
            if (nextToken2.type === 'Word' && nextToken2.value === 'n') {
              throw (
                this.unexpected(
                  {
                    message: ___R$project$rome$$romejs$codec$json$messages_ts$default.BIGINT_IN_JSON(),
                  },
                )
              );
            }

            // Turn the string into an actual number
            let num = Number(value);
            if (isNegative) {
              num = -num;
            }
            return num;
          }

          parsePropertyKey() {
            const token = this.getToken();

            switch (token.type) {
              case 'String':
                this.nextToken();
                return token.value;

              case 'Word':
                if (this.hasExtensions) {
                  this.nextToken();
                  return token.value;
                } else {
                  throw (
                    this.unexpected(
                      {
                        message: ___R$project$rome$$romejs$codec$json$messages_ts$default.PROPERTY_KEY_UNQUOTED_IN_JSON(),
                      },
                    )
                  );
                }

              default:
                throw this.unexpected();
            }
          }

          parseString(isStart) {
            const start = this.getPosition();
            const token = this.expectToken('String');

            if (isStart && this.nextToken().type === 'Colon') {
              if (this.hasExtensions) {
                return this.parseObject(start, token.value);
              } else {
                throw (
                  this.unexpected(
                    {
                      message: ___R$project$rome$$romejs$codec$json$messages_ts$default.IMPLICIT_OBJECT_IN_JSON(),
                    },
                  )
                );
              }
            } else {
              return token.value;
            }
          }

          parseExpression(isStart = false) {
            const token = this.getToken();

            switch (token.type) {
              case 'String':
                return this.parseString(isStart);

              case 'Minus':
              case 'Number':
                return this.parseNumber();

              case 'Word':
                return this.parseWord(isStart);

              case 'BracketOpen':
                return this.parseArray();

              case 'BraceOpen':
                this.nextToken();
                return this.parseObject();

              default:
                throw this.unexpected();
            }
          }

          parseEntry() {
            if (this.matchToken('EOF')) {
              if (this.hasExtensions) {
                // If we're in RJSON mode then an empty input is an implicit object
                return {};
              } else {
                throw this.unexpected({message: ___R$project$rome$$romejs$codec$json$messages_ts$default.EMPTY_INPUT_IN_JSON()});
              }
            } else {
              return this.parseExpression(true);
            }
          }

          parse() {
            let expectSyntaxError = false;

            if (!this.hasExtensions) {
              // If we're in regular JSON, try the native JSON.parse
              try {
                const value = JSON.parse(this.input);

                // Lazy parse when we need location information
                let context;
                const getContext = () => {
                  if (context === undefined) {
                    const res = this._parse();
                    context = res.context;
                    return res.context;
                  } else {
                    return context;
                  }
                };

                return (
                  {
                    context: {
                      category: this.consumeDiagnosticCategory,
                      getOriginalValue(path) {
                        return getContext().getOriginalValue(path);
                      },

                      getDiagnosticPointer(keys, target) {
                        return getContext().getDiagnosticPointer(keys, target);
                      },
                    },
                    value,
                  }
                );
              } catch (err) {
                // On syntax errors we'll fall back to our parser which is slower, but produces more meaningful errors
                if (err instanceof SyntaxError) {
                  expectSyntaxError = true;
                } else {
                  throw err;
                }
              }
            }

            const res = this._parse();

            if (expectSyntaxError) {
              throw (
                new Error(
                  'JSON.parse failed but our custom JSON parser was successful... That doesn\'t smell right',
                )
              );
            }

            return res;
          }

          _parse() {
            const leadingComments = this.eatComments();

            const expr = this.parseEntry();

            const trailingComments = this.eatComments();
            this.setComments(
              {
                inner: [],
                outer: [...leadingComments, ...trailingComments],
              },
            );

            this.finalize();

            const context = {
              category: this.consumeDiagnosticCategory,

              getDiagnosticPointer: (
                keys,
                target,
              ) => {
                const info = this.getPathInfo(keys);
                if (info === undefined) {
                  return;
                }

                let start = info.keyStart;
                let end = info.valueEnd;

                if (target === 'key') {
                  end = info.keyEnd;
                }

                if (target === 'value' || target === 'inner-value') {
                  start = info.valueStart;
                }

                let loc = {
                  filename: this.filename,
                  start,
                  end,
                };

                if (target === 'inner-value') {
                  const originalValue = context.getOriginalValue(keys);

                  // Remove quote marks for strings
                  if (typeof originalValue === 'string') {
                    loc =
                      Object.assign(
                        {
                        },
                        loc,
                        {
                          start: Object.assign(
                            {
                            },
                            loc.start,
                            {
                              column: ___R$project$rome$$romejs$ob1$index_ts$add(loc.start.column, 1),
                            },
                          ),
                          end: Object.assign(
                            {
                            },
                            loc.end,
                            {
                              column: ___R$project$rome$$romejs$ob1$index_ts$sub(loc.end.column, 1),
                            },
                          ),
                        },
                      );
                  }
                }

                return (
                  Object.assign(
                    {
                      language: 'json',
                    },
                    loc,
                    {
                      mtime: this.mtime,
                      sourceText: undefined,
                    },
                  )
                );
              },

              getOriginalValue: (keys) => {
                const info = this.getPathInfo(keys);
                if (info !== undefined) {
                  return info.originalValue;
                }
              },
            };

            return (
              {
                value: expr,
                context,
              }
            );
          }
        }

        return (
          JSONParser
        );
      })(),
  );

  // project-rome/@romejs/consume/types.ts
const ___R$project$rome$$romejs$consume$types_ts = {
  };

  // project-rome/@romejs/js-ast-utils/assertMultipleNodes.ts
function ___R$project$rome$$romejs$js$ast$utils$assertMultipleNodes_ts$default(
    result,
  ) {
    if (Array.isArray(result)) {
      return result;
    } else if (result === undefined) {
      return [];
    } else if (typeof result === 'symbol') {
      throw new Error('No symbols expected here');
    } else {
      return [result];
    }
  }

  // project-rome/@romejs/js-ast-utils/assertSingleNode.ts
function ___R$project$rome$$romejs$js$ast$utils$assertSingleNode_ts$default(result) {
    if (Array.isArray(result)) {
      if (result.length !== 1) {
        throw new Error('Expected node list length of 1 but got ' +
        result.length);
      }
      return result[0];
    } else if (result === undefined) {
      throw new Error('Expected node or node list but got null');
    } else if (typeof result === 'symbol') {
      throw new Error('No symbols expected here');
    } else {
      return result;
    }
  }

  // project-rome/@romejs/js-ast-utils/assertSingleOrMultipleNodes.ts
function ___R$project$rome$$romejs$js$ast$utils$assertSingleOrMultipleNodes_ts$default(
    result,
  ) {
    if (result === undefined) {
      throw new Error('Expected node or node list but got null');
    } else if (typeof result === 'symbol') {
      throw new Error('No symbols expected here');
    } else {
      return result;
    }
  }

  // project-rome/@romejs/js-ast-utils/getNodeReferenceParts.ts
function ___R$project$rome$$romejs$js$ast$utils$getNodeReferenceParts_ts$default(
    node,
  ) {
    const parts = [];

    function add(node) {
      if (node.type === 'Identifier' || node.type === 'ReferenceIdentifier') {
        parts.push(node.name);
        return false;
      } else if (node.type === 'StringLiteral') {
        parts.push(node.value);
        return false;
      } else if (node.type === 'MetaProperty') {
        parts.push(node.meta.name);
        parts.push(node.property.name);
        return false;
      } else if (node.type === 'MemberExpression') {
        const stop = add(node.object);
        if (stop) {
          return true;
        } else {
          return add(node.property);
        }
      } else if (node.type === 'ComputedMemberProperty' &&
        node.value.type ===
        'StringLiteral') {
        return add(node.value);
      } else if (node.type === 'StaticMemberProperty') {
        return add(node.value);
      } else {
        return true;
      }
    }

    const bailed = add(node);

    return [bailed, parts];
  }

  // project-rome/@romejs/js-ast-utils/doesNodeMatchPattern.ts
function ___R$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(
    member,
    match,
    allowPartial = false,
  ) {
    // Not a member expression
    if (member.type !== 'MemberExpression' && member.type !== 'Identifier') {
      return false;
    }

    const expectedParts = Array.isArray(match)
      ? match.slice() : match.split('.');

    const [bailed, actualParts] = ___R$project$rome$$romejs$js$ast$utils$getNodeReferenceParts_ts$default(member);

    // Bailed will be true if we were unable to derive a name for one of the parts
    if (bailed && !allowPartial) {
      return false;
    }

    // If there's less parts than the amount we expect then it's never going to match
    if (actualParts.length < expectedParts.length) {
      return false;
    }

    // I there's more parts than we expect and we weren't passed the allowPartial flag then it's never going to match either
    if (allowPartial === false && actualParts.length > expectedParts.length) {
      return false;
    }

    // Loop over the parts we received and match them
    while (actualParts.length > 0) {
      // If we have no more expected parts then return based on if we allow partial matches
      if (expectedParts.length === 0) {
        return allowPartial;
      }

      const actual = actualParts.shift();
      const expected = expectedParts.shift();

      // A star part can accept anything
      if (expected === '*') {
        continue;
      }

      // A double star will eat as many parts from 'actual until we find the next expected part
      if (expected === '**') {
        const next = expectedParts.shift();

        if (next === '*' || next === '**') {
          throw (
            new Error(
              'The next expected part was ' +
              next +
              ' but this isn\'t allowed since we\'re processing a double star',
            )
          );
        }

        let found = false;

        while (actualParts.length > 0) {
          const actual = actualParts.shift();
          if (actual === next) {
            found = true;
            break;
          }
        }

        if (found) {
          continue;
        } else {
          return false;
        }
      }

      if (expected !== actual) {
        return false;
      }
    }

    return true;
  }

  // project-rome/@romejs/js-ast/utils.ts
const ___R$project$rome$$romejs$js$ast$utils_ts$bindingKeys = new Map();
  const ___R$project$rome$$romejs$js$ast$utils_ts$visitorKeys = new Map();
  const ___R$project$rome$$romejs$js$ast$utils_ts$nodeNames = new Set();

  function ___R$project$rome$$romejs$js$ast$utils_ts$assertNodeTypeSet(names, desc) {
    const set = new Set(names.keys());

    const errors = [];

    // Verify that all names in `set` are valid
    for (const name of set) {
      if (name[0] === '_') {
        continue;
      }

      if (___R$project$rome$$romejs$js$ast$utils_ts$nodeNames.has(name) === false) {
        errors.push(name +
        ' is not a valid node');
      }
    }

    // Verify all nodes
    for (const name of ___R$project$rome$$romejs$js$ast$utils_ts$nodeNames) {
      if (set.has(name) === false) {
        errors.push(name +
        ' does not appear');
      }
    }

    if (errors.length > 0) {
      throw new Error(desc +
      ': ' +
      errors.join('\n'));
    }
  }

  function ___R$$priv$project$rome$$romejs$js$ast$utils_ts$declareBuilder(type, opts) {
    ___R$project$rome$$romejs$js$ast$utils_ts$nodeNames.add(type);

    if (opts.visitorKeys !== undefined) {
      ___R$project$rome$$romejs$js$ast$utils_ts$visitorKeys.set(type, Object.keys(opts.visitorKeys));
    }

    if (opts.bindingKeys !== undefined) {
      ___R$project$rome$$romejs$js$ast$utils_ts$bindingKeys.set(type, Object.keys(opts.bindingKeys));
    }
  }

  // TODO only allow this method to be called on a node with only one required property
  function ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
    type,
    quickKey,
    opts,
  ) {
    ___R$$priv$project$rome$$romejs$js$ast$utils_ts$declareBuilder(type, opts);

    return new ___R$$priv$project$rome$$romejs$js$ast$utils_ts$QuickBuilder(type, opts.visitorKeys, quickKey);
  }

  function ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    type,
    opts,
  ) {
    ___R$$priv$project$rome$$romejs$js$ast$utils_ts$declareBuilder(type, opts);

    return new ___R$$priv$project$rome$$romejs$js$ast$utils_ts$Builder(type, opts.visitorKeys);
  }

  class ___R$$priv$project$rome$$romejs$js$ast$utils_ts$Builder {
    constructor(type, visitorKeys) {
      this.type = type;
      this.visitorKeys = visitorKeys;
    }

    create(opts, inheritNode) {
      // @ts-ignore
      return (
        Object.assign(
          {
            loc: inheritNode === undefined ? undefined : ___R$project$rome$$romejs$js$ast$utils$inheritLoc_ts$default(inheritNode),
          },
          opts,
          {
            type: this.type,
          },
        )
      );
    }

    is(node) {
      return node !== undefined && node.type === this.type;
    }

    normalize(node) {
      if (this.is(node)) {
        return node;
      }
    }

    assert(res) {
      if (res === undefined) {
        throw new Error('Expected ' +
        this.type +
        ' Node but got undefined');
      }

      const node = ___R$project$rome$$romejs$js$ast$utils$assertSingleNode_ts$default(res);

      if (node.type !== this.type) {
        throw new Error('Expected ' +
        this.type +
        ' Node but got ' +
        node.type);
      }

      // @ts-ignore
      return node;
    }
  }

  class ___R$$priv$project$rome$$romejs$js$ast$utils_ts$QuickBuilder extends ___R$$priv$project$rome$$romejs$js$ast$utils_ts$Builder {
    constructor(type, visitorKeys, quickKey) {
      super(type, visitorKeys);
      this.quickKey = quickKey;
    }

    quick(arg, opts, inheritNode) {
      const node = (Object.assign(
        {
        },
        opts,
        {
          [this.quickKey]: arg,
        },
      ));

      return this.create(node, inheritNode);
    }
  }

  // project-rome/@romejs/js-ast-utils/getBindingIdentifiers.ts
function ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(
    node,
  ) {
    const ids = [];
    let queue = Array.isArray(node)
      ? [...node] : [
        node,
      ];

    while (queue.length) {
      const node = queue.pop();
      if (node === undefined) {
        continue;
      }

      if (node.type === 'BindingIdentifier') {
        ids.push(node);
        continue;
      }

      const keys = ___R$project$rome$$romejs$js$ast$utils_ts$bindingKeys.get(node.type);
      if (keys === undefined) {
        continue;
      }

      for (const key of keys) {
        // rome-suppress lint/noExplicitAny
        const val = (node)[key];
        if (val === undefined) {
          continue;
        } else if (Array.isArray(val)) {
          queue = queue.concat(val);
        } else {
          queue.push(val);
        }
      }
    }

    return ids;
  }

  // project-rome/@romejs/js-ast-utils/hasPotentialSideEffects.ts
function ___R$project$rome$$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(
    node,
    scope,
  ) {
    if (node === undefined) {
      return false;
    }

    switch (node.type) {
      case 'ExportLocalDeclaration':
        if (node.declaration === undefined) {
          return false;
        } else {
          return ___R$project$rome$$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(node.declaration, scope);
        }

      case 'ExportExternalDeclaration':
        return true;

      case 'FunctionExpression':
      case 'FunctionDeclaration':
        return false;

      case 'ClassDeclaration':
        return (
          node.meta.superClass !== undefined ||
          !___R$project$rome$$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(
            node.meta.superClass,
            scope,
          )
        );

      case 'ReferenceIdentifier':
        // Variables that aren't in scope and aren't registered globals could trigger a getter

        // Unlikely but let's aim for 100% correctness
        return (
          scope.getRootScope().isGlobal(node.name) ||
          scope.hasBinding(
            node.name,
          )
        );

      case 'VariableDeclaration':
        for (const declarator of node.declarations) {
          if (___R$project$rome$$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(declarator, scope)) {
            return true;
          }
        }
        return false;

      case 'VariableDeclarator':
        return (
          ___R$project$rome$$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(node.id, scope) ||
          ___R$project$rome$$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(
            node.init,
            scope,
          )
        );

      case 'SpreadProperty':
      case 'SpreadElement':
        return ___R$project$rome$$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(node.argument, scope);

      case 'BindingAssignmentPattern':
        return ___R$project$rome$$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(node.right, scope);

      case 'ObjectExpression':
      case 'BindingObjectPattern':
        for (const prop of node.properties) {
          if (___R$project$rome$$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(prop, scope)) {
            return true;
          }
        }
        return false;

      case 'StaticPropertyKey':
        return false;

      case 'ComputedPropertyKey':
        return ___R$project$rome$$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(node.value, scope);

      case 'BindingObjectPatternProperty':
      case 'ObjectProperty':
        return (
          ___R$project$rome$$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(node.key, scope) ||
          ___R$project$rome$$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(node.value, scope)
        );

      case 'BindingArrayPattern':
      case 'ArrayExpression':
        for (const elem of node.elements) {
          if (___R$project$rome$$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(elem, scope)) {
            return true;
          }
        }
        return false;

      case 'StringLiteral':
      case 'NumericLiteral':
      case 'BooleanLiteral':
      case 'NullLiteral':
        return false;
    }

    return true;
  }

  // project-rome/@romejs/js-ast-utils/isBinary.ts
function ___R$project$rome$$romejs$js$ast$utils$isBinary_ts$default(
    node,
  ) {
    if (node === undefined) {
      return false;
    }

    switch (node.type) {
      case 'BinaryExpression':
      case 'LogicalExpression':
        return true;

      default:
        return false;
    }
  }

  // project-rome/@romejs/js-ast-utils/isConditional.ts
function ___R$project$rome$$romejs$js$ast$utils$isConditional_ts$default(
    node,
  ) {
    if (node === undefined) {
      return false;
    }

    switch (node.type) {
      case 'ConditionalExpression':
      case 'IfStatement':
        return true;

      default:
        return false;
    }
  }

  // project-rome/@romejs/js-ast-utils/isTypeNode.ts
function ___R$project$rome$$romejs$js$ast$utils$isTypeNode_ts$default(node) {
    if (node.type.startsWith('Flow') || node.type.startsWith('TS') ||
    node.type.endsWith('TypeAnnotation')) {
      return true;
    } else if (node.type === 'ImportDeclaration') {
      return node.importKind === 'type' || node.importKind === 'typeof';
    } else if (node.type === 'ExportDefaultDeclaration' ||
    node.type ===
    'ExportLocalDeclaration' ||
    node.type === 'ExportAllDeclaration') {
      return node.exportKind === 'type';
    } else if (node.type === 'ImportSpecifier') {
      return node.local.importKind === 'type' || node.local.importKind === 'typeof';
    } else {
      return false;
    }
  }

  // project-rome/@romejs/js-ast-utils/isFor.ts
function ___R$project$rome$$romejs$js$ast$utils$isFor_ts$default(
    node,
  ) {
    if (node === undefined) {
      return false;
    }

    switch (node.type) {
      case 'ForStatement':
      case 'ForInStatement':
      case 'ForOfStatement':
        return true;

      default:
        return false;
    }
  }

  // project-rome/@romejs/js-ast-utils/isFunctionNode.ts
function ___R$project$rome$$romejs$js$ast$utils$isFunctionNode_ts$default(node) {
    return (
      node.type === 'FunctionDeclaration' ||
      node.type ===
      'FunctionExpression' ||
      node.type === 'ObjectMethod' ||
      node.type ===
      'ArrowFunctionExpression' ||
      node.type === 'ClassMethod'
    );
  }

  // project-rome/@romejs/js-ast-utils/isNodeLike.ts
function ___R$project$rome$$romejs$js$ast$utils$isNodeLike_ts$default(node) {
    if (node == null) {
      return false;
    } else {
      return ___R$project$rome$$romejs$typescript$helpers$index_ts$isPlainObject(node) && typeof node.type === 'string';
    }
  }

  // project-rome/@romejs/js-ast-utils/isDeclaration.ts
function ___R$project$rome$$romejs$js$ast$utils$isDeclaration_ts$default(
    node,
  ) {
    if (node === undefined) {
      return false;
    }

    switch (node.type) {
      case 'FunctionDeclaration':
      case 'ClassDeclaration':
      case 'ExportAllDeclaration':
      case 'ExportDefaultDeclaration':
      case 'ExportLocalDeclaration':
      case 'ImportDeclaration':
      case 'FlowDeclareClass':
      case 'FlowDeclareFunction':
      case 'FlowDeclareInterface':
      case 'FlowDeclareModule':
      case 'FlowDeclareModuleExports':
      case 'FlowDeclareOpaqueType':
      case 'FlowDeclareVariable':
      case 'FlowInterfaceDeclaration':
      case 'FlowOpaqueType':
      case 'TypeAliasTypeAnnotation':
      case 'VariableDeclarationStatement':
      case 'ExportExternalDeclaration':
      case 'FlowDeclareExportAll':
      case 'FlowDeclareExportDefault':
      case 'FlowDeclareExportNamed':
      case 'FlowInterface':
      case 'TSDeclareFunction':
      case 'TSEnumDeclaration':
      case 'TSExportAssignment':
      case 'TSImportEqualsDeclaration':
      case 'TSInterfaceDeclaration':
      case 'TSModuleDeclaration':
      case 'TSNamespaceExportDeclaration':
        const declaration = node;
        declaration;
        return true;

      default:
        const notDeclaration = node;
        notDeclaration;
        return false;
    }
  }

  // project-rome/@romejs/js-ast-utils/isStatement.ts
function ___R$project$rome$$romejs$js$ast$utils$isStatement_ts$default(
    node,
  ) {
    if (node === undefined) {
      return false;
    }

    if (___R$project$rome$$romejs$js$ast$utils$isDeclaration_ts$default(node)) {
      return true;
    }

    switch (node.type) {
      case 'BlockStatement':
      case 'BreakStatement':
      case 'ContinueStatement':
      case 'DebuggerStatement':
      case 'DoWhileStatement':
      case 'EmptyStatement':
      case 'ExpressionStatement':
      case 'ForInStatement':
      case 'ForStatement':
      case 'IfStatement':
      case 'LabeledStatement':
      case 'ReturnStatement':
      case 'SwitchStatement':
      case 'ThrowStatement':
      case 'TryStatement':
      case 'WhileStatement':
      case 'WithStatement':
      case 'ForOfStatement':
        const statement = node;
        statement;
        return true;

      default:
        // Assert that all statements were handled
        const notStatement = node;
        notStatement;
        return false;
    }
  }

  // project-rome/@romejs/js-ast-utils/isUnaryLike.ts
function ___R$project$rome$$romejs$js$ast$utils$isUnaryLike_ts$default(node) {
    if (node === undefined) {
      return false;
    }

    switch (node.type) {
      case 'UnaryExpression':
      case 'SpreadElement':
      case 'SpreadProperty':
        return true;

      default:
        return false;
    }
  }

  // project-rome/@romejs/js-parser-utils/identifier.ts
const ___R$project$rome$$romejs$js$parser$utils$identifier_ts = {
    get keywordRelationalOperator() {
      return (
        ___R$project$rome$$romejs$js$parser$utils$identifier_ts$keywordRelationalOperator
      );
    },

    isES2015ReservedWord: ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isES2015ReservedWord,
    isReservedWord: ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isReservedWord,
    isStrictReservedWord: ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isStrictReservedWord,
    isStrictBindReservedWord: ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isStrictBindReservedWord,
    isKeyword: ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isKeyword,
    getFullCharCodeAt: ___R$project$rome$$romejs$js$parser$utils$identifier_ts$getFullCharCodeAt,
    isIdentifierStart: ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierStart,
    isIdentifierChar: ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierChar,
  };
  const ___R$project$rome$$romejs$js$parser$utils$identifier_ts$keywordRelationalOperator = /^in(stanceof)?$/;

  function ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isES2015ReservedWord(word) {
    return word === 'enum' || word === 'await';
  }

  function ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isReservedWord(word, inModule) {
    return inModule && word === 'await' || word === 'enum';
  }

  const ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$reservedWordsStrict = new Set(
    [
      'implements',
      'interface',
      'let',
      'package',
      'private',
      'protected',
      'public',
      'static',
      'yield',
    ],
  );
  function ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isStrictReservedWord(word, inModule) {
    return ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isReservedWord(word, inModule) || ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$reservedWordsStrict.has(word);
  }

  function ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isStrictBindReservedWord(
    word,
    inModule,
  ) {
    return (
      ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isStrictReservedWord(word, inModule) || word === 'eval' ||
      word ===
      'arguments'
    );
  }

  const ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$keywords = new Set(
    [
      'break',
      'case',
      'catch',
      'continue',
      'debugger',
      'default',
      'do',
      'else',
      'finally',
      'for',
      'function',
      'if',
      'return',
      'switch',
      'throw',
      'try',
      'var',
      'const',
      'while',
      'with',
      'new',
      'this',
      'super',
      'class',
      'extends',
      'export',
      'import',
      'null',
      'true',
      'false',
      'in',
      'instanceof',
      'typeof',
      'void',
      'delete',
    ],
  );

  function ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isKeyword(word) {
    return ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$keywords.has(word);
  }

  // ## Character categories

  // Big ugly regular expressions that match characters in the

  // whitespace, identifier, and identifier-start categories. These

  // are only applied when a character is found to actually have a

  // code point above 128.

  // Generated by `bin/generate-identifier-regex.js`.

  /* prettier-ignore */
  let ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$nonASCIIidentifierStartChars = '\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312e\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fea\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ae\ua7b0-\ua7b7\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc';
  /* prettier-ignore */
  let ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$nonASCIIidentifierChars = '\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d4-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f';

  const ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$nonASCIIidentifierStart = new RegExp('[' +
  ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$nonASCIIidentifierStartChars +
  ']');
  const ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$nonASCIIidentifier = new RegExp(
    '[' +
    ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$nonASCIIidentifierStartChars +
    ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$nonASCIIidentifierChars +
    ']',
  );

  // These are a run-length and offset encoded representation of the

  // >0xffff code points that are a valid part of identifiers. The

  // offset starts at 0x10000, and each pair of numbers represents an

  // offset to the next range, and then a size of the range. They were

  // generated by `bin/generate-identifier-regex.js`.

  /* prettier-ignore */
  const ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$astralIdentifierStartCodes = [
    0,
    11,
    2,
    25,
    2,
    18,
    2,
    1,
    2,
    14,
    3,
    13,
    35,
    122,
    70,
    52,
    268,
    28,
    4,
    48,
    48,
    31,
    14,
    29,
    6,
    37,
    11,
    29,
    3,
    35,
    5,
    7,
    2,
    4,
    43,
    157,
    19,
    35,
    5,
    35,
    5,
    39,
    9,
    51,
    157,
    310,
    10,
    21,
    11,
    7,
    153,
    5,
    3,
    0,
    2,
    43,
    2,
    1,
    4,
    0,
    3,
    22,
    11,
    22,
    10,
    30,
    66,
    18,
    2,
    1,
    11,
    21,
    11,
    25,
    71,
    55,
    7,
    1,
    65,
    0,
    16,
    3,
    2,
    2,
    2,
    26,
    45,
    28,
    4,
    28,
    36,
    7,
    2,
    27,
    28,
    53,
    11,
    21,
    11,
    18,
    14,
    17,
    111,
    72,
    56,
    50,
    14,
    50,
    785,
    52,
    76,
    44,
    33,
    24,
    27,
    35,
    42,
    34,
    4,
    0,
    13,
    47,
    15,
    3,
    22,
    0,
    2,
    0,
    36,
    17,
    2,
    24,
    85,
    6,
    2,
    0,
    2,
    3,
    2,
    14,
    2,
    9,
    8,
    46,
    39,
    7,
    3,
    1,
    3,
    21,
    2,
    6,
    2,
    1,
    2,
    4,
    4,
    0,
    19,
    0,
    13,
    4,
    159,
    52,
    19,
    3,
    54,
    47,
    21,
    1,
    2,
    0,
    185,
    46,
    42,
    3,
    37,
    47,
    21,
    0,
    60,
    42,
    86,
    25,
    391,
    63,
    32,
    0,
    257,
    0,
    11,
    39,
    8,
    0,
    22,
    0,
    12,
    39,
    3,
    3,
    55,
    56,
    264,
    8,
    2,
    36,
    18,
    0,
    50,
    29,
    113,
    6,
    2,
    1,
    2,
    37,
    22,
    0,
    698,
    921,
    103,
    110,
    18,
    195,
    2749,
    1070,
    4050,
    582,
    8634,
    568,
    8,
    30,
    114,
    29,
    19,
    47,
    17,
    3,
    32,
    20,
    6,
    18,
    881,
    68,
    12,
    0,
    67,
    12,
    65,
    1,
    31,
    6124,
    20,
    754,
    9486,
    286,
    82,
    395,
    2309,
    106,
    6,
    12,
    4,
    8,
    8,
    9,
    5991,
    84,
    2,
    70,
    2,
    1,
    3,
    0,
    3,
    1,
    3,
    3,
    2,
    11,
    2,
    0,
    2,
    6,
    2,
    64,
    2,
    3,
    3,
    7,
    2,
    6,
    2,
    27,
    2,
    3,
    2,
    4,
    2,
    0,
    4,
    6,
    2,
    339,
    3,
    24,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    7,
    4149,
    196,
    60,
    67,
    1213,
    3,
    2,
    26,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    9,
    2,
    3,
    2,
    0,
    2,
    0,
    7,
    0,
    5,
    0,
    2,
    0,
    2,
    0,
    2,
    2,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    1,
    2,
    0,
    3,
    3,
    2,
    6,
    2,
    3,
    2,
    3,
    2,
    0,
    2,
    9,
    2,
    16,
    6,
    2,
    2,
    4,
    2,
    16,
    4421,
    42710,
    42,
    4148,
    12,
    221,
    3,
    5761,
    15,
    7472,
    3104,
    541,
  ];
  /* prettier-ignore */
  const ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$astralIdentifierCodes = [
    509,
    0,
    227,
    0,
    150,
    4,
    294,
    9,
    1368,
    2,
    2,
    1,
    6,
    3,
    41,
    2,
    5,
    0,
    166,
    1,
    1306,
    2,
    54,
    14,
    32,
    9,
    16,
    3,
    46,
    10,
    54,
    9,
    7,
    2,
    37,
    13,
    2,
    9,
    52,
    0,
    13,
    2,
    49,
    13,
    10,
    2,
    4,
    9,
    83,
    11,
    7,
    0,
    161,
    11,
    6,
    9,
    7,
    3,
    57,
    0,
    2,
    6,
    3,
    1,
    3,
    2,
    10,
    0,
    11,
    1,
    3,
    6,
    4,
    4,
    193,
    17,
    10,
    9,
    87,
    19,
    13,
    9,
    214,
    6,
    3,
    8,
    28,
    1,
    83,
    16,
    16,
    9,
    82,
    12,
    9,
    9,
    84,
    14,
    5,
    9,
    423,
    9,
    280,
    9,
    41,
    6,
    2,
    3,
    9,
    0,
    10,
    10,
    47,
    15,
    406,
    7,
    2,
    7,
    17,
    9,
    57,
    21,
    2,
    13,
    123,
    5,
    4,
    0,
    2,
    1,
    2,
    6,
    2,
    0,
    9,
    9,
    19719,
    9,
    135,
    4,
    60,
    6,
    26,
    9,
    1016,
    45,
    17,
    3,
    19723,
    1,
    5319,
    4,
    4,
    5,
    9,
    7,
    3,
    6,
    31,
    3,
    149,
    2,
    1418,
    49,
    513,
    54,
    5,
    49,
    9,
    0,
    15,
    0,
    23,
    4,
    2,
    14,
    1361,
    6,
    2,
    16,
    3,
    6,
    2,
    1,
    2,
    4,
    2214,
    6,
    110,
    6,
    6,
    9,
    792487,
    239,
  ];

  // Get the full char code at a certain position
  function ___R$project$rome$$romejs$js$parser$utils$identifier_ts$getFullCharCodeAt(str, offset) {
    const code = str.charCodeAt(offset);
    if (code <= 55295 || code >= 57344) {
      return code;
    }

    const next = str.charCodeAt(offset + 1);
    return (code << 10) + next - 56613888;
  }

  // This has a complexity linear to the value of the code. The

  // assumption is that looking up astral identifier characters is

  // rare.
  function ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$isInAstralSet(code, set) {
    let pos = 65536;
    for (let i = 0;
    i < set.length;
    i += 2) {
      pos += set[i];
      if (pos > code) {
        return false;
      }

      pos += set[i + 1];
      if (pos >= code) {
        return true;
      }
    }
    return false;
  }

  // Test whether a given character code starts an identifier.
  function ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierStart(code) {
    if (code === undefined) {
      return false;
    }

    if (code < 65) {
      return code === 36;
    }

    if (code < 91) {
      return true;
    }

    if (code < 97) {
      return code === 95;
    }

    if (code < 123) {
      return true;
    }

    if (code <= 65535) {
      return code >= 170 && ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$nonASCIIidentifierStart.test(String.fromCharCode(code));
    }

    return ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$isInAstralSet(code, ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$astralIdentifierStartCodes);
  }

  function ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierChar(code) {
    if (code < 48) {
      return code === 36;
    }

    if (code < 58) {
      return true;
    }

    if (code < 65) {
      return false;
    }

    if (code < 91) {
      return true;
    }

    if (code < 97) {
      return code === 95;
    }

    if (code < 123) {
      return true;
    }

    if (code <= 65535) {
      return code >= 170 && ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$nonASCIIidentifier.test(String.fromCharCode(code));
    }

    return (
      ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$isInAstralSet(code, ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$astralIdentifierStartCodes) ||
      ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$isInAstralSet(
        code,
        ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$astralIdentifierCodes,
      )
    );
  }

  // project-rome/@romejs/js-parser-utils/location.ts
const ___R$project$rome$$romejs$js$parser$utils$location_ts = {
    createIndexTracker: ___R$project$rome$$romejs$js$parser$utils$location_ts$createIndexTracker,
  };
  function ___R$project$rome$$romejs$js$parser$utils$location_ts$createIndexTracker() {
    return {index: ___R$project$rome$$romejs$ob1$index_ts$number0};
  }

  // project-rome/@romejs/js-parser-utils/messages.ts
const ___R$project$rome$$romejs$js$parser$utils$messages_ts$default = ___R$project$rome$$romejs$messages$index_ts$createMessageFactory(
    {
      DUPLICATE_REGEX_FLAG: 'Duplicate regular expression flag',
      INVALID_REGEX_FLAG: 'Invalid regular expression flag',
    },
  );

  // project-rome/@romejs/js-parser-utils/regex.ts
const ___R$project$rome$$romejs$js$parser$utils$regex_ts = {
    validateRegexFlags: ___R$project$rome$$romejs$js$parser$utils$regex_ts$validateRegexFlags,
  };
  const ___R$$priv$project$rome$$romejs$js$parser$utils$regex_ts$VALID_REGEX_FLAGS = 'gmsiyu'.split('');

  // This is used by both rome-json and rome-js-parser to validate regex flags
  function ___R$project$rome$$romejs$js$parser$utils$regex_ts$validateRegexFlags(
    flags,
    onUnexpected,
  ) {
    const foundFlags = new Set();

    for (let i = 0;
    i < flags.length;
    i++) {
      const flag = flags[i];

      if (___R$$priv$project$rome$$romejs$js$parser$utils$regex_ts$VALID_REGEX_FLAGS.includes(flag)) {
        if (foundFlags.has(flag)) {
          onUnexpected(___R$project$rome$$romejs$js$parser$utils$messages_ts$default.DUPLICATE_REGEX_FLAG(), i);
        } else {
          foundFlags.add(flag);
        }
      } else {
        onUnexpected(___R$project$rome$$romejs$js$parser$utils$messages_ts$default.INVALID_REGEX_FLAG(), i);
      }
    }

    return foundFlags;
  }

  // project-rome/@romejs/js-parser-utils/whitespace.ts
const ___R$project$rome$$romejs$js$parser$utils$whitespace_ts = {
    get lineBreak() {
      return (
        ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreak
      );
    },

    get lineBreakG() {
      return (
        ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreakG
      );
    },

    isNewLine: ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$isNewLine,
    get nonASCIIwhitespace() {
      return (
        ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$nonASCIIwhitespace
      );
    },

    get skipWhiteSpace() {
      return (
        ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$skipWhiteSpace
      );
    },

    get NEWLINE() {
      return (
        ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$NEWLINE
      );
    },
  };
  const ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreak = /\r\n?|\n|u2028|u2029/;
  const ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreakG = new RegExp(___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreak.source, 'g');

  function ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$isNewLine(code) {
    return code === 10 || code === 13 || code === 8232 || code === 8233;
  }

  const ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

  const ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

  const ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$NEWLINE = /\r\n|[\n\r\u2028\u2029]/;

  // project-rome/@romejs/js-parser-utils/index.ts


  // project-rome/@romejs/js-ast-utils/isValidIdentifierName.ts
function ___R$project$rome$$romejs$js$ast$utils$isValidIdentifierName_ts$default(name) {
    if (name.length === 0) {
      return false;
    }

    if (___R$project$rome$$romejs$js$parser$utils$identifier_ts$isStrictReservedWord(name, true)) {
      return false;
    }

    if (___R$project$rome$$romejs$js$parser$utils$identifier_ts$isStrictBindReservedWord(name, true)) {
      return false;
    }

    if (___R$project$rome$$romejs$js$parser$utils$identifier_ts$isES2015ReservedWord(name)) {
      return false;
    }

    if (___R$project$rome$$romejs$js$parser$utils$identifier_ts$isKeyword(name)) {
      return false;
    }

    if (___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierStart(___R$project$rome$$romejs$js$parser$utils$identifier_ts$getFullCharCodeAt(name, 0)) === false) {
      return false;
    }

    let i = 1;
    while (i < name.length) {
      const code = ___R$project$rome$$romejs$js$parser$utils$identifier_ts$getFullCharCodeAt(name, i);
      if (___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierChar(code)) {
        i += code <= 65535 ? 1 : 2;
      } else {
        return false;
      }
    }

    return true;
  }

  // project-rome/@romejs/js-ast-utils/inheritLoc.ts
function ___R$project$rome$$romejs$js$ast$utils$inheritLoc_ts$default(
    node,
    name,
  ) {
    const {loc} = node;
    if (loc === undefined) {
      return undefined;
    }

    // Inherit new name if specified
    if (name !== undefined) {
      return (
        Object.assign(
          {
          },
          loc,
          {
            identifierName: name,
          },
        )
      );
    }

    // Don't infer a name if it already has one
    if (loc.identifierName !== undefined) {
      return loc;
    }

    // If this location has no identifierName and we're an Identifier then inherit it

    // TODO maybe handle other identifier types? JSXIdentifier etc?
    if (node.type === 'Identifier') {
      return (
        Object.assign(
          {
          },
          loc,
          {
            identifierName: node.name,
          },
        )
      );
    }

    return loc;
  }

  // project-rome/@romejs/js-ast/base.ts
const ___R$project$rome$$romejs$js$ast$base_ts = {
  };

  // project-rome/@romejs/js-ast/constants.ts
const ___R$project$rome$$romejs$js$ast$constants_ts = {
  };

  // project-rome/@romejs/js-ast/unions.ts
const ___R$project$rome$$romejs$js$ast$unions_ts = {
  };

  // project-rome/@romejs/js-ast/temp/AmbiguousFlowTypeCastExpression.ts
const ___R$project$rome$$romejs$js$ast$temp$AmbiguousFlowTypeCastExpression_ts = {
    get ambiguousFlowTypeCastExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$temp$AmbiguousFlowTypeCastExpression_ts$ambiguousFlowTypeCastExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$temp$AmbiguousFlowTypeCastExpression_ts$ambiguousFlowTypeCastExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'AmbiguousFlowTypeCastExpression',
    {
      bindingKeys: {},
      visitorKeys: {
        expression: true,
        typeAnnotation: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/types/AnyKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$types$AnyKeywordTypeAnnotation_ts = {
    get anyKeywordTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$types$AnyKeywordTypeAnnotation_ts$anyKeywordTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$types$AnyKeywordTypeAnnotation_ts$anyKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'AnyKeywordTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/expressions/ArrayExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$ArrayExpression_ts = {
    get arrayExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$expressions$ArrayExpression_ts$arrayExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$expressions$ArrayExpression_ts$arrayExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
    'ArrayExpression',
    'elements',
    {
      bindingKeys: {},
      visitorKeys: {
        elements: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/expressions/ArrowFunctionExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$ArrowFunctionExpression_ts = {
    get arrowFunctionExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$expressions$ArrowFunctionExpression_ts$arrowFunctionExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$expressions$ArrowFunctionExpression_ts$arrowFunctionExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ArrowFunctionExpression',
    {
      bindingKeys: {},
      visitorKeys: {
        head: true,
        body: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/patterns/AssignmentArrayPattern.ts
const ___R$project$rome$$romejs$js$ast$patterns$AssignmentArrayPattern_ts = {
    get assignmentArrayPattern() {
      return (
        ___R$project$rome$$romejs$js$ast$patterns$AssignmentArrayPattern_ts$assignmentArrayPattern
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$patterns$AssignmentArrayPattern_ts$assignmentArrayPattern = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'AssignmentArrayPattern',
    {
      bindingKeys: {},
      visitorKeys: {
        elements: true,
        rest: true,
        meta: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/patterns/AssignmentAssignmentPattern.ts
const ___R$project$rome$$romejs$js$ast$patterns$AssignmentAssignmentPattern_ts = {
    get assignmentAssignmentPattern() {
      return (
        ___R$project$rome$$romejs$js$ast$patterns$AssignmentAssignmentPattern_ts$assignmentAssignmentPattern
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$patterns$AssignmentAssignmentPattern_ts$assignmentAssignmentPattern = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'AssignmentAssignmentPattern',
    {
      bindingKeys: {},
      visitorKeys: {
        left: true,
        right: true,
        meta: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/expressions/AssignmentExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$AssignmentExpression_ts = {
    get assignmentExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$expressions$AssignmentExpression_ts$assignmentExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$expressions$AssignmentExpression_ts$assignmentExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'AssignmentExpression',
    {
      bindingKeys: {},
      visitorKeys: {
        left: true,
        right: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/patterns/AssignmentIdentifier.ts
const ___R$project$rome$$romejs$js$ast$patterns$AssignmentIdentifier_ts = {
    get assignmentIdentifier() {
      return (
        ___R$project$rome$$romejs$js$ast$patterns$AssignmentIdentifier_ts$assignmentIdentifier
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$patterns$AssignmentIdentifier_ts$assignmentIdentifier = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
    'AssignmentIdentifier',
    'name',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/patterns/AssignmentObjectPattern.ts
const ___R$project$rome$$romejs$js$ast$patterns$AssignmentObjectPattern_ts = {
    get assignmentObjectPattern() {
      return (
        ___R$project$rome$$romejs$js$ast$patterns$AssignmentObjectPattern_ts$assignmentObjectPattern
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$patterns$AssignmentObjectPattern_ts$assignmentObjectPattern = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'AssignmentObjectPattern',
    {
      bindingKeys: {},
      visitorKeys: {
        properties: true,
        rest: true,
        meta: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/patterns/AssignmentObjectPatternProperty.ts
const ___R$project$rome$$romejs$js$ast$patterns$AssignmentObjectPatternProperty_ts = {
    get assignmentObjectPatternProperty() {
      return (
        ___R$project$rome$$romejs$js$ast$patterns$AssignmentObjectPatternProperty_ts$assignmentObjectPatternProperty
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$patterns$AssignmentObjectPatternProperty_ts$assignmentObjectPatternProperty = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'AssignmentObjectPatternProperty',
    {
      bindingKeys: {},
      visitorKeys: {
        key: true,
        value: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/expressions/AwaitExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$AwaitExpression_ts = {
    get awaitExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$expressions$AwaitExpression_ts$awaitExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$expressions$AwaitExpression_ts$awaitExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'AwaitExpression',
    {
      bindingKeys: {},
      visitorKeys: {
        argument: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/types/BigIntKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$types$BigIntKeywordTypeAnnotation_ts = {
    get bigIntKeywordTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$types$BigIntKeywordTypeAnnotation_ts$bigIntKeywordTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$types$BigIntKeywordTypeAnnotation_ts$bigIntKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'BigIntKeywordTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/literals/BigIntLiteral.ts
const ___R$project$rome$$romejs$js$ast$literals$BigIntLiteral_ts = {
    get bigIntLiteral() {
      return (
        ___R$project$rome$$romejs$js$ast$literals$BigIntLiteral_ts$bigIntLiteral
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$literals$BigIntLiteral_ts$bigIntLiteral = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'BigIntLiteral',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/expressions/BinaryExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$BinaryExpression_ts = {
    get binaryExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$expressions$BinaryExpression_ts$binaryExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$expressions$BinaryExpression_ts$binaryExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'BinaryExpression',
    {
      bindingKeys: {},
      visitorKeys: {
        left: true,
        right: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/patterns/BindingArrayPattern.ts
const ___R$project$rome$$romejs$js$ast$patterns$BindingArrayPattern_ts = {
    get bindingArrayPattern() {
      return (
        ___R$project$rome$$romejs$js$ast$patterns$BindingArrayPattern_ts$bindingArrayPattern
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$patterns$BindingArrayPattern_ts$bindingArrayPattern = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'BindingArrayPattern',
    {
      bindingKeys: {
        elements: true,
        rest: true,
      },
      visitorKeys: {
        elements: true,
        rest: true,
        meta: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/patterns/BindingAssignmentPattern.ts
const ___R$project$rome$$romejs$js$ast$patterns$BindingAssignmentPattern_ts = {
    get bindingAssignmentPattern() {
      return (
        ___R$project$rome$$romejs$js$ast$patterns$BindingAssignmentPattern_ts$bindingAssignmentPattern
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$patterns$BindingAssignmentPattern_ts$bindingAssignmentPattern = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'BindingAssignmentPattern',
    {
      bindingKeys: {
        left: true,
      },
      visitorKeys: {
        left: true,
        right: true,
        meta: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/patterns/BindingIdentifier.ts
const ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts = {
    get bindingIdentifier() {
      return (
        ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
    'BindingIdentifier',
    'name',
    {
      bindingKeys: {},
      visitorKeys: {
        meta: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/patterns/BindingObjectPattern.ts
const ___R$project$rome$$romejs$js$ast$patterns$BindingObjectPattern_ts = {
    get bindingObjectPattern() {
      return (
        ___R$project$rome$$romejs$js$ast$patterns$BindingObjectPattern_ts$bindingObjectPattern
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$patterns$BindingObjectPattern_ts$bindingObjectPattern = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'BindingObjectPattern',
    {
      bindingKeys: {
        properties: true,
        rest: true,
      },
      visitorKeys: {
        properties: true,
        rest: true,
        meta: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/patterns/BindingObjectPatternProperty.ts
const ___R$project$rome$$romejs$js$ast$patterns$BindingObjectPatternProperty_ts = {
    get bindingObjectPatternProperty() {
      return (
        ___R$project$rome$$romejs$js$ast$patterns$BindingObjectPatternProperty_ts$bindingObjectPatternProperty
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$patterns$BindingObjectPatternProperty_ts$bindingObjectPatternProperty = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'BindingObjectPatternProperty',
    {
      bindingKeys: {
        value: true,
      },
      visitorKeys: {
        key: true,
        value: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/statements/BlockStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts = {
    get blockStatement() {
      return (
        ___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts$blockStatement
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts$blockStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
    'BlockStatement',
    'body',
    {
      bindingKeys: {},
      visitorKeys: {
        body: true,
        directives: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/types/BooleanKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$types$BooleanKeywordTypeAnnotation_ts = {
    get booleanKeywordTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$types$BooleanKeywordTypeAnnotation_ts$booleanKeywordTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$types$BooleanKeywordTypeAnnotation_ts$booleanKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'BooleanKeywordTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/literals/BooleanLiteral.ts
const ___R$project$rome$$romejs$js$ast$literals$BooleanLiteral_ts = {
    get booleanLiteral() {
      return (
        ___R$project$rome$$romejs$js$ast$literals$BooleanLiteral_ts$booleanLiteral
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$literals$BooleanLiteral_ts$booleanLiteral = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
    'BooleanLiteral',
    'value',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/types/BooleanLiteralTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$types$BooleanLiteralTypeAnnotation_ts = {
    get booleanLiteralTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$types$BooleanLiteralTypeAnnotation_ts$booleanLiteralTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$types$BooleanLiteralTypeAnnotation_ts$booleanLiteralTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'BooleanLiteralTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/statements/BreakStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$BreakStatement_ts = {
    get breakStatement() {
      return (
        ___R$project$rome$$romejs$js$ast$statements$BreakStatement_ts$breakStatement
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$statements$BreakStatement_ts$breakStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'BreakStatement',
    {
      bindingKeys: {},
      visitorKeys: {
        label: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/expressions/CallExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$CallExpression_ts = {
    get callExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$expressions$CallExpression_ts$callExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$expressions$CallExpression_ts$callExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'CallExpression',
    {
      bindingKeys: {},
      visitorKeys: {
        callee: true,
        arguments: true,
        typeArguments: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/auxiliary/CatchClause.ts
const ___R$project$rome$$romejs$js$ast$auxiliary$CatchClause_ts = {
    get catchClause() {
      return (
        ___R$project$rome$$romejs$js$ast$auxiliary$CatchClause_ts$catchClause
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$auxiliary$CatchClause_ts$catchClause = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'CatchClause',
    {
      bindingKeys: {
        param: true,
      },
      visitorKeys: {
        param: true,
        body: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/classes/ClassDeclaration.ts
const ___R$project$rome$$romejs$js$ast$classes$ClassDeclaration_ts = {
    get classDeclaration() {
      return (
        ___R$project$rome$$romejs$js$ast$classes$ClassDeclaration_ts$classDeclaration
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$classes$ClassDeclaration_ts$classDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ClassDeclaration',
    {
      bindingKeys: {
        id: true,
      },
      visitorKeys: {
        id: true,
        meta: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/classes/ClassExpression.ts
const ___R$project$rome$$romejs$js$ast$classes$ClassExpression_ts = {
    get classExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$classes$ClassExpression_ts$classExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$classes$ClassExpression_ts$classExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ClassExpression',
    {
      bindingKeys: {
        id: true,
      },
      visitorKeys: {
        id: true,
        meta: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/classes/ClassHead.ts
const ___R$project$rome$$romejs$js$ast$classes$ClassHead_ts = {
    get classHead() {
      return (
        ___R$project$rome$$romejs$js$ast$classes$ClassHead_ts$classHead
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$classes$ClassHead_ts$classHead = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
    'ClassHead',
    'body',
    {
      bindingKeys: {},
      visitorKeys: {
        superClass: true,
        body: true,
        typeParameters: true,
        superTypeParameters: true,
        implements: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/classes/ClassMethod.ts
const ___R$project$rome$$romejs$js$ast$classes$ClassMethod_ts = {
    get classMethod() {
      return (
        ___R$project$rome$$romejs$js$ast$classes$ClassMethod_ts$classMethod
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$classes$ClassMethod_ts$classMethod = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ClassMethod',
    {
      bindingKeys: {},
      visitorKeys: {
        key: true,
        meta: true,
        head: true,
        body: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/classes/ClassPrivateMethod.ts
const ___R$project$rome$$romejs$js$ast$classes$ClassPrivateMethod_ts = {
    get classPrivateMethod() {
      return (
        ___R$project$rome$$romejs$js$ast$classes$ClassPrivateMethod_ts$classPrivateMethod
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$classes$ClassPrivateMethod_ts$classPrivateMethod = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ClassPrivateMethod',
    {
      bindingKeys: {},
      visitorKeys: {
        key: true,
        meta: true,
        head: true,
        body: true,
        variance: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/classes/ClassPrivateProperty.ts
const ___R$project$rome$$romejs$js$ast$classes$ClassPrivateProperty_ts = {
    get classPrivateProperty() {
      return (
        ___R$project$rome$$romejs$js$ast$classes$ClassPrivateProperty_ts$classPrivateProperty
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$classes$ClassPrivateProperty_ts$classPrivateProperty = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ClassPrivateProperty',
    {
      bindingKeys: {},
      visitorKeys: {
        key: true,
        meta: true,
        value: true,
        typeAnnotation: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/classes/ClassProperty.ts
const ___R$project$rome$$romejs$js$ast$classes$ClassProperty_ts = {
    get classProperty() {
      return (
        ___R$project$rome$$romejs$js$ast$classes$ClassProperty_ts$classProperty
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$classes$ClassProperty_ts$classProperty = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ClassProperty',
    {
      bindingKeys: {},
      visitorKeys: {
        key: true,
        meta: true,
        value: true,
        typeAnnotation: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/classes/ClassPropertyMeta.ts
const ___R$project$rome$$romejs$js$ast$classes$ClassPropertyMeta_ts = {
    get classPropertyMeta() {
      return (
        ___R$project$rome$$romejs$js$ast$classes$ClassPropertyMeta_ts$classPropertyMeta
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$classes$ClassPropertyMeta_ts$classPropertyMeta = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ClassPropertyMeta',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/core/CommentBlock.ts
const ___R$project$rome$$romejs$js$ast$core$CommentBlock_ts = {
    get commentBlock() {
      return (
        ___R$project$rome$$romejs$js$ast$core$CommentBlock_ts$commentBlock
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$core$CommentBlock_ts$commentBlock = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'CommentBlock',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/core/CommentLine.ts
const ___R$project$rome$$romejs$js$ast$core$CommentLine_ts = {
    get commentLine() {
      return (
        ___R$project$rome$$romejs$js$ast$core$CommentLine_ts$commentLine
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$core$CommentLine_ts$commentLine = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'CommentLine',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/auxiliary/ComputedMemberProperty.ts
const ___R$project$rome$$romejs$js$ast$auxiliary$ComputedMemberProperty_ts = {
    get computedMemberProperty() {
      return (
        ___R$project$rome$$romejs$js$ast$auxiliary$ComputedMemberProperty_ts$computedMemberProperty
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$auxiliary$ComputedMemberProperty_ts$computedMemberProperty = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
    'ComputedMemberProperty',
    'value',
    {
      bindingKeys: {},
      visitorKeys: {
        value: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/objects/ComputedPropertyKey.ts
const ___R$project$rome$$romejs$js$ast$objects$ComputedPropertyKey_ts = {
    get computedPropertyKey() {
      return (
        ___R$project$rome$$romejs$js$ast$objects$ComputedPropertyKey_ts$computedPropertyKey
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$objects$ComputedPropertyKey_ts$computedPropertyKey = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
    'ComputedPropertyKey',
    'value',
    {
      bindingKeys: {},
      visitorKeys: {
        variance: true,
        value: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/expressions/ConditionalExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$ConditionalExpression_ts = {
    get conditionalExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$expressions$ConditionalExpression_ts$conditionalExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$expressions$ConditionalExpression_ts$conditionalExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ConditionalExpression',
    {
      bindingKeys: {},
      visitorKeys: {
        test: true,
        consequent: true,
        alternate: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/statements/ContinueStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$ContinueStatement_ts = {
    get continueStatement() {
      return (
        ___R$project$rome$$romejs$js$ast$statements$ContinueStatement_ts$continueStatement
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$statements$ContinueStatement_ts$continueStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ContinueStatement',
    {
      bindingKeys: {},
      visitorKeys: {
        label: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/statements/DebuggerStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$DebuggerStatement_ts = {
    get debuggerStatement() {
      return (
        ___R$project$rome$$romejs$js$ast$statements$DebuggerStatement_ts$debuggerStatement
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$statements$DebuggerStatement_ts$debuggerStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'DebuggerStatement',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/core/Directive.ts
const ___R$project$rome$$romejs$js$ast$core$Directive_ts = {
    get directive() {
      return (
        ___R$project$rome$$romejs$js$ast$core$Directive_ts$directive
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$core$Directive_ts$directive = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'Directive',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/expressions/DoExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$DoExpression_ts = {
    get doExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$expressions$DoExpression_ts$doExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$expressions$DoExpression_ts$doExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'DoExpression',
    {
      bindingKeys: {},
      visitorKeys: {
        body: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/statements/DoWhileStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$DoWhileStatement_ts = {
    get doWhileStatement() {
      return (
        ___R$project$rome$$romejs$js$ast$statements$DoWhileStatement_ts$doWhileStatement
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$statements$DoWhileStatement_ts$doWhileStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'DoWhileStatement',
    {
      bindingKeys: {},
      visitorKeys: {
        test: true,
        body: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/types/EmptyKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$types$EmptyKeywordTypeAnnotation_ts = {
    get emptyKeywordTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$types$EmptyKeywordTypeAnnotation_ts$emptyKeywordTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$types$EmptyKeywordTypeAnnotation_ts$emptyKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'EmptyKeywordTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/statements/EmptyStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$EmptyStatement_ts = {
    get emptyStatement() {
      return (
        ___R$project$rome$$romejs$js$ast$statements$EmptyStatement_ts$emptyStatement
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$statements$EmptyStatement_ts$emptyStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'EmptyStatement',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/modules/ExportAllDeclaration.ts
const ___R$project$rome$$romejs$js$ast$modules$ExportAllDeclaration_ts = {
    get exportAllDeclaration() {
      return (
        ___R$project$rome$$romejs$js$ast$modules$ExportAllDeclaration_ts$exportAllDeclaration
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$modules$ExportAllDeclaration_ts$exportAllDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ExportAllDeclaration',
    {
      bindingKeys: {},
      visitorKeys: {
        source: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/modules/ExportDefaultDeclaration.ts
const ___R$project$rome$$romejs$js$ast$modules$ExportDefaultDeclaration_ts = {
    get exportDefaultDeclaration() {
      return (
        ___R$project$rome$$romejs$js$ast$modules$ExportDefaultDeclaration_ts$exportDefaultDeclaration
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$modules$ExportDefaultDeclaration_ts$exportDefaultDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ExportDefaultDeclaration',
    {
      bindingKeys: {},
      visitorKeys: {
        declaration: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/modules/ExportDefaultSpecifier.ts
const ___R$project$rome$$romejs$js$ast$modules$ExportDefaultSpecifier_ts = {
    get exportDefaultSpecifier() {
      return (
        ___R$project$rome$$romejs$js$ast$modules$ExportDefaultSpecifier_ts$exportDefaultSpecifier
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$modules$ExportDefaultSpecifier_ts$exportDefaultSpecifier = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ExportDefaultSpecifier',
    {
      bindingKeys: {},
      visitorKeys: {
        exported: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/modules/ExportExternalDeclaration.ts
const ___R$project$rome$$romejs$js$ast$modules$ExportExternalDeclaration_ts = {
    get exportExternalDeclaration() {
      return (
        ___R$project$rome$$romejs$js$ast$modules$ExportExternalDeclaration_ts$exportExternalDeclaration
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$modules$ExportExternalDeclaration_ts$exportExternalDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ExportExternalDeclaration',
    {
      bindingKeys: {},
      visitorKeys: {
        specifiers: true,
        source: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/modules/ExportExternalSpecifier.ts
const ___R$project$rome$$romejs$js$ast$modules$ExportExternalSpecifier_ts = {
    get exportExternalSpecifier() {
      return (
        ___R$project$rome$$romejs$js$ast$modules$ExportExternalSpecifier_ts$exportExternalSpecifier
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$modules$ExportExternalSpecifier_ts$exportExternalSpecifier = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ExportExternalSpecifier',
    {
      bindingKeys: {},
      visitorKeys: {
        exported: true,
        local: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/modules/ExportLocalDeclaration.ts
const ___R$project$rome$$romejs$js$ast$modules$ExportLocalDeclaration_ts = {
    get exportLocalDeclaration() {
      return (
        ___R$project$rome$$romejs$js$ast$modules$ExportLocalDeclaration_ts$exportLocalDeclaration
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$modules$ExportLocalDeclaration_ts$exportLocalDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ExportLocalDeclaration',
    {
      bindingKeys: {
        declaration: true,
      },
      visitorKeys: {
        declaration: true,
        specifiers: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/modules/ExportLocalSpecifier.ts
const ___R$project$rome$$romejs$js$ast$modules$ExportLocalSpecifier_ts = {
    get exportLocalSpecifier() {
      return (
        ___R$project$rome$$romejs$js$ast$modules$ExportLocalSpecifier_ts$exportLocalSpecifier
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$modules$ExportLocalSpecifier_ts$exportLocalSpecifier = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ExportLocalSpecifier',
    {
      bindingKeys: {},
      visitorKeys: {
        local: true,
        exported: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/modules/ExportNamespaceSpecifier.ts
const ___R$project$rome$$romejs$js$ast$modules$ExportNamespaceSpecifier_ts = {
    get exportNamespaceSpecifier() {
      return (
        ___R$project$rome$$romejs$js$ast$modules$ExportNamespaceSpecifier_ts$exportNamespaceSpecifier
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$modules$ExportNamespaceSpecifier_ts$exportNamespaceSpecifier = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ExportNamespaceSpecifier',
    {
      bindingKeys: {},
      visitorKeys: {
        exported: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/statements/ExpressionStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$ExpressionStatement_ts = {
    get expressionStatement() {
      return (
        ___R$project$rome$$romejs$js$ast$statements$ExpressionStatement_ts$expressionStatement
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$statements$ExpressionStatement_ts$expressionStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ExpressionStatement',
    {
      bindingKeys: {},
      visitorKeys: {
        expression: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowArrayTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowArrayTypeAnnotation_ts = {
    get flowArrayTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowArrayTypeAnnotation_ts$flowArrayTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowArrayTypeAnnotation_ts$flowArrayTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowArrayTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {
        elementType: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowClassImplements.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowClassImplements_ts = {
    get flowClassImplements() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowClassImplements_ts$flowClassImplements
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowClassImplements_ts$flowClassImplements = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowClassImplements',
    {
      bindingKeys: {},
      visitorKeys: {
        id: true,
        typeParameters: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowDeclareClass.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowDeclareClass_ts = {
    get flowDeclareClass() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowDeclareClass_ts$flowDeclareClass
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowDeclareClass_ts$flowDeclareClass = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowDeclareClass',
    {
      bindingKeys: {
        id: true,
      },
      visitorKeys: {
        id: true,
        typeParameters: true,
        implements: true,
        mixins: true,
        extends: true,
        body: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowDeclaredPredicate.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowDeclaredPredicate_ts = {
    get flowDeclaredPredicate() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowDeclaredPredicate_ts$flowDeclaredPredicate
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowDeclaredPredicate_ts$flowDeclaredPredicate = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowDeclaredPredicate',
    {
      bindingKeys: {},
      visitorKeys: {
        value: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowDeclareExportAll.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowDeclareExportAll_ts = {
    get flowDeclareExportAll() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowDeclareExportAll_ts$flowDeclareExportAll
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowDeclareExportAll_ts$flowDeclareExportAll = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowDeclareExportAll',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowDeclareExportDefault.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowDeclareExportDefault_ts = {
    get flowDeclareExportDefault() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowDeclareExportDefault_ts$flowDeclareExportDefault
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowDeclareExportDefault_ts$flowDeclareExportDefault = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowDeclareExportDefault',
    {
      bindingKeys: {},
      visitorKeys: {
        declaration: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowDeclareExportNamed.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowDeclareExportNamed_ts = {
    get flowDeclareExportNamed() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowDeclareExportNamed_ts$flowDeclareExportNamed
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowDeclareExportNamed_ts$flowDeclareExportNamed = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowDeclareExportNamed',
    {
      bindingKeys: {},
      visitorKeys: {
        specifiers: true,
        declaration: true,
        source: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowDeclareFunction.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowDeclareFunction_ts = {
    get flowDeclareFunction() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowDeclareFunction_ts$flowDeclareFunction
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowDeclareFunction_ts$flowDeclareFunction = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowDeclareFunction',
    {
      bindingKeys: {
        id: true,
      },
      visitorKeys: {
        id: true,
        predicate: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowDeclareInterface.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowDeclareInterface_ts = {
    get flowDeclareInterface() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowDeclareInterface_ts$flowDeclareInterface
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowDeclareInterface_ts$flowDeclareInterface = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowDeclareInterface',
    {
      bindingKeys: {
        id: true,
      },
      visitorKeys: {
        id: true,
        typeParameters: true,
        extends: true,
        implements: true,
        mixins: true,
        body: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowDeclareModule.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowDeclareModule_ts = {
    get flowDeclareModule() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowDeclareModule_ts$flowDeclareModule
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowDeclareModule_ts$flowDeclareModule = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowDeclareModule',
    {
      bindingKeys: {},
      visitorKeys: {
        id: true,
        body: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowDeclareModuleExports.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowDeclareModuleExports_ts = {
    get flowDeclareModuleExports() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowDeclareModuleExports_ts$flowDeclareModuleExports
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowDeclareModuleExports_ts$flowDeclareModuleExports = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowDeclareModuleExports',
    {
      bindingKeys: {},
      visitorKeys: {
        typeAnnotation: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowDeclareOpaqueType.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowDeclareOpaqueType_ts = {
    get flowDeclareOpaqueType() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowDeclareOpaqueType_ts$flowDeclareOpaqueType
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowDeclareOpaqueType_ts$flowDeclareOpaqueType = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowDeclareOpaqueType',
    {
      bindingKeys: {
        id: true,
      },
      visitorKeys: {
        id: true,
        typeParameters: true,
        supertype: true,
        impltype: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowDeclareVariable.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowDeclareVariable_ts = {
    get flowDeclareVariable() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowDeclareVariable_ts$flowDeclareVariable
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowDeclareVariable_ts$flowDeclareVariable = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowDeclareVariable',
    {
      bindingKeys: {
        id: true,
      },
      visitorKeys: {
        id: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowExistsTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowExistsTypeAnnotation_ts = {
    get flowExistsTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowExistsTypeAnnotation_ts$flowExistsTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowExistsTypeAnnotation_ts$flowExistsTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowExistsTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowFunctionTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowFunctionTypeAnnotation_ts = {
    get flowFunctionTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowFunctionTypeAnnotation_ts$flowFunctionTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowFunctionTypeAnnotation_ts$flowFunctionTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowFunctionTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {
        typeParameters: true,
        params: true,
        rest: true,
        returnType: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/patterns/PatternMeta.ts
const ___R$project$rome$$romejs$js$ast$patterns$PatternMeta_ts = {
    get patternMeta() {
      return (
        ___R$project$rome$$romejs$js$ast$patterns$PatternMeta_ts$patternMeta
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$patterns$PatternMeta_ts$patternMeta = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
    'PatternMeta',
    'typeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {
        typeAnnotation: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowFunctionTypeParam.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowFunctionTypeParam_ts = {
    get flowFunctionTypeParam() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowFunctionTypeParam_ts$flowFunctionTypeParam
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowFunctionTypeParam_ts$flowFunctionTypeParam = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowFunctionTypeParam',
    {
      bindingKeys: {},
      visitorKeys: {
        name: true,
        meta: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowGenericTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowGenericTypeAnnotation_ts = {
    get flowGenericTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowGenericTypeAnnotation_ts$flowGenericTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowGenericTypeAnnotation_ts$flowGenericTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowGenericTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {
        id: true,
        typeParameters: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowInferredPredicate.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowInferredPredicate_ts = {
    get flowInferredPredicate() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowInferredPredicate_ts$flowInferredPredicate
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowInferredPredicate_ts$flowInferredPredicate = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowInferredPredicate',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowInterface.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowInterface_ts = {
    get flowInterface() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowInterface_ts$flowInterface
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowInterface_ts$flowInterface = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowInterface',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowInterfaceDeclaration.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowInterfaceDeclaration_ts = {
    get flowInterfaceDeclaration() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowInterfaceDeclaration_ts$flowInterfaceDeclaration
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowInterfaceDeclaration_ts$flowInterfaceDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowInterfaceDeclaration',
    {
      bindingKeys: {
        id: true,
      },
      visitorKeys: {
        id: true,
        typeParameters: true,
        extends: true,
        mixins: true,
        implements: true,
        body: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowInterfaceExtends.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowInterfaceExtends_ts = {
    get flowInterfaceExtends() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowInterfaceExtends_ts$flowInterfaceExtends
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowInterfaceExtends_ts$flowInterfaceExtends = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowInterfaceExtends',
    {
      bindingKeys: {},
      visitorKeys: {
        id: true,
        typeParameters: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowInterfaceTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowInterfaceTypeAnnotation_ts = {
    get flowInterfaceTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowInterfaceTypeAnnotation_ts$flowInterfaceTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowInterfaceTypeAnnotation_ts$flowInterfaceTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowInterfaceTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {
        body: true,
        extends: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowNullableTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowNullableTypeAnnotation_ts = {
    get flowNullableTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowNullableTypeAnnotation_ts$flowNullableTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowNullableTypeAnnotation_ts$flowNullableTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowNullableTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {
        typeAnnotation: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowNumericLiteral.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowNumericLiteral_ts = {
    get flowNumericLiteral() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowNumericLiteral_ts$flowNumericLiteral
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowNumericLiteral_ts$flowNumericLiteral = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowNumericLiteral',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowObjectTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeAnnotation_ts = {
    get flowObjectTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeAnnotation_ts$flowObjectTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeAnnotation_ts$flowObjectTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowObjectTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {
        properties: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowObjectTypeCallProperty.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeCallProperty_ts = {
    get flowObjectTypeCallProperty() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeCallProperty_ts$flowObjectTypeCallProperty
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeCallProperty_ts$flowObjectTypeCallProperty = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowObjectTypeCallProperty',
    {
      bindingKeys: {},
      visitorKeys: {
        value: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowObjectTypeIndexer.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeIndexer_ts = {
    get flowObjectTypeIndexer() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeIndexer_ts$flowObjectTypeIndexer
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeIndexer_ts$flowObjectTypeIndexer = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowObjectTypeIndexer',
    {
      bindingKeys: {},
      visitorKeys: {
        id: true,
        key: true,
        value: true,
        variance: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowObjectTypeInternalSlot.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeInternalSlot_ts = {
    get flowObjectTypeInternalSlot() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeInternalSlot_ts$flowObjectTypeInternalSlot
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeInternalSlot_ts$flowObjectTypeInternalSlot = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowObjectTypeInternalSlot',
    {
      bindingKeys: {},
      visitorKeys: {
        id: true,
        value: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowObjectTypeProperty.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeProperty_ts = {
    get flowObjectTypeProperty() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeProperty_ts$flowObjectTypeProperty
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeProperty_ts$flowObjectTypeProperty = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowObjectTypeProperty',
    {
      bindingKeys: {},
      visitorKeys: {
        key: true,
        value: true,
        variance: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowObjectTypeSpreadProperty.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeSpreadProperty_ts = {
    get flowObjectTypeSpreadProperty() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeSpreadProperty_ts$flowObjectTypeSpreadProperty
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeSpreadProperty_ts$flowObjectTypeSpreadProperty = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowObjectTypeSpreadProperty',
    {
      bindingKeys: {},
      visitorKeys: {
        argument: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowOpaqueType.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowOpaqueType_ts = {
    get flowOpaqueType() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowOpaqueType_ts$flowOpaqueType
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowOpaqueType_ts$flowOpaqueType = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowOpaqueType',
    {
      bindingKeys: {
        id: true,
      },
      visitorKeys: {
        id: true,
        typeParameters: true,
        impltype: true,
        supertype: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowQualifiedTypeIdentifier.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowQualifiedTypeIdentifier_ts = {
    get flowQualifiedTypeIdentifier() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowQualifiedTypeIdentifier_ts$flowQualifiedTypeIdentifier
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowQualifiedTypeIdentifier_ts$flowQualifiedTypeIdentifier = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowQualifiedTypeIdentifier',
    {
      bindingKeys: {},
      visitorKeys: {
        id: true,
        qualification: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowThisTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowThisTypeAnnotation_ts = {
    get flowThisTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowThisTypeAnnotation_ts$flowThisTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowThisTypeAnnotation_ts$flowThisTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowThisTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowTupleTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowTupleTypeAnnotation_ts = {
    get flowTupleTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowTupleTypeAnnotation_ts$flowTupleTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowTupleTypeAnnotation_ts$flowTupleTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowTupleTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {
        types: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowTypeCastExpression.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowTypeCastExpression_ts = {
    get flowTypeCastExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowTypeCastExpression_ts$flowTypeCastExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowTypeCastExpression_ts$flowTypeCastExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowTypeCastExpression',
    {
      bindingKeys: {},
      visitorKeys: {
        expression: true,
        typeAnnotation: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowTypeofTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowTypeofTypeAnnotation_ts = {
    get flowTypeofTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowTypeofTypeAnnotation_ts$flowTypeofTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowTypeofTypeAnnotation_ts$flowTypeofTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowTypeofTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {
        argument: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowTypeParameter.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowTypeParameter_ts = {
    get flowTypeParameter() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowTypeParameter_ts$flowTypeParameter
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowTypeParameter_ts$flowTypeParameter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowTypeParameter',
    {
      bindingKeys: {},
      visitorKeys: {
        bound: true,
        default: true,
        variance: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowTypeParameterDeclaration.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowTypeParameterDeclaration_ts = {
    get flowTypeParameterDeclaration() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowTypeParameterDeclaration_ts$flowTypeParameterDeclaration
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowTypeParameterDeclaration_ts$flowTypeParameterDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowTypeParameterDeclaration',
    {
      bindingKeys: {},
      visitorKeys: {
        params: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowTypeParameterInstantiation.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowTypeParameterInstantiation_ts = {
    get flowTypeParameterInstantiation() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowTypeParameterInstantiation_ts$flowTypeParameterInstantiation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowTypeParameterInstantiation_ts$flowTypeParameterInstantiation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowTypeParameterInstantiation',
    {
      bindingKeys: {},
      visitorKeys: {
        params: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/flow/FlowVariance.ts
const ___R$project$rome$$romejs$js$ast$flow$FlowVariance_ts = {
    get flowVariance() {
      return (
        ___R$project$rome$$romejs$js$ast$flow$FlowVariance_ts$flowVariance
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$flow$FlowVariance_ts$flowVariance = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FlowVariance',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/statements/ForInStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$ForInStatement_ts = {
    get forInStatement() {
      return (
        ___R$project$rome$$romejs$js$ast$statements$ForInStatement_ts$forInStatement
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$statements$ForInStatement_ts$forInStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ForInStatement',
    {
      bindingKeys: {},
      visitorKeys: {
        left: true,
        right: true,
        body: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/statements/ForOfStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$ForOfStatement_ts = {
    get forOfStatement() {
      return (
        ___R$project$rome$$romejs$js$ast$statements$ForOfStatement_ts$forOfStatement
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$statements$ForOfStatement_ts$forOfStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ForOfStatement',
    {
      bindingKeys: {},
      visitorKeys: {
        left: true,
        right: true,
        body: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/statements/ForStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$ForStatement_ts = {
    get forStatement() {
      return (
        ___R$project$rome$$romejs$js$ast$statements$ForStatement_ts$forStatement
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$statements$ForStatement_ts$forStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ForStatement',
    {
      bindingKeys: {},
      visitorKeys: {
        init: true,
        test: true,
        update: true,
        body: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/statements/FunctionDeclaration.ts
const ___R$project$rome$$romejs$js$ast$statements$FunctionDeclaration_ts = {
    get functionDeclaration() {
      return (
        ___R$project$rome$$romejs$js$ast$statements$FunctionDeclaration_ts$functionDeclaration
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$statements$FunctionDeclaration_ts$functionDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FunctionDeclaration',
    {
      bindingKeys: {
        id: true,
      },
      visitorKeys: {
        head: true,
        id: true,
        body: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/expressions/FunctionExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$FunctionExpression_ts = {
    get functionExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$expressions$FunctionExpression_ts$functionExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$expressions$FunctionExpression_ts$functionExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'FunctionExpression',
    {
      bindingKeys: {
        id: true,
      },
      visitorKeys: {
        head: true,
        id: true,
        body: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/auxiliary/FunctionHead.ts
const ___R$project$rome$$romejs$js$ast$auxiliary$FunctionHead_ts = {
    get functionHead() {
      return (
        ___R$project$rome$$romejs$js$ast$auxiliary$FunctionHead_ts$functionHead
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$auxiliary$FunctionHead_ts$functionHead = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
    'FunctionHead',
    'params',
    {
      bindingKeys: {
        params: true,
        rest: true,
      },
      visitorKeys: {
        params: true,
        thisType: true,
        rest: true,
        returnType: true,
        typeParameters: true,
        predicate: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/auxiliary/Identifier.ts
const ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts = {
    get identifier() {
      return (
        ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
    'Identifier',
    'name',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/statements/IfStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$IfStatement_ts = {
    get ifStatement() {
      return (
        ___R$project$rome$$romejs$js$ast$statements$IfStatement_ts$ifStatement
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$statements$IfStatement_ts$ifStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'IfStatement',
    {
      bindingKeys: {},
      visitorKeys: {
        test: true,
        consequent: true,
        alternate: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/modules/ImportCall.ts
const ___R$project$rome$$romejs$js$ast$modules$ImportCall_ts = {
    get importCall() {
      return (
        ___R$project$rome$$romejs$js$ast$modules$ImportCall_ts$importCall
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$modules$ImportCall_ts$importCall = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ImportCall',
    {
      bindingKeys: {},
      visitorKeys: {
        argument: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/modules/ImportDeclaration.ts
const ___R$project$rome$$romejs$js$ast$modules$ImportDeclaration_ts = {
    get importDeclaration() {
      return (
        ___R$project$rome$$romejs$js$ast$modules$ImportDeclaration_ts$importDeclaration
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$modules$ImportDeclaration_ts$importDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ImportDeclaration',
    {
      bindingKeys: {},
      visitorKeys: {
        specifiers: true,
        source: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/modules/ImportDefaultSpecifier.ts
const ___R$project$rome$$romejs$js$ast$modules$ImportDefaultSpecifier_ts = {
    get importDefaultSpecifier() {
      return (
        ___R$project$rome$$romejs$js$ast$modules$ImportDefaultSpecifier_ts$importDefaultSpecifier
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$modules$ImportDefaultSpecifier_ts$importDefaultSpecifier = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ImportDefaultSpecifier',
    {
      bindingKeys: {
        local: true,
      },
      visitorKeys: {
        local: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/modules/ImportNamespaceSpecifier.ts
const ___R$project$rome$$romejs$js$ast$modules$ImportNamespaceSpecifier_ts = {
    get importNamespaceSpecifier() {
      return (
        ___R$project$rome$$romejs$js$ast$modules$ImportNamespaceSpecifier_ts$importNamespaceSpecifier
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$modules$ImportNamespaceSpecifier_ts$importNamespaceSpecifier = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ImportNamespaceSpecifier',
    {
      bindingKeys: {
        local: true,
      },
      visitorKeys: {
        local: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/modules/ImportSpecifier.ts
const ___R$project$rome$$romejs$js$ast$modules$ImportSpecifier_ts = {
    get importSpecifier() {
      return (
        ___R$project$rome$$romejs$js$ast$modules$ImportSpecifier_ts$importSpecifier
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$modules$ImportSpecifier_ts$importSpecifier = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ImportSpecifier',
    {
      bindingKeys: {
        local: true,
      },
      visitorKeys: {
        imported: true,
        local: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/modules/ImportSpecifierLocal.ts
const ___R$project$rome$$romejs$js$ast$modules$ImportSpecifierLocal_ts = {
    get importSpecifierLocal() {
      return (
        ___R$project$rome$$romejs$js$ast$modules$ImportSpecifierLocal_ts$importSpecifierLocal
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$modules$ImportSpecifierLocal_ts$importSpecifierLocal = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
    'ImportSpecifierLocal',
    'name',
    {
      bindingKeys: {
        name: true,
      },
      visitorKeys: {
        name: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/core/InterpreterDirective.ts
const ___R$project$rome$$romejs$js$ast$core$InterpreterDirective_ts = {
    get interpreterDirective() {
      return (
        ___R$project$rome$$romejs$js$ast$core$InterpreterDirective_ts$interpreterDirective
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$core$InterpreterDirective_ts$interpreterDirective = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'InterpreterDirective',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/types/IntersectionTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$types$IntersectionTypeAnnotation_ts = {
    get intersectionTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$types$IntersectionTypeAnnotation_ts$intersectionTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$types$IntersectionTypeAnnotation_ts$intersectionTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'IntersectionTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {
        types: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/jsx/JSXAttribute.ts
const ___R$project$rome$$romejs$js$ast$jsx$JSXAttribute_ts = {
    get jsxAttribute() {
      return (
        ___R$project$rome$$romejs$js$ast$jsx$JSXAttribute_ts$jsxAttribute
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$jsx$JSXAttribute_ts$jsxAttribute = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'JSXAttribute',
    {
      bindingKeys: {},
      visitorKeys: {
        name: true,
        value: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/jsx/JSXElement.ts
const ___R$project$rome$$romejs$js$ast$jsx$JSXElement_ts = {
    get jsxElement() {
      return (
        ___R$project$rome$$romejs$js$ast$jsx$JSXElement_ts$jsxElement
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$jsx$JSXElement_ts$jsxElement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'JSXElement',
    {
      bindingKeys: {},
      visitorKeys: {
        name: true,
        typeArguments: true,
        attributes: true,
        children: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/jsx/JSXEmptyExpression.ts
const ___R$project$rome$$romejs$js$ast$jsx$JSXEmptyExpression_ts = {
    get jsxEmptyExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$jsx$JSXEmptyExpression_ts$jsxEmptyExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$jsx$JSXEmptyExpression_ts$jsxEmptyExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'JSXEmptyExpression',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/jsx/JSXExpressionContainer.ts
const ___R$project$rome$$romejs$js$ast$jsx$JSXExpressionContainer_ts = {
    get jsxExpressionContainer() {
      return (
        ___R$project$rome$$romejs$js$ast$jsx$JSXExpressionContainer_ts$jsxExpressionContainer
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$jsx$JSXExpressionContainer_ts$jsxExpressionContainer = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'JSXExpressionContainer',
    {
      bindingKeys: {},
      visitorKeys: {
        expression: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/jsx/JSXFragment.ts
const ___R$project$rome$$romejs$js$ast$jsx$JSXFragment_ts = {
    get jsxFragment() {
      return (
        ___R$project$rome$$romejs$js$ast$jsx$JSXFragment_ts$jsxFragment
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$jsx$JSXFragment_ts$jsxFragment = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'JSXFragment',
    {
      bindingKeys: {},
      visitorKeys: {
        children: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/jsx/JSXIdentifier.ts
const ___R$project$rome$$romejs$js$ast$jsx$JSXIdentifier_ts = {
    get jsxIdentifier() {
      return (
        ___R$project$rome$$romejs$js$ast$jsx$JSXIdentifier_ts$jsxIdentifier
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$jsx$JSXIdentifier_ts$jsxIdentifier = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
    'JSXIdentifier',
    'name',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/jsx/JSXMemberExpression.ts
const ___R$project$rome$$romejs$js$ast$jsx$JSXMemberExpression_ts = {
    get jsxMemberExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$jsx$JSXMemberExpression_ts$jsxMemberExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$jsx$JSXMemberExpression_ts$jsxMemberExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'JSXMemberExpression',
    {
      bindingKeys: {},
      visitorKeys: {
        object: true,
        property: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/jsx/JSXNamespacedName.ts
const ___R$project$rome$$romejs$js$ast$jsx$JSXNamespacedName_ts = {
    get jsxNamespacedName() {
      return (
        ___R$project$rome$$romejs$js$ast$jsx$JSXNamespacedName_ts$jsxNamespacedName
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$jsx$JSXNamespacedName_ts$jsxNamespacedName = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'JSXNamespacedName',
    {
      bindingKeys: {},
      visitorKeys: {
        namespace: true,
        name: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/jsx/JSXReferenceIdentifier.ts
const ___R$project$rome$$romejs$js$ast$jsx$JSXReferenceIdentifier_ts = {
    get jsxReferenceIdentifier() {
      return (
        ___R$project$rome$$romejs$js$ast$jsx$JSXReferenceIdentifier_ts$jsxReferenceIdentifier
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$jsx$JSXReferenceIdentifier_ts$jsxReferenceIdentifier = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'JSXReferenceIdentifier',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/jsx/JSXSpreadAttribute.ts
const ___R$project$rome$$romejs$js$ast$jsx$JSXSpreadAttribute_ts = {
    get jsxSpreadAttribute() {
      return (
        ___R$project$rome$$romejs$js$ast$jsx$JSXSpreadAttribute_ts$jsxSpreadAttribute
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$jsx$JSXSpreadAttribute_ts$jsxSpreadAttribute = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'JSXSpreadAttribute',
    {
      bindingKeys: {},
      visitorKeys: {
        argument: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/jsx/JSXSpreadChild.ts
const ___R$project$rome$$romejs$js$ast$jsx$JSXSpreadChild_ts = {
    get jsxSpreadChild() {
      return (
        ___R$project$rome$$romejs$js$ast$jsx$JSXSpreadChild_ts$jsxSpreadChild
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$jsx$JSXSpreadChild_ts$jsxSpreadChild = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'JSXSpreadChild',
    {
      bindingKeys: {},
      visitorKeys: {
        expression: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/jsx/JSXText.ts
const ___R$project$rome$$romejs$js$ast$jsx$JSXText_ts = {
    get jsxText() {
      return (
        ___R$project$rome$$romejs$js$ast$jsx$JSXText_ts$jsxText
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$jsx$JSXText_ts$jsxText = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'JSXText',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/statements/LabeledStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$LabeledStatement_ts = {
    get labeledStatement() {
      return (
        ___R$project$rome$$romejs$js$ast$statements$LabeledStatement_ts$labeledStatement
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$statements$LabeledStatement_ts$labeledStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'LabeledStatement',
    {
      bindingKeys: {},
      visitorKeys: {
        label: true,
        body: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/expressions/LogicalExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$LogicalExpression_ts = {
    get logicalExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$expressions$LogicalExpression_ts$logicalExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$expressions$LogicalExpression_ts$logicalExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'LogicalExpression',
    {
      bindingKeys: {},
      visitorKeys: {
        left: true,
        right: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/expressions/MemberExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$MemberExpression_ts = {
    get memberExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$expressions$MemberExpression_ts$memberExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$expressions$MemberExpression_ts$memberExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'MemberExpression',
    {
      bindingKeys: {},
      visitorKeys: {
        object: true,
        property: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/expressions/MetaProperty.ts
const ___R$project$rome$$romejs$js$ast$expressions$MetaProperty_ts = {
    get metaProperty() {
      return (
        ___R$project$rome$$romejs$js$ast$expressions$MetaProperty_ts$metaProperty
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$expressions$MetaProperty_ts$metaProperty = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'MetaProperty',
    {
      bindingKeys: {},
      visitorKeys: {
        meta: true,
        property: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/types/MixedKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$types$MixedKeywordTypeAnnotation_ts = {
    get mixedKeywordTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$types$MixedKeywordTypeAnnotation_ts$mixedKeywordTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$types$MixedKeywordTypeAnnotation_ts$mixedKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'MixedKeywordTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/temp/MockParent.ts
const ___R$project$rome$$romejs$js$ast$temp$MockParent_ts = {
    get mockParent() {
      return (
        ___R$project$rome$$romejs$js$ast$temp$MockParent_ts$mockParent
      );
    },

    get MOCK_PARENT() {
      return (
        ___R$project$rome$$romejs$js$ast$temp$MockParent_ts$MOCK_PARENT
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$temp$MockParent_ts$mockParent = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'MockParent',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  const ___R$project$rome$$romejs$js$ast$temp$MockParent_ts$MOCK_PARENT = {
    type: 'MockParent',
  };

  // project-rome/@romejs/js-ast/types/NeverKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$types$NeverKeywordTypeAnnotation_ts = {
    get neverKeywordTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$types$NeverKeywordTypeAnnotation_ts$neverKeywordTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$types$NeverKeywordTypeAnnotation_ts$neverKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'NeverKeywordTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/expressions/NewExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$NewExpression_ts = {
    get newExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$expressions$NewExpression_ts$newExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$expressions$NewExpression_ts$newExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'NewExpression',
    {
      bindingKeys: {},
      visitorKeys: {
        callee: true,
        arguments: true,
        typeArguments: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/types/NullKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$types$NullKeywordTypeAnnotation_ts = {
    get nullKeywordTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$types$NullKeywordTypeAnnotation_ts$nullKeywordTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$types$NullKeywordTypeAnnotation_ts$nullKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'NullKeywordTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/literals/NullLiteral.ts
const ___R$project$rome$$romejs$js$ast$literals$NullLiteral_ts = {
    get nullLiteral() {
      return (
        ___R$project$rome$$romejs$js$ast$literals$NullLiteral_ts$nullLiteral
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$literals$NullLiteral_ts$nullLiteral = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'NullLiteral',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/types/NumberKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$types$NumberKeywordTypeAnnotation_ts = {
    get numberKeywordTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$types$NumberKeywordTypeAnnotation_ts$numberKeywordTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$types$NumberKeywordTypeAnnotation_ts$numberKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'NumberKeywordTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/literals/NumericLiteral.ts
const ___R$project$rome$$romejs$js$ast$literals$NumericLiteral_ts = {
    get numericLiteral() {
      return (
        ___R$project$rome$$romejs$js$ast$literals$NumericLiteral_ts$numericLiteral
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$literals$NumericLiteral_ts$numericLiteral = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'NumericLiteral',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/types/NumericLiteralTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$types$NumericLiteralTypeAnnotation_ts = {
    get numericLiteralTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$types$NumericLiteralTypeAnnotation_ts$numericLiteralTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$types$NumericLiteralTypeAnnotation_ts$numericLiteralTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'NumericLiteralTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/objects/ObjectExpression.ts
const ___R$project$rome$$romejs$js$ast$objects$ObjectExpression_ts = {
    get objectExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$objects$ObjectExpression_ts$objectExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$objects$ObjectExpression_ts$objectExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
    'ObjectExpression',
    'properties',
    {
      bindingKeys: {},
      visitorKeys: {
        properties: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/types/ObjectKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$types$ObjectKeywordTypeAnnotation_ts = {
    get objectKeywordTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$types$ObjectKeywordTypeAnnotation_ts$objectKeywordTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$types$ObjectKeywordTypeAnnotation_ts$objectKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ObjectKeywordTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/objects/ObjectMethod.ts
const ___R$project$rome$$romejs$js$ast$objects$ObjectMethod_ts = {
    get objectMethod() {
      return (
        ___R$project$rome$$romejs$js$ast$objects$ObjectMethod_ts$objectMethod
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$objects$ObjectMethod_ts$objectMethod = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ObjectMethod',
    {
      bindingKeys: {},
      visitorKeys: {
        key: true,
        head: true,
        body: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/objects/ObjectProperty.ts
const ___R$project$rome$$romejs$js$ast$objects$ObjectProperty_ts = {
    get objectProperty() {
      return (
        ___R$project$rome$$romejs$js$ast$objects$ObjectProperty_ts$objectProperty
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$objects$ObjectProperty_ts$objectProperty = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ObjectProperty',
    {
      bindingKeys: {},
      visitorKeys: {
        key: true,
        value: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/expressions/OptionalCallExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$OptionalCallExpression_ts = {
    get optionalCallExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$expressions$OptionalCallExpression_ts$optionalCallExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$expressions$OptionalCallExpression_ts$optionalCallExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'OptionalCallExpression',
    {
      bindingKeys: {},
      visitorKeys: {
        callee: true,
        arguments: true,
        typeArguments: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/classes/PrivateName.ts
const ___R$project$rome$$romejs$js$ast$classes$PrivateName_ts = {
    get privateName() {
      return (
        ___R$project$rome$$romejs$js$ast$classes$PrivateName_ts$privateName
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$classes$PrivateName_ts$privateName = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'PrivateName',
    {
      bindingKeys: {},
      visitorKeys: {
        id: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/core/Program.ts
const ___R$project$rome$$romejs$js$ast$core$Program_ts = {
    get MOCK_PROGRAM() {
      return (
        ___R$project$rome$$romejs$js$ast$core$Program_ts$MOCK_PROGRAM
      );
    },

    get program() {
      return (
        ___R$project$rome$$romejs$js$ast$core$Program_ts$program
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$core$Program_ts$MOCK_PROGRAM = {
    type: 'Program',
    directives: [],
    body: [],
    filename: 'unknown',
    mtime: undefined,
    interpreter: undefined,
    corrupt: false,
    sourceType: 'module',
    diagnostics: [],
    comments: [],
    syntax: [],
    hasHoistedVars: false,
  };

  const ___R$project$rome$$romejs$js$ast$core$Program_ts$program = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'Program',
    {
      bindingKeys: {},
      visitorKeys: {
        interpreter: true,
        directives: true,
        body: true,
        comments: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/expressions/ReferenceIdentifier.ts
const ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts = {
    get referenceIdentifier() {
      return (
        ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
    'ReferenceIdentifier',
    'name',
    {
      bindingKeys: {},
      visitorKeys: {
        meta: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/regex/RegExpAlternation.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpAlternation_ts = {
    get regExpAlternation() {
      return (
        ___R$project$rome$$romejs$js$ast$regex$RegExpAlternation_ts$regExpAlternation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$regex$RegExpAlternation_ts$regExpAlternation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'RegExpAlternation',
    {
      bindingKeys: {},
      visitorKeys: {
        left: true,
        right: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/regex/RegExpAnyCharacter.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpAnyCharacter_ts = {
    get regExpAnyCharacter() {
      return (
        ___R$project$rome$$romejs$js$ast$regex$RegExpAnyCharacter_ts$regExpAnyCharacter
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$regex$RegExpAnyCharacter_ts$regExpAnyCharacter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'RegExpAnyCharacter',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/regex/RegExpCharacter.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpCharacter_ts = {
    get regExpCharacter() {
      return (
        ___R$project$rome$$romejs$js$ast$regex$RegExpCharacter_ts$regExpCharacter
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$regex$RegExpCharacter_ts$regExpCharacter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'RegExpCharacter',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/regex/RegExpCharSet.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpCharSet_ts = {
    get regExpCharSet() {
      return (
        ___R$project$rome$$romejs$js$ast$regex$RegExpCharSet_ts$regExpCharSet
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$regex$RegExpCharSet_ts$regExpCharSet = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'RegExpCharSet',
    {
      bindingKeys: {},
      visitorKeys: {
        body: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/regex/RegExpCharSetRange.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpCharSetRange_ts = {
    get regExpCharSetRange() {
      return (
        ___R$project$rome$$romejs$js$ast$regex$RegExpCharSetRange_ts$regExpCharSetRange
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$regex$RegExpCharSetRange_ts$regExpCharSetRange = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'RegExpCharSetRange',
    {
      bindingKeys: {},
      visitorKeys: {
        start: true,
        end: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/regex/RegExpControlCharacter.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpControlCharacter_ts = {
    get regExpControlCharacter() {
      return (
        ___R$project$rome$$romejs$js$ast$regex$RegExpControlCharacter_ts$regExpControlCharacter
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$regex$RegExpControlCharacter_ts$regExpControlCharacter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'RegExpControlCharacter',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/regex/RegExpDigitCharacter.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpDigitCharacter_ts = {
    get regExpDigitCharacter() {
      return (
        ___R$project$rome$$romejs$js$ast$regex$RegExpDigitCharacter_ts$regExpDigitCharacter
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$regex$RegExpDigitCharacter_ts$regExpDigitCharacter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'RegExpDigitCharacter',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/regex/RegExpEndCharacter.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpEndCharacter_ts = {
    get regExpEndCharacter() {
      return (
        ___R$project$rome$$romejs$js$ast$regex$RegExpEndCharacter_ts$regExpEndCharacter
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$regex$RegExpEndCharacter_ts$regExpEndCharacter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'RegExpEndCharacter',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/regex/RegExpGroupCapture.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpGroupCapture_ts = {
    get regExpGroupCapture() {
      return (
        ___R$project$rome$$romejs$js$ast$regex$RegExpGroupCapture_ts$regExpGroupCapture
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$regex$RegExpGroupCapture_ts$regExpGroupCapture = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'RegExpGroupCapture',
    {
      bindingKeys: {},
      visitorKeys: {
        expression: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/regex/RegExpGroupNonCapture.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpGroupNonCapture_ts = {
    get regExpGroupNonCapture() {
      return (
        ___R$project$rome$$romejs$js$ast$regex$RegExpGroupNonCapture_ts$regExpGroupNonCapture
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$regex$RegExpGroupNonCapture_ts$regExpGroupNonCapture = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'RegExpGroupNonCapture',
    {
      bindingKeys: {},
      visitorKeys: {
        expression: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/literals/RegExpLiteral.ts
const ___R$project$rome$$romejs$js$ast$literals$RegExpLiteral_ts = {
    get regExpLiteral() {
      return (
        ___R$project$rome$$romejs$js$ast$literals$RegExpLiteral_ts$regExpLiteral
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$literals$RegExpLiteral_ts$regExpLiteral = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'RegExpLiteral',
    {
      bindingKeys: {},
      visitorKeys: {
        expression: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/regex/RegExpNonDigitCharacter.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpNonDigitCharacter_ts = {
    get regExpNonDigitCharacter() {
      return (
        ___R$project$rome$$romejs$js$ast$regex$RegExpNonDigitCharacter_ts$regExpNonDigitCharacter
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$regex$RegExpNonDigitCharacter_ts$regExpNonDigitCharacter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'RegExpNonDigitCharacter',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/regex/RegExpNonWhiteSpaceCharacter.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpNonWhiteSpaceCharacter_ts = {
    get regExpNonWhiteSpaceCharacter() {
      return (
        ___R$project$rome$$romejs$js$ast$regex$RegExpNonWhiteSpaceCharacter_ts$regExpNonWhiteSpaceCharacter
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$regex$RegExpNonWhiteSpaceCharacter_ts$regExpNonWhiteSpaceCharacter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'RegExpNonWhiteSpaceCharacter',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/regex/RegExpNonWordBoundaryCharacter.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpNonWordBoundaryCharacter_ts = {
    get regExpNonWordBoundaryCharacter() {
      return (
        ___R$project$rome$$romejs$js$ast$regex$RegExpNonWordBoundaryCharacter_ts$regExpNonWordBoundaryCharacter
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$regex$RegExpNonWordBoundaryCharacter_ts$regExpNonWordBoundaryCharacter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'RegExpNonWordBoundaryCharacter',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/regex/RegExpNonWordCharacter.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpNonWordCharacter_ts = {
    get regExpNonWordCharacter() {
      return (
        ___R$project$rome$$romejs$js$ast$regex$RegExpNonWordCharacter_ts$regExpNonWordCharacter
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$regex$RegExpNonWordCharacter_ts$regExpNonWordCharacter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'RegExpNonWordCharacter',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/regex/RegExpQuantified.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpQuantified_ts = {
    get regExpQuantified() {
      return (
        ___R$project$rome$$romejs$js$ast$regex$RegExpQuantified_ts$regExpQuantified
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$regex$RegExpQuantified_ts$regExpQuantified = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'RegExpQuantified',
    {
      bindingKeys: {},
      visitorKeys: {
        target: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/regex/RegExpStartCharacter.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpStartCharacter_ts = {
    get regExpStartCharacter() {
      return (
        ___R$project$rome$$romejs$js$ast$regex$RegExpStartCharacter_ts$regExpStartCharacter
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$regex$RegExpStartCharacter_ts$regExpStartCharacter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'RegExpStartCharacter',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/regex/RegExpSubExpression.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpSubExpression_ts = {
    get regExpSubExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$regex$RegExpSubExpression_ts$regExpSubExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$regex$RegExpSubExpression_ts$regExpSubExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'RegExpSubExpression',
    {
      bindingKeys: {},
      visitorKeys: {
        body: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/regex/RegExpWhiteSpaceCharacter.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpWhiteSpaceCharacter_ts = {
    get regExpWhiteSpaceCharacter() {
      return (
        ___R$project$rome$$romejs$js$ast$regex$RegExpWhiteSpaceCharacter_ts$regExpWhiteSpaceCharacter
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$regex$RegExpWhiteSpaceCharacter_ts$regExpWhiteSpaceCharacter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'RegExpWhiteSpaceCharacter',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/regex/RegExpWordBoundaryCharacter.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpWordBoundaryCharacter_ts = {
    get regExpWordBoundaryCharacter() {
      return (
        ___R$project$rome$$romejs$js$ast$regex$RegExpWordBoundaryCharacter_ts$regExpWordBoundaryCharacter
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$regex$RegExpWordBoundaryCharacter_ts$regExpWordBoundaryCharacter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'RegExpWordBoundaryCharacter',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/regex/RegExpWordCharacter.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpWordCharacter_ts = {
    get regExpWordCharacter() {
      return (
        ___R$project$rome$$romejs$js$ast$regex$RegExpWordCharacter_ts$regExpWordCharacter
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$regex$RegExpWordCharacter_ts$regExpWordCharacter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'RegExpWordCharacter',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/statements/ReturnStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$ReturnStatement_ts = {
    get returnStatement() {
      return (
        ___R$project$rome$$romejs$js$ast$statements$ReturnStatement_ts$returnStatement
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$statements$ReturnStatement_ts$returnStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
    'ReturnStatement',
    'argument',
    {
      bindingKeys: {},
      visitorKeys: {
        argument: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/expressions/SequenceExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$SequenceExpression_ts = {
    get sequenceExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$expressions$SequenceExpression_ts$sequenceExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$expressions$SequenceExpression_ts$sequenceExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'SequenceExpression',
    {bindingKeys: {}, visitorKeys: {expressions: true}},
  );

  // project-rome/@romejs/js-ast/auxiliary/SpreadElement.ts
const ___R$project$rome$$romejs$js$ast$auxiliary$SpreadElement_ts = {
    get spreadElement() {
      return (
        ___R$project$rome$$romejs$js$ast$auxiliary$SpreadElement_ts$spreadElement
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$auxiliary$SpreadElement_ts$spreadElement = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
    'SpreadElement',
    'argument',
    {
      bindingKeys: {},
      visitorKeys: {
        argument: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/objects/SpreadProperty.ts
const ___R$project$rome$$romejs$js$ast$objects$SpreadProperty_ts = {
    get spreadProperty() {
      return (
        ___R$project$rome$$romejs$js$ast$objects$SpreadProperty_ts$spreadProperty
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$objects$SpreadProperty_ts$spreadProperty = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'SpreadProperty',
    {
      bindingKeys: {},
      visitorKeys: {
        argument: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/auxiliary/StaticMemberProperty.ts
const ___R$project$rome$$romejs$js$ast$auxiliary$StaticMemberProperty_ts = {
    get staticMemberProperty() {
      return (
        ___R$project$rome$$romejs$js$ast$auxiliary$StaticMemberProperty_ts$staticMemberProperty
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$auxiliary$StaticMemberProperty_ts$staticMemberProperty = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
    'StaticMemberProperty',
    'value',
    {
      bindingKeys: {},
      visitorKeys: {
        value: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/objects/StaticPropertyKey.ts
const ___R$project$rome$$romejs$js$ast$objects$StaticPropertyKey_ts = {
    get staticPropertyKey() {
      return (
        ___R$project$rome$$romejs$js$ast$objects$StaticPropertyKey_ts$staticPropertyKey
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$objects$StaticPropertyKey_ts$staticPropertyKey = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
    'StaticPropertyKey',
    'value',
    {
      bindingKeys: {},
      visitorKeys: {
        variance: true,
        value: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/types/StringKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$types$StringKeywordTypeAnnotation_ts = {
    get stringKeywordTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$types$StringKeywordTypeAnnotation_ts$stringKeywordTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$types$StringKeywordTypeAnnotation_ts$stringKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'StringKeywordTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/literals/StringLiteral.ts
const ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts = {
    get stringLiteral() {
      return (
        ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
    'StringLiteral',
    'value',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/types/StringLiteralTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$types$StringLiteralTypeAnnotation_ts = {
    get stringLiteralTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$types$StringLiteralTypeAnnotation_ts$stringLiteralTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$types$StringLiteralTypeAnnotation_ts$stringLiteralTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'StringLiteralTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/expressions/Super.ts
const ___R$project$rome$$romejs$js$ast$expressions$Super_ts = {
    get _super() {
      return (
        ___R$project$rome$$romejs$js$ast$expressions$Super_ts$_super
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$expressions$Super_ts$_super = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'Super',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/auxiliary/SwitchCase.ts
const ___R$project$rome$$romejs$js$ast$auxiliary$SwitchCase_ts = {
    get switchCase() {
      return (
        ___R$project$rome$$romejs$js$ast$auxiliary$SwitchCase_ts$switchCase
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$auxiliary$SwitchCase_ts$switchCase = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'SwitchCase',
    {
      bindingKeys: {},
      visitorKeys: {
        test: true,
        consequent: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/statements/SwitchStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$SwitchStatement_ts = {
    get switchStatement() {
      return (
        ___R$project$rome$$romejs$js$ast$statements$SwitchStatement_ts$switchStatement
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$statements$SwitchStatement_ts$switchStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'SwitchStatement',
    {
      bindingKeys: {},
      visitorKeys: {
        discriminant: true,
        cases: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/types/SymbolKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$types$SymbolKeywordTypeAnnotation_ts = {
    get symbolKeywordTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$types$SymbolKeywordTypeAnnotation_ts$symbolKeywordTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$types$SymbolKeywordTypeAnnotation_ts$symbolKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'SymbolKeywordTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/expressions/TaggedTemplateExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$TaggedTemplateExpression_ts = {
    get taggedTemplateExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$expressions$TaggedTemplateExpression_ts$taggedTemplateExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$expressions$TaggedTemplateExpression_ts$taggedTemplateExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TaggedTemplateExpression',
    {
      bindingKeys: {},
      visitorKeys: {
        tag: true,
        quasi: true,
        typeArguments: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/auxiliary/TemplateElement.ts
const ___R$project$rome$$romejs$js$ast$auxiliary$TemplateElement_ts = {
    get templateElement() {
      return (
        ___R$project$rome$$romejs$js$ast$auxiliary$TemplateElement_ts$templateElement
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$auxiliary$TemplateElement_ts$templateElement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TemplateElement',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/literals/TemplateLiteral.ts
const ___R$project$rome$$romejs$js$ast$literals$TemplateLiteral_ts = {
    get templateLiteral() {
      return (
        ___R$project$rome$$romejs$js$ast$literals$TemplateLiteral_ts$templateLiteral
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$literals$TemplateLiteral_ts$templateLiteral = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TemplateLiteral',
    {
      bindingKeys: {},
      visitorKeys: {
        quasis: true,
        expressions: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/types/TemplateLiteralTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$types$TemplateLiteralTypeAnnotation_ts = {
    get templateLiteralTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$types$TemplateLiteralTypeAnnotation_ts$templateLiteralTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$types$TemplateLiteralTypeAnnotation_ts$templateLiteralTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TemplateLiteralTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/expressions/ThisExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$ThisExpression_ts = {
    get thisExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$expressions$ThisExpression_ts$thisExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$expressions$ThisExpression_ts$thisExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ThisExpression',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/statements/ThrowStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$ThrowStatement_ts = {
    get throwStatement() {
      return (
        ___R$project$rome$$romejs$js$ast$statements$ThrowStatement_ts$throwStatement
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$statements$ThrowStatement_ts$throwStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'ThrowStatement',
    {
      bindingKeys: {},
      visitorKeys: {
        argument: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/statements/TryStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$TryStatement_ts = {
    get tryStatement() {
      return (
        ___R$project$rome$$romejs$js$ast$statements$TryStatement_ts$tryStatement
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$statements$TryStatement_ts$tryStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TryStatement',
    {
      bindingKeys: {},
      visitorKeys: {
        block: true,
        handler: true,
        finalizer: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSArrayType.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSArrayType_ts = {
    get tsArrayType() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSArrayType_ts$tsArrayType
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSArrayType_ts$tsArrayType = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSArrayType',
    {
      bindingKeys: {},
      visitorKeys: {elementType: true},
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSAsExpression.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSAsExpression_ts = {
    get tsAsExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSAsExpression_ts$tsAsExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSAsExpression_ts$tsAsExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSAsExpression',
    {
      bindingKeys: {},
      visitorKeys: {expression: true, typeAnnotation: true},
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSAssignmentAsExpression.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentAsExpression_ts = {
    get tsAssignmentAsExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentAsExpression_ts$tsAssignmentAsExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentAsExpression_ts$tsAssignmentAsExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSAssignmentAsExpression',
    {
      bindingKeys: {},
      visitorKeys: {expression: true, typeAnnotation: true},
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSAssignmentNonNullExpression.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentNonNullExpression_ts = {
    get tsAssignmentNonNullExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentNonNullExpression_ts$tsAssignmentNonNullExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentNonNullExpression_ts$tsAssignmentNonNullExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSAssignmentNonNullExpression',
    {
      bindingKeys: {},
      visitorKeys: {expression: true},
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSAssignmentTypeAssertion.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentTypeAssertion_ts = {
    get tsAssignmentTypeAssertion() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentTypeAssertion_ts$tsAssignmentTypeAssertion
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentTypeAssertion_ts$tsAssignmentTypeAssertion = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSAssignmentTypeAssertion',
    {
      bindingKeys: {},
      visitorKeys: {expression: true, typeAnnotation: true},
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSCallSignatureDeclaration.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSCallSignatureDeclaration_ts = {
    get tsCallSignatureDeclaration() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSCallSignatureDeclaration_ts$tsCallSignatureDeclaration
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSCallSignatureDeclaration_ts$tsCallSignatureDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSCallSignatureDeclaration',
    {
      bindingKeys: {},
      visitorKeys: {
        meta: true,
        typeAnnotation: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSConditionalType.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSConditionalType_ts = {
    get tsConditionalType() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSConditionalType_ts$tsConditionalType
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSConditionalType_ts$tsConditionalType = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSConditionalType',
    {
      bindingKeys: {},
      visitorKeys: {
        checkType: true,
        extendsType: true,
        trueType: true,
        falseType: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSConstructorType.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSConstructorType_ts = {
    get tsConstructorType() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSConstructorType_ts$tsConstructorType
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSConstructorType_ts$tsConstructorType = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSConstructorType',
    {
      bindingKeys: {},
      visitorKeys: {
        meta: true,
        typeAnnotation: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSConstructSignatureDeclaration.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSConstructSignatureDeclaration_ts = {
    get tsConstructSignatureDeclaration() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSConstructSignatureDeclaration_ts$tsConstructSignatureDeclaration
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSConstructSignatureDeclaration_ts$tsConstructSignatureDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSConstructSignatureDeclaration',
    {
      bindingKeys: {},
      visitorKeys: {
        meta: true,
        typeAnnotation: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSDeclareFunction.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSDeclareFunction_ts = {
    get tsDeclareFunction() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSDeclareFunction_ts$tsDeclareFunction
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSDeclareFunction_ts$tsDeclareFunction = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSDeclareFunction',
    {
      bindingKeys: {
        id: true,
      },
      visitorKeys: {
        id: true,
        head: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSDeclareMethod.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSDeclareMethod_ts = {
    get tsDeclareMethod() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSDeclareMethod_ts$tsDeclareMethod
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSDeclareMethod_ts$tsDeclareMethod = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSDeclareMethod',
    {
      bindingKeys: {},
      visitorKeys: {
        meta: true,
        key: true,
        head: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSEnumDeclaration.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSEnumDeclaration_ts = {
    get tsEnumDeclaration() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSEnumDeclaration_ts$tsEnumDeclaration
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSEnumDeclaration_ts$tsEnumDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSEnumDeclaration',
    {
      bindingKeys: {
        id: true,
      },
      visitorKeys: {
        id: true,
        members: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSEnumMember.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSEnumMember_ts = {
    get tsEnumMember() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSEnumMember_ts$tsEnumMember
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSEnumMember_ts$tsEnumMember = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSEnumMember',
    {
      bindingKeys: {},
      visitorKeys: {
        id: true,
        initializer: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSExportAssignment.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSExportAssignment_ts = {
    get tsExportAssignment() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSExportAssignment_ts$tsExportAssignment
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSExportAssignment_ts$tsExportAssignment = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSExportAssignment',
    {bindingKeys: {}, visitorKeys: {expression: true}},
  );

  // project-rome/@romejs/js-ast/typescript/TSExpressionWithTypeArguments.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSExpressionWithTypeArguments_ts = {
    get tsExpressionWithTypeArguments() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSExpressionWithTypeArguments_ts$tsExpressionWithTypeArguments
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSExpressionWithTypeArguments_ts$tsExpressionWithTypeArguments = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSExpressionWithTypeArguments',
    {
      bindingKeys: {},
      visitorKeys: {
        expression: true,
        typeParameters: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSExternalModuleReference.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSExternalModuleReference_ts = {
    get tsExternalModuleReference() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSExternalModuleReference_ts$tsExternalModuleReference
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSExternalModuleReference_ts$tsExternalModuleReference = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSExternalModuleReference',
    {
      bindingKeys: {},
      visitorKeys: {expression: true},
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSFunctionType.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSFunctionType_ts = {
    get tsFunctionType() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSFunctionType_ts$tsFunctionType
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSFunctionType_ts$tsFunctionType = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSFunctionType',
    {
      bindingKeys: {},
      visitorKeys: {
        meta: true,
        typeAnnotation: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSImportEqualsDeclaration.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSImportEqualsDeclaration_ts = {
    get tsImportEqualsDeclaration() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSImportEqualsDeclaration_ts$tsImportEqualsDeclaration
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSImportEqualsDeclaration_ts$tsImportEqualsDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSImportEqualsDeclaration',
    {
      bindingKeys: {
        id: true,
      },
      visitorKeys: {id: true, moduleReference: true},
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSImportType.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSImportType_ts = {
    get tsImportType() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSImportType_ts$tsImportType
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSImportType_ts$tsImportType = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSImportType',
    {
      bindingKeys: {},
      visitorKeys: {
        argument: true,
        typeParameters: true,
        qualifier: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSIndexedAccessType.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSIndexedAccessType_ts = {
    get tsIndexedAccessType() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSIndexedAccessType_ts$tsIndexedAccessType
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSIndexedAccessType_ts$tsIndexedAccessType = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSIndexedAccessType',
    {
      bindingKeys: {},
      visitorKeys: {
        objectType: true,
        indexType: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSIndexSignature.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSIndexSignature_ts = {
    get tsIndexSignature() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSIndexSignature_ts$tsIndexSignature
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSIndexSignature_ts$tsIndexSignature = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSIndexSignature',
    {
      bindingKeys: {
        key: true,
      },
      visitorKeys: {
        typeAnnotation: true,
        key: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSInferType.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSInferType_ts = {
    get tsInferType() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSInferType_ts$tsInferType
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSInferType_ts$tsInferType = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSInferType',
    {
      bindingKeys: {},
      visitorKeys: {
        typeParameter: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSInterfaceBody.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSInterfaceBody_ts = {
    get tsInterfaceBody() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSInterfaceBody_ts$tsInterfaceBody
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSInterfaceBody_ts$tsInterfaceBody = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSInterfaceBody',
    {
      bindingKeys: {},
      visitorKeys: {
        body: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSInterfaceDeclaration.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSInterfaceDeclaration_ts = {
    get tsInterfaceDeclaration() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSInterfaceDeclaration_ts$tsInterfaceDeclaration
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSInterfaceDeclaration_ts$tsInterfaceDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSInterfaceDeclaration',
    {
      bindingKeys: {
        id: true,
      },
      visitorKeys: {
        id: true,
        body: true,
        typeParameters: true,
        extends: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSMappedType.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSMappedType_ts = {
    get tsMappedType() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSMappedType_ts$tsMappedType
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSMappedType_ts$tsMappedType = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSMappedType',
    {
      bindingKeys: {},
      visitorKeys: {
        typeParameter: true,
        typeAnnotation: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSMethodSignature.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSMethodSignature_ts = {
    get tsMethodSignature() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSMethodSignature_ts$tsMethodSignature
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSMethodSignature_ts$tsMethodSignature = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSMethodSignature',
    {
      bindingKeys: {},
      visitorKeys: {
        key: true,
        meta: true,
        typeAnnotation: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSModuleBlock.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSModuleBlock_ts = {
    get tsModuleBlock() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSModuleBlock_ts$tsModuleBlock
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSModuleBlock_ts$tsModuleBlock = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSModuleBlock',
    {
      bindingKeys: {},
      visitorKeys: {
        body: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSModuleDeclaration.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSModuleDeclaration_ts = {
    get tsModuleDeclaration() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSModuleDeclaration_ts$tsModuleDeclaration
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSModuleDeclaration_ts$tsModuleDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSModuleDeclaration',
    {
      bindingKeys: {},
      visitorKeys: {
        id: true,
        body: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSNamespaceExportDeclaration.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSNamespaceExportDeclaration_ts = {
    get tsNamespaceExportDeclaration() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSNamespaceExportDeclaration_ts$tsNamespaceExportDeclaration
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSNamespaceExportDeclaration_ts$tsNamespaceExportDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSNamespaceExportDeclaration',
    {bindingKeys: {}, visitorKeys: {id: true}},
  );

  // project-rome/@romejs/js-ast/typescript/TSNonNullExpression.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSNonNullExpression_ts = {
    get tsNonNullExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSNonNullExpression_ts$tsNonNullExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSNonNullExpression_ts$tsNonNullExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSNonNullExpression',
    {
      bindingKeys: {},
      visitorKeys: {
        expression: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSOptionalType.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSOptionalType_ts = {
    get tsOptionalType() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSOptionalType_ts$tsOptionalType
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSOptionalType_ts$tsOptionalType = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSOptionalType',
    {
      bindingKeys: {},
      visitorKeys: {
        typeAnnotation: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSParenthesizedType.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSParenthesizedType_ts = {
    get tsParenthesizedType() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSParenthesizedType_ts$tsParenthesizedType
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSParenthesizedType_ts$tsParenthesizedType = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSParenthesizedType',
    {
      bindingKeys: {},
      visitorKeys: {
        typeAnnotation: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSPropertySignature.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSPropertySignature_ts = {
    get tsPropertySignature() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSPropertySignature_ts$tsPropertySignature
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSPropertySignature_ts$tsPropertySignature = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSPropertySignature',
    {
      bindingKeys: {},
      visitorKeys: {
        key: true,
        typeAnnotation: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSQualifiedName.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSQualifiedName_ts = {
    get tsQualifiedName() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSQualifiedName_ts$tsQualifiedName
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSQualifiedName_ts$tsQualifiedName = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSQualifiedName',
    {
      bindingKeys: {},
      visitorKeys: {
        left: true,
        right: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSSignatureDeclarationMeta.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSSignatureDeclarationMeta_ts = {
    get tsSignatureDeclarationMeta() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSSignatureDeclarationMeta_ts$tsSignatureDeclarationMeta
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSSignatureDeclarationMeta_ts$tsSignatureDeclarationMeta = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSSignatureDeclarationMeta',
    {
      bindingKeys: {},
      visitorKeys: {
        parameters: true,
        rest: true,
        typeParameters: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSThisType.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSThisType_ts = {
    get tsThisType() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSThisType_ts$tsThisType
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSThisType_ts$tsThisType = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSThisType',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSTupleType.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSTupleType_ts = {
    get tsTupleType() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSTupleType_ts$tsTupleType
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSTupleType_ts$tsTupleType = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSTupleType',
    {
      bindingKeys: {},
      visitorKeys: {
        elementTypes: true,
        rest: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSTypeAssertion.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSTypeAssertion_ts = {
    get tsTypeAssertion() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSTypeAssertion_ts$tsTypeAssertion
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSTypeAssertion_ts$tsTypeAssertion = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSTypeAssertion',
    {
      bindingKeys: {},
      visitorKeys: {
        expression: true,
        typeAnnotation: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSTypeLiteral.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSTypeLiteral_ts = {
    get tsTypeLiteral() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSTypeLiteral_ts$tsTypeLiteral
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSTypeLiteral_ts$tsTypeLiteral = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSTypeLiteral',
    {
      bindingKeys: {},
      visitorKeys: {
        members: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSTypeOperator.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSTypeOperator_ts = {
    get tsTypeOperator() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSTypeOperator_ts$tsTypeOperator
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSTypeOperator_ts$tsTypeOperator = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSTypeOperator',
    {
      bindingKeys: {},
      visitorKeys: {
        typeAnnotation: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSTypeParameter.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameter_ts = {
    get tsTypeParameter() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameter_ts$tsTypeParameter
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameter_ts$tsTypeParameter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSTypeParameter',
    {
      bindingKeys: {},
      visitorKeys: {
        default: true,
        constraint: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSTypeParameterDeclaration.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterDeclaration_ts = {
    get tsTypeParameterDeclaration() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterDeclaration_ts$tsTypeParameterDeclaration
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterDeclaration_ts$tsTypeParameterDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSTypeParameterDeclaration',
    {
      bindingKeys: {},
      visitorKeys: {
        params: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSTypeParameterInstantiation.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterInstantiation_ts = {
    get tsTypeParameterInstantiation() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterInstantiation_ts$tsTypeParameterInstantiation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterInstantiation_ts$tsTypeParameterInstantiation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSTypeParameterInstantiation',
    {
      bindingKeys: {},
      visitorKeys: {
        params: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSTypePredicate.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSTypePredicate_ts = {
    get tsTypePredicate() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSTypePredicate_ts$tsTypePredicate
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSTypePredicate_ts$tsTypePredicate = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSTypePredicate',
    {
      bindingKeys: {},
      visitorKeys: {
        parameterName: true,
        typeAnnotation: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSTypeQuery.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSTypeQuery_ts = {
    get tsTypeQuery() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSTypeQuery_ts$tsTypeQuery
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSTypeQuery_ts$tsTypeQuery = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSTypeQuery',
    {
      bindingKeys: {},
      visitorKeys: {
        exprName: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/typescript/TSTypeReference.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSTypeReference_ts = {
    get tsTypeReference() {
      return (
        ___R$project$rome$$romejs$js$ast$typescript$TSTypeReference_ts$tsTypeReference
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$typescript$TSTypeReference_ts$tsTypeReference = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TSTypeReference',
    {
      bindingKeys: {},
      visitorKeys: {
        typeName: true,
        typeParameters: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/types/TypeAliasTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$types$TypeAliasTypeAnnotation_ts = {
    get typeAliasTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$types$TypeAliasTypeAnnotation_ts$typeAliasTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$types$TypeAliasTypeAnnotation_ts$typeAliasTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'TypeAliasTypeAnnotation',
    {
      bindingKeys: {
        id: true,
      },
      visitorKeys: {
        id: true,
        typeParameters: true,
        right: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/expressions/UnaryExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$UnaryExpression_ts = {
    get unaryExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$expressions$UnaryExpression_ts$unaryExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$expressions$UnaryExpression_ts$unaryExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'UnaryExpression',
    {
      bindingKeys: {},
      visitorKeys: {
        argument: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/types/UndefinedKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$types$UndefinedKeywordTypeAnnotation_ts = {
    get undefinedKeywordTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$types$UndefinedKeywordTypeAnnotation_ts$undefinedKeywordTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$types$UndefinedKeywordTypeAnnotation_ts$undefinedKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'UndefinedKeywordTypeAnnotation',
    {bindingKeys: {}, visitorKeys: {}},
  );

  // project-rome/@romejs/js-ast/types/UnionTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$types$UnionTypeAnnotation_ts = {
    get unionTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$types$UnionTypeAnnotation_ts$unionTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$types$UnionTypeAnnotation_ts$unionTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'UnionTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {
        types: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/types/UnknownKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$types$UnknownKeywordTypeAnnotation_ts = {
    get unknownKeywordTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$types$UnknownKeywordTypeAnnotation_ts$unknownKeywordTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$types$UnknownKeywordTypeAnnotation_ts$unknownKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'UnknownKeywordTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/expressions/UpdateExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$UpdateExpression_ts = {
    get updateExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$expressions$UpdateExpression_ts$updateExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$expressions$UpdateExpression_ts$updateExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'UpdateExpression',
    {
      bindingKeys: {},
      visitorKeys: {
        argument: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/auxiliary/VariableDeclaration.ts
const ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts = {
    get variableDeclaration() {
      return (
        ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'VariableDeclaration',
    {
      bindingKeys: {
        declarations: true,
      },
      visitorKeys: {
        declarations: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/statements/VariableDeclarationStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts = {
    get variableDeclarationStatement() {
      return (
        ___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
    'VariableDeclarationStatement',
    'declaration',
    {
      bindingKeys: {
        declaration: true,
      },
      visitorKeys: {
        declaration: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/auxiliary/VariableDeclarator.ts
const ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts = {
    get variableDeclarator() {
      return (
        ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'VariableDeclarator',
    {
      bindingKeys: {
        id: true,
      },
      visitorKeys: {
        id: true,
        init: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/types/VoidKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$types$VoidKeywordTypeAnnotation_ts = {
    get voidKeywordTypeAnnotation() {
      return (
        ___R$project$rome$$romejs$js$ast$types$VoidKeywordTypeAnnotation_ts$voidKeywordTypeAnnotation
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$types$VoidKeywordTypeAnnotation_ts$voidKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'VoidKeywordTypeAnnotation',
    {
      bindingKeys: {},
      visitorKeys: {},
    },
  );

  // project-rome/@romejs/js-ast/statements/WhileStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$WhileStatement_ts = {
    get whileStatement() {
      return (
        ___R$project$rome$$romejs$js$ast$statements$WhileStatement_ts$whileStatement
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$statements$WhileStatement_ts$whileStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'WhileStatement',
    {
      bindingKeys: {},
      visitorKeys: {
        test: true,
        body: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/statements/WithStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$WithStatement_ts = {
    get withStatement() {
      return (
        ___R$project$rome$$romejs$js$ast$statements$WithStatement_ts$withStatement
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$statements$WithStatement_ts$withStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'WithStatement',
    {
      bindingKeys: {},
      visitorKeys: {
        object: true,
        body: true,
      },
    },
  );

  // project-rome/@romejs/js-ast/expressions/YieldExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$YieldExpression_ts = {
    get yieldExpression() {
      return (
        ___R$project$rome$$romejs$js$ast$expressions$YieldExpression_ts$yieldExpression
      );
    },
  };

  const ___R$project$rome$$romejs$js$ast$expressions$YieldExpression_ts$yieldExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
    'YieldExpression',
    {bindingKeys: {}, visitorKeys: {argument: true}},
  );

  // project-rome/@romejs/js-ast/index.ts
const ___R$project$rome$$romejs$js$ast$index_ts = {
    get visitorKeys() {
      return (
        ___R$project$rome$$romejs$js$ast$utils_ts$visitorKeys
      );
    },

    get nodeNames() {
      return (
        ___R$project$rome$$romejs$js$ast$utils_ts$nodeNames
      );
    },

    get assertNodeTypeSet() {
      return (
        ___R$project$rome$$romejs$js$ast$utils_ts$assertNodeTypeSet
      );
    },
  };
  Object.keys(
    ___R$project$rome$$romejs$js$ast$base_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$base_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$constants_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$constants_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$unions_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$unions_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$temp$AmbiguousFlowTypeCastExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$temp$AmbiguousFlowTypeCastExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$types$AnyKeywordTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$types$AnyKeywordTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$expressions$ArrayExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$expressions$ArrayExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$expressions$ArrowFunctionExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$expressions$ArrowFunctionExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$patterns$AssignmentArrayPattern_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$patterns$AssignmentArrayPattern_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$patterns$AssignmentAssignmentPattern_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$patterns$AssignmentAssignmentPattern_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$expressions$AssignmentExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$expressions$AssignmentExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$patterns$AssignmentIdentifier_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$patterns$AssignmentIdentifier_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$patterns$AssignmentObjectPattern_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$patterns$AssignmentObjectPattern_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$patterns$AssignmentObjectPatternProperty_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$patterns$AssignmentObjectPatternProperty_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$expressions$AwaitExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$expressions$AwaitExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$types$BigIntKeywordTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$types$BigIntKeywordTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$literals$BigIntLiteral_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$literals$BigIntLiteral_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$expressions$BinaryExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$expressions$BinaryExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$patterns$BindingArrayPattern_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$patterns$BindingArrayPattern_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$patterns$BindingAssignmentPattern_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$patterns$BindingAssignmentPattern_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$patterns$BindingObjectPattern_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$patterns$BindingObjectPattern_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$patterns$BindingObjectPatternProperty_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$patterns$BindingObjectPatternProperty_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$types$BooleanKeywordTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$types$BooleanKeywordTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$literals$BooleanLiteral_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$literals$BooleanLiteral_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$types$BooleanLiteralTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$types$BooleanLiteralTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$statements$BreakStatement_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$statements$BreakStatement_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$expressions$CallExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$expressions$CallExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$auxiliary$CatchClause_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$auxiliary$CatchClause_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$classes$ClassDeclaration_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$classes$ClassDeclaration_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$classes$ClassExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$classes$ClassExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$classes$ClassHead_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$classes$ClassHead_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$classes$ClassMethod_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$classes$ClassMethod_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$classes$ClassPrivateMethod_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$classes$ClassPrivateMethod_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$classes$ClassPrivateProperty_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$classes$ClassPrivateProperty_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$classes$ClassProperty_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$classes$ClassProperty_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$classes$ClassPropertyMeta_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$classes$ClassPropertyMeta_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$core$CommentBlock_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$core$CommentBlock_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$core$CommentLine_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$core$CommentLine_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$auxiliary$ComputedMemberProperty_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$auxiliary$ComputedMemberProperty_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$objects$ComputedPropertyKey_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$objects$ComputedPropertyKey_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$expressions$ConditionalExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$expressions$ConditionalExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$statements$ContinueStatement_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$statements$ContinueStatement_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$statements$DebuggerStatement_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$statements$DebuggerStatement_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$core$Directive_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$core$Directive_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$expressions$DoExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$expressions$DoExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$statements$DoWhileStatement_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$statements$DoWhileStatement_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$types$EmptyKeywordTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$types$EmptyKeywordTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$statements$EmptyStatement_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$statements$EmptyStatement_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$modules$ExportAllDeclaration_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$modules$ExportAllDeclaration_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$modules$ExportDefaultDeclaration_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$modules$ExportDefaultDeclaration_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$modules$ExportDefaultSpecifier_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$modules$ExportDefaultSpecifier_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$modules$ExportExternalDeclaration_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$modules$ExportExternalDeclaration_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$modules$ExportExternalSpecifier_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$modules$ExportExternalSpecifier_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$modules$ExportLocalDeclaration_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$modules$ExportLocalDeclaration_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$modules$ExportLocalSpecifier_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$modules$ExportLocalSpecifier_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$modules$ExportNamespaceSpecifier_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$modules$ExportNamespaceSpecifier_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$statements$ExpressionStatement_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$statements$ExpressionStatement_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowArrayTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowArrayTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowClassImplements_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowClassImplements_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowDeclareClass_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowDeclareClass_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowDeclaredPredicate_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowDeclaredPredicate_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowDeclareExportAll_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowDeclareExportAll_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowDeclareExportDefault_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowDeclareExportDefault_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowDeclareExportNamed_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowDeclareExportNamed_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowDeclareFunction_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowDeclareFunction_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowDeclareInterface_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowDeclareInterface_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowDeclareModule_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowDeclareModule_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowDeclareModuleExports_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowDeclareModuleExports_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowDeclareOpaqueType_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowDeclareOpaqueType_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowDeclareVariable_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowDeclareVariable_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowExistsTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowExistsTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowFunctionTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowFunctionTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowFunctionTypeParam_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowFunctionTypeParam_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowGenericTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowGenericTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowInferredPredicate_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowInferredPredicate_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowInterface_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowInterface_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowInterfaceDeclaration_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowInterfaceDeclaration_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowInterfaceExtends_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowInterfaceExtends_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowInterfaceTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowInterfaceTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowNullableTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowNullableTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowNumericLiteral_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowNumericLiteral_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeCallProperty_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeCallProperty_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeIndexer_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeIndexer_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeInternalSlot_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeInternalSlot_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeProperty_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeProperty_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeSpreadProperty_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeSpreadProperty_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowOpaqueType_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowOpaqueType_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowQualifiedTypeIdentifier_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowQualifiedTypeIdentifier_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowThisTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowThisTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowTupleTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowTupleTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowTypeCastExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowTypeCastExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowTypeofTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowTypeofTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowTypeParameter_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowTypeParameter_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowTypeParameterDeclaration_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowTypeParameterDeclaration_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowTypeParameterInstantiation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowTypeParameterInstantiation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$flow$FlowVariance_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$flow$FlowVariance_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$statements$ForInStatement_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$statements$ForInStatement_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$statements$ForOfStatement_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$statements$ForOfStatement_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$statements$ForStatement_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$statements$ForStatement_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$statements$FunctionDeclaration_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$statements$FunctionDeclaration_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$expressions$FunctionExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$expressions$FunctionExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$auxiliary$FunctionHead_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$auxiliary$FunctionHead_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$statements$IfStatement_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$statements$IfStatement_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$modules$ImportCall_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$modules$ImportCall_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$modules$ImportDeclaration_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$modules$ImportDeclaration_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$modules$ImportDefaultSpecifier_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$modules$ImportDefaultSpecifier_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$modules$ImportNamespaceSpecifier_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$modules$ImportNamespaceSpecifier_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$modules$ImportSpecifier_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$modules$ImportSpecifier_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$modules$ImportSpecifierLocal_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$modules$ImportSpecifierLocal_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$core$InterpreterDirective_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$core$InterpreterDirective_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$types$IntersectionTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$types$IntersectionTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$jsx$JSXAttribute_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$jsx$JSXAttribute_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$jsx$JSXElement_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$jsx$JSXElement_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$jsx$JSXEmptyExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$jsx$JSXEmptyExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$jsx$JSXExpressionContainer_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$jsx$JSXExpressionContainer_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$jsx$JSXFragment_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$jsx$JSXFragment_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$jsx$JSXIdentifier_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$jsx$JSXIdentifier_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$jsx$JSXMemberExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$jsx$JSXMemberExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$jsx$JSXNamespacedName_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$jsx$JSXNamespacedName_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$jsx$JSXReferenceIdentifier_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$jsx$JSXReferenceIdentifier_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$jsx$JSXSpreadAttribute_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$jsx$JSXSpreadAttribute_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$jsx$JSXSpreadChild_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$jsx$JSXSpreadChild_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$jsx$JSXText_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$jsx$JSXText_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$statements$LabeledStatement_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$statements$LabeledStatement_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$expressions$LogicalExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$expressions$LogicalExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$expressions$MemberExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$expressions$MemberExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$expressions$MetaProperty_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$expressions$MetaProperty_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$types$MixedKeywordTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$types$MixedKeywordTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$temp$MockParent_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$temp$MockParent_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$types$NeverKeywordTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$types$NeverKeywordTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$expressions$NewExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$expressions$NewExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$types$NullKeywordTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$types$NullKeywordTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$literals$NullLiteral_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$literals$NullLiteral_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$types$NumberKeywordTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$types$NumberKeywordTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$literals$NumericLiteral_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$literals$NumericLiteral_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$types$NumericLiteralTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$types$NumericLiteralTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$objects$ObjectExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$objects$ObjectExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$types$ObjectKeywordTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$types$ObjectKeywordTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$objects$ObjectMethod_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$objects$ObjectMethod_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$objects$ObjectProperty_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$objects$ObjectProperty_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$expressions$OptionalCallExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$expressions$OptionalCallExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$patterns$PatternMeta_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$patterns$PatternMeta_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$classes$PrivateName_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$classes$PrivateName_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$core$Program_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$core$Program_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$regex$RegExpAlternation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$regex$RegExpAlternation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$regex$RegExpAnyCharacter_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$regex$RegExpAnyCharacter_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$regex$RegExpCharacter_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$regex$RegExpCharacter_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$regex$RegExpCharSet_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$regex$RegExpCharSet_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$regex$RegExpCharSetRange_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$regex$RegExpCharSetRange_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$regex$RegExpControlCharacter_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$regex$RegExpControlCharacter_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$regex$RegExpDigitCharacter_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$regex$RegExpDigitCharacter_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$regex$RegExpEndCharacter_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$regex$RegExpEndCharacter_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$regex$RegExpGroupCapture_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$regex$RegExpGroupCapture_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$regex$RegExpGroupNonCapture_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$regex$RegExpGroupNonCapture_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$literals$RegExpLiteral_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$literals$RegExpLiteral_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$regex$RegExpNonDigitCharacter_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$regex$RegExpNonDigitCharacter_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$regex$RegExpNonWhiteSpaceCharacter_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$regex$RegExpNonWhiteSpaceCharacter_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$regex$RegExpNonWordBoundaryCharacter_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$regex$RegExpNonWordBoundaryCharacter_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$regex$RegExpNonWordCharacter_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$regex$RegExpNonWordCharacter_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$regex$RegExpQuantified_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$regex$RegExpQuantified_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$regex$RegExpStartCharacter_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$regex$RegExpStartCharacter_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$regex$RegExpSubExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$regex$RegExpSubExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$regex$RegExpWhiteSpaceCharacter_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$regex$RegExpWhiteSpaceCharacter_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$regex$RegExpWordBoundaryCharacter_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$regex$RegExpWordBoundaryCharacter_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$regex$RegExpWordCharacter_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$regex$RegExpWordCharacter_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$statements$ReturnStatement_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$statements$ReturnStatement_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$expressions$SequenceExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$expressions$SequenceExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$auxiliary$SpreadElement_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$auxiliary$SpreadElement_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$objects$SpreadProperty_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$objects$SpreadProperty_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$auxiliary$StaticMemberProperty_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$auxiliary$StaticMemberProperty_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$objects$StaticPropertyKey_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$objects$StaticPropertyKey_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$types$StringKeywordTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$types$StringKeywordTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$types$StringLiteralTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$types$StringLiteralTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$expressions$Super_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$expressions$Super_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$auxiliary$SwitchCase_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$auxiliary$SwitchCase_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$statements$SwitchStatement_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$statements$SwitchStatement_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$types$SymbolKeywordTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$types$SymbolKeywordTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$expressions$TaggedTemplateExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$expressions$TaggedTemplateExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$auxiliary$TemplateElement_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$auxiliary$TemplateElement_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$literals$TemplateLiteral_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$literals$TemplateLiteral_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$types$TemplateLiteralTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$types$TemplateLiteralTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$expressions$ThisExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$expressions$ThisExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$statements$ThrowStatement_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$statements$ThrowStatement_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$statements$TryStatement_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$statements$TryStatement_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSArrayType_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSArrayType_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSAsExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSAsExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentAsExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentAsExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentNonNullExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentNonNullExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentTypeAssertion_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentTypeAssertion_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSCallSignatureDeclaration_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSCallSignatureDeclaration_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSConditionalType_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSConditionalType_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSConstructorType_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSConstructorType_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSConstructSignatureDeclaration_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSConstructSignatureDeclaration_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSDeclareFunction_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSDeclareFunction_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSDeclareMethod_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSDeclareMethod_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSEnumDeclaration_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSEnumDeclaration_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSEnumMember_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSEnumMember_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSExportAssignment_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSExportAssignment_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSExpressionWithTypeArguments_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSExpressionWithTypeArguments_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSExternalModuleReference_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSExternalModuleReference_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSFunctionType_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSFunctionType_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSImportEqualsDeclaration_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSImportEqualsDeclaration_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSImportType_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSImportType_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSIndexedAccessType_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSIndexedAccessType_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSIndexSignature_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSIndexSignature_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSInferType_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSInferType_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSInterfaceBody_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSInterfaceBody_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSInterfaceDeclaration_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSInterfaceDeclaration_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSMappedType_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSMappedType_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSMethodSignature_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSMethodSignature_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSModuleBlock_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSModuleBlock_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSModuleDeclaration_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSModuleDeclaration_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSNamespaceExportDeclaration_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSNamespaceExportDeclaration_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSNonNullExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSNonNullExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSOptionalType_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSOptionalType_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSParenthesizedType_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSParenthesizedType_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSPropertySignature_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSPropertySignature_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSQualifiedName_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSQualifiedName_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSSignatureDeclarationMeta_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSSignatureDeclarationMeta_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSThisType_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSThisType_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSTupleType_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSTupleType_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSTypeAssertion_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSTypeAssertion_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSTypeLiteral_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSTypeLiteral_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSTypeOperator_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSTypeOperator_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameter_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameter_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterDeclaration_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterDeclaration_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterInstantiation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterInstantiation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSTypePredicate_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSTypePredicate_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSTypeQuery_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSTypeQuery_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$typescript$TSTypeReference_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$typescript$TSTypeReference_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$types$TypeAliasTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$types$TypeAliasTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$expressions$UnaryExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$expressions$UnaryExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$types$UndefinedKeywordTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$types$UndefinedKeywordTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$types$UnionTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$types$UnionTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$types$UnknownKeywordTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$types$UnknownKeywordTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$expressions$UpdateExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$expressions$UpdateExpression_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$types$VoidKeywordTypeAnnotation_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$types$VoidKeywordTypeAnnotation_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$statements$WhileStatement_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$statements$WhileStatement_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$statements$WithStatement_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$statements$WithStatement_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$ast$expressions$YieldExpression_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$ast$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$ast$expressions$YieldExpression_ts[key]
            );
          },
        },
      );
    },
  );

  // project-rome/@romejs/js-ast-utils/isVariableIdentifier.ts
function ___R$project$rome$$romejs$js$ast$utils$isVariableIdentifier_ts$default(
    node,
  ) {
    return (
      node.type === 'BindingIdentifier' ||
      node.type ===
      'AssignmentIdentifier' ||
      node.type === 'ReferenceIdentifier' ||
      node.type ===
      'JSXReferenceIdentifier'
    );
  }

  // project-rome/@romejs/js-ast-utils/renameBindings.ts
function ___R$project$rome$$romejs$js$ast$utils$renameBindings_ts$default(
    path,
    oldToNewMapping,
  ) {
    if (oldToNewMapping.size === 0) {
      return path.node;
    }

    const oldBindingToNewName = new Map();

    // get a list of the current bindings for this scope
    const oldNameToBinding = new Map();
    for (const [oldName, newName] of oldToNewMapping) {
      if (typeof oldName === 'string') {
        const binding = path.scope.getBinding(oldName);
        oldNameToBinding.set(oldName, binding);
      } else {
        oldBindingToNewName.set(oldName, newName);
      }
    }

    // discover nodes to replace first without manipulating the AST as that will change the scope and binding objects
    const replaceNodesWithName = new Map();
    path.traverse(
      'renameBindingsCollector',
      (path) => {
        const {node, scope} = path;
        if (!___R$project$rome$$romejs$js$ast$utils$isVariableIdentifier_ts$default(node)) {
          return;
        }

        const binding = scope.getBinding(node.name);

        // oldName -> newName
        if (oldToNewMapping.has(node.name) &&
          binding ===
          oldNameToBinding.get(
            node.name,
          )) {
          const newName = oldToNewMapping.get(node.name);
          if (newName === undefined) {
            throw new Error('Should exist');
          }
          replaceNodesWithName.set(node, newName);
        }

        // Binding -> newName
        if (binding !== undefined && oldBindingToNewName.has(binding)) {
          const newName = oldBindingToNewName.get(binding);
          if (newName === undefined) {
            throw new Error('Should exist');
          }
          replaceNodesWithName.set(node, newName);
        }
      },
    );
    if (replaceNodesWithName.size === 0) {
      return path.node;
    }

    //
    const replaced = new Set();

    // replace the nodes
    const renamedNode = path.reduce(
      {
        name: 'renameBindings',
        enter(path) {
          const {node} = path;

          // Retain the correct exported name for `export function` and `export class`
          if (node.type === 'ExportLocalDeclaration' &&
            node.declaration !==
            undefined &&
            (node.declaration.type === 'FunctionDeclaration' ||
            node.declaration.type === 'ClassDeclaration')) {
            const newName = replaceNodesWithName.get(node.declaration.id);

            if (newName !== undefined) {
              replaced.add(node.declaration.id);

              const oldName = node.declaration.id.name;

              return (
                ([
                  node.declaration,
                  ___R$project$rome$$romejs$js$ast$modules$ExportLocalDeclaration_ts$exportLocalDeclaration.create(
                    {
                      specifiers: [
                        ___R$project$rome$$romejs$js$ast$modules$ExportLocalSpecifier_ts$exportLocalSpecifier.create(
                          {
                            loc: node.declaration.id.loc,
                            local: ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(newName),
                            exported: ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.quick(oldName),
                          },
                        ),
                      ],
                    },
                  ),
                ])
              );
            }
          }

          // Retain the correct exported names for `export const`
          if (node.type === 'ExportLocalDeclaration' &&
            node.declaration !==
            undefined) {
            const bindings = ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(node.declaration);
            let includesAny = false;
            for (const node of bindings) {
              if (replaceNodesWithName.has(node)) {
                includesAny = true;
                break;
              }
            }

            if (includesAny) {
              return (
                ([
                  node.declaration,
                  ___R$project$rome$$romejs$js$ast$modules$ExportLocalDeclaration_ts$exportLocalDeclaration.create(
                    {
                      specifiers: bindings.map(
                        (node) => {
                          let local = node.name;

                          const newName = replaceNodesWithName.get(node);
                          if (newName !== undefined) {
                            local = newName;
                            replaced.add(node);
                          }

                          return (
                            ___R$project$rome$$romejs$js$ast$modules$ExportLocalSpecifier_ts$exportLocalSpecifier.create(
                              {
                                loc: node.loc,
                                local: ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(local),
                                exported: ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.quick(node.name),
                              },
                            )
                          );
                        },
                      ),
                    },
                  ),
                ])
              );
            }
          }

          if (___R$project$rome$$romejs$js$ast$utils$isVariableIdentifier_ts$default(node)) {
            const newName = replaceNodesWithName.get(node);
            if (newName !== undefined) {
              replaced.add(node);
              return (
                Object.assign(
                  {
                  },
                  node,
                  {
                    name: newName,
                    loc: ___R$project$rome$$romejs$js$ast$utils$inheritLoc_ts$default(node, node.name),
                  },
                )
              );
            }
          }

          return node;
        },
      },
      {
        noScopeCreation: true,
      },
    );

    //
    if (replaced.size !== replaceNodesWithName.size) {
      throw new Error('Missed some bindings');
    }

    return ___R$project$rome$$romejs$js$ast$utils$assertSingleOrMultipleNodes_ts$default(renamedNode);
  }

  // project-rome/@romejs/js-compiler/constants.ts
const ___R$project$rome$$romejs$js$compiler$constants_ts = {
    get SCOPE_PRIVATE_PREFIX() {
      return (
        ___R$project$rome$$romejs$js$compiler$constants_ts$SCOPE_PRIVATE_PREFIX
      );
    },

    get REDUCE_SKIP_SUBTREE() {
      return (
        ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_SKIP_SUBTREE
      );
    },

    get REDUCE_REMOVE() {
      return (
        ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_REMOVE
      );
    },
  };
  const ___R$project$rome$$romejs$js$compiler$constants_ts$SCOPE_PRIVATE_PREFIX = '___R$';
  const ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_SKIP_SUBTREE = Symbol();
  const ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_REMOVE = Symbol();

  // project-rome/@romejs/js-compiler/scope/evaluators/ClassExpression.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$ClassExpression_ts$default = {
    creator: true,
    build(node, parent, scope) {
      const newScope = scope.fork('class', node);
      newScope.evaluate(node.meta.typeParameters);
      return newScope;
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/ClassDeclaration.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$ClassDeclaration_ts$default = {
    creator: false,
    build(node, parent, scope) {
      if (node.id !== undefined) {
        scope.addBinding(
          new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ClassBinding(
            {
              name: node.id.name,
              node: node.id,
              scope,
            },
          ),
        );
      }
      return ___R$project$rome$$romejs$js$compiler$scope$evaluators$ClassExpression_ts$default.build(node, parent, scope);
    },
  };

  // project-rome/@romejs/js-compiler/scope/utils.ts
function ___R$project$rome$$romejs$js$compiler$scope$utils_ts$addFunctionBindings(
    scope,
    node,
    hasArguments = true,
  ) {
    const {head} = node;

    // Add type parameters
    scope.evaluate(head.typeParameters);

    const params = head.rest === undefined
      ? head.params : [
        ...head.params,
        head.rest,
      ];

    // Add parameters
    for (const param of params) {
      for (const id of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(param)) {
        // TODO maybe add a `param` binding type?
        scope.addBinding(
          new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$LetBinding(
            {
              node: id,
              name: id.name,
              scope,
              kind: 'parameter',
            },
          ),
        );
      }
    }

    // Add `arguments` binding
    if (hasArguments) {
      scope.addBinding(
        new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ArgumentsBinding(
          {
            name: 'arguments',
            node,
            scope,
          },
        ),
      );
    }

    if (head.hasHoistedVars) {
      ___R$project$rome$$romejs$js$compiler$scope$utils_ts$addVarBindings(scope, node);
    }
  }

  function ___R$project$rome$$romejs$js$compiler$scope$utils_ts$addVarBindings(scope, topNode) {
    const {context} = scope.getRootScope();
    scope.setHoistedVars();

    context.reduce(
      topNode,
      [
        {
          name: 'scopeVarFunc',
          enter: (path) => {
            const {node, parent} = path;

            if (___R$project$rome$$romejs$js$ast$utils$isFunctionNode_ts$default(node) && node !== topNode) {
              return ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_SKIP_SUBTREE;
            }

            if (node.type === 'VariableDeclaration' && node.kind === 'var') {
              scope.evaluate(node, parent);
            }

            return node;
          },
        },
      ],
      {
        scope,
        noScopeCreation: true,
      },
    );
  }

  // project-rome/@romejs/js-compiler/scope/evaluators/FunctionDeclaration.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$FunctionDeclaration_ts$default = {
    creator: false,
    build(node, parent, scope) {
      if (node.id !== undefined) {
        scope.addBinding(
          new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$FunctionBinding(
            {
              node: node.id,
              name: node.id.name,
              scope,
            },
          ),
        );
      }

      const newScope = scope.fork('function', node);
      ___R$project$rome$$romejs$js$compiler$scope$utils_ts$addFunctionBindings(newScope, node);
      return newScope;
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/VariableDeclaration.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$VariableDeclaration_ts$default = {
    creator: false,
    build(node, parent, scope) {
      for (const decl of node.declarations) {
        for (const id of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(decl)) {
          if (node.kind === 'let') {
            scope.addBinding(
              new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$LetBinding(
                {
                  node: id,
                  name: id.name,
                  scope,
                },
              ),
            );
          }

          if (node.kind === 'const') {
            // Only set the value for simple declarations
            let valueNode = id === decl.id ? decl.init : undefined;
            scope.addBinding(
              new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ConstBinding(
                {
                  node: id,
                  name: id.name,
                  scope,
                },
                valueNode,
              ),
            );
          }

          if (node.kind === 'var' &&
            (scope.kind === 'program' ||
            scope.kind ===
            'function')) {
            if (!scope.hasHoistedVars) {
              throw (
                new Error(
                  'This scope does not allow `var`iables. This is probably because `var`iables were injected into a scope that did not contain `var` in the original source.' +
                  scope.kind,
                )
              );
            }

            scope.addBinding(
              new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$VarBinding(
                {
                  node: id,
                  name: id.name,
                  scope,
                },
              ),
            );
          }
        }
      }
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/TypeAliasTypeAnnotation.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$TypeAliasTypeAnnotation_ts$default = {
    creator: false,
    build(node, parent, scope) {
      scope.evaluate(node.typeParameters);
      scope.addBinding(
        new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$TypeBinding(
          {
            node: node.id,
            name: node.id.name,
            scope,
          },
          node,
          'typealias',
        ),
      );
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/ExportDefaultDeclaration.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$ExportDefaultDeclaration_ts$default = {
    creator: false,
    build(node, parent, scope) {
      const {declaration} = node;
      const newScope = scope.evaluate(declaration, node);
      if (declaration.type === 'ClassDeclaration' ||
      declaration.type ===
      'FunctionDeclaration') {
        const id = declaration.id;
        if (id !== undefined) {
          newScope.getBindingAssert(id.name).setExported(true);
        }
      }
      return newScope;
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/ExportLocalDeclaration.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$ExportLocalDeclaration_ts$default = {
    creator: false,
    build(node, parent, scope) {
      const newScope = scope.evaluate(node.declaration, node);
      for (const id of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(node)) {
        newScope.getBindingAssert(id.name).setExported(true);
      }
      return newScope;
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/ImportDeclaration.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$ImportDeclaration_ts$default = {
    creator: false,
    build(node, parent, scope) {
      const source = node.source.value;
      const {specifiers} = node;

      if (specifiers !== undefined) {
        for (const specifier of specifiers) {
          let kind = specifier.local.importKind ||
          node.importKind ||
          'value';
          let meta;

          if (specifier.type === 'ImportNamespaceSpecifier') {
            meta =
              {
                kind,
                type: 'namespace',
                source,
              };
          } else if (specifier.type === 'ImportDefaultSpecifier') {
            meta =
              {
                kind,
                type: 'name',
                imported: 'default',
                source,
              };
          } else if (specifier.type === 'ImportSpecifier') {
            meta =
              {
                kind,
                type: 'name',
                imported: specifier.imported.name,
                source,
              };
          }

          if (meta === undefined) {
            return undefined;
          }

          scope.addBinding(
            new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ImportBinding(
              {
                node: specifier.local.name,
                name: specifier.local.name.name,
                scope,
              },
              meta,
            ),
          );
        }
      }
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/FlowTypeParameterDeclaration.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$FlowTypeParameterDeclaration_ts$default = {
    creator: false,
    build(node, parent, scope) {
      for (const id of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(node)) {
        scope.addBinding(
          new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$TypeBinding(
            {
              node: id,
              name: id.name,
              scope,
            },
            node,
            'parameter',
          ),
        );
      }
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/FlowDeclareExportNamed.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$FlowDeclareExportNamed_ts$default = {
    creator: false,
    build(node, parent, scope) {
      const {declaration} = node;
      const newScope = scope.evaluate(declaration, node);
      if (declaration !== undefined) {
        if (declaration.type === 'FlowDeclareOpaqueType') {
          newScope.getBindingAssert(declaration.id.name).setExported(true);
        }
      }
      return newScope;
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/SwitchCase.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$SwitchCase_ts$default = {
    creator: false,
    build(node, parent, scope) {
      for (const child of node.consequent) {
        scope.evaluate(child, node);
      }
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/SwitchStatement.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$SwitchStatement_ts$default = {
    creator: false,
    build(node, parent, scope) {
      for (const child of node.cases) {
        scope.evaluate(child, node);
      }
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/FlowInterfaceDeclaration.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$FlowInterfaceDeclaration_ts$default = {
    creator: false,
    build(node, parent, scope) {
      scope.addBinding(
        new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$TypeBinding(
          {
            node: node.id,
            name: node.id.name,
            scope,
          },
          node,
          'interface',
        ),
      );
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/FlowOpaqueType.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$FlowOpaqueType_ts$default = {
    creator: false,
    build(node, parent, scope) {
      scope.addBinding(
        new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$TypeBinding(
          {
            node: node.id,
            name: node.id.name,
            scope,
          },
          node,
          'typealias',
        ),
      );
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/FlowDeclareOpaqueType.ts


  // project-rome/@romejs/js-compiler/scope/evaluators/FlowDeclareFunction.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$FlowDeclareFunction_ts$default = {
    creator: false,
    build(node, parent, scope) {
      scope.addBinding(
        new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$TypeBinding(
          {
            node: node.id,
            name: node.id.name,
            scope,
          },
          node,
          'function',
        ),
      );
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/FlowDeclareClass.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$FlowDeclareClass_ts$default = {
    creator: false,
    build(node, parent, scope) {
      scope.addBinding(
        new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$TypeBinding(
          {
            node: node.id,
            name: node.id.name,
            scope,
          },
          node,
          'class',
        ),
      );
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/TSImportEqualsDeclaration.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$TSImportEqualsDeclaration_ts$default = {
    creator: false,
    build(node, parent, scope) {
      const {moduleReference, id} = node;

      if (moduleReference.type === 'TSExternalModuleReference') {
        scope.addBinding(
          new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ImportBinding(
            {
              node: id,
              name: id.name,
              scope,
            },
            {
              type: 'namespace',
              kind: 'value',
              source: moduleReference.expression.value,
            },
          ),
        );
      } else {
        // TODO
      }
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/ArrowFunctionExpression.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$ArrowFunctionExpression_ts$default = {
    creator: true,
    build(node, parent, scope) {
      const newScope = scope.fork('function', node);
      ___R$project$rome$$romejs$js$compiler$scope$utils_ts$addFunctionBindings(newScope, node, false);
      return newScope;
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/ClassMethod.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$ClassMethod_ts$default = {
    creator: true,
    build(node, parent, scope) {
      const newScope = scope.fork('function', node);
      ___R$project$rome$$romejs$js$compiler$scope$utils_ts$addFunctionBindings(newScope, node);
      return newScope;
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/FunctionExpression.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$FunctionExpression_ts$default = {
    creator: true,
    build(node, parent, scope) {
      const newScope = scope.fork('function', node);
      if (node.id !== undefined) {
        newScope.addBinding(
          new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$LetBinding(
            {
              node: node.id,
              name: node.id.name,
              scope,
            },
          ),
        );
      }
      ___R$project$rome$$romejs$js$compiler$scope$utils_ts$addFunctionBindings(newScope, node);
      return newScope;
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/ObjectMethod.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$ObjectMethod_ts$default = {
    creator: true,
    build(node, parent, scope) {
      const newScope = scope.fork('function', node);
      ___R$project$rome$$romejs$js$compiler$scope$utils_ts$addFunctionBindings(newScope, node);
      return newScope;
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/BlockStatement.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$BlockStatement_ts$default = {
    creator: true,
    build(node, parent, scope) {
      const newScope = scope.fork('block', node);
      for (const child of node.body) {
        newScope.evaluate(child, node);
      }
      return newScope;
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/CatchClause.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$CatchClause_ts$default = {
    creator: true,
    build(node, parent, scope) {
      const newScope = scope.fork('block', node);
      if (node.param !== undefined) {
        for (const id of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(node.param)) {
          // TODO maybe add a `catch` binding type?
          newScope.addBinding(
            new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$LetBinding(
              {
                node: id,
                name: id.name,
                scope: newScope,
              },
            ),
          );
        }
      }
      return newScope;
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/Program.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$Program_ts$default = {
    creator: true,
    build(node, parent, scope) {
      const newScope = scope.fork('program', node);
      if (node.hasHoistedVars) {
        ___R$project$rome$$romejs$js$compiler$scope$utils_ts$addVarBindings(newScope, node);
      }
      for (const child of node.body) {
        newScope.evaluate(child, node);
      }
      return newScope;
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/ForStatement.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$ForStatement_ts$default = {
    creator: true,
    build(node, parent, scope) {
      const newScope = scope.fork('loop', node);
      newScope.evaluate(node.init, node);
      return newScope;
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/ForOfStatement.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$ForOfStatement_ts$default = {
    creator: true,
    build(node, parent, scope) {
      const newScope = scope.fork('loop', node);
      newScope.evaluate(node.left, node);
      return newScope;
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/VariableDeclarationStatement.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$VariableDeclarationStatement_ts$default = {
    creator: false,
    build(node, parent, scope) {
      if (node.declare) {
        for (const {name} of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(node)) {
          scope.addGlobal(name);
        }
      } else {
        scope.evaluate(node.declaration, node);
      }
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/TSInterfaceDeclaration.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$TSInterfaceDeclaration_ts$default = {
    creator: false,
    build(node, parent, scope) {
      scope.addBinding(
        new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$TypeBinding(
          {
            node: node.id,
            name: node.id.name,
            scope,
          },
          node,
          'interface',
        ),
      );
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/TSDeclareFunction.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$TSDeclareFunction_ts$default = {
    creator: false,
    build(node, parent, scope) {
      scope.addBinding(
        new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$FunctionBinding(
          {
            node: node.id,
            name: node.id.name,
            scope,
          },
        ),
      );
    },
  };

  // project-rome/@romejs/js-compiler/scope/evaluators/index.ts
const ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators = new Map();

  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('TSDeclareFunction', ___R$project$rome$$romejs$js$compiler$scope$evaluators$TSDeclareFunction_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('ClassDeclaration', ___R$project$rome$$romejs$js$compiler$scope$evaluators$ClassDeclaration_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('FunctionDeclaration', ___R$project$rome$$romejs$js$compiler$scope$evaluators$FunctionDeclaration_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('VariableDeclarationStatement', ___R$project$rome$$romejs$js$compiler$scope$evaluators$VariableDeclarationStatement_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('VariableDeclaration', ___R$project$rome$$romejs$js$compiler$scope$evaluators$VariableDeclaration_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('TypeAliasTypeAnnotation', ___R$project$rome$$romejs$js$compiler$scope$evaluators$TypeAliasTypeAnnotation_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('ExportDefaultDeclaration', ___R$project$rome$$romejs$js$compiler$scope$evaluators$ExportDefaultDeclaration_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('ExportLocalDeclaration', ___R$project$rome$$romejs$js$compiler$scope$evaluators$ExportLocalDeclaration_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('ImportDeclaration', ___R$project$rome$$romejs$js$compiler$scope$evaluators$ImportDeclaration_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('FlowTypeParameterDeclaration', ___R$project$rome$$romejs$js$compiler$scope$evaluators$FlowTypeParameterDeclaration_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('FlowDeclareExportNamed', ___R$project$rome$$romejs$js$compiler$scope$evaluators$FlowDeclareExportNamed_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('SwitchCase', ___R$project$rome$$romejs$js$compiler$scope$evaluators$SwitchCase_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('SwitchStatement', ___R$project$rome$$romejs$js$compiler$scope$evaluators$SwitchStatement_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('FlowInterfaceDeclaration', ___R$project$rome$$romejs$js$compiler$scope$evaluators$FlowInterfaceDeclaration_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('FlowOpaqueType', ___R$project$rome$$romejs$js$compiler$scope$evaluators$FlowOpaqueType_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('FlowDeclareOpaqueType', ___R$project$rome$$romejs$js$compiler$scope$evaluators$FlowOpaqueType_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('FlowDeclareFunction', ___R$project$rome$$romejs$js$compiler$scope$evaluators$FlowDeclareFunction_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('FlowDeclareClass', ___R$project$rome$$romejs$js$compiler$scope$evaluators$FlowDeclareClass_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('TypeAliasTypeAnnotation', ___R$project$rome$$romejs$js$compiler$scope$evaluators$TypeAliasTypeAnnotation_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('TSImportEqualsDeclaration', ___R$project$rome$$romejs$js$compiler$scope$evaluators$TSImportEqualsDeclaration_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('ArrowFunctionExpression', ___R$project$rome$$romejs$js$compiler$scope$evaluators$ArrowFunctionExpression_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('ClassMethod', ___R$project$rome$$romejs$js$compiler$scope$evaluators$ClassMethod_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('FunctionExpression', ___R$project$rome$$romejs$js$compiler$scope$evaluators$FunctionExpression_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('ObjectMethod', ___R$project$rome$$romejs$js$compiler$scope$evaluators$ObjectMethod_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('BlockStatement', ___R$project$rome$$romejs$js$compiler$scope$evaluators$BlockStatement_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('ClassExpression', ___R$project$rome$$romejs$js$compiler$scope$evaluators$ClassExpression_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('CatchClause', ___R$project$rome$$romejs$js$compiler$scope$evaluators$CatchClause_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('Program', ___R$project$rome$$romejs$js$compiler$scope$evaluators$Program_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('ForStatement', ___R$project$rome$$romejs$js$compiler$scope$evaluators$ForStatement_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('ForOfStatement', ___R$project$rome$$romejs$js$compiler$scope$evaluators$ForOfStatement_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('ForInStatement', ___R$project$rome$$romejs$js$compiler$scope$evaluators$ForOfStatement_ts$default);
  ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('TSInterfaceDeclaration', ___R$project$rome$$romejs$js$compiler$scope$evaluators$TSInterfaceDeclaration_ts$default);
  const ___R$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$default = ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators;

  // project-rome/@romejs/js-compiler/scope/globals.ts
const ___R$project$rome$$romejs$js$compiler$scope$globals_ts = {
    get builtin() {
      return (
        ___R$project$rome$$romejs$js$compiler$scope$globals_ts$builtin
      );
    },

    get es5() {
      return (
        ___R$project$rome$$romejs$js$compiler$scope$globals_ts$es5
      );
    },

    get es2015() {
      return (
        ___R$project$rome$$romejs$js$compiler$scope$globals_ts$es2015
      );
    },

    get es2017() {
      return (
        ___R$project$rome$$romejs$js$compiler$scope$globals_ts$es2017
      );
    },

    get browser() {
      return (
        ___R$project$rome$$romejs$js$compiler$scope$globals_ts$browser
      );
    },

    get worker() {
      return (
        ___R$project$rome$$romejs$js$compiler$scope$globals_ts$worker
      );
    },

    get node() {
      return (
        ___R$project$rome$$romejs$js$compiler$scope$globals_ts$node
      );
    },

    get commonjs() {
      return (
        ___R$project$rome$$romejs$js$compiler$scope$globals_ts$commonjs
      );
    },

    get serviceworker() {
      return (
        ___R$project$rome$$romejs$js$compiler$scope$globals_ts$serviceworker
      );
    },
  };
  const ___R$project$rome$$romejs$js$compiler$scope$globals_ts$builtin = [
    'Array',
    'ArrayBuffer',
    'Atomics',
    'BigInt',
    'BigInt64Array',
    'BigUint64Array',
    'Boolean',
    'constructor',
    'DataView',
    'Date',
    'decodeURI',
    'decodeURIComponent',
    'encodeURI',
    'encodeURIComponent',
    'Error',
    'escape',
    'eval',
    'EvalError',
    'Float32Array',
    'Float64Array',
    'Function',
    'globalThis',
    'hasOwnProperty',
    'Infinity',
    'Int16Array',
    'Int32Array',
    'Int8Array',
    'isFinite',
    'isNaN',
    'isPrototypeOf',
    'JSON',
    'Map',
    'Math',
    'NaN',
    'Number',
    'Object',
    'parseFloat',
    'parseInt',
    'Promise',
    'propertyIsEnumerable',
    'Proxy',
    'RangeError',
    'ReferenceError',
    'Reflect',
    'RegExp',
    'Set',
    'SharedArrayBuffer',
    'String',
    'Symbol',
    'SyntaxError',
    'toLocaleString',
    'toString',
    'TypeError',
    'Uint16Array',
    'Uint32Array',
    'Uint8Array',
    'Uint8ClampedArray',
    'undefined',
    'unescape',
    'URIError',
    'valueOf',
    'WeakMap',
    'WeakSet',
  ];

  const ___R$project$rome$$romejs$js$compiler$scope$globals_ts$es5 = [
    'Array',
    'Boolean',
    'constructor',
    'Date',
    'decodeURI',
    'decodeURIComponent',
    'encodeURI',
    'encodeURIComponent',
    'Error',
    'escape',
    'eval',
    'EvalError',
    'Function',
    'hasOwnProperty',
    'Infinity',
    'isFinite',
    'isNaN',
    'isPrototypeOf',
    'JSON',
    'Math',
    'NaN',
    'Number',
    'Object',
    'parseFloat',
    'parseInt',
    'propertyIsEnumerable',
    'RangeError',
    'ReferenceError',
    'RegExp',
    'String',
    'SyntaxError',
    'toLocaleString',
    'toString',
    'TypeError',
    'undefined',
    'unescape',
    'URIError',
    'valueOf',
  ];

  const ___R$project$rome$$romejs$js$compiler$scope$globals_ts$es2015 = [
    'Array',
    'ArrayBuffer',
    'Boolean',
    'constructor',
    'DataView',
    'Date',
    'decodeURI',
    'decodeURIComponent',
    'encodeURI',
    'encodeURIComponent',
    'Error',
    'escape',
    'eval',
    'EvalError',
    'Float32Array',
    'Float64Array',
    'Function',
    'hasOwnProperty',
    'Infinity',
    'Int16Array',
    'Int32Array',
    'Int8Array',
    'isFinite',
    'isNaN',
    'isPrototypeOf',
    'JSON',
    'Map',
    'Math',
    'NaN',
    'Number',
    'Object',
    'parseFloat',
    'parseInt',
    'Promise',
    'propertyIsEnumerable',
    'Proxy',
    'RangeError',
    'ReferenceError',
    'Reflect',
    'RegExp',
    'Set',
    'String',
    'Symbol',
    'SyntaxError',
    'toLocaleString',
    'toString',
    'TypeError',
    'Uint16Array',
    'Uint32Array',
    'Uint8Array',
    'Uint8ClampedArray',
    'undefined',
    'unescape',
    'URIError',
    'valueOf',
    'WeakMap',
    'WeakSet',
  ];

  const ___R$project$rome$$romejs$js$compiler$scope$globals_ts$es2017 = [
    'Array',
    'ArrayBuffer',
    'Atomics',
    'Boolean',
    'constructor',
    'DataView',
    'Date',
    'decodeURI',
    'decodeURIComponent',
    'encodeURI',
    'encodeURIComponent',
    'Error',
    'escape',
    'eval',
    'EvalError',
    'Float32Array',
    'Float64Array',
    'Function',
    'hasOwnProperty',
    'Infinity',
    'Int16Array',
    'Int32Array',
    'Int8Array',
    'isFinite',
    'isNaN',
    'isPrototypeOf',
    'JSON',
    'Map',
    'Math',
    'NaN',
    'Number',
    'Object',
    'parseFloat',
    'parseInt',
    'Promise',
    'propertyIsEnumerable',
    'Proxy',
    'RangeError',
    'ReferenceError',
    'Reflect',
    'RegExp',
    'Set',
    'SharedArrayBuffer',
    'String',
    'Symbol',
    'SyntaxError',
    'toLocaleString',
    'toString',
    'TypeError',
    'Uint16Array',
    'Uint32Array',
    'Uint8Array',
    'Uint8ClampedArray',
    'undefined',
    'unescape',
    'URIError',
    'valueOf',
    'WeakMap',
    'WeakSet',
  ];

  const ___R$project$rome$$romejs$js$compiler$scope$globals_ts$browser = [
    'AbortController',
    'AbortSignal',
    'addEventListener',
    'alert',
    'AnalyserNode',
    'Animation',
    'AnimationEffectReadOnly',
    'AnimationEffectTiming',
    'AnimationEffectTimingReadOnly',
    'AnimationEvent',
    'AnimationPlaybackEvent',
    'AnimationTimeline',
    'applicationCache',
    'ApplicationCache',
    'ApplicationCacheErrorEvent',
    'atob',
    'Attr',
    'Audio',
    'AudioBuffer',
    'AudioBufferSourceNode',
    'AudioContext',
    'AudioDestinationNode',
    'AudioListener',
    'AudioNode',
    'AudioParam',
    'AudioProcessingEvent',
    'AudioScheduledSourceNode',
    'AudioWorkletGlobalScope ',
    'AudioWorkletNode',
    'AudioWorkletProcessor',
    'BarProp',
    'BaseAudioContext',
    'BatteryManager',
    'BeforeUnloadEvent',
    'BiquadFilterNode',
    'Blob',
    'BlobEvent',
    'blur',
    'BroadcastChannel',
    'btoa',
    'BudgetService',
    'ByteLengthQueuingStrategy',
    'Cache',
    'caches',
    'CacheStorage',
    'cancelAnimationFrame',
    'cancelIdleCallback',
    'CanvasCaptureMediaStreamTrack',
    'CanvasGradient',
    'CanvasPattern',
    'CanvasRenderingContext2D',
    'ChannelMergerNode',
    'ChannelSplitterNode',
    'CharacterData',
    'clearInterval',
    'clearTimeout',
    'clientInformation',
    'ClipboardEvent',
    'close',
    'closed',
    'CloseEvent',
    'Comment',
    'CompositionEvent',
    'confirm',
    'console',
    'ConstantSourceNode',
    'ConvolverNode',
    'CountQueuingStrategy',
    'createImageBitmap',
    'Credential',
    'CredentialsContainer',
    'crypto',
    'Crypto',
    'CryptoKey',
    'CSS',
    'CSSConditionRule',
    'CSSFontFaceRule',
    'CSSGroupingRule',
    'CSSImportRule',
    'CSSKeyframeRule',
    'CSSKeyframesRule',
    'CSSMediaRule',
    'CSSNamespaceRule',
    'CSSPageRule',
    'CSSRule',
    'CSSRuleList',
    'CSSStyleDeclaration',
    'CSSStyleRule',
    'CSSStyleSheet',
    'CSSSupportsRule',
    'CustomElementRegistry',
    'customElements',
    'CustomEvent',
    'DataTransfer',
    'DataTransferItem',
    'DataTransferItemList',
    'defaultstatus',
    'defaultStatus',
    'DelayNode',
    'DeviceMotionEvent',
    'DeviceOrientationEvent',
    'devicePixelRatio',
    'dispatchEvent',
    'document',
    'Document',
    'DocumentFragment',
    'DocumentType',
    'DOMError',
    'DOMException',
    'DOMImplementation',
    'DOMMatrix',
    'DOMMatrixReadOnly',
    'DOMParser',
    'DOMPoint',
    'DOMPointReadOnly',
    'DOMQuad',
    'DOMRect',
    'DOMRectReadOnly',
    'DOMStringList',
    'DOMStringMap',
    'DOMTokenList',
    'DragEvent',
    'DynamicsCompressorNode',
    'Element',
    'ErrorEvent',
    'event',
    'Event',
    'EventSource',
    'EventTarget',
    'external',
    'fetch',
    'File',
    'FileList',
    'FileReader',
    'find',
    'focus',
    'FocusEvent',
    'FontFace',
    'FontFaceSetLoadEvent',
    'FormData',
    'frameElement',
    'frames',
    'GainNode',
    'Gamepad',
    'GamepadButton',
    'GamepadEvent',
    'getComputedStyle',
    'getSelection',
    'HashChangeEvent',
    'Headers',
    'history',
    'History',
    'HTMLAllCollection',
    'HTMLAnchorElement',
    'HTMLAreaElement',
    'HTMLAudioElement',
    'HTMLBaseElement',
    'HTMLBodyElement',
    'HTMLBRElement',
    'HTMLButtonElement',
    'HTMLCanvasElement',
    'HTMLCollection',
    'HTMLContentElement',
    'HTMLDataElement',
    'HTMLDataListElement',
    'HTMLDetailsElement',
    'HTMLDialogElement',
    'HTMLDirectoryElement',
    'HTMLDivElement',
    'HTMLDListElement',
    'HTMLDocument',
    'HTMLElement',
    'HTMLEmbedElement',
    'HTMLFieldSetElement',
    'HTMLFontElement',
    'HTMLFormControlsCollection',
    'HTMLFormElement',
    'HTMLFrameElement',
    'HTMLFrameSetElement',
    'HTMLHeadElement',
    'HTMLHeadingElement',
    'HTMLHRElement',
    'HTMLHtmlElement',
    'HTMLIFrameElement',
    'HTMLImageElement',
    'HTMLInputElement',
    'HTMLLabelElement',
    'HTMLLegendElement',
    'HTMLLIElement',
    'HTMLLinkElement',
    'HTMLMapElement',
    'HTMLMarqueeElement',
    'HTMLMediaElement',
    'HTMLMenuElement',
    'HTMLMetaElement',
    'HTMLMeterElement',
    'HTMLModElement',
    'HTMLObjectElement',
    'HTMLOListElement',
    'HTMLOptGroupElement',
    'HTMLOptionElement',
    'HTMLOptionsCollection',
    'HTMLOutputElement',
    'HTMLParagraphElement',
    'HTMLParamElement',
    'HTMLPictureElement',
    'HTMLPreElement',
    'HTMLProgressElement',
    'HTMLQuoteElement',
    'HTMLScriptElement',
    'HTMLSelectElement',
    'HTMLShadowElement',
    'HTMLSlotElement',
    'HTMLSourceElement',
    'HTMLSpanElement',
    'HTMLStyleElement',
    'HTMLTableCaptionElement',
    'HTMLTableCellElement',
    'HTMLTableColElement',
    'HTMLTableElement',
    'HTMLTableRowElement',
    'HTMLTableSectionElement',
    'HTMLTemplateElement',
    'HTMLTextAreaElement',
    'HTMLTimeElement',
    'HTMLTitleElement',
    'HTMLTrackElement',
    'HTMLUListElement',
    'HTMLUnknownElement',
    'HTMLVideoElement',
    'IDBCursor',
    'IDBCursorWithValue',
    'IDBDatabase',
    'IDBFactory',
    'IDBIndex',
    'IDBKeyRange',
    'IDBObjectStore',
    'IDBOpenDBRequest',
    'IDBRequest',
    'IDBTransaction',
    'IDBVersionChangeEvent',
    'IdleDeadline',
    'IIRFilterNode',
    'Image',
    'ImageBitmap',
    'ImageBitmapRenderingContext',
    'ImageCapture',
    'ImageData',
    'indexedDB',
    'innerHeight',
    'innerWidth',
    'InputEvent',
    'IntersectionObserver',
    'IntersectionObserverEntry',
    'Intl',
    'isSecureContext',
    'KeyboardEvent',
    'KeyframeEffect',
    'KeyframeEffectReadOnly',
    'length',
    'localStorage',
    'location',
    'Location',
    'locationbar',
    'matchMedia',
    'MediaDeviceInfo',
    'MediaDevices',
    'MediaElementAudioSourceNode',
    'MediaEncryptedEvent',
    'MediaError',
    'MediaKeyMessageEvent',
    'MediaKeySession',
    'MediaKeyStatusMap',
    'MediaKeySystemAccess',
    'MediaList',
    'MediaQueryList',
    'MediaQueryListEvent',
    'MediaRecorder',
    'MediaSettingsRange',
    'MediaSource',
    'MediaStream',
    'MediaStreamAudioDestinationNode',
    'MediaStreamAudioSourceNode',
    'MediaStreamEvent',
    'MediaStreamTrack',
    'MediaStreamTrackEvent',
    'menubar',
    'MessageChannel',
    'MessageEvent',
    'MessagePort',
    'MIDIAccess',
    'MIDIConnectionEvent',
    'MIDIInput',
    'MIDIInputMap',
    'MIDIMessageEvent',
    'MIDIOutput',
    'MIDIOutputMap',
    'MIDIPort',
    'MimeType',
    'MimeTypeArray',
    'MouseEvent',
    'moveBy',
    'moveTo',
    'MutationEvent',
    'MutationObserver',
    'MutationRecord',
    'name',
    'NamedNodeMap',
    'NavigationPreloadManager',
    'navigator',
    'Navigator',
    'NetworkInformation',
    'Node',
    'NodeFilter',
    'NodeIterator',
    'NodeList',
    'Notification',
    'OfflineAudioCompletionEvent',
    'OfflineAudioContext',
    'offscreenBuffering',
    'OffscreenCanvas',
    'onabort',
    'onafterprint',
    'onanimationend',
    'onanimationiteration',
    'onanimationstart',
    'onappinstalled',
    'onauxclick',
    'onbeforeinstallprompt',
    'onbeforeprint',
    'onbeforeunload',
    'onblur',
    'oncancel',
    'oncanplay',
    'oncanplaythrough',
    'onchange',
    'onclick',
    'onclose',
    'oncontextmenu',
    'oncuechange',
    'ondblclick',
    'ondevicemotion',
    'ondeviceorientation',
    'ondeviceorientationabsolute',
    'ondrag',
    'ondragend',
    'ondragenter',
    'ondragleave',
    'ondragover',
    'ondragstart',
    'ondrop',
    'ondurationchange',
    'onemptied',
    'onended',
    'onerror',
    'onfocus',
    'ongotpointercapture',
    'onhashchange',
    'oninput',
    'oninvalid',
    'onkeydown',
    'onkeypress',
    'onkeyup',
    'onlanguagechange',
    'onload',
    'onloadeddata',
    'onloadedmetadata',
    'onloadstart',
    'onlostpointercapture',
    'onmessage',
    'onmessageerror',
    'onmousedown',
    'onmouseenter',
    'onmouseleave',
    'onmousemove',
    'onmouseout',
    'onmouseover',
    'onmouseup',
    'onmousewheel',
    'onoffline',
    'ononline',
    'onpagehide',
    'onpageshow',
    'onpause',
    'onplay',
    'onplaying',
    'onpointercancel',
    'onpointerdown',
    'onpointerenter',
    'onpointerleave',
    'onpointermove',
    'onpointerout',
    'onpointerover',
    'onpointerup',
    'onpopstate',
    'onprogress',
    'onratechange',
    'onrejectionhandled',
    'onreset',
    'onresize',
    'onscroll',
    'onsearch',
    'onseeked',
    'onseeking',
    'onselect',
    'onstalled',
    'onstorage',
    'onsubmit',
    'onsuspend',
    'ontimeupdate',
    'ontoggle',
    'ontransitionend',
    'onunhandledrejection',
    'onunload',
    'onvolumechange',
    'onwaiting',
    'onwheel',
    'open',
    'openDatabase',
    'opener',
    'Option',
    'origin',
    'OscillatorNode',
    'outerHeight',
    'outerWidth',
    'PageTransitionEvent',
    'pageXOffset',
    'pageYOffset',
    'PannerNode',
    'parent',
    'Path2D',
    'PaymentAddress',
    'PaymentRequest',
    'PaymentRequestUpdateEvent',
    'PaymentResponse',
    'performance',
    'Performance',
    'PerformanceEntry',
    'PerformanceLongTaskTiming',
    'PerformanceMark',
    'PerformanceMeasure',
    'PerformanceNavigation',
    'PerformanceNavigationTiming',
    'PerformanceObserver',
    'PerformanceObserverEntryList',
    'PerformancePaintTiming',
    'PerformanceResourceTiming',
    'PerformanceTiming',
    'PeriodicWave',
    'Permissions',
    'PermissionStatus',
    'personalbar',
    'PhotoCapabilities',
    'Plugin',
    'PluginArray',
    'PointerEvent',
    'PopStateEvent',
    'postMessage',
    'Presentation',
    'PresentationAvailability',
    'PresentationConnection',
    'PresentationConnectionAvailableEvent',
    'PresentationConnectionCloseEvent',
    'PresentationConnectionList',
    'PresentationReceiver',
    'PresentationRequest',
    'print',
    'ProcessingInstruction',
    'ProgressEvent',
    'PromiseRejectionEvent',
    'prompt',
    'PushManager',
    'PushSubscription',
    'PushSubscriptionOptions',
    'queueMicrotask',
    'RadioNodeList',
    'Range',
    'ReadableStream',
    'registerProcessor',
    'RemotePlayback',
    'removeEventListener',
    'Request',
    'requestAnimationFrame',
    'requestIdleCallback',
    'resizeBy',
    'ResizeObserver',
    'ResizeObserverEntry',
    'resizeTo',
    'Response',
    'RTCCertificate',
    'RTCDataChannel',
    'RTCDataChannelEvent',
    'RTCDtlsTransport',
    'RTCIceCandidate',
    'RTCIceGatherer',
    'RTCIceTransport',
    'RTCPeerConnection',
    'RTCPeerConnectionIceEvent',
    'RTCRtpContributingSource',
    'RTCRtpReceiver',
    'RTCRtpSender',
    'RTCSctpTransport',
    'RTCSessionDescription',
    'RTCStatsReport',
    'RTCTrackEvent',
    'screen',
    'Screen',
    'screenLeft',
    'ScreenOrientation',
    'screenTop',
    'screenX',
    'screenY',
    'ScriptProcessorNode',
    'scroll',
    'scrollbars',
    'scrollBy',
    'scrollTo',
    'scrollX',
    'scrollY',
    'SecurityPolicyViolationEvent',
    'Selection',
    'self',
    'ServiceWorker',
    'ServiceWorkerContainer',
    'ServiceWorkerRegistration',
    'sessionStorage',
    'setInterval',
    'setTimeout',
    'ShadowRoot',
    'SharedWorker',
    'SourceBuffer',
    'SourceBufferList',
    'speechSynthesis',
    'SpeechSynthesisEvent',
    'SpeechSynthesisUtterance',
    'StaticRange',
    'status',
    'statusbar',
    'StereoPannerNode',
    'stop',
    'Storage',
    'StorageEvent',
    'StorageManager',
    'styleMedia',
    'StyleSheet',
    'StyleSheetList',
    'SubtleCrypto',
    'SVGAElement',
    'SVGAngle',
    'SVGAnimatedAngle',
    'SVGAnimatedBoolean',
    'SVGAnimatedEnumeration',
    'SVGAnimatedInteger',
    'SVGAnimatedLength',
    'SVGAnimatedLengthList',
    'SVGAnimatedNumber',
    'SVGAnimatedNumberList',
    'SVGAnimatedPreserveAspectRatio',
    'SVGAnimatedRect',
    'SVGAnimatedString',
    'SVGAnimatedTransformList',
    'SVGAnimateElement',
    'SVGAnimateMotionElement',
    'SVGAnimateTransformElement',
    'SVGAnimationElement',
    'SVGCircleElement',
    'SVGClipPathElement',
    'SVGComponentTransferFunctionElement',
    'SVGDefsElement',
    'SVGDescElement',
    'SVGDiscardElement',
    'SVGElement',
    'SVGEllipseElement',
    'SVGFEBlendElement',
    'SVGFEColorMatrixElement',
    'SVGFEComponentTransferElement',
    'SVGFECompositeElement',
    'SVGFEConvolveMatrixElement',
    'SVGFEDiffuseLightingElement',
    'SVGFEDisplacementMapElement',
    'SVGFEDistantLightElement',
    'SVGFEDropShadowElement',
    'SVGFEFloodElement',
    'SVGFEFuncAElement',
    'SVGFEFuncBElement',
    'SVGFEFuncGElement',
    'SVGFEFuncRElement',
    'SVGFEGaussianBlurElement',
    'SVGFEImageElement',
    'SVGFEMergeElement',
    'SVGFEMergeNodeElement',
    'SVGFEMorphologyElement',
    'SVGFEOffsetElement',
    'SVGFEPointLightElement',
    'SVGFESpecularLightingElement',
    'SVGFESpotLightElement',
    'SVGFETileElement',
    'SVGFETurbulenceElement',
    'SVGFilterElement',
    'SVGForeignObjectElement',
    'SVGGElement',
    'SVGGeometryElement',
    'SVGGradientElement',
    'SVGGraphicsElement',
    'SVGImageElement',
    'SVGLength',
    'SVGLengthList',
    'SVGLinearGradientElement',
    'SVGLineElement',
    'SVGMarkerElement',
    'SVGMaskElement',
    'SVGMatrix',
    'SVGMetadataElement',
    'SVGMPathElement',
    'SVGNumber',
    'SVGNumberList',
    'SVGPathElement',
    'SVGPatternElement',
    'SVGPoint',
    'SVGPointList',
    'SVGPolygonElement',
    'SVGPolylineElement',
    'SVGPreserveAspectRatio',
    'SVGRadialGradientElement',
    'SVGRect',
    'SVGRectElement',
    'SVGScriptElement',
    'SVGSetElement',
    'SVGStopElement',
    'SVGStringList',
    'SVGStyleElement',
    'SVGSVGElement',
    'SVGSwitchElement',
    'SVGSymbolElement',
    'SVGTextContentElement',
    'SVGTextElement',
    'SVGTextPathElement',
    'SVGTextPositioningElement',
    'SVGTitleElement',
    'SVGTransform',
    'SVGTransformList',
    'SVGTSpanElement',
    'SVGUnitTypes',
    'SVGUseElement',
    'SVGViewElement',
    'TaskAttributionTiming',
    'Text',
    'TextDecoder',
    'TextEncoder',
    'TextEvent',
    'TextMetrics',
    'TextTrack',
    'TextTrackCue',
    'TextTrackCueList',
    'TextTrackList',
    'TimeRanges',
    'toolbar',
    'top',
    'Touch',
    'TouchEvent',
    'TouchList',
    'TrackEvent',
    'TransitionEvent',
    'TreeWalker',
    'UIEvent',
    'URL',
    'URLSearchParams',
    'ValidityState',
    'visualViewport',
    'VisualViewport',
    'VTTCue',
    'WaveShaperNode',
    'WebAssembly',
    'WebGL2RenderingContext',
    'WebGLActiveInfo',
    'WebGLBuffer',
    'WebGLContextEvent',
    'WebGLFramebuffer',
    'WebGLProgram',
    'WebGLQuery',
    'WebGLRenderbuffer',
    'WebGLRenderingContext',
    'WebGLSampler',
    'WebGLShader',
    'WebGLShaderPrecisionFormat',
    'WebGLSync',
    'WebGLTexture',
    'WebGLTransformFeedback',
    'WebGLUniformLocation',
    'WebGLVertexArrayObject',
    'WebSocket',
    'WheelEvent',
    'window',
    'Window',
    'Worker',
    'WritableStream',
    'XMLDocument',
    'XMLHttpRequest',
    'XMLHttpRequestEventTarget',
    'XMLHttpRequestUpload',
    'XMLSerializer',
    'XPathEvaluator',
    'XPathExpression',
    'XPathResult',
    'XSLTProcessor',
  ];

  const ___R$project$rome$$romejs$js$compiler$scope$globals_ts$worker = [
    'addEventListener',
    'applicationCache',
    'atob',
    'Blob',
    'BroadcastChannel',
    'btoa',
    'Cache',
    'caches',
    'clearInterval',
    'clearTimeout',
    'close',
    'console',
    'fetch',
    'FileReaderSync',
    'FormData',
    'Headers',
    'IDBCursor',
    'IDBCursorWithValue',
    'IDBDatabase',
    'IDBFactory',
    'IDBIndex',
    'IDBKeyRange',
    'IDBObjectStore',
    'IDBOpenDBRequest',
    'IDBRequest',
    'IDBTransaction',
    'IDBVersionChangeEvent',
    'ImageData',
    'importScripts',
    'indexedDB',
    'location',
    'MessageChannel',
    'MessagePort',
    'name',
    'navigator',
    'Notification',
    'onclose',
    'onconnect',
    'onerror',
    'onlanguagechange',
    'onmessage',
    'onoffline',
    'ononline',
    'onrejectionhandled',
    'onunhandledrejection',
    'performance',
    'Performance',
    'PerformanceEntry',
    'PerformanceMark',
    'PerformanceMeasure',
    'PerformanceNavigation',
    'PerformanceResourceTiming',
    'PerformanceTiming',
    'postMessage',
    'Promise',
    'queueMicrotask',
    'removeEventListener',
    'Request',
    'Response',
    'self',
    'ServiceWorkerRegistration',
    'setInterval',
    'setTimeout',
    'TextDecoder',
    'TextEncoder',
    'URL',
    'URLSearchParams',
    'WebSocket',
    'Worker',
    'WorkerGlobalScope',
    'XMLHttpRequest',
  ];

  const ___R$project$rome$$romejs$js$compiler$scope$globals_ts$node = [
    '__dirname',
    '__filename',
    'Buffer',
    'clearImmediate',
    'clearInterval',
    'clearTimeout',
    'console',
    'exports',
    'global',
    'Intl',
    'module',
    'process',
    'queueMicrotask',
    'require',
    'setImmediate',
    'setInterval',
    'setTimeout',
    'TextDecoder',
    'TextEncoder',
    'URL',
    'URLSearchParams',
  ];

  const ___R$project$rome$$romejs$js$compiler$scope$globals_ts$commonjs = ['exports', 'global', 'module', 'require'];

  const ___R$project$rome$$romejs$js$compiler$scope$globals_ts$serviceworker = [
    'addEventListener',
    'applicationCache',
    'atob',
    'Blob',
    'BroadcastChannel',
    'btoa',
    'Cache',
    'caches',
    'CacheStorage',
    'clearInterval',
    'clearTimeout',
    'Client',
    'clients',
    'Clients',
    'close',
    'console',
    'ExtendableEvent',
    'ExtendableMessageEvent',
    'fetch',
    'FetchEvent',
    'FileReaderSync',
    'FormData',
    'Headers',
    'IDBCursor',
    'IDBCursorWithValue',
    'IDBDatabase',
    'IDBFactory',
    'IDBIndex',
    'IDBKeyRange',
    'IDBObjectStore',
    'IDBOpenDBRequest',
    'IDBRequest',
    'IDBTransaction',
    'IDBVersionChangeEvent',
    'ImageData',
    'importScripts',
    'indexedDB',
    'location',
    'MessageChannel',
    'MessagePort',
    'name',
    'navigator',
    'Notification',
    'onclose',
    'onconnect',
    'onerror',
    'onfetch',
    'oninstall',
    'onlanguagechange',
    'onmessage',
    'onmessageerror',
    'onnotificationclick',
    'onnotificationclose',
    'onoffline',
    'ononline',
    'onpush',
    'onpushsubscriptionchange',
    'onrejectionhandled',
    'onsync',
    'onunhandledrejection',
    'performance',
    'Performance',
    'PerformanceEntry',
    'PerformanceMark',
    'PerformanceMeasure',
    'PerformanceNavigation',
    'PerformanceResourceTiming',
    'PerformanceTiming',
    'postMessage',
    'Promise',
    'queueMicrotask',
    'registration',
    'removeEventListener',
    'Request',
    'Response',
    'self',
    'ServiceWorker',
    'ServiceWorkerContainer',
    'ServiceWorkerGlobalScope',
    'ServiceWorkerMessageEvent',
    'ServiceWorkerRegistration',
    'setInterval',
    'setTimeout',
    'skipWaiting',
    'TextDecoder',
    'TextEncoder',
    'URL',
    'URLSearchParams',
    'WebSocket',
    'WindowClient',
    'Worker',
    'WorkerGlobalScope',
    'XMLHttpRequest',
  ];

  // project-rome/@romejs/js-compiler/scope/Scope.ts
let ___R$$priv$project$rome$$romejs$js$compiler$scope$Scope_ts$scopeCounter = 0;

  Error.stackTraceLimit = Infinity;

  class ___R$project$rome$$romejs$js$compiler$scope$Scope_ts$default {
    constructor({
      kind,
      node,
      parentScope,
      rootScope,
    }) {
      this.parentScope = parentScope;
      this.rootScope = rootScope;
      this.node = node;
      this.kind = kind;
      this.bindings = new Map();
      this.id = ___R$$priv$project$rome$$romejs$js$compiler$scope$Scope_ts$scopeCounter++;
      this.hasHoistedVars = false;
      this.globals = new Set();

      this.childScopeCache = new WeakMap();
    }

    setHoistedVars() {
      this.hasHoistedVars = true;
    }

    hasBindings() {
      return this.bindings.size > 0;
    }

    getOwnBindings() {
      return this.bindings;
    }

    getOwnBindingNames() {
      return Array.from(this.bindings.keys());
    }

    findScope(kind) {
      let scope = this;
      while (scope !== undefined) {
        if (scope.kind === kind) {
          return scope;
        } else {
          scope = scope.parentScope;
        }
      }
    }

    getRootScope() {
      const {rootScope} = this;
      if (rootScope === undefined) {
        throw new Error('Expected rootScope');
      }
      return rootScope;
    }

    evaluate(node, parent = ___R$project$rome$$romejs$js$ast$temp$MockParent_ts$MOCK_PARENT, creatorOnly = false, force = false) {
      if (node === undefined) {
        return this;
      }

      if (!force && node === this.node) {
        return this;
      }
      const cached = this.childScopeCache.get(node);
      if (cached !== undefined) {
        return cached;
      }

      let evaluator = ___R$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$default.get(node.type);

      if (!creatorOnly && evaluator !== undefined && evaluator.creator) {
        evaluator = undefined;
      }

      if (evaluator === undefined) {
        return this;
      }

      let scope = evaluator.build(node, parent, this);

      if (scope === undefined) {
        scope = this;
      }

      this.childScopeCache.set(node, scope);
      return scope;
    }

    fork(kind, node) {
      const rootScope = this.getRootScope();
      return (
        new ___R$project$rome$$romejs$js$compiler$scope$Scope_ts$default(
          {
            kind,
            node,
            parentScope: this,
            rootScope,
          },
        )
      );
    }

    dump(root = true) {
      if (root) {
        console.log('START');
      }
      console.log('------', this.id, this.kind);
      for (const [name, binding] of this.bindings) {
        console.log(' ', binding.id, '-', binding.constructor.name, name);
      }
      if (this.parentScope !== undefined) {
        this.parentScope.dump(false);
      }
      if (root) {
        console.log('END');
      }
    }

    getOwnBinding(name) {
      return this.bindings.get(name);
    }

    getBinding(name) {
      const binding = this.getOwnBinding(name);
      if (binding !== undefined) {
        return binding;
      }

      const {parentScope} = this;
      if (parentScope !== undefined) {
        return parentScope.getBinding(name);
      }

      return undefined;
    }

    getBindingAssert(name) {
      const binding = this.getBinding(name);
      if (binding === undefined) {
        this.dump();
        throw new Error('Expected ' +
        name +
        ' binding');
      }
      return binding;
    }

    addBinding(binding) {
      this.bindings.set(binding.name, binding);
      return binding;
    }

    hasBinding(name) {
      return this.getBinding(name) !== undefined;
    }

    generateUid(name) {
      return this.getRootScope().generateUid(name);
    }

    addGlobal(name) {
      this.globals.add(name);
    }

    isGlobal(name) {
      if (this.globals.has(name)) {
        return true;
      }

      if (this.parentScope !== undefined) {
        return this.parentScope.isGlobal(name);
      }

      return false;
    }
  }

  const ___R$$priv$project$rome$$romejs$js$compiler$scope$Scope_ts$GLOBAL_COMMENT_START = /^([\s+]|)global /;
  const ___R$$priv$project$rome$$romejs$js$compiler$scope$Scope_ts$GLOBAL_COMMENT_COLON = /:(.*?)$/;

  class ___R$project$rome$$romejs$js$compiler$scope$Scope_ts$RootScope extends ___R$project$rome$$romejs$js$compiler$scope$Scope_ts$default {
    constructor(context, ast) {
      super(
        {
          kind: 'root',
          parentScope: undefined,
          rootScope: undefined,
          node: undefined,
        },
      );
      this.uids = new Set();
      this.context = context;

      this.globals =
        new Set(
          [
            ...___R$project$rome$$romejs$js$compiler$scope$globals_ts.builtin,
            ...___R$project$rome$$romejs$js$compiler$scope$globals_ts.es5,
            ...___R$project$rome$$romejs$js$compiler$scope$globals_ts.es2015,
            ...___R$project$rome$$romejs$js$compiler$scope$globals_ts.es2017,
            ...___R$project$rome$$romejs$js$compiler$scope$globals_ts.browser,
            ...___R$project$rome$$romejs$js$compiler$scope$globals_ts.worker,
            ...___R$project$rome$$romejs$js$compiler$scope$globals_ts.node,
            ...___R$project$rome$$romejs$js$compiler$scope$globals_ts.commonjs,
            ...___R$project$rome$$romejs$js$compiler$scope$globals_ts.serviceworker,
            ...context.project.config.lint.globals,
            ...this.parseGlobalComments(ast),
          ],
        );
    }

    parseGlobalComments(ast) {
      const globals = [];

      for (const {value} of ast.comments) {
        // Check if comment starts with "global ", ignoring any leading whitespace
        if (!___R$$priv$project$rome$$romejs$js$compiler$scope$Scope_ts$GLOBAL_COMMENT_START.test(value)) {
          continue;
        }

        // Remove prefix
        const clean = value.replace(___R$$priv$project$rome$$romejs$js$compiler$scope$Scope_ts$GLOBAL_COMMENT_START, '');

        // Split by commas, supports comments like "foo, bar"
        const parts = clean.split(',');

        for (const part of parts) {
          let name = part.trim();

          // Support comments like "foo: true" amd "bar: false"
          if (___R$$priv$project$rome$$romejs$js$compiler$scope$Scope_ts$GLOBAL_COMMENT_COLON.test(name)) {
            const match = part.match(___R$$priv$project$rome$$romejs$js$compiler$scope$Scope_ts$GLOBAL_COMMENT_COLON);
            if (match == null) {
              throw (
                new Error(
                  'Used RegExp.test already so know this will always match',
                )
              );
            }

            // Remove everything after the colon
            name = name.replace(___R$$priv$project$rome$$romejs$js$compiler$scope$Scope_ts$GLOBAL_COMMENT_COLON, '');

            const value = match[1].trim();

            // Other tools would flag these as unavailable and remove them from the master set

            // We don't do that, we might want to later though?

            // Also, we should maybe validate the value to only true/false
            if (value === 'false') {
              break;
            }
          }

          globals.push(name);
        }
      }

      return globals;
    }

    getRootScope() {
      return this;
    }

    generateUid(name) {
      const prefixed = '' +
      ___R$project$rome$$romejs$js$compiler$constants_ts$SCOPE_PRIVATE_PREFIX +
      (name === undefined ? '' : name);

      // Check for invalid names
      if (name !== undefined && !___R$project$rome$$romejs$js$ast$utils$isValidIdentifierName_ts$default(name)) {
        throw new Error(name +
        ' is not a valid identifier name');
      }

      // TODO find some way to remove the possibility of user bindings colliding with our private prefix
      let counter = 0;

      while (true) {
        const suffix = counter === 0 ? '' : String(counter);
        const name = prefixed + suffix;

        if (this.uids.has(name)) {
          counter++;
        } else {
          this.uids.add(name);
          return name;
        }
      }

      throw new Error('Unreachable');
    }
  }

  // project-rome/@romejs/js-compiler/methods/reduce.ts
const ___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$BAIL_EXIT = 'BAIL';
  const ___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$KEEP_EXIT = 'KEEP';

  /**
 * Validate the return value of an enter or exit transform
 */
  function ___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$validateTransformReturn(
    transformName,
    node,
    path,
  ) {
    // Ignore some constants that will be handled later
    if (node === ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_REMOVE) {
      return;
    }

    // If this function hits a symbol then it's invalid as we would have dealt with it before if it were a valid constant
    if (typeof node === 'symbol') {
      throw (
        new Error(
          'Returned a symbol from transform ' +
          transformName +
          ' that doesn\'t correspond to any reduce constant',
        )
      );
    }

    // Verify common mistake of forgetting to return something
    if (typeof node === 'undefined') {
      throw (
        new Error(
          'Returned `undefined` from transform ' + transformName +
          '. If you meant to delete this node then use `return' +
          ' REDUCE_REMOVE`, otherwise if you want to keep it then use `return path.node;`',
        )
      );
    }

    // Handle returning an array of nodes
    if (Array.isArray(node)) {
      // keyed nodes cannot be replaced with an array of nodes
      if (path.opts.noArrays === true) {
        throw (
          new Error(
            'Cannot replace this keyed node ' +
            path.parent.type +
            '[' +
            path.opts.nodeKey +
            '] with an array of nodes - originated from transform ' +
            transformName,
          )
        );
      }
      return;
    }

    // Verify that it's a valid node
    if (!___R$project$rome$$romejs$js$ast$utils$isNodeLike_ts$default(node)) {
      throw (
        new Error(
          'Expected a return value of a plain object with a `type` property or a reduce constant - originated from \'transform ' +
          transformName,
        )
      );
    }
  }

  /**
 * Given a return value from a transform, determine if we should bail out.
 * Bailing out means returning the actual node and making the parent reduce
 * call handle it (if any).
 */
  function ___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$shouldBailReduce(
    node,
  ) {
    if (Array.isArray(node)) {
      // We just return the array of nodes, without transforming them

      // reduce() calls higher in the chain will splice this array and do it's

      // own transform call so when the transform is performed on the node it's

      // in it's correct place in the tree
      return true;
    }

    // This node is being removed, no point recursing into it
    if (node === ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_REMOVE) {
      return true;
    }

    return false;
  }

  /**
 * Run an exit handler. We will return a tuple marking whether we should bail
 * with the returned value.
 */
  function ___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$runExit(
    path,
    name,
    callback,
    state,
  ) {
    // Call transformer
    let transformedNode = callback(path, state);

    // Validate the node
    ___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$validateTransformReturn(name, transformedNode, path);

    // Check if we need to bail out
    if (___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$shouldBailReduce(transformedNode)) {
      return [___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$BAIL_EXIT, transformedNode];
    }

    // create new path if node has been changed
    if (transformedNode !== path.node) {
      path = path.fork(transformedNode);
    }

    return [___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$KEEP_EXIT, path];
  }

  function ___R$project$rome$$romejs$js$compiler$methods$reduce_ts$default(
    origNode,
    visitors,
    context,
    pathOpts = {},
  ) {
    // Initialize first path
    let path = new ___R$project$rome$$romejs$js$compiler$lib$Path_ts$default(origNode, context, pathOpts);

    // Perform enter transforms
    for (const visitor of visitors) {
      const {enter} = visitor;
      if (enter === undefined) {
        continue;
      }

      // Call transformer
      let transformedNode = enter(path);

      // When returning this symbol, it indicates we should skip the subtree
      if (transformedNode === ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_SKIP_SUBTREE) {
        return origNode;
      }

      // Validate the return value
      ___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$validateTransformReturn(visitor.name, transformedNode, path);

      // Check if we need to bail out. See the comment for shouldBailReduce on what that means
      if (___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$shouldBailReduce(transformedNode)) {
        return transformedNode;
      }

      // Create new path if node has been changed
      if (transformedNode !== path.node) {
        path = path.fork(transformedNode);
      }
    }

    // Reduce the children
    let {node} = path;
    const visitorKeys = ___R$project$rome$$romejs$js$ast$utils_ts$visitorKeys.get(node.type);
    if (visitorKeys !== undefined) {
      // Build the ancestry paths that we'll pass to each child path
      const ancestryPaths = pathOpts.ancestryPaths || [];
      let childAncestryPaths = [path].concat(ancestryPaths);

      // Reduce the children
      for (const key of visitorKeys) {
        // rome-suppress lint/noExplicitAny
        const oldVal = (node)[key];

        if (Array.isArray(oldVal)) {
          let children = oldVal;

          // When removing items from the children array, we decrement this offset and subtract it

          // whenever looking up to get the correct position
          let childrenOffset = 0;

          // This needs to be calculated beforehand as the length of the array may change when removing

          // items
          let length = children.length;

          for (let i = 0;
          i < length;
          i++) {
            // Calculate the correct index that this children can be found at
            const correctedIndex = childrenOffset + i;

            // Get the child
            const child = children[correctedIndex];

            // An array may be mixed containing [undefined, Node] etc so check that it's actually a valid node

            // An example of a property with empty elements is an ArrayExpression with holes
            if (___R$project$rome$$romejs$js$ast$utils$isNodeLike_ts$default(child)) {
              // Run transforms on this node
              const newChild = ___R$project$rome$$romejs$js$compiler$methods$reduce_ts$default(
                child,
                visitors,
                context,
                {
                  noScopeCreation: pathOpts.noScopeCreation,
                  frozen: pathOpts.frozen,
                  parentScope: path.scope,
                  ancestryPaths: childAncestryPaths,
                  listKey: correctedIndex,
                  nodeKey: key,
                },
              );

              // If this item has been changed then...
              if (newChild !== child && !pathOpts.frozen) {
                // Clone the children array
                children = children.slice();

                // Check if the item is to be deleted

                // REDUCE_REMOVE or an empty array are considered equivalent
                if (newChild === ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_REMOVE ||
                Array.isArray(newChild) &&
                  newChild.length === 0) {
                  // Remove the item from the array
                  children.splice(correctedIndex, 1);

                  // Since the array now has one less item, change the offset so all

                  // future indices will be correct
                  childrenOffset--;
                } else if (Array.isArray(newChild)) {
                  var ___R$;
                  // Remove the previous, and add the new items to the array

                    ___R$ =
                      children,
                    ___R$.splice.apply(___R$, [
                      correctedIndex,
                      1,
                      ...newChild,
                    ])
                  ;

                  // We increase the length of the array so that this loop covers

                  // the newly inserted nodes

                  // `childrenOffset` is not used here because that's just used to

                  // skip elements
                  length += newChild.length;

                  // Revisit the current index, this is necessary as there's now a

                  // new node at this position
                  i--;
                } else {
                  // Otherwise it's a valid node so set it
                  children[correctedIndex] = newChild;

                  // Revisit the current index, the node has changed and some

                  // transforms may care about it
                  i--;
                }

                // Mutate the original node - funky typing since Flow doesn't understand the mutation
                node = (Object.assign(
                  {
                  },
                  node,
                  {
                    [key]: children,
                  },
                ));

                // Create a new node path
                path = path.fork(node);

                // And create a new ancestry array for subsequent children
                childAncestryPaths = [path].concat(ancestryPaths);
              }
            }
          }
        } else if (___R$project$rome$$romejs$js$ast$utils$isNodeLike_ts$default(oldVal)) {
          // Run transforms on this node
          let newVal = ___R$project$rome$$romejs$js$compiler$methods$reduce_ts$default(
            oldVal,
            visitors,
            context,
            {
              noScopeCreation: pathOpts.noScopeCreation,
              parentScope: path.scope,
              ancestryPaths: childAncestryPaths,
              noArrays: true,
              frozen: pathOpts.frozen,
              nodeKey: key,
            },
          );

          // If this value has been changed then...
          if (newVal !== oldVal && !pathOpts.frozen) {
            // When replacing a key value, we cannot replace it with an array
            if (Array.isArray(newVal)) {
              throw (
                new Error(
                  'Cannot replace a key value node with an array of nodes',
                )
              );
            }

            // If the node is deleted then use `void` instead
            if (newVal === ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_REMOVE) {
              newVal = undefined;
            }

            // Mutate the original object - funky typing since Flow doesn't understand the mutation
            node = (Object.assign(
              {
              },
              node,
              {
                [key]: newVal,
              },
            ));

            // Create a new node path for it
            path = path.fork(node);

            // And create a new ancestry array for subsequent children
            childAncestryPaths = [path].concat(ancestryPaths);
          }
        } else {
          // not sure what this is...
          continue;
        }
      }
    }

    // Run all exit hooks
    for (const ref of path.hooks) {
      const {exit} = ref.descriptor;
      if (exit === undefined) {
        // A hook exit method is optional
        continue;
      }

      const res = ___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$runExit(path, ref.descriptor.name, exit, ref.state);
      if (res[0] === ___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$BAIL_EXIT) {
        return res[1];
      } else {
        path = res[1];
      }
    }

    // Run exit transforms
    for (const visitor of visitors) {
      if (visitor.exit !== undefined) {
        const res = ___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$runExit(path, visitor.name, visitor.exit, undefined);
        if (res[0] === ___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$BAIL_EXIT) {
          return res[1];
        } else {
          path = res[1];
        }
      }
    }

    return path.node;
  }

  // project-rome/@romejs/js-compiler/lib/Context.ts
class ___R$project$rome$$romejs$js$compiler$lib$Context_ts$default {
    constructor(arg) {
      const {ast, project, options = {}, origin} = arg;

      this.diagnostics = [];
      this.records = [];

      this.path = ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(ast.filename);
      this.filename = ast.filename;

      this.mtime = ast.mtime;
      this.project = project;
      this.options = options;
      this.origin = origin;
      this.cacheDependencies = new Set();
      this.sourceType = ast.sourceType;
      this.rootScope = new ___R$project$rome$$romejs$js$compiler$scope$Scope_ts$RootScope(this, ast);
    }

    async normalizeTransforms(transforms) {
      return (
        Promise.all(
          transforms.map(
            async (visitor) => {
              if (typeof visitor === 'function') {
                return await visitor(this);
              } else {
                return visitor;
              }
            },
          ),
        )
      );
    }

    getRootScope() {
      const {rootScope} = this;
      if (rootScope === undefined) {
        throw new Error('Expected root scope');
      }
      return rootScope;
    }

    getCacheDependencies() {
      return Array.from(this.cacheDependencies);
    }

    addCacheDependency(filename) {
      this.cacheDependencies.add(filename);
    }

    reduce(ast, visitors, pathOpts) {
      return ___R$project$rome$$romejs$js$compiler$methods$reduce_ts$default(ast, visitors, this, pathOpts);
    }

    record(record) {
      this.records.push(record);
    }

    addDiagnostics(diagnostics) {
      this.diagnostics = [...this.diagnostics, ...diagnostics];
    }

    addLocDiagnostic(loc, diag) {
      let origins = [];
      if (this.origin !== undefined) {
        origins.push(this.origin);
      }
      if (diag.origins !== undefined) {
        origins = origins.concat(diag.origins);
      }

      if (loc !== undefined && loc.filename !== this.filename) {
        throw (
          new Error(
            'Trying to add a location from ' +
            loc.filename +
            ' on a Context from ' +
            this.path,
          )
        );
      }

      this.diagnostics.push(
        Object.assign(
          {
          },
          diag,
          {
            mtime: this.mtime,
            filename: this.filename,
            start: loc === undefined ? diag.start : loc.start,
            end: loc === undefined ? diag.end : loc.end,
            language: 'js',
            sourceType: this.sourceType,
            origins,
          },
        ),
      );
    }

    addNodeDiagnostic(node, diag) {
      return this.addLocDiagnostic(node === undefined ? undefined : node.loc, diag);
    }

    addNodesRangeDiagnostic(nodes, diag) {
      return (
        this.addLocDiagnostic(
          ___R$project$rome$$romejs$parser$core$index_ts$extractSourceLocationRangeFromNodes(nodes),
          diag,
        )
      );
    }
  }

  // project-rome/@romejs/js-compiler/lib/Path.ts
class ___R$project$rome$$romejs$js$compiler$lib$Path_ts$default {
    constructor(node, context, opts) {
      const ancestryPaths = opts.ancestryPaths || [];
      this.ancestryPaths = ancestryPaths;

      if (node === ___R$project$rome$$romejs$js$ast$temp$MockParent_ts$MOCK_PARENT) {
        this.parentPath = this;
      } else if (ancestryPaths.length === 0) {
        this.parentPath =
          new ___R$project$rome$$romejs$js$compiler$lib$Path_ts$default(
            ___R$project$rome$$romejs$js$ast$temp$MockParent_ts$MOCK_PARENT,
            context,
            {
              isMock: true,
            },
          );
      } else {
        this.parentPath = ancestryPaths[0];
      }

      this.node = node;
      this.parent = this.parentPath.node;
      this.context = context;

      const parentScope = opts.parentScope === undefined
        ? context.getRootScope() : opts.parentScope;

      let scope = opts.scope;
      if (scope === undefined) {
        if (opts.noScopeCreation === true) {
          scope = parentScope;
        } else {
          scope = parentScope.evaluate(node, this.parent, true);
        }
      }
      this.scope = scope;

      this.nodeKey = opts.nodeKey;
      this.listKey = opts.listKey;

      this.isMock = opts.isMock === true;
      this.opts = opts;

      this.hooks = opts.hooks === undefined ? [] : opts.hooks;
    }

    callHook( // rome-suppress lint/noExplicitAny
    descriptor, arg, optionalRet, requiredDepth) {
      const hook = this.findHook(descriptor, requiredDepth);
      if (hook === undefined) {
        if (optionalRet === undefined) {
          throw new Error('No hook found');
        } else {
          return optionalRet;
        }
      }
      if (descriptor.call === undefined) {
        throw new Error('Hook doesn\'t have a call method');
      }

      const {depth, ref} = hook;
      const {state, value, bubble} = descriptor.call(this, ref.state, arg);
      ref.state = state;

      if (bubble === true) {
        return this.callHook(descriptor, arg, value, depth + 1);
      } else {
        return value;
      }
    }

    provideHook( // rome-suppress lint/noExplicitAny
    descriptor, state) {
      this.hooks.push(
        {
          state: Object.assign(
            {
            },
            descriptor.initialState,
            state,
          ),
          descriptor,
        },
      );

      return this.node;
    }

    findHook(
      descriptor,
      requiredDepth = 0,
    ) {
      let depth = 0;
      for (const {hooks} of this.ancestryPaths) {
        for (const hook of hooks) {
          if (hook.descriptor === descriptor) {
            if (depth === requiredDepth) {
              return {ref: hook, depth};
            } else {
              depth++;
            }
          }
        }
      }
    }

    findAncestry(callback) {
      for (const path of this.ancestryPaths) {
        if (callback(path)) {
          return path;
        }
      }
    }

    getChildPath(key) {
      // rome-suppress lint/noExplicitAny
      const node = (this.node)[key];
      if (node === undefined) {
        throw (
          new Error(
            'Attempted to get child path for ' +
            key +
            ' but no such node existed',
          )
        );
      }

      return (
        new ___R$project$rome$$romejs$js$compiler$lib$Path_ts$default(
          node,
          this.context,
          {
            parentScope: this.scope,
            ancestryPaths: this.ancestryPaths.concat([this]),
            nodeKey: key,
          },
        )
      );
    }

    getChildPaths(key) {
      // rome-suppress lint/noExplicitAny
      const nodes = (this.node)[key];

      if (nodes === undefined) {
        throw (
          new Error(
            'Attempted to get child paths for ' +
            key +
            ' but no such node existed',
          )
        );
      }

      if (!Array.isArray(nodes)) {
        throw new Error('Expected child nodes for ' +
        key +
        ' to be an array');
      }

      const ancestryPaths = this.ancestryPaths.concat([this]);

      return (
        nodes.map(
          (node, i) => {
            return (
              new ___R$project$rome$$romejs$js$compiler$lib$Path_ts$default(
                node,
                this.context,
                {
                  parentScope: this.scope,
                  ancestryPaths,
                  listKey: i,
                  nodeKey: key,
                },
              )
            );
          },
        )
      );
    }

    getPathKeys() {
      const parts = [];

      let path = this;
      while (path !== undefined && !path.isMock) {
        if (path.listKey !== undefined) {
          parts.push(String(path.listKey));
        }
        if (path.nodeKey !== undefined) {
          parts.push(path.nodeKey);
        }
        path = path.parentPath;
      }

      return parts.reverse();
    }

    fork(newNode) {
      return new ___R$project$rome$$romejs$js$compiler$lib$Path_ts$default(newNode, this.context, this.getPathOptions());
    }

    getPathOptions() {
      return (
        Object.assign(
          {
          },
          this.opts,
          {
            hooks: this.hooks,
            parentScope: this.scope === undefined ? undefined : this.scope.parentScope,
          },
        )
      );
    }

    traverse(name, callback) {
      this.reduce(
        {
          name,
          enter(path) {
            callback(path);
            return path.node;
          },
        },
      );
    }

    reduce(visitors, opts) {
      return (
        ___R$project$rome$$romejs$js$compiler$methods$reduce_ts$default(
          this.node,
          Array.isArray(visitors) ? visitors : [visitors],
          this.context,
          Object.assign(
            {
            },
            this.getPathOptions(),
            opts,
          ),
        )
      );
    }

    addDiagnostic(opts) {
      return this.context.addNodeDiagnostic(this.node, opts);
    }
  }

  // project-rome/@romejs/js-compiler/lib/Record.ts
class ___R$project$rome$$romejs$js$compiler$lib$Record_ts$default {}

  // project-rome/@romejs/js-compiler/lib/Cache.ts
let ___R$$priv$project$rome$$romejs$js$compiler$lib$Cache_ts$projectIdCounter = 0;
  const ___R$$priv$project$rome$$romejs$js$compiler$lib$Cache_ts$projectToId = new WeakMap();

  class ___R$project$rome$$romejs$js$compiler$lib$Cache_ts$default {
    constructor() {
      this.cache = new WeakMap();
    }

    static buildQuery(req, options) {
      const {ast, project} = req;
      const keyParts = [];

      let projectId = ___R$$priv$project$rome$$romejs$js$compiler$lib$Cache_ts$projectToId.get(project);
      if (projectId === undefined) {
        projectId = ___R$$priv$project$rome$$romejs$js$compiler$lib$Cache_ts$projectIdCounter++;
        ___R$$priv$project$rome$$romejs$js$compiler$lib$Cache_ts$projectToId.set(project, projectId);
      }

      // Add project config cache counter
      keyParts.push(String(projectId));

      // Add options if they exist
      if (options !== undefined && Object.keys(options).length > 0) {
        keyParts.push(JSON.stringify(options));
      }

      return (
        {
          ast,
          key: keyParts.join(';'),
        }
      );
    }

    get(query) {
      const astCache = this.cache.get(query.ast);
      if (astCache) {
        return astCache.get(query.key);
      }
    }

    set(query, value) {
      let astCache = this.cache.get(query.ast);
      if (astCache === undefined) {
        astCache = new Map();
        this.cache.set(query.ast, astCache);
      }
      astCache.set(query.key, value);
    }
  }

  // project-rome/@romejs/js-compiler/transforms/lint/defaultExportSameBasename.ts
function ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$defaultExportSameBasename_ts$isValidDeclaration(
    node,
  ) {
    return node.type === 'FunctionDeclaration' || node.type === 'ClassDeclaration';
  }

  function ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$defaultExportSameBasename_ts$filenameToId(path, capitalize) {
    let basename = path.getExtensionlessBasename();

    if (basename === 'index') {
      // If the filename is `index` then use the parent directory name
      basename = path.getParent().getExtensionlessBasename();
    }

    return ___R$project$rome$$romejs$string$utils$toCamelCase_ts$toCamelCase(basename, capitalize);
  }

  const ___R$project$rome$$romejs$js$compiler$transforms$lint$defaultExportSameBasename_ts$default = {
    name: 'defaultExportSameBasename',
    enter(path) {
      const {context, node} = path;

      if (node.type === 'Program') {
        let defaultExport;
        for (const bodyNode of node.body) {
          if (bodyNode.type === 'ExportDefaultDeclaration') {
            defaultExport = bodyNode;
            break;
          }
        }

        if (defaultExport !== undefined &&
          ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$defaultExportSameBasename_ts$isValidDeclaration(
            defaultExport.declaration,
          )) {
          const {declaration} = defaultExport;

          // Get the export default id
          const id = declaration.id;
          if (id !== undefined && context.path !== undefined) {
            const type = declaration.type === 'FunctionDeclaration'
              ? 'function' : 'class';
            const basename = ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$defaultExportSameBasename_ts$filenameToId(context.path, type === 'class');

            if (basename !== id.name) {
              const correctFilename = id.name + context.path.getExtensions();

              let adviceMessage = '';

              if (id.name === '*default*') {
                adviceMessage += 'The';
              } else {
                adviceMessage +=
                  'Filename should be <emphasis>' +
                  correctFilename +
                  '</emphasis> or the';
              }

              adviceMessage +=
                ' ' +
                type +
                ' name should be <emphasis>' +
                basename +
                '</emphasis>';

              context.addNodeDiagnostic(
                id,
                {
                  fixable: true,
                  category: 'lint/defaultExportSameBasename',
                  message: 'Filename and the name of a default ' +
                  type +
                  ' should match',
                  advice: [
                    {
                      type: 'log',
                      category: 'info',
                      message: adviceMessage,
                    },
                  ],
                },
              );

              return ___R$project$rome$$romejs$js$ast$utils$renameBindings_ts$default(path, new Map([[id.name, basename]]));
            }
          }
        }
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/noMultipleSpacesInRegularExpressionLiterals.ts
function ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$noMultipleSpacesInRegularExpressionLiterals_ts$isSpaceChar(
    node,
  ) {
    return (
      node !== undefined && node.type === 'RegExpCharacter' &&
        node.value ===
        ' '
    );
  }

  function ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$noMultipleSpacesInRegularExpressionLiterals_ts$checkRegex(
    node,
    context,
  ) {
    for (let i = 0;
    i < node.body.length;
    i++) {
      const item = node.body[i];

      // Do some quick checks to see if we'll produce an error
      if (!___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$noMultipleSpacesInRegularExpressionLiterals_ts$isSpaceChar(item) || !___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$noMultipleSpacesInRegularExpressionLiterals_ts$isSpaceChar(node.body[i + 1])) {
        continue;
      }

      const spaceNodes = [];

      // Get all the space nodes
      for (let x = i;
      x < node.body.length;
      x++) {
        const item = node.body[i];
        if (___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$noMultipleSpacesInRegularExpressionLiterals_ts$isSpaceChar(item)) {
          spaceNodes.push(item);
          x++;
        } else {
          break;
        }
      }

      context.addLocDiagnostic(
        ___R$project$rome$$romejs$parser$core$index_ts$extractSourceLocationRangeFromNodes(spaceNodes),
        {
          fixable: true,
          category: 'lint/noMultipleSpacesInRegularExpressionLiterals',
          message: 'Unclear multiple spaces in regular expression',
          advice: [
            {
              type: 'log',
              category: 'info',
              message: 'It\'s hard to visually count the amount of spaces, it\'s clearer if you use a quantifier instead. eg / {' +
              spaceNodes.length +
              '}/',
            },
          ],
        },
      );

      const quantifiedSpace = ___R$project$rome$$romejs$js$ast$regex$RegExpQuantified_ts$regExpQuantified.create(
        {
          min: spaceNodes.length,
          max: spaceNodes.length,
          target: item,
        },
      );

      const newRegex = Object.assign(
        {
        },
        node,
        {
          body: [
            // Get start
            ...node.body.slice(0, i - 1),
            // Inject quantifier
            quantifiedSpace,
            // Get end
            ...node.body.slice(i + spaceNodes.length),
          ],
        },
      );

      return ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$noMultipleSpacesInRegularExpressionLiterals_ts$checkRegex(newRegex, context);
    }

    return node;
  }

  const ___R$project$rome$$romejs$js$compiler$transforms$lint$noMultipleSpacesInRegularExpressionLiterals_ts$default = {
    name: 'noMultipleSpacesInRegularExpressionLiterals',
    enter(path) {
      const {context, node} = path;

      if (node.type === 'RegExpSubExpression') {
        return ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$noMultipleSpacesInRegularExpressionLiterals_ts$checkRegex(node, context);
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/noVar.ts
const ___R$project$rome$$romejs$js$compiler$transforms$lint$noVar_ts$default = {
    name: 'noVar',
    enter(path) {
      const {context, node: declaration} = path;

      if (declaration.type === 'VariableDeclaration' && declaration.kind === 'var') {
        context.addNodeDiagnostic(
          declaration,
          {
            category: 'lint/noVar',
            message: 'Variable declarations using `var` are disallowed, use `let` or `const` instead.',
          },
        );
      }

      return declaration;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/emptyBlocks.ts
function ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$emptyBlocks_ts$isEmpty(node) {
    if (node.innerComments !== undefined && node.innerComments.length > 0) {
      return false;
    }

    if (node.type === 'EmptyStatement') {
      return true;
    }

    if (node.type === 'BlockStatement' && node.body.length === 0) {
      return true;
    }

    return false;
  }

  const ___R$project$rome$$romejs$js$compiler$transforms$lint$emptyBlocks_ts$default = {
    name: 'emptyBlocks',
    enter(path) {
      const {node, context} = path;

      if (node.type === 'IfStatement') {
        if (___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$emptyBlocks_ts$isEmpty(node.consequent)) {
          context.addNodeDiagnostic(
            node.consequent,
            {
              category: 'lint/emptyBlocks',
              message: 'Empty block',
            },
          );
        }
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/getterReturn.ts
const ___R$project$rome$$romejs$js$compiler$transforms$lint$getterReturn_ts$default = {
    name: 'getterReturn',
    enter(path) {
      const {node} = path;

      if ((node.type === 'ClassMethod' || node.type === 'ObjectMethod') &&
        node.kind === 'get') {
        for (const record of ___R$project$rome$$romejs$js$ast$utils$getCompletionRecords_ts$default(node.body)) {
          if (record.type === 'INVALID') {
            path.context.addNodeDiagnostic(
              record.node,
              {
                category: 'lint/getterReturn',
                message: 'Expected a \'return\' at end of a getter method but got ' +
                record.description,
              },
            );
          }
        }
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/noAsyncPromiseExecutor.ts
const ___R$project$rome$$romejs$js$compiler$transforms$lint$noAsyncPromiseExecutor_ts$default = {
    name: 'noAsyncPromiseExecutor',
    enter(path) {
      const {node, context} = path;

      if (node.type === 'NewExpression' &&
        node.callee.type ===
        'ReferenceIdentifier' &&
        node.callee.name === 'Promise' &&
        node.arguments.length > 0 &&
        (node.arguments[0].type ===
        'ArrowFunctionExpression' ||
        node.arguments[0].type === 'FunctionExpression') &&
        node.arguments[0].head.async) {
        context.addNodeDiagnostic(
          node.arguments[0],
          {
            category: 'lint/noAsyncPromiseExecutor',
            message: 'Promise executor functions should not be async.',
          },
        );
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/noCompareNegZero.ts
const ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$noCompareNegZero_ts$OPERATORS_TO_CHECK = ['>', '>=', '<', '<=', '==', '===', '!=', '!=='];

  function ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$noCompareNegZero_ts$isNegZero(node) {
    return (
      node.type === 'UnaryExpression' && node.operator === '-' &&
        node.argument.type === 'NumericLiteral' &&
        node.argument.value === 0
    );
  }

  const ___R$project$rome$$romejs$js$compiler$transforms$lint$noCompareNegZero_ts$default = {
    name: 'noCompareNegZero',
    enter(path) {
      const {node} = path;

      if (node.type === 'BinaryExpression' &&
        ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$noCompareNegZero_ts$OPERATORS_TO_CHECK.includes(
          node.operator,
        ) &&
        (___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$noCompareNegZero_ts$isNegZero(node.left) || ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$noCompareNegZero_ts$isNegZero(node.right))) {
        path.context.addNodeDiagnostic(
          node,
          {
            category: 'lint/noCompareNegZero',
            message: 'Do not use the \'' +
            node.operator +
            '\' operator to compare against -0',
            fixable: true,
          },
        );
        return ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`Object.is(${node.left}, ${node.right})`;
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/noCondAssign.ts
const ___R$project$rome$$romejs$js$compiler$transforms$lint$noCondAssign_ts$default = {
    name: 'noCondAssign',
    enter(path) {
      const {node} = path;

      if ((node.type === 'IfStatement' || node.type === 'ForStatement' ||
      node.type === 'WhileStatement' ||
      node.type === 'DoWhileStatement') &&
        node.test &&
        node.test.type === 'AssignmentExpression') {
        path.context.addNodeDiagnostic(
          node,
          {
            category: 'lint/noCondAssign',
            message: 'Cannot assign variable in loop condition',
          },
        );
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/noDebugger.ts
const ___R$project$rome$$romejs$js$compiler$transforms$lint$noDebugger_ts$default = {
    name: 'noDebugger',
    enter(path) {
      const {node} = path;

      if (node.type === 'DebuggerStatement') {
        path.context.addNodeDiagnostic(
          node,
          {
            fixable: true,
            category: 'lint/noDebugger',
            message: 'Unexpected \'debugger\' statement',
          },
        );

        return ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_REMOVE;
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/noDeleteVars.ts
const ___R$project$rome$$romejs$js$compiler$transforms$lint$noDeleteVars_ts$default = {
    name: 'noDeleteVars',
    enter(path) {
      const {node} = path;

      if (node.type === 'UnaryExpression' && node.operator === 'delete' &&
        node.argument.type === 'ReferenceIdentifier') {
        path.context.addNodeDiagnostic(
          node,
          {
            category: 'lint/noDeleteVars',
            message: 'Variables should not be deleted.',
          },
        );
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/noDupeArgs.ts
const ___R$project$rome$$romejs$js$compiler$transforms$lint$noDupeArgs_ts$default = {
    name: 'noDupeArgs',
    enter(path) {
      const {node, context} = path;

      if (node.type === 'FunctionHead') {
        const uniqueIdentifiers = new Set();

        for (const param of node.params) {
          for (const {name} of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(param)) {
            if (uniqueIdentifiers.has(name)) {
              context.addNodeDiagnostic(
                param,
                {
                  category: 'lint/noDupeArgs',
                  message: 'Duplicate argument <emphasis>' +
                  name +
                  '</emphasis> in function definition',
                },
              );
            }

            uniqueIdentifiers.add(name);
          }
        }
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/noDuplicateCase.ts
const ___R$project$rome$$romejs$js$compiler$transforms$lint$noDuplicateCase_ts$default = {
    name: 'noDuplicateCase',
    enter(path) {
      const {node, context} = path;

      if (node.type === 'SwitchStatement') {
        const uniqueSwitchCases = new Set();

        for (const param of node.cases) {
          if (param.test && param.test.type === 'StringLiteral') {
            const {test} = param;

            if (uniqueSwitchCases.has(test.value)) {
              context.addNodeDiagnostic(
                param,
                {
                  category: 'lint/noDuplicateCase',
                  message: 'Duplicate case <emphasis>' +
                  test.value +
                  '</emphasis> not allowed.',
                },
              );
            }

            uniqueSwitchCases.add(test.value);
          }
        }
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/noDuplicateKeys.ts
function ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$noDuplicateKeys_ts$extractPropertyKey(
    node,
  ) {
    if ((node.type === 'ObjectMethod' || node.type === 'ObjectProperty') &&
      node.key.type === 'StaticPropertyKey') {
      const {value} = node.key;

      if (value.type === 'PrivateName') {
        return value.id.name;
      }

      if (value.type === 'Identifier') {
        return value.name;
      }

      return String(value.value);
    }

    return undefined;
  }

  const ___R$project$rome$$romejs$js$compiler$transforms$lint$noDuplicateKeys_ts$default = {
    name: 'noDuplicateKeys',
    enter(path) {
      const {node} = path;

      if (node.type === 'ObjectExpression') {
        const previousKeys = new Set();

        for (const prop of node.properties) {
          const key = ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$noDuplicateKeys_ts$extractPropertyKey(prop);

          if (key !== undefined) {
            if (previousKeys.has(key)) {
              path.context.addNodeDiagnostic(
                prop,
                {
                  category: 'lint/noDuplicateKeys',
                  message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Duplicate key <emphasis>${key}</emphasis>`,
                },
              );
            }

            previousKeys.add(key);
          }
        }
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/noEmptyCharacterClass.ts
const ___R$project$rome$$romejs$js$compiler$transforms$lint$noEmptyCharacterClass_ts$default = {
    name: 'noEmptyCharacterClass',
    enter(path) {
      const {context, node} = path;

      if (node.type === 'RegExpCharSet' && node.body.length === 0 && !node.invert) {
        context.addNodeDiagnostic(
          node,
          {
            fixable: true,
            category: 'lint/noEmptyCharacterClass',
            message: 'Empty character classes in regular expressions are not allowed',
          },
        );
        return ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_REMOVE;
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/noExplicitAny.ts
const ___R$project$rome$$romejs$js$compiler$transforms$lint$noExplicitAny_ts$default = {
    name: 'noExplicitAny',
    enter(path) {
      const {context, node} = path;

      if (node.type === 'AnyKeywordTypeAnnotation') {
        context.addNodeDiagnostic(
          node,
          {
            category: 'lint/noExplicitAny',
            message: 'Unexpected any. Specify a different type.',
          },
        );
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/noExtraBooleanCast.ts
function ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$noExtraBooleanCast_ts$isBooleanConstructorCall(node) {
    return (
      node.type === 'NewExpression' &&
        node.callee.type ===
        'ReferenceIdentifier' &&
        node.callee.name === 'Boolean'
    );
  }

  function ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$noExtraBooleanCast_ts$isConditionalStatement(node) {
    return node.type === 'ConditionalExpression';
  }

  function ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$noExtraBooleanCast_ts$isInBooleanContext(
    node,
  ) {
    return (
      node.type === 'IfStatement' || node.type === 'DoWhileStatement' ||
      node.type === 'WhileStatement' ||
      node.type === 'ForStatement'
    );
  }

  function ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$noExtraBooleanCast_ts$getNode(path) {
    let {node} = path;

    if (___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$noExtraBooleanCast_ts$isBooleanConstructorCall(node)) {
      if (node.type === 'NewExpression' && node.arguments.length > 0) {
        return node.arguments[0];
      }
    }

    if (___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$noExtraBooleanCast_ts$isInBooleanContext(node) || ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$noExtraBooleanCast_ts$isConditionalStatement(node)) {
      return node.test;
    }
  }

  const ___R$project$rome$$romejs$js$compiler$transforms$lint$noExtraBooleanCast_ts$default = {
    name: 'noExtraBooleanCast',
    enter(path) {
      const {context} = path;

      let node = ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$noExtraBooleanCast_ts$getNode(path);

      if (node !== undefined) {
        if (node.type === 'UnaryExpression' && node.operator === '!' &&
          node.argument.type === 'UnaryExpression' &&
          node.argument.operator ===
          '!' ||
        node.type === 'CallExpression' &&
          node.callee.type ===
          'ReferenceIdentifier' &&
          node.callee.name === 'Boolean') {
          context.addNodeDiagnostic(
            node,
            {
              category: 'lint/noExtraBooleanCast',
              message: 'Redundant double negation.',
            },
          );
        }
      }

      return path.node;
    },
  };

  // project-rome/@romejs/js-compiler/scope/bindings.ts
const ___R$project$rome$$romejs$js$compiler$scope$bindings_ts = {
    get Binding() {
      return (
        ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$Binding
      );
    },

    get ConstBinding() {
      return (
        ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ConstBinding
      );
    },

    get LetBinding() {
      return (
        ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$LetBinding
      );
    },

    get VarBinding() {
      return (
        ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$VarBinding
      );
    },

    get ImportBinding() {
      return (
        ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ImportBinding
      );
    },

    get ArgumentsBinding() {
      return (
        ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ArgumentsBinding
      );
    },

    get FunctionBinding() {
      return (
        ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$FunctionBinding
      );
    },

    get TypeBinding() {
      return (
        ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$TypeBinding
      );
    },

    get ClassBinding() {
      return (
        ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ClassBinding
      );
    },
  };
  let ___R$$priv$project$rome$$romejs$js$compiler$scope$bindings_ts$id = 0;

  class ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$Binding {
    constructor(opts, defaultKind = 'variable') {
      this.isExported = false;
      this.scope = opts.scope;
      this.name = opts.name;
      this.node = opts.node;
      this.kind = opts.kind === undefined ? defaultKind : opts.kind;
      this.id = ___R$$priv$project$rome$$romejs$js$compiler$scope$bindings_ts$id++;
    }

    setExported(isExported) {
      this.isExported = isExported;
    }
  }

  class ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ConstBinding extends ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$Binding {
    constructor(opts, value, defaultKind) {
      super(opts, defaultKind);
      this.value = value;
    }
  }

  class ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$LetBinding extends ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$Binding {}

  class ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$VarBinding extends ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$Binding {}

  class ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ImportBinding extends ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$Binding {
    constructor(opts, meta) {
      super(opts, 'import');
      this.meta = meta;
    }
  }

  class ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ArgumentsBinding extends ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$Binding {
    constructor(opts) {
      super(opts, 'arguments');
    }
  }

  class ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$FunctionBinding extends ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$Binding {
    constructor(opts) {
      super(opts, 'function');
    }
  }

  class ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$TypeBinding extends ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ConstBinding {
    constructor(opts, valueNode, kind) {
      super(opts, valueNode, 'type');
      this.typeKind = kind;
    }
  }

  class ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ClassBinding extends ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$Binding {
    constructor(opts) {
      super(opts, 'class');
    }
  }

  // project-rome/@romejs/js-compiler/transforms/lint/noFunctionAssign.ts
const ___R$project$rome$$romejs$js$compiler$transforms$lint$noFunctionAssign_ts$default = {
    name: 'noFunctionAssign',
    enter(path) {
      const {node, scope} = path;

      if (node.type === 'AssignmentIdentifier' &&
        scope.getBinding(node.name) instanceof ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$FunctionBinding) {
        path.context.addNodeDiagnostic(
          node,
          {
            category: 'lint/noFunctionAssign',
            message: 'Reassignment of function declaration',
          },
        );
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/noImportAssign.ts
function ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$noImportAssign_ts$isAssignment(path) {
    switch (path.parentPath.node.type) {
      case 'AssignmentExpression':
      case 'AssignmentArrayPattern':
      case 'AssignmentObjectPatternProperty':
      case 'UpdateExpression':
      case 'AssignmentObjectPattern':
      case 'ForInStatement':
        return true;
    }
  }

  const ___R$project$rome$$romejs$js$compiler$transforms$lint$noImportAssign_ts$default = {
    name: 'noImportAssign',
    enter(path) {
      const {node, scope} = path;

      if (node.type === 'AssignmentIdentifier' && ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$noImportAssign_ts$isAssignment(path) ||
      node.type === 'ReferenceIdentifier' &&
        path.parentPath.node.type ===
        'UpdateExpression') {
        let binding = scope.getBinding(node.name);
        if (binding !== undefined && binding.kind === 'import') path.context.addNodeDiagnostic(
          node,
          {
            category: 'lint/noImportAssign',
            message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`<emphasis>${node.name}</emphasis> is read-only`,
          },
        );
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/noLabelVar.ts
const ___R$project$rome$$romejs$js$compiler$transforms$lint$noLabelVar_ts$default = {
    name: 'noLabelVar',
    enter(path) {
      const {node, scope} = path;

      if (node.type === 'LabeledStatement') {
        const name = node.label.name;
        const binding = scope.getBinding(name);
        const isDefined = binding !== undefined ||
        scope.getRootScope().isGlobal(
          name,
        );

        if (isDefined) {
          path.context.addNodeDiagnostic(
            node,
            {
              category: 'lint/noLabelVar',
              message: 'Labels should not be variable names',
            },
          );
        }
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/noShadowRestrictedNames.ts
const ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$noShadowRestrictedNames_ts$restrictedNames = new Set([...___R$project$rome$$romejs$js$compiler$scope$globals_ts$builtin, ...___R$project$rome$$romejs$js$compiler$scope$globals_ts$es5, ...___R$project$rome$$romejs$js$compiler$scope$globals_ts$es2015, ...___R$project$rome$$romejs$js$compiler$scope$globals_ts$es2017]);
  const ___R$project$rome$$romejs$js$compiler$transforms$lint$noShadowRestrictedNames_ts$default = {
    name: 'noShadowRestrictedNames',
    enter(path) {
      const {node, context, scope} = path;

      if (scope.node === node) {
        for (const [name, binding] of scope.getOwnBindings()) {
          if (___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$noShadowRestrictedNames_ts$restrictedNames.has(name)) {
            context.addNodeDiagnostic(
              binding.node,
              {
                category: 'lint/noShadowRestrictedNames',
                message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Shadowing of global property <emphasis>${name}</emphasis>`,
                advice: [
                  {
                    type: 'log',
                    category: 'info',
                    message: 'Consider renaming this variable. It\'s easy to confuse the origin of variables when they\'re named after a known global.',
                  },
                ],
              },
            );
          }
        }
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/noTemplateCurlyInString.ts
const ___R$project$rome$$romejs$js$compiler$transforms$lint$noTemplateCurlyInString_ts$default = {
    name: 'noTemplateCurlyInString',
    enter(path) {
      const {node, context} = path;

      if (node.type === 'StringLiteral') {
        const regex = /\$\{[^}]+\}/u;

        if (regex.test(node.value)) {
          context.addNodeDiagnostic(
            node,
            {
              category: 'lint/noTemplateCurlyInString',
              message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Unexpected template string expression.`,
            },
          );
        }
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/noUnsafeFinally.ts
const ___R$project$rome$$romejs$js$compiler$transforms$lint$noUnsafeFinally_ts$default = {
    name: 'noUnsafeFinally',
    enter(path) {
      const {node, context} = path;

      if (node.type === 'TryStatement') {
        const {finalizer} = node;

        if (finalizer && finalizer.type === 'BlockStatement') {
          for (const statement of finalizer.body) {
            if (statement.type === 'ThrowStatement' ||
            statement.type ===
            'ContinueStatement' ||
            statement.type === 'BreakStatement' ||
            statement.type === 'ReturnStatement') {
              context.addNodeDiagnostic(
                statement,
                {
                  category: 'lint/noUnsafeFinally',
                  message: 'Unsafe usage of ' +
                  statement.type +
                  '.',
                },
              );
            }
          }
        }
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/preferFunctionDeclarations.ts
// This hook is created with a list of initial VariableDeclarators that contain functions we want to convert

  // We then remove any ArrowFunctionExpression VariableDeclarators that contain a valid ThisExpression
  const ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$preferFunctionDeclarations_ts$hook = ___R$project$rome$$romejs$js$compiler$api$createHook_ts$default(
    {
      name: 'preferFunctionDeclarationsHook',

      initialState: {
        declarators: [],
      },

      call(path, state, {declarator, node}) {
        return (
          {
            bubble: !state.declarators.includes(declarator),
            value: node,
            state: {
              declarators: state.declarators.filter((decl) => decl !== declarator),
            },
          }
        );
      },

      exit(
        path,
        state,
      ) {
        const node = ___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement.assert(path.node);

        // We may have invalidated all declarations
        if (state.declarators.length === 0) {
          return node;
        }

        const nodes = [];

        const newNode = Object.assign(
          {
          },
          node,
          {
            declaration: Object.assign(
              {
              },
              node.declaration,
              {
                declarations: node.declaration.declarations.filter(
                  (
                    decl,
                  ) =>
                    !state.declarators.includes(decl),
                ),
              },
            ),
          },
        );

        // We may have removed all the declarators
        if (newNode.declaration.declarations.length > 0) {
          nodes.push(newNode);
        }

        // Convert functions
        for (const decl of state.declarators) {
          const id = ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.assert(decl.id);
          const {init} = decl;

          if (init === undefined ||
          init.type !== 'FunctionExpression' &&
            init.type !== 'ArrowFunctionExpression') {
            throw new Error('Invalid declarator put into state');
          }

          path.context.addNodeDiagnostic(
            init,
            {
              category: 'lint/preferFunctionDeclarations',
              message: 'Use a function declaration instead of a const function',
              fixable: true,
            },
          );

          // Convert arrow function body if necessary
          const body = init.body.type === 'BlockStatement'
            ? init.body : ___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts$blockStatement.create(
              {
                body: [___R$project$rome$$romejs$js$ast$statements$ReturnStatement_ts$returnStatement.quick(init.body)],
              },
            );

          nodes.push(
            ___R$project$rome$$romejs$js$ast$statements$FunctionDeclaration_ts$functionDeclaration.create(
              {
                id,
                head: init.head,
                body,
              },
            ),
          );
        }

        return nodes;
      },
    },
  );
  const ___R$project$rome$$romejs$js$compiler$transforms$lint$preferFunctionDeclarations_ts$default = {
    name: 'preferFunctionDeclarations',
    enter(path) {
      const {node} = path;

      if (node.type === 'VariableDeclarationStatement' &&
        node.declaration.kind === 'const') {
        // Get all declarators that are function expressions, have no type annotation, and have a binding identifier id
        const declarators = node.declaration.declarations.filter(
          (decl) => {
            return (
              decl.id.type === 'BindingIdentifier' &&
                (decl.id.meta ===
                undefined ||
                decl.id.meta.typeAnnotation === undefined) &&
                decl.init !==
                undefined &&
                (decl.init.type === 'FunctionExpression' ||
                decl.init.type === 'ArrowFunctionExpression')
            );
          },
        );
        if (declarators.length > 0) {
          return (
            path.provideHook(
              ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$preferFunctionDeclarations_ts$hook,
              {
                declarators,
              },
            )
          );
        }
      }

      // If we have a `this` inside of an arrow function attached as a variable declarator then we should consider

      // it valid
      if (node.type === 'ThisExpression') {
        // Try to find the arrow function owner, or stop if we get to another function
        const func = path.findAncestry(
          (path) => {
            if (path.node.type === 'ArrowFunctionExpression') {
              return path.parent.type === 'VariableDeclarator';
            }

            if (___R$project$rome$$romejs$js$ast$utils$isFunctionNode_ts$default(path.node)) {
              return true;
            }

            return false;
          },
        );

        // We'll only return an ArrowFunctionExpression if it was inside of a VariableDeclarator
        if (func !== undefined && func.node.type === 'ArrowFunctionExpression') {
          return (
            path.callHook(
              ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$preferFunctionDeclarations_ts$hook,
              {
                declarator: ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator.assert(func.parent),
                node,
              },
              node,
            )
          );
        }
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/preferTemplate.ts
const ___R$project$rome$$romejs$js$compiler$transforms$lint$preferTemplate_ts$default = {
    name: 'preferTemplate',
    enter(path) {
      const {node} = path;

      if (node.type === 'BinaryExpression' && node.operator === '+' &&
        (node.left.type === 'StringLiteral' && !node.left.value.includes('`') ||
        node.right.type === 'StringLiteral' && !node.right.value.includes('`'))) {
        path.context.addNodeDiagnostic(
          node,
          {
            category: 'lint/preferTemplate',
            message: 'You\'re using string concatenation when template literals are preferred',
          },
        );
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/sparseArray.ts
const ___R$project$rome$$romejs$js$compiler$transforms$lint$sparseArray_ts$default = {
    name: 'sparseArray',
    enter(path) {
      const {node} = path;

      if (node.type === 'ArrayExpression' && node.elements.includes(undefined)) {
        path.context.addNodeDiagnostic(
          node,
          {
            fixable: true,
            category: 'lint/sparseArray',
            message: 'Your array contains an empty slot',
          },
        );

        return (
          ___R$project$rome$$romejs$js$ast$expressions$ArrayExpression_ts$arrayExpression.quick(
            node.elements.map(
              (
                elem,
              ) =>
                elem === undefined
                  ? ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.create({name: 'undefined'}) : elem,
            ),
          )
        );
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/undeclaredVariables.ts
const ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$undeclaredVariables_ts$NODE_VARIABLES = [
    'require',
    '__dirname',
    '__filename',
    'module',
    'exports',
    'babelHelpers',
  ];

  const ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$undeclaredVariables_ts$BROWSER_VARIABLES = [
    'fetch',
    'document',
    'window',
    'Worker',
    'cancelAnimationFrame',
    'requestAnimationFrame',
    'WebSocket',
    'alert',
    'Blob',
    'navigator',
    'Element',
    'Text',
    'Document',
    'performance',
  ];

  const ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$undeclaredVariables_ts$JEST_VARIABLES = ['expect', 'it', 'jest', 'beforeEach', 'describe'];
  const ___R$project$rome$$romejs$js$compiler$transforms$lint$undeclaredVariables_ts$default = {
    name: 'undeclaredVariables',
    enter(path) {
      const {node, scope} = path;

      if ((node.type === 'ReferenceIdentifier' ||
      node.type ===
      'JSXReferenceIdentifier') &&
        !___R$project$rome$$romejs$js$ast$utils$isInTypeAnnotation_ts$default(path)) {
        const {name} = node;
        const binding = scope.getBinding(name);

        const isDefined = binding !== undefined ||
        scope.getRootScope().isGlobal(
          name,
        ) ||
        ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$undeclaredVariables_ts$JEST_VARIABLES.includes(name) ||
        ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$undeclaredVariables_ts$BROWSER_VARIABLES.includes(name) ||
        ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$undeclaredVariables_ts$NODE_VARIABLES.includes(name);

        if (!isDefined) {
          path.context.addNodeDiagnostic(
            node,
            {
              category: 'lint/undeclaredVariables',
              message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Undeclared variable <emphasis>${name}</emphasis>`,
            },
          );
        }
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/unsafeNegation.ts
const ___R$project$rome$$romejs$js$compiler$transforms$lint$unsafeNegation_ts$default = {
    name: 'unsafeNegation',
    enter(path) {
      const {node} = path;

      if (node.type === 'BinaryExpression' &&
        (node.operator === 'in' ||
        node.operator === 'instanceof') &&
        node.left.type === 'UnaryExpression' &&
        node.left.operator === '!') {
        path.context.addNodeDiagnostic(
          node,
          {
            fixable: true,
            category: 'lint/unsafeNegation',
            message: 'Unsafe usage of negation operator in left side of binary expression',
          },
        );

        return (
          ___R$project$rome$$romejs$js$ast$expressions$UnaryExpression_ts$unaryExpression.create(
            {
              operator: node.left.operator,
              argument: Object.assign(
                {
                },
                node,
                {
                  left: node.left.argument,
                },
              ),
            },
          )
        );
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/unusedVariables.ts
const ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$unusedVariables_ts$initialState = {
    usedBindings: {},
    scope: undefined,
  };

  const ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$unusedVariables_ts$provider = ___R$project$rome$$romejs$js$compiler$api$createHook_ts$default(
    {
      name: 'unusedVariablesProvider',

      initialState: ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$unusedVariables_ts$initialState,

      call(path, state) {
        const {node} = path;
        if (node.type !== 'ReferenceIdentifier' &&
          node.type !==
          'JSXReferenceIdentifier') {
          throw new Error('Expected only Identifier to be dispatched');
        }

        const binding = path.scope.getBinding(node.name);

        // Check if this binding belongs to the scope we're tracking
        if (binding === undefined || binding.scope !== state.scope) {
          return (
            {
              bubble: true,
              value: node,
              state,
            }
          );
        }

        // Mark this binding as used
        return (
          {
            value: node,
            state: Object.assign(
              {
              },
              state,
              {
                usedBindings: Object.assign(
                  {
                  },
                  state.usedBindings,
                  {
                    [node.name]: true,
                  },
                ),
              },
            ),
          }
        );
      },

      exit(path, state) {
        for (const name in state.usedBindings) {
          const used = state.usedBindings[name];
          const binding = path.scope.getBinding(name);

          if (used === false && binding !== undefined) {
            path.context.addNodeDiagnostic(
              binding.node,
              {
                category: 'lint/unusedVariables',
                message: 'Unused ' +
                binding.kind +
                ' <emphasis>' +
                name +
                '</emphasis>',
              },
            );
          }
        }

        return path.node;
      },
    },
  );
  const ___R$project$rome$$romejs$js$compiler$transforms$lint$unusedVariables_ts$default = {
    name: 'unusedVariables',
    enter(path) {
      const {node, scope} = path;

      if (scope.node === node) {
        const usedBindings = {};

        // Get all the non-exported bindings in this file and mark them as unused
        for (const [name, binding] of scope.getOwnBindings()) {
          if (binding instanceof ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ArgumentsBinding) {
            continue;
          }

          if (binding.isExported) {
            continue;
          }

          usedBindings[name] = false;
        }

        // For functions, consider all parameters except the last to be used
        if (node.type === 'FunctionDeclaration' ||
        node.type ===
        'FunctionExpression' ||
        node.type === 'ObjectMethod' ||
        node.type ===
        'ClassMethod' ||
        node.type === 'ArrowFunctionExpression') {
          for (const {name} of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(node.head.params.slice(0, -1))) {
            usedBindings[name] = true;
          }

          // For functions that have a single throw statement in the body, consider all their arguments

          // to be used as this is typically an interface definition
          const {body: block} = node;
          if (block.type === 'BlockStatement' && block.body.length === 1 &&
            block.body[0].type === 'ThrowStatement') {
            for (const {name} of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(node.head.params)) {
              usedBindings[name] = true;
            }
          }
        }

        if (node.type === 'CatchClause' && node.param &&
          node.param.type ===
          'BindingIdentifier') {
          // Mark error param as used as they are required
          usedBindings[node.param.name] = true;
        }

        // For a named function expression, don't consider the id to be unused
        if (node.type === 'FunctionExpression' && node.id !== undefined) {
          usedBindings[node.id.name] = true;
        }

        return (
          path.provideHook(
            ___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$unusedVariables_ts$provider,
            {
              usedBindings,
              scope,
            },
          )
        );
      }

      if (node.type === 'JSXReferenceIdentifier' ||
      node.type ===
      'ReferenceIdentifier') {
        return path.callHook(___R$$priv$project$rome$$romejs$js$compiler$transforms$lint$unusedVariables_ts$provider, undefined);
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/lint/index.ts
const ___R$project$rome$$romejs$js$compiler$transforms$lint$index_ts$lintTransforms = [
    ___R$project$rome$$romejs$js$compiler$transforms$lint$defaultExportSameBasename_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$noMultipleSpacesInRegularExpressionLiterals_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$noVar_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$emptyBlocks_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$getterReturn_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$noAsyncPromiseExecutor_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$noCompareNegZero_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$noCondAssign_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$noDebugger_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$noDeleteVars_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$noDupeArgs_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$noDuplicateCase_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$noDuplicateKeys_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$noEmptyCharacterClass_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$noExplicitAny_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$noExtraBooleanCast_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$noFunctionAssign_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$noImportAssign_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$noLabelVar_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$noShadowRestrictedNames_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$noTemplateCurlyInString_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$noUnsafeFinally_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$preferFunctionDeclarations_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$preferTemplate_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$sparseArray_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$undeclaredVariables_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$unsafeNegation_ts$default,
    ___R$project$rome$$romejs$js$compiler$transforms$lint$unusedVariables_ts$default,
  ];

  // project-rome/@romejs/js-generator/generators/temp/AmbiguousFlowTypeCastExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$temp$AmbiguousFlowTypeCastExpression_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$temp$AmbiguousFlowTypeCastExpression_ts$ambiguousFlowTypeCastExpression.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-generator/generators/types/AnyKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$types$AnyKeywordTypeAnnotation_ts$default(generator) {
    generator.word('any');
  }

  // project-rome/@romejs/js-generator/generators/expressions/ArrayExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$expressions$ArrayExpression_ts$default(generator, _node) {
    const node = _node.type === 'BindingArrayPattern' ||
    _node.type ===
    'AssignmentArrayPattern'
      ? _node : ___R$project$rome$$romejs$js$ast$expressions$ArrayExpression_ts$arrayExpression.assert(_node);

    generator.multiline(
      node,
      (multiline, node) => {
        const elems = node.elements;

        generator.token('[');
        generator.printInnerComments(node);

        generator.printCommaList(
          elems,
          node,
          {
            multiline,
            trailing: true,
          },
        );

        if ((node.type === 'BindingArrayPattern' ||
        node.type ===
        'AssignmentArrayPattern') &&
          node.rest !== undefined) {
          if (elems.length > 0) {
            generator.token(',');
            generator.spaceOrNewline(multiline);
          }

          generator.token('...');
          generator.print(node.rest, node);
        }

        if (multiline) {
          generator.buf.removeTrailingNewlines();
          generator.forceNewline();
        }

        generator.token(']');
      },
      {conditions: ['more-than-one-line', 'source-had-multiline']},
    );
  }

  // project-rome/@romejs/js-generator/generators/expressions/ArrowFunctionExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$expressions$ArrowFunctionExpression_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$expressions$ArrowFunctionExpression_ts$arrowFunctionExpression.assert(node);

    if (node.head.async === true) {
      generator.word('async');
      generator.space();
    }

    generator.print(node.head, node);

    generator.space();
    generator.token('=>');
    generator.space();

    const {body} = node;
    if (body.type === 'BlockStatement') {
      generator.print(body, node);
    } else {
      generator.multiline(
        node,
        (multiline) => {
          if (multiline) {
            generator.newline();
            generator.indent();
          }

          generator.print(body, node);

          if (multiline) {
            generator.dedent();
          }
        },
        {conditions: ['more-than-one-line']},
      );
    }
  }

  // project-rome/@romejs/js-generator/generators/patterns/AssignmentArrayPattern.ts
function ___R$project$rome$$romejs$js$generator$generators$patterns$AssignmentArrayPattern_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$patterns$AssignmentArrayPattern_ts$assignmentArrayPattern.assert(node);

    ___R$project$rome$$romejs$js$generator$generators$expressions$ArrayExpression_ts$default(generator, node);
  }

  // project-rome/@romejs/js-generator/generators/patterns/AssignmentAssignmentPattern.ts
function ___R$project$rome$$romejs$js$generator$generators$patterns$AssignmentAssignmentPattern_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$patterns$AssignmentAssignmentPattern_ts$assignmentAssignmentPattern.assert(node);

    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-generator/node/parentheses.ts
const ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$PRECEDENCE = {
    '||': 0,
    '&&': 1,
    '??': 1,
    '|': 2,
    '^': 3,
    '&': 4,
    '==': 5,
    '===': 5,
    '!=': 5,
    '!==': 5,
    '<': 6,
    '>': 6,
    '<=': 6,
    '>=': 6,
    in: 6,
    instanceof: 6,
    '>>': 7,
    '<<': 7,
    '>>>': 7,
    '+': 8,
    '-': 8,
    '*': 9,
    '/': 9,
    '%': 9,
    '**': 10,
  };

  function ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$isClassExtendsClause(node, parent) {
    return (
      (parent.type === 'ClassDeclaration' || parent.type === 'ClassExpression') &&
        parent.meta.superClass === node
    );
  }

  const ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens = new Map();
  const ___R$project$rome$$romejs$js$generator$node$parentheses_ts$default = ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens;
  ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens.set(
    'TSAsExpression',
    () => {
      return true;
    },
  );

  ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens.set(
    'TSTypeAssertion',
    () => {
      return true;
    },
  );

  ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens.set(
    'FlowNullableTypeAnnotation',
    (
      node,
      parent,
    ) => {
      return parent.type === 'FlowArrayTypeAnnotation';
    },
  );

  ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens.set(
    'MemberExpression',
    function UpdateExpression(
      node,
      parent,
    ) {
      if (node.property.optional) {
        return (
          parent.type === 'CallExpression' && parent.callee === node ||
          parent.type === 'MemberExpression' && parent.object === node
        );
      } else {
        return false;
      }
    },
  );

  ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens.set(
    'UpdateExpression',
    function UpdateExpression(
      node,
      parent,
    ) {
      return (
        // (foo++).test(), (foo++)[0]
        parent.type === 'MemberExpression' && parent.object === node ||
        // (foo++)()
        parent.type === 'CallExpression' && parent.callee === node ||
        // new (foo++)()
        parent.type === 'NewExpression' && parent.callee === node ||
        ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$isClassExtendsClause(node, parent)
      );
    },
  );

  ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens.set(
    'ObjectExpression',
    function ObjectExpression(
      node,
      parent,
      printStack,
    ) {
      return ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$isFirstInStatement(printStack, {considerArrow: true});
    },
  );

  ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens.set(
    'DoExpression',
    function DoExpression(
      node,
      parent,
      printStack,
    ) {
      return ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$isFirstInStatement(printStack);
    },
  );

  function ___R$project$rome$$romejs$js$ast$index_ts$LogicalExpression(
    node,
    parent,
  ) {
    if (node.operator === '**' && parent.type === 'BinaryExpression' &&
      parent.operator === '**') {
      return parent.left === node;
    }

    if (___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$isClassExtendsClause(node, parent)) {
      return true;
    }

    if ((parent.type === 'CallExpression' || parent.type === 'NewExpression') &&
      parent.callee === node ||
    ___R$project$rome$$romejs$js$ast$utils$isUnaryLike_ts$default(parent) ||
    parent.type ===
    'MemberExpression' &&
      parent.object === node ||
    parent.type ===
    'AwaitExpression') {
      return true;
    }

    if (___R$project$rome$$romejs$js$ast$utils$isBinary_ts$default(parent)) {
      const parentOp = parent.operator;
      const parentPos = ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$PRECEDENCE[parentOp];

      const nodeOp = node.operator;
      const nodePos = ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$PRECEDENCE[nodeOp];

      if ( // Logical expressions with the same precedence don't need parens.
      parentPos === nodePos && parent.right === node &&
        parent.type !==
        'LogicalExpression' ||
      parentPos > nodePos) {
        return true;
      }
    }

    switch (node.operator) {
      case '||':
        if (parent.type === 'LogicalExpression') {
          return parent.operator === '??' || parent.operator === '&&';
        } else {
          return false;
        }

      case '&&':
        return parent.type === 'LogicalExpression' && parent.operator === '??';

      case '??':
        return parent.type === 'LogicalExpression' && parent.operator !== '??';

      default:
        return false;
    }
  }

  ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens.set('LogicalExpression', ___R$project$rome$$romejs$js$ast$index_ts$LogicalExpression);

  ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens.set(
    'BinaryExpression',
    function BinaryExpression(
      node,
      parent,
    ) {
      // let i = (1 in []);

      // for ((1 in []);;);
      return (
        node.operator === 'in' &&
          (parent.type === 'VariableDeclarator' ||
          ___R$project$rome$$romejs$js$ast$utils$isFor_ts$default(parent)) ||
        ___R$project$rome$$romejs$js$ast$index_ts$LogicalExpression(node, parent)
      );
    },
  );

  ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens.set(
    'SequenceExpression',
    function SequenceExpression(
      node,
      parent,
    ) {
      if ( // Although parentheses wouldn"t hurt around sequence

      // expressions in the head of for loops, traditional style

      // dictates that e.g. i++, j++ should not be wrapped with

      // parentheses.
      parent.type === 'ForStatement' || parent.type === 'ThrowStatement' ||
      parent.type === 'ReturnStatement' ||
      parent.type === 'IfStatement' &&
        parent.test === node ||
      parent.type === 'WhileStatement' &&
        parent.test ===
        node ||
      parent.type === 'ForInStatement' && parent.right === node ||
      parent.type === 'SwitchStatement' && parent.discriminant === node ||
      parent.type === 'ExpressionStatement' && parent.expression === node) {
        return false;
      }

      // Otherwise err on the side of overparenthesization, adding

      // explicit exceptions above if this proves overzealous.
      return true;
    },
  );

  function ___R$project$rome$$romejs$js$ast$index_ts$YieldExpression(node, parent) {
    return (
      ___R$project$rome$$romejs$js$ast$utils$isBinary_ts$default(parent) || ___R$project$rome$$romejs$js$ast$utils$isUnaryLike_ts$default(parent) ||
      parent.type ===
      'MemberExpression' ||
      parent.type === 'CallExpression' &&
        parent.callee ===
        node ||
      parent.type === 'NewExpression' && parent.callee === node ||
      parent.type === 'AwaitExpression' && node.type === 'YieldExpression' ||
      parent.type === 'ConditionalExpression' && node === parent.test ||
      ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$isClassExtendsClause(node, parent)
    );
  }

  ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens.set('YieldExpression', ___R$project$rome$$romejs$js$ast$index_ts$YieldExpression);
  ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens.set('AwaitExpression', ___R$project$rome$$romejs$js$ast$index_ts$YieldExpression);

  ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens.set(
    'OptionalCallExpression',
    function OptionalCallExpression(
      node,
      parent,
    ) {
      return (
        parent.type === 'CallExpression' && parent.callee === node ||
        parent.type === 'MemberExpression' && parent.object === node
      );
    },
  );

  ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens.set(
    'ClassExpression',
    function ClassExpression(
      node,
      parent,
      printStack,
    ) {
      return ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$isFirstInStatement(printStack, {considerDefaultExports: true});
    },
  );

  function ___R$project$rome$$romejs$js$ast$index_ts$UnaryExpression(
    node,

    parent,
  ) {
    return (
      parent.type === 'MemberExpression' && parent.object === node ||
      parent.type === 'CallExpression' && parent.callee === node ||
      parent.type ===
      'NewExpression' &&
        parent.callee === node ||
      parent.type === 'BinaryExpression' && parent.operator === '**' &&
        parent.left === node ||
      ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$isClassExtendsClause(node, parent)
    );
  }

  ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens.set('UnaryExpression', ___R$project$rome$$romejs$js$ast$index_ts$UnaryExpression);
  ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens.set('SpreadElement', ___R$project$rome$$romejs$js$ast$index_ts$UnaryExpression);
  ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens.set('SpreadProperty', ___R$project$rome$$romejs$js$ast$index_ts$UnaryExpression);

  ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens.set(
    'FunctionExpression',
    function FunctionExpression(
      node,
      parent,
      printStack,
    ) {
      return ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$isFirstInStatement(printStack, {considerDefaultExports: true});
    },
  );

  ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens.set(
    'ArrowFunctionExpression',
    function ArrowFunctionExpression(
      node,
      parent,
    ) {
      return (
        parent.type === 'ExportLocalDeclaration' ||
        ___R$project$rome$$romejs$js$ast$index_ts$ConditionalExpression(
          node,
          parent,
        )
      );
    },
  );

  function ___R$project$rome$$romejs$js$ast$index_ts$ConditionalExpression(
    node,
    parent,
  ) {
    if (___R$project$rome$$romejs$js$ast$utils$isUnaryLike_ts$default(parent) || ___R$project$rome$$romejs$js$ast$utils$isBinary_ts$default(parent) ||
    parent.type ===
    'ConditionalExpression' &&
      parent.test === node ||
    parent.type ===
    'AwaitExpression' ||
    parent.type === 'MemberExpression' &&
      parent.object ===
      node &&
      parent.property.optional ||
    parent.type === 'OptionalCallExpression' && parent.callee === node ||
    parent.type === 'TaggedTemplateExpression' ||
    parent.type === 'TSTypeAssertion' ||
    parent.type === 'TSAsExpression') {
      return true;
    }

    return ___R$project$rome$$romejs$js$ast$index_ts$UnaryExpression(node, parent);
  }

  ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens.set('ConditionalExpression', ___R$project$rome$$romejs$js$ast$index_ts$ConditionalExpression);

  ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens.set(
    'AssignmentExpression',
    function AssignmentExpression(
      node,
      parent,
    ) {
      if (node.left.type === 'AssignmentObjectPattern') {
        return true;
      } else {
        return ___R$project$rome$$romejs$js$ast$index_ts$ConditionalExpression(node, parent);
      }
    },
  );

  function ___R$project$rome$$romejs$js$ast$index_ts$UnionTypeAnnotation(node, parent) {
    return (
      parent.type === 'FlowArrayTypeAnnotation' ||
      parent.type ===
      'FlowNullableTypeAnnotation' ||
      parent.type === 'IntersectionTypeAnnotation' ||
      parent.type === 'UnionTypeAnnotation' ||
      parent.type === 'TSArrayType' ||
      parent.type === 'TSOptionalType'
    );
  }

  ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens.set('UnionTypeAnnotation', ___R$project$rome$$romejs$js$ast$index_ts$UnionTypeAnnotation);
  ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens.set('IntersectionTypeAnnotation', ___R$project$rome$$romejs$js$ast$index_ts$UnionTypeAnnotation);

  ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens.set(
    'TSInferType',
    function TSInferType(
      node,
      parent,
    ) {
      return parent.type === 'TSArrayType' || parent.type === 'TSOptionalType';
    },
  );

  ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$parens.set(
    'FlowFunctionTypeAnnotation',
    function FlowFunctionTypeAnnotation(
      node,
      parent,
      printStack,
    ) {
      // Check if we are the return type of an arrow
      for (const printNode of printStack) {
        if (printNode.type === 'ArrowFunctionExpression' &&
          printNode.head.returnType === node) {
          return true;
        }
      }

      // ((a: () => A) => (a: A) => A)
      if (node.returnType !== undefined &&
        node.returnType.type ===
        'FlowFunctionTypeAnnotation') {
        return true;
      }

      return (
        // (() => A) | (() => B)
        parent.type === 'UnionTypeAnnotation' ||
        // (() => A) & (() => B)
        parent.type === 'IntersectionTypeAnnotation' ||
        // (() => A)[]
        parent.type === 'FlowArrayTypeAnnotation'
      );
    },
  );

  // Walk up the print stack to deterimine if our node can come first

  // in statement.
  function ___R$$priv$project$rome$$romejs$js$generator$node$parentheses_ts$isFirstInStatement(
    printStack,
    {considerArrow = false, considerDefaultExports = false} = {},
  ) {
    let i = printStack.length - 1;
    let node = printStack[i];
    i--;
    let parent = printStack[i];
    while (i > 0) {
      if (parent.type === 'ExpressionStatement' && parent.expression === node ||
      parent.type === 'TaggedTemplateExpression' ||
      considerDefaultExports &&
        parent.type === 'ExportDefaultDeclaration' &&
        parent.declaration === node ||
      considerArrow && parent.type === 'ArrowFunctionExpression' &&
        parent.body === node) {
        return true;
      }

      if (parent.type === 'CallExpression' && parent.callee === node ||
      parent.type === 'SequenceExpression' && parent.expressions[0] === node ||
      parent.type === 'MemberExpression' && parent.object === node ||
      ___R$project$rome$$romejs$js$ast$utils$isConditional_ts$default(parent) && parent.test === node ||
      ___R$project$rome$$romejs$js$ast$utils$isBinary_ts$default(parent) &&
        parent.left === node ||
      parent.type === 'AssignmentExpression' &&
        parent.left === node) {
        node = parent;
        i--;
        parent = printStack[i];
      } else {
        return false;
      }
    }

    return false;
  }

  // project-rome/@romejs/js-generator/node/index.ts
const ___R$project$rome$$romejs$js$generator$node$index_ts = {
    hasExtraLineBetween: ___R$project$rome$$romejs$js$generator$node$index_ts$hasExtraLineBetween,
    getLinesBetween: ___R$project$rome$$romejs$js$generator$node$index_ts$getLinesBetween,
    isMultiLine: ___R$project$rome$$romejs$js$generator$node$index_ts$isMultiLine,
    needsParens: ___R$project$rome$$romejs$js$generator$node$index_ts$needsParens,
  };
  function ___R$$priv$project$rome$$romejs$js$generator$node$index_ts$isOrHasCallExpression(node) {
    if (node.type === 'CallExpression') {
      return true;
    }

    if (node.type === 'ComputedMemberProperty') {
      return ___R$$priv$project$rome$$romejs$js$generator$node$index_ts$isOrHasCallExpression(node.value);
    }

    if (node.type === 'MemberExpression') {
      return (
        ___R$$priv$project$rome$$romejs$js$generator$node$index_ts$isOrHasCallExpression(node.object) ||
        ___R$$priv$project$rome$$romejs$js$generator$node$index_ts$isOrHasCallExpression(
          node.property,
        )
      );
    }

    return false;
  }

  const ___R$$priv$project$rome$$romejs$js$generator$node$index_ts$EXTRA_LINE_DECLARATION_DENYLIST = new Set(
    [
      'VariableDeclarationStatement',
      'ImportDeclaration',
      'ExportExternalDeclaration',
      'TSDeclareFunction',
    ],
  );

  const ___R$$priv$project$rome$$romejs$js$generator$node$index_ts$EXTRA_LINE_ALLOWLIST = new Set(
    [
      'ObjectMethod',
      'ClassMethod',
    ],
  );

  function ___R$$priv$project$rome$$romejs$js$generator$node$index_ts$orderLoc(
    a,
    b,
  ) {
    if (___R$project$rome$$romejs$ob1$index_ts$get0(a.end.index) < ___R$project$rome$$romejs$ob1$index_ts$get0(b.start.index)) {
      return [a, b];
    } else {
      return [b, a];
    }
  }

  function ___R$project$rome$$romejs$js$generator$node$index_ts$hasExtraLineBetween(node) {
    if (node.type === 'ExportLocalDeclaration' && node.declaration !== undefined) {
      return ___R$project$rome$$romejs$js$generator$node$index_ts$hasExtraLineBetween(node.declaration);
    }

    if (___R$project$rome$$romejs$js$ast$utils$isDeclaration_ts$default(node) && !___R$$priv$project$rome$$romejs$js$generator$node$index_ts$EXTRA_LINE_DECLARATION_DENYLIST.has(node.type)) {
      return true;
    }

    if (___R$$priv$project$rome$$romejs$js$generator$node$index_ts$EXTRA_LINE_ALLOWLIST.has(node.type)) {
      return true;
    }

    return false;
  }

  function ___R$project$rome$$romejs$js$generator$node$index_ts$getLinesBetween(
    aNode,
    bNode,
  ) {
    if (aNode !== undefined && bNode !== undefined && aNode.loc !== undefined &&
      bNode.loc !== undefined) {
      const [a, b] = ___R$$priv$project$rome$$romejs$js$generator$node$index_ts$orderLoc(aNode.loc, bNode.loc);
      const lines = [];
      for (let line = ___R$project$rome$$romejs$ob1$index_ts$get1(a.end.line);
      line < ___R$project$rome$$romejs$ob1$index_ts$get1(b.start.line);
      line++) {
        lines.push(___R$project$rome$$romejs$ob1$index_ts$coerce1(line));
      }
      return lines;
    } else {
      return [];
    }
  }

  function ___R$project$rome$$romejs$js$generator$node$index_ts$isMultiLine(node) {
    if (node !== undefined && node.loc !== undefined) {
      return node.loc.end.line > node.loc.start.line;
    } else {
      return true;
    }
  }

  function ___R$project$rome$$romejs$js$generator$node$index_ts$needsParens(
    node,
    parent,
    printStack,
  ) {
    if (!parent) {
      return false;
    }

    if (parent.type === 'NewExpression' && parent.callee === node) {
      if (___R$$priv$project$rome$$romejs$js$generator$node$index_ts$isOrHasCallExpression(node)) {
        return true;
      }
    }

    const fn = ___R$project$rome$$romejs$js$generator$node$parentheses_ts$default.get(node.type);
    return fn ? fn(node, parent, printStack) : undefined;
  }

  // project-rome/@romejs/js-generator/generators/expressions/AssignmentExpression.ts
const ___R$$priv$project$rome$$romejs$js$generator$generators$expressions$AssignmentExpression_ts$INDENT_OPERATORS = new Set(
    [
      '&&',
      '=',
      '-=',
      '+=',
      '/=',
      '*=',
    ],
  );

  function ___R$project$rome$$romejs$js$generator$generators$expressions$AssignmentExpression_ts$default(
    generator,
    _node,
    parent,
  ) {
    const node = _node.type === 'BinaryExpression' ||
    _node.type ===
    'LogicalExpression'
      ? _node : ___R$project$rome$$romejs$js$ast$expressions$AssignmentExpression_ts$assignmentExpression.assert(_node);

    // Somewhere inside a for statement `init` node but doesn't usually

    // needs a paren except for `in` expressions: `for (a in b ? a : b;;)`
    const needsExtraParens = generator.inForStatementInitCounter > 0 &&
      node.operator === 'in' &&
      !___R$project$rome$$romejs$js$generator$node$index_ts.needsParens(node, parent, []);

    if (needsExtraParens) {
      generator.token('(');
    }

    generator.multiline(
      node,
      (multiline, node) => {
        const shouldIndent = multiline && ___R$$priv$project$rome$$romejs$js$generator$generators$expressions$AssignmentExpression_ts$INDENT_OPERATORS.has(node.operator);

        generator.print(node.left, node);

        generator.space();
        if (node.operator === 'in' || node.operator === 'instanceof') {
          generator.word(node.operator);
        } else {
          generator.token(node.operator);
        }

        generator.spaceOrNewline(multiline);

        if (shouldIndent) {
          generator.indent();
        }

        generator.print(node.right, node);

        if (shouldIndent) {
          generator.dedent();
        }
      },
      {conditions: ['any-line-exceeds']},
    );

    if (needsExtraParens) {
      generator.token(')');
    }
  }

  // project-rome/@romejs/js-generator/generators/auxiliary/Identifier.ts
function ___R$project$rome$$romejs$js$generator$generators$auxiliary$Identifier_ts$default(generator, node) {
    node =
      node.type === 'ReferenceIdentifier' || node.type === 'BindingIdentifier' ||
      node.type === 'AssignmentIdentifier'
        ? node : ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.assert(node);

    generator.word(node.name);
  }

  // project-rome/@romejs/js-generator/generators/patterns/AssignmentIdentifier.ts
function ___R$project$rome$$romejs$js$generator$generators$patterns$AssignmentIdentifier_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$patterns$AssignmentIdentifier_ts$assignmentIdentifier.assert(node);

    ___R$project$rome$$romejs$js$generator$generators$auxiliary$Identifier_ts$default(generator, node);
  }

  // project-rome/@romejs/js-generator/generators/objects/ObjectExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$objects$ObjectExpression_ts$default(generator, _node) {
    const node = _node.type === 'BindingObjectPattern' ||
    _node.type ===
    'AssignmentObjectPattern'
      ? _node : ___R$project$rome$$romejs$js$ast$objects$ObjectExpression_ts$objectExpression.assert(_node);

    generator.multiline(
      node,
      (multiline, node) => {
        const props = node.properties;

        generator.token('{');
        generator.printInnerComments(node);
        generator.printCommaList(
          props,
          node,
          {
            multiline,
            trailing: true,
          },
        );

        if ((node.type === 'BindingObjectPattern' ||
        node.type ===
        'AssignmentObjectPattern') &&
          node.rest !== undefined) {
          if (props.length > 0) {
            if (!multiline) {
              generator.token(',');
            }
            generator.spaceOrNewline(multiline);
          }

          generator.token('...');
          generator.print(node.rest, node);
        }

        if (multiline) {
          generator.buf.removeTrailingNewlines();
          generator.forceNewline();
        }

        generator.token('}');
      },
      {conditions: ['more-than-one-line', 'source-had-multiline']},
    );
  }

  // project-rome/@romejs/js-generator/generators/patterns/AssignmentObjectPattern.ts
function ___R$project$rome$$romejs$js$generator$generators$patterns$AssignmentObjectPattern_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$patterns$AssignmentObjectPattern_ts$assignmentObjectPattern.assert(node);

    ___R$project$rome$$romejs$js$generator$generators$objects$ObjectExpression_ts$default(generator, node);
  }

  // project-rome/@romejs/js-generator/generators/objects/ObjectProperty.ts
function ___R$$priv$project$rome$$romejs$js$generator$generators$objects$ObjectProperty_ts$isShorthand(key, value) {
    return (
      key.type === 'StaticPropertyKey' && key.value.type === 'Identifier' &&
        (value.type === 'ReferenceIdentifier' || value.type === 'BindingIdentifier' ||
        value.type === 'AssignmentIdentifier') &&
        value.name === key.value.name
    );
  }

  function ___R$project$rome$$romejs$js$generator$generators$objects$ObjectProperty_ts$default(generator, node) {
    node =
      node.type === 'BindingObjectPatternProperty' ||
      node.type ===
      'AssignmentObjectPatternProperty'
        ? node : ___R$project$rome$$romejs$js$ast$objects$ObjectProperty_ts$objectProperty.assert(node);

    generator.print(node.key, node);

    if ((node.value.type === 'BindingAssignmentPattern' ||
    node.value.type ===
    'AssignmentAssignmentPattern') &&
      ___R$$priv$project$rome$$romejs$js$generator$generators$objects$ObjectProperty_ts$isShorthand(node.key, node.value.left)) {
      generator.space();
      generator.token('=');
      generator.space();
      generator.print(node.value.right, node.value);
    } else if (!___R$$priv$project$rome$$romejs$js$generator$generators$objects$ObjectProperty_ts$isShorthand(node.key, node.value)) {
      generator.token(':');
      generator.space();
      generator.print(node.value, node);
    }
  }

  // project-rome/@romejs/js-generator/generators/patterns/AssignmentObjectPatternProperty.ts
function ___R$project$rome$$romejs$js$generator$generators$patterns$AssignmentObjectPatternProperty_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$patterns$AssignmentObjectPatternProperty_ts$assignmentObjectPatternProperty.assert(node);
    ___R$project$rome$$romejs$js$generator$generators$objects$ObjectProperty_ts$default(generator, node);
  }

  // project-rome/@romejs/js-generator/generators/utils.ts
function ___R$project$rome$$romejs$js$generator$generators$utils_ts$buildForXStatementGenerator(op) {
    return (
      function(generator, node) {
        node = node.type === 'ForInStatement' ? node : ___R$project$rome$$romejs$js$ast$statements$ForOfStatement_ts$forOfStatement.assert(node);

        generator.word('for');
        generator.space();
        if (op === 'of' && node.type === 'ForOfStatement' && node.await === true) {
          generator.word('await');
          generator.space();
        }
        generator.token('(');
        generator.print(node.left, node);
        generator.space();
        generator.word(op);
        generator.space();
        generator.print(node.right, node);
        generator.token(')');
        generator.printBlock(node);
      }
    );
  }

  function ___R$project$rome$$romejs$js$generator$generators$utils_ts$buildYieldAwaitGenerator(keyword) {
    return (
      function(generator, node) {
        node = node.type === 'YieldExpression' ? node : ___R$project$rome$$romejs$js$ast$expressions$AwaitExpression_ts$awaitExpression.assert(node);

        generator.word(keyword);

        if (node.type === 'YieldExpression' && node.delegate === true) {
          generator.token('*');
        }

        if (node.argument) {
          generator.space();
          const terminatorState = generator.startTerminatorless();
          generator.print(node.argument, node);
          generator.endTerminatorless(terminatorState);
        }
      }
    );
  }

  function ___R$project$rome$$romejs$js$generator$generators$utils_ts$buildLabelStatementGenerator(prefix) {
    return (
      function(generator, node) {
        node =
          node.type === 'ContinueStatement' || node.type === 'ReturnStatement' ||
          node.type === 'BreakStatement'
            ? node : ___R$project$rome$$romejs$js$ast$statements$ThrowStatement_ts$throwStatement.assert(node);

        generator.word(prefix);

        if ((node.type === 'ContinueStatement' || node.type === 'BreakStatement') &&
          node.label !== undefined) {
          generator.space();
          generator.print(node.label, node);
        }

        if ((node.type === 'ThrowStatement' || node.type === 'ReturnStatement') &&
          node.argument !== undefined) {
          generator.space();

          generator.multiline(
            node,
            (multiline, node) => {
              const terminatorState = generator.startTerminatorless();
              if (multiline) {
                generator.forceNewline();
              }
              generator.print(node.argument, node);
              generator.endTerminatorless(terminatorState);
            },
          );
        }

        generator.semicolon();
      }
    );
  }

  function ___R$project$rome$$romejs$js$generator$generators$utils_ts$printMethod(
    generator,
    node,
  ) {
    const kind = node.kind;

    if (kind === 'method' && node.head.generator === true) {
      generator.token('*');
    }

    if (kind === 'get' || kind === 'set') {
      generator.word(kind);
      generator.space();
    }

    if (node.head.async === true) {
      generator.word('async');
      generator.space();
    }

    if (node.type === 'TSDeclareMethod') {
      generator.print(node.head, node);
      return;
    }

    generator.print(node.key, node);
    generator.print(node.head, node);
    generator.space();
    generator.print(node.body, node);
  }

  function ___R$project$rome$$romejs$js$generator$generators$utils_ts$tokenIfPlusMinus(generator, token) {
    if (token !== true) {
      generator.token(token);
    }
  }

  function ___R$project$rome$$romejs$js$generator$generators$utils_ts$printBindingPatternParams(
    generator,
    node,
    params,
    rest,
    multiline = false,
  ) {
    generator.printCommaList(
      params,
      node,
      {
        trailing: true,
        multiline,
      },
    );

    if (rest !== undefined) {
      if (params.length > 0) {
        if (!multiline) {
          generator.token(',');
        }
        generator.spaceOrNewline(multiline);
      }

      generator.token('...');
      generator.print(rest, node);
    }
  }

  function ___R$project$rome$$romejs$js$generator$generators$utils_ts$printTSBraced(
    generator,
    node,
    members,
  ) {
    generator.token('{');

    if (members.length > 0) {
      const multiline = members.length > 1;

      generator.indent();

      if (multiline) {
        generator.newline();
      }

      for (const member of members) {
        generator.print(member, node);

        if (multiline) {
          generator.newline();
        } else {
          generator.buf.removeTrailing(';');
        }
      }

      generator.dedent();
      generator.rightBrace();
    } else {
      generator.token('}');
    }
  }

  function ___R$project$rome$$romejs$js$generator$generators$utils_ts$printPatternMeta(
    generator,
    node,
    meta,
  ) {
    if (generator.options.typeAnnotations && meta !== undefined) {
      if (meta.optional) {
        generator.token('?');
      }
      generator.printTypeColon(meta.typeAnnotation, node);
    }
  }

  // project-rome/@romejs/js-generator/generators/expressions/AwaitExpression.ts
const ___R$project$rome$$romejs$js$generator$generators$expressions$AwaitExpression_ts$default = ___R$project$rome$$romejs$js$generator$generators$utils_ts$buildYieldAwaitGenerator('await');

  // project-rome/@romejs/js-generator/generators/types/BigIntKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$types$BigIntKeywordTypeAnnotation_ts$default(generator) {
    generator.word('bigint');
  }

  // project-rome/@romejs/js-generator/generators/literals/BigIntLiteral.ts
function ___R$project$rome$$romejs$js$generator$generators$literals$BigIntLiteral_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$literals$BigIntLiteral_ts$bigIntLiteral.assert(node);

    generator.word(node.value +
    'n');
  }

  // project-rome/@romejs/js-generator/generators/expressions/BinaryExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$expressions$BinaryExpression_ts$default(
    generator,
    node,
    parent,
  ) {
    node = ___R$project$rome$$romejs$js$ast$expressions$BinaryExpression_ts$binaryExpression.assert(node);
    ___R$project$rome$$romejs$js$generator$generators$expressions$AssignmentExpression_ts$default(generator, node, parent);
  }

  // project-rome/@romejs/js-generator/generators/patterns/BindingArrayPattern.ts
function ___R$project$rome$$romejs$js$generator$generators$patterns$BindingArrayPattern_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$patterns$BindingArrayPattern_ts$bindingArrayPattern.assert(node);

    ___R$project$rome$$romejs$js$generator$generators$expressions$ArrayExpression_ts$default(generator, node);
    ___R$project$rome$$romejs$js$generator$generators$utils_ts$printPatternMeta(generator, node, node.meta);
  }

  // project-rome/@romejs/js-generator/generators/patterns/BindingAssignmentPattern.ts
function ___R$project$rome$$romejs$js$generator$generators$patterns$BindingAssignmentPattern_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$patterns$BindingAssignmentPattern_ts$bindingAssignmentPattern.assert(node);

    generator.print(node.left, node);
    generator.space();
    generator.token('=');
    generator.space();
    generator.print(node.right, node);
  }

  // project-rome/@romejs/js-generator/generators/patterns/BindingIdentifier.ts
function ___R$project$rome$$romejs$js$generator$generators$patterns$BindingIdentifier_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.assert(node);

    if (node.name[0] === '*') {
      // Internal name
      return;
    }

    ___R$project$rome$$romejs$js$generator$generators$auxiliary$Identifier_ts$default(generator, node);
    ___R$project$rome$$romejs$js$generator$generators$utils_ts$printPatternMeta(generator, node, node.meta);
  }

  // project-rome/@romejs/js-generator/generators/patterns/BindingObjectPattern.ts
function ___R$project$rome$$romejs$js$generator$generators$patterns$BindingObjectPattern_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$patterns$BindingObjectPattern_ts$bindingObjectPattern.assert(node);

    ___R$project$rome$$romejs$js$generator$generators$objects$ObjectExpression_ts$default(generator, node);
    ___R$project$rome$$romejs$js$generator$generators$utils_ts$printPatternMeta(generator, node, node.meta);
  }

  // project-rome/@romejs/js-generator/generators/patterns/BindingObjectPatternProperty.ts
function ___R$project$rome$$romejs$js$generator$generators$patterns$BindingObjectPatternProperty_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$patterns$BindingObjectPatternProperty_ts$bindingObjectPatternProperty.assert(node);
    ___R$project$rome$$romejs$js$generator$generators$objects$ObjectProperty_ts$default(generator, node);
  }

  // project-rome/@romejs/js-generator/generators/statements/BlockStatement.ts
function ___R$project$rome$$romejs$js$generator$generators$statements$BlockStatement_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts$blockStatement.assert(node);

    generator.token('{');
    generator.printInnerComments(node);

    const hasDirectives = Boolean(
      node.directives &&
        node.directives.length > 0,
    );

    if (node.body.length > 0 || hasDirectives) {
      generator.forceNewline();

      generator.printStatementList(node.directives, node, {indent: true});
      if (hasDirectives) {
        generator.forceNewline();
      }

      generator.printStatementList(node.body, node, {indent: true});

      generator.source('end', node.loc);

      generator.buf.removeTrailingNewlines();
      generator.forceNewline();

      generator.rightBrace();
    } else {
      generator.source('end', node.loc);
      generator.token('}');
    }
  }

  // project-rome/@romejs/js-generator/generators/types/BooleanKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$types$BooleanKeywordTypeAnnotation_ts$default(generator) {
    generator.word('boolean');
  }

  // project-rome/@romejs/js-generator/generators/literals/BooleanLiteral.ts
function ___R$project$rome$$romejs$js$generator$generators$literals$BooleanLiteral_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$literals$BooleanLiteral_ts$booleanLiteral.assert(node);
    generator.word(node.value ? 'true' : 'false');
  }

  // project-rome/@romejs/js-generator/generators/types/BooleanLiteralTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$types$BooleanLiteralTypeAnnotation_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$types$BooleanLiteralTypeAnnotation_ts$booleanLiteralTypeAnnotation.assert(node);
    generator.word(node.value ? 'true' : 'false');
  }

  // project-rome/@romejs/js-generator/generators/statements/BreakStatement.ts
const ___R$project$rome$$romejs$js$generator$generators$statements$BreakStatement_ts$default = ___R$project$rome$$romejs$js$generator$generators$utils_ts$buildLabelStatementGenerator('break');

  // project-rome/@romejs/js-generator/generators/expressions/CallExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$expressions$CallExpression_ts$default(generator, node) {
    node =
      node.type === 'OptionalCallExpression' || node.type === 'NewExpression'
        ? node : ___R$project$rome$$romejs$js$ast$expressions$CallExpression_ts$callExpression.assert(node);

    generator.multiline(
      node,
      (multiline, node) => {
        generator.print(node.callee, node);
        generator.print(node.typeArguments, node);

        const startLine = generator.buf.position.line;
        const startIndent = generator.currentLineIndentLevel;

        if (node.type === 'OptionalCallExpression') {
          generator.token('?');
        }

        generator.token('(');
        generator.printCommaList(
          node.arguments,
          node,
          {
            multiline,
            trailing: true,
          },
        );

        // TODO add newline if we've added a line and are on a different indentation level
        const endLine = generator.buf.position.line;
        const endIndent = generator.currentLineIndentLevel;
        if (startLine !== endLine && startIndent !== endIndent) {
          generator.newline();
        }

        generator.token(')');
      },
    );
  }

  // project-rome/@romejs/js-generator/generators/auxiliary/CatchClause.ts
function ___R$project$rome$$romejs$js$generator$generators$auxiliary$CatchClause_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$auxiliary$CatchClause_ts$catchClause.assert(node);
    ___R$project$rome$$romejs$js$ast$auxiliary$CatchClause_ts$catchClause.assert(node);
    generator.word('catch');
    generator.space();
    generator.token('(');
    generator.print(node.param, node);
    generator.token(')');
    generator.space();
    generator.print(node.body, node);
  }

  // project-rome/@romejs/js-generator/generators/classes/ClassDeclaration.ts
function ___R$project$rome$$romejs$js$generator$generators$classes$ClassDeclaration_ts$default(generator, node) {
    node = node.type === 'ClassExpression' ? node : ___R$project$rome$$romejs$js$ast$classes$ClassDeclaration_ts$classDeclaration.assert(node);

    generator.word('class');

    if (node.id) {
      generator.space();
      generator.print(node.id, node);
    }

    generator.print(node.meta, node);

    generator.space();

    generator.token('{');

    generator.printInnerComments(node);
    generator.printInnerComments(node.meta);

    if (node.meta.body.length === 0) {
      generator.token('}');
    } else {
      generator.forceNewline();

      generator.indent();
      generator.printStatementList(node.meta.body, node.meta);
      generator.dedent();

      generator.buf.removeTrailingNewlines();
      generator.forceNewline();

      generator.rightBrace();
    }
  }

  // project-rome/@romejs/js-generator/generators/classes/ClassExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$classes$ClassExpression_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$classes$ClassExpression_ts$classExpression.assert(node);
    ___R$project$rome$$romejs$js$generator$generators$classes$ClassDeclaration_ts$default(generator, node);
  }

  // project-rome/@romejs/js-generator/generators/classes/ClassHead.ts
function ___R$project$rome$$romejs$js$generator$generators$classes$ClassHead_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$classes$ClassHead_ts$classHead.assert(node);

    generator.print(node.typeParameters, node);

    if (node.superClass) {
      generator.space();
      generator.word('extends');
      generator.space();
      generator.print(node.superClass, node);
      generator.print(node.superTypeParameters, node);
    }

    if (node.implements !== undefined && node.implements.length > 0 &&
      generator.options.typeAnnotations) {
      generator.space();
      generator.word('implements');
      generator.space();
      generator.printCommaList(node.implements, node);
    }
  }

  // project-rome/@romejs/js-generator/generators/classes/ClassMethod.ts
function ___R$project$rome$$romejs$js$generator$generators$classes$ClassMethod_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$classes$ClassMethod_ts$classMethod.assert(node);

    if (node.meta.static === true) {
      generator.word('static');
      generator.space();
    }

    ___R$project$rome$$romejs$js$generator$generators$utils_ts$printMethod(generator, node);
    generator.forceNewline();
  }

  // project-rome/@romejs/js-generator/generators/classes/ClassPrivateMethod.ts
function ___R$project$rome$$romejs$js$generator$generators$classes$ClassPrivateMethod_ts$default() {
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-generator/generators/classes/ClassPrivateProperty.ts
function ___R$project$rome$$romejs$js$generator$generators$classes$ClassPrivateProperty_ts$default() {
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-generator/generators/classes/ClassProperty.ts
function ___R$project$rome$$romejs$js$generator$generators$classes$ClassProperty_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$classes$ClassProperty_ts$classProperty.assert(node);

    if (node.value === undefined && !generator.options.typeAnnotations) {
      // A ClassProperty with no value is a type annotation
      return;
    }

    generator.print(node.meta, node);

    generator.print(node.key, node);
    generator.printTypeColon(node.typeAnnotation, node);

    if (node.value) {
      generator.space();
      generator.token('=');
      generator.space();
      generator.print(node.value, node);
    }

    generator.semicolon();
  }

  // project-rome/@romejs/js-generator/generators/classes/ClassPropertyMeta.ts
function ___R$project$rome$$romejs$js$generator$generators$classes$ClassPropertyMeta_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$classes$ClassPropertyMeta_ts$classPropertyMeta.assert(node);

    if (!generator.options.typeAnnotations) {
      if (node.accessibility) {
        generator.word(node.accessibility);
      }

      if (node.readonly) {
        generator.word('readonly');
      }

      if (node.abstract) {
        generator.word('abstract');
      }
    }

    if (node.static) {
      generator.word('static');
    }
  }

  // project-rome/@romejs/js-generator/generators/core/CommentBlock.ts
function ___R$project$rome$$romejs$js$generator$generators$core$CommentBlock_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$core$CommentBlock_ts$commentBlock.assert(node);
    ___R$project$rome$$romejs$js$ast$core$CommentBlock_ts$commentBlock.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-generator/generators/core/CommentLine.ts
function ___R$project$rome$$romejs$js$generator$generators$core$CommentLine_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$core$CommentLine_ts$commentLine.assert(node);
    ___R$project$rome$$romejs$js$ast$core$CommentLine_ts$commentLine.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-generator/generators/auxiliary/ComputedMemberProperty.ts
function ___R$project$rome$$romejs$js$generator$generators$auxiliary$ComputedMemberProperty_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$auxiliary$ComputedMemberProperty_ts$computedMemberProperty.assert(node);

    generator.token('[');
    generator.print(node.value, node);
    generator.token(']');
  }

  // project-rome/@romejs/js-generator/generators/objects/ComputedPropertyKey.ts
function ___R$project$rome$$romejs$js$generator$generators$objects$ComputedPropertyKey_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$objects$ComputedPropertyKey_ts$computedPropertyKey.assert(node);

    generator.token('[');
    generator.print(node.value, node);
    generator.token(']');
  }

  // project-rome/@romejs/js-generator/generators/expressions/ConditionalExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$expressions$ConditionalExpression_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$expressions$ConditionalExpression_ts$conditionalExpression.assert(node);

    generator.multiline(
      node,
      (multiline, node) => {
        generator.print(node.test, node);

        if (multiline) {
          generator.newline();
          generator.indent();
        } else {
          generator.space();
        }

        generator.token('?');
        generator.space();
        generator.print(node.consequent, node);
        generator.space();
        generator.token(':');
        generator.space();
        generator.print(node.alternate, node);

        if (multiline) {
          generator.dedent();
        }
      },
    );
  }

  // project-rome/@romejs/js-generator/generators/statements/ContinueStatement.ts
const ___R$project$rome$$romejs$js$generator$generators$statements$ContinueStatement_ts$default = ___R$project$rome$$romejs$js$generator$generators$utils_ts$buildLabelStatementGenerator('continue');

  // project-rome/@romejs/js-generator/generators/statements/DebuggerStatement.ts
function ___R$project$rome$$romejs$js$generator$generators$statements$DebuggerStatement_ts$default(generator) {
    generator.word('debugger');
    generator.semicolon();
  }

  // project-rome/@romejs/js-parser/options.ts
const ___R$$priv$project$rome$$romejs$js$parser$options_ts$DEFAULT_USER_OPTIONS = {
    // I want to kill this option very badly
    allowReturnOutsideFunction: false,

    // Source type ("template", "script" or "module") for different semantics
    sourceType: 'script',

    // Whether we should be tracking tokens when parsing this file

    // NOTE: This is memory-intensive
    tokens: false,

    syntax: [],
    manifestPath: 'package.json',
  };

  // Interpret and default an options object
  function ___R$project$rome$$romejs$js$parser$options_ts$normalizeOptions(opts) {
    return (
      Object.assign(
        {
        },
        ___R$$priv$project$rome$$romejs$js$parser$options_ts$DEFAULT_USER_OPTIONS,
        opts,
      )
    );
  }

  // project-rome/@romejs/js-parser/xhtmlEntities.ts
const ___R$project$rome$$romejs$js$parser$xhtmlEntities_ts = {
    get xhtmlEntityNameToChar() {
      return (
        ___R$project$rome$$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityNameToChar
      );
    },

    get xhtmlEntityCharToName() {
      return (
        ___R$project$rome$$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityCharToName
      );
    },

    escapeXHTMLEntities: ___R$project$rome$$romejs$js$parser$xhtmlEntities_ts$escapeXHTMLEntities,
  };
  const ___R$project$rome$$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityNameToChar = {
    quot: '"',
    amp: '&',
    apos: '\'',
    lt: '<',
    gt: '>',
    nbsp: '\xa0',
    iexcl: '\xa1',
    cent: '\xa2',
    pound: '\xa3',
    curren: '\xa4',
    yen: '\xa5',
    brvbar: '\xa6',
    sect: '\xa7',
    uml: '\xa8',
    copy: '\xa9',
    ordf: '\xaa',
    laquo: '\xab',
    not: '\xac',
    shy: '\xad',
    reg: '\xae',
    macr: '\xaf',
    deg: '\xb0',
    plusmn: '\xb1',
    sup2: '\xb2',
    sup3: '\xb3',
    acute: '\xb4',
    micro: '\xb5',
    para: '\xb6',
    middot: '\xb7',
    cedil: '\xb8',
    sup1: '\xb9',
    ordm: '\xba',
    raquo: '\xbb',
    frac14: '\xbc',
    frac12: '\xbd',
    frac34: '\xbe',
    iquest: '\xbf',
    Agrave: '\xc0',
    Aacute: '\xc1',
    Acirc: '\xc2',
    Atilde: '\xc3',
    Auml: '\xc4',
    Aring: '\xc5',
    AElig: '\xc6',
    Ccedil: '\xc7',
    Egrave: '\xc8',
    Eacute: '\xc9',
    Ecirc: '\xca',
    Euml: '\xcb',
    Igrave: '\xcc',
    Iacute: '\xcd',
    Icirc: '\xce',
    Iuml: '\xcf',
    ETH: '\xd0',
    Ntilde: '\xd1',
    Ograve: '\xd2',
    Oacute: '\xd3',
    Ocirc: '\xd4',
    Otilde: '\xd5',
    Ouml: '\xd6',
    times: '\xd7',
    Oslash: '\xd8',
    Ugrave: '\xd9',
    Uacute: '\xda',
    Ucirc: '\xdb',
    Uuml: '\xdc',
    Yacute: '\xdd',
    THORN: '\xde',
    szlig: '\xdf',
    agrave: '\xe0',
    aacute: '\xe1',
    acirc: '\xe2',
    atilde: '\xe3',
    auml: '\xe4',
    aring: '\xe5',
    aelig: '\xe6',
    ccedil: '\xe7',
    egrave: '\xe8',
    eacute: '\xe9',
    ecirc: '\xea',
    euml: '\xeb',
    igrave: '\xec',
    iacute: '\xed',
    icirc: '\xee',
    iuml: '\xef',
    eth: '\xf0',
    ntilde: '\xf1',
    ograve: '\xf2',
    oacute: '\xf3',
    ocirc: '\xf4',
    otilde: '\xf5',
    ouml: '\xf6',
    divide: '\xf7',
    oslash: '\xf8',
    ugrave: '\xf9',
    uacute: '\xfa',
    ucirc: '\xfb',
    uuml: '\xfc',
    yacute: '\xfd',
    thorn: '\xfe',
    yuml: '\xff',
    OElig: '\u0152',
    oelig: '\u0153',
    Scaron: '\u0160',
    scaron: '\u0161',
    Yuml: '\u0178',
    fnof: '\u0192',
    circ: '\u02c6',
    tilde: '\u02dc',
    Alpha: '\u0391',
    Beta: '\u0392',
    Gamma: '\u0393',
    Delta: '\u0394',
    Epsilon: '\u0395',
    Zeta: '\u0396',
    Eta: '\u0397',
    Theta: '\u0398',
    Iota: '\u0399',
    Kappa: '\u039a',
    Lambda: '\u039b',
    Mu: '\u039c',
    Nu: '\u039d',
    Xi: '\u039e',
    Omicron: '\u039f',
    Pi: '\u03a0',
    Rho: '\u03a1',
    Sigma: '\u03a3',
    Tau: '\u03a4',
    Upsilon: '\u03a5',
    Phi: '\u03a6',
    Chi: '\u03a7',
    Psi: '\u03a8',
    Omega: '\u03a9',
    alpha: '\u03b1',
    beta: '\u03b2',
    gamma: '\u03b3',
    delta: '\u03b4',
    epsilon: '\u03b5',
    zeta: '\u03b6',
    eta: '\u03b7',
    theta: '\u03b8',
    iota: '\u03b9',
    kappa: '\u03ba',
    lambda: '\u03bb',
    mu: '\u03bc',
    nu: '\u03bd',
    xi: '\u03be',
    omicron: '\u03bf',
    pi: '\u03c0',
    rho: '\u03c1',
    sigmaf: '\u03c2',
    sigma: '\u03c3',
    tau: '\u03c4',
    upsilon: '\u03c5',
    phi: '\u03c6',
    chi: '\u03c7',
    psi: '\u03c8',
    omega: '\u03c9',
    thetasym: '\u03d1',
    upsih: '\u03d2',
    piv: '\u03d6',
    ensp: '\u2002',
    emsp: '\u2003',
    thinsp: '\u2009',
    zwnj: '\u200c',
    zwj: '\u200d',
    lrm: '\u200e',
    rlm: '\u200f',
    ndash: '\u2013',
    mdash: '\u2014',
    lsquo: '\u2018',
    rsquo: '\u2019',
    sbquo: '\u201a',
    ldquo: '\u201c',
    rdquo: '\u201d',
    bdquo: '\u201e',
    dagger: '\u2020',
    Dagger: '\u2021',
    bull: '\u2022',
    hellip: '\u2026',
    permil: '\u2030',
    prime: '\u2032',
    Prime: '\u2033',
    lsaquo: '\u2039',
    rsaquo: '\u203a',
    oline: '\u203e',
    frasl: '\u2044',
    euro: '\u20ac',
    image: '\u2111',
    weierp: '\u2118',
    real: '\u211c',
    trade: '\u2122',
    alefsym: '\u2135',
    larr: '\u2190',
    uarr: '\u2191',
    rarr: '\u2192',
    darr: '\u2193',
    harr: '\u2194',
    crarr: '\u21b5',
    lArr: '\u21d0',
    uArr: '\u21d1',
    rArr: '\u21d2',
    dArr: '\u21d3',
    hArr: '\u21d4',
    forall: '\u2200',
    part: '\u2202',
    exist: '\u2203',
    empty: '\u2205',
    nabla: '\u2207',
    isin: '\u2208',
    notin: '\u2209',
    ni: '\u220b',
    prod: '\u220f',
    sum: '\u2211',
    minus: '\u2212',
    lowast: '\u2217',
    radic: '\u221a',
    prop: '\u221d',
    infin: '\u221e',
    ang: '\u2220',
    and: '\u2227',
    or: '\u2228',
    cap: '\u2229',
    cup: '\u222a',
    int: '\u222b',
    there4: '\u2234',
    sim: '\u223c',
    cong: '\u2245',
    asymp: '\u2248',
    ne: '\u2260',
    equiv: '\u2261',
    le: '\u2264',
    ge: '\u2265',
    sub: '\u2282',
    sup: '\u2283',
    nsub: '\u2284',
    sube: '\u2286',
    supe: '\u2287',
    oplus: '\u2295',
    otimes: '\u2297',
    perp: '\u22a5',
    sdot: '\u22c5',
    lceil: '\u2308',
    rceil: '\u2309',
    lfloor: '\u230a',
    rfloor: '\u230b',
    lang: '\u2329',
    rang: '\u232a',
    loz: '\u25ca',
    spades: '\u2660',
    clubs: '\u2663',
    hearts: '\u2665',
    diams: '\u2666',
  };

  const ___R$project$rome$$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityCharToName = {};
  for (const key in ___R$project$rome$$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityNameToChar) {
    ___R$project$rome$$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityCharToName[___R$project$rome$$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityNameToChar[key]] = key;
  }

  function ___R$project$rome$$romejs$js$parser$xhtmlEntities_ts$escapeXHTMLEntities(value, only) {
    let escaped = '';
    for (const char of value) {
      const entity = ___R$project$rome$$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityCharToName[char];
      if (entity !== undefined && (only === undefined || only.includes(char))) {
        escaped += '&' +
        entity +
        ';';
      } else {
        escaped += char;
      }
    }
    return escaped;
  }

  // project-rome/@romejs/js-parser/tokenizer/types.ts
// ## Token types

  // The assignment of fine-grained, information-carrying type objects

  // allows the tokenizer to store the information it has about a

  // token in a way that is very cheap for the parser to look up.

  // All token type variables start with an underscore, to make them

  // easy to recognize.

  // The `beforeExpr` property is used to disambiguate between regular

  // expressions and divisions. It is set on all token types that can

  // be followed by an expression (thus, a slash after them would be a

  // regular expression).

  //

  // `isLoop` marks a keyword as starting a loop, which is important

  // to know when parsing a label, in order to allow or disallow

  // continue jumps to that label.
  const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr = true;
  const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr = true;
  const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$isLoop = true;
  const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$isAssign = true;
  const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$prefix = true;
  const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$postfix = true;

  class ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType {
    constructor(label, conf = {}) {
      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.rightAssociative = !!conf.rightAssociative;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = typeof conf.binop === 'number' ? conf.binop : undefined;
      this.updateContext = undefined;
    }

    getBinop() {
      const {binop} = this;
      if (binop === undefined) {
        throw new Error('Token ' +
        this.label +
        ' doesn\'t have a binop');
      }
      return binop;
    }
  }

  const ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$keywords = new Map();

  class ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType extends ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType {
    constructor(name, options = {}) {
      options.keyword = name;

      super(name, options);

      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$keywords.set(name, this);
    }
  }

  class ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$BinopTokenType extends ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType {
    constructor(name, prec) {
      super(name, {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr, binop: prec});
    }
  }

  const ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types = {
    num: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('num', {startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    bigint: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('bigint', {startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    regexp: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('regexp', {startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    string: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('string', {startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    name: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('name', {startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    eof: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('eof'),
    invalid: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('invalid'),
    comment: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('comment'),

    // Punctuation token types.
    bracketL: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('[', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr, startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    bracketR: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(']'),
    braceL: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('{', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr, startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    braceBarL: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('{|', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr, startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    braceR: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('}'),
    braceBarR: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('|}'),
    parenL: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('(', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr, startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    parenR: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(')'),
    comma: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(',', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr}),
    semi: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(';', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr}),
    colon: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(':', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr}),
    doubleColon: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('::', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr}),
    dot: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('.'),
    question: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('?', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr}),
    questionDot: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('?.'),
    arrow: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('=>', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr}),
    template: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('template'),
    ellipsis: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('...', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr}),
    backQuote: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('`', {startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    dollarBraceL: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('${', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr, startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    at: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('@'),
    hash: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('#'),

    // Operators. These carry several kinds of properties to help the

    // parser use them properly (the presence of these properties is

    // what categorizes them as operators).

    //

    // `binop`, when present, specifies that this operator is a binary

    // operator, and will refer to its precedence.

    //

    // `prefix` and `postfix` mark the operator as a prefix or postfix

    // unary operator.

    //

    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as

    // binary operators with a very low precedence, that should result

    // in AssignmentExpression nodes.

    eq: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('=', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr, isAssign: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$isAssign}),
    assign: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('_=', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr, isAssign: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$isAssign}),
    incDec: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('++/--', {prefix: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$prefix, postfix: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$postfix, startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    bang: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('!', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr, prefix: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$prefix, startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    tilde: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('~', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr, prefix: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$prefix, startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    nullishCoalescing: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$BinopTokenType('??', 1),
    logicalOR: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$BinopTokenType('||', 1),
    logicalAND: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$BinopTokenType('&&', 2),
    bitwiseOR: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$BinopTokenType('|', 3),
    bitwiseXOR: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$BinopTokenType('^', 4),
    bitwiseAND: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$BinopTokenType('&', 5),
    equality: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$BinopTokenType('==/!=', 6),
    relational: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$BinopTokenType('</>', 7),
    bitShift: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$BinopTokenType('<</>>', 8),
    plusMin: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('+/-', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr, binop: 9, prefix: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$prefix, startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    modulo: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$BinopTokenType('%', 10),
    star: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$BinopTokenType('*', 10),
    slash: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$BinopTokenType('/', 10),
    exponent: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
      '**',
      {
        beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
        binop: 11,
        rightAssociative: true,
      },
    ),

    jsxName: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('jsxName'),
    jsxText: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('jsxText', {beforeExpr: true}),
    jsxTagStart: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('jsxTagStart', {startsExpr: true}),
    jsxTagEnd: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType('jsxTagEnd'),

    _break: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('break'),
    _case: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('case', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr}),
    _catch: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('catch'),
    _continue: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('continue'),
    _debugger: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('debugger'),
    _default: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('default', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr}),
    _do: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('do', {isLoop: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$isLoop, beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr}),
    _else: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('else', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr}),
    _finally: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('finally'),
    _for: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('for', {isLoop: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$isLoop}),
    _function: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('function', {startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    _if: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('if'),
    _return: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('return', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr}),
    _switch: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('switch'),
    _throw: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('throw', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr, prefix: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$prefix, startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    _try: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('try'),
    _var: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('var'),
    _const: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('const'),
    _while: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('while', {isLoop: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$isLoop}),
    _with: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('with'),
    _new: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('new', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr, startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    _this: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('this', {startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    _super: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('super', {startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    _class: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('class', {startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    _extends: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('extends', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr}),
    _export: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('export'),
    _import: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('import', {startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    _null: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('null', {startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    _true: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('true', {startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    _false: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('false', {startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    _in: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('in', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr, binop: 7}),
    _instanceof: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('instanceof', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr, binop: 7}),
    _typeof: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('typeof', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr, prefix: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$prefix, startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    _void: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('void', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr, prefix: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$prefix, startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    _delete: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('delete', {beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr, prefix: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$prefix, startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr}),
  };

  // project-rome/@romejs/js-parser/tokenizer/context.ts
class ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$TokContext {
    constructor(token, isExpr, preserveSpace, override) // Takes a Tokenizer as a parser.parameter, and returns void.
    {
      this.token = token;
      this.isExpr = !!isExpr;
      this.preserveSpace = !!preserveSpace;
      this.override = override;
    }
  }

  const ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types = {
    braceStatement: new ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$TokContext('{', false),
    braceExpression: new ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$TokContext('{', true),
    templateQuasi: new ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$TokContext('${', false),
    parenStatement: new ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$TokContext('(', false),
    parenExpression: new ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$TokContext('(', true),
    template: new ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$TokContext('`', true, true, (p) => ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$readTemplateToken(p)),
    functionExpression: new ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$TokContext('function', true),
    functionStatement: new ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$TokContext('function', false),

    // JSX
    jsxOpenTag: new ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$TokContext('<tag', false),
    jsxCloseTag: new ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$TokContext('</tag', false),
    jsxInner: new ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$TokContext('<tag>...</tag>', true, true),
  };

  // Token-specific context update code
  ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR.updateContext =
    ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR.updateContext =
      function(parser) {
        if (parser.state.context.length === 1) {
          parser.state.exprAllowed = true;
          return undefined;
        }

        let out = parser.state.context.pop();
        if (out === ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.braceStatement &&
          ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$getCurContext(parser).token ===
          'function') {
          out = parser.state.context.pop();
        }

        if (out === undefined) {
          throw new Error('No context found');
        }

        parser.state.exprAllowed = !out.isExpr;
      };

  ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name.updateContext =
    function(parser, prevType) {
      let allowed = false;
      if (prevType !== ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot) {
        if (parser.state.tokenValue === 'of' && !parser.state.exprAllowed ||
        parser.state.tokenValue === 'yield' && parser.inScope('GENERATOR')) {
          allowed = true;
        }
      }

      parser.state.exprAllowed = allowed;

      if (parser.state.isIterator) {
        parser.state.isIterator = false;
      }
    };

  ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL.updateContext =
    function(parser, prevType) {
      parser.state.context.push(
        ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$isBraceBlock(parser, prevType)
          ? ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.braceStatement : ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.braceExpression,
      );
      parser.state.exprAllowed = true;
    };

  ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dollarBraceL.updateContext =
    function(parser) {
      parser.state.context.push(___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.templateQuasi);
      parser.state.exprAllowed = true;
    };

  ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL.updateContext =
    function(parser, prevType) {
      const statementParens = prevType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._if || prevType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._for ||
      prevType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._with ||
      prevType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._while;
      parser.state.context.push(
        statementParens
          ? ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.parenStatement : ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.parenExpression,
      );
      parser.state.exprAllowed = true;
    };

  ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.incDec.updateContext =
    function() {
      // tokExprAllowed stays unchanged
    };

  ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._function.updateContext =
    function(parser, prevType) {
      if (prevType.beforeExpr && prevType !== ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi && prevType !== ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._else &&
        !(prevType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._return &&
          ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreak.test(
            parser.getRawInput(
              parser.state.lastEndPos.index,
              parser.state.startPos.index,
            ),
          )) &&
        !((prevType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon || prevType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL) &&
          ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$getCurContext(
            parser,
          ) ===
          ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.b_stat)) {
        parser.state.context.push(___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.functionExpression);
      } else {
        parser.state.context.push(___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.functionStatement);
      }

      parser.state.exprAllowed = false;
    };

  ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._class.updateContext = ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._function.updateContext;

  ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.backQuote.updateContext =
    function(parser) {
      if (___R$project$rome$$romejs$js$parser$tokenizer$index_ts$getCurContext(parser) === ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.template) {
        parser.state.context.pop();
      } else {
        parser.state.context.push(___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.template);
      }
      parser.state.exprAllowed = false;
    };

  ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart.updateContext =
    function(parser) {
      parser.state.context.push(___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.jsxInner); // treat as beginning of JSX expression
      parser.state.context.push(___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.jsxOpenTag); // start opening tag context
      parser.state.exprAllowed = false;
    };

  ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagEnd.updateContext =
    function(parser, prevType) {
      const out = parser.state.context.pop();
      if (out === ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.jsxOpenTag && prevType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.slash ||
      out ===
      ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.jsxCloseTag) {
        parser.state.context.pop();
        parser.state.exprAllowed = ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$getCurContext(parser) === ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.jsxInner;
      } else {
        parser.state.exprAllowed = true;
      }
    };

  // project-rome/@romejs/js-parser/parser/comments.ts
const ___R$project$rome$$romejs$js$parser$parser$comments_ts = {
    addComment: ___R$project$rome$$romejs$js$parser$parser$comments_ts$addComment,
    attachComments: ___R$project$rome$$romejs$js$parser$parser$comments_ts$attachComments,
  };
  function ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$last(stack) {
    return stack[stack.length - 1];
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$getLoc(node) {
    const {loc} = node;
    if (loc === undefined) {
      throw new Error('No loc found');
    }
    return loc;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$start(node) {
    return ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$getLoc(node).start.index;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(node) {
    return ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$getLoc(node).end.index;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$hasComments(
    comments,
  ) {
    return comments !== undefined && comments.length > 0;
  }

  function ___R$project$rome$$romejs$js$parser$parser$comments_ts$addComment(parser, comment) {
    parser.state.trailingComments.push(comment);
    parser.state.leadingComments.push(comment);
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$adjustCommentsAfterTrailingComma(
    parser,
    node,
    elements,
    // When the current node is followed by a token which hasn't a respective AST node, we

    // need to take all the trailing comments to prevent them from being attached to an

    // unrelated node. e.g. in

    //     var { x } /* cmt */ = { y }

    // we don't want /* cmt */ to be attached to { y }.

    // On the other hand, in

    //     fn(x) [new line] /* cmt */ [new line] y

    // /* cmt */ is both a trailing comment of fn(x) and a leading comment of y
    takeAllComments,
  ) {
    if (parser.state.leadingComments.length === 0) {
      return;
    }

    let lastElement = undefined;
    let i = elements.length;
    while (lastElement === undefined && i > 0) {
      lastElement = elements[--i];
    }
    if (lastElement === undefined) {
      return;
    }

    const {commentPreviousNode} = parser.state;
    if (commentPreviousNode === undefined) {
      throw new Error('No commentPreviousNode found');
    }

    for (let j = 0;
    j < parser.state.leadingComments.length;
    j++) {
      if (___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(parser.state.leadingComments[j]) < ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(commentPreviousNode)) {
        parser.state.leadingComments.splice(j, 1);
        j--;
      }
    }

    const newTrailingComments = [];
    for (let i = 0;
    i < parser.state.leadingComments.length;
    i++) {
      const leadingComment = parser.state.leadingComments[i];
      if (___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(leadingComment) < ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(node)) {
        newTrailingComments.push(leadingComment);

        // Perf: we don't need to splice if we are going to reset the array anyway
        if (!takeAllComments) {
          parser.state.leadingComments.splice(i, 1);
          i--;
        }
      } else {
        if (node.trailingComments === undefined) {
          node.trailingComments = [];
        }
        node.trailingComments.push(leadingComment);
      }
    }
    if (takeAllComments) {
      parser.state.leadingComments = [];
    }

    if (newTrailingComments.length > 0) {
      lastElement.trailingComments = newTrailingComments;
    } else if (lastElement.trailingComments !== undefined) {
      lastElement.trailingComments = [];
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$comments_ts$attachComments(parser, node) {
    if (node.type === 'Program' && node.body.length > 0) {
      return;
    }

    const {commentStack, commentPreviousNode} = parser.state;

    let trailingComments;

    if (parser.state.trailingComments.length > 0) {
      // If the first comment in trailingComments comes after the

      // current node, then we're good - all comments in the array will

      // come after the node and so it's safe to add them as official

      // trailingComments.
      if (___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$start(parser.state.trailingComments[0]) >= ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(node)) {
        trailingComments = parser.state.trailingComments;
        parser.state.trailingComments = [];
      } else {
        // Otherwise, if the first comment doesn't come after the

        // current node, that means we have a mix of leading and trailing

        // comments in the array and that leadingComments contains the

        // same items as trailingComments. Reset trailingComments to

        // zero items and we'll handle this by evaluating leadingComments

        // later.
        parser.state.trailingComments = [];
      }
    } else if (commentStack.length > 0) {
      const lastInStack = ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$last(commentStack);
      if (___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$hasComments(lastInStack.trailingComments) &&
        ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$start(
          lastInStack.trailingComments[0],
        ) >=
        ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(node)) {
        trailingComments = lastInStack.trailingComments;
        lastInStack.trailingComments = undefined;
      }
    }

    // Eating the stack.
    let firstChild;
    if (commentStack.length > 0 && ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$start(___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$last(commentStack)) >= ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$start(node)) {
      firstChild = commentStack.pop();
    }

    let lastChild;
    while (commentStack.length > 0 && ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$start(___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$last(commentStack)) >= ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$start(node)) {
      lastChild = commentStack.pop();
    }

    if (!lastChild && firstChild) {
      lastChild = firstChild;
    }

    // Adjust comments that follow a trailing comma on the last element in a

    // comma separated list of nodes to be the trailing comments on the last

    // element
    if (firstChild) {
      switch (node.type) {
        case 'ObjectExpression':
          ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$adjustCommentsAfterTrailingComma(parser, node, node.properties);
          break;

        case 'BindingObjectPattern':
        case 'AssignmentObjectPattern':
          ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$adjustCommentsAfterTrailingComma(parser, node, node.properties, true);
          break;

        case 'CallExpression':
          ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$adjustCommentsAfterTrailingComma(parser, node, node.arguments);
          break;

        case 'ArrayExpression':
          ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$adjustCommentsAfterTrailingComma(parser, node, node.elements);
          break;

        case 'BindingArrayPattern':
        case 'AssignmentArrayPattern':
          ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$adjustCommentsAfterTrailingComma(parser, node, node.elements, true);
          break;
      }
    } else if (commentPreviousNode !== undefined &&
      (commentPreviousNode.type ===
      'ImportSpecifier' &&
        node.type !== 'ImportSpecifier' ||
      commentPreviousNode.type === 'ExportLocalSpecifier' &&
        node.type !==
        'ExportExternalSpecifier' ||
      commentPreviousNode.type ===
      'ExportExternalSpecifier' &&
        node.type !== 'ExportExternalSpecifier')) {
      ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$adjustCommentsAfterTrailingComma(
        parser,
        node,
        [
          parser.state.commentPreviousNode,
        ],
      );
    }

    if (lastChild !== undefined) {
      if (___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$hasComments(lastChild.leadingComments)) {
        if (lastChild !== node &&
          ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$last(lastChild.leadingComments)) <=
          ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$start(
            node,
          )) {
          node.leadingComments = lastChild.leadingComments;
          lastChild.leadingComments = undefined;
        } else {
          // A leading comment for an anonymous class had been stolen by its first ClassMethod,

          // so this takes back the leading comment.

          // See also: https://github.com/eslint/espree/issues/158
          for (let i = lastChild.leadingComments.length - 2;
          i >= 0;
          --i) {
            if (___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(lastChild.leadingComments[i]) <= ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$start(node)) {
              node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
              break;
            }
          }
        }
      }
    } else if (parser.state.leadingComments.length > 0) {
      if (___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$last(parser.state.leadingComments)) <= ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$start(node)) {
        if (parser.state.commentPreviousNode) {
          for (let j = 0;
          j < parser.state.leadingComments.length;
          j++) {
            if (___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(parser.state.leadingComments[j]) <
            ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(
              parser.state.commentPreviousNode,
            )) {
              parser.state.leadingComments.splice(j, 1);
              j--;
            }
          }
        }
        if (parser.state.leadingComments.length > 0) {
          node.leadingComments = parser.state.leadingComments;
          parser.state.leadingComments = [];
        }
      } else {
        // https://github.com/eslint/espree/issues/2

        //

        // In special cases, such as return (without a value) and

        // debugger, all comments will end up as leadingComments and

        // will otherwise be eliminated. This step runs when the

        // commentStack is empty and there are comments left

        // in leadingComments.

        //

        // This loop figures out the stopping point between the actual

        // leading and trailing comments by finding the location of the

        // first comment that comes after the given node.
        let i = 0;
        while (i < parser.state.leadingComments.length) {
          if (___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(parser.state.leadingComments[i]) > ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$start(node)) {
            break;
          } else {
            i++;
          }
        }

        // Split the array based on the location of the first comment

        // that comes after the node. Keep in mind that this could

        // result in an empty array, and if so, the array must be

        // deleted.
        const leadingComments = parser.state.leadingComments.slice(0, i);

        if (leadingComments.length > 0) {
          node.leadingComments = leadingComments;
        }

        // Similarly, trailing comments are attached later. The variable

        // must be reset to null if there are no trailing comments.
        trailingComments = parser.state.leadingComments.slice(i);
        if (trailingComments.length === 0) {
          trailingComments = undefined;
        }
      }
    }

    parser.state.commentPreviousNode = node;

    if (trailingComments) {
      let innerEndIndex = -1;

      for (let i = 0;
      i < trailingComments.length;
      i++) {
        const comment = trailingComments[i];
        if (___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$start(comment) >= ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$start(node) && ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(comment) <= ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(node)) {
          innerEndIndex++;
        } else {
          break;
        }
      }

      if (innerEndIndex === -1) {
        node.trailingComments = trailingComments;
      } else {
        node.innerComments = trailingComments.slice(0, innerEndIndex + 1);
        node.trailingComments = trailingComments.slice(innerEndIndex + 1);
      }
    }

    commentStack.push(node);
  }

  // project-rome/@romejs/js-parser/parser/statement.ts
const ___R$project$rome$$romejs$js$parser$parser$statement_ts = {
    parseTopLevel: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseTopLevel,
    parsePossibleInterpreterDirective: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parsePossibleInterpreterDirective,
    expressionStatementToDirective: ___R$project$rome$$romejs$js$parser$parser$statement_ts$expressionStatementToDirective,
    isLetStart: ___R$project$rome$$romejs$js$parser$parser$statement_ts$isLetStart,
    parseStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseStatement,
    isAsyncFunctionDeclarationStart: ___R$project$rome$$romejs$js$parser$parser$statement_ts$isAsyncFunctionDeclarationStart,
    assertModuleNodeAllowed: ___R$project$rome$$romejs$js$parser$parser$statement_ts$assertModuleNodeAllowed,
    parseBreakContinueStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBreakContinueStatement,
    parseDebuggerStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseDebuggerStatement,
    parseDoStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseDoStatement,
    parseForStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseForStatement,
    assertVarKind: ___R$project$rome$$romejs$js$parser$parser$statement_ts$assertVarKind,
    parseIfStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseIfStatement,
    parseReturnStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseReturnStatement,
    parseSwitchStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseSwitchStatement,
    parseThrowStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseThrowStatement,
    parseTryStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseTryStatement,
    parseVarStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseVarStatement,
    parseWhileStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseWhileStatement,
    parseWithStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseWithStatement,
    parseEmptyStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseEmptyStatement,
    parseLabeledStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseLabeledStatement,
    parseExpressionStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseExpressionStatement,
    parseBlock: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlock,
    isValidDirective: ___R$project$rome$$romejs$js$parser$parser$statement_ts$isValidDirective,
    parseBlockBody: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlockBody,
    parseBlockOrModuleBlockBody: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlockOrModuleBlockBody,
    parseFor: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFor,
    parseForIn: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseForIn,
    parseVar: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseVar,
    parseVarHead: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseVarHead,
    parseFunctionDeclaration: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionDeclaration,
    parseExportDefaultFunctionDeclaration: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseExportDefaultFunctionDeclaration,
    parseFunctionExpression: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionExpression,
    parseFunction: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunction,
    splitFunctionParams: ___R$project$rome$$romejs$js$parser$parser$statement_ts$splitFunctionParams,
    parseFunctionParams: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionParams,
  };
  const ___R$$priv$project$rome$$romejs$js$parser$parser$statement_ts$loopLabel = {kind: 'loop'};
  const ___R$$priv$project$rome$$romejs$js$parser$parser$statement_ts$switchLabel = {kind: 'switch'};

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseTopLevel(parser) {
    const start = parser.getPosition();
    const openContext = {
      name: 'top-level',
      start,
      indent: ___R$project$rome$$romejs$ob1$index_ts$number0,
      open: ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof,
      close: ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof,
    };

    // Parse the body, and catch fatal syntax errors

    // Get the first token
    ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$nextToken(parser);

    const interpreter = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parsePossibleInterpreterDirective(parser);
    const {body, directives} = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlockBody(parser, true, true, openContext);

    const loc = parser.finishLoc(start);

    return (
      {
        type: 'Program',
        corrupt: parser.state.corrupt,
        loc,
        body,
        directives,
        mtime: parser.mtime,
        diagnostics: parser.getDiagnostics(),
        filename: parser.filename,
        comments: parser.state.comments,
        sourceType: parser.sourceType,
        interpreter,
        syntax: Array.from(parser.syntax),
        hasHoistedVars: parser.state.hasHoistedVars,
      }
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parsePossibleInterpreterDirective(
    parser,
  ) {
    // Check for #!
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.hash) &&
      parser.input[___R$project$rome$$romejs$ob1$index_ts$get0(parser.state.endPos.index)] ===
      '!') {
      // Parse as a regular comment, we should abstract this logic

      // TODO this gets pushed to all the comments which is bad
      const comment = ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$skipLineComment(parser, 2);

      // Advance to next token
      parser.next();

      return (
        {
          type: 'InterpreterDirective',
          value: comment.value,
          loc: comment.loc,
        }
      );
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$expressionStatementToDirective(
    parser,
    stmt,
  ) {
    const expr = stmt.expression;

    const start = parser.getLoc(stmt).start;

    const raw = parser.getRawInput(
      parser.getLoc(expr).start.index,
      parser.getLoc(
        expr,
      ).end.index,
    );
    const val = raw.slice(1, -1); // remove quotes
    const end = parser.getLoc(stmt).end;

    return (
      parser.finishNodeAt(
        start,
        end,
        {
          type: 'Directive',
          value: val,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$isLetStart(parser, context) {
    if (!parser.isContextual('let')) {
      return false;
    }

    ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$skipWhiteSpace.lastIndex = ___R$project$rome$$romejs$ob1$index_ts$get0(parser.state.index);
    const skip = ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$skipWhiteSpace.exec(parser.input);
    if (skip == null) {
      throw new Error('Should never be true');
    }

    const next = ___R$project$rome$$romejs$ob1$index_ts$add(parser.state.index, skip[0].length);
    const nextCh = parser.input.charCodeAt(___R$project$rome$$romejs$ob1$index_ts$get0(next));

    // For ambiguous cases, determine if a LexicalDeclaration (or only a

    // Statement) is allowed here. If context is not empty then only a Statement

    // is allowed. However, `let [` is an explicit negative lookahead for

    // ExpressionStatement, so special-case it first.
    if (nextCh === ___R$project$rome$$romejs$string$charcodes$index_ts.leftSquareBracket) {
      return true;
    }

    if (context !== undefined) {
      return false;
    }

    if (nextCh === ___R$project$rome$$romejs$string$charcodes$index_ts.leftCurlyBrace) {
      return true;
    }

    if (___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierStart(nextCh)) {
      let pos = ___R$project$rome$$romejs$ob1$index_ts$add(next, 1);
      while (___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierChar(parser.input.charCodeAt(___R$project$rome$$romejs$ob1$index_ts$get0(pos)))) {
        pos = ___R$project$rome$$romejs$ob1$index_ts$inc(pos);
      }

      const ident = parser.getRawInput(next, pos);
      if (!___R$project$rome$$romejs$js$parser$utils$identifier_ts$keywordRelationalOperator.test(ident)) {
        return true;
      }
    }
    return false;
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseStatement(
    parser,
    context = undefined,
    topLevel = false,
  ) {
    let startType = parser.state.tokenType;
    const start = parser.getPosition();

    if (startType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._const && parser.isSyntaxEnabled('ts')) {
      const ahead = parser.lookaheadState();
      if (ahead.tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name && ahead.tokenValue === 'enum') {
        parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._const);
        parser.expectContextual('enum');
        return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSEnumDeclaration(parser, start, /* isConst */true);
      }
    }

    let kind;
    if (___R$project$rome$$romejs$js$parser$parser$statement_ts$isLetStart(parser, context)) {
      startType = ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._var;
      kind = 'let';
    }

    // Most types of statements are recognized by the keyword they

    // start with. Many are trivial to parse, some require a bit of

    // complexity.
    switch (startType) {
      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._break:
        return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBreakContinueStatement(parser, start, true);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._continue:
        return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBreakContinueStatement(parser, start, false);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._debugger:
        return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseDebuggerStatement(parser, start);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._do:
        return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseDoStatement(parser, start);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._for:
        return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseForStatement(parser, start);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._function:
        if (parser.lookaheadState().tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot) {
          // MetaProperty: eg. function.sent
          break;
        }

        if (context !== undefined) {
          if (parser.inScope('STRICT')) {
            parser.addDiagnostic(
              {
                message: 'In strict mode code, functions can only be declared at top level or inside a block',
              },
            );
          } else if (context !== 'if' && context !== 'label') {
            parser.addDiagnostic(
              {
                message: 'In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement',
              },
            );
          }
        }

        parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._function);

        const result = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionDeclaration(parser, start, false);

        if (context !== undefined && result.head.generator === true) {
          parser.addDiagnostic(
            {
              message: 'Generators can only be declared at the top level or inside a block',
              loc: result.loc,
            },
          );
        }

        return result;

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._class:
        {
          if (context !== undefined) {
            parser.unexpectedToken();
          }
          return ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseClassDeclaration(parser, start);
        }

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._if:
        return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseIfStatement(parser, start);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._return:
        return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseReturnStatement(parser, start);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._switch:
        return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseSwitchStatement(parser, start);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._throw:
        return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseThrowStatement(parser, start);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._try:
        return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseTryStatement(parser, start);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._const:
      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._var:
        kind =
          kind === undefined
            ? ___R$project$rome$$romejs$js$parser$parser$statement_ts$assertVarKind(String(parser.state.tokenValue)) : kind;
        if (context !== undefined && kind !== 'var') {
          parser.addDiagnostic(
            {
              message: 'Lexical declaration cannot appear in a single-statement context',
            },
          );
        }
        return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseVarStatement(parser, start, kind);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._while:
        return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseWhileStatement(parser, start);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._with:
        return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseWithStatement(parser, start);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL:
        return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlock(parser);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi:
        return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseEmptyStatement(parser, start);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._export:
      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._import:
        {
          const nextToken = parser.lookaheadState();
          if (nextToken.tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL || nextToken.tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot) {
            break;
          }

          parser.next();

          let result;
          if (startType == ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._import) {
            result = ___R$project$rome$$romejs$js$parser$parser$modules_ts$parseImport(parser, start);
          } else {
            result = ___R$project$rome$$romejs$js$parser$parser$modules_ts$parseExport(parser, start);
          }

          if (!topLevel) {
            parser.addDiagnostic(
              {
                message: '\'import\' and \'export\' may only appear at the top level',
              },
            );
          }

          ___R$project$rome$$romejs$js$parser$parser$statement_ts$assertModuleNodeAllowed(parser, result);

          return result;
        }

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name:
        if (___R$project$rome$$romejs$js$parser$parser$statement_ts$isAsyncFunctionDeclarationStart(parser)) {
          if (context !== undefined) {
            parser.addDiagnostic(
              {
                message: 'Async functions can only be declared at the top level or inside a block',
              },
            );
          }

          // async identifier
          parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name);

          // function keyword
          parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._function);

          return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionDeclaration(parser, start, true);
        }
    }

    // If the statement does not start with a statement keyword or a

    // brace, it's an ExpressionStatement or LabeledStatement. We

    // simply start parsing an expression, and afterwards, if the

    // next token is a colon and the expression was a simple

    // Identifier node, we switch to interpreting it as a label.
    const maybeName = String(parser.state.tokenValue);
    const expr = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(parser, 'statement expression');

    if (startType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name && expr.type === 'ReferenceIdentifier' &&
      parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseLabeledStatement(parser, start, maybeName, expr, context);
    } else {
      return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseExpressionStatement(parser, start, expr);
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$isAsyncFunctionDeclarationStart(parser) {
    if (!parser.isContextual('async')) {
      return false;
    }

    const {input} = parser;
    const {index} = parser.state;

    ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$skipWhiteSpace.lastIndex = ___R$project$rome$$romejs$ob1$index_ts$get0(index);
    const skip = ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$skipWhiteSpace.exec(input);

    if (!skip || skip.length === 0) {
      return false;
    }

    const next = ___R$project$rome$$romejs$ob1$index_ts$add(index, skip[0].length);

    return (
      !___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreak.test(parser.getRawInput(index, next)) &&
        parser.getRawInput(
          next,
          ___R$project$rome$$romejs$ob1$index_ts$add(next, 8),
        ) ===
        'function' &&
        (___R$project$rome$$romejs$ob1$index_ts$get0(next) + 8 === input.length ||
        !___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierChar(
          input.charCodeAt(___R$project$rome$$romejs$ob1$index_ts$get0(next) + 8),
        ))
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$assertModuleNodeAllowed(parser, node) {
    if (node.type === 'ImportDeclaration' &&
      (node.importKind === 'type' ||
      node.importKind === 'typeof') ||
    node.type === 'ExportLocalDeclaration' &&
      node.exportKind === 'type' ||
    node.type === 'ExportAllDeclaration' &&
      node.exportKind === 'type') {
      // Allow Flow type imports and exports in all conditions because

      // Flow itself does not care about 'sourceType'.
      return;
    }

    if (!parser.inModule) {
      parser.addDiagnostic(
        {
          loc: node.loc,
          message: '<emphasis>import</emphasis> and <emphasis>export</emphasis> can only appear in a module',
          advice: [
            // TODO this advice is pointless if you have syntax extensions enabled

            // TODO point to the actual package.json for this file
            {
              type: 'log',
              category: 'info',
              message: 'Change the extension to <emphasis>.mjs</emphasis> to turn this file into a module',
            },
            {
              type: 'log',
              category: 'info',
              message: 'Add <emphasis>"type": "module"</emphasis> to your <filelink emphasis target="' +
              parser.options.manifestPath +
              '" />',
            },
          ],
        },
      );
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBreakContinueStatement(
    parser,
    start,
    isBreak,
  ) {
    const keyword = isBreak ? 'break' : 'continue';
    parser.next();

    let label;
    if (parser.isLineTerminator()) {
      label = undefined;
    } else if (!parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name)) {
      parser.unexpectedToken();
    } else {
      label = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser);
      parser.semicolon();
    }

    // Verify that there is an actual destination to break or

    // continue to.
    let i;
    for (i = 0;
    i < parser.state.labels.length;
    ++i) {
      const lab = parser.state.labels[i];
      if (label === undefined || lab.name === label.name) {
        if (lab.kind !== undefined && (isBreak || lab.kind === 'loop')) {
          break;
        }

        if (label && isBreak) {
          break;
        }
      }
    }
    if (i === parser.state.labels.length) {
      parser.addDiagnostic(
        {
          start,
          message: 'Unsyntactic ' +
          keyword,
        },
      );
    }

    if (isBreak) {
      return (
        parser.finishNode(
          start,
          {
            type: 'BreakStatement',
            label,
          },
        )
      );
    } else {
      return (
        parser.finishNode(
          start,
          {
            type: 'ContinueStatement',
            label,
          },
        )
      );
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseDebuggerStatement(
    parser,
    start,
  ) {
    parser.next();
    parser.semicolon();
    return parser.finishNode(start, {type: 'DebuggerStatement'});
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseDoStatement(
    parser,
    start,
  ) {
    parser.next();
    parser.state.labels.push(___R$$priv$project$rome$$romejs$js$parser$parser$statement_ts$loopLabel);
    const body = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseStatement(parser, 'do');
    parser.state.labels.pop();
    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._while);
    const test = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenExpression(parser, 'do test');
    parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi);
    return (
      parser.finishNode(
        start,
        {
          type: 'DoWhileStatement',
          body,
          test,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseForStatement(
    parser,
    start,
  ) {
    parser.next();
    parser.state.labels.push(___R$$priv$project$rome$$romejs$js$parser$parser$statement_ts$loopLabel);

    let awaitAt;
    if (parser.inScope('ASYNC') && parser.eatContextual('await')) {
      awaitAt = parser.getLastEndPosition();
    }

    const openContext = parser.expectOpening(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR, 'for head');

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi)) {
      if (awaitAt) {
        parser.unexpectedToken();
      }
      return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFor(parser, start, openContext, undefined);
    }

    const _isLet = ___R$project$rome$$romejs$js$parser$parser$statement_ts$isLetStart(parser);
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._var) || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._const) || _isLet) {
      const initStart = parser.getPosition();

      const kind = ___R$project$rome$$romejs$js$parser$parser$statement_ts$assertVarKind(_isLet ? 'let' : String(parser.state.tokenValue));
      parser.next();

      const declarations = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseVar(parser, initStart, kind, true);

      const init = parser.finishNode(
        initStart,
        {
          type: 'VariableDeclaration',
          kind,
          declarations,
        },
      );

      if ((parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._in) || parser.isContextual('of')) &&
        init.declarations.length === 1) {
        return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseForIn(parser, start, openContext, init, awaitAt);
      }

      if (awaitAt !== undefined) {
        parser.addDiagnostic(
          {
            start: awaitAt,
            message: 'Can\'t have an await on a regular for loop',
          },
        );
      }

      return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFor(parser, start, openContext, init);
    }

    const refShorthandDefaultPos = {index: ___R$project$rome$$romejs$ob1$index_ts$number0};
    let init = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(parser, 'for init', true, refShorthandDefaultPos);

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._in) || parser.isContextual('of')) {
      const description = parser.isContextual('of')
        ? 'for-of statement' : 'for-in statement';
      const initPattern = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(parser, init, description);
      ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(parser, init, undefined, undefined, description);
      return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseForIn(parser, start, openContext, initPattern, awaitAt);
    }

    if (___R$project$rome$$romejs$ob1$index_ts$get0(refShorthandDefaultPos.index) > 0) {
      parser.unexpectedToken(
        parser.getPositionFromIndex(
          refShorthandDefaultPos.index,
        ),
      );
    }

    if (awaitAt !== undefined) {
      parser.addDiagnostic(
        {
          start: awaitAt,
          message: 'Can\'t have an await on a regular for loop',
        },
      );
    }

    return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFor(parser, start, openContext, init);
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$assertVarKind(kind) {
    if (kind === 'let' || kind === 'var' || kind === 'const') {
      return kind;
    } else {
      throw new Error('Expected valid variable kind but got ' +
      kind);
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseIfStatement(parser, start) {
    parser.next();
    const test = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenExpression(parser, 'if test');
    const consequent = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseStatement(parser, 'if');
    const alternate = parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._else)
      ? ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseStatement(parser, 'if') : undefined;
    return (
      parser.finishNode(
        start,
        {
          type: 'IfStatement',
          test,
          consequent,
          alternate,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseReturnStatement(
    parser,
    start,
  ) {
    if (!parser.inScope('FUNCTION') && parser.sourceType !== 'template' &&
      !parser.options.allowReturnOutsideFunction) {
      parser.addDiagnostic(
        {
          message: '\'return\' outside of function',
        },
      );
    }

    parser.next();

    // In `return` (and `break`/`continue`), the keywords with

    // optional arguments, we eagerly look for a semicolon or the

    // possibility to insert one.
    let argument;
    if (!parser.isLineTerminator()) {
      argument = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(parser, 'return argument');
      parser.semicolon();
    }

    return (
      parser.finishNode(
        start,
        {
          type: 'ReturnStatement',
          argument,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseSwitchStatement(
    parser,
    start,
  ) {
    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._switch);
    const discriminant = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenExpression(parser, 'switch discriminant');
    const cases = [];
    const hasBrace = parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL);
    const openContext = parser.expectOpening(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR, 'switch body');
    parser.state.labels.push(___R$$priv$project$rome$$romejs$js$parser$parser$statement_ts$switchLabel);

    if (hasBrace) {
      // Statements under must be grouped (by label) in SwitchCase

      // nodes. `cur` is used to keep the node that we are currently

      // adding statements to.

      let cur;

      function pushCase() {
        if (cur === undefined) {
          return undefined;
        }

        cases.push(
          parser.finishNode(
            cur.start,
            {
              type: 'SwitchCase',
              test: cur.test,
              consequent: cur.consequent,
            },
          ),
        );

        cur = undefined;
      }

      let sawDefault;

      while (true) {
        if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR) || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof)) {
          break;
        }

        if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._case) || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._default)) {
          pushCase();

          const isCase = parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._case);

          parser.next();

          let test;
          if (isCase) {
            test = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(parser, 'case test');
          } else {
            if (sawDefault) {
              parser.addDiagnostic(
                {
                  start: parser.state.lastStartPos,
                  message: 'Multiple default clauses',
                },
              );
            }
            sawDefault = true;
          }

          cur =
            {
              start: parser.getPosition(),
              consequent: [],
              test,
            };

          parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon);
        } else {
          const stmt = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseStatement(parser, undefined);
          if (cur === undefined) {
            parser.addDiagnostic(
              {
                loc: stmt.loc,
                message: 'Statement outside of a case or default block',
              },
            );
          } else {
            cur.consequent.push(stmt);
          }
        }
      }

      pushCase();
    }

    parser.expectClosing(openContext);
    parser.state.labels.pop();

    return (
      parser.finishNode(
        start,
        {
          type: 'SwitchStatement',
          discriminant,
          cases,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseThrowStatement(
    parser,
    start,
  ) {
    parser.next();
    if (___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreak.test(
      parser.getRawInput(
        parser.state.lastEndPos.index,
        parser.state.startPos.index,
      ),
    )) {
      parser.addDiagnostic(
        {
          start: parser.state.lastEndPos,
          message: 'Illegal newline after throw',
        },
      );
    }

    const argument = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(parser, 'throw argument');
    parser.semicolon();
    return (
      parser.finishNode(
        start,
        {
          type: 'ThrowStatement',
          argument,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseTryStatement(
    parser,
    start,
  ) {
    parser.next();

    const block = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlock(parser);
    let handler = undefined;

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._catch)) {
      const clauseStart = parser.getPosition();
      parser.next();

      let param;
      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL)) {
        const openContext = parser.expectOpening(
          ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
          ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
          'catch clause param',
        );
        param = ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseTargetBindingPattern(parser);
        const clashes = new Map();
        ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(parser, param, true, clashes, 'catch clause');
        parser.expectClosing(openContext);
      }

      const body = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlock(parser);
      handler =
        parser.finishNode(
          clauseStart,
          {
            type: 'CatchClause',
            body,
            param,
          },
        );
    }

    const finalizer = parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._finally) ? ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlock(parser) : undefined;

    if (!handler && !finalizer) {
      parser.addDiagnostic(
        {
          start,
          message: 'Missing catch or finally clause',
        },
      );
    }

    return (
      parser.finishNode(
        start,
        {
          type: 'TryStatement',
          block,
          finalizer,
          handler,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseVarStatement(
    parser,
    start,
    kind,
  ) {
    parser.next();
    const declarations = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseVar(parser, start, kind, false);
    parser.semicolon();
    return (
      parser.finishNode(
        start,
        {
          type: 'VariableDeclarationStatement',
          declaration: parser.finishNode(
            start,
            {
              type: 'VariableDeclaration',
              kind,
              declarations,
            },
          ),
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseWhileStatement(
    parser,
    start,
  ) {
    parser.next();
    const test = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenExpression(parser, 'while test');
    parser.state.labels.push(___R$$priv$project$rome$$romejs$js$parser$parser$statement_ts$loopLabel);
    const body = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseStatement(parser, 'while');
    parser.state.labels.pop();
    return {loc: parser.finishLoc(start), type: 'WhileStatement', test, body};
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseWithStatement(
    parser,
    start,
  ) {
    parser.next();
    const object = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenExpression(parser, 'with object');
    const body = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseStatement(parser, 'with');

    if (parser.inScope('STRICT')) {
      parser.addDiagnostic(
        {
          loc: parser.finishLoc(start),
          message: '\'with\' in strict mode',
        },
      );
    }

    return (
      parser.finishNode(
        start,
        {
          type: 'WithStatement',
          object,
          body,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseEmptyStatement(
    parser,
    start,
  ) {
    parser.next();
    return parser.finishNode(start, {type: 'EmptyStatement'});
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseLabeledStatement(
    parser,
    start,
    maybeName,
    expr,
    context,
  ) {
    for (const label of parser.state.labels) {
      if (label.name === maybeName) {
        parser.addDiagnostic(
          {
            loc: expr.loc,
            message: 'Label \'' +
            maybeName +
            '\' is already declared',
          },
        );
      }
    }

    let kind = undefined;
    if (parser.state.tokenType.isLoop) {
      kind = 'loop';
    } else if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._switch)) {
      kind = 'switch';
    }

    for (let i = parser.state.labels.length - 1;
    i >= 0;
    i--) {
      const label = parser.state.labels[i];
      if (label.statementStart === start.index) {
        label.statementStart = parser.state.startPos.index;
        label.kind = kind;
      } else {
        break;
      }
    }

    parser.state.labels.push(
      {
        name: maybeName,
        kind,
        statementStart: parser.state.startPos.index,
      },
    );

    let statementContext = 'label';
    if (context !== undefined) {
      if (context.includes('label')) {
        statementContext = context;
      } else {
        // @ts-ignore
        statementContext = context +
        'label';
      }
    }
    const body = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseStatement(parser, statementContext);

    if (body.type == 'ClassDeclaration' ||
    body.type ==
    'VariableDeclarationStatement' &&
      body.declaration.kind !== 'var' ||
    body.type == 'FunctionDeclaration' &&
      (parser.inScope('STRICT') ||
      body.head.generator === true ||
      body.head.async === true)) {
      parser.addDiagnostic(
        {
          loc: body.loc,
          message: 'Invalid labeled declaration',
        },
      );
    }

    parser.state.labels.pop();
    return (
      parser.finishNode(
        start,
        {
          type: 'LabeledStatement',
          label: Object.assign(
            {
            },
            expr,
            {
              type: 'Identifier',
            },
          ),
          body,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseExpressionStatement(
    parser,
    start,
    expr,
  ) {
    const node = ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeExpressionStatement(parser, start, expr);
    if (node !== undefined) {
      return node;
    }

    parser.semicolon();
    return (
      parser.finishNode(
        start,
        {
          type: 'ExpressionStatement',
          expression: expr,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlock(
    parser,
    allowDirectives,
  ) {
    const start = parser.getPosition();
    const openContext = parser.expectOpening(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR, 'block');
    const {body, directives} = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlockBody(
      parser,
      allowDirectives,
      false,
      openContext,
    );
    return (
      parser.finishNode(
        start,
        {
          type: 'BlockStatement',
          directives,
          body,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$isValidDirective(parser, stmt) {
    return (
      stmt.type === 'ExpressionStatement' &&
        stmt.expression.type ===
        'StringLiteral' &&
        !parser.isParenthesized(stmt.expression)
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlockBody(
    parser,
    allowDirectives = false,
    topLevel,
    openContext,
  ) {
    return (
      ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlockOrModuleBlockBody(
        parser,
        allowDirectives,
        topLevel,
        openContext,
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlockOrModuleBlockBody(
    parser,
    allowDirectives,
    topLevel,
    openContext,
  ) {
    const body = [];
    const directives = [];

    let parsedNonDirective = false;
    let didSetStrict = undefined;
    let octalPosition;

    while (true) {
      if (parser.match(openContext.close) || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof)) {
        parser.expectClosing(openContext);
        break;
      }

      if (!parsedNonDirective && parser.state.containsOctal && !octalPosition) {
        octalPosition = parser.state.octalPosition;
      }

      const stmt = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseStatement(parser, undefined, topLevel);

      if (allowDirectives && !parsedNonDirective &&
        stmt.type ===
        'ExpressionStatement' &&
        ___R$project$rome$$romejs$js$parser$parser$statement_ts$isValidDirective(parser, stmt)) {
        const directive = ___R$project$rome$$romejs$js$parser$parser$statement_ts$expressionStatementToDirective(parser, stmt);
        directives.push(directive);

        if (didSetStrict === undefined && directive.value === 'use strict') {
          ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$setStrict(parser, true);
          didSetStrict = true;

          if (octalPosition !== undefined) {
            parser.addDiagnostic(
              {
                index: octalPosition,
                message: 'Octal literal in strict mode',
              },
            );
          }
        }

        continue;
      }

      parsedNonDirective = true;
      body.push(stmt);
    }

    if (didSetStrict) {
      parser.popScope('STRICT');
    }

    return {body, directives};
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFor(
    parser,
    start,
    openContext,
    init,
  ) {
    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi);

    const test = parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi)
      ? undefined : ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(
        parser,
        'for test',
      );
    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi);

    const update = parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR)
      ? undefined : ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(
        parser,
        'for update',
      );
    parser.expectClosing(openContext);

    const body = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseStatement(parser, 'for');
    parser.state.labels.pop();

    return (
      parser.finishNode(
        start,
        {
          type: 'ForStatement',
          init,
          test,
          update,
          body,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseForIn(
    parser,
    start,
    openContext,
    init,
    awaitAt,
  ) {
    const isForIn = parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._in);
    parser.next();

    const isAwait = awaitAt !== undefined;
    if (isForIn && isAwait) {
      parser.addDiagnostic(
        {
          start: awaitAt,
          message: 'Unexpected await for `for-in`',
        },
      );
    }

    if (init.type === 'VariableDeclaration' &&
      init.declarations[0].init !==
      undefined &&
      (!isForIn || parser.inScope('STRICT') || init.kind !== 'var' ||
      init.declarations[0].id.type !== 'BindingIdentifier')) {
      parser.addDiagnostic(
        {
          loc: init.loc,
          message: (isForIn ? 'for-in' : 'for-of') +
          ' loop variable declaration may not have an initializer',
        },
      );
    }

    const left = init;
    const right = isForIn
      ? ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(parser, 'for right') : ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
        parser,
        'for right',
      );
    parser.expectClosing(openContext);

    const body = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseStatement(parser, 'for');
    parser.state.labels.pop();

    if (isForIn) {
      const node = parser.finishNode(
        start,
        {
          type: 'ForInStatement',
          left,
          right,
          body,
        },
      );
      return node;
    } else {
      const node = parser.finishNode(
        start,
        {
          type: 'ForOfStatement',
          await: isAwait,
          left,
          right,
          body,
        },
      );
      return node;
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseVar(
    parser,
    start,
    kind,
    isFor,
  ) {
    const declarations = [];

    for (;;) {
      const start = parser.getPosition();
      const id = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseVarHead(parser, start);

      if (kind === 'var') {
        parser.state.hasHoistedVars = true;
      }

      let init;
      if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq)) {
        init = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, 'var init', isFor);
      } else {
        if (kind === 'const' &&
          !(parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._in) || parser.isContextual('of'))) {
          // `const` with no initializer is allowed in TypeScript.

          // It could be a declaration like `const x: number;`.
          if (!parser.isSyntaxEnabled('ts')) {
            parser.addDiagnostic(
              {
                message: 'const with no initializer isn\'t allowed',
                loc: id.loc,
              },
            );
          }
        }

        // We exclude `const` because we already validated it above
        if (kind !== 'const' && id.type !== 'BindingIdentifier' &&
          !(isFor &&
            (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._in) || parser.isContextual('of')))) {
          parser.addDiagnostic(
            {
              start: parser.state.lastEndPos,
              message: 'Complex binding patterns require an initialization value',
            },
          );
        }
      }

      declarations.push(
        parser.finishNode(
          start,
          {
            type: 'VariableDeclarator',
            id,
            init,
          },
        ),
      );

      if (!parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma)) {
        break;
      }
    }

    return declarations;
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseVarHead(
    parser,
    start,
  ) {
    const id = ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseTargetBindingPattern(parser);

    ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(parser, id, true, undefined, 'variable declaration');

    let definite;
    if (id.type === 'BindingIdentifier' && parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bang)) {
      definite = true;

      if (!parser.isSyntaxEnabled('ts')) {
        parser.addDiagnostic(
          {
            message: 'TypeScript syntax isn\'t enabled for definite syntax',
          },
        );
      }

      parser.next();
    }

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      const typeAnnotation = ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parsePrimaryTypeAnnotation(parser);

      return (
        parser.finishNode(
          start,
          Object.assign(
            {
            },
            id,
            {
              meta: parser.finishNode(
                start,
                {
                  type: 'PatternMeta',
                  typeAnnotation,
                  definite,
                },
              ),
            },
          ),
        )
      );
    } else if (definite) {
      return (
        Object.assign(
          {
          },
          id,
          {
            meta: parser.finishNode(start, {type: 'PatternMeta', definite}),
          },
        )
      );
    } else {
      return id;
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionId(
    parser,
    requiredStatementId,
  ) {
    if (requiredStatementId || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name)) {
      return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionDeclaration(
    parser,
    start,
    isAsync,
  ) {
    const ___R$ = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunction(
      parser,
      {
        start,
        requiredStatementId: true,
        isStatement: true,
        isAsync,
      },
    );
    const shape = Object.assign(
      {
      },
      ___R$,
    );
    delete shape.id;
    delete shape.body;
    const {
      id,
      body,
    } = ___R$;
    if (id === undefined) {
      throw new Error('Required function name');
    }

    if (body === undefined) {
      return (
        parser.finalizeNode(
          Object.assign(
            {
              type: 'TSDeclareFunction',
            },
            shape,
            {
              id,
            },
          ),
        )
      );
    }

    return (
      parser.finalizeNode(
        Object.assign(
          {
            type: 'FunctionDeclaration',
          },
          shape,
          {
            id,
            body,
          },
        ),
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseExportDefaultFunctionDeclaration(
    parser,
    start,
    isAsync,
  ) {
    let ___R$1 = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunction(
      parser,
      {
        start,
        requiredStatementId: false,
        isStatement: true,
        isAsync,
      },
    );
    let shape = Object.assign(
      {
      },
      ___R$1,
    );
    delete shape.id;
    delete shape.body;
    let {
      id,
      body,
    } = ___R$1;
    if (id === undefined) {
      id =
        {
          type: 'BindingIdentifier',
          name: '*default*',
          // Does this `loc` make sense?
          loc: shape.loc,
        };
    }

    if (body === undefined) {
      return (
        parser.finalizeNode(
          Object.assign(
            {
              type: 'TSDeclareFunction',
            },
            shape,
            {
              id,
            },
          ),
        )
      );
    }

    return (
      parser.finalizeNode(
        Object.assign(
          {
            type: 'FunctionDeclaration',
          },
          shape,
          {
            id,
            body,
          },
        ),
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionExpression(
    parser,
    start,
    isAsync,
  ) {
    const ___R$2 = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunction(
      parser,
      {
        start,
        requiredStatementId: false,
        isStatement: false,
        isAsync,
      },
    );
    const shape = Object.assign(
      {
      },
      ___R$2,
    );
    delete shape.body;
    const {
      body,
    } = ___R$2;
    if (body === undefined) {
      throw new Error('Expected body');
    }

    return (
      Object.assign(
        {
        },
        shape,
        {
          body,
          type: 'FunctionExpression',
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunction(
    parser,
    opts,
  ) {
    const {start, isStatement, requiredStatementId, isAsync} = opts;

    const isGenerator = parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star);

    let id;
    if (isStatement) {
      id = ___R$$priv$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionId(parser, requiredStatementId);
    }

    const oldYieldPos = parser.state.yieldPos;
    const oldAwaitPos = parser.state.awaitPos;
    parser.pushScope('FUNCTION_LOC', start);
    parser.pushScope('FUNCTION', true);
    parser.pushScope('METHOD', false);
    parser.pushScope('GENERATOR', isGenerator);
    parser.pushScope('ASYNC', isAsync);
    parser.pushScope('CLASS_PROPERTY', false);
    parser.pushScope('NON_ARROW_FUNCTION');
    parser.state.yieldPos = ___R$project$rome$$romejs$ob1$index_ts$number0;
    parser.state.awaitPos = ___R$project$rome$$romejs$ob1$index_ts$number0;

    if (!isStatement) {
      id = ___R$$priv$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionId(parser, false);
    }

    const {params, rest, typeParameters} = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionParams(parser);
    const {head, body} = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseFunctionBodyAndFinish(
      parser,
      {
        allowBodiless: isStatement,
        id,
        params,
        rest,
        isArrowFunction: false,
        isMethod: false,
        isAsync,
        isGenerator,
        start,
      },
    );

    parser.state.yieldPos = oldYieldPos;
    parser.state.awaitPos = oldAwaitPos;

    parser.popScope('NON_ARROW_FUNCTION');
    parser.popScope('FUNCTION');
    parser.popScope('FUNCTION_LOC');
    parser.popScope('CLASS_PROPERTY');
    parser.popScope('METHOD');
    parser.popScope('GENERATOR');
    parser.popScope('ASYNC');

    if (body !== undefined && body.type !== 'BlockStatement') {
      throw new Error('Expected block statement for functions');
    }

    return (
      {
        head: Object.assign(
          {
          },
          head,
          {
            typeParameters,
          },
        ),
        body,
        id,
        loc: parser.finishLoc(start),
      }
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$splitFunctionParams(
    params,
  ) {
    const firstParam = params[0];
    if (firstParam !== undefined && firstParam.type === 'BindingIdentifier' &&
      firstParam.name === 'this') {
      return (
        {
          thisType: firstParam,
          params: params.slice(1),
        }
      );
    } else {
      return (
        {
          thisType: undefined,
          params,
        }
      );
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionParams(
    parser,
    kind,
    allowTSModifiers,
  ) {
    let typeParameters = undefined;
    if (parser.isRelational('<')) {
      typeParameters = ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$maybeParseTypeParameters(parser);

      if (typeParameters !== undefined && (kind === 'get' || kind === 'set')) {
        parser.addDiagnostic(
          {
            loc: typeParameters.loc,
            message: 'An accessor cannot have type parameters',
          },
        );
      }
    }

    parser.pushScope('PARAMETERS', true);

    const openContext = parser.expectOpening(
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
      'function params',
    );
    const {list: params, rest} = ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingListNonEmpty(
      parser,
      openContext,
      allowTSModifiers,
    );

    parser.popScope('PARAMETERS');
    ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkYieldAwaitInDefaultParams(parser);
    return {params, rest, typeParameters};
  }

  // project-rome/@romejs/codec-js-regexp/index.ts
function ___R$$priv$project$rome$$romejs$codec$js$regexp$index_ts$isHex(str) {
    return !/[^0-9a-fA-F]/.test(str);
  }

  function ___R$$priv$project$rome$$romejs$codec$js$regexp$index_ts$getCodePoint(char) {
    if (char.length === 1) {
      const point = char.codePointAt(0);
      if (point !== undefined) {
        return point;
      }
    }

    throw new Error('Input was not 1 character long');
  }

  const ___R$project$rome$$romejs$codec$js$regexp$index_ts$createRegExpParser = ___R$project$rome$$romejs$parser$core$index_ts$createParser(
    (
      ParserCore,
    ) =>
      (() => {
        class RegExpParser extends ParserCore {
          constructor(opts) {
            super(opts, 'parse/regex');
            this.diagnostics = [];
            this.unicode = opts.unicode;
          }

          addDiagnostic(opts) {
            this.diagnostics.push(this.createDiagnostic(opts));
          }

          unexpected() {
            throw new Error('No throwing');
          }

          tokenize(index, input) {
            const char = input[___R$project$rome$$romejs$ob1$index_ts$get0(index)];

            if (char === '\\') {
              let end = ___R$project$rome$$romejs$ob1$index_ts$add(index, 2);

              const nextChar = input[___R$project$rome$$romejs$ob1$index_ts$get0(index) + 1];
              switch (nextChar) {
                case 't':
                  return (
                    this.finishComplexToken(
                      'Character',
                      {
                        escaped: false,
                        value: '\t',
                      },
                      end,
                    )
                  );

                case 'n':
                  return (
                    this.finishComplexToken(
                      'Character',
                      {
                        escaped: false,
                        value: '\n',
                      },
                      end,
                    )
                  );

                case 'r':
                  return (
                    this.finishComplexToken(
                      'Character',
                      {
                        escaped: false,
                        value: '\r',
                      },
                      end,
                    )
                  );

                case 'v':
                  return (
                    this.finishComplexToken(
                      'Character',
                      {
                        escaped: false,
                        value: '\x0b',
                      },
                      end,
                    )
                  );

                case 'f':
                  return (
                    this.finishComplexToken(
                      'Character',
                      {
                        escaped: false,
                        value: '\f',
                      },
                      end,
                    )
                  );

                case 'b':
                  return (
                    this.finishComplexToken(
                      'Character',
                      {
                        escaped: false,
                        value: '\b',
                      },
                      end,
                    )
                  );

                case 'd':
                case 'D':
                case 'B':
                case 's':
                case 'S':
                case 'w':
                case 'W':
                  return this.finishValueToken('EscapedCharacter', nextChar, end);

                case 'k':
                  if (this.unicode) {
                    // TODO named group back reference https://github.com/tc39/proposal-regexp-named-groups#backreferences
                  }

                  return (
                    this.finishComplexToken(
                      'Character',
                      {
                        value: 'k',
                        escaped: true,
                      },
                      end,
                    )
                  );

                case 'p':
                  if (this.unicode) {
                    // TODO unicode property escapes https://github.com/tc39/proposal-regexp-unicode-property-escapes
                  }

                  return (
                    this.finishComplexToken(
                      'Character',
                      {
                        value: 'p',
                        escaped: true,
                      },
                      end,
                    )
                  );

                case 'P':
                  if (this.unicode) {
                    // TODO unicode property escapes https://github.com/tc39/proposal-regexp-unicode-property-escapes
                  }

                  return (
                    this.finishComplexToken(
                      'Character',
                      {
                        value: 'P',
                        escaped: true,
                      },
                      end,
                    )
                  );

                case 'c':
                  // TODO???
                  return (
                    this.finishComplexToken(
                      'Character',
                      {
                        value: 'c',
                        escaped: true,
                      },
                      end,
                    )
                  );

                case '0':
                  // TODO octal

                  return (
                    this.finishComplexToken(
                      'Character',
                      {
                        value: String.fromCharCode(0),
                        escaped: true,
                      },
                      end,
                    )
                  );

                case 'x':
                  {
                    const possibleHex = input.slice(___R$project$rome$$romejs$ob1$index_ts$get0(index) + 1, 2);

                    // \xhh
                    if (possibleHex.length === 2 && ___R$$priv$project$rome$$romejs$codec$js$regexp$index_ts$isHex(possibleHex)) {
                      end = ___R$project$rome$$romejs$ob1$index_ts$add(end, 2);

                      return (
                        this.finishComplexToken(
                          'Character',
                          {
                            value: String.fromCharCode(parseInt(possibleHex, 16)),
                            escaped: true,
                          },
                          end,
                        )
                      );
                    }

                    return (
                      this.finishComplexToken(
                        'Character',
                        {
                          value: 'x',
                          escaped: true,
                        },
                        end,
                      )
                    );
                  }

                case 'u':
                  {
                    // Get the next 4 characters after \u
                    const possibleHex = input.slice(___R$project$rome$$romejs$ob1$index_ts$get0(index) + 2, ___R$project$rome$$romejs$ob1$index_ts$get0(index) + 6);

                    // \uhhhh
                    if (possibleHex.length === 4 && ___R$$priv$project$rome$$romejs$codec$js$regexp$index_ts$isHex(possibleHex)) {
                      end = ___R$project$rome$$romejs$ob1$index_ts$add(end, 4);

                      return (
                        this.finishComplexToken(
                          'Character',
                          {
                            value: String.fromCharCode(parseInt(possibleHex, 16)),
                            escaped: true,
                          },
                          end,
                        )
                      );
                    }

                    if (this.unicode) {
                      // TODO \u{hhhh} or \u{hhhhh}
                    }

                    return (
                      this.finishComplexToken(
                        'Character',
                        {
                          value: 'u',
                          escaped: true,
                        },
                        end,
                      )
                    );
                  }

                // Redundant escaping
                default:
                  // TODO dangling backslash

                  // TODO backreference
                  return (
                    this.finishComplexToken(
                      'Character',
                      {
                        value: nextChar,
                        escaped: true,
                      },
                      end,
                    )
                  );
              }
            }

            switch (char) {
              case '$':
              case '^':
              case '.':
              case '?':
              case '}':
              case '+':
              case '|':
              case '*':
              case '[':
              case ']':
              case '(':
              case ')':
                return this.finishValueToken('Operator', char);
            }

            return (
              this.finishComplexToken(
                'Character',
                {
                  value: char,
                  escaped: false,
                },
              )
            );
          }

          getGroupModifiers() {
            const token = this.getToken();

            if (token.type === 'Character') {
              switch (token.value) {
                case ':':
                  this.nextToken();
                  return (
                    {
                      type: 'NON_CAPTURE',
                      kind: undefined,
                    }
                  );

                case '=':
                  this.nextToken();
                  return (
                    {
                      type: 'NON_CAPTURE',
                      kind: 'positive-lookahead',
                    }
                  );

                case '!':
                  this.nextToken();
                  return (
                    {
                      type: 'NON_CAPTURE',
                      kind: 'negative-lookahead',
                    }
                  );

                case '<':
                  const nextToken = this.lookaheadToken();

                  if (nextToken.type === 'Character') {
                    switch (nextToken.value) {
                      case '!':
                        this.nextToken();
                        this.nextToken();
                        return (
                          {
                            type: 'NON_CAPTURE',
                            kind: 'negative-lookbehind',
                          }
                        );

                      case '=':
                        this.nextToken();
                        this.nextToken();
                        return (
                          {
                            type: 'NON_CAPTURE',
                            kind: 'positive-lookbehind',
                          }
                        );
                    }

                    if (___R$project$rome$$romejs$parser$core$index_ts$isESIdentifierStart(nextToken.value)) {
                      let name = '';

                      // 1 is for the <
                      let skipCount = 1;
                      let targetToken = nextToken;
                      while (targetToken.type === 'Character' &&
                        ___R$project$rome$$romejs$parser$core$index_ts$isESIdentifierChar(
                          targetToken.value,
                        )) {
                        name += targetToken.value;
                        targetToken = this.lookaheadToken(targetToken.end);
                        skipCount++;
                      }

                      if (targetToken.type === 'Character' && targetToken.value === '>') {
                        // Skip through all the name tokens

                        // This is kinda a hacky solution, and slower than it could be
                        for (let i = 0;
                        i < skipCount;
                        i++) {
                          this.nextToken();
                        }

                        return (
                          {
                            type: 'NAMED_CAPTURE',
                            name,
                          }
                        );
                      }
                    }
                  }
              }
            }

            this.addDiagnostic(
              {
                message: 'Invalid capture group modifier',
                token,
              },
            );
          }

          matchOperator(op) {
            const token = this.getToken();
            return token.type === 'Operator' && token.value === op;
          }

          eatOperator(op) {
            if (this.matchOperator(op)) {
              this.nextToken();
              return true;
            } else {
              return false;
            }
          }

          parseGroupCapture() {
            const start = this.getPosition();
            this.nextToken();

            let modifiers;
            if (this.eatOperator('?')) {
              modifiers = this.getGroupModifiers();
            }

            const expression = this.parseExpression(() => !this.matchOperator(')'));

            if (!this.eatOperator(')')) {
              this.addDiagnostic(
                {
                  message: 'Unclosed group',
                  start,
                },
              );
            }

            if (modifiers !== undefined && modifiers.type === 'NON_CAPTURE') {
              return (
                {
                  type: 'RegExpGroupNonCapture',
                  expression,
                  kind: modifiers.kind,
                  loc: this.finishLoc(start),
                }
              );
            } else {
              let name = modifiers !== undefined ? modifiers.name : undefined;
              return (
                {
                  type: 'RegExpGroupCapture',
                  expression,
                  name,
                  loc: this.finishLoc(start),
                }
              );
            }
          }

          parseCharSet() {
            const start = this.getPosition();
            this.nextToken();

            const body = [];
            const invert = this.eatOperator('^');

            while (!this.matchToken('EOF') && !this.matchOperator(']')) {
              const part = this.parseCharacterOrRange();
              body.push(part);
            }

            if (!this.eatOperator(']')) {
              this.addDiagnostic(
                {
                  message: 'Unclosed character set',
                  start,
                },
              );
            }

            return (
              {
                type: 'RegExpCharSet',
                invert,
                body,
                loc: this.finishLoc(start),
              }
            );
          }

          getCharacterFromToken(token) {
            switch (token.type) {
              case 'Character':
              case 'Operator':
                return token.value;

              case 'SOF':
              case 'EOF':
              case 'Invalid':
                throw new Error('Unnecessary');

              default:
                throw new Error('Never');
            }
          }

          parseCharacter() {
            const token = this.getToken();

            if (token.type === 'Character') {
              this.nextToken();
              return (
                {
                  type: 'RegExpCharacter',
                  value: token.value,
                  loc: this.finishLocFromToken(token),
                }
              );
            }

            if (token.type === 'EscapedCharacter') {
              this.nextToken();

              const loc = this.finishLocFromToken(token);
              switch (token.value) {
                case 'd':
                  return (
                    {
                      type: 'RegExpDigitCharacter',
                      loc,
                    }
                  );

                case 'D':
                  return (
                    {
                      type: 'RegExpNonDigitCharacter',
                      loc,
                    }
                  );

                case 'b':
                  return (
                    {
                      type: 'RegExpWordBoundaryCharacter',
                      loc,
                    }
                  );

                case 'B':
                  return (
                    {
                      type: 'RegExpNonWordBoundaryCharacter',
                      loc,
                    }
                  );

                case 's':
                  return (
                    {
                      type: 'RegExpWhiteSpaceCharacter',
                      loc,
                    }
                  );

                case 'S':
                  return (
                    {
                      type: 'RegExpNonWhiteSpaceCharacter',
                      loc,
                    }
                  );

                case 'w':
                  return (
                    {
                      type: 'RegExpWordCharacter',
                      loc,
                    }
                  );

                case 'W':
                  return (
                    {
                      type: 'RegExpNonWordCharacter',
                      loc,
                    }
                  );
              }
            }

            this.nextToken();
            return (
              {
                type: 'RegExpCharacter',
                value: this.getCharacterFromToken(token),
                loc: this.finishLocFromToken(token),
              }
            );
          }

          parseCharacterOrRange() {
            const startPos = this.getPosition();
            let start = this.parseCharacter();

            // Range
            const nextToken = this.getToken();
            if (start.type === 'RegExpCharacter' && nextToken.type === 'Character' &&
              nextToken.value === '-' &&
              !nextToken.escaped) {
              const lookaheadToken = this.lookaheadToken();
              if (lookaheadToken.type === 'Character') {
                // Skip dash
                this.nextToken();

                let end = this.parseCharacter();

                const loc = this.finishLoc(startPos);

                if (start.type === 'RegExpCharacter' && end.type === 'RegExpCharacter' &&
                  ___R$$priv$project$rome$$romejs$codec$js$regexp$index_ts$getCodePoint(end.value) < ___R$$priv$project$rome$$romejs$codec$js$regexp$index_ts$getCodePoint(start.value)) {
                  this.addDiagnostic(
                    {
                      message: 'Range values reversed. Start char code is greater than end char code',
                      loc,
                    },
                  );
                  const _end = end;
                  end = start;
                  start = _end;
                }

                return (
                  {
                    type: 'RegExpCharSetRange',
                    loc,
                    start,
                    end,
                  }
                );
              }
            }

            return start;
          }

          parseDigits() {
            let digits = '';
            let token = this.getToken();
            while (token.type === 'Character' && ___R$project$rome$$romejs$parser$core$index_ts$isDigit(token.value)) {
              digits += token.value;
              token = this.nextToken();
            }

            if (digits.length === 0) {
              return undefined;
            } else {
              return Number(digits);
            }
          }

          parseQuantifier() {
            if (this.eatOperator('?')) {
              return (
                {
                  min: 0,
                  max: 1,
                }
              );
            }

            if (this.eatOperator('*')) {
              return (
                {
                  min: 0,
                  max: undefined,
                }
              );
            }

            if (this.eatOperator('+')) {
              return (
                {
                  min: 1,
                  max: undefined,
                }
              );
            }

            if (this.matchOperator('{')) {
              const snapshot = this.save();

              this.nextToken();

              const min = this.parseDigits();

              if (min !== undefined) {
                const nextToken = this.getToken();
                if (nextToken.type === 'Character' && nextToken.value === ',') {
                  this.nextToken();
                  const max = this.parseDigits();

                  const endToken = this.getToken();
                  if (endToken.type === 'Operator' && endToken.value === '}') {
                    return (
                      {
                        min,
                        max,
                      }
                    );
                  }
                } else if (nextToken.type === 'Operator' && nextToken.value === '}') {
                  return (
                    {
                      min,
                      max: min,
                    }
                  );
                }
              }

              this.restore(snapshot);
            }
          }

          parseBodyItem() {
            const start = this.getPosition();

            const prefix = this.parseBodyItemPrefix();
            if (prefix === undefined) {
              return undefined;
            }

            let target = prefix;

            while (true) {
              const quantifier = this.parseQuantifier();
              if (quantifier === undefined) {
                break;
              }

              const lazy = this.eatOperator('?');

              const quantified = Object.assign(
                {
                  type: 'RegExpQuantified',
                  loc: this.finishLoc(start),
                  target,
                  lazy,
                },
                quantifier,
              );

              target = quantified;
            }

            return target;
          }

          parseOperator(token) {
            switch (token.value) {
              case '$':
                this.nextToken();
                return (
                  {
                    type: 'RegExpEndCharacter',
                    loc: this.finishLocFromToken(token),
                  }
                );

              case '^':
                this.nextToken();
                return (
                  {
                    type: 'RegExpStartCharacter',
                    loc: this.finishLocFromToken(token),
                  }
                );

              case '.':
                this.nextToken();
                return (
                  {
                    type: 'RegExpAnyCharacter',
                    loc: this.finishLocFromToken(token),
                  }
                );

              case '[':
                return this.parseCharSet();

              case '(':
                return this.parseGroupCapture();

              case ')':
                this.nextToken();
                this.addDiagnostic(
                  {
                    message: 'Unopened group',
                    token,
                  },
                );
                return;

              case '?':
              case '*':
              case '+':
                this.nextToken();
                this.addDiagnostic(
                  {
                    message: 'Invalid target for quantifier',
                    token,
                  },
                );
                return;

              case ']':
              case '}':
                return this.parseCharacter();
            }
          }

          parseBodyItemPrefix() {
            const token = this.getToken();

            switch (token.type) {
              case 'Operator':
                return this.parseOperator(token);

              case 'EscapedCharacter':
              case 'Character':
                return this.parseCharacter();
            }

            this.addDiagnostic(
              {
                message: 'Unknown regex part',
                token,
              },
            );
          }

          parseExpression(whileCallback) {
            const alternations = [];
            let body = [];

            const start = this.getPosition();
            let alternateStart = start;

            while (!this.matchToken('EOF') &&
              (whileCallback === undefined ||
              whileCallback())) {
              if (this.eatOperator('|')) {
                alternations.push(
                  {
                    start: alternateStart,
                    end: this.getPosition(),
                    body,
                  },
                );
                alternateStart = this.getPosition();
                body = [];
                continue;
              }

              const part = this.parseBodyItem();
              if (part !== undefined) {
                body.push(part);
              }
            }

            alternations.push(
              {
                body,
                start: alternateStart,
                end: this.getPosition(),
              },
            );

            let expression;

            while (alternations.length > 0) {
              const alternation = alternations.shift();
              if (alternation === undefined) {
                throw new Error('Impossible. We check it above.');
              }

              const sub = {
                type: 'RegExpSubExpression',
                body: alternation.body,
                loc: this.finishLocAt(alternation.start, alternation.end),
              };

              if (expression === undefined) {
                expression = sub;
              } else {
                const alternationNode = {
                  type: 'RegExpAlternation',
                  left: expression,
                  right: sub,
                  loc: this.finishLocAt(this.getLoc(expression).start, alternation.end),
                };

                expression = alternationNode;
              }
            }

            if (expression === undefined) {
              throw (
                new Error(
                  'Impossible. We should always have at least one alternation that will set this.',
                )
              );
            }

            return expression;
          }

          parse() {
            return (
              {
                expression: this.parseExpression(),
                diagnostics: this.diagnostics,
              }
            );
          }
        }

        return (
          RegExpParser
        );
      })(),
  );

  // project-rome/@romejs/js-parser/parser/expression.ts
const ___R$project$rome$$romejs$js$parser$parser$expression_ts = {
    checkPropClash: ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkPropClash,
    parseExpression: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression,
    parseMaybeAssign: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign,
    parseMaybeConditional: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeConditional,
    tryParseConditionalConsequent: ___R$project$rome$$romejs$js$parser$parser$expression_ts$tryParseConditionalConsequent,
    parseConditional: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseConditional,
    forwardNoArrowParamsConversionAt: ___R$project$rome$$romejs$js$parser$parser$expression_ts$forwardNoArrowParamsConversionAt,
    parseExpressionOps: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionOps,
    parseExpressionOp: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionOp,
    parseMaybeUnary: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeUnary,
    parseExpressionWithPossibleSubscripts: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionWithPossibleSubscripts,
    parseSubscripts: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseSubscripts,
    parseExpressionSubscript: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionSubscript,
    parseTaggedTemplateExpression: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseTaggedTemplateExpression,
    checkYieldAwaitInDefaultParams: ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkYieldAwaitInDefaultParams,
    atPossibleAsync: ___R$project$rome$$romejs$js$parser$parser$expression_ts$atPossibleAsync,
    parseCallExpressionArguments: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseCallExpressionArguments,
    shouldParseAsyncArrow: ___R$project$rome$$romejs$js$parser$parser$expression_ts$shouldParseAsyncArrow,
    parseAsyncArrowFromCallExpression: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseAsyncArrowFromCallExpression,
    parseNoCallExpr: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseNoCallExpr,
    parseExpressionAtom: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionAtom,
    parseBooleanLiteral: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBooleanLiteral,
    parseMaybePrivateName: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybePrivateName,
    parseFunctionExpressionOrMetaProperty: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseFunctionExpressionOrMetaProperty,
    parseMetaProperty: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMetaProperty,
    parseImportMetaProperty: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseImportMetaProperty,
    parseParenExpression: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenExpression,
    parseParenAndDistinguishExpression: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenAndDistinguishExpression,
    shouldParseArrow: ___R$project$rome$$romejs$js$parser$parser$expression_ts$shouldParseArrow,
    parseArrowHead: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseArrowHead,
    parseParenItem: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenItem,
    parseNew: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseNew,
    parseTemplateElement: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseTemplateElement,
    parseTemplate: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseTemplate,
    parseObjectExpression: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectExpression,
    parseObjectPattern: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPattern,
    isGetterOrSetterMethod: ___R$project$rome$$romejs$js$parser$parser$expression_ts$isGetterOrSetterMethod,
    checkGetterSetterParamCount: ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkGetterSetterParamCount,
    parseObjectMethod: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectMethod,
    parseObjectProperty: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectProperty,
    parseObjectPropertyValue: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPropertyValue,
    parseObjectPropertyKey: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPropertyKey,
    parseMethod: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMethod,
    parseArrowExpression: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseArrowExpression,
    isStrictBody: ___R$project$rome$$romejs$js$parser$parser$expression_ts$isStrictBody,
    parseFunctionBodyAndFinish: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseFunctionBodyAndFinish,
    parseFunctionBody: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseFunctionBody,
    checkFunctionNameAndParams: ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkFunctionNameAndParams,
    parseExpressionList: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionList,
    parseExpressionListNonEmpty: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionListNonEmpty,
    parseCallArgument: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseCallArgument,
    parseIdentifier: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier,
    parseBindingIdentifier: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier,
    parseReferenceIdentifier: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseReferenceIdentifier,
    toBindingIdentifier: ___R$project$rome$$romejs$js$parser$parser$expression_ts$toBindingIdentifier,
    toAssignmentIdentifier: ___R$project$rome$$romejs$js$parser$parser$expression_ts$toAssignmentIdentifier,
    toReferenceIdentifier: ___R$project$rome$$romejs$js$parser$parser$expression_ts$toReferenceIdentifier,
    toIdentifier: ___R$project$rome$$romejs$js$parser$parser$expression_ts$toIdentifier,
    createIdentifier: ___R$project$rome$$romejs$js$parser$parser$expression_ts$createIdentifier,
    parseIdentifierName: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifierName,
    checkReservedWord: ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkReservedWord,
    parseAwait: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseAwait,
    parseYield: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseYield,
    parseStringLiteral: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseStringLiteral,
    parseNumericLiteral: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseNumericLiteral,
  };
  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkPropClash(
    parser,
    prop,
    props,
  ) {
    if (prop.key.type === 'ComputedPropertyKey' || prop.type === 'ObjectMethod') {
      return undefined;
    }

    const key = prop.key.value;

    // We can only check these for collisions since they're statically known
    if (key.type !== 'Identifier' && key.type !== 'StringLiteral' &&
      key.type !==
      'NumericLiteral') {
      return;
    }

    // It is either an Identifier or a String/NumericLiteral
    const name = key.type === 'Identifier' ? key.name : String(key.value);

    if (name === '__proto__') {
      if (props.has('proto')) {
        parser.addDiagnostic(
          {
            message: 'Redefinition of __proto__ property',
            loc: key.loc,
          },
        );
      } else {
        props.add('proto');
      }
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(
    parser,
    context,
    noIn,
    refShorthandDefaultPos,
  ) {
    const startPos = parser.state.startPos;
    const expr = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, context, noIn, refShorthandDefaultPos);
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma)) {
      let expressions = [expr];
      while (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma)) {
        expressions.push(
          ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
            parser,
            context,
            noIn,
            refShorthandDefaultPos,
          ),
        );
      }

      expressions = ___R$project$rome$$romejs$js$parser$parser$lval_ts$filterSpread(parser, ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedList(parser, expressions));

      return (
        parser.finishNode(
          startPos,
          {
            type: 'SequenceExpression',
            expressions,
          },
        )
      );
    }
    return expr;
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
    parser,
    context,
    noIn,
    refShorthandDefaultPos,
    afterLeftParse,
    refNeedsArrowPos,
  ) {
    const branches = parser.createBranch();

    // Try parsing as JSX
    if ((parser.isRelational('<') || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart)) &&
      parser.shouldTokenizeJSX()) {
      branches.add(
        () => {
          return (
            ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$_parseMaybeAssign(
              parser,
              context,
              noIn,
              refShorthandDefaultPos,
              afterLeftParse,
              refNeedsArrowPos,
            )
          );
        },
        {diagnosticsPriority: 1},
      );

      // Remove `tc.j_expr` and `tc.j_oTag` from 'context added

      // by parsing `jsxTagStart` to stop the JSX plugin from

      // messing with the tokens
      const cLength = parser.state.context.length;
      if (parser.state.context[cLength - 1] === ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.jsxOpenTag) {
        parser.state.context.length -= 2;
      }
      ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.relational, '<');
    }

    // Try parsing as an arrow function with type parameters
    if (parser.isRelational('<')) {
      branches.add(
        () => {
          const start = parser.getPosition();
          const typeParameters = ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeParameters(parser);
          const arrowExpression = ___R$project$rome$$romejs$js$parser$parser$expression_ts$forwardNoArrowParamsConversionAt(
            parser,
            start,
            () =>
              ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$_parseMaybeAssign(
                parser,
                context,
                noIn,
                refShorthandDefaultPos,
                afterLeftParse,
                refNeedsArrowPos,
              ),
          );
          parser.resetStartLocationFromNode(arrowExpression, typeParameters);

          if (arrowExpression.type === 'ArrowFunctionExpression') {
            return (
              Object.assign(
                {
                },
                arrowExpression,
                {
                  typeParameters,
                },
              )
            );
          } else {
            parser.addDiagnostic(
              {
                loc: typeParameters.loc,
                message: 'Expected an arrow function after this type parameter declaration',
              },
            );
            return (
              ___R$project$rome$$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(
                parser,
                parser.createUnknownIdentifier(
                  'type params without arrow function',
                ),
              )
            );
          }
        },
      );
    }

    branches.add(
      () => {
        return (
          ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$_parseMaybeAssign(
            parser,
            context,
            noIn,
            refShorthandDefaultPos,
            afterLeftParse,
            refNeedsArrowPos,
          )
        );
      },
    );

    // Pick the branch with the least amount of errors
    return branches.pick();
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$_parseMaybeAssign(
    parser,
    context,
    noIn,
    refShorthandDefaultPos,
    afterLeftParse,
    refNeedsArrowPos,
  ) {
    const startPos = parser.state.startPos;

    if (parser.isContextual('yield')) {
      if (parser.inScope('GENERATOR')) {
        let left = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseYield(parser, noIn);
        if (afterLeftParse) {
          left = afterLeftParse(parser, left, startPos);
        }
        return left;
      } else {
        // The tokenizer will assume an expression is allowed after

        // `yield`, but this isn't that kind of yield
        parser.state.exprAllowed = false;
      }
    }

    const oldCommaAfterSpreadAt = parser.state.commaAfterSpreadAt;
    parser.state.commaAfterSpreadAt = ___R$project$rome$$romejs$ob1$index_ts$number0Neg1;

    let failOnShorthandAssign;
    if (refShorthandDefaultPos) {
      failOnShorthandAssign = false;
    } else {
      refShorthandDefaultPos = ___R$project$rome$$romejs$js$parser$utils$location_ts$createIndexTracker();
      failOnShorthandAssign = true;
    }

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL) || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name)) {
      parser.state.potentialArrowAt = parser.state.startPos.index;
    }

    let left = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeConditional(
      parser,
      context,
      noIn,
      refShorthandDefaultPos,
      refNeedsArrowPos,
    );
    if (afterLeftParse) {
      left = afterLeftParse(parser, left, startPos);
    }

    if (parser.state.tokenType.isAssign) {
      const operator = (String(parser.state.tokenValue));
      const leftPatt = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignmentPattern(parser, left, 'assignment expression');

      // reset because shorthand default was used correctly
      refShorthandDefaultPos.index = ___R$project$rome$$romejs$ob1$index_ts$number0;

      ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(parser, leftPatt, undefined, undefined, 'assignment expression');

      // We should never get patterns here...?

      //if (left.type === 'BindingArrayPattern' || left.type === 'BindingObjectPattern') {
      //  checkCommaAfterRestFromSpread(parser);

      //}
      parser.state.commaAfterSpreadAt = oldCommaAfterSpreadAt;

      parser.next();
      const right = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, 'assignment right', noIn);
      return (
        parser.finishNode(
          startPos,
          {
            type: 'AssignmentExpression',
            operator,
            left: leftPatt,
            right,
          },
        )
      );
    } else if (failOnShorthandAssign && ___R$project$rome$$romejs$ob1$index_ts$get0(refShorthandDefaultPos.index) > 0) {
      parser.unexpectedToken(
        parser.getPositionFromIndex(
          refShorthandDefaultPos.index,
        ),
      );
    }

    parser.state.commaAfterSpreadAt = oldCommaAfterSpreadAt;

    return left;
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeConditional(
    parser,
    context,
    noIn,
    refShorthandDefaultPos,
    refNeedsArrowPos,
  ) {
    const startPos = parser.state.startPos;
    const potentialArrowAt = parser.state.potentialArrowAt;
    const expr = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionOps(parser, context, noIn, refShorthandDefaultPos);

    if (expr.type === 'ArrowFunctionExpression' &&
      parser.getLoc(expr).start.index === potentialArrowAt) {
      return expr;
    }

    if (refShorthandDefaultPos && ___R$project$rome$$romejs$ob1$index_ts$get0(refShorthandDefaultPos.index) > 0) {
      return expr;
    }

    return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseConditional(parser, expr, noIn, startPos, refNeedsArrowPos);
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$tryParseConditionalConsequent(
    parser,
  ) {
    const brancher = parser.createBranch();

    brancher.add(
      () => {
        parser.state.noArrowParamsConversionAt.push(parser.state.startPos.index);
        const consequent = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, 'conditional consequent');
        parser.state.noArrowParamsConversionAt.pop();
        return (
          {
            consequent,
            failed: !parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon),
          }
        );
      },
    );

    return brancher.pick();
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseConditional(
    parser,
    expr,
    noIn,
    startPos,
    refNeedsArrowPos,
  ) {
    if (!parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question)) {
      return expr;
    }

    // This is to handle a case like this: const foo = (foo?: bar) => {};

    // We'll be called due to the `?`, and we should mark ourselves as an

    // expected arrow function if parsing as a regular conditional fails
    if (refNeedsArrowPos) {
      const branch = parser.createBranch();

      branch.add(
        () => ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$_parseConditional(parser, expr, noIn, startPos),
        {
          maxNewDiagnostics: 0,
        },
      );

      if (branch.hasBranch()) {
        return branch.pick();
      } else {
        refNeedsArrowPos.index = parser.state.startPos.index;
        return expr;
      }
    }

    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question);
    const originalNoArrowAt = parser.state.noArrowAt;
    let {consequent} = ___R$project$rome$$romejs$js$parser$parser$expression_ts$tryParseConditionalConsequent(parser);
    parser.state.noArrowAt = originalNoArrowAt;

    if (!parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      parser.addDiagnostic(
        {
          message: 'Missing conditional expression consequent separator',
        },
      );
    }

    const alternate = ___R$project$rome$$romejs$js$parser$parser$expression_ts$forwardNoArrowParamsConversionAt(
      parser,
      startPos,
      () =>
        ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
          parser,
          'conditional alternate',
          noIn,
          undefined,
          undefined,
          undefined,
        ),
    );

    return (
      parser.finishNode(
        startPos,
        {
          type: 'ConditionalExpression',
          test: expr,
          consequent,
          alternate,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$forwardNoArrowParamsConversionAt(
    parser,
    start,
    parse,
  ) {
    if (parser.state.noArrowParamsConversionAt.includes(start.index)) {
      let result;
      parser.state.noArrowParamsConversionAt.push(parser.state.startPos.index);
      result = parse();
      parser.state.noArrowParamsConversionAt.pop();
      return result;
    } else {
      return parse();
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$_parseConditional(
    parser,
    expr,
    noIn,
    startPos,
  ) {
    if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question)) {
      const test = expr;
      const consequent = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, 'conditional consequent');
      parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon);
      const alternate = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, 'conditional alternate', noIn);
      return (
        parser.finishNode(
          startPos,
          {
            type: 'ConditionalExpression',
            test,
            consequent,
            alternate,
          },
        )
      );
    }
    return expr;
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionOps(
    parser,
    context,
    noIn,
    refShorthandDefaultPos,
  ) {
    const startPos = parser.state.startPos;
    const potentialArrowAt = parser.state.potentialArrowAt;
    const expr = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeUnary(parser, context, refShorthandDefaultPos);

    if (expr.type === 'ArrowFunctionExpression' &&
      parser.getLoc(expr).start.index === potentialArrowAt) {
      return expr;
    }
    if (refShorthandDefaultPos && ___R$project$rome$$romejs$ob1$index_ts$get0(refShorthandDefaultPos.index) > 0) {
      return expr;
    }

    return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionOp(parser, context, expr, startPos, -1, noIn);
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionOp(
    parser,
    context,
    left,
    leftStartPos,
    minPrec,
    noIn = false,
  ) {
    if (___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._in.getBinop() > minPrec && !parser.hasPrecedingLineBreak() &&
      parser.isContextual('as')) {
      const _const = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSNextParseConstantContext(parser);

      let typeAnnotation;
      if (_const) {
        ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext(parser, left);
        typeAnnotation = _const;
      } else {
        typeAnnotation = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tsNextThenParseType(parser);
      }

      const node = parser.finishNode(
        leftStartPos,
        {
          type: 'TSAsExpression',
          typeAnnotation,
          expression: left,
        },
      );

      return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionOp(parser, context, node, leftStartPos, minPrec, noIn);
    }

    const prec = parser.state.tokenType.binop;
    if (prec !== undefined && (!noIn || !parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._in))) {
      if (prec > minPrec) {
        const operator = (String(parser.state.tokenValue));

        if (operator === '**' && left.type === 'UnaryExpression' &&
          !parser.isParenthesized(left)) {
          parser.addDiagnostic(
            {
              loc: left.argument.loc,
              message: 'Illegal expression. Wrap left hand side or entire exponentiation in parentheses.',
            },
          );
        }

        const op = parser.state.tokenType;
        parser.next();

        const startPos = parser.state.startPos;

        const right = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionOp(
          parser,
          context,
          ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeUnary(
            parser,
            context,
          ),
          startPos,
          op.rightAssociative ? prec - 1 : prec,
          noIn,
        );

        let node;
        if (operator === '||' || operator === '&&' || operator === '??') {
          node =
            parser.finishNode(
              leftStartPos,
              {
                type: 'LogicalExpression',
                left,
                right,
                operator,
              },
            );
        } else {
          node =
            parser.finishNode(
              leftStartPos,
              {
                type: 'BinaryExpression',
                left,
                right,
                operator,
              },
            );
        }

        return (
          ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionOp(
            parser,
            context,
            node,
            leftStartPos,
            minPrec,
            noIn,
          )
        );
      }
    }

    return left;
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeUnary(
    parser,
    context,
    refShorthandDefaultPos,
  ) {
    if (parser.isSyntaxEnabled('ts') && !parser.isSyntaxEnabled('jsx') &&
      parser.isRelational('<')) {
      return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAssertion(parser);
    }

    if (parser.isContextual('await') && parser.inScope('ASYNC')) {
      return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseAwait(parser);
    }

    if (parser.state.tokenType.prefix) {
      const start = parser.getPosition();
      const update = parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.incDec);
      const operator = (String(parser.state.tokenValue));
      const prefix = true;

      parser.next();

      const argument = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeUnary(parser, context);

      if (refShorthandDefaultPos && ___R$project$rome$$romejs$ob1$index_ts$get0(refShorthandDefaultPos.index) > 0) {
        parser.unexpectedToken(
          parser.getPositionFromIndex(
            refShorthandDefaultPos.index,
          ),
        );
      }

      if (update) {
        ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(parser, argument, undefined, undefined, 'prefix operation');
      } else if (parser.inScope('STRICT') && operator === 'delete') {
        if (argument.type === 'ReferenceIdentifier') {
          parser.addDiagnostic(
            {
              loc: argument.loc,
              message: 'Deleting local variable in strict mode',
            },
          );
        } else if (argument.type === 'MemberExpression' &&
          argument.property.value.type === 'PrivateName') {
          parser.addDiagnostic(
            {
              loc: argument.property.loc,
              message: 'Deleting a private field is not allowed',
            },
          );
        }
      }

      let node;
      if (update) {
        if (operator !== '++' && operator !== '--') {
          throw new Error('Expected ++/-- operator only for UpdateExpression');
        }

        node =
          parser.finishNode(
            start,
            {
              type: 'UpdateExpression',
              argument,
              operator,
              prefix,
            },
          );
      } else {
        if (operator === '++' || operator === '--') {
          throw new Error('BinaryExpression cannot have ++/-- operator');
        }

        node =
          parser.finishNode(
            start,
            {
              type: 'UnaryExpression',
              argument,
              operator,
              prefix,
            },
          );
      }

      return node;
    }

    const startPos = parser.state.startPos;

    let expr = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionWithPossibleSubscripts(
      parser,
      context,
      refShorthandDefaultPos,
    );
    if (refShorthandDefaultPos && ___R$project$rome$$romejs$ob1$index_ts$get0(refShorthandDefaultPos.index) > 0) {
      return expr;
    }

    while (parser.state.tokenType.postfix && !parser.canInsertSemicolon()) {
      const operator = (String(parser.state.tokenValue));
      ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(parser, expr, undefined, undefined, 'postfix operation');
      parser.next();

      const updateNode = parser.finishNode(
        startPos,
        {
          type: 'UpdateExpression',
          operator,
          prefix: false,
          argument: expr,
        },
      );
      expr = updateNode;
    }

    return expr;
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionWithPossibleSubscripts(
    parser,
    context,
    refShorthandDefaultPos,
  ) {
    const startPos = parser.state.startPos;
    const potentialArrowAt = parser.state.potentialArrowAt;
    const expr = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionAtom(parser, context, refShorthandDefaultPos);

    if (expr.type === 'ArrowFunctionExpression' &&
      parser.getLoc(expr).start.index === potentialArrowAt) {
      return expr;
    }

    if (refShorthandDefaultPos && ___R$project$rome$$romejs$ob1$index_ts$get0(refShorthandDefaultPos.index) > 0) {
      return expr;
    }

    return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseSubscripts(parser, expr, startPos);
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseSubscripts(
    parser,
    base,
    startPos,
    noCalls,
  ) {
    const maybeAsyncArrow = ___R$project$rome$$romejs$js$parser$parser$expression_ts$atPossibleAsync(parser, base);

    if (base.type === 'ReferenceIdentifier' && base.name === 'async' &&
      parser.state.noArrowAt.includes(startPos.index)) {
      const openContext = parser.expectOpening(
        ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
        ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
        'call arguments',
      );
      const callee = base;
      const {args} = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseCallExpressionArguments(parser, openContext, false);
      base =
        parser.finishNode(
          startPos,
          {
            type: 'CallExpression',
            callee,
            arguments: args,
          },
        );
    } else if (base.type === 'ReferenceIdentifier' && base.name === 'async' &&
      parser.isRelational('<')) {
      const branch = parser.createBranch();
      branch.add(() => ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseAsyncArrowWithFlowTypeParameters(parser, startPos));
      branch.add(
        () =>
          ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionSubscriptsRecursively(
            parser,
            base,
            startPos,
            noCalls,
            maybeAsyncArrow,
          ),
      );
      return branch.pick();
    }

    return (
      ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionSubscriptsRecursively(
        parser,
        base,
        startPos,
        noCalls,
        maybeAsyncArrow,
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionSubscriptsRecursively(
    parser,
    base,
    startPos,
    noCalls,
    maybeAsyncArrow,
  ) {
    const state = {
      optionalChainMember: false,
      stop: false,
    };
    do {
      base =
        ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionSubscript(
          parser,
          base,
          startPos,
          noCalls,
          state,
          maybeAsyncArrow,
        );
    } while (!state.stop);
    return base;
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionSubscript(
    parser,
    base,
    startPos,
    noCalls = false,
    state,
    maybeAsyncArrow,
  ) {
    if (!parser.hasPrecedingLineBreak() && parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bang)) {
      parser.state.exprAllowed = false;
      parser.next();

      return (
        parser.finishNode(
          startPos,
          {
            type: 'TSNonNullExpression',
            expression: base,
          },
        )
      );
    }

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.questionDot)) {
      state.optionalChainMember = true;

      if (noCalls && parser.lookaheadState().tokenType == ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL) {
        state.stop = true;
        return base;
      }

      parser.next();

      // eg: o.m?.<T>(e);
      if (parser.isRelational('<')) {
        if (noCalls) {
          state.stop = true;
          return base;
        }

        const callee = base;
        const typeArguments = ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeCallArguments(parser);
        const openContext = parser.expectOpening(
          ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
          ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
          'call arguments',
        );
        const {args} = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseCallExpressionArguments(parser, openContext, false);
        return (
          parser.finishNode(
            startPos,
            {
              type: 'OptionalCallExpression',
              arguments: args,
              callee,
              typeArguments,
            },
          )
        );
      }

      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL)) {
        const propStart = parser.getPosition();
        const openContext = parser.expectOpening(
          ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL,
          ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR,
          'computed property',
        );
        const object = base;
        const property = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(
          parser,
          'optional member expression property',
        );
        parser.expectClosing(openContext);
        return (
          parser.finishNode(
            startPos,
            {
              type: 'MemberExpression',
              object,
              property: parser.finishNode(
                propStart,
                {
                  type: 'ComputedMemberProperty',
                  optional: true,
                  value: property,
                },
              ),
            },
          )
        );
      }

      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL)) {
        const openContext = parser.expectOpening(
          ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
          ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
          'call arguments',
        );
        const callee = base;
        const {args} = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseCallExpressionArguments(parser, openContext, false);

        return (
          parser.finishNode(
            startPos,
            {
              type: 'OptionalCallExpression',
              callee,
              arguments: args,
            },
          )
        );
      }

      const object = base;
      const property = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true);

      return (
        parser.finishNode(
          startPos,
          {
            type: 'MemberExpression',
            object,
            property: {
              type: 'StaticMemberProperty',
              loc: property.loc,
              optional: true,
              value: property,
            },
          },
        )
      );
    }

    if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot)) {
      const object = base;
      const property = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybePrivateName(parser);

      return (
        parser.finishNode(
          startPos,
          {
            type: 'MemberExpression',
            object,
            property: {
              type: 'StaticMemberProperty',
              loc: property.loc,
              value: property,
            },
          },
        )
      );
    }

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL)) {
      const propStart = parser.getPosition();
      const openContext = parser.expectOpening(
        ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL,
        ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR,
        'computed property',
      );
      const object = base;
      const property = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(
        parser,
        'member expression computed property',
      );
      parser.expectClosing(openContext);

      return (
        parser.finishNode(
          startPos,
          {
            type: 'MemberExpression',
            object,
            property: parser.finishNode(
              propStart,
              {
                type: 'ComputedMemberProperty',
                value: property,
              },
            ),
          },
        )
      );
    }

    // Supports: foo<Foo>(); and foo<Foo>``;
    if (parser.isRelational('<') && ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$isTypeSystemEnabled(parser)) {
      const possibleCallExpression = parser.tryBranch(
        () => {
          const typeArguments = ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeCallArguments(parser);

          if (!noCalls && parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL)) {
            const openContext = parser.expectOpening(
              ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
              ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
              'call arguments',
            );
            const {args} = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseCallExpressionArguments(parser, openContext, false);
            const node = parser.finishNode(
              startPos,
              {
                type: 'CallExpression',
                arguments: args,
                callee: base,
                typeArguments,
              },
            );
            return node;
          }

          if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.backQuote)) {
            return (
              ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseTaggedTemplateExpression(
                parser,
                startPos,
                base,
                state,
                typeArguments,
              )
            );
          }
        },
      );

      if (possibleCallExpression !== undefined) {
        return possibleCallExpression;
      }
    }

    if (!noCalls && parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL)) {
      const oldMaybeInArrowParameters = parser.state.maybeInArrowParameters;
      const oldYieldPos = parser.state.yieldPos;
      const oldAwaitPos = parser.state.awaitPos;
      parser.state.maybeInArrowParameters = true;
      parser.state.yieldPos = ___R$project$rome$$romejs$ob1$index_ts$number0;
      parser.state.awaitPos = ___R$project$rome$$romejs$ob1$index_ts$number0;

      const openContext = parser.expectOpening(
        ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
        ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
        'call arguments',
      );
      const callee = base;

      const oldCommaAfterSpreadAt = parser.state.commaAfterSpreadAt;
      parser.state.commaAfterSpreadAt = ___R$project$rome$$romejs$ob1$index_ts$number0Neg1;

      let {args, params} = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseCallExpressionArguments(
        parser,
        openContext,
        maybeAsyncArrow,
      );

      if (maybeAsyncArrow && ___R$project$rome$$romejs$js$parser$parser$expression_ts$shouldParseAsyncArrow(parser)) {
        state.stop = true;

        ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkCommaAfterRestFromSpread(parser);

        const node = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseAsyncArrowFromCallExpression(
          parser,
          startPos,
          params === undefined ? args : params,
        );
        ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkYieldAwaitInDefaultParams(parser);
        parser.state.yieldPos = oldYieldPos;
        parser.state.awaitPos = oldAwaitPos;
        return node;
      } else {
        args = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListDeep(parser, args);

        // We keep the old value if it isn't null, for cases like

        //   (x = async(yield)) => {}
        parser.state.yieldPos = oldYieldPos || parser.state.yieldPos;
        parser.state.awaitPos = oldAwaitPos || parser.state.awaitPos;
      }

      parser.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      parser.state.commaAfterSpreadAt = oldCommaAfterSpreadAt;

      return (
        parser.finishNode(
          startPos,
          {
            type: 'CallExpression',
            callee,
            arguments: args,
          },
        )
      );
    }

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.backQuote)) {
      return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseTaggedTemplateExpression(parser, startPos, base, state);
    }

    state.stop = true;
    return base;
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseTaggedTemplateExpression(
    parser,
    startPos,
    tag,
    state,
    typeArguments,
  ) {
    if (state.optionalChainMember) {
      parser.addDiagnostic(
        {
          message: 'Tagged Template Literals are not allowed in optionalChain',
        },
      );
    }

    const quasi = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseTemplate(parser, true);
    return (
      parser.finishNode(
        startPos,
        {
          type: 'TaggedTemplateExpression',
          tag,
          quasi,
          typeArguments,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkYieldAwaitInDefaultParams(parser) {
    if (___R$project$rome$$romejs$ob1$index_ts$get0(parser.state.yieldPos) > 0 &&
      (parser.state.awaitPos === ___R$project$rome$$romejs$ob1$index_ts$number0 ||
      parser.state.yieldPos < parser.state.awaitPos)) {
      parser.addDiagnostic(
        {
          index: parser.state.yieldPos,
          message: 'Yield cannot be used as name inside a generator function',
        },
      );
    }

    if (___R$project$rome$$romejs$ob1$index_ts$get0(parser.state.awaitPos) > 0) {
      parser.addDiagnostic(
        {
          index: parser.state.awaitPos,
          message: 'Await cannot be used as name inside an async function',
        },
      );
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$atPossibleAsync(parser, base) {
    const loc = parser.getLoc(base);
    return (
      base.type === 'ReferenceIdentifier' && base.name === 'async' &&
        parser.state.lastEndPos.index === loc.end.index &&
        !parser.canInsertSemicolon() &&
        parser.getRawInput(
          loc.start.index,
          loc.end.index,
        ) ===
        'async'
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseCallExpressionArguments(
    parser,
    openContext,
    possibleAsyncArrow,
    refTrailingCommaPos,
  ) {
    let callArgs = [];
    let funcParams = [];

    let innerParenStart;
    let first = true;

    let forceAsyncArrow = false;

    while (true) {
      if (parser.match(openContext.close) || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof)) {
        parser.expectClosing(openContext);
        break;
      }

      if (first) {
        first = false;
      } else {
        if (!parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma)) {
          break;
        }

        if (parser.eat(openContext.close)) {
          break;
        }
      }

      // we need to make sure that if this is an async arrow functions, that we don't allow inner parens inside the params
      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL) && !innerParenStart) {
        innerParenStart = parser.state.startPos;
      }

      const elt = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseCallArgument(
        parser,
        'call expression argument',
        false,
        possibleAsyncArrow ? ___R$project$rome$$romejs$js$parser$utils$location_ts$createIndexTracker() : undefined,
        possibleAsyncArrow ? ___R$project$rome$$romejs$js$parser$utils$location_ts$createIndexTracker() : undefined,
        possibleAsyncArrow ? refTrailingCommaPos : undefined,
      );
      if (elt === undefined) {
        throw new Error('Expected element');
      }

      if (elt.type === 'AmbiguousFlowTypeCastExpression') {
        if (possibleAsyncArrow) {
          // Definitely needs to be an arrow
          forceAsyncArrow = true;

          if (callArgs.length > 0) {
            funcParams = callArgs.slice();
            callArgs = [];
          }

          funcParams.push(elt);
        } else {
          parser.addDiagnostic(
            {
              message: 'Function parameter type annotation? Possibly forgot curlies around an object. Possibly forgot async keyword.',
              loc: elt.loc,
            },
          );
        }
        continue;
      }

      if (funcParams.length > 0) {
        funcParams.push(elt);
      } else {
        callArgs.push(elt);
      }
    }

    if (forceAsyncArrow && !___R$project$rome$$romejs$js$parser$parser$expression_ts$shouldParseAsyncArrow(parser)) {
      parser.addDiagnostic(
        {
          message: 'Expected arrow because we are a possible async arrow and type annotated parameters were present',
        },
      );
    }

    // we found an async arrow function so let's not allow any inner parens
    if (possibleAsyncArrow && innerParenStart !== undefined &&
      ___R$project$rome$$romejs$js$parser$parser$expression_ts$shouldParseAsyncArrow(parser)) {
      parser.addDiagnostic(
        {
          start: innerParenStart,
          message: 'Inner paren inside of an async arrow function params',
        },
      );
    }

    return (
      {
        args: callArgs,
        params: funcParams.length === 0 ? undefined : funcParams,
      }
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$shouldParseAsyncArrow(parser) {
    return (
      parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon) ||
      parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow) &&
        !parser.canInsertSemicolon()
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseAsyncArrowFromCallExpression(
    parser,
    start,
    args,
  ) {
    let returnType;

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      const oldNoAnonFunctionType = parser.state.noAnonFunctionType;
      parser.state.noAnonFunctionType = true;
      returnType = ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parsePrimaryTypeAnnotation(parser);
      parser.state.noAnonFunctionType = oldNoAnonFunctionType;
    }

    const oldYield = parser.state.yieldInPossibleArrowParameters;
    parser.state.yieldInPossibleArrowParameters = undefined;
    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow);
    const node = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseArrowExpression(
      parser,
      start,
      {
        assignmentList: args,
      },
      true,
    );
    parser.state.yieldInPossibleArrowParameters = oldYield;
    return (
      Object.assign(
        {
        },
        node,
        {
          head: Object.assign(
            {
            },
            node.head,
            {
              returnType,
            },
          ),
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseNoCallExpr(
    parser,
    context,
  ) {
    const startPos = parser.state.startPos;
    return (
      ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseSubscripts(
        parser,
        ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionAtom(parser, context),
        startPos,
        true,
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionAtom(
    parser,
    context,
    refShorthandDefaultPos,
  ) {
    // If a division operator appears in an expression position, the

    // tokenizer got confused, and we force it to read a regexp instead.
    if (parser.state.tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.slash) {
      ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$readRegexp(parser);
    }

    const canBeArrow = parser.state.potentialArrowAt ===
    parser.state.startPos.index;

    // We don't want to match <! as it's the start of a HTML comment
    if (parser.isRelational('<') &&
      parser.input.charCodeAt(
        ___R$project$rome$$romejs$ob1$index_ts$get0(
          parser.state.index,
        ),
      ) !==
      ___R$project$rome$$romejs$string$charcodes$index_ts.exclamationMark) {
      // In case we encounter an lt token here it will always be the start of

      // jsx as the lt sign is not allowed in places that expect an expression
      ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart);
      return ___R$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXElement(parser);
    }

    switch (parser.state.tokenType) {
      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart:
        return ___R$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXElement(parser);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._super:
        return ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseSuper(parser);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._import:
        return ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseImportOrMetaProperty(parser);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._this:
        {
          const start = parser.getPosition();
          parser.next();
          return parser.finishNode(start, {type: 'ThisExpression'});
        }

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name:
        {
          const start = parser.getPosition();
          const containsEsc = parser.state.escapePosition !== undefined;
          const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser);

          if (!containsEsc && id.name === 'async' && parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._function) &&
            !parser.canInsertSemicolon()) {
            parser.next();
            return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionExpression(parser, start, true);
          }

          if (canBeArrow && !containsEsc && id.name === 'async' &&
            parser.match(
              ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
            )) {
            const oldYield = parser.state.yieldInPossibleArrowParameters;
            parser.state.yieldInPossibleArrowParameters = undefined;
            const params = [___R$project$rome$$romejs$js$parser$parser$expression_ts$parseReferenceIdentifier(parser)];
            parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow);
            // let foo = bar => {};
            const node = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseArrowExpression(
              parser,
              start,
              {
                assignmentList: params,
              },
              true,
            );
            parser.state.yieldInPossibleArrowParameters = oldYield;
            return node;
          }

          if (canBeArrow && !parser.canInsertSemicolon() && parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow)) {
            const oldYield = parser.state.yieldInPossibleArrowParameters;
            parser.state.yieldInPossibleArrowParameters = undefined;
            const node = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseArrowExpression(
              parser,
              start,
              {
                assignmentList: [___R$project$rome$$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(parser, id)],
              },
            );
            parser.state.yieldInPossibleArrowParameters = oldYield;
            return node;
          }

          return ___R$project$rome$$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(parser, id);
        }

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._do:
        return ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseDoExpression(parser);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.regexp:
        return ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseRegExpLiteral(parser);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.num:
        return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseNumericLiteral(parser);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bigint:
        return ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseBigIntLiteral(parser);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string:
        return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseStringLiteral(parser);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._null:
        return ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseNullLiteral(parser);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._true:
      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._false:
        return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBooleanLiteral(parser);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL:
        return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenAndDistinguishExpression(parser, context, canBeArrow);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL:
        return ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseArrayExpression(parser, refShorthandDefaultPos);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL:
        return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectExpression(parser, refShorthandDefaultPos);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._function:
        return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseFunctionExpressionOrMetaProperty(parser);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._class:
        {
          const start = parser.getPosition();
          return ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseClassExpression(parser, start);
        }

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._new:
        return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseNew(parser);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.backQuote:
        return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseTemplate(parser, false);

      default:
        {
          const start = parser.getPosition();
          parser.addDiagnostic(
            {
              message: 'Unknown start to an ' +
              context,
            },
          );
          parser.next();
          return (
            ___R$project$rome$$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(
              parser,
              parser.createUnknownIdentifier(
                context,
                start,
              ),
            )
          );
        }
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBooleanLiteral(parser) {
    const start = parser.getPosition();
    const value = parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._true);
    parser.next();
    return (
      parser.finishNode(
        start,
        {
          type: 'BooleanLiteral',
          value,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybePrivateName(parser) {
    const isPrivate = parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.hash);

    if (isPrivate) {
      const start = parser.getPosition();
      parser.next();
      parser.assertNoSpace('Unexpected space between # and identifier');
      const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true);
      return (
        parser.finishNode(
          start,
          {
            type: 'PrivateName',
            id,
          },
        )
      );
    } else {
      return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true);
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseFunctionExpressionOrMetaProperty(
    parser,
  ) {
    const start = parser.getPosition();
    parser.next();

    // We do not do parseIdentifier here because when parseFunctionExpressionOrMetaProperty

    // is called we already know that the current token is a "name" with the value "function"

    // This will improve perf a tiny little bit as we do not do validation but more importantly

    // here is that parseIdentifier will remove an item from the expression stack

    // if "function" or "class" is parsed as identifier (in objects e.g.), which should not happen here.
    const meta = ___R$project$rome$$romejs$js$parser$parser$expression_ts$createIdentifier(parser, start, 'function');

    if (parser.inScope('GENERATOR') && parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot)) {
      return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMetaProperty(parser, start, meta, 'sent');
    }

    const node = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionExpression(parser, start, false);

    if (node.type !== 'FunctionExpression') {
      throw new Error('Expected parseFunction to return a FunctionExpression');
    }

    return node;
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMetaProperty(
    parser,
    start,
    meta,
    propertyName,
  ) {
    if (meta.name === 'function' && propertyName === 'sent' &&
      !parser.isContextual(propertyName)) {
      // They didn't actually say `function.sent`, just `function.`, so a simple error would be less confusing.
      parser.unexpectedToken();
    }

    const escapePosition = parser.state.escapePosition;
    const property = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true);

    if (property.name === propertyName) {
      parser.banUnicodeEscape(escapePosition, propertyName);
    } else {
      parser.addDiagnostic(
        {
          loc: property.loc,
          message: 'The only valid meta property for ' +
          meta.name +
          ' is ' +
          meta.name +
          '.' +
          propertyName,
        },
      );
    }

    return (
      parser.finishNode(
        start,
        {
          type: 'MetaProperty',
          meta,
          property,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseImportMetaProperty(parser) {
    const start = parser.getPosition();
    const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true);
    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot);
    const node = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMetaProperty(parser, start, id, 'meta');

    if (!parser.inModule) {
      parser.addDiagnostic(
        {
          loc: node.loc,
          message: 'import.meta may appear only with \'sourceType: "module"\'',
        },
      );
    }

    return node;
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenExpression(
    parser,
    context,
  ) {
    const openContext = parser.expectOpening(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR, context);
    const val = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(parser, context);
    parser.expectClosing(openContext);
    return val;
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenAndDistinguishExpression(
    parser,
    context,
    canBeArrow,
  ) {
    if (parser.state.noArrowAt.includes(parser.state.startPos.index)) {
      canBeArrow = false;
    }

    const startPos = parser.state.startPos;

    const openContext = parser.expectOpening(
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
      'paren expression',
    );

    const oldMaybeInArrowParameters = parser.state.maybeInArrowParameters;
    const oldYieldPos = parser.state.yieldPos;
    const oldAwaitPos = parser.state.awaitPos;
    const oldYield = parser.state.yieldInPossibleArrowParameters;
    parser.state.maybeInArrowParameters = true;
    parser.state.yieldInPossibleArrowParameters = undefined;
    parser.state.yieldPos = ___R$project$rome$$romejs$ob1$index_ts$number0;
    parser.state.awaitPos = ___R$project$rome$$romejs$ob1$index_ts$number0;

    const innerStart = parser.getPosition();
    const exprList = [];
    const refShorthandDefaultPos = ___R$project$rome$$romejs$js$parser$utils$location_ts$createIndexTracker();
    const refNeedsArrowPos = ___R$project$rome$$romejs$js$parser$utils$location_ts$createIndexTracker();
    let first = true;
    let spreadStart;
    let optionalCommaStart;

    while (!parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR)) {
      if (first) {
        first = false;
      } else {
        if (!parser.expect(
          ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
          refNeedsArrowPos.index === ___R$project$rome$$romejs$ob1$index_ts$number0
            ? undefined : parser.getPositionFromIndex(refNeedsArrowPos.index),
        )) {
          break;
        }

        if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR)) {
          optionalCommaStart = parser.state.startPos;
          break;
        }
      }

      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis)) {
        const spreadNodeStartPos = parser.state.startPos;
        spreadStart = parser.state.startPos;
        exprList.push(
          ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenItem(
            parser,
            ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseSpread(parser),
            spreadNodeStartPos,
          ),
        );

        if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma) &&
          parser.lookaheadState().tokenType ===
          ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR) {
          ___R$project$rome$$romejs$js$parser$parser$lval_ts$raiseRestNotLast(parser);
          parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma);
        }
      } else {
        exprList.push(
          ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
            parser,
            context,
            false,
            refShorthandDefaultPos,
            ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenItem,
            refNeedsArrowPos,
          ),
        );
      }
    }

    const innerEnd = parser.getPosition();
    parser.expectClosing(openContext);

    parser.state.maybeInArrowParameters = oldMaybeInArrowParameters;

    const arrowStart = startPos;
    if (canBeArrow && ___R$project$rome$$romejs$js$parser$parser$expression_ts$shouldParseArrow(parser)) {
      const {valid, returnType, predicate} = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseArrowHead(parser);

      if (valid) {
        ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkYieldAwaitInDefaultParams(parser);
        parser.state.yieldPos = oldYieldPos;
        parser.state.awaitPos = oldAwaitPos;

        for (const param of exprList) {
          if (parser.isParenthesized(param)) {
            parser.addDiagnostic(
              {
                loc: param.loc,
                message: 'Function parameters can\'t be parenthesized',
              },
            );
          }
        }

        const arrow = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseArrowExpression(
          parser,
          arrowStart,
          {
            assignmentList: exprList,
          },
        );
        parser.state.yieldInPossibleArrowParameters = oldYield;
        return (
          Object.assign(
            {
            },
            arrow,
            {
              head: Object.assign(
                {
                },
                arrow.head,
                {
                  predicate,
                  returnType,
                },
              ),
            },
          )
        );
      }
    }

    parser.state.yieldInPossibleArrowParameters = oldYield;

    // We keep the old value if it isn't null, for cases like

    //   (x = (yield)) => {}
    parser.state.yieldPos = oldYieldPos || parser.state.yieldPos;
    parser.state.awaitPos = oldAwaitPos || parser.state.awaitPos;

    if (exprList.length === 0) {
      parser.addDiagnostic(
        {
          start: innerStart,
          end: innerEnd,
          message: 'Parenthesized expression didnt contain anything',
        },
      );

      exprList.push(
        ___R$project$rome$$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(
          parser,
          parser.createUnknownIdentifier(
            'empty parenthesized expression',
            innerStart,
            innerEnd,
          ),
        ),
      );
    }

    if (optionalCommaStart !== undefined) {
      parser.unexpectedToken(optionalCommaStart);
    }

    if (spreadStart !== undefined) {
      parser.unexpectedToken(spreadStart);
    }

    if (___R$project$rome$$romejs$ob1$index_ts$get0(refShorthandDefaultPos.index) > 0) {
      parser.unexpectedToken(
        parser.getPositionFromIndex(
          refShorthandDefaultPos.index,
        ),
      );
    }

    if (___R$project$rome$$romejs$ob1$index_ts$get0(refNeedsArrowPos.index) > 0) {
      parser.unexpectedToken(parser.getPositionFromIndex(refNeedsArrowPos.index));
    }

    const filterList = ___R$project$rome$$romejs$js$parser$parser$lval_ts$filterSpread(
      parser,
      ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListDeep(
        parser,
        exprList, /* isParenthesizedExpr */true,
      ),
    );

    let val = filterList[0];
    if (filterList.length > 1) {
      val =
        parser.finishNodeAt(
          innerStart,
          innerEnd,
          {
            type: 'SequenceExpression',
            expressions: filterList,
          },
        );
    }

    parser.addParenthesized(val);

    return val;
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$shouldParseArrow(parser) {
    return parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon) || !parser.canInsertSemicolon();
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseArrowHead(
    parser,
  ) {
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      const oldNoAnonFunctionType = parser.state.noAnonFunctionType;
      parser.state.noAnonFunctionType = true;

      const branch = parser.createBranch();

      branch.add(
        () => {
          const res = ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeAnnotationAndPredicate(parser);

          if (parser.canInsertSemicolon()) {
            // No semicolon insertion expected
            return;
          }

          if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow)) {
            return res;
          }
        },
      );

      if (branch.hasBranch()) {
        const typeInfo = branch.pick();
        parser.state.noAnonFunctionType = oldNoAnonFunctionType;

        if (typeInfo === undefined) {
          throw (
            new Error(
              'hasBranchResult call above should have refined this condition',
            )
          );
        }

        return (
          {
            valid: true,
            predicate: typeInfo[1],
            returnType: typeInfo[0],
          }
        );
      } else {
        parser.state.noAnonFunctionType = oldNoAnonFunctionType;
        return (
          {
            valid: false,
            predicate: undefined,
            returnType: undefined,
          }
        );
      }
    } else {
      return (
        {
          valid: parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow),
          predicate: undefined,
          returnType: undefined,
        }
      );
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenItem(
    parser,
    node,
    startPos,
  ) {
    let optional = undefined;
    if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question)) {
      optional = true;
    }

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      const typeAnnotation = ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parsePrimaryTypeAnnotation(parser);
      return (
        parser.finishNode(
          startPos,
          {
            type: 'AmbiguousFlowTypeCastExpression',
            expression: node,
            typeAnnotation,
            optional,
          },
        )
      );
    }

    if (optional) {
      return (
        parser.finishNode(
          startPos,
          {
            type: 'AmbiguousFlowTypeCastExpression',
            expression: node,
            typeAnnotation: undefined,
            optional,
          },
        )
      );
    }

    return node;
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseNew(parser) {
    const start = parser.getPosition();
    const meta = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true);

    if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot)) {
      const metaProp = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMetaProperty(parser, start, meta, 'target');

      if (!parser.inScope('NON_ARROW_FUNCTION') &&
        !parser.inScope(
          'CLASS_PROPERTY',
        )) {
        parser.addDiagnostic(
          {
            loc: metaProp.loc,
            message: 'new.target can only be used in functions or class properties',
          },
        );
      }

      return metaProp;
    }

    const callee = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseNoCallExpr(parser, 'new callee');

    if (callee.type === 'ImportCall') {
      parser.addDiagnostic(
        {
          loc: callee.loc,
          message: 'Cannot use new with import(...)',
        },
      );
    }

    const optionalMember = ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$getFirstOptionalChainMember(callee);
    if (optionalMember !== undefined) {
      const memberLoc = parser.getLoc(optionalMember);

      parser.addDiagnostic(
        {
          message: 'constructors in/after an Optional Chain are not allowed',
          advice: [
            {
              type: 'log',
              category: 'info',
              message: 'Optional chain member responsible',
            },
            {
              type: 'frame',
              filename: parser.filename,
              start: memberLoc.start,
              end: memberLoc.end,
            },
          ],
        },
      );
    }

    if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.questionDot)) {
      parser.addDiagnostic(
        {
          message: 'constructors in/after an Optional Chain are not allowed',
        },
      );
    }

    let optional = undefined;
    if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.questionDot)) {
      optional = true;
    }

    let typeArguments = undefined;
    if (___R$project$rome$$romejs$js$parser$parser$type$systems_ts$isTypeSystemEnabled(parser) && parser.isRelational('<')) {
      typeArguments = parser.tryBranch(___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeCallArguments);
    }

    let args = [];
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL)) {
      const openContext = parser.expectOpening(
        ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
        ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
        'new argument',
      );
      args =
        ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionListNonEmpty(
          parser,
          'new expression argument',
          openContext,
        );
      args = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedList(parser, args);
    } else if (parser.isSyntaxEnabled('ts') && typeArguments !== undefined) {
      parser.addDiagnostic(
        {
          message: 'In TypeScript, a new expression with type arguments must have parens',
        },
      );
    }

    return (
      parser.finishNode(
        start,
        {
          type: 'NewExpression',
          callee,
          typeArguments,
          arguments: args,
          optional,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$getFirstOptionalChainMember(
    node,
  ) {
    if (node.type === 'OptionalCallExpression') {
      return node;
    }

    if (node.type === 'MemberExpression') {
      if (node.property.optional) {
        return node;
      }

      if (node.property.type === 'StaticMemberProperty') {
        return ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$getFirstOptionalChainMember(node.object);
      }
    }
  }

  // Parse template expression.
  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseTemplateElement(
    parser,
    isTagged,
  ) {
    const start = parser.getPosition();
    const tokenValue = parser.state.tokenValue;

    if (tokenValue === undefined) {
      if (isTagged) {
        parser.state.invalidTemplateEscapePosition = undefined;
      } else {
        parser.addDiagnostic(
          {
            index: parser.state.invalidTemplateEscapePosition,
            message: 'Invalid escape sequence in template',
          },
        );
      }
    }

    const raw = parser.getRawInput(
      parser.state.startPos.index,
      parser.state.endPos.index,
    ).replace(
      /\r\n?/g,
      '\n',
    );
    const cooked = tokenValue === undefined ? raw : String(tokenValue);

    parser.next();
    const tail = parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.backQuote);
    return (
      parser.finishNode(
        start,
        {
          type: 'TemplateElement',
          raw,
          cooked,
          tail,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseTemplate(
    parser,
    isTagged,
  ) {
    const start = parser.getPosition();
    const openContext = parser.expectOpening(
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.backQuote,
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.backQuote,
      'template literal',
    );
    const expressions = [];
    let curElt = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseTemplateElement(parser, isTagged);
    const quasis = [curElt];

    while (true) {
      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof) || curElt.tail === true) {
        break;
      }

      const exprPpenContext = parser.expectOpening(
        ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dollarBraceL,
        ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
        'template expression value',
      );
      expressions.push(___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(parser, 'template expression value'));
      parser.expectClosing(exprPpenContext);

      curElt = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseTemplateElement(parser, isTagged);
      quasis.push(curElt);
    }

    parser.expectClosing(openContext);

    return (
      parser.finishNode(
        start,
        {
          type: 'TemplateLiteral',
          expressions,
          quasis,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectExpression(
    parser,
    refShorthandDefaultPos,
  ) {
    const propHash = new Set();
    let first = true;

    const start = parser.getPosition();
    const properties = [];

    const openContext = parser.expectOpening(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR, 'object');

    while (true) {
      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR) || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof)) {
        parser.expectClosing(openContext);
        break;
      }

      if (first) {
        first = false;
      } else {
        if (!parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma)) {
          break;
        }

        if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR)) {
          break;
        }
      }

      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis)) {
        const prop = Object.assign(
          {
          },
          ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseSpread(parser),
          {
            type: 'SpreadProperty',
          },
        );
        properties.push(prop);
        continue;
      }

      const start = parser.getPosition();
      let isGenerator = parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star);
      let isAsync = false;

      let key;
      let escapePosition;

      if (parser.isContextual('async')) {
        if (isGenerator) {
          parser.unexpectedToken();
        }

        const asyncId = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser);
        if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon) || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL) ||
        parser.match(
          ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
        ) ||
        parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq) ||
        parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma)) {
          key =
            {
              type: 'StaticPropertyKey',
              loc: asyncId.loc,
              value: asyncId,
            };
        } else {
          if (parser.hasPrecedingLineBreak()) {
            parser.addDiagnostic(
              {
                message: 'There shouldn\'t be any newlines between async and the rest of the function',
              },
            );
          }

          isAsync = true;
          if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star)) {
            parser.next();
            isGenerator = true;
          }
          escapePosition = parser.state.escapePosition;
          key = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPropertyKey(parser);
        }
      } else {
        escapePosition = parser.state.escapePosition;
        key = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPropertyKey(parser);
      }

      const prop = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPropertyValue(
        parser,
        {
          key,
          start,
          isGenerator,
          isAsync,
          isPattern: false,
          refShorthandDefaultPos,
          escapePosition,
        },
      );
      if (prop === undefined) {
        continue;
      }
      if (prop.type === 'BindingObjectPatternProperty') {
        throw new Error('Impossible');
      }

      ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkPropClash(parser, prop, propHash);
      properties.push(prop);
    }

    return (
      parser.finishNode(
        start,
        {
          type: 'ObjectExpression',
          properties,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPattern(
    parser,
    refShorthandDefaultPos,
  ) {
    const propHash = new Set();
    let first = true;

    const start = parser.getPosition();
    const properties = [];
    let rest;

    const openContext = parser.expectOpening(
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
      'object pattern',
    );

    let firstRestLocation = undefined;

    while (true) {
      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof) || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR)) {
        break;
      }

      if (first) {
        first = false;
      } else {
        parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma);

        if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof) || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR)) {
          break;
        }
      }

      let isGenerator = false;
      let isAsync = false;
      let start = parser.getPosition();

      if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis)) {
        const argument = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);
        rest = argument;

        if (firstRestLocation !== undefined) {
          parser.addDiagnostic(
            {
              loc: argument.loc,
              message: 'Cannot have multiple rest elements when destructuring',
            },
          );
        }

        if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR) || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof)) {
          break;
        }

        if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma) &&
          parser.lookaheadState().tokenType ===
          ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR) {
          parser.addDiagnostic(
            {
              message: 'A trailing comma is not permitted after the rest element',
            },
          );
          parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma);
          break;
        } else {
          firstRestLocation = argument.loc;
          continue;
        }
      }

      start = parser.getPosition();

      const key = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPropertyKey(parser);
      const prop = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPropertyValue(
        parser,
        {
          key,
          start,
          isGenerator,
          isAsync,
          isPattern: true,
          refShorthandDefaultPos,
          escapePosition: undefined,
        },
      );

      if (prop === undefined) {
        continue;
      }

      ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkPropClash(parser, prop, propHash);

      if (prop.type !== 'BindingObjectPatternProperty') {
        parser.addDiagnostic(
          {
            message: 'Invalid property node for object pattern',
            loc: prop.loc,
          },
        );
        continue;
      }

      properties.push(prop);
    }

    parser.expectClosing(openContext);

    if (firstRestLocation !== undefined) {
      ___R$project$rome$$romejs$js$parser$parser$lval_ts$raiseRestNotLast(parser, firstRestLocation);
    }

    return (
      parser.finishNode(
        start,
        {
          type: 'BindingObjectPattern',
          properties,
          rest,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$isGetterOrSetterMethod(
    parser,
    key,
    // `key` is always from `name.key`, we just need it here to refine
    keyVal,
    isPattern,
  ) {
    return (
      !isPattern && key.type === 'StaticPropertyKey' &&
        keyVal.type ===
        'Identifier' &&
        (keyVal.name === 'get' || keyVal.name === 'set') &&
        (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string) ||
        // get "string"() {}
        parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.num) ||
        // get 1() {}
        parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL) ||
        // get ["string"]() {}
        parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name) ||
        // get foo() {}
        !!parser.state.tokenType.keyword) // get debugger() {}

    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkGetterSetterParamCount(
    parser,
    method,

    kind,
  ) {
    const head = method.type === 'FlowFunctionTypeAnnotation'
      ? method : method.head;

    if (kind === 'get') {
      if (head.rest !== undefined || head.params.length !== 0) {
        parser.addDiagnostic(
          {
            loc: method.loc,
            message: 'getter should have no parameters',
          },
        );
      }
    } else if (kind === 'set') {
      if (head.rest !== undefined) {
        parser.addDiagnostic(
          {
            loc: head.rest.loc,
            message: 'setter function argument must not be a rest parameter',
          },
        );
      } else if (head.params.length !== 1) {
        parser.addDiagnostic(
          {
            loc: method.loc,
            message: 'setter should have exactly one param',
          },
        );
      }
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectMethod(
    parser,
    {
      key,
      start,
      isGenerator,
      isAsync,
      isPattern,
      escapePosition,
    },
  ) {
    if (isAsync || isGenerator || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL)) {
      if (isPattern) {
        parser.addDiagnostic(
          {
            message: 'Object methods aren\'t allowed in object patterns',
          },
        );
      }

      const partial = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMethod(
        parser,
        {
          kind: 'method',
          isClass: false,
          isGenerator,
          isAsync,
          isConstructor: false,
        },
      );

      const {body} = partial;
      if (body === undefined || body.type !== 'BlockStatement') {
        throw new Error('Expected body');
      }

      return (
        parser.finishNode(
          start,
          Object.assign(
            {
            },
            partial,
            {
              body,
              key,
              type: 'ObjectMethod',
              kind: 'method',
            },
          ),
        )
      );
    }

    if (___R$project$rome$$romejs$js$parser$parser$expression_ts$isGetterOrSetterMethod(parser, key, key.value, isPattern)) {
      if (isAsync) {
        parser.addDiagnostic(
          {
            message: 'An object setter/getter can\'t be async',
          },
        );
      }

      if (isGenerator) {
        parser.addDiagnostic(
          {
            message: 'An object setter/getter can\'t be a generator',
          },
        );
      }

      const kind = key.value.name;
      if (kind !== 'get' && kind !== 'set') {
        throw (
          new Error(
            'Name should be get or set as we already validated it as such',
          )
        );
      }
      parser.banUnicodeEscape(escapePosition, kind);

      const newKey = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPropertyKey(parser);

      const partial = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMethod(
        parser,
        {
          kind,
          isClass: false,
          isGenerator: false,
          isAsync: false,
          isConstructor: false,
        },
      );

      const {body, head} = partial;
      if (body === undefined || body.type !== 'BlockStatement') {
        throw new Error('Expected body');
      }

      const method = parser.finishNode(
        start,
        {
          head,
          body,
          key: newKey,
          type: 'ObjectMethod',
          kind,
        },
      );
      ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkGetterSetterParamCount(parser, method, method.kind);
      return method;
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectProperty(
    parser,
    key,
    start,
    isPattern,
    refShorthandDefaultPos,
  ) {
    if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      if (isPattern) {
        const value = ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseMaybeDefault(parser);
        return (
          parser.finishNode(
            start,
            {
              key,
              type: 'BindingObjectPatternProperty',
              value,
            },
          )
        );
      } else {
        const value = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
          parser,
          'object property value',
          false,
          refShorthandDefaultPos,
        );
        return (
          parser.finishNode(
            start,
            {
              key,
              type: 'ObjectProperty',
              value,
            },
          )
        );
      }
    }

    if (key.type === 'StaticPropertyKey' && key.value.type === 'Identifier') {
      ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkReservedWord(
        parser,
        key.value.name,
        parser.getLoc(key.value),
        true,
        true,
      );

      if (isPattern) {
        let value = ___R$project$rome$$romejs$js$parser$parser$expression_ts$toBindingIdentifier(
          parser,
          parser.cloneNode(key.value),
        );

        if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq) && refShorthandDefaultPos) {
          if (refShorthandDefaultPos.index === ___R$project$rome$$romejs$ob1$index_ts$number0) {
            refShorthandDefaultPos.index = parser.state.startPos.index;
          }

          value = ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseMaybeDefault(parser, start, value);
        }

        return (
          parser.finishNode(
            start,
            {
              type: 'BindingObjectPatternProperty',
              key,
              value,
            },
          )
        );
      }

      return (
        parser.finishNode(
          start,
          {
            type: 'ObjectProperty',
            key,
            value: ___R$project$rome$$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(parser, parser.cloneNode(key.value)),
          },
        )
      );
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPropertyValue(
    parser,
    {
      key,
      start,
      isGenerator,
      isAsync,
      isPattern,
      refShorthandDefaultPos,
      escapePosition,
    },
  ) {
    if (key.variance !== undefined) {
      parser.addDiagnostic(
        {
          loc: key.variance.loc,
          message: 'variance not allowed here',
        },
      );
    }

    // parse type parameters for object method shorthand
    let typeParameters = ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$maybeParseTypeParameters(parser);
    if (typeParameters !== undefined && !parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL)) {
      parser.unexpectedToken();
    }

    let node = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectMethod(
      parser,
      {
        key,
        start,
        isGenerator,
        isAsync,
        isPattern,
        escapePosition,
      },
    ) ||
    ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectProperty(parser, key, start, isPattern, refShorthandDefaultPos);

    if (node === undefined) {
      parser.unexpectedToken();
      return undefined;
    }

    if (typeParameters === undefined) {
      return node;
    } else {
      if (node.type === 'ObjectProperty' ||
      node.type ===
      'BindingObjectPatternProperty') {
        parser.addDiagnostic(
          {
            loc: typeParameters.loc,
            message: 'Object property cannot have type parameters',
          },
        );
        return node;
      }

      return (
        Object.assign(
          {
          },
          node,
          {
            head: Object.assign(
              {
              },
              node.head,
              {
                typeParameters,
              },
            ),
          },
        )
      );
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPropertyKey(
    parser,
  ) {
    const start = parser.getPosition();
    const variance = ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowVariance(parser);

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL)) {
      const openContext = parser.expectOpening(
        ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL,
        ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR,
        'property name',
      );

      const value = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, 'property name');
      parser.expectClosing(openContext);
      return (
        parser.finishNode(
          start,
          {
            type: 'ComputedPropertyKey',
            value,
            variance,
          },
        )
      );
    } else {
      parser.pushScope('PROPERTY_NAME', true);

      // We check if it's valid for it to be a private name when we push it.
      let value;
      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.num)) {
        value = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseNumericLiteral(parser);
      } else if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string)) {
        value = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseStringLiteral(parser);
      } else {
        value = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybePrivateName(parser);
      }

      parser.popScope('PROPERTY_NAME');

      return (
        parser.finishNode(
          start,
          {
            type: 'StaticPropertyKey',
            value,
            variance,
          },
        )
      );
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMethod(
    parser,
    opts,
  ) {
    const {kind, isClass, isGenerator, isAsync, isConstructor} = opts;

    const oldYieldPos = parser.state.yieldPos;
    const oldAwaitPos = parser.state.awaitPos;
    parser.pushScope('FUNCTION', true);
    parser.pushScope('NON_ARROW_FUNCTION');
    parser.pushScope('METHOD', kind);
    parser.pushScope('GENERATOR', isGenerator);
    parser.state.yieldPos = ___R$project$rome$$romejs$ob1$index_ts$number0;
    parser.state.awaitPos = ___R$project$rome$$romejs$ob1$index_ts$number0;

    const allowTSModifiers = isConstructor;
    const {typeParameters, rest, params} = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionParams(
      parser,
      kind,
      allowTSModifiers,
    );
    const start = parser.getPosition();
    const {body, head} = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseFunctionBodyAndFinish(
      parser,
      {
        rest,
        params,
        id: undefined,
        allowBodiless: isClass,
        isArrowFunction: false,
        isAsync,
        isGenerator,
        isMethod: true,
        start,
      },
    );

    parser.popScope('METHOD');
    parser.popScope('GENERATOR');
    parser.popScope('FUNCTION');
    parser.popScope('NON_ARROW_FUNCTION');
    parser.state.yieldPos = oldYieldPos;
    parser.state.awaitPos = oldAwaitPos;

    return (
      {
        head: Object.assign(
          {
          },
          head,
          {
            typeParameters,
          },
        ),
        body,
      }
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$createFunctionHead(
    parser,
    params,
    rest,
    opts,
  ) {
    const nonRestParams = [];

    for (const param of params) {
      switch (param.type) {
        case 'BindingIdentifier':
        case 'BindingAssignmentPattern':
        case 'BindingObjectPattern':
        case 'BindingArrayPattern':
          nonRestParams.push(param);
          break;

        default:
          throw new Error('TODO');
      }
    }

    return (
      Object.assign(
        {
          type: 'FunctionHead',
          rest,
        },
        ___R$project$rome$$romejs$js$parser$parser$statement_ts$splitFunctionParams(nonRestParams),
        opts,
      )
    );
  }

  // Parse arrow function expression.

  // If the parameters are provided, they will be converted to an assignable list.
  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseArrowExpression(
    parser,
    start,
    opts,

    isAsync = false,
  ) {
    // if we got there, it's no more "yield in possible arrow parameters";

    // it's just "yield in arrow parameters"
    if (parser.state.yieldInPossibleArrowParameters) {
      parser.addDiagnostic(
        {
          start: parser.state.yieldInPossibleArrowParameters,
          message: 'Yield cannot be used as name inside a generator function',
        },
      );
    }

    parser.pushScope('FUNCTION', true);

    const oldYieldPos = parser.state.yieldPos;
    const oldAwaitPos = parser.state.awaitPos;
    const oldMaybeInArrowParameters = parser.state.maybeInArrowParameters;
    parser.pushScope('GENERATOR', false);
    parser.state.maybeInArrowParameters = false;
    parser.state.yieldPos = ___R$project$rome$$romejs$ob1$index_ts$number0;
    parser.state.awaitPos = ___R$project$rome$$romejs$ob1$index_ts$number0;

    const headEnd = parser.getPosition();

    const {body, hasHoistedVars} = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseFunctionBody(
      parser,
      {
        id: undefined,
        allowBodiless: false,
        isArrowFunction: true,
        isMethod: false,
        isAsync,
        isGenerator: false,
        start,
      },
    );

    let params = [];
    let rest = opts.rest;

    if (opts.bindingList !== undefined) {
      params = opts.bindingList;
    }

    if (opts.assignmentList !== undefined) {
      ({params, rest} =
        ___R$project$rome$$romejs$js$parser$parser$lval_ts$toFunctionParamsBindingList(
          parser,
          opts.assignmentList,
          'arrow function parameters',
        ));
    }

    ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkFunctionNameAndParams(
      parser,
      {
        isArrowFunction: true,
        isMethod: false,
        id: undefined,
        params,
        rest,
        start,
      },
      body,
    );

    parser.popScope('GENERATOR');
    parser.popScope('FUNCTION');
    parser.state.maybeInArrowParameters = oldMaybeInArrowParameters;
    parser.state.yieldPos = oldYieldPos;
    parser.state.awaitPos = oldAwaitPos;

    return (
      parser.finishNode(
        start,
        {
          type: 'ArrowFunctionExpression',
          body,
          head: ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$createFunctionHead(
            parser,
            params,
            rest,
            {
              loc: parser.finishLocAt(start, headEnd),
              hasHoistedVars,
              async: isAsync,
            },
          ),
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$isStrictBody(parser, body) {
    if (body.type === 'BlockStatement' && body.directives !== undefined) {
      for (const directive of body.directives) {
        if (directive.value === 'use strict') {
          return true;
        }
      }
    }

    return false;
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseFunctionBodyAndFinish(
    parser,
    opts,
  ) {
    let returnType = undefined;
    let predicate;

    // For arrow functions, `parseArrow` handles the return type itself.
    if (!opts.isArrowFunction && parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      [returnType, predicate] = ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeAnnotationAndPredicate(parser);
    }

    if (opts.allowBodiless && !parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL) && parser.isLineTerminator()) {
      return (
        {
          head: ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$createFunctionHead(
            parser,
            opts.params,
            opts.rest,
            {
              loc: parser.finishLoc(opts.start),
              hasHoistedVars: false,
              generator: opts.isGenerator,
              async: opts.isAsync,
              returnType,
              predicate,
            },
          ),
          body: undefined,
        }
      );
    }

    const headEnd = parser.getPosition();

    const {body, hasHoistedVars} = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseFunctionBody(parser, opts);

    const head = ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$createFunctionHead(
      parser,
      opts.params,
      opts.rest,
      {
        loc: parser.finishLocAt(opts.start, headEnd),
        generator: opts.isGenerator,
        async: opts.isAsync,
        hasHoistedVars: false,
        returnType,
        predicate,
      },
    );

    ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkFunctionNameAndParams(
      parser,
      {
        isArrowFunction: opts.isArrowFunction,
        isMethod: opts.isMethod,
        id: opts.id,
        start: opts.start,
        params: opts.params,
        rest: opts.rest,
      },
      body,
    );

    head.hasHoistedVars = hasHoistedVars;

    return (
      {
        head,
        body,
      }
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseFunctionBody(
    parser,
    opts,
  ) {
    if (opts.isArrowFunction) {
      return (
        ___R$project$rome$$romejs$js$parser$parser$expression_ts$forwardNoArrowParamsConversionAt(
          parser,
          opts.start,
          () =>
            ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$_parseFunctionBody(parser, opts),
        )
      );
    } else {
      return ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$_parseFunctionBody(parser, opts);
    }
  }

  // Parse function body and check parameters.
  function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$_parseFunctionBody(
    parser,
    opts,
  ) {
    const {isArrowFunction, isAsync, isGenerator} = opts;

    const isExpression = isArrowFunction && !parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL);

    parser.pushScope('PARAMETERS', false);
    parser.pushScope('ASYNC', isAsync);

    let hasHoistedVars = false;
    let body;
    if (isExpression) {
      body = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, 'function body');
    } else {
      // Start a new scope with regard to labels and the `inGenerator`

      // flag (restore them to their old value afterwards).
      const oldLabels = parser.state.labels;
      parser.pushScope('GENERATOR', isGenerator);
      parser.state.labels = [];

      const oldhasHoistedVars = parser.state.hasHoistedVars;
      parser.state.hasHoistedVars = false;

      body = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlock(parser, true);
      hasHoistedVars = parser.state.hasHoistedVars;

      parser.popScope('GENERATOR');

      parser.state.hasHoistedVars = oldhasHoistedVars;
      parser.state.labels = oldLabels;
    }

    parser.popScope('ASYNC');
    parser.popScope('PARAMETERS');

    return {body, hasHoistedVars};
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkFunctionNameAndParams(
    parser,
    opts,
    body,
    force,
  ) {
    const {isArrowFunction, isMethod, id, rest, params, start} = opts;

    if (!___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$isSimpleParamList(params, rest) && body.type === 'BlockStatement' &&
      body.directives !== undefined) {
      const firstDirective = body.directives[0];
      if (firstDirective !== undefined && firstDirective.value === 'use strict') {
        parser.addDiagnostic(
          {
            loc: firstDirective.loc,
            message: 'Illegal \'use strict\' directive in function with non-simple parameter list',
          },
        );
      }
    }

    if (isArrowFunction && force !== true &&
      parser.state.noArrowParamsConversionAt.includes(start.index)) {
      return undefined;
    }

    // If this is a strict mode function, verify that argument names

    // are not repeated, and it does not try to bind the words `eval`
    const _isStrictBody = ___R$project$rome$$romejs$js$parser$parser$expression_ts$isStrictBody(parser, body);
    const isStrict = parser.inScope('STRICT') || _isStrictBody;

    const isSimpleParams = ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$isSimpleParamList(params, rest);
    const shouldCheckLVal = isStrict || isArrowFunction || isMethod ||
    !isSimpleParams;

    parser.pushScope('STRICT', isStrict);

    if (shouldCheckLVal) {
      const clashes = new Map();

      if (id !== undefined) {
        ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(parser, id, true, undefined, 'function name');
      }

      for (const param of params) {
        if (_isStrictBody && param.type !== 'BindingIdentifier') {
          parser.addDiagnostic(
            {
              loc: param.loc,
              message: 'Non-simple parameter in strict mode',
            },
          );
        }
        ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(parser, param, true, clashes, 'function parameter list');
      }
    }

    parser.popScope('STRICT');
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$isSimpleParamList(
    params,
    rest,
  ) {
    if (rest !== undefined) {
      return false;
    }

    for (const param of params) {
      if (param.type !== 'BindingIdentifier') {
        return false;
      }
    }

    return true;
  }

  // Parses a comma-separated list of expressions, and returns them as

  // an array. `close` is the token type that ends the list, and

  // `allowEmpty` can be turned on to allow subsequent commas with

  // nothing in between them to be parsed as `null` (which is needed

  // for array literals).
  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionList(
    parser,
    context,
    openContext,
    allowEmpty,
    refShorthandDefaultPos,
  ) {
    const elts = [];
    let first = true;

    while (true) {
      if (parser.match(openContext.close) || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof)) {
        break;
      }

      if (first) {
        first = false;
      } else {
        parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma);

        if (parser.match(openContext.close)) {
          break;
        }
      }

      elts.push(
        ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseCallArgument(
          parser,
          context,
          allowEmpty,
          refShorthandDefaultPos,
        ),
      );
    }

    parser.expectClosing(openContext);

    return elts;
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionListNonEmpty(
    parser,
    context,
    openContext,
    refShorthandDefaultPos,
  ) {
    const val = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionList(
      parser,
      context,
      openContext,
      false,
      refShorthandDefaultPos,
    );
    // @ts-ignore: Passed allowEmpty: false above
    return val;
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseCallArgument(
    parser,
    context,
    maybeAllowEmpty,
    refShorthandDefaultPos,
    refNeedsArrowPos,
    refTrailingCommaPos,
  ) {
    const allowEmpty = Boolean(maybeAllowEmpty);

    let elt;
    if (allowEmpty && parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma)) {
      elt = undefined;
    } else if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis)) {
      const spreadNodeStart = parser.state.startPos;

      elt =
        ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenItem(
          parser,
          ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseSpread(
            parser,
            refShorthandDefaultPos,
            refNeedsArrowPos,
          ),
          spreadNodeStart,
        );

      if (refTrailingCommaPos && parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma)) {
        refTrailingCommaPos.index = parser.state.startPos.index;
      }
    } else {
      elt =
        ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
          parser,
          context,
          false,
          refShorthandDefaultPos,
          ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenItem,
          refNeedsArrowPos,
        );
    }

    return elt;
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, liberal) {
    const start = parser.getPosition();
    const name = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifierName(parser, liberal);
    return ___R$project$rome$$romejs$js$parser$parser$expression_ts$createIdentifier(parser, start, name);
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(
    parser,
    liberal,
  ) {
    return ___R$project$rome$$romejs$js$parser$parser$expression_ts$toBindingIdentifier(parser, ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, liberal));
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseReferenceIdentifier(
    parser,
    liberal,
  ) {
    return ___R$project$rome$$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(parser, ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, liberal));
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$toBindingIdentifier(
    parser,
    node,
  ) {
    return (
      parser.finalizeNode(
        Object.assign(
          {
          },
          node,
          {
            type: 'BindingIdentifier',
          },
        ),
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$toAssignmentIdentifier(
    parser,
    node,
  ) {
    return (
      parser.finalizeNode(
        Object.assign(
          {
          },
          node,
          {
            type: 'AssignmentIdentifier',
          },
        ),
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(
    parser,
    node,
  ) {
    return (
      parser.finalizeNode(
        Object.assign(
          {
          },
          node,
          {
            type: 'ReferenceIdentifier',
          },
        ),
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$toIdentifier(
    parser,
    node,
  ) {
    return (
      Object.assign(
        {
        },
        node,
        {
          type: 'Identifier',
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$createIdentifier(
    parser,
    start,
    name,
  ) {
    return (
      parser.finishNode(
        start,
        {
          type: 'Identifier',
          name,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifierName(
    parser,
    liberal = false,
  ) {
    const loc = parser.finishLocAt(parser.state.startPos, parser.state.endPos);

    if (!liberal) {
      ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkReservedWord(
        parser,
        String(parser.state.tokenValue),
        loc,
        !!parser.state.tokenType.keyword,
        false,
      );
    }

    let name;

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name)) {
      name = String(parser.state.tokenValue);
    } else if (parser.state.tokenType.keyword !== undefined) {
      name = parser.state.tokenType.keyword;

      // `class` and `function` keywords push new context into this.context.

      // But there is no chance to pop the context if the keyword is consumed

      // as an identifier such as a property name.

      // If the previous token is a dot, this does not apply because the

      // context-managing code already ignored the keyword
      if ((name === 'class' || name === 'function') &&
        (parser.state.lastEndPos.index !== ___R$project$rome$$romejs$ob1$index_ts$inc(parser.state.lastStartPos.index) ||
        parser.input.charCodeAt(___R$project$rome$$romejs$ob1$index_ts$get0(parser.state.lastStartPos.index)) !==
        ___R$project$rome$$romejs$string$charcodes$index_ts.dot)) {
        parser.state.context.pop();
      }
    } else {
      parser.addDiagnostic(
        {
          message: 'Expected an identifier here',
        },
      );
      name = '';
    }

    if (!liberal) {
      ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkReservedWord(
        parser,
        name,
        loc,
        parser.state.tokenType.keyword !==
        undefined,
        false,
      );
    }

    parser.next();
    return name;
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkReservedWord(
    parser,
    word,
    loc,
    checkKeywords,
    isBinding,
  ) {
    if (parser.isSyntaxEnabled('ts')) {
      // TypeScript support in Babel disables reserved word checking...

      // This is mostly because TS allows reserved words in certain scenarios

      // TODO we should just allow those rather than relying on this hack
      return undefined;
    }

    if (parser.inScope('GENERATOR') && word === 'yield') {
      parser.addDiagnostic(
        {
          loc,
          message: 'Can not use \'yield\' as identifier inside a generator',
        },
      );
    }

    if (parser.inScope('ASYNC') && word === 'await') {
      parser.addDiagnostic(
        {
          loc,
          message: 'Can not use keyword \'await\' outside an async function',
        },
      );
    }

    if (parser.inScope('CLASS_PROPERTY') && word === 'arguments') {
      parser.addDiagnostic(
        {
          loc,
          message: '\'arguments\' is not allowed in class field initializer',
        },
      );
    }

    if (checkKeywords && ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isKeyword(word)) {
      parser.addDiagnostic(
        {
          loc,
          message: 'Unexpected keyword \'' +
          word +
          '\'',
        },
      );
    }

    let isReserved = false;
    if (parser.inScope('STRICT')) {
      if (isBinding) {
        isReserved = ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isStrictBindReservedWord(word, parser.inModule);
      } else {
        isReserved = ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isStrictReservedWord(word, parser.inModule);
      }
    } else {
      isReserved = ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isReservedWord(word, parser.inModule);
    }

    if (isReserved) {
      if (!parser.inScope('ASYNC') && word === 'await') {
        parser.addDiagnostic(
          {
            loc,
            message: 'Can not use keyword \'await\' outside an async function',
          },
        );
      } else {
        parser.addDiagnostic(
          {
            loc,
            message: word +
            ' is a reserved word',
          },
        );
      }
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseAwait(parser) {
    if (!parser.state.awaitPos) {
      parser.state.awaitPos = parser.state.index;
    }

    if (!parser.inScope('ASYNC')) {
      parser.addDiagnostic(
        {
          message: 'Can\'t use await outside of an async function',
        },
      );
    }

    const start = parser.getPosition();
    parser.next();

    if (parser.inScope('PARAMETERS')) {
      parser.addDiagnostic(
        {
          message: 'await is not allowed in async function parameters',
        },
      );
    }

    if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star)) {
      parser.addDiagnostic(
        {
          start,
          message: 'await* has been removed from the async functions proposal. Use Promise.all() instead.',
        },
      );
    }

    const argument = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeUnary(parser, 'await argument');
    return parser.finishNode(start, {type: 'AwaitExpression', argument});
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseYield(parser, noIn) {
    if (!parser.state.yieldPos) {
      parser.state.yieldPos = parser.state.index;
    }

    const start = parser.getPosition();

    if (parser.inScope('PARAMETERS')) {
      parser.addDiagnostic(
        {
          start,
          message: 'yield is not allowed in generator parameters',
        },
      );
    }

    if (parser.state.maybeInArrowParameters &&
      // We only set yieldInPossibleArrowParameters if we haven't already

      // found a possible invalid YieldExpression.
      parser.state.yieldInPossibleArrowParameters === undefined) {
      parser.state.yieldInPossibleArrowParameters = start;
    }

    parser.next();

    let delegate;
    let argument;
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi) ||
    !parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star) &&
      !parser.state.tokenType.startsExpr ||
    parser.canInsertSemicolon()) {
      delegate = false;
    } else {
      delegate = parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star);
      argument = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, 'yield argument', noIn);
    }

    return (
      parser.finishNode(
        start,
        {
          type: 'YieldExpression',
          delegate,
          argument,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseNullLiteral(parser) {
    const start = parser.getPosition();
    parser.next();
    return parser.finishNode(start, {type: 'NullLiteral'});
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseStringLiteral(parser) {
    const start = parser.getPosition();
    const value = String(parser.state.tokenValue);
    parser.next();
    return (
      parser.finishNode(
        start,
        {
          type: 'StringLiteral',
          value,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseBigIntLiteral(parser) {
    const start = parser.getPosition();
    const value = String(parser.state.tokenValue);
    parser.next();
    return (
      parser.finishNode(
        start,
        {
          type: 'BigIntLiteral',
          value,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseNumericLiteral(parser) {
    const start = parser.getPosition();
    const value = Number(parser.state.tokenValue);
    parser.next();
    return (
      parser.finishNode(
        start,
        {
          type: 'NumericLiteral',
          value,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseRegExpLiteral(parser) {
    const start = parser.getPosition();
    const value = parser.state.tokenValue;
    if (!(value instanceof ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$RegExpTokenValue)) {
      throw new Error('Expected regex token value');
    }
    parser.next();

    const {flags, pattern} = value;

    const regexParser = ___R$project$rome$$romejs$codec$js$regexp$index_ts$createRegExpParser(
      {
        offsetPosition: Object.assign(
          {
          },
          start,
          {
            column: ___R$project$rome$$romejs$ob1$index_ts$inc(start.column),
            index: ___R$project$rome$$romejs$ob1$index_ts$inc(start.index),
          },
        ),
        path: parser.filename,
        input: pattern,
        unicode: flags.has('u'),
      },
    );

    const {diagnostics, expression} = regexParser.parse();

    for (const diagnostic of diagnostics) {
      parser.addDiagnostic(diagnostic);
    }

    return (
      parser.finishNode(
        start,
        {
          type: 'RegExpLiteral',
          expression,
          global: flags.has('g'),
          multiline: flags.has('m'),
          sticky: flags.has('y'),
          insensitive: flags.has('i'),
          noDotNewline: flags.has('s'),
          unicode: flags.has('u'),
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseImportOrMetaProperty(parser) {
    if (parser.lookaheadState().tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot) {
      return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseImportMetaProperty(parser);
    } else {
      return ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseImportCall(parser);
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseImportCall(parser) {
    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._import);

    const start = parser.getPosition();
    const openContext = parser.expectOpening(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR, 'array');

    let argument;

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR)) {
      parser.addDiagnostic(
        {
          message: 'import() requires exactly one argument',
        },
      );

      argument =
        ___R$project$rome$$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(
          parser,
          parser.createUnknownIdentifier(
            'import call argument',
          ),
        );
    } else {
      const callArg = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseCallArgument(parser, 'call expression argument', false);
      if (callArg === undefined) {
        throw (
          new Error(
            'Expected argument, parseExpressionListItem was passed maybeAllowEmpty: false',
          )
        );
      } else {
        argument = callArg;
      }
    }

    // TODO warn on multiple arguments
    if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma)) {
      parser.addDiagnostic(
        {
          start: parser.state.lastStartPos,
          end: parser.state.lastEndPos,
          message: 'Trailing comma is disallowed inside import(...) arguments',
        },
      );
    }

    if (argument.type === 'SpreadElement') {
      parser.addDiagnostic(
        {
          loc: argument.loc,
          message: 'Spread is not allowed in import()',
        },
      );
    }

    parser.expectClosing(openContext);

    const spreadOrExpression = argument.type ===
    'AmbiguousFlowTypeCastExpression'
      ? argument.expression : argument;

    const expression = spreadOrExpression.type === 'SpreadElement'
      ? spreadOrExpression.argument : spreadOrExpression;

    return parser.finishNode(start, {type: 'ImportCall', argument: expression});
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseSuper(parser) {
    if (!parser.inScope('METHOD') && !parser.inScope('CLASS_PROPERTY') &&
      parser.sourceType !== 'template') {
      parser.addDiagnostic(
        {
          message: 'super is only allowed in object methods and classes',
        },
      );
    }

    const start = parser.getPosition();
    parser.next();

    if (!parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL) && !parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL) &&
      !parser.match(
        ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot,
      )) {
      parser.addDiagnostic(
        {
          message: 'Invalid super suffix operator',
        },
      );
    }

    const loc = parser.finishLoc(start);

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL) &&
      (parser.getLastScope('METHOD') !== 'constructor' ||
      parser.getLastScope(
        'CLASS',
      ) !==
      'derived') &&
      parser.sourceType !== 'template') {
      parser.addDiagnostic(
        {
          loc,
          message: 'super() is only valid inside a class constructor of a subclass',
          advice: [
            {
              type: 'log',
              category: 'info',
              message: 'Maybe a typo in the method name (\'constructor\') or not extending another class?',
            },
          ],
        },
      );
    }

    return (
      parser.finalizeNode(
        {
          type: 'Super',
          loc,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseDoExpression(parser) {
    const start = parser.getPosition();
    parser.next();
    const oldLabels = parser.state.labels;
    parser.state.labels = [];
    parser.pushScope('FUNCTION', false);
    const body = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlock(parser, false);
    parser.popScope('FUNCTION');
    parser.state.labels = oldLabels;
    return (
      parser.finishNode(
        start,
        {
          type: 'DoExpression',
          body,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseArrayExpression(
    parser,
    refShorthandDefaultPos,
  ) {
    const start = parser.getPosition();
    const openContext = parser.expectOpening(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR, 'array');

    const elements = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListOptional(
      parser,
      ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionList(
        parser,
        'array element',
        openContext,
        true,
        refShorthandDefaultPos,
      ),
    );

    return (
      parser.finishNode(
        start,
        {
          type: 'ArrayExpression',
          elements,
        },
      )
    );
  }

  // project-rome/@romejs/js-parser/parser/lval.ts
const ___R$project$rome$$romejs$js$parser$parser$lval_ts = {
    toAssignmentPattern: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignmentPattern,
    toTargetAssignmentPattern: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern,
    toTargetBindingPattern: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetBindingPattern,
    toParamBindingPattern: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toParamBindingPattern,
    toBindingPattern: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toBindingPattern,
    toAssignmentObjectProperty: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignmentObjectProperty,
    toAssignableList: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignableList,
    toFunctionParamsBindingList: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toFunctionParamsBindingList,
    toReferencedList: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedList,
    toReferencedListOptional: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListOptional,
    toReferencedItem: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedItem,
    filterSpread: ___R$project$rome$$romejs$js$parser$parser$lval_ts$filterSpread,
    toReferencedListDeep: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListDeep,
    toReferencedListDeepOptional: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListDeepOptional,
    parseSpread: ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseSpread,
    parseTargetBindingPattern: ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseTargetBindingPattern,
    parseBindingList: ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingList,
    parseBindingListNonEmpty: ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingListNonEmpty,
    parseBindingListItem: ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingListItem,
    parseBindingListItemTypes: ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingListItemTypes,
    parseMaybeDefault: ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseMaybeDefault,
    checkLVal: ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal,
    checkToRestConversion: ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkToRestConversion,
    hasCommaAfterRest: ___R$project$rome$$romejs$js$parser$parser$lval_ts$hasCommaAfterRest,
    raiseRestNotLast: ___R$project$rome$$romejs$js$parser$parser$lval_ts$raiseRestNotLast,
    checkCommaAfterRestFromSpread: ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkCommaAfterRestFromSpread,
  };
  const ___R$$priv$project$rome$$romejs$js$parser$parser$lval_ts$VALID_REST_ARGUMENT_TYPES = ['Identifier', 'MemberExpression'];

  function ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignmentPattern(
    parser,
    node,
    contextDescription,
  ) {
    switch (node.type) {
      case 'AssignmentObjectPattern':
      case 'AssignmentArrayPattern':
      case 'AssignmentAssignmentPattern':
      case 'AssignmentObjectPatternProperty':
      case 'AssignmentIdentifier':
      case 'MemberExpression':
        return node;

      case 'AmbiguousFlowTypeCastExpression':
        return (
          ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignmentPattern(
            parser,
            ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$ambiguousTypeCastToParameter(
              parser,
              node,
            ),
            contextDescription,
          )
        );

      case 'BindingIdentifier':
      case 'ReferenceIdentifier':
        return ___R$project$rome$$romejs$js$parser$parser$expression_ts$toAssignmentIdentifier(parser, node);

      case 'TSAsExpression':
        return (
          Object.assign(
            {
            },
            node,
            {
              type: 'TSAssignmentAsExpression',
              expression: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(
                parser,
                node.expression,
                contextDescription,
              ),
            },
          )
        );

      case 'TSNonNullExpression':
        return (
          Object.assign(
            {
            },
            node,
            {
              type: 'TSAssignmentNonNullExpression',
              expression: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(
                parser,
                node.expression,
                contextDescription,
              ),
            },
          )
        );

      case 'TSTypeAssertion':
        return (
          Object.assign(
            {
            },
            node,
            {
              type: 'TSAssignmentTypeAssertion',
              expression: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(
                parser,
                node.expression,
                contextDescription,
              ),
            },
          )
        );

      case 'ObjectExpression':
        {
          const props = [];
          let rest;
          for (let index = 0;
          index < node.properties.length;
          index++) {
            const prop = node.properties[index];
            if (prop.type === 'SpreadProperty') {
              const arg = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(
                parser,
                prop.argument,
                contextDescription,
              );
              if (arg.type === 'AssignmentIdentifier') {
                rest = arg;
              } else {
                parser.addDiagnostic(
                  {
                    loc: arg.loc,
                    message: 'Invalid rest operator\'s argument',
                  },
                );
              }
              continue;
            }

            props.push(___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignmentObjectProperty(parser, prop));
          }
          return (
            {
              type: 'AssignmentObjectPattern',
              loc: node.loc,
              properties: props,
              rest,
            }
          );
        }

      case 'ArrayExpression':
        {
          const {list: elements, rest} = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignableList(
            parser,
            node.elements,
            contextDescription,
          );
          return (
            {
              type: 'AssignmentArrayPattern',
              loc: node.loc,
              elements,
              rest,
            }
          );
        }

      case 'AssignmentExpression':
        {
          if (node.operator !== '=') {
            parser.addDiagnostic(
              {
                loc: parser.getLoc(node.left),
                message: 'Only \'=\' operator can be used for specifying default value.',
              },
            );
          }

          return (
            Object.assign(
              {
              },
              node,
              {
                type: 'AssignmentAssignmentPattern',
                left: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(parser, node.left, contextDescription),
                right: node.right,
                loc: node.loc,
              },
            )
          );
        }

      default:
        {
          const message = 'Invalid left-hand side in ' +
          contextDescription +
          ' ' +
          node.type;
          parser.addDiagnostic(
            {
              loc: node.loc,
              message,
            },
          );
          return (
            ___R$project$rome$$romejs$js$parser$parser$expression_ts$toAssignmentIdentifier(
              parser,
              parser.createUnknownIdentifier(
                contextDescription,
              ),
            )
          );
        }
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(
    parser,
    node,
    contextDescription,
  ) {
    const binding = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignmentPattern(parser, node, contextDescription);

    switch (binding.type) {
      case 'AssignmentIdentifier':
      case 'AssignmentArrayPattern':
      case 'AssignmentObjectPattern':
      case 'MemberExpression':
      case 'TSAssignmentAsExpression':
      case 'TSAssignmentNonNullExpression':
      case 'TSAssignmentTypeAssertion':
        return binding;

      default:
        parser.addDiagnostic(
          {
            loc: node.loc,
            message: 'Not a valid assignment target',
          },
        );
        return (
          {
            type: 'AssignmentIdentifier',
            loc: node.loc,
            name: 'X',
          }
        );
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetBindingPattern(
    parser,
    node,
    contextDescription,
  ) {
    const binding = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toBindingPattern(parser, node, contextDescription);

    switch (binding.type) {
      case 'BindingIdentifier':
      case 'BindingArrayPattern':
      case 'BindingObjectPattern':
        return binding;

      default:
        // TODO return Unknown
        throw new Error('TODO ' +
        binding.type);
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$lval_ts$toParamBindingPattern(
    parser,
    node,
    contextDescription,
  ) {
    const binding = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toBindingPattern(parser, node, contextDescription);

    switch (binding.type) {
      case 'BindingIdentifier':
      case 'BindingArrayPattern':
      case 'BindingObjectPattern':
      case 'BindingAssignmentPattern':
        return binding;

      default:
        // TODO return Unknown
        throw new Error('TODO ' +
        binding.type);
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$lval_ts$toBindingPattern(
    parser,
    node,
    contextDescription,
  ) {
    const binding = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignmentPattern(parser, node, contextDescription);

    if (binding.type === 'MemberExpression') {
      parser.addDiagnostic(
        {
          loc: node.loc,
          message: 'Binding member expression',
        },
      );

      return (
        {
          type: 'BindingIdentifier',
          name: 'X',
          loc: node.loc,
        }
      );
    }

    switch (binding.type) {
      case 'AssignmentObjectPattern':
        {
          const newNode = Object.assign(
            {
            },
            binding,
            {
              type: 'BindingObjectPattern',
              rest: binding.rest === undefined
                ? undefined : ___R$project$rome$$romejs$js$parser$parser$expression_ts$toBindingIdentifier(
                  parser,
                  binding.rest,
                ),
              properties: binding.properties.map(
                (prop) => {
                  const bindingProp = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toBindingPattern(
                    parser,
                    prop,
                    contextDescription,
                  );

                  if (bindingProp.type !== 'BindingObjectPatternProperty') {
                    throw new Error('impossible condition');
                  }

                  return bindingProp;
                },
              ),
            },
          );
          return newNode;
        }

      case 'AssignmentAssignmentPattern':
        {
          const newNode = Object.assign(
            {
            },
            binding,
            {
              type: 'BindingAssignmentPattern',
              left: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetBindingPattern(parser, binding.left, contextDescription),
            },
          );
          return newNode;
        }

      case 'AssignmentArrayPattern':
        {
          const newNode = Object.assign(
            {
            },
            binding,
            {
              type: 'BindingArrayPattern',
              elements: binding.elements.map(
                (
                  elem,
                ) =>
                  elem === undefined
                    ? elem : ___R$project$rome$$romejs$js$parser$parser$lval_ts$toParamBindingPattern(
                      parser,
                      elem,
                      contextDescription,
                    ),
              ),
              rest: binding.rest === undefined
                ? undefined : ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetBindingPattern(
                  parser,
                  binding.rest,
                  contextDescription,
                ),
            },
          );
          return newNode;
        }

      case 'AssignmentIdentifier':
        {
          const newNode = Object.assign(
            {
            },
            binding,
            {
              type: 'BindingIdentifier',
            },
          );
          return newNode;
        }

      case 'AssignmentObjectPatternProperty':
        {
          const newNode = Object.assign(
            {
            },
            binding,
            {
              type: 'BindingObjectPatternProperty',
              value: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toBindingPattern(parser, binding.value, contextDescription),
            },
          );
          return newNode;
        }

      default:
        throw new Error('Unknown node ' +
        node.type);
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignmentObjectProperty(
    parser,
    prop,
  ) {
    switch (prop.type) {
      case 'ObjectMethod':
        {
          const error = prop.kind === 'get' || prop.kind === 'set'
            ? 'Object pattern can\'t contain getter or setter' : 'Object pattern can\'t contain methods';

          parser.addDiagnostic(
            {
              loc: prop.key.loc,
              message: error,
            },
          );

          const fakeProp = {
            type: 'AssignmentObjectPatternProperty',
            loc: prop.loc,
            key: {
              type: 'StaticPropertyKey',
              value: {
                type: 'Identifier',
                name: 'X',
                loc: prop.loc,
              },
              loc: prop.loc,
            },
            value: {
              type: 'AssignmentIdentifier',
              name: 'X',
              loc: prop.loc,
            },
          };

          return fakeProp;
        }

      case 'ObjectProperty':
        return (
          Object.assign(
            {
            },
            prop,
            {
              type: 'AssignmentObjectPatternProperty',
              value: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignmentPattern(
                parser,
                prop.value,
                'assignment object property value',
              ),
            },
          )
        );

      default:
        parser.addDiagnostic(
          {
            loc: prop.loc,
            message: 'Not a valid assignment object pattern property',
          },
        );
        return (
          {
            type: 'AssignmentObjectPatternProperty',
            loc: prop.loc,
            key: {
              type: 'StaticPropertyKey',
              loc: prop.loc,
              value: {
                type: 'Identifier',
                loc: prop.loc,
                name: 'X',
              },
            },
            value: {
              type: 'AssignmentIdentifier',
              loc: prop.loc,
              name: 'X',
            },
          }
        );
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignableList(
    parser,
    exprList,

    contextDescription,
  ) {
    const newList = [];
    let rest;

    let end = exprList.length;

    // Validate last element
    if (end > 0) {
      let last = exprList[end - 1];

      if (last !== undefined && last.type === 'SpreadElement') {
        const arg = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(
          parser,
          last.argument,
          contextDescription,
        );
        rest = arg;
        end--;
      }

      if (last !== undefined && last.type === 'AmbiguousFlowTypeCastExpression' &&
        last.expression.type === 'SpreadElement') {
        rest =
          ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$ambiguousTypeCastToParameter(
            parser,
            Object.assign(
              {
              },
              last,
              {
                expression: last.expression.argument,
              },
            ),
          );
        end--;
      }
    }

    // Turn type casts that we found in function parameter head into type annotated params
    for (let i = 0;
    i < end;
    i++) {
      const expr = exprList[i];
      if (expr === undefined) {
        continue;
      }

      if (expr.type === 'AmbiguousFlowTypeCastExpression') {
        exprList[i] = ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$ambiguousTypeCastToParameter(parser, expr);
      }

      if (expr.type === 'TSAsExpression' || expr.type === 'TSTypeAssertion') {
        parser.addDiagnostic(
          {
            loc: expr.loc,
            message: 'Unexpected type cast in parameter position',
          },
        );
      }
    }

    for (let i = 0;
    i < end;
    i++) {
      const elt = exprList[i];
      if (elt === undefined) {
        continue;
      }

      if (elt.type === 'SpreadElement') {
        ___R$project$rome$$romejs$js$parser$parser$lval_ts$raiseRestNotLast(parser, parser.getLoc(elt));
      }

      const assign = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignmentPattern(parser, elt, contextDescription);
      newList.push(assign);
    }

    return {list: newList, rest};
  }

  function ___R$project$rome$$romejs$js$parser$parser$lval_ts$toFunctionParamsBindingList(
    parser,
    exprList,
    contextDescription,
  ) {
    const bindingList = [];

    const {list: assignmentList, rest: assignmentRest} = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignableList(
      parser,
      exprList,
      contextDescription,
    );

    const bindingRest = assignmentRest === undefined
      ? assignmentRest : ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetBindingPattern(
        parser,
        assignmentRest,
        contextDescription,
      );

    for (const item of assignmentList) {
      if (item === undefined) {
        // TODO should never happen?
        continue;
      }

      if (item.type === 'AssignmentAssignmentPattern') {
        const binding = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toBindingPattern(parser, item, contextDescription);
        if (binding.type !== 'BindingAssignmentPattern') {
          throw new Error('TODO');
        }

        bindingList.push(binding);
        continue;
      }

      const binding = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetBindingPattern(parser, item, contextDescription);
      bindingList.push(binding);
    }

    return {params: bindingList, rest: bindingRest};
  }

  function ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedList(
    parser,
    exprList,
    isParenthesizedExpr,
  ) {
    for (let i = 0;
    i < exprList.length;
    i++) {
      const expr = exprList[i];
      exprList[i] =
        ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedItem(
          parser,
          expr,
          exprList.length > 1,
          isParenthesizedExpr,
        );
    }

    // @ts-ignore: We actually filtered them out
    return exprList;
  }

  function ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListOptional(
    parser,
    exprList,
    isParenthesizedExpr,
  ) {
    for (let i = 0;
    i < exprList.length;
    i++) {
      const expr = exprList[i];
      if (expr !== undefined) {
        exprList[i] =
          ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedItem(
            parser,
            expr,
            exprList.length > 1,
            isParenthesizedExpr,
          );
      }
    }

    // @ts-ignore: We actually filtered them out
    return exprList;
  }

  function ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedItem(
    parser,
    expr,
    multiple,
    isParenthesizedExpr,
  ) {
    if (expr.type !== 'AmbiguousFlowTypeCastExpression') {
      return expr;
    }

    if (parser.isSyntaxEnabled('ts')) {
      parser.addDiagnostic(
        {
          loc: expr.loc,
          message: 'Flow type cast expressions aren\'t allowed in TypeScript',
        },
      );
    }

    if (!parser.isParenthesized(expr) && (multiple || !isParenthesizedExpr)) {
      parser.addDiagnostic(
        {
          loc: expr.loc,
          message: 'The type cast expression is expected to be wrapped with parentheses',
        },
      );
    }

    if (expr.optional) {
      parser.addDiagnostic(
        {
          loc: expr.loc,
          message: 'Type cast expressions cannot be optional. Did you mean for this to be a function parameter?',
        },
      );
    }

    const {typeAnnotation, expression} = expr;

    if (typeAnnotation === undefined) {
      parser.addDiagnostic(
        {
          loc: expr.loc,
          message: 'Type cast expression has no type annotation. Did you mean for this to be a function parameter?',
        },
      );
      return expression;
    }

    if (expression.type === 'SpreadElement') {
      throw (
        new Error(
          'I don\'t think a SpreadElement is ever allowed to hit this path?',
        )
      );
    }

    const node = {
      type: 'FlowTypeCastExpression',
      loc: expr.loc,
      typeAnnotation,
      expression,
    };
    return node;
  }

  function ___R$project$rome$$romejs$js$parser$parser$lval_ts$filterSpread(
    parser,
    elems,
  ) {
    for (let i = 0;
    i < elems.length;
    i++) {
      const elem = elems[i];
      if (elem.type === 'SpreadElement') {
        parser.addDiagnostic(
          {
            message: 'Is this even ever possible?',
            loc: elem.loc,
          },
        );

        elems[i] =
          ___R$project$rome$$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(
            parser,
            parser.createUnknownIdentifier(
              'spread substitute',
            ),
          );
      }
    }
    // @ts-ignore Technically wrong but we removed all SpreadElement
    return elems;
  }

  function ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListDeep(
    parser,
    exprList,
    isParenthesizedExpr,
  ) {
    const refList = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedList(parser, exprList, isParenthesizedExpr);
    ___R$$priv$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListDeepItems(parser, refList);
    return refList;
  }

  function ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListDeepOptional(
    parser,
    exprList,
    isParenthesizedExpr,
  ) {
    const refList = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListOptional(parser, exprList, isParenthesizedExpr);
    ___R$$priv$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListDeepItems(parser, refList);
    return refList;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListDeepItems(
    parser,
    exprList,
  ) {
    for (let i = 0;
    i < exprList.length;
    i++) {
      const expr = exprList[i];
      if (expr !== undefined && expr.type === 'ArrayExpression') {
        ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListDeepOptional(parser, expr.elements);
      }
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseSpread(
    parser,
    refShorthandDefaultPos,
    refNeedsArrowPos,
  ) {
    const start = parser.getPosition();
    parser.next();

    const argument = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
      parser,
      'spread argument',
      false,
      refShorthandDefaultPos,
      undefined,
      refNeedsArrowPos,
    );

    if (___R$project$rome$$romejs$ob1$index_ts$get0(parser.state.commaAfterSpreadAt) === -1 && parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma)) {
      parser.state.commaAfterSpreadAt = parser.state.index;
    }

    return (
      parser.finishNode(
        start,
        {
          type: 'SpreadElement',
          argument,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseTargetBindingPattern(
    parser,
  ) {
    switch (parser.state.tokenType) {
      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL:
        return ___R$$priv$project$rome$$romejs$js$parser$parser$lval_ts$parseArrayPattern(parser);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL:
        return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPattern(parser, ___R$project$rome$$romejs$js$parser$utils$location_ts$createIndexTracker());
    }

    return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$lval_ts$parseArrayPattern(parser) {
    const start = parser.getPosition();
    const openContext = parser.expectOpening(
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL,
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR,
      'array pattern',
    );
    const {list: elements, rest} = ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingList(parser, openContext, true);
    return (
      parser.finishNode(
        start,
        {
          type: 'BindingArrayPattern',
          elements,
          rest,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingList(
    parser,
    openContext,
    allowEmpty = false,
    allowTSModifiers = false,
  ) {
    const elts = [];
    let rest;

    let first = true;
    while (true) {
      if (parser.match(openContext.close) || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof)) {
        parser.expectClosing(openContext);
        break;
      }

      if (first) {
        first = false;
      } else {
        if (!parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma)) {
          parser.addDiagnostic(
            {
              message: 'Expected a comma to separate items in ' +
              openContext.name,
            },
          );
          break;
        }
      }

      if (allowEmpty && parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma)) {
        elts.push(undefined);
      } else if (parser.match(openContext.close)) {
        parser.expectClosing(openContext);
        break;
      } else if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis)) {
        parser.next();

        rest =
          ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingListItemTypes(
            parser,
            parser.getPosition(),
            ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseTargetBindingPattern(parser),
          );

        if (!___R$project$rome$$romejs$js$parser$parser$lval_ts$hasCommaAfterRest(parser)) {
          parser.expectClosing(openContext);
          break;
        }
      } else {
        elts.push(___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingListItem(parser, allowTSModifiers));
      }
    }
    return {list: elts, rest};
  }

  function ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingListNonEmpty(
    parser,
    openContext,
    allowTSModifiers,
  ) {
    const list = ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingList(parser, openContext, false, allowTSModifiers);
    // @ts-ignore: Need to make this more explicit we set `allowEmpty: false` above
    return list;
  }

  function ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingListItem(
    parser,
    allowTSModifiers,
  ) {
    const start = parser.getPosition();

    let accessibility;
    let readonly = false;
    if (allowTSModifiers) {
      accessibility = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSAccessModifier(parser);
      readonly = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$hasTSModifier(parser, ['readonly']);
    }

    const left = ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingListItemTypes(
      parser,
      start,
      ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseTargetBindingPattern(parser),
    );
    const elt = ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseMaybeDefault(parser, start, left);

    if (accessibility !== undefined || readonly) {
      if (!parser.isSyntaxEnabled('ts')) {
        parser.addDiagnostic(
          {
            message: 'Accessibility and readonly syntax found but TS is not enabled',
          },
        );
      }

      if (elt.type !== 'BindingIdentifier' &&
        elt.type !==
        'BindingAssignmentPattern') {
        parser.addDiagnostic(
          {
            start,
            message: 'A parameter property may not be declared using a binding pattern.',
          },
        );
      }

      return (
        parser.finishNode(
          start,
          Object.assign(
            {
            },
            elt,
            {
              meta: parser.finishNode(
                start,
                {
                  type: 'PatternMeta',
                  accessibility,
                  readonly,
                },
              ),
            },
          ),
        )
      );
    }

    return elt;
  }

  function ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingListItemTypes(
    parser,
    start,
    param,
  ) {
    let typeAnnotation;
    let optional;

    if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question)) {
      if (param.type !== 'BindingIdentifier') {
        parser.addDiagnostic(
          {
            loc: param.loc,
            message: 'A binding pattern parameter cannot be optional in an implementation signature.',
          },
        );
      }

      optional = true;
    }

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      typeAnnotation = ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parsePrimaryTypeAnnotation(parser);
    }

    return (
      parser.finalizeNode(
        Object.assign(
          {
          },
          param,
          {
            meta: parser.finishNode(
              start,
              {
                type: 'PatternMeta',
                optional,
                typeAnnotation,
              },
            ),
          },
        ),
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseMaybeDefault(
    parser,
    start = parser.getPosition(),
    left = ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseTargetBindingPattern(parser),
  ) {
    let target;

    if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq)) {
      const right = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
        parser,
        'assignment pattern right',
      );
      const assign = parser.finishNode(
        start,
        {
          type: 'BindingAssignmentPattern',
          left,
          right,
        },
      );
      target = assign;
    } else {
      target = left;
    }

    if (target.type === 'BindingAssignmentPattern' && target.meta !== undefined &&
      target.meta.typeAnnotation !== undefined &&
      parser.getLoc(target.right).start.index <
      parser.getLoc(
        target.meta.typeAnnotation,
      ).start.index) {
      parser.addDiagnostic(
        {
          loc: target.meta.typeAnnotation.loc,
          message: 'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`',
        },
      );
    }

    return target;
  }

  const ___R$$priv$project$rome$$romejs$js$parser$parser$lval_ts$ALLOWED_PARENTHESIZED_LVAL_TYPES = [
    'Identifier',
    'MemberExpression',
    'TSAsExpression',
    'TSTypeAssertion',
    'TSAssignmentTypeAssertion',
    'TSAssignmentAsExpression',
    'TSAssignmentNonNullExpression',
  ];

  // Verify that a node is an lval  something that can be assigned

  // to.
  function ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(
    parser,
    expr,
    maybeIsBinding,
    checkClashes,
    contextDescription,
  ) {
    const isBinding = maybeIsBinding === undefined
      ? false : maybeIsBinding;

    // Verify that nodes aren't parenthesized
    if (parser.isParenthesized(expr) &&
      !___R$$priv$project$rome$$romejs$js$parser$parser$lval_ts$ALLOWED_PARENTHESIZED_LVAL_TYPES.includes(expr.type)) {
      let adviceMsg;
      if (expr.type === 'BindingObjectPattern') {
        adviceMsg = 'Did you use `({a}) = 0` instead of `({a} = 0)`?';
      } else if (expr.type === 'BindingArrayPattern') {
        adviceMsg = 'Did you use `([a]) = 0` instead of `([a] = 0)`?';
      }

      const advice = [];
      if (adviceMsg !== undefined) {
        advice.push(
          {
            type: 'log',
            category: 'info',
            message: adviceMsg,
          },
        );
      }

      parser.addDiagnostic(
        {
          message: 'Invalid parenthesized binding',
          advice,
          loc: expr.loc,
        },
      );
    }

    switch (expr.type) {
      case 'FlowTypeCastExpression':
        // Allow 'typecasts' to appear on the left of assignment expressions,

        // because it may be in an arrow function.

        // e.g. `const f = (foo: number = 0) => foo;`

        // This will be validated later
        return undefined;

      case 'TSAsExpression':
      case 'TSNonNullExpression':
      case 'TSTypeAssertion':
        ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(
          parser,
          expr.expression,
          isBinding,
          checkClashes,
          contextDescription,
        );
        return undefined;

      case 'BindingIdentifier':
      case 'ReferenceIdentifier':
      case 'AssignmentIdentifier':
        if (parser.inScope('STRICT') &&
          ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isStrictBindReservedWord(
            expr.name,
            parser.inModule,
          )) {
          parser.addDiagnostic(
            {
              loc: expr.loc,
              message: expr.name +
              ' is a reserved word',
            },
          );
        }

        if (checkClashes !== undefined) {
          const clash = checkClashes.get(expr.name);

          if (clash === undefined) {
            checkClashes.set(expr.name, expr);
          } else {
            const loc = parser.getLoc(clash);
            parser.addDiagnostic(
              {
                loc: expr.loc,
                message: 'Argument name clash in strict mode',
                advice: [
                  {
                    type: 'log',
                    category: 'info',
                    message: 'Collides with this existing definition',
                  },
                  {
                    type: 'frame',
                    filename: parser.filename,
                    start: loc.start,
                    end: loc.end,
                  },
                ],
              },
            );
          }
        }
        break;

      case 'AssignmentObjectPattern':
      case 'BindingObjectPattern':
        if (expr.rest !== undefined) {
          ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(parser, expr.rest, isBinding, checkClashes, 'rest property');
        }

        for (let prop of expr.properties) {
          if (prop.type === 'BindingObjectPatternProperty') {
            ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(
              parser,
              prop.value,
              isBinding,
              checkClashes,
              'object destructuring pattern',
            );
          } else {
            ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(
              parser,
              prop,
              isBinding,
              checkClashes,
              'object destructuring pattern',
            );
          }
        }
        break;

      case 'AssignmentObjectPatternProperty':
      case 'BindingObjectPatternProperty':
        break;

      case 'AssignmentArrayPattern':
      case 'BindingArrayPattern':
        if (expr.rest !== undefined) {
          ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(parser, expr.rest, isBinding, checkClashes, 'rest element');
        }

        for (const elem of expr.elements) {
          if (elem) {
            ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(
              parser,
              elem,
              isBinding,
              checkClashes,
              'array destructuring pattern',
            );
          }
        }
        break;

      case 'BindingAssignmentPattern':
        ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(parser, expr.left, isBinding, checkClashes, 'assignment pattern');
        break;
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkToRestConversion(
    parser,
    node,
  ) {
    if (___R$$priv$project$rome$$romejs$js$parser$parser$lval_ts$VALID_REST_ARGUMENT_TYPES.includes(node.argument.type) === false) {
      parser.addDiagnostic(
        {
          loc: node.argument.loc,
          message: 'Invalid rest operator\'s argument',
        },
      );
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$lval_ts$hasCommaAfterRest(parser) {
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma)) {
      ___R$project$rome$$romejs$js$parser$parser$lval_ts$raiseRestNotLast(parser);
      return true;
    }

    return false;
  }

  function ___R$project$rome$$romejs$js$parser$parser$lval_ts$raiseRestNotLast(
    parser,
    loc,
    start,
  ) {
    parser.addDiagnostic(
      {
        start,
        loc,
        message: 'The rest element has to be the last element when destructuring',
      },
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkCommaAfterRestFromSpread(parser) {
    if (___R$project$rome$$romejs$ob1$index_ts$get0(parser.state.commaAfterSpreadAt) > -1) {
      ___R$project$rome$$romejs$js$parser$parser$lval_ts$raiseRestNotLast(
        parser,
        undefined,
        parser.getPositionFromIndex(
          parser.state.commaAfterSpreadAt,
        ),
      );
    }
  }

  // project-rome/@romejs/js-parser/parser/jsx.ts
const ___R$project$rome$$romejs$js$parser$parser$jsx_ts = {
    parseJSXText: ___R$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXText,
    parseJSXElement: ___R$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXElement,
  };
  // Indicates whether we should create a JSXIdentifier or a JSXReferenceIdentifier
  function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$isHTMLTagName(tagName) {
    return (
      /^[a-z]|-/.test(tagName) && ___R$project$rome$$romejs$js$ast$utils$isValidIdentifierName_ts$default(tagName)
    );
  }

  // Transforms JSX element name to string.
  function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(node) {
    if (node === undefined) {
      return '';
    }

    switch (node.type) {
      case 'JSXIdentifier':
      case 'JSXReferenceIdentifier':
        return node.name;

      case 'JSXNamespacedName':
        return node.namespace.name +
        ':' +
        node.name.name;

      case 'JSXMemberExpression':
        return (
          ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(node.object) +
          '.' +
          ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(
            node.property,
          )
        );
    }
  }

  // Parse next token as JSX identifier
  function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXIdentifier(parser) {
    const start = parser.getPosition();
    let name;
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxName)) {
      name = String(parser.state.tokenValue);
    } else if (parser.state.tokenType.keyword !== undefined) {
      name = parser.state.tokenType.keyword;
    } else {
      parser.addDiagnostic(
        {
          message: 'Unknown JSX identifier token',
        },
      );
      name = '';
    }

    parser.next();
    return (
      parser.finishNode(
        start,
        {
          type: 'JSXIdentifier',
          name,
        },
      )
    );
  }

  // Parse namespaced identifier.
  function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXNamespacedName(
    parser,
  ) {
    const start = parser.getPosition();

    const namespace = ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXIdentifier(parser);
    if (!parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      return namespace;
    }

    const name = ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXIdentifier(parser);
    return (
      parser.finishNode(
        start,
        {
          type: 'JSXNamespacedName',
          name,
          namespace,
        },
      )
    );
  }

  // Parses element name in any form - namespaced, member

  // or single identifier.
  function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXElementName(parser) {
    const start = parser.getPosition();

    const namespacedName = ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXNamespacedName(parser);

    let node;
    if (namespacedName.type === 'JSXIdentifier' &&
      !___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$isHTMLTagName(
        namespacedName.name,
      )) {
      node =
        Object.assign(
          {
          },
          namespacedName,
          {
            type: 'JSXReferenceIdentifier',
          },
        );
    } else {
      node = namespacedName;
    }

    while (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot)) {
      const property = ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXIdentifier(parser);
      node =
        parser.finishNode(
          start,
          {
            type: 'JSXMemberExpression',
            object: node,
            property,
          },
        );
    }

    return node;
  }

  // Parses any type of JSX attribute value.
  function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXAttributeValue(
    parser,
  ) {
    let node;
    switch (parser.state.tokenType) {
      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL:
        node = ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXExpressionContainer(parser);
        if (node.expression.type === 'JSXEmptyExpression') {
          parser.addDiagnostic(
            {
              loc: node.loc,
              message: 'JSX attributes must only be assigned a non-empty expression',
            },
          );
        }
        return node;

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart:
        return ___R$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXElement(parser);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string:
        return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseStringLiteral(parser);

      default:
        {
          parser.addDiagnostic(
            {
              message: 'JSX value should be either an expression or a quoted JSX text',
            },
          );
          return (
            parser.finishNode(
              parser.getPosition(),
              {
                type: 'StringLiteral',
                value: '?',
              },
            )
          );
        }
    }
  }

  // JSXEmptyExpression is unique type since it doesn't actually parse anything,

  // and so it should start at the end of last read token (left brace) and finish

  // at the beginning of the next one (right brace).
  function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXEmptyExpression(parser) {
    return (
      parser.finishNode(
        parser.state.lastEndPos,
        {
          type: 'JSXEmptyExpression',
        },
      )
    );
  }

  // Parse JSX spread child
  function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXSpreadChild(parser) {
    const start = parser.getPosition();
    const openContext = parser.expectOpening(
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
      'jsx spread child',
    );
    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis);
    const expression = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(parser, 'jsx spread child expression');
    parser.expectClosing(openContext);

    return (
      parser.finishNode(
        start,
        {
          type: 'JSXSpreadChild',
          expression,
        },
      )
    );
  }

  // Parses JSX expression enclosed into curly brackets.
  function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXExpressionContainer(parser) {
    const start = parser.getPosition();
    const openContext = parser.expectOpening(
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
      'jsx expression container',
    );
    let expression;
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR)) {
      expression = ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXEmptyExpression(parser);
    } else {
      expression = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(parser, 'jsx inner expression container');
    }
    parser.expectClosing(openContext);
    return (
      parser.finishNode(
        start,
        {
          type: 'JSXExpressionContainer',
          expression,
        },
      )
    );
  }

  // Parses following JSX attribute name-value pair.
  function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXAttribute(parser) {
    const start = parser.getPosition();

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL)) {
      const openContext = parser.expectOpening(
        ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
        ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
        'jsx attribute spread',
      );
      parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis);
      const argument = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, 'jsx attribute spread');
      parser.expectClosing(openContext);
      return (
        parser.finishNode(
          start,
          {
            type: 'JSXSpreadAttribute',
            argument,
          },
        )
      );
    }

    const name = ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXNamespacedName(parser);
    const value = parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq) ? ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXAttributeValue(parser) : undefined;
    return (
      parser.finishNode(
        start,
        {
          type: 'JSXAttribute',
          name,
          value,
        },
      )
    );
  }

  // Parses JSX opening tag starting after "<".
  function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXOpeningElementAt(
    parser,
    start,
  ) {
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagEnd)) {
      parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagEnd);
      return (
        {
          typeArguments: undefined,
          name: undefined,
          loc: {
            filename: parser.filename,
            start,
            end: parser.getPosition(),
          },
          attributes: [],
          selfClosing: false,
        }
      );
    }

    const attributes = [];
    const name = ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXElementName(parser);

    let typeArguments;
    if (parser.isRelational('<')) {
      if (!parser.isSyntaxEnabled('ts')) {
        parser.addDiagnostic(
          {
            message: 'JSX element type arguments are only allowed in TS',
          },
        );
      }

      typeArguments = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeArguments(parser);
    }

    // We need to check for isRelational('>') here as the above type arguments parsing can put the tokenizer

    // into an unusual state for: <foo<bar>></foo>
    while (!parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.slash) && !parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagEnd) &&
      !parser.atEOF()) {
      attributes.push(___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXAttribute(parser));
    }
    const selfClosing = parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.slash);
    if (!parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagEnd)) {
      parser.addDiagnostic(
        {
          message: 'Unclosed JSX element open',
        },
      );
    }
    return (
      {
        typeArguments,
        name,
        attributes,
        selfClosing,
        loc: parser.getLoc(name),
      }
    );
  }

  // Parses JSX closing tag starting after "</".
  function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXClosingElementAt(
    parser,
  ) {
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagEnd)) {
      if (!parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagEnd)) {
        parser.addDiagnostic(
          {
            message: 'Unclosed JSX fragment close',
          },
        );
      }

      return undefined;
    }

    const name = ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXElementName(parser);

    if (!parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagEnd)) {
      parser.addDiagnostic(
        {
          message: 'Unclosed JSX element close',
        },
      );
    }

    return name;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$getJSXOpenElementAdvice(
    parser,
    def,
  ) {
    let message = 'Originated from this opening tag';

    if (def.name !== undefined) {
      message =
        'Originated from opening tag of <emphasis>' +
        ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(
          def.name,
        ) +
        '</emphasis>';
    }

    const {loc} = def;
    return (
      [
        {
          type: 'log',
          category: 'info',
          message,
        },
        {
          type: 'frame',
          filename: parser.filename,
          start: loc.start,
          end: loc.end,
        },
      ]
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$getJSXCloseElementAdvice(
    parser,
    name,
    loc,
  ) {
    let message;
    if (name === undefined) {
      message = 'But found a closing fragment instead';
    } else {
      message =
        'But found a closing tag of <emphasis>' +
        ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(name) +
        '</emphasis> instead';
    }

    return (
      [
        {
          type: 'log',
          category: 'info',
          message,
        },
        {
          type: 'frame',
          filename: parser.filename,
          start: loc.start,
          end: loc.end,
        },
      ]
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$recoverFromUnclosedJSX(parser) {
    // jsxOpenTag
    parser.state.context.pop();
    parser.state.exprAllowed = false;
  }

  // Parses entire JSX element, including it"s opening tag

  // (starting after "<"), attributes, contents and closing tag.
  function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXElementAt(
    parser,
    start,
  ) {
    const children = [];
    const openingDef = ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXOpeningElementAt(parser, start);

    let closingNameLoc;
    let closingName;

    // Parse children for unclosed elements
    if (openingDef.selfClosing === false) {
      contents: while (true) {
        switch (parser.state.tokenType) {
          case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart:
            {
              const start = parser.getPosition();
              parser.next();
              if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.slash)) {
                closingName = ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXClosingElementAt(parser);
                closingNameLoc =
                  {
                    filename: parser.filename,
                    start,
                    end: parser.getPosition(),
                  };
                break contents;
              }
              children.push(___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXElementAt(parser, start));
              break;
            }

          case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxText:
            children.push(___R$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXText(parser));
            break;

          case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL:
            if (parser.lookaheadState().tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis) {
              children.push(___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXSpreadChild(parser));
            } else {
              children.push(___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXExpressionContainer(parser));
            }
            break;

          case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof:
            parser.addDiagnostic(
              {
                message: 'Unclosed JSX element',
                advice: ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$getJSXOpenElementAdvice(parser, openingDef),
              },
            );
            break contents;

          default:
            parser.addDiagnostic(
              {
                message: 'Unknown JSX children start',
                advice: ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$getJSXOpenElementAdvice(parser, openingDef),
              },
            );

            // We don't need to do it for the tt.eof case above because nothing will ever be parsed after
            ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$recoverFromUnclosedJSX(parser);

            break contents;
        }
      }

      // Unclosed element, would have produced an error above but we still want to produce a valid AST and avoid the below error conditions
      if (closingNameLoc === undefined) {
        closingName = openingDef.name;
        closingNameLoc = openingDef.loc;
      }

      // Fragment open, element close
      if (openingDef.name === undefined && closingName !== undefined) {
        parser.addDiagnostic(
          {
            loc: openingDef.loc,
            message: 'Expected JSX closing fragment tag',
            advice: ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$getJSXCloseElementAdvice(parser, closingName, closingNameLoc),
          },
        );
      }

      // Element open, fragment close
      if (openingDef.name !== undefined && closingName === undefined) {
        parser.addDiagnostic(
          {
            loc: openingDef.loc,
            message: 'Expected a corresponding JSX closing tag for <emphasis>' +
            ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(
              openingDef.name,
            ) +
            '</emphasis>',
            advice: ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$getJSXCloseElementAdvice(parser, closingName, closingNameLoc),
          },
        );
      }

      // Validate element names: Element open, element close
      if (openingDef.name !== undefined && closingName !== undefined) {
        if (___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(closingName) !==
        ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(
          openingDef.name,
        )) {
          parser.addDiagnostic(
            {
              loc: openingDef.loc,
              message: 'Expected a corresponding JSX closing tag for <emphasis>' +
              ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(
                openingDef.name,
              ) +
              '</emphasis>',
              advice: ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$getJSXCloseElementAdvice(parser, closingName, closingNameLoc),
            },
          );
        }
      }
    }

    ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$checkAccidentalFragment(parser);

    const openingName = openingDef.name;
    if (openingName === undefined) {
      return (
        parser.finishNode(
          start,
          {
            type: 'JSXFragment',
            children,
          },
        )
      );
    } else {
      return (
        parser.finishNode(
          start,
          {
            type: 'JSXElement',
            name: openingName,
            typeArguments: openingDef.typeArguments,
            attributes: openingDef.attributes,
            selfClosing: openingDef.selfClosing,
            children,
          },
        )
      );
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$checkAccidentalFragment(parser) {
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.relational) && parser.state.tokenValue === '<') {
      parser.addDiagnostic(
        {
          message: 'Adjacent JSX elements must be wrapped in an enclosing tag. \n        Did you want a JSX fragment <>...</>?',
        },
      );
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXText(parser) {
    // No need to assert syntax here because we wont get that far as parseJSXElement would have already been called

    const start = parser.getPosition();
    const value = String(parser.state.tokenValue);
    parser.next();
    return (
      parser.finishNode(
        start,
        {
          type: 'JSXText',
          value,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXElement(parser) {
    // Only necessary here as this is the only JSX entry point
    if (!parser.isSyntaxEnabled('jsx')) {
      if (parser.isSyntaxEnabled('ts')) {
        parser.addDiagnostic(
          {
            message: 'JSX isn\'t allowed in regular TypeScript files',
            advice: [
              {
                type: 'log',
                category: 'info',
                message: 'Change the file extension to <emphasis>.tsx</emphasis> to enable JSX support',
              },
            ],
          },
        );
      } else {
        parser.addDiagnostic(
          {
            message: 'JSX syntax isn\'t enabled',
            advice: [
              {
                type: 'log',
                category: 'info',
                message: 'Are you using <emphasis>TypeScript</emphasis>? Change the file extension to <emphasis>.tsx</emphasis>',
              },
              {
                type: 'log',
                category: 'info',
                message: 'Are you using <emphasis>Flow</emphasis>? Add a <emphasis>@flow</emphasis> comment annotation to the top of the file',
              },
              {
                type: 'log',
                category: 'info',
                message: 'Not using either? Change the file extension to <emphasis>.jsx</emphasis>',
              },
            ],
          },
        );
      }
    }

    const start = parser.getPosition();
    parser.next();
    return ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXElementAt(parser, start);
  }

  // project-rome/@romejs/js-parser/parser/flow.ts
const ___R$project$rome$$romejs$js$parser$parser$flow_ts = {
    hasTypeImportKind: ___R$project$rome$$romejs$js$parser$parser$flow_ts$hasTypeImportKind,
    isMaybeDefaultImport: ___R$project$rome$$romejs$js$parser$parser$flow_ts$isMaybeDefaultImport,
    parseFlowTypeParameterInstantiationCallOrNew: ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterInstantiationCallOrNew,
    parseFlowTypeAndPredicateInitialiser: ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeAndPredicateInitialiser,
    parseFlowDeclare: ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowDeclare,
    parseFlowInterface: ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowInterface,
    checkReservedType: ___R$project$rome$$romejs$js$parser$parser$flow_ts$checkReservedType,
    parseFlowRestrictedIdentifier: ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowRestrictedIdentifier,
    parseFlowTypeAliasTypeAnnotation: ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeAliasTypeAnnotation,
    parseFlowOpaqueType: ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowOpaqueType,
    parseFlowTypeParameterDeclaration: ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterDeclaration,
    parseFlowTypeParameterInstantiation: ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterInstantiation,
    parseFlowTypeAnnotation: ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeAnnotation,
    parseFlowClassImplemented: ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowClassImplemented,
    parseFlowVariance: ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowVariance,
    parseAsyncArrowWithFlowTypeParameters: ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseAsyncArrowWithFlowTypeParameters,
    parseFlowObjectTypeInternalSlot: ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowObjectTypeInternalSlot,
  };
  const ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$primitiveTypes = [
    'any',
    'bool',
    'boolean',
    'empty',
    'false',
    'mixed',
    'null',
    'number',
    'bigint',
    'static',
    'string',
    'true',
    'typeof',
    'void',
    'interface',
    'extends',
    '_',
  ];

  const ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$exportSuggestions = new Map(
    [
      ['const', 'declare export var'],
      ['let', 'declare export var'],
      ['type', 'export type'],
      ['interface', 'export interface'],
    ],
  );

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$checkNotUnderscore(parser, id) {
    if (id.name === '_') {
      parser.addDiagnostic(
        {
          loc: id.loc,
          message: '`_` is only allowed as a type argument to call or new',
        },
      );
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$isEsModuleType(bodyElement) {
    return (
      bodyElement.type === 'ExportAllDeclaration' ||
      bodyElement.type ===
      'ExportLocalDeclaration' &&
        (!bodyElement.declaration ||
        bodyElement.declaration.type !== 'TypeAliasTypeAnnotation' &&
          bodyElement.declaration.type !== 'FlowInterfaceDeclaration')
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$flow_ts$hasTypeImportKind(
    kind,
  ) {
    return kind === 'type' || kind === 'typeof';
  }

  function ___R$project$rome$$romejs$js$parser$parser$flow_ts$isMaybeDefaultImport(state) {
    return (
      (state.tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name || !!state.tokenType.keyword) &&
        state.tokenValue !== 'from'
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterInstantiationCallOrNew(
    parser,
  ) {
    const start = parser.getPosition();
    const params = [];

    parser.pushScope('TYPE', true);

    if (parser.expectRelational('<')) {
      while (!parser.isRelational('>')) {
        params.push(___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeOrImplicitInstantiation(parser));

        if (!parser.isRelational('>') && !parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma)) {
          break;
        }
      }
      parser.expectRelational('>');
    }

    parser.popScope('TYPE');

    return (
      parser.finishNode(
        start,
        {
          type: 'FlowTypeParameterInstantiation',
          params,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeOrImplicitInstantiation(parser) {
    if (parser.state.tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name && parser.state.tokenValue === '_') {
      const startPos = parser.state.startPos;
      const node = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser);
      return ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowGenericType(parser, startPos, node);
    } else {
      return ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowType(parser);
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeInitialiser(
    parser,
    tok,
  ) {
    parser.pushScope('TYPE', true);
    parser.expect(tok || ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon);
    const type = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowType(parser);
    parser.popScope('TYPE');
    return type;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowPredicate(
    parser,
  ) {
    const start = parser.getPosition();
    const moduloPos = parser.state.startPos;
    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.modulo);
    const checksPos = parser.state.startPos;
    parser.expectContextual('checks');

    // Force '%' and 'checks' to be adjacent
    if (moduloPos.line !== checksPos.line ||
    ___R$project$rome$$romejs$ob1$index_ts$get0(moduloPos.column) !==
    ___R$project$rome$$romejs$ob1$index_ts$get0(
      checksPos.column,
    ) -
    1) {
      parser.addDiagnostic(
        {
          start: moduloPos,
          message: 'Spaces between \xb4%\xb4 and \xb4checks\xb4 are not allowed here.',
        },
      );
    }

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL)) {
      const openContext = parser.expectOpening(
        ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
        ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
        'flow declared predicate',
      );
      const value = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(parser, 'flow declared predicate');
      parser.expectClosing(openContext);
      return (
        parser.finishNode(
          start,
          {
            type: 'FlowDeclaredPredicate',
            value,
          },
        )
      );
    } else {
      return (
        parser.finishNode(
          start,
          {
            type: 'FlowInferredPredicate',
          },
        )
      );
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeAndPredicateInitialiser(
    parser,
  ) {
    ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$addFlowDiagnostic(
      parser,
      ' flow type and predicate initializer',
      parser.getPosition(),
    );

    parser.pushScope('TYPE', true);
    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon);
    let type = undefined;
    let predicate = undefined;
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.modulo)) {
      parser.popScope('TYPE');
      predicate = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowPredicate(parser);
    } else {
      type = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowType(parser);
      parser.popScope('TYPE');
      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.modulo)) {
        predicate = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowPredicate(parser);
      }
    }
    return [type, predicate];
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowDeclareClass(
    parser,
    start,
  ) {
    parser.next();
    return (
      parser.finishNode(
        start,
        Object.assign(
          {
          },
          ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowInterfaceish(parser, true),
          {
            type: 'FlowDeclareClass',
          },
        ),
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowDeclareFunction(
    parser,
    start,
  ) {
    parser.next();

    const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser);

    let typeParameters = undefined;
    if (parser.isRelational('<')) {
      typeParameters = ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterDeclaration(parser, true);
    }

    const openContext = parser.expectOpening(
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
      'flow function type params',
    );
    const {params, rest} = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowFunctionTypeParams(parser);
    parser.expectClosing(openContext);

    const [returnType, predicate] = ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeAndPredicateInitialiser(parser);

    parser.semicolon();

    if (predicate !== undefined && predicate.type === 'FlowInferredPredicate') {
      parser.addDiagnostic(
        {
          loc: predicate.loc,
          message: 'Predicate function declarations need to declare a predicate expression',
        },
      );
    }

    return (
      parser.finishNode(
        start,
        {
          type: 'FlowDeclareFunction',
          id: parser.finishNode(
            start,
            {
              type: 'BindingIdentifier',
              name: id.name,

              meta: parser.finishNode(
                start,
                {
                  type: 'PatternMeta',
                  typeAnnotation: parser.finishNode(
                    start,
                    {
                      type: 'FlowFunctionTypeAnnotation',
                      params,
                      rest,
                      returnType,
                      typeParameters,
                    },
                  ),
                },
              ),
            },
          ),
          predicate,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowDeclare(
    parser,
    start,
    insideModule = false,
  ) {
    ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$addFlowDiagnostic(parser, 'type declaration', start);

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._class)) {
      return ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowDeclareClass(parser, start);
    }

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._function)) {
      return ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowDeclareFunction(parser, start);
    }

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._var)) {
      return ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowDeclareVariable(parser, start);
    }

    if (parser.isContextual('module')) {
      if (parser.lookaheadState().tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot) {
        return ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowDeclareModuleExports(parser, start);
      } else {
        if (insideModule) {
          parser.addDiagnostic(
            {
              message: '`declare module` cannot be used inside another `declare module`',
            },
          );
        }
        return ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowDeclareModule(parser, start);
      }
    }

    if (parser.isContextual('type')) {
      return ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowDeclareTypeAlias(parser, start);
    }

    if (parser.isContextual('opaque')) {
      return ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowDeclareOpaqueType(parser, start);
    }

    if (parser.isContextual('interface')) {
      return ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowDeclareInterface(parser, start);
    }

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._export)) {
      return ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseExportLocalDeclaration(parser, start, insideModule);
    }

    parser.addDiagnostic(
      {
        message: 'Unknown start to Flow declaration',
      },
    );

    // Fake node
    return (
      parser.finishNode(
        start,
        {
          type: 'FlowDeclareVariable',
          id: ___R$project$rome$$romejs$js$parser$parser$expression_ts$toBindingIdentifier(
            parser,
            parser.createUnknownIdentifier(
              'flow declaration',
              start,
            ),
          ),
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowDeclareVariable(
    parser,
    start,
  ) {
    parser.next();
    const id = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeAnnotatableIdentifier(
      parser,
      /*allowPrimitiveOverride*/true,
    );
    parser.semicolon();
    return (
      parser.finishNode(
        start,
        {
          type: 'FlowDeclareVariable',
          id,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowDeclareModule(
    parser,
    start,
  ) {
    // Eat `module` token
    parser.next();

    let id;
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string)) {
      id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseStringLiteral(parser);
    } else {
      id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);
    }

    const bodyStart = parser.getPosition();
    const body = [];
    const openContext = parser.expectOpening(
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
      'flow declare module body',
    );

    while (!parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR)) {
      let bodyNodeStart = parser.getPosition();

      let bodyNode;
      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._import)) {
        const lookahead = parser.lookaheadState();
        if (lookahead.tokenValue !== 'type' && lookahead.tokenValue !== 'typeof') {
          parser.addDiagnostic(
            {
              message: 'Imports within a `declare module` body must always be `import type` or `import typeof`',
            },
          );
        }
        parser.next();
        bodyNode = ___R$project$rome$$romejs$js$parser$parser$modules_ts$parseImport(parser, bodyNodeStart);
      } else {
        if (!parser.expectContextual(
          'declare',
          'Only declares and type imports are allowed inside declare module',
        )) {
          break;
        }

        bodyNode = ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowDeclare(parser, bodyNodeStart, true);
      }

      body.push(bodyNode);
    }

    parser.expectClosing(openContext);

    const bodyNode = parser.finishNode(
      bodyStart,
      {
        type: 'BlockStatement',
        body,
      },
    );

    let kind;
    let hasModuleExport = false;
    const errorMessage = 'Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module';

    for (const bodyElement of body) {
      if (___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$isEsModuleType(bodyElement)) {
        if (kind === 'commonjs') {
          parser.addDiagnostic(
            {
              loc: bodyElement.loc,
              message: errorMessage,
            },
          );
        }
        kind = 'es';
      } else if (bodyElement.type === 'FlowDeclareModuleExports') {
        if (hasModuleExport) {
          parser.addDiagnostic(
            {
              loc: bodyElement.loc,
              message: 'Duplicate `declare module.exports` statement',
            },
          );
        }

        if (kind === 'es') {
          parser.addDiagnostic(
            {
              loc: bodyElement.loc,
              message: errorMessage,
            },
          );
        }

        kind = 'commonjs';
        hasModuleExport = true;
      }
    }

    return (
      parser.finishNode(
        start,
        {
          type: 'FlowDeclareModule',
          id,
          kind: kind === undefined ? 'commonjs' : kind,
          body: bodyNode,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseExportLocalDeclaration(
    parser,
    start,
    insideModule,
  ) {
    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._export);

    if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._default)) {
      let declaration;
      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._function) || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._class)) {
        // declare export default class ...

        // declare export default function ...
        declaration = ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowDeclare(parser, parser.getPosition());
      } else {
        // declare export default [type];
        declaration = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowType(parser);
        parser.semicolon();
      }

      return (
        parser.finishNode(
          start,
          {
            type: 'FlowDeclareExportDefault',
            declaration,
          },
        )
      );
    } else {
      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._const) || ___R$project$rome$$romejs$js$parser$parser$statement_ts$isLetStart(parser) ||
      (parser.isContextual(
        'type',
      ) ||
      parser.isContextual('interface')) &&
        !insideModule) {
        const label = String(parser.state.tokenValue);
        const suggestion = String(___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$exportSuggestions.get(label));
        parser.addDiagnostic(
          {
            message: '`declare export ' +
            label +
            '` is not supported. Use `' +
            suggestion +
            '` instead',
          },
        );
      }

      if ( // declare export var ...
      parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._var) ||
      // declare function ...
      parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._function) ||
      // declare export class ...
      parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._class) ||
      // declare export opaque ..
      parser.isContextual('opaque')) {
        const declaration = ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowDeclare(parser, parser.getPosition());

        return (
          parser.finishNode(
            start,
            {
              type: 'FlowDeclareExportNamed',
              declaration,
            },
          )
        );
      }

      if ( // declare export * from '';
      parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star) ||
      // declare export {} ...
      parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL) ||
      // declare export interface ...
      parser.isContextual('interface') ||
      // declare export type ...
      parser.isContextual('type') ||
      // declare export opaque type ...
      parser.isContextual('opaque')) {
        const node = ___R$project$rome$$romejs$js$parser$parser$modules_ts$parseExport(parser, start);

        if (node !== undefined) {
          if (node.type === 'ExportLocalDeclaration' ||
          node.type ===
          'ExportExternalDeclaration') {
            return (
              Object.assign(
                {
                },
                node,
                {
                  type: 'FlowDeclareExportNamed',
                },
              )
            );
          } else if (node.type === 'ExportAllDeclaration') {
            return (
              Object.assign(
                {
                },
                node,
                {
                  type: 'FlowDeclareExportAll',
                },
              )
            );
          }
        }
      }
    }

    parser.addDiagnostic(
      {
        start,
        message: 'No valid start for Flow declare export declaration found',
      },
    );

    // Fake node
    return (
      parser.finishNode(
        start,
        {
          type: 'FlowDeclareExportDefault',
          declaration: Object.assign(
            {
            },
            parser.createUnknownStringLiteral(
              'flow declare export declaration',
              start,
            ),
            {
              type: 'StringLiteralTypeAnnotation',
            },
          ),
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowDeclareModuleExports(
    parser,
    start,
  ) {
    parser.expectContextual('module');
    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot);
    parser.expectContextual('exports');
    const typeAnnotation = ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeAnnotation(parser);
    parser.semicolon();

    return (
      parser.finishNode(
        start,
        {
          type: 'FlowDeclareModuleExports',
          typeAnnotation,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowDeclareTypeAlias(
    parser,
    start,
  ) {
    parser.next();
    return (
      Object.assign(
        {
        },
        ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeAliasTypeAnnotation(parser, start),
        {
          declare: true,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowDeclareOpaqueType(
    parser,
    start,
  ) {
    parser.next();
    const opaque = ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowOpaqueType(parser, start, true);
    return (
      parser.finishNode(
        start,
        Object.assign(
          {
          },
          opaque,
          {
            type: 'FlowDeclareOpaqueType',
          },
        ),
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowDeclareInterface(
    parser,
    start,
  ) {
    parser.next();
    return (
      parser.finishNode(
        start,
        Object.assign(
          {
          },
          ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowInterfaceish(parser),
          {
            type: 'FlowDeclareInterface',
          },
        ),
      )
    );
  }

  // Interfaces
  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowInterfaceish(
    parser,
    isClass = false,
  ) {
    const id = ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowRestrictedIdentifier(parser, /*liberal*/!isClass);

    let typeParameters = undefined;
    if (parser.isRelational('<')) {
      typeParameters = ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterDeclaration(parser, true);
    }

    const _extends = [];
    const mixins = [];
    const _implements = [];

    if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._extends)) {
      do {
        _extends.push(___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowInterfaceExtends(parser));
      } while (!isClass && parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma));
    }

    if (parser.isContextual('mixins')) {
      parser.next();
      do {
        mixins.push(___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowInterfaceExtends(parser));
      } while (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma));
    }

    if (parser.isContextual('implements')) {
      parser.next();
      do {
        _implements.push(___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowInterfaceExtends(parser));
      } while (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma));
    }

    const body = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowObjectType(
      parser,
      {
        allowStatic: isClass,
        allowExact: false,
        allowSpread: false,
        allowProto: isClass,
        allowInexact: false,
      },
    );
    return (
      {
        body,
        extends: _extends,
        mixins,
        id,
        typeParameters,
        implements: _implements,
      }
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowInterfaceType(parser) {
    const start = parser.getPosition();
    parser.expectContextual('interface');

    const _extends = [];
    if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._extends)) {
      do {
        _extends.push(___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowInterfaceExtends(parser));
      } while (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma));
    }

    const body = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowObjectType(
      parser,
      {
        allowStatic: false,
        allowExact: false,
        allowSpread: false,
        allowProto: false,
        allowInexact: false,
      },
    );

    return (
      parser.finishNode(
        start,
        {
          type: 'FlowInterfaceTypeAnnotation',
          extends: _extends,
          body,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowInterfaceExtends(parser) {
    const start = parser.getPosition();

    const id = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowQualifiedTypeIdentifier(parser);
    let typeParameters = undefined;
    if (parser.isRelational('<')) {
      typeParameters = ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterInstantiation(parser);
    }

    return (
      parser.finishNode(
        start,
        {
          type: 'FlowInterfaceExtends',
          id,
          typeParameters,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowInterface(
    parser,
    start,
  ) {
    ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$addFlowDiagnostic(parser, 'interface declaration', start);
    return (
      Object.assign(
        {
        },
        ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowInterfaceish(parser),
        {
          loc: parser.finishLoc(start),
          type: 'FlowInterfaceDeclaration',
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$flow_ts$checkReservedType(
    parser,
    word,
    loc,
  ) {
    if (___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$primitiveTypes.includes(word)) {
      parser.addDiagnostic(
        {
          loc,
          message: 'Cannot overwrite primitive type ' +
          word,
        },
      );
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowRestrictedIdentifier(
    parser,
    liberal,
  ) {
    ___R$project$rome$$romejs$js$parser$parser$flow_ts$checkReservedType(
      parser,
      String(parser.state.tokenValue),
      parser.finishLocAt(
        parser.state.startPos,
        parser.state.endPos,
      ),
    );
    return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser, liberal);
  }

  function ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeAliasTypeAnnotation(
    parser,
    start,
  ) {
    ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$addFlowDiagnostic(parser, 'type alias', start);

    const id = ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowRestrictedIdentifier(parser);
    let typeParameters;

    if (parser.isRelational('<')) {
      typeParameters = ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterDeclaration(parser, true);
    } else {
      typeParameters = undefined;
    }

    const right = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeInitialiser(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq);
    parser.semicolon();

    return (
      parser.finishNode(
        start,
        {
          type: 'TypeAliasTypeAnnotation',
          id,
          typeParameters,
          right,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowOpaqueType(
    parser,
    start,
    declare,
  ) {
    ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$addFlowDiagnostic(parser, 'opaque type', start);
    parser.expectContextual('type');
    const id = ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowRestrictedIdentifier(parser, /*liberal*/true);

    let typeParameters;
    if (parser.isRelational('<')) {
      typeParameters = ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterDeclaration(parser, true);
    } else {
      typeParameters = undefined;
    }

    // Parse the supertype
    let supertype = undefined;
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      supertype = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeInitialiser(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon);
    }

    let impltype = undefined;
    if (!declare) {
      impltype = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeInitialiser(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq);
    }
    parser.semicolon();

    return (
      parser.finishNode(
        start,
        {
          type: 'FlowOpaqueType',
          id,
          typeParameters,
          supertype,
          impltype,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeParameter(
    parser,
    allowDefault = true,
    requireDefault = false,
  ) {
    const start = parser.getPosition();

    const variance = ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowVariance(parser);

    const ident = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeAnnotatableIdentifier(parser);
    const name = ident.name;
    const bound = ident.meta !== undefined ? ident.meta.typeAnnotation : undefined;

    let def;
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq)) {
      if (!allowDefault) {
        parser.addDiagnostic(
          {
            message: 'Default type parameters arent allowed here',
          },
        );
      }

      parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq);
      def = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowType(parser);
    } else if (requireDefault) {
      parser.addDiagnostic(
        {
          message: 'Type parameter declaration needs a default, since a preceding type parameter declaration has a default.',
        },
      );
    }

    return (
      parser.finishNode(
        start,
        {
          type: 'FlowTypeParameter',
          default: def,
          name,
          variance,
          bound,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterDeclaration(
    parser,
    allowDefault,
  ) {
    const start = parser.getPosition();
    ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$addFlowDiagnostic(parser, 'type parameter declaration', start);

    const params = [];

    parser.pushScope('TYPE', true);

    parser.expectRelational('<');

    let defaultRequired = false;

    do {
      const param = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeParameter(parser, allowDefault, defaultRequired);

      if (param.default) {
        defaultRequired = true;
      }

      params.push(param);

      if (!parser.isRelational('>') && !parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma)) {
        break;
      }
    } while (!parser.isRelational('>'));

    parser.expectRelational('>');

    parser.popScope('TYPE');

    return (
      parser.finishNode(
        start,
        {
          type: 'FlowTypeParameterDeclaration',
          params,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterInstantiation(
    parser,
  ) {
    const start = parser.getPosition();
    ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$addFlowDiagnostic(parser, 'type parameter instantiation', start);

    const params = [];

    parser.pushScope('TYPE', true);

    parser.expectRelational('<');
    const oldNoAnonFunctionType = parser.state.noAnonFunctionType;
    parser.state.noAnonFunctionType = false;

    while (!parser.isRelational('>')) {
      params.push(___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowType(parser));

      if (!parser.isRelational('>') && !parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma)) {
        break;
      }
    }

    parser.state.noAnonFunctionType = oldNoAnonFunctionType;
    parser.expectRelational('>');

    parser.popScope('TYPE');

    return (
      parser.finishNode(
        start,
        {
          type: 'FlowTypeParameterInstantiation',
          params,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowObjectPropertyKey(parser) {
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.num)) {
      return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseNumericLiteral(parser);
    } else if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string)) {
      return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseStringLiteral(parser);
    } else {
      return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true);
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowObjectTypeIndexer(
    parser,
    start,
    isStatic,
    variance,
  ) {
    let id;
    let key;

    // Note: bracketL has already been consumed
    if (parser.lookaheadState().tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon) {
      id = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowObjectPropertyKey(parser);
      key = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeInitialiser(parser);
    } else {
      id = undefined;
      key = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowType(parser);
    }
    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR);
    const value = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeInitialiser(parser);

    return (
      parser.finishNode(
        start,
        {
          type: 'FlowObjectTypeIndexer',
          static: isStatic,
          key,
          id,
          value,
          variance,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowObjectTypeMethodish(
    parser,
    start,
  ) {
    let typeParameters = undefined;

    if (parser.isRelational('<')) {
      typeParameters = ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterDeclaration(parser, false);
    }

    const openContext = parser.expectOpening(
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
      'function object method params',
    );
    const {params, rest} = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowFunctionTypeParams(parser);
    parser.expectClosing(openContext);
    const returnType = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeInitialiser(parser);

    return (
      parser.finishNode(
        start,
        {
          type: 'FlowFunctionTypeAnnotation',
          params,
          rest,
          typeParameters,
          returnType,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowObjectTypeCallProperty(
    parser,
    start,
    isStatic,
  ) {
    const valueNode = parser.getPosition();
    const value = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowObjectTypeMethodish(parser, valueNode);
    return (
      parser.finishNode(
        start,
        {
          type: 'FlowObjectTypeCallProperty',
          static: isStatic,
          value,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowObjectType(
    parser,
    opts,
  ) {
    const {allowExact, allowSpread, allowProto, allowInexact} = opts;
    let {allowStatic} = opts;

    parser.pushScope('TYPE', true);

    const start = parser.getPosition();

    const properties = [];

    let openContext;
    let exact;
    let inexact;
    if (allowExact && parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceBarL)) {
      openContext =
        parser.expectOpening(
          ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceBarL,
          ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceBarR,
          'flow exact object',
        );
      exact = true;
    } else {
      openContext = parser.expectOpening(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR, 'flow object');
      exact = false;
    }

    while (true) {
      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof) || parser.match(openContext.close)) {
        break;
      }

      const start = parser.getPosition();
      let isStatic = false;
      let protoStart = undefined;

      if (allowProto && parser.isContextual('proto')) {
        const lookahead = parser.lookaheadState();

        if (lookahead.tokenType !== ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon && lookahead.tokenType !== ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question) {
          parser.next();
          protoStart = parser.state.startPos;
          allowStatic = false;
        }
      }

      if (allowStatic && parser.isContextual('static')) {
        const lookahead = parser.lookaheadState();

        // static is a valid identifier name
        if (lookahead.tokenType !== ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon && lookahead.tokenType !== ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question) {
          parser.next();
          isStatic = true;
        }
      }

      const variance = ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowVariance(parser);

      if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL)) {
        if (protoStart !== undefined) {
          parser.unexpectedToken(protoStart);
        }

        if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL)) {
          if (variance) {
            parser.addDiagnostic(
              {
                loc: variance.loc,
                message: 'Variance not allowed',
              },
            );
          }

          properties.push(___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowObjectTypeInternalSlot(parser, start, isStatic));
        } else {
          properties.push(
            ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowObjectTypeIndexer(
              parser,
              start,
              isStatic,
              variance,
            ),
          );
        }
      } else if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL) || parser.isRelational('<')) {
        if (protoStart !== undefined) {
          parser.unexpectedToken(protoStart);
        }

        if (variance) {
          parser.addDiagnostic(
            {
              loc: variance.loc,
              message: 'Variance not allowed',
            },
          );
        }

        properties.push(___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowObjectTypeCallProperty(parser, start, isStatic));
      } else {
        let kind = 'init';

        if (parser.isContextual('get') || parser.isContextual('set')) {
          const lookahead = parser.lookaheadState();
          if (lookahead.tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name || lookahead.tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string ||
          lookahead.tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.num) {
            const value = String(parser.state.tokenValue);
            if (value !== 'get' && value !== 'set') {
              throw (
                new Error(
                  'Expected get or set as we already validated it above',
                )
              );
            }
            kind = value;
            parser.next();
          }
        }

        const propOrInexact = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowObjectTypeProperty(
          parser,
          {
            start,
            isStatic,
            protoStart,
            variance,
            kind,
            allowSpread,
            allowInexact,
          },
        );

        if (propOrInexact === undefined) {
          inexact = true;
        } else {
          properties.push(propOrInexact);
        }
      }

      ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$flowObjectTypeSemicolon(parser);
    }

    parser.expectClosing(openContext);
    parser.popScope('TYPE');

    return (
      parser.finishNode(
        start,
        {
          type: 'FlowObjectTypeAnnotation',
          properties,
          exact,
          inexact,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowObjectTypeProperty(
    parser,
    opts,
  ) {
    const {
      start,
      isStatic,
      protoStart,
      variance,
      kind,
      allowSpread,
      allowInexact,
    } = opts;

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis)) {
      if (!allowSpread) {
        parser.addDiagnostic(
          {
            message: 'Spread operator cannot appear in class or interface definitions',
          },
        );
      }

      if (protoStart !== undefined) {
        parser.unexpectedToken(protoStart);
      }

      if (variance) {
        parser.addDiagnostic(
          {
            loc: variance.loc,
            message: 'Spread properties cannot have variance',
          },
        );
      }

      parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis);

      const isInexactToken = parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma) || parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi);

      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR)) {
        if (allowInexact) {
          return undefined;
        }

        parser.addDiagnostic(
          {
            message: 'Explicit inexact syntax is only allowed inside inexact objects',
          },
        );
      }

      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceBarR)) {
        parser.addDiagnostic(
          {
            message: 'Explicit inexact syntax cannot appear inside an explicit exact object type',
          },
        );
      }

      if (isInexactToken) {
        parser.addDiagnostic(
          {
            message: 'Explicit inexact syntax must appear at the end of an inexact object',
          },
        );
      }

      const argument = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowType(parser);
      return (
        parser.finishNode(
          start,
          {
            type: 'FlowObjectTypeSpreadProperty',
            argument,
          },
        )
      );
    } else {
      const proto = protoStart !== undefined;
      const key = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowObjectPropertyKey(parser);
      let value = undefined;
      let optional = false;

      if (parser.isRelational('<') || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL)) {
        if (protoStart !== undefined) {
          parser.unexpectedToken(protoStart);
        }

        if (variance) {
          parser.addDiagnostic(
            {
              loc: variance.loc,
              message: 'Type methods can\'t have variance',
            },
          );
        }

        value = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowObjectTypeMethodish(parser, start);

        if (kind === 'get' || kind === 'set') {
          ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkGetterSetterParamCount(parser, value, kind);
        }
      } else {
        if (kind !== 'init') {
          parser.unexpectedToken();
        }

        if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question)) {
          optional = true;
        }
        value = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeInitialiser(parser);
      }

      return (
        parser.finishNode(
          start,
          {
            type: 'FlowObjectTypeProperty',
            key,
            static: isStatic,
            kind,
            value,
            variance,
            optional,
            proto,
          },
        )
      );
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$flowObjectTypeSemicolon(parser) {
    if (!parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi) && !parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma) && !parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR) &&
      !parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceBarR)) {
      parser.unexpectedToken();
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowQualifiedTypeIdentifier(
    parser,
    start = parser.getPosition(),
    id,
  ) {
    let node = id === undefined
      ? ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser) : id;

    while (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot)) {
      const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser);
      node =
        parser.finishNode(
          start,
          {
            type: 'FlowQualifiedTypeIdentifier',
            id,
            qualification: node,
          },
        );
    }

    return node;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowGenericType(
    parser,
    start,
    _id,
  ) {
    let typeParameters = undefined;
    const id = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowQualifiedTypeIdentifier(parser, start, _id);

    if (parser.isRelational('<')) {
      typeParameters = ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterInstantiation(parser);
    }

    return (
      parser.finishNode(
        start,
        {
          type: 'FlowGenericTypeAnnotation',
          id,
          typeParameters,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeofType(parser) {
    const start = parser.getPosition();
    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._typeof);
    const argument = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowPrimaryType(parser);
    return (
      parser.finishNode(
        start,
        {
          type: 'FlowTypeofTypeAnnotation',
          argument,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTupleType(parser) {
    const start = parser.getPosition();
    const types = [];
    const openContext = parser.expectOpening(
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL,
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR,
      'flow tuple type',
    );
    // We allow trailing commas

    while (parser.state.index < parser.length && !parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR)) {
      types.push(___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowType(parser));
      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR)) {
        break;
      }

      if (!parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma)) {
        break;
      }
    }
    parser.expectClosing(openContext);
    return (
      parser.finishNode(
        start,
        {
          type: 'FlowTupleTypeAnnotation',
          types,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowFunctionTypeParam(parser) {
    let name = undefined;
    let optional = false;
    let typeAnnotation = undefined;
    const start = parser.getPosition();
    const lh = parser.lookaheadState();
    if (lh.tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon || lh.tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question) {
      name = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser);
      if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question)) {
        optional = true;
      }
      typeAnnotation = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeInitialiser(parser);
    } else {
      typeAnnotation = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowType(parser);
    }
    return (
      parser.finishNode(
        start,
        {
          type: 'FlowFunctionTypeParam',
          name,
          meta: parser.finishNode(
            start,
            {
              type: 'PatternMeta',
              optional,
              typeAnnotation,
            },
          ),
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$reinterpretTypeAsFlowFunctionTypeParam(
    parser,
    type,
  ) {
    const loc = parser.finishLoc(parser.getLoc(type).start);
    return (
      {
        type: 'FlowFunctionTypeParam',
        loc,
        name: undefined,
        meta: {
          type: 'PatternMeta',
          loc,
          optional: false,
          typeAnnotation: type,
        },
      }
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowFunctionTypeParams(
    parser,
  ) {
    const params = [];
    let rest;

    while (!parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR) && !parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis)) {
      params.push(___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowFunctionTypeParam(parser));

      if (!parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR) && !parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma)) {
        break;
      }
    }

    if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis)) {
      const param = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowFunctionTypeParam(parser);
      rest = param;

      // TODO warn on additional elements?
    }

    return {params, rest};
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$flowIdentToTypeAnnotation(
    parser,
    start,
    id,
  ) {
    switch (id.name) {
      case 'any':
        return (
          parser.finishNode(
            start,
            {
              type: 'AnyKeywordTypeAnnotation',
            },
          )
        );

      case 'bool':
      case 'boolean':
        return (
          parser.finishNode(
            start,
            {
              type: 'BooleanKeywordTypeAnnotation',
            },
          )
        );

      case 'mixed':
        return (
          parser.finishNode(
            start,
            {
              type: 'MixedKeywordTypeAnnotation',
            },
          )
        );

      case 'empty':
        return (
          parser.finishNode(
            start,
            {
              type: 'EmptyKeywordTypeAnnotation',
            },
          )
        );

      case 'number':
        return (
          parser.finishNode(
            start,
            {
              type: 'NumberKeywordTypeAnnotation',
            },
          )
        );

      case 'string':
        return (
          parser.finishNode(
            start,
            {
              type: 'StringKeywordTypeAnnotation',
            },
          )
        );

      case 'bigint':
        return (
          parser.finishNode(
            start,
            {
              type: 'BigIntKeywordTypeAnnotation',
            },
          )
        );

      default:
        ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$checkNotUnderscore(parser, id);
        return ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowGenericType(parser, start, id);
    }
  }

  // The parsing of types roughly parallels the parsing of expressions, and

  // primary types are kind of like primary expressions...they're the

  // primitives with which other types are constructed.
  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowPrimaryType(parser) {
    const start = parser.getPosition();
    let type;
    let isGroupedType = false;
    const oldNoAnonFunctionType = parser.state.noAnonFunctionType;

    switch (parser.state.tokenType) {
      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name:
        if (parser.isContextual('interface')) {
          return ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowInterfaceType(parser);
        }

        return ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$flowIdentToTypeAnnotation(parser, start, ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser));

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL:
        return (
          ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowObjectType(
            parser,
            {
              allowStatic: false,
              allowExact: false,
              allowSpread: true,
              allowProto: false,
              allowInexact: true,
            },
          )
        );

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceBarL:
        return (
          ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowObjectType(
            parser,
            {
              allowStatic: false,
              allowExact: true,
              allowSpread: true,
              allowProto: false,
              allowInexact: false,
            },
          )
        );

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL:
        return ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTupleType(parser);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.relational:
        if (parser.state.tokenValue === '<') {
          const typeParameters = ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterDeclaration(parser, false);
          const openContext = parser.expectOpening(
            ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
            ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
            'flow function params',
          );
          const {params, rest} = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowFunctionTypeParams(parser);
          parser.expectClosing(openContext);

          parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow);

          const returnType = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowType(parser);

          return (
            parser.finishNode(
              start,
              {
                type: 'FlowFunctionTypeAnnotation',
                typeParameters,
                params,
                rest,
                returnType,
              },
            )
          );
        }
        break;

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL:
        {
          const openContext = parser.expectOpening(
            ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
            ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
            'flow function params',
          );

          // Check to see if this is actually a grouped type
          if (!parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR) && !parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis)) {
            if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name)) {
              const token = parser.lookaheadState().tokenType;
              isGroupedType = token !== ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question && token !== ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon;
            } else {
              isGroupedType = true;
            }
          }

          if (isGroupedType) {
            parser.state.noAnonFunctionType = false;
            type = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowType(parser);
            parser.state.noAnonFunctionType = oldNoAnonFunctionType;

            // A `,` or a `) =>` means this is an anonymous function type
            if (parser.state.noAnonFunctionType ||
            !(parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma) ||
            parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR) &&
              parser.lookaheadState().tokenType ===
              ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow)) {
              parser.expectClosing(openContext);
              return type;
            } else {
              // Eat a comma if there is one
              parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma);
            }
          }

          let params;
          let rest;
          if (type) {
            const firstParam = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$reinterpretTypeAsFlowFunctionTypeParam(parser, type);
            ({params, rest} = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowFunctionTypeParams(parser));
            params = [firstParam, ...params];
          } else {
            ({params, rest} = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowFunctionTypeParams(parser));
          }

          parser.expectClosing(openContext);
          parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow);

          const returnType = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowType(parser);

          return (
            parser.finishNode(
              start,
              {
                type: 'FlowFunctionTypeAnnotation',
                typeParameters: undefined,
                params,
                rest,
                returnType,
              },
            )
          );
        }

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.num:
      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string:
      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._true:
      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._false:
      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.plusMin:
        return ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeLiteralAnnotation(parser);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._void:
        parser.next();
        return parser.finishNode(start, {type: 'VoidKeywordTypeAnnotation'});

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._null:
        parser.next();
        return parser.finishNode(start, {type: 'NullKeywordTypeAnnotation'});

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._this:
        parser.next();
        return parser.finishNode(start, {type: 'FlowThisTypeAnnotation'});

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star:
        parser.next();
        return parser.finishNode(start, {type: 'FlowExistsTypeAnnotation'});

      default:
        if (parser.state.tokenType.keyword === 'typeof') {
          return ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeofType(parser);
        } else if (parser.state.tokenType.keyword !== undefined) {
          const label = parser.state.tokenType.label;
          parser.next();
          const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$createIdentifier(parser, start, label);
          return ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$flowIdentToTypeAnnotation(parser, start, id);
        }

    }

    parser.addDiagnostic(
      {
        message: 'Unknown flow primarty type start',
      },
    );

    // Fake node
    return parser.finishNode(start, {type: 'MixedKeywordTypeAnnotation'});
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowPostfixType(parser) {
    const startPos = parser.state.startPos;
    let type = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowPrimaryType(parser);
    while (!parser.canInsertSemicolon() && parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL)) {
      const elementType = type;
      parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL);
      parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR);
      type =
        parser.finishNode(
          startPos,
          {
            type: 'FlowArrayTypeAnnotation',
            elementType,
          },
        );
    }
    return type;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowPrefixType(parser) {
    const start = parser.getPosition();
    if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question)) {
      return (
        parser.finishNode(
          start,
          {
            type: 'FlowNullableTypeAnnotation',
            typeAnnotation: ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowPrefixType(parser),
          },
        )
      );
    } else {
      return ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowPostfixType(parser);
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowAnonFunctionWithoutParens(parser) {
    const param = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowPrefixType(parser);

    if (!parser.state.noAnonFunctionType && parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow)) {
      const start = parser.getLoc(param).start;
      const params = [___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$reinterpretTypeAsFlowFunctionTypeParam(parser, param)];
      const returnType = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowType(parser);
      return (
        parser.finishNode(
          start,
          {
            type: 'FlowFunctionTypeAnnotation',
            params,
            returnType,
          },
        )
      );
    }

    return param;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowIntersectionType(parser) {
    const start = parser.getPosition();
    parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bitwiseAND);

    const type = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowAnonFunctionWithoutParens(parser);
    const types = [type];
    while (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bitwiseAND)) {
      types.push(___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowAnonFunctionWithoutParens(parser));
    }

    if (types.length === 1) {
      return type;
    } else {
      return (
        parser.finishNode(
          start,
          {
            type: 'IntersectionTypeAnnotation',
            types,
          },
        )
      );
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$eatUnionBitwise(parser) {
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.logicalOR)) {
      parser.addDiagnostic(
        {
          message: 'Unexpected ||, did you mean just |?',
        },
      );
      parser.next();
    } else {
      parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bitwiseOR);
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowUnionType(parser) {
    const start = parser.getPosition();
    ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$eatUnionBitwise(parser);

    const type = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowIntersectionType(parser);
    const types = [type];

    while (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.logicalOR) || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bitwiseOR)) {
      ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$eatUnionBitwise(parser);
      types.push(___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowIntersectionType(parser));
    }

    if (types.length === 1) {
      return type;
    } else {
      return (
        parser.finishNode(
          start,
          {
            type: 'UnionTypeAnnotation',
            types,
          },
        )
      );
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowType(parser) {
    parser.pushScope('TYPE', true);
    const type = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowUnionType(parser);
    parser.popScope('TYPE');
    // Ensure that a brace after a function generic type annotation is a

    // statement, except in arrow functions (noAnonFunctionType)
    parser.state.exprAllowed =
      parser.state.exprAllowed ||
      parser.state.noAnonFunctionType;
    return type;
  }

  function ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeAnnotation(parser) {
    const start = parser.getPosition();
    ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$addFlowDiagnostic(parser, 'type annotation', start);
    return ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeInitialiser(parser);
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeAnnotatableIdentifier(
    parser,
    allowPrimitiveOverride = false,
  ) {
    const start = parser.getPosition();
    const ident = allowPrimitiveOverride
      ? ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser) : ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowRestrictedIdentifier(parser);

    let typeAnnotation = undefined;
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      typeAnnotation = ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeAnnotation(parser);
    }

    if (typeAnnotation === undefined) {
      return ident;
    } else {
      return (
        parser.finishNode(
          start,
          Object.assign(
            {
            },
            ident,
            {
              meta: parser.finishNode(start, {type: 'PatternMeta', typeAnnotation}),
            },
          ),
        )
      );
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowClassImplemented(
    parser,
  ) {
    const implemented = [];

    do {
      const start = parser.getPosition();
      const id = ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowRestrictedIdentifier(parser, /*liberal*/true);

      let typeParameters;
      if (parser.isRelational('<')) {
        typeParameters = ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterInstantiation(parser);
      }

      implemented.push(
        parser.finishNode(
          start,
          {
            type: 'FlowClassImplements',
            id: ___R$project$rome$$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(parser, id),
            typeParameters,
          },
        ),
      );
    } while (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma));

    return implemented;
  }

  function ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowVariance(parser) {
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.plusMin)) {
      const start = parser.getPosition();
      ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$addFlowDiagnostic(parser, 'variance', start);
      let kind;
      if (parser.state.tokenValue === '+') {
        kind = 'plus';
      } else {
        kind = 'minus';
      }
      parser.next();
      return (
        parser.finishNode(
          start,
          {
            type: 'FlowVariance',
            kind,
          },
        )
      );
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseAsyncArrowWithFlowTypeParameters(
    parser,
    startPos,
  ) {
    const {params, rest, typeParameters} = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionParams(parser);

    const {returnType, valid, predicate} = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseArrowHead(parser);
    if (!valid) {
      parser.addDiagnostic(
        {
          message: 'Invalid async arrow with type parameters',
        },
      );
      return undefined;
    }

    const func = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseArrowExpression(
      parser,
      startPos,
      {
        bindingList: params,
        rest,
      }, /* isAsync */true,
    );

    return (
      Object.assign(
        {
        },
        func,
        {
          head: Object.assign(
            {
            },
            func.head,
            {
              returnType,
              predicate,
              typeParameters,
            },
          ),
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowObjectTypeInternalSlot(
    parser,
    start,
    isStatic,
  ) {
    // Note: both bracketL have already been consumed
    const id = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowObjectPropertyKey(parser);
    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR);
    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR);

    let optional = false;
    let value;
    if (parser.isRelational('<') || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL)) {
      value = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowObjectTypeMethodish(parser, start);
    } else {
      optional = parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question);
      value = ___R$$priv$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeInitialiser(parser);
    }

    return (
      parser.finishNode(
        start,
        {
          type: 'FlowObjectTypeInternalSlot',
          optional,
          value,
          id,
          static: isStatic,
        },
      )
    );
  }

  // project-rome/@romejs/js-parser/parser/typescript.ts
const ___R$project$rome$$romejs$js$parser$parser$typescript_ts = {
    parseTSModifier: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModifier,
    hasTSModifier: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$hasTSModifier,
    parseTSTypeParameters: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeParameters,
    tryTSNextParseConstantContext: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSNextParseConstantContext,
    tsCheckLiteralForConstantContext: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext,
    tryTSParseIndexSignature: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSParseIndexSignature,
    parseTSTypeOrTypePredicateAnnotation: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation,
    parseTSTypeAnnotation: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation,
    parseTSTypeAssertion: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAssertion,
    parseTSHeritageClause: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSHeritageClause,
    parseTSInterfaceDeclaration: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSInterfaceDeclaration,
    parseTSTypeAliasTypeAnnotation: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAliasTypeAnnotation,
    tsNextThenParseType: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tsNextThenParseType,
    parseTSEnumDeclaration: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSEnumDeclaration,
    parseTSModuleBlock: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModuleBlock,
    parseTSModuleOrNamespaceDeclaration: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModuleOrNamespaceDeclaration,
    parseTSAmbientExternalModuleDeclaration: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSAmbientExternalModuleDeclaration,
    parseTSImportEqualsDeclaration: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSImportEqualsDeclaration,
    parseTSDeclare: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSDeclare,
    parseTSAbstractClass: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSAbstractClass,
    parseTSExportDefaultAbstractClass: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSExportDefaultAbstractClass,
    parseTSTypeArguments: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeArguments,
    isTSDeclarationStart: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$isTSDeclarationStart,
    parseTSAccessModifier: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSAccessModifier,
    isTSAbstractClass: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$isTSAbstractClass,
    parseTSExport: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSExport,
  };

  // Doesn't handle 'void' or 'null' because those are keywords, not identifiers.
  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$keywordTypeFromName(
    value,
  ) {
    switch (value) {
      case 'any':
        return 'AnyKeywordTypeAnnotation';

      case 'boolean':
        return 'BooleanKeywordTypeAnnotation';

      case 'bigint':
        return 'BigIntKeywordTypeAnnotation';

      case 'never':
        return 'NeverKeywordTypeAnnotation';

      case 'number':
        return 'NumberKeywordTypeAnnotation';

      case 'object':
        return 'ObjectKeywordTypeAnnotation';

      case 'string':
        return 'StringKeywordTypeAnnotation';

      case 'symbol':
        return 'SymbolKeywordTypeAnnotation';

      case 'undefined':
        return 'UndefinedKeywordTypeAnnotation';

      case 'unknown':
        return 'UnknownKeywordTypeAnnotation';

      default:
        return undefined;
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsIdentifier(parser) {
    // TODO: actually a bit more complex in TypeScript, but shouldn't matter.

    // See https://github.com/Microsoft/TypeScript/issues/15008
    return parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name);
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsNextTokenCanFollowModifier(parser) {
    // Note: TypeScript's implementation is much more complicated because

    // more things are considered modifiers there.

    // This implementation only handles modifiers not handled by @babel/parser itself. And 'static'.

    // TODO: Would be nice to avoid lookahead. Want a hasLineBreakUpNext() method...
    parser.next();
    return (
      !parser.hasPrecedingLineBreak() && !parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL) &&
        !parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR) &&
        !parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon) &&
        !parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq) &&
        !parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question) &&
        !parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bang)
    );
  }

  /** Parses a modifier matching one the given modifier names. */
  function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModifier(
    parser,
    allowedModifiers,
  ) {
    if (!parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name)) {
      return undefined;
    }

    // @ts-ignore: We are lying here but we validate it in all the correct places
    const modifier = String(parser.state.tokenValue);
    if (allowedModifiers.includes(modifier) &&
      ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSParse(
        parser,
        ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsNextTokenCanFollowModifier,
      )) {
      return modifier;
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$hasTSModifier(
    parser,
    allowedModifiers,
  ) {
    return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModifier(parser, allowedModifiers) !== undefined;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsListTerminator(parser, kind) {
    switch (kind) {
      case 'EnumMembers':
      case 'TypeMembers':
        return parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR);

      case 'HeritageClauseElement':
        return parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL);

      case 'TupleElementTypes':
        return parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR);

      case 'TypeParametersOrArguments':
        return parser.isRelational('>');
    }

    throw new Error('Unreachable');
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSList(
    parser,
    kind,
    parseElement,
  ) {
    const result = [];
    while (!___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsListTerminator(parser, kind)) {
      // Skipping 'parseListElement' from the TS source since that's just for error handling.
      result.push(parseElement(parser));
    }
    return result;
  }

  /**
 * If !expectSuccess, returns undefined instead of failing to parse.
 * If expectSuccess, parseElement should always return a defined value.
 */
  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSDelimitedList(
    parser,
    kind,
    parseElement,
  ) {
    const result = [];

    while (true) {
      if (___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsListTerminator(parser, kind)) {
        break;
      }

      const element = parseElement(parser);
      if (element == undefined) {
        break;
      }

      result.push(element);

      if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma)) {
        continue;
      }

      if (___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsListTerminator(parser, kind)) {
        break;
      }

      // This will fail with an error about a missing comma
      if (parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma)) {
        break;
      }
    }

    return result;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSBracketedList(
    parser,
    kind,
    parseElement,
    bracket,
    skipFirstToken,
  ) {
    if (!skipFirstToken) {
      if (bracket) {
        parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL);
      } else {
        parser.expectRelational('<');
      }
    }

    const result = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSDelimitedList(parser, kind, parseElement);

    if (bracket) {
      parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR);
    } else {
      parser.expectRelational('>');
    }

    return result;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSImportType(parser) {
    const start = parser.getPosition();
    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._import);
    const openContext = parser.expectOpening(
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
      'ts import type',
    );

    if (!parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string)) {
      parser.addDiagnostic(
        {
          message: 'Argument in a type import must be a string literal',
        },
      );
    }

    const argument = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionAtom(parser, 'ts import argument');
    parser.expectClosing(openContext);

    let qualifier;
    if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot)) {
      qualifier = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSEntityName(parser, /* allowReservedWords */true);
    }

    let typeParameters;
    if (parser.isRelational('<')) {
      typeParameters = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeArguments(parser);
    }

    return (
      parser.finishNode(
        start,
        {
          type: 'TSImportType',
          argument,
          qualifier,
          typeParameters,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSEntityName(
    parser,
    allowReservedWords,
  ) {
    let entity = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseReferenceIdentifier(parser);
    while (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot)) {
      const start = parser.getLoc(entity).start;
      const right = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, allowReservedWords);
      entity =
        parser.finishNode(
          start,
          {
            type: 'TSQualifiedName',
            left: entity,
            right,
          },
        );
    }
    return entity;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeReference(parser) {
    const start = parser.getPosition();
    const typeName = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSEntityName(parser, /* allowReservedWords */false);
    let typeParameters;
    if (!parser.hasPrecedingLineBreak() && parser.isRelational('<')) {
      typeParameters = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeArguments(parser);
    }
    return (
      parser.finishNode(
        start,
        {
          type: 'TSTypeReference',
          typeName,
          typeParameters,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSThisTypePredicate(
    parser,
    lhs,
  ) {
    parser.next();
    const start = parser.getLoc(lhs).start;
    const parameterName = lhs;
    const typeAnnotation = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(parser, /* eatColon */false);

    return (
      parser.finishNode(
        start,
        {
          type: 'TSTypePredicate',
          asserts: false,
          parameterName,
          typeAnnotation,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSThisTypeNode(parser) {
    const start = parser.getPosition();
    parser.next();
    return (
      parser.finishNode(
        start,
        {
          type: 'TSThisType',
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeQuery(parser) {
    const start = parser.getPosition();
    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._typeof);
    let exprName;
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._import)) {
      exprName = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSImportType(parser);
    } else {
      exprName = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSEntityName(parser, /* allowReservedWords */true);
    }
    return (
      parser.finishNode(
        start,
        {
          type: 'TSTypeQuery',
          exprName,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeParameter(parser) {
    const start = parser.getPosition();
    const name = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifierName(parser);
    const constraint = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsEatThenParseType(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._extends);
    const _default = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsEatThenParseType(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq);
    return (
      parser.finishNode(
        start,
        {
          type: 'TSTypeParameter',
          name,
          constraint,
          default: _default,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tryParseTSTypeParameters(
    parser,
  ) {
    if (parser.isRelational('<')) {
      return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeParameters(parser);
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeParameters(
    parser,
  ) {
    const start = parser.getPosition();

    parser.expectRelational('<');

    const params = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSBracketedList(
      parser,
      'TypeParametersOrArguments',
      ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeParameter,
      /* bracket */false,
      /* skipFirstToken */true,
    );

    return (
      parser.finishNode(
        start,
        {
          type: 'TSTypeParameterDeclaration',
          params,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSNextParseConstantContext(
    parser,
  ) {
    if (parser.lookaheadState().tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._const) {
      parser.next();
      return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeReference(parser);
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext(parser, node) {
    switch (node.type) {
      case 'StringLiteral':
      case 'TemplateLiteral':
      case 'NumericLiteral':
      case 'BooleanLiteral':
      case 'SpreadElement':
      case 'ObjectMethod':
      case 'ObjectExpression':
        break;

      case 'ArrayExpression':
        for (const elem of node.elements) {
          if (elem) {
            ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext(parser, elem);
          }
        }
        break;

      case 'ObjectProperty':
        ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext(parser, node.value);
        break;

      case 'UnaryExpression':
        ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext(parser, node.argument);
        break;

      default:
        parser.addDiagnostic(
          {
            loc: node.loc,
            message: 'Only literal values are allowed in constant contexts',
          },
        );
    }
  }

  // Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,

  // but here it's always false, because parser.is only used for types.
  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSSignatureDeclarationMeta(
    parser,
    returnToken,
  ) {
    const start = parser.getPosition();

    // Arrow fns *must* have return token (`=>`). Normal functions can omit it.
    const returnTokenRequired = returnToken === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow;
    const typeParameters = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tryParseTSTypeParameters(parser);
    const {list: parameters, rest} = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSBindingListForSignature(parser);

    let typeAnnotation;
    if (returnTokenRequired) {
      typeAnnotation = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation(parser, returnToken);
    } else if (parser.match(returnToken)) {
      typeAnnotation = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation(parser, returnToken);
    }

    return (
      {
        typeAnnotation,
        meta: parser.finishNode(
          start,
          {
            type: 'TSSignatureDeclarationMeta',
            typeParameters,
            parameters,
            rest,
          },
        ),
      }
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSBindingListForSignature(
    parser,
  ) {
    const openContext = parser.expectOpening(
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
      'ts signature parameters',
    );
    const {list: patterns, rest} = ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingListNonEmpty(parser, openContext);
    const validPatterns = [];

    for (const pattern of patterns) {
      if (pattern.type === 'BindingIdentifier' ||
      pattern.type ===
      'BindingObjectPattern' ||
      pattern.type === 'BindingArrayPattern') {
        validPatterns.push(pattern);
      } else {
        parser.addDiagnostic(
          {
            loc: pattern.loc,
            message: 'Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ' +
            pattern.type,
          },
        );
      }
    }

    return {list: validPatterns, rest};
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeMemberSemicolon(parser) {
    if (!parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma)) {
      parser.semicolon();
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSConstructSignatureDeclaration(
    parser,
  ) {
    const start = parser.getPosition();
    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._new);
    const {meta, typeAnnotation} = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSSignatureDeclarationMeta(
      parser,
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
    );
    parser.semicolon();
    return (
      parser.finishNode(
        start,
        {
          type: 'TSConstructSignatureDeclaration',
          meta,
          typeAnnotation,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSCallSignatureDeclaration(
    parser,
  ) {
    const start = parser.getPosition();
    const {meta, typeAnnotation} = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSSignatureDeclarationMeta(
      parser,
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
    );
    parser.semicolon();
    return (
      parser.finishNode(
        start,
        {
          type: 'TSCallSignatureDeclaration',
          meta,
          typeAnnotation,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsUnambiguouslyIndexSignature(parser) {
    parser.next(); // Skip '{'
    return parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name) && parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon);
  }

  function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSParseIndexSignature(
    parser,
    start,
  ) {
    if (!(parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL) &&
      ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$lookaheadTS(
        parser,
        ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsUnambiguouslyIndexSignature,
      ))) {
      return undefined;
    }

    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL);

    const idStart = parser.getPosition();
    const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);

    const keyTypeAnnotation = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(parser);
    const key = parser.finishNode(
      idStart,
      Object.assign(
        {
        },
        id,
        {
          meta: parser.finishNode(
            idStart,
            Object.assign(
              {
              },
              id.meta,
              {
                type: 'PatternMeta',
                typeAnnotation: keyTypeAnnotation,
              },
            ),
          ),
        },
      ),
    );

    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR);

    const typeAnnotation = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSParseTypeAnnotation(parser);

    parser.semicolon();
    return (
      parser.finishNode(
        start,
        {
          type: 'TSIndexSignature',
          typeAnnotation,
          key,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSPropertyOrMethodSignature(
    parser,
    start,
    readonly,
  ) {
    const key = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPropertyKey(parser);
    const optional = parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question);

    if (!readonly && (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL) || parser.isRelational('<'))) {
      const {meta, typeAnnotation} = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSSignatureDeclarationMeta(
        parser,
        ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
      );
      ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeMemberSemicolon(parser);
      return (
        parser.finishNode(
          start,
          {
            type: 'TSMethodSignature',
            optional,
            meta,
            key,
            typeAnnotation,
          },
        )
      );
    } else {
      const typeAnnotation = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSParseTypeAnnotation(parser);
      ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeMemberSemicolon(parser);
      return (
        parser.finishNode(
          start,
          {
            type: 'TSPropertySignature',
            optional,
            readonly,
            typeAnnotation,
            key,
          },
        )
      );
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeMember(parser) {
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL) || parser.isRelational('<')) {
      return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSCallSignatureDeclaration(parser);
    }

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._new) && ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$lookaheadTS(parser, ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsStartOfConstructSignature)) {
      return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSConstructSignatureDeclaration(parser);
    }

    const start = parser.getPosition();
    const readonly = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$hasTSModifier(parser, ['readonly']);

    const idx = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSParseIndexSignature(parser, start);
    if (idx) {
      return (
        Object.assign(
          {
          },
          idx,
          {
            readonly,
          },
        )
      );
    }

    return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSPropertyOrMethodSignature(parser, start, readonly);
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsStartOfConstructSignature(parser) {
    parser.next();
    return parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL) || parser.isRelational('<');
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeLiteral(parser) {
    const start = parser.getPosition();
    const members = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSObjectTypeMembers(parser);
    return (
      parser.finishNode(
        start,
        {
          type: 'TSTypeLiteral',
          members,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSObjectTypeMembers(parser) {
    const openContext = parser.expectOpening(
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
      'ts object type members',
    );
    const members = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSList(parser, 'TypeMembers', ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeMember);
    parser.expectClosing(openContext);
    return members;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsStartOfMappedType(parser) {
    parser.next();

    if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.plusMin)) {
      return parser.isContextual('readonly');
    }

    if (parser.isContextual('readonly')) {
      parser.next();
    }

    if (!parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL)) {
      return false;
    }

    parser.next();

    if (!___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsIdentifier(parser)) {
      return false;
    }

    parser.next();

    return parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._in);
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSMappedTypeParameter(parser) {
    const start = parser.getPosition();
    const name = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifierName(parser);
    const constraint = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsExpectThenParseType(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._in);
    return (
      parser.finishNode(
        start,
        {
          type: 'TSTypeParameter',
          name,
          constraint,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$toPlusMin(val) {
    const str = String(val);
    if (str === '+' || str === '-') {
      return str;
    } else {
      throw new Error('Expected +/-');
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSMappedType(parser) {
    const start = parser.getPosition();

    const openContext = parser.expectOpening(
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
      'ts mapped type',
    );

    let readonly;
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.plusMin)) {
      readonly = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$toPlusMin(parser.state.tokenValue);
      parser.next();
      parser.expectContextual('readonly');
    } else if (parser.eatContextual('readonly')) {
      readonly = true;
    }

    const paramOpenContext = parser.expectOpening(
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL,
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR,
      'ts mapped type parameter',
    );
    const typeParameter = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSMappedTypeParameter(parser);
    parser.expectClosing(paramOpenContext);

    let optional;
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.plusMin)) {
      optional = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$toPlusMin(parser.state.tokenValue);
      parser.next();
      parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question);
    } else if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question)) {
      optional = true;
    }

    const typeAnnotation = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSParseType(parser);
    parser.semicolon();
    parser.expectClosing(openContext);

    return (
      parser.finishNode(
        start,
        {
          type: 'TSMappedType',
          typeParameter,
          typeAnnotation,
          optional,
          readonly,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTupleType(parser) {
    const start = parser.getPosition();
    const elementDefs = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSBracketedList(
      parser,
      'TupleElementTypes',
      ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTupleElementType,
      /* bracket */true,
      /* skipFirstToken */false,
    );

    // Validate the elementTypes to ensure:
    //   No mandatory elements may follow optional elements

    //   If there's a rest element, it must be at the end of the tuple
    let seenOptionalElement = false;
    const elementTypes = [];
    let rest;
    for (const {type, isRest} of elementDefs) {
      if (rest !== undefined) {
        // No elements should come after a rest, we should have already produced an error
        continue;
      }

      if (type.type === 'TSOptionalType') {
        seenOptionalElement = true;
      } else if (seenOptionalElement && !isRest) {
        parser.addDiagnostic(
          {
            loc: type.loc,
            message: 'A required element cannot follow an optional element.',
          },
        );
      }

      if (isRest) {
        rest = type;
      } else {
        elementTypes.push(type);
      }
    }

    return (
      parser.finishNode(
        start,
        {
          type: 'TSTupleType',
          elementTypes,
          rest,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTupleElementType(
    parser,
  ) {
    // parses `...TsType[]`
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis)) {
      parser.next(); // skips ellipsis
      const typeAnnotation = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSType(parser);
      ___R$project$rome$$romejs$js$parser$parser$lval_ts$hasCommaAfterRest(parser);

      return (
        {
          isRest: true,
          type: typeAnnotation,
        }
      );
    }

    const typeAnnotation = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSType(parser);

    // Parses `TsType?`
    if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question)) {
      const start = parser.getLoc(typeAnnotation).start;
      return (
        {
          isRest: false,
          type: parser.finishNode(
            start,
            {
              type: 'TSOptionalType',
              typeAnnotation,
            },
          ),
        }
      );
    }

    return (
      {
        isRest: false,
        type: typeAnnotation,
      }
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSParenthesizedType(parser) {
    const start = parser.getPosition();
    const openContext = parser.expectOpening(
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
      'ts parenthesized type',
    );
    const typeAnnotation = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSType(parser);
    parser.expectClosing(openContext);
    return (
      parser.finishNode(
        start,
        {
          type: 'TSParenthesizedType',
          typeAnnotation,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSFunctionType(parser) {
    const start = parser.getPosition();
    const {meta, typeAnnotation} = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSSignatureDeclarationMeta(
      parser,
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow,
    );

    if (typeAnnotation === undefined) {
      throw (
        new Error(
          'Type annotation return type required as we passed tt.arrow above',
        )
      );
    }

    return (
      parser.finishNode(
        start,
        {
          type: 'TSFunctionType',
          meta,
          typeAnnotation,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSConstructorType(parser) {
    const start = parser.getPosition();
    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._new);

    const {meta, typeAnnotation} = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSSignatureDeclarationMeta(
      parser,
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow,
    );

    if (typeAnnotation === undefined) {
      throw (
        new Error(
          'Type annotation return type required as we passed tt.arrow above',
        )
      );
    }

    return (
      parser.finishNode(
        start,
        {
          type: 'TSConstructorType',
          meta,
          typeAnnotation,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTemplateLiteralType(
    parser,
  ) {
    const templateNode = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseTemplate(parser, false);

    if (templateNode.expressions.length > 0) {
      parser.addDiagnostic(
        {
          loc: parser.getLoc(templateNode.expressions[0]),
          message: 'Template literal types cannot have any substitution',
        },
      );
    }

    return (
      {
        type: 'TemplateLiteralTypeAnnotation',
        value: templateNode.quasis[0].raw,
        loc: templateNode.loc,
      }
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSNonArrayType(parser) {
    switch (parser.state.tokenType) {
      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name:
      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._void:
      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._null:
        {
          let type;
          if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._void)) {
            type = 'VoidKeywordTypeAnnotation';
          } else if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._null)) {
            type = 'NullKeywordTypeAnnotation';
          } else {
            type = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$keywordTypeFromName(String(parser.state.tokenValue));
          }

          if (type !== undefined && parser.lookaheadState().tokenType !== ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot) {
            const start = parser.getPosition();
            parser.next();
            return (
              parser.finishNode(
                start,
                ({
                  type,
                }),
              )
            );
          }
          return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeReference(parser);
        }

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string:
      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.num:
      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._true:
      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._false:
      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.plusMin:
        return ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeLiteralAnnotation(parser);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._this:
        {
          const thisKeyword = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSThisTypeNode(parser);
          if (parser.isContextual('is') && !parser.hasPrecedingLineBreak()) {
            return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSThisTypePredicate(parser, thisKeyword);
          } else {
            return thisKeyword;
          }
        }

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._typeof:
        return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeQuery(parser);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._import:
        return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSImportType(parser);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL:
        if (___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$lookaheadTS(parser, ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsStartOfMappedType)) {
          return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSMappedType(parser);
        } else {
          return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeLiteral(parser);
        }

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL:
        return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTupleType(parser);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL:
        return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSParenthesizedType(parser);

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.backQuote:
        return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTemplateLiteralType(parser);
    }

    parser.addDiagnostic(
      {
        message: 'Unknown TS non array type start',
      },
    );
    parser.next();

    return (
      parser.finishNode(
        parser.getPosition(),
        {
          type: 'TSTypeReference',
          typeName: ___R$project$rome$$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(
            parser,
            parser.createUnknownIdentifier(
              'ts non array type start',
            ),
          ),
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSArrayTypeOrHigher(parser) {
    let type = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSNonArrayType(parser);

    while (!parser.hasPrecedingLineBreak() && parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL)) {
      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR)) {
        const start = parser.getLoc(type).start;
        const elementType = type;
        parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR);
        type =
          parser.finishNode(
            start,
            {
              type: 'TSArrayType',
              elementType,
            },
          );
      } else {
        const start = parser.getLoc(type).start;
        const objectType = type;
        const indexType = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSType(parser);
        parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR);
        type =
          parser.finishNode(
            start,
            {
              type: 'TSIndexedAccessType',
              objectType,
              indexType,
            },
          );
      }
    }
    return type;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeOperator(
    parser,
    operator,
  ) {
    const start = parser.getPosition();
    parser.expectContextual(operator);

    const typeAnnotation = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeOperatorOrHigher(parser);

    const node = parser.finishNode(
      start,
      {
        type: 'TSTypeOperator',
        typeAnnotation,
        operator,
      },
    );

    if (operator === 'readonly') {
      ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsCheckTypeAnnotationForReadOnly(parser, typeAnnotation);
    }

    return node;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsCheckTypeAnnotationForReadOnly(parser, node) {
    switch (node.type) {
      case 'TSTupleType':
      case 'TSArrayType':
        return undefined;

      default:
        parser.addDiagnostic(
          {
            loc: node.loc,
            message: '\'readonly\' type modifier is only permitted on array and tuple literal types.',
          },
        );
        break;
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSInferType(parser) {
    const inferStart = parser.getPosition();
    parser.expectContextual('infer');

    const start = parser.getPosition();
    const name = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifierName(parser);
    const typeParameter = parser.finishNode(
      start,
      {
        type: 'TSTypeParameter',
        name,
      },
    );

    return (
      parser.finishNode(
        inferStart,
        {
          type: 'TSInferType',
          typeParameter,
        },
      )
    );
  }

  const ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$TS_TYPE_OPERATORS = [
    'keyof',
    'unique',
    'readonly',
  ];

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeOperatorOrHigher(parser) {
    let operator;

    for (const op of ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$TS_TYPE_OPERATORS) {
      if (parser.isContextual(op)) {
        operator = op;
        break;
      }
    }

    if (operator !== undefined) {
      return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeOperator(parser, operator);
    } else if (parser.isContextual('infer')) {
      return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSInferType(parser);
    } else {
      return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSArrayTypeOrHigher(parser);
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSUnionOrIntersectionType(
    parser,
    kind,
    parseConstituentType,
    operator,
  ) {
    parser.eat(operator);
    let type = parseConstituentType(parser);

    if (parser.match(operator)) {
      const types = [type];
      while (parser.eat(operator)) {
        types.push(parseConstituentType(parser));
      }

      const start = parser.getLoc(type).start;
      if (kind === 'UnionTypeAnnotation') {
        type =
          parser.finishNode(
            start,
            {
              type: 'UnionTypeAnnotation',
              types,
            },
          );
      } else if (kind === 'IntersectionTypeAnnotation') {
        type =
          parser.finishNode(
            start,
            {
              type: 'IntersectionTypeAnnotation',
              types,
            },
          );
      }
    }

    return type;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseIntersectionTypeAnnotationOrHigher(parser) {
    return (
      ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSUnionOrIntersectionType(
        parser,
        'IntersectionTypeAnnotation',
        ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeOperatorOrHigher,
        ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bitwiseAND,
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseUnionTypeAnnotationOrHigher(parser) {
    return (
      ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSUnionOrIntersectionType(
        parser,
        'UnionTypeAnnotation',
        ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseIntersectionTypeAnnotationOrHigher,
        ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bitwiseOR,
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsStartOfFunctionType(parser) {
    if (parser.isRelational('<')) {
      return true;
    }
    return (
      parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL) &&
        ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$lookaheadTS(
          parser,
          ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsUnambiguouslyStartOfFunctionType,
        )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsSkipParameterStart(parser) {
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name) || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._this)) {
      parser.next();
      return true;
    }

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL)) {
      let braceStackCounter = 1;
      parser.next();

      while (braceStackCounter > 0) {
        if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL)) {
          braceStackCounter++;
        } else if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR)) {
          braceStackCounter--;
        }

        parser.next();
      }
      return true;
    }

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL)) {
      let braceStackCounter = 1;
      parser.next();

      while (braceStackCounter > 0) {
        if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL)) {
          braceStackCounter++;
        } else if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR)) {
          braceStackCounter--;
        }

        parser.next();
      }
      return true;
    }

    return false;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsUnambiguouslyStartOfFunctionType(parser) {
    parser.next();
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR) || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis)) {
      // ()

      // (...
      return true;
    }
    if (___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsSkipParameterStart(parser)) {
      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon) || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma) ||
      parser.match(
        ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question,
      ) ||
      parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq)) {
        // (xxx :
        // (xxx ,

        // (xxx ?

        // (xxx =
        return true;
      }
      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR)) {
        parser.next();
        if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow)) {
          // (xxx ) =>
          return true;
        }
      }
    }
    return false;
  }

  function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation(
    parser,
    returnToken,
  ) {
    let start = parser.getPosition();
    parser.pushScope('TYPE', true);
    parser.expect(returnToken);

    let hasAsserts = parser.eatContextual('asserts');
    let parameterName;
    let typePredicateVariable;
    if (___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsIdentifier(parser)) {
      typePredicateVariable = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSParse(parser, ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypePredicatePrefix);
    }
    if (typePredicateVariable === undefined) {
      if (hasAsserts) {
        parameterName = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser);
        if (parameterName === undefined) {
          throw Error('Should have an identifier after asserts');
        }
      } else {
        parser.popScope('TYPE');
        return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(parser, /* eatColon */false, start);
      }
    } else {
      parameterName = typePredicateVariable;
    }

    let type;
    if (typePredicateVariable) {
      type = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(parser, /* eatColon */false);
      start = parser.getLoc(typePredicateVariable).start;
    }

    parser.popScope('TYPE');

    return (
      parser.finishNode(
        start,
        {
          type: 'TSTypePredicate',
          asserts: hasAsserts,
          parameterName,
          typeAnnotation: type,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSParseTypeAnnotation(parser) {
    return parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon) ? ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(parser) : undefined;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSParseType(parser) {
    return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsEatThenParseType(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon);
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypePredicatePrefix(parser) {
    const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser);
    if (parser.isContextual('is') && !parser.hasPrecedingLineBreak()) {
      parser.next();
      return id;
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
    parser,
    eatColon = true,
    start = parser.getPosition(),
  ) {
    parser.pushScope('TYPE', true);

    if (eatColon) {
      parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon);
    }

    const typeAnnotation = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSType(parser, start);
    parser.popScope('TYPE');
    return typeAnnotation;
  }

  /** Be sure to be in a type context before calling parser. using `tsInType`. */
  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSType(
    parser,
    start = parser.getPosition(),
  ) {
    parser.pushScope('TYPE', true);

    const type = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSNonConditionalType(parser);
    if (parser.hasPrecedingLineBreak() || !parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._extends)) {
      parser.popScope('TYPE');
      return type;
    }

    const checkType = type;

    const extendsType = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSNonConditionalType(parser);
    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question);

    const trueType = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSType(parser);
    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon);

    const falseType = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSType(parser);
    parser.popScope('TYPE');

    return (
      parser.finishNode(
        start,
        {
          type: 'TSConditionalType',
          checkType,
          extendsType,
          trueType,
          falseType,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSNonConditionalType(parser) {
    if (___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsStartOfFunctionType(parser)) {
      return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSFunctionType(parser);
    }

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._new)) {
      // As in `new () => Date`
      return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSConstructorType(parser);
    }

    return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseUnionTypeAnnotationOrHigher(parser);
  }

  function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAssertion(parser) {
    const start = parser.getPosition();
    const _const = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSNextParseConstantContext(parser);
    const typeAnnotation = _const || ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tsNextThenParseType(parser);
    parser.expectRelational('>');

    const expression = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeUnary(parser, 'ts type assertion');
    if (_const) {
      ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext(parser, expression);
    }

    return (
      parser.finishNode(
        start,
        {
          type: 'TSTypeAssertion',
          expression,
          typeAnnotation,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSHeritageClause(
    parser,
    descriptor,
  ) {
    const originalStart = parser.state.startPos;
    const delimitedList = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSDelimitedList(
      parser,
      'HeritageClauseElement',
      ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSExpressionWithTypeArguments,
    );

    if (!delimitedList.length) {
      parser.addDiagnostic(
        {
          start: originalStart,
          message: '\'' +
          descriptor +
          '\' list cannot be empty.',
        },
      );
    }

    return delimitedList;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSExpressionWithTypeArguments(
    parser,
  ) {
    const start = parser.getPosition();

    // Note: TS uses parseLeftHandSideExpressionOrHigher,

    // then has grammar errors later if it's not an EntityName.
    const expression = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSEntityName(parser, /* allowReservedWords */false);

    let typeParameters;
    if (parser.isRelational('<')) {
      typeParameters = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeArguments(parser);
    }

    return (
      parser.finishNode(
        start,
        {
          type: 'TSExpressionWithTypeArguments',
          expression,
          typeParameters,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSInterfaceDeclaration(
    parser,
    start,
  ) {
    parser.pushScope('TYPE', true);
    const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);
    const typeParameters = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tryParseTSTypeParameters(parser);

    let _extends;
    if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._extends)) {
      _extends = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSHeritageClause(parser, 'extends');
    }

    const bodyStart = parser.getPosition();
    const bodyItems = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSObjectTypeMembers(parser);
    const body = parser.finishNode(
      bodyStart,
      {
        type: 'TSInterfaceBody',
        body: bodyItems,
      },
    );

    parser.popScope('TYPE');
    return (
      parser.finishNode(
        start,
        {
          type: 'TSInterfaceDeclaration',
          id,
          body,
          typeParameters,
          extends: _extends,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAliasTypeAnnotation(
    parser,
    start,
  ) {
    const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);
    const typeParameters = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tryParseTSTypeParameters(parser);
    const typeAnnotation = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsExpectThenParseType(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq);
    parser.semicolon();
    return (
      parser.finishNode(
        start,
        {
          type: 'TypeAliasTypeAnnotation',
          id,
          typeParameters,
          right: typeAnnotation,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsInNoContext(parser, cb) {
    const oldContext = parser.state.context;
    parser.state.context = [oldContext[0]];
    const res = cb(parser);
    parser.state.context = oldContext;
    return res;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsEatThenParseType(
    parser,
    token,
  ) {
    if (parser.match(token)) {
      return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tsNextThenParseType(parser);
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsExpectThenParseType(parser, token) {
    return (
      ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsDoThenParseType(
        parser,
        () => {
          parser.expect(token);
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tsNextThenParseType(parser) {
    return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsDoThenParseType(parser, () => parser.next());
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsDoThenParseType(parser, cb) {
    cb();
    return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSType(parser);
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSEnumMember(parser) {
    const start = parser.getPosition();
    // Computed property names are grammar errors in an enum, so accept just string literal or identifier.
    const id = parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string)
      ? ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseStringLiteral(parser) : ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, /* liberal */true);

    let initializer;
    if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq)) {
      initializer =
        ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
          parser,
          'ts enum member initializer',
        );
    }

    return (
      parser.finishNode(
        start,
        {
          type: 'TSEnumMember',
          initializer,
          id,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSEnumDeclaration(
    parser,
    start,
    isConst,
  ) {
    parser.addDiagnosticFilter(
      {
        message: 'enum is a reserved word',
        start,
      },
    );

    const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);

    const openContext = parser.expectOpening(
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
      'ts enum declaration',
    );

    const members = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSDelimitedList(parser, 'EnumMembers', ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSEnumMember);
    parser.expectClosing(openContext);

    return (
      parser.finishNode(
        start,
        {
          type: 'TSEnumDeclaration',
          members,
          id,
          const: isConst,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModuleBlock(parser) {
    const start = parser.getPosition();

    const openContext = parser.expectOpening(
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
      'ts module block',
    );

    // Inside of a module block is considered 'top-level', meaning it can have imports and exports.
    const {body} = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlockOrModuleBlockBody(
      parser,
      /* allowDirectives */false,
      /* topLevel */true,
      openContext,
    );
    return (
      parser.finishNode(
        start,
        {
          type: 'TSModuleBlock',
          body,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModuleOrNamespaceDeclaration(
    parser,
    start,
  ) {
    const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);

    let body;
    if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot)) {
      body = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModuleOrNamespaceDeclaration(parser, parser.getPosition());
    } else {
      body = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModuleBlock(parser);
    }

    return (
      parser.finishNode(
        start,
        {
          type: 'TSModuleDeclaration',
          id,
          body,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSAmbientExternalModuleDeclaration(
    parser,
    start,
  ) {
    let global;
    let id;
    if (parser.isContextual('global')) {
      global = true;
      id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);
    } else if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string)) {
      id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseStringLiteral(parser);
    } else {
      throw parser.unexpected();
    }

    let body;
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL)) {
      body = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModuleBlock(parser);
    } else {
      parser.semicolon();
    }

    return (
      parser.finishNode(
        start,
        {
          type: 'TSModuleDeclaration',
          id,
          global,
          body,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSImportEqualsDeclaration(
    parser,
    start,
    isExport = false,
  ) {
    const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);
    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq);

    const moduleReference = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModuleReference(parser);
    parser.semicolon();

    return (
      parser.finishNode(
        start,
        {
          type: 'TSImportEqualsDeclaration',
          id,
          moduleReference,
          isExport,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsExternalModuleReference(parser) {
    return (
      parser.isContextual('require') &&
        parser.lookaheadState().tokenType ===
        ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModuleReference(parser) {
    return (
      ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsExternalModuleReference(parser)
        ? ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSExternalModuleReference(
          parser,
        ) : ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSEntityName(parser, /* allowReservedWords */false)
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSExternalModuleReference(
    parser,
  ) {
    const start = parser.getPosition();
    parser.expectContextual('require');
    const openContext = parser.expectOpening(
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
      'ts external module reference',
    );

    let expression;
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string)) {
      expression = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseStringLiteral(parser);
    } else {
      parser.addDiagnostic(
        {
          message: 'Invalid TS external module reference expression',
        },
      );

      // Skip as much of the next expression as we can
      ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionAtom(parser, 'ts external module reference expression');

      // Create a fake string literal
      expression =
        parser.finishNode(
          start,
          {
            type: 'StringLiteral',
            value: '',
          },
        );
    }

    parser.expectClosing(openContext);

    return (
      parser.finishNode(
        start,
        {
          type: 'TSExternalModuleReference',
          expression,
        },
      )
    );
  }

  // Utilities

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$lookaheadTS(parser, f) {
    const state = parser.cloneState();
    const res = f(parser);
    parser.state = state;
    return res;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSParse(
    parser,
    f,
  ) {
    const state = parser.cloneState();
    const result = f(parser);
    if (result === undefined || result === false) {
      parser.state = state;
      return undefined;
    } else {
      return result;
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSDeclare(parser, start) {
    let starttype = parser.state.tokenType;
    let kind;
    if (parser.isContextual('let')) {
      starttype = ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._var;
      kind = 'let';
    }

    if (starttype === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._const && parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._const) &&
      parser.isLookaheadContextual('enum')) {
      // `const enum = 0;` not allowed because 'enum' is a strict mode reserved word.
      parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._const);
      parser.expectContextual('enum');
      return (
        Object.assign(
          {
            declare: true,
          },
          ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSEnumDeclaration(parser, start, /* isConst */true),
        )
      );
    }

    switch (starttype) {
      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._function:
        return (
          Object.assign(
            {
            },
            ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionDeclaration(parser, start, false),
            {
              declare: true,
            },
          )
        );

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._class:
        return (
          Object.assign(
            {
            },
            ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseClassDeclaration(parser, start),
            {
              declare: true,
            },
          )
        );

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._const:
      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._var:
        kind =
          kind === undefined
            ? ___R$project$rome$$romejs$js$parser$parser$statement_ts$assertVarKind(String(parser.state.tokenValue)) : kind;
        return (
          Object.assign(
            {
              declare: true,
            },
            ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseVarStatement(parser, start, kind),
          )
        );

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name:
        {
          const value = String(parser.state.tokenValue);

          if (value === 'global') {
            return (
              Object.assign(
                {
                  declare: true,
                },
                ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSAmbientExternalModuleDeclaration(parser, start),
              )
            );
          } else if (___R$project$rome$$romejs$js$parser$parser$typescript_ts$isTSDeclarationStart(parser)) {
            const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseReferenceIdentifier(parser);
            const decl = ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeExpressionStatement(parser, start, id);

            if (decl === undefined) {
              throw new Error('Should have returned a node');
            }

            if (decl.type !== 'TSInterfaceDeclaration' &&
              decl.type !==
              'TypeAliasTypeAnnotation' &&
              decl.type !== 'TSEnumDeclaration' &&
              decl.type !== 'FunctionDeclaration' &&
              decl.type !==
              'ClassDeclaration' &&
              decl.type !== 'VariableDeclarationStatement' &&
              decl.type !== 'TSDeclareFunction' &&
              decl.type !==
              'TSModuleDeclaration') {
              throw (
                new Error(
                  'Encountered a non-TS declare node when calling parseTypeExpressionStatement',
                )
              );
            }

            return Object.assign(
              {
              },
              decl,
              {
                declare: true,
              },
            );
          }
        }
    }

    parser.addDiagnostic(
      {
        message: 'Unknown typescript declare start',
      },
    );

    // Fake node
    const loc = parser.finishLoc(start);
    return (
      {
        type: 'VariableDeclarationStatement',
        loc,
        declaration: {
          type: 'VariableDeclaration',
          loc,
          kind: 'var',
          declarations: [
            {
              type: 'VariableDeclarator',
              loc,
              id: ___R$project$rome$$romejs$js$parser$parser$expression_ts$toBindingIdentifier(
                parser,
                parser.createUnknownIdentifier(
                  'typescript declare start',
                  start,
                ),
              ),
              init: undefined,
            },
          ],
        },
      }
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSAbstractClass(
    parser,
    start,
  ) {
    return (
      Object.assign(
        {
        },
        ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseClassDeclaration(parser, start),
        {
          abstract: true,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSExportDefaultAbstractClass(
    parser,
    start,
  ) {
    return (
      Object.assign(
        {
        },
        ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseExportDefaultClassDeclaration(parser, start),
        {
          abstract: true,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeArguments(
    parser,
  ) {
    const start = parser.getPosition();
    parser.pushScope('TYPE', true);

    const params = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsInNoContext(
      parser,
      () => {
        parser.expectRelational('<');
        return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSDelimitedList(parser, 'TypeParametersOrArguments', ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSType);
      },
    );

    // This reads the next token after the `>` too, so do parser.in the enclosing context.

    // But be sure not to parse a regex in the jsx expression `<C<number> />`, so set exprAllowed = false
    parser.state.exprAllowed = false;
    parser.popScope('TYPE');
    parser.expectRelational('>');

    return (
      parser.finishNode(
        start,
        {
          type: 'TSTypeParameterInstantiation',
          params,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$isTSDeclarationStart(parser) {
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name)) {
      switch (parser.state.tokenValue) {
        case 'abstract':
        case 'declare':
        case 'enum':
        case 'interface':
        case 'module':
        case 'namespace':
        case 'type':
          return true;
      }
    }

    return false;
  }

  function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSAccessModifier(
    parser,
  ) {
    return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModifier(parser, ['public', 'protected', 'private']);
  }

  function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$isTSAbstractClass(parser) {
    return (
      parser.isContextual('abstract') &&
        parser.lookaheadState().tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._class
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSExport(
    parser,
    start,
  ) {
    if (!parser.isSyntaxEnabled('ts')) {
      return undefined;
    }

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._import)) {
      // `export const A =B;`
      parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._import);
      return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSImportEqualsDeclaration(parser, start, /* isExport */true);
    }

    if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq)) {
      // `export = x;`
      const expression = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(parser, 'ts export assignment');
      parser.semicolon();
      return (
        parser.finishNode(
          start,
          {
            type: 'TSExportAssignment',
            expression,
          },
        )
      );
    }

    if (parser.eatContextual('as')) {
      // `export as namespace A;`

      // See `parseNamespaceExportDeclaration` in TypeScript's own parser
      parser.expectContextual('namespace');
      const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser);
      parser.semicolon();
      return (
        parser.finishNode(
          start,
          {
            type: 'TSNamespaceExportDeclaration',
            id,
          },
        )
      );
    }
  }

  // project-rome/@romejs/js-parser/parser/classes.ts
const ___R$project$rome$$romejs$js$parser$parser$classes_ts = {
    parseClassExpression: ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseClassExpression,
    parseExportDefaultClassDeclaration: ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseExportDefaultClassDeclaration,
    parseClassDeclaration: ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseClassDeclaration,
    parseClass: ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseClass,
  };
  function ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseClassExpression(
    parser,
    start,
  ) {
    return (
      parser.finalizeNode(
        Object.assign(
          {
          },
          ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseClass(parser, start, true),
          {
            type: 'ClassExpression',
          },
        ),
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseExportDefaultClassDeclaration(
    parser,
    start,
  ) {
    let ___R$ = ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseClass(parser, start, true);
    let shape = Object.assign(
      {
      },
      ___R$,
    );
    delete shape.id;
    let {
      id,
    } = ___R$;
    if (id === undefined) {
      id =
        {
          type: 'BindingIdentifier',
          name: '*default*',
          // Does this `loc` make sense?
          loc: shape.loc,
        };
    }

    return (
      parser.finalizeNode(
        Object.assign(
          {
          },
          shape,
          {
            type: 'ClassDeclaration',
            id,
          },
        ),
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseClassDeclaration(
    parser,
    start,
  ) {
    const ___R$1 = ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseClass(parser, start, false);
    const shape = Object.assign(
      {
      },
      ___R$1,
    );
    delete shape.id;
    const {
      id,
    } = ___R$1;
    if (id === undefined) {
      throw new Error('Expected id');
    }

    return (
      parser.finalizeNode(
        Object.assign(
          {
          },
          shape,
          {
            type: 'ClassDeclaration',
            id,
          },
        ),
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseClass(
    parser,
    start,
    optionalId,
  ) {
    parser.pushScope('METHOD', false);
    parser.pushScope('STRICT', true);

    parser.next();
    const {id, typeParameters} = ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassId(parser, optionalId);
    const {superClass, superTypeParameters, implemented} = ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassSuper(parser);

    parser.pushScope('CLASS', superClass === undefined ? 'normal' : 'derived');

    const body = ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassBody(parser);

    parser.popScope('CLASS');
    parser.popScope('STRICT');
    parser.popScope('METHOD');

    const meta = parser.finishNode(
      start,
      {
        type: 'ClassHead',
        body,
        typeParameters,
        superClass,
        superTypeParameters,
        implements: implemented,
      },
    );

    return (
      {
        loc: parser.finishLoc(start),
        id,
        meta,
      }
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$isClassProperty(parser) {
    return (
      parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bang) || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon) || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq) ||
      parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi) ||
      parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR)
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$isClassMethod(parser) {
    return parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL) || parser.isRelational('<');
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$isNonstaticConstructor(
    parser,
    key,
    meta,
  ) {
    // Class property
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      return false;
    }

    // Static
    if (meta.static) {
      return false;
    }

    if (key.type === 'StaticPropertyKey' && key.value.type === 'Identifier' &&
      key.value.name === 'constructor') {
      return true;
    }

    if (key.value.type === 'StringLiteral' && key.value.value === 'constructor') {
      return true;
    }

    return false;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassBody(parser) {
    // class bodies are implicitly strict
    parser.pushScope('STRICT', true);
    parser.state.classLevel = ___R$project$rome$$romejs$ob1$index_ts$inc(parser.state.classLevel);

    const state = {hadConstructor: false};

    const body = [];

    const openContext = parser.expectOpening(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR, 'class body');

    while (true) {
      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR) || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof)) {
        break;
      }

      if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi)) {
        continue;
      }

      const member = ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassMember(parser, state);
      if (member !== undefined) {
        body.push(member);
      }
    }

    parser.expectClosing(openContext);

    parser.state.classLevel = ___R$project$rome$$romejs$ob1$index_ts$dec(parser.state.classLevel);
    parser.popScope('STRICT');

    return body;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassMember(
    parser,
    state,
  ) {
    const start = parser.getPosition();
    const escapePosition = parser.state.escapePosition;

    let accessibility;
    if (parser.isSyntaxEnabled('ts')) {
      accessibility = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSAccessModifier(parser);
    }

    let isStatic = false;
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name) && parser.state.tokenValue === 'static') {
      const keyId = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true); // eats 'static'
      const key = {
        type: 'StaticPropertyKey',
        value: keyId,
        loc: keyId.loc,
      };

      const meta = parser.finishNode(
        start,
        {
          type: 'ClassPropertyMeta',
          static: false,
          typeAnnotation: undefined,
          accessibility,
          optional: false,
          abstract: false,
          readonly: false,
        },
      );

      if (___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$isClassMethod(parser)) {
        // A method named 'static'
        return (
          ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassMethod(
            parser,
            {
              start,
              meta,
              key,
              kind: 'method',
              isStatic: false,
              isAsync: false,
              isGenerator: false,
              isConstructor: false,
            },
          )
        );
      }

      if (___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$isClassProperty(parser)) {
        // A property named 'static'
        return ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassProperty(parser, start, key, meta);
      }

      if (escapePosition !== undefined) {
        parser.addDiagnostic(
          {
            index: escapePosition,
            message: 'No escapes allowed in static contextual keyword',
          },
        );
      }

      // Otherwise something static
      isStatic = true;
    }

    return (
      ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassMemberWithIsStatic(
        parser,
        start,
        state,
        isStatic,
        accessibility,
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassMemberWithIsStatic(
    parser,
    start,
    state,
    isStatic,
    accessibility,
  ) {
    let abstract = false;
    let readonly = false;

    const mod = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModifier(parser, ['abstract', 'readonly']);
    switch (mod) {
      case 'readonly':
        readonly = true;
        abstract = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$hasTSModifier(parser, ['abstract']);
        break;

      case 'abstract':
        abstract = true;
        readonly = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$hasTSModifier(parser, ['readonly']);
        break;
    }

    const nameOpts = {
      start,
      static: isStatic,
      accessibility,
      readonly,
      abstract,
    };

    if (!abstract && !isStatic && accessibility === undefined) {
      const indexSignature = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSParseIndexSignature(parser, start);
      if (indexSignature) {
        return (
          Object.assign(
            {
            },
            indexSignature,
            {
              readonly,
            },
          )
        );
      }
    }

    // Must be a property (if not an index signature).
    if (readonly) {
      const {key, meta} = ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPropertyMeta(parser, nameOpts);
      if (key.value.type === 'PrivateName') {
        return ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPrivateProperty(parser, start, key.value, meta);
      } else {
        return ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$pushClassProperty(parser, start, key, meta);
      }
    }

    // Generator methods
    if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star)) {
      const {meta, key} = ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPropertyMeta(parser, nameOpts);

      if (key.value.type === 'PrivateName') {
        // Private generator method
        return (
          ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPrivateMethod(
            parser,
            {
              start,
              key: key.value,
              variance: undefined,
              meta,
              isGenerator: true,
              isAsync: false,
              kind: 'method',
            },
          )
        );
      }

      if (___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$isNonstaticConstructor(parser, key, meta)) {
        parser.addDiagnostic(
          {
            loc: key.loc,
            message: 'Constructor can\'t be a generator',
          },
        );
      }

      return (
        ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassMethod(
          parser,
          {
            start,
            key,
            meta,
            kind: 'method',
            isStatic: false,
            isGenerator: true,
            isAsync: false,
            isConstructor: false,
          },
        )
      );
    }

    const escapePosition = parser.state.escapePosition;
    const {meta, key} = ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPropertyMeta(parser, nameOpts);

    // Regular method
    if (___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$isClassMethod(parser)) {
      // Private method
      if (key.value.type === 'PrivateName') {
        return (
          ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPrivateMethod(
            parser,
            {
              start,
              key: key.value,
              meta,
              isGenerator: false,
              isAsync: false,
              kind: 'method',
              variance: undefined,
            },
          )
        );
      }

      const isConstructor = ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$isNonstaticConstructor(parser, key, meta);

      let kind = 'method';
      if (isConstructor) {
        kind = 'constructor';

        // TypeScript allows multiple overloaded constructor declarations
        if (state.hadConstructor && !parser.isSyntaxEnabled('ts')) {
          parser.addDiagnostic(
            {
              loc: key.loc,
              message: 'Duplicate constructor in the same class',
            },
          );
        }
        state.hadConstructor = true;
      }

      return (
        ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassMethod(
          parser,
          {
            start,
            key,
            meta,
            kind,
            isStatic,
            isGenerator: false,
            isAsync: false,
            isConstructor,
          },
        )
      );
    }

    // Class property
    if (___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$isClassProperty(parser)) {
      if (key.value.type === 'PrivateName') {
        return ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPrivateProperty(parser, start, key.value, meta);
      } else {
        return ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$pushClassProperty(parser, start, key, meta);
      }
    }

    // Async method
    if (key.value.type === 'Identifier' && key.value.name === 'async' &&
      !parser.isLineTerminator()) {
      parser.banUnicodeEscape(escapePosition, 'async');

      // an async method
      const isGenerator = parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star);

      // The so-called parsed name would have been "async": get the real name.
      const {meta, key} = ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPropertyMeta(parser, nameOpts);

      if (key.value.type === 'PrivateName') {
        // private async method
        return (
          ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPrivateMethod(
            parser,
            {
              start,
              key: key.value,
              meta,
              isGenerator,
              isAsync: true,
              kind: 'method',
              variance: undefined,
            },
          )
        );
      } else {
        const method = ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassMethod(
          parser,
          {
            start,
            key,
            meta,
            kind: 'method',
            isStatic,
            isGenerator,
            isAsync: true,
            isConstructor: false,
          },
        );

        if (___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$isNonstaticConstructor(parser, key, meta)) {
          parser.addDiagnostic(
            {
              loc: key.loc,
              message: 'Constructor can\'t be an async function',
            },
          );
        }

        return method;
      }
    }

    // Getter/setter method
    if (key.value.type === 'Identifier' &&
      (key.value.name === 'get' ||
      key.value.name === 'set') &&
      !(parser.isLineTerminator() &&
        parser.match(
          ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star,
        ))) {
      // `get\n*` is an uninitialized property named 'get' followed by a generator.

      // a getter or setter
      const kind = key.value.name;
      parser.banUnicodeEscape(escapePosition, kind);

      // The so-called parsed name would have been "get/set": get the real name.
      const {meta, key: methodKey} = ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPropertyMeta(parser, nameOpts);

      if (methodKey.value.type === 'PrivateName') {
        // private getter/setter
        const method = ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPrivateMethod(
          parser,
          {
            start,
            key: methodKey.value,
            meta,
            isGenerator: false,
            isAsync: false,
            kind,
            variance: undefined,
          },
        );
        ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkGetterSetterParamCount(parser, method, method.kind);
        return method;
      } else {
        const method = ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassMethod(
          parser,
          {
            start,
            key: methodKey,
            meta,
            kind,
            isStatic: false,
            isGenerator: false,
            isAsync: false,
            isConstructor: false,
          },
        );

        if (___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$isNonstaticConstructor(parser, key, meta)) {
          parser.addDiagnostic(
            {
              loc: methodKey.loc,
              message: 'Constructor can\'t have get/set modifier',
            },
          );
        }

        ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkGetterSetterParamCount(parser, method, method.kind);
        return method;
      }
    }

    if (parser.isLineTerminator()) {
      // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)
      if (key.value.type === 'PrivateName') {
        return ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPrivateProperty(parser, start, key.value, meta);
      } else {
        return ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$pushClassProperty(parser, start, key, meta);
      }
    }

    parser.addDiagnostic(
      {
        message: 'Unknown class property start',
      },
    );
    return undefined;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPropertyMeta(
    parser,
    opts,
  ) {
    let typeAnnotation;
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      typeAnnotation = ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parsePrimaryTypeAnnotation(parser);
    }

    const key = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPropertyKey(parser);

    if (key.type === 'StaticPropertyKey' && opts.static === true &&
      key.value.type === 'Identifier' &&
      key.value.name === 'prototype') {
      parser.addDiagnostic(
        {
          loc: key.loc,
          message: 'Classes may not have static property named prototype',
        },
      );
    }

    if (key.value.type === 'PrivateName' && key.value.id.name === 'constructor') {
      parser.addDiagnostic(
        {
          loc: key.loc,
          message: 'Classes may not have a private field named \'#constructor\'',
        },
      );
    }

    let optional = false;
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question)) {
      optional = true;

      if (!parser.isSyntaxEnabled('ts')) {
        parser.addDiagnostic(
          {
            message: 'Optional syntax but ts is not enabled',
          },
        );
      }

      parser.next();
    }

    return (
      {
        key,
        meta: parser.finishNode(
          opts.start,
          Object.assign(
            {
              type: 'ClassPropertyMeta',
              typeAnnotation,
              optional,
            },
            opts,
          ),
        ),
      }
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$pushClassProperty(
    parser,
    start,
    key,
    meta,
  ) {
    // This only affects properties, not methods.
    if (___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$isNonstaticConstructor(parser, key, meta)) {
      parser.addDiagnostic(
        {
          loc: key.loc,
          message: 'Classes may not have a non-static field named \'constructor\'',
        },
      );
    }

    return ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassProperty(parser, start, key, meta);
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassMethod(
    parser,
    opts,
  ) {
    const {start, key, meta, kind, isGenerator, isAsync, isConstructor} = opts;

    if (key.variance !== undefined) {
      parser.addDiagnostic(
        {
          loc: key.variance.loc,
          message: 'variance not allowed here',
        },
      );
    }

    const typeParameters = ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$maybeParseTypeParameters(parser);

    const {head, body} = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMethod(
      parser,
      {
        kind,
        isClass: true,
        isGenerator,
        isAsync,
        isConstructor,
      },
    );

    const method = {
      head: Object.assign(
        {
        },
        head,
        {
          typeParameters,
        },
      ),
      loc: parser.finishLoc(start),
      kind,
      key,
      meta,
    };

    if (body === undefined) {
      return (
        parser.finalizeNode(
          Object.assign(
            {
            },
            method,
            {
              type: 'TSDeclareMethod',
              body: undefined,
            },
          ),
        )
      );
    } else {
      if (body.type !== 'BlockStatement') {
        throw new Error('Expected BlockStatement body');
      }

      if (key.value.type === 'PrivateName') {
        throw new Error('Expected to hit other private methods instead');
      }

      return (
        parser.finalizeNode(
          Object.assign(
            {
            },
            method,
            {
              body,
              type: 'ClassMethod',
            },
          ),
        )
      );
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPrivateMethod(
    parser,
    opts,
  ) {
    const {start, key, variance, meta, isGenerator, isAsync, kind} = opts;

    if (variance !== undefined) {
      parser.addDiagnostic(
        {
          loc: variance.loc,
          message: 'variance not allowed here',
        },
      );
    }

    const typeParameters = ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$maybeParseTypeParameters(parser);
    const method = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMethod(
      parser,
      {
        kind,
        isClass: true,
        isGenerator,
        isAsync,
        isConstructor: false,
      },
    );

    const {body} = method;
    if (body === undefined || body.type !== 'BlockStatement') {
      throw new Error('Expected body');
    }

    return (
      parser.finishNode(
        start,
        Object.assign(
          {
          },
          method,
          {
            body,
            meta,
            key,
            kind,
            type: 'ClassPrivateMethod',
            variance,
            head: Object.assign(
              {
              },
              method.head,
              {
                typeParameters,
              },
            ),
          },
        ),
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPrivateProperty(
    parser,
    start,
    key,
    meta,
  ) {
    parser.pushScope('CLASS_PROPERTY', true);

    let typeAnnotation;
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      typeAnnotation = ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parsePrimaryTypeAnnotation(parser);
    }

    const value = parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq)
      ? ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
        parser,
        'class private property value',
      ) : undefined;
    parser.semicolon();
    parser.popScope('CLASS_PROPERTY');

    return (
      parser.finishNode(
        start,
        {
          meta,
          key,
          type: 'ClassPrivateProperty',
          value,
          typeAnnotation,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassProperty(
    parser,
    start,
    key,
    meta,
  ) {
    // TODO maybe parsing should be abstracted for private class properties too?
    let definite;
    if (!meta.optional && parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bang)) {
      definite = true;

      if (!parser.isSyntaxEnabled('ts')) {
        parser.addDiagnostic(
          {
            message: 'Definite syntax but ts is not enabled',
          },
        );
      }
    }

    let typeAnnotation;
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      typeAnnotation = ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parsePrimaryTypeAnnotation(parser);
    }

    parser.pushScope('CLASS_PROPERTY', true);

    let value;
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq)) {
      parser.next();
      value = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, 'class property value');
    }
    parser.semicolon();

    parser.popScope('CLASS_PROPERTY');

    if (key.value.type === 'PrivateName') {
      throw (
        new Error(
          'PrivateName encountered in regular parseClassProperty, expects method is parsePrivateClassProperty',
        )
      );
    }

    return (
      parser.finishNode(
        start,
        {
          meta,
          key,
          type: 'ClassProperty',
          definite,
          typeAnnotation,
          value,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassId(
    parser,
    optionalId,
  ) {
    let idAllowed = true;

    // Allow `class implements Foo {}` in class expressions
    if (optionalId === true && parser.isContextual('implements')) {
      idAllowed = false;
    }

    let id;
    if (idAllowed) {
      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name)) {
        id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);
      } else if (!optionalId) {
        parser.addDiagnostic(
          {
            message: 'A class name is required',
          },
        );
        id =
          ___R$project$rome$$romejs$js$parser$parser$expression_ts$toBindingIdentifier(
            parser,
            parser.createUnknownIdentifier(
              'required class name',
            ),
          );
      }
    }

    const typeParameters = ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$maybeParseTypeParameters(parser, true);
    return {id, typeParameters};
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassSuper(
    parser,
  ) {
    let superClass = parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._extends)
      ? ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionWithPossibleSubscripts(parser, 'class heritage') : undefined;
    let superTypeParameters;

    if (superClass !== undefined) {
      superTypeParameters = ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$maybeParseTypeArguments(parser);
    }

    let implemented;
    if (parser.isContextual('implements')) {
      parser.next();
      implemented = ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseClassImplements(parser);
    }

    return {superClass, superTypeParameters, implemented};
  }

  // project-rome/@romejs/js-parser/parser/type-systems.ts
const ___R$project$rome$$romejs$js$parser$parser$type$systems_ts = {
    isTypeSystemEnabled: ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$isTypeSystemEnabled,
    parseTypeLiteralAnnotation: ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeLiteralAnnotation,
    addFlowOrTSDiagnostic: ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$addFlowOrTSDiagnostic,
    addFlowDiagnostic: ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$addFlowDiagnostic,
    addTSDiagnostic: ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$addTSDiagnostic,
    parseClassImplements: ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseClassImplements,
    parsePrimaryTypeAnnotation: ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parsePrimaryTypeAnnotation,
    parseInterface: ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseInterface,
    parseDeclare: ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseDeclare,
    parseTypeAnnotationAndPredicate: ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeAnnotationAndPredicate,
    parseTypeAlias: ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeAlias,
    parseTypeParameters: ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeParameters,
    maybeParseTypeParameters: ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$maybeParseTypeParameters,
    parseTypeArguments: ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeArguments,
    parseTypeCallArguments: ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeCallArguments,
    maybeParseTypeArguments: ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$maybeParseTypeArguments,
    parseTypeExpressionStatement: ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeExpressionStatement,
    ambiguousTypeCastToParameter: ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$ambiguousTypeCastToParameter,
  };
  function ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$isTypeSystemEnabled(parser) {
    return parser.isSyntaxEnabled('flow') || parser.isSyntaxEnabled('ts');
  }

  function ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeLiteralAnnotation(
    parser,
  ) {
    const start = parser.getPosition();

    switch (parser.state.tokenType) {
      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string:
        {
          const value = String(parser.state.tokenValue);
          parser.next();
          return (
            parser.finishNode(
              start,
              {
                type: 'StringLiteralTypeAnnotation',
                value,
              },
            )
          );
        }

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.num:
        {
          const value = Number(parser.state.tokenValue);
          parser.next();
          return (
            parser.finishNode(
              start,
              {
                type: 'NumericLiteralTypeAnnotation',
                value,
              },
            )
          );
        }

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._true:
      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._false:
        {
          const value = parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._true);
          parser.next();
          return (
            parser.finishNode(
              start,
              {
                type: 'BooleanLiteralTypeAnnotation',
                value,
              },
            )
          );
        }

      case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.plusMin:
        {
          if (parser.state.tokenValue === '-') {
            parser.next();

            if (!parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.num)) {
              parser.addDiagnostic(
                {
                  message: 'Unexpected token, expected "number"',
                },
              );
              parser.next();
              return (
                parser.finishNode(
                  start,
                  {
                    type: 'NumericLiteralTypeAnnotation',
                    value: 0,
                  },
                )
              );
            }

            const value = Number(parser.state.tokenValue);
            parser.next();
            return (
              parser.finishNode(
                start,
                {
                  type: 'NumericLiteralTypeAnnotation',
                  value: -value,
                },
              )
            );
          } else {
            parser.addDiagnostic(
              {
                message: 'Numeric literal type annotations cannot stand with a +, omit it instead',
              },
            );
            parser.next();

            if (!parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.num)) {
              parser.addDiagnostic(
                {
                  message: 'Unexpected token, expected "number"',
                },
              );
              parser.next();
              return (
                parser.finishNode(
                  start,
                  {
                    type: 'NumericLiteralTypeAnnotation',
                    value: 0,
                  },
                )
              );
            }

            return ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeLiteralAnnotation(parser);
          }
        }

      default:
        throw (
          new Error(
            'Caller should have already validated the range of token types',
          )
        );
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$type$systems_ts$parseFlowOrTS(
    parser,
    label,
    flow,
    ts,
  ) {
    if (parser.isSyntaxEnabled('flow')) {
      return flow(parser);
    } else if (parser.isSyntaxEnabled('ts')) {
      return ts(parser);
    } else {
      const branches = parser.createBranch();

      // Suppress disabled syntax errors
      parser.syntax.add('flow');
      branches.add(flow);
      parser.syntax.delete('flow');

      // If we parsed this as Flow syntax, then it's definitely valid Flow syntax, but could also be valid TS syntax since sometimes they intersect
      let isFlowOrTS = branches.hasOptimalBranch();

      // Suppress disabled syntax errors
      parser.syntax.add('ts');
      branches.add(ts);
      parser.syntax.delete('ts');

      // If we didn't pick the Flow branch but picked the TS one, then this could only ever be TS syntax
      let isOnlyTS = !isFlowOrTS && branches.hasOptimalBranch();

      const start = parser.getPosition();
      const node = branches.pick();

      if (isOnlyTS) {
        ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$addTSDiagnostic(parser, label, start);
      } else {
        ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$addFlowOrTSDiagnostic(parser, label, start);
      }

      return node;
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$addFlowOrTSDiagnostic(
    parser,
    label,
    start,
  ) {
    if (parser.isSyntaxEnabled('ts') || parser.isSyntaxEnabled('flow')) {
      return;
    }

    parser.addDiagnostic(
      {
        start,
        message: 'A ' +
        label +
        ' is only valid inside of a TypeScript or Flow file',
        advice: [
          {
            type: 'log',
            category: 'info',
            message: 'Did you mean <emphasis>TypeScript</emphasis>? Change the file extension to <emphasis>.ts</emphasis> or <emphasis>.tsx</emphasis>',
          },
          {
            type: 'log',
            category: 'info',
            message: 'Did you mean <emphasis>Flow</emphasis>? Add a <emphasis>@flow</emphasis> comment annotation to the top of the file',
          },
        ],
      },
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$addFlowDiagnostic(
    parser,
    label,
    start,
  ) {
    if (parser.isSyntaxEnabled('flow')) {
      return;
    }

    parser.addDiagnostic(
      {
        start,
        message: 'A ' +
        label +
        ' is only valid inside of a Flow file',
        advice: [
          {
            type: 'log',
            category: 'info',
            message: 'To enable <emphasis>Flow</emphasis> support, add a <emphasis>@flow</emphasis> comment annotation to the top of the file',
          },
        ],
      },
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$addTSDiagnostic(parser, label, start) {
    if (parser.isSyntaxEnabled('ts')) {
      return;
    }

    parser.addDiagnostic(
      {
        start,
        message: 'A ' +
        label +
        ' is only valid inside of a TypeScript file',
        advice: [
          {
            type: 'log',
            category: 'info',
            message: 'To enable <emphasis>TypeScript</emphasis> support, the file extension should end in <emphasis>.ts</emphasis> or <emphasis>.tsx</emphasis>',
          },
        ],
      },
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseClassImplements(
    parser,
  ) {
    return (
      ___R$$priv$project$rome$$romejs$js$parser$parser$type$systems_ts$parseFlowOrTS(
        parser,
        'class implements',
        ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowClassImplemented,
        () => ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSHeritageClause(parser, 'implements'),
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parsePrimaryTypeAnnotation(parser) {
    return (
      ___R$$priv$project$rome$$romejs$js$parser$parser$type$systems_ts$parseFlowOrTS(
        parser,
        'type annotation',
        ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeAnnotation,
        () =>
          ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(parser, true),
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseInterface(
    parser,
    start,
  ) {
    parser.addDiagnosticFilter(
      {
        message: 'interface is a reserved word',
        start,
      },
    );

    return (
      ___R$$priv$project$rome$$romejs$js$parser$parser$type$systems_ts$parseFlowOrTS(
        parser,
        'interface',
        () =>
          ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowInterface(parser, start),
        () =>
          ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSInterfaceDeclaration(parser, start),
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseDeclare(
    parser,
    start,
  ) {
    return (
      ___R$$priv$project$rome$$romejs$js$parser$parser$type$systems_ts$parseFlowOrTS(
        parser,
        'type declaration',
        () =>
          ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowDeclare(parser, start),
        () => ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSDeclare(parser, start),
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeAnnotationAndPredicate(
    parser,
  ) {
    return (
      ___R$$priv$project$rome$$romejs$js$parser$parser$type$systems_ts$parseFlowOrTS(
        parser,
        'type annotation and a predicate',
        () => {
          return ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeAndPredicateInitialiser(parser);
        },
        () => {
          return (
            [
              ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon),
              undefined,
            ]
          );
        },
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeAlias(
    parser,
    start,
  ) {
    return (
      ___R$$priv$project$rome$$romejs$js$parser$parser$type$systems_ts$parseFlowOrTS(
        parser,
        'type alias',
        () =>
          ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeAliasTypeAnnotation(parser, start),
        () =>
          ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAliasTypeAnnotation(parser, start),
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeParameters(
    parser,
    allowDefault = false,
  ) {
    return (
      ___R$$priv$project$rome$$romejs$js$parser$parser$type$systems_ts$parseFlowOrTS(
        parser,
        'type parameters',
        () =>
          ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterDeclaration(parser, allowDefault),
        ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeParameters,
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$maybeParseTypeParameters(
    parser,
    allowDefault,
  ) {
    if (parser.isRelational('<')) {
      return ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeParameters(parser, allowDefault);
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeArguments(parser) {
    return (
      ___R$$priv$project$rome$$romejs$js$parser$parser$type$systems_ts$parseFlowOrTS(
        parser,
        'type arguments',
        ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterInstantiation,
        ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeArguments,
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeCallArguments(parser) {
    return (
      ___R$$priv$project$rome$$romejs$js$parser$parser$type$systems_ts$parseFlowOrTS(
        parser,
        'type call arguments',
        ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterInstantiationCallOrNew,
        ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeArguments,
      )
    );
  }

  function ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$maybeParseTypeArguments(
    parser,
  ) {
    if (parser.isRelational('<')) {
      return ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeArguments(parser);
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeExpressionStatement(
    parser,
    start,
    expr,
  ) {
    // TODO TypeScript does not like parser.isLineTerminator()
    if (expr.type !== 'ReferenceIdentifier') {
      return undefined;
    }

    // In TS, line breaks aren't allowed between the keyword and the rest of the statement

    // In Flow, they are allowed
    if (parser.isSyntaxEnabled('ts') && parser.hasPrecedingLineBreak()) {
      return undefined;
    }

    switch (expr.name) {
      case 'declare':
        if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._class) || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name) ||
        parser.match(
          ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._function,
        ) ||
        parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._const) ||
        parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._var) ||
        parser.match(
          ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._export,
        )) {
          return ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseDeclare(parser, start);
        } else {
          break;
        }

      case 'interface':
        // TODO perform some lookahead to make sure we want to do this
        return ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseInterface(parser, start);

      case 'type':
        // TODO perform some lookahead to make sure we want to do this
        return ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeAlias(parser, start);

      case 'opaque':
        // TODO perform some lookahead to make sure we want to do this
        ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$addFlowDiagnostic(parser, 'opaque type', start);
        return ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowOpaqueType(parser, start, false);

      case 'abstract':
        if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._class)) {
          ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$addTSDiagnostic(parser, 'abstract class', start);
          return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSAbstractClass(parser, start);
        } else {
          break;
        }

      case 'enum':
        {
          if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name)) {
            ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$addTSDiagnostic(parser, 'enum declaration', start);
            return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSEnumDeclaration(parser, start, /* isConst */false);
          } else {
            break;
          }
        }

      case 'module':
        if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string)) {
          ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$addTSDiagnostic(parser, 'ambient external module declaration', start);
          return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSAmbientExternalModuleDeclaration(parser, start);
        } else if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name) && !parser.isLineTerminator()) {
          ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$addTSDiagnostic(parser, 'module or namespace declaration', start);
          return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModuleOrNamespaceDeclaration(parser, start);
        } else {
          break;
        }

      case 'namespace':
        if (!parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name)) {
          return undefined;
        }

        ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$addTSDiagnostic(parser, 'module or namespace declaration', start);
        return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModuleOrNamespaceDeclaration(parser, start);

      // TODO abstract this into typescript.js
      case 'global':
        // `global { }` (with no `declare`) may appear inside an ambient module declaration.

        // Would like to use parseTSAmbientExternalModuleDeclaration here, but already ran past 'global'.
        if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL)) {
          ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$addTSDiagnostic(parser, 'module declaration', start);
          const global = true;
          const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$toBindingIdentifier(parser, expr);
          const body = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModuleBlock(parser);
          return (
            parser.finishNode(
              start,
              {
                type: 'TSModuleDeclaration',
                global,
                id,
                body,
              },
            )
          );
        }
    }
  }

  function ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$ambiguousTypeCastToParameter(
    parser,
    node,
  ) {
    const start = parser.getPosition();
    const expr = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(parser, node.expression, 'parameter');

    const meta = parser.finishNode(
      start,
      {
        type: 'PatternMeta',
        optional: node.optional,
        typeAnnotation: node.typeAnnotation,
      },
    );

    return (
      parser.finishNode(
        start,
        Object.assign(
          {
          },
          expr,
          {
            // @ts-ignore
            meta,
          },
        ),
      )
    );
  }

  // project-rome/@romejs/js-parser/parser/modules.ts
const ___R$project$rome$$romejs$js$parser$parser$modules_ts = {
    parseExport: ___R$project$rome$$romejs$js$parser$parser$modules_ts$parseExport,
    parseImport: ___R$project$rome$$romejs$js$parser$parser$modules_ts$parseImport,
  };

  function ___R$project$rome$$romejs$js$parser$parser$modules_ts$parseExport(parser, start) {
    const tsNode = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSExport(parser, start);
    if (tsNode !== undefined) {
      return tsNode;
    }

    let exportKind = 'value';
    let declaration;
    let specifiers;

    // export * from '...'';
    if (___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$shouldParseExportStar(parser)) {
      return ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportStar(parser, start);
    } else if (___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$isExportDefaultSpecifier(parser)) {
      const defStart = parser.getPosition();
      const defExported = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true);
      let specifiers = [];

      specifiers.push(
        parser.finishNode(
          defStart,
          {
            type: 'ExportDefaultSpecifier',
            exported: defExported,
          },
        ),
      );

      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma) && parser.lookaheadState().tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star) {
        parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma);
        const specifierStart = parser.getPosition();
        parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star);
        parser.expectContextual('as');
        const exported = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser);
        specifiers.push(
          parser.finishNode(
            specifierStart,
            {
              type: 'ExportNamespaceSpecifier',
              exported,
            },
          ),
        );
      } else {
        specifiers =
          [
            ...specifiers,
            ...___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$convertLocalToExternalSpecifiers(
              parser,
              ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportLocalSpecifiersMaybe(parser),
            ),
          ];
      }

      const source = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportFromExpect(parser);
      return ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$createExportExternalDeclaration(parser, start, specifiers, source);
    } else if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._default)) {
      // export default ...
      const declaration = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportDefaultExpression(parser);
      ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$checkExport(parser, specifiers, declaration, true, true);

      const node = parser.finishNode(
        start,
        {
          type: 'ExportDefaultDeclaration',
          declaration,
        },
      );
      return node;
    } else if (___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$shouldParseExportDeclaration(parser)) {
      let source;
      ({declaration, source, specifiers, exportKind} =
        ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportDeclaration(
          parser,
        ));

      if (source !== undefined) {
        if (declaration !== undefined) {
          throw (
            new Error(
              'When there\'s a source we don\'t also expect a declaration',
            )
          );
        }

        return (
          ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$createExportExternalDeclaration(
            parser,
            start,
            specifiers,
            source,
            exportKind,
          )
        );
      }
    } else if (parser.isContextual('async') &&
      !___R$project$rome$$romejs$js$parser$parser$statement_ts$isAsyncFunctionDeclarationStart(
        parser,
      )) {
      const next = parser.lookaheadState();

      parser.addDiagnostic(
        {
          start: next.startPos,
          end: next.endPos,
          message: 'Started with `export async` so we expected to receive an async function but no function keyword was found',
        },
      );
      declaration = undefined;
      specifiers = [];
    } else {
      // export { x, y as z } [from '...']';
      specifiers = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportSpecifiers(parser);

      const source = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportFrom(parser, false);
      if (source !== undefined) {
        return ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$createExportExternalDeclaration(parser, start, specifiers, source);
      }
    }

    ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$checkExport(parser, specifiers, declaration, true, false);

    if (declaration !== undefined) {
      if (declaration.type !== 'VariableDeclarationStatement' &&
        declaration.type !== 'ClassDeclaration' &&
        declaration.type !==
        'FunctionDeclaration' &&
        declaration.type !== 'TSModuleDeclaration' &&
        declaration.type !== 'TSEnumDeclaration' &&
        declaration.type !==
        'FlowInterfaceDeclaration' &&
        declaration.type !== 'TypeAliasTypeAnnotation' &&
        declaration.type !== 'TSInterfaceDeclaration' &&
        declaration.type !== 'TSDeclareFunction' &&
        declaration.type !== 'FlowOpaqueType') {
        parser.addDiagnostic(
          {
            loc: declaration.loc,
            message: 'Invalid export declaration',
          },
        );
        return declaration;
      }
    }

    const node = parser.finishNode(
      start,
      {
        type: 'ExportLocalDeclaration',
        exportKind,
        specifiers,
        declaration,
      },
    );
    return node;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$createExportExternalDeclaration(
    parser,
    start,
    rawSpecifiers,

    source,
    exportKind,
  ) {
    const specifiers = rawSpecifiers === undefined
      ? undefined : ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$convertLocalToExternalSpecifiers(parser, rawSpecifiers);
    ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$checkExport(parser, specifiers, undefined, true, false);

    return (
      parser.finishNode(
        start,
        {
          type: 'ExportExternalDeclaration',
          exportKind,
          source,
          specifiers,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$convertLocalToExternalSpecifiers(
    parser,
    specifiers,
  ) {
    return (
      specifiers.map(
        (specifier) => {
          if (specifier.type === 'ExportLocalSpecifier') {
            return (
              Object.assign(
                {
                },
                specifier,
                {
                  type: 'ExportExternalSpecifier',
                  local: ___R$project$rome$$romejs$js$parser$parser$expression_ts$toIdentifier(parser, specifier.local),
                },
              )
            );
          } else {
            return specifier;
          }
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportDefaultExpression(
    parser,
  ) {
    if (parser.isSyntaxEnabled('ts')) {
      if (___R$project$rome$$romejs$js$parser$parser$typescript_ts$isTSAbstractClass(parser)) {
        const start = parser.getPosition();
        parser.next(); // Skip 'abstract'
        return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSExportDefaultAbstractClass(parser, start);
      }

      if (parser.state.tokenValue === 'interface' && !parser.isLineTerminator()) {
        const start = parser.getPosition();
        parser.next();
        return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSInterfaceDeclaration(parser, start);
      }
    }

    const start = parser.getPosition();
    const isAsync = ___R$project$rome$$romejs$js$parser$parser$statement_ts$isAsyncFunctionDeclarationStart(parser);
    if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._function) || isAsync) {
      if (isAsync) {
        parser.eatContextual('async');
        parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._function);
      }

      return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseExportDefaultFunctionDeclaration(parser, start, isAsync);
    }

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._class)) {
      return ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseExportDefaultClassDeclaration(parser, start);
    }

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._const) || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._var) || ___R$project$rome$$romejs$js$parser$parser$statement_ts$isLetStart(parser)) {
      parser.addDiagnostic(
        {
          message: 'Only expressions, functions or classes are allowed as the `default` export.',
        },
      );
    }

    const res = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, 'export default declaration');
    parser.semicolon();
    return res;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportDeclaration(
    parser,
  ) {
    if (parser.isContextual('type')) {
      const start = parser.getPosition();
      parser.next();

      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL)) {
        // export { foo, bar };
        const specifiers = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportSpecifiers(parser);
        const source = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportFrom(parser, false);
        return (
          {
            exportKind: 'type',
            specifiers,
            source,
          }
        );
      } else {
        // export type Foo = Bar;
        return (
          {
            exportKind: 'type',
            declaration: ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseTypeAlias(parser, start),
          }
        );
      }
    }

    if (parser.isContextual('opaque')) {
      const declarationNode = parser.getPosition();
      parser.next();
      // export opaque type Foo = Bar;
      return (
        {
          exportKind: 'type',
          declaration: ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowOpaqueType(parser, declarationNode, false),
        }
      );
    }

    if (parser.isContextual('interface')) {
      const declarationNode = parser.getPosition();
      parser.next();
      return (
        {
          exportKind: 'type',
          declaration: ___R$project$rome$$romejs$js$parser$parser$type$systems_ts$parseInterface(parser, declarationNode),
        }
      );
    }

    return (
      {
        exportKind: 'value',
        declaration: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseStatement(parser),
      }
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$isExportDefaultSpecifier(parser) {
    const lookahead = parser.lookaheadState();
    if (lookahead.tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma ||
    lookahead.tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name &&
      lookahead.tokenValue === 'from') {
      return true;
    }

    if (parser.isSyntaxEnabled('ts') && ___R$project$rome$$romejs$js$parser$parser$typescript_ts$isTSDeclarationStart(parser)) {
      return false;
    }

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name) &&
      (parser.state.tokenValue === 'type' ||
      parser.state.tokenValue === 'interface' ||
      parser.state.tokenValue == 'opaque')) {
      return false;
    }

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name)) {
      return (
        parser.state.tokenValue !== 'async' &&
          parser.state.tokenValue !==
          'let'
      );
    }

    if (!parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._default)) {
      return false;
    }

    return false;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportLocalSpecifiersMaybe(
    parser,
  ) {
    if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma)) {
      return ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportSpecifiers(parser);
    } else {
      return [];
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportFromExpect(parser) {
    // @ts-ignore: `expect` parameter will always return a StringLiteral
    return ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportFrom(parser, true);
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportFrom(
    parser,
    expect,
  ) {
    let source;

    if (parser.eatContextual('from')) {
      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string)) {
        source = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseStringLiteral(parser);
      } else {
        const expr = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionAtom(parser, 'export from');

        parser.addDiagnostic(
          {
            loc: expr.loc,
            message: 'Import from only allows strings',
          },
        );

        source =
          {
            type: 'StringLiteral',
            value: '',
            loc: expr.loc,
          };
      }
    } else if (expect) {
      parser.addDiagnostic(
        {
          message: 'Expected `from` for an export node',
        },
      );

      source =
        {
          type: 'StringLiteral',
          value: '',
          loc: parser.finishLoc(parser.getPosition()),
        };
    }

    parser.semicolon();

    return source;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$shouldParseExportStar(parser) {
    return (
      parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star) ||
      parser.isContextual('type') &&
        parser.lookaheadState().tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportStar(
    parser,
    start,
  ) {
    let exportKind;
    if (parser.eatContextual('type')) {
      exportKind = 'type';
    }

    parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star);

    if (parser.isContextual('as')) {
      const {source, specifiers} = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportNamespace(parser, exportKind);
      return (
        parser.finishNode(
          start,
          {
            type: 'ExportExternalDeclaration',
            exportKind,
            specifiers,
            source,
          },
        )
      );
    } else {
      const source = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportFrom(parser, true);
      if (source === undefined) {
        throw new Error('Passed `true` above which expects there to be a string');
      }
      return (
        parser.finishNode(
          start,
          {
            type: 'ExportAllDeclaration',
            exportKind,
            source,
          },
        )
      );
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportNamespace(
    parser,
    exportKind,
  ) {
    if (exportKind === 'type') {
      parser.addDiagnostic(
        {
          message: 'Can\'t have a type export namespacer specifier',
        },
      );
    }

    const specifierStart = parser.state.lastStartPos;
    parser.next();
    const exported = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true);

    let specifiers = [];

    specifiers.push(
      parser.finishNode(
        specifierStart,
        {
          type: 'ExportNamespaceSpecifier',
          exported,
        },
      ),
    );

    specifiers =
      [
        ...specifiers,
        ...___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$convertLocalToExternalSpecifiers(
          parser,
          ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportLocalSpecifiersMaybe(
            parser,
          ),
        ),
      ];

    const source = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportFromExpect(parser);
    return {source, specifiers};
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$shouldParseExportDeclaration(parser) {
    return (
      ___R$project$rome$$romejs$js$parser$parser$typescript_ts$isTSDeclarationStart(parser) || parser.isContextual('type') ||
      parser.isContextual('interface') ||
      parser.isContextual('opaque') ||
      parser.state.tokenType.keyword === 'var' ||
      parser.state.tokenType.keyword ===
      'const' ||
      parser.state.tokenType.keyword === 'function' ||
      parser.state.tokenType.keyword === 'class' ||
      ___R$project$rome$$romejs$js$parser$parser$statement_ts$isLetStart(parser) ||
      ___R$project$rome$$romejs$js$parser$parser$statement_ts$isAsyncFunctionDeclarationStart(parser) ||
      parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.at)
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$checkExport(
    parser,
    specifiers,

    declaration,
    checkNames = false,
    isDefault = false,
  ) {
    if (checkNames === false) {
      return undefined;
    }

    // Check for duplicate exports
    if (isDefault) {
      // Default exports
      if (declaration !== undefined) {
        ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$checkDuplicateExports(parser, declaration, 'default');
      }
      return undefined;
    }

    if (specifiers !== undefined && specifiers.length > 0) {
      // Named exports
      for (const specifier of specifiers) {
        ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$checkDuplicateExports(parser, specifier, specifier.exported.name);

        if (specifier.type === 'ExportLocalSpecifier') {
          const {local} = specifier;
          if (local !== undefined) {
            // check for keywords used as local names
            ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkReservedWord(
              parser,
              local.name,
              parser.getLoc(local),
              true,
              false,
            );
          }
        }
      }
      return undefined;
    }

    if (declaration !== undefined) {
      // Exported declarations
      if (declaration.type === 'FunctionDeclaration') {
        if (declaration.id === undefined) {
          throw new Error('Expected declaration.id');
        }

        ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$checkDuplicateExports(parser, declaration, declaration.id.name);
      }

      if (declaration.type === 'ClassDeclaration') {
        if (declaration.id === undefined) {
          throw new Error('Expected declaration.id');
        }

        ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$checkDuplicateExports(parser, declaration, declaration.id.name);
      }

      if (declaration.type === 'VariableDeclaration') {
        for (const node of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(declaration)) {
          ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$checkDuplicateExports(parser, node, node.name);
        }
      }
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$checkDuplicateExports(
    parser,
    node,
    name,
  ) {
    if (parser.isSyntaxEnabled('ts')) {
      // Refer to checkReservedWord for an explanation
      return undefined;
    }

    const existing = parser.state.exportedIdentifiers.get(name);
    if (existing !== undefined) {
      parser.addDiagnostic(
        {
          loc: node.loc,
          message: name === 'default'
            ? 'Only one default export allowed per module.' : '`' +
            name +
            '` has already been exported. Exported identifiers must be unique.',
          advice: [
            {
              type: 'log',
              category: 'info',
              message: 'First defined here',
            },
            {
              type: 'frame',
              filename: existing.filename,
              start: existing.start,
              end: existing.end,
            },
          ],
        },
      );
    }

    parser.state.exportedIdentifiers.set(name, parser.getLoc(node));
  }

  // Parses a comma-separated list of module exports.
  function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportSpecifiers(parser) {
    const specifiers = [];
    let first = true;

    // export { x, y as z } [from '...']';
    const openContext = parser.expectOpening(
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
      'export specifiers',
    );

    while (true) {
      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR) || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof)) {
        parser.expectClosing(openContext);
        break;
      }

      if (first) {
        first = false;
      } else {
        parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma);
        if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR)) {
          break;
        }
      }

      const start = parser.getPosition();
      const local = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseReferenceIdentifier(parser, true);
      const exported = parser.eatContextual('as')
        ? ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true) : ___R$project$rome$$romejs$js$parser$parser$expression_ts$toIdentifier(
          parser,
          parser.cloneNode(
            local,
          ),
        );
      specifiers.push(
        parser.finishNode(
          start,
          {
            type: 'ExportLocalSpecifier',
            local,
            exported,
            // TODO exportKind?
          },
        ),
      );
    }

    return specifiers;
  }

  function ___R$project$rome$$romejs$js$parser$parser$modules_ts$parseImport(parser, start) {
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name) && parser.lookaheadState().tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq) {
      return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSImportEqualsDeclaration(parser, start);
    }

    let specifiers;
    let source;
    let importKind;

    // import '...'
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string)) {
      specifiers = [];
      source = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseStringLiteral(parser);
    } else {
      ({specifiers, importKind} = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseImportSpecifiers(parser, start));

      if (parser.expectContextual('from') && parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string)) {
        source = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseStringLiteral(parser);
      } else {
        parser.addDiagnostic(
          {
            message: 'import missing a source',
          },
        );

        source =
          parser.finishNode(
            start,
            {
              type: 'StringLiteral',
              value: '',
            },
          );
      }
    }

    parser.semicolon();
    return (
      parser.finishNode(
        start,
        {
          type: 'ImportDeclaration',
          specifiers,
          source,
          importKind,
        },
      )
    );
  }

  // eslint-disable-next-line no-unused-vars
  function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$shouldParseDefaultImport(
    parser,
    kind,
  ) {
    if (___R$project$rome$$romejs$js$parser$parser$flow_ts$hasTypeImportKind(kind)) {
      return ___R$project$rome$$romejs$js$parser$parser$flow_ts$isMaybeDefaultImport(parser.state);
    } else {
      return parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name);
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseImportSpecifierLocal(
    parser,
    importKind,
    contextDescription,
  ) {
    const start = parser.getPosition();

    const local = ___R$project$rome$$romejs$js$parser$parser$flow_ts$hasTypeImportKind(importKind)
      ? ___R$project$rome$$romejs$js$parser$parser$flow_ts$parseFlowRestrictedIdentifier(
        parser,
        true,
      ) : ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);

    ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(parser, local, true, undefined, contextDescription);

    return (
      parser.finishNode(
        start,
        {
          type: 'ImportSpecifierLocal',
          name: local,
          importKind,
        },
      )
    );
  }

  // Parses a comma-separated list of module imports.
  function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseImportSpecifiers(
    parser,
    start,
  ) {
    let importKind = undefined;

    // Ensure that when parsing `import from './type.js` we don't mistakenly think it's an import type';

    // TODO probably need to check for a comma and `as`
    const lh = parser.lookaheadState();
    if (lh.tokenType !== ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name ||
    lh.tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name &&
      lh.tokenValue !==
      'from') {
      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._typeof)) {
        importKind = 'typeof';
      } else if (parser.isContextual('type')) {
        importKind = 'type';
      }
    }

    if (importKind) {
      if (importKind === 'type' && lh.tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star) {
        parser.addDiagnostic(
          {
            start: lh.startPos,
            message: 'import * is not allowed',
          },
        );
      }

      if (___R$project$rome$$romejs$js$parser$parser$flow_ts$isMaybeDefaultImport(lh) || lh.tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL ||
      lh.tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star) {
        parser.next();
      }
    }

    const specifiers = [];

    let first = true;

    // import defaultObj, { x, y as z } from '...'';
    if (___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$shouldParseDefaultImport(parser, importKind)) {
      const meta = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseImportSpecifierLocal(
        parser,
        importKind,
        'default import specifier',
      );

      specifiers.push(
        parser.finishNode(
          start,
          {
            type: 'ImportDefaultSpecifier',
            local: meta,
          },
        ),
      );

      if (!parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma)) {
        return {specifiers, importKind};
      }
    }

    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star)) {
      parser.next();
      parser.expectContextual('as');

      const meta = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseImportSpecifierLocal(
        parser,
        importKind,
        'import namespace specifier',
      );

      specifiers.push(
        parser.finishNode(
          start,
          {
            type: 'ImportNamespaceSpecifier',
            local: meta,
          },
        ),
      );

      return {specifiers, importKind};
    }

    const openContext = parser.expectOpening(
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
      'import specifiers',
    );

    while (true) {
      if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR) || parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof)) {
        parser.expectClosing(openContext);
        break;
      }

      if (first) {
        first = false;
      } else {
        // Detect an attempt to deep destructure
        if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon)) {
          parser.addDiagnostic(
            {
              message: 'ES2015 named imports do not destructure. Use another statement for destructuring after the import.',
            },
          );
        }

        parser.expect(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma);

        if (parser.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR)) {
          break;
        }
      }

      specifiers.push(___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseImportSpecifier(parser, importKind));
    }

    return {specifiers, importKind};
  }

  function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseImportSpecifier(
    parser,
    nodeKind,
  ) {
    const start = parser.getPosition();
    const firstIdentPos = parser.state.startPos;
    const firstIdent = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true);

    let imported;
    let local;
    let importKind = undefined;
    if (firstIdent.name === 'type') {
      importKind = 'type';
    } else if (firstIdent.name === 'typeof') {
      importKind = 'typeof';
    }

    let isBinding = false;
    if (parser.isContextual('as') && !parser.isLookaheadContextual('as')) {
      const as_ident = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true);
      if (importKind !== undefined && !parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name) &&
        parser.state.tokenType.keyword === undefined) {
        // `import {type as ,` or `import {type as }`
        imported = as_ident;
        local = ___R$project$rome$$romejs$js$parser$parser$expression_ts$toBindingIdentifier(parser, parser.cloneNode(as_ident));
      } else {
        // `import {type as foo`
        imported = firstIdent;
        importKind = undefined;
        local = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);
      }
    } else if (importKind !== undefined &&
      (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name) ||
      parser.state.tokenType.keyword)) {
      // `import {type foo`
      imported = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true);
      if (parser.eatContextual('as')) {
        local = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);
      } else {
        isBinding = true;
        local = ___R$project$rome$$romejs$js$parser$parser$expression_ts$toBindingIdentifier(parser, parser.cloneNode(imported));
      }
    } else {
      isBinding = true;
      imported = firstIdent;
      importKind = undefined;
      local = ___R$project$rome$$romejs$js$parser$parser$expression_ts$toBindingIdentifier(parser, parser.cloneNode(imported));
    }

    const nodeIsTypeImport = ___R$project$rome$$romejs$js$parser$parser$flow_ts$hasTypeImportKind(nodeKind);
    const specifierIsTypeImport = ___R$project$rome$$romejs$js$parser$parser$flow_ts$hasTypeImportKind(importKind);

    if (nodeIsTypeImport && specifierIsTypeImport) {
      parser.addDiagnostic(
        {
          start: firstIdentPos,
          message: 'The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements',
        },
      );
    }

    const loc = parser.finishLoc(start);

    if (nodeIsTypeImport || specifierIsTypeImport) {
      ___R$project$rome$$romejs$js$parser$parser$flow_ts$checkReservedType(parser, local.name, loc);
    }

    if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {
      ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkReservedWord(parser, local.name, loc, true, true);
    }

    ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(parser, local, true, undefined, 'import specifier');

    return (
      parser.finishNode(
        start,
        {
          type: 'ImportSpecifier',
          imported,
          local: parser.finishNode(
            start,
            {
              type: 'ImportSpecifierLocal',
              name: local,
              importKind,
            },
          ),
        },
      )
    );
  }

  // project-rome/@romejs/js-parser/parser/index.ts


  // project-rome/@romejs/js-parser/tokenizer/unicodeMistakes.ts
const ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES = new Map();

  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u07fa', ['Nko Lajanyalan', '_']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ufe4d', ['Dashed Low Line', '_']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ufe4e', ['Centreline Low Line', '_']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ufe4f', ['Wavy Low Line', '_']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff3f', ['Fullwidth Low Line', '_']);

  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2010', ['Hyphen', '-']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2011', ['Non-Breaking Hyphen', '-']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2012', ['Figure Dash', '-']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2013', ['En Dash', '-']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2014', ['Em Dash', '-']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ufe58', ['Small Em Dash', '-']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u06d4', ['Arabic Full Stop', '-']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2043', ['Hyphen Bullet', '-']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02d7', ['Modifier Letter Minus Sign', '-']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2212', ['Minus Sign', '-']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2796', ['Heavy Minus Sign', '-']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2cba', ['Coptic Letter Dialect-P Ni', '-']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u30fc', ['Katakana-Hiragana Prolonged Sound Mark', '-']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff0d', ['Fullwidth Hyphen-Minus', '-']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2015', ['Horizontal Bar', '-']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2500', ['Box Drawings Light Horizontal', '-']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2501', ['Box Drawings Heavy Horizontal', '-']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u31d0', ['CJK Stroke H', '-']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ua7f7', ['Latin Epigraphic Letter Dideways', '-']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1173', ['Hangul Jungseong Eu', '-']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3161', ['Hangul Letter Eu', '-']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u4e00', ['CJK Unified Ideograph-4E00', '-']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2f00', ['Kangxi Radical One', '-']);

  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u060d', ['Arabic Date Separator', ',']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u066b', ['Arabic Decimal Separator', ',']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u201a', ['Single Low-9 Quotation Mark', ',']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\xb8', ['Cedilla', ',']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ua4f9', ['Lisu Letter Tone Na Po', ',']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff0c', ['Fullwidth Comma', ',']);

  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u037e', ['Greek Question Mark', ';']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff1b', ['Fullwidth Semicolon', ';']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ufe14', ['Presentation Form For Vertical Semicolon', ';']);

  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u0903', ['Devanagari Sign Visarga', ':']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u0a83', ['Gujarati Sign Visarga', ':']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff1a', ['Fullwidth Colon', ':']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u0589', ['Armenian Full Stop', ':']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u0703', ['Syriac Supralinear Colon', ':']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u0704', ['Syriac Sublinear Colon', ':']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u16ec', ['Runic Multiple Punctuation', ':']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
    '\ufe30',
    [
      'Presentation Form For Vertical Two Dot Leader',
      ':',
    ],
  );
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1803', ['Mongolian Full Stop', ':']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1809', ['Mongolian Manchu Full Stop', ':']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u205a', ['Two Dot Punctuation', ':']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u05c3', ['Hebrew Punctuation Sof Pasuq', ':']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02f8', ['Modifier Letter Raised Colon', ':']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ua789', ['Modifier Letter Colon', ':']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2236', ['Ratio', ':']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02d0', ['Modifier Letter Triangular Colon', ':']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ua4fd', ['Lisu Letter Tone Mya Jeu', ':']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ufe13', ['Presentation Form For Vertical Colon', ':']);

  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff01', ['Fullwidth Exclamation Mark', '!']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u01c3', ['Latin Letter Retroflex Click', '!']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2d51', ['Tifinagh Letter Tuareg Yang', '!']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
    '\ufe15',
    [
      'Presentation Form For Vertical Exclamation Mark',
      '!',
    ],
  );

  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u0294', ['Latin Letter Glottal Stop', '?']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u0241', ['Latin Capital Letter Glottal Stop', '?']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u097d', ['Devanagari Letter Glottal Stop', '?']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u13ae', ['Cherokee Letter He', '?']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ua6eb', ['Bamum Letter Ntuu', '?']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff1f', ['Fullwidth Question Mark', '?']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
    '\ufe16',
    [
      'Presentation Form For Vertical Question Mark',
      '?',
    ],
  );

  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
    '\u{1d16d}',
    [
      'Musical Symbol Combining Augmentation Dot',
      '.',
    ],
  );
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2024', ['One Dot Leader', '.']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u0701', ['Syriac Supralinear Full Stop', '.']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u0702', ['Syriac Sublinear Full Stop', '.']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ua60e', ['Vai Full Stop', '.']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u{10a50}', ['Kharoshthi Punctuation Dot', '.']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u0660', ['Arabic-Indic Digit Zero', '.']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u06f0', ['Extended Arabic-Indic Digit Zero', '.']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ua4f8', ['Lisu Letter Tone Mya Ti', '.']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\xb7', ['Middle Dot', '.']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u30fb', ['Katakana Middle Dot', '.']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff65', ['Halfwidth Katakana Middle Dot', '.']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u16eb', ['Runic Single Punctuation', '.']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u0387', ['Greek Ano Teleia', '.']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2e31', ['Word Separator Middle Dot', '.']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u{10101}', ['Aegean Word Separator Dot', '.']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2022', ['Bullet', '.']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2027', ['Hyphenation Point', '.']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2219', ['Bullet Operator', '.']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u22c5', ['Dot Operator', '.']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ua78f', ['Latin Letter Sinological Dot', '.']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1427', ['Canadian Syllabics Final Middle Dot', '.']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1427', ['Canadian Syllabics Final Middle Dot', '.']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff0e', ['Fullwidth Full Stop', '.']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3002', ['Ideographic Full Stop', '.']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
    '\ufe12',
    [
      'Presentation Form For Vertical Ideographic Full Stop',
      '.',
    ],
  );

  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u055d', ['Armenian Comma', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff07', ['Fullwidth Apostrophe', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2018', ['Left Single Quotation Mark', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2019', ['Right Single Quotation Mark', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u201b', ['Single High-Reversed-9 Quotation Mark', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2032', ['Prime', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2035', ['Reversed Prime', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u055a', ['Armenian Apostrophe', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u05f3', ['Hebrew Punctuation Geresh', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('`', ['Grave Accent', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1fef', ['Greek Varia', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff40', ['Fullwidth Grave Accent', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\xb4', ['Acute Accent', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u0384', ['Greek Tonos', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1ffd', ['Greek Oxia', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1fbd', ['Greek Koronis', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1fbf', ['Greek Psili', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1ffe', ['Greek Dasia', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02b9', ['Modifier Letter Prime', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u0374', ['Greek Numeral Sign', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02c8', ['Modifier Letter Vertical Line', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02ca', ['Modifier Letter Acute Accent', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02cb', ['Modifier Letter Grave Accent', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02f4', ['Modifier Letter Middle Grave Accent', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02bb', ['Modifier Letter Turned Comma', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02bd', ['Modifier Letter Reversed Comma', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02bc', ['Modifier Letter Apostrophe', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02be', ['Modifier Letter Right Half Ring', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ua78c', ['Latin Small Letter Saltillo', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u05d9', ['Hebrew Letter Yod', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u07f4', ['Nko High Tone Apostrophe', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u07f5', ['Nko Low Tone Apostrophe', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u144a', ['Canadian Syllabics West-Cree P', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u16cc', ['Runic Letter Short-Twig-Sol S', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u{16f51}', ['Miao Sign Aspiration', '\'']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u{16f52}', ['Miao Sign Reformed Voicing', '\'']);

  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1cd3', ['Vedic Sign Nihshvasa', '"']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff02', ['Fullwidth Quotation Mark', '"']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u201c', ['Left Double Quotation Mark', '"']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u201d', ['Right Double Quotation Mark', '"']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u201f', ['Double High-Reversed-9 Quotation Mark', '"']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2033', ['Double Prime', '"']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2036', ['Reversed Double Prime', '"']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3003', ['Ditto Mark', '"']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u05f4', ['Hebrew Punctuation Gershayim', '"']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02dd', ['Double Acute Accent', '"']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02ba', ['Modifier Letter Double Prime', '"']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
    '\u02f6',
    [
      'Modifier Letter Middle Double Acute Accent',
      '"',
    ],
  );
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
    '\u02f5',
    [
      'Modifier Letter Middle Double Grave Accent',
      '"',
    ],
  );
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02ee', ['Modifier Letter Double Apostrophe', '"']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u05f2', ['Hebrew Ligature Yiddish Double Yod', '"']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
    '\u275e',
    [
      'Heavy Double Comma Quotation Mark Ornament',
      '"',
    ],
  );
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
    '\u275d',
    [
      'Heavy Double Turned Comma Quotation Mark Ornament',
      '"',
    ],
  );

  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff08', ['Fullwidth Left Parenthesis', '(']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2768', ['Medium Left Parenthesis Ornament', '(']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ufd3e', ['Ornate Left Parenthesis', '(']);

  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff09', ['Fullwidth Right Parenthesis', ')']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2769', ['Medium Right Parenthesis Ornament', ')']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ufd3f', ['Ornate Right Parenthesis', ')']);

  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff3b', ['Fullwidth Left Square Bracket', '[']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
    '\u2772',
    [
      'Light Left Tortoise Shell Bracket Ornament',
      '[',
    ],
  );
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u300c', ['Left Corner Bracket', '[']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u300e', ['Left White Corner Bracket', '[']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3010', ['Left Black Lenticular Bracket', '[']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3014', ['Left Tortoise Shell Bracket', '[']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3016', ['Left White Lenticular Bracket', '[']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3018', ['Left White Tortoise Shell Bracket', '[']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u301a', ['Left White Square Bracket', '[']);

  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff3d', ['Fullwidth Right Square Bracket', ']']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
    '\u2773',
    [
      'Light Right Tortoise Shell Bracket Ornament',
      ']',
    ],
  );
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u300d', ['Right Corner Bracket', ']']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u300f', ['Right White Corner Bracket', ']']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3011', ['Right Black Lenticular Bracket', ']']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3015', ['Right Tortoise Shell Bracket', ']']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3017', ['Right White Lenticular Bracket', ']']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3019', ['Right White Tortoise Shell Bracket', ']']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u301b', ['Right White Square Bracket', ']']);

  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2774', ['Medium Left Curly Bracket Ornament', '{']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u{1d114}', ['Musical Symbol Brace', '{']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff5b', ['Fullwidth Left Curly Bracket', '{']);

  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2775', ['Medium Right Curly Bracket Ornament', '}']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff5d', ['Fullwidth Right Curly Bracket', '}']);

  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u204e', ['Low Asterisk', '*']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u066d', ['Arabic Five Pointed Star', '*']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2217', ['Asterisk Operator', '*']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u{1031f}', ['Old Italic Letter Ess', '*']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff0a', ['Fullwidth Asterisk', '*']);

  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1735', ['Philippine Single Punctuation', '/']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2041', ['Caret Insertion Point', '/']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2215', ['Division Slash', '/']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2044', ['Fraction Slash', '/']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
    '\u2571',
    [
      'Box Drawings Light Diagonal Upper Right To Lower Left',
      '/',
    ],
  );
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u27cb', ['Mathematical Rising Diagonal', '/']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u29f8', ['Big Solidus', '/']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u{1d23a}', ['Greek Instrumental Notation Symbol-47', '/']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u31d3', ['CJK Stroke Sp', '/']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3033', ['Vertical Kana Repeat Mark Upper Half', '/']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2cc6', ['Coptic Capital Letter Old Coptic Esh', '/']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u30ce', ['Katakana Letter No', '/']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u4e3f', ['CJK Unified Ideograph-4E3F', '/']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2f03', ['Kangxi Radical Slash', '/']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff0f', ['Fullwidth Solidus', '/']);

  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff3c', ['Fullwidth Reverse Solidus', '\\']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ufe68', ['Small Reverse Solidus', '\\']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2216', ['Set Minus', '\\']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u27cd', ['Mathematical Falling Diagonal', '\\']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u29f5', ['Reverse Solidus Operator', '\\']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u29f9', ['Big Reverse Solidus', '\\']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u29f9', ['Greek Vocal Notation Symbol-16', '\\']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u29f9', ['Greek Instrumental Symbol-48', '\\']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u31d4', ['CJK Stroke D', '\\']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u4e36', ['CJK Unified Ideograph-4E36', '\\']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2f02', ['Kangxi Radical Dot', '\\']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3001', ['Ideographic Comma', '\\']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u30fd', ['Katakana Iteration Mark', '\\']);

  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ua778', ['Latin Small Letter Um', '&']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff06', ['Fullwidth Ampersand', '&']);

  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u16ed', ['Runic Cross Punctuation', '+']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2795', ['Heavy Plus Sign', '+']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u{1029b}', ['Lycian Letter H', '+']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ufb29', ['Hebrew Letter Alternative Plus Sign', '+']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff0b', ['Fullwidth Plus Sign', '+']);

  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
    '\u2039',
    ['Single Left-Pointing Angle Quotation Mark', '<'],
  );
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
    '\u276e',
    [
      'Heavy Left-Pointing Angle Quotation Mark Ornament',
      '<',
    ],
  );
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02c2', ['Modifier Letter Left Arrowhead', '<']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u{1d236}', ['Greek Instrumental Symbol-40', '<']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1438', ['Canadian Syllabics Pa', '<']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u16b2', ['Runic Letter Kauna', '<']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
    '\u276c',
    [
      'Medium Left-Pointing Angle Bracket Ornament',
      '<',
    ],
  );
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u27e8', ['Mathematical Left Angle Bracket', '<']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2329', ['Left-Pointing Angle Bracket', '<']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3008', ['Left Angle Bracket', '<']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u31db', ['CJK Stroke Pd', '<']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u304f', ['Hiragana Letter Ku', '<']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u{21fe8}', ['CJK Unified Ideograph-21FE8', '<']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u300a', ['Left Double Angle Bracket', '<']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff1c', ['Fullwidth Less-Than Sign', '<']);

  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1400', ['Canadian Syllabics Hyphen', '=']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2e40', ['Double Hyphen', '=']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u30a0', ['Katakana-Hiragana Double Hyphen', '=']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ua4ff', ['Lisu Punctuation Full Stop', '=']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff1d', ['Fullwidth Equals Sign', '=']);

  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
    '\u203a',
    [
      'Single Right-Pointing Angle Quotation Mark',
      '>',
    ],
  );
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
    '\u276f',
    [
      'Heavy Right-Pointing Angle Quotation Mark Ornament',
      '>',
    ],
  );
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02c3', ['Modifier Letter Right Arrowhead', '>']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u{1d237}', ['Greek Instrumental Symbol-42', '>']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1433', ['Canadian Syllabics Po', '>']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u{16f3f}', ['Miao Letter Archaic Zza', '>']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
    '\u276d',
    [
      'Medium Right-Pointing Angle Bracket Ornament',
      '>',
    ],
  );
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u27e9', ['Mathematical Right Angle Bracket', '>']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u232a', ['Right-Pointing Angle Bracket', '>']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3009', ['Right Angle Bracket', '>']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u300b', ['Right Double Angle Bracket', '>']);
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff1e', ['Fullwidth Greater-Than Sign', '>']);

  const ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES = new Map();
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(' ', 'Space');
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('_', 'Underscore');
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('-', 'Minus/Hyphen');
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(',', 'Comma');
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(';', 'Semicolon');
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(':', 'Colon');
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('!', 'Exclamation Mark');
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('?', 'Question Mark');
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('.', 'Period');
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('\'', 'Single Quote');
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('"', 'Quotation Mark');
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('(', 'Left Parenthesis');
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(')', 'Right Parenthesis');
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('[', 'Left Square Bracket');
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(']', 'Right Square Bracket');
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('{', 'Left Curly Brace');
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('}', 'Right Curly Brace');
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('*', 'Asterisk');
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('/', 'Slash');
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('\\', 'Backslash');
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('&', 'Ampersand');
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('+', 'Plus Sign');
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('<', 'Less-Than Sign');
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('=', 'Equals Sign');
  ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('>', 'Greater-Than Sign');

  // project-rome/@romejs/js-parser/tokenizer/index.ts
const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$HEX_NUMBER = /^[\da-fA-F]+$/;
  const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$DECIMAL_NUMBER = /^\d+$/;

  // The following character codes are forbidden from 'being

  // an immediate sibling of NumericLiteralSeparator _
  const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$forbiddenNumericSeparatorSiblings = {
    decBinOct: [
      ___R$project$rome$$romejs$string$charcodes$index_ts.dot,
      ___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseB,
      ___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseE,
      ___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseO,
      ___R$project$rome$$romejs$string$charcodes$index_ts.underscore, // multiple separators are not allowed
      ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseB,
      ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseE,
      ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseO,
    ],
    hex: [
      ___R$project$rome$$romejs$string$charcodes$index_ts.dot,
      ___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseX,
      ___R$project$rome$$romejs$string$charcodes$index_ts.underscore, // multiple separators are not allowed
      ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseX,
    ],
  };

  const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsBin = [
    // 0 - 1
    ___R$project$rome$$romejs$string$charcodes$index_ts.digit0,
    ___R$project$rome$$romejs$string$charcodes$index_ts.digit1,
  ];
  const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsOct = [
    // 0 - 7
    ...___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsBin,
    ___R$project$rome$$romejs$string$charcodes$index_ts.digit2,
    ___R$project$rome$$romejs$string$charcodes$index_ts.digit3,
    ___R$project$rome$$romejs$string$charcodes$index_ts.digit4,
    ___R$project$rome$$romejs$string$charcodes$index_ts.digit5,
    ___R$project$rome$$romejs$string$charcodes$index_ts.digit6,
    ___R$project$rome$$romejs$string$charcodes$index_ts.digit7,
  ];
  const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsDec = [
    // 0 - 9
    ...___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsOct,
    ___R$project$rome$$romejs$string$charcodes$index_ts.digit8,
    ___R$project$rome$$romejs$string$charcodes$index_ts.digit9,
  ];

  const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsHex = [
    // 0 - 9, A - F, a - f,
    ...___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsDec,
    ___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseA,
    ___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseB,
    ___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseC,
    ___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseD,
    ___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseE,
    ___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseF,
    ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseA,
    ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseB,
    ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseC,
    ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseD,
    ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseE,
    ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseF,
  ];
  const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblings = {
    bin: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsBin,
    oct: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsOct,
    dec: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsDec,
    hex: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsHex,
  };

  // Object type used to represent tokens. Note that normally, tokens

  // simply exist as properties on the parser object. This is only

  // used for the onToken callback and the external tokenizer.

  class ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$RegExpTokenValue {
    constructor(pattern, flags) {
      this.pattern = pattern;
      this.flags = flags;
    }
  }

  // ## Tokenizer
  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser) {
    const index = ___R$project$rome$$romejs$ob1$index_ts$inc(parser.state.index);
    parser.state.index = index;
    return index;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) {
    return ___R$project$rome$$romejs$ob1$index_ts$get0(parser.state.index);
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$codePointToString(code) {
    // UTF-16 Decoding
    if (code <= 65535) {
      return String.fromCharCode(code);
    } else {
      return (
        String.fromCharCode(
          (code - 65536 >> 10) + 55296,
          (code - 65536 &
          1023) +
          56320,
        )
      );
    }
  }

  // Toggle strict mode. Re-reads the next number or string to please

  // pedantic tests (`"use strict"; 010;` should fail).
  function ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$setStrict(parser, isStrict) {
    parser.pushScope('STRICT', isStrict);

    if (!parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.num) && !parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string)) {
      return undefined;
    }

    parser.state.index = parser.state.startPos.index;
    while (parser.state.index < parser.state.lineStartIndex) {
      parser.state.lineStartIndex =
        ___R$project$rome$$romejs$ob1$index_ts$coerce0(
          parser.input.lastIndexOf(
            '\n',
            ___R$project$rome$$romejs$ob1$index_ts$get0(
              parser.state.lineStartIndex,
            ) -
            2,
          ) +
          1,
        );
      parser.state.curLine = ___R$project$rome$$romejs$ob1$index_ts$inc(parser.state.curLine);
    }
    ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$nextToken(parser);
  }

  function ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$getCurContext(parser) {
    return parser.state.context[parser.state.context.length - 1];
  }

  function ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$nextToken(parser) {
    const curContext = ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$getCurContext(parser);

    if (!curContext || !curContext.preserveSpace) {
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$skipSpace(parser);
    }

    parser.state.containsOctal = false;
    parser.state.octalPosition = undefined;
    parser.state.startPos = parser.getPositionFromState();

    if (parser.state.index >= parser.length) {
      ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof);
      return undefined;
    }

    if (curContext.override) {
      curContext.override(parser);
    } else {
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken(parser, ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$fullCharCodeAtPos(parser));
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken(parser, code) {
    const matchedJSX = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readJSXToken(parser, code);
    if (matchedJSX) {
      return undefined;
    } else {
      return ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readNormalToken(parser, code);
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readJSXToken(parser, code) {
    if (parser.inScope('PROPERTY_NAME')) {
      return false;
    }

    if (parser.inScope('TYPE')) {
      return false;
    }

    if (!parser.shouldTokenizeJSX()) {
      return false;
    }

    const context = ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$getCurContext(parser);

    if (context === ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.jsxInner) {
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_jsx(parser);
      return true;
    }

    if (context === ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.jsxOpenTag || context === ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.jsxCloseTag) {
      if (___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierStart(code)) {
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_jsxWord(parser);
        return true;
      }

      if (code === ___R$project$rome$$romejs$string$charcodes$index_ts.greaterThan) {
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
        ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagEnd);
        return true;
      }

      if ((code === ___R$project$rome$$romejs$string$charcodes$index_ts.quotationMark || code === ___R$project$rome$$romejs$string$charcodes$index_ts.apostrophe) &&
        context === ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.jsxOpenTag) {
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_jsxString(parser, code);
        return true;
      }
    }

    if (code === ___R$project$rome$$romejs$string$charcodes$index_ts.lessThan && parser.state.exprAllowed &&
      parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1) !== ___R$project$rome$$romejs$string$charcodes$index_ts.exclamationMark) {
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart);
      return true;
    }

    return false;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readNormalToken(parser, code) {
    // Identifier or keyword. '\uXXXX' sequences are allowed in

    // identifiers, so '\' also dispatches to that.
    if (___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierStart(code) || code === ___R$project$rome$$romejs$string$charcodes$index_ts.backslash) {
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readWord(parser);
    } else {
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getTokenFromCode(parser, code);
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$fullCharCodeAtPos(parser) {
    return ___R$project$rome$$romejs$js$parser$utils$identifier_ts$getFullCharCodeAt(parser.input, ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser));
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$pushComment(
    parser,
    opts,
  ) {
    const loc = parser.finishLocAt(opts.startPos, opts.endPos);
    let comment;
    if (opts.block) {
      comment =
        {
          type: 'CommentBlock',
          value: opts.text,
          loc,
        };
    } else {
      comment =
        {
          type: 'CommentLine',
          value: opts.text,
          loc,
        };
    }

    // TODO maybe make sure this is at the head?

    // We should enable flow syntax when there's a comment with @\flow

    // We also handle @\noflow here as it's sometimes in files that have type annotations
    if (opts.text.includes('@flow') || opts.text.includes('@noflow')) {
      if (parser.syntax.has('ts')) {
        parser.addDiagnostic(
          {
            message: 'Cannot have a @flow annotation comment when TypeScript syntax has been enabled',
          },
        );
      } else {
        parser.syntax.add('flow');

        // Let's also implicitly allow JSX
        parser.syntax.add('jsx');
      }
    }

    // We should enable jsx syntax when there's a comment with @\jsx
    if (opts.text.includes('@jsx')) {
      parser.syntax.add('jsx');
    }

    if (parser.isLookahead === false) {
      parser.state.comments.push(comment);
      ___R$project$rome$$romejs$js$parser$parser$comments_ts$addComment(parser, comment);
    }

    if (parser.shouldCreateToken()) {
      /*parser.pushToken({
      type: tt.comment,
      loc,
    });*/}

    return comment;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$skipBlockComment(parser) {
    const startPos = parser.getPositionFromState();
    const startIndex = parser.state.index;
    parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$add(parser.state.index, 2);

    const endIndex = ___R$project$rome$$romejs$ob1$index_ts$coerce0(parser.input.indexOf('*/', ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser)));

    if (endIndex === ___R$project$rome$$romejs$ob1$index_ts$number0Neg1) {
      parser.addDiagnostic(
        {
          end: parser.getPositionFromIndex(___R$project$rome$$romejs$ob1$index_ts$sub(parser.state.index, 2)),
          message: 'Unterminated comment',
        },
      );
      return undefined;
    }

    // Skip */
    parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$add(endIndex, 2);

    ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreakG.lastIndex = ___R$project$rome$$romejs$ob1$index_ts$get0(startIndex);

    let match;
    while ((match = ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreakG.exec(parser.input)) &&
      match.index <
      ___R$project$rome$$romejs$ob1$index_ts$get0(
        parser.state.index,
      )) {
      parser.state.curLine = ___R$project$rome$$romejs$ob1$index_ts$inc(parser.state.curLine);
      parser.resetTokenizerLine();
      parser.state.lineStartIndex = ___R$project$rome$$romejs$ob1$index_ts$coerce0(match.index + match[0].length);
    }

    ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$pushComment(
      parser,
      {
        block: true,
        text: parser.getRawInput(___R$project$rome$$romejs$ob1$index_ts$add(startIndex, 2), endIndex),
        startPos,
        endPos: parser.getPositionFromState(),
      },
    );
  }

  function ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$skipLineComment(parser, startSkip) {
    const startIndex = parser.state.index;
    const startPos = parser.getPositionFromState();
    parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$add(parser.state.index, startSkip);
    let ch = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser));
    if (parser.state.index < parser.length) {
      while (ch !== ___R$project$rome$$romejs$string$charcodes$index_ts.lineFeed && ch !== ___R$project$rome$$romejs$string$charcodes$index_ts.carriageReturn &&
        ch !== ___R$project$rome$$romejs$string$charcodes$index_ts.lineSeparator &&
        ch !== ___R$project$rome$$romejs$string$charcodes$index_ts.paragraphSeparator &&
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser) < parser.length) {
        ch = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser));
      }
    }

    return (
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$pushComment(
        parser,
        {
          block: false,
          text: parser.getRawInput(___R$project$rome$$romejs$ob1$index_ts$add(startIndex, startSkip), parser.state.index),
          startPos,
          endPos: parser.getPositionFromState(),
        },
      )
    );
  }

  // Called at the start of the parse and after every token. Skips

  // whitespace and comments, and.
  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$skipSpace(parser) {
    loop: while (parser.state.index < parser.length) {
      const ch = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser));

      if (parser.state.lineStart) {
        if (ch === ___R$project$rome$$romejs$string$charcodes$index_ts.space || ch === ___R$project$rome$$romejs$string$charcodes$index_ts.tab) {
          parser.state.indentLevel = ___R$project$rome$$romejs$ob1$index_ts$inc(parser.state.indentLevel);
        } else {
          parser.state.lineStart = false;
        }
      }

      if (ch === ___R$project$rome$$romejs$string$charcodes$index_ts.carriageReturn &&
        parser.input.charCodeAt(
          ___R$project$rome$$romejs$ob1$index_ts$get0(
            parser.state.index,
          ) +
          1,
        ) ===
        ___R$project$rome$$romejs$string$charcodes$index_ts.lineFeed) {
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      }

      switch (ch) {
        case ___R$project$rome$$romejs$string$charcodes$index_ts.space:
        case ___R$project$rome$$romejs$string$charcodes$index_ts.nonBreakingSpace:
          ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
          break;

        case ___R$project$rome$$romejs$string$charcodes$index_ts.carriageReturn:
        case ___R$project$rome$$romejs$string$charcodes$index_ts.lineFeed:
        case ___R$project$rome$$romejs$string$charcodes$index_ts.lineSeparator:
        case ___R$project$rome$$romejs$string$charcodes$index_ts.paragraphSeparator:
          ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
          parser.state.curLine = ___R$project$rome$$romejs$ob1$index_ts$inc(parser.state.curLine);
          parser.resetTokenizerLine();
          break;

        case ___R$project$rome$$romejs$string$charcodes$index_ts.slash:
          switch (parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1)) {
            case ___R$project$rome$$romejs$string$charcodes$index_ts.asterisk:
              // Break the loop and don't consume Flow comment code
              if (parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 2) === ___R$project$rome$$romejs$string$charcodes$index_ts.colon &&
                parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 3) === ___R$project$rome$$romejs$string$charcodes$index_ts.colon) {
                break loop;
              }

              ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$skipBlockComment(parser);
              break;

            case ___R$project$rome$$romejs$string$charcodes$index_ts.slash:
              ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$skipLineComment(parser, 2);
              break;

            default:
              break loop;
          }
          break;

        default:
          if (ch > ___R$project$rome$$romejs$string$charcodes$index_ts.backSpace && ch < ___R$project$rome$$romejs$string$charcodes$index_ts.shiftOut ||
          ch >=
          ___R$project$rome$$romejs$string$charcodes$index_ts.oghamSpaceMark &&
            ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$nonASCIIwhitespace.test(
              String.fromCharCode(
                ch,
              ),
            )) {
            ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
          } else {
            break loop;
          }
      }
    }
  }

  // Called at the end of every token. Sets `end`, `val`, and

  // maintains `context` and `exprAllowed`, and skips the space after

  // the token, so that the next one's `start` will point at the

  // right position.
  function ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
    parser,
    type,
    val,
  ) {
    parser.state.endPos = parser.getPositionFromState();

    const prevType = parser.state.tokenType;
    parser.state.tokenType = type;
    parser.state.tokenValue = val;

    ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$updateContext(parser, prevType);
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_dot(parser) {
    const next = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1);
    if (next >= ___R$project$rome$$romejs$string$charcodes$index_ts.digit0 && next <= ___R$project$rome$$romejs$string$charcodes$index_ts.digit9) {
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readNumber(parser, true);
      return undefined;
    }

    const next2 = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 2);
    if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.dot && next2 === ___R$project$rome$$romejs$string$charcodes$index_ts.dot) {
      parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$add(parser.state.index, 3);
      ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis);
    } else {
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot);
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_slash(parser) {
    const next = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1);

    // If this starts with /*:: then it's a Flow comment

    // TODO Flow also allows "flow-include" in place of "::"
    if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.asterisk &&
      parser.input.charCodeAt(
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 2,
      ) ===
      ___R$project$rome$$romejs$string$charcodes$index_ts.colon &&
      parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 3) ===
      ___R$project$rome$$romejs$string$charcodes$index_ts.colon) {
      parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$add(parser.state.index, 4);
      parser.pushScope('FLOW_COMMENT');
      ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$nextToken(parser);
      return;
    }

    // '/'
    if (parser.state.exprAllowed) {
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$readRegexp(parser);
      return;
    }

    if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.equalsTo) {
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.assign, 2);
    } else {
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.slash, 1);
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_mult_modulo(parser, code) {
    let next = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1);

    // */ Is the end of a Flow comment
    if (code === ___R$project$rome$$romejs$string$charcodes$index_ts.asterisk && parser.inScope('FLOW_COMMENT') &&
      next ===
      ___R$project$rome$$romejs$string$charcodes$index_ts.slash) {
      parser.popScope('FLOW_COMMENT');
      parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$add(parser.state.index, 2);
      ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$nextToken(parser);
      return;
    }

    // '%*'
    let type = code === ___R$project$rome$$romejs$string$charcodes$index_ts.asterisk ? ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star : ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.modulo;
    let width = 1;
    const exprAllowed = parser.state.exprAllowed;

    // Exponentiation operator **
    if (code === ___R$project$rome$$romejs$string$charcodes$index_ts.asterisk && next === ___R$project$rome$$romejs$string$charcodes$index_ts.asterisk) {
      width++;
      next = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 2);
      type = ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.exponent;
    }

    if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.equalsTo && !exprAllowed) {
      width++;
      type = ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.assign;
    }

    ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(parser, type, width);
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_pipe_amp(parser, code) {
    // '|&'
    const next = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1);

    if (next === code) {
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(
        parser,
        code === ___R$project$rome$$romejs$string$charcodes$index_ts.verticalBar
          ? ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.logicalOR : ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.logicalAND,
        2,
      );
      return undefined;
    }

    // '|}'
    if (code === ___R$project$rome$$romejs$string$charcodes$index_ts.verticalBar && next === ___R$project$rome$$romejs$string$charcodes$index_ts.rightCurlyBrace) {
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceBarR, 2);
      return undefined;
    }

    if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.equalsTo) {
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.assign, 2);
      return undefined;
    }

    ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(
      parser,
      code === ___R$project$rome$$romejs$string$charcodes$index_ts.verticalBar ? ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bitwiseOR : ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bitwiseAND,
      1,
    );
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_caret(parser) {
    // '^'
    const next = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1);
    if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.equalsTo) {
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.assign, 2);
    } else {
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bitwiseXOR, 1);
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_plus_min(parser, code) {
    // '+-'
    const next = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1);

    if (next === code) {
      if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.dash && !parser.inModule &&
        parser.input.charCodeAt(
          ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 2,
        ) ===
        ___R$project$rome$$romejs$string$charcodes$index_ts.greaterThan &&
        (parser.state.lastEndPos.index === ___R$project$rome$$romejs$ob1$index_ts$number0 ||
        ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreak.test(
          parser.getRawInput(
            parser.state.lastEndPos.index,
            parser.state.index,
          ),
        ))) {
        // A `-->` line comment
        ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$skipLineComment(parser, 3);
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$skipSpace(parser);
        ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$nextToken(parser);
        return undefined;
      }
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.incDec, 2);
      return undefined;
    }

    if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.equalsTo) {
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.assign, 2);
    } else {
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.plusMin, 1);
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_lt_gt(parser, code) {
    // '<>'
    const next = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1);
    let size = 1;

    // we need to check if we're in a type to avoid interpreting the >> in Array<Array<string>> as a bitshift
    if (next === code && !parser.inScope('TYPE')) {
      size =
        code === ___R$project$rome$$romejs$string$charcodes$index_ts.greaterThan &&
          parser.input.charCodeAt(
            ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
              parser,
            ) +
            2,
          ) ===
          ___R$project$rome$$romejs$string$charcodes$index_ts.greaterThan
          ? 3 : 2;
      if (parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + size) === ___R$project$rome$$romejs$string$charcodes$index_ts.equalsTo) {
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.assign, size + 1);
        return undefined;
      }
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bitShift, size);
      return undefined;
    }

    if (code === ___R$project$rome$$romejs$string$charcodes$index_ts.lessThan && next === ___R$project$rome$$romejs$string$charcodes$index_ts.exclamationMark &&
      !parser.inModule &&
      parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 2) ===
      ___R$project$rome$$romejs$string$charcodes$index_ts.dash &&
      parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 3) ===
      ___R$project$rome$$romejs$string$charcodes$index_ts.dash) {
      // `<!--`, an XML-style comment that should be interpreted as a line comment
      ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$skipLineComment(parser, 4);
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$skipSpace(parser);
      ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$nextToken(parser);
      return undefined;
    }

    if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.equalsTo) {
      // <= | >=
      size = 2;
    }

    ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.relational, size);
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_eq_excl(parser, code) {
    // '=!'
    const next = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1);
    if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.equalsTo) {
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(
        parser,
        ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.equality,
        parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 2) === ___R$project$rome$$romejs$string$charcodes$index_ts.equalsTo
          ? 3 : 2,
      );
      return undefined;
    }
    if (code === ___R$project$rome$$romejs$string$charcodes$index_ts.equalsTo && next === ___R$project$rome$$romejs$string$charcodes$index_ts.greaterThan) {
      // '=>'
      parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$add(parser.state.index, 2);
      ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow);
      return undefined;
    }
    ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(parser, code === ___R$project$rome$$romejs$string$charcodes$index_ts.equalsTo ? ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq : ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bang, 1);
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_question(parser) {
    const next = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1);
    const next2 = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 2);
    if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.questionMark && !parser.inScope('TYPE')) {
      if (next2 === ___R$project$rome$$romejs$string$charcodes$index_ts.equalsTo) {
        // '??='
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.assign, 3);
      } else {
        // '??'
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.nullishCoalescing, 2);
      }
    } else if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.dot &&
      !(next2 >= ___R$project$rome$$romejs$string$charcodes$index_ts.digit0 &&
        next2 <=
        ___R$project$rome$$romejs$string$charcodes$index_ts.digit9)) {
      // '.' not followed by a number
      parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$add(parser.state.index, 2);
      ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.questionDot);
    } else {
      // '?'
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question);
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_numberSign(parser) {
    // Only tokenize a hash if we're inside of a class, or if we're the first character in the file (hashbang indicator)
    if (___R$project$rome$$romejs$ob1$index_ts$get0(parser.state.classLevel) > 0 || parser.state.index === ___R$project$rome$$romejs$ob1$index_ts$number0) {
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.hash);
      return undefined;
    }

    // Check if there's a ! after this, in that case it's a confused hashbang
    let advice;
    if (parser.input[___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1] === '!') {
      advice =
        [
          {
            type: 'log',
            category: 'info',
            message: 'Did you want to write a hashbang? A hashbang can only be the first thing in a file.',
          },
        ];
    }

    // TODO make this a diagnostic, and advance to the next line if suspected hashbang
    parser.addDiagnostic(
      {
        message: 'Unexpected character \'#\'',
        advice,
      },
    );
    ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
    ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$nextToken(parser);
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getTokenFromCode(parser, code) {
    if (code === ___R$project$rome$$romejs$string$charcodes$index_ts.digit0) {
      const next = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1);

      // '0x', '0X' - hex number
      if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseX || next === ___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseX) {
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readRadixNumber(parser, 16);
        return undefined;
      }

      // '0o', '0O' - octal number
      if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseO || next === ___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseO) {
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readRadixNumber(parser, 8);
        return undefined;
      }

      // '0b', '0B' - binary number
      if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseB || next === ___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseB) {
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readRadixNumber(parser, 2);
        return undefined;
      }
    }

    switch (code) {
      case ___R$project$rome$$romejs$string$charcodes$index_ts.numberSign:
        return ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_numberSign(parser);

      // The interpretation of a dot depends on whether it is followed

      // by a digit or another two dots.
      case ___R$project$rome$$romejs$string$charcodes$index_ts.dot:
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_dot(parser);
        return undefined;

      // Punctuation tokens.
      case ___R$project$rome$$romejs$string$charcodes$index_ts.leftParenthesis:
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
        ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL);
        return undefined;

      case ___R$project$rome$$romejs$string$charcodes$index_ts.rightParenthesis:
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
        ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR);
        return undefined;

      case ___R$project$rome$$romejs$string$charcodes$index_ts.semicolon:
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
        ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi);
        return undefined;

      case ___R$project$rome$$romejs$string$charcodes$index_ts.comma:
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
        ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma);
        return undefined;

      case ___R$project$rome$$romejs$string$charcodes$index_ts.leftSquareBracket:
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
        ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL);
        return undefined;

      case ___R$project$rome$$romejs$string$charcodes$index_ts.rightSquareBracket:
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
        ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR);
        return undefined;

      case ___R$project$rome$$romejs$string$charcodes$index_ts.leftCurlyBrace:
        if (parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1) === ___R$project$rome$$romejs$string$charcodes$index_ts.verticalBar) {
          ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceBarL, 2);
        } else {
          ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
          ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL);
        }
        return undefined;

      case ___R$project$rome$$romejs$string$charcodes$index_ts.rightCurlyBrace:
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
        ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR);
        return undefined;

      case ___R$project$rome$$romejs$string$charcodes$index_ts.colon:
        if (parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1) === ___R$project$rome$$romejs$string$charcodes$index_ts.colon) {
          ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.doubleColon, 2);
        } else {
          ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
          ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon);
        }
        return undefined;

      case ___R$project$rome$$romejs$string$charcodes$index_ts.questionMark:
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_question(parser);
        return undefined;

      case ___R$project$rome$$romejs$string$charcodes$index_ts.atSign:
        {
          // The token @@ is the start of a Flow iterator name
          const next = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1);
          if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.atSign) {
            parser.state.isIterator = true;
            ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readWord(parser);
          } else {
            ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
            ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.at);
          }
          return undefined;
        }

      case ___R$project$rome$$romejs$string$charcodes$index_ts.graveAccent:
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
        ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.backQuote);
        return undefined;

      // Anything else beginning with a digit is an integer, octal

      // number, or float.
      case ___R$project$rome$$romejs$string$charcodes$index_ts.digit0:
      case ___R$project$rome$$romejs$string$charcodes$index_ts.digit1:
      case ___R$project$rome$$romejs$string$charcodes$index_ts.digit2:
      case ___R$project$rome$$romejs$string$charcodes$index_ts.digit3:
      case ___R$project$rome$$romejs$string$charcodes$index_ts.digit4:
      case ___R$project$rome$$romejs$string$charcodes$index_ts.digit5:
      case ___R$project$rome$$romejs$string$charcodes$index_ts.digit6:
      case ___R$project$rome$$romejs$string$charcodes$index_ts.digit7:
      case ___R$project$rome$$romejs$string$charcodes$index_ts.digit8:
      case ___R$project$rome$$romejs$string$charcodes$index_ts.digit9:
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readNumber(parser, false);
        return undefined;

      // Quotes produce strings.
      case ___R$project$rome$$romejs$string$charcodes$index_ts.quotationMark:
      case ___R$project$rome$$romejs$string$charcodes$index_ts.apostrophe:
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readString(parser, code);
        return undefined;

      // Operators are parsed inline in tiny state machines. '=' (charCodes.equalsTo) is

      // often referred to. `finishOp` simply skips the amount of

      // characters it is given as second argument, and returns a token

      // of the type given by its first argument.
      case ___R$project$rome$$romejs$string$charcodes$index_ts.slash:
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_slash(parser);
        return undefined;

      case ___R$project$rome$$romejs$string$charcodes$index_ts.percentSign:
      case ___R$project$rome$$romejs$string$charcodes$index_ts.asterisk:
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_mult_modulo(parser, code);
        return undefined;

      case ___R$project$rome$$romejs$string$charcodes$index_ts.verticalBar:
      case ___R$project$rome$$romejs$string$charcodes$index_ts.ampersand:
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_pipe_amp(parser, code);
        return undefined;

      case ___R$project$rome$$romejs$string$charcodes$index_ts.caret:
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_caret(parser);
        return undefined;

      case ___R$project$rome$$romejs$string$charcodes$index_ts.plusSign:
      case ___R$project$rome$$romejs$string$charcodes$index_ts.dash:
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_plus_min(parser, code);
        return undefined;

      case ___R$project$rome$$romejs$string$charcodes$index_ts.lessThan:
      case ___R$project$rome$$romejs$string$charcodes$index_ts.greaterThan:
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_lt_gt(parser, code);
        return undefined;

      case ___R$project$rome$$romejs$string$charcodes$index_ts.equalsTo:
      case ___R$project$rome$$romejs$string$charcodes$index_ts.exclamationMark:
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_eq_excl(parser, code);
        return undefined;

      case ___R$project$rome$$romejs$string$charcodes$index_ts.tilde:
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.tilde, 1);
        return undefined;
    }

    const char = parser.input[___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser)];
    const unicodeMistake = ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.get(char);
    if (unicodeMistake !== undefined) {
      const [unicodeName, equivalentChar] = unicodeMistake;
      const equivalentName = ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.get(equivalentChar);
      if (equivalentName === undefined) {
        throw new Error('Expected ASCII name for ' +
        equivalentChar);
      }

      parser.addDiagnostic(
        {
          message: 'Unexpected Unicode character \'<emphasis>' +
          char +
          '</emphasis>\' (<emphasis>' +
          unicodeName +
          '</emphasis>)',

          advice: [
            {
              type: 'log',
              category: 'info',
              message: 'Did you mean \'<emphasis>' +
              equivalentChar +
              '</emphasis>\' (<emphasis>' +
              equivalentName +
              '</emphasis>)? Both characters look the same, but are not.',
            },
          ],
        },
      );

      // Read the token as the equivalent character
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getTokenFromCode(parser, equivalentChar.charCodeAt(0));
      return;
    }

    parser.addDiagnostic(
      {
        message: 'Unexpected character \'' +
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$codePointToString(code) +
        '\'',
      },
    );

    // Skip unknown characters
    ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
    ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$nextToken(parser);
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(parser, type, size) {
    const str = parser.getRawInput(
      parser.state.index,
      ___R$project$rome$$romejs$ob1$index_ts$add(
        parser.state.index,
        size,
      ),
    );
    parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$add(parser.state.index, size);
    ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, type, str);
  }

  function ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$readRegexp(parser) {
    const start = parser.state.index;
    let escaped, inClass;
    for (;;) {
      if (parser.state.index >= parser.length) {
        parser.addDiagnostic(
          {
            end: parser.getPositionFromIndex(parser.state.index),
            message: 'Unterminated regular expression',
          },
        );
        break;
      }

      const ch = parser.input.charAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser));
      if (___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreak.test(ch)) {
        parser.addDiagnostic(
          {
            end: parser.getPositionFromIndex(parser.state.index),
            message: 'Unterminated regular expression',
          },
        );
        break;
      }

      if (escaped) {
        escaped = false;
      } else {
        if (ch === '[') {
          inClass = true;
        } else if (ch === ']' && inClass) {
          inClass = false;
        } else if (ch === '/' && !inClass) {
          break;
        }

        escaped = ch === '\\';
      }

      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
    }

    const content = parser.getRawInput(start, parser.state.index);
    ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);

    const rawMods = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readWord1(parser);

    if (parser.state.escapePosition !== undefined) {
      parser.addDiagnostic(
        {
          index: parser.state.escapePosition,
          message: 'Regular expression flags can\'t contain unicode escapes',
        },
      );
    }

    const mods = ___R$project$rome$$romejs$js$parser$utils$regex_ts$validateRegexFlags(
      rawMods,
      (msg, index) => {
        parser.addDiagnostic(
          {
            index: ___R$project$rome$$romejs$ob1$index_ts$add(start, index),
            message: msg,
          },
        );
      },
    );

    ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.regexp, new ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$RegExpTokenValue(content, mods));
  }

  // Read an integer in the given radix. Return null if zero digits

  // were read, the integer value otherwise. When `len` is given, this

  // will return `null` unless the integer has exactly `len` digits.
  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readInt(
    parser,
    radix,
    len,
  ) {
    const start = parser.state.index;
    const forbiddenSiblings = radix === 16
      ? ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$forbiddenNumericSeparatorSiblings.hex : ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$forbiddenNumericSeparatorSiblings.decBinOct;

    let allowedSiblings;
    if (radix === 16) {
      allowedSiblings = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblings.hex;
    } else if (radix === 10) {
      allowedSiblings = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblings.dec;
    } else if (radix === 8) {
      allowedSiblings = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblings.oct;
    } else {
      allowedSiblings = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblings.bin;
    }

    let total = 0;

    for (let i = 0, e = len === undefined ? Infinity : len;
    i < e;
    ++i) {
      const code = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser));
      let val;

      const prev = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) - 1);
      const next = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1);
      if (code === ___R$project$rome$$romejs$string$charcodes$index_ts.underscore) {
        if (allowedSiblings.indexOf(next) === -1) {
          parser.addDiagnostic(
            {
              message: 'Invalid or unexpected token',
            },
          );
        }

        if (forbiddenSiblings.indexOf(prev) > -1 ||
        forbiddenSiblings.indexOf(next) > -1 ||
        Number.isNaN(next)) {
          parser.addDiagnostic(
            {
              message: 'Invalid or unexpected token',
            },
          );
        }

        // Ignore this _ character
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
        continue;
      }

      if (code >= ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseA) {
        val = code - ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseA + ___R$project$rome$$romejs$string$charcodes$index_ts.lineFeed;
      } else if (code >= ___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseA) {
        val = code - ___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseA + ___R$project$rome$$romejs$string$charcodes$index_ts.lineFeed;
      } else if (___R$project$rome$$romejs$string$charcodes$index_ts.isDigit(code)) {
        val = code - ___R$project$rome$$romejs$string$charcodes$index_ts.digit0; // 0-9
      } else {
        val = Infinity;
      }

      if (val >= radix) {
        break;
      }

      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      total = total * radix + val;
    }

    if (parser.state.index === start ||
    len !== undefined &&
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) -
      ___R$project$rome$$romejs$ob1$index_ts$get0(start) !==
      len) {
      return undefined;
    }

    return total;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readRadixNumber(parser, radix) {
    const start = parser.state.index;
    let isBigInt = false;

    parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$add(parser.state.index, 2); // 0x
    const val = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readInt(parser, radix);
    if (val === undefined) {
      parser.addDiagnostic(
        {
          index: ___R$project$rome$$romejs$ob1$index_ts$add(start, 2),
          message: 'Expected number in radix ' +
          radix,
        },
      );
    }

    if (parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser)) === ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseN) {
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      isBigInt = true;
    }

    if (___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierStart(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$fullCharCodeAtPos(parser))) {
      parser.addDiagnostic(
        {
          index: parser.state.index,
          message: 'Identifier directly after number',
        },
      );
    }

    if (isBigInt) {
      const str = parser.getRawInput(start, parser.state.index).replace(
        /[_n]/g,
        '',
      );
      ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bigint, str);
      return undefined;
    }

    ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.num, val);
  }

  // Read an integer, octal integer, or floating-point number.
  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readNumber(parser, startsWithDot) {
    const start = parser.state.startPos;
    let isFloat = false;
    let isBigInt = false;

    if (!startsWithDot && ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readInt(parser, 10) === undefined) {
      parser.addDiagnostic(
        {
          index: parser.state.index,
          message: 'Invalid number',
        },
      );
    }

    let isOctal = ___R$project$rome$$romejs$ob1$index_ts$get0(parser.state.index) - ___R$project$rome$$romejs$ob1$index_ts$get0(start.index) >= 2 &&
      parser.input.charCodeAt(___R$project$rome$$romejs$ob1$index_ts$get0(start.index)) === ___R$project$rome$$romejs$string$charcodes$index_ts.digit0;
    if (isOctal) {
      if (parser.inScope('STRICT')) {
        parser.addDiagnostic(
          {
            index: parser.state.index,
            message: 'Legacy octal literals are not allowed in strict mode',
          },
        );
      }

      if (/[89]/.test(parser.getRawInput(start.index, parser.state.index))) {
        isOctal = false;
      }
    }

    let next = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser));
    if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.dot && !isOctal) {
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readInt(parser, 10);
      isFloat = true;
      next = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser));
    }

    if ((next === ___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseE || next === ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseE) &&
      !isOctal) {
      next = parser.input.charCodeAt(___R$project$rome$$romejs$ob1$index_ts$get0(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser)));

      if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.plusSign || next === ___R$project$rome$$romejs$string$charcodes$index_ts.dash) {
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      }

      if (___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readInt(parser, 10) === undefined) {
        parser.addDiagnostic(
          {
            index: parser.state.index,
            message: 'Invalid number',
          },
        );
      }

      isFloat = true;
      next = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser));
    }

    if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseN) {
      // Disallow floats and legacy octal syntax, new style octal ("0o") is handled in readRadixNumber
      if (isFloat) {
        parser.addDiagnostic(
          {
            index: parser.state.index,
            message: 'A bigint can\'t have a decimal',
          },
        );
      }

      if (isOctal) {
        parser.addDiagnostic(
          {
            index: parser.state.index,
            message: 'A bigint can\'t be an octal',
          },
        );
      }

      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      isBigInt = true;
    }

    if (___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierStart(parser.input.codePointAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser)))) {
      parser.addDiagnostic(
        {
          index: parser.state.index,
          message: 'Identifier directly after number',
        },
      );
    }

    // Remove "_" for numeric literal separator, and "n" for BigInts
    const str = parser.getRawInput(start.index, parser.state.index).replace(
      /[_n]/g,
      '',
    );

    if (isBigInt) {
      ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bigint, str);
      return undefined;
    }

    const val = isOctal ? parseInt(str, 8) : parseFloat(str);
    ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.num, val);
  }

  // Read a string value, interpreting backslash-escapes.
  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readCodePoint(
    parser,
    throwOnInvalid,
  ) {
    const ch = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser));
    let code;

    if (ch === ___R$project$rome$$romejs$string$charcodes$index_ts.leftCurlyBrace) {
      const codePos = parser.state.index;
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      code =
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readHexChar(
          parser,
          parser.input.indexOf('}', ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser)) -
          ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser),
          throwOnInvalid,
        );
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      if (code === undefined) {
        // @ts-ignore
        parser.state.invalidTemplateEscapePosition--; // to point to the '\'' instead of the 'u'
      } else if (code > 1114111) {
        if (throwOnInvalid) {
          parser.addDiagnostic(
            {
              index: codePos,
              message: 'Code point out of bounds',
            },
          );
        } else {
          parser.state.invalidTemplateEscapePosition = ___R$project$rome$$romejs$ob1$index_ts$sub(codePos, 2);
          return undefined;
        }
      }
    } else {
      code = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readHexChar(parser, 4, throwOnInvalid);
    }
    return code;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readString(parser, quote) {
    let out = '';
    let chunkStart = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);

    while (true) {
      if (parser.state.index >= parser.length) {
        parser.addDiagnostic(
          {
            end: parser.getPositionFromIndex(parser.state.index),
            message: 'Unterminated string constant',
          },
        );
        break;
      }

      const ch = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser));
      if (ch === quote) {
        break;
      }

      if (ch === ___R$project$rome$$romejs$string$charcodes$index_ts.backslash) {
        out += parser.getRawInput(chunkStart, parser.state.index);
        out += ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readEscapedChar(parser, false);
        chunkStart = parser.state.index;
      } else if (ch === ___R$project$rome$$romejs$string$charcodes$index_ts.lineSeparator ||
      ch ===
      ___R$project$rome$$romejs$string$charcodes$index_ts.paragraphSeparator) {
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
        parser.state.curLine = ___R$project$rome$$romejs$ob1$index_ts$inc(parser.state.curLine);
      } else {
        if (___R$project$rome$$romejs$js$parser$utils$whitespace_ts$isNewLine(ch)) {
          parser.addDiagnostic(
            {
              end: parser.getPositionFromIndex(parser.state.index),
              message: 'Unterminated string constant',
            },
          );
        }
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      }
    }

    out += parser.getRawInput(chunkStart, parser.state.index);
    ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
    ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string, out);
  }

  // Reads template string tokens.
  function ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$readTemplateToken(parser) {
    let out = '';
    let chunkStart = parser.state.index;
    let containsInvalid = false;

    while (true) {
      if (parser.state.index >= parser.length) {
        parser.addDiagnostic(
          {
            end: parser.getPositionFromIndex(parser.state.index),
            message: 'Unterminated template',
          },
        );
        break;
      }

      const ch = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser));
      if (ch === ___R$project$rome$$romejs$string$charcodes$index_ts.graveAccent ||
      ch === ___R$project$rome$$romejs$string$charcodes$index_ts.dollarSign &&
        parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1) === ___R$project$rome$$romejs$string$charcodes$index_ts.leftCurlyBrace) {
        if (parser.state.index === parser.state.startPos.index &&
          parser.match(
            ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.template,
          )) {
          if (ch === ___R$project$rome$$romejs$string$charcodes$index_ts.dollarSign) {
            parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$add(parser.state.index, 2);
            ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dollarBraceL);
            return undefined;
          } else {
            ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
            ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.backQuote);
            return undefined;
          }
        }
        out += parser.getRawInput(chunkStart, parser.state.index);
        ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.template, containsInvalid ? undefined : out);
        return undefined;
      }

      if (ch === ___R$project$rome$$romejs$string$charcodes$index_ts.backslash) {
        out += parser.getRawInput(chunkStart, parser.state.index);
        const escaped = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readEscapedChar(parser, true);
        if (escaped === undefined) {
          containsInvalid = true;
        } else {
          out += escaped;
        }
        chunkStart = parser.state.index;
      } else if (___R$project$rome$$romejs$js$parser$utils$whitespace_ts$isNewLine(ch)) {
        out += parser.getRawInput(chunkStart, parser.state.index);
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);

        if (ch === ___R$project$rome$$romejs$string$charcodes$index_ts.carriageReturn &&
          parser.input.charCodeAt(
            ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
              parser,
            ),
          ) ===
          ___R$project$rome$$romejs$string$charcodes$index_ts.lineFeed) {
          ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
        }

        switch (ch) {
          case ___R$project$rome$$romejs$string$charcodes$index_ts.carriageReturn:
          case ___R$project$rome$$romejs$string$charcodes$index_ts.lineFeed:
            out += '\n';
            break;

          default:
            out += String.fromCharCode(ch);
            break;
        }

        parser.state.curLine = ___R$project$rome$$romejs$ob1$index_ts$inc(parser.state.curLine);
        parser.resetTokenizerLine();
        chunkStart = parser.state.index;
      } else {
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      }
    }
  }

  // Used to read escaped characters
  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readEscapedChar(
    parser,
    inTemplate,
  ) {
    const throwOnInvalid = !inTemplate;
    const ch = parser.input.charCodeAt(___R$project$rome$$romejs$ob1$index_ts$get0(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser)));
    ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);

    if (ch === ___R$project$rome$$romejs$string$charcodes$index_ts.carriageReturn &&
      parser.input.charCodeAt(
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser),
      ) ===
      ___R$project$rome$$romejs$string$charcodes$index_ts.lineFeed) {
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
    }

    switch (ch) {
      case ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseN:
        return '\n';

      case ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseR:
        return '\r';

      case ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseX:
        {
          const code = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readHexChar(parser, 2, throwOnInvalid);
          return code === undefined ? undefined : String.fromCharCode(code);
        }

      case ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseU:
        {
          const code = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readCodePoint(parser, throwOnInvalid);
          return code === undefined ? undefined : ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$codePointToString(code);
        }

      case ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseT:
        return '\t';

      case ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseB:
        return '\b';

      case ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseV:
        return '\x0b';

      case ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseF:
        return '\f';

      case ___R$project$rome$$romejs$string$charcodes$index_ts.carriageReturn:
      case ___R$project$rome$$romejs$string$charcodes$index_ts.lineFeed:
        parser.state.curLine = ___R$project$rome$$romejs$ob1$index_ts$inc(parser.state.curLine);
        parser.resetTokenizerLine();
        return '';

      default:
        if (ch >= ___R$project$rome$$romejs$string$charcodes$index_ts.digit0 && ch <= ___R$project$rome$$romejs$string$charcodes$index_ts.digit7) {
          const codePos = ___R$project$rome$$romejs$ob1$index_ts$dec(parser.state.index);
          const octalMatches = parser.input.substr(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser) - 1, 3).match(
            /^[0-7]+/,
          );

          if (octalMatches == null) {
            throw new Error('No octals found, impossible since we checked it');
          }

          let octalStr = octalMatches[0];
          let octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }

          if (octal > 0) {
            if (inTemplate) {
              parser.state.invalidTemplateEscapePosition = codePos;
              return undefined;
            } else if (parser.inScope('STRICT')) {
              parser.addDiagnostic(
                {
                  index: codePos,
                  message: 'Octal literal in strict mode',
                },
              );
            } else if (!parser.state.containsOctal) {
              // These properties are only used to throw an error for an octal which occurs

              // in a directive which occurs prior to a "use strict" directive.
              parser.state.containsOctal = true;
              parser.state.octalPosition = codePos;
            }
          }

          parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$add(parser.state.index, octalStr.length - 1);
          return String.fromCharCode(octal);
        }

        return String.fromCharCode(ch);
    }
  }

  // Used to read character escape sequences ('\x', '\u').
  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readHexChar(
    parser,
    len,
    throwOnInvalid,
  ) {
    const start = parser.state.index;
    const n = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readInt(parser, 16, len);

    if (n === undefined) {
      if (throwOnInvalid) {
        parser.addDiagnostic(
          {
            index: start,
            message: 'Bad character escape sequence',
          },
        );
        return 0;
      }

      const codePos = parser.state.index;
      parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$dec(codePos);
      parser.state.invalidTemplateEscapePosition = ___R$project$rome$$romejs$ob1$index_ts$dec(codePos);
    }

    return n;
  }

  // Read an identifier, and return it as a string. Sets `parser.state.escapePosition`

  // to an index if the word contained a '\u' escape.

  //

  // Incrementally adds only escaped chars, adding other chunks as-is

  // as a micro-optimization.
  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readWord1(parser) {
    parser.state.escapePosition = undefined;
    let word = '';
    let first = true;
    let chunkStart = parser.state.index;

    while (parser.state.index < parser.length) {
      const ch = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$fullCharCodeAtPos(parser);

      if (___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierChar(ch)) {
        parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$add(parser.state.index, ch <= 65535 ? 1 : 2);
      } else if (parser.state.isIterator && ch === ___R$project$rome$$romejs$string$charcodes$index_ts.atSign) {
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      } else if (ch === ___R$project$rome$$romejs$string$charcodes$index_ts.backslash) {
        parser.state.escapePosition = parser.state.index;

        word += parser.getRawInput(chunkStart, parser.state.index);

        if (parser.input.charCodeAt(___R$project$rome$$romejs$ob1$index_ts$get0(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser))) !==
        ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseU) {
          parser.addDiagnostic(
            {
              index: parser.state.index,
              message: 'Expecting Unicode escape sequence \\uXXXX',
            },
          );
        }

        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);

        const esc = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readCodePoint(parser, true);
        if (esc === undefined) {
          throw new Error('readCodePoint() should have thrown an error');
        }

        const isValid = first ? ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierStart : ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierChar;
        if (isValid(esc) === false) {
          parser.addDiagnostic(
            {
              index: parser.state.index,
              message: 'Invalid Unicode escape',
            },
          );
        }

        word += ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$codePointToString(esc);
        chunkStart = parser.state.index;
      } else {
        break;
      }

      first = false;
    }

    return word + parser.getRawInput(chunkStart, parser.state.index);
  }

  // Read an identifier or keyword token. Will check for reserved

  // words when necessary.
  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readWord(parser) {
    const word = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readWord1(parser);

    // @ts-ignore: The value of keywordTypes has a generic parameter of `string` instead of the labels that we would actually find in keywordTypes
    let type = ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$keywords.get(word) || ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name;

    if (type.keyword !== undefined && parser.state.escapePosition !== undefined) {
      parser.addDiagnostic(
        {
          index: parser.state.escapePosition,
          message: 'Escape sequence in keyword ' +
          word,
        },
      );
    }

    if (parser.state.isIterator && (!___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$isIterator(word) || !parser.inScope('TYPE'))) {
      parser.addDiagnostic(
        {
          message: 'Invalid identifier ' +
          word,
        },
      );
    }

    ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, type, word);
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$isIterator(word) {
    return word === '@@iterator' || word === '@@asyncIterator';
  }

  function ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$isBraceBlock(parser, prevType) {
    const parent = ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$getCurContext(parser);
    if (parent === ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.functionExpression || parent === ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.functionStatement) {
      return true;
    }
    if (prevType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon &&
      (parent === ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.braceStatement ||
      parent ===
      ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.braceExpression)) {
      return !parent.isExpr;
    }

    // The check for `tt.name && exprAllowed` detects whether we are

    // after a `yield` or `of` construct. See the `updateContext` for

    // `tt.name`.
    if (prevType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._return || prevType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name && parser.state.exprAllowed) {
      return (
        ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreak.test(
          parser.getRawInput(
            parser.state.lastEndPos.index,
            parser.state.startPos.index,
          ),
        )
      );
    }

    if (prevType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._else || prevType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi || prevType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof ||
    prevType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR ||
    prevType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow) {
      return true;
    }

    if (prevType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL) {
      return parent === ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.braceStatement;
    }

    if (prevType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._var || prevType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name || prevType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._const) {
      return false;
    }

    if (prevType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.relational) {
      // `class C<T> { ... }`
      return true;
    }

    return !parser.state.exprAllowed;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$updateContext(parser, prevType) {
    if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL)) {
      const curContext = ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$getCurContext(parser);
      if (curContext === ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.jsxOpenTag) {
        parser.state.context.push(___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.braceExpression);
      } else if (curContext === ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.jsxInner) {
        parser.state.context.push(___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.templateQuasi);
      } else {
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$_updateContext(parser, prevType);
      }

      parser.state.exprAllowed = true;
    } else if (parser.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.slash) && prevType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart) {
      parser.state.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore
      parser.state.context.push(___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.jsxCloseTag); // reconsider as closing tag context
      parser.state.exprAllowed = false;
    } else {
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$_updateContext(parser, prevType);
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$_updateContext(parser, prevType) {
    const type = parser.state.tokenType;

    if (type.keyword !== undefined &&
      (prevType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot ||
      prevType ===
      ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.questionDot)) {
      parser.state.exprAllowed = false;
    } else if (type.updateContext !== undefined) {
      type.updateContext(parser, prevType);
    } else {
      parser.state.exprAllowed = type.beforeExpr;
    }
  }

  // Reads inline JSX contents token.
  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_jsx(parser) {
    let out = '';
    let chunkStart = parser.state.index;
    while (true) {
      if (parser.state.index >= parser.length) {
        ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof);
        break;
      }

      const code = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser));

      if (code === ___R$project$rome$$romejs$string$charcodes$index_ts.lessThan || code === ___R$project$rome$$romejs$string$charcodes$index_ts.leftCurlyBrace) {
        if (parser.state.index === parser.state.startPos.index) {
          if (code === ___R$project$rome$$romejs$string$charcodes$index_ts.lessThan && parser.state.exprAllowed) {
            ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
            return ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart);
          }

          return ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getTokenFromCode(parser, code);
        }

        out += parser.getRawInput(chunkStart, parser.state.index);
        return ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxText, out);
      }

      if (code === ___R$project$rome$$romejs$string$charcodes$index_ts.ampersand) {
        out += parser.getRawInput(chunkStart, parser.state.index);
        out += ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_jsxEntity(parser);
        chunkStart = parser.state.index;
        continue;
      }

      if (___R$project$rome$$romejs$js$parser$utils$whitespace_ts$isNewLine(code)) {
        out += parser.getRawInput(chunkStart, parser.state.index);
        out += ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_jsxNewLine(parser, true);
        chunkStart = parser.state.index;
      } else {
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      }
    }
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_jsxNewLine(parser, normalizeCRLF) {
    const ch = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser));
    let out;
    ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);

    if (ch === ___R$project$rome$$romejs$string$charcodes$index_ts.carriageReturn &&
      parser.input.charCodeAt(
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser),
      ) ===
      ___R$project$rome$$romejs$string$charcodes$index_ts.lineFeed) {
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      out = normalizeCRLF ? '\n' : '\r\n';
    } else {
      out = String.fromCharCode(ch);
    }

    parser.state.curLine = ___R$project$rome$$romejs$ob1$index_ts$inc(parser.state.curLine);
    parser.resetTokenizerLine();
    return out;
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_jsxString(parser, quote) {
    let out = '';
    let chunkStart = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
    while (true) {
      if (parser.state.index >= parser.length) {
        parser.addDiagnostic(
          {
            end: parser.getPositionFromIndex(parser.state.index),
            message: 'Unterminated string constant',
          },
        );
        break;
      }

      const ch = parser.input.charCodeAt(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser));
      if (ch === quote) {
        break;
      }

      if (ch === ___R$project$rome$$romejs$string$charcodes$index_ts.ampersand) {
        out += parser.getRawInput(chunkStart, parser.state.index);
        out += ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_jsxEntity(parser);
        chunkStart = parser.state.index;
      } else if (___R$project$rome$$romejs$js$parser$utils$whitespace_ts$isNewLine(ch)) {
        out += parser.getRawInput(chunkStart, parser.state.index);
        out += ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_jsxNewLine(parser, false);
        chunkStart = parser.state.index;
      } else {
        ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      }
    }

    out += parser.getRawInput(chunkStart, parser.state.index);
    ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
    return ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string, out);
  }

  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_jsxEntity(parser) {
    let str = '';
    let count = 0;
    let entity;
    let ch = parser.input[___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser)];

    const startIndex = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);

    while (parser.state.index < parser.length && count++ < 10) {
      ch = parser.input[___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(parser)];
      ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      if (ch === ';') {
        if (str[0] === '#') {
          if (str[1] === 'x') {
            str = str.substr(2);
            if (___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$HEX_NUMBER.test(str)) {
              entity = String.fromCodePoint(parseInt(str, 16));
            }
          } else {
            str = str.substr(1);
            if (___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$DECIMAL_NUMBER.test(str)) {
              entity = String.fromCodePoint(parseInt(str, 10));
            }
          }
        } else {
          entity = ___R$project$rome$$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityNameToChar[str];
        }
        break;
      }
      str += ch;
    }

    if (entity === undefined) {
      parser.state.index = startIndex;
      return '&';
    } else {
      return entity;
    }
  }

  // Read a JSX identifier (valid tag or attribute name).

  //

  // Optimized version since JSX identifiers can't contain

  // escape characters and so can be read as single slice.

  // Also assumes that first character was already checked

  // by isIdentifierStart in readToken.
  function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken_jsxWord(parser) {
    let ch;
    const start = parser.state.index;
    do {
      ch = parser.input.charCodeAt(___R$project$rome$$romejs$ob1$index_ts$get0(___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser)));
    } while (___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierChar(ch) || ch === ___R$project$rome$$romejs$string$charcodes$index_ts.dash);
    return (
      ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
        parser,
        ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxName,
        parser.getRawInput(
          start,
          parser.state.index,
        ),
      )
    );
  }

  // project-rome/@romejs/js-parser/tokenizer/state.ts
const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$state_ts$EMPTY_POS = {
    line: ___R$project$rome$$romejs$ob1$index_ts$number1,
    column: ___R$project$rome$$romejs$ob1$index_ts$number0,
    index: ___R$project$rome$$romejs$ob1$index_ts$number0,
  };

  function ___R$project$rome$$romejs$js$parser$tokenizer$state_ts$createInitialState() {
    return (
      {
        scopes: {},
        diagnostics: [],
        diagnosticFilters: [],
        hasHoistedVars: false,
        corrupt: false,
        tokens: [],
        potentialArrowAt: ___R$project$rome$$romejs$ob1$index_ts$number0Neg1,
        commaAfterSpreadAt: ___R$project$rome$$romejs$ob1$index_ts$number0Neg1,
        yieldPos: ___R$project$rome$$romejs$ob1$index_ts$number0,
        awaitPos: ___R$project$rome$$romejs$ob1$index_ts$number0,
        noArrowAt: [],
        noArrowParamsConversionAt: [],
        maybeInArrowParameters: false,
        isIterator: false,
        noAnonFunctionType: false,
        classLevel: ___R$project$rome$$romejs$ob1$index_ts$number0,
        labels: [],
        yieldInPossibleArrowParameters: undefined,
        comments: [],
        trailingComments: [],
        leadingComments: [],
        commentStack: [],
        commentPreviousNode: undefined,
        index: ___R$project$rome$$romejs$ob1$index_ts$number0,
        lineStartIndex: ___R$project$rome$$romejs$ob1$index_ts$number0,
        curLine: ___R$project$rome$$romejs$ob1$index_ts$number1,
        tokenType: ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof,
        tokenValue: undefined,
        startPos: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$state_ts$EMPTY_POS,
        endPos: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$state_ts$EMPTY_POS,
        lastStartPos: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$state_ts$EMPTY_POS,
        lastEndPos: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$state_ts$EMPTY_POS,
        context: [___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.braceStatement],
        exprAllowed: true,
        containsOctal: false,
        escapePosition: undefined,
        octalPosition: undefined,
        invalidTemplateEscapePosition: undefined,
        exportedIdentifiers: new Map(),
        possibleIncorrectOpenParens: [],
        lineStart: true,
        indentLevel: ___R$project$rome$$romejs$ob1$index_ts$number0,
      }
    );
  }

  // project-rome/@romejs/js-parser/ParserBranchFinder.ts
class ___R$project$rome$$romejs$js$parser$ParserBranchFinder_ts$default {
    constructor(parser) {
      this.parser = parser;
      this.branch = undefined;
      this.picked = false;
    }

    hasOptimalBranch() {
      return this.branch !== undefined && this.branch.optimal;
    }

    hasBranch() {
      return this.branch !== undefined;
    }

    add(callback, opts = {}) {
      const topBranch = this.branch;

      // If we already have a branch that produced no errors then no point continuing
      if (topBranch !== undefined && topBranch.optimal) {
        return this;
      }

      const {maxNewDiagnostics, diagnosticsPriority} = opts;
      const {parser} = this;
      const prevState = parser.cloneState();

      parser.pushScope('MAX_NEW_DIAGNOSTICS', maxNewDiagnostics);

      let result;
      try {
        result = callback(parser);
      } catch (err) {
        if (err instanceof ___R$project$rome$$romejs$js$parser$parser_ts$DiagnosticsFatalError) {
          parser.setState(prevState);
          return this;
        } else {
          throw err;
        }
      }

      if (result === undefined) {
        parser.setState(prevState);
        return this;
      }

      // We capture the state at this point because it could have been previously changed
      const newState = parser.state;
      parser.popScope('MAX_NEW_DIAGNOSTICS');
      parser.setState(prevState);

      // Verify that we didn't exceed the maxDiagnostics, this should have already been done in Parser#addDiagnostic

      // but do it again as a sanity check. Previously some code caused the state to be manipulated in odd ways
      const newDiagnosticCount = newState.diagnostics.length;
      const prevDiagnosticCount = prevState.diagnostics.length;
      if (maxNewDiagnostics !== undefined &&
        newDiagnosticCount -
        prevDiagnosticCount >
        maxNewDiagnostics) {
        throw (
          new Error(
            'Max diagnostics unexpectedly exceeded ' +
            maxNewDiagnostics +
            '. Prev: ' +
            prevDiagnosticCount +
            ' New: ' +
            newDiagnosticCount,
          )
        );
      }

      const branch = {
        diagnosticsPriority,
        result,
        state: newState,
        newDiagnosticCount: newDiagnosticCount - prevDiagnosticCount,
        diagnosticCount: newDiagnosticCount,
        optimal: newDiagnosticCount === prevDiagnosticCount,
      };

      // Promote this branch to the leader if it's the first, or if it has less diagnostics than the current
      let shouldPromote = false;

      if (topBranch === undefined || branch.optimal) {
        shouldPromote = true;
      } else {
        // Promote if the branch has less diagnostics than the top branch
        if (branch.diagnosticCount < topBranch.diagnosticCount) {
          shouldPromote = true;
        }

        // Promote if we have a priority but the top branch doesn't
        if (branch.diagnosticsPriority !== undefined &&
          topBranch.diagnosticsPriority === undefined) {
          shouldPromote = true;
        }

        // Promote if we have a priority, and the top branch does, and we're higher
        if (branch.diagnosticsPriority !== undefined &&
          topBranch.diagnosticsPriority !== undefined &&
          branch.diagnosticsPriority > topBranch.diagnosticsPriority) {
          shouldPromote = true;
        }

        // Don't promote if the top branch has a priority but we don't
        if (topBranch.diagnosticsPriority !== undefined &&
          branch.diagnosticsPriority === undefined) {
          shouldPromote = false;
        }
      }

      if (shouldPromote) {
        this.branch = branch;
      }

      return this;
    }

    getBranch() {
      if (this.branch === undefined) {
        throw new Error('No branch');
      } else {
        return this.branch;
      }
    }

    pickOptional() {
      if (this.hasBranch()) {
        return this.pick();
      } else {
        return undefined;
      }
    }

    pick() {
      if (this.picked) {
        throw new Error('Already been picked');
      }
      this.picked = true;

      const {parser} = this;
      const branch = this.getBranch();

      const {result, state} = branch;
      parser.setState(state);
      return result;
    }
  }

  // project-rome/@romejs/js-parser/parser.ts
const ___R$$priv$project$rome$$romejs$js$parser$parser_ts$TOKEN_MISTAKES = {
    ';': ':',
    ',': '.',
  };

  class ___R$project$rome$$romejs$js$parser$parser_ts$DiagnosticsFatalError extends Error {
    constructor() {
      super(
        'Diagnostics exceeded maxDiagnostics state cap, this error is expected to be handled by a try-catch in the call stack',
      );
    }
  }

  const ___R$$priv$project$rome$$romejs$js$parser$parser_ts$SCOPE_TYPES = [
    'FUNCTION_LOC',
    'NON_ARROW_FUNCTION',
    'FUNCTION',
    'GENERATOR',
    'ASYNC',
    'PROPERTY_NAME',
    'CLASS_PROPERTY',
    'PARAMETERS',
    'METHOD',
    'CLASS',
    'TYPE',
    'MAX_NEW_DIAGNOSTICS',
    'STRICT',
    'FLOW_COMMENT',
  ];

  const ___R$$priv$project$rome$$romejs$js$parser$parser_ts$createJSParser = ___R$project$rome$$romejs$parser$core$index_ts$createParser(
    (
      ParserCore,
      ParserWithRequiredPath,
    ) =>
      (() => {
        // rome-suppress lint/noExplicitAny
        class JSParser extends ParserWithRequiredPath {
          constructor(options) {
            const state = ___R$project$rome$$romejs$js$parser$tokenizer$state_ts$createInitialState();

            const parserOpts = {
              path: options.path,
              mtime: options.mtime,
              input: options.input,
            };
            super(parserOpts, 'parse/js', state);

            this.isTrackingTokens = options.tokens;

            this.isLookahead = false;

            this.sourceType = options.sourceType;
            this.options = options;
            this.inModule =
              this.options.sourceType === 'template' ||
              this.options.sourceType === 'module';
            this.parenthesized = new Set();

            // Turn options.syntax into a Set, probably faster than doing `includes` on the array

            // We may also push stuff to it as we read comments such as `@\flow`
            this.syntax = new Set(options.syntax);
          }

          resetTokenizerLine() {
            this.state.lineStartIndex = this.state.index;
            this.state.lineStart = true;
            this.state.indentLevel = ___R$project$rome$$romejs$ob1$index_ts$number0;
          }

          getScope(type) {
            let scope = this.state.scopes[type];
            if (scope === undefined) {
              scope = [];
              this.state.scopes[type] = scope;
            }
            return scope;
          }

          getLastScope(type) {
            const scope = this.getScope(type);
            return scope[scope.length - 1];
          }

          pushScope(type, value) {
            //console.log('+' + type);

            //console.group();
            this.getScope(type).push(value);
          }

          popScope(type) {
            //console.groupEnd();

            //console.log('-' + type);
            this.getScope(type).pop();
          }

          inScope(type) {
            return this.hasScope(type) && this.getLastScope(type) !== false;
          }

          hasScope(type) {
            const scope = this.state.scopes[type];
            return scope !== undefined && scope.length > 0;
          }

          addParenthesized(node) {
            this.parenthesized.add(this.getLoc(node).start.index);
          }

          isParenthesized(node) {
            return this.parenthesized.has(this.getLoc(node).start.index);
          }

          setState(newState) {
            // Verify that this new state doesn't exceed any previous maxDiagnostic cap

            // maxDiagnostics will be at -1 when it's own limit has been exceeded, in

            // this case, we are likely replacing the State with another that's valid

            // and doesn't exceed
            const maxDiagnostics = this.getLastScope('MAX_NEW_DIAGNOSTICS');
            if (typeof maxDiagnostics === 'number' && maxDiagnostics !== -1) {
              const diff = newState.diagnostics.length - this.state.diagnostics.length;
              if (diff > maxDiagnostics) {
                throw new ___R$project$rome$$romejs$js$parser$parser_ts$DiagnosticsFatalError();
              }
            }

            this.state = newState;
          }

          atEOF() {
            return this.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof);
          }

          createBranch() {
            return new ___R$project$rome$$romejs$js$parser$ParserBranchFinder_ts$default(this);
          }

          tryBranch(fn) {
            const branch = new ___R$project$rome$$romejs$js$parser$ParserBranchFinder_ts$default(this);
            branch.add(fn, {maxNewDiagnostics: 0});
            if (branch.hasBranch()) {
              return branch.pickOptional();
            }
          }

          finalizeNode(node) {
            ___R$project$rome$$romejs$js$parser$parser$comments_ts$attachComments(this, node);
            return node;
          }

          finishNode(start, node) {
            return this.finishNodeAt(start, this.getLastEndPosition(), node);
          }

          finishNodeAt(start, end, node) {
            // Maybe mutating `node` is better...?
            const newNode = Object.assign(
              {
              },
              node,
              {
                loc: this.finishLocAt(start, end),
              },
            );
            return this.finalizeNode(newNode);
          }

          createUnknownIdentifier(reason, start = this.getPosition(), end = this.getLastEndPosition()) {
            this.state.corrupt = true;
            return (
              {
                type: 'Identifier',
                name: 'INVALID_PLACEHOLDER',
                loc: this.finishLocAt(start, end),
              }
            );
          }

          createUnknownStringLiteral(reason, start = this.getPosition(), end = this.getLastEndPosition()) {
            this.state.corrupt = true;
            return (
              {
                type: 'StringLiteral',
                value: 'INVALID_PLACEHOLDER',
                loc: this.finishLocAt(start, end),
              }
            );
          }

          assertNoSpace(message = 'Unexpected space') {
            const {state} = this;

            if (state.startPos.index > state.lastEndPos.index) {
              this.addDiagnostic(
                {
                  start: state.lastEndPos,
                  end: state.lastEndPos,
                  message,
                },
              );
            }
          }

          getDiagnostics() {
            const collector = new ___R$project$rome$$romejs$diagnostics$DiagnosticsProcessor_ts$default(
              {
                origins: [
                  {
                    category: 'js-parser',
                  },
                ],
                //unique: ['start.line'],
              },
            );

            for (const filter of this.state.diagnosticFilters) {
              collector.addFilter(filter);
            }

            // TODO remove any trailing "eof" diagnostic
            return collector.addDiagnostics(this.state.diagnostics).slice(0, 1);
          }

          addDiagnosticFilter(diag) {
            this.state.diagnosticFilters.push(diag);
          }

          addCompleteDiagnostic(diags) {
            this.state.diagnostics = [...this.state.diagnostics, ...diags];
          }

          shouldCreateToken() {
            return this.isTrackingTokens && this.isLookahead === false;
          }

          createToken(state) {
            const token = {
              type: state.tokenType,
              start: state.startPos.index,
              end: state.endPos.index,
              loc: {
                filename: this.filename,
                start: state.startPos,
                end: state.endPos,
              },
            };
            this.pushToken(token);
            return token;
          }

          pushToken(token) {
            const lastToken = this.state.tokens[this.state.tokens.length - 1];
            if (lastToken !== undefined) {
              if (token.loc.start.index < lastToken.loc.end.index) {
                throw (
                  new Error(
                    'Trying to push a token that appears before the last pushed token',
                  )
                );
              }
            }

            this.state.tokens.push(token);
          }

          addDiagnostic(diag) {
            if (this.isLookahead) {
              return undefined;
            }

            let maxDiagnostics = this.getLastScope('MAX_NEW_DIAGNOSTICS');
            if (typeof maxDiagnostics === 'number') {
              maxDiagnostics--;
              this.popScope('MAX_NEW_DIAGNOSTICS');
              this.pushScope('MAX_NEW_DIAGNOSTICS', maxDiagnostics);
              if (maxDiagnostics < 0) {
                throw new ___R$project$rome$$romejs$js$parser$parser_ts$DiagnosticsFatalError();
              }
            }

            if (this.state.diagnostics.length > 0) {
              //return;
            }

            let {start, end} = diag;

            if (diag.index !== undefined) {
              start = this.getPositionFromIndex(diag.index);
              end = start;
            }

            if (diag.loc !== undefined) {
              start = diag.loc.start;
              end = diag.loc.end;
            }

            // If we weren't given a start then default to the provided end, or the current token start
            if (start === undefined && end === undefined) {
              start = this.getPosition();
              end = this.getLastEndPosition();
            }

            if (start === undefined && end !== undefined) {
              start = end;
            }

            if (start !== undefined && end === undefined) {
              end = start;
            }

            this.state.diagnostics.push(
              {
                filename: this.filename,
                sourceType: this.sourceType,
                mtime: this.mtime,
                message: diag.message,
                advice: diag.advice,
                start,
                end,
                category: 'parse/js',
              },
            );
          }

          shouldTokenizeJSX() {
            return !this.isSyntaxEnabled('ts') || this.isSyntaxEnabled('jsx');
          }

          isSyntaxEnabled(syntax) {
            return this.syntax.has(syntax);
          }

          expectSyntaxEnabled(syntax) {
            if (!this.isSyntaxEnabled(syntax)) {
              this.addDiagnostic(
                {
                  message: 'Expected ' +
                  syntax +
                  ' to be enabled',
                },
              );
            }
          }

          isRelational(op) {
            return this.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.relational) && this.state.tokenValue === op;
          }

          expectRelational(op) {
            if (this.eatRelational(op)) {
              return true;
            } else {
              this.addDiagnostic(
                {
                  message: 'Expected relational operator',
                },
              );
              return false;
            }
          }

          isLookaheadRelational(op) {
            const l = this.lookaheadState();
            return l.tokenType == ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.relational && l.tokenValue == op;
          }

          banUnicodeEscape(index, name) {
            if (index !== undefined) {
              this.addDiagnostic(
                {
                  index,
                  message: name +
                  ' can\'t contain a unicode escape',
                },
              );
            }
          }

          // eat() for relational operators.
          eatRelational(op) {
            if (this.isRelational(op)) {
              this.next();
              return true;
            } else {
              return false;
            }
          }

          // Tests whether parsed token is a contextual keyword.
          isContextual(name) {
            return (
              this.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name) && this.state.tokenValue === name &&
                this.state.escapePosition === undefined
            );
          }

          isLookaheadContextual(name) {
            const l = this.lookaheadState();
            return (
              l.tokenType === ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name && l.tokenValue === name &&
                l.escapePosition === undefined
            );
          }

          // Consumes contextual keyword if possible.
          eatContextual(name) {
            if (this.isContextual(name)) {
              this.next();
              return true;
            } else {
              return false;
            }
          }

          // Asserts that following token is given contextual keyword.
          expectContextual(name, message = 'Expected keyword ' +
          name) {
            if (this.eatContextual(name)) {
              return true;
            } else {
              this.addDiagnostic(
                {
                  message,
                },
              );
              return false;
            }
          }

          // Test whether a semicolon can be inserted at the current position.
          canInsertSemicolon() {
            return (
              this.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof) || this.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR) ||
              this.hasPrecedingLineBreak()
            );
          }

          hasPrecedingLineBreak() {
            return (
              ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreak.test(
                this.getRawInput(
                  this.state.lastEndPos.index,
                  this.state.startPos.index,
                ),
              )
            );
          }

          isLineTerminator() {
            return this.eat(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi) || this.canInsertSemicolon();
          }

          // Consume a semicolon, or, failing that, see if we are allowed to

          // pretend that there is a semicolon at this position.
          semicolon() {
            if (!this.isLineTerminator()) {
              this.addDiagnostic(
                {
                  message: 'Expected a semicolon or a line terminator',
                },
              );
            }
          }

          // Expect a token of a given type. If found, consume it, otherwise,

          // raise an unexpected token error at given pos.
          expect(type, pos) {
            if (this.eat(type)) {
              return true;
            } else {
              this.unexpectedToken(pos, type);
              return false;
            }
          }

          expectOpening(open, close, name) {
            const pos = this.getPosition();
            const indent = this.state.indentLevel;
            this.expect(open);
            return (
              {
                indent,
                start: pos,
                name,
                open,
                close,
              }
            );
          }

          expectClosing(context) {
            if (this.match(context.close)) {
              if (this.state.indentLevel !== context.indent) {
                this.state.possibleIncorrectOpenParens.push(context);
              }
              this.next();
              return true;
            } else {
              const currPos = this.getPosition();

              const advice = [
                {
                  type: 'log',
                  category: 'info',
                  message: 'We expected to find the closing character <emphasis>' +
                  context.close.label +
                  '</emphasis> here',
                },
                {
                  type: 'frame',
                  filename: this.filename,
                  start: currPos,
                  end: currPos,
                },
              ];

              const possibleThief = this.state.possibleIncorrectOpenParens.shift();
              if (possibleThief !== undefined) {
                advice.push(
                  {
                    type: 'log',
                    category: 'info',
                    message: 'We found this ' +
                    possibleThief.name +
                    ' that looks suspicious. It could be the real culprit that\'s unclosed.',
                  },
                );

                advice.push(
                  {
                    type: 'frame',
                    filename: this.filename,
                    start: possibleThief.start,
                    end: possibleThief.start,
                  },
                );
              }

              this.addDiagnostic(
                {
                  message: 'Unclosed ' +
                  context.name,
                  start: context.start,
                  end: context.start,
                  advice,
                },
              );
              return false;
            }
          }

          // Raise an unexpected token error. Can take the expected token type

          // instead of a message string.
          unexpectedToken(pos, tokenType) {
            const advice = [];
            let message = 'Unexpected token'; // + new Error().stack;
            if (tokenType !== undefined) {
              message += ', expected "' +
              tokenType.label +
              '"';

              const possibleMistake = ___R$$priv$project$rome$$romejs$js$parser$parser_ts$TOKEN_MISTAKES[tokenType.label];
              if (possibleMistake !== undefined &&
                possibleMistake ===
                this.state.tokenType.label) {
                advice.push(
                  {
                    type: 'log',
                    category: 'info',
                    message: 'Did you accidently hold shift?',
                  },
                );
              }
            }

            this.addDiagnostic(
              {
                message,
                start: pos === undefined ? this.state.startPos : pos,
                end: pos === undefined ? this.state.endPos : pos,
                advice,
              },
            );
          }

          unexpected() {
            throw (
              new Error(
                'js-parser should never throw an exception, use addDiagnostic or unexpectedToken instead',
              )
            );
          }

          tokenize() {
            throw new Error('js-parser does not use the parser-core tokenizer');
          }

          cloneNode(node) {
            if (node.leadingComments === undefined &&
              node.trailingComments ===
              undefined &&
              node.innerComments === undefined) {
              // Do we really need to clone this?
              return Object.assign(
                {
                },
                node,
              );
            } else {
              return (
                Object.assign(
                  {
                  },
                  node,
                  {
                    leadingComments: undefined,
                    trailingComments: undefined,
                    innerComments: undefined,
                  },
                )
              );
            }
          }

          // Reset the start location of node to the start location of locationNode
          resetStartLocationFromNode(node, locationNode) {
            node.loc =
              Object.assign(
                {
                },
                this.getLoc(node),
                {
                  start: this.getLoc(locationNode).start,
                },
              );
          }

          next() {
            if (this.shouldCreateToken()) {
              this.createToken(this.state);
            }

            this.state.lastEndPos = this.state.endPos;
            this.state.lastStartPos = this.state.startPos;
            ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$nextToken(this);
          }

          eat(type) {
            if (this.match(type)) {
              this.next();
              return true;
            }

            return false;
          }

          match(type) {
            return this.state.tokenType === type;
          }

          lookaheadState() {
            const old = this.state;
            this.state = this.cloneState(true);

            this.isLookahead = true;
            this.next();
            this.isLookahead = false;

            const curr = this.state;
            this.state = old;
            return curr;
          }

          cloneState(skipArrays = false) {
            const state = Object.assign(
              {
              },
              this.state,
            );

            for (const key in state) {
              // @ts-ignore
              let val = state[key];

              const shouldSlice = skipArrays === false || key === 'context';
              if (shouldSlice && Array.isArray(val)) {
                // @ts-ignore
                state[key] = val.slice();
              }
            }

            const scopes = Object.assign(
              {
              },
              state.scopes,
            );
            state.scopes = scopes;
            for (const type of ___R$$priv$project$rome$$romejs$js$parser$parser_ts$SCOPE_TYPES) {
              const scope = scopes[type];
              if (scope !== undefined) {
                scopes[type] = scope.slice();
              }
            }

            return state;
          }

          // Overrides ParserCore#getPosition
          getPosition() {
            return this.state.startPos;
          }

          // Overrides ParserCore#getLastEndPosition
          getLastEndPosition() {
            return this.state.lastEndPos;
          }

          // Private method to actually generate a Position
          getPositionFromState() {
            const {state} = this;
            return (
              {
                index: state.index,
                line: state.curLine,
                column: ___R$project$rome$$romejs$ob1$index_ts$sub(state.index, state.lineStartIndex),
              }
            );
          }

          parse() {
            if (this.inModule) {
              this.pushScope('ASYNC', true);
              this.pushScope('STRICT', true);
            }

            const program = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseTopLevel(this);

            if (this.inModule) {
              this.popScope('ASYNC');
              this.popScope('STRICT');
            }

            // Smoke test for unpopped scopes
            for (const type of ___R$$priv$project$rome$$romejs$js$parser$parser_ts$SCOPE_TYPES) {
              if (this.hasScope(type)) {
                throw (
                  new Error(
                    'Finished parsing but there was still a ' +
                    type +
                    ' scope stack',
                  )
                );
              }
            }

            // Smoke test for token exhaustion
            if (!this.match(___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof)) {
              throw new Error('Finish parsing but we arent at the end of the file');
            }

            return program;
          }
        }

        return (
          JSParser
        );
      })(),
  );

  const ___R$project$rome$$romejs$js$parser$parser_ts$default = ___R$$priv$project$rome$$romejs$js$parser$parser_ts$createJSParser;

  // project-rome/@romejs/js-parser/index.ts
function ___R$project$rome$$romejs$js$parser$index_ts$parseJS(userOptions) {
    const options = ___R$project$rome$$romejs$js$parser$options_ts$normalizeOptions(userOptions);
    return ___R$project$rome$$romejs$js$parser$parser_ts$default(options).parse();
  }

  function ___R$project$rome$$romejs$js$parser$index_ts$tokenizeJS(
    input,
    userOptions,
  ) {
    const options = ___R$project$rome$$romejs$js$parser$options_ts$normalizeOptions(userOptions);
    const parser = ___R$project$rome$$romejs$js$parser$parser_ts$default(Object.assign(
      {
      },
      options,
      {
        tokens: true,
        input,
      },
    ));
    parser.parse();

    const diagnostics = parser.getDiagnostics();
    let tokens = parser.state.tokens;

    // If we have any diagnostics, then mark anything from the first as invalid
    if (diagnostics.length > 0) {
      const firstDiag = diagnostics[0];
      const invalidStart = firstDiag.start;
      const invalidEnd = firstDiag.end;
      if (invalidStart === undefined || invalidEnd === undefined) {
        throw new Error('All parser diagnostics are expected to have a start/end');
      }

      const invalidStartIndex = invalidStart.index;

      const invalidToken = {
        type: ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.invalid,
        start: invalidStart.index,
        end: invalidEnd.index,
        loc: {
          filename: parser.filename,
          start: invalidStart,
          end: invalidEnd,
        },
      };

      // Remove all tokens after our invalid one
      tokens =
        tokens.filter(
          (token) => {
            return token.loc.start.index >= invalidStartIndex;
          },
        );

      tokens.push(invalidToken);
    }

    return tokens;
  }

  // project-rome/@romejs/js-generator/generators/literals/StringLiteral.ts
function ___R$project$rome$$romejs$js$generator$generators$literals$StringLiteral_ts$default(
    generator,
    node,
    parent,
  ) {
    node =
      node.type == 'StringLiteralTypeAnnotation' || node.type === 'Directive'
        ? node : ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.assert(node);

    // JSX Attribute strings have ridiculous alternate semantics, should probably be a distinct AST node
    const quotes = parent.type === 'JSXAttribute' ? '"' : '\'';
    const value = parent.type === 'JSXAttribute'
      ? ___R$project$rome$$romejs$js$parser$xhtmlEntities_ts$escapeXHTMLEntities(node.value) : node.value;

    generator.token(
      ___R$project$rome$$romejs$string$escape$escapeString_ts$default(
        value,
        {
          quote: quotes,
        },
      ),
    );
  }

  // project-rome/@romejs/js-generator/generators/core/Directive.ts
function ___R$project$rome$$romejs$js$generator$generators$core$Directive_ts$default(
    generator,
    node,
    parent,
  ) {
    ___R$project$rome$$romejs$js$generator$generators$literals$StringLiteral_ts$default(generator, node, parent);
    generator.semicolon();
  }

  // project-rome/@romejs/js-generator/generators/expressions/DoExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$expressions$DoExpression_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$expressions$DoExpression_ts$doExpression.assert(node);
    ___R$project$rome$$romejs$js$ast$expressions$DoExpression_ts$doExpression.assert(node);
    generator.word('do');
    generator.space();
    generator.print(node.body, node);
  }

  // project-rome/@romejs/js-generator/generators/statements/DoWhileStatement.ts
function ___R$project$rome$$romejs$js$generator$generators$statements$DoWhileStatement_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$statements$DoWhileStatement_ts$doWhileStatement.assert(node);

    generator.word('do');
    generator.space();
    generator.print(node.body, node);
    generator.space();
    generator.word('while');
    generator.space();
    generator.token('(');
    generator.print(node.test, node);
    generator.token(')');
    generator.semicolon();
  }

  // project-rome/@romejs/js-generator/generators/types/EmptyKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$types$EmptyKeywordTypeAnnotation_ts$default(generator) {
    generator.word('empty');
  }

  // project-rome/@romejs/js-generator/generators/statements/EmptyStatement.ts
function ___R$project$rome$$romejs$js$generator$generators$statements$EmptyStatement_ts$default(generator) {
    generator.semicolon();
  }

  // project-rome/@romejs/js-generator/generators/modules/ExportAllDeclaration.ts
function ___R$project$rome$$romejs$js$generator$generators$modules$ExportAllDeclaration_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$modules$ExportAllDeclaration_ts$exportAllDeclaration.assert(node);

    generator.word('export');
    generator.space();
    generator.token('*');
    generator.space();
    generator.word('from');
    generator.space();
    generator.print(node.source, node);
    generator.semicolon();
  }

  // project-rome/@romejs/js-generator/generators/modules/ExportLocalDeclaration.ts
function ___R$project$rome$$romejs$js$generator$generators$modules$ExportLocalDeclaration_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$modules$ExportLocalDeclaration_ts$exportLocalDeclaration.assert(node);

    if (node.exportKind === 'type' && !generator.options.typeAnnotations) {
      return;
    }
    generator.word('export');
    generator.space();
    ___R$project$rome$$romejs$js$generator$generators$modules$ExportLocalDeclaration_ts$_ExportDeclaration(generator, node);
  }

  function ___R$project$rome$$romejs$js$generator$generators$modules$ExportLocalDeclaration_ts$_ExportDeclaration(generator, node) {
    node =
      node.type === 'ExportDefaultDeclaration'
        ? node : ___R$project$rome$$romejs$js$ast$modules$ExportLocalDeclaration_ts$exportLocalDeclaration.assert(node);

    if (node.declaration) {
      const declar = node.declaration;
      generator.print(declar, node);
      if (!___R$project$rome$$romejs$js$ast$utils$isDeclaration_ts$default(declar)) {
        generator.semicolon();
      }
    } else {
      if (node.type !== 'ExportLocalDeclaration') {
        throw new Error('Expected  ExportLocalDeclaration');
      }

      if (node.exportKind === 'type') {
        generator.word('type');
        generator.space();
      }

      const {specifiers} = node;
      if (specifiers === undefined) {
        throw new Error('Expected specifiers since there was no declaration');
      }

      generator.multiline(
        node,
        (multiline, node) => {
          generator.token('{');

          if (specifiers.length > 0) {
            generator.printCommaList(
              specifiers,
              node,
              {
                multiline,
                trailing: true,
              },
            );
          }
          generator.token('}');

          generator.semicolon();
        },
      );
    }
  }

  // project-rome/@romejs/js-generator/generators/modules/ExportDefaultDeclaration.ts
function ___R$project$rome$$romejs$js$generator$generators$modules$ExportDefaultDeclaration_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$modules$ExportDefaultDeclaration_ts$exportDefaultDeclaration.assert(node);

    generator.word('export');
    generator.space();
    generator.word('default');
    generator.space();
    ___R$project$rome$$romejs$js$generator$generators$modules$ExportLocalDeclaration_ts$_ExportDeclaration(generator, node);
  }

  // project-rome/@romejs/js-generator/generators/modules/ExportDefaultSpecifier.ts
function ___R$project$rome$$romejs$js$generator$generators$modules$ExportDefaultSpecifier_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$modules$ExportDefaultSpecifier_ts$exportDefaultSpecifier.assert(node);

    generator.print(node.exported, node);
  }

  // project-rome/@romejs/js-generator/generators/modules/ExportExternalDeclaration.ts
function ___R$project$rome$$romejs$js$generator$generators$modules$ExportExternalDeclaration_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$modules$ExportExternalDeclaration_ts$exportExternalDeclaration.assert(node);

    generator.word('export');
    generator.space();

    if (node.exportKind === 'type') {
      generator.word('type');
      generator.space();
    }

    if (node.specifiers === undefined) {
      throw new Error('Expected specifiers since there was no declaration');
    }

    const specifiers = node.specifiers.slice(0);

    generator.multiline(
      node,
      (multiline, node) => {
        // print "special" specifiers first
        let hasSpecial = false;
        while (true) {
          const first = specifiers[0];
          if (first !== undefined &&
            (first.type === 'ExportDefaultSpecifier' ||
            first.type === 'ExportNamespaceSpecifier')) {
            hasSpecial = true;
            generator.print(specifiers.shift(), node);
            if (specifiers.length) {
              generator.token(',');
              generator.space();
            }
          } else {
            break;
          }
        }

        if (specifiers.length || !specifiers.length && !hasSpecial) {
          generator.token('{');
          if (specifiers.length) {
            generator.printCommaList(
              specifiers,
              node,
              {
                multiline,
                trailing: true,
              },
            );
          }
          generator.token('}');
        }

        generator.space();
        generator.word('from');
        generator.space();
        generator.print(node.source, node);

        generator.semicolon();
      },
    );
  }

  // project-rome/@romejs/js-generator/generators/modules/ExportLocalSpecifier.ts
function ___R$project$rome$$romejs$js$generator$generators$modules$ExportLocalSpecifier_ts$default(generator, node) {
    node =
      node.type === 'ExportExternalSpecifier'
        ? node : ___R$project$rome$$romejs$js$ast$modules$ExportLocalSpecifier_ts$exportLocalSpecifier.assert(node);

    generator.print(node.local, node);
    if (node.exported && node.local.name !== node.exported.name) {
      generator.space();
      generator.word('as');
      generator.space();
      generator.print(node.exported, node);
    }
  }

  // project-rome/@romejs/js-generator/generators/modules/ExportExternalSpecifier.ts
function ___R$project$rome$$romejs$js$generator$generators$modules$ExportExternalSpecifier_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$modules$ExportExternalSpecifier_ts$exportExternalSpecifier.assert(node);
    ___R$project$rome$$romejs$js$generator$generators$modules$ExportLocalSpecifier_ts$default(generator, node);
  }

  // project-rome/@romejs/js-generator/generators/modules/ExportNamespaceSpecifier.ts
function ___R$project$rome$$romejs$js$generator$generators$modules$ExportNamespaceSpecifier_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$modules$ExportNamespaceSpecifier_ts$exportNamespaceSpecifier.assert(node);

    generator.token('*');
    generator.space();
    generator.word('as');
    generator.space();
    generator.print(node.exported, node);
  }

  // project-rome/@romejs/js-generator/generators/statements/ExpressionStatement.ts
function ___R$project$rome$$romejs$js$generator$generators$statements$ExpressionStatement_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$statements$ExpressionStatement_ts$expressionStatement.assert(node);

    generator.print(node.expression, node);
    generator.semicolon();
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowArrayTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowArrayTypeAnnotation_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowArrayTypeAnnotation_ts$flowArrayTypeAnnotation.assert(node);

    generator.print(node.elementType, node);
    generator.token('[');
    generator.token(']');
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowInterfaceExtends.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowInterfaceExtends_ts$default(generator, node) {
    node =
      node.type === 'FlowGenericTypeAnnotation' ||
      node.type ===
      'FlowClassImplements'
        ? node : ___R$project$rome$$romejs$js$ast$flow$FlowInterfaceExtends_ts$flowInterfaceExtends.assert(node);

    generator.print(node.id, node);
    generator.print(node.typeParameters, node);
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowClassImplements.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowClassImplements_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowClassImplements_ts$flowClassImplements.assert(node);
    ___R$project$rome$$romejs$js$generator$generators$flow$FlowInterfaceExtends_ts$default(generator, node);
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowInterfaceDeclaration.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowInterfaceDeclaration_ts$default(
    generator,
    node,
  ) {
    node =
      node.type === 'FlowDeclareInterface'
        ? node : ___R$project$rome$$romejs$js$ast$flow$FlowInterfaceDeclaration_ts$flowInterfaceDeclaration.assert(node);

    generator.word('interface');
    generator.space();
    ___R$project$rome$$romejs$js$generator$generators$flow$FlowInterfaceDeclaration_ts$_interfaceish(generator, node);
  }

  function ___R$project$rome$$romejs$js$generator$generators$flow$FlowInterfaceDeclaration_ts$_interfaceish(generator, node) {
    node =
      node.type === 'FlowDeclareInterface' || node.type === 'FlowDeclareClass'
        ? node : ___R$project$rome$$romejs$js$ast$flow$FlowInterfaceDeclaration_ts$flowInterfaceDeclaration.assert(node);

    generator.print(node.id, node);
    generator.print(node.typeParameters, node);

    if (node.extends.length > 0) {
      generator.space();
      generator.word('extends');
      generator.space();
      generator.printCommaList(node.extends, node);
    }

    if (node.mixins.length > 0) {
      generator.space();
      generator.word('mixins');
      generator.space();
      generator.printCommaList(node.mixins, node);
    }

    generator.space();
    generator.print(node.body, node);
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowDeclareClass.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowDeclareClass_ts$default(
    generator,
    node,
    parent,
  ) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowDeclareClass_ts$flowDeclareClass.assert(node);

    if (parent.type !== 'ExportLocalDeclaration') {
      generator.word('declare');
      generator.space();
    }
    generator.word('class');
    generator.space();
    ___R$project$rome$$romejs$js$generator$generators$flow$FlowInterfaceDeclaration_ts$_interfaceish(generator, node);
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowDeclaredPredicate.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowDeclaredPredicate_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowDeclaredPredicate_ts$flowDeclaredPredicate.assert(node);

    generator.token('%checks');
    generator.space();
    generator.print(node.value, node);
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowDeclareExportAll.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowDeclareExportAll_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowDeclareExportAll_ts$flowDeclareExportAll.assert(node);

    ___R$project$rome$$romejs$js$ast$flow$FlowDeclareExportAll_ts$flowDeclareExportAll.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowDeclareExportDefault.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowDeclareExportDefault_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowDeclareExportDefault_ts$flowDeclareExportDefault.assert(node);

    ___R$project$rome$$romejs$js$ast$flow$FlowDeclareExportDefault_ts$flowDeclareExportDefault.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowDeclareExportNamed.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowDeclareExportNamed_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowDeclareExportNamed_ts$flowDeclareExportNamed.assert(node);

    ___R$project$rome$$romejs$js$ast$flow$FlowDeclareExportNamed_ts$flowDeclareExportNamed.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowDeclareFunction.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowDeclareFunction_ts$default(
    generator,
    node,
    parent,
  ) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowDeclareFunction_ts$flowDeclareFunction.assert(node);

    if (parent.type !== 'ExportLocalDeclaration') {
      generator.word('declare');
      generator.space();
    }
    generator.word('function');
    generator.space();
    generator.print(node.id, node);
    generator.semicolon();
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowDeclareInterface.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowDeclareInterface_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowDeclareInterface_ts$flowDeclareInterface.assert(node);

    generator.word('declare');
    generator.space();
    ___R$project$rome$$romejs$js$generator$generators$flow$FlowInterfaceDeclaration_ts$default(generator, node);
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowDeclareModule.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowDeclareModule_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowDeclareModule_ts$flowDeclareModule.assert(node);

    generator.word('declare');
    generator.space();
    generator.word('module');
    generator.space();
    generator.print(node.id, node);
    generator.space();
    generator.print(node.body, node);
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowDeclareModuleExports.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowDeclareModuleExports_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowDeclareModuleExports_ts$flowDeclareModuleExports.assert(node);

    generator.word('declare');
    generator.space();
    generator.word('module');
    generator.token('.');
    generator.word('exports');
    generator.printTypeColon(node.typeAnnotation, node);
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowOpaqueType.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowOpaqueType_ts$default(generator, node) {
    node =
      node.type === 'FlowDeclareOpaqueType'
        ? node : ___R$project$rome$$romejs$js$ast$flow$FlowOpaqueType_ts$flowOpaqueType.assert(
          node,
        );

    generator.word('opaque');
    generator.space();
    generator.word('type');
    generator.space();
    generator.print(node.id, node);
    generator.print(node.typeParameters, node);
    if (node.supertype) {
      generator.token(':');
      generator.space();
      generator.print(node.supertype, node);
    }
    if (node.impltype) {
      generator.space();
      generator.token('=');
      generator.space();
      generator.print(node.impltype, node);
    }
    generator.semicolon();
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowDeclareOpaqueType.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowDeclareOpaqueType_ts$default(
    generator,
    node,
    parent,
  ) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowDeclareOpaqueType_ts$flowDeclareOpaqueType.assert(node);

    if (parent.type !== 'ExportLocalDeclaration') {
      generator.word('declare');
      generator.space();
    }
    ___R$project$rome$$romejs$js$generator$generators$flow$FlowOpaqueType_ts$default(generator, node);
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowDeclareVariable.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowDeclareVariable_ts$default(
    generator,
    node,
    parent,
  ) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowDeclareVariable_ts$flowDeclareVariable.assert(node);

    if (parent.type !== 'ExportLocalDeclaration') {
      generator.word('declare');
      generator.space();
    }
    generator.word('var');
    generator.space();

    const {id} = node;
    generator.print(id, node);
    if (id.meta !== undefined) {
      generator.print(id.meta.typeAnnotation, node);
    }

    generator.semicolon();
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowExistsTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowExistsTypeAnnotation_ts$default(generator) {
    generator.token('*');
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowFunctionTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowFunctionTypeAnnotation_ts$default(
    generator,
    node,
    parent,
  ) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowFunctionTypeAnnotation_ts$flowFunctionTypeAnnotation.assert(node);

    generator.print(node.typeParameters, node);
    generator.token('(');
    generator.printCommaList(node.params, node);
    generator.token(')');

    // this node type is overloaded, not sure why but it makes it EXTREMELY annoying
    if (parent.type === 'FlowObjectTypeCallProperty' ||
    parent.type ===
    'FlowDeclareFunction') {
      generator.token(':');
    } else {
      generator.space();
      generator.token('=>');
    }

    generator.space();
    generator.print(node.returnType, node);
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowFunctionTypeParam.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowFunctionTypeParam_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowFunctionTypeParam_ts$flowFunctionTypeParam.assert(node);

    if (node.name) {
      generator.print(node.name, node);
      if (node.meta.optional === true) {
        generator.token('?');
      }
      generator.token(':');
      generator.space();
    }
    generator.print(node.meta.typeAnnotation, node);
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowGenericTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowGenericTypeAnnotation_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowGenericTypeAnnotation_ts$flowGenericTypeAnnotation.assert(node);

    ___R$project$rome$$romejs$js$generator$generators$flow$FlowInterfaceExtends_ts$default(generator, node);
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowInferredPredicate.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowInferredPredicate_ts$default(generator) {
    generator.token('%checks');
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowInterface.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowInterface_ts$default() {
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowInterfaceTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowInterfaceTypeAnnotation_ts$default() {
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowNullableTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowNullableTypeAnnotation_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowNullableTypeAnnotation_ts$flowNullableTypeAnnotation.assert(node);

    generator.token('?');
    generator.print(node.typeAnnotation, node);
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowNumericLiteral.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowNumericLiteral_ts$default() {
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowObjectTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowObjectTypeAnnotation_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeAnnotation_ts$flowObjectTypeAnnotation.assert(node);

    if (node.exact === true) {
      generator.token('{|');
    } else {
      generator.token('{');
    }

    generator.printCommaList(node.properties, node);

    if (node.exact === true) {
      generator.token('|}');
    } else {
      generator.token('}');
    }
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowObjectTypeCallProperty.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowObjectTypeCallProperty_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeCallProperty_ts$flowObjectTypeCallProperty.assert(node);

    if (node.static === true) {
      generator.word('static');
      generator.space();
    }
    generator.print(node.value, node);
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowObjectTypeIndexer.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowObjectTypeIndexer_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeIndexer_ts$flowObjectTypeIndexer.assert(node);

    if (node.static === true) {
      generator.word('static');
      generator.space();
    }

    generator.print(node.variance, node);
    generator.token('[');

    if (node.id !== undefined) {
      generator.print(node.id, node);
      generator.token(':');
    }

    generator.space();
    generator.print(node.key, node);
    generator.token(']');
    generator.token(':');
    generator.space();
    generator.print(node.value, node);
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowObjectTypeInternalSlot.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowObjectTypeInternalSlot_ts$default() {
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowObjectTypeProperty.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowObjectTypeProperty_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeProperty_ts$flowObjectTypeProperty.assert(node);

    if (node.static === true) {
      generator.word('static');
      generator.space();
    }
    generator.print(node.variance, node);
    generator.print(node.key, node);
    if (node.optional === true) {
      generator.token('?');
    }
    generator.token(':');
    generator.space();
    generator.print(node.value, node);
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowObjectTypeSpreadProperty.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowObjectTypeSpreadProperty_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeSpreadProperty_ts$flowObjectTypeSpreadProperty.assert(node);

    generator.token('...');
    generator.print(node.argument, node);
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowQualifiedTypeIdentifier.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowQualifiedTypeIdentifier_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowQualifiedTypeIdentifier_ts$flowQualifiedTypeIdentifier.assert(node);

    generator.print(node.qualification, node);
    generator.token('.');
    generator.print(node.id, node);
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowThisTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowThisTypeAnnotation_ts$default(generator) {
    generator.word('this');
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowTupleTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowTupleTypeAnnotation_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowTupleTypeAnnotation_ts$flowTupleTypeAnnotation.assert(node);

    generator.token('[');
    generator.printCommaList(node.types, node);
    generator.token(']');
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowTypeCastExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowTypeCastExpression_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowTypeCastExpression_ts$flowTypeCastExpression.assert(node);

    if (generator.options.typeAnnotations) {
      generator.token('(');
      generator.print(node.expression, node);
      generator.printTypeColon(node.typeAnnotation, node);
      generator.token(')');
    } else {
      generator.print(node.expression, node);
    }
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowTypeofTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowTypeofTypeAnnotation_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowTypeofTypeAnnotation_ts$flowTypeofTypeAnnotation.assert(node);

    generator.word('typeof');
    generator.space();
    generator.print(node.argument, node);
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowTypeParameter.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowTypeParameter_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowTypeParameter_ts$flowTypeParameter.assert(node);

    generator.print(node.variance, node);
    generator.word(node.name);

    if (node.bound) {
      generator.print(node.bound, node);
    }

    if (node.default) {
      generator.space();
      generator.token('=');
      generator.space();
      generator.print(node.default, node);
    }
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowTypeParameterInstantiation.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowTypeParameterInstantiation_ts$default(
    generator,
    node,
  ) {
    node =
      node.type === 'FlowTypeParameterDeclaration'
        ? node : ___R$project$rome$$romejs$js$ast$flow$FlowTypeParameterInstantiation_ts$flowTypeParameterInstantiation.assert(node);

    generator.token('<');
    generator.printCommaList(node.params, node);
    generator.token('>');
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowTypeParameterDeclaration.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowTypeParameterDeclaration_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowTypeParameterDeclaration_ts$flowTypeParameterDeclaration.assert(node);

    ___R$project$rome$$romejs$js$generator$generators$flow$FlowTypeParameterInstantiation_ts$default(generator, node);
  }

  // project-rome/@romejs/js-generator/generators/flow/FlowVariance.ts
function ___R$project$rome$$romejs$js$generator$generators$flow$FlowVariance_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowVariance_ts$flowVariance.assert(node);
    ___R$project$rome$$romejs$js$ast$flow$FlowVariance_ts$flowVariance.assert(node);
    if (node.kind === 'plus') {
      generator.token('+');
    } else if (node.kind === 'minus') {
      generator.token('-');
    }
  }

  // project-rome/@romejs/js-generator/generators/statements/ForInStatement.ts
const ___R$project$rome$$romejs$js$generator$generators$statements$ForInStatement_ts$default = ___R$project$rome$$romejs$js$generator$generators$utils_ts$buildForXStatementGenerator('in');

  // project-rome/@romejs/js-generator/generators/statements/ForOfStatement.ts
const ___R$project$rome$$romejs$js$generator$generators$statements$ForOfStatement_ts$default = ___R$project$rome$$romejs$js$generator$generators$utils_ts$buildForXStatementGenerator('of');

  // project-rome/@romejs/js-generator/generators/statements/ForStatement.ts
function ___R$project$rome$$romejs$js$generator$generators$statements$ForStatement_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$statements$ForStatement_ts$forStatement.assert(node);
    ___R$project$rome$$romejs$js$ast$statements$ForStatement_ts$forStatement.assert(node);
    generator.word('for');
    generator.space();
    generator.token('(');

    generator.multiline(
      node,
      (multiline, node) => {
        generator.inForStatementInitCounter++;
        generator.print(node.init, node);
        generator.inForStatementInitCounter--;
        generator.token(';');

        if (node.test) {
          generator.spaceOrNewline(multiline);
          generator.print(node.test, node);
        }
        generator.token(';');

        if (node.update) {
          generator.spaceOrNewline(multiline);
          generator.print(node.update, node);
        }
      },
      {
        conditions: ['more-than-one-line'],
        indent: true,
        indentTrailingNewline: true,
      },
    );

    generator.token(')');
    generator.printBlock(node);
  }

  // project-rome/@romejs/js-generator/generators/expressions/FunctionExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$expressions$FunctionExpression_ts$default(generator, node) {
    node =
      node.type === 'FunctionDeclaration'
        ? node : ___R$project$rome$$romejs$js$ast$expressions$FunctionExpression_ts$functionExpression.assert(
          node,
        );

    if (node.head.async === true) {
      generator.word('async');
      generator.space();
    }

    generator.word('function');

    if (node.head.generator === true) {
      generator.token('*');
    }

    if (node.id) {
      generator.space();
      generator.print(node.id, node);
    }

    generator.print(node.head, node);
    generator.space();
    generator.print(node.body, node);
  }

  // project-rome/@romejs/js-generator/generators/statements/FunctionDeclaration.ts
function ___R$project$rome$$romejs$js$generator$generators$statements$FunctionDeclaration_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$statements$FunctionDeclaration_ts$functionDeclaration.assert(node);

    ___R$project$rome$$romejs$js$generator$generators$expressions$FunctionExpression_ts$default(generator, node);
  }

  // project-rome/@romejs/js-generator/generators/auxiliary/FunctionHead.ts
function ___R$project$rome$$romejs$js$generator$generators$auxiliary$FunctionHead_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$auxiliary$FunctionHead_ts$functionHead.assert(node);

    generator.multiline(
      node,
      (multiline, node) => {
        const {typeAnnotations} = generator.options;

        generator.print(node.typeParameters, node);
        generator.token('(');

        ___R$project$rome$$romejs$js$generator$generators$utils_ts$printBindingPatternParams(generator, node, node.params, node.rest, multiline);

        generator.token(')');

        if (typeAnnotations) {
          if (node.returnType) {
            generator.printTypeColon(node.returnType, node);
          }

          if (node.predicate) {
            if (!node.returnType) {
              generator.token(':');
            }
            generator.space();
            generator.print(node.predicate, node);
          }
        }
      },
      {conditions: ['any-line-exceeds', 'more-than-one-line']},
    );
  }

  // project-rome/@romejs/js-generator/generators/statements/IfStatement.ts
function ___R$project$rome$$romejs$js$generator$generators$statements$IfStatement_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$statements$IfStatement_ts$ifStatement.assert(node);
    ___R$project$rome$$romejs$js$ast$statements$IfStatement_ts$ifStatement.assert(node);
    generator.word('if');
    generator.space();
    generator.token('(');
    generator.multiline(
      node.test,
      (multiline, test) => {
        generator.print(test, node);
      },
      {indent: true, indentTrailingNewline: true},
    );
    generator.token(')');
    generator.space();

    let needsBlock = false;
    if (node.alternate !== undefined) {
      needsBlock = ___R$$priv$project$rome$$romejs$js$generator$generators$statements$IfStatement_ts$getLastStatement(node.consequent).type === 'IfStatement';
    }
    if (needsBlock) {
      generator.token('{');
      generator.forceNewline();
      generator.indent();
    }

    generator.print(node.consequent, node);

    if (needsBlock) {
      generator.dedent();
      generator.forceNewline();
      generator.token('}');
    }

    if (node.alternate) {
      if (generator.buf.endsWith('}')) {
        generator.space();
      }
      generator.word('else');
      generator.space();
      generator.print(node.alternate, node);
    }

    generator.forceNewline();
  }

  // Recursively get the last statement.
  function ___R$$priv$project$rome$$romejs$js$generator$generators$statements$IfStatement_ts$getLastStatement(statement) {
    if ((statement.type === 'WithStatement' || statement.type === 'WhileStatement' ||
    statement.type === 'DoWhileStatement' ||
    statement.type === 'ForOfStatement' ||
    statement.type === 'ForInStatement' ||
    statement.type === 'ForStatement') &&
      ___R$project$rome$$romejs$js$ast$utils$isStatement_ts$default(statement.body)) {
      return ___R$$priv$project$rome$$romejs$js$generator$generators$statements$IfStatement_ts$getLastStatement(statement.body);
    } else {
      return statement;
    }
  }

  // project-rome/@romejs/js-generator/generators/modules/ImportCall.ts
function ___R$project$rome$$romejs$js$generator$generators$modules$ImportCall_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$modules$ImportCall_ts$importCall.assert(node);
    ___R$project$rome$$romejs$js$ast$modules$ImportCall_ts$importCall.assert(node);
    generator.word('import');
    generator.token('(');
    generator.print(node.argument, node);
    generator.token(')');
  }

  // project-rome/@romejs/js-generator/generators/modules/ImportDeclaration.ts
function ___R$project$rome$$romejs$js$generator$generators$modules$ImportDeclaration_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$modules$ImportDeclaration_ts$importDeclaration.assert(node);

    generator.word('import');
    generator.space();

    if (node.importKind === 'type' || node.importKind === 'typeof') {
      generator.word(node.importKind);
      generator.space();
    }

    generator.multiline(
      node,
      (multiline, node) => {
        let {specifiers} = node;
        if (specifiers !== undefined && specifiers.length > 0) {
          specifiers = [...specifiers];

          // Print "special" specifiers first
          while (specifiers.length > 0) {
            const first = specifiers[0];
            if (first.type === 'ImportDefaultSpecifier' ||
            first.type ===
            'ImportNamespaceSpecifier') {
              generator.print(specifiers.shift(), node);
              if (specifiers.length) {
                generator.token(',');
                generator.space();
              }
            } else {
              break;
            }
          }

          if (specifiers.length > 0) {
            generator.token('{');
            generator.printCommaList(
              specifiers,
              node,
              {
                multiline,
                trailing: true,
              },
            );
            generator.token('}');
          }

          generator.space();
          generator.word('from');
          generator.space();
        }

        generator.print(node.source, node);
        generator.semicolon();
      },
      {conditions: ['more-than-one-line']},
    );
  }

  // project-rome/@romejs/js-generator/generators/modules/ImportDefaultSpecifier.ts
function ___R$project$rome$$romejs$js$generator$generators$modules$ImportDefaultSpecifier_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$modules$ImportDefaultSpecifier_ts$importDefaultSpecifier.assert(node);

    generator.print(node.local.name, node);
  }

  // project-rome/@romejs/js-generator/generators/modules/ImportNamespaceSpecifier.ts
function ___R$project$rome$$romejs$js$generator$generators$modules$ImportNamespaceSpecifier_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$modules$ImportNamespaceSpecifier_ts$importNamespaceSpecifier.assert(node);

    generator.token('*');
    generator.space();
    generator.word('as');
    generator.space();
    generator.print(node.local.name, node);
  }

  // project-rome/@romejs/js-generator/generators/modules/ImportSpecifier.ts
function ___R$project$rome$$romejs$js$generator$generators$modules$ImportSpecifier_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$modules$ImportSpecifier_ts$importSpecifier.assert(node);

    if (node.local.importKind === 'type' || node.local.importKind === 'typeof') {
      generator.word(node.local.importKind);
      generator.space();
    }

    generator.print(node.imported, node);

    if (node.local.name.name !== node.imported.name) {
      generator.space();
      generator.word('as');
      generator.space();
      generator.print(node.local.name, node);
    }
  }

  // project-rome/@romejs/js-generator/generators/modules/ImportSpecifierLocal.ts
function ___R$project$rome$$romejs$js$generator$generators$modules$ImportSpecifierLocal_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$modules$ImportSpecifierLocal_ts$importSpecifierLocal.assert(node);

    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-generator/generators/core/InterpreterDirective.ts
function ___R$project$rome$$romejs$js$generator$generators$core$InterpreterDirective_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$core$InterpreterDirective_ts$interpreterDirective.assert(node);

    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-generator/generators/types/IntersectionTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$types$IntersectionTypeAnnotation_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$types$IntersectionTypeAnnotation_ts$intersectionTypeAnnotation.assert(node);

    generator.multiline(
      node,
      (multiline, node) => {
        if (multiline) {
          ___R$$priv$project$rome$$romejs$js$generator$generators$types$IntersectionTypeAnnotation_ts$andNewlineSeparator(generator, false);
        }

        generator.printJoin(
          node.types,
          node,
          {
            after: multiline ? ___R$$priv$project$rome$$romejs$js$generator$generators$types$IntersectionTypeAnnotation_ts$andNewlineSeparator : ___R$$priv$project$rome$$romejs$js$generator$generators$types$IntersectionTypeAnnotation_ts$andSpaceSeparator,
          },
        );
      },
      {conditions: ['more-than-one-line'], indent: true},
    );
  }

  function ___R$$priv$project$rome$$romejs$js$generator$generators$types$IntersectionTypeAnnotation_ts$andNewlineSeparator(generator, isLast) {
    if (isLast) {
      return;
    }

    generator.newline();
    generator.token('&');
    generator.space();
  }

  function ___R$$priv$project$rome$$romejs$js$generator$generators$types$IntersectionTypeAnnotation_ts$andSpaceSeparator(generator, isLast) {
    if (isLast) {
      return;
    }

    generator.space();
    generator.token('&');
    generator.space();
  }

  // project-rome/@romejs/js-generator/generators/jsx/JSXAttribute.ts
function ___R$project$rome$$romejs$js$generator$generators$jsx$JSXAttribute_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$jsx$JSXAttribute_ts$jsxAttribute.assert(node);
    ___R$project$rome$$romejs$js$ast$jsx$JSXAttribute_ts$jsxAttribute.assert(node);
    generator.print(node.name, node);
    if (node.value) {
      generator.token('=');
      generator.print(node.value, node);
    }
  }

  // project-rome/@romejs/js-generator/generators/jsx/JSXElement.ts
function ___R$project$rome$$romejs$js$generator$generators$jsx$JSXElement_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$jsx$JSXElement_ts$jsxElement.assert(node);
    ___R$project$rome$$romejs$js$ast$jsx$JSXElement_ts$jsxElement.assert(node);
    generator.token('<');
    generator.print(node.name, node);
    generator.print(node.typeArguments, node);

    if (node.attributes.length > 0) {
      generator.space();
      generator.printJoin(
        node.attributes,
        node,
        {
          after: ___R$$priv$project$rome$$romejs$js$generator$generators$jsx$JSXElement_ts$spaceSeparator,
        },
      );
    }

    if (node.selfClosing === true) {
      generator.space();
      generator.token('/>');
      return;
    } else {
      generator.token('>');
    }

    generator.indent();
    for (const child of node.children) {
      generator.print(child, node);
    }
    generator.dedent();

    generator.token('</');
    generator.print(node.name, node);
    generator.token('>');
  }

  function ___R$$priv$project$rome$$romejs$js$generator$generators$jsx$JSXElement_ts$spaceSeparator(generator, isLast) {
    if (isLast) {
      return;
    }

    generator.space();
  }

  // project-rome/@romejs/js-generator/generators/jsx/JSXEmptyExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$jsx$JSXEmptyExpression_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$jsx$JSXEmptyExpression_ts$jsxEmptyExpression.assert(node);

    generator.printInnerComments(node);
  }

  // project-rome/@romejs/js-generator/generators/jsx/JSXExpressionContainer.ts
function ___R$project$rome$$romejs$js$generator$generators$jsx$JSXExpressionContainer_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$jsx$JSXExpressionContainer_ts$jsxExpressionContainer.assert(node);

    generator.token('{');
    generator.print(node.expression, node);
    generator.token('}');
  }

  // project-rome/@romejs/js-generator/generators/jsx/JSXFragment.ts
function ___R$project$rome$$romejs$js$generator$generators$jsx$JSXFragment_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$jsx$JSXFragment_ts$jsxFragment.assert(node);
    ___R$project$rome$$romejs$js$ast$jsx$JSXFragment_ts$jsxFragment.assert(node);
    generator.token('<>');
    generator.indent();

    for (const child of node.children) {
      generator.print(child, node);
    }

    generator.dedent();
    generator.token('</>');
  }

  // project-rome/@romejs/js-generator/generators/jsx/JSXIdentifier.ts
function ___R$project$rome$$romejs$js$generator$generators$jsx$JSXIdentifier_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$jsx$JSXIdentifier_ts$jsxIdentifier.assert(node);

    generator.word(node.name);
  }

  // project-rome/@romejs/js-generator/generators/jsx/JSXMemberExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$jsx$JSXMemberExpression_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$jsx$JSXMemberExpression_ts$jsxMemberExpression.assert(node);

    generator.print(node.object, node);
    generator.token('.');
    generator.print(node.property, node);
  }

  // project-rome/@romejs/js-generator/generators/jsx/JSXNamespacedName.ts
function ___R$project$rome$$romejs$js$generator$generators$jsx$JSXNamespacedName_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$jsx$JSXNamespacedName_ts$jsxNamespacedName.assert(node);

    generator.print(node.namespace, node);
    generator.token(':');
    generator.print(node.name, node);
  }

  // project-rome/@romejs/js-generator/generators/jsx/JSXReferenceIdentifier.ts
function ___R$project$rome$$romejs$js$generator$generators$jsx$JSXReferenceIdentifier_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$jsx$JSXReferenceIdentifier_ts$jsxReferenceIdentifier.assert(node);

    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-generator/generators/jsx/JSXSpreadAttribute.ts
function ___R$project$rome$$romejs$js$generator$generators$jsx$JSXSpreadAttribute_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$jsx$JSXSpreadAttribute_ts$jsxSpreadAttribute.assert(node);

    generator.token('{');
    generator.token('...');
    generator.print(node.argument, node);
    generator.token('}');
  }

  // project-rome/@romejs/js-generator/generators/jsx/JSXSpreadChild.ts
function ___R$project$rome$$romejs$js$generator$generators$jsx$JSXSpreadChild_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$jsx$JSXSpreadChild_ts$jsxSpreadChild.assert(node);

    generator.token('{');
    generator.token('...');
    generator.print(node.expression, node);
    generator.token('}');
  }

  // project-rome/@romejs/js-generator/generators/jsx/JSXText.ts
function ___R$project$rome$$romejs$js$generator$generators$jsx$JSXText_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$jsx$JSXText_ts$jsxText.assert(node);
    ___R$project$rome$$romejs$js$ast$jsx$JSXText_ts$jsxText.assert(node);
    generator.token(___R$project$rome$$romejs$js$parser$xhtmlEntities_ts$escapeXHTMLEntities(node.value));
  }

  // project-rome/@romejs/js-generator/generators/statements/LabeledStatement.ts
function ___R$project$rome$$romejs$js$generator$generators$statements$LabeledStatement_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$statements$LabeledStatement_ts$labeledStatement.assert(node);

    generator.print(node.label, node);
    generator.token(':');
    generator.space();
    generator.print(node.body, node);
  }

  // project-rome/@romejs/js-generator/generators/expressions/LogicalExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$expressions$LogicalExpression_ts$default(
    generator,
    node,
    parent,
  ) {
    node = ___R$project$rome$$romejs$js$ast$expressions$LogicalExpression_ts$logicalExpression.assert(node);

    ___R$project$rome$$romejs$js$generator$generators$expressions$AssignmentExpression_ts$default(generator, node, parent);
  }

  // project-rome/@romejs/js-generator/generators/expressions/MemberExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$expressions$MemberExpression_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$expressions$MemberExpression_ts$memberExpression.assert(node);

    generator.print(node.object, node);
    generator.print(node.property, node);
  }

  // project-rome/@romejs/js-generator/generators/expressions/MetaProperty.ts
function ___R$project$rome$$romejs$js$generator$generators$expressions$MetaProperty_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$expressions$MetaProperty_ts$metaProperty.assert(node);
    ___R$project$rome$$romejs$js$ast$expressions$MetaProperty_ts$metaProperty.assert(node);
    generator.print(node.meta, node);
    generator.token('.');
    generator.print(node.property, node);
  }

  // project-rome/@romejs/js-generator/generators/types/MixedKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$types$MixedKeywordTypeAnnotation_ts$default(generator) {
    generator.word('mixed');
  }

  // project-rome/@romejs/js-generator/generators/temp/MockParent.ts
function ___R$project$rome$$romejs$js$generator$generators$temp$MockParent_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$temp$MockParent_ts$mockParent.assert(node);
    ___R$project$rome$$romejs$js$ast$temp$MockParent_ts$mockParent.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-generator/generators/types/NeverKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$types$NeverKeywordTypeAnnotation_ts$default(generator) {
    generator.word('never');
  }

  // project-rome/@romejs/js-generator/generators/expressions/NewExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$expressions$NewExpression_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$expressions$NewExpression_ts$newExpression.assert(node);

    generator.word('new');
    ___R$project$rome$$romejs$js$generator$generators$expressions$CallExpression_ts$default(generator, node);
  }

  // project-rome/@romejs/js-generator/generators/types/NullKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$types$NullKeywordTypeAnnotation_ts$default(generator) {
    generator.word('null');
  }

  // project-rome/@romejs/js-generator/generators/literals/NullLiteral.ts
function ___R$project$rome$$romejs$js$generator$generators$literals$NullLiteral_ts$default(generator) {
    generator.word('null');
  }

  // project-rome/@romejs/js-generator/generators/types/NumberKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$types$NumberKeywordTypeAnnotation_ts$default(generator) {
    generator.word('number');
  }

  // project-rome/@romejs/js-generator/generators/literals/NumericLiteral.ts
function ___R$project$rome$$romejs$js$generator$generators$literals$NumericLiteral_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$literals$NumericLiteral_ts$numericLiteral.assert(node);

    if (generator.options.format === 'pretty') {
      generator.number(___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(node.value));
    } else {
      generator.number(String(node.value));
    }
  }

  // project-rome/@romejs/js-generator/generators/types/NumericLiteralTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$types$NumericLiteralTypeAnnotation_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$types$NumericLiteralTypeAnnotation_ts$numericLiteralTypeAnnotation.assert(node);
    generator.number(String(node.value));
  }

  // project-rome/@romejs/js-generator/generators/types/ObjectKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$types$ObjectKeywordTypeAnnotation_ts$default(generator) {
    generator.word('object');
  }

  // project-rome/@romejs/js-generator/generators/objects/ObjectMethod.ts
function ___R$project$rome$$romejs$js$generator$generators$objects$ObjectMethod_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$objects$ObjectMethod_ts$objectMethod.assert(node);
    ___R$project$rome$$romejs$js$generator$generators$utils_ts$printMethod(generator, node);
  }

  // project-rome/@romejs/js-generator/generators/expressions/OptionalCallExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$expressions$OptionalCallExpression_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$expressions$OptionalCallExpression_ts$optionalCallExpression.assert(node);
    ___R$project$rome$$romejs$js$generator$generators$expressions$CallExpression_ts$default(generator, node);
  }

  // project-rome/@romejs/js-generator/generators/patterns/PatternMeta.ts
function ___R$project$rome$$romejs$js$generator$generators$patterns$PatternMeta_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$patterns$PatternMeta_ts$patternMeta.assert(node);
    ___R$project$rome$$romejs$js$ast$patterns$PatternMeta_ts$patternMeta.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-generator/generators/classes/PrivateName.ts
function ___R$project$rome$$romejs$js$generator$generators$classes$PrivateName_ts$default() {
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-generator/generators/core/Program.ts
function ___R$project$rome$$romejs$js$generator$generators$core$Program_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$core$Program_ts$program.assert(node);

    generator.printInnerComments(node, false);
    generator.printStatementList(node.directives, node);

    if (node.directives && node.directives.length) {
      generator.forceNewline();
    }

    generator.printStatementList(node.body, node);
  }

  // project-rome/@romejs/js-generator/generators/expressions/ReferenceIdentifier.ts
function ___R$project$rome$$romejs$js$generator$generators$expressions$ReferenceIdentifier_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.assert(node);
    ___R$project$rome$$romejs$js$generator$generators$auxiliary$Identifier_ts$default(generator, node);
  }

  // project-rome/@romejs/js-generator/generators/regex/RegExpAlternation.ts
function ___R$project$rome$$romejs$js$generator$generators$regex$RegExpAlternation_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpAlternation_ts$regExpAlternation.assert(node);
    generator.print(node.left, node);
    generator.token('|');
    generator.print(node.right, node);
  }

  // project-rome/@romejs/js-generator/generators/regex/RegExpAnyCharacter.ts
function ___R$project$rome$$romejs$js$generator$generators$regex$RegExpAnyCharacter_ts$default(generator) {
    generator.append('.');
  }

  // project-rome/@romejs/js-generator/generators/regex/RegExpCharacter.ts
function ___R$project$rome$$romejs$js$generator$generators$regex$RegExpCharacter_ts$default(
    generator,
    node,
    parent,
  ) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpCharacter_ts$regExpCharacter.assert(node);

    const isInCharSet = parent.type === 'RegExpCharSet';
    if (isInCharSet) {
      switch (node.value) {
        case '$':
        case '^':
        case '.':
        case '?':
        case '{':
        case '}':
        case '+':
        case '*':
        case '[':
        case ']':
        case '(':
        case ')':
        case '|':
          generator.append(node.value);
          return;

        case '-':
          generator.append('\\-');
          return;
      }
    }

    switch (node.value) {
      case '\t':
        generator.append('\\t');
        break;

      case '\n':
        generator.append('\\n');
        break;

      case '\r':
        generator.append('\\r');
        break;

      case '\x0b':
        generator.append('\\v');
        break;

      case '\f':
        generator.append('\\f');
        break;

      case '\b':
        generator.append('\\b');
        break;

      case '/':
      case '\\':
      case '$':
      case '^':
      case '.':
      case '?':
      case '{':
      case '}':
      case '+':
      case '*':
      case '[':
      case ']':
      case '(':
      case ')':
      case '|':
        generator.append('\\' +
        node.value);
        break;

      default:
        generator.append(
          ___R$project$rome$$romejs$string$escape$escapeString_ts$default(
            node.value,
            {
              json: true,
              unicodeOnly: true,
            },
          ),
        );
    }
  }

  // project-rome/@romejs/js-generator/generators/regex/RegExpCharSet.ts
function ___R$project$rome$$romejs$js$generator$generators$regex$RegExpCharSet_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpCharSet_ts$regExpCharSet.assert(node);
    generator.append('[');
    if (node.invert) {
      generator.append('^');
    }
    for (const item of node.body) {
      generator.print(item, node);
    }
    generator.append(']');
  }

  // project-rome/@romejs/js-generator/generators/regex/RegExpCharSetRange.ts
function ___R$project$rome$$romejs$js$generator$generators$regex$RegExpCharSetRange_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpCharSetRange_ts$regExpCharSetRange.assert(node);
    generator.print(node.start, node);
    generator.append('-');
    generator.print(node.end, node);
  }

  // project-rome/@romejs/js-generator/generators/regex/RegExpControlCharacter.ts
function ___R$project$rome$$romejs$js$generator$generators$regex$RegExpControlCharacter_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpControlCharacter_ts$regExpControlCharacter.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-generator/generators/regex/RegExpDigitCharacter.ts
function ___R$project$rome$$romejs$js$generator$generators$regex$RegExpDigitCharacter_ts$default(generator) {
    generator.append('\\d');
  }

  // project-rome/@romejs/js-generator/generators/regex/RegExpEndCharacter.ts
function ___R$project$rome$$romejs$js$generator$generators$regex$RegExpEndCharacter_ts$default(generator) {
    generator.append('$');
  }

  // project-rome/@romejs/js-generator/generators/regex/RegExpGroupCapture.ts
function ___R$project$rome$$romejs$js$generator$generators$regex$RegExpGroupCapture_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpGroupCapture_ts$regExpGroupCapture.assert(node);

    generator.append('(');
    if (node.name !== undefined) {
      generator.append('?<');
      generator.append(node.name);
      generator.append('>');
    }
    generator.print(node.expression, node);
    generator.append(')');
  }

  // project-rome/@romejs/js-generator/generators/regex/RegExpGroupNonCapture.ts
function ___R$project$rome$$romejs$js$generator$generators$regex$RegExpGroupNonCapture_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpGroupNonCapture_ts$regExpGroupNonCapture.assert(node);

    generator.append('(?');

    switch (node.kind) {
      case 'positive-lookahead':
        generator.append('=');
        break;

      case 'negative-lookahead':
        generator.append('!');
        break;

      case 'positive-lookbehind':
        generator.append('<!');
        break;

      case 'negative-lookbehind':
        generator.append('<=');
        break;

      default:
        generator.append(':');
    }

    generator.print(node.expression, node);
    generator.append(')');
  }

  // project-rome/@romejs/js-generator/generators/literals/RegExpLiteral.ts
function ___R$project$rome$$romejs$js$generator$generators$literals$RegExpLiteral_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$literals$RegExpLiteral_ts$regExpLiteral.assert(node);

    const flags = [];

    if (node.global === true) {
      flags.push('g');
    }

    if (node.multiline === true) {
      flags.push('m');
    }

    if (node.sticky === true) {
      flags.push('y');
    }

    if (node.insensitive === true) {
      flags.push('i');
    }

    if (node.noDotNewline === true) {
      flags.push('s');
    }

    if (node.unicode === true) {
      flags.push('u');
    }

    generator.token('/');
    generator.print(node.expression, node);
    generator.token('/' +
    flags.join(''));
  }

  // project-rome/@romejs/js-generator/generators/regex/RegExpNonDigitCharacter.ts
function ___R$project$rome$$romejs$js$generator$generators$regex$RegExpNonDigitCharacter_ts$default(generator) {
    generator.append('\\D');
  }

  // project-rome/@romejs/js-generator/generators/regex/RegExpNonWhiteSpaceCharacter.ts
function ___R$project$rome$$romejs$js$generator$generators$regex$RegExpNonWhiteSpaceCharacter_ts$default(generator) {
    generator.append('\\S');
  }

  // project-rome/@romejs/js-generator/generators/regex/RegExpNonWordBoundaryCharacter.ts
function ___R$project$rome$$romejs$js$generator$generators$regex$RegExpNonWordBoundaryCharacter_ts$default(generator) {
    generator.append('\\B');
  }

  // project-rome/@romejs/js-generator/generators/regex/RegExpNonWordCharacter.ts
function ___R$project$rome$$romejs$js$generator$generators$regex$RegExpNonWordCharacter_ts$default(generator) {
    generator.append('\\W');
  }

  // project-rome/@romejs/js-generator/generators/regex/RegExpQuantified.ts
function ___R$project$rome$$romejs$js$generator$generators$regex$RegExpQuantified_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpQuantified_ts$regExpQuantified.assert(node);
    generator.print(node.target, node);

    if (node.min === 0 && node.max === 1) {
      generator.append('?');
    } else if (node.min === 0 && node.max === undefined) {
      generator.append('*');
    } else if (node.min === 1 && node.max === undefined) {
      generator.append('+');
    } else {
      generator.append('{');

      generator.append(String(node.min));

      if (node.min !== node.max) {
        generator.token(',');
        if (node.max !== undefined) {
          generator.append(String(node.max));
        }
      }

      generator.append('}');
    }

    if (node.lazy) {
      generator.append('?');
    }
  }

  // project-rome/@romejs/js-generator/generators/regex/RegExpStartCharacter.ts
function ___R$project$rome$$romejs$js$generator$generators$regex$RegExpStartCharacter_ts$default(generator) {
    generator.append('^');
  }

  // project-rome/@romejs/js-generator/generators/regex/RegExpSubExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$regex$RegExpSubExpression_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpSubExpression_ts$regExpSubExpression.assert(node);

    for (const item of node.body) {
      generator.print(item, node);
    }
  }

  // project-rome/@romejs/js-generator/generators/regex/RegExpWhiteSpaceCharacter.ts
function ___R$project$rome$$romejs$js$generator$generators$regex$RegExpWhiteSpaceCharacter_ts$default(generator) {
    generator.append('\\s');
  }

  // project-rome/@romejs/js-generator/generators/regex/RegExpWordBoundaryCharacter.ts
function ___R$project$rome$$romejs$js$generator$generators$regex$RegExpWordBoundaryCharacter_ts$default(generator) {
    generator.append('\\b');
  }

  // project-rome/@romejs/js-generator/generators/regex/RegExpWordCharacter.ts
function ___R$project$rome$$romejs$js$generator$generators$regex$RegExpWordCharacter_ts$default(generator) {
    generator.append('\\w');
  }

  // project-rome/@romejs/js-generator/generators/statements/ReturnStatement.ts
const ___R$project$rome$$romejs$js$generator$generators$statements$ReturnStatement_ts$default = ___R$project$rome$$romejs$js$generator$generators$utils_ts$buildLabelStatementGenerator('return');

  // project-rome/@romejs/js-generator/generators/expressions/SequenceExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$expressions$SequenceExpression_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$expressions$SequenceExpression_ts$sequenceExpression.assert(node);

    generator.printCommaList(node.expressions, node);
  }

  // project-rome/@romejs/js-generator/generators/auxiliary/SpreadElement.ts
function ___R$project$rome$$romejs$js$generator$generators$auxiliary$SpreadElement_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$auxiliary$SpreadElement_ts$spreadElement.assert(node);

    generator.token('...');
    generator.print(node.argument, node);
  }

  // project-rome/@romejs/js-generator/generators/objects/SpreadProperty.ts
function ___R$project$rome$$romejs$js$generator$generators$objects$SpreadProperty_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$objects$SpreadProperty_ts$spreadProperty.assert(node);

    generator.token('...');
    generator.print(node.argument, node);
  }

  // project-rome/@romejs/js-generator/generators/auxiliary/StaticMemberProperty.ts
function ___R$project$rome$$romejs$js$generator$generators$auxiliary$StaticMemberProperty_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$auxiliary$StaticMemberProperty_ts$staticMemberProperty.assert(node);

    generator.token('.');
    generator.print(node.value, node);
  }

  // project-rome/@romejs/js-generator/generators/objects/StaticPropertyKey.ts
function ___R$project$rome$$romejs$js$generator$generators$objects$StaticPropertyKey_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$objects$StaticPropertyKey_ts$staticPropertyKey.assert(node);

    generator.print(node.value, node);
  }

  // project-rome/@romejs/js-generator/generators/types/StringKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$types$StringKeywordTypeAnnotation_ts$default(generator) {
    generator.word('string');
  }

  // project-rome/@romejs/js-generator/generators/types/StringLiteralTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$types$StringLiteralTypeAnnotation_ts$default(
    generator,
    node,
    parent,
  ) {
    node = ___R$project$rome$$romejs$js$ast$types$StringLiteralTypeAnnotation_ts$stringLiteralTypeAnnotation.assert(node);
    ___R$project$rome$$romejs$js$generator$generators$literals$StringLiteral_ts$default(generator, node, parent);
  }

  // project-rome/@romejs/js-generator/generators/expressions/Super.ts
function ___R$project$rome$$romejs$js$generator$generators$expressions$Super_ts$default(generator) {
    generator.word('super');
  }

  // project-rome/@romejs/js-generator/generators/auxiliary/SwitchCase.ts
function ___R$project$rome$$romejs$js$generator$generators$auxiliary$SwitchCase_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$auxiliary$SwitchCase_ts$switchCase.assert(node);

    if (node.test) {
      generator.word('case');
      generator.space();
      generator.print(node.test, node);
      generator.token(':');
    } else {
      generator.word('default');
      generator.token(':');
    }

    generator.forceNewline();

    if (node.consequent.length) {
      generator.printStatementList(node.consequent, node, {indent: true});
    }
  }

  // project-rome/@romejs/js-generator/generators/statements/SwitchStatement.ts
function ___R$project$rome$$romejs$js$generator$generators$statements$SwitchStatement_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$statements$SwitchStatement_ts$switchStatement.assert(node);

    generator.word('switch');
    generator.space();
    generator.token('(');
    generator.print(node.discriminant, node);
    generator.token(')');
    generator.space();
    generator.token('{');

    generator.printStatementList(
      node.cases,
      node,
      {
        indent: true,
      },
    );

    generator.token('}');
  }

  // project-rome/@romejs/js-generator/generators/types/SymbolKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$types$SymbolKeywordTypeAnnotation_ts$default(generator) {
    generator.word('symbol');
  }

  // project-rome/@romejs/js-generator/generators/expressions/TaggedTemplateExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$expressions$TaggedTemplateExpression_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$expressions$TaggedTemplateExpression_ts$taggedTemplateExpression.assert(node);

    generator.print(node.tag, node);
    generator.print(node.quasi, node);
  }

  // project-rome/@romejs/js-generator/generators/auxiliary/TemplateElement.ts
function ___R$project$rome$$romejs$js$generator$generators$auxiliary$TemplateElement_ts$default(
    generator,
    node,
    parent,
  ) {
    node = ___R$project$rome$$romejs$js$ast$auxiliary$TemplateElement_ts$templateElement.assert(node);
    parent = ___R$project$rome$$romejs$js$ast$literals$TemplateLiteral_ts$templateLiteral.assert(parent);

    const isFirst = parent.quasis[0] === node;
    const isLast = parent.quasis[parent.quasis.length - 1] === node;

    const value = (isFirst ? '`' : '}') + node.raw + (isLast ? '`' : '${');

    generator.token(value);
  }

  // project-rome/@romejs/js-generator/generators/literals/TemplateLiteral.ts
function ___R$project$rome$$romejs$js$generator$generators$literals$TemplateLiteral_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$literals$TemplateLiteral_ts$templateLiteral.assert(node);

    const quasis = node.quasis;

    for (let i = 0;
    i < quasis.length;
    i++) {
      generator.print(quasis[i], node);

      if (i + 1 < quasis.length) {
        generator.print(node.expressions[i], node);
      }
    }
  }

  // project-rome/@romejs/js-generator/generators/types/TemplateLiteralTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$types$TemplateLiteralTypeAnnotation_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$types$TemplateLiteralTypeAnnotation_ts$templateLiteralTypeAnnotation.assert(node);

    ___R$project$rome$$romejs$js$ast$types$TemplateLiteralTypeAnnotation_ts$templateLiteralTypeAnnotation.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-generator/generators/expressions/ThisExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$expressions$ThisExpression_ts$default(generator) {
    generator.word('this');
  }

  // project-rome/@romejs/js-generator/generators/statements/ThrowStatement.ts
const ___R$project$rome$$romejs$js$generator$generators$statements$ThrowStatement_ts$default = ___R$project$rome$$romejs$js$generator$generators$utils_ts$buildLabelStatementGenerator('throw');

  // project-rome/@romejs/js-generator/generators/statements/TryStatement.ts
function ___R$project$rome$$romejs$js$generator$generators$statements$TryStatement_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$statements$TryStatement_ts$tryStatement.assert(node);
    ___R$project$rome$$romejs$js$ast$statements$TryStatement_ts$tryStatement.assert(node);
    generator.word('try');
    generator.space();
    generator.print(node.block, node);
    generator.space();
    generator.print(node.handler, node);

    if (node.finalizer) {
      generator.space();
      generator.word('finally');
      generator.space();
      generator.print(node.finalizer, node);
    }
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSArrayType.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSArrayType_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSArrayType_ts$tsArrayType.assert(node);
    generator.print(node.elementType, node);
    generator.token('[]');
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSAsExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSAsExpression_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSAsExpression_ts$tsAsExpression.assert(node);

    generator.print(node.expression, node);

    if (generator.options.typeAnnotations) {
      generator.space();
      generator.word('as');
      generator.print(node.typeAnnotation, node);
    }
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSAssignmentAsExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSAssignmentAsExpression_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentAsExpression_ts$tsAssignmentAsExpression.assert(node);

    generator.print(node.expression, node);

    if (generator.options.typeAnnotations) {
      generator.word('as');
      generator.print(node.typeAnnotation, node);
    }
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSAssignmentNonNullExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSAssignmentNonNullExpression_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentNonNullExpression_ts$tsAssignmentNonNullExpression.assert(node);
    generator.print(node.expression, node);
    generator.token('!');
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSAssignmentTypeAssertion.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSAssignmentTypeAssertion_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentTypeAssertion_ts$tsAssignmentTypeAssertion.assert(node);
    generator.token('<');
    generator.print(node.typeAnnotation, node);
    generator.token('>');
    generator.space();
    generator.print(node.expression, node);
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSCallSignatureDeclaration.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSCallSignatureDeclaration_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSCallSignatureDeclaration_ts$tsCallSignatureDeclaration.assert(node);

    generator.print(node.meta, node);

    if (node.typeAnnotation !== undefined) {
      generator.token(':');
      generator.space();
      generator.print(node.typeAnnotation, node);
    }

    generator.semicolon();
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSConditionalType.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSConditionalType_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSConditionalType_ts$tsConditionalType.assert(node);

    generator.multiline(
      node,
      (multiline, node) => {
        generator.print(node.checkType, node);
        generator.space();
        generator.word('extends');
        generator.space();
        generator.print(node.extendsType, node);

        if (multiline) {
          generator.newline();
          generator.indent();
        } else {
          generator.space();
        }

        generator.token('?');
        generator.space();
        generator.print(node.trueType, node);
        generator.spaceOrNewline(multiline);
        generator.token(':');
        generator.space();
        generator.print(node.falseType, node);

        if (multiline) {
          generator.dedent();
        }
      },
    );
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSConstructorType.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSConstructorType_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSConstructorType_ts$tsConstructorType.assert(node);

    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSConstructSignatureDeclaration.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSConstructSignatureDeclaration_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSConstructSignatureDeclaration_ts$tsConstructSignatureDeclaration.assert(node);

    generator.word('new');
    generator.space();
    generator.print(node.meta, node);

    if (node.typeAnnotation !== undefined) {
      generator.token(':');
      generator.space();
      generator.print(node.typeAnnotation, node);
    }

    generator.token(';');
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSDeclareFunction.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSDeclareFunction_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSDeclareFunction_ts$tsDeclareFunction.assert(node);

    if (node.declare) {
      generator.word('declare');
      generator.space();
    }

    generator.word('function');

    generator.print(node.id, node);
    generator.print(node.head, node);
    generator.token(';');
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSDeclareMethod.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSDeclareMethod_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSDeclareMethod_ts$tsDeclareMethod.assert(node);

    generator.print(node.meta, node);
    generator.print(node.key, node);
    ___R$project$rome$$romejs$js$generator$generators$utils_ts$printMethod(generator, node);
    generator.forceNewline();
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSEnumDeclaration.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSEnumDeclaration_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSEnumDeclaration_ts$tsEnumDeclaration.assert(node);

    if (node.declare) {
      generator.word('declare');
      generator.space();
    }

    if (node.const) {
      generator.word('const');
      generator.space();
    }

    generator.word('enum');
    generator.space();
    generator.print(node.id, node);
    generator.space();
    ___R$project$rome$$romejs$js$generator$generators$utils_ts$printTSBraced(generator, node, node.members);
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSEnumMember.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSEnumMember_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSEnumMember_ts$tsEnumMember.assert(node);

    generator.print(node.id, node);

    if (node.initializer) {
      generator.space();
      generator.token('=');
      generator.space();
      generator.print(node.initializer, node);
    }

    generator.token(',');
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSExportAssignment.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSExportAssignment_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSExportAssignment_ts$tsExportAssignment.assert(node);
    generator.word('export');
    generator.space();
    generator.token('=');
    generator.space();
    generator.print(node.expression, node);
    generator.token(';');
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSExpressionWithTypeArguments.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSExpressionWithTypeArguments_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSExpressionWithTypeArguments_ts$tsExpressionWithTypeArguments.assert(node);
    generator.print(node.expression, node);
    generator.print(node.typeParameters, node);
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSExternalModuleReference.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSExternalModuleReference_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSExternalModuleReference_ts$tsExternalModuleReference.assert(node);
    generator.token('require(');
    generator.print(node.expression, node);
    generator.token(')');
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSFunctionType.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSFunctionType_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSFunctionType_ts$tsFunctionType.assert(node);
    generator.print(node.meta, node);
    generator.token('=>');
    generator.space();
    generator.print(node.typeAnnotation, node);
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSImportEqualsDeclaration.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSImportEqualsDeclaration_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSImportEqualsDeclaration_ts$tsImportEqualsDeclaration.assert(node);

    if (node.isExport) {
      generator.word('export');
      generator.space();
    }

    generator.word('import');
    generator.space();
    generator.print(node.id, node);
    generator.space();
    generator.token('=');
    generator.space();
    generator.print(node.moduleReference, node);
    generator.token(';');
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSImportType.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSImportType_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSImportType_ts$tsImportType.assert(node);

    generator.word('import');
    generator.token('(');
    generator.print(node.argument, node);
    generator.token(')');

    if (node.qualifier) {
      generator.token('.');
      generator.print(node.qualifier, node);
    }

    if (node.typeParameters) {
      generator.print(node.typeParameters, node);
    }
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSIndexedAccessType.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSIndexedAccessType_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSIndexedAccessType_ts$tsIndexedAccessType.assert(node);
    generator.print(node.objectType, node);
    generator.token('[');
    generator.print(node.indexType, node);
    generator.token(']');
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSIndexSignature.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSIndexSignature_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSIndexSignature_ts$tsIndexSignature.assert(node);

    if (node.readonly) {
      generator.word('readonly');
      generator.space();
    }

    generator.token('[');
    generator.print(node.key, node);
    generator.token(']');
    generator.token(':');
    generator.space();
    generator.print(node.typeAnnotation, node);
    generator.token(';');
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSInferType.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSInferType_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSInferType_ts$tsInferType.assert(node);
    generator.token('infer');
    generator.space();
    generator.print(node.typeParameter, node);
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSInterfaceBody.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSInterfaceBody_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSInterfaceBody_ts$tsInterfaceBody.assert(node);
    ___R$project$rome$$romejs$js$generator$generators$utils_ts$printTSBraced(generator, node, node.body);
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSInterfaceDeclaration.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSInterfaceDeclaration_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSInterfaceDeclaration_ts$tsInterfaceDeclaration.assert(node);

    if (node.declare) {
      generator.word('declare');
      generator.space();
    }

    generator.word('interface');
    generator.space();
    generator.print(node.id, node);
    generator.print(node.typeParameters, node);

    if (node.extends) {
      generator.space();
      generator.word('extends');
      generator.space();
      generator.printCommaList(node.extends, node);
    }

    generator.space();
    generator.print(node.body, node);
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSMappedType.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSMappedType_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSMappedType_ts$tsMappedType.assert(node);

    generator.token('{');
    generator.space();

    if (node.readonly) {
      ___R$project$rome$$romejs$js$generator$generators$utils_ts$tokenIfPlusMinus(generator, node.readonly);
      generator.word('readonly');
      generator.space();
    }

    const {typeParameter} = node;
    generator.token('[');
    generator.word(typeParameter.name);
    generator.space();
    generator.word('in');
    generator.space();
    generator.print(typeParameter.constraint, typeParameter);
    generator.token(']');

    if (node.optional) {
      ___R$project$rome$$romejs$js$generator$generators$utils_ts$tokenIfPlusMinus(generator, node.optional);
      generator.token('?');
    }

    generator.token(':');
    generator.space();
    generator.print(node.typeAnnotation, node);
    generator.space();
    generator.token('}');
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSMethodSignature.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSMethodSignature_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSMethodSignature_ts$tsMethodSignature.assert(node);
    generator.print(node.key, node);
    generator.print(node.meta, node);
    generator.token(';');
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSModuleBlock.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSModuleBlock_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSModuleBlock_ts$tsModuleBlock.assert(node);
    ___R$project$rome$$romejs$js$generator$generators$utils_ts$printTSBraced(generator, node, node.body);
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSModuleDeclaration.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSModuleDeclaration_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSModuleDeclaration_ts$tsModuleDeclaration.assert(node);

    if (node.declare) {
      generator.word('declare');
      generator.space();
    }

    if (!node.global) {
      generator.word(node.id.type === 'BindingIdentifier' ? 'namespace' : 'module');
      generator.space();
    }
    generator.print(node.id, node);

    if (!node.body) {
      generator.token(';');
      return;
    }

    let body = node.body;
    while (body !== undefined && body.type === 'TSModuleDeclaration') {
      generator.token('.');
      generator.print(body.id, body);
      body = body.body;
    }

    generator.space();
    generator.print(body, node);
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSNamespaceExportDeclaration.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSNamespaceExportDeclaration_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSNamespaceExportDeclaration_ts$tsNamespaceExportDeclaration.assert(node);
    generator.word('export');
    generator.space();
    generator.word('as');
    generator.space();
    generator.word('namespace');
    generator.space();
    generator.print(node.id, node);
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSNonNullExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSNonNullExpression_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSNonNullExpression_ts$tsNonNullExpression.assert(node);
    generator.print(node.expression, node);
    generator.token('!');
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSOptionalType.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSOptionalType_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSOptionalType_ts$tsOptionalType.assert(node);
    generator.print(node.typeAnnotation, node);
    generator.token('?');
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSParenthesizedType.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSParenthesizedType_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSParenthesizedType_ts$tsParenthesizedType.assert(node);
    generator.token('(');
    generator.print(node.typeAnnotation, node);
    generator.token(')');
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSPropertySignature.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSPropertySignature_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSPropertySignature_ts$tsPropertySignature.assert(node);

    if (node.readonly) {
      generator.word('readonly');
      generator.space();
    }

    generator.print(node.key, node);

    if (node.optional) {
      generator.token('?');
    }

    generator.token(':');
    generator.space();

    generator.print(node.typeAnnotation, node);
    generator.token(';');
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSQualifiedName.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSQualifiedName_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSQualifiedName_ts$tsQualifiedName.assert(node);
    generator.print(node.left, node);
    generator.token('.');
    generator.print(node.right, node);
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSSignatureDeclarationMeta.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSSignatureDeclarationMeta_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSSignatureDeclarationMeta_ts$tsSignatureDeclarationMeta.assert(node);

    generator.print(node.typeParameters, node);
    generator.token('(');
    ___R$project$rome$$romejs$js$generator$generators$utils_ts$printBindingPatternParams(generator, node, node.parameters, node.rest);
    generator.token(')');
    generator.space();
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSThisType.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSThisType_ts$default(generator) {
    generator.word('this');
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSTupleType.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSTupleType_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSTupleType_ts$tsTupleType.assert(node);
    generator.token('[');
    generator.printCommaList(node.elementTypes, node);
    generator.token(']');
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSTypeAssertion.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSTypeAssertion_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSTypeAssertion_ts$tsTypeAssertion.assert(node);
    generator.token('<');
    generator.print(node.typeAnnotation, node);
    generator.token('>');
    generator.space();
    generator.print(node.expression, node);
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSTypeLiteral.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSTypeLiteral_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSTypeLiteral_ts$tsTypeLiteral.assert(node);
    ___R$project$rome$$romejs$js$generator$generators$utils_ts$printTSBraced(generator, node, node.members);
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSTypeOperator.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSTypeOperator_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSTypeOperator_ts$tsTypeOperator.assert(node);
    generator.token(node.operator);
    generator.space();
    generator.print(node.typeAnnotation, node);
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSTypeParameter.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSTypeParameter_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameter_ts$tsTypeParameter.assert(node);

    generator.word(node.name);

    if (node.constraint) {
      generator.space();
      generator.word('extends');
      generator.space();
      generator.print(node.constraint, node);
    }

    if (node.default) {
      generator.space();
      generator.token('=');
      generator.space();
      generator.print(node.default, node);
    }
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSTypeParameterDeclaration.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSTypeParameterDeclaration_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterDeclaration_ts$tsTypeParameterDeclaration.assert(node);
    generator.token('<');
    generator.printCommaList(node.params, node);
    generator.token('>');
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSTypeParameterInstantiation.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSTypeParameterInstantiation_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterInstantiation_ts$tsTypeParameterInstantiation.assert(node);
    generator.token('<');
    generator.printCommaList(node.params, node);
    generator.token('>');
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSTypePredicate.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSTypePredicate_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSTypePredicate_ts$tsTypePredicate.assert(node);

    if (node.asserts) {
      generator.word('asserts');
      generator.space();
    }

    generator.print(node.parameterName, node);

    if (node.typeAnnotation) {
      generator.space();
      generator.word('is');
      generator.space();
      generator.print(node.typeAnnotation, node);
    }
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSTypeQuery.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSTypeQuery_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSTypeQuery_ts$tsTypeQuery.assert(node);
    generator.word('typeof');
    generator.space();
    generator.print(node.exprName, node);
  }

  // project-rome/@romejs/js-generator/generators/typescript/TSTypeReference.ts
function ___R$project$rome$$romejs$js$generator$generators$typescript$TSTypeReference_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSTypeReference_ts$tsTypeReference.assert(node);
    generator.print(node.typeName, node);
    generator.print(node.typeParameters, node);
  }

  // project-rome/@romejs/js-generator/generators/types/TypeAliasTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$types$TypeAliasTypeAnnotation_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$types$TypeAliasTypeAnnotation_ts$typeAliasTypeAnnotation.assert(node);

    generator.word('type');
    generator.space();
    generator.print(node.id, node);
    generator.print(node.typeParameters, node);
    generator.space();
    generator.token('=');
    generator.space();
    generator.print(node.right, node);
    generator.semicolon();
  }

  // project-rome/@romejs/js-generator/generators/expressions/UnaryExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$expressions$UnaryExpression_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$expressions$UnaryExpression_ts$unaryExpression.assert(node);

    if (node.operator === 'void' || node.operator === 'delete' ||
    node.operator === 'typeof') {
      generator.word(node.operator);
      generator.space();
    } else {
      generator.token(node.operator);
    }

    generator.print(node.argument, node);
  }

  // project-rome/@romejs/js-generator/generators/types/UndefinedKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$types$UndefinedKeywordTypeAnnotation_ts$default(generator) {
    generator.word('undefined');
  }

  // project-rome/@romejs/js-generator/generators/types/UnionTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$types$UnionTypeAnnotation_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$types$UnionTypeAnnotation_ts$unionTypeAnnotation.assert(node);

    generator.multiline(
      node,
      (multiline, node) => {
        if (multiline) {
          generator.indent();
          ___R$$priv$project$rome$$romejs$js$generator$generators$types$UnionTypeAnnotation_ts$orNewlineSeparator(generator, false);
        }

        generator.printJoin(
          node.types,
          node,
          {
            after: multiline ? ___R$$priv$project$rome$$romejs$js$generator$generators$types$UnionTypeAnnotation_ts$orNewlineSeparator : ___R$$priv$project$rome$$romejs$js$generator$generators$types$UnionTypeAnnotation_ts$orSpaceSeparator,
          },
        );

        if (multiline) {
          generator.dedent();
        }
      },
      {conditions: ['more-than-one-line'], indent: true},
    );
  }

  function ___R$$priv$project$rome$$romejs$js$generator$generators$types$UnionTypeAnnotation_ts$orNewlineSeparator(generator, isLast) {
    if (isLast) {
      return;
    }

    generator.newline();
    generator.token('|');
    generator.space();
  }

  function ___R$$priv$project$rome$$romejs$js$generator$generators$types$UnionTypeAnnotation_ts$orSpaceSeparator(generator, isLast) {
    if (isLast) {
      return;
    }

    generator.space();
    generator.token('|');
    generator.space();
  }

  // project-rome/@romejs/js-generator/generators/types/UnknownKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$types$UnknownKeywordTypeAnnotation_ts$default(generator) {
    generator.word('unknown');
  }

  // project-rome/@romejs/js-generator/generators/expressions/UpdateExpression.ts
function ___R$project$rome$$romejs$js$generator$generators$expressions$UpdateExpression_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$expressions$UpdateExpression_ts$updateExpression.assert(node);

    if (node.prefix === true) {
      generator.token(node.operator);
      generator.print(node.argument, node);
    } else {
      generator.print(node.argument, node);
      generator.token(node.operator);
    }
  }

  // project-rome/@romejs/js-generator/generators/auxiliary/VariableDeclaration.ts
function ___R$project$rome$$romejs$js$generator$generators$auxiliary$VariableDeclaration_ts$default(
    generator,
    node,
    parent,
  ) {
    node = ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.assert(node);

    generator.word(node.kind);
    generator.space();

    let hasInits = false;

    // don't add whitespace to loop heads
    if (!___R$project$rome$$romejs$js$ast$utils$isFor_ts$default(parent)) {
      for (const declar of node.declarations) {
        if (declar.init) {
          // has an init so let's split it up over multiple lines
          hasInits = true;
        }
      }
    }

    //

    // use a pretty separator when we aren't in compact mode, have initializers and don't have retainLines on

    // this will format declarations like:
    //

    //   let foo = "bar", bar = "foo";

    //

    // into

    //

    //   let foo = "bar",

    //       bar = "foo";

    //
    let separator = ___R$$priv$project$rome$$romejs$js$generator$generators$auxiliary$VariableDeclaration_ts$variableDeclarationNormal;
    if (hasInits) {
      separator =
        node.kind === 'const'
          ? ___R$$priv$project$rome$$romejs$js$generator$generators$auxiliary$VariableDeclaration_ts$constDeclarationIndent : ___R$$priv$project$rome$$romejs$js$generator$generators$auxiliary$VariableDeclaration_ts$variableDeclarationIndent;
    }

    generator.printJoin(
      node.declarations,
      node,
      {
        after: separator,
      },
    );
  }

  function ___R$$priv$project$rome$$romejs$js$generator$generators$auxiliary$VariableDeclaration_ts$variableDeclarationNormal(generator, isLast) {
    if (isLast) {
      return;
    }

    generator.token(',');
    generator.space();
  }

  function ___R$$priv$project$rome$$romejs$js$generator$generators$auxiliary$VariableDeclaration_ts$variableDeclarationIndent(generator, isLast) {
    if (isLast) {
      return;
    }

    // "let " or "var " indentation.
    generator.token(',');
    generator.forceNewline();
    if (generator.buf.endsWith('\n')) {
      for (let i = 0;
      i < 4;
      i++) {
        generator.space();
      }
    }
  }

  function ___R$$priv$project$rome$$romejs$js$generator$generators$auxiliary$VariableDeclaration_ts$constDeclarationIndent(generator, isLast) {
    if (isLast) {
      return;
    }

    // "const " indentation.
    generator.token(',');
    generator.forceNewline();
    if (generator.buf.endsWith('\n')) {
      for (let i = 0;
      i < 6;
      i++) {
        generator.space();
      }
    }
  }

  // project-rome/@romejs/js-generator/generators/statements/VariableDeclarationStatement.ts
function ___R$project$rome$$romejs$js$generator$generators$statements$VariableDeclarationStatement_ts$default(
    generator,
    node,
  ) {
    node = ___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement.assert(node);

    if (node.declare === true && !generator.options.typeAnnotations) {
      return;
    }

    if (node.declare) {
      generator.word('declare');
    }

    generator.print(node.declaration, node);
    generator.semicolon();
  }

  // project-rome/@romejs/js-generator/generators/auxiliary/VariableDeclarator.ts
function ___R$project$rome$$romejs$js$generator$generators$auxiliary$VariableDeclarator_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator.assert(node);

    generator.print(node.id, node);

    if (node.init) {
      generator.space();
      generator.token('=');
      generator.space();

      generator.multiline(
        node,
        (multiline, node) => {
          generator.print(node.init, node);
        },
        {indent: true},
      );
    }
  }

  // project-rome/@romejs/js-generator/generators/types/VoidKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$generator$generators$types$VoidKeywordTypeAnnotation_ts$default(generator) {
    generator.word('void');
  }

  // project-rome/@romejs/js-generator/generators/statements/WhileStatement.ts
function ___R$project$rome$$romejs$js$generator$generators$statements$WhileStatement_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$statements$WhileStatement_ts$whileStatement.assert(node);

    generator.word('while');
    generator.space();
    generator.token('(');
    generator.print(node.test, node);
    generator.token(')');
    generator.printBlock(node);
  }

  // project-rome/@romejs/js-generator/generators/statements/WithStatement.ts
function ___R$project$rome$$romejs$js$generator$generators$statements$WithStatement_ts$default(generator, node) {
    node = ___R$project$rome$$romejs$js$ast$statements$WithStatement_ts$withStatement.assert(node);

    generator.word('with');
    generator.space();
    generator.token('(');
    generator.print(node.object, node);
    generator.token(')');
    generator.printBlock(node);
  }

  // project-rome/@romejs/js-generator/generators/expressions/YieldExpression.ts
const ___R$project$rome$$romejs$js$generator$generators$expressions$YieldExpression_ts$default = ___R$project$rome$$romejs$js$generator$generators$utils_ts$buildYieldAwaitGenerator('yield');

  // project-rome/@romejs/js-generator/generators/index.ts
const ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators = new Map();
  const ___R$project$rome$$romejs$js$generator$generators$index_ts$default = ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators;
  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set(
    'AmbiguousFlowTypeCastExpression',
    ___R$project$rome$$romejs$js$generator$generators$temp$AmbiguousFlowTypeCastExpression_ts$default,
  );

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('AnyKeywordTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$types$AnyKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ArrayExpression', ___R$project$rome$$romejs$js$generator$generators$expressions$ArrayExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ArrowFunctionExpression', ___R$project$rome$$romejs$js$generator$generators$expressions$ArrowFunctionExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('AssignmentArrayPattern', ___R$project$rome$$romejs$js$generator$generators$patterns$AssignmentArrayPattern_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('AssignmentAssignmentPattern', ___R$project$rome$$romejs$js$generator$generators$patterns$AssignmentAssignmentPattern_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('AssignmentExpression', ___R$project$rome$$romejs$js$generator$generators$expressions$AssignmentExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('AssignmentIdentifier', ___R$project$rome$$romejs$js$generator$generators$patterns$AssignmentIdentifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('AssignmentObjectPattern', ___R$project$rome$$romejs$js$generator$generators$patterns$AssignmentObjectPattern_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set(
    'AssignmentObjectPatternProperty',
    ___R$project$rome$$romejs$js$generator$generators$patterns$AssignmentObjectPatternProperty_ts$default,
  );

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('AwaitExpression', ___R$project$rome$$romejs$js$generator$generators$expressions$AwaitExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('BigIntKeywordTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$types$BigIntKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('BigIntLiteral', ___R$project$rome$$romejs$js$generator$generators$literals$BigIntLiteral_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('BinaryExpression', ___R$project$rome$$romejs$js$generator$generators$expressions$BinaryExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('BindingArrayPattern', ___R$project$rome$$romejs$js$generator$generators$patterns$BindingArrayPattern_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('BindingAssignmentPattern', ___R$project$rome$$romejs$js$generator$generators$patterns$BindingAssignmentPattern_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('BindingIdentifier', ___R$project$rome$$romejs$js$generator$generators$patterns$BindingIdentifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('BindingObjectPattern', ___R$project$rome$$romejs$js$generator$generators$patterns$BindingObjectPattern_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('BindingObjectPatternProperty', ___R$project$rome$$romejs$js$generator$generators$patterns$BindingObjectPatternProperty_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('BlockStatement', ___R$project$rome$$romejs$js$generator$generators$statements$BlockStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('BooleanKeywordTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$types$BooleanKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('BooleanLiteral', ___R$project$rome$$romejs$js$generator$generators$literals$BooleanLiteral_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('BooleanLiteralTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$types$BooleanLiteralTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('BreakStatement', ___R$project$rome$$romejs$js$generator$generators$statements$BreakStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('CallExpression', ___R$project$rome$$romejs$js$generator$generators$expressions$CallExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('CatchClause', ___R$project$rome$$romejs$js$generator$generators$auxiliary$CatchClause_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ClassDeclaration', ___R$project$rome$$romejs$js$generator$generators$classes$ClassDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ClassExpression', ___R$project$rome$$romejs$js$generator$generators$classes$ClassExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ClassHead', ___R$project$rome$$romejs$js$generator$generators$classes$ClassHead_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ClassMethod', ___R$project$rome$$romejs$js$generator$generators$classes$ClassMethod_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ClassPrivateMethod', ___R$project$rome$$romejs$js$generator$generators$classes$ClassPrivateMethod_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ClassPrivateProperty', ___R$project$rome$$romejs$js$generator$generators$classes$ClassPrivateProperty_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ClassProperty', ___R$project$rome$$romejs$js$generator$generators$classes$ClassProperty_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ClassPropertyMeta', ___R$project$rome$$romejs$js$generator$generators$classes$ClassPropertyMeta_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('CommentBlock', ___R$project$rome$$romejs$js$generator$generators$core$CommentBlock_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('CommentLine', ___R$project$rome$$romejs$js$generator$generators$core$CommentLine_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ComputedMemberProperty', ___R$project$rome$$romejs$js$generator$generators$auxiliary$ComputedMemberProperty_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ComputedPropertyKey', ___R$project$rome$$romejs$js$generator$generators$objects$ComputedPropertyKey_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ConditionalExpression', ___R$project$rome$$romejs$js$generator$generators$expressions$ConditionalExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ContinueStatement', ___R$project$rome$$romejs$js$generator$generators$statements$ContinueStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('DebuggerStatement', ___R$project$rome$$romejs$js$generator$generators$statements$DebuggerStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('Directive', ___R$project$rome$$romejs$js$generator$generators$core$Directive_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('DoExpression', ___R$project$rome$$romejs$js$generator$generators$expressions$DoExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('DoWhileStatement', ___R$project$rome$$romejs$js$generator$generators$statements$DoWhileStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('EmptyKeywordTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$types$EmptyKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('EmptyStatement', ___R$project$rome$$romejs$js$generator$generators$statements$EmptyStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ExportAllDeclaration', ___R$project$rome$$romejs$js$generator$generators$modules$ExportAllDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ExportDefaultDeclaration', ___R$project$rome$$romejs$js$generator$generators$modules$ExportDefaultDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ExportDefaultSpecifier', ___R$project$rome$$romejs$js$generator$generators$modules$ExportDefaultSpecifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ExportExternalDeclaration', ___R$project$rome$$romejs$js$generator$generators$modules$ExportExternalDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ExportExternalSpecifier', ___R$project$rome$$romejs$js$generator$generators$modules$ExportExternalSpecifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ExportLocalDeclaration', ___R$project$rome$$romejs$js$generator$generators$modules$ExportLocalDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ExportLocalSpecifier', ___R$project$rome$$romejs$js$generator$generators$modules$ExportLocalSpecifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ExportNamespaceSpecifier', ___R$project$rome$$romejs$js$generator$generators$modules$ExportNamespaceSpecifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ExpressionStatement', ___R$project$rome$$romejs$js$generator$generators$statements$ExpressionStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowArrayTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$flow$FlowArrayTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowClassImplements', ___R$project$rome$$romejs$js$generator$generators$flow$FlowClassImplements_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowDeclareClass', ___R$project$rome$$romejs$js$generator$generators$flow$FlowDeclareClass_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowDeclaredPredicate', ___R$project$rome$$romejs$js$generator$generators$flow$FlowDeclaredPredicate_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowDeclareExportAll', ___R$project$rome$$romejs$js$generator$generators$flow$FlowDeclareExportAll_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowDeclareExportDefault', ___R$project$rome$$romejs$js$generator$generators$flow$FlowDeclareExportDefault_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowDeclareExportNamed', ___R$project$rome$$romejs$js$generator$generators$flow$FlowDeclareExportNamed_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowDeclareFunction', ___R$project$rome$$romejs$js$generator$generators$flow$FlowDeclareFunction_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowDeclareInterface', ___R$project$rome$$romejs$js$generator$generators$flow$FlowDeclareInterface_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowDeclareModule', ___R$project$rome$$romejs$js$generator$generators$flow$FlowDeclareModule_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowDeclareModuleExports', ___R$project$rome$$romejs$js$generator$generators$flow$FlowDeclareModuleExports_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowDeclareOpaqueType', ___R$project$rome$$romejs$js$generator$generators$flow$FlowDeclareOpaqueType_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowDeclareVariable', ___R$project$rome$$romejs$js$generator$generators$flow$FlowDeclareVariable_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowExistsTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$flow$FlowExistsTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowFunctionTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$flow$FlowFunctionTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowFunctionTypeParam', ___R$project$rome$$romejs$js$generator$generators$flow$FlowFunctionTypeParam_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowGenericTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$flow$FlowGenericTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowInferredPredicate', ___R$project$rome$$romejs$js$generator$generators$flow$FlowInferredPredicate_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowInterface', ___R$project$rome$$romejs$js$generator$generators$flow$FlowInterface_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowInterfaceDeclaration', ___R$project$rome$$romejs$js$generator$generators$flow$FlowInterfaceDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowInterfaceExtends', ___R$project$rome$$romejs$js$generator$generators$flow$FlowInterfaceExtends_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowInterfaceTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$flow$FlowInterfaceTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowNullableTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$flow$FlowNullableTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowNumericLiteral', ___R$project$rome$$romejs$js$generator$generators$flow$FlowNumericLiteral_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowObjectTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$flow$FlowObjectTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowObjectTypeCallProperty', ___R$project$rome$$romejs$js$generator$generators$flow$FlowObjectTypeCallProperty_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowObjectTypeIndexer', ___R$project$rome$$romejs$js$generator$generators$flow$FlowObjectTypeIndexer_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowObjectTypeInternalSlot', ___R$project$rome$$romejs$js$generator$generators$flow$FlowObjectTypeInternalSlot_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowObjectTypeProperty', ___R$project$rome$$romejs$js$generator$generators$flow$FlowObjectTypeProperty_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowObjectTypeSpreadProperty', ___R$project$rome$$romejs$js$generator$generators$flow$FlowObjectTypeSpreadProperty_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowOpaqueType', ___R$project$rome$$romejs$js$generator$generators$flow$FlowOpaqueType_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowQualifiedTypeIdentifier', ___R$project$rome$$romejs$js$generator$generators$flow$FlowQualifiedTypeIdentifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowThisTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$flow$FlowThisTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowTupleTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$flow$FlowTupleTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowTypeCastExpression', ___R$project$rome$$romejs$js$generator$generators$flow$FlowTypeCastExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowTypeofTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$flow$FlowTypeofTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowTypeParameter', ___R$project$rome$$romejs$js$generator$generators$flow$FlowTypeParameter_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowTypeParameterDeclaration', ___R$project$rome$$romejs$js$generator$generators$flow$FlowTypeParameterDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowTypeParameterInstantiation', ___R$project$rome$$romejs$js$generator$generators$flow$FlowTypeParameterInstantiation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FlowVariance', ___R$project$rome$$romejs$js$generator$generators$flow$FlowVariance_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ForInStatement', ___R$project$rome$$romejs$js$generator$generators$statements$ForInStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ForOfStatement', ___R$project$rome$$romejs$js$generator$generators$statements$ForOfStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ForStatement', ___R$project$rome$$romejs$js$generator$generators$statements$ForStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FunctionDeclaration', ___R$project$rome$$romejs$js$generator$generators$statements$FunctionDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FunctionExpression', ___R$project$rome$$romejs$js$generator$generators$expressions$FunctionExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('FunctionHead', ___R$project$rome$$romejs$js$generator$generators$auxiliary$FunctionHead_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('Identifier', ___R$project$rome$$romejs$js$generator$generators$auxiliary$Identifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('IfStatement', ___R$project$rome$$romejs$js$generator$generators$statements$IfStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ImportCall', ___R$project$rome$$romejs$js$generator$generators$modules$ImportCall_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ImportDeclaration', ___R$project$rome$$romejs$js$generator$generators$modules$ImportDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ImportDefaultSpecifier', ___R$project$rome$$romejs$js$generator$generators$modules$ImportDefaultSpecifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ImportNamespaceSpecifier', ___R$project$rome$$romejs$js$generator$generators$modules$ImportNamespaceSpecifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ImportSpecifier', ___R$project$rome$$romejs$js$generator$generators$modules$ImportSpecifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ImportSpecifierLocal', ___R$project$rome$$romejs$js$generator$generators$modules$ImportSpecifierLocal_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('InterpreterDirective', ___R$project$rome$$romejs$js$generator$generators$core$InterpreterDirective_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('IntersectionTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$types$IntersectionTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('JSXAttribute', ___R$project$rome$$romejs$js$generator$generators$jsx$JSXAttribute_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('JSXElement', ___R$project$rome$$romejs$js$generator$generators$jsx$JSXElement_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('JSXEmptyExpression', ___R$project$rome$$romejs$js$generator$generators$jsx$JSXEmptyExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('JSXExpressionContainer', ___R$project$rome$$romejs$js$generator$generators$jsx$JSXExpressionContainer_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('JSXFragment', ___R$project$rome$$romejs$js$generator$generators$jsx$JSXFragment_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('JSXIdentifier', ___R$project$rome$$romejs$js$generator$generators$jsx$JSXIdentifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('JSXMemberExpression', ___R$project$rome$$romejs$js$generator$generators$jsx$JSXMemberExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('JSXNamespacedName', ___R$project$rome$$romejs$js$generator$generators$jsx$JSXNamespacedName_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('JSXReferenceIdentifier', ___R$project$rome$$romejs$js$generator$generators$jsx$JSXReferenceIdentifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('JSXSpreadAttribute', ___R$project$rome$$romejs$js$generator$generators$jsx$JSXSpreadAttribute_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('JSXSpreadChild', ___R$project$rome$$romejs$js$generator$generators$jsx$JSXSpreadChild_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('JSXText', ___R$project$rome$$romejs$js$generator$generators$jsx$JSXText_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('LabeledStatement', ___R$project$rome$$romejs$js$generator$generators$statements$LabeledStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('LogicalExpression', ___R$project$rome$$romejs$js$generator$generators$expressions$LogicalExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('MemberExpression', ___R$project$rome$$romejs$js$generator$generators$expressions$MemberExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('MetaProperty', ___R$project$rome$$romejs$js$generator$generators$expressions$MetaProperty_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('MixedKeywordTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$types$MixedKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('MockParent', ___R$project$rome$$romejs$js$generator$generators$temp$MockParent_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('NeverKeywordTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$types$NeverKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('NewExpression', ___R$project$rome$$romejs$js$generator$generators$expressions$NewExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('NullKeywordTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$types$NullKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('NullLiteral', ___R$project$rome$$romejs$js$generator$generators$literals$NullLiteral_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('NumberKeywordTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$types$NumberKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('NumericLiteral', ___R$project$rome$$romejs$js$generator$generators$literals$NumericLiteral_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('NumericLiteralTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$types$NumericLiteralTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ObjectExpression', ___R$project$rome$$romejs$js$generator$generators$objects$ObjectExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ObjectKeywordTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$types$ObjectKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ObjectMethod', ___R$project$rome$$romejs$js$generator$generators$objects$ObjectMethod_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ObjectProperty', ___R$project$rome$$romejs$js$generator$generators$objects$ObjectProperty_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('OptionalCallExpression', ___R$project$rome$$romejs$js$generator$generators$expressions$OptionalCallExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('PatternMeta', ___R$project$rome$$romejs$js$generator$generators$patterns$PatternMeta_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('PrivateName', ___R$project$rome$$romejs$js$generator$generators$classes$PrivateName_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('Program', ___R$project$rome$$romejs$js$generator$generators$core$Program_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ReferenceIdentifier', ___R$project$rome$$romejs$js$generator$generators$expressions$ReferenceIdentifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('RegExpAlternation', ___R$project$rome$$romejs$js$generator$generators$regex$RegExpAlternation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('RegExpAnyCharacter', ___R$project$rome$$romejs$js$generator$generators$regex$RegExpAnyCharacter_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('RegExpCharacter', ___R$project$rome$$romejs$js$generator$generators$regex$RegExpCharacter_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('RegExpCharSet', ___R$project$rome$$romejs$js$generator$generators$regex$RegExpCharSet_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('RegExpCharSetRange', ___R$project$rome$$romejs$js$generator$generators$regex$RegExpCharSetRange_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('RegExpControlCharacter', ___R$project$rome$$romejs$js$generator$generators$regex$RegExpControlCharacter_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('RegExpDigitCharacter', ___R$project$rome$$romejs$js$generator$generators$regex$RegExpDigitCharacter_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('RegExpEndCharacter', ___R$project$rome$$romejs$js$generator$generators$regex$RegExpEndCharacter_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('RegExpGroupCapture', ___R$project$rome$$romejs$js$generator$generators$regex$RegExpGroupCapture_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('RegExpGroupNonCapture', ___R$project$rome$$romejs$js$generator$generators$regex$RegExpGroupNonCapture_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('RegExpLiteral', ___R$project$rome$$romejs$js$generator$generators$literals$RegExpLiteral_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('RegExpNonDigitCharacter', ___R$project$rome$$romejs$js$generator$generators$regex$RegExpNonDigitCharacter_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('RegExpNonWhiteSpaceCharacter', ___R$project$rome$$romejs$js$generator$generators$regex$RegExpNonWhiteSpaceCharacter_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('RegExpNonWordBoundaryCharacter', ___R$project$rome$$romejs$js$generator$generators$regex$RegExpNonWordBoundaryCharacter_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('RegExpNonWordCharacter', ___R$project$rome$$romejs$js$generator$generators$regex$RegExpNonWordCharacter_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('RegExpQuantified', ___R$project$rome$$romejs$js$generator$generators$regex$RegExpQuantified_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('RegExpStartCharacter', ___R$project$rome$$romejs$js$generator$generators$regex$RegExpStartCharacter_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('RegExpSubExpression', ___R$project$rome$$romejs$js$generator$generators$regex$RegExpSubExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('RegExpWhiteSpaceCharacter', ___R$project$rome$$romejs$js$generator$generators$regex$RegExpWhiteSpaceCharacter_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('RegExpWordBoundaryCharacter', ___R$project$rome$$romejs$js$generator$generators$regex$RegExpWordBoundaryCharacter_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('RegExpWordCharacter', ___R$project$rome$$romejs$js$generator$generators$regex$RegExpWordCharacter_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ReturnStatement', ___R$project$rome$$romejs$js$generator$generators$statements$ReturnStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('SequenceExpression', ___R$project$rome$$romejs$js$generator$generators$expressions$SequenceExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('SpreadElement', ___R$project$rome$$romejs$js$generator$generators$auxiliary$SpreadElement_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('SpreadProperty', ___R$project$rome$$romejs$js$generator$generators$objects$SpreadProperty_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('StaticMemberProperty', ___R$project$rome$$romejs$js$generator$generators$auxiliary$StaticMemberProperty_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('StaticPropertyKey', ___R$project$rome$$romejs$js$generator$generators$objects$StaticPropertyKey_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('StringKeywordTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$types$StringKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('StringLiteral', ___R$project$rome$$romejs$js$generator$generators$literals$StringLiteral_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('StringLiteralTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$types$StringLiteralTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('Super', ___R$project$rome$$romejs$js$generator$generators$expressions$Super_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('SwitchCase', ___R$project$rome$$romejs$js$generator$generators$auxiliary$SwitchCase_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('SwitchStatement', ___R$project$rome$$romejs$js$generator$generators$statements$SwitchStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('SymbolKeywordTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$types$SymbolKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TaggedTemplateExpression', ___R$project$rome$$romejs$js$generator$generators$expressions$TaggedTemplateExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TemplateElement', ___R$project$rome$$romejs$js$generator$generators$auxiliary$TemplateElement_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TemplateLiteral', ___R$project$rome$$romejs$js$generator$generators$literals$TemplateLiteral_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TemplateLiteralTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$types$TemplateLiteralTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ThisExpression', ___R$project$rome$$romejs$js$generator$generators$expressions$ThisExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('ThrowStatement', ___R$project$rome$$romejs$js$generator$generators$statements$ThrowStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TryStatement', ___R$project$rome$$romejs$js$generator$generators$statements$TryStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSArrayType', ___R$project$rome$$romejs$js$generator$generators$typescript$TSArrayType_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSAsExpression', ___R$project$rome$$romejs$js$generator$generators$typescript$TSAsExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSAssignmentAsExpression', ___R$project$rome$$romejs$js$generator$generators$typescript$TSAssignmentAsExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSAssignmentNonNullExpression', ___R$project$rome$$romejs$js$generator$generators$typescript$TSAssignmentNonNullExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSAssignmentTypeAssertion', ___R$project$rome$$romejs$js$generator$generators$typescript$TSAssignmentTypeAssertion_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSCallSignatureDeclaration', ___R$project$rome$$romejs$js$generator$generators$typescript$TSCallSignatureDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSConditionalType', ___R$project$rome$$romejs$js$generator$generators$typescript$TSConditionalType_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSConstructorType', ___R$project$rome$$romejs$js$generator$generators$typescript$TSConstructorType_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set(
    'TSConstructSignatureDeclaration',
    ___R$project$rome$$romejs$js$generator$generators$typescript$TSConstructSignatureDeclaration_ts$default,
  );

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSDeclareFunction', ___R$project$rome$$romejs$js$generator$generators$typescript$TSDeclareFunction_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSDeclareMethod', ___R$project$rome$$romejs$js$generator$generators$typescript$TSDeclareMethod_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSEnumDeclaration', ___R$project$rome$$romejs$js$generator$generators$typescript$TSEnumDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSEnumMember', ___R$project$rome$$romejs$js$generator$generators$typescript$TSEnumMember_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSExportAssignment', ___R$project$rome$$romejs$js$generator$generators$typescript$TSExportAssignment_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSExpressionWithTypeArguments', ___R$project$rome$$romejs$js$generator$generators$typescript$TSExpressionWithTypeArguments_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSExternalModuleReference', ___R$project$rome$$romejs$js$generator$generators$typescript$TSExternalModuleReference_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSFunctionType', ___R$project$rome$$romejs$js$generator$generators$typescript$TSFunctionType_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSImportEqualsDeclaration', ___R$project$rome$$romejs$js$generator$generators$typescript$TSImportEqualsDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSImportType', ___R$project$rome$$romejs$js$generator$generators$typescript$TSImportType_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSIndexedAccessType', ___R$project$rome$$romejs$js$generator$generators$typescript$TSIndexedAccessType_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSIndexSignature', ___R$project$rome$$romejs$js$generator$generators$typescript$TSIndexSignature_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSInferType', ___R$project$rome$$romejs$js$generator$generators$typescript$TSInferType_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSInterfaceBody', ___R$project$rome$$romejs$js$generator$generators$typescript$TSInterfaceBody_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSInterfaceDeclaration', ___R$project$rome$$romejs$js$generator$generators$typescript$TSInterfaceDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSMappedType', ___R$project$rome$$romejs$js$generator$generators$typescript$TSMappedType_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSMethodSignature', ___R$project$rome$$romejs$js$generator$generators$typescript$TSMethodSignature_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSModuleBlock', ___R$project$rome$$romejs$js$generator$generators$typescript$TSModuleBlock_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSModuleDeclaration', ___R$project$rome$$romejs$js$generator$generators$typescript$TSModuleDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSNamespaceExportDeclaration', ___R$project$rome$$romejs$js$generator$generators$typescript$TSNamespaceExportDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSNonNullExpression', ___R$project$rome$$romejs$js$generator$generators$typescript$TSNonNullExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSOptionalType', ___R$project$rome$$romejs$js$generator$generators$typescript$TSOptionalType_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSParenthesizedType', ___R$project$rome$$romejs$js$generator$generators$typescript$TSParenthesizedType_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSPropertySignature', ___R$project$rome$$romejs$js$generator$generators$typescript$TSPropertySignature_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSQualifiedName', ___R$project$rome$$romejs$js$generator$generators$typescript$TSQualifiedName_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSSignatureDeclarationMeta', ___R$project$rome$$romejs$js$generator$generators$typescript$TSSignatureDeclarationMeta_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSThisType', ___R$project$rome$$romejs$js$generator$generators$typescript$TSThisType_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSTupleType', ___R$project$rome$$romejs$js$generator$generators$typescript$TSTupleType_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSTypeAssertion', ___R$project$rome$$romejs$js$generator$generators$typescript$TSTypeAssertion_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSTypeLiteral', ___R$project$rome$$romejs$js$generator$generators$typescript$TSTypeLiteral_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSTypeOperator', ___R$project$rome$$romejs$js$generator$generators$typescript$TSTypeOperator_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSTypeParameter', ___R$project$rome$$romejs$js$generator$generators$typescript$TSTypeParameter_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSTypeParameterDeclaration', ___R$project$rome$$romejs$js$generator$generators$typescript$TSTypeParameterDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSTypeParameterInstantiation', ___R$project$rome$$romejs$js$generator$generators$typescript$TSTypeParameterInstantiation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSTypePredicate', ___R$project$rome$$romejs$js$generator$generators$typescript$TSTypePredicate_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSTypeQuery', ___R$project$rome$$romejs$js$generator$generators$typescript$TSTypeQuery_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TSTypeReference', ___R$project$rome$$romejs$js$generator$generators$typescript$TSTypeReference_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('TypeAliasTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$types$TypeAliasTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('UnaryExpression', ___R$project$rome$$romejs$js$generator$generators$expressions$UnaryExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('UndefinedKeywordTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$types$UndefinedKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('UnionTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$types$UnionTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('UnknownKeywordTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$types$UnknownKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('UpdateExpression', ___R$project$rome$$romejs$js$generator$generators$expressions$UpdateExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('VariableDeclaration', ___R$project$rome$$romejs$js$generator$generators$auxiliary$VariableDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('VariableDeclarationStatement', ___R$project$rome$$romejs$js$generator$generators$statements$VariableDeclarationStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('VariableDeclarator', ___R$project$rome$$romejs$js$generator$generators$auxiliary$VariableDeclarator_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('VoidKeywordTypeAnnotation', ___R$project$rome$$romejs$js$generator$generators$types$VoidKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('WhileStatement', ___R$project$rome$$romejs$js$generator$generators$statements$WhileStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('WithStatement', ___R$project$rome$$romejs$js$generator$generators$statements$WithStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$generator$generators$index_ts$generators.set('YieldExpression', ___R$project$rome$$romejs$js$generator$generators$expressions$YieldExpression_ts$default);

  // project-rome/@romejs/js-generator/Buffer.ts
class ___R$project$rome$$romejs$js$generator$Buffer_ts$default {
    constructor(opts, code) {
      this.originalCode = code;
      this.opts = opts;
      this.mappings = [];
      this.inputSourceMap =
        opts.inputSourceMap === undefined
          ? undefined : new ___R$project$rome$$romejs$codec$source$map$SourceMapConsumer_ts$default(opts.inputSourceMap);

      this.lineLengths = [];
      this.buf = [];
      this.last = '';

      this.position =
        {
          index: ___R$project$rome$$romejs$ob1$index_ts$number0Neg1,
          column: ___R$project$rome$$romejs$ob1$index_ts$number0,
          line: ___R$project$rome$$romejs$ob1$index_ts$number1,
        };

      this.sourcePosition =
        {
          column: undefined,
          filename: undefined,
          identifierName: undefined,
          line: undefined,
        };
    }

    save() {
      return (
        {
          mappingsIndex: this.mappings.length,
          lastGenLine: this.lastGenLine,
          lastSourceLine: this.lastSourceLine,
          lastSourceColumn: this.lastSourceColumn,
          bufIndex: this.buf.length,
          last: this.last,
          position: Object.assign(
            {
            },
            this.position,
          ),
          sourcePosition: Object.assign(
            {
            },
            this.sourcePosition,
          ),
          lineLengthsIndex: this.lineLengths.length,
        }
      );
    }

    restore(snapshot) {
      this.mappings = this.mappings.slice(0, snapshot.mappingsIndex);
      this.lastGenLine = snapshot.lastGenLine;
      this.lastSourceLine = snapshot.lastSourceLine;
      this.lastSourceColumn = snapshot.lastSourceColumn;
      this.buf = this.buf.slice(0, snapshot.bufIndex);
      this.last = snapshot.last;
      this.position = snapshot.position;
      this.sourcePosition = snapshot.sourcePosition;
      this.lineLengths = this.lineLengths.slice(0, snapshot.lineLengthsIndex);
    }

    getSourceMap() {
      const {opts} = this;

      const map = new ___R$project$rome$$romejs$codec$source$map$SourceMapGenerator_ts$default(
        {
          file: opts.sourceMapTarget,
          sourceRoot: opts.sourceRoot,
        },
      );

      if (opts.sourceFileName !== undefined) {
        map.setSourceContent(opts.sourceFileName, this.originalCode);
      }

      for (const mapping of this.mappings) {
        map.addMapping(mapping);
      }

      return map.toJSON();
    }

    getMappings() {
      return this.mappings.slice();
    }

    /**
   * Mark the current generated position with a source position. May also be passed null line/column
   * values to insert a mapping to nothing.
   */
    mark(generatedLine, generatedColumn, originalLine, originalColumn, identifierName, filename = this.opts.sourceFileName) {
      // TODO: emit a mapping with `original: undefined` in this case - after

      // deduplicating using lastSourceLine and lastSourceColumn.
      if (originalLine === undefined || originalColumn === undefined) {
        return undefined;
      }

      // If this mapping points to the same source location as the last one, we can ignore it since

      // the previous one covers it.
      if (this.lastGenLine === generatedLine &&
        this.lastSourceLine ===
        originalLine &&
        this.lastSourceColumn === originalColumn) {
        return undefined;
      }

      this.lastGenLine = generatedLine;
      this.lastSourceLine = originalLine;
      this.lastSourceColumn = originalColumn;

      // undefined to allow for more compact json serialization
      const name = identifierName === undefined ? undefined : identifierName;
      const source = filename;

      // Forward mappings if provided with an inputSourceMap
      const {inputSourceMap} = this;
      if (inputSourceMap !== undefined) {
        const actual = inputSourceMap.exactOriginalPositionFor(
          originalLine,
          originalColumn,
        );
        if (actual === undefined) {
          // If we were given an input source map and we didn't find the original location in it then omit it since it probably doesn't make sense
          return;
        } else {
          originalLine = actual.line;
          originalColumn = actual.column;
        }
      }

      this.mappings.push(
        {
          generated: {line: generatedLine, column: generatedColumn},
          original: {line: originalLine, column: originalColumn},
          name,
          source,
        },
      );
    }

    /**
   * Get the final string output from the buffer.
   */
    getCode() {
      let code = this.buf.join('').trimRight();

      if (this.opts.format === 'pretty') {
        code += '\n';
      }

      return code;
    }

    append(str) {
      const {column, filename, identifierName, line} = this.sourcePosition;

      // If there the line is ending, adding a new mapping marker is redundant
      if (str[0] !== '\n') {
        this.mark(
          this.position.line,
          this.position.column,
          line,
          column,
          identifierName,
          filename,
        );
      }

      this.buf.push(str);
      this.last = str[str.length - 1];

      for (let i = 0;
      i < str.length;
      i++) {
        this.position.index = ___R$project$rome$$romejs$ob1$index_ts$inc(this.position.index);

        if (str[i] === '\n') {
          this.lineLengths.push(___R$project$rome$$romejs$ob1$index_ts$inc(this.position.column));
          this.position.line = ___R$project$rome$$romejs$ob1$index_ts$inc(this.position.line);
          this.position.column = ___R$project$rome$$romejs$ob1$index_ts$number0;
        } else {
          this.position.column = ___R$project$rome$$romejs$ob1$index_ts$inc(this.position.column);
        }
      }
    }

    isEmpty() {
      // Fast paths
      if (this.buf.length === 0) {
        return true;
      }

      if (this.buf[0] !== '') {
        return false;
      }

      for (const part of this.buf) {
        if (part !== '') {
          return false;
        }
      }

      return true;
    }

    removeTrailing(char) {
      while (this.endsWith(char)) {
        const i = this.buf.length - 1;
        if (this.buf[i] === char) {
          this.buf.pop();
        } else {
          this.buf[i] = this.buf[i].slice(0, -1);
        }

        if (char === '\n') {
          this.position.line = ___R$project$rome$$romejs$ob1$index_ts$dec(this.position.line);

          const lastLine = this.lineLengths.pop();
          this.position.column = lastLine || ___R$project$rome$$romejs$ob1$index_ts$number0;
        } else {
          this.position.column = ___R$project$rome$$romejs$ob1$index_ts$dec(this.position.column);
        }
      }
    }

    removeTrailingNewlines() {
      this.removeTrailing('\n');
    }

    endsWith(suffix) {
      if (this.buf.length === 0) {
        return false;
      }

      let i = this.buf.length - 1;
      let last = this.buf[i];
      while (last.length < suffix.length && i > 0) {
        i--;
        last = this.buf[i] + last;
      }
      return last.endsWith(suffix);
    }

    hasContent() {
      return this.last !== '';
    }

    /**
   * Sets a given position as the current source location so generated code after this call
   * will be given this position in the sourcemap.
   */
    source(prop, loc) {
      if (prop && !loc) {
        return undefined;
      }

      // @ts-ignore
      const pos = loc ? loc[prop] : undefined;

      this.sourcePosition.identifierName = loc && loc.identifierName || undefined;
      this.sourcePosition.line = pos ? pos.line : undefined;
      this.sourcePosition.column = pos ? pos.column : undefined;
      this.sourcePosition.filename = loc && loc.filename || undefined;
    }

    /**
   * Call a callback with a specific source location and restore on completion.
   */
    withSource(prop, loc, cb) {
      // Use the call stack to manage a stack of "source location" data.
      const originalLine = this.sourcePosition.line;
      const originalColumn = this.sourcePosition.column;
      const originalFilename = this.sourcePosition.filename;
      const originalIdentifierName = this.sourcePosition.identifierName;

      this.source(prop, loc);

      cb();

      this.sourcePosition.line = originalLine;
      this.sourcePosition.column = originalColumn;
      this.sourcePosition.filename = originalFilename;
      this.sourcePosition.identifierName = originalIdentifierName;
    }
  }

  // project-rome/@romejs/js-generator/Generator.ts
___R$project$rome$$romejs$js$ast$utils_ts$assertNodeTypeSet(___R$project$rome$$romejs$js$generator$generators$index_ts$default, 'generators');

  const ___R$$priv$project$rome$$romejs$js$generator$Generator_ts$SCIENTIFIC_NOTATION = /e/i;
  const ___R$$priv$project$rome$$romejs$js$generator$Generator_ts$ZERO_DECIMAL_INTEGER = /\.0+$/;
  const ___R$$priv$project$rome$$romejs$js$generator$Generator_ts$NON_DECIMAL_LITERAL = /^0[box]/;

  const ___R$$priv$project$rome$$romejs$js$generator$Generator_ts$MAX_PRETTY_LINE_LENGTH = 80;

  function ___R$$priv$project$rome$$romejs$js$generator$Generator_ts$doesLineExceed(column) {
    // We take off 1 as column is the column that the line ends, which is not a character
    return ___R$project$rome$$romejs$ob1$index_ts$get0(column) - 1 > ___R$$priv$project$rome$$romejs$js$generator$Generator_ts$MAX_PRETTY_LINE_LENGTH;
  }

  class ___R$project$rome$$romejs$js$generator$Generator_ts$default {
    constructor(opts, code) {
      this.buf = new ___R$project$rome$$romejs$js$generator$Buffer_ts$default(opts, code);
      this.currentIndentLevel = opts.indent === undefined ? 0 : opts.indent;
      this.currentLineIndentLevel = this.currentIndentLevel;

      this.options = opts;
      this.inForStatementInitCounter = 0;
      this.inferredNewlines = new Set();
      this.printedCommentStarts = new Set();
      this.printedComments = new Set();
      this.printStack = [];
      this.parenPushNewlineState = undefined;
      this.endsWithInteger = false;
      this.endsWithWord = false;
    }

    indent() {
      this.currentIndentLevel++;
    }

    dedent() {
      this.currentIndentLevel--;
    }

    save() {
      return (
        {
          inForStatementInitCounter: this.inForStatementInitCounter,
          printedCommentStarts: new Set(this.printedCommentStarts),
          printedComments: new Set(this.printedComments),
          inferredNewlines: new Set(this.inferredNewlines),
          printStackIndex: this.printStack.length,
          parenPushNewlineState: this.parenPushNewlineState,
          endsWithInteger: this.endsWithInteger,
          endsWithWord: this.endsWithWord,
          currentIndentLevel: this.currentIndentLevel,
          currentLineIndentLevel: this.currentLineIndentLevel,
          buffer: this.buf.save(),
        }
      );
    }

    restore(snapshot) {
      this.buf.restore(snapshot.buffer);
      this.inForStatementInitCounter = snapshot.inForStatementInitCounter;
      this.printedCommentStarts = snapshot.printedCommentStarts;
      this.printedComments = snapshot.printedComments;
      this.inferredNewlines = snapshot.inferredNewlines;
      this.printStack = this.printStack.slice(0, snapshot.printStackIndex);
      this.parenPushNewlineState = snapshot.parenPushNewlineState;
      this.endsWithInteger = snapshot.endsWithInteger;
      this.endsWithWord = snapshot.endsWithWord;
      this.currentIndentLevel = snapshot.currentIndentLevel;
      this.currentLineIndentLevel = snapshot.currentLineIndentLevel;
    }

    multiline(node, callback, {
      conditions,
      indentTrailingNewline,
      indent,
    } = {}) {
      if (this.options.format !== 'pretty') {
        callback(___R$project$rome$$romejs$js$generator$node$index_ts.isMultiLine(node), node);
        return;
      }

      // If we have the source-had-multiline condition and the original source had multiple lines then assume multiline always
      if (conditions !== undefined && conditions.includes('source-had-multiline') &&
        ___R$project$rome$$romejs$js$generator$node$index_ts.isMultiLine(node)) {
        callback(true, node);
        return;
      }

      const snapshot = this.save();

      callback(false, node);

      let shouldMultiline = false;

      // AKA first-line-exceeds
      if (this.buf.position.line === snapshot.buffer.position.line) {
        shouldMultiline = ___R$$priv$project$rome$$romejs$js$generator$Generator_ts$doesLineExceed(this.buf.position.column);
      } else {
        shouldMultiline =
          ___R$$priv$project$rome$$romejs$js$generator$Generator_ts$doesLineExceed(
            this.buf.lineLengths[snapshot.buffer.lineLengthsIndex],
          );
      }

      if (conditions !== undefined && !shouldMultiline) {
        for (const condition of conditions) {
          switch (condition) {
            case 'more-than-one-line':
              shouldMultiline =
                this.buf.position.line !==
                snapshot.buffer.position.line;
              break;

            case 'any-line-exceeds':
              // Check current line
              shouldMultiline = ___R$$priv$project$rome$$romejs$js$generator$Generator_ts$doesLineExceed(this.buf.position.column);

              // Check previous lines
              for (let i = snapshot.buffer.lineLengthsIndex;
              i < this.buf.lineLengths.length;
              i++) {
                if (shouldMultiline) {
                  break;
                }
                shouldMultiline = ___R$$priv$project$rome$$romejs$js$generator$Generator_ts$doesLineExceed(this.buf.lineLengths[i]);
              }
              break;
          }

          if (shouldMultiline) {
            break;
          }
        }
      }

      if (shouldMultiline) {
        this.restore(snapshot);

        if (indent) {
          this.newline();
          this.indent();
        }

        callback(true, node);

        if (indent) {
          if (indentTrailingNewline) {
            this.newline();
          }
          this.dedent();
        }
      }
    }

    /**
   * Add a semicolon to the buffer.
   */
    semicolon() {
      this.append(';');
    }

    /**
   * Add a right brace to the buffer.
   */
    rightBrace() {
      // TODO remove this?
      this.token('}');
    }

    spaceOrNewline(newline) {
      if (newline) {
        this.newline();
      } else {
        this.space();
      }
    }

    /**
   * Add a space to the buffer unless it is compact.
   */
    space(force = false) {
      if (this.buf.hasContent() && !this.buf.endsWith(' ') &&
        !this.buf.endsWith(
          '\n',
        ) ||
      force) {
        this._space();
      }
    }

    /**
   * Writes a token that can't be safely parsed without taking whitespace into account.
   */
    word(str) {
      if (this.endsWithWord) {
        this.space();
      }

      this.append(str);

      this.endsWithWord = true;
    }

    /**
   * Writes a number token so that we can validate if it is an integer.
   */
    number(str) {
      this.word(str);

      // Integer tokens need special handling because they cannot have '.'s inserted

      // immediately after them.
      this.endsWithInteger =
        Number.isInteger(Number(str)) &&
          !___R$$priv$project$rome$$romejs$js$generator$Generator_ts$NON_DECIMAL_LITERAL.test(str) &&
          !___R$$priv$project$rome$$romejs$js$generator$Generator_ts$SCIENTIFIC_NOTATION.test(str) &&
          !___R$$priv$project$rome$$romejs$js$generator$Generator_ts$ZERO_DECIMAL_INTEGER.test(str) &&
          str[str.length - 1] !== '.';
    }

    /**
   * Writes a simple token.
   */
    token(str) {
      // space is mandatory to avoid outputting <!--

      // http://javascript.spec.whatwg.org/#comment-syntax
      if (str === '--' && this.buf.endsWith('!') ||
      // Need spaces for operators of the same kind to avoid: `a+++b`
      str[0] === '+' && this.buf.endsWith('+') ||
      str[0] === '-' &&
        this.buf.endsWith('-') ||
      // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.
      str[0] === '.' && this.endsWithInteger) {
        this.space();
      }

      this.append(str);
    }

    source(prop, loc) {
      this.buf.source(prop, loc);
    }

    _space() {
      this.append(' ');
    }

    newline() {
      if (!this.buf.endsWith('\n')) {
        this.forceNewline();
      }
    }

    inferredNewline(line) {
      if (this.inferredNewlines.has(line)) {
        return false;
      } else {
        this.inferredNewlines.add(line);
        this.forceNewline();
        return true;
      }
    }

    forceNewline() {
      if (this.buf.isEmpty()) {
        return;
      }

      // Never allow more than two lines
      if (this.buf.endsWith('\n\n')) {
        return;
      }

      //
      if (this.buf.endsWith('{\n') || this.buf.endsWith(':\n')) {
        return;
      }

      if (!this.parenPushNewlineState) {
        this.buf.removeTrailing(' ');
      }
      this.append('\n');
    }

    newlineX(num) {
      if (num >= 1) {
        this.forceNewline();
      }
      if (num >= 2) {
        this.forceNewline();
      }
    }

    append(str) {
      this.maybeAddParen(str);
      this.maybeIndent(str);
      this.buf.append(str);
      this.endsWithWord = false;
      this.endsWithInteger = false;
    }

    maybeIndent(str) {
      // we've got a newline before us so prepend on the indentation
      if (this.buf.endsWith('\n') && str[0] !== '\n') {
        if (this.currentIndentLevel > 0) {
          this.buf.append(this.getIndent());
          this.currentLineIndentLevel = this.currentIndentLevel;
        } else {
          this.currentLineIndentLevel = 0;
        }
      }
    }

    maybeAddParen(str) {
      // see startTerminatorless() instance method
      const parenPushNewlineState = this.parenPushNewlineState;
      if (!parenPushNewlineState) {
        return undefined;
      }
      this.parenPushNewlineState = undefined;

      let i;
      for (i = 0;
      i < str.length && str[i] === ' ';
      i++) {
        continue;
      }
      if (i === str.length) {
        return undefined;
      }

      const cha = str[i];
      if (cha === '\n' || cha === '/') {
        // we're going to break this terminator expression so we need to add a parentheses
        this.token('(');
        this.indent();
        parenPushNewlineState.printed = true;
      }
    }

    /**
   * Get the current indent.
   */
    getIndent() {
      return '  '.repeat(this.currentIndentLevel);
    }

    /**
   * Set some state that will be modified if a newline has been inserted before any
   * non-space characters.
   *
   * This is to prevent breaking semantics for terminatorless separator nodes. eg:
   *
   *    return foo;
   *
   * returns `foo`. But if we do:
   *
   *   return
   *   foo;
   *
   *  `undefined` will be returned and not `foo` due to the terminator.
   */
    startTerminatorless() {
      return (
        this.parenPushNewlineState =
          {
            printed: false,
          }
      );
    }

    /**
   * Print an ending parentheses if a starting one has been printed.
   */
    endTerminatorless(state) {
      if (state.printed) {
        this.dedent();
        this.forceNewline();
        this.token(')');
      }
    }

    // If the passed in node exists then print a colon followed by the node
    printTypeColon(node, parent) {
      if (node !== undefined) {
        this.token(':');
        this.space();
        this.print(node, parent);
      }
    }

    maybeCommentNewlines(node, comment, trailing) {
      if (comment === undefined) {
        return;
      }

      const lines = ___R$project$rome$$romejs$js$generator$node$index_ts.getLinesBetween(node, comment);

      // BlockComment already has a newline
      if (lines.length >= 1 && (comment.type !== 'CommentLine' || trailing)) {
        this.inferredNewline(lines[0]);
      }

      if (lines.length >= 2) {
        this.inferredNewline(lines[1]);
      }
    }

    print(node, parent, beforeTrailing, includeTrailingComments = true) {
      if (node === undefined) {
        return;
      }

      if (this.options.typeAnnotations === false && ___R$project$rome$$romejs$js$ast$utils$isTypeNode_ts$default(node) &&
        !___R$project$rome$$romejs$js$ast$utils$isTypeExpressionWrapperNode_ts$default(node)) {
        return;
      }

      const printMethod = ___R$project$rome$$romejs$js$generator$generators$index_ts$default.get(
        node.type,
      );
      if (printMethod === undefined) {
        throw (
          new Error(
            'No known generator for node ' +
            node.type +
            ' with parent ' +
            parent.type,
          )
        );
      }

      this.printStack.push(node);

      const needsParens = ___R$project$rome$$romejs$js$generator$node$index_ts.needsParens(node, parent, this.printStack);

      if (needsParens) {
        this.token('(');
      }

      const loc = node.type === 'Program' ? undefined : node.loc;

      const leadingComments = this.getComments(true, node);
      this.printComments(leadingComments);

      // If leading comment had an empty line after then retain it
      if (leadingComments !== undefined) {
        this.maybeCommentNewlines(
          node,
          leadingComments[leadingComments.length - 1],
          false,
        );
      }

      this.buf.withSource(
        'start',
        loc,
        () => {
          printMethod(this, node, parent);
        },
      );

      if (needsParens) {
        this.token(')');
      }

      if (beforeTrailing !== undefined) {
        beforeTrailing();
      }

      // If there's an empty line between the node and it's trailing comments then keep it
      if (includeTrailingComments) {
        const trailingComments = this.getComments(false, node);
        if (trailingComments !== undefined) {
          this.maybeCommentNewlines(node, trailingComments[0], true);
        }
        this.printComments(trailingComments);
      }

      this.printStack.pop();
    }

    printJoin(nodes, parent, opts = {}) {
      if (!nodes || !nodes.length) {
        return undefined;
      }

      if (opts.indent === true) {
        this.indent();
      }

      if (opts.multiline === true) {
        this.forceNewline();
      }

      let isLastNode = false;
      let i = 0;

      let printAfter;
      if (opts.after !== undefined) {
        printAfter =
          () => {
            if (opts.after) {
              opts.after(this, isLastNode);
            }
          };
      }

      while (i < nodes.length) {
        const node = nodes[i];
        isLastNode = i === nodes.length - 1;

        if (node === undefined) {
          if (printAfter !== undefined) {
            printAfter();
          }
        } else {
          this.print(node, parent, printAfter);

          if (opts.multiline === true) {
            let nextNode = (nodes[i + 1]);

            // Don't print a newline if the next node has a leadingComment that begins on the same line as this node
            let hasNextTrailingCommentOnSameLine = false;

            // Lots of refinements...
            if (nextNode !== undefined && node.loc !== undefined &&
              nextNode.loc !== undefined &&
              nextNode.leadingComments !== undefined) {
              const firstNextNodeLeadingComments = nextNode.leadingComments[0];
              if (firstNextNodeLeadingComments !== undefined &&
                firstNextNodeLeadingComments.loc !== undefined) {
                nextNode = firstNextNodeLeadingComments;
                hasNextTrailingCommentOnSameLine =
                  node.loc.end.line ===
                  firstNextNodeLeadingComments.loc.start.line;
              }
            }

            if (!hasNextTrailingCommentOnSameLine) {
              this.newline();
            }

            this.maybeInsertExtraStatementNewlines(node, nextNode);
          }
        }

        i++;
      }

      if (opts.indent === true) {
        this.dedent();
      }
    }

    maybeInsertExtraStatementNewlines(node, nextNode) {
      // Insert an inferred newline or extra if it satisfies our conditions
      const linesBetween = ___R$project$rome$$romejs$js$generator$node$index_ts.getLinesBetween(node, nextNode);
      if (linesBetween.length > 1) {
        this.inferredNewline(linesBetween[1]);
        return;
      }

      if (___R$project$rome$$romejs$js$generator$node$index_ts.hasExtraLineBetween(node)) {
        this.forceNewline();
      }
    }

    printBlock(parent) {
      const node = parent.body;

      if (node.type !== 'EmptyStatement') {
        this.space();
      }

      this.print(node, parent);
    }

    printStatementList(nodes, parent, opts = {}) {
      return this.printJoin(nodes, parent, Object.assign(
        {
        },
        opts,
        {
          multiline: true,
        },
      ));
    }

    printCommaList(items, parent, opts = {}) {
      if (!items || !items.length) {
        return undefined;
      }

      const print = (multiline) => {
        function separator(generator, isLast) {
          if (isLast && (!opts.trailing || !multiline)) {
            return;
          }

          generator.token(',');
          if (!multiline) {
            generator.space();
          }
        }

        this.printJoin(
          items,
          parent,
          {
            after: separator,
            indent: multiline,
            multiline,
          },
        );
      };

      if (opts.multiline === undefined) {
        this.multiline(parent, print);
      } else {
        print(opts.multiline);
      }
    }

    printInnerComments(node, indent = true) {
      const {innerComments} = node;
      if (innerComments === undefined) {
        return;
      }

      if (indent) {
        this.indent();
      }

      if (___R$project$rome$$romejs$js$generator$node$index_ts.getLinesBetween(node, innerComments[0])) {
        this.forceNewline();
      }

      this.printComments(innerComments);

      if (indent) {
        this.dedent();
      }
    }

    printComments(comments) {
      if (!comments || !comments.length) {
        return undefined;
      }

      for (let i = 0;
      i < comments.length;
      i++) {
        const comment = comments[i];
        this.printComment(comment);

        const nextComment = comments[i + 1];
        if (nextComment !== undefined) {
          this.maybeCommentNewlines(comment, nextComment, true);
        }
      }
    }

    getComments(leading, node) {
      if (!node) {
        return undefined;
      }

      const comments = leading ? node.leadingComments : node.trailingComments;
      if (!comments) {
        return undefined;
      }

      return (
        comments.filter(
          (comment) => {
            return !this.hasPrintedComment(comment);
          },
        )
      );
    }

    hasPrintedComment(comment) {
      if (!comment) {
        return true;
      }

      if (this.printedComments.has(comment)) {
        return true;
      }

      if (comment.loc !== undefined &&
        this.printedCommentStarts.has(
          comment.loc.start.index,
        )) {
        return true;
      }

      return false;
    }

    printComment(comment) {
      if (this.hasPrintedComment(comment)) {
        return;
      }

      this.printedComments.add(comment);

      if (comment.loc !== undefined) {
        this.printedCommentStarts.add(comment.loc.start.index);
      }

      if (!this.buf.endsWith('[') && !this.buf.endsWith('{')) {
        this.space();
      }

      // Avoid creating //* comments
      if (this.buf.endsWith('/')) {
        this.space();
      }

      this.buf.withSource(
        'start',
        comment.loc,
        () => {
          const isBlockComment = comment.type === 'CommentBlock';
          const val = isBlockComment
            ? '/*' +
            comment.value +
            '*/' : '//' +
            comment.value +
            '\n';
          this.append(val);
        },
      );
    }
  }

  // project-rome/@romejs/js-generator/index.ts
function ___R$project$rome$$romejs$js$generator$index_ts$generateJS(
    ast,
    opts,
    code = '',
  ) {
    const generator = new ___R$project$rome$$romejs$js$generator$Generator_ts$default(opts, code);
    generator.print(ast, ___R$project$rome$$romejs$js$ast$temp$MockParent_ts$MOCK_PARENT);
    return generator;
  }

  // project-rome/@romejs/js-compiler/suppressions.ts
const ___R$$priv$project$rome$$romejs$js$compiler$suppressions_ts$SUPPRESSION_START = 'rome-suppress';
  const ___R$$priv$project$rome$$romejs$js$compiler$suppressions_ts$PREFIX_MISTAKES = ['@rome-suppress', 'rome-ignore', '@rome-ignore'];

  function ___R$$priv$project$rome$$romejs$js$compiler$suppressions_ts$extractSuppressionsFromComment(
    comment,
  ) {
    const {loc} = comment;
    if (loc === undefined) {
      return undefined;
    }

    const suppressedCategories = new Set();
    const diagnostics = [];
    const suppressions = [];

    const lines = comment.value.split('\n');
    const cleanLines = lines.map(
      (line) => {
        // Trim line and remove leading star
        return line.trim().replace(/\*[\s]/, '');
      },
    );

    for (const line of cleanLines) {
      if (!line.startsWith(___R$$priv$project$rome$$romejs$js$compiler$suppressions_ts$SUPPRESSION_START)) {
        for (const prefix of ___R$$priv$project$rome$$romejs$js$compiler$suppressions_ts$PREFIX_MISTAKES) {
          if (line.startsWith(prefix)) {
            diagnostics.push(
              Object.assign(
                {
                  category: 'suppressions/incorrectPrefix',
                  message: 'Invalid suppression prefix <emphasis>' +
                  prefix +
                  '</emphasis>',
                  advice: [
                    {
                      type: 'log',
                      category: 'info',
                      message: 'Did you mean <emphasis>' +
                      ___R$$priv$project$rome$$romejs$js$compiler$suppressions_ts$SUPPRESSION_START +
                      '</emphasis>?',
                    },
                  ],
                },
                loc,
              ),
            );
          }
        }
        continue;
      }

      const categories = line.slice(___R$$priv$project$rome$$romejs$js$compiler$suppressions_ts$SUPPRESSION_START.length).trim().split(' ');
      const cleanCategories = categories.map((category) => category.trim());

      for (let category of cleanCategories) {
        if (category === '') {
          continue;
        }

        // If a category ends with a colon then all the things that follow it are an explanation
        let shouldBreak = false;
        if (category[category.length - 1] === ':') {
          shouldBreak = true;
          category = category.slice(-1);
        }

        if (suppressedCategories.has(category)) {
          diagnostics.push(
            Object.assign(
              {
                category: 'suppressions/duplicate',
                message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Duplicate suppression category <emphasis>${category}</emphasis>`,
              },
              loc,
            ),
          );
        } else {
          suppressedCategories.add(category);

          suppressions.push(
            {
              category,
              loc,
            },
          );
        }

        if (shouldBreak) {
          break;
        }
      }
    }

    if (suppressions.length === 0 && diagnostics.length === 0) {
      return undefined;
    } else {
      return {diagnostics, suppressions};
    }
  }

  function ___R$project$rome$$romejs$js$compiler$suppressions_ts$extractSuppressionsFromComments(
    comments,
  ) {
    let diagnostics = [];
    let suppressions = [];

    for (const comment of comments) {
      const result = ___R$$priv$project$rome$$romejs$js$compiler$suppressions_ts$extractSuppressionsFromComment(comment);
      if (result !== undefined) {
        diagnostics = diagnostics.concat(result.diagnostics);
        suppressions = suppressions.concat(result.suppressions);
      }
    }

    return {suppressions, diagnostics};
  }

  function ___R$project$rome$$romejs$js$compiler$suppressions_ts$extractSuppressionsFromProgram(
    ast,
  ) {
    return ___R$project$rome$$romejs$js$compiler$suppressions_ts$extractSuppressionsFromComments(ast.comments);
  }

  // project-rome/@romejs/js-compiler/api/lint.ts
const ___R$$priv$project$rome$$romejs$js$compiler$api$lint_ts$lintCache = new ___R$project$rome$$romejs$js$compiler$lib$Cache_ts$default();

  async function ___R$project$rome$$romejs$js$compiler$api$lint_ts$default(req) {
    const {ast, sourceText, project, format} = req;

    const query = ___R$project$rome$$romejs$js$compiler$lib$Cache_ts$default.buildQuery(req);
    const cached = ___R$$priv$project$rome$$romejs$js$compiler$api$lint_ts$lintCache.get(query);
    if (cached) {
      return cached;
    }

    if (ast.corrupt) {
      const result = {
        suppressions: [],
        diagnostics: [...ast.diagnostics],
        src: req.sourceText,
      };
      ___R$$priv$project$rome$$romejs$js$compiler$api$lint_ts$lintCache.set(query, result);
      return result;
    }

    let formattedCode = sourceText;
    if (format) {
      // Perform autofixes
      const context = new ___R$project$rome$$romejs$js$compiler$lib$Context_ts$default(
        {
          ast,
          project,
          origin: {
            category: 'lint',
          },
        },
      );
      const newAst = ___R$project$rome$$romejs$js$ast$core$Program_ts$program.assert(
        context.reduce(
          ast,
          ___R$project$rome$$romejs$js$compiler$transforms$lint$index_ts$lintTransforms,
          {
            frozen: false,
          },
        ),
      );

      const generator = ___R$project$rome$$romejs$js$generator$index_ts$generateJS(
        newAst,
        {
          typeAnnotations: true,
          format: 'pretty',
        },
        sourceText,
      );
      formattedCode = generator.buf.getCode();
    }

    // Run lints (could be with the autofixed AST)
    const context = new ___R$project$rome$$romejs$js$compiler$lib$Context_ts$default(
      {
        ast,
        project,
        origin: {
          category: 'lint',
        },
      },
    );
    ___R$project$rome$$romejs$js$ast$core$Program_ts$program.assert(context.reduce(ast, ___R$project$rome$$romejs$js$compiler$transforms$lint$index_ts$lintTransforms, {frozen: true}));

    const extractedSuppressions = ___R$project$rome$$romejs$js$compiler$suppressions_ts$extractSuppressionsFromProgram(ast);

    const result = {
      suppressions: extractedSuppressions.suppressions,
      diagnostics: [
        ...ast.diagnostics,
        ...context.diagnostics,
        ...extractedSuppressions.diagnostics,
      ],
      src: formattedCode,
    };
    ___R$$priv$project$rome$$romejs$js$compiler$api$lint_ts$lintCache.set(query, result);
    return result;
  }

  // project-rome/@romejs/js-compiler/transforms/compile/transpile/classProperties.ts
function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$hasClassProps(node) {
    for (const bodyNode of node.meta.body) {
      if (bodyNode.type === 'ClassProperty') {
        return true;
      }
    }

    return false;
  }

  function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$createConstructor(
    rest,
    body,
  ) {
    return (
      ___R$project$rome$$romejs$js$ast$classes$ClassMethod_ts$classMethod.create(
        {
          kind: 'constructor',
          key: ___R$project$rome$$romejs$js$ast$objects$StaticPropertyKey_ts$staticPropertyKey.quick(___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.quick('constructor')),
          meta: ___R$project$rome$$romejs$js$ast$classes$ClassPropertyMeta_ts$classPropertyMeta.create({}),
          head: ___R$project$rome$$romejs$js$ast$auxiliary$FunctionHead_ts$functionHead.create({params: [], rest}),
          body: ___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts$blockStatement.create({body}),
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$toExpressionStatements(
    expressions,
  ) {
    return (
      expressions.map(
        (expr) => {
          return ___R$project$rome$$romejs$js$ast$statements$ExpressionStatement_ts$expressionStatement.create({expression: expr});
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$isSuperCall(node) {
    return node.type === 'CallExpression' && node.callee.type === 'Super';
  }

  function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$transformClass(
    node,
    scope,
    context,
  ) {
    const bodyReplacements = [];
    const constructorAssignments = [];
    const className = node.id === undefined
      ? scope.generateUid('class') : node.id.name;

    let _constructor = undefined;
    const filteredClassBody = [];
    for (const bodyNode of node.meta.body) {
      if (bodyNode.type === 'ClassMethod' && bodyNode.kind === 'constructor') {
        _constructor = bodyNode;
        continue;
      }

      if (bodyNode.type === 'ClassProperty') {
        if (bodyNode.value === undefined) {
          continue;
        }

        if (bodyNode.key.type === 'ComputedPropertyKey') {
          if (bodyNode.meta.static === true) {
            bodyReplacements.push(
              ___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`${className}[${bodyNode.key.value}] = ${bodyNode.value};`,
            );
          } else {
            constructorAssignments.push(
              ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`this[${bodyNode.key.value}] = ${bodyNode.value};`,
            );
          }
        } else {
          if (bodyNode.meta.static === true) {
            bodyReplacements.push(
              ___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`${className}.${bodyNode.key.value} = ${bodyNode.value};`,
            );
          } else {
            constructorAssignments.push(
              ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`this.${bodyNode.key.value} = ${bodyNode.value};`,
            );
          }
        }
      } else {
        filteredClassBody.push(bodyNode);
      }
    }

    if (constructorAssignments.length) {
      if (node.meta.superClass !== undefined) {
        if (_constructor) {
          const visited = new Set();

          // find super() and insert assignments
          const reducedConstructor = context.reduce(
            _constructor,
            [
              {
                name: 'classPropertiesInjector',
                enter(path) {
                  const {node} = path;

                  if (visited.has(node)) {
                    return node;
                  }

                  if (___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$isSuperCall(node) && path.parent.type !== 'ExpressionStatement') {
                    visited.add(node);

                    // TODO retain proper value of super()
                    return (
                      ___R$project$rome$$romejs$js$ast$expressions$SequenceExpression_ts$sequenceExpression.create(
                        {
                          expressions: [node, ...constructorAssignments],
                        },
                      )
                    );
                  }

                  if (node.type === 'ExpressionStatement' &&
                    ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$isSuperCall(
                      node.expression,
                    )) {
                    visited.add(node);

                    return (
                      ([
                        node,
                        ...___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$toExpressionStatements(constructorAssignments),
                      ])
                    );
                  }

                  return node;
                },
              },
            ],
          );
          _constructor = ___R$project$rome$$romejs$js$ast$classes$ClassMethod_ts$classMethod.assert(reducedConstructor);
        } else {
          // create new constructor with a super() call and assignments
          _constructor =
            ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$createConstructor(
              ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.quick('args'),
              [
                ___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`super(...args);`,
                ...___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$toExpressionStatements(constructorAssignments),
              ],
            );
        }
      } else {
        if (_constructor) {
          // add assignments to end of constructor
          _constructor =
            Object.assign(
              {
              },
              _constructor,
              {
                body: Object.assign(
                  {
                  },
                  _constructor.body,
                  {
                    body: [
                      ...___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$toExpressionStatements(constructorAssignments),
                      ..._constructor.body.body,
                    ],
                  },
                ),
              },
            );
        } else {
          // create new constructor with just the assignments
          _constructor =
            ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$createConstructor(
              undefined,
              ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$toExpressionStatements(
                constructorAssignments,
              ),
            );
        }
      }
    }

    if (_constructor !== undefined) {
      filteredClassBody.unshift(_constructor);
    }

    const newClass = Object.assign(
      {
      },
      node,
      {
        id: node.id !== undefined && node.id.name === className
          ? node.id : ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.create(
            {
              name: className,
            },
          ),
        meta: Object.assign(
          {
          },
          node.meta,
          {
            body: filteredClassBody,
          },
        ),
      },
    );

    return (
      {
        newClass,
        className,
        declarations: bodyReplacements,
      }
    );
  }

  const ___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$default = {
    name: 'classProperties',
    enter(path) {
      const {node, scope, context} = path;

      // correctly replace an export class with the class node then append the declarations
      if ((node.type === 'ExportLocalDeclaration' ||
      node.type ===
      'ExportDefaultDeclaration') &&
        node.declaration !== undefined &&
        node.declaration.type === 'ClassDeclaration' &&
        ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$hasClassProps(
          node.declaration,
        )) {
        const {newClass, declarations} = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$transformClass(
          node.declaration,
          scope,
          context,
        );
        return (
          ([
            Object.assign(
              {
              },
              node,
              {
                declaration: newClass,
              },
            ),
            ...declarations,
          ])
        );
      }

      // turn a class expression into an IIFE that returns a class declaration
      if (node.type === 'ClassExpression' && ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$hasClassProps(node)) {
        const className = node.id === undefined
          ? scope.generateUid('class') : node.id.name;

        return (
          ___R$project$rome$$romejs$js$ast$expressions$CallExpression_ts$callExpression.create(
            {
              callee: ___R$project$rome$$romejs$js$ast$expressions$ArrowFunctionExpression_ts$arrowFunctionExpression.create(
                {
                  head: ___R$project$rome$$romejs$js$ast$auxiliary$FunctionHead_ts$functionHead.quick([]),
                  body: ___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts$blockStatement.create(
                    {
                      body: [
                        Object.assign(
                          {
                          },
                          node,
                          {
                            type: 'ClassDeclaration',
                            id: ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.quick(className),
                          },
                        ),
                        ___R$project$rome$$romejs$js$ast$statements$ReturnStatement_ts$returnStatement.create(
                          {
                            argument: ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(className),
                          },
                        ),
                      ],
                    },
                  ),
                },
              ),
              arguments: [],
            },
          )
        );
      }

      if (node.type === 'ClassDeclaration' && ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$hasClassProps(node)) {
        const {newClass, declarations} = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$transformClass(node, scope, context);
        return ([newClass, ...declarations]);
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/compile/transpile/paramlessCatch.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$paramlessCatch_ts$default = {
    name: 'paramlessCatch',

    enter(path) {
      const {node} = path;

      if (node.type === 'CatchClause' && node.param === undefined) {
        return (
          Object.assign(
            {
            },
            node,
            {
              param: ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.create(
                {
                  name: path.scope.generateUid(),
                },
              ),
            },
          )
        );
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/compile/transpile/optionalChaining.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$optionalChaining_ts$default = {
    name: 'optionalChaining',

    enter(path) {
      const {node} = path;

      if (node.type === 'MemberExpression' && node.property.optional) {
        // TODO assign `node.object` to a variable and use it as a reference
        if (node.property.type === 'ComputedMemberProperty') {
          return (
            ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`${node.object} == null ? undefined : ${node.object}[${node.property.value}]`
          );
        } else {
          return (
            ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`${node.object} == null ? undefined : ${node.object}.${node.property.value}`
          );
        }
      }

      if (node.type === 'OptionalCallExpression') {
        // TODO assign `node.callee` to a variable and use it as a reference
        return (
          ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`${node.callee} == null ? undefined : ${___R$project$rome$$romejs$js$ast$expressions$CallExpression_ts$callExpression.create(
            {
              callee: node.callee,
              arguments: node.arguments,
            },
          )}`
        );
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/compile/transpile/nullishCoalescing.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$nullishCoalescing_ts$default = {
    name: 'nullishCoalescing',

    enter(path) {
      const {node} = path;

      if (node.type === 'LogicalExpression' && node.operator === '??') {
        // TODO assign `node.left` to a variable and use it as a reference
        return (
          ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`${node.left} == null ? ${node.right} : ${node.left}`
        );
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/defaultHooks/index.ts
const ___R$project$rome$$romejs$js$compiler$transforms$defaultHooks$index_ts$bindingInjector = ___R$project$rome$$romejs$js$compiler$api$createHook_ts$default(
    {
      name: 'bindingInjectorHook',

      initialState: {
        bindings: [],
      },

      call(path, state, opts = {}) {
        const name = opts.name === undefined ? path.scope.generateUid() : opts.name;

        const ref = ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(name);

        // lol
        const ass = ___R$project$rome$$romejs$js$ast$patterns$AssignmentIdentifier_ts$assignmentIdentifier.quick(name);

        return (
          {
            value: [ref, ass],
            state: {
              bindings: [...state.bindings, [name, opts.init]],
            },
          }
        );
      },

      exit(path, state) {
        const {node} = path;

        if (node.type !== 'BlockStatement' && node.type !== 'Program') {
          throw new Error('Never should have been used as a provider');
        }

        const {bindings} = state;
        if (bindings.length === 0) {
          return node;
        }

        return (
          Object.assign(
            {
            },
            node,
            {
              body: [
                ___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement.quick(
                  ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.create(
                    {
                      kind: 'var',
                      declarations: bindings.map(
                        ([name, init]) => {
                          return (
                            ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator.create(
                              {
                                id: ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.quick(name),
                                init,
                              },
                            )
                          );
                        },
                      ),
                    },
                  ),
                ),

                ...node.body,
              ],
            },
          )
        );
      },
    },
  );

  const ___R$project$rome$$romejs$js$compiler$transforms$defaultHooks$index_ts$variableInjectorVisitor = {
    name: 'variableInjector',
    enter(path) {
      const {node} = path;

      if (node.type === 'BlockStatement' || node.type === 'Program') {
        path.provideHook(___R$project$rome$$romejs$js$compiler$transforms$defaultHooks$index_ts$bindingInjector);
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/compile/transpile/callSpread.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$callSpread_ts$default = {
    name: 'callSpread',

    enter(path) {
      const {node} = path;

      if (node.type === 'CallExpression') {
        let func = node.callee;

        // Impossible to transform a bare super call
        if (func.type === 'Super') {
          return node;
        }

        let hasSpread = false;
        for (const arg of node.arguments) {
          if (arg.type === 'SpreadElement') {
            hasSpread = true;
            break;
          }
        }
        if (hasSpread) {
          let prepend;

          let object;
          if (func.type === 'MemberExpression') {
            const injection = path.callHook(___R$project$rome$$romejs$js$compiler$transforms$defaultHooks$index_ts$bindingInjector, {});
            object = injection[0];

            prepend =
              ___R$project$rome$$romejs$js$ast$expressions$AssignmentExpression_ts$assignmentExpression.create(
                {
                  operator: '=',
                  left: injection[1],
                  right: func.object,
                },
              );

            func =
              ___R$project$rome$$romejs$js$ast$expressions$MemberExpression_ts$memberExpression.create(
                {
                  object,
                  property: func.property,
                },
              );
          } else {
            object = ___R$project$rome$$romejs$js$ast$literals$NullLiteral_ts$nullLiteral.create({});
          }

          let call = {
            type: 'CallExpression',
            loc: node.loc,
            callee: ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`${func}.apply`,
            arguments: [
              object,
              ___R$project$rome$$romejs$js$ast$expressions$ArrayExpression_ts$arrayExpression.create({elements: node.arguments}),
            ],
          };

          if (prepend === undefined) {
            return call;
          } else {
            return (
              ___R$project$rome$$romejs$js$ast$expressions$SequenceExpression_ts$sequenceExpression.create(
                {
                  expressions: [prepend, call],
                },
              )
            );
          }
        }
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/compile/transpile/templateLiterals.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$templateLiterals_ts$default = {
    name: 'templateLiterals',
    enter(path) {
      const {node, parent} = path;

      if (node.type === 'TaggedTemplateExpression') {
        // TODO
      }

      if (node.type === 'TemplateLiteral' &&
        parent.type !==
        'TaggedTemplateExpression') {
        const nodes = [];
        const {expressions, quasis} = node;

        let index = 0;
        for (const elem of quasis) {
          if (elem.cooked) {
            nodes.push(
              ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.create(
                {
                  value: elem.cooked,
                },
              ),
            );
          }

          if (index < expressions.length) {
            const expr = expressions[index++];
            if (expr.type !== 'StringLiteral' || expr.value !== '') {
              nodes.push(expr);
            }
          }
        }

        if (nodes.length === 1) {
          return nodes[0];
        }

        // Since `+` is left-to-right associative, nsure the first node is a string if first/second isn't
        if (nodes[0].type !== 'StringLiteral' && nodes[1].type !== 'StringLiteral') {
          nodes.unshift(___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.quick(''));
        }

        // Build the final expression
        let root = nodes[0];
        for (let i = 1;
        i < nodes.length;
        i++) {
          root =
            ___R$project$rome$$romejs$js$ast$expressions$BinaryExpression_ts$binaryExpression.create(
              {
                operator: '+',
                left: root,
                right: nodes[i],
              },
            );
        }
        return root;
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/compile/transpile/objectSpread.ts
function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$hasSpreadProperty(props) {
    for (const prop of props) {
      if (prop.type === 'SpreadProperty') {
        return true;
      }
    }
    return false;
  }

  function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$getRestProperty(
    node,
  ) {
    if (node === undefined) {
      return undefined;
    }

    switch (node.type) {
      case 'VariableDeclarator':
        return ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$getRestProperty(node.id);

      case 'VariableDeclarationStatement':
        return ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$getRestProperty(node.declaration);

      case 'VariableDeclaration':
        for (const declarator of node.declarations) {
          const rest = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$getRestProperty(declarator);
          if (rest !== undefined) {
            return rest;
          }
        }
        return undefined;

      case 'BindingObjectPattern':
        return node.rest;
    }
  }

  function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$transformSpreadProperty(
    path,
    node,
  ) {
    let props = [];
    const assignArgs = [];

    function pushProps() {
      if (props.length === 0 && assignArgs.length > 0) {
        return undefined;
      }

      assignArgs.push(___R$project$rome$$romejs$js$ast$objects$ObjectExpression_ts$objectExpression.create({properties: props}));

      props = [];
    }

    for (const prop of node.properties) {
      if (prop.type === 'SpreadProperty') {
        pushProps();
        assignArgs.push(prop.argument);
      } else {
        props.push(prop);
      }
    }

    pushProps();

    return (
      ___R$project$rome$$romejs$js$ast$expressions$CallExpression_ts$callExpression.create(
        {
          callee: ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`Object.assign`,
          arguments: assignArgs,
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$transformRestProperty(
    path,
    node,
  ) {
    const nodes = [];

    for (const declarator of node.declarations) {
      const restElem = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$getRestProperty(declarator);

      if (restElem === undefined || declarator.id.type !== 'BindingObjectPattern') {
        nodes.push(
          ___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement.quick(
            ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.create(
              {
                kind: node.kind,
                declarations: [declarator],
              },
            ),
          ),
        );
        continue;
      }

      const uid = path.scope.generateUid();

      // push on the initial declaration so we can reference it later
      nodes.push(
        ___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement.quick(
          ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.create(
            {
              kind: node.kind,
              declarations: [
                ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator.create(
                  {
                    id: ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.create(
                      {
                        name: uid,
                      },
                    ),
                    init: declarator.init,
                  },
                ),
              ],
            },
          ),
        ),
      );

      // fetch all the previous prop names
      const removeProps = [];
      for (const prop of declarator.id.properties) {
        if (prop.type === 'BindingObjectPatternProperty') {
          if (prop.key.type === 'ComputedPropertyKey' ||
          prop.key.value.type !==
          'Identifier') {
            throw new Error('unimplemented');
          } else {
            removeProps.push(prop.key.value.name);
          }
        }
      }

      // clone the init to the rest element
      const restName = restElem.name;
      nodes.push(
        ___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement.quick(
          ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.create(
            {
              kind: node.kind,
              declarations: [
                ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator.create(
                  {
                    id: ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.quick(restName),
                    init: ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`Object.assign({}, ${uid})`,
                  },
                ),
              ],
            },
          ),
        ),
      );

      // `delete` the properties
      for (const name of removeProps) {
        nodes.push(___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`delete ${restName}.${name};`);
      }

      // push on the initial destructuring without the rest element
      nodes.push(
        ___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement.quick(
          ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.create(
            {
              kind: node.kind,
              declarations: [
                ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator.create(
                  {
                    id: ___R$project$rome$$romejs$js$ast$patterns$BindingObjectPattern_ts$bindingObjectPattern.create(
                      {
                        properties: declarator.id.properties,
                        rest: undefined,
                      },
                    ),
                    init: ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(uid),
                  },
                ),
              ],
            },
          ),
        ),
      );
    }

    return nodes;
  }

  const ___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$default = {
    name: 'objectSpread',
    enter(path) {
      const {node} = path;

      if (node.type === 'VariableDeclarationStatement' &&
        ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$getRestProperty(node) !== undefined) {
        return ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$transformRestProperty(path, node.declaration);
      }

      if (node.type === 'ObjectExpression' && ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$hasSpreadProperty(node.properties)) {
        return ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$transformSpreadProperty(path, node);
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/compile/validation/optimizeImports.ts
// TODO: Remove this. This contains React for the following reason:
  //   A user may write: import * as React from 'react';

  //   We will remove the namespace and have only the used specifiers

  //   But the JSX plugin inserts `React.createElement`. Oh no.
  const ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$validation$optimizeImports_ts$IGNORED_NAMES = ['React', 'react'];

  function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$validation$optimizeImports_ts$getName(node) {
    if (node.type !== 'MemberExpression' && node.type !== 'JSXMemberExpression') {
      return;
    }

    const {property} = node;

    if (property.type === 'ComputedMemberProperty') {
      if (property.value.type === 'StringLiteral') {
        return property.value.value;
      }
    } else {
      if (___R$project$rome$$romejs$js$ast$utils$isIdentifierish_ts$default(property)) {
        return property.name;
      }
    }
  }

  const ___R$project$rome$$romejs$js$compiler$transforms$compile$validation$optimizeImports_ts$default = {
    name: 'optimizeImports',
    enter(path) {
      const {node} = path;

      if (node.type !== 'Program') {
        return node;
      }

      // Check if we have any wildcard imports
      const wildcardImports = new Map();
      const wildcardImportNodeToLocal = new Map();
      for (const child of node.body) {
        if (child.type === 'ImportDeclaration' &&
          !___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$validation$optimizeImports_ts$IGNORED_NAMES.includes(
            child.source.value,
          ) &&
          child.specifiers !== undefined) {
          for (const specifier of child.specifiers) {
            if (specifier.type === 'ImportNamespaceSpecifier') {
              wildcardImports.set(
                specifier.local.name.name,
                {
                  binding: path.scope.getBindingAssert(specifier.local.name.name),
                  names: new Set(),
                  mappings: new Map(),
                  references: new Set(),
                },
              );
              wildcardImportNodeToLocal.set(child, specifier.local.name.name);
            }
          }
        }
      }
      if (wildcardImports.size === 0) {
        return node;
      }

      // - Find all imported names from this namespace

      // - Remove the namespaces that have computed property access
      path.traverse(
        'optimizeImportsWildcardCollector',
        (path) => {
          const {node, parent} = path;
          if (node.type !== 'ReferenceIdentifier') {
            return;
          }

          // Ensure we're referencing a wildcard import
          const wildcardInfo = wildcardImports.get(node.name);
          if (wildcardInfo === undefined) {
            return;
          }

          // Ensure that the binding hasn't been shadowed
          if (path.scope.getBinding(node.name) !== wildcardInfo.binding) {
            return;
          }

          const isComputed = parent.type === 'MemberExpression' &&
            parent.object ===
            node &&
            ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$validation$optimizeImports_ts$getName(parent) === undefined;
          const isUnboxed = parent.type !== 'MemberExpression' &&
            parent.type !==
            'JSXMemberExpression';

          if (isComputed || isUnboxed) {
            // Deopt as we can't follow this
            wildcardImports.delete(node.name);
          } else {
            const name = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$validation$optimizeImports_ts$getName(parent);
            if (name === undefined) {
              throw new Error('Expected name');
            }
            wildcardInfo.names.add(name);
            wildcardInfo.references.add(parent);
          }
        },
      );
      if (wildcardImports.size === 0) {
        return node;
      }

      // Populate the `mappings` field with a uid
      for (const info of wildcardImports.values()) {
        for (const name of info.names) {
          info.mappings.set(name, path.scope.generateUid(name));
        }
      }

      return (
        path.reduce(
          {
            name: 'optimizeImportWilcards',
            enter(path) {
              const {node} = path;

              // Replace all member expressions with their uids
              if ((node.type === 'MemberExpression' ||
              node.type ===
              'JSXMemberExpression') &&
                ___R$project$rome$$romejs$js$ast$utils$isIdentifierish_ts$default(node.object)) {
                const wildcardInfo = wildcardImports.get(node.object.name);
                if (wildcardInfo !== undefined && wildcardInfo.references.has(node)) {
                  const name = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$validation$optimizeImports_ts$getName(node);
                  if (name === undefined) {
                    throw new Error('Expected name');
                  }

                  const newName = wildcardInfo.mappings.get(name);
                  if (newName === undefined) {
                    throw new Error('Expected newName');
                  }

                  if (node.type === 'JSXMemberExpression') {
                    return ___R$project$rome$$romejs$js$ast$jsx$JSXIdentifier_ts$jsxIdentifier.quick(newName);
                  } else {
                    return ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(newName);
                  }
                }
              }

              // Add new specifiers to wildcard import declarations
              if (node.type === 'ImportDeclaration' &&
                wildcardImportNodeToLocal.has(
                  node,
                )) {
                const local = wildcardImportNodeToLocal.get(node);
                if (local === undefined) {
                  throw new Error('Expected local');
                }

                const wildcardInfo = wildcardImports.get(local);
                if (wildcardInfo === undefined) {
                  // We would have deopted earlier
                  return node;
                }

                // Remove wildcard specifier
                let specifiers = [];
                if (node.specifiers !== undefined) {
                  specifiers =
                    node.specifiers.filter(
                      (specifier) => {
                        if (specifier.type === 'ImportNamespaceSpecifier' &&
                          specifier.local.name.name === local) {
                          return false;
                        } else {
                          return true;
                        }
                      },
                    );
                }

                // Add on our new mappings
                for (const [imported, local] of wildcardInfo.mappings) {
                  specifiers.push(
                    ___R$project$rome$$romejs$js$ast$modules$ImportSpecifier_ts$importSpecifier.create(
                      {
                        imported: ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.quick(imported),
                        local: ___R$project$rome$$romejs$js$ast$modules$ImportSpecifierLocal_ts$importSpecifierLocal.quick(___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.quick(local)),
                      },
                    ),
                  );
                }

                return ___R$project$rome$$romejs$js$ast$modules$ImportDeclaration_ts$importDeclaration.create({specifiers, source: node.source});
              }

              return node;
            },
          },
        )
      );
    },
  };

  // project-rome/@romejs/js-compiler/transforms/compile/validation/optimizeExports.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compile$validation$optimizeExports_ts$default = {
    name: 'optimizeExports',
    enter(path) {
      const {node} = path;

      // turn `import {a} from 'b'; export {a}`; to `export {a} from 'b';`';
      if (node.type === 'ExportLocalDeclaration' && node.exportKind === 'value' &&
        node.declaration === undefined &&
        node.specifiers !== undefined) {
        const nodes = [];
        const specifiers = [];

        for (const specifier of node.specifiers) {
          if (specifier.type === 'ExportLocalSpecifier') {
            const binding = path.scope.getBinding(specifier.local.name);
            if (binding !== undefined && binding instanceof ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ImportBinding &&
              binding.meta.type === 'name') {
              nodes.push(
                ___R$project$rome$$romejs$js$ast$modules$ExportExternalDeclaration_ts$exportExternalDeclaration.create(
                  {
                    specifiers: [
                      ___R$project$rome$$romejs$js$ast$modules$ExportExternalSpecifier_ts$exportExternalSpecifier.create(
                        {
                          local: ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.quick(binding.meta.imported),
                          exported: specifier.exported,
                          loc: specifier.loc,
                        },
                      ),
                    ],
                    source: ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.quick(binding.meta.source),
                  },
                ),
              );
            } else {
              specifiers.push(specifier);
            }
          } else {
            // TODO ???
            specifiers.push(specifier);
          }
        }

        if (specifiers.length === node.specifiers.length && nodes.length === 0) {
          return node;
        }

        if (specifiers.length !== 0) {
          nodes.push(___R$project$rome$$romejs$js$ast$modules$ExportLocalDeclaration_ts$exportLocalDeclaration.create({specifiers}));
        }

        return nodes;
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/compile/jsx.ts
function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$convertJSXIdentifier(
    path,
  ) {
    const {node} = path;

    if (node.type === 'JSXReferenceIdentifier') {
      if (node.name === 'this') {
        return ___R$project$rome$$romejs$js$ast$expressions$ThisExpression_ts$thisExpression.create({});
      } else {
        return (
          ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.create(
            {
              name: node.name,
            },
            node,
          )
        );
      }
    } else if (node.type === 'JSXIdentifier') {
      return ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.quick(node.name);
    } else if (node.type === 'JSXMemberExpression') {
      let prop = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$convertJSXIdentifier(path.getChildPath('property'));

      if (prop.type === 'ReferenceIdentifier') {
        return (
          ___R$project$rome$$romejs$js$ast$expressions$MemberExpression_ts$memberExpression.create(
            {
              object: ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$convertJSXIdentifier(path.getChildPath('object')),
              property: ___R$project$rome$$romejs$js$ast$auxiliary$StaticMemberProperty_ts$staticMemberProperty.quick(___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.quick(prop.name)),
            },
          )
        );
      } else {
        return (
          ___R$project$rome$$romejs$js$ast$expressions$MemberExpression_ts$memberExpression.create(
            {
              object: ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$convertJSXIdentifier(path.getChildPath('object')),
              property: ___R$project$rome$$romejs$js$ast$auxiliary$ComputedMemberProperty_ts$computedMemberProperty.quick(prop),
            },
          )
        );
      }
    } else {
      throw (
        new Error(
          'Received a node of type ' +
          node.type +
          ', the only node types that should be in this position are JSXIdentifier and JSXMemberExpression',
        )
      );
    }
  }

  function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$convertAttributeValue(
    node,
  ) {
    if (node.type === 'JSXExpressionContainer') {
      return node.expression;
    } else {
      return node;
    }
  }

  function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$extractName(node) {
    if (node.type === 'JSXNamespacedName') {
      throw new Error('JSX is not XML blah blah blah');
    } else {
      return ___R$project$rome$$romejs$js$ast$jsx$JSXIdentifier_ts$jsxIdentifier.assert(node).name;
    }
  }

  function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$convertAttribute(node) {
    let valueNode = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$convertAttributeValue(
      node.value ||
      ___R$project$rome$$romejs$js$ast$literals$BooleanLiteral_ts$booleanLiteral.create(
        {
          value: true,
        },
      ),
    );
    if (valueNode.type === 'StringLiteral' &&
      (!node.value ||
      node.value.type !==
      'JSXExpressionContainer')) {
      valueNode =
        ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.create(
          {
            value: valueNode.value.replace(/\n\s+/g, ' '),
          },
        );
    }

    const name = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$extractName(node.name);

    if (___R$project$rome$$romejs$js$ast$utils$isValidIdentifierName_ts$default(name)) {
      const nameNode = ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.create(
        {
          name,
          loc: ___R$project$rome$$romejs$js$ast$utils$inheritLoc_ts$default(node),
        },
      );

      return (
        ___R$project$rome$$romejs$js$ast$objects$ObjectProperty_ts$objectProperty.create(
          {
            key: ___R$project$rome$$romejs$js$ast$objects$StaticPropertyKey_ts$staticPropertyKey.quick(nameNode),
            value: valueNode,
          },
        )
      );
    } else {
      return (
        ___R$project$rome$$romejs$js$ast$objects$ObjectProperty_ts$objectProperty.create(
          {
            key: ___R$project$rome$$romejs$js$ast$objects$ComputedPropertyKey_ts$computedPropertyKey.quick(___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.quick(name)),
            value: valueNode,
          },
        )
      );
    }
  }

  function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$pushProps(
    _props,
    objs,
  ) {
    if (!_props.length) {
      return _props;
    }

    objs.push(___R$project$rome$$romejs$js$ast$objects$ObjectExpression_ts$objectExpression.create({properties: _props}));
    return [];
  }

  function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$buildOpeningElementAttributes(attribs) {
    let _props = [];
    const objs = [];

    while (attribs.length > 0) {
      const prop = attribs.shift();
      if (prop === undefined) {
        throw new Error('Already validated length');
      }

      if (prop.type === 'JSXSpreadAttribute') {
        _props = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$pushProps(_props, objs);
        objs.push(prop.argument);
      } else {
        _props.push(___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$convertAttribute(prop));
      }
    }

    ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$pushProps(_props, objs);

    let ret;
    if (objs.length === 1) {
      // only one object
      ret = objs[0];
    } else {
      // looks like we have multiple objects
      if (objs[0].type !== 'ObjectExpression') {
        objs.unshift(___R$project$rome$$romejs$js$ast$objects$ObjectExpression_ts$objectExpression.create({properties: []}));
      }

      // spread it
      ret =
        ___R$project$rome$$romejs$js$ast$expressions$CallExpression_ts$callExpression.create(
          {
            callee: ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`Object.assign`,
            arguments: objs,
          },
        );
    }

    return ret;
  }

  function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$cleanJSXElementLiteralChild(value) {
    const lines = value.split(/\r\n|\n|\r/);

    let lastNonEmptyLine = 0;

    for (let i = 0;
    i < lines.length;
    i++) {
      if (lines[i].match(/[^ \t]/)) {
        lastNonEmptyLine = i;
      }
    }

    let str = '';

    for (let i = 0;
    i < lines.length;
    i++) {
      const line = lines[i];

      const isFirstLine = i === 0;
      const isLastLine = i === lines.length - 1;
      const isLastNonEmptyLine = i === lastNonEmptyLine;

      // replace rendered whitespace tabs with spaces
      let trimmedLine = line.replace(/\t/g, ' ');

      // trim whitespace touching a newline
      if (!isFirstLine) {
        trimmedLine = trimmedLine.replace(/^[ ]+/, '');
      }

      // trim whitespace touching an endline
      if (!isLastLine) {
        trimmedLine = trimmedLine.replace(/[ ]+$/, '');
      }

      if (trimmedLine) {
        if (!isLastNonEmptyLine) {
          trimmedLine += ' ';
        }

        str += trimmedLine;
      }
    }

    if (str != '') {
      return ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.quick(str);
    }
  }

  function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$buildChildren(
    children,
  ) {
    const elems = [];

    for (let child of children) {
      if (child.type === 'JSXText') {
        const node = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$cleanJSXElementLiteralChild(child.value);
        if (node !== undefined) {
          elems.push(node);
        }
        continue;
      }

      if (child.type === 'JSXExpressionContainer') {
        const {expression} = child;
        if (expression.type !== 'JSXEmptyExpression') {
          elems.push(child.expression);
        }
        continue;
      }

      if (child.type === 'JSXSpreadChild') {
        elems.push(___R$project$rome$$romejs$js$ast$auxiliary$SpreadElement_ts$spreadElement.quick(child.expression));
        continue;
      }

      elems.push(child);
    }

    return elems;
  }

  const ___R$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$default = {
    name: 'jsx',
    enter(path) {
      const {node, context, parent} = path;

      if (___R$project$rome$$romejs$js$ast$jsx$JSXElement_ts$jsxElement.is(node)) {
        let type = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$convertJSXIdentifier(path.getChildPath('name'));

        if (___R$project$rome$$romejs$js$ast$jsx$JSXNamespacedName_ts$jsxNamespacedName.is(node.name)) {
          // TODO better handle this
          context.addNodeDiagnostic(
            type,
            {
              category: 'compile/jsx',
              message: 'JSX is not XML',
            },
          );
        }

        let attribs;
        if (node.attributes.length > 0) {
          attribs = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$buildOpeningElementAttributes(node.attributes);
        } else {
          attribs = ___R$project$rome$$romejs$js$ast$literals$NullLiteral_ts$nullLiteral.create({});
        }

        const call = ___R$project$rome$$romejs$js$ast$expressions$CallExpression_ts$callExpression.create(
          {
            callee: ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`React.createElement`,
            arguments: [type, attribs, ...___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$buildChildren(node.children)],
          },
        );

        // If we're a JSX element child then we need to be wrapped
        if (___R$project$rome$$romejs$js$ast$jsx$JSXElement_ts$jsxElement.is(parent)) {
          return (
            ___R$project$rome$$romejs$js$ast$jsx$JSXExpressionContainer_ts$jsxExpressionContainer.create(
              {
                expression: call,
              },
            )
          );
        } else {
          return call;
        }
      }

      if (node.type === 'JSXFragment') {
        const type = ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`React.Fragment`;
        const attribs = ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`null`;
        return (
          ___R$project$rome$$romejs$js$ast$expressions$CallExpression_ts$callExpression.create(
            {
              callee: ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`React.createElement`,
              arguments: [type, attribs, ...___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$buildChildren(node.children)],
            },
          )
        );
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/compileForBundle/_utils.ts
function ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getOptions(context) {
    const opts = context.options.bundle;
    if (opts === undefined) {
      throw new Error('No bundle options found');
    }
    return opts;
  }

  function ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrivateName(name, moduleId) {
    return ___R$project$rome$$romejs$js$compiler$constants_ts$SCOPE_PRIVATE_PREFIX +
    '$priv$' +
    ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$normalizeModuleId(moduleId) +
    '$' +
    name;
  }

  function ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$normalizeModuleId(id) {
    // TODO probably need more stuff in this
    return id.replace(/[\\\/@\-]/g, '$').replace(/[\-.]/g, '_');
  }

  function ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
    name,
    moduleId,
    opts,
  ) {
    const forwarded = opts.resolvedImports[moduleId +
    ':' +
    name];
    if (forwarded !== undefined) {
      moduleId = forwarded.id;
      name = forwarded.name;
    }

    return ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$normalizeModuleId(moduleId)) +
    '$' +
    name;
  }

  function ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(moduleId) {
    return '' +
    ___R$project$rome$$romejs$js$compiler$constants_ts$SCOPE_PRIVATE_PREFIX +
    ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$normalizeModuleId(moduleId);
  }

  function ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getModuleId(
    source,
    opts,
  ) {
    return opts.relativeSourcesToModuleId[source];
  }

  // project-rome/@romejs/js-analysis/Graph.ts
class ___R$project$rome$$romejs$js$analysis$Graph_ts$default {
    constructor() {
      this.nodes = [];
      this.nodesByValue = new Map();
    }

    addNode(value) {
      if (this.find(value)) {
        return undefined;
      }

      const node = {lines: [], value};
      this.nodesByValue.set(value, node);
      this.nodes.push(node);
    }

    find(value) {
      return this.nodesByValue.get(value);
    }

    hasConnections(value) {
      const node = this.nodesByValue.get(value);
      return node !== undefined && node.lines.length > 0;
    }

    addLine(startValue, endValue) {
      const startNode = this.find(startValue);
      const endNode = this.find(endValue);

      if (!startNode || !endNode) {
        throw new Error('Both nodes need to exist');
      }

      startNode.lines.push(endNode);
    }
  }

  // project-rome/@romejs/js-analysis/types/T.ts
let ___R$$priv$project$rome$$romejs$js$analysis$types$T_ts$counter = 0;

  class ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode) {
      this.human = undefined;
      this.scope = scope;

      const {hub} = scope;
      this.hub = hub;
      this.utils = hub.utils;
      this.evaluator = hub.evaluator;
      this.originEvaluator = scope.evaluator.evaluatingType;

      // setup graph
      this.graph = scope.evaluator.graph;
      this.graph.addNode(this);

      this.originNode = originNode;
      this.originLoc = originNode === undefined ? undefined : originNode.loc;
      this.id = String(process.pid) +
      ':' +
      String(___R$$priv$project$rome$$romejs$js$analysis$types$T_ts$counter++);

      this.compatibilityCache = new Map();
    }

    getConstructor() {
      // @ts-ignore
      return this.constructor;
    }

    setHuman(human) {
      this.human = human;
    }

    shouldMatch(type) {
      this.hub.assertOpen();
      this.graph.addLine(this, type);
    }

    hasConnections() {
      return this.graph.hasConnections(this);
    }

    explodeUnion() {
      return [this];
    }

    compatibleWith(otherType) {
      return otherType instanceof this.constructor;
    }

    clone() {
      const idsToType = new Map();

      const addType = (type) => {
        const reduced = this.utils.reduce(type);
        idsToType.set(type.id, type);
        return reduced.id;
      };

      const data = this.serialize(addType);

      const getType = (id) => {
        if (typeof id !== 'string') {
          throw new Error('Expected id to be a string');
        }

        const type = idsToType.get(id);
        if (type === undefined) {
          throw new Error('Expected type');
        }
        return type;
      };

      return (
        this.getConstructor().hydrate(
          this.scope,
          this.originNode,
          data,
          getType,
        )
      );
    }

    static hydrate(scope, originNode, data, getType) {
      throw new Error('Unimplemented ' +
      this.type +
      '.hydrate');
    }

    serialize(addType) {
      throw (
        new Error(
          'Unimplemented ' +
          this.getConstructor().type +
          '.prototype.serialize',
        )
      );
    }

    reduce() {
      return this;
    }

    humanize(builder) {
      const reduced = this.utils.reduce(this);
      if (reduced === this) {
        throw new Error('unimplemented');
      } else {
        return builder.humanize(reduced);
      }
    }

    inspect() {
      return this.utils.inspect(this);
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$T_ts$default.type =
    'T';

  // project-rome/@romejs/js-analysis/types/UnknownT.ts
class ___R$project$rome$$romejs$js$analysis$types$UnknownT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___R$project$rome$$romejs$js$analysis$types$UnknownT_ts$default(scope, originNode);
    }

    humanize() {
      return 'unknown';
    }

    compatibleWith() {
      return false;
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$UnknownT_ts$default.type =
    'UnknownT';

  // project-rome/@romejs/js-analysis/types/OpenT.ts
class ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    humanize(builder) {
      const type = this.utils.reduce(this);
      if (type === this) {
        return 'open';
      } else {
        return builder.humanize(type);
      }
    }

    reduce() {
      const node = this.graph.find(this);
      if (node === undefined) {
        return new ___R$project$rome$$romejs$js$analysis$types$UnknownT_ts$default(this.scope, this.originNode);
      }

      const values = node.lines.map((line) => this.utils.reduce(line.value));
      return this.scope.createUnion(values, this.originNode);
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default.type =
    'OpenT';

  // project-rome/@romejs/js-analysis/types/OpenIntrinsicT.ts
class ___R$project$rome$$romejs$js$analysis$types$OpenIntrinsicT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default {
    constructor(scope, originNode, name) {
      super(scope, originNode);
      this.name = name;
    }

    serialize() {
      return (
        {
          name: this.name,
        }
      );
    }

    static hydrate(scope, originNode, data) {
      return scope.intrinsics.get(String(data.name));
    }

    humanize() {
      return 'open intrinsic';
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$OpenIntrinsicT_ts$default.type =
    'OpenIntrinsicT';

  // project-rome/@romejs/js-analysis/Intrinsics.ts
class ___R$project$rome$$romejs$js$analysis$Intrinsics_ts$default {
    constructor(scope) {
      this.scope = scope;

      this.intrinsicByName = new Map();

      this.NumberPrototype = this.createOpenT('NumberPrototype');
      this.Number = this.createOpenT('Number');

      this.StringPrototype = this.createOpenT('StringPrototype');
      this.String = this.createOpenT('String');

      this.ObjectPrototype = this.createOpenT('ObjectPrototype');
      this.Object = this.createOpenT('Object');

      this.ArrayPrototype = this.createOpenT('ArrayPrototype');
      this.Array = this.createOpenT('Array');

      this.RegExpPrototype = this.createOpenT('RegExpPrototype');
      this.RegExp = this.createOpenT('RegExp');
    }

    get(name) {
      const t = this.intrinsicByName.get(name);
      if (t === undefined) {
        throw new Error('No intrinsic found for ' +
        name);
      }
      return t;
    }

    createOpenT(name) {
      const t = new ___R$project$rome$$romejs$js$analysis$types$OpenIntrinsicT_ts$default(this.scope, undefined, name);
      this.intrinsicByName.set(name, t);
      return t;
    }

    link() {
      this.String.shouldMatch(this.scope.query(['String']));
      this.StringPrototype.shouldMatch(this.scope.query(['String', 'prototype']));

      this.Object.shouldMatch(this.scope.query(['Object']));
      this.ObjectPrototype.shouldMatch(this.scope.query(['Object', 'prototype']));

      this.Array.shouldMatch(this.scope.query(['Array']));
      this.ArrayPrototype.shouldMatch(this.scope.query(['Array', 'prototype']));

      this.RegExp.shouldMatch(this.scope.query(['RegExp']));
      this.RegExpPrototype.shouldMatch(this.scope.query(['RegExp', 'prototype']));

      this.Number.shouldMatch(this.scope.query(['Number']));
      this.NumberPrototype.shouldMatch(this.scope.query(['Number', 'prototype']));
    }
  }

  // project-rome/@romejs/js-analysis/types/ObjPropT.ts
class ___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, key, value) {
      super(scope, originNode);
      this.key = key;
      this.value = value;
    }

    serialize(addType) {
      return (
        {
          key: this.key,
          value: addType(this.value),
        }
      );
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default(scope, originNode, String(data.key), getType(data.value));
    }

    compatibleWith(otherType) {
      if (otherType instanceof ___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default && otherType.key === this.key) {
        return this.utils.checkCompability(this.value, otherType.value);
      } else {
        return false;
      }
    }

    humanize(builder) {
      return this.key +
      ': ' +
      builder.humanize(this.value);
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default.type =
    'ObjPropT';

  // project-rome/@romejs/js-analysis/types/ObjT.ts
class ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, opts) {
      super(scope, originNode);
      this.calls = opts.calls === undefined ? [] : opts.calls;
      this.props = opts.props === undefined ? [] : opts.props;
      this.proto = opts.proto;
    }

    serialize(addType) {
      if (this.constructor !== ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default) {
        throw (
          new Error(
            'Expected ObjT to be constructor, youve likely forgot to define this method in the type subclass',
          )
        );
      }

      return (
        {
          calls: this.calls.map((type) => addType(type)),
          proto: this.proto === undefined ? undefined : addType(this.proto),
          props: this.props.map((type) => addType(type)),
        }
      );
    }

    static hydrate(scope, originNode, data, getType) {
      return (
        new ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default(
          scope,
          originNode,
          {
            props: Array(data.props).map((id) => getType(id)),
            proto: data.proto === undefined ? undefined : getType(data.proto),
            calls: Array(data.calls).map((id) => getType(id)),
          },
        )
      );
    }

    compatibleWith(otherType) {
      if (!(otherType instanceof ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default)) {
        return false;
      }

      const ourProps = this.props;
      const theirProps = otherType.props;

      // check that the other type has all of our props
      for (const ourPropRaw of ourProps) {
        // reduce and get the key of this prop
        const ourProp = this.utils.reduce(ourPropRaw);
        let key;
        if (ourProp instanceof ___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default) {
          key = ourProp.key;
        } else {
          // should probably do something here
          continue;
        }

        // try and find a prop of the same key in the other object
        let theirProp;
        for (const theirPropRaw of theirProps) {
          const maybeTheirProp = this.utils.reduce(theirPropRaw);
          if (maybeTheirProp instanceof ___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default && maybeTheirProp.key === key) {
            theirProp = maybeTheirProp;
            break;
          }
        }

        if (!ourProp || !theirProp) {
          return false;
        }

        const compatibility = this.utils.checkCompability(ourProp, theirProp);
        if (compatibility.type === 'incompatible') {
          return compatibility;
        }
      }

      return true;
    }

    humanize(builder) {
      if (this.props.length === 0) {
        return '{}';
      } else {
        return (
          [
            '{',
            ...this.props.map(
              (prop) => {
                const val = builder.humanize(prop);
                let lines = val.split('\n');
                lines = lines.map((line) => '  ' +
                line);
                return lines.join('\n') +
                ',';
              },
            ),
            '}',
          ].join(
            '\n',
          )
        );
      }
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default.type =
    'ObjT';

  // project-rome/@romejs/js-analysis/types/StringLiteralT.ts
class ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default {
    constructor(scope, originNode, value) {
      super(
        scope,
        originNode,
        {
          props: [],
          proto: scope.intrinsics.StringPrototype,
          calls: [],
        },
      );
      this.value = value;
    }

    serialize() {
      return {value: this.value};
    }

    static hydrate(scope, originNode, data) {
      return new ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default(scope, originNode, String(data.value));
    }

    humanize() {
      let str = JSON.stringify(this.value);
      if (this.value.includes('\'')) {
        return str;
      } else {
        return '\'' +
        str.slice(1, -1) +
        '\'';
      }
    }

    compatibleWith(type) {
      return type instanceof ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default && type.value === this.value;
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default.type =
    'StringLiteralT';

  // project-rome/@romejs/js-analysis/types/AnyT.ts
class ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default(scope, originNode);
    }

    compatibleWith() {
      return true;
    }

    humanize() {
      return 'any';
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default.type =
    'AnyT';

  // project-rome/@romejs/js-analysis/types/errors/E.ts
class ___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    static hydrate(scope, originNode) {
      return new ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default(scope, originNode);
    }

    humanize() {
      return this.getError().message;
    }

    getError() {
      throw new Error('unimplemented');
    }

    compatibleWith() {
      return false;
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default.type =
    'E';

  // project-rome/@romejs/js-analysis/types/errors/UnknownPropE.ts
class ___R$project$rome$$romejs$js$analysis$types$errors$UnknownPropE_ts$default extends ___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default {
    constructor(scope, originNode, opts) {
      super(scope, originNode);
      this.thisKeys = opts.thisKeys;
      this.protoKeys = opts.protoKeys;
      this.allProps = [...this.thisKeys, ...this.protoKeys];
      this.key = opts.key;
      this.object = opts.object;
      this.property = opts.property;
    }

    sortProps(props) {
      if (props.length === 0) {
        return props;
      }

      const ratings = ___R$project$rome$$romejs$string$utils$orderBySimilarity_ts$orderBySimilarity(this.key, props);
      const sortedProps = ratings.map((prop) => prop.target);
      return sortedProps;
    }

    getError() {
      let message = 'Property \'' +
      this.key +
      '\' not found in';

      return (
        {
          category: 'typeCheck/unknownProperty',
          message,
          advice: ___R$project$rome$$romejs$diagnostics$helpers_ts$buildSuggestionAdvice(this.key, this.allProps),
          lowerTarget: this.property,
          upperTarget: this.object,
        }
      );
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$errors$UnknownPropE_ts$default.type =
    'UnknownPropE';

  // project-rome/@romejs/js-analysis/types/ObjIndexPropT.ts
class ___R$project$rome$$romejs$js$analysis$types$ObjIndexPropT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, key, value) {
      super(scope, originNode);
      this.key = key;
      this.value = value;
    }

    serialize(addType) {
      return (
        {
          key: addType(this.key),
          value: addType(this.value),
        }
      );
    }

    static hydrate(scope, originNode, data, getType) {
      return (
        new ___R$project$rome$$romejs$js$analysis$types$ObjIndexPropT_ts$default(
          scope,
          originNode,
          getType(data.key),
          getType(
            data.value,
          ),
        )
      );
    }

    humanize(builder) {
      return '[' +
      builder.humanize(this.key) +
      ']: ' +
      builder.humanize(this.value);
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$ObjIndexPropT_ts$default.type =
    'ObjIndexPropT';

  // project-rome/@romejs/js-analysis/types/GetPropT.ts
class ___R$project$rome$$romejs$js$analysis$types$GetPropT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, object, property) {
      super(scope, originNode);
      this.object = object;
      this.property = property;
    }

    serialize(addType) {
      return (
        {
          object: addType(this.object),
          property: addType(this.property),
        }
      );
    }

    static hydrate(scope, originNode, data, getType) {
      return (
        new ___R$project$rome$$romejs$js$analysis$types$GetPropT_ts$default(
          scope,
          originNode,
          getType(data.object),
          getType(
            data.property,
          ),
        )
      );
    }

    lookup(object, property, opts = {}) {
      object = this.utils.reduce(object);
      property = this.utils.reduce(property);

      const thisKeys = new Set();

      //
      const protoKeys = opts.protoKeys === undefined ? [] : opts.protoKeys;
      const topObject = opts.topObject === undefined ? object : opts.topObject;

      // turn property into string key
      let key;
      if (property instanceof ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default) {
        key = property.value;
      }

      // look up on object
      if (key !== undefined && object instanceof ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default) {
        //
        const indexers = [];
        for (const maybePropRaw of object.props) {
          const maybeProp = this.utils.reduce(maybePropRaw);
          if (maybeProp instanceof ___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default) {
            if (maybeProp.key === key) {
              // TODO collate these in case there's multiple properties of this name
              return this.utils.reduce(maybeProp.value);
            } else {
              thisKeys.add(maybeProp.key);
            }
          } else if (maybeProp instanceof ___R$project$rome$$romejs$js$analysis$types$ObjIndexPropT_ts$default) {
            indexers.push(maybeProp);
          }
        }

        //
        for (const indexer of indexers) {
          if (this.utils.isCompatibleWith(indexer.key, property)) {
            return this.utils.reduce(indexer.value);
          }
        }

        //
        if (object.proto) {
          return (
            this.lookup(
              object.proto,
              property,
              {
                topObject,
                protoKeys: [...protoKeys, ...thisKeys],
              },
            )
          );
        }
      }

      // property lookups on an `any` return `any`!
      if (object instanceof ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default || object instanceof ___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default) {
        return new ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default(this.scope, this.originNode);
      }

      //
      if (typeof key === 'string') {
        return (
          new ___R$project$rome$$romejs$js$analysis$types$errors$UnknownPropE_ts$default(
            this.scope,
            this.originNode,
            {
              object: topObject,
              property,
              key,
              thisKeys: Array.from(thisKeys),
              protoKeys,
            },
          )
        );
      } else {
        return new ___R$project$rome$$romejs$js$analysis$types$UnknownT_ts$default(this.scope, this.originNode);
      }
    }

    reduce() {
      return this.lookup(this.object, this.property);
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$GetPropT_ts$default.type =
    'GetPropT';

  // project-rome/@romejs/js-analysis/types/UnionT.ts
class ___R$project$rome$$romejs$js$analysis$types$UnionT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, types) {
      super(scope, originNode);
      this.types = [...new Set(types)];
    }

    serialize(addType) {
      return (
        {
          types: this.types.map((type) => addType(type)),
        }
      );
    }

    static hydrate(scope, originNode, data, getType) {
      return (
        new ___R$project$rome$$romejs$js$analysis$types$UnionT_ts$default(
          scope,
          originNode,
          Array(data.types).map(
            (
              id,
            ) =>
              getType(id),
          ),
        )
      );
    }

    reduce() {
      const uniqTypes = [];
      const types = this.explodeUnion();

      for (const type of types) {
        let foundMatch = false;
        for (const compareType of uniqTypes) {
          const isCompatible = this.utils.isCompatibleWith(compareType, type);
          if (isCompatible) {
            foundMatch = true;
            break;
          }
        }
        if (foundMatch === false) {
          uniqTypes.push(type);
        }
      }

      if (uniqTypes.length === types.length) {
        return this;
      } else if (uniqTypes.length === 1) {
        return uniqTypes[0];
      } else {
        return new ___R$project$rome$$romejs$js$analysis$types$UnionT_ts$default(this.scope, this.originNode, uniqTypes);
      }
    }

    explodeUnion() {
      let types = [];
      const visited = new Set([this]);

      for (const type of this.types) {
        const reduced = this.utils.reduce(type);
        if (visited.has(reduced)) {
          continue;
        } else {
          visited.add(reduced);
        }

        types = types.concat(this.utils.explodeUnion(type));
      }

      return types;
    }

    compatibleWith(otherType) {
      const ourTypes = this.utils.explodeUnion(this);

      // fast path to check if a union contains a type
      if (ourTypes.includes(otherType)) {
        return true;
      }

      const otherTypes = this.utils.explodeUnion(otherType);
      const missing = [];

      for (const type of ourTypes) {
        let compatible = false;

        for (const otherType of otherTypes) {
          if (this.utils.isCompatibleWith(type, otherType)) {
            compatible = true;
          }
        }

        if (compatible === false) {
          missing.push(type);
        }
      }

      if (missing.length === 0) {
        return true;
      } else {
        // create custom error with the types that weren't in the opposing one

        //return new MissingUnionE(this.scope, otherType.originNode, otherType, this, missing);
        return false;
      }
    }

    humanize(builder) {
      return this.types.map((type) => builder.humanize(type)).join(' | ');
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$UnionT_ts$default.type =
    'UnionT';

  // project-rome/@romejs/js-analysis/scopes.ts
class ___R$project$rome$$romejs$js$analysis$scopes_ts$Scope {
    constructor(opts) {
      let {evaluator, parentScope} = opts;
      if (evaluator === undefined && parentScope !== undefined) {
        evaluator = parentScope.evaluator;
      }

      if (evaluator === undefined) {
        throw new Error('No evaluator was passed or inferred');
      }

      this.intrinsics = evaluator.intrinsics;
      this.evaluator = evaluator;
      this.hub = evaluator.hub;
      this.parentScope = parentScope;

      this.bindings = new Map();
    }

    getBinding(name) {
      let scope = this;
      while (scope) {
        const binding = scope.bindings.get(name);
        if (binding) {
          return binding.type;
        }
        scope = scope.parentScope;
      }
    }

    getBindingAssert(name) {
      const binding = this.getBinding(name);
      if (binding === undefined) {
        throw new Error('Expected binding ' +
        name);
      }
      return binding;
    }

    query(paths) {
      let initial = this.getBinding(paths[0]);
      if (initial === undefined) {
        throw (
          new Error(
            'Expected "' +
            paths[0] +
            '" binding, found ' +
            JSON.stringify(
              this.getBindingNames(),
            ) +
            ' ' +
            this.evaluator.filename,
          )
        );
      }

      //invariant(initial !== undefined, `Expected "${paths[0]}" binding`);
      for (let i = 1;
      i < paths.length;
      i++) {
        initial =
          new ___R$project$rome$$romejs$js$analysis$types$GetPropT_ts$default(
            this,
            undefined,
            initial,
            new ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default(
              this,
              undefined,
              paths[i],
            ),
          );
      }

      return initial;
    }

    declareBinding(name, originNode) {
      if (name === undefined) {
        throw new Error('Expected name');
      }
      this.bindings.set(
        name,
        {
          type: new ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default(this, originNode),
          status: 'declared',
        },
      );
    }

    addBinding(name, type) {
      if (name === undefined) {
        throw new Error('Expected name');
      }

      const existingBinding = this.bindings.get(name);
      if (existingBinding !== undefined && existingBinding.status === 'declared') {
        if (!(existingBinding.type instanceof ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default)) {
          throw new Error('expected OpenT');
        }

        existingBinding.type.shouldMatch(type);
      }

      this.bindings.set(
        name,
        {
          type,
          status: 'initialized',
        },
      );
    }

    getBindingNames() {
      const names = new Set(
        this.parentScope
          ? this.parentScope.getBindingNames() : [],
      );

      for (const [name] of this.bindings) {
        names.add(name);
      }

      return Array.from(names);
    }

    getOwnBindingNames() {
      return Array.from(this.bindings.keys());
    }

    createUnion(types, originNode) {
      if (types.length === 0) {
        return new ___R$project$rome$$romejs$js$analysis$types$UnknownT_ts$default(this, originNode);
      } else if (types.length === 1) {
        return types[0];
      } else {
        return new ___R$project$rome$$romejs$js$analysis$types$UnionT_ts$default(this, originNode, types);
      }
    }

    fork() {
      return new ___R$project$rome$$romejs$js$analysis$scopes_ts$Scope({evaluator: this.evaluator, parentScope: this});
    }

    find(klass) {
      const scope = this.findOptional(klass);
      if (scope === undefined) {
        throw new Error('Failed to find class');
      } else {
        return scope;
      }
    }

    findOptional(klass) {
      let scope = this;

      do {
        if (scope instanceof klass) {
          return scope;
        }

        scope = scope.parentScope;
      } while (scope !== undefined);
    }

    refine() {
      return new ___R$project$rome$$romejs$js$analysis$scopes_ts$RefineScope({evaluator: this.evaluator, parentScope: this});
    }

    evaluate(node) {
      return this.evaluator.evaluate(node, this);
    }
  }

  class ___R$project$rome$$romejs$js$analysis$scopes_ts$RefineScope extends ___R$project$rome$$romejs$js$analysis$scopes_ts$Scope {}

  class ___R$project$rome$$romejs$js$analysis$scopes_ts$ClassScope extends ___R$project$rome$$romejs$js$analysis$scopes_ts$Scope {
    constructor(opts, meta) {
      super(opts);
      this.meta = meta;
    }
  }

  class ___R$project$rome$$romejs$js$analysis$scopes_ts$ThisScope extends ___R$project$rome$$romejs$js$analysis$scopes_ts$Scope {
    constructor(opts, context) {
      super(opts);
      this.context = context;
    }
  }

  class ___R$project$rome$$romejs$js$analysis$scopes_ts$FunctionScope extends ___R$project$rome$$romejs$js$analysis$scopes_ts$ThisScope {
    constructor(opts, meta) {
      super(opts, meta.thisContext);
      this.meta = meta;
    }
  }

  // project-rome/@romejs/js-analysis/types/errors/UnknownImportE.ts
class ___R$project$rome$$romejs$js$analysis$types$errors$UnknownImportE_ts$default extends ___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default {
    constructor(scope, originNode, opts) {
      super(scope, originNode);
      this.possibleNames = opts.possibleNames;
      this.importedName = opts.importedName;
      this.source = opts.source;
    }

    getError() {
      const {possibleNames} = this;
      const suggestion = ___R$project$rome$$romejs$string$utils$findClosestStringMatch_ts$findClosestStringMatch(this.importedName, possibleNames);

      let infoMessage = undefined;
      let infoList = undefined;

      if (possibleNames.length === 0) {
        infoMessage = 'This file contains no exports.';
      } else {
        if (suggestion === undefined) {
          infoList = this.possibleNames;
          infoMessage = 'Did you mean one of these?';
        } else {
          infoMessage = 'Did you mean <emphasis>' +
          suggestion +
          '</emphasis>?';
        }
      }

      const advice = [
        {
          type: 'log',
          category: 'info',
          message: infoMessage,
        },
      ];
      if (infoList !== undefined) {
        advice.push(
          {
            type: 'list',
            list: infoList,
          },
        );
      }

      return (
        {
          category: 'typeCheck/unknownImport',
          message: 'Unknown import \'' +
          this.importedName +
          '\' in \'' +
          this.source +
          '\'',
          advice,
          lowerTarget: this,
        }
      );
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$errors$UnknownImportE_ts$default.type =
    'UnknownImportE';

  // project-rome/@romejs/js-analysis/types/VoidT.ts
class ___R$project$rome$$romejs$js$analysis$types$VoidT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___R$project$rome$$romejs$js$analysis$types$VoidT_ts$default(scope, originNode);
    }

    humanize() {
      return 'void';
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$VoidT_ts$default.type =
    'VoidT';

  // project-rome/@romejs/js-analysis/types/EmptyT.ts
class ___R$project$rome$$romejs$js$analysis$types$EmptyT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___R$project$rome$$romejs$js$analysis$types$EmptyT_ts$default(scope, originNode);
    }

    humanize() {
      return 'empty';
    }

    compatibleWith(otherType) {
      return otherType instanceof ___R$project$rome$$romejs$js$analysis$types$EmptyT_ts$default || otherType instanceof ___R$project$rome$$romejs$js$analysis$types$VoidT_ts$default;
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$EmptyT_ts$default.type =
    'EmptyT';

  // project-rome/@romejs/js-analysis/types/BooleanLiteralT.ts
class ___R$project$rome$$romejs$js$analysis$types$BooleanLiteralT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, value) {
      super(scope, originNode);
      this.value = value;
    }

    serialize() {
      return {value: this.value};
    }

    static hydrate(scope, originNode, data) {
      return new ___R$project$rome$$romejs$js$analysis$types$BooleanLiteralT_ts$default(scope, originNode, Boolean(data.value));
    }

    humanize() {
      if (this.value === true) {
        return 'true';
      } else {
        return 'false';
      }
    }

    compatibleWith(type) {
      return type instanceof ___R$project$rome$$romejs$js$analysis$types$BooleanLiteralT_ts$default && type.value === this.value;
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$BooleanLiteralT_ts$default.type =
    'BooleanLiteralT';

  // project-rome/@romejs/js-analysis/types/BooleanT.ts
class ___R$project$rome$$romejs$js$analysis$types$BooleanT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___R$project$rome$$romejs$js$analysis$types$BooleanT_ts$default(scope, originNode);
    }

    humanize() {
      return 'boolean';
    }

    compatibleWith(type) {
      // A boolean literal can flow into a generic boolean
      return type instanceof ___R$project$rome$$romejs$js$analysis$types$BooleanT_ts$default || type instanceof ___R$project$rome$$romejs$js$analysis$types$BooleanLiteralT_ts$default;
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$BooleanT_ts$default.type =
    'BooleanT';

  // project-rome/@romejs/js-analysis/types/errors/NotCallableE.ts
class ___R$project$rome$$romejs$js$analysis$types$errors$NotCallableE_ts$default extends ___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default {
    constructor(scope, originNode, callee) {
      super(scope, originNode);
      this.callee = callee;
    }

    getError() {
      return (
        {
          category: 'typeCheck/uncallable',
          message: 'This type isn\'t callable',
          lowerTarget: this.callee,
        }
      );
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$errors$NotCallableE_ts$default.type =
    'NotCallableE';

  // project-rome/@romejs/js-analysis/types/FunctionT.ts
class ___R$project$rome$$romejs$js$analysis$types$FunctionT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default {
    constructor(scope, originNode, opts) {
      super(
        scope,
        originNode,
        {
          props: opts.props,
          proto: opts.proto,
          calls: [],
        },
      );
      this.params = opts.params;
      this.rest = opts.rest;
      this.returns = opts.returns;
      this.body = opts.body;
    }

    serialize(addType) {
      return (
        {
          params: this.params.map((type) => addType(type)),
          rest: this.rest ? addType(this.rest) : undefined,
          returns: addType(this.returns),
          proto: this.proto === undefined ? undefined : addType(this.proto),
          body: this.body === undefined ? undefined : addType(this.body),
          props: this.props.map((type) => addType(type)),
        }
      );
    }

    static hydrate(scope, originNode, data, getType) {
      return (
        new ___R$project$rome$$romejs$js$analysis$types$FunctionT_ts$default(
          scope,
          originNode,
          {
            params: Array(data.params).map((id) => getType(id)),
            rest: data.rest === undefined ? undefined : getType(data.rest),
            returns: getType(data.returns),
            props: Array(data.props).map((id) => getType(id)),
            proto: data.proto === undefined ? undefined : getType(data.proto),
            body: data.body === undefined ? undefined : getType(data.body),
          },
        )
      );
    }

    humanize(builder) {
      return (
        '(' +
        this.params.map((param) => builder.humanize(param)).join(', ') +
        ') => ' +
        builder.humanize(
          this.returns,
        )
      );
    }

    reduce() {
      // No body, just a type signature
      const {body} = this;
      if (body === undefined) {
        return this;
      }

      // Reduce the body and create a new function
      const reducedBody = this.utils.reduce(body);
      if (reducedBody !== body) {
        return (
          new ___R$project$rome$$romejs$js$analysis$types$FunctionT_ts$default(
            this.scope,
            this.originNode,
            {
              params: this.params,
              rest: this.rest,
              returns: this.returns,
              props: this.props,
              proto: this.proto,
              body: reducedBody,
            },
          )
        );
      }

      // Already been reduced
      return this;
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$FunctionT_ts$default.type =
    'FunctionT';

  // project-rome/@romejs/js-analysis/types/CallT.ts
class ___R$project$rome$$romejs$js$analysis$types$CallT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, callee, args) {
      super(scope, originNode);
      this.callee = callee;
      this.args = args;
    }

    reduce() {
      let callee = this.utils.reduce(this.callee);
      if (callee instanceof ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default && callee.calls.length) {
        callee = this.utils.reduce(callee.calls[0]);
      }

      if (callee instanceof ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default || callee instanceof ___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default) {
        return new ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default(this.scope, this.originNode);
      } else if (callee instanceof ___R$project$rome$$romejs$js$analysis$types$FunctionT_ts$default) {
        return this.utils.reduce(callee.returns);
      } else {
        return new ___R$project$rome$$romejs$js$analysis$types$errors$NotCallableE_ts$default(this.scope, this.originNode, this.callee);
      }
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$CallT_ts$default.type =
    'CallT';

  // project-rome/@romejs/js-analysis/types/ClassT.ts
class ___R$project$rome$$romejs$js$analysis$types$ClassT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default {
    constructor(scope, originNode, opts) {
      // point `class.prototype.__proto__` to `superClass.prototype`
      let protoProp = undefined;
      if (opts.extends) {
        const originNode = opts.extends.originNode;
        protoProp =
          new ___R$project$rome$$romejs$js$analysis$types$GetPropT_ts$default(
            scope,
            originNode,
            opts.extends,
            new ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default(scope, originNode, 'prototype'),
          );
      }

      // create `class.prototype.constructor`
      const constructorOpen = new ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default(scope, undefined);
      const constructorProp = new ___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default(
        scope,
        undefined,
        'constructor',
        constructorOpen,
      );
      const instances = [...opts.instances, constructorProp];

      // create `class.prototype`
      const protoObj = new ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default(
        scope,
        originNode,
        {
          props: instances,
          proto: protoProp,
          calls: [],
        },
      );

      super(
        scope,
        originNode,
        {
          props: [
            ...opts.statics,
            new ___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default(scope, originNode, 'prototype', protoObj),
          ],
          proto: opts.extends,
          calls: opts.calls === undefined ? [] : opts.calls,
        },
      );

      constructorOpen.shouldMatch(this);

      this._constructor = opts._constructor;
      this._statics = opts.statics;
      this._instances = opts.instances;
      this._extends = opts.extends;
    }

    serialize(addType) {
      return (
        {
          constructor: this._constructor === undefined
            ? undefined : addType(
              this._constructor,
            ),
          statics: this._statics.map((type) => addType(type)),
          instances: this._instances.map((type) => addType(type)),
          extends: this._extends === undefined ? undefined : addType(this._extends),
        }
      );
    }

    static hydrate(scope, originNode, data, getType) {
      return (
        new ___R$project$rome$$romejs$js$analysis$types$ClassT_ts$default(
          scope,
          originNode,
          {
            _constructor: data.constructor === undefined
              ? undefined : getType(
                data.constructor,
              ),
            statics: Array(data.statics).map((id) => getType(id)),
            instances: Array(data.instances).map((id) => getType(id)),
            extends: data.extends === undefined ? undefined : getType(data.extends),
          },
        )
      );
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$ClassT_ts$default.type =
    'ClassT';

  // project-rome/@romejs/js-analysis/types/IntersectionT.ts
class ___R$project$rome$$romejs$js$analysis$types$IntersectionT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, types) {
      super(scope, originNode);
      this.types = types;
    }

    serialize(addType) {
      return (
        {
          types: this.types.map((type) => addType(type)),
        }
      );
    }

    static hydrate(scope, originNode, data, getType) {
      return (
        new ___R$project$rome$$romejs$js$analysis$types$IntersectionT_ts$default(
          scope,
          originNode,
          Array(data.types).map(
            (
              id,
            ) =>
              getType(id),
          ),
        )
      );
    }

    compatibleWith(otherType) {
      for (const type of this.types) {
        const compatibility = this.utils.checkCompability(type, otherType);
        if (compatibility.type === 'incompatible') {
          return compatibility;
        }
      }
      return true;
    }

    humanize(builder) {
      return this.types.map((type) => builder.humanize(type)).join(' & ');
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$IntersectionT_ts$default.type =
    'IntersectionT';

  // project-rome/@romejs/js-analysis/types/NullT.ts
class ___R$project$rome$$romejs$js$analysis$types$NullT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___R$project$rome$$romejs$js$analysis$types$NullT_ts$default(scope, originNode);
    }

    humanize() {
      return 'null';
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$NullT_ts$default.type =
    'NullT';

  // project-rome/@romejs/js-analysis/types/MaybeT.ts
class ___R$project$rome$$romejs$js$analysis$types$MaybeT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, parent) {
      super(scope, originNode);
      this.parent = parent;
    }

    serialize(addType) {
      return (
        {
          parent: addType(this.parent),
        }
      );
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___R$project$rome$$romejs$js$analysis$types$MaybeT_ts$default(scope, originNode, getType(data.parent));
    }

    humanize(builder) {
      return '?' +
      builder.humanize(this.parent);
    }

    explodeUnion() {
      return (
        [
          new ___R$project$rome$$romejs$js$analysis$types$VoidT_ts$default(this.scope, this.originNode),
          new ___R$project$rome$$romejs$js$analysis$types$NullT_ts$default(this.scope, this.originNode),
          ...this.utils.explodeUnion(this.parent),
        ]
      );
    }

    compatibleWith(otherType) {
      if (otherType instanceof ___R$project$rome$$romejs$js$analysis$types$MaybeT_ts$default) {
        return this.utils.checkCompability(this.parent, otherType.parent);
      } else {
        return (
          otherType instanceof ___R$project$rome$$romejs$js$analysis$types$VoidT_ts$default || otherType instanceof ___R$project$rome$$romejs$js$analysis$types$NullT_ts$default ||
          this.utils.checkCompability(this.parent, otherType)
        );
      }
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$MaybeT_ts$default.type =
    'MaybeT';

  // project-rome/@romejs/js-analysis/types/MixedT.ts
class ___R$project$rome$$romejs$js$analysis$types$MixedT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___R$project$rome$$romejs$js$analysis$types$MixedT_ts$default(scope, originNode);
    }

    compatibleWith() {
      return false;
    }

    humanize() {
      return 'mixed';
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$MixedT_ts$default.type =
    'MixedT';

  // project-rome/@romejs/js-analysis/types/NumericT.ts
class ___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default {
    constructor(scope, originNode) {
      super(
        scope,
        originNode,
        {
          props: [],
          proto: scope.intrinsics.NumberPrototype,
          calls: [],
        },
      );
    }

    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default(scope, originNode);
    }

    humanize() {
      return 'number';
    }

    compatibleWith(type) {
      // a numeric literal can flow into a generic number
      return type instanceof ___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default || type instanceof ___R$project$rome$$romejs$js$analysis$types$NumericLiteralT_ts$default;
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default.type =
    'NumericT';

  // project-rome/@romejs/js-analysis/types/NumericLiteralT.ts
class ___R$project$rome$$romejs$js$analysis$types$NumericLiteralT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default {
    constructor(scope, originNode, value) {
      super(
        scope,
        originNode,
        {
          props: [],
          proto: scope.intrinsics.NumberPrototype,
          calls: [],
        },
      );
      this.value = value;
    }

    serialize() {
      return {value: this.value};
    }

    static hydrate(scope, originNode, data) {
      return new ___R$project$rome$$romejs$js$analysis$types$NumericLiteralT_ts$default(scope, originNode, Number(data.value));
    }

    humanize() {
      return String(this.value);
    }

    compatibleWith(type) {
      return (
        type instanceof ___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default ||
        type instanceof ___R$project$rome$$romejs$js$analysis$types$NumericLiteralT_ts$default &&
          type.value === this.value
      );
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$NumericLiteralT_ts$default.type =
    'NumericLiteralT';

  // project-rome/@romejs/js-analysis/types/ImportT.ts
class ___R$project$rome$$romejs$js$analysis$types$ImportT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, opts) {
      super(scope, originNode);
      this.importedName = opts.importedName;
      this.relative =
        opts.relative === undefined
          ? scope.evaluator.filename : opts.relative;
      this.source = opts.source;
      this.absolute = undefined;
      this.resolvedType = undefined;
      scope.evaluator.addImport(
        this,
        {
          importedName: this.importedName,
          relative: this.relative,
          source: this.source,
        },
      );
    }

    setAbsolute(absolute) {
      this.absolute = absolute;
    }

    setResolvedType(resolvedType) {
      this.resolvedType = resolvedType;
    }

    serialize() {
      return (
        {
          importedName: this.importedName,
          relative: this.relative,
          source: this.source,
        }
      );
    }

    static hydrate(scope, originNode, data) {
      return (
        new ___R$project$rome$$romejs$js$analysis$types$ImportT_ts$default(
          scope,
          originNode,
          {
            importedName: String(data.importedName),
            source: String(data.source),
            relative: String(data.relative),
          },
        )
      );
    }

    humanize(builder) {
      let object;
      if (this.resolvedType !== undefined) {
        object = builder.humanize(this.resolvedType);
      } else if (this.absolute === undefined) {
        object = '$Exports<"' +
        this.source +
        '", "' +
        this.relative +
        '">';
      } else {
        object = '$Exports<"' +
        this.absolute +
        '">';
      }

      if (this.importedName === undefined) {
        return object;
      } else {
        return object +
        '.' +
        this.importedName;
      }
    }

    reduce() {
      if (this.resolvedType === undefined) {
        return this;
      } else {
        return this.resolvedType;
      }
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$ImportT_ts$default.type =
    'ImportT';

  // project-rome/@romejs/js-analysis/types/StringT.ts
class ___R$project$rome$$romejs$js$analysis$types$StringT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default {
    constructor(scope, originNode) {
      super(
        scope,
        originNode,
        {
          props: [],
          proto: scope.intrinsics.StringPrototype,
          calls: [],
        },
      );
    }

    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___R$project$rome$$romejs$js$analysis$types$StringT_ts$default(scope, originNode);
    }

    humanize() {
      return 'string';
    }

    compatibleWith(type) {
      // a string literal can flow into a generic string
      return type instanceof ___R$project$rome$$romejs$js$analysis$types$StringT_ts$default || type instanceof ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default;
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$StringT_ts$default.type =
    'StringT';

  // project-rome/@romejs/js-analysis/types/ExhaustiveT.ts
class ___R$$priv$project$rome$$romejs$js$analysis$types$ExhaustiveT_ts$ENotExhaustive extends ___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default {
    constructor(scope, originNode, target, only, extraenous) {
      super(scope, originNode);
      this.target = target;
      this.only = only;
      this.extraenous = extraenous;
    }

    getError() {
      let message = 'Expected only a ' +
      this.utils.humanize(this.only) +
      ' but got ' +
      this.utils.humanize(
        this.target,
      );
      //message += `but allows ${this.extraenous.map(type => this.utils.humanize(type)).join(' | ')}`;
      return (
        {
          category: 'typeCheck/notExhaustive',
          message,
          lowerTarget: this.target,
        }
      );
    }
  }

  ___R$$priv$project$rome$$romejs$js$analysis$types$ExhaustiveT_ts$ENotExhaustive.type =
    'ENotExhaustive';
  class ___R$project$rome$$romejs$js$analysis$types$ExhaustiveT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, target, only) {
      super(scope, originNode);
      this.target = target;
      this.only = only;
    }

    serialize(addType) {
      return (
        {
          target: addType(this.target),
          only: addType(this.only),
        }
      );
    }

    static hydrate(scope, originNode, data, getType) {
      return (
        new ___R$project$rome$$romejs$js$analysis$types$ExhaustiveT_ts$default(
          scope,
          originNode,
          getType(data.target),
          getType(
            data.only,
          ),
        )
      );
    }

    reduce() {
      const target = this.utils.reduce(this.target);
      const only = this.utils.reduce(this.only);
      if (target instanceof ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default || only instanceof ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default) {
        return this.only;
      }

      const targetCandidates = this.utils.explodeUnion(target);
      const onlyCandidates = this.utils.explodeUnion(only);

      const extraneous = [];
      for (const possible of targetCandidates) {
        let compatible = false;

        for (const otherType of onlyCandidates) {
          if (this.utils.isCompatibleWith(possible, otherType)) {
            compatible = true;
          }
        }

        if (compatible === false) {
          extraneous.push(possible);
        }
      }

      if (extraneous.length === 0) {
        return target;
      } else {
        return (
          new ___R$$priv$project$rome$$romejs$js$analysis$types$ExhaustiveT_ts$ENotExhaustive(
            this.scope,
            this.originNode,
            this.target,
            this.only,
            extraneous,
          )
        );
      }
    }

    humanize(builder) {
      return (
        'exhaustive ' +
        builder.humanize(this.target) +
        ' should only match ' +
        builder.humanize(
          this.target,
        )
      );
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$ExhaustiveT_ts$default.type =
    'ExhaustiveT';

  // project-rome/@romejs/js-analysis/types/InstanceT.ts
class ___R$project$rome$$romejs$js$analysis$types$InstanceT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default {
    constructor(scope, originNode, target, typeParameters) {
      const prototype = new ___R$project$rome$$romejs$js$analysis$types$GetPropT_ts$default(
        scope,
        originNode,
        target,
        new ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default(scope, originNode, 'prototype'),
      );
      super(
        scope,
        originNode,
        {
          props: [],
          proto: prototype,
          calls: [],
        },
      );

      this.typeParameters = typeParameters;
      this.target = target;
    }

    serialize(addType) {
      return (
        {
          target: addType(this.target),
          params: this.typeParameters.map((type) => addType(type)),
        }
      );
    }

    static hydrate(scope, originNode, data, getType) {
      return (
        new ___R$project$rome$$romejs$js$analysis$types$InstanceT_ts$default(
          scope,
          originNode,
          getType(data.target),
          Array(
            data.params,
          ).map(
            (id) => getType(id),
          ),
        )
      );
    }

    humanize(builder) {
      const name = builder.humanize(this.target);
      const typeParams = this.typeParameters;
      if (typeParams.length === 0) {
        return name;
      } else {
        return (
          name +
          '<' +
          typeParams.map((param) => builder.humanize(param)).join(
            ', ',
          ) +
          '>'
        );
      }
    }

    compatibleWith(otherType) {
      return (
        otherType instanceof ___R$project$rome$$romejs$js$analysis$types$InstanceT_ts$default &&
          this.utils.checkCompability(
            this.target,
            otherType.target,
          )
      );
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$InstanceT_ts$default.type =
    'InstanceT';

  // project-rome/@romejs/js-analysis/types/GenericT.ts
class ___R$project$rome$$romejs$js$analysis$types$GenericT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, name, type) {
      super(scope, originNode);
      this.name = name;
      this.type = type;
    }

    serialize(addType) {
      return (
        {
          name: this.name,
          type: addType(this.type),
        }
      );
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___R$project$rome$$romejs$js$analysis$types$GenericT_ts$default(scope, originNode, String(data.name), getType(data.type));
    }

    humanize() {
      return this.name;
    }

    reduce() {
      const type = this.utils.reduce(this.type);
      if (type instanceof ___R$project$rome$$romejs$js$analysis$types$ClassT_ts$default) {
        return new ___R$project$rome$$romejs$js$analysis$types$InstanceT_ts$default(this.scope, this.originNode, this.type, []);
      } else {
        return type;
      }
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$GenericT_ts$default.type =
    'GenericT';

  // project-rome/@romejs/js-analysis/types/BinaryOpT.ts
function ___R$$priv$project$rome$$romejs$js$analysis$types$BinaryOpT_ts$isNumber(t) {
    return t instanceof ___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default || t instanceof ___R$project$rome$$romejs$js$analysis$types$NumericLiteralT_ts$default;
  }

  class ___R$project$rome$$romejs$js$analysis$types$BinaryOpT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, left, operator, right) {
      super(scope, originNode);
      this.operator = operator;
      this.left = left;
      this.right = right;
    }

    serialize(addType) {
      return (
        {
          left: addType(this.left),
          right: addType(this.right),
        }
      );
    }

    static hydrate(scope, originNode, data, getType) {
      return (
        new ___R$project$rome$$romejs$js$analysis$types$BinaryOpT_ts$default(
          scope,
          originNode,
          getType(data.left),
          String(
            data.operator,
          ),
          getType(data.right),
        )
      );
    }

    reduce() {
      const left = this.utils.reduce(this.left);
      const right = this.utils.reduce(this.right);
      const {scope, originNode, operator} = this;

      // return type
      switch (operator) {
        case // returns booleans
        '===':
        case '==':
        case '!=':
        case '!==':
        case '<':
        case '<=':
        case '>':
        case '>=':
        case 'in':
        case 'instanceof':
          // TODO return BooleanLiteralT in the cases whe we have all the info
          return new ___R$project$rome$$romejs$js$analysis$types$BooleanT_ts$default(scope, originNode);

        // Returns a string or a number
        case '+':
          if (left instanceof ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default || right instanceof ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default) {
            return new ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default(scope, originNode);
          } else if (left instanceof ___R$project$rome$$romejs$js$analysis$types$NumericLiteralT_ts$default &&
            right instanceof
            ___R$project$rome$$romejs$js$analysis$types$NumericLiteralT_ts$default) {
            return new ___R$project$rome$$romejs$js$analysis$types$NumericLiteralT_ts$default(scope, originNode, left.value + right.value);
          } else if (___R$$priv$project$rome$$romejs$js$analysis$types$BinaryOpT_ts$isNumber(left) && ___R$$priv$project$rome$$romejs$js$analysis$types$BinaryOpT_ts$isNumber(right)) {
            return new ___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default(scope, originNode);
          } else if (left instanceof ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default &&
            right instanceof
            ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default) {
            return new ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default(scope, originNode, left.value + right.value);
          } else {
            return new ___R$project$rome$$romejs$js$analysis$types$StringT_ts$default(scope, originNode);
          }

        // returns a number
        case '<<':
        case '>>':
        case '>>>':
        case '-':
        case '*':
        case '/':
        case '%':
        case '**':
        case '|':
        case '^':
        case '&':
          // TODO return NumericLiteralT if left/right are literals too
          return new ___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default(scope, originNode);

        default:
          throw new Error('Unknown operator');
      }
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$BinaryOpT_ts$default.type =
    'BinaryOpT';

  // project-rome/@romejs/js-analysis/types/errors/MissingUnionE.ts
class ___R$project$rome$$romejs$js$analysis$types$errors$MissingUnionE_ts$default extends ___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default {
    constructor(scope, originNode, target, union, missing) {
      super(scope, originNode);
      this.target = target;
      this.union = union;
      this.missing = missing;
    }

    getError() {
      return (
        {
          category: 'typeCheck/missingCondition',
          message: 'Missing the conditions ' +
          this.missing.map(
            (
              type,
            ) =>
              this.utils.humanize(type),
          ).join(
            ', ',
          ),
          lowerTarget: this.target,
        }
      );
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$errors$MissingUnionE_ts$default.type =
    'MissingUnionE';

  // project-rome/@romejs/js-analysis/types/RefinedT.ts
class ___R$project$rome$$romejs$js$analysis$types$RefinedT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, root, remove) {
      super(scope, originNode);
      this.root = root;
      this.remove = remove;
    }

    reduce() {
      const {root} = this;

      const exploded = this.utils.explodeUnion(root);
      const removeTypes = this.utils.explodeUnion(this.remove);

      const clean = [];
      const removed = [];

      // remove any possible derived types from the root that are compatible with the removed type
      for (const type of exploded) {
        let compatible = false;

        // check if any of the removed types are compatible, if every removed type is incompatible then

        // we've refined away the type
        for (const remove of removeTypes) {
          if (this.utils.isCompatibleWith(type, remove)) {
            compatible = true;
          }
        }

        if (compatible === false) {
          clean.push(type);
        } else {
          removed.push(type);
        }
      }

      if (removed.length === 0) {
        // return an error here because the removed type doesn't exist in the root
        return (
          new ___R$project$rome$$romejs$js$analysis$types$errors$MissingUnionE_ts$default(
            root.scope,
            root.originNode,
            root,
            this.remove,
            removed,
          )
        );
      } else {
        return root.scope.createUnion(clean, root.originNode);
      }
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$RefinedT_ts$default.type =
    'RefinedT';

  // project-rome/@romejs/js-analysis/types/RefineTypeofT.ts
class ___R$project$rome$$romejs$js$analysis$types$RefineTypeofT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    constructor(scope, node, str, fallback) {
      super(scope, node);
      this.str = str;
      this.fallback = fallback;
    }

    reduce() {
      const {fallback, utils} = this;
      const str = utils.reduce(this.str);

      if (str instanceof ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default) {
        let val;

        switch (str.value) {
          case 'string':
            val = new ___R$project$rome$$romejs$js$analysis$types$StringT_ts$default(this.scope, undefined);
            break;

          case 'number':
            val = new ___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default(this.scope, undefined);
            break;

          case 'undefined':
            val = new ___R$project$rome$$romejs$js$analysis$types$VoidT_ts$default(this.scope, undefined);
            break;

          case 'boolean':
            val = new ___R$project$rome$$romejs$js$analysis$types$BooleanT_ts$default(this.scope, undefined);
            break;

          case 'symbol':
          case 'function':
          case 'object':
            // TODO
            return utils.reduce(fallback);

          default:
            // TODO complain about unknown value
            return utils.reduce(fallback);
        }

        // make sure our refinement is actually possible and matches a value in `fallback`

        // then pluck the matching type
        const types = utils.explodeUnion(fallback);
        for (const type of types) {
          if (utils.isCompatibleWith(type, val)) {
            return utils.reduce(type);
          }
        }

        // TODO complain of a missing condition
        return utils.reduce(fallback);
      }

      return utils.reduce(fallback);
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$RefineTypeofT_ts$default.type =
    'RefineTypeofT';

  // project-rome/@romejs/js-analysis/types/TypeofT.ts
class ___R$project$rome$$romejs$js$analysis$types$TypeofT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    constructor(scope, node, obj) {
      super(scope, node);
      this.obj = obj;
    }

    reduce() {
      const types = this.utils.explodeUnion(this.obj);

      const possibleTypes = [];
      for (const rawType of types) {
        const type = this.utils.reduce(rawType);
        let typeStr;

        if (type instanceof ___R$project$rome$$romejs$js$analysis$types$StringT_ts$default || type instanceof ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default) {
          typeStr = 'string';
        }

        if (type instanceof ___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default || type instanceof ___R$project$rome$$romejs$js$analysis$types$NumericLiteralT_ts$default) {
          typeStr = 'number';
        }

        if (type instanceof ___R$project$rome$$romejs$js$analysis$types$BooleanT_ts$default || type instanceof ___R$project$rome$$romejs$js$analysis$types$BooleanLiteralT_ts$default) {
          typeStr = 'boolean';
        }

        if (type instanceof ___R$project$rome$$romejs$js$analysis$types$VoidT_ts$default) {
          typeStr = 'undefined';
        }

        if (type instanceof ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default) {
          if (type.calls.length === 0) {
            typeStr = 'object';
          } else {
            typeStr = 'function';
          }
        }

        if (type instanceof ___R$project$rome$$romejs$js$analysis$types$NullT_ts$default) {
          typeStr = 'object';
        }

        // TODO symbol

        // TODO bigint
        if (typeStr !== undefined) {
          possibleTypes.push(
            new ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default(
              this.scope,
              this.originNode,
              typeStr,
            ),
          );
        }
      }

      if (possibleTypes.length === 0) {
        return new ___R$project$rome$$romejs$js$analysis$types$StringT_ts$default(this.scope, this.originNode);
      } else {
        return this.scope.createUnion(possibleTypes, this.originNode);
      }
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$TypeofT_ts$default.type =
    'TypeofT';

  // project-rome/@romejs/js-analysis/types/SideEffectT.ts
class ___R$project$rome$$romejs$js$analysis$types$SideEffectT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, actualType) {
      super(scope, originNode);
      this.actualType = actualType;
    }

    reduce() {
      return this.utils.reduce(this.actualType);
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$SideEffectT_ts$default.type =
    'SideEffectT';

  // project-rome/@romejs/js-analysis/types/BlockT.ts
class ___R$project$rome$$romejs$js$analysis$types$BlockT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, body) {
      super(scope, originNode);
      this.body = body;
    }

    reduce() {
      const body = [];
      let changed = false;

      for (const type of this.body) {
        const reduced = this.utils.reduce(type);
        body.push(reduced);
        if (reduced !== type) {
          changed = true;
        }
      }

      if (changed) {
        return new ___R$project$rome$$romejs$js$analysis$types$BlockT_ts$default(this.scope, this.originNode, body);
      } else {
        return this;
      }
    }

    humanize() {
      return '{}';
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$BlockT_ts$default.type =
    'BlockT';

  // project-rome/@romejs/js-analysis/types/errors/UndeclaredVarE.ts
class ___R$project$rome$$romejs$js$analysis$types$errors$UndeclaredVarE_ts$default extends ___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default {
    constructor(scope, originNode, name) {
      super(scope, originNode);
      this.name = name;
    }

    getError() {
      const possibleNames = this.scope.getBindingNames();
      return (
        {
          category: 'typeCheck/undeclaredVariable',
          message: 'Undeclared variable \'' +
          this.name +
          '\'',
          advice: ___R$project$rome$$romejs$diagnostics$helpers_ts$buildSuggestionAdvice(this.name, possibleNames),
          lowerTarget: this,
        }
      );
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$errors$UndeclaredVarE_ts$default.type =
    'UndeclaredVarE';

  // project-rome/@romejs/js-analysis/types/index.ts
const ___R$project$rome$$romejs$js$analysis$types$index_ts = {
    get default() {
      return (
        ___R$project$rome$$romejs$js$analysis$types$index_ts$default
      );
    },
  };
  const ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types = new Map();
  const ___R$project$rome$$romejs$js$analysis$types$index_ts$default = ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types;
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('AnyT', ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('BooleanLiteralT', ___R$project$rome$$romejs$js$analysis$types$BooleanLiteralT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('BooleanT', ___R$project$rome$$romejs$js$analysis$types$BooleanT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('CallT', ___R$project$rome$$romejs$js$analysis$types$CallT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('ClassT', ___R$project$rome$$romejs$js$analysis$types$ClassT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('EmptyT', ___R$project$rome$$romejs$js$analysis$types$EmptyT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('FunctionT', ___R$project$rome$$romejs$js$analysis$types$FunctionT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('GetPropT', ___R$project$rome$$romejs$js$analysis$types$GetPropT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('IntersectionT', ___R$project$rome$$romejs$js$analysis$types$IntersectionT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('MaybeT', ___R$project$rome$$romejs$js$analysis$types$MaybeT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('MixedT', ___R$project$rome$$romejs$js$analysis$types$MixedT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('NullT', ___R$project$rome$$romejs$js$analysis$types$NullT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('NumericLiteralT', ___R$project$rome$$romejs$js$analysis$types$NumericLiteralT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('NumericT', ___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('ObjPropT', ___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('ObjT', ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('OpenIntrinsicT', ___R$project$rome$$romejs$js$analysis$types$OpenIntrinsicT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('ImportT', ___R$project$rome$$romejs$js$analysis$types$ImportT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('OpenT', ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('StringLiteralT', ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('StringT', ___R$project$rome$$romejs$js$analysis$types$StringT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('UnionT', ___R$project$rome$$romejs$js$analysis$types$UnionT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('UnknownT', ___R$project$rome$$romejs$js$analysis$types$UnknownT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('VoidT', ___R$project$rome$$romejs$js$analysis$types$VoidT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('ExhaustiveT', ___R$project$rome$$romejs$js$analysis$types$ExhaustiveT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('InstanceT', ___R$project$rome$$romejs$js$analysis$types$InstanceT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('GenericT', ___R$project$rome$$romejs$js$analysis$types$GenericT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('ObjIndexPropT', ___R$project$rome$$romejs$js$analysis$types$ObjIndexPropT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('BinaryOpT', ___R$project$rome$$romejs$js$analysis$types$BinaryOpT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('RefinedT', ___R$project$rome$$romejs$js$analysis$types$RefinedT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('RefineTypeofT', ___R$project$rome$$romejs$js$analysis$types$RefineTypeofT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('TypeofT', ___R$project$rome$$romejs$js$analysis$types$TypeofT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('SideEffectT', ___R$project$rome$$romejs$js$analysis$types$SideEffectT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('BlockT', ___R$project$rome$$romejs$js$analysis$types$BlockT_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('E', ___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('NotCallableE', ___R$project$rome$$romejs$js$analysis$types$errors$NotCallableE_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('UndeclaredVarE', ___R$project$rome$$romejs$js$analysis$types$errors$UndeclaredVarE_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('UnknownPropE', ___R$project$rome$$romejs$js$analysis$types$errors$UnknownPropE_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('UnknownImportE', ___R$project$rome$$romejs$js$analysis$types$errors$UnknownImportE_ts$default);
  ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set('MissingUnionE', ___R$project$rome$$romejs$js$analysis$types$errors$MissingUnionE_ts$default);

  // project-rome/@romejs/js-analysis/evaluators/temp/AmbiguousFlowTypeCastExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$temp$AmbiguousFlowTypeCastExpression_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$temp$AmbiguousFlowTypeCastExpression_ts$ambiguousFlowTypeCastExpression.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/types/AnyKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$types$AnyKeywordTypeAnnotation_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$types$AnyKeywordTypeAnnotation_ts$anyKeywordTypeAnnotation.assert(node);
    return new ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default(scope, node);
  }

  // project-rome/@romejs/js-analysis/evaluators/expressions/ArrayExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$ArrayExpression_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$expressions$ArrayExpression_ts$arrayExpression.assert(node);
    const elems = [];

    for (const expr of node.elements) {
      if (expr === undefined) {
        // TODO array hole, add undefined here
      } else {
        elems.push(scope.evaluate(expr));
      }
    }

    let value;
    if (elems.length === 0) {
      value = new ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default(scope, node);
    } else {
      value = scope.createUnion(elems, node);
    }
    return new ___R$project$rome$$romejs$js$analysis$types$InstanceT_ts$default(scope, node, scope.intrinsics.Array, [value]);
  }

  // project-rome/@romejs/js-analysis/utils/executeAtom.ts
function ___R$project$rome$$romejs$js$analysis$utils$executeAtom_ts$default(
    leftNode,
    rightType,
    scope,
  ) {
    switch (leftNode.type) {
      case 'BindingIdentifier':
        scope.addBinding(leftNode.name, rightType);
        break;

      case 'BindingObjectPattern':
        for (const prop of leftNode.properties) {
          ___R$project$rome$$romejs$js$analysis$utils$executeAtom_ts$default(prop, rightType, scope);
        }
        break;

      case 'BindingObjectPatternProperty':
        {
          const {key} = leftNode;
          if (key.type === 'ComputedPropertyKey' || key.value.type !== 'Identifier') {
            throw new Error('unimplemented');
          }

          const propKey = new ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default(scope, key, key.value.name);
          const getProp = new ___R$project$rome$$romejs$js$analysis$types$GetPropT_ts$default(scope, leftNode, rightType, propKey);
          ___R$project$rome$$romejs$js$analysis$utils$executeAtom_ts$default(leftNode.value, getProp, scope);
          break;
        }

      case 'BindingArrayPattern':
        for (let i = 0;
        i < leftNode.elements.length;
        i++) {
          const elem = leftNode.elements[i];
          if (elem === undefined) {
            continue;
          }

          const propKey = new ___R$project$rome$$romejs$js$analysis$types$NumericLiteralT_ts$default(scope, elem, i);
          const getProp = new ___R$project$rome$$romejs$js$analysis$types$GetPropT_ts$default(scope, leftNode, rightType, propKey);
          ___R$project$rome$$romejs$js$analysis$utils$executeAtom_ts$default(elem, getProp, scope);
        }
        break;

      case 'BindingAssignmentPattern':
        ___R$project$rome$$romejs$js$analysis$utils$executeAtom_ts$default(leftNode.left, rightType, scope);
        break;
    }
  }

  // project-rome/@romejs/js-analysis/utils/executeFunction.ts
function ___R$project$rome$$romejs$js$analysis$utils$executeFunction_ts$default(
    node,
    scope,
    bindId,
    thisContext,
  ) {
    const {head} = node;

    // build return type
    const returns = new ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default(scope, head.returnType ? head.returnType : node);

    // type check the body
    const bodyScope = new ___R$project$rome$$romejs$js$analysis$scopes_ts$FunctionScope(
      {
        parentScope: scope,
      },
      {
        thisContext: thisContext ? thisContext : new ___R$project$rome$$romejs$js$analysis$types$VoidT_ts$default(scope, undefined),
        returnType: returns,
      },
    );
    if (head.typeParameters) {
      bodyScope.evaluate(head.typeParameters);
    }

    // build param types
    const params = [];
    let rest;
    for (let paramNode of head.params) {
      let optional = paramNode.meta !== undefined &&
        paramNode.meta.optional ===
        true;
      if (paramNode.type === 'BindingAssignmentPattern') {
        optional = false;
        paramNode = paramNode.left;
      }

      let paramType;
      if (paramNode.meta !== undefined &&
        paramNode.meta.typeAnnotation !==
        undefined) {
        paramType = scope.evaluate(paramNode.meta.typeAnnotation);
      } else {
        paramType = new ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default(scope, paramNode);
      }

      if (optional) {
        paramType = new ___R$project$rome$$romejs$js$analysis$types$MaybeT_ts$default(scope, paramNode, paramType);
      }

      params.push(paramType);
    }

    for (let i = 0;
    i < head.params.length;
    i++) {
      ___R$project$rome$$romejs$js$analysis$utils$executeAtom_ts$default(head.params[i], params[i], scope);
    }
    const block = bodyScope.evaluate(node.body);

    // if no types have flowed into the return type then it'll return undefined
    if (returns.hasConnections() === false) {
      //const ret = new VoidT(scope, node);

      //returns.shouldMatch(ret);
    }

    if (head.returnType) {
      returns.shouldMatch(scope.evaluate(head.returnType));
    }

    // create the function
    const func = new ___R$project$rome$$romejs$js$analysis$types$FunctionT_ts$default(scope, node, {params, rest, returns, body: block});
    return func;
  }

  // project-rome/@romejs/js-analysis/evaluators/expressions/ArrowFunctionExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$ArrowFunctionExpression_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$expressions$ArrowFunctionExpression_ts$arrowFunctionExpression.assert(node);

    let thisContext;
    const funcScope = scope.findOptional(___R$project$rome$$romejs$js$analysis$scopes_ts$FunctionScope);
    if (funcScope !== undefined) {
      thisContext = funcScope.meta.thisContext;
    }

    return ___R$project$rome$$romejs$js$analysis$utils$executeFunction_ts$default(node, scope, true, thisContext);
  }

  // project-rome/@romejs/js-analysis/evaluators/patterns/AssignmentArrayPattern.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$patterns$AssignmentArrayPattern_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$patterns$AssignmentArrayPattern_ts$assignmentArrayPattern.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/patterns/AssignmentAssignmentPattern.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$patterns$AssignmentAssignmentPattern_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$patterns$AssignmentAssignmentPattern_ts$assignmentAssignmentPattern.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/expressions/AssignmentExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$AssignmentExpression_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$expressions$AssignmentExpression_ts$assignmentExpression.assert(node);

    const {left, right, operator} = node;

    if (operator === '=') {
      const rightType = scope.evaluate(right);
      const leftType = scope.evaluate(left);
      leftType.shouldMatch(rightType);
      return new ___R$project$rome$$romejs$js$analysis$types$SideEffectT_ts$default(scope, node, rightType);
    } else {
      // TODO!
    }
  }

  // project-rome/@romejs/js-analysis/evaluators/patterns/AssignmentIdentifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$patterns$AssignmentIdentifier_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$patterns$AssignmentIdentifier_ts$assignmentIdentifier.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/patterns/AssignmentObjectPattern.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$patterns$AssignmentObjectPattern_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$patterns$AssignmentObjectPattern_ts$assignmentObjectPattern.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/patterns/AssignmentObjectPatternProperty.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$patterns$AssignmentObjectPatternProperty_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$patterns$AssignmentObjectPatternProperty_ts$assignmentObjectPatternProperty.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/expressions/AwaitExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$AwaitExpression_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$expressions$AwaitExpression_ts$awaitExpression.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/types/BigIntKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$types$BigIntKeywordTypeAnnotation_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$types$BigIntKeywordTypeAnnotation_ts$bigIntKeywordTypeAnnotation.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/literals/BigIntLiteral.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$literals$BigIntLiteral_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$literals$BigIntLiteral_ts$bigIntLiteral.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/expressions/BinaryExpression.ts
function ___R$$priv$project$rome$$romejs$js$analysis$evaluators$expressions$BinaryExpression_ts$maybeRefine(
    node,
    left,
    right,
    scope,
  ) {
    const evaluator = scope.evaluator;

    if (left.type === 'Identifier') {
      scope.addBinding(left.name, evaluator.getTypeFromEvaluatedNode(right));
      return true;
    }

    if (left.type === 'UnaryExpression' && left.operator === 'typeof' &&
      left.argument.type === 'ReferenceIdentifier') {
      const name = left.argument.name;
      const binding = scope.getBinding(name);
      if (binding !== undefined) {
        const type = new ___R$project$rome$$romejs$js$analysis$types$RefineTypeofT_ts$default(
          scope,
          node,
          evaluator.getTypeFromEvaluatedNode(right),
          binding,
        );
        scope.addBinding(name, type);
        return true;
      }
    }

    return false;
  }

  function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$BinaryExpression_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$expressions$BinaryExpression_ts$binaryExpression.assert(node);

    const left = scope.evaluate(node.left);
    const right = scope.evaluate(node.right);

    // Enforce that the left and right sides of these operators are numbers
    switch (node.operator) {
      case '<<':
      case '>>':
      case '>>>':
      case '-':
      case '*':
      case '/':
      case '%':
      case '**':
      case '|':
      case '^':
      case '&':
      case '<':
      case '<=':
      case '>':
      case '>=':
        const num = new ___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default(scope, undefined);
        new ___R$project$rome$$romejs$js$analysis$types$ExhaustiveT_ts$default(scope, node, left, num);
        new ___R$project$rome$$romejs$js$analysis$types$ExhaustiveT_ts$default(scope, node, right, num);
        break;
    }

    // Refinements
    let refinedScope = scope;
    if (node.operator === '===') {
      refinedScope = scope.refine();
      ___R$$priv$project$rome$$romejs$js$analysis$evaluators$expressions$BinaryExpression_ts$maybeRefine(node, node.left, node.right, refinedScope) ||
      ___R$$priv$project$rome$$romejs$js$analysis$evaluators$expressions$BinaryExpression_ts$maybeRefine(
        node,
        node.right,
        node.left,
        refinedScope,
      );
    }

    return new ___R$project$rome$$romejs$js$analysis$types$BinaryOpT_ts$default(refinedScope, node, left, node.operator, right);
  }

  // project-rome/@romejs/js-analysis/evaluators/patterns/BindingArrayPattern.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$patterns$BindingArrayPattern_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$patterns$BindingArrayPattern_ts$bindingArrayPattern.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/patterns/BindingAssignmentPattern.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$patterns$BindingAssignmentPattern_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$patterns$BindingAssignmentPattern_ts$bindingAssignmentPattern.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/patterns/BindingIdentifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$patterns$BindingIdentifier_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/patterns/BindingObjectPattern.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$patterns$BindingObjectPattern_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$patterns$BindingObjectPattern_ts$bindingObjectPattern.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/patterns/BindingObjectPatternProperty.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$patterns$BindingObjectPatternProperty_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$patterns$BindingObjectPatternProperty_ts$bindingObjectPatternProperty.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/statements/BlockStatement.ts
function ___R$$priv$project$rome$$romejs$js$analysis$evaluators$statements$BlockStatement_ts$shouldHoistExecute(node) {
    if (node === undefined) {
      return false;
    }

    if (node.type === 'FunctionDeclaration' || ___R$project$rome$$romejs$js$ast$utils$isTypeNode_ts$default(node)) {
      return true;
    }

    if (node.type === 'ExportLocalDeclaration' ||
    node.type ===
    'ExportDefaultDeclaration') {
      return ___R$$priv$project$rome$$romejs$js$analysis$evaluators$statements$BlockStatement_ts$shouldHoistExecute(node.declaration);
    }

    return false;
  }

  function ___R$project$rome$$romejs$js$analysis$evaluators$statements$BlockStatement_ts$default(node, scope) {
    node = node.type === 'Program' ? node : ___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts$blockStatement.assert(node);

    // Declare variables
    for (const child of node.body) {
      if (child.type === 'ImportDeclaration') {
        scope.evaluate(child);
      }

      const declarations = ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(child);
      for (const id of declarations) {
        scope.declareBinding(id.name, id);
      }
    }

    const types = [];

    // Execute hoisted nodes
    const body = [];
    for (const child of node.body) {
      if (child.type === 'ImportDeclaration') {
        // already executed
      } else if (___R$$priv$project$rome$$romejs$js$analysis$evaluators$statements$BlockStatement_ts$shouldHoistExecute(child)) {
        types.push(scope.evaluate(child));
      } else {
        body.push(child);
      }
    }

    // Execute rest
    for (const child of body) {
      types.push(scope.evaluate(child));
    }

    return new ___R$project$rome$$romejs$js$analysis$types$BlockT_ts$default(scope, node, types);
  }

  // project-rome/@romejs/js-analysis/evaluators/types/BooleanKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$types$BooleanKeywordTypeAnnotation_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$types$BooleanKeywordTypeAnnotation_ts$booleanKeywordTypeAnnotation.assert(node);
    return new ___R$project$rome$$romejs$js$analysis$types$BooleanT_ts$default(scope, node);
  }

  // project-rome/@romejs/js-analysis/evaluators/literals/BooleanLiteral.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$literals$BooleanLiteral_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$literals$BooleanLiteral_ts$booleanLiteral.assert(node);
    return new ___R$project$rome$$romejs$js$analysis$types$BooleanLiteralT_ts$default(scope, node, node.value);
  }

  // project-rome/@romejs/js-analysis/evaluators/types/BooleanLiteralTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$types$BooleanLiteralTypeAnnotation_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$types$BooleanLiteralTypeAnnotation_ts$booleanLiteralTypeAnnotation.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/statements/BreakStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$BreakStatement_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$statements$BreakStatement_ts$breakStatement.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/expressions/CallExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$CallExpression_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$expressions$CallExpression_ts$callExpression.assert(node);

    return (
      new ___R$project$rome$$romejs$js$analysis$types$CallT_ts$default(
        scope,
        node,
        scope.evaluate(node.callee),
        node.arguments.map(
          (arg) => {
            return scope.evaluate(arg);
          },
        ),
      )
    );
  }

  // project-rome/@romejs/js-analysis/evaluators/auxiliary/CatchClause.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$CatchClause_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$auxiliary$CatchClause_ts$catchClause.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/classes/ClassExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassExpression_ts$default(node, scope) {
    node = node.type === 'ClassDeclaration' ? node : ___R$project$rome$$romejs$js$ast$classes$ClassExpression_ts$classExpression.assert(node);

    const instances = [];
    const statics = [];

    //
    const classInstance = new ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default(scope, node);
    const classId = new ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default(scope, node);

    //
    const bodyScope = new ___R$project$rome$$romejs$js$analysis$scopes_ts$ClassScope(
      {parentScope: scope},
      {
        instance: classInstance,
        static: classId,
      },
    );

    if (node.id !== undefined) {
      bodyScope.addBinding(node.id.name, classId);
    }

    if (node.meta.typeParameters !== undefined) {
      bodyScope.evaluate(node.meta.typeParameters);
    }

    let _constructor = undefined;

    for (const bodyNode of node.meta.body) {
      const type = bodyScope.evaluate(bodyNode);

      if (bodyNode.type === 'ClassMethod' && bodyNode.kind === 'constructor') {
        _constructor = type;
      } else {
        if (bodyNode.type !== 'TSIndexSignature' && bodyNode.meta.static === true) {
          statics.push(type);
        } else {
          instances.push(type);
        }
      }
    }

    //
    const classOrigin = node.id ? node.id : node;
    let type = new ___R$project$rome$$romejs$js$analysis$types$ClassT_ts$default(
      scope,
      classOrigin,
      {
        _constructor,
        instances,
        statics,
        extends: node.meta.superClass
          ? scope.evaluate(node.meta.superClass) : undefined,
      },
    );
    if (node.id) {
      type.setHuman(node.id.name);
    }

    //
    classId.shouldMatch(type);

    //
    const instance = new ___R$project$rome$$romejs$js$analysis$types$InstanceT_ts$default(scope, classOrigin, type, []);
    classInstance.shouldMatch(instance);

    return type;
  }

  // project-rome/@romejs/js-analysis/evaluators/classes/ClassDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassDeclaration_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$classes$ClassDeclaration_ts$classDeclaration.assert(node);
    const type = ___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassExpression_ts$default(node, scope);
    if (node.id) {
      scope.addBinding(node.id.name, type);
    }
    return type;
  }

  // project-rome/@romejs/js-analysis/evaluators/classes/ClassHead.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassHead_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$classes$ClassHead_ts$classHead.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/classes/ClassMethod.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassMethod_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$classes$ClassMethod_ts$classMethod.assert(node);
    if (node.key.type === 'ComputedPropertyKey' === true) {
      // TODO
      return undefined;
    }

    const classScope = scope.find(___R$project$rome$$romejs$js$analysis$scopes_ts$ClassScope);
    const thisContext = node.meta.static === true
      ? classScope.meta.static : classScope.meta.instance;
    const func = ___R$project$rome$$romejs$js$analysis$utils$executeFunction_ts$default(node, scope, false, thisContext);

    if (node.key.value.type !== 'Identifier') {
      throw new Error('Expected only an identifier key');
    }
    return new ___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default(scope, node, node.key.value.name, func);
  }

  // project-rome/@romejs/js-analysis/evaluators/classes/ClassPrivateMethod.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassPrivateMethod_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$classes$ClassPrivateMethod_ts$classPrivateMethod.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/classes/ClassPrivateProperty.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassPrivateProperty_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$classes$ClassPrivateProperty_ts$classPrivateProperty.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/classes/ClassProperty.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassProperty_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$classes$ClassProperty_ts$classProperty.assert(node);

    if (node.key.type === 'ComputedPropertyKey') {
      // TODO
      return undefined;
    }

    const classScope = scope.find(___R$project$rome$$romejs$js$analysis$scopes_ts$ClassScope);
    const funcScope = new ___R$project$rome$$romejs$js$analysis$scopes_ts$ThisScope({parentScope: scope}, classScope.meta.instance);

    let annotatedType;
    let inferredType;

    if (node.typeAnnotation) {
      annotatedType = funcScope.evaluate(node.typeAnnotation);
    }

    if (node.value) {
      inferredType = funcScope.evaluate(node.value);

      if (annotatedType !== undefined) {
        inferredType.shouldMatch(annotatedType);
      }
    }

    if (annotatedType === undefined && inferredType === undefined) {
      // TODO what do we do here?
      inferredType = new ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default(scope, node);
    }

    const actualValue = annotatedType === undefined ? inferredType : annotatedType;
    if (actualValue === undefined) {
      throw new Error('Expected actual value');
    }

    if (node.key.value.type !== 'Identifier') {
      throw new Error('Expected only an identifier key');
    }

    return new ___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default(scope, node, node.key.value.name, actualValue);
  }

  // project-rome/@romejs/js-analysis/evaluators/classes/ClassPropertyMeta.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassPropertyMeta_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$classes$ClassPropertyMeta_ts$classPropertyMeta.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/core/CommentBlock.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$core$CommentBlock_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$core$CommentBlock_ts$commentBlock.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/core/CommentLine.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$core$CommentLine_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$core$CommentLine_ts$commentLine.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/auxiliary/ComputedMemberProperty.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$ComputedMemberProperty_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$auxiliary$ComputedMemberProperty_ts$computedMemberProperty.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/objects/ComputedPropertyKey.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$objects$ComputedPropertyKey_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$objects$ComputedPropertyKey_ts$computedPropertyKey.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/statements/IfStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$IfStatement_ts$default(node, scope) {
    node = node.type === 'ConditionalExpression' ? node : ___R$project$rome$$romejs$js$ast$statements$IfStatement_ts$ifStatement.assert(node);

    const test = scope.evaluate(node.test);
    new ___R$project$rome$$romejs$js$analysis$types$ExhaustiveT_ts$default(scope, node, test, new ___R$project$rome$$romejs$js$analysis$types$BooleanT_ts$default(scope, undefined));

    const hasRefinedTest = test.scope instanceof ___R$project$rome$$romejs$js$analysis$scopes_ts$RefineScope;

    const consequentScope = hasRefinedTest ? test.scope : scope;
    const consequent = consequentScope.evaluate(node.consequent);

    if (node.alternate === undefined) {
      return consequent;
    } else {
      const alternateScope = scope.fork();

      /*if (hasRefinedTest) {
      // get bindings from 'test.scope and flip them
      for (const name of test.scope.getOwnBindingNames()) {
        const outerBinding = scope.getBinding(name);
        invariant(outerBinding !== undefined, 'expected outerBinding for %s', name);

        const refinedBinding = test.scope.getBinding(name);
        invariant(refinedBinding !== undefined, 'expected refinedBinding for %s', name);

        const opposite = new RefinedT(alternateScope, refinedBinding.originNode, outerBinding, refinedBinding);
        alternateScope.addBinding(name, opposite);
      }
    }*/
      return (
        new ___R$project$rome$$romejs$js$analysis$types$UnionT_ts$default(
          scope,
          undefined,
          [
            consequent,
            alternateScope.evaluate(node.alternate),
          ],
        )
      );
    }
  }

  // project-rome/@romejs/js-analysis/evaluators/expressions/ConditionalExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$ConditionalExpression_ts$default(node, scope) {
    return ___R$project$rome$$romejs$js$analysis$evaluators$statements$IfStatement_ts$default(node, scope);
  }

  // project-rome/@romejs/js-analysis/evaluators/statements/ContinueStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$ContinueStatement_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$statements$ContinueStatement_ts$continueStatement.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/statements/DebuggerStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$DebuggerStatement_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$statements$DebuggerStatement_ts$debuggerStatement.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/core/Directive.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$core$Directive_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$core$Directive_ts$directive.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/expressions/DoExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$DoExpression_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$expressions$DoExpression_ts$doExpression.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/statements/DoWhileStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$DoWhileStatement_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$statements$DoWhileStatement_ts$doWhileStatement.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/types/EmptyKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$types$EmptyKeywordTypeAnnotation_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$types$EmptyKeywordTypeAnnotation_ts$emptyKeywordTypeAnnotation.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/statements/EmptyStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$EmptyStatement_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$statements$EmptyStatement_ts$emptyStatement.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/modules/ExportAllDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportAllDeclaration_ts$default(
    node,
    scope,
    {evaluator},
  ) {
    node = ___R$project$rome$$romejs$js$ast$modules$ExportAllDeclaration_ts$exportAllDeclaration.assert(node);
    evaluator.addExportAll(node.source.value);
  }

  // project-rome/@romejs/js-analysis/evaluators/modules/ExportDefaultDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportDefaultDeclaration_ts$default(
    node,
    scope,
    {evaluator},
  ) {
    node = ___R$project$rome$$romejs$js$ast$modules$ExportDefaultDeclaration_ts$exportDefaultDeclaration.assert(node);

    const decl = node.declaration;
    const declType = scope.evaluate(decl);
    evaluator.addExport('default', declType);
    return declType;
  }

  // project-rome/@romejs/js-analysis/evaluators/modules/ExportDefaultSpecifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportDefaultSpecifier_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$modules$ExportDefaultSpecifier_ts$exportDefaultSpecifier.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/modules/ExportExternalDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportExternalDeclaration_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$modules$ExportExternalDeclaration_ts$exportExternalDeclaration.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/modules/ExportExternalSpecifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportExternalSpecifier_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$modules$ExportExternalSpecifier_ts$exportExternalSpecifier.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/modules/ExportLocalDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportLocalDeclaration_ts$default(
    node,
    scope,
    {evaluator},
  ) {
    node = ___R$project$rome$$romejs$js$ast$modules$ExportLocalDeclaration_ts$exportLocalDeclaration.assert(node);

    // export const foo = 'bar';

    // export default function foo() {}
    const decl = node.declaration;
    if (decl !== undefined) {
      const declType = scope.evaluate(decl);

      switch (decl.type) {
        case 'FunctionDeclaration':
        case 'ClassDeclaration':
          const id = decl.id;
          if (id === undefined) {
            throw new Error('Expected id');
          }
          evaluator.addExport(id.name, declType);
          break;

        case 'VariableDeclarationStatement':
          for (const id of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(decl)) {
            const type = scope.getBinding(id.name);
            if (type === undefined) {
              throw new Error('Couldn\'t find binding type for ' +
              id.name);
            }
            evaluator.addExport(id.name, type);
          }
          break;

        case 'TypeAliasTypeAnnotation':
          const type = scope.getBinding(decl.id.name);
          if (type === undefined) {
            throw new Error('Couldn\'t find binding type for ' +
            decl.id.name);
          }
          evaluator.addExport(decl.id.name, type);
          break;
      }

      return declType;
    }

    // export {foo, bar};

    // export {foo, bar} from './foo';
    const source = undefined; // TODO node.source === undefined ? undefined : node.source.value;
    const {specifiers} = node;
    if (specifiers !== undefined) {
      for (const specifier of specifiers) {
        if (specifier.type === 'ExportLocalSpecifier' ||
        specifier.type ===
        'ExportExternalSpecifier') {
          let type;
          if (source === undefined) {
            type = scope.evaluate(specifier.local);
          } else {
            type =
              new ___R$project$rome$$romejs$js$analysis$types$ImportT_ts$default(
                scope,
                node,
                {
                  importedName: specifier.local.name,
                  source,
                },
              );
          }
          evaluator.addExport(specifier.exported.name, type);
        }
      }
    }
  }

  // project-rome/@romejs/js-analysis/evaluators/modules/ExportLocalSpecifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportLocalSpecifier_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$modules$ExportLocalSpecifier_ts$exportLocalSpecifier.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/modules/ExportNamespaceSpecifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportNamespaceSpecifier_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$modules$ExportNamespaceSpecifier_ts$exportNamespaceSpecifier.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/statements/ExpressionStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$ExpressionStatement_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$statements$ExpressionStatement_ts$expressionStatement.assert(node);

    return scope.evaluate(node.expression);
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowArrayTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowArrayTypeAnnotation_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowArrayTypeAnnotation_ts$flowArrayTypeAnnotation.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowClassImplements.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowClassImplements_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowClassImplements_ts$flowClassImplements.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowDeclareClass.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowDeclareClass_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowDeclareClass_ts$flowDeclareClass.assert(node);
    const bodyScope = scope.fork();
    if (node.typeParameters) {
      bodyScope.evaluate(node.typeParameters);
    }

    const calls = [];
    const instances = [];
    const statics = [];

    for (const propNode of node.body.properties) {
      const prop = bodyScope.evaluate(propNode);
      if (propNode.type !== 'FlowObjectTypeSpreadProperty' &&
        propNode.static ===
        true) {
        statics.push(prop);
      } else if (propNode.type === 'FlowObjectTypeCallProperty') {
        calls.push(scope.evaluate(propNode));
      } else {
        instances.push(prop);
      }
    }

    let xtends = undefined;
    if (node.extends.length > 0) {
      xtends = scope.evaluate(node.extends[0]);
    }

    const type = new ___R$project$rome$$romejs$js$analysis$types$ClassT_ts$default(
      bodyScope,
      node.id,
      {
        _constructor: undefined,
        instances,
        statics,
        extends: xtends,
        calls,
      },
    );
    scope.addBinding(node.id.name, type);
    type.setHuman(node.id.name);
    return type;
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowDeclaredPredicate.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowDeclaredPredicate_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowDeclaredPredicate_ts$flowDeclaredPredicate.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowDeclareExportAll.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowDeclareExportAll_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowDeclareExportAll_ts$flowDeclareExportAll.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowDeclareExportDefault.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowDeclareExportDefault_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowDeclareExportDefault_ts$flowDeclareExportDefault.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowDeclareExportNamed.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowDeclareExportNamed_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowDeclareExportNamed_ts$flowDeclareExportNamed.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowDeclareFunction.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowDeclareFunction_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowDeclareFunction_ts$flowDeclareFunction.assert(node);

    return (
      scope.addBinding(
        node.id.name,
        scope.evaluate(
          node.id.meta.typeAnnotation,
        ),
      )
    );
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowInterfaceDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowInterfaceDeclaration_ts$default(node, scope) {
    node =
      node.type === 'FlowDeclareInterface'
        ? node : ___R$project$rome$$romejs$js$ast$flow$FlowInterfaceDeclaration_ts$flowInterfaceDeclaration.assert(node);

    const typeScope = scope.fork();
    if (node.typeParameters) {
      typeScope.evaluate(node.typeParameters);
    }

    // TODO extends
    const body = typeScope.evaluate(node.body);
    scope.addBinding(node.id.name, body);
    return body;
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowDeclareInterface.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowDeclareInterface_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowDeclareInterface_ts$flowDeclareInterface.assert(node);
    return ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowInterfaceDeclaration_ts$default(node, scope);
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowDeclareModule.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowDeclareModule_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowDeclareModule_ts$flowDeclareModule.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowDeclareModuleExports.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowDeclareModuleExports_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowDeclareModuleExports_ts$flowDeclareModuleExports.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/types/OpaqueT.ts
class ___R$project$rome$$romejs$js$analysis$types$OpaqueT_ts$default extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, name) {
      super(scope, originNode);
      this.name = name;
    }

    serialize() {
      return {name: this.name};
    }

    static hydrate(scope, originNode, data) {
      return new ___R$project$rome$$romejs$js$analysis$types$OpaqueT_ts$default(scope, originNode, String(data.name));
    }

    humanize() {
      return 'opaque ' +
      this.name;
    }

    compatibleWith(otherType) {
      return otherType === this;
    }
  }

  ___R$project$rome$$romejs$js$analysis$types$OpaqueT_ts$default.type =
    'OpaqueT';

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowDeclareOpaqueType.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowDeclareOpaqueType_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowDeclareOpaqueType_ts$flowDeclareOpaqueType.assert(node);

    return new ___R$project$rome$$romejs$js$analysis$types$OpaqueT_ts$default(scope, node.id, node.id.name);
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowDeclareVariable.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowDeclareVariable_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowDeclareVariable_ts$flowDeclareVariable.assert(node);

    const {id} = node;
    if (id.meta === undefined) {
      throw new Error('TODO');
    }

    const type = scope.evaluate(id.meta.typeAnnotation);
    scope.addBinding(id.name, type);
    return type;
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowExistsTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowExistsTypeAnnotation_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowExistsTypeAnnotation_ts$flowExistsTypeAnnotation.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowFunctionTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowFunctionTypeAnnotation_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowFunctionTypeAnnotation_ts$flowFunctionTypeAnnotation.assert(node);

    const bodyScope = scope.fork();
    if (node.typeParameters) {
      bodyScope.evaluate(node.typeParameters);
    }

    // build param types
    const params = [];
    let rest;
    for (const paramNode of node.params) {
      let paramType = bodyScope.evaluate(paramNode.meta.typeAnnotation);
      if (paramNode.meta.optional === true) {
        paramType = new ___R$project$rome$$romejs$js$analysis$types$MaybeT_ts$default(scope, paramNode, paramType);
      }
      params.push(paramType);
    }
    if (node.rest !== undefined) {
      rest = bodyScope.evaluate(node.rest.meta.typeAnnotation);
    }

    // build return type
    const returns = bodyScope.evaluate(node.returnType);

    // create the function
    return new ___R$project$rome$$romejs$js$analysis$types$FunctionT_ts$default(scope, node, {params, rest, returns, body: undefined});
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowFunctionTypeParam.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowFunctionTypeParam_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowFunctionTypeParam_ts$flowFunctionTypeParam.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowGenericTypeAnnotation.ts
function ___R$$priv$project$rome$$romejs$js$analysis$evaluators$flow$FlowGenericTypeAnnotation_ts$getName(node) {
    if (node.type === 'Identifier') {
      return node.name;
    } else {
      return ___R$$priv$project$rome$$romejs$js$analysis$evaluators$flow$FlowGenericTypeAnnotation_ts$getName(node.id) +
      '.' +
      ___R$$priv$project$rome$$romejs$js$analysis$evaluators$flow$FlowGenericTypeAnnotation_ts$getName(node.qualification);
    }
  }

  function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowGenericTypeAnnotation_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowGenericTypeAnnotation_ts$flowGenericTypeAnnotation.assert(node);

    //if (node.typeParameters) {
    //  // TODO execute type params

    //  return new InstanceT(scope, node, node.id.name, scope.evaluate(node.id), []);

    //} else {
    return new ___R$project$rome$$romejs$js$analysis$types$GenericT_ts$default(scope, node, ___R$$priv$project$rome$$romejs$js$analysis$evaluators$flow$FlowGenericTypeAnnotation_ts$getName(node.id), scope.evaluate(node.id));
    //}
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowInferredPredicate.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowInferredPredicate_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowInferredPredicate_ts$flowInferredPredicate.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowInterface.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowInterface_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowInterface_ts$flowInterface.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowInterfaceExtends.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowInterfaceExtends_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowInterfaceExtends_ts$flowInterfaceExtends.assert(node);

    return scope.evaluate(node.id);
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowInterfaceTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowInterfaceTypeAnnotation_ts$default() {
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowNullableTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowNullableTypeAnnotation_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowNullableTypeAnnotation_ts$flowNullableTypeAnnotation.assert(node);
    return new ___R$project$rome$$romejs$js$analysis$types$MaybeT_ts$default(scope, node, scope.evaluate(node.typeAnnotation));
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowNumericLiteral.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowNumericLiteral_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowNumericLiteral_ts$flowNumericLiteral.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowObjectTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowObjectTypeAnnotation_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeAnnotation_ts$flowObjectTypeAnnotation.assert(node);

    const props = [];
    const calls = [];

    for (const prop of node.properties) {
      props.push(scope.evaluate(prop));
    }

    return (
      new ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default(
        scope,
        node,
        {
          props,
          proto: scope.intrinsics.ObjectPrototype,
          calls,
        },
      )
    );
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowObjectTypeCallProperty.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowObjectTypeCallProperty_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeCallProperty_ts$flowObjectTypeCallProperty.assert(node);

    return scope.evaluate(node.value);
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowObjectTypeIndexer.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowObjectTypeIndexer_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeIndexer_ts$flowObjectTypeIndexer.assert(node);

    return (
      new ___R$project$rome$$romejs$js$analysis$types$ObjIndexPropT_ts$default(
        scope,
        node,
        scope.evaluate(node.key),
        scope.evaluate(node.value),
      )
    );
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowObjectTypeInternalSlot.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowObjectTypeInternalSlot_ts$default() {
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowObjectTypeProperty.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowObjectTypeProperty_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeProperty_ts$flowObjectTypeProperty.assert(node);

    const {key, value} = node;

    let keyStr;
    if (key.type === 'Identifier') {
      keyStr = key.name;
    } else if (key.type === 'StringLiteral') {
      keyStr = key.value;
    } else {
      throw new Error('Unknown property key');
    }

    return new ___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default(scope, node, keyStr, scope.evaluate(value));
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowObjectTypeSpreadProperty.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowObjectTypeSpreadProperty_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowObjectTypeSpreadProperty_ts$flowObjectTypeSpreadProperty.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowOpaqueType.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowOpaqueType_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowOpaqueType_ts$flowOpaqueType.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowQualifiedTypeIdentifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowQualifiedTypeIdentifier_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowQualifiedTypeIdentifier_ts$flowQualifiedTypeIdentifier.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowThisTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowThisTypeAnnotation_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowThisTypeAnnotation_ts$flowThisTypeAnnotation.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowTupleTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowTupleTypeAnnotation_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowTupleTypeAnnotation_ts$flowTupleTypeAnnotation.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowTypeCastExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowTypeCastExpression_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowTypeCastExpression_ts$flowTypeCastExpression.assert(node);
    const expressionType = scope.evaluate(node.expression);
    const assertedType = scope.evaluate(node.typeAnnotation);
    new ___R$project$rome$$romejs$js$analysis$types$ExhaustiveT_ts$default(scope, node, expressionType, assertedType);
    return assertedType;
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowTypeofTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowTypeofTypeAnnotation_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowTypeofTypeAnnotation_ts$flowTypeofTypeAnnotation.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowTypeParameter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowTypeParameter_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowTypeParameter_ts$flowTypeParameter.assert(node);
    const type = new ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default(scope, node);
    scope.addBinding(node.name, type);
    return type;
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowTypeParameterDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowTypeParameterDeclaration_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowTypeParameterDeclaration_ts$flowTypeParameterDeclaration.assert(node);

    for (const param of node.params) {
      scope.evaluate(param);
    }
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowTypeParameterInstantiation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowTypeParameterInstantiation_ts$default(
    node,
    scope,
  ) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowTypeParameterInstantiation_ts$flowTypeParameterInstantiation.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/flow/FlowVariance.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowVariance_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$flow$FlowVariance_ts$flowVariance.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/statements/ForInStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$ForInStatement_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$statements$ForInStatement_ts$forInStatement.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/statements/ForOfStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$ForOfStatement_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$statements$ForOfStatement_ts$forOfStatement.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/statements/ForStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$ForStatement_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$statements$ForStatement_ts$forStatement.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/statements/FunctionDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$FunctionDeclaration_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$statements$FunctionDeclaration_ts$functionDeclaration.assert(node);

    const func = ___R$project$rome$$romejs$js$analysis$utils$executeFunction_ts$default(node, scope, false);
    if (node.id !== undefined) {
      scope.addBinding(node.id.name, func);
    }
    return func;
  }

  // project-rome/@romejs/js-analysis/evaluators/expressions/FunctionExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$FunctionExpression_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$expressions$FunctionExpression_ts$functionExpression.assert(node);
    return ___R$project$rome$$romejs$js$analysis$utils$executeFunction_ts$default(node, scope, true);
  }

  // project-rome/@romejs/js-analysis/evaluators/auxiliary/FunctionHead.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$FunctionHead_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$auxiliary$FunctionHead_ts$functionHead.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/auxiliary/Identifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$Identifier_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.assert(node);

    const binding = scope.getBinding(node.name);
    if (binding) {
      const type = new ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default(scope, node);
      type.shouldMatch(binding);
      return type;
    } else {
      switch (node.name) {
        case 'React$PropType$Primitive':
        case 'React$PropType$ArrayOf':
        case 'React$PropType$InstanceOf':
        case 'React$PropType$ObjectOf':
        case 'React$PropType$OneOf':
        case 'React$PropType$OneOfType':
        case 'React$PropTypePartial':
        case 'React$ElementProps':
        case 'React$ElementRef':
        case '$Exact':
        case 'Partial':
        case '$Keys':
        case 'Object$Assign':
        case 'Object$GetPrototypeOf':
        case 'Object$SetPrototypeOf':
        case '$CharSet':
        case 'Class':
        case '$Compose':
        case '$ComposeReverse':
        case '$Subtype':
        case 'Function$Prototype$Apply':
        case 'Function$Prototype$Bind':
        case 'Function$Prototype$Call':
        case '$Exports':
          return new ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default(scope, node);

        default:
          return new ___R$project$rome$$romejs$js$analysis$types$errors$UndeclaredVarE_ts$default(scope, node, node.name);
      }
    }
  }

  // project-rome/@romejs/js-analysis/evaluators/modules/ImportCall.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ImportCall_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$modules$ImportCall_ts$importCall.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/modules/ImportDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ImportDeclaration_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$modules$ImportDeclaration_ts$importDeclaration.assert(node);

    const source = node.source.value;

    const {specifiers} = node;
    if (specifiers !== undefined) {
      for (const specifier of specifiers) {
        if (specifier.type === 'ImportSpecifier') {
          const localName = specifier.local.name.name;
          const importedName = specifier.imported.name;

          const open = new ___R$project$rome$$romejs$js$analysis$types$ImportT_ts$default(
            scope,
            specifier,
            {
              importedName,
              source,
            },
          );
          scope.addBinding(localName, open);
        } else if (specifier.type === 'ImportDefaultSpecifier') {
          const localName = specifier.local.name.name;
          const open = new ___R$project$rome$$romejs$js$analysis$types$ImportT_ts$default(
            scope,
            specifier,
            {
              importedName: 'default',
              source,
            },
          );
          scope.addBinding(localName, open);
        } else if (specifier.type === 'ImportNamespaceSpecifier') {
          const localName = specifier.local.name.name;
          const open = new ___R$project$rome$$romejs$js$analysis$types$ImportT_ts$default(
            scope,
            specifier,
            {
              importedName: undefined,
              source,
            },
          );
          scope.addBinding(localName, open);
        } else {
          // TODO error
        }
      }
    }
  }

  // project-rome/@romejs/js-analysis/evaluators/modules/ImportDefaultSpecifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ImportDefaultSpecifier_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$modules$ImportDefaultSpecifier_ts$importDefaultSpecifier.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/modules/ImportNamespaceSpecifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ImportNamespaceSpecifier_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$modules$ImportNamespaceSpecifier_ts$importNamespaceSpecifier.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/modules/ImportSpecifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ImportSpecifier_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$modules$ImportSpecifier_ts$importSpecifier.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/modules/ImportSpecifierLocal.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ImportSpecifierLocal_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$modules$ImportSpecifierLocal_ts$importSpecifierLocal.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/core/InterpreterDirective.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$core$InterpreterDirective_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$core$InterpreterDirective_ts$interpreterDirective.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/types/IntersectionTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$types$IntersectionTypeAnnotation_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$types$IntersectionTypeAnnotation_ts$intersectionTypeAnnotation.assert(node);

    return (
      new ___R$project$rome$$romejs$js$analysis$types$IntersectionT_ts$default(
        scope,
        node,
        node.types.map(
          (type) => {
            return scope.evaluate(type);
          },
        ),
      )
    );
  }

  // project-rome/@romejs/js-analysis/evaluators/jsx/JSXAttribute.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXAttribute_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$jsx$JSXAttribute_ts$jsxAttribute.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/jsx/JSXElement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXElement_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$jsx$JSXElement_ts$jsxElement.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/jsx/JSXEmptyExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXEmptyExpression_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$jsx$JSXEmptyExpression_ts$jsxEmptyExpression.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/jsx/JSXExpressionContainer.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXExpressionContainer_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$jsx$JSXExpressionContainer_ts$jsxExpressionContainer.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/jsx/JSXFragment.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXFragment_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$jsx$JSXFragment_ts$jsxFragment.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/jsx/JSXIdentifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXIdentifier_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$jsx$JSXIdentifier_ts$jsxIdentifier.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/jsx/JSXMemberExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXMemberExpression_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$jsx$JSXMemberExpression_ts$jsxMemberExpression.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/jsx/JSXNamespacedName.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXNamespacedName_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$jsx$JSXNamespacedName_ts$jsxNamespacedName.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/jsx/JSXReferenceIdentifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXReferenceIdentifier_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$jsx$JSXReferenceIdentifier_ts$jsxReferenceIdentifier.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/jsx/JSXSpreadAttribute.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXSpreadAttribute_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$jsx$JSXSpreadAttribute_ts$jsxSpreadAttribute.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/jsx/JSXSpreadChild.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXSpreadChild_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$jsx$JSXSpreadChild_ts$jsxSpreadChild.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/jsx/JSXText.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXText_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$jsx$JSXText_ts$jsxText.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/statements/LabeledStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$LabeledStatement_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$statements$LabeledStatement_ts$labeledStatement.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/expressions/LogicalExpression.ts
function ___R$$priv$project$rome$$romejs$js$analysis$evaluators$expressions$LogicalExpression_ts$uniq(args) {
    return [...new Set(args)];
  }

  function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$LogicalExpression_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$expressions$LogicalExpression_ts$logicalExpression.assert(node);

    switch (node.operator) {
      case '||':
        {
          const left = scope.refine().evaluate(node.left);
          const right = scope.refine().evaluate(node.right);

          // create a new scope that has unions of all the refined bindings
          const refinedScope = scope.refine();
          const refinedNames = ___R$$priv$project$rome$$romejs$js$analysis$evaluators$expressions$LogicalExpression_ts$uniq(
            [
              ...left.scope.getOwnBindingNames(),
              ...right.scope.getOwnBindingNames(),
            ],
          );
          const mergeScopes = [left.scope, right.scope];
          for (const name of refinedNames) {
            const rawTypes = new Set();
            for (const scope of mergeScopes) {
              const binding = scope.getBinding(name);
              if (binding !== undefined) {
                rawTypes.add(binding);
              }
            }

            const types = Array.from(rawTypes);
            refinedScope.addBinding(name, refinedScope.createUnion(types));
          }

          return new ___R$project$rome$$romejs$js$analysis$types$UnionT_ts$default(refinedScope, node, [left, right]);
        }

      case '&&':
        {
          const left = scope.evaluate(node.left);
          const right = left.scope.evaluate(node.right);
          return new ___R$project$rome$$romejs$js$analysis$types$UnionT_ts$default(right.scope, node, [left, right]);
        }

      default:
        throw new Error('Unknown operator');
    }
  }

  // project-rome/@romejs/js-analysis/evaluators/expressions/MemberExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$MemberExpression_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$expressions$MemberExpression_ts$memberExpression.assert(node);
    if (node.property.type === 'ComputedMemberProperty') {
      throw new Error('Computed properties not supportd yet');
    }

    if (node.property.value.type === 'PrivateName') {
      throw new Error('PrivateName in static member not supported yet');
    }

    const prop = new ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default(
      scope,
      node.property.value,
      node.property.value.name,
    );
    return new ___R$project$rome$$romejs$js$analysis$types$GetPropT_ts$default(scope, node, scope.evaluate(node.object), prop);
  }

  // project-rome/@romejs/js-analysis/evaluators/expressions/MetaProperty.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$MetaProperty_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$expressions$MetaProperty_ts$metaProperty.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/types/MixedKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$types$MixedKeywordTypeAnnotation_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$types$MixedKeywordTypeAnnotation_ts$mixedKeywordTypeAnnotation.assert(node);
    return new ___R$project$rome$$romejs$js$analysis$types$MixedT_ts$default(scope, node);
  }

  // project-rome/@romejs/js-analysis/evaluators/temp/MockParent.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$temp$MockParent_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$temp$MockParent_ts$mockParent.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/types/NeverKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$types$NeverKeywordTypeAnnotation_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$types$NeverKeywordTypeAnnotation_ts$neverKeywordTypeAnnotation.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/expressions/NewExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$NewExpression_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$expressions$NewExpression_ts$newExpression.assert(node);
    return new ___R$project$rome$$romejs$js$analysis$types$InstanceT_ts$default(scope, node, scope.evaluate(node.callee), []);
  }

  // project-rome/@romejs/js-analysis/evaluators/types/NullKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$types$NullKeywordTypeAnnotation_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$types$NullKeywordTypeAnnotation_ts$nullKeywordTypeAnnotation.assert(node);
    return new ___R$project$rome$$romejs$js$analysis$types$NullT_ts$default(scope, node);
  }

  // project-rome/@romejs/js-analysis/evaluators/literals/NullLiteral.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$literals$NullLiteral_ts$default(node, scope) {
    node = node = ___R$project$rome$$romejs$js$ast$literals$NullLiteral_ts$nullLiteral.assert(node);
    return new ___R$project$rome$$romejs$js$analysis$types$NullT_ts$default(scope, node);
  }

  // project-rome/@romejs/js-analysis/evaluators/types/NumberKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$types$NumberKeywordTypeAnnotation_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$types$NumberKeywordTypeAnnotation_ts$numberKeywordTypeAnnotation.assert(node);
    return new ___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default(scope, node);
  }

  // project-rome/@romejs/js-analysis/evaluators/literals/NumericLiteral.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$literals$NumericLiteral_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$literals$NumericLiteral_ts$numericLiteral.assert(node);
    return new ___R$project$rome$$romejs$js$analysis$types$NumericLiteralT_ts$default(scope, node, node.value);
  }

  // project-rome/@romejs/js-analysis/evaluators/types/NumericLiteralTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$types$NumericLiteralTypeAnnotation_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$types$NumericLiteralTypeAnnotation_ts$numericLiteralTypeAnnotation.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/objects/ObjectExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$objects$ObjectExpression_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$objects$ObjectExpression_ts$objectExpression.assert(node);
    const props = [];

    for (const prop of node.properties) {
      if (prop.type === 'SpreadProperty') {
        // TODO
      } else if (prop.type === 'ObjectProperty') {
        if (prop.key.type === 'ComputedPropertyKey') {
          // TODO
        } else {
          const {
            key: {value: key},
            value,
          } = prop;

          let keyStr;
          if (key.type === 'Identifier') {
            keyStr = key.name;
          } else {
            // TODO
            continue;
          }

          if (keyStr === undefined) {
            throw new Error('Expected keyStr');
          }

          props.push(new ___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default(scope, prop, keyStr, scope.evaluate(value)));
        }
      } else {
        // TODO
      }
    }

    return (
      new ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default(
        scope,
        node,
        {
          calls: [],
          props,
          proto: scope.intrinsics.ObjectPrototype,
        },
      )
    );
  }

  // project-rome/@romejs/js-analysis/evaluators/types/ObjectKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$types$ObjectKeywordTypeAnnotation_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$types$ObjectKeywordTypeAnnotation_ts$objectKeywordTypeAnnotation.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/objects/ObjectMethod.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$objects$ObjectMethod_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$objects$ObjectMethod_ts$objectMethod.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/objects/ObjectProperty.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$objects$ObjectProperty_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$objects$ObjectProperty_ts$objectProperty.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/expressions/OptionalCallExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$OptionalCallExpression_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$expressions$OptionalCallExpression_ts$optionalCallExpression.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/patterns/PatternMeta.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$patterns$PatternMeta_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$patterns$PatternMeta_ts$patternMeta.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/classes/PrivateName.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$classes$PrivateName_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$classes$PrivateName_ts$privateName.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/core/Program.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$core$Program_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$core$Program_ts$program.assert(node);
    ___R$project$rome$$romejs$js$analysis$evaluators$statements$BlockStatement_ts$default(node, scope);
  }

  // project-rome/@romejs/js-analysis/evaluators/expressions/ReferenceIdentifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$ReferenceIdentifier_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpAlternation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpAlternation_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpAlternation_ts$regExpAlternation.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpAnyCharacter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpAnyCharacter_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpAnyCharacter_ts$regExpAnyCharacter.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpCharacter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpCharacter_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpCharacter_ts$regExpCharacter.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpCharSet.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpCharSet_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpCharSet_ts$regExpCharSet.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpCharSetRange.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpCharSetRange_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpCharSetRange_ts$regExpCharSetRange.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpControlCharacter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpControlCharacter_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpControlCharacter_ts$regExpControlCharacter.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpDigitCharacter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpDigitCharacter_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpDigitCharacter_ts$regExpDigitCharacter.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpEndCharacter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpEndCharacter_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpEndCharacter_ts$regExpEndCharacter.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpGroupCapture.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpGroupCapture_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpGroupCapture_ts$regExpGroupCapture.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpGroupNonCapture.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpGroupNonCapture_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpGroupNonCapture_ts$regExpGroupNonCapture.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/literals/RegExpLiteral.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$literals$RegExpLiteral_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$literals$RegExpLiteral_ts$regExpLiteral.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpNonDigitCharacter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpNonDigitCharacter_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpNonDigitCharacter_ts$regExpNonDigitCharacter.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpNonWhiteSpaceCharacter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpNonWhiteSpaceCharacter_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpNonWhiteSpaceCharacter_ts$regExpNonWhiteSpaceCharacter.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpNonWordBoundaryCharacter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpNonWordBoundaryCharacter_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpNonWordBoundaryCharacter_ts$regExpNonWordBoundaryCharacter.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpNonWordCharacter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpNonWordCharacter_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpNonWordCharacter_ts$regExpNonWordCharacter.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpQuantified.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpQuantified_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpQuantified_ts$regExpQuantified.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpStartCharacter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpStartCharacter_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpStartCharacter_ts$regExpStartCharacter.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpSubExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpSubExpression_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpSubExpression_ts$regExpSubExpression.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpWhiteSpaceCharacter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpWhiteSpaceCharacter_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpWhiteSpaceCharacter_ts$regExpWhiteSpaceCharacter.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpWordBoundaryCharacter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpWordBoundaryCharacter_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpWordBoundaryCharacter_ts$regExpWordBoundaryCharacter.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpWordCharacter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpWordCharacter_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$regex$RegExpWordCharacter_ts$regExpWordCharacter.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/statements/ReturnStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$ReturnStatement_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$statements$ReturnStatement_ts$returnStatement.assert(node);
    const funcScope = scope.find(___R$project$rome$$romejs$js$analysis$scopes_ts$FunctionScope);
    if (node.argument === undefined) {
      // TODO connect to undefined
    } else {
      const type = scope.evaluate(node.argument);
      funcScope.meta.returnType.shouldMatch(type);
    }
  }

  // project-rome/@romejs/js-analysis/evaluators/expressions/SequenceExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$SequenceExpression_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$expressions$SequenceExpression_ts$sequenceExpression.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/auxiliary/SpreadElement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$SpreadElement_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$auxiliary$SpreadElement_ts$spreadElement.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/objects/SpreadProperty.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$objects$SpreadProperty_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$objects$SpreadProperty_ts$spreadProperty.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/auxiliary/StaticMemberProperty.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$StaticMemberProperty_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$auxiliary$StaticMemberProperty_ts$staticMemberProperty.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/objects/StaticPropertyKey.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$objects$StaticPropertyKey_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$objects$StaticPropertyKey_ts$staticPropertyKey.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/types/StringKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$types$StringKeywordTypeAnnotation_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$types$StringKeywordTypeAnnotation_ts$stringKeywordTypeAnnotation.assert(node);
    return new ___R$project$rome$$romejs$js$analysis$types$StringT_ts$default(scope, node);
  }

  // project-rome/@romejs/js-analysis/evaluators/literals/StringLiteral.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$literals$StringLiteral_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.assert(node);
    return new ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default(scope, node, node.value);
  }

  // project-rome/@romejs/js-analysis/evaluators/types/StringLiteralTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$types$StringLiteralTypeAnnotation_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$types$StringLiteralTypeAnnotation_ts$stringLiteralTypeAnnotation.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/expressions/Super.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$Super_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$expressions$Super_ts$_super.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/auxiliary/SwitchCase.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$SwitchCase_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$auxiliary$SwitchCase_ts$switchCase.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/statements/SwitchStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$SwitchStatement_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$statements$SwitchStatement_ts$switchStatement.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/types/SymbolKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$types$SymbolKeywordTypeAnnotation_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$types$SymbolKeywordTypeAnnotation_ts$symbolKeywordTypeAnnotation.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/expressions/TaggedTemplateExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$TaggedTemplateExpression_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$expressions$TaggedTemplateExpression_ts$taggedTemplateExpression.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/auxiliary/TemplateElement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$TemplateElement_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$auxiliary$TemplateElement_ts$templateElement.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/literals/TemplateLiteral.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$literals$TemplateLiteral_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$literals$TemplateLiteral_ts$templateLiteral.assert(node);
    for (const expr of node.expressions) {
      new ___R$project$rome$$romejs$js$analysis$types$ExhaustiveT_ts$default(
        scope,
        expr,
        scope.evaluate(expr),
        new ___R$project$rome$$romejs$js$analysis$types$StringT_ts$default(
          scope,
          undefined,
        ),
      );
    }
    return new ___R$project$rome$$romejs$js$analysis$types$StringT_ts$default(scope, node);
  }

  // project-rome/@romejs/js-analysis/evaluators/types/TemplateLiteralTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$types$TemplateLiteralTypeAnnotation_ts$default(
    node,
    scope,
  ) {
    node = ___R$project$rome$$romejs$js$ast$types$TemplateLiteralTypeAnnotation_ts$templateLiteralTypeAnnotation.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/expressions/ThisExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$ThisExpression_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$expressions$ThisExpression_ts$thisExpression.assert(node);
    const thisScope = scope.find(___R$project$rome$$romejs$js$analysis$scopes_ts$ThisScope);
    if (thisScope === undefined) {
      // TODO complain
    } else {
      const type = new ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default(scope, node);
      type.shouldMatch(thisScope.context);
      return type;
    }
  }

  // project-rome/@romejs/js-analysis/evaluators/statements/ThrowStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$ThrowStatement_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$statements$ThrowStatement_ts$throwStatement.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/statements/TryStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$TryStatement_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$statements$TryStatement_ts$tryStatement.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSArrayType.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSArrayType_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSArrayType_ts$tsArrayType.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSAsExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSAsExpression_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSAsExpression_ts$tsAsExpression.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSAssignmentAsExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSAssignmentAsExpression_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentAsExpression_ts$tsAssignmentAsExpression.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSAssignmentNonNullExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSAssignmentNonNullExpression_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentNonNullExpression_ts$tsAssignmentNonNullExpression.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSAssignmentTypeAssertion.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSAssignmentTypeAssertion_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentTypeAssertion_ts$tsAssignmentTypeAssertion.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSCallSignatureDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSCallSignatureDeclaration_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSCallSignatureDeclaration_ts$tsCallSignatureDeclaration.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSConditionalType.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSConditionalType_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSConditionalType_ts$tsConditionalType.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSConstructorType.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSConstructorType_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSConstructorType_ts$tsConstructorType.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSConstructSignatureDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSConstructSignatureDeclaration_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSConstructSignatureDeclaration_ts$tsConstructSignatureDeclaration.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSDeclareFunction.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSDeclareFunction_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSDeclareFunction_ts$tsDeclareFunction.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSDeclareMethod.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSDeclareMethod_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSDeclareMethod_ts$tsDeclareMethod.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSEnumDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSEnumDeclaration_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSEnumDeclaration_ts$tsEnumDeclaration.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSEnumMember.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSEnumMember_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSEnumMember_ts$tsEnumMember.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSExportAssignment.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSExportAssignment_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSExportAssignment_ts$tsExportAssignment.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSExpressionWithTypeArguments.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSExpressionWithTypeArguments_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSExpressionWithTypeArguments_ts$tsExpressionWithTypeArguments.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSExternalModuleReference.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSExternalModuleReference_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSExternalModuleReference_ts$tsExternalModuleReference.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSFunctionType.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSFunctionType_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSFunctionType_ts$tsFunctionType.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSImportEqualsDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSImportEqualsDeclaration_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSImportEqualsDeclaration_ts$tsImportEqualsDeclaration.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSImportType.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSImportType_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSImportType_ts$tsImportType.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSIndexedAccessType.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSIndexedAccessType_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSIndexedAccessType_ts$tsIndexedAccessType.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSIndexSignature.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSIndexSignature_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSIndexSignature_ts$tsIndexSignature.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSInferType.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSInferType_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSInferType_ts$tsInferType.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSInterfaceBody.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSInterfaceBody_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSInterfaceBody_ts$tsInterfaceBody.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSInterfaceDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSInterfaceDeclaration_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSInterfaceDeclaration_ts$tsInterfaceDeclaration.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSMappedType.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSMappedType_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSMappedType_ts$tsMappedType.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSMethodSignature.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSMethodSignature_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSMethodSignature_ts$tsMethodSignature.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSModuleBlock.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSModuleBlock_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSModuleBlock_ts$tsModuleBlock.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSModuleDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSModuleDeclaration_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSModuleDeclaration_ts$tsModuleDeclaration.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSNamespaceExportDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSNamespaceExportDeclaration_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSNamespaceExportDeclaration_ts$tsNamespaceExportDeclaration.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSNonNullExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSNonNullExpression_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSNonNullExpression_ts$tsNonNullExpression.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSOptionalType.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSOptionalType_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSOptionalType_ts$tsOptionalType.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSParenthesizedType.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSParenthesizedType_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSParenthesizedType_ts$tsParenthesizedType.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSPropertySignature.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSPropertySignature_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSPropertySignature_ts$tsPropertySignature.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSQualifiedName.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSQualifiedName_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSQualifiedName_ts$tsQualifiedName.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSSignatureDeclarationMeta.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSSignatureDeclarationMeta_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSSignatureDeclarationMeta_ts$tsSignatureDeclarationMeta.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSThisType.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSThisType_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSThisType_ts$tsThisType.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSTupleType.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTupleType_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSTupleType_ts$tsTupleType.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSTypeAssertion.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeAssertion_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSTypeAssertion_ts$tsTypeAssertion.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSTypeLiteral.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeLiteral_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSTypeLiteral_ts$tsTypeLiteral.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSTypeOperator.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeOperator_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSTypeOperator_ts$tsTypeOperator.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSTypeParameter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeParameter_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameter_ts$tsTypeParameter.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSTypeParameterDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeParameterDeclaration_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterDeclaration_ts$tsTypeParameterDeclaration.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSTypeParameterInstantiation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeParameterInstantiation_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterInstantiation_ts$tsTypeParameterInstantiation.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSTypePredicate.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypePredicate_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSTypePredicate_ts$tsTypePredicate.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSTypeQuery.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeQuery_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSTypeQuery_ts$tsTypeQuery.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/typescript/TSTypeReference.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeReference_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$typescript$TSTypeReference_ts$tsTypeReference.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/types/TypeAliasTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$types$TypeAliasTypeAnnotation_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$types$TypeAliasTypeAnnotation_ts$typeAliasTypeAnnotation.assert(node);

    const typeScope = scope.fork();
    if (node.typeParameters) {
      typeScope.evaluate(node.typeParameters);
    }

    const right = typeScope.evaluate(node.right);
    scope.addBinding(node.id.name, right);
    return right;
  }

  // project-rome/@romejs/js-analysis/evaluators/expressions/UnaryExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$UnaryExpression_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$expressions$UnaryExpression_ts$unaryExpression.assert(node);
    const argType = scope.evaluate(node.argument);

    switch (node.operator) {
      case // booleans
      'delete':
      case '!':
        return new ___R$project$rome$$romejs$js$analysis$types$BooleanT_ts$default(scope, node);

      // numbers
      case '+':
      case '-':
      case '~':
        return new ___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default(scope, node);

      // strings
      case 'typeof':
        return new ___R$project$rome$$romejs$js$analysis$types$TypeofT_ts$default(scope, node, argType);

      // void
      case 'void':
        return new ___R$project$rome$$romejs$js$analysis$types$VoidT_ts$default(scope, node);

      // empty!
      case 'throw':
        break;
    }
  }

  // project-rome/@romejs/js-analysis/evaluators/types/UndefinedKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$types$UndefinedKeywordTypeAnnotation_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$types$UndefinedKeywordTypeAnnotation_ts$undefinedKeywordTypeAnnotation.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/types/UnionTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$types$UnionTypeAnnotation_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$types$UnionTypeAnnotation_ts$unionTypeAnnotation.assert(node);

    return (
      new ___R$project$rome$$romejs$js$analysis$types$UnionT_ts$default(
        scope,
        node,
        node.types.map(
          (type) => {
            return scope.evaluate(type);
          },
        ),
      )
    );
  }

  // project-rome/@romejs/js-analysis/evaluators/types/UnknownKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$types$UnknownKeywordTypeAnnotation_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$types$UnknownKeywordTypeAnnotation_ts$unknownKeywordTypeAnnotation.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/expressions/UpdateExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$UpdateExpression_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$expressions$UpdateExpression_ts$updateExpression.assert(node);
    const type = new ___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default(scope, node);
    new ___R$project$rome$$romejs$js$analysis$types$ExhaustiveT_ts$default(scope, node.argument, scope.evaluate(node.argument), type);
    return type;
  }

  // project-rome/@romejs/js-analysis/evaluators/auxiliary/VariableDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$VariableDeclaration_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.assert(node);

    for (const declarator of node.declarations) {
      const {id, init} = declarator;
      let inferredType;

      if (init === undefined) {
        inferredType = new ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default(scope, declarator);
        inferredType.shouldMatch(new ___R$project$rome$$romejs$js$analysis$types$VoidT_ts$default(scope, declarator));
      } else {
        inferredType = scope.evaluate(init);
      }

      let actualType = inferredType;

      if (id.meta !== undefined && id.meta.typeAnnotation !== undefined) {
        const annotatedType = scope.evaluate(id.meta.typeAnnotation);
        inferredType.shouldMatch(annotatedType);
        actualType = annotatedType;
      }

      ___R$project$rome$$romejs$js$analysis$utils$executeAtom_ts$default(id, actualType, scope);
    }
  }

  // project-rome/@romejs/js-analysis/evaluators/statements/VariableDeclarationStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$VariableDeclarationStatement_ts$default(node) {
    node = ___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement.assert(node);
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/auxiliary/VariableDeclarator.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$VariableDeclarator_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/types/VoidKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$types$VoidKeywordTypeAnnotation_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$types$VoidKeywordTypeAnnotation_ts$voidKeywordTypeAnnotation.assert(node);
    return new ___R$project$rome$$romejs$js$analysis$types$VoidT_ts$default(scope, node);
  }

  // project-rome/@romejs/js-analysis/evaluators/statements/WhileStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$WhileStatement_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$statements$WhileStatement_ts$whileStatement.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/statements/WithStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$WithStatement_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$statements$WithStatement_ts$withStatement.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/expressions/YieldExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$YieldExpression_ts$default(node, scope) {
    node = ___R$project$rome$$romejs$js$ast$expressions$YieldExpression_ts$yieldExpression.assert(node);
    scope;
    throw new Error('unimplemented');
  }

  // project-rome/@romejs/js-analysis/evaluators/index.ts
const ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators = new Map();
  const ___R$project$rome$$romejs$js$analysis$evaluators$index_ts$default = ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators;
  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
    'AmbiguousFlowTypeCastExpression',
    ___R$project$rome$$romejs$js$analysis$evaluators$temp$AmbiguousFlowTypeCastExpression_ts$default,
  );

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('AnyKeywordTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$types$AnyKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ArrayExpression', ___R$project$rome$$romejs$js$analysis$evaluators$expressions$ArrayExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ArrowFunctionExpression', ___R$project$rome$$romejs$js$analysis$evaluators$expressions$ArrowFunctionExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('AssignmentArrayPattern', ___R$project$rome$$romejs$js$analysis$evaluators$patterns$AssignmentArrayPattern_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('AssignmentAssignmentPattern', ___R$project$rome$$romejs$js$analysis$evaluators$patterns$AssignmentAssignmentPattern_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('AssignmentExpression', ___R$project$rome$$romejs$js$analysis$evaluators$expressions$AssignmentExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('AssignmentIdentifier', ___R$project$rome$$romejs$js$analysis$evaluators$patterns$AssignmentIdentifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('AssignmentObjectPattern', ___R$project$rome$$romejs$js$analysis$evaluators$patterns$AssignmentObjectPattern_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
    'AssignmentObjectPatternProperty',
    ___R$project$rome$$romejs$js$analysis$evaluators$patterns$AssignmentObjectPatternProperty_ts$default,
  );

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('AwaitExpression', ___R$project$rome$$romejs$js$analysis$evaluators$expressions$AwaitExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('BigIntKeywordTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$types$BigIntKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('BigIntLiteral', ___R$project$rome$$romejs$js$analysis$evaluators$literals$BigIntLiteral_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('BinaryExpression', ___R$project$rome$$romejs$js$analysis$evaluators$expressions$BinaryExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('BindingArrayPattern', ___R$project$rome$$romejs$js$analysis$evaluators$patterns$BindingArrayPattern_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('BindingAssignmentPattern', ___R$project$rome$$romejs$js$analysis$evaluators$patterns$BindingAssignmentPattern_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('BindingIdentifier', ___R$project$rome$$romejs$js$analysis$evaluators$patterns$BindingIdentifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('BindingObjectPattern', ___R$project$rome$$romejs$js$analysis$evaluators$patterns$BindingObjectPattern_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('BindingObjectPatternProperty', ___R$project$rome$$romejs$js$analysis$evaluators$patterns$BindingObjectPatternProperty_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('BlockStatement', ___R$project$rome$$romejs$js$analysis$evaluators$statements$BlockStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('BooleanKeywordTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$types$BooleanKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('BooleanLiteral', ___R$project$rome$$romejs$js$analysis$evaluators$literals$BooleanLiteral_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('BooleanLiteralTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$types$BooleanLiteralTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('BreakStatement', ___R$project$rome$$romejs$js$analysis$evaluators$statements$BreakStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('CallExpression', ___R$project$rome$$romejs$js$analysis$evaluators$expressions$CallExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('CatchClause', ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$CatchClause_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ClassDeclaration', ___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ClassExpression', ___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ClassHead', ___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassHead_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ClassMethod', ___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassMethod_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ClassPrivateMethod', ___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassPrivateMethod_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ClassPrivateProperty', ___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassPrivateProperty_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ClassProperty', ___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassProperty_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ClassPropertyMeta', ___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassPropertyMeta_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('CommentBlock', ___R$project$rome$$romejs$js$analysis$evaluators$core$CommentBlock_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('CommentLine', ___R$project$rome$$romejs$js$analysis$evaluators$core$CommentLine_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ComputedMemberProperty', ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$ComputedMemberProperty_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ComputedPropertyKey', ___R$project$rome$$romejs$js$analysis$evaluators$objects$ComputedPropertyKey_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ConditionalExpression', ___R$project$rome$$romejs$js$analysis$evaluators$expressions$ConditionalExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ContinueStatement', ___R$project$rome$$romejs$js$analysis$evaluators$statements$ContinueStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('DebuggerStatement', ___R$project$rome$$romejs$js$analysis$evaluators$statements$DebuggerStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('Directive', ___R$project$rome$$romejs$js$analysis$evaluators$core$Directive_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('DoExpression', ___R$project$rome$$romejs$js$analysis$evaluators$expressions$DoExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('DoWhileStatement', ___R$project$rome$$romejs$js$analysis$evaluators$statements$DoWhileStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('EmptyKeywordTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$types$EmptyKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('EmptyStatement', ___R$project$rome$$romejs$js$analysis$evaluators$statements$EmptyStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ExportAllDeclaration', ___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportAllDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ExportDefaultDeclaration', ___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportDefaultDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ExportDefaultSpecifier', ___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportDefaultSpecifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ExportExternalDeclaration', ___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportExternalDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ExportExternalSpecifier', ___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportExternalSpecifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ExportLocalDeclaration', ___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportLocalDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ExportLocalSpecifier', ___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportLocalSpecifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ExportNamespaceSpecifier', ___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportNamespaceSpecifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ExpressionStatement', ___R$project$rome$$romejs$js$analysis$evaluators$statements$ExpressionStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowArrayTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowArrayTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowClassImplements', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowClassImplements_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowDeclareClass', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowDeclareClass_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowDeclaredPredicate', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowDeclaredPredicate_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowDeclareExportAll', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowDeclareExportAll_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowDeclareExportDefault', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowDeclareExportDefault_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowDeclareExportNamed', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowDeclareExportNamed_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowDeclareFunction', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowDeclareFunction_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowDeclareInterface', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowDeclareInterface_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowDeclareModule', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowDeclareModule_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowDeclareModuleExports', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowDeclareModuleExports_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowDeclareOpaqueType', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowDeclareOpaqueType_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowDeclareVariable', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowDeclareVariable_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowExistsTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowExistsTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowFunctionTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowFunctionTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowFunctionTypeParam', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowFunctionTypeParam_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowGenericTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowGenericTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowInferredPredicate', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowInferredPredicate_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowInterface', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowInterface_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowInterfaceDeclaration', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowInterfaceDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowInterfaceExtends', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowInterfaceExtends_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowInterfaceTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowInterfaceTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowNullableTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowNullableTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowNumericLiteral', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowNumericLiteral_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowObjectTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowObjectTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowObjectTypeCallProperty', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowObjectTypeCallProperty_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowObjectTypeIndexer', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowObjectTypeIndexer_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowObjectTypeInternalSlot', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowObjectTypeInternalSlot_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowObjectTypeProperty', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowObjectTypeProperty_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowObjectTypeSpreadProperty', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowObjectTypeSpreadProperty_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowOpaqueType', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowOpaqueType_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowQualifiedTypeIdentifier', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowQualifiedTypeIdentifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowThisTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowThisTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowTupleTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowTupleTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowTypeCastExpression', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowTypeCastExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowTypeofTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowTypeofTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowTypeParameter', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowTypeParameter_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowTypeParameterDeclaration', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowTypeParameterDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowTypeParameterInstantiation', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowTypeParameterInstantiation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowVariance', ___R$project$rome$$romejs$js$analysis$evaluators$flow$FlowVariance_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ForInStatement', ___R$project$rome$$romejs$js$analysis$evaluators$statements$ForInStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ForOfStatement', ___R$project$rome$$romejs$js$analysis$evaluators$statements$ForOfStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ForStatement', ___R$project$rome$$romejs$js$analysis$evaluators$statements$ForStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FunctionDeclaration', ___R$project$rome$$romejs$js$analysis$evaluators$statements$FunctionDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FunctionExpression', ___R$project$rome$$romejs$js$analysis$evaluators$expressions$FunctionExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('FunctionHead', ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$FunctionHead_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('Identifier', ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$Identifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('IfStatement', ___R$project$rome$$romejs$js$analysis$evaluators$statements$IfStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ImportCall', ___R$project$rome$$romejs$js$analysis$evaluators$modules$ImportCall_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ImportDeclaration', ___R$project$rome$$romejs$js$analysis$evaluators$modules$ImportDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ImportDefaultSpecifier', ___R$project$rome$$romejs$js$analysis$evaluators$modules$ImportDefaultSpecifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ImportNamespaceSpecifier', ___R$project$rome$$romejs$js$analysis$evaluators$modules$ImportNamespaceSpecifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ImportSpecifier', ___R$project$rome$$romejs$js$analysis$evaluators$modules$ImportSpecifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ImportSpecifierLocal', ___R$project$rome$$romejs$js$analysis$evaluators$modules$ImportSpecifierLocal_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('InterpreterDirective', ___R$project$rome$$romejs$js$analysis$evaluators$core$InterpreterDirective_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('IntersectionTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$types$IntersectionTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('JSXAttribute', ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXAttribute_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('JSXElement', ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXElement_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('JSXEmptyExpression', ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXEmptyExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('JSXExpressionContainer', ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXExpressionContainer_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('JSXFragment', ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXFragment_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('JSXIdentifier', ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXIdentifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('JSXMemberExpression', ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXMemberExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('JSXNamespacedName', ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXNamespacedName_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('JSXReferenceIdentifier', ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXReferenceIdentifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('JSXSpreadAttribute', ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXSpreadAttribute_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('JSXSpreadChild', ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXSpreadChild_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('JSXText', ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXText_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('LabeledStatement', ___R$project$rome$$romejs$js$analysis$evaluators$statements$LabeledStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('LogicalExpression', ___R$project$rome$$romejs$js$analysis$evaluators$expressions$LogicalExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('MemberExpression', ___R$project$rome$$romejs$js$analysis$evaluators$expressions$MemberExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('MetaProperty', ___R$project$rome$$romejs$js$analysis$evaluators$expressions$MetaProperty_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('MixedKeywordTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$types$MixedKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('MockParent', ___R$project$rome$$romejs$js$analysis$evaluators$temp$MockParent_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('NeverKeywordTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$types$NeverKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('NewExpression', ___R$project$rome$$romejs$js$analysis$evaluators$expressions$NewExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('NullKeywordTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$types$NullKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('NullLiteral', ___R$project$rome$$romejs$js$analysis$evaluators$literals$NullLiteral_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('NumberKeywordTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$types$NumberKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('NumericLiteral', ___R$project$rome$$romejs$js$analysis$evaluators$literals$NumericLiteral_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('NumericLiteralTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$types$NumericLiteralTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ObjectExpression', ___R$project$rome$$romejs$js$analysis$evaluators$objects$ObjectExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ObjectKeywordTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$types$ObjectKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ObjectMethod', ___R$project$rome$$romejs$js$analysis$evaluators$objects$ObjectMethod_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ObjectProperty', ___R$project$rome$$romejs$js$analysis$evaluators$objects$ObjectProperty_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('OptionalCallExpression', ___R$project$rome$$romejs$js$analysis$evaluators$expressions$OptionalCallExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('PatternMeta', ___R$project$rome$$romejs$js$analysis$evaluators$patterns$PatternMeta_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('PrivateName', ___R$project$rome$$romejs$js$analysis$evaluators$classes$PrivateName_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('Program', ___R$project$rome$$romejs$js$analysis$evaluators$core$Program_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ReferenceIdentifier', ___R$project$rome$$romejs$js$analysis$evaluators$expressions$ReferenceIdentifier_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('RegExpAlternation', ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpAlternation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('RegExpAnyCharacter', ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpAnyCharacter_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('RegExpCharacter', ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpCharacter_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('RegExpCharSet', ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpCharSet_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('RegExpCharSetRange', ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpCharSetRange_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('RegExpControlCharacter', ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpControlCharacter_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('RegExpDigitCharacter', ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpDigitCharacter_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('RegExpEndCharacter', ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpEndCharacter_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('RegExpGroupCapture', ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpGroupCapture_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('RegExpGroupNonCapture', ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpGroupNonCapture_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('RegExpLiteral', ___R$project$rome$$romejs$js$analysis$evaluators$literals$RegExpLiteral_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('RegExpNonDigitCharacter', ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpNonDigitCharacter_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('RegExpNonWhiteSpaceCharacter', ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpNonWhiteSpaceCharacter_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('RegExpNonWordBoundaryCharacter', ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpNonWordBoundaryCharacter_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('RegExpNonWordCharacter', ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpNonWordCharacter_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('RegExpQuantified', ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpQuantified_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('RegExpStartCharacter', ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpStartCharacter_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('RegExpSubExpression', ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpSubExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('RegExpWhiteSpaceCharacter', ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpWhiteSpaceCharacter_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('RegExpWordBoundaryCharacter', ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpWordBoundaryCharacter_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('RegExpWordCharacter', ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpWordCharacter_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ReturnStatement', ___R$project$rome$$romejs$js$analysis$evaluators$statements$ReturnStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('SequenceExpression', ___R$project$rome$$romejs$js$analysis$evaluators$expressions$SequenceExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('SpreadElement', ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$SpreadElement_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('SpreadProperty', ___R$project$rome$$romejs$js$analysis$evaluators$objects$SpreadProperty_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('StaticMemberProperty', ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$StaticMemberProperty_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('StaticPropertyKey', ___R$project$rome$$romejs$js$analysis$evaluators$objects$StaticPropertyKey_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('StringKeywordTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$types$StringKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('StringLiteral', ___R$project$rome$$romejs$js$analysis$evaluators$literals$StringLiteral_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('StringLiteralTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$types$StringLiteralTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('Super', ___R$project$rome$$romejs$js$analysis$evaluators$expressions$Super_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('SwitchCase', ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$SwitchCase_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('SwitchStatement', ___R$project$rome$$romejs$js$analysis$evaluators$statements$SwitchStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('SymbolKeywordTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$types$SymbolKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TaggedTemplateExpression', ___R$project$rome$$romejs$js$analysis$evaluators$expressions$TaggedTemplateExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TemplateElement', ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$TemplateElement_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TemplateLiteral', ___R$project$rome$$romejs$js$analysis$evaluators$literals$TemplateLiteral_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TemplateLiteralTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$types$TemplateLiteralTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ThisExpression', ___R$project$rome$$romejs$js$analysis$evaluators$expressions$ThisExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('ThrowStatement', ___R$project$rome$$romejs$js$analysis$evaluators$statements$ThrowStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TryStatement', ___R$project$rome$$romejs$js$analysis$evaluators$statements$TryStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSArrayType', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSArrayType_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSAsExpression', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSAsExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSAssignmentAsExpression', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSAssignmentAsExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSAssignmentNonNullExpression', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSAssignmentNonNullExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSAssignmentTypeAssertion', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSAssignmentTypeAssertion_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSCallSignatureDeclaration', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSCallSignatureDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSConditionalType', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSConditionalType_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSConstructorType', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSConstructorType_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
    'TSConstructSignatureDeclaration',
    ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSConstructSignatureDeclaration_ts$default,
  );

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSDeclareFunction', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSDeclareFunction_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSDeclareMethod', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSDeclareMethod_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSEnumDeclaration', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSEnumDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSEnumMember', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSEnumMember_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSExportAssignment', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSExportAssignment_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSExpressionWithTypeArguments', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSExpressionWithTypeArguments_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSExternalModuleReference', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSExternalModuleReference_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSFunctionType', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSFunctionType_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSImportEqualsDeclaration', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSImportEqualsDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSImportType', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSImportType_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSIndexedAccessType', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSIndexedAccessType_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSIndexSignature', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSIndexSignature_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSInferType', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSInferType_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSInterfaceBody', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSInterfaceBody_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSInterfaceDeclaration', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSInterfaceDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSMappedType', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSMappedType_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSMethodSignature', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSMethodSignature_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSModuleBlock', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSModuleBlock_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSModuleDeclaration', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSModuleDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSNamespaceExportDeclaration', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSNamespaceExportDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSNonNullExpression', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSNonNullExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSOptionalType', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSOptionalType_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSParenthesizedType', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSParenthesizedType_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSPropertySignature', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSPropertySignature_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSQualifiedName', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSQualifiedName_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSSignatureDeclarationMeta', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSSignatureDeclarationMeta_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSThisType', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSThisType_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSTupleType', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTupleType_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSTypeAssertion', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeAssertion_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSTypeLiteral', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeLiteral_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSTypeOperator', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeOperator_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSTypeParameter', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeParameter_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSTypeParameterDeclaration', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeParameterDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSTypeParameterInstantiation', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeParameterInstantiation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSTypePredicate', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypePredicate_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSTypeQuery', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeQuery_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSTypeReference', ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeReference_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('TypeAliasTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$types$TypeAliasTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('UnaryExpression', ___R$project$rome$$romejs$js$analysis$evaluators$expressions$UnaryExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('UndefinedKeywordTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$types$UndefinedKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('UnionTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$types$UnionTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('UnknownKeywordTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$types$UnknownKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('UpdateExpression', ___R$project$rome$$romejs$js$analysis$evaluators$expressions$UpdateExpression_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('VariableDeclaration', ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$VariableDeclaration_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('VariableDeclarationStatement', ___R$project$rome$$romejs$js$analysis$evaluators$statements$VariableDeclarationStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('VariableDeclarator', ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$VariableDeclarator_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('VoidKeywordTypeAnnotation', ___R$project$rome$$romejs$js$analysis$evaluators$types$VoidKeywordTypeAnnotation_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('WhileStatement', ___R$project$rome$$romejs$js$analysis$evaluators$statements$WhileStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('WithStatement', ___R$project$rome$$romejs$js$analysis$evaluators$statements$WithStatement_ts$default);

  ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set('YieldExpression', ___R$project$rome$$romejs$js$analysis$evaluators$expressions$YieldExpression_ts$default);

  // project-rome/@romejs/js-analysis/Evaluator.ts
___R$project$rome$$romejs$js$ast$utils_ts$assertNodeTypeSet(___R$project$rome$$romejs$js$analysis$evaluators$index_ts$default, 'evaluators');

  class ___R$project$rome$$romejs$js$analysis$Evaluator_ts$ModuleSignatureManager {
    constructor(graph, getModuleSignature, topScope) {
      this.topScope = topScope;
      this.getModuleSignature = getModuleSignature;
      this.graph = graph;
      this.openTypes = new Map();
      this.filename = graph.filename;

      this.exportNamesToTypeId = new Map();
    }

    addAll(manager) {
      for (const [name, id] of manager.exportNamesToTypeId) {
        if (name === 'default') {
          // ignore `default`
          continue;
        }

        this.exportNamesToTypeId.set(name, id);

        const openType = manager.openTypes.get(id);
        if (openType === undefined) {
          throw new Error('Expected an open type');
        }
        this.openTypes.set(id, openType);
      }
    }

    async init() {
      const {graph, openTypes} = this;

      // Create initial open types for all the nodes in this graph
      for (const id in graph.types) {
        const open = new ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default(this.topScope, undefined);
        openTypes.set(id, open);
      }

      let currGetType;

      // Create a factory to fetch the open ids
      const getType = (id) => {
        if (id === undefined) {
          throw new Error('expected id');
        }

        if (typeof id !== 'string') {
          throw new Error('expected string id');
        }

        const type = openTypes.get(id);

        if (type === undefined) {
          throw (
            new Error(
              graph.filename +
              ': Expected type of id ' +
              id +
              ' but it doesn\'t exist, serialized data: ' +
              String(
                JSON.stringify(currGetType),
              ),
            )
          );
        }

        return type;
      };

      // Fetch the graphs of `export *` dependencies, future calls to `this.getModuleSignature` will fetch from 'cache
      await Promise.all(
        graph.exports.map(
          (def) => {
            if (def.type === 'all') {
              return this.getModuleSignature(def.source, graph.filename);
            } else {
              return undefined;
            }
          },
        ),
      );

      // Resolve all exports
      for (const def of graph.exports) {
        if (def.type === 'all') {
          const manager = await this.getModuleSignature(def.source, graph.filename);
          if (manager !== undefined) {
            this.addAll(manager);
          }
        } else {
          this.exportNamesToTypeId.set(def.name, def.value);
        }
      }

      // Hydrate all types in the graph and link them to their open types
      for (const id in graph.types) {
        const node = graph.types[id];
        const {origin, type, data, human} = node;
        currGetType = node;

        // Retrieve the open type
        const openT = openTypes.get(id);
        if (openT === undefined) {
          throw new Error('Expected an open type');
        }

        // Get the type constructor
        const TConstructor = ___R$project$rome$$romejs$js$analysis$types$index_ts$default.get(type);
        if (TConstructor === undefined) {
          throw new Error('Expected a valid internal type constructor name');
        }

        // Create the type

        // @ts-ignore
        const realT = TConstructor.hydrate(
          this.topScope,
          {loc: origin},
          data,
          getType,
        );

        //
        realT.setHuman(human);

        // Link it to the open type
        openT.shouldMatch(realT);
      }
    }

    link(importedName, type) {
      const graph = this.graph;

      // Get type id for this export
      const maybeExportId = this.exportNamesToTypeId.get(importedName);
      if (maybeExportId === undefined) {
        // Export not found in the module so let's link it to an error
        const error = new ___R$project$rome$$romejs$js$analysis$types$errors$UnknownImportE_ts$default(
          this.topScope,
          type.originNode,
          {
            possibleNames: Array.from(this.exportNamesToTypeId.keys()),
            importedName,
            source: graph.filename,
          },
        );
        error.shouldMatch(type);
        return undefined;
      }

      // Retrieve the open type
      const openT = this.openTypes.get(maybeExportId);
      if (openT === undefined) {
        throw new Error('Expected an open type');
      }

      // Link it to this type
      type.setResolvedType(openT);
    }
  }

  class ___R$project$rome$$romejs$js$analysis$Evaluator_ts$default {
    constructor(hub, filename) {
      this.filename = filename;
      this.nodeToType = new Map();
      this.exports = [];
      this.imports = [];
      this.hub = hub;
      this.graph = hub.graph;
      // TODO we should use `ThisScope` and set it correctly to `window` or `undefined` depending on strict mode
      this.topScope = new ___R$project$rome$$romejs$js$analysis$scopes_ts$Scope({evaluator: this});
      this.intrinsics = this.topScope.intrinsics = new ___R$project$rome$$romejs$js$analysis$Intrinsics_ts$default(this.topScope);
      this.evaluatingType = undefined;
    }

    initModuleSignature(graph, getModuleSignature) {
      return new ___R$project$rome$$romejs$js$analysis$Evaluator_ts$ModuleSignatureManager(graph, getModuleSignature, this.topScope);
    }

    seed(ast) {
      return this.evaluate(ast, this.topScope);
    }

    evaluate(node, scope) {
      if (node === undefined) {
        throw new Error('Expected node but received undefined');
      }

      const evaluator = ___R$project$rome$$romejs$js$analysis$evaluators$index_ts$default.get(node.type);
      if (evaluator === undefined) {
        throw new Error('what is this? ' +
        node.type);
      } else {
        const oldEvaluatingType = this.evaluatingType;
        this.evaluatingType = node.type;
        let type = evaluator(node, scope, this.hub);
        if (type === undefined) {
          type = new ___R$project$rome$$romejs$js$analysis$types$EmptyT_ts$default(scope, node);
        }
        this.evaluatingType = oldEvaluatingType;
        this.nodeToType.set(node, type);
        return type;
      }
    }

    getTypeFromEvaluatedNode(node) {
      const type = this.nodeToType.get(node);
      if (type === undefined) {
        throw (
          new Error(
            'getTypeFromEvaluatedNode() called on a node that has not been validated yet',
          )
        );
      } else {
        return type;
      }
    }

    addExport(name, type) {
      this.exports.push(
        {
          type: 'local',
          name,
          value: type,
        },
      );
    }

    addExportAll(source) {
      this.exports.push(
        {
          type: 'all',
          source,
        },
      );
    }

    addImport(t, opts) {
      this.imports.push(
        {
          relative: opts.relative,
          importedName: opts.importedName,
          source: opts.source,
          type: t,
        },
      );
    }
  }

  // project-rome/@romejs/js-analysis/Utils.ts
class ___R$$priv$project$rome$$romejs$js$analysis$Utils_ts$ReduceRecursionError extends Error {}

  const ___R$$priv$project$rome$$romejs$js$analysis$Utils_ts$TYPE_COMPATIBLE = {type: 'compatible'};

  const ___R$$priv$project$rome$$romejs$js$analysis$Utils_ts$MAX_DEPTH = 100;

  class ___R$project$rome$$romejs$js$analysis$Utils_ts$HumanBuilder {
    constructor() {
      this.stack = new Set();
      this.usedAliases = new Set();
      this.aliases = new Map();
    }

    isRecursive(t) {
      if (t.human !== undefined) {
        return false;
      }

      if (this.aliases.has(t)) {
        return true;
      }

      if (this.stack.has(t)) {
        return true;
      }

      return false;
    }

    humanize(type) {
      // Check if we already have a human form for this type
      if (type.human !== undefined) {
        return type.human;
      }

      // Check if we have an already created alias
      if (this.aliases.has(type)) {
        const alias = this.aliases.get(type);
        if (alias === undefined) {
          throw new Error('Expected alias');
        }
        return alias;
      }

      // Generate an alias if we've determined this as recursive
      if (this.isRecursive(type)) {
        const alias = 'Alias' +
        type.id;
        this.aliases.set(type, alias);
        return alias;
      }

      // Setup the stack and call
      this.stack.add(type);
      try {
        let humanized = type.humanize(this);

        // Check if an alias was created
        const alias = this.aliases.get(type);
        if (alias !== undefined) {
          humanized = alias +
          ' = ' +
          humanized;
        }
        return humanized;
      } finally {
        this.stack.delete(type);
      }
    }
  }

  class ___R$project$rome$$romejs$js$analysis$Utils_ts$default {
    constructor(hub) {
      this.reduceCatchers = new Set();
      this.reduceCache = new Map();
      this.reduceStack = new Set();
      this.compatibilityDepth = 0;
      this.hub = hub;
      this.debug = false;
    }

    inspect(t, safe = false) {
      const prevDebug = this.debug;
      this.debug = true;

      const data = new Map();
      data.set('id', String(t.id));

      const {originLoc, originEvaluator} = t;
      if (originLoc === undefined) {
        data.set('origin', 'unknown');
      } else {
        data.set(
          'origin',
          String(originLoc.filename) +
          ':' +
          String(
            originLoc.start.line,
          ) +
          ':' +
          String(originLoc.start.column),
        );
      }
      if (originEvaluator !== undefined) {
        data.set('evaluator', originEvaluator);
      }

      const dataStr = Array.from(data.keys()).map(
        (
          key,
        ) =>
          key +
          ': ' +
          String(data.get(key)),
      ).join(
        ', ',
      );

      let info = t.getConstructor().type +
      '<';
      if (safe === false) {
        info += this.humanize(t) +
        ', ';
      }
      info += dataStr +
      '>';

      this.debug = prevDebug;
      return info;
    }

    assertClosed() {
      if (this.debug === false) {
        this.hub.assertClosed();
      }
    }

    explodeUnion(type) {
      return Array.from(new Set(this.reduce(type).explodeUnion()));
    }

    isCompatibleWith(a, b) {
      return this.checkCompability(a, b).type === 'compatible';
    }

    checkCompability(a, b) {
      this.assertClosed();

      const lower = this.reduce(a);
      const upper = this.reduce(b);

      // Exact same type
      if (lower === upper) {
        return ___R$$priv$project$rome$$romejs$js$analysis$Utils_ts$TYPE_COMPATIBLE;
      }

      // Any types shouldn't cause errors
      if (lower instanceof ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default || upper instanceof ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default) {
        return ___R$$priv$project$rome$$romejs$js$analysis$Utils_ts$TYPE_COMPATIBLE;
      }

      // Simple check for call stack limits
      if (this.compatibilityDepth > ___R$$priv$project$rome$$romejs$js$analysis$Utils_ts$MAX_DEPTH) {
        throw (
          new Error(
            'Max depth exceeded when checking compatibility of ' +
            lower.inspect() +
            ' to ' +
            upper.inspect(),
          )
        );
      }

      const cached = lower.compatibilityCache.get(upper);
      if (cached === undefined) {
        lower.compatibilityCache.set(
          upper,
          {
            type: 'incompatible',
            lower,
            upper,
          },
        );
      } else {
        return cached;
      }

      // Check this relationship for compatibility
      this.compatibilityDepth++;
      let ret;
      try {
        ret = lower.compatibleWith(upper);
      } catch (err) {
        if (err instanceof ___R$$priv$project$rome$$romejs$js$analysis$Utils_ts$ReduceRecursionError) {
          ret = ___R$$priv$project$rome$$romejs$js$analysis$Utils_ts$TYPE_COMPATIBLE;
        } else {
          throw err;
        }
      } finally {
        this.compatibilityDepth--;
      }
      let res;
      if (ret === true) {
        res = ___R$$priv$project$rome$$romejs$js$analysis$Utils_ts$TYPE_COMPATIBLE;
      } else if (ret === false) {
        res = {type: 'incompatible', lower: a, upper: b};
      } else if (ret instanceof ___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default) {
        res = {type: 'incompatible', lower: a, upper: ret};
      } else {
        res = ret;
      }

      lower.compatibilityCache.set(upper, res);

      return res;
    }

    humanize(type) {
      this.assertClosed();

      return new ___R$project$rome$$romejs$js$analysis$Utils_ts$HumanBuilder().humanize(type);
    }

    reduce(type) {
      //
      this.assertClosed();

      //
      const cached = this.reduceCache.get(type);
      if (cached !== undefined) {
        return cached;
      }

      // Check if we're already trying to reduce this node, in that case this is a recursion error
      if (this.reduceStack.has(type)) {
        //throw new ReduceRecursionError(`Reduce recursion error for ${this.inspect(type, true)}`);
        return new ___R$project$rome$$romejs$js$analysis$types$UnknownT_ts$default(type.scope, type.originNode);
      }

      //
      if (this.reduceStack.size > ___R$$priv$project$rome$$romejs$js$analysis$Utils_ts$MAX_DEPTH) {
        throw new Error('Max depth exceeded when reducing');
      }

      this.reduceStack.add(type);

      if (this.reduceCatchers.size) {
        for (const set of this.reduceCatchers) {
          set.add(type);
        }
      }

      try {
        const reduced = type.reduce();

        if (reduced === undefined) {
          throw (
            new Error(
              'The reduce() method for ' +
              this.inspect(type, true) +
              ' returned null',
            )
          );
        }

        if (reduced.getConstructor().type === 'OpenT') {
          throw (
            new Error(
              'The reduce() method for ' +
              this.inspect(type, true) +
              ' returned an OpenT. This should never be possible. It likely forgot to return utils.reduce() on it.',
            )
          );
        }

        if (this.debug === false) {
          this.reduceCache.set(type, reduced);
        }

        return reduced;
      } finally {
        this.reduceStack.delete(type);
      }
    }

    reduceCatch(
      type,
    ) {
      const involved = new Set();
      this.reduceCatchers.add(involved);

      const final = this.reduce(type);
      this.reduceCatchers.delete(involved);

      return {final, involved};
    }
  }

  // project-rome/@romejs/js-analysis/Hub.ts
const ___R$$priv$project$rome$$romejs$js$analysis$Hub_ts$statuses = {
    OPEN: 0,
    CLOSING: 1,
    CLOSED: 2,
  };

  class ___R$project$rome$$romejs$js$analysis$Hub_ts$default {
    constructor(ast, project) {
      this.context =
        new ___R$project$rome$$romejs$js$compiler$lib$Context_ts$default(
          {
            ast,
            project,
            origin: {
              category: 'typeChecking',
            },
          },
        );
      this.utils = new ___R$project$rome$$romejs$js$analysis$Utils_ts$default(this);
      this.graph = new ___R$project$rome$$romejs$js$analysis$Graph_ts$default();
      this.evaluator = new ___R$project$rome$$romejs$js$analysis$Evaluator_ts$default(this, ast.filename);
      this.status = ___R$$priv$project$rome$$romejs$js$analysis$Hub_ts$statuses.OPEN;
    }

    close() {
      this.status = ___R$$priv$project$rome$$romejs$js$analysis$Hub_ts$statuses.CLOSING;

      for (const [node] of this.graph.nodesByValue) {
        this.utils.reduce(node);
      }

      this.status = ___R$$priv$project$rome$$romejs$js$analysis$Hub_ts$statuses.CLOSED;
    }

    isClosing() {
      return this.status === ___R$$priv$project$rome$$romejs$js$analysis$Hub_ts$statuses.CLOSING;
    }

    isOpen() {
      return this.isClosing() || this.status === ___R$$priv$project$rome$$romejs$js$analysis$Hub_ts$statuses.OPEN;
    }

    isClosed() {
      return this.isClosing() || this.status === ___R$$priv$project$rome$$romejs$js$analysis$Hub_ts$statuses.CLOSED;
    }

    assertOpen() {
      if (this.isClosed() && this.isClosing() === false) {
        throw (
          new Error(
            'This method can only be called when the graph has been open',
          )
        );
      }
    }

    assertClosed() {
      if (this.isOpen() && this.isClosing() === false) {
        throw (
          new Error(
            'This method can only be called when the graph has been closed',
          )
        );
      }
    }
  }

  // project-rome/@romejs/js-analysis/api/buildGraph.ts
async function ___R$project$rome$$romejs$js$analysis$api$buildGraph_ts$default(
    opts,
  ) {
    const {ast, connected, project, provider} = opts;

    const hub = new ___R$project$rome$$romejs$js$analysis$Hub_ts$default(ast, project);
    const {evaluator} = hub;
    if (provider.libs !== undefined) {
      let body = [];
      for (const ast of provider.libs) {
        body = [...body, ...ast.body];
      }
      evaluator.seed(
        Object.assign(
          {
          },
          ast,
          {
            body,
          },
        ),
      );
    }
    evaluator.seed(ast);

    // fetch imports
    if (connected) {
      // create graphs
      const graphs = new Map();
      async function getModuleSignature(
        source,
        relative,
      ) {
        const graphKey = relative +
        ':' +
        source;
        if (graphs.has(graphKey)) {
          // already prepared graph
          return graphs.get(graphKey);
        }

        // query the provider for the export types
        const graph = await provider.getExportTypes(relative, source);

        // check if the resolved graph even exists
        if (graph === undefined) {
          // TODO unknown module, create an error
          graphs.set(graphKey, undefined);
          return undefined;
        }

        // check if we've already initialised this graph before, in the case of different relative URLs
        if (graphs.has(graph.filename)) {
          // TODO this is pretty inefficient, we shouldn't even receive it
          const manager = graphs.get(graph.filename);
          graphs.set(graphKey, manager);
          return manager;
        }

        // create the graph
        const manager = evaluator.initModuleSignature(graph, getModuleSignature);
        graphs.set(graphKey, manager);
        graphs.set(graph.filename, manager);
        await manager.init();
        return manager;
      }

      // seed graphs
      const seedCache = new Set();
      await Promise.all(
        evaluator.imports.map(
          ({source, relative}) => {
            const cacheKey = source +
            ':' +
            relative;
            if (seedCache.has(cacheKey)) {
              return undefined;
            }

            seedCache.add(cacheKey);
            return getModuleSignature(source, relative);
          },
        ),
      );

      // link imports
      for (const {source, importedName, relative, type} of evaluator.imports) {
        const graphKey = relative +
        ':' +
        source;
        const graph = graphs.get(graphKey);
        if (graph === undefined) {
          // unknown module, an error would have been created in the initial graph prep
          continue;
        }

        if (importedName === undefined) {
          // nothing to link here!
          continue;
        }

        type.setAbsolute(graph.filename);
        graph.link(importedName, type);
      }
    }

    evaluator.intrinsics.link();
    hub.close();
    return hub;
  }

  // project-rome/@romejs/js-analysis/api/getModuleSignature.ts
const ___R$$priv$project$rome$$romejs$js$analysis$api$getModuleSignature_ts$exportsCache = new WeakMap();

  async function ___R$project$rome$$romejs$js$analysis$api$getModuleSignature_ts$default(
    opts,
  ) {
    const {ast, provider} = opts;
    const {filename} = ast;

    if (filename.includes('node_modules')) {
      return (
        {
          filename,
          exports: [],
          types: {},
        }
      );
    }

    const cached = ___R$$priv$project$rome$$romejs$js$analysis$api$getModuleSignature_ts$exportsCache.get(ast);
    if (cached !== undefined) {
      return cached;
    }

    const {
      evaluator: {exports},
      utils,
    } = await ___R$project$rome$$romejs$js$analysis$api$buildGraph_ts$default(
      {
        ast,
        project: opts.project,
        connected: false,
        provider,
      },
    );
    const types = {};
    const exportMap = [];

    const added = new Set();

    function addType(type) {
      const reducedType = utils.reduce(type);
      if (added.has(reducedType)) {
        return reducedType.id;
      } else {
        added.add(reducedType);
      }

      // export errors as any types to suppress errors
      if (reducedType instanceof ___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default) {
        types[reducedType.id] =
          {
            human: undefined,
            origin: reducedType.originLoc,
            type: 'AnyT',
            data: {},
          };
        return reducedType.id;
      }

      const data = reducedType.serialize(addType);

      types[reducedType.id] =
        {
          human: reducedType.human,
          origin: reducedType.originLoc,
          type: reducedType.getConstructor().type,
          data,
        };
      return reducedType.id;
    }

    for (const def of exports) {
      if (def.type === 'all') {
        exportMap.push(
          {
            type: 'all',
            source: def.source,
          },
        );
      } else if (def.type === 'local') {
        exportMap.push(
          {
            type: 'local',
            name: def.name,
            value: addType(def.value),
          },
        );
      } else {
        throw new Error('unknown export def type');
      }
    }

    const result = {
      filename,
      exports: exportMap,
      types,
    };
    ___R$$priv$project$rome$$romejs$js$analysis$api$getModuleSignature_ts$exportsCache.set(ast, result);
    return result;
  }

  // project-rome/@romejs/js-analysis/api/check.ts
async function ___R$project$rome$$romejs$js$analysis$api$check_ts$default(
    opts,
  ) {
    const hub = await ___R$project$rome$$romejs$js$analysis$api$buildGraph_ts$default(
      {
        ast: opts.ast,
        connected: true,
        provider: opts.provider,
        project: opts.project,
      },
    );
    ___R$$priv$project$rome$$romejs$js$analysis$api$check_ts$resolveGraph(hub);
    return hub.context.diagnostics;
  }

  function ___R$$priv$project$rome$$romejs$js$analysis$api$check_ts$isError(t) {
    return t !== undefined && t instanceof ___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default;
  }

  function ___R$$priv$project$rome$$romejs$js$analysis$api$check_ts$resolveGraph(hub) {
    const {graph, utils, context} = hub;

    // we track caught errors here as if a normal type returns a error in it's reduce() method

    // then it will be added to the graph, however we'd have already dealt with it
    const caughtErrors = new Set();

    for (const node of graph.nodes) {
      const lower = node.value;

      // unconnected node, we'll resolve these if they've been connected to any nodes
      if (lower instanceof ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default) {
        continue;
      }

      // see if this reduces to a type error
      const reduced = utils.reduce(lower);
      if (reduced instanceof ___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default) {
        if (caughtErrors.has(reduced)) {
          continue;
        } else {
          caughtErrors.add(reduced);
        }

        const {
          category,
          lowerTarget,
          upperTarget,
          advice: rawAdvice,
          message,
        } = reduced.getError();

        // ignore errors inside
        if (___R$$priv$project$rome$$romejs$js$analysis$api$check_ts$isError(lowerTarget) || ___R$$priv$project$rome$$romejs$js$analysis$api$check_ts$isError(upperTarget)) {
          continue;
        }

        let advice = [];

        if (upperTarget !== undefined) {
          const marker = upperTarget &&
            !(upperTarget instanceof
            reduced.constructor)
            ? utils.humanize(upperTarget) : undefined;
          const {originLoc} = upperTarget;

          if (originLoc !== undefined && marker !== undefined) {
            advice.push(
              {
                type: 'log',
                category: 'info',
                message: marker,
              },
            );
          } else if (originLoc !== undefined) {
            advice.push(
              {
                type: 'frame',
                filename: originLoc.filename,
                start: originLoc.start,
                end: originLoc.end,
                marker,
              },
            );
          }
        }

        if (rawAdvice !== undefined) {
          advice = advice.concat(rawAdvice);
        }

        context.addNodeDiagnostic(
          lowerTarget.originNode,
          {
            category,
            message,
            advice,
            marker: lowerTarget && !(lowerTarget instanceof reduced.constructor)
              ? utils.humanize(lowerTarget) : undefined,
          },
        );
        continue;
      }

      // ignore unconnected nodes
      if (node.lines.length === 0) {
        continue;
      }

      for (const line of node.lines) {
        const upper = line.value;
        const compatibility = utils.checkCompability(upper, lower);

        if (compatibility.type === 'incompatible') {
          // ignore associated errors, as they've already been handled
          if (___R$$priv$project$rome$$romejs$js$analysis$api$check_ts$isError(compatibility.lower) || ___R$$priv$project$rome$$romejs$js$analysis$api$check_ts$isError(compatibility.upper)) {
            continue;
          }

          const advice = [
            {
              type: 'log',
              category: 'error',
              message: 'This type is incompatible with expected type of',
            },
          ];

          const {originLoc} = upper;
          if (originLoc === undefined) {
            advice.push(
              {
                type: 'log',
                category: 'info',
                message: utils.humanize(upper),
              },
            );
          } else {
            advice.push(
              {
                type: 'frame',
                filename: originLoc.filename,
                start: originLoc.start,
                end: originLoc.end,
                marker: utils.humanize(upper),
              },
            );
          }

          context.addNodeDiagnostic(
            compatibility.lower.originNode,
            {
              category: 'typeCheck/incompatible',
              message: 'Type incompatibility found',
              marker: utils.humanize(compatibility.lower),
              advice,
            },
          );
        }
      }
    }

    return context.diagnostics;
  }

  // project-rome/@romejs/js-analysis/types.ts
const ___R$project$rome$$romejs$js$analysis$types_ts = {
  };

  // project-rome/@romejs/js-analysis/index.ts
const ___R$project$rome$$romejs$js$analysis$index_ts = {
    get getModuleSignature() {
      return (
        ___R$project$rome$$romejs$js$analysis$api$getModuleSignature_ts$default
      );
    },

    get buildGraph() {
      return (
        ___R$project$rome$$romejs$js$analysis$api$buildGraph_ts$default
      );
    },

    get check() {
      return (
        ___R$project$rome$$romejs$js$analysis$api$check_ts$default
      );
    },
  };
  Object.keys(
    ___R$project$rome$$romejs$js$analysis$types$index_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$analysis$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$analysis$types$index_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$analysis$types_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$analysis$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$analysis$types_ts[key]
            );
          },
        },
      );
    },
  );

  // project-rome/@romejs/core/common/types/analyzeDependencies.ts
const ___R$project$rome$$romejs$core$common$types$analyzeDependencies_ts = {
    get UNKNOWN_ANALYZE_DEPENDENCIES_RESULT() {
      return (
        ___R$project$rome$$romejs$core$common$types$analyzeDependencies_ts$UNKNOWN_ANALYZE_DEPENDENCIES_RESULT
      );
    },
  };

  const ___R$project$rome$$romejs$core$common$types$analyzeDependencies_ts$UNKNOWN_ANALYZE_DEPENDENCIES_RESULT = {
    moduleType: 'unknown',
    syntax: [],
    diagnostics: [],
    firstTopAwaitLocation: undefined,
    importFirstUsage: [],
    exports: [],
    dependencies: [],
  };

  // project-rome/@romejs/fs/index.ts
const ___R$$priv$project$rome$$romejs$fs$index_ts$fs = require(
    'fs',
  );

  function ___R$$priv$project$rome$$romejs$fs$index_ts$promisifyData(
    path,
    factory,
  ) {
    return (
      new Promise(
        (resolve, reject) => {
          factory(
            path.join(),
            (err, data) => {
              if (err === null) {
                resolve(data);
              } else {
                reject(err);
              }
            },
          );
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$fs$index_ts$promisifyVoid(
    path,
    factory,
  ) {
    return (
      new Promise(
        (resolve, reject) => {
          factory(
            path.join(),
            (err) => {
              if (err === null) {
                resolve();
              } else {
                reject(err);
              }
            },
          );
        },
      )
    );
  }

  // watch
  function ___R$project$rome$$romejs$fs$index_ts$watch(
    path,
    options,

    listener,
  ) {
    return ___R$$priv$project$rome$$romejs$fs$index_ts$fs.watch(path.join(), options, listener);
  }

  function ___R$project$rome$$romejs$fs$index_ts$readFile(path) {
    return (
      ___R$$priv$project$rome$$romejs$fs$index_ts$promisifyData(
        path,
        (
          filename,
          callback,
        ) =>
          ___R$$priv$project$rome$$romejs$fs$index_ts$fs.readFile(filename, callback),
      )
    );
  }

  function ___R$project$rome$$romejs$fs$index_ts$readFileSync(path) {
    return ___R$$priv$project$rome$$romejs$fs$index_ts$fs.readFileSync(path.join());
  }

  async function ___R$project$rome$$romejs$fs$index_ts$readFileText(path) {
    return (await ___R$project$rome$$romejs$fs$index_ts$readFile(path)).toString();
  }

  function ___R$project$rome$$romejs$fs$index_ts$readFileTextSync(path) {
    return ___R$$priv$project$rome$$romejs$fs$index_ts$fs.readFileSync(path.join(), 'utf8');
  }

  function ___R$project$rome$$romejs$fs$index_ts$writeFile(
    path,
    content,
  ) {
    return (
      ___R$$priv$project$rome$$romejs$fs$index_ts$promisifyVoid(
        path,
        (
          filename,
          callback,
        ) =>
          ___R$$priv$project$rome$$romejs$fs$index_ts$fs.writeFile(filename, content, callback),
      )
    );
  }

  function ___R$project$rome$$romejs$fs$index_ts$writeFileSync(
    path,
    content,
  ) {
    return ___R$$priv$project$rome$$romejs$fs$index_ts$fs.writeFileSync(path.join(), content);
  }

  // readdir
  function ___R$$priv$project$rome$$romejs$fs$index_ts$createReaddirReturn(
    folder,
    files,
  ) {
    return (
      new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet(
        files.map(
          (basename) => {
            return folder.append(basename);
          },
        ),
      )
    );
  }

  function ___R$project$rome$$romejs$fs$index_ts$readdir(path) {
    return (
      new Promise(
        (resolve, reject) => {
          ___R$$priv$project$rome$$romejs$fs$index_ts$fs.readdir(
            path.join(),
            (err, files) => {
              if (err === null) {
                resolve(___R$$priv$project$rome$$romejs$fs$index_ts$createReaddirReturn(path, files));
              } else {
                reject(err);
              }
            },
          );
        },
      )
    );
  }

  function ___R$project$rome$$romejs$fs$index_ts$readdirSync(path) {
    return ___R$$priv$project$rome$$romejs$fs$index_ts$createReaddirReturn(path, ___R$$priv$project$rome$$romejs$fs$index_ts$fs.readdirSync(path.join()));
  }

  function ___R$project$rome$$romejs$fs$index_ts$lstat(path) {
    return (
      ___R$$priv$project$rome$$romejs$fs$index_ts$promisifyData(
        path,
        (filename, callback) => ___R$$priv$project$rome$$romejs$fs$index_ts$fs.lstat(filename, callback),
      )
    );
  }

  function ___R$project$rome$$romejs$fs$index_ts$lstatSync(path) {
    return ___R$$priv$project$rome$$romejs$fs$index_ts$fs.lstatSync(path.join());
  }

  function ___R$project$rome$$romejs$fs$index_ts$exists(path) {
    return (
      new Promise(
        (resolve) => {
          ___R$$priv$project$rome$$romejs$fs$index_ts$fs.exists(
            path.join(),
            (exists) => {
              resolve(exists);
            },
          );
        },
      )
    );
  }

  function ___R$project$rome$$romejs$fs$index_ts$existsSync(path) {
    return ___R$$priv$project$rome$$romejs$fs$index_ts$fs.existsSync(path.join());
  }

  function ___R$project$rome$$romejs$fs$index_ts$unlink(path) {
    return (
      ___R$$priv$project$rome$$romejs$fs$index_ts$promisifyVoid(
        path,
        (
          filename,
          callback,
        ) =>
          ___R$$priv$project$rome$$romejs$fs$index_ts$fs.unlink(
            filename,
            (err) => {
              if (err != null && err.code !== 'ENOENT') {
                callback(err);
              } else {
                callback(null);
              }
            },
          ),
      )
    );
  }

  function ___R$project$rome$$romejs$fs$index_ts$unlinkSync(path) {
    try {
      ___R$$priv$project$rome$$romejs$fs$index_ts$fs.unlinkSync(path.join());
    } catch (err) {
      if (err.code !== 'ENOENT') {
        throw err;
      }
    }
  }

  function ___R$project$rome$$romejs$fs$index_ts$createDirectory(
    path,
    opts = {},
  ) {
    return (
      ___R$$priv$project$rome$$romejs$fs$index_ts$promisifyVoid(
        path,
        (
          filename,
          callback,
        ) =>
          ___R$$priv$project$rome$$romejs$fs$index_ts$fs.mkdir(filename, {recursive: opts.recursive}, callback),
      )
    );
  }

  function ___R$project$rome$$romejs$fs$index_ts$createDirectorySync(
    path,
    opts = {},
  ) {
    ___R$$priv$project$rome$$romejs$fs$index_ts$fs.mkdirSync(path.join(), {recursive: opts.recursive});
  }

  // project-rome/@romejs/core/common/fileHandlers.ts
function ___R$project$rome$$romejs$core$common$fileHandlers_ts$getFileHandlerExtensions(
    projectConfig,
  ) {
    return [...___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$DEFAULT_HANDLERS.keys(), ...projectConfig.files.assetExtensions];
  }

  function ___R$project$rome$$romejs$core$common$fileHandlers_ts$getFileHandler(
    path,
    projectConfig,
  ) {
    const basename = path.getBasename();

    const match = basename.match(/\.([a-zA-Z]+)$/);
    if (match == null) {
      return {ext: '', handler: undefined};
    }

    const ext = match[1];
    let handler = ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$DEFAULT_HANDLERS.get(ext);

    // Allow setting custom assert extensions in the project config
    if (handler === undefined && projectConfig.files.assetExtensions.includes(ext)) {
      handler = ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$assetHandler;
    }

    return {ext, handler};
  }

  function ___R$project$rome$$romejs$core$common$fileHandlers_ts$getFileHandlerAssert(
    path,
    projectConfig,
  ) {
    const {handler, ext} = ___R$project$rome$$romejs$core$common$fileHandlers_ts$getFileHandler(path, projectConfig);

    if (handler === undefined) {
      throw new Error('No file handler found for \'' +
      path.join() +
      '\'');
    } else {
      return {handler, ext};
    }
  }

  const ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$textHandler = {
    sourceType: 'module',

    // Mock a single default export

    // We could always just pass this through to analyzeDependencies and get the same result due to the toJavaScript call below,

    // but the return value is predictable so we inline it
    async analyzeDependencies() {
      return (
        Object.assign(
          {
          },
          ___R$project$rome$$romejs$core$common$types$analyzeDependencies_ts$UNKNOWN_ANALYZE_DEPENDENCIES_RESULT,
          {
            moduleType: 'es',
            exports: [
              {
                type: 'local',
                // TODO we could fake this?
                loc: undefined,
                kind: 'value',
                valueType: 'other',
                name: 'default',
              },
            ],
          },
        )
      );
    },

    async toJavaScript({file}) {
      const src = await ___R$project$rome$$romejs$fs$index_ts$readFileText(file.real);
      const serial = JSON.stringify(src);
      return (
        {
          sourceText: 'export default ' +
          serial +
          ';',
          generated: true,
        }
      );
    },
  };

  const ___R$project$rome$$romejs$core$common$fileHandlers_ts$ASSET_EXPORT_TEMPORARY_VALUE = 'VALUE_INJECTED_BY_BUNDLER';

  const ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$assetHandler = Object.assign(
    {
    },
    ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$textHandler,
    {
      canHaveScale: true,
      isAsset: true,

      async toJavaScript() {
        // This exists just so analyzeDependencies has something to look at

        // When bundling we'll have custom logic in the compiler to handle assets and inject the correct string
        return (
          {
            generated: true,
            sourceText: 'export default \'' +
            ___R$project$rome$$romejs$core$common$fileHandlers_ts$ASSET_EXPORT_TEMPORARY_VALUE +
            '\';',
          }
        );
      },
    },
  );

  const ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$jsonHandler = Object.assign(
    {
    },
    ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$textHandler,
    {
      hasteMode: 'noext',

      async format(info) {
        const {file: ref, project} = info;
        const {uid} = ref;

        const real = ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(ref.real);
        const sourceText = await ___R$project$rome$$romejs$fs$index_ts$readFileText(real);
        const path = ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(uid);

        let formatted = sourceText;

        if (project.config.format.enabled) {
          if (sourceText.length > 50000) {
            // Fast path for big JSON files
            ___R$project$rome$$romejs$codec$json$index_ts$parseJSON(
              {
                path,
                input: sourceText,
              },
            );
          } else {
            const {consumer, comments, hasExtensions} = ___R$project$rome$$romejs$codec$json$index_ts$consumeJSONExtra(
              {
                input: sourceText,
                path,
              },
            );

            if (hasExtensions) {
              formatted = ___R$project$rome$$romejs$codec$json$index_ts$stringifyJSON({consumer, comments});
            } else {
              formatted =
                String(
                  JSON.stringify(
                    consumer.asUnknown(),
                    undefined,
                    '  ',
                  ),
                );
            }
          }
        }

        return (
          {
            sourceText,
            diagnostics: [],
            suppressions: [],
            formatted,
          }
        );
      },

      async toJavaScript({file}) {
        const src = await ___R$project$rome$$romejs$fs$index_ts$readFileText(file.real);

        // Parse the JSON to make sure it's valid
        const obj = ___R$project$rome$$romejs$codec$json$index_ts$parseJSON(
          {
            path: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(file.uid),
            input: src,
          },
        );

        const rawJson = JSON.stringify(obj);
        const json = rawJson === undefined ? 'undefined' : rawJson;

        // TODO handle unicode newlines here
        return (
          {
            sourceText: 'export default ' +
            json +
            ';',
            generated: true,
          }
        );
      },
    },
  );

  // These are extensions that be implicitly tried when a file is referenced

  // This is mostly for compatibility with Node.js projects. This list should not

  // be extended. Explicit extensions are required in the browser for as modules and

  // should be required everywhere.

  // TypeScript is unfortunately included here as it produces an error if you use an

  // import source with ".ts"
  const ___R$project$rome$$romejs$core$common$fileHandlers_ts$IMPLICIT_JS_EXTENSIONS = ['js', 'json', 'ts', 'tsx'];

  const ___R$project$rome$$romejs$core$common$fileHandlers_ts$LINTABLE_EXTENSIONS = [];

  const ___R$project$rome$$romejs$core$common$fileHandlers_ts$FORMATTABLE_EXTENSIONS = [];

  function ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$setHandler(ext, handler) {
    if (handler.lint !== undefined) {
      ___R$project$rome$$romejs$core$common$fileHandlers_ts$LINTABLE_EXTENSIONS.push(ext);
    }

    if (handler.format !== undefined) {
      ___R$project$rome$$romejs$core$common$fileHandlers_ts$FORMATTABLE_EXTENSIONS.push(ext);
    }

    ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$DEFAULT_HANDLERS.set(ext, handler);
  }

  // Used when filtering files, inserted by buildJSHandler
  const ___R$project$rome$$romejs$core$common$fileHandlers_ts$JS_EXTENSIONS = [];

  function ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$buildJSHandler(
    ext,
    syntax,
    sourceType,
  ) {
    ___R$project$rome$$romejs$core$common$fileHandlers_ts$JS_EXTENSIONS.push(ext);

    return (
      {
        hasteMode: 'ext',
        syntax,
        sourceType,

        async analyzeDependencies({file, worker}) {
          const {ast, sourceText, project, generated} = await worker.parseJS(file);
          worker.logger.info('Analyzing:', file.real);

          return (
            worker.api.interceptAndAddGeneratedToDiagnostics(
              await ___R$project$rome$$romejs$js$compiler$index_ts.analyzeDependencies(
                {
                  ast,
                  sourceText,
                  project,
                  options: {},
                },
              ),
              generated,
            )
          );
        },

        async toJavaScript({file}) {
          return (
            {
              sourceText: await ___R$project$rome$$romejs$fs$index_ts$readFileText(file.real),
              generated: false,
            }
          );
        },

        async format(info) {
          const {file: ref, worker} = info;

          const {ast, sourceText, generated} = await worker.parseJS(ref);

          const res = ___R$project$rome$$romejs$js$generator$index_ts$generateJS(
            ast,
            {
              typeAnnotations: true,
              format: 'pretty',
            },
          );

          const extractedSuppressions = ___R$project$rome$$romejs$js$compiler$index_ts.extractSuppressionsFromProgram(ast);

          return (
            worker.api.interceptAndAddGeneratedToDiagnostics(
              {
                formatted: res.buf.getCode(),
                sourceText,
                suppressions: extractedSuppressions.suppressions,
                diagnostics: [
                  ...ast.diagnostics,
                  ...extractedSuppressions.diagnostics,
                ],
              },
              generated,
            )
          );
        },

        async lint(info) {
          const {
            file: ref,
            project,
            format,
            prefetchedModuleSignatures,
            worker,
          } = info;

          const {ast, sourceText, generated} = await worker.parseJS(ref);

          worker.logger.info('Linting: ', ref.real);

          // Run the compiler in lint-mode which is where all the rules are actually ran
          const res = await ___R$project$rome$$romejs$js$compiler$index_ts.lint(
            {
              options: {},
              ast,
              project,
              sourceText,
              format,
            },
          );

          // Extract lint diagnostics
          let {diagnostics} = res;

          // Only enable typechecking if enabled in .romeconfig
          let typeCheckingEnabled = project.config.typeCheck.enabled === true;
          if (project.config.typeCheck.libs.has(ref.real)) {
            // don't typecheck lib files
            typeCheckingEnabled = false;
          }

          // Run type checking if necessary
          if (typeCheckingEnabled) {
            const typeCheckProvider = await worker.getTypeCheckProvider(
              ref.project,
              prefetchedModuleSignatures,
            );
            const typeDiagnostics = await ___R$project$rome$$romejs$js$analysis$api$check_ts$default(
              {
                ast,
                provider: typeCheckProvider,
                project,
              },
            );
            diagnostics = [...diagnostics, ...typeDiagnostics];
          }

          return (
            worker.api.interceptAndAddGeneratedToDiagnostics(
              {
                suppressions: res.suppressions,
                diagnostics,
                sourceText,
                formatted: res.src,
              },
              generated,
            )
          );
        },
      }
    );
  }

  const ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$DEFAULT_HANDLERS = new Map();

  const ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$DEFUALT_ASSET_EXTENSIONS = [
    // Images
    'png',
    'jpg',
    'jpeg',
    'gif',

    // Video
    'webm',
    'mp4',
    'm4v',
    'avi',
    'mkv',

    // Audio
    'mp3',

    // Fonts
    'woff',
    'woff2',
    'eot',
    'ttf',
    'otf',
  ];
  for (const ext of ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$DEFUALT_ASSET_EXTENSIONS) {
    ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$setHandler(ext, ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$assetHandler);
  }

  ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$setHandler('html', ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$textHandler);
  ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$setHandler('htm', ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$textHandler);
  ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$setHandler('css', ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$textHandler);
  ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$setHandler('txt', ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$textHandler);
  ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$setHandler('md', ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$textHandler);
  ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$setHandler('csv', ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$textHandler);
  ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$setHandler('tsv', ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$textHandler);

  ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$setHandler('js', ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$buildJSHandler('js', ['jsx', 'flow'])); // TODO eventually remove the syntax shit
  ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$setHandler('jsx', ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$buildJSHandler('jsx', ['jsx']));
  ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$setHandler('cjs', ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$buildJSHandler('cjs', [], 'script'));
  ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$setHandler('mjs', ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$buildJSHandler('mjs', [], 'module'));
  ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$setHandler('ts', ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$buildJSHandler('ts', ['ts'], 'module'));
  ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$setHandler('tsx', ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$buildJSHandler('tsx', ['ts', 'jsx'], 'module'));
  ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$setHandler('json', ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$jsonHandler);
  ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$setHandler('rjson', ___R$$priv$project$rome$$romejs$core$common$fileHandlers_ts$jsonHandler);

  // project-rome/@romejs/js-compiler/transforms/compileForBundle/assetTransform.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$assetTransform_ts$default = {
    name: 'asset',

    enter(path) {
      const {node} = path;
      const options = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getOptions(path.context);

      if (node.type === 'ExportDefaultDeclaration' &&
        node.declaration.type ===
        'StringLiteral' &&
        node.declaration.value === ___R$project$rome$$romejs$core$common$fileHandlers_ts$ASSET_EXPORT_TEMPORARY_VALUE &&
        options.assetPath !== undefined) {
        return (
          Object.assign(
            {
            },
            node,
            {
              declaration: Object.assign(
                {
                },
                node.declaration,
                {
                  value: options.moduleId,
                },
              ),
            },
          )
        );
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/compileForBundle/modern/cjsRootTransform.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$modern$cjsRootTransform_ts$default = {
    name: 'cjsRootTransform',
    enter(path) {
      const {node, scope, context} = path;

      const {moduleId} = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getOptions(context);

      if (node.type === 'Program') {
        const mappings = new Map();

        // make all variables private
        for (const [name] of path.scope.bindings) {
          mappings.set(name, ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrivateName(name, moduleId));
        }

        if (scope.hasBinding('exports') === false) {
          mappings.set('exports', ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(moduleId));
        }

        const newProgram = ___R$project$rome$$romejs$js$ast$utils$renameBindings_ts$default(path, mappings);
        return newProgram;
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/compileForBundle/modern/esToRefTransform.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$modern$esToRefTransform_ts$default = {
    name: 'esToRefTransform',
    enter(path) {
      const {node, scope, context} = path;

      const opts = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getOptions(context);

      if (___R$project$rome$$romejs$js$ast$core$Program_ts$program.is(node)) {
        const mappings = new Map();

        // make all variables private
        for (const [name] of path.scope.bindings) {
          mappings.set(name, ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrivateName(name, opts.moduleId));
        }

        // map exports and imports and correctly
        for (const child of node.body) {
          if (child.type === 'ImportDeclaration' && child.importKind !== 'type' &&
            child.importKind !== 'typeof' &&
            child.specifiers !== undefined) {
            const moduleId = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getModuleId(child.source.value, opts);
            if (moduleId === undefined) {
              continue;
            }

            for (const specifier of child.specifiers) {
              if (specifier.type === 'ImportSpecifier') {
                mappings.set(
                  specifier.local.name.name,
                  ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
                    specifier.imported.name,
                    moduleId,
                    opts,
                  ),
                );
              } else if (specifier.type === 'ImportNamespaceSpecifier') {
                mappings.set(
                  specifier.local.name.name,
                  ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(
                    moduleId,
                  ),
                );
              } else if (specifier.type === 'ImportDefaultSpecifier') {
                mappings.set(
                  specifier.local.name.name,
                  ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
                    'default',
                    moduleId,
                    opts,
                  ),
                );
              } else {
                throw new Error('unexpected');
              }
            }
          }

          if (child.type === 'ExportLocalDeclaration') {
            // export const foo = '';

            // export function foo() {}
            for (const {name} of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(child)) {
              mappings.set(name, ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(name, opts.moduleId, opts));
            }

            // export {foo};
            if (child.specifiers !== undefined) {
              for (const specifier of child.specifiers) {
                const local = specifier.local.name;
                if (scope.getBindingAssert(local) instanceof ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ImportBinding) {
                  continue;
                }

                mappings.set(
                  local,
                  ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
                    specifier.exported.name,
                    opts.moduleId,
                    opts,
                  ),
                );
              }
            }
          }

          if (child.type === 'ExportDefaultDeclaration') {
            const {declaration: decl} = child;
            if ((decl.type === 'FunctionDeclaration' ||
            decl.type ===
            'ClassDeclaration') &&
              decl.id !== undefined) {
              mappings.set(
                decl.id.name,
                ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
                  'default',
                  opts.moduleId,
                  opts,
                ),
              );
            }
          }
        }

        const newProgram = ___R$project$rome$$romejs$js$ast$core$Program_ts$program.assert(___R$project$rome$$romejs$js$ast$utils$renameBindings_ts$default(path, mappings));

        // Get new scope with updated bindings. TODO Maybe `renameBindings` should return the path?
        const newScope = scope.getRootScope().evaluate(newProgram, undefined, true);

        if (opts.moduleAll === true) {
          // Get all the export names
          const exportNames = new Map();
          for (const child of newProgram.body) {
            if (child.type === 'ExportDefaultDeclaration') {
              exportNames.set(
                'default',
                ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
                  'default',
                  opts.moduleId,
                  opts,
                ),
              );
            }

            if (child.type === 'ExportLocalDeclaration' ||
            child.type ===
            'ExportExternalDeclaration') {
              const {specifiers} = child;

              if (child.type === 'ExportLocalDeclaration' &&
                child.declaration !==
                undefined) {
                throw (
                  new Error(
                    'No export declarations should be here as they have been removed by renameBindings',
                  )
                );
              }

              let source;
              if (child.type === 'ExportExternalDeclaration') {
                source = child.source;
              }

              if (specifiers !== undefined) {
                for (const specifier of specifiers) {
                  if (specifier.type === 'ExportLocalSpecifier' ||
                  specifier.type === 'ExportExternalSpecifier') {
                    // The local binding has already been rewritten by renameBindings if it existed
                    let local = specifier.local.name;

                    // If this is an external export then use the correct name
                    if (source !== undefined) {
                      const moduleId = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getModuleId(source.value, opts);
                      if (moduleId === undefined) {
                        continue;
                      }

                      local = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(local, moduleId, opts);
                    }

                    exportNames.set(specifier.exported.name, local);
                  } else {
                    // TODO ???
                  }
                }
              }
            }
          }

          const exportObjProps = [];

          for (const [exported, local] of exportNames) {
            const binding = newScope.getBinding(local);
            if (binding !== undefined) {
              if (binding instanceof ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$TypeBinding) {
                continue;
              }

              if (binding instanceof ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$FunctionBinding) {
                exportObjProps.push(
                  ___R$project$rome$$romejs$js$ast$objects$ObjectProperty_ts$objectProperty.create(
                    {
                      key: ___R$project$rome$$romejs$js$ast$objects$StaticPropertyKey_ts$staticPropertyKey.quick(___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.quick(exported)),
                      value: ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(local),
                    },
                  ),
                );
                continue;
              }
            }

            exportObjProps.push(
              ___R$project$rome$$romejs$js$ast$objects$ObjectMethod_ts$objectMethod.create(
                {
                  kind: 'get',
                  key: ___R$project$rome$$romejs$js$ast$objects$StaticPropertyKey_ts$staticPropertyKey.quick(___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.quick(exported)),
                  head: ___R$project$rome$$romejs$js$ast$auxiliary$FunctionHead_ts$functionHead.quick([]),
                  body: ___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts$blockStatement.create(
                    {
                      body: [
                        ___R$project$rome$$romejs$js$ast$statements$ReturnStatement_ts$returnStatement.create(
                          {
                            argument: ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.create(
                              {
                                name: local,
                              },
                            ),
                          },
                        ),
                      ],
                    },
                  ),
                },
              ),
            );
          }

          const exportObj = ___R$project$rome$$romejs$js$ast$objects$ObjectExpression_ts$objectExpression.create({properties: exportObjProps});

          return (
            Object.assign(
              {
              },
              newProgram,
              {
                type: 'Program',
                body: [
                  ___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement.quick(
                    ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.create(
                      {
                        kind: 'const',
                        declarations: [
                          ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator.create(
                            {
                              id: ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.create(
                                {
                                  name: ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(opts.moduleId),
                                },
                              ),
                              init: exportObj,
                            },
                          ),
                        ],
                      },
                    ),
                  ),
                  ...newProgram.body,
                ],
              },
            )
          );
        } else {
          return newProgram;
        }
      }

      if (node.type === 'ImportDeclaration') {
        // should have already been handled with the Program branch
        return ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_REMOVE;
      }

      if (node.type === 'ExportDefaultDeclaration') {
        const {declaration} = node;
        if (declaration.type === 'FunctionDeclaration' ||
        declaration.type ===
        'ClassDeclaration') {
          if (declaration.id === undefined) {
            // give it the correct name
            return (
              Object.assign(
                {
                },
                node,
                {
                  declaration: Object.assign(
                    {
                    },
                    declaration,
                    {
                      id: ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.create(
                        {
                          name: ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName('default', opts.moduleId, opts),
                        },
                      ),
                    },
                  ),
                },
              )
            );
          } else {
            // if the export was named then we'll have already given it the correct name
            return declaration;
          }
        } else {
          return (
            ___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`const ${___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
              'default',
              opts.moduleId,
              opts,
            )} = ${declaration};`
          );
        }
      }

      if (node.type === 'ExportExternalDeclaration') {
        // Remove external exports with a source as they will be resolved correctly and never point here
        return ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_REMOVE;
      }

      if (node.type === 'ExportLocalDeclaration') {
        const {declaration, specifiers} = node;

        if (specifiers === undefined) {
          if (declaration === undefined) {
            throw (
              new Error(
                'No specifiers or declaration existed, if there\'s no specifiers then there should be a declaration',
              )
            );
          }
          return declaration;
        } else {
          // check if any of the specifiers reference a global or import

          // if so, we need to insert declarations for them
          const nodes = [];

          for (const specifier of specifiers) {
            if (specifier.type === 'ExportLocalSpecifier') {
              const binding = path.scope.getBinding(specifier.local.name);

              // TODO we only really need this declaration for global bindings, `analyze()` could detect the exported import and resolvedImports would just work
              if (binding === undefined || binding instanceof ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ImportBinding) {
                nodes.push(
                  ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.create(
                    {
                      kind: 'const',
                      declarations: [
                        ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator.create(
                          {
                            id: ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.create(
                              {
                                name: ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
                                  specifier.exported.name,
                                  opts.moduleId,
                                  opts,
                                ),
                              },
                            ),
                            init: ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(specifier.local.name),
                          },
                        ),
                      ],
                    },
                  ),
                );
              }
            } else {
              // TODO ???
            }
          }

          if (nodes.length === 0) {
            return ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_REMOVE;
          } else {
            return nodes;
          }
        }
      }

      if (node.type === 'ExportAllDeclaration' && opts.moduleAll === true) {
        const moduleId = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getModuleId(node.source.value, opts);
        if (moduleId === undefined) {
          return node;
        }

        const theirNamespace = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(moduleId);
        const ourNamespace = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(opts.moduleId);
        return (
          ___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`
        Object.keys(${theirNamespace}).forEach(function (key) {
          if (key === 'default') return undefined;
          Object.defineProperty(${ourNamespace}, key, {
            enumerable: true,
            configurable: true,
            get: function get() {
              return ${theirNamespace}[key];
            }
          });
        });
      `
        );
      }

      if (node.type === 'ExportAllDeclaration' && opts.moduleAll !== true) {
        // We can remove these, this signature has already been flagged by analyze() and we'll automatically forward it
        return ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_REMOVE;
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/compileForBundle/modern/requireRewriteTransform.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$modern$requireRewriteTransform_ts$default = {
    name: 'requireRewriteTransform',
    enter(path) {
      const {node, context} = path;

      const {relativeSourcesToModuleId, moduleId} = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getOptions(context);

      // Replace all references to module.exports to the correct version
      if (node.type === 'MemberExpression' &&
        ___R$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(
          node,
          'module.exports',
        )) {
        return (
          ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.create(
            {
              name: ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(moduleId),
              loc: ___R$project$rome$$romejs$js$ast$utils$inheritLoc_ts$default(node, 'module.exports'),
            },
          )
        );
      }

      // Replace all assignments of module.exports to the correct version
      if (node.type === 'AssignmentExpression' &&
        ___R$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(
          node.left,
          'module.exports',
        )) {
        return (
          ___R$project$rome$$romejs$js$ast$expressions$AssignmentExpression_ts$assignmentExpression.create(
            {
              operator: node.operator,
              left: ___R$project$rome$$romejs$js$ast$patterns$AssignmentIdentifier_ts$assignmentIdentifier.create(
                {
                  name: ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(moduleId),
                  loc: ___R$project$rome$$romejs$js$ast$utils$inheritLoc_ts$default(node, 'module.exports'),
                },
              ),
              right: node.right,
            },
          )
        );
      }

      // Replace import foo = require('module');
      if (node.type === 'TSImportEqualsDeclaration' &&
        node.moduleReference.type === 'TSExternalModuleReference') {
        return (
          ___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`const ${node.id} = require(${node.moduleReference.expression});`
        );
      }

      // Now handle normal `require('module')`
      if (node.type !== 'CallExpression') {
        return node;
      }

      const {callee} = node;
      if (callee.type !== 'ReferenceIdentifier' || callee.name !== 'require') {
        return node;
      }

      const sourceArg = node.arguments[0];
      if (sourceArg.type !== 'StringLiteral') {
        return node;
      }

      if (path.scope.hasBinding('require')) {
        return node;
      }

      const replacement = relativeSourcesToModuleId[sourceArg.value];
      if (typeof replacement === 'string') {
        return (
          ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.create(
            {
              name: ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(replacement),
            },
          )
        );
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/compileForBundle/legacy/magicCJSTransform.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$legacy$magicCJSTransform_ts$default = {
    name: 'magicCJSTransform',
    enter(path) {
      const {node, scope, context} = path;
      const options = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getOptions(context);

      // Update relative requires with their module id
      if (node.type === 'CallExpression' &&
        node.callee.type ===
        'ReferenceIdentifier' &&
        node.callee.name === 'require' &&
        scope.getBinding(
          'require',
        ) ===
        undefined) {
        const args = node.arguments;
        const arg = args[0];

        // Maybe error?
        if (args.length !== 1 || arg.type !== 'StringLiteral') {
          return node;
        }

        const source = arg.value;

        if (Object.prototype.hasOwnProperty.call(
          options.relativeSourcesToModuleId,
          source,
        )) {
          const resolved = options.relativeSourcesToModuleId[source];
          const sourceNode = ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.create(
            {
              value: resolved,
            },
          );
          return ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`Rome.requireNamespace(${sourceNode})`;
        }
      }

      if (node.type === 'ReferenceIdentifier' && node.name === 'require' &&
        scope.getBinding('require') === undefined) {
        return ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`Rome.requireNamespace`;
      }

      return node;
    },

    exit(path) {
      const {node, context} = path;
      const options = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getOptions(context);

      // Add module wrapper
      if (node.type === 'Program') {
        const source = ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.create(
          {
            value: options.moduleId,
          },
        );

        // Build factory
        const factoryBody = ___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts$blockStatement.create(
          {
            directives: node.directives,
            body: node.body,
          },
        );

        const factory = Object.assign(
          {
          },
          ___R$project$rome$$romejs$js$ast$expressions$FunctionExpression_ts$functionExpression.assert(
            ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`(function(module, exports) {})`,
          ),
          {
            body: factoryBody,
          },
        );

        // Build call
        const declare = options.analyze.moduleType === 'es'
          ? ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`Rome.declareES` : ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`Rome.declareCJS`;
        const wrapper = ___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`${declare}(${source}, ${factory})`;

        return (
          Object.assign(
            {
            },
            node,
            {
              directives: [],
              body: [wrapper],
            },
          )
        );
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/compileForBundle/legacy/inlineRequiresTransform.ts
const ___R$$priv$project$rome$$romejs$js$compiler$transforms$compileForBundle$legacy$inlineRequiresTransform_ts$NON_INLINED_REQUIRES = [];
  const ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$legacy$inlineRequiresTransform_ts$default = {
    name: 'inlineRequiresTransform',
    enter(path) {
      const {node} = path;

      if (node.type === 'ReferenceIdentifier') {
        const binding = path.scope.getBinding(node.name);

        // Inline references to a require variable
        if (binding !== undefined && binding instanceof ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ConstBinding) {
          const source = ___R$project$rome$$romejs$js$ast$utils$getRequireSource_ts$default(binding.value, path.scope, true);
          if (source !== undefined && !___R$$priv$project$rome$$romejs$js$compiler$transforms$compileForBundle$legacy$inlineRequiresTransform_ts$NON_INLINED_REQUIRES.includes(source) &&
            !___R$project$rome$$romejs$js$ast$utils$isInTypeAnnotation_ts$default(path) &&
            binding.value !== undefined) {
            return binding.value;
          }
        }
      }

      return node;
    },

    exit(path) {
      const {node} = path;

      if (node.type === 'Program' || node.type === 'BlockStatement') {
        const body = [];
        let hadRequires = false;

        // Remove all require declarations that could have been inlined
        for (const bodyNode of node.body) {
          if (bodyNode.type === 'VariableDeclarationStatement' &&
            bodyNode.declaration.kind === 'const') {
            let hadRequireDeclarators = false;
            const declarators = [];

            for (const decl of bodyNode.declaration.declarations) {
              if (decl.id.type !== 'BindingIdentifier') {
                // Patterns aren't supported yet
                declarators.push(decl);
                continue;
              }

              const source = ___R$project$rome$$romejs$js$ast$utils$getRequireSource_ts$default(decl.init, path.scope, true);
              if (source === undefined) {
                // Didn't contain a `require`
                declarators.push(decl);
                continue;
              }

              if (___R$$priv$project$rome$$romejs$js$compiler$transforms$compileForBundle$legacy$inlineRequiresTransform_ts$NON_INLINED_REQUIRES.includes(source)) {
                // Blacklisted
                declarators.push(decl);
                continue;
              }

              hadRequireDeclarators = true;
              hadRequires = true;
            }

            if (hadRequireDeclarators) {
              if (declarators.length > 0) {
                body.push(
                  Object.assign(
                    {
                    },
                    bodyNode,
                    {
                      declaration: Object.assign(
                        {
                        },
                        bodyNode.declaration,
                        {
                          declarations: declarators,
                        },
                      ),
                    },
                  ),
                );
              }
              continue;
            }
          }

          body.push(bodyNode);
        }

        if (!hadRequires) {
          return node;
        }

        return (
          Object.assign(
            {
            },
            node,
            {
              body,
            },
          )
        );
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/compileForBundle/legacy/esToCJSTransform.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$legacy$esToCJSTransform_ts$default = {
    name: 'esToCJSTransform',
    enter(path) {
      const {node} = path;
      if (!___R$project$rome$$romejs$js$ast$core$Program_ts$program.is(node)) {
        return node;
      }

      const options = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getOptions(path.context);

      const topBody = [];
      const bottomBody = [];

      for (const bodyNode of node.body) {
        if (bodyNode.type === 'ImportDeclaration') {
          if (bodyNode.importKind === 'type') {
            continue;
          }

          const moduleId = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getModuleId(bodyNode.source.value, options);
          if (moduleId === undefined) {
            continue;
          }

          const source = ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.create(
            {
              value: moduleId,
            },
          );

          const {specifiers} = bodyNode;
          if (specifiers === undefined || specifiers.length === 0) {
            topBody.push(___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`Rome.requireNamespace(${source});`);
          } else {
            for (const specifier of specifiers) {
              if (specifier.local.importKind === 'type') {
                continue;
              }

              if (specifier.type === 'ImportSpecifier') {
                topBody.push(
                  ___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`const ${specifier.local.name} = Rome.requireNamespace(${source}).${specifier.imported};`,
                );
              } else if (specifier.type === 'ImportNamespaceSpecifier') {
                topBody.push(
                  ___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`const ${specifier.local.name} = Rome.requireNamespace(${source});`,
                );
              } else if (specifier.type === 'ImportDefaultSpecifier') {
                topBody.push(
                  ___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`const ${specifier.local.name} = Rome.requireDefault(${source});`,
                );
              }
            }
          }
          continue;
        }

        if (bodyNode.type === 'ExportAllDeclaration') {
          // TODO
          continue;
        }

        if (bodyNode.type === 'ExportLocalDeclaration' ||
        bodyNode.type ===
        'ExportExternalDeclaration') {
          // Ignore typed exports
          if (bodyNode.exportKind === 'type') {
            continue;
          }

          let declaration;
          let source;
          const {specifiers} = bodyNode;

          if (bodyNode.type === 'ExportExternalDeclaration') {
            source = bodyNode.source;
          }

          if (bodyNode.type === 'ExportLocalDeclaration') {
            declaration = bodyNode.declaration;
          }

          if (declaration !== undefined) {
            // Hoist function declarations
            if (declaration.type === 'FunctionDeclaration') {
              topBody.push(
                ___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`exports.${declaration.id} = ${declaration.id}`,
              );
              bottomBody.push(declaration);
              continue;
            }

            // Handle type declarations (these have no runtime ordering implications)
            if (declaration.type === 'TSModuleDeclaration' ||
            declaration.type ===
            'TSEnumDeclaration' ||
            declaration.type === 'FlowInterfaceDeclaration' ||
            declaration.type === 'TypeAliasTypeAnnotation' ||
            declaration.type === 'TSInterfaceDeclaration' ||
            declaration.type === 'TSDeclareFunction' ||
            declaration.type === 'FlowOpaqueType') {
              bottomBody.push(declaration);
              continue;
            }

            // Handle variables and classes
            if (declaration.type === 'VariableDeclarationStatement' ||
            declaration.type === 'ClassDeclaration') {
              bottomBody.push(declaration);

              for (const id of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(declaration)) {
                topBody.push(___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`exports.${id} = undefined;`);
                bottomBody.push(___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`exports.${id} = ${id};`);
              }
            }
          }

          if (specifiers !== undefined) {
            for (const specifier of specifiers) {
              if (specifier.type === 'ExportDefaultSpecifier') {
                // TODO only allowed for `source`
              }

              if (specifier.type === 'ExportNamespaceSpecifier') {
                // TODO only allowed for `source`
              }

              // TODO skip type exports
              if (specifier.type === 'ExportLocalSpecifier' ||
              specifier.type ===
              'ExportExternalSpecifier') {
                if (source === undefined) {
                  const binding = path.scope.getBinding(specifier.local.name);

                  if (binding instanceof ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$FunctionBinding) {
                    topBody.push(
                      ___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`exports.${specifier.exported} = ${specifier.local};`,
                    );
                  } else {
                    topBody.push(
                      ___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`exports.${specifier.exported} = undefined;`,
                    );
                    bottomBody.push(
                      ___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`exports.${specifier.exported} = ${specifier.local};`,
                    );
                  }
                } else {
                  topBody.push(
                    ___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`Object.defineProperty(exports, ${___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.create(
                      {
                        value: specifier.exported.name,
                      },
                    )}, {
                    get: function() {
                      return Rome.requireNamespace(${source}).${specifier.local};
                    },
                  })`,
                  );
                }
              }
            }
          }

          continue;
        }

        if (bodyNode.type === 'ExportDefaultDeclaration') {
          const {declaration} = bodyNode;

          // Hoist function declarations
          if (declaration.type === 'FunctionDeclaration') {
            // If it has an id then there's no way that anything in the program can refer to it, so inline it as a function expression
            if (declaration.id === undefined) {
              const expr = Object.assign(
                {
                },
                declaration,
                {
                  type: 'FunctionExpression',
                },
              );
              topBody.push(___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`exports.default = ${expr};`);
            } else {
              topBody.push(declaration);
              topBody.push(
                ___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`exports.default = ${declaration.id};`,
              );
            }
            continue;
          }

          // Handle classes
          if (declaration.type === 'ClassDeclaration') {
            // Technically we could hoist these if they have no super class, but we don't as it's not spec compliant
            topBody.push(___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`exports.default = undefined;`);
            if (declaration.id === undefined) {
              const expr = Object.assign(
                {
                },
                declaration,
                {
                  type: 'ClassExpression',
                },
              );
              bottomBody.push(___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`exports.default = ${expr};`);
            } else {
              bottomBody.push(declaration);
              bottomBody.push(
                ___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`exports.default = ${declaration.id};`,
              );
            }
            continue;
          }

          // Handle type declarations (these have no runtime ordering implications)
          if (declaration.type === 'FlowDeclareOpaqueType' ||
          declaration.type ===
          'TSInterfaceDeclaration' ||
          declaration.type === 'TSDeclareFunction') {
            // Maybe we should keep them? Not sure what they would desugar to
            continue;
          }

          // Otherwise it's an expression
          bottomBody.push(___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`exports.default = ${declaration};`);

          // There are cases where we could omit this declaration at all if we the file has no imports, some other conditions etc
          topBody.push(___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`exports.default = undefined;`);

          continue;
        }

        bottomBody.push(bodyNode);
      }

      return (
        Object.assign(
          {
          },
          node,
          {
            body: [...topBody, ...bottomBody],
          },
        )
      );
    },
  };

  // project-rome/@romejs/js-compiler/transforms/compileForBundle/metaPropertyTransform.ts
function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compileForBundle$metaPropertyTransform_ts$isImportMeta(node) {
    return (
      node.type === 'MetaProperty' && node.meta.name === 'import' &&
        node.property.name === 'meta'
    );
  }

  function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compileForBundle$metaPropertyTransform_ts$createURLString(context) {
    const str = ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.create(
      {
        value: 'file://' +
        ___R$$priv$project$rome$$romejs$js$compiler$transforms$compileForBundle$metaPropertyTransform_ts$getFilename(context),
      },
    );
    return (
      ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`typeof __filename === 'string' ? 'file://' + __filename : ${str}`
    );
  }

  function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compileForBundle$metaPropertyTransform_ts$getFilename(context) {
    const {path} = context;
    if (path === undefined) {
      return '';
    } else {
      return path.join();
    }
  }

  const ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$metaPropertyTransform_ts$default = {
    name: 'metaPropertyTransform',
    enter(path) {
      const {node, context} = path;

      // Inline __filenamd and __dirname

      /*if (
      node.type === 'ReferenceIdentifier' &&
      (node.type === '__dirname' || node.name === '__filename')
    ) {
      if (node.type === '__dirname') {
        return stringLiteral.create({
          value: pathUtils.dirname(getFilename(context)),
        });
      }

      if (node.type === '__filename') {
        return stringLiteral.create({
          value: getFilename(context),
        });
      }
    }*/

      // Direct reference to import.meta.url
      if (node.type === 'MemberExpression' &&
        node.property.type ===
        'StaticMemberProperty' &&
        ___R$$priv$project$rome$$romejs$js$compiler$transforms$compileForBundle$metaPropertyTransform_ts$isImportMeta(node.object) &&
        node.property.value.type === 'Identifier' &&
        node.property.value.name ===
        'url') {
        return ___R$$priv$project$rome$$romejs$js$compiler$transforms$compileForBundle$metaPropertyTransform_ts$createURLString(context);
      }

      // This is an escaped import.meta or else our other transform would have changed it
      if (___R$$priv$project$rome$$romejs$js$compiler$transforms$compileForBundle$metaPropertyTransform_ts$isImportMeta(node)) {
        return ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`({url: ${___R$$priv$project$rome$$romejs$js$compiler$transforms$compileForBundle$metaPropertyTransform_ts$createURLString(context)}})`;
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/compileForBundle/scopedRomeTransform.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$scopedRomeTransform_ts$default = {
    name: 'scopedRome',

    enter(path) {
      const {node, scope} = path;

      if (scope.node === node && scope.hasBinding('Rome')) {
        return ___R$project$rome$$romejs$js$ast$utils$renameBindings_ts$default(path, new Map([['Rome', scope.generateUid('Rome')]]));
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/compileForBundle/asyncImportTransform.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$asyncImportTransform_ts$default = {
    name: 'asyncImport',

    enter(path) {
      const {node} = path;

      if (node.type === 'CallExpression' && node.callee.type === 'ImportCall') {
        return (
          Object.assign(
            {
            },
            node,
            {
              callee: ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.create(
                {
                  name: 'require',
                },
              ),
            },
          )
        );
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/compileForBundle/inlineEnv.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$inlineEnv_ts$default = {
    name: 'inlineEnv',

    enter(path) {
      const {node} = path;

      if (node.type === 'MemberExpression' &&
        node.property.value.type ===
        'Identifier' &&
        node.property.value.name === 'NODE_ENV' &&
        !path.scope.hasBinding('process') &&
        ___R$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(
          node,
          'process.env.NODE_ENV',
        )) {
        return (
          ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.create(
            {
              value: 'development',
            },
          )
        );
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/transforms/index.ts
const ___R$project$rome$$romejs$js$compiler$transforms$index_ts$stageOrder = [
    'pre',
    'compile',
    'compileForBundle',
  ];

  const ___R$project$rome$$romejs$js$compiler$transforms$index_ts$hookVisitors = [___R$project$rome$$romejs$js$compiler$transforms$defaultHooks$index_ts$variableInjectorVisitor];

  const ___R$project$rome$$romejs$js$compiler$transforms$index_ts$stageTransforms = {
    // These may effect dependency analysis
    pre: () => [___R$project$rome$$romejs$js$compiler$transforms$compile$validation$optimizeImports_ts$default, ___R$project$rome$$romejs$js$compiler$transforms$compile$validation$optimizeExports_ts$default, ___R$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$default],
    compile: () =>
      [
        ___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$paramlessCatch_ts$default,
        ___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$optionalChaining_ts$default,
        ___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$nullishCoalescing_ts$default,
        ___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$default,
        ___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$default,
        ___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$templateLiterals_ts$default,
        ___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$callSpread_ts$default,
      ],
    compileForBundle: (projectConfig, options) => {
      const opts = options.bundle;
      if (opts === undefined) {
        throw new Error('Expected bundle options for compileForBundle stage');
      }

      const transforms = [];

      if (opts.assetPath !== undefined) {
        transforms.push(___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$assetTransform_ts$default);
      }
      transforms.push(___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$metaPropertyTransform_ts$default);
      transforms.push(___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$asyncImportTransform_ts$default);
      transforms.push(___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$scopedRomeTransform_ts$default);
      transforms.push(___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$inlineEnv_ts$default);

      if (opts.mode === 'modern') {
        transforms.push(___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$modern$requireRewriteTransform_ts$default);
        transforms.push(
          opts.analyze.moduleType === 'cjs'
            ? ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$modern$cjsRootTransform_ts$default : ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$modern$esToRefTransform_ts$default,
        );
      } else {
        transforms.push(___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$legacy$inlineRequiresTransform_ts$default);
        transforms.push(___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$legacy$esToCJSTransform_ts$default);
        transforms.push(___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$legacy$magicCJSTransform_ts$default);
      }

      return transforms;
    },
  };

  // project-rome/@romejs/js-compiler/methods/transform.ts
const ___R$$priv$project$rome$$romejs$js$compiler$methods$transform_ts$transformCaches = ___R$project$rome$$romejs$js$compiler$transforms$index_ts$stageOrder.map(
    () =>
      new ___R$project$rome$$romejs$js$compiler$lib$Cache_ts$default(),
  );

  async function ___R$project$rome$$romejs$js$compiler$methods$transform_ts$default(
    req,
  ) {
    const stage = req.stage === undefined ? 'compile' : req.stage;

    const {options, project} = req;
    let ast = req.ast;

    const cacheQuery = ___R$project$rome$$romejs$js$compiler$lib$Cache_ts$default.buildQuery(req);

    const stageNo = ___R$project$rome$$romejs$js$compiler$transforms$index_ts$stageOrder.indexOf(stage);

    // Check this exact stage cache
    const stageCache = ___R$$priv$project$rome$$romejs$js$compiler$methods$transform_ts$transformCaches[stageNo];
    const cached = stageCache.get(cacheQuery);
    if (cached !== undefined) {
      return cached;
    }

    let prevStageDiagnostics = [];
    let prevStageCacheDeps = [];

    // Run the previous stage
    if (stageNo > 0) {
      const prevStage = await ___R$project$rome$$romejs$js$compiler$methods$transform_ts$default(Object.assign(
        {
        },
        req,
        {
          stage: ___R$project$rome$$romejs$js$compiler$transforms$index_ts$stageOrder[stageNo - 1],
        },
      ));
      prevStageDiagnostics = prevStage.diagnostics;
      prevStageCacheDeps = prevStage.cacheDependencies;
      ast = prevStage.ast;
    }

    const context = new ___R$project$rome$$romejs$js$compiler$lib$Context_ts$default(
      {
        ast,
        project,
        options,
        origin: {
          category: 'transform',
        },
      },
    );

    const transformFactory = ___R$project$rome$$romejs$js$compiler$transforms$index_ts$stageTransforms[stage];
    const transforms = transformFactory(project.config, options);

    let visitors = [
      ...___R$project$rome$$romejs$js$compiler$transforms$index_ts$hookVisitors,
      ...(await context.normalizeTransforms(transforms)),
    ];

    const compiledAst = ___R$project$rome$$romejs$js$ast$core$Program_ts$program.assert(context.reduce(ast, visitors));

    const extractedSuppressions = ___R$project$rome$$romejs$js$compiler$suppressions_ts$extractSuppressionsFromProgram(ast);

    const res = {
      suppressions: extractedSuppressions.suppressions,
      diagnostics: [
        ...prevStageDiagnostics,
        ...context.diagnostics,
        ...extractedSuppressions.diagnostics,
      ],
      cacheDependencies: [
        ...prevStageCacheDeps,
        ...context.getCacheDependencies(),
      ],
      ast: compiledAst,
    };
    stageCache.set(cacheQuery, res);
    return res;
  }

  // project-rome/@romejs/js-compiler/api/compile.ts
const ___R$$priv$project$rome$$romejs$js$compiler$api$compile_ts$compileCache = new ___R$project$rome$$romejs$js$compiler$lib$Cache_ts$default();

  async function ___R$project$rome$$romejs$js$compiler$api$compile_ts$default(
    req,
  ) {
    const {sourceText, ast} = req;

    const query = ___R$project$rome$$romejs$js$compiler$lib$Cache_ts$default.buildQuery(req);
    const cached = ___R$$priv$project$rome$$romejs$js$compiler$api$compile_ts$compileCache.get(query);
    if (cached) {
      return cached;
    }

    const {filename} = ast;
    const {
      ast: transformedAst,
      diagnostics,
      suppressions,
      cacheDependencies,
    } = await ___R$project$rome$$romejs$js$compiler$methods$transform_ts$default(req);
    const generator = ___R$project$rome$$romejs$js$generator$index_ts$generateJS(
      transformedAst,
      {
        typeAnnotations: false,
        indent: req.stage === 'compileForBundle' ? 1 : 0,
        sourceMapTarget: filename,
        sourceFileName: filename,
        inputSourceMap: req.inputSourceMap,
      },
      sourceText,
    );

    const res = {
      compiledCode: generator.buf.getCode(),
      mappings: generator.buf.getMappings(),
      diagnostics: [...ast.diagnostics, ...diagnostics],
      cacheDependencies,
      suppressions,
      sourceText,
    };
    ___R$$priv$project$rome$$romejs$js$compiler$api$compile_ts$compileCache.set(query, res);
    return res;
  }

  // project-rome/@romejs/js-compiler/api/analyzeDependencies/records.ts
class ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportRecord extends ___R$project$rome$$romejs$js$compiler$lib$Record_ts$default {
    constructor(data) {
      super();
      this.data = data;
    }
  }

  class ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord extends ___R$project$rome$$romejs$js$compiler$lib$Record_ts$default {
    constructor(data) {
      super();
      this.data = data;
    }
  }

  class ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$EscapedCJSRefRecord extends ___R$project$rome$$romejs$js$compiler$lib$Record_ts$default {
    constructor(node) {
      super();
      this.node = node;
    }
  }

  class ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$CJSExportRecord extends ___R$project$rome$$romejs$js$compiler$lib$Record_ts$default {
    constructor(node) {
      super();
      this.node = node;
    }
  }

  class ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$CJSVarRefRecord extends ___R$project$rome$$romejs$js$compiler$lib$Record_ts$default {
    constructor(node) {
      super();
      this.node = node;
    }
  }

  class ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ESExportRecord extends ___R$project$rome$$romejs$js$compiler$lib$Record_ts$default {
    constructor(kind, node) {
      super();
      this.node = node;
      this.kind = kind;
    }
  }

  class ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$TopLevelAwaitRecord extends ___R$project$rome$$romejs$js$compiler$lib$Record_ts$default {
    constructor(loc) {
      super();
      this.loc = loc;
    }
  }

  class ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportUsageRecord extends ___R$project$rome$$romejs$js$compiler$lib$Record_ts$default {
    constructor(isTop, data) {
      super();
      this.isTop = isTop;
      this.data = data;
    }
  }

  // project-rome/@romejs/js-compiler/api/analyzeDependencies/utils.ts
function ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$isOptional(path) {
    for (const {node} of path.ancestryPaths) {
      if (node.type === 'TryStatement') {
        return true;
      }
    }

    return false;
  }

  function ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$isTypeKind(kind) {
    return kind === 'type' || kind === 'typeof';
  }

  function ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getImportKind(
    kind,
  ) {
    return kind === undefined ? 'value' : kind;
  }

  function ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getExportKind(
    kind,
  ) {
    return kind === undefined ? 'value' : kind;
  }

  function ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$maybeTypeBinding(
    kind,
    scope,
    id,
  ) {
    const binding = scope.getBinding(id.name);
    if (kind === 'value' && binding instanceof ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$TypeBinding) {
      return 'type';
    } else {
      return kind;
    }
  }

  function ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getKindWithSpecifiers(
    rawKind,
    specifierKinds,
  ) {
    const kind = ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getImportKind(rawKind);
    if (___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$isTypeKind(kind) || specifierKinds.length === 0) {
      return kind;
    }

    for (const specifierKind of specifierKinds) {
      if (specifierKind === 'value') {
        return 'value';
      }
    }
    return 'type';
  }

  function ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(
    scope,
    node,
  ) {
    if (node === undefined) {
      return 'other';
    }

    if (node.type === 'Identifier') {
      const binding = scope.getBinding(node.name);

      if (binding instanceof ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$FunctionBinding) {
        return 'function';
      }

      if (binding instanceof ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ClassBinding) {
        return 'class';
      }

      if (binding instanceof ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$TypeBinding) {
        const {typeKind} = binding;
        switch (typeKind) {
          case 'function':
          case 'class':
            return typeKind;
        }
      }
    }

    if (node.type === 'FunctionDeclaration') {
      return 'function';
    }

    if (node.type === 'ClassDeclaration' || node.type === 'ClassExpression') {
      return 'class';
    }

    return 'other';
  }

  function ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(
    scope,
    node,
  ) {
    if (node.type === 'ReferenceIdentifier') {
      const binding = scope.getBinding(node.name);
      if (binding !== undefined) {
        return binding.node.loc;
      }
    }

    return node.loc;
  }

  // project-rome/@romejs/js-compiler/api/analyzeDependencies/visitors/es.ts
const ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$visitors$es_ts$default = {
    name: 'analyzeDependenciesES',
    enter(path) {
      const {node, scope, context} = path;

      // import('./bar');
      if (node.type === 'ImportCall' && node.argument.type === 'StringLiteral') {
        context.record(
          new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportRecord(
            {
              type: 'es',
              async: true,
              kind: 'value',
              names: [],
              loc: node.argument.loc,
              source: node.argument.value,
              optional: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$isOptional(path),
              all: true,
            },
          ),
        );
      }

      // Local bindings exports:
      // export const foo

      // export function foo() {}

      // export {};
      if (node.type === 'ExportLocalDeclaration') {
        const valueType = ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(scope, node.declaration);
        for (const id of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(node)) {
          const kind = ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$maybeTypeBinding(___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getExportKind(node.exportKind), scope, id);
          context.record(
            new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord(
              {
                type: 'local',
                valueType,
                kind,
                loc: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(scope, id),
                name: id.name,
              },
            ),
          );
        }

        const {specifiers} = node;
        if (specifiers !== undefined) {
          for (const specifier of specifiers) {
            const kind = ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$maybeTypeBinding(
              ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getExportKind(
                specifier.exportKind || node.exportKind,
              ),
              scope,
              specifier.local,
            );

            context.record(
              new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord(
                {
                  type: 'local',
                  loc: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(scope, specifier.local),
                  valueType: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(scope, specifier.local),
                  kind,
                  name: specifier.exported.name,
                },
              ),
            );
          }
        }
      }

      // export default
      if (node.type === 'ExportDefaultDeclaration') {
        context.record(
          new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord(
            {
              type: 'local',
              loc: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(scope, node.declaration),
              valueType: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(scope, node.declaration),
              kind: 'value',
              name: 'default',
            },
          ),
        );
      }

      // External binding exports:
      // export {} from '';
      if (node.type === 'ExportExternalDeclaration') {
        const {source} = node;
        const specifiersKinds = [];
        const exportedNames = [];

        const {specifiers} = node;
        if (specifiers !== undefined) {
          for (const specifier of specifiers) {
            switch (specifier.type) {
              case 'ExportExternalSpecifier':
                {
                  const kind = ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getImportKind(
                    specifier.exportKind ||
                    node.exportKind,
                  );
                  specifiersKinds.push(kind);

                  exportedNames.push(
                    {
                      name: specifier.local.name,
                      kind,
                      loc: specifier.loc,
                    },
                  );

                  context.record(
                    new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord(
                      {
                        type: 'external',
                        kind,
                        loc: specifier.loc,
                        imported: specifier.local.name,
                        exported: specifier.exported.name,
                        source: source.value,
                      },
                    ),
                  );
                  break;
                }

              case 'ExportNamespaceSpecifier':
                throw new Error('unimplemented');

              case 'ExportDefaultSpecifier':
                throw new Error('unimplemented');
            }
          }

          context.record(
            new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportRecord(
              {
                type: 'es',
                async: false,
                kind: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getKindWithSpecifiers(node.exportKind, specifiersKinds),
                names: exportedNames,
                loc: source.loc,
                source: source.value,
                optional: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$isOptional(path),
                all: false,
              },
            ),
          );
        }
      }

      // TS: import A = require('B');
      if (node.type === 'TSImportEqualsDeclaration' &&
        node.moduleReference.type === 'TSExternalModuleReference') {
        context.record(
          new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportRecord(
            {
              type: 'cjs',
              kind: 'value',
              optional: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$isOptional(path),
              loc: node.loc,
              source: node.moduleReference.expression.value,
              names: [],
              all: true,
              async: false,
            },
          ),
        );
      }

      // export * from '';
      if (node.type === 'ExportAllDeclaration') {
        context.record(
          new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportRecord(
            {
              type: 'es',
              async: false,
              kind: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getExportKind(node.exportKind),
              optional: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$isOptional(path),
              loc: node.source.loc,
              names: [],
              source: node.source.value,
              all: true,
            },
          ),
        );

        context.record(
          new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord(
            {
              type: 'externalAll',
              loc: node.loc,
              kind: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getExportKind(node.exportKind),
              source: node.source.value,
            },
          ),
        );
      }

      if (node.type === 'ExportAllDeclaration' ||
      node.type ===
      'ExportDefaultDeclaration' ||
      node.type === 'ExportLocalDeclaration') {
        context.record(new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ESExportRecord(___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getExportKind(node.exportKind), node));
      }

      // import {} from '';

      // import * as foo from '';
      if (node.type === 'ImportDeclaration') {
        let hasNamespaceSpecifier = false;
        const specifierKinds = [];
        const names = [];

        const {specifiers} = node;
        if (specifiers !== undefined) {
          for (const specifier of specifiers) {
            if (specifier.type === 'ImportNamespaceSpecifier') {
              hasNamespaceSpecifier = true;
              break;
            }

            const kind = ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getImportKind(
              specifier.local.importKind || node.importKind,
            );
            specifierKinds.push(kind);

            if (specifier.type === 'ImportDefaultSpecifier') {
              names.push(
                {
                  kind,
                  loc: specifier.loc,
                  name: 'default',
                },
              );
            }

            if (specifier.type === 'ImportSpecifier') {
              names.push(
                {
                  kind,
                  loc: specifier.loc,
                  name: specifier.imported.name,
                },
              );
            }
          }
        }

        context.record(
          new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportRecord(
            {
              type: 'es',
              async: false,
              kind: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getKindWithSpecifiers(node.importKind, specifierKinds),
              loc: node.source.loc,
              optional: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$isOptional(path),
              source: node.source.value,
              all: hasNamespaceSpecifier,
              names,
            },
          ),
        );
      }

      // Detect top level await
      if (node.type === 'AwaitExpression' &&
        path.findAncestry(
          (
            path,
          ) =>
            ___R$project$rome$$romejs$js$ast$utils$isFunctionNode_ts$default(path.node),
        ) ===
        undefined) {
        const {loc} = node;
        if (loc === undefined) {
          throw new Error('loc is undefined on AwaitExpression we want to mark');
        }
        context.record(new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$TopLevelAwaitRecord(loc));
      }

      if (node.type === 'ReferenceIdentifier') {
        const binding = path.scope.getBinding(node.name);

        // Mark references to imports outside of functions
        if (binding !== undefined && binding instanceof ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ImportBinding) {
          const {meta} = binding;

          // We can skip this if it's referencing a namespace
          if (meta.type !== 'name') {
            return node;
          }

          // These are nodes that will defer the execution of code outside the init path

          // (They could still be triggered with an actual function call but this is just for some basic analysis)
          const deferredExecution = path.findAncestry(
            (
              path,
            ) =>
              ___R$project$rome$$romejs$js$ast$utils$isFunctionNode_ts$default(path.node) || path.node.type === 'ClassProperty',
          );
          const isTop = deferredExecution === undefined;

          let kind = ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getImportKind(meta.kind);
          if (___R$project$rome$$romejs$js$ast$utils$isInTypeAnnotation_ts$default(path)) {
            kind = 'type';
          }

          context.record(
            new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportUsageRecord(
              isTop,
              {
                kind,
                loc: node.loc,
                local: node.name,
                imported: meta.imported,
                source: meta.source,
              },
            ),
          );
        }
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/api/analyzeDependencies/visitors/cjs.ts
const ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$visitors$cjs_ts$default = {
    name: 'analyzeDependenciesCJS',
    enter(path) {
      const {node, parent, scope, context} = path;

      // Handle require()
      if (node.type === 'CallExpression') {
        const {callee, arguments: args} = node;

        const isRequire = callee.type === 'ReferenceIdentifier' &&
          callee.name === 'require' &&
          path.scope.hasBinding('require') === false;
        const sourceArg = args[0];

        if (isRequire && args.length === 1 && sourceArg.type === 'StringLiteral') {
          context.record(
            new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportRecord(
              {
                type: 'cjs',
                kind: 'value',
                optional: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$isOptional(path),
                loc: node.loc,
                source: sourceArg.value,
                names: [],
                all: true,
                async: false,
              },
            ),
          );
        }
      }

      // Detect assignments to exports and module.exports as definitely being an CJS module
      if (node.type === 'AssignmentExpression') {
        const isModuleExports = path.scope.getBinding('module') === undefined &&
          ___R$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(node.left, 'module.exports', true);
        const isExports = path.scope.getBinding('exports') === undefined &&
          ___R$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(node.left, 'exports', true);

        if (isModuleExports || isExports) {
          context.record(new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$CJSExportRecord(node));
        }

        if (isModuleExports) {
          const {right} = node;

          if (___R$project$rome$$romejs$js$ast$objects$ObjectExpression_ts$objectExpression.is(right)) {
            context.record(
              new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord(
                {
                  type: 'local',
                  loc: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(scope, node.right),
                  valueType: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(scope, node.right),
                  kind: 'value',
                  name: 'default',
                },
              ),
            );

            for (const prop of right.properties) {
              // Don't allow spread, unknown, or computed properties
              if (prop.type === 'SpreadProperty' ||
              prop.key.type ===
              'ComputedPropertyKey' &&
                prop.key.value.type !== 'StringLiteral') {
                context.record(new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$EscapedCJSRefRecord(prop));
                continue;
              }

              const key = prop.key.value;
              let name;
              if (key.type === 'Identifier') {
                name = key.name;
              } else if (key.type === 'StringLiteral') {
                name = key.value;
              } else {
                // Unknown key literal
                context.record(new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$EscapedCJSRefRecord(key));
                continue;
              }

              let target = prop.type === 'ObjectMethod' ? prop : prop.value;

              context.record(
                new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord(
                  {
                    type: 'local',
                    loc: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(scope, target),
                    valueType: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(scope, target),
                    kind: 'value',
                    name,
                  },
                ),
              );
            }
          } else {
            const source = ___R$project$rome$$romejs$js$ast$utils$getRequireSource_ts$default(node.right, scope);
            if (source === undefined) {
              context.record(
                new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord(
                  {
                    type: 'local',
                    loc: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(scope, node.right),
                    valueType: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(scope, node.right),
                    kind: 'value',
                    name: 'default',
                  },
                ),
              );
            } else {
              context.record(
                new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord(
                  {
                    type: 'externalAll',
                    loc: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(scope, node.right),
                    kind: 'value',
                    source,
                  },
                ),
              );

              context.record(
                new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord(
                  {
                    type: 'external',
                    kind: 'value',
                    loc: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(scope, node.right),
                    imported: 'default',
                    exported: 'default',
                    source,
                  },
                ),
              );
            }
          }
        }

        if (isExports) {
          const [, parts] = ___R$project$rome$$romejs$js$ast$utils$getNodeReferenceParts_ts$default(node.left);

          // parts[0] is exports
          const name = parts[1];

          context.record(
            new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord(
              {
                type: 'local',
                loc: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(scope, node.right),
                valueType: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(scope, node.right),
                kind: 'value',
                name,
              },
            ),
          );
        }
      }

      if (node.type === 'ReferenceIdentifier') {
        const binding = path.scope.getBinding(node.name);

        // Detect references to exports and module
        if (binding === undefined) {
          if (node.name === '__filename' || node.name === '__dirname' ||
          node.name === 'require' ||
          node.name === 'module' ||
          node.name ===
          'exports') {
            context.record(new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$CJSVarRefRecord(node));
          }

          if (node.name === 'module' || node.name === 'exports') {
            const inMemberExpression = parent.type === 'MemberExpression' &&
              parent.object === node;
            if (!inMemberExpression) {
              context.record(new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$EscapedCJSRefRecord(node));
            }
          }
        }
      }

      return node;
    },
  };

  // project-rome/@romejs/js-compiler/api/analyzeDependencies/visitors/index.ts
const ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$visitors$index_ts$default = [___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$visitors$es_ts$default, ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$visitors$cjs_ts$default];

  // project-rome/@romejs/js-compiler/api/analyzeDependencies/index.ts
const ___R$$priv$project$rome$$romejs$js$compiler$api$analyzeDependencies$index_ts$analyzeCache = new ___R$project$rome$$romejs$js$compiler$lib$Cache_ts$default();

  async function ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$index_ts$default(
    req,
  ) {
    const {ast, project} = req;

    const query = ___R$project$rome$$romejs$js$compiler$lib$Cache_ts$default.buildQuery(req);
    const cached = ___R$$priv$project$rome$$romejs$js$compiler$api$analyzeDependencies$index_ts$analyzeCache.get(query);
    if (cached) {
      return cached;
    }

    const context = new ___R$project$rome$$romejs$js$compiler$lib$Context_ts$default(
      {
        ast,
        project,
        origin: {
          category: 'analyzeDependencies',
        },
      },
    );
    const {ast: transformedAst} = await ___R$project$rome$$romejs$js$compiler$methods$transform_ts$default(Object.assign(
      {
      },
      req,
      {
        stage: 'pre',
      },
    ));
    context.reduce(transformedAst, ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$visitors$index_ts$default);

    //
    const importFirstUsage = [];
    const seenImportFirstUsage = new Set();

    // Extract records
    const exports = [];
    const dependenciesBySource = new Map();

    const esValueExports = [];
    const cjsExports = [];
    let firstTopAwaitLocation;

    // TODO description
    let hasCJSRef = false;

    // Whether we have a default export, used to automatically add one for CJS
    let hasDefaultExport = false;

    // Find the import sources that are only used as a type
    const sourcesUsedAsType = new Set();
    const sourcesUsedAsValue = new Set();
    for (const record of context.records) {
      let data;

      if (record instanceof ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportUsageRecord) {
        data = record.data;
      }

      // This has to be a separate if or else TS wont refine it...
      if (record instanceof ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord && record.data.type !== 'local') {
        data = record.data;
      }

      if (data !== undefined) {
        const {kind, source} = data;
        if (kind === 'type') {
          sourcesUsedAsType.add(source);
        } else {
          sourcesUsedAsValue.add(source);
        }
      }
    }
    for (const source of sourcesUsedAsValue) {
      sourcesUsedAsType.delete(source);
    }

    // Process rest of the records
    for (const record of context.records) {
      if (record instanceof ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$EscapedCJSRefRecord) {
        exports.push(
          {
            type: 'local',
            loc: record.node.loc,
            kind: 'value',
            valueType: 'other',
            name: '*',
          },
        );
      }

      if (record instanceof ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportRecord) {
        let {data} = record;

        // If this source was only ever used as a type then convert us to a value
        if (data.type === 'es' && data.kind === 'value' &&
          sourcesUsedAsType.has(
            data.source,
          )) {
          const names = [];

          for (const name of data.names) {
            names.push(
              Object.assign(
                {
                },
                name,
                {
                  kind: 'type',
                },
              ),
            );
          }

          data = Object.assign(
            {
            },
            data,
            {
              kind: 'type',
              names,
            },
          );
        }

        // If we have multiple import records for this file, then merge them together
        const existing = dependenciesBySource.get(data.source);
        if (existing === undefined) {
          dependenciesBySource.set(data.source, data);
        } else {
          let kind;
          if (data.kind === existing.kind) {
            kind = data.kind;
          } else {
            kind = 'value';
          }

          const combinedRecord = {
            type: data.type === 'es' && existing.type === 'es' ? 'es' : 'cjs',
            kind,
            optional: existing.optional && data.optional,
            async: existing.async || data.async,
            source: data.source,
            all: existing.all || data.all,
            names: [...existing.names, ...data.names],
            loc: existing.loc || data.loc,
          };

          // Map ordering is by insertion time, so in the case where the previous import was a type import

          // then we don't want to place our combined record in that position, it should be at the end.

          // Inserting a type import statement at the top of the file shouldn't change the execution order

          // if it was imported later
          if (existing.kind === 'type' && data.kind === 'value') {
            dependenciesBySource.delete(data.source);
          }

          dependenciesBySource.set(data.source, combinedRecord);
        }
      } else if (record instanceof ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord) {
        exports.push(record.data);
      } else if (record instanceof ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$CJSVarRefRecord) {
        hasCJSRef = true;
      } else if (record instanceof ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$CJSExportRecord) {
        cjsExports.push(record.node);
      } else if (record instanceof ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ESExportRecord) {
        // No point checking for ES imported in CJS because it would have been a syntax error
        if (record.kind === 'value') {
          esValueExports.push(record.node);
        }
      } else if (record instanceof ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$TopLevelAwaitRecord) {
        if (firstTopAwaitLocation === undefined) {
          firstTopAwaitLocation = record.loc;
        }
      } else if (record instanceof ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportUsageRecord && record.isTop &&
        record.data.kind === 'value') {
        // Track the first reference to a value import that's not in a function

        // This is used to detect module cycles
        const {data} = record;
        const key = data.source +
        ':' +
        data.imported;
        if (seenImportFirstUsage.has(key)) {
          continue;
        }

        seenImportFirstUsage.add(key);
        importFirstUsage.push(data);
      }
    }

    // Build dependencies
    const dependencies = Array.from(
      dependenciesBySource.values(),
    );

    // Infer the module type
    let moduleType = ast.sourceType === 'script' ? 'cjs' : 'es';

    // Infer module type in legacy mode
    if (project.config.bundler.mode === 'legacy') {
      if (cjsExports.length > 0) {
        moduleType = 'cjs';
      } else if (esValueExports.length > 0) {
        moduleType = 'es';
      } else if (hasCJSRef) {
        moduleType = 'cjs';
      } else {
        moduleType = 'unknown';
      }
    }

    //
    for (const record of context.records) {
      if (record instanceof ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$CJSVarRefRecord) {
        if (project.config.bundler.mode === 'modern' && moduleType === 'es') {
          /*context.addNodeDiagnostic(record.node, {
          category: 'analyzeDependencies',
          message: `CommonJS variable <emphasis>${
            record.node.name
          }</emphasis> is not available in an ES module`,
        });*/}
      } else if (record instanceof ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$CJSExportRecord) {
        if (moduleType === 'es') {
          context.addNodeDiagnostic(
            record.node,
            {
              category: 'analyzeDependencies/cjsExportInES',
              message: 'You cannot use CommonJS exports in an ES module',
            },
          );
        }
      }
    }

    // Add an implicit default import for CJS if there is none
    if (moduleType === 'cjs' && !hasDefaultExport) {
      exports.push(
        {
          type: 'local',
          loc: undefined,
          kind: 'value',
          valueType: 'other',
          name: 'default',
        },
      );
    }

    const res = {
      moduleType,
      firstTopAwaitLocation,
      exports,
      dependencies,
      importFirstUsage,
      syntax: ast.syntax,
      diagnostics: [...ast.diagnostics, ...context.diagnostics],
    };
    ___R$$priv$project$rome$$romejs$js$compiler$api$analyzeDependencies$index_ts$analyzeCache.set(query, res);
    return res;
  }

  function ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$index_ts$mergeAnalyzeDependencies(
    main,
    second,
  ) {
    const exports = [...main.exports];

    // Take only local type exports
    for (const exp of second.exports) {
      if (exp.type === 'local' && exp.kind === 'type') {
        exports.push(exp);
      }

      // Ensure that all external exports are only reachable with `type`
      if (exp.type === 'external' || exp.type === 'externalAll') {
        exports.push(
          Object.assign(
            {
            },
            exp,
            {
              kind: 'type',
            },
          ),
        );
      }
    }

    return (
      Object.assign(
        {
        },
        main,
        {
          exports,
          diagnostics: [...main.diagnostics, ...second.diagnostics],
        },
      )
    );
  }

  // project-rome/@romejs/js-compiler/api/createHook.ts
function ___R$project$rome$$romejs$js$compiler$api$createHook_ts$default(
    descriptor,
  ) {
    return descriptor;
  }

  // project-rome/@romejs/js-compiler/types.ts
const ___R$project$rome$$romejs$js$compiler$types_ts = {
  };

  // project-rome/@romejs/js-compiler/index.ts
const ___R$project$rome$$romejs$js$compiler$index_ts = {
    get Context() {
      return (
        ___R$project$rome$$romejs$js$compiler$lib$Context_ts$default
      );
    },

    get PathOptions() {
      return (
        ___R$project$rome$$romejs$js$compiler$lib$Path_ts$PathOptions
      );
    },

    get Path() {
      return (
        ___R$project$rome$$romejs$js$compiler$lib$Path_ts$default
      );
    },

    get Record() {
      return (
        ___R$project$rome$$romejs$js$compiler$lib$Record_ts$default
      );
    },

    get Cache() {
      return (
        ___R$project$rome$$romejs$js$compiler$lib$Cache_ts$default
      );
    },

    get lint() {
      return (
        ___R$project$rome$$romejs$js$compiler$api$lint_ts$default
      );
    },

    get compile() {
      return (
        ___R$project$rome$$romejs$js$compiler$api$compile_ts$default
      );
    },

    get analyzeDependencies() {
      return (
        ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$index_ts$default
      );
    },

    get mergeAnalyzeDependencies() {
      return (
        ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$index_ts$mergeAnalyzeDependencies
      );
    },

    get Scope() {
      return (
        ___R$project$rome$$romejs$js$compiler$scope$Scope_ts$default
      );
    },

    get getPrefixedBundleNamespace() {
      return (
        ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace
      );
    },

    get createHook() {
      return (
        ___R$project$rome$$romejs$js$compiler$api$createHook_ts$default
      );
    },

    get extractSuppressionsFromProgram() {
      return (
        ___R$project$rome$$romejs$js$compiler$suppressions_ts$extractSuppressionsFromProgram
      );
    },

    get LintResult() {
      return (
        ___R$project$rome$$romejs$js$compiler$api$lint_ts$LintResult
      );
    },

    get CompileResult() {
      return (
        ___R$project$rome$$romejs$js$compiler$api$compile_ts$CompileResult
      );
    },

    get HookDescriptor() {
      return (
        ___R$project$rome$$romejs$js$compiler$api$createHook_ts$HookDescriptor
      );
    },
  };
  Object.keys(
    ___R$project$rome$$romejs$js$compiler$scope$bindings_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$compiler$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$compiler$scope$bindings_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$compiler$constants_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$compiler$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$compiler$constants_ts[key]
            );
          },
        },
      );
    },
  );
  Object.keys(
    ___R$project$rome$$romejs$js$compiler$types_ts,
  ).forEach(
    function(
      key,
    ) {
      if (key ===
      'default') return (
        undefined
      );
      Object.defineProperty(
        ___R$project$rome$$romejs$js$compiler$index_ts,
        key,
        {
          enumerable: true,
          configurable: true,
          get: function get() {
            return (
              ___R$project$rome$$romejs$js$compiler$types_ts[key]
            );
          },
        },
      );
    },
  );

  // project-rome/@romejs/project/types.ts
const ___R$project$rome$$romejs$project$types_ts = {
    get DEFAULT_PROJECT_CONFIG_META() {
      return (
        ___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG_META
      );
    },

    get DEFAULT_PROJECT_CONFIG() {
      return (
        ___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG
      );
    },
  };

  const ___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG_META = {
    projectFolder: undefined,
    configPath: undefined,
    configHashes: [],
    configDependencies: new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet(),
    consumer: undefined,
    configSourceSubKey: undefined,
    consumersChain: [],
  };

  const ___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG = {
    name: 'unknown',
    root: false,
    version: undefined,

    cache: {},

    develop: {
      serveStatic: true,
    },

    bundler: {
      mode: 'modern',
    },

    compiler: {},

    resolver: {},

    typeCheck: {
      enabled: false,
      // Maybe this needs to be cloned...?
      libs: new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet(),
    },

    dependencies: {
      enabled: false,
    },

    format: {
      enabled: false,
      ignore: [],
    },

    haste: {
      enabled: false,
      ignore: [],
    },

    lint: {
      enabled: false,
      ignore: [],
      globals: [],
    },

    tests: {
      enabled: false,
      ignore: [],
    },

    vsc: {
      root: ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath('/'),
    },

    files: {
      vendorPath: ___R$project$rome$$romejs$path$index_ts$TEMP_PATH.append('rome-remote'),
      assetExtensions: [],
      watchman: false,
      maxSize: 40000000, // 40 megabytes
    },

    targets: new Map(),
  };

  // project-rome/@romejs/path-match/parse.ts
const ___R$$priv$project$rome$$romejs$path$match$parse_ts$createPathMatchParser = ___R$project$rome$$romejs$parser$core$index_ts$createParser(
    (
      ParserCore,
    ) =>
      (() => {
        class PathMatchParser extends ParserCore {
          constructor(opts, mode) {
            super(opts, 'parse/patchMatch');
            this.mode = mode;
          }

          isWordCharacter(char, index, input) {
            const prevChar = input[___R$project$rome$$romejs$ob1$index_ts$get0(index) - 1];
            const nextChar = input[___R$project$rome$$romejs$ob1$index_ts$get0(index) + 1];

            // Windows separator
            if (char === '\\' && nextChar === '\\') {
              return false;
            }

            // Any escaped character is a word character
            if (prevChar === '\\') {
              return true;
            }

            // Unix separator and wildcard
            if (char === '/') {
              return false;
            }

            if (this.mode === 'pattern') {
              // Wildcard
              if (char === '*') {
                return false;
              }

              // Comment
              if (char === '#') {
                return false;
              }
            }

            return true;
          }

          tokenize(index, input) {
            const char = input[___R$project$rome$$romejs$ob1$index_ts$get0(index)];
            const nextChar = input[___R$project$rome$$romejs$ob1$index_ts$get0(index) + 1];

            if (this.mode === 'pattern') {
              if (char === '*') {
                if (nextChar === '*') {
                  return this.finishToken('DoubleStar', ___R$project$rome$$romejs$ob1$index_ts$add(index, 2));
                } else {
                  return this.finishToken('Star');
                }
              } else if (index === ___R$project$rome$$romejs$ob1$index_ts$number0 && char === '!') {
                return this.finishToken('Exclamation');
              } else if (char === '#') {
                return this.finishToken('Hash');
              }
            }

            if (char === '/') {
              return this.finishToken('Separator');
            } else if (char === '\\' && nextChar === '\\') {
              return this.finishToken('Separator', ___R$project$rome$$romejs$ob1$index_ts$add(index, 2));
            }

            const [value, end] = this.readInputFrom(
              index,
              this.isWordCharacter.bind(
                this,
              ),
            );
            return this.finishValueToken('Word', value, end);
          }

          eatSeparators() {
            let ate = false;
            while (this.eatToken('Separator') !== undefined) {
              ate = true;
            }
            return ate;
          }

          //# Pattern parsing
          parsePatternSegmentPart() {
            const startPos = this.getPosition();
            const token = this.getToken();
            this.nextToken();

            switch (token.type) {
              case 'Star':
                return (
                  {
                    type: 'Wildcard',
                    loc: this.finishLoc(startPos),
                  }
                );

              case 'Word':
                return (
                  {
                    type: 'Word',
                    loc: this.finishLoc(startPos),
                    value: token.value,
                  }
                );

              default:
                throw (
                  this.unexpected(
                    {
                      start: startPos,
                      message: 'Invalid pattern segment part',
                    },
                  )
                );
            }
          }

          parseSegment() {
            const startPos = this.getPosition();
            const parts = [];

            // A ** token is only allowed as the only part of a segment
            if (this.matchToken('DoubleStar')) {
              const lookahead = this.lookaheadToken();
              if (lookahead.type === 'Separator' || lookahead.type === 'EOF') {
                this.eatToken('DoubleStar');
                this.eatSeparators();
                return (
                  {
                    type: 'WildcardSegment',
                    loc: this.finishLoc(startPos),
                  }
                );
              }
            }

            // Keep consuming tokens until we hit a separator or a comment
            while (!this.matchToken('Hash') && !this.matchToken('EOF') &&
              !this.eatSeparators()) {
              parts.push(this.parsePatternSegmentPart());
            }

            return (
              {
                loc: this.finishLoc(startPos),
                type: 'Segment',
                parts,
              }
            );
          }

          isWildcardOnlySegment(segment) {
            if (segment === undefined) {
              return false;
            }

            if (segment.type === 'WildcardSegment') {
              return true;
            }

            if (segment.parts.length === 1 && segment.parts[0].type === 'Wildcard') {
              return true;
            }

            return false;
          }

          // Normalize all path segments, removing empty segments and wildcards from the start and end

          // These could also be parse errors but let's allow them
          normalizePatternSegments(segments) {
            const normalized = [];

            // Never normalize it if there's a single segment. This is to support writing a pattern that's just "*"
            if (segments.length === 1) {
              return segments;
            }

            for (const seg of segments) {
              // Remove all wildcard-only segments from 'beginning
              if (normalized.length === 0 && this.isWildcardOnlySegment(seg)) {
                continue;
              }

              // Remove all empty segments
              if (seg.type === 'Segment' && seg.parts.length === 0) {
                continue;
              }

              normalized.push(seg);
            }

            // TODO Remove duplicate wildcard segments

            // - Multiple WildcardSegment

            // - Wildcard next to a WildcardSegment

            // Remove all wildcard-only segments from end
            while (this.isWildcardOnlySegment(normalized[normalized.length - 1])) {
              normalized.pop();
            }

            return normalized;
          }

          parsePattern() {
            const startPos = this.getPosition();
            const segments = [];
            const negate = this.eatToken('Exclamation') !== undefined;

            // Keep parsing segments until we hit the end of the input or a comment
            while (!this.matchToken('Hash') && !this.matchToken('EOF')) {
              segments.push(this.parseSegment());
            }

            // Get a trailing comment
            let comment = '';
            if (this.eatToken('Hash')) {
              comment =
                this.getRawInput(
                  this.getToken().start,
                  ___R$project$rome$$romejs$ob1$index_ts$coerce0(
                    this.input.length,
                  ),
                );
            }

            let root = false;
            if (segments.length > 0) {
              const firstSeg = segments[0];
              root = firstSeg.type === 'Segment' && firstSeg.parts.length === 0;
            }

            return (
              {
                type: 'PathPattern',
                loc: this.finishLoc(startPos),
                root,
                comment,
                negate,
                segments: this.normalizePatternSegments(segments),
              }
            );
          }

          //# Path parsing
          parsePath() {
            const segments = [];

            this.eatSeparators();

            while (!this.matchToken('EOF')) {
              segments.push(this.parsePathSegment());
            }

            return segments;
          }

          parsePathSegment() {
            let segment = '';

            while (!this.eatSeparators() && !this.matchToken('EOF')) {
              segment += this.normalizePathSegmentToken();
            }

            return segment;
          }

          normalizePathSegmentToken() {
            const token = this.getToken();
            this.nextToken();

            if (token.type === 'Word') {
              return token.value;
            } else {
              throw (
                this.unexpected(
                  {
                    message: 'Invalid path segment',
                  },
                )
              );
            }
          }
        }

        return (
          PathMatchParser
        );
      })(),
  );

  function ___R$project$rome$$romejs$path$match$parse_ts$parsePattern(opts) {
    const parser = ___R$$priv$project$rome$$romejs$path$match$parse_ts$createPathMatchParser(opts, 'pattern');
    return parser.parsePattern();
  }

  // project-rome/@romejs/path-match/match.ts
function ___R$$priv$project$rome$$romejs$path$match$match_ts$matchSegment(path, patternSeg) {
    if (patternSeg.type !== 'Segment') {
      throw new Error('Expected only plain segment');
    }

    const parts = [...patternSeg.parts];
    let buffer = path;

    function matchPart(part) {
      // If the buffer is empty then it's impossible for anything to match
      if (buffer.length === 0) {
        return false;
      }

      if (part.type === 'Word') {
        if (buffer.startsWith(part.value)) {
          buffer = buffer.slice(part.value.length);
        } else {
          return false;
        }
      } else if (part.type === 'Wildcard') {
        const nextPart = parts.shift();

        // If there's no other parts then a wildcard matches any buffer
        if (nextPart === undefined) {
          return buffer.length > 0;
        }

        // Keep removing characters until we match the next part
        while (buffer.length > 0) {
          if (matchPart(nextPart)) {
            return true;
          }

          buffer = buffer.slice(1);
        }

        // We consumed the whole buffer and nothing matched
        return false;
      }

      return true;
    }

    while (parts.length > 0) {
      const part = parts.shift();
      if (part === undefined) {
        throw new Error('parts.length checked above');
      }

      if (matchPart(part) === false) {
        return false;
      }
    }

    return true;
  }

  function ___R$project$rome$$romejs$path$match$match_ts$default(
    pathSegs,
    pattern,
    cwdSegs,
  ) {
    // Clone so we can freely mutate
    const patternSegs = [...pattern.segments];
    pathSegs = [...pathSegs];

    // Check if the pattern is empty
    if (patternSegs.length === 0 || pathSegs.length === 0) {
      return false;
    }

    // Quick optimization, check if the path contains all of the absolute names in the pattern
    for (const seg of patternSegs) {
      if (seg.type !== 'Segment' || seg.parts.length !== 1) {
        continue;
      }

      const part = seg.parts[0];
      if (part.type === 'Word' && !pathSegs.includes(part.value)) {
        return false;
      }
    }

    if (pattern.root && cwdSegs !== undefined) {
      cwdSegs = [...cwdSegs];

      // If this is a root pattern, then remove all the starting path segments that match the cwd
      for (const cwdSeg of cwdSegs) {
        const pathSeg = pathSegs.shift();
        if (cwdSeg === pathSeg) {
          continue;
        } else {
          return false;
        }
      }
    } else {
      // Start removing all the path segments until we find one that matches the first pattern segment
      const firstPatternSeg = patternSegs.shift();
      if (firstPatternSeg === undefined) {
        throw new Error('patternSegs.length already validated above');
      }

      while (pathSegs.length > 0) {
        const pathSeg = pathSegs.shift();
        if (pathSeg === undefined) {
          throw new Error('pathSegs.length already validated above');
        }

        if (___R$$priv$project$rome$$romejs$path$match$match_ts$matchSegment(pathSeg, firstPatternSeg)) {
          if (pathSegs.length === 0 && patternSegs.length === 0) {
            // If there's no more path or pattern segments then this was a successfully match!
            return true;
          } else {
            // Make sure the rest match
            break;
          }
        }
      }
    }

    // If we consumed all the path segments then we didn't match anything
    if (pathSegs.length === 0) {
      return false;
    }

    // Match the rest of the path segments
    for (let i = 0;
    i < patternSegs.length;
    i++) {
      const patternSeg = patternSegs[i];

      // If we have no more path segments then it's impossible for this to match
      if (pathSegs.length === 0) {
        return false;
      }

      // When given a wildcard segment, keep popping off all the path segments until we find one that matches the next pattern segment
      if (patternSeg.type === 'WildcardSegment') {
        const nextPattern = patternSegs[i + 1];
        while (!___R$$priv$project$rome$$romejs$path$match$match_ts$matchSegment(pathSegs[0], nextPattern)) {
          pathSegs.shift();
        }
        continue;
      }

      // Basic match
      const pathSeg = pathSegs.shift();
      if (pathSeg === undefined) {
        throw new Error('pathSegs.length already validated above');
      }
      if (___R$$priv$project$rome$$romejs$path$match$match_ts$matchSegment(pathSeg, patternSeg)) {
        continue;
      } else {
        return false;
      }
    }

    return true;
  }

  // project-rome/@romejs/path-match/stringify.ts
function ___R$project$rome$$romejs$path$match$stringify_ts$stringifyPathPattern(
    node,
  ) {
    switch (node.type) {
      case 'PathPattern':
        return (
          node.segments.map((segment) => ___R$project$rome$$romejs$path$match$stringify_ts$stringifyPathPattern(segment)).join(
            '/',
          )
        );

      case 'Segment':
        return node.parts.map((part) => ___R$project$rome$$romejs$path$match$stringify_ts$stringifyPathPattern(part)).join('');

      case 'WildcardSegment':
        return '**';

      case 'Wildcard':
        return '*';

      case 'Word':
        return node.value;
    }
  }

  // project-rome/@romejs/path-match/index.ts
function ___R$project$rome$$romejs$path$match$index_ts$flipPathPatterns(patterns) {
    return (
      patterns.map(
        (pattern) => {
          return (
            Object.assign(
              {
              },
              pattern,
              {
                negate: !pattern.negate,
              },
            )
          );
        },
      )
    );
  }

  function ___R$project$rome$$romejs$path$match$index_ts$matchPath(
    path,
    patternNode,
    cwdSegs,
  ) {
    const matches = ___R$project$rome$$romejs$path$match$match_ts$default(path.getSegments(), patternNode, cwdSegs);

    if (patternNode.negate) {
      return !matches;
    } else {
      return matches;
    }
  }

  function ___R$$priv$project$rome$$romejs$path$match$index_ts$getGreater(pattern, num) {
    if (pattern.segments.length > num) {
      return pattern.segments.length;
    } else {
      return num;
    }
  }

  function ___R$project$rome$$romejs$path$match$index_ts$matchPathPatterns(
    path,
    patterns,
    cwd,
  ) {
    // Bail out if there are no patterns
    if (patterns.length === 0) {
      return 'NO_MATCH';
    }

    let matches = 0;
    let notMatches = 0;

    let hasNegate = false;

    const pathSegments = path.getSegments();
    const cwdSegs = cwd === undefined ? undefined : cwd.getSegments();

    for (const pattern of patterns) {
      // No point in matching an empty pattern, could just contain a comment
      if (pattern.segments.length === 0) {
        continue;
      }

      if (pattern.negate) {
        hasNegate = true;
        if (___R$project$rome$$romejs$path$match$match_ts$default(pathSegments, Object.assign(
          {
          },
          pattern,
          {
            negate: false,
          },
        ), cwdSegs)) {
          notMatches = ___R$$priv$project$rome$$romejs$path$match$index_ts$getGreater(pattern, notMatches);
        }
      } else {
        if (___R$project$rome$$romejs$path$match$match_ts$default(pathSegments, pattern, cwdSegs)) {
          matches = ___R$$priv$project$rome$$romejs$path$match$index_ts$getGreater(pattern, matches);
        }
      }
    }

    // If we have a negate pattern, then we need to match more segments than it in order to qualify as a match
    if (hasNegate) {
      if (notMatches > matches) {
        return 'NO_MATCH';
      } else if (matches > notMatches) {
        return 'EXPLICIT_MATCH';
      } else {
        return 'IMPLICIT_MATCH';
      }
    }

    if (matches > 0) {
      return 'EXPLICIT_MATCH';
    }

    return 'NO_MATCH';
  }

  // project-rome/@romejs/project/constants.ts
const ___R$project$rome$$romejs$project$constants_ts = {
    get ROME_CONFIG_PACKAGE_JSON_FIELD() {
      return (
        ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_PACKAGE_JSON_FIELD
      );
    },

    get ROME_CONFIG_FOLDER() {
      return (
        ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_FOLDER
      );
    },

    get ROME_CONFIG_FILENAMES() {
      return (
        ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_FILENAMES
      );
    },

    get ROME_CONFIG_WARN_FILENAMES() {
      return (
        ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_WARN_FILENAMES
      );
    },
  };
  const ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_PACKAGE_JSON_FIELD = 'rome';

  const ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_FOLDER = '.config';

  const ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_FILENAMES = ['rome.json', 'rome.rjson'];

  const ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_WARN_FILENAMES = [
    'romeconfig',
    'romerc',
    'rome.son',
    'rome.config.ts',
    'rome.config.js',
    'rome.config.json',
    'rome.config.rjson',
    'rome.config.son',
  ];

  // Add dot versions
  for (const basename of ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_WARN_FILENAMES) {
    if (basename[0] !== '.') {
      ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_WARN_FILENAMES.push('.' +
      basename);
    }
  }
  for (const filename of ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_FILENAMES.slice()) {
    ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_FILENAMES.push('.' +
    filename);
  }

  // project-rome/@romejs/project/utils.ts
const ___R$project$rome$$romejs$project$utils_ts = {
    assertHardMeta: ___R$project$rome$$romejs$project$utils_ts$assertHardMeta,
    arrayOfStrings: ___R$project$rome$$romejs$project$utils_ts$arrayOfStrings,
    arrayOfPatterns: ___R$project$rome$$romejs$project$utils_ts$arrayOfPatterns,
    mergeArrays: ___R$project$rome$$romejs$project$utils_ts$mergeArrays,
    mergeAbsoluteFilePathSets: ___R$project$rome$$romejs$project$utils_ts$mergeAbsoluteFilePathSets,
    getParentConfigDependencies: ___R$project$rome$$romejs$project$utils_ts$getParentConfigDependencies,
  };
  function ___R$project$rome$$romejs$project$utils_ts$assertHardMeta(meta) {
    const {configPath, projectFolder: folder, consumer} = meta;
    if (configPath === undefined || folder === undefined || consumer === undefined) {
      throw new Error('This is not a disk project');
    }

    return (
      Object.assign(
        {
        },
        meta,
        {
          configPath,
          consumer,
          projectFolder: folder,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$project$utils_ts$arrayOfStrings(consumer) {
    if (consumer.exists()) {
      return consumer.asArray().map((item) => item.asString());
    } else {
      return [];
    }
  }

  function ___R$project$rome$$romejs$project$utils_ts$arrayOfPatterns(consumer) {
    // TODO consumer.handleThrownDiagnostics
    return (
      consumer.asArray().map(
        (item) => {
          return (
            ___R$project$rome$$romejs$path$match$parse_ts$parsePattern(
              {
                path: consumer.filename,
                input: item.asString(),
                offsetPosition: item.getLocation('inner-value').start,
              },
            )
          );
        },
      )
    );
  }

  function ___R$project$rome$$romejs$project$utils_ts$mergeArrays(
    a,
    b,
  ) {
    if (a === undefined) {
      return a;
    }

    if (b === undefined) {
      return a;
    }

    return [...a, ...b];
  }

  function ___R$project$rome$$romejs$project$utils_ts$mergeAbsoluteFilePathSets(
    a,
    b,
  ) {
    if (a === undefined) {
      return a;
    }

    if (b === undefined) {
      return a;
    }

    return new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet([...a, ...b]);
  }

  function ___R$project$rome$$romejs$project$utils_ts$getParentConfigDependencies(
    path,
  ) {
    const deps = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet();

    for (const folder of path.getChain()) {
      deps.add(folder.append('package.json'));

      for (const configFilename of ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_FILENAMES) {
        deps.add(folder.append(configFilename));
        deps.add(folder.append(___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_FOLDER).append(configFilename));
      }
    }

    return deps;
  }

  // project-rome/@romejs/codec-semver/parse.ts
const ___R$$priv$project$rome$$romejs$codec$semver$parse_ts$createSemverParser = ___R$project$rome$$romejs$parser$core$index_ts$createParser(
    (
      ParserCore,
    ) =>
      (() => {
        class SemverParser extends ParserCore {
          constructor({loose, ...opts}, mode) {
            super(opts, 'parse/semver');
            this.input = this.input.trimRight();
            this.mode = mode;
            this.loose = loose === undefined ? false : loose;
          }

          // For some reason Flow will throw an error without the type casts...
          tokenize(index, input) {
            const char = input[___R$project$rome$$romejs$ob1$index_ts$get0(index)];
            const nextChar = input[___R$project$rome$$romejs$ob1$index_ts$get0(index) + 1];

            if (char === '<' && nextChar === '=' || char === '>' && nextChar === '=' ||
            char === '~' && nextChar === '>') {
              // @ts-ignore: TS doesn't infer the possible combinations
              const value = char + nextChar;
              return this.finishValueToken('Operator', value, ___R$project$rome$$romejs$ob1$index_ts$add(index, 2));
            }

            if (char === '^' || char === '<' || char === '>' || char === '~' ||
            char === '=') {
              const op = char;
              return this.finishValueToken('Operator', op);
            }

            if (char === '|' && nextChar === '|') {
              return this.finishToken('Pipe', ___R$project$rome$$romejs$ob1$index_ts$add(index, 2));
            }

            if (char === '*') {
              return this.finishToken('Star');
            }

            if (input[___R$project$rome$$romejs$ob1$index_ts$get0(index) - 1] === ' ' && char === '-' && nextChar === ' ') {
              return this.finishToken('RangeDash');
            }

            if (char === '-') {
              return this.finishToken('Dash');
            }

            if (char === '+') {
              return this.finishToken('Plus');
            }

            if (char === '.') {
              return this.finishToken('Dot');
            }

            if (___R$project$rome$$romejs$parser$core$index_ts$isDigit(char)) {
              const [value] = this.readInputFrom(index, ___R$project$rome$$romejs$parser$core$index_ts$isDigit);
              return (
                this.finishValueToken(
                  'Number',
                  Number(value),
                  ___R$project$rome$$romejs$ob1$index_ts$add(
                    index,
                    value.length,
                  ),
                )
              );
            }

            if (___R$project$rome$$romejs$parser$core$index_ts$isAlpha(char)) {
              const [value] = this.readInputFrom(index, ___R$project$rome$$romejs$parser$core$index_ts$isAlpha);
              return this.finishValueToken('Word', value, ___R$project$rome$$romejs$ob1$index_ts$add(index, value.length));
            }

            if (char === ' ' || char === '\t') {
              return this.finishToken('Space');
            }

            // Unknown character
            return undefined;
          }

          // Remove all subsequent space tokens
          eatSpaceToken() {
            while (this.eatToken('Space') !== undefined);
          }

          parseVersionOrWildcard() {
            const startPos = this.getPosition();
            const startToken = this.getToken();
            const version = this.parseVersion();

            // We should return a bare wildcard when parsed in a version position if there was nothing else attached
            if (this.isWildcardToken(startToken) && version.minor === undefined &&
              version.patch === undefined &&
              version.prerelease.length === 0 &&
              version.build.length === 0) {
              return (
                {
                  type: 'Wildcard',
                  loc: this.finishLoc(startPos),
                }
              );
            }

            return version;
          }

          parseVersion() {
            const startPos = this.getPosition();
            const startToken = this.getToken();

            if (this.isVersionCharacter(startToken)) {
              this.nextToken();
            }

            const major = this.parseVersionNumber();
            let minor = undefined;
            let patch = undefined;

            if (this.eatToken('Dot')) {
              minor = this.parseVersionNumber();
            } else if (this.mode === 'version') {
              throw (
                this.unexpected(
                  {
                    message: 'A minor number is required for a version',
                  },
                )
              );
            }

            if (this.eatToken('Dot')) {
              patch = this.parseVersionNumber();
            } else if (this.mode === 'version') {
              throw (
                this.unexpected(
                  {
                    message: 'A patch number is required for a version',
                  },
                )
              );
            }

            if (this.matchToken('Dot')) {
              throw this.unexpected({message: 'Too many parts for version'});
            }

            // The dash is optional in loose mode. eg. 1.2.3pre
            let prerelease = [];
            if (this.eatToken('Dash') || this.loose && this.matchToken('Word')) {
              prerelease = this.parseVersionQualifierParts();
            }

            let build = [];
            if (this.eatToken('Plus')) {
              build = this.parseVersionQualifierParts();
            }

            if (major !== undefined && minor !== undefined && patch !== undefined) {
              return (
                {
                  type: 'AbsoluteVersion',
                  loc: this.finishLoc(startPos),
                  major,
                  minor,
                  patch,
                  prerelease,
                  build,
                }
              );
            } else {
              return (
                {
                  type: 'WildcardVersion',
                  loc: this.finishLoc(startPos),
                  major,
                  minor,
                  patch,
                  prerelease,
                  build,
                }
              );
            }
          }

          parseVersionQualifierParts() {
            const parts = [];
            do {
              parts.push(this.parseVersionQualifierPart());
            } while (this.eatToken('Dot') !== undefined);
            return parts;
          }

          parseVersionQualifierPart() {
            const parts = [];

            do {
              const token = this.getToken();

              if (token.type === 'Number' || token.type === 'Word') {
                this.nextToken();
                parts.push(token.value);
              } else if (token.type === 'Dash') {
                this.nextToken();
                parts.push('-');
              } else {
                throw this.unexpected({message: 'Invalid version qualifier part'});
              }
            } while (this.matchToken('Number') || this.matchToken('Word') ||
            this.matchToken('Dash'));

            if (parts.length === 1 && typeof parts[0] === 'number') {
              return parts[0];
            } else {
              return parts.join('');
            }
          }

          isWildcardToken(token) {
            if (token.type === 'Star') {
              return true;
            }

            if (token.type === 'Word') {
              return token.value === 'x' || token.value === 'X';
            }

            return false;
          }

          parseVersionNumber() {
            const token = this.getToken();

            if (token.type === 'Number') {
              this.nextToken();
              return token.value;
            }

            if (this.isWildcardToken(token)) {
              if (this.mode === 'version') {
                throw (
                  this.unexpected(
                    {
                      message: 'Wildcard aren\'t allowed in a hard version',
                    },
                  )
                );
              }

              this.nextToken();
            } else {
              throw (
                this.unexpected(
                  {
                    message: 'This isn\'t a valid version part, expected a number',
                  },
                )
              );
            }

            return undefined;
          }

          parseLogicalOr(left) {
            this.nextToken();
            this.eatSpaceToken();

            const right = this.parseExpression();
            return (
              {
                loc: this.finishLoc(this.getLoc(left).start),
                type: 'LogicalOr',
                left,
                right,
              }
            );
          }

          validateRangeSide(node) {
            // In loose mode, we allow ranges to be a bare wildcard instead of a version

            // eg. * - 1.2.3
            if (node.type === 'WildcardVersion' || node.type === 'AbsoluteVersion') {
              return node;
            }

            if (node.type === 'Wildcard' && this.loose) {
              return node;
            }

            throw (
              this.unexpected(
                {
                  message: 'A semver range can only be defined with versions',
                  start: this.getLoc(node).start,
                },
              )
            );
          }

          parseVersionRange(left) {
            this.nextToken();
            this.eatSpaceToken();

            const right = this.parseVersionOrWildcard();

            return (
              {
                type: 'VersionRange',
                loc: this.finishLoc(this.getLoc(left).start),
                left: this.validateRangeSide(left),
                right: this.validateRangeSide(right),
              }
            );
          }

          parseWildcard() {
            const startPos = this.getPosition();
            this.nextToken();
            return {type: 'Wildcard', loc: this.finishLoc(startPos)};
          }

          parseAtomOperator(token) {
            const startPos = this.getPosition();
            this.nextToken();
            this.eatSpaceToken();

            const version = this.parseVersionOrWildcard();

            return (
              {
                type: 'Comparator',
                loc: this.finishLoc(startPos),
                operator: token.value,
                version,
              }
            );
          }

          isVersionCharacter(token) {
            if (this.loose && token.type === 'Word') {
              return token.value === 'v';
            }

            return false;
          }

          parseAtomStartPipe() {
            if (this.loose) {
              // A bare pipe in an atom start position is treated the same as a wildcard...

              // Why...? Because node-semver allows it lol

              // > satisfies('1.2.3', '||') === true
              return this.parseWildcard();
            } else {
              throw (
                this.unexpected(
                  {
                    message: 'Bare pipes are only allowed in loose mode',
                  },
                )
              );
            }
          }

          parseAtomStartWord(token) {
            if (this.isWildcardToken(token)) {
              return this.parseWildcard();
            } else if (this.isVersionCharacter(token)) {
              return this.parseVersion();
            } else {
              throw (
                this.unexpected(
                  {
                    message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Unexpected word <emphasis>${token.value}</emphasis>`,
                  },
                )
              );
            }
          }

          parseAtom() {
            const token = this.getToken();

            switch (token.type) {
              case 'Number':
                return this.parseVersion();

              case 'Operator':
                return this.parseAtomOperator(token);

              case 'Star':
                return this.parseWildcard();

              case 'Pipe':
                return this.parseAtomStartPipe();

              case 'Word':
                return this.parseAtomStartWord(token);

              default:
                throw this.unexpected({message: 'Unknown start of atom'});
            }
          }

          parseLogicalAnd(left) {
            const right = this.parseExpression();

            return (
              {
                type: 'LogicalAnd',
                left,
                right,
                loc: {
                  filename: this.filename,
                  start: this.getLoc(left).start,
                  end: this.getLoc(right).end,
                },
              }
            );
          }

          parseExpression() {
            const left = this.parseAtom();
            this.eatSpaceToken();

            if (this.matchToken('RangeDash')) {
              return this.parseVersionRange(left);
            }

            if (this.matchToken('Pipe')) {
              return this.parseLogicalOr(left);
            }

            if (!this.matchToken('EOF')) {
              return this.parseLogicalAnd(left);
            }

            return left;
          }

          parseInitialRange() {
            // Allow spaces at the beginning, spaces at the end have been removed by the trimRight in the constructor
            this.eatSpaceToken();

            // Empty string is an implicit wildcard in loose mode
            if (this.matchToken('EOF') && this.loose) {
              return this.parseWildcard();
            }

            const expr = this.parseExpression();
            this.finalize();

            return expr;
          }

          parseInitialVersion() {
            const node = this.parseInitialRange();

            // Verify the return value in version mode
            if (node.type !== 'AbsoluteVersion') {
              throw (
                this.unexpected(
                  {
                    message: 'Unexpected value for version',
                    start: this.getLoc(node).start,
                  },
                )
              );
            }

            return node;
          }
        }

        return (
          SemverParser
        );
      })(),
  );

  function ___R$project$rome$$romejs$codec$semver$parse_ts$parseSemverRange(opts) {
    return ___R$$priv$project$rome$$romejs$codec$semver$parse_ts$createSemverParser(opts, 'range').parseInitialRange();
  }

  function ___R$project$rome$$romejs$codec$semver$parse_ts$parseSemverVersion(
    opts,
  ) {
    return ___R$$priv$project$rome$$romejs$codec$semver$parse_ts$createSemverParser(opts, 'version').parseInitialVersion();
  }

  // project-rome/@romejs/codec-semver/compare.ts
function ___R$$priv$project$rome$$romejs$codec$semver$compare_ts$compareIdentifiers(
    a,
    b,
  ) {
    // Equal
    if (b === undefined) {
      return 0;
    }

    if (typeof a === 'string' || typeof b === 'string') {
      // @ts-ignore: built-in def is not restrictive enough
      return String(a).localeCompare(String(b));
    }

    // Less than
    if (a < b) {
      return -1;
    }

    // Greater than
    if (a > b) {
      return 1;
    }

    // Equal
    return 0;
  }

  function ___R$$priv$project$rome$$romejs$codec$semver$compare_ts$compareMain(
    version,
    range,
  ) {
    return (
      ___R$$priv$project$rome$$romejs$codec$semver$compare_ts$compareIdentifiers(version.major, range.major) ||
      ___R$$priv$project$rome$$romejs$codec$semver$compare_ts$compareIdentifiers(
        version.minor,
        range.minor,
      ) ||
      ___R$$priv$project$rome$$romejs$codec$semver$compare_ts$compareIdentifiers(version.patch, range.patch)
    );
  }

  function ___R$$priv$project$rome$$romejs$codec$semver$compare_ts$comparePre(version, range) {
    // NOT having a prerelease is > having one
    if (version.prerelease.length > 0 && range.prerelease.length === 0) {
      return -1;
    } else if (version.prerelease.length === 0 && range.prerelease.length > 0) {
      return 1;
    } else if (version.prerelease.length === 0 && range.prerelease.length === 0) {
      return 0;
    }

    let i = 0;
    do {
      const a = version.prerelease[i];
      const b = range.prerelease[i];

      if (a === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a === undefined) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return ___R$$priv$project$rome$$romejs$codec$semver$compare_ts$compareIdentifiers(a, b);
      }
    } while (++i);

    throw new Error('Unreachable');
  }

  function ___R$project$rome$$romejs$codec$semver$compare_ts$default(
    version,
    range,
  ) {
    return ___R$$priv$project$rome$$romejs$codec$semver$compare_ts$compareMain(version, range) || ___R$$priv$project$rome$$romejs$codec$semver$compare_ts$comparePre(version, range);
  }

  // project-rome/@romejs/codec-semver/satisfies.ts
function ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$buildVersion(
    major,
    minor,
    patch,
  ) {
    return (
      {
        type: 'WildcardVersion',
        major,
        minor,
        patch,
        prerelease: [],
        build: [],
      }
    );
  }

  function ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$compareOp(
    op,
    version,
    range,
  ) {
    if (range.type === 'Wildcard') {
      return true;
    }

    switch (op) {
      case '=':
        return ___R$project$rome$$romejs$codec$semver$compare_ts$default(version, range) === 0;

      case '<':
        return ___R$project$rome$$romejs$codec$semver$compare_ts$default(version, range) < 0;

      case '>':
        return ___R$project$rome$$romejs$codec$semver$compare_ts$default(version, range) > 0;

      case '>=':
        return ___R$project$rome$$romejs$codec$semver$compare_ts$default(version, range) >= 0;

      case '<=':
        return ___R$project$rome$$romejs$codec$semver$compare_ts$default(version, range) <= 0;

      case '^':
        {
          // Make sure that the version isn't less than the range
          if (___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$compareOp('>=', version, range) === false) {
            return false;
          }

          // Deconstruct the range
          const {major, minor, patch} = range;

          if (major === 0) {
            if (minor === 0) {
              // ^0.0.3 := >=0.0.3 <0.0.4

              // @ts-ignore
              return ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$compareOp('<', version, ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$buildVersion(0, 0, patch + 1));
            } else {
              // ^0.2.3 := >=0.2.3 <0.3.0

              // @ts-ignore
              return ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$compareOp('<', version, ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$buildVersion(0, minor + 1, 0));
            }
          }

          // ^1.2.3 := >=1.2.3 <2.0.0

          // @ts-ignore
          return ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$compareOp('<', version, ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$buildVersion(major + 1, 0, 0));
        }

      case '~>':
      case '~':
        {
          // Make sure that the version isn't less than the range
          if (___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$compareOp('>=', version, range) === false) {
            return false;
          }

          // Deconstruct the range
          const {major, minor} = range;

          if (minor === undefined) {
            // ~1 := >=1.0.0 <(1+1).0.0 := >=1.0.0 <2.0.0 (Same as 1.x)

            // @ts-ignore
            return ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$compareOp('<', version, ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$buildVersion(major + 1, minor, 0));
          }

          // ~1.2.3 := >=1.2.3 <1.(2+1).0 := >=1.2.3 <1.3.0
          return ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$compareOp('<', version, ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$buildVersion(major, minor + 1, 0));
        }

      default:
        throw new Error('Unknown operator ' +
        op);
    }
  }

  function ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$inRange(
    version,
    left,
    right,
  ) {
    if (left.type === 'Wildcard' || right.type === 'Wildcard') {
      return true;
    }

    return ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$compareOp('>=', version, left) && ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$compareOp('<=', version, right);
  }

  function ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$collectVersions(range) {
    switch (range.type) {
      case 'AbsoluteVersion':
      case 'WildcardVersion':
        return [range];

      case 'Wildcard':
        return [];

      case 'Comparator':
        return ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$collectVersions(range.version);

      case 'LogicalAnd':
      case 'LogicalOr':
      case 'VersionRange':
        return [...___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$collectVersions(range.left), ...___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$collectVersions(range.right)];

      default:
        throw new Error('Unknown range type');
    }
  }

  function ___R$project$rome$$romejs$codec$semver$satisfies_ts$default(
    version,
    range,
  ) {
    const res = ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$satisfiesSub(version, range);
    if (res === false) {
      return false;
    }

    if (version.prerelease.length > 0) {
      // Find the set of versions that are allowed to have prereleases

      // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0

      // That should allow `1.2.3-pr.2` to pass.

      // However, `1.2.4-alpha.notready` should NOT be allowed,

      // even though it's within the range set by the comparators.
      const versions = ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$collectVersions(range);

      for (const comparator of versions) {
        if (comparator.prerelease.length > 0) {
          if (comparator.major === version.major &&
            comparator.minor ===
            version.minor &&
            comparator.patch === version.patch) {
            return true;
          }
        }
      }

      // Version has a -pre, but it's not one of the ones we like.
      return false;
    }

    return true;
  }

  function ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$satisfiesSub(version, range) {
    switch (range.type) {
      case 'AbsoluteVersion':
      case 'WildcardVersion':
        return ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$compareOp('=', version, range);

      case 'Wildcard':
        return true;

      case 'Comparator':
        return ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$compareOp(range.operator, version, range.version);

      case 'LogicalAnd':
        return (
          ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$satisfiesSub(version, range.left) &&
            ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$satisfiesSub(
              version,
              range.right,
            )
        );

      case 'LogicalOr':
        return (
          ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$satisfiesSub(version, range.left) ||
          ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$satisfiesSub(
            version,
            range.right,
          )
        );

      case 'VersionRange':
        return (
          ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$inRange(version, range.left, range.right) ||
          ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$inRange(
            version,
            range.right,
            range.left,
          )
        );
    }
  }

  // project-rome/@romejs/codec-semver/utils.ts
function ___R$project$rome$$romejs$codec$semver$utils_ts$normalizeUserVersion(
    ver,
    opts,
  ) {
    if (typeof ver === 'string') {
      return ___R$project$rome$$romejs$codec$semver$parse_ts$parseSemverVersion(Object.assign(
        {
        },
        opts,
        {
          input: ver,
        },
      ));
    } else if (ver.type === 'AbsoluteVersion') {
      return ver;
    } else {
      throw new Error('Not a valid version: ' +
      ver.type);
    }
  }

  function ___R$project$rome$$romejs$codec$semver$utils_ts$normalizeUserRange(
    range,
    opts,
  ) {
    if (typeof range === 'string') {
      return ___R$project$rome$$romejs$codec$semver$parse_ts$parseSemverRange(Object.assign(
        {
        },
        opts,
        {
          input: range,
        },
      ));
    } else {
      return range;
    }
  }

  // project-rome/@romejs/codec-semver/stringify.ts
// Remove all
  function ___R$$priv$project$rome$$romejs$codec$semver$stringify_ts$compactRight(
    parts,
  ) {
    for (let i = parts.length - 1;
    i >= 0;
    i--) {
      const part = parts[i];
      if (part !== undefined) {
        return parts.slice(0, i + 1);
      }
    }

    return [];
  }

  const ___R$$priv$project$rome$$romejs$codec$semver$stringify_ts$WILDCARD = '*';

  function ___R$project$rome$$romejs$codec$semver$stringify_ts$default(node) {
    switch (node.type) {
      case 'WildcardVersion':
      case 'AbsoluteVersion':
        {
          // Build up x.x.x format
          let str = ___R$$priv$project$rome$$romejs$codec$semver$stringify_ts$compactRight([node.major, node.minor, node.patch]).map(
            (part) => part === undefined ? ___R$$priv$project$rome$$romejs$codec$semver$stringify_ts$WILDCARD : part,
          ).join(
            '.',
          );

          // add on qualifiers
          if (node.prerelease.length > 0) {
            str += '-' +
            node.prerelease.join('.');
          }
          if (node.build.length > 0) {
            str += '+' +
            node.build.join('.');
          }
          return str;
        }

      case 'Wildcard':
        return ___R$$priv$project$rome$$romejs$codec$semver$stringify_ts$WILDCARD;

      case 'Comparator':
        return '' +
        node.operator +
        ___R$project$rome$$romejs$codec$semver$stringify_ts$default(node.version);

      case 'LogicalAnd':
        return ___R$project$rome$$romejs$codec$semver$stringify_ts$default(node.left) +
        ' ' +
        ___R$project$rome$$romejs$codec$semver$stringify_ts$default(node.right);

      case 'LogicalOr':
        return ___R$project$rome$$romejs$codec$semver$stringify_ts$default(node.left) +
        ' || ' +
        ___R$project$rome$$romejs$codec$semver$stringify_ts$default(node.right);

      case 'VersionRange':
        return ___R$project$rome$$romejs$codec$semver$stringify_ts$default(node.left) +
        ' - ' +
        ___R$project$rome$$romejs$codec$semver$stringify_ts$default(node.right);
    }
  }

  // project-rome/@romejs/codec-semver/index.ts
function ___R$project$rome$$romejs$codec$semver$index_ts$sortSemverVersions(
    rawVersions,
    opts,
  ) {
    const versions = rawVersions.map((ver) => ___R$project$rome$$romejs$codec$semver$utils_ts$normalizeUserVersion(ver, opts));
    return versions.sort((a, b) => ___R$project$rome$$romejs$codec$semver$compare_ts$default(a, b));
  }

  function ___R$project$rome$$romejs$codec$semver$index_ts$maxSatisfyingSemver(
    rawVersions,
    rawRange,
    opts,
  ) {
    const versions = ___R$project$rome$$romejs$codec$semver$index_ts$sortSemverVersions(rawVersions, opts).reverse();
    const range = ___R$project$rome$$romejs$codec$semver$utils_ts$normalizeUserRange(rawRange, opts);

    for (const version of versions) {
      if (___R$project$rome$$romejs$codec$semver$satisfies_ts$default(version, range)) {
        return version;
      }
    }

    return undefined;
  }

  function ___R$project$rome$$romejs$codec$semver$index_ts$minSatisfyingSemver(
    rawVersions,
    rawRange,
    opts,
  ) {
    const versions = ___R$project$rome$$romejs$codec$semver$index_ts$sortSemverVersions(rawVersions, opts);
    const range = ___R$project$rome$$romejs$codec$semver$utils_ts$normalizeUserRange(rawRange, opts);

    for (const version of versions) {
      if (___R$project$rome$$romejs$codec$semver$satisfies_ts$default(version, range)) {
        return version;
      }
    }

    return undefined;
  }

  function ___R$project$rome$$romejs$codec$semver$index_ts$satisfiesSemver(
    rawVersion,
    rawRange,
    opts,
  ) {
    try {
      const version = ___R$project$rome$$romejs$codec$semver$utils_ts$normalizeUserVersion(rawVersion, opts);
      const range = ___R$project$rome$$romejs$codec$semver$utils_ts$normalizeUserRange(rawRange, opts);
      return ___R$project$rome$$romejs$codec$semver$satisfies_ts$default(version, range);
    } catch (err) {
      if (err instanceof ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError) {
        return false;
      } else {
        throw err;
      }
    }
  }

  // project-rome/@romejs/project/load.ts
const ___R$project$rome$$romejs$project$load_ts = {
    loadCompleteProjectConfig: ___R$project$rome$$romejs$project$load_ts$loadCompleteProjectConfig,
    normalizeProjectConfig: ___R$project$rome$$romejs$project$load_ts$normalizeProjectConfig,
  };
  const ___R$$priv$project$rome$$romejs$project$load_ts$crypto = require(
    'crypto',
  );
  const ___R$$priv$project$rome$$romejs$project$load_ts$WATCHMAN_CONFIG_FILENAME = '.watchmanconfig';
  const ___R$$priv$project$rome$$romejs$project$load_ts$IGNORE_FILENAMES = ['.gitignore', '.hgignore'];

  function ___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(consumer) {
    if (!consumer.exists()) {
      return false;
    }

    const value = consumer.asUnknown();
    if (typeof value === 'boolean') {
      consumer.unexpected(
        'Expected an object here but got a boolean',
        {
          advice: [
            {
              type: 'log',
              category: 'info',
              message: 'You likely wanted `{"enabled": ' +
              String(value) +
              '}` instead',
            },
          ],
        },
      );
      return false;
    }

    return true;
  }

  function ___R$project$rome$$romejs$project$load_ts$loadCompleteProjectConfig(
    projectFolder,
    configPath,
  ) {
    // TODO use consumer.capture somehow here to aggregate errors
    const {partial, meta} = ___R$$priv$project$rome$$romejs$project$load_ts$loadPartialProjectConfig(projectFolder, configPath);
    const {consumer} = meta;

    // Produce a defaultConfig with some folder specific values
    const defaultConfig = Object.assign(
      {
      },
      ___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG,
      {
        vsc: Object.assign(
          {
            root: projectFolder,
          },
          ___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG.vsc,
        ),
      },
    );

    const name = consumer.get('name').asString(
      'project-' +
      projectFolder.getBasename(),
    );

    const config = Object.assign(
      {
      },
      ___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG,
      {
        name,
        root: partial.root === undefined ? ___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG.root : partial.root,
      },
      ___R$$priv$project$rome$$romejs$project$load_ts$mergePartialConfig(defaultConfig, partial),
    );

    // Infer VCS ignore files as lint ignore rules
    for (const filename of ___R$$priv$project$rome$$romejs$project$load_ts$IGNORE_FILENAMES) {
      const possiblePath = config.vsc.root.append(filename);
      meta.configDependencies.add(possiblePath);

      if (___R$project$rome$$romejs$fs$index_ts$existsSync(possiblePath)) {
        const file = ___R$project$rome$$romejs$fs$index_ts$readFileTextSync(possiblePath);
        const lines = file.split('\n');

        let index = ___R$project$rome$$romejs$ob1$index_ts$number0;

        consumer.handleThrownDiagnostics(
          () => {
            const patterns = lines.map(
              (line, i) => {
                const pattern = ___R$project$rome$$romejs$path$match$parse_ts$parsePattern(
                  {
                    input: line,
                    path: possiblePath,
                    offsetPosition: {
                      index,
                      line: ___R$project$rome$$romejs$ob1$index_ts$coerce1(i),
                      column: ___R$project$rome$$romejs$ob1$index_ts$number0,
                    },
                  },
                );

                index = ___R$project$rome$$romejs$ob1$index_ts$add(index, line.length);

                // Newline char
                index = ___R$project$rome$$romejs$ob1$index_ts$inc(index);

                return pattern;
              },
            );

            // TODO: Maybe these are useful in other places?
            config.lint.ignore = [...config.lint.ignore, ...patterns];
          },
        );
      }
    }

    // Set fs.watchman=true when the file .watchmanconfig is present and no fs.watchman config was set
    if (partial.files.watchman === undefined) {
      // Try the project and vsc.root folder for a .watchmanconfig

      // We do the Set magic to only visit the projectFolder once if it is also the vsc.root
      for (const dir of new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet(
        [
          projectFolder,
          config.vsc.root,
        ],
      )) {
        const watchmanConfigPath = dir.append(___R$$priv$project$rome$$romejs$project$load_ts$WATCHMAN_CONFIG_FILENAME);
        meta.configDependencies.add(watchmanConfigPath);
        if (___R$project$rome$$romejs$fs$index_ts$existsSync(watchmanConfigPath)) {
          config.files.watchman = true;
        }
      }
    }

    return (
      {
        config,
        meta,
      }
    );
  }

  function ___R$$priv$project$rome$$romejs$project$load_ts$loadPartialProjectConfig(
    projectFolder,
    configPath,
  ) {
    const configFile = ___R$project$rome$$romejs$fs$index_ts$readFileTextSync(configPath);
    const res = ___R$project$rome$$romejs$codec$json$index_ts$consumeJSONExtra(
      {
        path: configPath,
        input: configFile,
      },
    );

    return ___R$project$rome$$romejs$project$load_ts$normalizeProjectConfig(res, configPath, configFile, projectFolder);
  }

  function ___R$project$rome$$romejs$project$load_ts$normalizeProjectConfig(
    res,
    configPath,
    configFile,
    projectFolder,
  ) {
    let {consumer} = res;

    let configSourceSubKey;
    let name;
    const isInPackageJson = configPath.getBasename() === 'package.json';
    if (isInPackageJson) {
      // Infer name from package.json
      name = consumer.get('name').asStringOrVoid();

      consumer = consumer.get(___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_PACKAGE_JSON_FIELD);
      configSourceSubKey = ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_PACKAGE_JSON_FIELD;
    }

    const hash = ___R$$priv$project$rome$$romejs$project$load_ts$crypto.createHash('sha256').update(configFile).digest('hex');

    const config = {
      compiler: {},
      bundler: {},
      cache: {},
      lint: {},
      haste: {},
      resolver: {},
      develop: {},
      typeCheck: {},
      format: {},
      tests: {},
      files: {},
      vsc: {},
      dependencies: {},
      targets: new Map(),
    };

    if (name !== undefined) {
      config.name = name;
    }

    const meta = {
      projectFolder,
      configPath,
      consumer,
      consumersChain: [consumer],
      configHashes: [hash],
      configSourceSubKey,
      configDependencies: ___R$project$rome$$romejs$project$utils_ts$getParentConfigDependencies(projectFolder),
    };

    // We never use `name` here but it's used in `loadCompleteProjectConfig`
    consumer.markUsedProperty('name');

    if (consumer.has('version')) {
      const version = consumer.get('version');

      consumer.handleThrownDiagnostics(
        () => {
          config.version =
            ___R$project$rome$$romejs$codec$semver$parse_ts$parseSemverRange(
              {
                path: consumer.filename,
                input: version.asString(),
                offsetPosition: version.getLocation('inner-value').start,
              },
            );

          // TODO verify that config.version range satisfies current version
        },
      );
    }

    if (consumer.has('root')) {
      config.root = consumer.get('root').asBoolean();
    }

    const cache = consumer.get('cache');
    if (___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(cache)) {
      // TODO
    }

    const resolver = consumer.get('resolver');
    if (___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(resolver)) {
      // TODO
    }

    const bundler = consumer.get('bundler');
    if (___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(bundler)) {
      if (bundler.has('mode')) {
        config.bundler.mode = bundler.get('mode').asStringSet(['modern', 'legacy']);
      }
    }

    const haste = consumer.get('haste');
    if (___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(haste)) {
      if (haste.has('enabled')) {
        config.haste.enabled = haste.get('enabled').asBoolean();
      }

      if (haste.has('ignore')) {
        config.haste.ignore = ___R$project$rome$$romejs$project$utils_ts$arrayOfPatterns(haste.get('ignore'));
      }
    }

    const typeChecking = consumer.get('typeChecking');
    if (___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(typeChecking)) {
      if (typeChecking.has('enabled')) {
        config.typeCheck.enabled = typeChecking.get('enabled').asBoolean();
      }

      if (typeChecking.has('libs')) {
        const libs = ___R$$priv$project$rome$$romejs$project$load_ts$normalizeTypeCheckingLibs(
          projectFolder,
          typeChecking.get(
            'libs',
          ),
        );
        config.typeCheck.libs = libs.files;
        meta.configDependencies =
          new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet(
            [
              ...meta.configDependencies,
              ...libs.folders,
              ...libs.files,
            ],
          );
      }
    }

    const dependencies = consumer.get('dependencies');
    if (___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(dependencies)) {
      if (dependencies.has('enabled')) {
        config.dependencies.enabled = dependencies.get('dependencies').asBoolean();
      }
    }

    const lint = consumer.get('lint');
    if (___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(lint)) {
      if (lint.has('enabled')) {
        config.lint.enabled = lint.get('enabled').asBoolean();
      }

      if (lint.has('ignore')) {
        config.lint.ignore = ___R$project$rome$$romejs$project$utils_ts$arrayOfPatterns(lint.get('ignore'));
      }

      if (lint.has('globals')) {
        config.lint.globals = ___R$project$rome$$romejs$project$utils_ts$arrayOfStrings(lint.get('globals'));
      }
    }

    const format = consumer.get('format');
    if (___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(format)) {
      if (format.has('enabled')) {
        config.format.enabled = format.get('enabled').asBoolean();
      }

      if (format.has('ignore')) {
        config.format.ignore = ___R$project$rome$$romejs$project$utils_ts$arrayOfPatterns(format.get('ignore'));
      }
    }

    const tests = consumer.get('tests');
    if (___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(tests)) {
      if (tests.has('enabled')) {
        config.tests.enabled = tests.get('enabled').asBoolean();
      }

      if (tests.has('ignore')) {
        config.tests.ignore = ___R$project$rome$$romejs$project$utils_ts$arrayOfPatterns(tests.get('ignore'));
      }
    }

    const develop = consumer.get('develop');
    if (___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(develop)) {
      if (develop.has('serveStatic')) {
        config.develop.serveStatic = develop.get('serveStatic').asBoolean();
      }
    }

    const files = consumer.get('files');
    if (___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(files)) {
      if (files.has('watchman')) {
        config.files.watchman = files.get('watchman').asBoolean();
      }

      if (files.has('vendorPath')) {
        config.files.vendorPath =
          projectFolder.resolve(
            files.get('vendorPath').asString(),
          );
      }

      if (files.has('maxSize')) {
        config.files.maxSize = files.get('maxSize').asNumber();
      }

      if (files.has('assetExtensions')) {
        config.files.assetExtensions =
          files.get('assetExtensions').asArray().map(
            (item) => item.asString(),
          );
      }
    }

    const vsc = consumer.get('vsc');
    if (___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(vsc)) {
      if (vsc.has('root')) {
        config.vsc.root = projectFolder.resolve(vsc.get('root').asString());
      }
    }

    const compiler = consumer.get('compiler');
    if (___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(compiler)) {
      // TODO
    }

    const targets = consumer.get('targets');
    if (___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(targets)) {
      for (const [name, object] of targets.asMap()) {
        const target = {
          constraints: object.get('constraints').asImplicitArray().map(
            (
              item,
            ) =>
              item.asString(),
          ),
        };
        object.enforceUsedProperties('config target property');
        config.targets.set(name, target);
      }
    }

    // Complain about common misspellings
    if (consumer.has('linter')) {
      consumer.get('linter').unexpected('Did you mean <emphasis>lint</emphasis>?');
    }

    // Need to get this before enforceUsedProperties so it will be flagged
    const _extends = consumer.get('extends');

    // Flag unknown properties
    consumer.enforceUsedProperties('config property');

    if (_extends.exists()) {
      return ___R$$priv$project$rome$$romejs$project$load_ts$extendProjectConfig(projectFolder, _extends, config, meta);
    }

    return (
      {
        partial: config,
        meta,
      }
    );
  }

  function ___R$$priv$project$rome$$romejs$project$load_ts$normalizeTypeCheckingLibs(
    projectFolder,
    consumer,
  ) {
    const libFiles = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet();

    // Normalize library folders
    const folders = ___R$project$rome$$romejs$project$utils_ts$arrayOfStrings(consumer).map(
      (
        libFolder,
      ) =>
        projectFolder.resolve(libFolder),
    );

    // Crawl library folders and add their files
    for (const folder of folders) {
      const files = ___R$project$rome$$romejs$fs$index_ts$readdirSync(folder);
      for (const file of files) {
        const stats = ___R$project$rome$$romejs$fs$index_ts$lstatSync(file);
        if (stats.isFile()) {
          libFiles.add(file);
        } else if (stats.isDirectory()) {
          folders.push(file);
        }
      }
    }

    return (
      {
        files: libFiles,
        folders,
      }
    );
  }

  function ___R$$priv$project$rome$$romejs$project$load_ts$extendProjectConfig(
    projectFolder,
    extendsStrConsumer,
    config,
    meta,
  ) {
    const extendsRelative = extendsStrConsumer.asString();

    if (extendsRelative === 'parent') {
      // TODO maybe do some magic here?
    }

    const extendsPath = projectFolder.resolve(extendsRelative);
    const {partial: extendsObj, meta: extendsMeta} = ___R$$priv$project$rome$$romejs$project$load_ts$loadPartialProjectConfig(
      extendsPath.getParent(),
      extendsPath,
    );

    // Check for recursive config
    for (const path of extendsMeta.configDependencies) {
      if (path.equal(extendsPath)) {
        throw extendsStrConsumer.unexpected('Recursive config value');
      }
    }

    const merged = ___R$$priv$project$rome$$romejs$project$load_ts$mergePartialConfig(extendsObj, config);

    const lintIgnore = ___R$project$rome$$romejs$project$utils_ts$mergeArrays(extendsObj.lint.ignore, config.lint.ignore);
    if (lintIgnore !== undefined) {
      merged.lint.ignore = lintIgnore;
    }

    const lintGlobals = ___R$project$rome$$romejs$project$utils_ts$mergeArrays(extendsObj.lint.globals, config.lint.globals);
    if (lintGlobals !== undefined) {
      merged.lint.globals = lintGlobals;
    }

    const hasteIgnore = ___R$project$rome$$romejs$project$utils_ts$mergeArrays(extendsObj.haste.ignore, config.haste.ignore);
    if (hasteIgnore !== undefined) {
      merged.haste.ignore = hasteIgnore;
    }

    const testingIgnore = ___R$project$rome$$romejs$project$utils_ts$mergeArrays(extendsObj.tests.ignore, config.tests.ignore);
    if (testingIgnore !== undefined) {
      merged.tests.ignore = testingIgnore;
    }

    const typeCheckingLibs = ___R$project$rome$$romejs$project$utils_ts$mergeAbsoluteFilePathSets(
      extendsObj.typeCheck.libs,
      config.typeCheck.libs,
    );
    if (typeCheckingLibs !== undefined) {
      merged.typeCheck.libs = typeCheckingLibs;
    }

    return (
      {
        partial: merged,
        meta: Object.assign(
          {
          },
          meta,
          {
            consumersChain: [...meta.consumersChain, ...extendsMeta.consumersChain],
            configDependencies: new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet(
              [
                ...meta.configDependencies,
                ...extendsMeta.configDependencies,
                extendsPath,
              ],
            ),
            configHashes: [...meta.configHashes, ...extendsMeta.configHashes],
          },
        ),
      }
    );
  }

  function ___R$$priv$project$rome$$romejs$project$load_ts$mergePartialConfig(
    a,
    b,
  ) {
    return (
      {
        cache: Object.assign(
          {
          },
          a.cache,
          b.cache,
        ),
        compiler: Object.assign(
          {
          },
          a.compiler,
          b.compiler,
        ),
        lint: Object.assign(
          {
          },
          a.lint,
          b.lint,
        ),
        develop: Object.assign(
          {
          },
          a.develop,
          b.develop,
        ),
        bundler: Object.assign(
          {
          },
          a.bundler,
          b.bundler,
        ),
        dependencies: Object.assign(
          {
          },
          a.dependencies,
          b.dependencies,
        ),
        resolver: Object.assign(
          {
          },
          a.resolver,
          b.resolver,
        ),
        haste: Object.assign(
          {
          },
          a.haste,
          b.haste,
        ),
        typeCheck: Object.assign(
          {
          },
          a.typeCheck,
          b.typeCheck,
        ),
        tests: Object.assign(
          {
          },
          a.tests,
          b.tests,
        ),
        format: Object.assign(
          {
          },
          a.format,
          b.format,
        ),
        files: Object.assign(
          {
          },
          a.files,
          b.files,
        ),
        vsc: Object.assign(
          {
          },
          a.vsc,
          b.vsc,
        ),
        targets: new Map([...a.targets.entries(), ...b.targets.entries()]),
      }
    );
  }

  // project-rome/@romejs/project/save.ts
const ___R$project$rome$$romejs$project$save_ts = {
    modifyProjectConfig: ___R$project$rome$$romejs$project$save_ts$modifyProjectConfig,
  };
  async function ___R$project$rome$$romejs$project$save_ts$modifyProjectConfig(
    softMeta,
    callbacks,
  ) {
    const meta = ___R$project$rome$$romejs$project$utils_ts$assertHardMeta(softMeta);
    const {configPath, configSourceSubKey: consumerSubKey} = meta;

    await callbacks.pre(meta);

    // Load the config file again
    const configFile = await ___R$project$rome$$romejs$fs$index_ts$readFileText(configPath);
    const res = ___R$project$rome$$romejs$codec$json$index_ts$consumeJSONExtra(
      {
        path: configPath,
        input: configFile,
      },
    );

    const {consumer} = res;
    if (consumerSubKey === undefined) {
      await callbacks.modify(consumer);
    } else {
      await callbacks.modify(consumer.get(consumerSubKey));
    }

    // Stringify the config
    let stringified;
    if (res.hasExtensions) {
      stringified = ___R$project$rome$$romejs$codec$json$index_ts$stringifyJSON(res);
    } else {
      stringified = JSON.stringify(consumer.asUnknown(), null, '  ');
    }

    // Test if this project config doesn't result in errors
    try {
      // Reconsume with new stringified config
      const res = ___R$project$rome$$romejs$codec$json$index_ts$consumeJSONExtra(
        {
          path: configPath,
          input: stringified,
        },
      );

      // Validate the new config
      ___R$project$rome$$romejs$project$load_ts$normalizeProjectConfig(res, configPath, stringified, meta.projectFolder);
    } catch (err) {
      let diagnostics = ___R$project$rome$$romejs$diagnostics$errors_ts$getDiagnosticsFromError(err);
      if (diagnostics === undefined) {
        throw err;
      }

      // Set the `code` property on relevant diagnostics since our changes don't exist on disk
      diagnostics =
        diagnostics.map(
          (diag) => {
            return (
              diag.filename === configPath.join()
                ? Object.assign(
                  {
                  },
                  diag,
                  {
                    sourceText: stringified,
                  },
                ) : diag
            );
          },
        );

      throw (
        new ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError(
          'Diagnostics produced while testing new project config',
          diagnostics,
        )
      );
    }

    // Write it out
    await ___R$project$rome$$romejs$fs$index_ts$writeFile(configPath, stringified);
  }

  // project-rome/@romejs/project/transport.ts
const ___R$project$rome$$romejs$project$transport_ts = {
    serializeJSONProjectConfig: ___R$project$rome$$romejs$project$transport_ts$serializeJSONProjectConfig,
    hydrateJSONProjectConfig: ___R$project$rome$$romejs$project$transport_ts$hydrateJSONProjectConfig,
  };
  function ___R$project$rome$$romejs$project$transport_ts$serializeJSONProjectConfig(
    config,
  ) {
    const targets = {};
    for (const [name, target] of config.targets) {
      targets[name] = target;
    }

    return (
      Object.assign(
        {
        },
        config,
        {
          vsc: Object.assign(
            {
            },
            config.vsc,
            {
              root: config.vsc.root.join(),
            },
          ),
          typeCheck: Object.assign(
            {
            },
            config.typeCheck,
            {
              libs: Array.from(config.typeCheck.libs, (path) => path.join()),
            },
          ),
          files: Object.assign(
            {
            },
            config.files,
            {
              vendorPath: config.files.vendorPath.join(),
            },
          ),
          targets,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$project$transport_ts$hydrateJSONProjectConfig(
    config,
  ) {
    return (
      Object.assign(
        {
        },
        config,
        {
          files: Object.assign(
            {
            },
            config.files,
            {
              vendorPath: ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(config.files.vendorPath),
            },
          ),
          vsc: Object.assign(
            {
            },
            config.vsc,
            {
              root: ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(config.vsc.root),
            },
          ),
          typeCheck: Object.assign(
            {
            },
            config.typeCheck,
            {
              libs: new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet(
                config.typeCheck.libs.map(
                  (
                    str,
                  ) =>
                    ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(str),
                ),
              ),
            },
          ),
          targets: new Map(Object.entries(config.targets)),
        },
      )
    );
  }

  // project-rome/@romejs/project/index.ts


  // project-rome/@romejs/js-ast-utils/removeLoc.ts
function ___R$$priv$project$rome$$romejs$js$ast$utils$removeLoc_ts$removeProp(obj) {
    const ___R$ = obj;
    const locless = Object.assign(
      {
      },
      ___R$,
    );
    delete locless.loc;
    const {
      loc,
    } = ___R$;
    loc;
    return locless;
  }

  function ___R$$priv$project$rome$$romejs$js$ast$utils$removeLoc_ts$removeComments(
    comments,
  ) {
    if (comments === undefined) {
      return undefined;
    }

    const newComments = comments.map(
      (
        comment,
      ) =>
        comment.type === 'CommentBlock' ? ___R$$priv$project$rome$$romejs$js$ast$utils$removeLoc_ts$removeProp(comment) : ___R$$priv$project$rome$$romejs$js$ast$utils$removeLoc_ts$removeProp(comment),
    );
    return newComments;
  }

  const ___R$$priv$project$rome$$romejs$js$ast$utils$removeLoc_ts$removeLocTransform = [
    {
      name: 'removeLocTransform',
      enter(path) {
        const {node} = path;
        if (node.loc === undefined) {
          return node;
        } else {
          const newNode = Object.assign(
            {
            },
            ___R$$priv$project$rome$$romejs$js$ast$utils$removeLoc_ts$removeProp(node),
            {
              leadingComments: ___R$$priv$project$rome$$romejs$js$ast$utils$removeLoc_ts$removeComments(node.leadingComments),
              trailingComments: ___R$$priv$project$rome$$romejs$js$ast$utils$removeLoc_ts$removeComments(node.trailingComments),
              innerComments: ___R$$priv$project$rome$$romejs$js$ast$utils$removeLoc_ts$removeComments(node.innerComments),
            },
          );

          // Also remove any `undefined` properties

          // rome-suppress lint/noExplicitAny
          const escaped = newNode;
          for (const key in newNode) {
            if (escaped[key] === undefined) {
              delete escaped[key];
            }
          }

          return (newNode);
        }
      },
    },
  ];

  function ___R$project$rome$$romejs$js$ast$utils$removeLoc_ts$default(ast) {
    const context = new ___R$project$rome$$romejs$js$compiler$lib$Context_ts$default(
      {
        ast: ___R$project$rome$$romejs$js$ast$core$Program_ts$MOCK_PROGRAM,
        project: {
          folder: undefined,
          config: ___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG,
        },
      },
    );
    return context.reduce(ast, ___R$$priv$project$rome$$romejs$js$ast$utils$removeLoc_ts$removeLocTransform);
  }

  // project-rome/@romejs/js-ast-utils/isIdentifierish.ts
function ___R$project$rome$$romejs$js$ast$utils$isIdentifierish_ts$default(node) {
    return (
      node.type === 'Identifier' || node.type === 'JSXIdentifier' ||
      node.type === 'JSXReferenceIdentifier' ||
      node.type === 'BindingIdentifier' ||
      node.type === 'AssignmentIdentifier' ||
      node.type === 'ReferenceIdentifier'
    );
  }

  // project-rome/@romejs/js-ast-utils/template.ts
const ___R$$priv$project$rome$$romejs$js$ast$utils$template_ts$templateCache = new Map();

  function ___R$$priv$project$rome$$romejs$js$ast$utils$template_ts$getTemplate(strs) {
    const cached = ___R$$priv$project$rome$$romejs$js$ast$utils$template_ts$templateCache.get(strs);
    if (cached) {
      return cached;
    }

    // calculate amount of placeholders to insert
    const pathCount = strs.length - 1;

    // create path ids
    let placeholders = {};
    const placeholderIds = [];
    for (let i = 0;
    i < pathCount;
    i++) {
      const id = '__' +
      String(i) +
      '__';
      placeholderIds.push(id);
      placeholders[id] = undefined;
    }

    // interpolate placeholders and original code
    let code = '';
    for (let i = 0;
    i < strs.length;
    i++) {
      // add original part of code
      code += strs[i];

      // add in placeholder
      const placeholder = placeholderIds[i];
      if (placeholder) {
        code += placeholder;
      }
    }

    // parse the interpolated code
    let ast = ___R$project$rome$$romejs$js$parser$index_ts$parseJS(
      {
        input: code,
        sourceType: 'template',
        path: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath('template'),
      },
    );

    // remove `loc` properties
    ast = ___R$project$rome$$romejs$js$ast$core$Program_ts$program.assert(___R$project$rome$$romejs$js$ast$utils$removeLoc_ts$default(ast));

    // traverse and find placeholders paths
    function collectPlaceholderPaths(path) {
      const {node} = path;
      if (___R$project$rome$$romejs$js$ast$utils$isIdentifierish_ts$default(node) && node.name in placeholders) {
        placeholders[node.name] =
          {
            type: node.type,
            path: path.getPathKeys(),
          };
      }
      return node;
    }

    const context = new ___R$project$rome$$romejs$js$compiler$lib$Context_ts$default(
      {
        ast,
        project: {
          folder: undefined,
          config: ___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG,
        },
      },
    );
    context.reduce(
      ast,
      [
        {name: 'collectPlaceholderPaths', enter: collectPlaceholderPaths},
      ],
    );

    const placeholderPaths = [];
    for (const id in placeholders) {
      const path = placeholders[id];
      if (path === undefined) {
        throw new Error('Failed to find placeholder path for ' +
        id);
      } else {
        placeholderPaths.push(path);
      }
    }

    return {ast, placeholderPaths};
  }

  function ___R$$priv$project$rome$$romejs$js$ast$utils$template_ts$createIdentifier(
    substitute,
    expectedIdType,
  ) {
    if (typeof substitute === 'string') {
      // @ts-ignore: No idea why this error exists
      return (
        {
          type: expectedIdType,
          name: substitute,
        }
      );
    } else {
      return substitute;
    }
  }

  function ___R$project$rome$$romejs$js$ast$utils$template_ts$default(
    strs,
  ...substitutions) {
    const {ast, placeholderPaths} = ___R$$priv$project$rome$$romejs$js$ast$utils$template_ts$getTemplate(strs);

    // no substitutions so we can just return the ast!
    if (!substitutions.length) {
      return ast;
    }

    // this case should never be hit
    if (placeholderPaths.length !== substitutions.length) {
      throw new Error('Expected subtituions to be the same length as paths');
    }

    const newAst = Object.assign(
      {
      },
      ast,
    );

    for (let i = 0;
    i < placeholderPaths.length;
    i++) {
      const {type, path} = placeholderPaths[i];

      const substitute = ___R$$priv$project$rome$$romejs$js$ast$utils$template_ts$createIdentifier(substitutions[i], type);
      // rome-suppress lint/noExplicitAny
      let target = newAst;

      for (let i = 0;
      i < path.length;
      i++) {
        const key = path[i];
        const isLast = i === path.length - 1;

        if (isLast) {
          target[key] = substitute;
        } else {
          let currTarget = target[key];
          if (Array.isArray(currTarget)) {
            currTarget = currTarget.slice();
          } else {
            currTarget = Object.assign(
              {
              },
              currTarget,
            );
          }
          target[key] = currTarget;
          target = currTarget;
        }
      }
    }

    return newAst;
  }

  ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression =
    (
      strs,
    ...substitutions) => {
      var ___R$;
      const first = (
        ___R$ =
          ___R$project$rome$$romejs$js$ast$utils$template_ts$default,
        ___R$.statement.apply(___R$, [
          strs,
          ...substitutions,
        ])
      );

      // Ensure that the single statement is an ExpressionStatement
      if (first.type !== 'ExpressionStatement') {
        throw new Error('Single statement should be an ExpressionStatement');
      }

      return first.expression;
    };

  ___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement =
    (
      strs,
    ...substitutions) => {
      // Parse the template, with caching
      const ast = ___R$project$rome$$romejs$js$ast$core$Program_ts$program.assert(___R$project$rome$$romejs$js$ast$utils$template_ts$default.apply(null, [
        strs,
        ...substitutions,
      ]));

      // Ensure that there's only a single statement in the Program body
      const body = ast.body;
      if (body.length !== 1) {
        throw new Error('More than one statement isn\'t allowed for a template.');
      }
      return body[0];
    };

  // project-rome/@romejs/js-ast-utils/isTypeExpressionWrapperNode.ts
function ___R$project$rome$$romejs$js$ast$utils$isTypeExpressionWrapperNode_ts$default(
    node,
  ) {
    return node.type === 'FlowTypeCastExpression' || node.type === 'TSAsExpression';
  }

  // project-rome/@romejs/js-ast-utils/isInTypeAnnotation.ts
// Is this honestly the best heuristics?
  function ___R$$priv$project$rome$$romejs$js$ast$utils$isInTypeAnnotation_ts$getTypeNode(path) {
    const {parent, parentPath} = path;
    if (parent === undefined || parentPath === undefined) {
      return undefined;
    }

    if (___R$project$rome$$romejs$js$ast$utils$isTypeNode_ts$default(parent)) {
      return parent;
    }

    if (___R$project$rome$$romejs$js$ast$utils$isTypeNode_ts$default(parentPath.parent)) {
      return parentPath.parent;
    }
  }

  function ___R$project$rome$$romejs$js$ast$utils$isInTypeAnnotation_ts$default(path) {
    const match = ___R$$priv$project$rome$$romejs$js$ast$utils$isInTypeAnnotation_ts$getTypeNode(path);
    if (match === undefined) {
      return false;
    }

    if (___R$project$rome$$romejs$js$ast$utils$isTypeExpressionWrapperNode_ts$default(match)) {
      return false;
    } else {
      return true;
    }
  }

  // project-rome/@romejs/js-ast-utils/getRequireSource.ts
const ___R$$priv$project$rome$$romejs$js$ast$utils$getRequireSource_ts$ROME_DEFAULT_REQUIRE = ['Rome', 'requireDefault'];
  const ___R$$priv$project$rome$$romejs$js$ast$utils$getRequireSource_ts$ROME_NAMESPACE_REQUIRE = ['Rome', 'requireNamespace'];

  function ___R$project$rome$$romejs$js$ast$utils$getRequireSource_ts$default(
    node,
    scope,
    allowStaticMember = false,
  ) {
    if (node === undefined) {
      return;
    }

    if (allowStaticMember && node.type === 'MemberExpression' &&
      node.property.type === 'StaticMemberProperty') {
      node = node.object;
    }

    if (node.type !== 'CallExpression') {
      return;
    }

    const {arguments: args, callee} = node;

    const [firstArg] = args;
    if (args.length !== 1 || firstArg.type !== 'StringLiteral') {
      return;
    }

    const validRequireCallee = callee.type === 'ReferenceIdentifier' &&
      callee.name === 'require' &&
      scope.getBinding('require') === undefined;

    const validRomeRequreCallee = (___R$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(
      callee,
      ___R$$priv$project$rome$$romejs$js$ast$utils$getRequireSource_ts$ROME_DEFAULT_REQUIRE,
    ) ||
    ___R$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(callee, ___R$$priv$project$rome$$romejs$js$ast$utils$getRequireSource_ts$ROME_NAMESPACE_REQUIRE)) &&
      scope.getBinding('Rome') === undefined;

    if (validRequireCallee || validRomeRequreCallee) {
      return firstArg.value;
    }
  }

  // project-rome/@romejs/js-ast-utils/getCompletionRecords.ts
function ___R$$priv$project$rome$$romejs$js$ast$utils$getCompletionRecords_ts$getIfCompletionRecords(
    node,
    parent,
    key,
  ) {
    if (node === undefined) {
      return (
        [
          {
            type: 'INVALID',
            description: 'empty ' +
            key,
            node: parent,
          },
        ]
      );
    } else {
      return ___R$project$rome$$romejs$js$ast$utils$getCompletionRecords_ts$default(node);
    }
  }

  function ___R$$priv$project$rome$$romejs$js$ast$utils$getCompletionRecords_ts$getLastCompletionRecordFromNodes(
    nodes,
  ) {
    // Get the last node to produce records
    for (let i = nodes.length - 1;
    i >= 0;
    i--) {
      const node = nodes[i];
      const records = ___R$$priv$project$rome$$romejs$js$ast$utils$getCompletionRecords_ts$_getCompletionRecords(node);
      if (records !== undefined) {
        return records;
      }
    }
  }

  function ___R$$priv$project$rome$$romejs$js$ast$utils$getCompletionRecords_ts$_getCompletionRecords(node) {
    if (node.type === 'BlockStatement') {
      const records = ___R$$priv$project$rome$$romejs$js$ast$utils$getCompletionRecords_ts$getLastCompletionRecordFromNodes(node.body);
      if (records !== undefined) {
        return records;
      }

      return (
        [
          {
            type: 'INVALID',
            description: 'empty block',
            node,
          },
        ]
      );
    }

    if (node.type === 'SwitchStatement') {
      for (const caseNode of node.cases) {
        if (caseNode.test === undefined) {
          const records = ___R$$priv$project$rome$$romejs$js$ast$utils$getCompletionRecords_ts$getLastCompletionRecordFromNodes(caseNode.consequent);
          if (records === undefined) {
            return (
              [
                {
                  type: 'INVALID',
                  description: 'default switch clause with no completions',
                  node: caseNode,
                },
              ]
            );
          } else {
            return records;
          }
        }
      }

      return (
        [
          {
            type: 'INVALID',
            description: 'switch with no default clause',
            node,
          },
        ]
      );
    }

    if (node.type === 'IfStatement') {
      return (
        [
          ...___R$$priv$project$rome$$romejs$js$ast$utils$getCompletionRecords_ts$getIfCompletionRecords(node.consequent, node, 'consequent'),
          ...___R$$priv$project$rome$$romejs$js$ast$utils$getCompletionRecords_ts$getIfCompletionRecords(node.alternate, node, 'alternate'),
        ]
      );
    }

    if (node.type === 'ReturnStatement' || node.type === 'ContinueStatement' ||
    node.type === 'BreakStatement' ||
    node.type === 'ThrowStatement') {
      return (
        [
          {
            type: 'COMPLETION',
            node,
          },
        ]
      );
    }
  }

  function ___R$project$rome$$romejs$js$ast$utils$getCompletionRecords_ts$default(node) {
    const records = ___R$$priv$project$rome$$romejs$js$ast$utils$getCompletionRecords_ts$_getCompletionRecords(node);
    if (records === undefined) {
      return (
        [
          {
            type: 'INVALID',
            description: 'invalid node',
            node,
          },
        ]
      );
    } else {
      return records;
    }
  }

  // project-rome/@romejs/js-ast-utils/index.ts


  // project-rome/@romejs/consume/Consumer.ts
function ___R$$priv$project$rome$$romejs$consume$Consumer_ts$isComputedPart(part) {
    return typeof part === 'number' || !___R$project$rome$$romejs$js$ast$utils$isValidIdentifierName_ts$default(part);
  }

  function ___R$$priv$project$rome$$romejs$consume$Consumer_ts$joinPath(path) {
    let str = '';

    for (let i = 0;
    i < path.length;
    i++) {
      const part = path[i];
      const nextPart = path[i + 1];

      // If we are a computed property then wrap in brackets, the previous part would not have inserted a dot
      if (___R$$priv$project$rome$$romejs$consume$Consumer_ts$isComputedPart(part)) {
        const inner = typeof part === 'number'
          ? String(part) : ___R$project$rome$$romejs$string$escape$escapeString_ts$default(
            part,
            {
              quote: '\'',
            },
          );

        str += '[' +
        inner +
        ']';
      } else {
        if (nextPart === undefined || ___R$$priv$project$rome$$romejs$consume$Consumer_ts$isComputedPart(nextPart)) {
          // Don't append a dot if there are no parts or the next is computed
          str += part;
        } else {
          str += part +
          '.';
        }
      }
    }

    return str;
  }

  class ___R$project$rome$$romejs$consume$Consumer_ts$default {
    constructor(opts) {
      this.path = opts.filePath;
      this.filename = this.path === undefined ? undefined : this.path.join();

      this.value = opts.value;
      this.parent = opts.parent;
      this.keyPath = opts.objectPath;
      this.context = opts.context;
      this.onDefinition = opts.onDefinition;
      this.propertyMetadata = opts.propertyMetadata;
      this.usedNames = new Set();
      this.forkCache = new Map();
      this.forceDiagnosticTarget = opts.forceDiagnosticTarget;

      // See shouldDispatchUnexpected for explanation
      this.hasHandledUnexpected = false;
      this.handleUnexpected = opts.handleUnexpectedDiagnostic;
    }

    async capture(
      callback,
    ) {
      let diagnostics = [];
      const definitions = [];

      const consumer = this.clone(
        {
          onDefinition(def) {
            definitions.push(def);
          },

          handleUnexpectedDiagnostic(diag) {
            diagnostics.push(diag);
          },
        },
      );

      const result = await callback(consumer);
      return {result, definitions, diagnostics};
    }

    handleThrownDiagnostics(callback) {
      if (this.handleUnexpected === undefined) {
        callback();
      } else {
        try {
          callback();
        } catch (err) {
          const diags = ___R$project$rome$$romejs$diagnostics$errors_ts$getDiagnosticsFromError(err);
          if (diags === undefined) {
            throw err;
          } else {
            for (const diag of diags) {
              this.handleUnexpected(diag);
            }
          }
        }
      }
    }

    declareDefinition(def) {
      if (this.onDefinition !== undefined) {
        this.onDefinition(
          (Object.assign(
            {
            },
            def,
            {
              objectPath: this.keyPath,
              metadata: this.propertyMetadata,
            },
          )),
        );
      }
    }

    getDiagnosticPointer(target = 'all') {
      const {getDiagnosticPointer} = this.context;
      if (getDiagnosticPointer === undefined) {
        return undefined;
      }

      const {forceDiagnosticTarget} = this;
      if (forceDiagnosticTarget !== undefined) {
        target = forceDiagnosticTarget;
      }
      return getDiagnosticPointer(this.keyPath, target);
    }

    getLocation(target) {
      const pointer = this.getDiagnosticPointer(target);
      if (pointer === undefined) {
        return (
          {
            filename: this.filename,
            start: ___R$project$rome$$romejs$parser$core$types_ts$UNKNOWN_POSITION,
            end: ___R$project$rome$$romejs$parser$core$types_ts$UNKNOWN_POSITION,
          }
        );
      } else {
        return (
          {
            filename: pointer.filename,
            start: pointer.start,
            end: pointer.end,
          }
        );
      }
    }

    getLocationRange(startIndex, endIndex = startIndex, target) {
      const loc = this.getLocation(target);
      if (loc.start === ___R$project$rome$$romejs$parser$core$types_ts$UNKNOWN_POSITION) {
        return loc;
      }

      const {start, end} = loc;

      // We don't support handling line differences here... yet?
      if (start.line !== end.line) {
        return loc;
      }

      return (
        Object.assign(
          {
          },
          loc,
          {
            start: Object.assign(
              {
              },
              start,
              {
                column: ___R$project$rome$$romejs$ob1$index_ts$add(start.column, startIndex),
                index: ___R$project$rome$$romejs$ob1$index_ts$add(start.index, startIndex),
              },
            ),
            end: Object.assign(
              {
              },
              start,
              {
                column: ___R$project$rome$$romejs$ob1$index_ts$add(start.column, endIndex),
                index: ___R$project$rome$$romejs$ob1$index_ts$add(start.index, endIndex),
              },
            ),
          },
        )
      );
    }

    getKey() {
      return (
        this.clone(
          {
            forceDiagnosticTarget: 'key',
            value: this.getParentKey(),
          },
        )
      );
    }

    getParentKey() {
      return this.keyPath[this.keyPath.length - 1];
    }

    hasChangedFromSource() {
      const {getOriginalValue} = this.context;
      if (getOriginalValue === undefined) {
        return false;
      }

      const originalValue = getOriginalValue(this.keyPath);
      return !this.wasInSource() || this.value !== originalValue;
    }

    wasInSource() {
      return this.getDiagnosticPointer() !== undefined;
    }

    generateUnexpectedMessage(msg, opts) {
      const {at = 'suffix', atParent = false} = opts;
      const {parent} = this;

      let target = this;

      if (atParent) {
        if (parent === undefined) {
          // Cannot target the parent if it does not exist
          return msg;
        } else {
          target = parent;
        }
      }

      if (at === 'suffix') {
        msg += ' at <emphasis>' +
        ___R$$priv$project$rome$$romejs$consume$Consumer_ts$joinPath(target.keyPath) +
        '</emphasis>';
      } else {
        msg = '<emphasis>' +
        ___R$$priv$project$rome$$romejs$consume$Consumer_ts$joinPath(target.keyPath) +
        '</emphasis> ' +
        msg;
      }

      return msg;
    }

    unexpected(msg, opts = {}) {
      const {target = 'value'} = opts;
      let {loc} = opts;

      const {filename} = this;
      let pointer = this.getDiagnosticPointer(target);
      const fromSource = pointer !== undefined;

      msg = this.generateUnexpectedMessage(msg, opts);

      const advice = [...(opts.advice || [])];

      // Make the errors more descriptive
      if (fromSource) {
        if (this.hasChangedFromSource()) {
          advice.push(
            {
              type: 'log',
              category: 'warn',
              message: 'Our internal value has been modified since we read the original source',
            },
          );
        }
      } else {
        // Go up the consumer tree and take the position from the first consumer found in the source
        let consumer = this;
        do {
          const possiblePointer = consumer.getDiagnosticPointer(target);
          if (possiblePointer !== undefined) {
            pointer = possiblePointer;
            break;
          }
          consumer = consumer.parent;
        } while (consumer !== undefined);

        // If consumer is undefined and we have no filename then we were not able to find a location,

        // in this case, just throw a normal error
        if (consumer === undefined && filename === undefined) {
          throw new Error(msg);
        }

        // Warn that we didn't find this value in the source if it's parent wasn't either
        if (this.parent === undefined || !this.parent.wasInSource()) {
          advice.push(
            {
              type: 'log',
              category: 'warn',
              message: 'This value was expected to be found at <emphasis>' +
              ___R$$priv$project$rome$$romejs$consume$Consumer_ts$joinPath(
                this.keyPath,
              ) +
              '</emphasis> but was not in the original source',
            },
          );
        }
      }

      if (pointer === undefined) {
        throw new Error(msg);
      }

      if (loc === undefined) {
        loc =
          {
            filename: pointer.filename,
            start: pointer.start,
            end: pointer.end,
          };
      }

      const diagnostic = Object.assign(
        {
          category: opts.category === undefined
            ? this.context.category : opts.category,
          filename: this.filename,
          message: msg,
        },
        loc,
        {
          language: pointer.language,
          mtime: pointer.mtime,
          sourceText: pointer.sourceText,
          advice,
        },
      );

      const errMsg = 'Error occurred while consuming at ' +
      loc.filename +
      ' (' +
      loc.start.line +
      ':' +
      loc.start.column +
      '): ' +
      msg;
      const err = new ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError(errMsg, [diagnostic]);

      if (this.handleUnexpected === undefined) {
        throw err;
      } else {
        if (this.shouldDispatchUnexpected()) {
          this.handleUnexpected(diagnostic);
          this.hasHandledUnexpected = true;
        }

        // Still allow throwing the diagnostic
        return err;
      }
    }

    // Only dispatch a single error for the current consumer, and suppress any if we have a parent consumer with errors

    // We do this since we could be producing redundant stale errors based on

    // results we've normalized to allow us to continue
    shouldDispatchUnexpected() {
      if (this.hasHandledUnexpected) {
        return false;
      }

      const {parent} = this;
      if (parent !== undefined) {
        return parent.shouldDispatchUnexpected();
      }

      return true;
    }

    clone(opts) {
      return (
        new ___R$project$rome$$romejs$consume$Consumer_ts$default(
          Object.assign(
            {
              onDefinition: this.onDefinition,
              handleUnexpectedDiagnostic: this.handleUnexpected,
              filePath: this.path,
              context: this.context,
              value: this.value,
              parent: this.parent,
              objectPath: this.keyPath,
              propertyMetadata: this.propertyMetadata,
            },
            opts,
          ),
        )
      );
    }

    fork(key, value, propertyMetadata) {
      // We require this cache as we sometimes want to store state about a forked property such as used items
      const cached = this.forkCache.get(String(key));
      if (cached !== undefined && cached.value === value &&
        (cached.propertyMetadata === undefined ||
        cached.propertyMetadata ===
        propertyMetadata)) {
        return cached;
      }

      const forked = this.clone(
        {
          propertyMetadata,
          value,
          parent: this,
          objectPath: [...this.keyPath, key],
        },
      );
      this.forkCache.set(String(key), forked);
      return forked;
    }

    _normalizeValueForSet(value) {
      if (value instanceof Set) {
        return Array.from(value);
      }

      if (value instanceof Map) {
        const obj = {};
        for (const [key, val] of value) {
          obj[key] = val;
        }
        return obj;
      }

      return value;
    }

    getValue(def) {
      if (this.exists()) {
        return this.value;
      } else {
        return def;
      }
    }

    setValue(rawValue) {
      const value = this._normalizeValueForSet(rawValue);
      this.value = value;

      // If we're at the root (as indicated by the lack of these properties) then go no where else
      const {parent, keyPath} = this;
      if (parent === undefined || keyPath.length === 0) {
        return this;
      }

      // Validate the parent is an object
      const parentValue = parent.asUnknown();
      if (parentValue === undefined || parentValue === null ||
      typeof parentValue !== 'object') {
        throw parent.unexpected('Attempted to set a property on a non-object');
      }

      // Mutate the parent
      const parentObj = parent.asUnknownObject();
      const key = this.getParentKey();
      parentObj[String(key)] = value;
      parent.setValue(parentObj);

      return this;
    }

    has(key) {
      return this.get(key).asUnknown() !== undefined;
    }

    setProperty(key, value) {
      return this.get(key).setValue(value);
    }

    get(key, metadata) {
      const value = this.asUnknownObject();
      this.markUsedProperty(key);
      return this.fork(key, value[key], metadata);
    }

    markUsedProperty(name) {
      this.usedNames.add(name);
    }

    enforceUsedProperties(type = 'property', recursive = true) {
      if (!this.isObject()) {
        return;
      }

      const knownProperties = Array.from(this.usedNames.keys());

      for (const [key, value] of this.asMap(false, false)) {
        if (!this.usedNames.has(key)) {
          value.unexpected(
            'Unknown <emphasis>' +
            key +
            '</emphasis> ' +
            type,
            {
              target: 'key',
              at: 'suffix',
              atParent: true,
              advice: ___R$project$rome$$romejs$diagnostics$helpers_ts$buildSuggestionAdvice(
                key,
                knownProperties,
                {
                  ignoreCase: true,
                },
              ),
            },
          );
        }

        if (recursive) {
          value.enforceUsedProperties(type, true);
        }
      }
    }

    // ARRAY MUTATION
    pushArray(item) {
      this.concatArray([item]);
      return this;
    }

    concatArray(items) {
      const arr = this.asPlainArray();
      this.setValue(arr.concat(items));
      return this;
    }

    // JSON
    asJSONValue() {
      const {value} = this;

      switch (typeof value) {
        case 'number':
        case 'string':
        case 'boolean':
          return value;
      }

      if (value === null) {
        return null;
      }

      if (Array.isArray(value)) {
        return this.asJSONArray();
      }

      if (this.isObject()) {
        return this.asJSONObject();
      }

      this.unexpected('Expected a JSON value');
      return '';
    }

    asJSONArray() {
      const arr = [];
      for (const value of this.asArray()) {
        arr.push(value.asJSONValue());
      }
      return arr;
    }

    asJSONObject() {
      const obj = {};
      for (const [key, value] of this.asMap()) {
        obj[key] = value.asJSONPropertyValue();
      }
      return obj;
    }

    asJSONPropertyValue() {
      if (this.exists()) {
        return this.asJSONValue();
      } else {
        return undefined;
      }
    }

    //
    exists() {
      return this.value !== undefined;
    }

    isObject() {
      const {value} = this;
      return (
        typeof value === 'object' && value !== null &&
          value.constructor ===
          Object
      );
    }

    // OBJECTS
    keys(optional) {
      return Object.keys(this.asUnknownObject(optional));
    }

    asUnknownObject(optional = false) {
      this.declareDefinition(
        {
          type: 'object',
          default: undefined,
          required: !optional,
        },
      );

      if (optional === true && !this.exists()) {
        return {};
      }

      const {value} = this;
      if (!this.isObject()) {
        this.unexpected('Expected object');
        return {};
      }

      // @ts-ignore
      return Object.assign(
        {
        },
        value,
      );
    }

    asMap(optional, markUsed = true) {
      const value = this.asUnknownObject(optional);
      const map = new Map();
      for (const key in value) {
        if (markUsed) {
          this.markUsedProperty(key);
        }
        map.set(key, this.fork(key, value[key]));
      }
      return map;
    }

    // ARRAY-LIKES
    asSet(optional) {
      const arr = this.asArray(optional);
      const setVals = new Set();
      const set = new Set();

      for (let i = 0;
      i < arr.length;
      i++) {
        const consumer = arr[i];
        const value = consumer.asUnknown();
        if (setVals.has(value)) {
          continue;
        }

        setVals.add(value);
        set.add(consumer);
      }

      return set;
    }

    asPlainArray(optional = false) {
      this.declareDefinition(
        {
          type: 'array',
          default: undefined,
          required: !optional,
        },
      );

      if (optional === true && !this.exists()) {
        return [];
      }

      const {value} = this;

      if (!Array.isArray(value)) {
        this.unexpected('Expected array');
        return [];
      }

      return [...value];
    }

    asArray(optional) {
      const arr = this.asPlainArray(optional);

      return (
        arr.map(
          (val, index) => {
            return this.fork(index, val);
          },
        )
      );
    }

    asImplicitArray() {
      if (Array.isArray(this.asUnknown())) {
        return this.asArray();
      } else if (!this.exists()) {
        return [];
      } else {
        return [this];
      }
    }

    // DATES
    asDateOrVoid(def) {
      this.declareDefinition(
        {
          type: 'date',
          default: def,
          required: false,
        },
      );
      if (this.exists()) {
        return this._asDate(def);
      } else {
        return undefined;
      }
    }

    asDate(def) {
      this.declareDefinition(
        {
          type: 'date',
          default: def,
          required: true,
        },
      );
      return this._asDate(def);
    }

    _asDate(def) {
      const value = this.getValue(def);
      if (!(value instanceof Date)) {
        this.unexpected('Expected a date');
        return new Date();
      }
      return value;
    }

    // BOOLEANS
    asBooleanOrVoid(def) {
      this.declareDefinition(
        {
          type: 'boolean',
          default: def,
          required: false,
        },
      );
      if (this.exists()) {
        return this._asBoolean(def);
      } else {
        return undefined;
      }
    }

    asBoolean(def) {
      this.declareDefinition(
        {
          type: 'boolean',
          default: def,
          required: true,
        },
      );
      return this._asBoolean(def);
    }

    _asBoolean(def) {
      const value = this.getValue(def);
      if (typeof value !== 'boolean') {
        this.unexpected('Expected a boolean');
        return false;
      }
      return value;
    }

    // STRINGS
    asStringOrVoid(def) {
      this.declareDefinition(
        {
          type: 'string',
          default: def,
          required: false,
        },
      );

      if (this.exists()) {
        return this.asString(def);
      } else {
        return undefined;
      }
    }

    asString(def) {
      this.declareDefinition(
        {
          type: 'string',
          default: def,
          required: true,
        },
      );
      return this._asString(def);
    }

    _asString(def) {
      const value = this.getValue(def);
      if (typeof value !== 'string') {
        this.unexpected('Expected a string');
        return '';
      }
      return value;
    }

    asStringSet(validValues, def) {
      const value = this.asString(String(def));

      // @ts-ignore
      if (validValues.includes(value)) {
        // @ts-ignore
        return value;
      } else {
        this.unexpected(
          'Invalid value <emphasis>' +
          value +
          '</emphasis>',
          {
            target: 'value',
            advice: [
              {
                type: 'log',
                category: 'info',
                message: 'Possible values are',
              },
              {
                type: 'list',
                list: validValues.map((str) => String(str)),
              },
            ],
          },
        );
        return validValues[0];
      }
    }

    asStringSetOrVoid(validValues) {
      if (this.exists()) {
        return this.asStringSet(validValues);
      } else {
        return undefined;
      }
    }

    // BIGINT
    asBigIntOrVoid(def) {
      this.declareDefinition(
        {
          type: 'bigint',
          default: def,
          required: false,
        },
      );
      if (this.exists()) {
        return this._asBigInt(def);
      } else {
        return undefined;
      }
    }

    asBigInt(def) {
      this.declareDefinition(
        {
          type: 'bigint',
          default: def,
          required: true,
        },
      );
      return this._asBigInt(def);
    }

    _asBigInt(def) {
      const value = this.getValue(def);

      if (typeof value === 'number') {
        return BigInt(value);
      }

      if (typeof value === 'bigint') {
        return value;
      }

      this.unexpected('Expected a bigint');
      return BigInt('0');
    }

    // PATHS
    asURLFilePath() {
      const path = this.asUnknownFilePath();
      if (path.isURL()) {
        return path.assertURL();
      } else {
        this.unexpected('Expected a URL');
        return ___R$project$rome$$romejs$path$index_ts$createURLFilePath('unknown://').append(path);
      }
    }

    asUnknownFilePath() {
      return ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(this.asString());
    }

    asAbsoluteFilePath() {
      const path = this.asUnknownFilePath();
      if (path.isAbsolute()) {
        return path.assertAbsolute();
      } else {
        this.unexpected('Expected an absolute file path');
        return ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath('/').append(path);
      }
    }

    asRelativeFilePath() {
      const path = this.asUnknownFilePath();
      if (path.isRelative()) {
        return path.assertRelative();
      } else {
        this.unexpected('Expected a relative file path');
        return path.toExplicitRelative();
      }
    }

    asExplicitRelativeFilePath() {
      const path = this.asRelativeFilePath();

      if (path.isExplicitRelative()) {
        return path;
      } else {
        this.unexpected(
          'Expected an explicit relative file path. This is one that starts with <emphasis>./</emphasis> or <emphasis>../</emphasis>',
        );
        return path.toExplicitRelative();
      }
    }

    // NUMBER
    asNumberOrVoid(def) {
      this.declareDefinition(
        {
          type: 'number',
          default: def,
          required: false,
        },
      );

      if (this.exists()) {
        return this._asNumber(def);
      } else {
        return undefined;
      }
    }

    asZeroIndexedNumber() {
      return ___R$project$rome$$romejs$ob1$index_ts$coerce0(this.asNumber());
    }

    asOneIndexedNumber() {
      return ___R$project$rome$$romejs$ob1$index_ts$coerce1(this.asNumber());
    }

    asNumber(def) {
      this.declareDefinition(
        {
          type: 'number',
          default: def,
          required: true,
        },
      );
      return this._asNumber(def);
    }

    asNumberInRange(opts) {
      const num = this._asNumber(opts.default);

      const {min, max} = opts;

      this.declareDefinition(
        {
          type: 'number-range',
          default: opts.default,
          required: true,
          // @ts-ignore
          min,
          max,
        },
      );

      // Nice error message when both min and max are specified
      if (min !== undefined && max !== undefined && (num < min || num > max)) {
        this.unexpected('Expected number between ' +
        min +
        ' and ' +
        max);
        return num;
      }

      if (min !== undefined && num < min) {
        this.unexpected('Expected number higher than ' +
        min);
      }

      if (max !== undefined && num > max) {
        this.unexpected('Expected number lower than ' +
        max);
      }

      return num;
    }

    _asNumber(def) {
      const value = this.getValue(def);
      if (typeof value !== 'number') {
        this.unexpected('Expected a number');
        return 0;
      }
      return value;
    }

    //
    asUnknown() {
      return this.value;
    }

    // rome-suppress lint/noExplicitAny
    asAny() {
      return this.value;
    }
  }

  // project-rome/@romejs/consume/index.ts
const ___R$$priv$project$rome$$romejs$consume$index_ts$EMPTY_CONSUME_OPTIONS = {
    propertyMetadata: undefined,
    value: undefined,
    handleUnexpectedDiagnostic: undefined,
    onDefinition: undefined,
    filePath: undefined,
    objectPath: [],
    parent: undefined,
  };

  function ___R$project$rome$$romejs$consume$index_ts$consume(
    opts,
  ) {
    return (
      new ___R$project$rome$$romejs$consume$Consumer_ts$default(
        Object.assign(
          {
          },
          ___R$$priv$project$rome$$romejs$consume$index_ts$EMPTY_CONSUME_OPTIONS,
          opts,
        ),
      )
    );
  }

  function ___R$project$rome$$romejs$consume$index_ts$consumeUnknown(
    value,
    category,
  ) {
    return (
      new ___R$project$rome$$romejs$consume$Consumer_ts$default(
        Object.assign(
          {
          },
          ___R$$priv$project$rome$$romejs$consume$index_ts$EMPTY_CONSUME_OPTIONS,
          {
            context: {
              category,
            },
            value,
          },
        ),
      )
    );
  }

  // project-rome/@romejs/codec-json/stringify.ts
function ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$joinList(
    open,
    close,
    indent,
    items,
  ) {
    if (items.length === 0) {
      return open + close;
    }

    if (items.length === 1) {
      // Trim to remove indentation
      const first = items[0].trim();

      // We never want to place a comment in between braces because it will break for line comments

      // and look weird for blocks
      if (first[0] !== '/') {
        return open + first + close;
      }
    }

    return [open, ...items, indent + close].join('\n');
  }

  function ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyKey(key) {
    if (___R$project$rome$$romejs$codec$json$parse_ts$isValidWord(key)) {
      // A property key doesn't need quotes if it's a valid word
      return key;
    } else {
      return (
        ___R$project$rome$$romejs$string$escape$escapeString_ts$default(
          key,
          {
            quote: '"',
            ignoreWhitespaceEscapes: true,
            json: true,
          },
        )
      );
    }
  }

  function ___R$project$rome$$romejs$codec$json$stringify_ts$stringifyComments(
    indent,
    comments,
  ) {
    return (
      comments.map(
        (node) => {
          if (node.type === 'BlockComment') {
            return indent +
            '/*' +
            node.value +
            '*/';
          } else {
            // node.type === 'LineComment'
            return indent +
            '//' +
            node.value;
          }
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyPrimitives(value) {
    if (value === null) {
      return 'null';
    }

    // Coerce primitive objects to their primitive form, as specified in ECMA262 24.5.2.1
    if (value instanceof Number || value instanceof String ||
    value instanceof
    Boolean) {
      value = value.valueOf();
    }

    // Basic primitive types
    switch (typeof value) {
      case 'symbol':
      case 'function':
      case 'undefined':
        return 'null';

      case 'boolean':
        return value ? 'true' : 'false';

      case 'string':
        return (
          ___R$project$rome$$romejs$string$escape$escapeString_ts$default(
            value,
            {
              quote: '"',
              json: true,
              ignoreWhitespaceEscapes: true,
            },
          )
        );

      case 'bigint':
        // This is the actual V8 message lol
        throw new Error('Do not know how to serialize a BigInt');

      case 'number':
        return ___R$project$rome$$romejs$pretty$format$index_ts$formatNumber(value);
    }

    return undefined;
  }

  function ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$sortMapKeys(map) {
    return new Set(Array.from(map.keys()).sort(___R$project$rome$$romejs$string$utils$naturalCompare_ts$naturalCompare));
  }

  function ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$sortMap(map) {
    const sortedMap = new Map();
    const sortedKeys = ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$sortMapKeys(map);

    // Add any prioritized keys so they're before anything alphabetized
    for (const key of ___R$project$rome$$romejs$pretty$format$index_ts$PRIORITIZE_KEYS) {
      if (sortedKeys.has(key)) {
        sortedKeys.delete(key);

        const val = map.get(key);
        if (val === undefined) {
          throw new Error('Expected value');
        }

        sortedMap.set(key, val);
      }
    }

    // Now add the rest
    for (const key of sortedKeys) {
      const val = map.get(key);
      if (val === undefined) {
        throw new Error('Expected value');
      }

      sortedMap.set(key, val);
    }

    return sortedMap;
  }

  function ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$getComments(consumer, opts) {
    const comments = opts.comments.get(consumer.keyPath.join('.'));
    if (comments === undefined) {
      return (
        {
          inner: [],
          outer: [],
        }
      );
    } else {
      return comments;
    }
  }

  function ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyArray(consumer, info) {
    const {level, prevIndent, nextIndent, stack} = info;

    let buff = [];

    const arr = consumer.asArray();
    for (const consumer of arr) {
      // Add element comments
      const comments = ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$getComments(consumer, info).outer;
      buff = buff.concat(___R$project$rome$$romejs$codec$json$stringify_ts$stringifyComments(nextIndent, comments));

      // Add the actual element line
      const element = ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyConsumer(
        consumer,
        {
          comments: info.comments,
          isTopLevel: false,
          level: level + 1,
          stack,
        },
      );
      buff.push('' +
      nextIndent +
      element);
    }

    // Add inner comments
    const innerComments = ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$getComments(consumer, info).inner;
    buff = buff.concat(___R$project$rome$$romejs$codec$json$stringify_ts$stringifyComments(nextIndent, innerComments));

    return ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$joinList('[', ']', prevIndent, buff);
  }

  function ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyPlainObject(
    consumer,
    info,
  ) {
    const {level, prevIndent, stack, isTopLevel} = info;
    let {nextIndent} = info;

    // Must be an object if we failed all the other conditions
    let buff = [];
    const map = consumer.asMap();

    // Remove function, symbol, and undefined properties
    for (const [key, consumer] of map) {
      const value = consumer.asUnknown();

      if (typeof value === 'function' || typeof value === 'undefined' ||
      typeof value === 'symbol') {
        map.delete(key);
      }
    }

    let propLevel = level + 1;

    // We only want to increase the level for properties when we aren't at the top
    if (isTopLevel && level === 0) {
      propLevel = 0;
      nextIndent = '';
    }

    // Build properties
    for (const [key, consumer] of ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$sortMap(map)) {
      // Add property comments
      const comments = ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$getComments(consumer, info).outer;
      buff = buff.concat(___R$project$rome$$romejs$codec$json$stringify_ts$stringifyComments(nextIndent, comments));

      // Add the actual property line
      const propKey = ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyKey(key);
      const propValue = ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyConsumer(
        consumer,
        {
          comments: info.comments,
          isTopLevel: false,
          level: propLevel,
          stack,
        },
      );
      buff.push('' +
      nextIndent +
      propKey +
      ': ' +
      propValue);
    }

    // We track this so we know whether we can safely put everything at the top level

    // If we only have comments then there's no way the parser could infer it was originally an object
    const hasProps = buff.length > 0;

    // Add inner comments
    const innerComments = ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$getComments(consumer, info).inner;
    buff = buff.concat(___R$project$rome$$romejs$codec$json$stringify_ts$stringifyComments(nextIndent, innerComments));

    if (level === 0 && isTopLevel) {
      if (hasProps) {
        return buff.join('\n');
      } else if (buff.length > 0) {
        // Otherwise we just have a bunch of comments

        // Indent them correctly and just output it as a normal object
        buff =
          buff.map(
            (str) => {
              return '  ' +
              str;
            },
          );
      }
    }

    return ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$joinList('{', '}', prevIndent, buff);
  }

  function ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyObject(
    consumer,
    value,
    opts,
  ) {
    const {isTopLevel, level, stack} = opts;

    const info = {
      comments: opts.comments,
      isTopLevel,
      nextIndent: '  '.repeat(level + 1),
      prevIndent: level === 0 ? '' : '  '.repeat(level - 1),
      level,
      stack,
    };

    try {
      stack.add(value);

      if (Array.isArray(value) || value instanceof Set) {
        return ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyArray(consumer, info);
      }

      return ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyPlainObject(consumer, info);
    } finally {
      stack.delete(value);
    }
  }

  function ___R$project$rome$$romejs$codec$json$stringify_ts$stringifyRootConsumer(
    consumer,
    pathToComments,
  ) {
    const opts = {
      comments: pathToComments,
      isTopLevel: true,
      level: 0,
      stack: new Set(),
    };

    // Nothing else handles comments at the top level
    const inner = ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyConsumer(consumer, opts);
    const comments = ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$getComments(consumer, opts);
    const outer = ___R$project$rome$$romejs$codec$json$stringify_ts$stringifyComments('', comments.outer);

    return [...outer, inner].join('\n');
  }

  function ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyConsumer(consumer, opts) {
    const value = consumer.asUnknown();

    // Stringify primitives
    const asPrim = ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyPrimitives(value);
    if (asPrim !== undefined) {
      return asPrim;
    }

    // Check if we're already stringfying this value to prevent recursion
    if (opts.stack.has(value)) {
      throw new TypeError('Recursive');
    }

    return ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyObject(consumer, value, opts);
  }

  // project-rome/@romejs/codec-json/index.ts
function ___R$project$rome$$romejs$codec$json$index_ts$consumeJSON(opts) {
    return ___R$project$rome$$romejs$codec$json$index_ts$consumeJSONExtra(opts).consumer;
  }

  function ___R$project$rome$$romejs$codec$json$index_ts$consumeJSONExtra(opts) {
    const parser = ___R$project$rome$$romejs$codec$json$parse_ts$default(opts);
    const {value, context} = parser.parse();

    return (
      {
        hasExtensions: parser.hasExtensions,
        consumer: ___R$project$rome$$romejs$consume$index_ts$consume(
          {
            filePath: parser.path,
            context,
            objectPath: [],
            value,
            parent: undefined,
          },
        ),
        comments: parser.pathToComments,
      }
    );
  }

  function ___R$project$rome$$romejs$codec$json$index_ts$parseJSON(opts) {
    return ___R$project$rome$$romejs$codec$json$parse_ts$default(opts).parse().value;
  }

  function ___R$project$rome$$romejs$codec$json$index_ts$tokenizeJSON(opts) {
    return ___R$project$rome$$romejs$codec$json$parse_ts$default(opts).tokenizeAll();
  }

  function ___R$project$rome$$romejs$codec$json$index_ts$stringifyJSON(
    opts,
  ) {
    return ___R$project$rome$$romejs$codec$json$stringify_ts$stringifyRootConsumer(opts.consumer, opts.comments);
  }

  // project-rome/@romejs/v8/InspectorClient.ts
class ___R$project$rome$$romejs$v8$InspectorClient_ts$InspectorClientCloseError extends Error {
    constructor() {
      super('Inspector connection closed');
    }
  }

  class ___R$project$rome$$romejs$v8$InspectorClient_ts$default {
    constructor(socket) {
      this.socket = socket;
      this.id = 0;

      this.subscriptions = new Map();
      this.callbacks = new Map();

      this.alive = true;

      this.init();
    }

    end() {
      this.socket.end();
    }

    init() {
      const {socket} = this;

      socket.errorEvent.subscribe(
        (err) => {
          this.alive = false;
          for (const [, {reject}] of this.callbacks) {
            reject(err);
          }
          this.callbacks.clear();
          this.end();
        },
      );

      socket.endEvent.subscribe(
        () => {
          this.alive = false;
          for (const [, {reject}] of this.callbacks) {
            reject(new ___R$project$rome$$romejs$v8$InspectorClient_ts$InspectorClientCloseError());
          }
          this.callbacks.clear();
        },
      );

      socket.completeFrameEvent.subscribe(
        (frame) => {
          const json = frame.payload.toString();
          const data = ___R$project$rome$$romejs$codec$json$index_ts$consumeJSON(
            {
              input: json,
            },
          );

          // Message reply
          const id = data.get('id').asNumberOrVoid();
          if (id !== undefined) {
            const handler = this.callbacks.get(id);
            if (handler !== undefined) {
              if (data.has('error')) {
                const errorMessage = data.get('error').get('message').asString();
                handler.reject(new Error(errorMessage));
              } else {
                handler.resolve(data.get('result'));
              }
              this.callbacks.delete(id);
            }
            return undefined;
          }

          // Event
          const method = data.get('method').asStringOrVoid();
          if (method !== undefined) {
            const subs = this.subscriptions.get(method);
            if (subs !== undefined) {
              for (const sub of subs) {
                const {callback, once} = sub;
                callback(data.get('params'));
                if (once) {
                  subs.delete(sub);
                }
              }
            }
          }
        },
      );
    }

    subscribe(method, sub) {
      let subs = this.subscriptions.get(method);
      if (subs === undefined) {
        subs = new Set();
        this.subscriptions.set(method, subs);
      }
      subs.add(sub);
    }

    assertAlive() {
      if (!this.alive) {
        throw new Error('InspectorClient has no active socket');
      }
    }

    async wait(method) {
      return (
        new Promise(
          (resolve) => {
            this.assertAlive();
            this.subscribe(
              method,
              {
                once: true,
                callback: resolve,
              },
            );
          },
        )
      );
    }

    call(method, params) {
      const id = ++this.id;

      return (
        new Promise(
          (resolve, reject) => {
            this.assertAlive();
            this.callbacks.set(id, {resolve, reject});

            this.socket.sendJSON(
              {
                id,
                method,
                params,
              },
            );
          },
        )
      );
    }
  }

  // project-rome/@romejs/v8/CoverageCollector.ts
const ___R$$priv$project$rome$$romejs$v8$CoverageCollector_ts$inspector = require(
    'inspector',
  );
  function ___R$$priv$project$rome$$romejs$v8$CoverageCollector_ts$createCoverageFileStats(
    covered,
    uncovered,
  ) {
    const total = uncovered + covered;
    return (
      {
        uncovered,
        covered,
        total,
        percent: total === 0 ? 100 : 100 / total * covered,
      }
    );
  }

  class ___R$project$rome$$romejs$v8$CoverageCollector_ts$default {
    constructor() {
      this.sourceMaps = new Map();
    }

    addSourceMap(filename, code, map) {
      this.sourceMaps.set(
        filename,
        {
          ranges: [],
          map,
          code,
        },
      );
    }

    addCoverage(entries) {
      for (const entry of entries) {
        const filename = ___R$project$rome$$romejs$v8$utils_ts$urlToFilename(entry.url);

        const data = this.sourceMaps.get(filename);
        if (data === undefined) {
          continue;
        }

        for (const {ranges, functionName, isBlockCoverage} of entry.functions) {
          data.ranges =
            data.ranges.concat(
              ranges.map(
                (range) => {
                  let kind = 'expression';
                  if (functionName !== '') {
                    kind = 'function';
                  } else if (isBlockCoverage) {
                    kind = 'branch';
                  }

                  return (
                    Object.assign(
                      {
                        kind,
                      },
                      range,
                    )
                  );
                },
              ),
            );
        }
      }
    }

    generate() {
      const insertedLocs = new Map();
      const locs = [];

      for (const data of this.sourceMaps.values()) {
        const {ranges, code, map} = data;

        // Turn an index into a position in the compiled source
        let line = ___R$project$rome$$romejs$ob1$index_ts$number1;
        let column = ___R$project$rome$$romejs$ob1$index_ts$number0;
        let index = ___R$project$rome$$romejs$ob1$index_ts$number0;
        const indexCache = new Map();
        function findIndex(newIndex) {
          const cached = indexCache.get(newIndex);
          if (cached !== undefined) {
            return cached;
          }

          if (newIndex < index) {
            throw new Error('Expected newIndex(' +
            newIndex +
            ') >= index(' +
            index +
            ')');
          }

          if (___R$project$rome$$romejs$ob1$index_ts$get0(newIndex) > code.length) {
            throw (
              new Error(
                'Expected newIndex(' +
                newIndex +
                ') <= code.length(' +
                code.length +
                ')',
              )
            );
          }

          while (index < newIndex) {
            const char = code[___R$project$rome$$romejs$ob1$index_ts$get0(index)];
            if (char === '\n') {
              line = ___R$project$rome$$romejs$ob1$index_ts$inc(line);
              column = ___R$project$rome$$romejs$ob1$index_ts$number0;
            } else {
              column = ___R$project$rome$$romejs$ob1$index_ts$inc(column);
            }
            index = ___R$project$rome$$romejs$ob1$index_ts$inc(index);
          }

          const pos = {
            index: newIndex,
            line,
            column,
          };
          indexCache.set(newIndex, pos);
          return pos;
        }

        // Prefetch all sorted indexes
        const offsets = [];
        for (const {startOffset, endOffset} of ranges) {
          offsets.push(___R$project$rome$$romejs$ob1$index_ts$coerce0(startOffset));
          offsets.push(___R$project$rome$$romejs$ob1$index_ts$coerce0(endOffset));
        }
        offsets.sort((a, b) => ___R$project$rome$$romejs$ob1$index_ts$get0(a) - ___R$project$rome$$romejs$ob1$index_ts$get0(b));
        for (const index of offsets) {
          findIndex(index);
        }

        //
        const sourceMap = new ___R$project$rome$$romejs$codec$source$map$SourceMapConsumer_ts$default(map);
        for (const {kind, startOffset, endOffset, count} of ranges) {
          const originalStart = findIndex(___R$project$rome$$romejs$ob1$index_ts$coerce0(startOffset));
          const originalEnd = findIndex(___R$project$rome$$romejs$ob1$index_ts$coerce0(endOffset));

          const sourceStart = sourceMap.approxOriginalPositionFor(
            originalStart.line,
            originalStart.column,
          );
          if (sourceStart === undefined) {
            continue;
          }

          const sourceEnd = sourceMap.approxOriginalPositionFor(
            originalEnd.line,
            originalEnd.column,
          );
          if (sourceEnd === undefined) {
            continue;
          }

          if (sourceStart.source !== sourceEnd.source) {
            throw (
              new Error(
                'Expected the same source for start and end: ' +
                sourceStart.source +
                ' !== ' +
                sourceEnd.source,
              )
            );
          }

          const key = sourceStart.source +
          ':' +
          String(startOffset) +
          '-' +
          String(
            endOffset,
          );
          const alreadyInserted = insertedLocs.get(key);
          if (alreadyInserted !== undefined) {
            alreadyInserted.count += count;
            continue;
          }

          const loc = {
            kind,
            filename: sourceStart.source,
            count,
            start: {
              index: ___R$project$rome$$romejs$ob1$index_ts$coerce0(startOffset),
              line: sourceStart.line,
              column: sourceStart.column,
            },
            end: {
              index: ___R$project$rome$$romejs$ob1$index_ts$coerce0(endOffset),
              line: sourceEnd.line,
              column: sourceEnd.column,
            },
          };
          insertedLocs.set(key, loc);
          locs.push(loc);
        }
      }

      // Assemble files
      const rangesByFile = new Map();
      for (const loc of locs) {
        let ranges = rangesByFile.get(loc.filename);
        if (ranges === undefined) {
          ranges = [];
          rangesByFile.set(loc.filename, ranges);
        }
        ranges.push(loc);
      }

      const files = [];
      for (const [filename, ranges] of rangesByFile) {
        const coveredLines = new Set();
        const uncoveredLines = new Set();

        let uncoveredFunctions = new Set();
        let coveredFunctions = new Set();
        let uncoveredBranches = new Set();
        let coveredBranches = new Set();

        for (const {count, kind, start, end} of ranges) {
          // Fill in lines
          for (let i = start.line;
          i <= end.line;
          i = ___R$project$rome$$romejs$ob1$index_ts$inc(i)) {
            if (count === 0) {
              uncoveredLines.add(i);
            } else {
              coveredLines.add(i);
            }
          }

          // Mark covered kind
          if (kind === 'function') {
            if (count === 0) {
              uncoveredBranches.add(start.index);
              uncoveredFunctions.add(start.line);
            } else {
              coveredFunctions.add(start.line);
              coveredBranches.add(start.index);
            }
          } else if (kind === 'branch') {
            if (count === 0) {
              uncoveredBranches.add(start.index);
            } else {
              coveredBranches.add(start.index);
            }
          }
        }

        for (const line of coveredLines) {
          uncoveredLines.delete(line);
        }

        for (const index of coveredBranches) {
          uncoveredBranches.delete(index);
        }

        for (const index of coveredFunctions) {
          uncoveredFunctions.delete(index);
        }

        // No point showing fully covered files
        if (uncoveredLines.size === 0 && uncoveredBranches.size === 0 &&
          uncoveredFunctions.size === 0) {
          continue;
        }

        files.push(
          {
            filename,
            lines: ___R$$priv$project$rome$$romejs$v8$CoverageCollector_ts$createCoverageFileStats(coveredLines.size, uncoveredLines.size),
            branches: ___R$$priv$project$rome$$romejs$v8$CoverageCollector_ts$createCoverageFileStats(
              coveredBranches.size,
              uncoveredBranches.size,
            ),
            functions: ___R$$priv$project$rome$$romejs$v8$CoverageCollector_ts$createCoverageFileStats(
              coveredFunctions.size,
              uncoveredFunctions.size,
            ),
          },
        );
      }
      return files;
    }
  }

  // project-rome/@romejs/v8/index.ts
const ___R$project$rome$$romejs$v8$index_ts$sourceMapManager = ___R$project$rome$$romejs$v8$sourceMapManager_ts

  // project-rome/@romejs/events/Bridge.ts
class ___R$project$rome$$romejs$events$Bridge_ts$default {
    constructor(opts) {
      this.errorTransports = new Map();

      this.alive = true;
      this.type = opts.type;
      this.opts = opts;

      this.messageIdCounter = 0;
      this.events = new Map();

      this.hasHandshook = false;
      this.handshakeEvent = new ___R$project$rome$$romejs$events$Event_ts$default({name: 'Bridge.handshake'});
      this.endEvent = new ___R$project$rome$$romejs$events$Event_ts$default({name: 'Bridge.end', serial: true});
      this.updatedListenersEvent =
        new ___R$project$rome$$romejs$events$Event_ts$default(
          {
            name: 'Bridge.updatedListenersEvent',
          },
        );

      // A Set of event names that are being listened to on the other end

      // We track this to avoid sending over subscriptions that aren't needed
      this.listeners = new Set();

      this.prioritizedResponses = new Set();
      this.deprioritizedResponseQueue = [];

      this.postHandshakeQueue = [];

      this.heartbeatEvent =
        this.createEvent(
          {
            name: 'Bridge.heartbeat',
            direction: 'server<->client',
          },
        );
      this.heartbeatEvent.subscribe(
        () => {
          return undefined;
        },
      );

      this.clear();
      this.init();
    }

    attachEndSubscriptionRemoval(subscription) {
      this.endEvent.subscribe(
        () => {
          subscription.unsubscribe();
        },
      );
    }

    monitorHeartbeat(timeout, onExceeded) {
      this.heartbeatTimeout =
        setTimeout(
          async () => {
            try {
              await this.heartbeatEvent.call(undefined, {timeout});
              this.monitorHeartbeat(timeout, onExceeded);
            } catch (err) {
              if (err instanceof ___R$project$rome$$romejs$events$BridgeError_ts$default) {
                if (this.alive) {
                  onExceeded();
                }
              } else {
                throw err;
              }
            }
          },
          1000,
        );
    }

    clearPrioritization(id) {
      this.prioritizedResponses.delete(id);

      if (this.prioritizedResponses.size === 0) {
        for (const msg of this.deprioritizedResponseQueue) {
          this.sendMessage(msg);
        }
        this.deprioritizedResponseQueue = [];
      }
    }

    async handshake(opts = {}) {
      if (this.hasHandshook) {
        throw new Error('Already performed handshake');
      }

      const {timeout, second = false} = opts;

      // Send a handshake in case we were the first
      if (!second) {
        this.sendMessage(
          {
            type: 'handshake',
            first: true,
            subscriptions: this.getSubscriptions(),
          },
        );
      }

      // Wait for a handshake from the other end
      const res = await this.handshakeEvent.wait(undefined, timeout);

      if (res.first) {
        // Send the handshake again, as it wouldn't have received the first
        this.sendMessage(
          {
            type: 'handshake',
            first: false,
            subscriptions: this.getSubscriptions(),
          },
        );
      }

      this.receivedSubscriptions(res.subscriptions);

      this.hasHandshook = true;

      for (const msg of this.postHandshakeQueue) {
        this.sendMessage(msg);
      }
      this.postHandshakeQueue = [];
    }

    getSubscriptions() {
      const names = [];
      for (const event of this.events.values()) {
        if (event.hasSubscriptions()) {
          names.push(event.name);
        }
      }
      return names;
    }

    sendSubscriptions() {
      if (!this.hasHandshook) {
        // If we haven't had the handshake then no point sending them. They'll be sent all at once after
        return undefined;
      }

      // Notify the other side of what we're currently subscribed to

      // We send over a list of all of our subscriptions every time

      // This is fine since we don't change subscriptions often and they aren't very large

      // If we have a lot of subscriptions, or are changing them a lot in the future then this could be optimized
      this.sendMessage(
        {
          type: 'subscriptions',
          names: this.getSubscriptions(),
        },
      );
    }

    receivedSubscriptions(names) {
      this.listeners = new Set(names);
      this.updatedListenersEvent.send(this.listeners);
    }

    init() {
      // This method can be overridden by subclasses, it allows you to add logic such as error serializers
    }

    clear() {
      for (const [, event] of this.events) {
        event.clear();
      }
    }

    getNextMessageId() {
      return ++this.messageIdCounter;
    }

    createEvent(opts) {
      if (this.events.has(opts.name)) {
        throw new Error('Duplicate event');
      }

      const event = new ___R$project$rome$$romejs$events$BridgeEvent_ts$default(opts, this);
      this.events.set(opts.name, event);
      return event;
    }

    //# Connection death
    assertAlive() {
      if (this.alive === false) {
        throw new Error('Bridge is dead');
      }
    }

    endWithError(err) {
      if (this.alive === false) {
        return undefined;
      }

      this.alive = false;

      // Reject any pending requests
      for (const [, event] of this.events) {
        event.end(err);
      }
      this.clear();

      // Clear any currently processing heartbeat
      if (this.heartbeatTimeout !== undefined) {
        clearTimeout(this.heartbeatTimeout);
      }

      // Notify listeners
      this.endEvent.callSync(err);
    }

    end(message = 'Connection died') {
      this.endWithError(new ___R$project$rome$$romejs$events$BridgeError_ts$default(message, this));
    }

    //# Error serialization
    buildError(value, data) {
      const transport = this.errorTransports.get(value.name);
      if (transport === undefined) {
        return ___R$project$rome$$romejs$v8$errors_ts$createErrorFromStructure(value);
      } else {
        return transport.hydrate(value, data);
      }
    }

    buildErrorResponse(id, event, errRaw) {
      // Just in case something that wasn't an Error was thrown
      const err = errRaw instanceof Error ? errRaw : new Error(String(errRaw));

      // Fetch some metadata for hydration
      const tranport = this.errorTransports.get(err.name);
      const metadata = tranport === undefined
        ? {} : tranport.serialize(err);

      return (
        {
          id,
          event,
          type: 'response',
          responseStatus: 'error',
          value: ___R$project$rome$$romejs$v8$errors_ts$getErrorStructure(err),
          metadata,
        }
      );
    }

    addErrorTransport(name, transport) {
      this.errorTransports.set(name, transport);
    }

    //# Message transmission
    sendMessage(msg) {
      // There's no try-catch gated around sendMessage because the call stack here will include some other error handler

      // We need to be specific for handleMessage because it could come from anywhere

      if (msg.type !== 'handshake' && !this.hasHandshook) {
        this.postHandshakeQueue.push(msg);
        return;
      }

      this.assertAlive();

      if (msg.type === 'response') {
        if (this.prioritizedResponses.size > 0 &&
          !this.prioritizedResponses.has(
            msg.id,
          )) {
          this.deprioritizedResponseQueue.push(msg);
          return;
        }

        if (this.prioritizedResponses.has(msg.id)) {
          this.clearPrioritization(msg.id);
        }
      }

      const {opts} = this;
      opts.sendMessage(msg);
      if (opts.onSendMessage !== undefined) {
        opts.onSendMessage(msg);
      }
    }

    handleJSONMessage(str) {
      try {
        const data = JSON.parse(str);
        this.handleMessage(data);
      } catch (err) {
        if (err instanceof SyntaxError) {
          this.endWithError(
            new ___R$project$rome$$romejs$events$BridgeError_ts$default(
              'Error parsing message JSON: ' +
              err.message,
              this,
            ),
          );
        } else {
          this.endWithError(err);
        }
      }
    }

    handleMessage(msg) {
      try {
        this.assertAlive();

        if (msg.type === 'handshake') {
          this.handshakeEvent.send(
            {
              subscriptions: msg.subscriptions,
              first: msg.first,
            },
          );
        }

        if (msg.type === 'subscriptions') {
          this.receivedSubscriptions(msg.names);
        }

        if (msg.type === 'request') {
          this.handleMessageRequest(msg);
        }

        if (msg.type === 'response') {
          this.handleMessageResponse(msg);
        }
      } catch (err) {
        this.endWithError(err);
      }
    }

    handleMessageResponse(data) {
      const {id, event} = data;
      if (id === undefined) {
        throw new Error('Expected id');
      }
      if (event === undefined) {
        throw new Error('Expected event');
      }

      const eventHandler = this.events.get(event);
      if (eventHandler === undefined) {
        throw new Error('Unknown event');
      }

      eventHandler.dispatchResponse(id, data);
    }

    handleMessageRequest(data) {
      const {id, event, param, priority} = data;
      if (event === undefined) {
        throw new Error('Expected event in message request but received none');
      }

      const eventHandler = this.events.get(event);
      if (eventHandler === undefined) {
        throw new Error('Unknown event ' +
        event);
      }

      if (id === undefined) {
        // We don't need to do anything with the return value of this since

        // there's nothing on the other end to catch it
        eventHandler.dispatchRequest(param);
      } else {
        if (priority) {
          this.prioritizedResponses.add(id);
        }

        eventHandler.dispatchRequest(param).then(
          (value) => {
            this.sendMessage(
              {
                event,
                id,
                type: 'response',
                responseStatus: 'success',
                value,
              },
            );
          },
        ).catch(
          (err) => {
            this.sendMessage(this.buildErrorResponse(id, event, err));
          },
        ).catch(
          (err) => this.endWithError(err),
        );
      }
    }
  }

  // project-rome/@romejs/events/bridgeCreators.ts
const ___R$project$rome$$romejs$events$bridgeCreators_ts = {
    createBridgeFromWebSocketInterface: ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromWebSocketInterface,
    createBridgeFromBrowserWebSocket: ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromBrowserWebSocket,
    createBridgeFromSocket: ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromSocket,
    createBridgeFromLocal: ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromLocal,
    createBridgeFromChildProcess: ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromChildProcess,
    createBridgeFromParentProcess: ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromParentProcess,
  };
  const ___R$$priv$project$rome$$romejs$events$bridgeCreators_ts$SOCKET_LENGTH = /^(\d+):/;

  // JSON.stringify but throw on bad data types

  // Most likely slower... But safer and our data structures are usually fairly shallow
  function ___R$$priv$project$rome$$romejs$events$bridgeCreators_ts$stringify(obj) {
    return (
      JSON.stringify(
        obj,
        (key, value) => {
          const type = typeof value;

          if (value === undefined || value === null) {
            return value;
          }

          // Primitives
          if (type === 'string' || type === 'number' || type === 'boolean') {
            return value;
          }

          // Arrays and plain objects
          if (Array.isArray(value) || value.constructor === Object) {
            return value;
          }

          throw (
            new Error(
              'Illegal data type not allowed in JSON: ' +
              ___R$project$rome$$romejs$pretty$format$index_ts$default(value) +
              ' in ' +
              ___R$project$rome$$romejs$pretty$format$index_ts$default(
                obj,
              ),
            )
          );
        },
      )
    );
  }

  function ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromWebSocketInterface(
    CustomBridge,
    inf,
    opts,
  ) {
    const bridge = new CustomBridge(
      Object.assign(
        {
        },
        opts,
        {
          sendMessage: (data) => {
            inf.sendJSON(data);
          },
        },
      ),
    );

    const {socket} = inf;

    bridge.endEvent.subscribe(
      () => {
        socket.end();
      },
    );

    inf.completeFrameEvent.subscribe(
      (frame) => {
        const json = frame.payload.toString();
        bridge.handleJSONMessage(json);
      },
    );

    socket.on(
      'error',
      (err) => {
        bridge.endWithError(err);
      },
    );

    socket.on(
      'end',
      () => {
        bridge.end('RPC WebSocket died');
      },
    );

    return bridge;
  }

  function ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromBrowserWebSocket(
    CustomBridge,
    socket,
    opts,
  ) {
    const bridge = new CustomBridge(
      Object.assign(
        {
        },
        opts,
        {
          sendMessage: (data) => {
            socket.send(___R$$priv$project$rome$$romejs$events$bridgeCreators_ts$stringify(data));
          },
        },
      ),
    );

    bridge.endEvent.subscribe(
      () => {
        socket.close();
      },
    );

    socket.onmessage =
      function(event) {
        bridge.handleJSONMessage(String(event.data));
      };

    socket.onclose =
      () => {
        bridge.end('RPC WebSocket disconnected');
      };

    return bridge;
  }

  function ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromSocket(
    CustomBridge,
    socket,
    opts,
  ) {
    const bridge = new CustomBridge(
      Object.assign(
        {
        },
        opts,
        {
          sendMessage: (data) => {
            const serialized = ___R$$priv$project$rome$$romejs$events$bridgeCreators_ts$stringify(data);
            socket.write(serialized.length +
            ':' +
            serialized);
          },
        },
      ),
    );

    bridge.endEvent.subscribe(
      () => {
        socket.end();
      },
    );

    // buffer data and parse message on newline
    let buff = '';
    let messageLength = 0;
    socket.setEncoding('utf8');
    function checkForPossibleMessage() {
      // we're awaiting a message and have received it
      if (messageLength > 0 && buff.length >= messageLength) {
        // retrieve the message from the buffer
        const msg = buff.slice(0, messageLength);

        // clear the next message length and remove the current message from the buffer
        buff = buff.slice(messageLength);
        messageLength = 0;

        // parse it
        bridge.handleJSONMessage(msg);
      }

      // if we aren't waiting for a message and we have a buffer then check for an incoming message
      if (messageLength === 0 && buff !== '') {
        // check if we've received the starting info of a message
        const possibleLength = buff.match(___R$$priv$project$rome$$romejs$events$bridgeCreators_ts$SOCKET_LENGTH);
        if (possibleLength != null) {
          // get the message length
          messageLength = Number(possibleLength[1]);

          // remove the length designator
          buff = buff.slice(possibleLength[0].length);

          // check if we have a full message
          checkForPossibleMessage();
        }
      }
    }

    socket.on(
      'data',
      (chunk) => {
        buff += chunk;
        checkForPossibleMessage();
      },
    );

    socket.on(
      'error',
      (err) => {
        bridge.endWithError(err);
      },
    );

    socket.on(
      'end',
      () => {
        bridge.end('Socket disconnected');
      },
    );

    return bridge;
  }

  function ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromLocal(
    CustomBridge,
    opts,
  ) {
    const bridge = new CustomBridge(
      Object.assign(
        {
        },
        opts,
        {
          type: 'server&client',
          sendMessage: (msg) => {
            bridge.handleMessage(msg);
          },
        },
      ),
    );

    return bridge;
  }

  function ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromChildProcess(
    CustomBridge,
    proc,
    opts,
  ) {
    const bridge = new CustomBridge(
      Object.assign(
        {
        },
        opts,
        {
          sendMessage: (data) => {
            proc.send(data);
          },
        },
      ),
    );

    bridge.endEvent.subscribe(
      () => {
        proc.kill();
      },
    );

    proc.on(
      'error',
      (err) => {
        bridge.endWithError(err);
      },
    );

    proc.on(
      'message',
      (msg) => {
        bridge.handleMessage((msg));
      },
    );

    // Catch process dying and reject any requests in flight
    proc.on(
      'close',
      () => {
        bridge.end('RPC child process died');
      },
    );

    return bridge;
  }

  function ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromParentProcess(
    CustomBridge,
    opts,
  ) {
    const bridge = new CustomBridge(
      Object.assign(
        {
        },
        opts,
        {
          sendMessage: (data) => {
            if (typeof process.send === 'function') {
              process.send(data);
            } else {
              throw new Error('No process.send found');
            }
          },
        },
      ),
    );

    process.on(
      'message',
      (data) => {
        bridge.handleMessage(data);
      },
    );

    // I doubt any of these will have time to dispatch but for consistency sake...
    process.on(
      'exit',
      () => {
        bridge.end('RPC self process died');
      },
    );

    return bridge;
  }

  // project-rome/@romejs/events/types.ts
const ___R$project$rome$$romejs$events$types_ts = {
  };

  // project-rome/@romejs/events/index.ts


  // project-rome/@romejs/cli-reporter/Reporter.ts
const ___R$$priv$project$rome$$romejs$cli$reporter$Reporter_ts$stream = require(
    'stream',
  );
  const ___R$$priv$project$rome$$romejs$cli$reporter$Reporter_ts$readline = require(
    'readline',
  );

  let ___R$$priv$project$rome$$romejs$cli$reporter$Reporter_ts$remoteProgressIdCounter = 0;

  const ___R$$priv$project$rome$$romejs$cli$reporter$Reporter_ts$INDENT = '  ';

  class ___R$project$rome$$romejs$cli$reporter$Reporter_ts$default {
    constructor(opts = {}) {
      this.wrapCallback =
        (callback) => {
          const {wrapperFactory} = this;
          if (wrapperFactory === undefined) {
            return callback;
          } else {
            return wrapperFactory(callback);
          }
        };
      this.programName = opts.programName === undefined ? 'rome' : opts.programName;
      this.programVersion = opts.programVersion;

      this.noProgress = process.env.CI === '1';
      this.isVerbose = Boolean(opts.verbose);

      this.silent = opts.silent === true;
      this.startTime = opts.startTime === undefined ? Date.now() : opts.startTime;
      this.hasClearScreen =
        opts.hasClearScreen === undefined
          ? true : opts.hasClearScreen;
      this.activeElements = new Set();
      this.indentLevel = 0;
      this.indentString = '';
      this.enabled = opts.disabled === true ? 0 : 1;
      this.markupOptions =
        opts.markupOptions === undefined
          ? {} : opts.markupOptions;
      this.hasSpacer = false;
      this.shouldRedirectOutToErr = false;
      this.stdin = opts.stdin;

      this.wrapperFactory = opts.wrapperFactory;

      this.remoteClientProgressBars = new Map();
      this.remoteServerProgressBars = new Map();

      this.sendRemoteServerMessage =
        new ___R$project$rome$$romejs$events$Event_ts$default(
          {
            name: 'sendRemoteServerMessage',
          },
        );
      this.sendRemoteClientMessage =
        new ___R$project$rome$$romejs$events$Event_ts$default(
          {
            name: 'sendRemoteClientMessage',
          },
        );

      this.isRemote = opts.useRemoteProgressBars === true;

      this.outStreams = new Set();
      this.errStreams = new Set();
      this.streams = new Set();

      if (opts.streams !== undefined) {
        for (const stream of opts.streams) {
          this.addStream(stream);
        }
      }
    }

    attachStdoutStreams(stdout, stderr, format) {
      const columns = stdout === undefined || stdout.columns === undefined
        ? ___R$project$rome$$romejs$cli$reporter$Reporter_ts$default.DEFAULT_COLUMNS : stdout.columns;

      if (format === undefined) {
        format = stdout !== undefined && stdout.isTTY === true ? 'ansi' : 'none';
      }

      const columnsUpdated = new ___R$project$rome$$romejs$events$Event_ts$default(
        {
          name: 'columnsUpdated',
        },
      );

      const outStream = {
        type: 'out',
        format,
        columns,
        write(chunk) {
          if (stdout !== undefined) {
            stdout.write(chunk);
          }
        },

        teardown() {},
      };

      const errStream = Object.assign(
        {
        },
        outStream,
        {
          type: 'error',
          write(chunk) {
            if (stderr !== undefined) {
              stderr.write(chunk);
            }
          },
        },
      );

      // Watch for resizing
      if (outStream.format === 'ansi' && stdout !== undefined) {
        const onStdoutResize = () => {
          if (stdout !== undefined && stdout.columns !== undefined) {
            const {columns} = stdout;
            columnsUpdated.send(columns);
            this.setStreamColumns([outStream, errStream], columns);
          }
        };

        outStream.teardown =
          () => {
            stdout.off('resize', onStdoutResize);
          };

        stdout.on('resize', onStdoutResize);
      }

      this.addStream(outStream);
      this.addStream(errStream);

      return (
        {
          columnsUpdated,
          stdout: outStream,
          stderr: errStream,
        }
      );
    }

    static fromProcess(opts = {}) {
      const reporter = new ___R$project$rome$$romejs$cli$reporter$Reporter_ts$default(
        Object.assign(
          {
          },
          opts,
          {
            markupOptions: Object.assign(
              {
                cwd: ___R$project$rome$$romejs$path$index_ts$CWD_PATH,
              },
              opts.markupOptions,
            ),
          },
        ),
      );

      reporter.attachStdoutStreams(process.stdout, process.stderr);

      return reporter;
    }

    processRemoteClientMessage(msg) {
      if (msg.type === 'PROGRESS_CREATE') {
        this.remoteClientProgressBars.set(
          msg.id,
          this.progressLocal(
            msg.opts,
            () => {
              this.sendRemoteServerMessage.call(
                {
                  type: 'ENDED',
                  id: msg.id,
                },
              );
            },
          ),
        );
        return;
      }

      let bar = this.remoteClientProgressBars.get(msg.id);
      if (bar === undefined) {
        throw (
          new Error(
            'Remote reporter message for progress bar ' +
            msg.id +
            ' that does not exist',
          )
        );
      }

      bar.processRemoteClientMessage(msg);

      if (msg.type === 'PROGRESS_END') {
        this.remoteClientProgressBars.delete(msg.id);
      }
    }

    receivedRemoteServerMessage(msg) {
      // Currently the only message a remote Reporter can send is that it has ended
      switch (msg.type) {
        case 'ENDED':
          const progress = this.remoteServerProgressBars.get(msg.id);
          if (progress !== undefined) {
            progress.end();
          }
      }
    }

    getMessagePrefix(stream) {
      stream;
      return '';
    }

    normalizeMessage(stream, tty, opts) {
      let msg = stream.format !== 'none' || opts.nonTTY === undefined
        ? tty : opts.nonTTY;

      if (opts.noPrefix !== true) {
        msg = this.getMessagePrefix(stream) + msg;
      }

      // Don't indent if there is no indent, or the message is empty
      const {indentString} = this;
      if (indentString !== '' && msg !== '') {
        // Indent each line, leaving out the indentation for empty lines
        msg = indentString + msg.replace(/\n([^\n])/g, '\n' +
        indentString +
        '$1');
      }

      // Track if there's going to be a completely empty line
      this.hasSpacer = msg === '' || msg[msg.length - 1] === '\n';

      return msg;
    }

    redirectOutToErr(should) {
      this.shouldRedirectOutToErr = should;
    }

    setStreamColumns(streams, columns) {
      for (const stream of streams) {
        if (!this.streams.has(stream)) {
          throw (
            new Error(
              'Trying to setStreamColumns on a stream that isn\'t attached to this Reporter',
            )
          );
        }

        stream.columns = columns;
      }

      for (const elem of this.activeElements) {
        elem.render();
      }
    }

    addStream(stream) {
      if (this.silent) {
        return;
      }

      this.streams.add(stream);

      if (stream.type === 'error' || stream.type === 'all') {
        this.errStreams.add(stream);
      }

      if (stream.type === 'out' || stream.type === 'all') {
        this.outStreams.add(stream);
      }
    }

    removeStream(stream) {
      if (stream.teardown !== undefined) {
        stream.teardown();
      }
      this.streams.delete(stream);
      this.outStreams.delete(stream);
      this.errStreams.delete(stream);
    }

    //# Stdin
    getStdin() {
      const {stdin} = this;
      if (stdin === undefined) {
        throw new Error('This operation expected a stdin but we have none');
      }
      return stdin;
    }

    async question(message, {hint, default: def = '', yes = false} = {}) {
      if (yes) {
        return def;
      }

      const stdin = this.getStdin();

      const origPrompt = '<brightBlack emphasis>?</brightBlack> <emphasis>' +
      message +
      '</emphasis>';
      let prompt = origPrompt;
      if (hint !== undefined) {
        prompt += ' <dim>' +
        hint +
        '</dim>';
      }
      if (def !== '') {
        prompt += ' (' +
        def +
        ')';
      }
      prompt += ': ';
      this.logAll(
        prompt,
        {
          newline: false,
        },
      );

      const rl = ___R$$priv$project$rome$$romejs$cli$reporter$Reporter_ts$readline.createInterface(
        {
          input: stdin,
          output: new ___R$$priv$project$rome$$romejs$cli$reporter$Reporter_ts$stream.Writable(
            {
              write: (chunk, encoding, callback) => {
                this.writeAll(chunk);
                callback();
              },
            },
          ),
          terminal: false,
        },
      );

      return (
        new Promise(
          (resolve) => {
            rl.on(
              'line',
              (line) => {
                rl.close();

                const normalized = line === '' ? def : line;

                // Replace initial prompt
                this.writeAll(___R$project$rome$$romejs$string$ansi$escapes_ts$escapes.cursorUp());
                this.writeAll(___R$project$rome$$romejs$string$ansi$escapes_ts$escapes.eraseLine);

                let prompt = origPrompt;
                prompt += ': ';
                if (normalized === '') {
                  prompt += '<dim>empty</dim>';
                } else {
                  prompt += normalized;
                }
                this.logAll(prompt);

                resolve(normalized);
              },
            );
          },
        )
      );
    }

    async questionValidate(message, validate, options = {}) {
      while (true) {
        let res;

        await this.question(
          message,
          Object.assign(
            {
            },
            options,
            {
              normalize: (value) => {
                res = validate(value);

                if (res[0] === true && typeof res[1] === 'string') {
                  return res[1];
                } else {
                  return value;
                }
              },
            },
          ),
        );

        if (res === undefined) {
          throw new Error('normalize should have been called');
        }

        if (res[0] === false) {
          this.error(res[1]);
          continue;
        } else {
          return res[1];
        }
      }
    }

    async radioConfirm(message) {
      const answer = await this.radio(
        message,
        {
          options: {
            yes: {
              label: 'Yes',
            },
            no: {
              label: 'No',
            },
          },
        },
      );
      return answer === 'yes';
    }

    async radio(message, arg) {
      const set = await this.select(message, Object.assign(
        {
        },
        arg,
        {
          radio: true,
        },
      ));

      // Should always have at least one element
      return Array.from(set)[0];
    }

    async select(message, {
      options,
      defaults = [],
      radio = false,
      yes = false,
    }) {
      const optionNames = Object.keys(options);
      const optionCount = optionNames.length;
      if (optionCount === 0) {
        return new Set();
      }

      if (yes) {
        return new Set(defaults);
      }

      let prompt = '<brightBlack>\u276f</brightBlack> <emphasis>' +
      message +
      '</emphasis>';
      this.logAll(prompt);

      if (radio) {
        this.info(
          'Use arrow keys and then <emphasis>enter</emphasis> to select an option',
        );
      } else {
        this.info(
          'Use arrow keys and <emphasis>space</emphasis> to select or deselect options and then <emphasis>enter</emphasis> to confirm',
        );
      }

      const selectedOptions = new Set(defaults);
      let activeOption = 0;

      // Set first option if this is a radio
      if (radio && !defaults.length) {
        selectedOptions.add(optionNames[0]);
      }

      function boundActive() {
        activeOption = Math.min(activeOption, optionCount - 1);
        activeOption = Math.max(activeOption, 0);

        if (radio) {
          selectedOptions.clear();
          selectedOptions.add(optionNames[activeOption]);
        }
      }

      // If we aren't a radio then set the active option to the bottom of any that are enabled
      if (!radio) {
        while (selectedOptions.has(optionNames[activeOption])) {
          activeOption++;
        }
      }

      const render = () => {
        for (let i = 0;
        i < optionNames.length;
        i++) {
          const key = optionNames[i];
          const {label} = options[key];
          const formattedLabel = optionNames.indexOf(key) === activeOption
            ? '<underline>' +
            label +
            '</underline>' : label;

          let symbol = '';
          if (radio) {
            symbol = selectedOptions.has(key) ? '\u25c9' : '\u25ef';
          } else {
            symbol = selectedOptions.has(key) ? '\u2611' : '\u2610';
          }

          this.logAll(
            '  ' +
            symbol +
            ' ' +
            formattedLabel,
            {
              // Don't put a newline on the last option
              newline: i !== optionNames.length - 1,
            },
          );
        }
      };

      const cleanup = () => {
        for (let i = 0;
        i < optionCount;
        i++) {
          this.writeAll(___R$project$rome$$romejs$string$ansi$escapes_ts$escapes.eraseLine);

          // Don't move above the top line
          if (i !== optionCount - 1) {
            this.writeAll(___R$project$rome$$romejs$string$ansi$escapes_ts$escapes.cursorUp());
          }
        }
        this.writeAll(___R$project$rome$$romejs$string$ansi$escapes_ts$escapes.cursorTo(0));
      };

      let onkeypress = undefined;

      const stdin = this.getStdin();

      render();

      ___R$$priv$project$rome$$romejs$cli$reporter$Reporter_ts$readline.emitKeypressEvents(stdin);

      if (stdin.isTTY && stdin.setRawMode !== undefined) {
        stdin.setRawMode(true);
      }

      stdin.resume();

      await new Promise(
        (resolve) => {
          const finish = () => {
            cleanup();

            // Remove initial help message
            this.writeAll(___R$project$rome$$romejs$string$ansi$escapes_ts$escapes.cursorUp());
            this.writeAll(___R$project$rome$$romejs$string$ansi$escapes_ts$escapes.eraseLine);

            // Remove initial log message
            this.writeAll(___R$project$rome$$romejs$string$ansi$escapes_ts$escapes.cursorUp());
            this.writeAll(___R$project$rome$$romejs$string$ansi$escapes_ts$escapes.eraseLine);

            prompt += ': ';
            if (selectedOptions.size > 0) {
              prompt +=
                Array.from(selectedOptions, (key) => options[key].label).join(', ');
            } else {
              prompt += '<dim>none</dim>';
            }
            this.logAll(prompt);

            resolve();
          };

          onkeypress =
            (
              chunk,
              key,
            ) => {
              switch (key.name) {
                case 'up':
                  activeOption--;
                  break;

                case 'down':
                  activeOption++;
                  break;

                case 'space':
                  if (!radio) {
                    const optionName = optionNames[activeOption];
                    if (selectedOptions.has(optionName)) {
                      selectedOptions.delete(optionName);
                    } else {
                      selectedOptions.add(optionName);
                    }
                  }
                  break;

                case 'c':
                  if (key.ctrl) {
                    this.forceSpacer();
                    this.warn('Cancelled by user');
                    process.exit(1);
                  }
                  return;

                case 'escape':
                  this.forceSpacer();
                  this.warn('Cancelled by user');
                  process.exit(1);
                  return;

                case 'return':
                  finish();
                  return;

                default:
                  return;
              }

              boundActive();
              cleanup();
              render();
            };

          stdin.addListener('keypress', onkeypress);
        },
      );

      if (onkeypress !== undefined) {
        stdin.removeListener('keypress', onkeypress);
      }

      if (stdin.isTTY && stdin.setRawMode !== undefined) {
        stdin.setRawMode(false);
      }

      stdin.pause();

      return selectedOptions;
    }

    //# Control
    isEnabled(stderr) {
      return this.getStreams(stderr).size > 0;
    }

    getStreams(stderr) {
      if (this.enabled === 0) {
        return new Set();
      }

      if (this.shouldRedirectOutToErr) {
        return this.errStreams;
      }

      if (stderr) {
        return this.errStreams;
      }

      return this.outStreams;
    }

    enable() {
      let alreadyDisabled = false;

      this.enabled++;

      return (
        () => {
          if (alreadyDisabled) {
            throw new Error('Already disabled Reporter');
          }

          this.enabled--;
          alreadyDisabled = true;
        }
      );
    }

    //# LIFECYCLE
    teardown() {
      for (const stream of this.streams) {
        this.removeStream(stream);
      }

      for (const elem of this.activeElements) {
        elem.end();
      }
      this.activeElements.clear();
    }

    fork(opts = {}) {
      return (
        new ___R$project$rome$$romejs$cli$reporter$Reporter_ts$default(
          Object.assign(
            {
              streams: [...this.streams],
              verbose: this.isVerbose,
              markupOptions: this.markupOptions,
              wrapperFactory: this.wrapperFactory,
            },
            opts,
          ),
        )
      );
    }

    //# INDENTATION METHODS
    indent(callback) {
      this.indentLevel++;
      this.updateIndent();

      callback();
      this.indentLevel--;
      this.updateIndent();
    }

    noIndent(callback) {
      const prevIndentLevel = this.indentLevel;
      this.indentLevel = 0;
      this.updateIndent();
      callback();
      this.indentLevel = prevIndentLevel;
      this.updateIndent();
    }

    updateIndent() {
      this.indentString = ___R$$priv$project$rome$$romejs$cli$reporter$Reporter_ts$INDENT.repeat(this.indentLevel);
    }

    //# INTERNAL
    prependEmoji(stream, msg, emoji, fallback) {
      if (stream.format === 'none') {
        return emoji +
        ' ' +
        msg;
      } else {
        if (fallback === undefined) {
          return msg;
        } else {
          return fallback +
          ' ' +
          msg;
        }
      }
    }

    //# VISUALISATION
    table(head, rawBody) {
      // Format the head, just treat it like another row
      head =
        head.map(
          (
            field,
          ) =>
            ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bold(___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.underline(field)),
        );

      // Humanize all number fields
      const rows = [head];
      for (const row of rawBody) {
        rows.push(
          row.map(
            (field) => {
              if (typeof field === 'number') {
                return ___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(field);
              } else {
                return field;
              }
            },
          ),
        );
      }

      // Get column widths
      const cols = [];
      for (let i = 0;
      i < head.length;
      i++) {
        var ___R$;
        const widths = rows.map((row) => ___R$project$rome$$romejs$string$ansi$format_ts$stripAnsi(row[i]).length);
        cols[i] = (
          ___R$ =
            Math,
          ___R$.max.apply(___R$, [
            ...widths,
          ])
        );
      }

      // Format all rows
      const builtRows = rows.map(
        (row) => {
          for (let i = 0;
          i < row.length;
          i++) {
            const field = row[i];
            const padding = cols[i] - ___R$project$rome$$romejs$string$ansi$format_ts$stripAnsi(field).length;

            row[i] = field + ' '.repeat(padding);
          }
          return row.join(' ');
        },
      );

      this.logAll(builtRows.join('\n'));
    }

    verboseInspect(val) {
      if (this.isVerbose) {
        this.inspect(val);
      }
    }

    inspect(value) {
      for (const stream of this.getStreams(false)) {
        let formatted = value;

        if (typeof formatted !== 'number' && typeof formatted !== 'string') {
          formatted = ___R$project$rome$$romejs$pretty$format$index_ts$default(formatted, {color: stream.format === 'ansi'});
        }

        this.logOneNoMarkup(stream, String(formatted));
      }
    }

    //# ESCAPE HATCHES
    clearLineAll() {
      for (const stream of this.getStreams(false)) {
        this.clearLineSpecific(stream);
      }
    }

    clearLineSpecific(stream) {
      stream.write(___R$project$rome$$romejs$string$ansi$escapes_ts$escapes.eraseLine);
      stream.write(___R$project$rome$$romejs$string$ansi$escapes_ts$escapes.cursorTo(0));
    }

    writeAll(msg, opts = {}) {
      for (const stream of this.getStreams(opts.stderr)) {
        this.writeSpecific(stream, msg, opts);
      }
    }

    writeSpecific(stream, msg, opts = {}) {
      if (!this.isEnabled(opts.stderr)) {
        return;
      }

      this.hasClearScreen = false;

      if (stream.format === 'ansi' && this.activeElements.size > 0) {
        // A progress bar is active and has probably drawn to the screen
        this.clearLineSpecific(stream);
      }

      stream.write(msg);
    }

    //# UTILITIES
    getTotalTime() {
      return Date.now() - this.startTime;
    }

    clear() {
      for (const stream of this.getStreams(false)) {
        if (stream.format === 'ansi') {
          stream.write(___R$project$rome$$romejs$string$ansi$escapes_ts$escapes.clearScreen);
        }
      }
      this.hasClearScreen = true;
    }

    //# SECTIONS
    heading(text) {
      this.spacer();
      this.logAll(
        '<inverse><emphasis>' +
        text +
        '</emphasis></inverse>',
        {
          nonTTY: '# ' +
          text,
        },
      );
      this.spacer();
    }

    section(title, callback) {
      this.hr(title === undefined ? undefined : '<emphasis>' +
      title +
      '</emphasis>');
      this.indent(
        () => {
          callback();
          this.spacer();
        },
      );
    }

    hr(text) {
      const {hasClearScreen} = this;

      this.spacer();

      if (hasClearScreen && text === undefined) {
        return;
      }

      for (const stream of this.getStreams(false)) {
        const prefix = this.markupify(
          stream,
          text === undefined ? '' : ' ' +
          text +
          ' ',
        );
        const prefixLength = this.indentString.length + ___R$project$rome$$romejs$string$ansi$format_ts$stripAnsi(prefix).length;
        const barLength = Math.max(0, stream.columns - prefixLength);
        this.logOneNoMarkup(stream, prefix + '\u2501'.repeat(barLength));
      }

      this.spacer();
    }

    async steps(callbacks) {
      const total = callbacks.length;
      let current = 1;
      for (const {clear, message, callback} of callbacks) {
        this.step(current, total, message);

        if (clear) {
          this.hasClearScreen = true;
        }

        await callback();
        current++;

        // If a step doesn't produce any output, or just progress bars that are cleared, we can safely remove the previous `step` message line
        if (clear && this.hasClearScreen) {
          for (const stream of this.getStreams(false)) {
            if (stream.format === 'ansi') {
              stream.write(___R$project$rome$$romejs$string$ansi$escapes_ts$escapes.cursorTo(0));
              stream.write(___R$project$rome$$romejs$string$ansi$escapes_ts$escapes.cursorUp());
              stream.write(___R$project$rome$$romejs$string$ansi$escapes_ts$escapes.eraseLine);
            }
          }
        }
      }
    }

    step(current, total, msg) {
      if (msg.endsWith('?')) {
        msg = ___R$project$rome$$romejs$string$utils$removeSuffix_ts$removeSuffix(msg, '?') +
        '...?';
      } else {
        msg += '...';
      }

      this.logAll('<dim>[' +
      current +
      '/' +
      total +
      ']</dim> ' +
      msg);
    }

    spacer() {
      if (!this.hasSpacer) {
        this.forceSpacer();
      }
    }

    forceSpacer() {
      this.logAll('');
    }

    //# LOG
    stripMarkup(str) {
      return ___R$project$rome$$romejs$string$markup$format_ts$stripMarkupTags(str, this.markupOptions);
    }

    markupify(stream, str) {
      if (stream.format === 'ansi') {
        return ___R$project$rome$$romejs$string$markup$format_ts$markupToAnsi(str, this.markupOptions);
      } else if (stream.format === 'html') {
        // TODO
        return ___R$project$rome$$romejs$string$markup$format_ts$stripMarkupTags(str);
      } else {
        return ___R$project$rome$$romejs$string$markup$format_ts$stripMarkupTags(str);
      }
    }

    logAll(tty, opts = {}) {
      for (const stream of this.getStreams(opts.stderr)) {
        this.logOne(stream, tty, opts);
      }
    }

    logAllNoMarkup(msg, opts = {}) {
      for (const stream of this.getStreams(opts.stderr)) {
        this.logOneNoMarkup(stream, msg, opts);
      }
    }

    logOne(stream, tty, opts = {}) {
      const msg = stream.format !== 'none' || opts.nonTTY === undefined
        ? tty : opts.nonTTY;
      const formatted = this.markupify(stream, msg);
      this.logOneNoMarkup(stream, formatted, opts);
    }

    logOneNoMarkup(stream, tty, opts = {}) {
      if (!this.isEnabled(opts.stderr)) {
        return;
      }

      let msg = this.normalizeMessage(stream, tty, opts);
      if (opts.newline !== false) {
        msg += '\n';
      }
      this.writeSpecific(stream, msg, opts);
    }

    logAllWithCategory(msg, args, opts) {
      for (const stream of this.getStreams(opts.stderr)) {
        const prefix = this.getMessagePrefix(stream) + opts.prefix;

        // Format with string-markup, we only do the first message rather than the interpolated string so you can pass in any data and not have to worry about escaping it
        const msgMarkup = this.markupify(stream, msg);

        // Interpolated and line wrapped string
        let inner = ___R$project$rome$$romejs$cli$reporter$util_ts$interpolate(msgMarkup, args);

        // Word wrap - we don't use getColumns() here as we don't want to line wrap for a non-tty
        if (stream.format === 'ansi') {
          const width = stream.columns;
          const allowedWidth = width - prefix.length -
          ___R$$priv$project$rome$$romejs$cli$reporter$Reporter_ts$INDENT.length *
          this.indentLevel;
          if (___R$project$rome$$romejs$string$ansi$format_ts$stripAnsi(inner).length > allowedWidth) {
            const lines = ___R$project$rome$$romejs$string$ansi$split_ts$splitAnsiLines(inner, allowedWidth);
            inner = String(lines.shift());

            for (const line of lines) {
              inner += '\n' +
              ' '.repeat(prefix.length) +
              line;
            }
          }
        }

        // If the message contains any color then we shouldn't format it, so consider it outside the prefix (which will always be colored)
        let outer = '';
        if (___R$project$rome$$romejs$string$ansi$format_ts$hasAnsiColor(inner)) {
          outer = inner;
          inner = prefix;
        }

        // Build the TTY and non-TTY variants
        let tty = ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bold(opts.format(prefix)) + opts.format(inner) + outer;
        let nonTTY = prefix + inner + outer;
        if (opts.suffix !== undefined) {
          tty += opts.format(___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bold(opts.suffix));
          nonTTY += opts.suffix;
        }

        this.logOneNoMarkup(
          stream,
          tty,
          Object.assign(
            {
              nonTTY,
              // No prefix as we added it ourselves at the beginning, this is so the indentation is correct when line wrapped
              noPrefix: true,
            },
            opts,
          ),
        );
      }
    }

    success(msg, ...args) {
      this.logAllWithCategory(
        msg,
        args,
        {
          prefix: '\u2714 ',
          format: ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.green,
        },
      );
    }

    error(msg, ...args) {
      this.logAllWithCategory(
        msg,
        args,
        {
          format: ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.red,
          prefix: '\u2716 ',
          stderr: true,
        },
      );
    }

    errorObj(err) {
      this.error(err.stack || err.message || err.name || 'Unknown Error');
    }

    info(msg, ...args) {
      this.logAllWithCategory(
        msg,
        args,
        {
          prefix: '\u2139 ',
          format: ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.blue,
        },
      );
    }

    warn(msg, ...args) {
      this.logAllWithCategory(
        msg,
        args,
        {
          prefix: '\u26a0 ',
          suffix: ' \u26a0',
          format: ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.yellow,
          stderr: true,
        },
      );
    }

    verbose(msg, ...args) {
      if (this.isVerbose) {
        this.verboseForce(msg, args);
      }
    }

    verboseForce(msg, ...args) {
      this.logAllWithCategory(
        msg,
        args,
        {
          prefix: '\u26a1 ',
          format: ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.brightBlack,
        },
      );
    }

    command(command) {
      for (const stream of this.getStreams(false)) {
        this.logOneNoMarkup(
          stream,
          ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.dim('$ ' +
          command),
          {
            nonTTY: '$ ' +
            command,
          },
        );
      }
    }

    //# LISTS
    _getListIndentation() {
      // If we're at the top level then add some implicit indentation
      return this.indentLevel === 0 ? '  ' : '';
    }

    processedList(items, callback, opts = {}) {
      if (items.length === 0) {
        // We make some assumptions that there's at least one item
        return;
      }

      const indent = this._getListIndentation();

      let tuples;
      if (opts.reverse === true) {
        tuples = items.reverse().map((item, i) => [items.length - i, item]);
      } else {
        tuples = items.map((item, i) => [i, item]);
      }

      // Truncate if necessary
      let truncatedCount = 0;
      if (opts.truncate !== undefined) {
        tuples = tuples.slice(0, opts.truncate);
        truncatedCount = items.length - tuples.length;
      }

      let indentLength = indent.length;

      if (opts.ordered) {
        // Get the highest visible number. It could be at the start or the end depending on if it was reversed
        const highestVisible = Math.max(tuples[0][0], tuples[tuples.length - 1][0]);

        // Length of the largest visible number plus the dot for padding
        const numLen = ___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(highestVisible + 1).length + 1;

        // "0. "
        indentLength += numLen + 1;

        for (const [index, item] of tuples) {
          callback(
            item,
            (str) => {
              const num = ___R$project$rome$$romejs$string$ansi$pad_ts$rightPad(___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(index + 1) +
              '.', numLen);
              this.logAll(indent +
              '<dim>' +
              num +
              '</dim> ' +
              str);
            },
          );
        }
      } else {
        // "- "
        indentLength += 2;

        for (const [, item] of tuples) {
          callback(
            item,
            (str) => {
              this.logAll(indent +
              '<dim>-</dim> ' +
              str);
            },
          );
        }
      }

      if (truncatedCount > 0) {
        const indent = ' '.repeat(indentLength);
        this.logAll(indent +
        'and <number>' +
        truncatedCount +
        '</number> others...');
      }
    }

    list(items, opts = {}) {
      this.processedList(items, (str, display) => display(str), opts);
    }

    progress(opts) {
      if (this.isRemote) {
        return this.progressRemote(opts);
      } else {
        return this.progressLocal(opts);
      }
    }

    progressLocal(opts, onEnd) {
      const bar = new ___R$project$rome$$romejs$cli$reporter$Progress_ts$default(
        this,
        opts,
        () => {
          this.activeElements.delete(bar);
          if (onEnd !== undefined) {
            onEnd();
          }
        },
      );
      this.activeElements.add(bar);
      return bar;
    }

    progressRemote(opts) {
      const id = process.pid +
      ':' +
      ___R$$priv$project$rome$$romejs$cli$reporter$Reporter_ts$remoteProgressIdCounter++;

      this.sendRemoteClientMessage.send(
        {
          type: 'PROGRESS_CREATE',
          opts,
          id,
        },
      );

      let closed = false;

      const dispatch = (message) => {
        if (!closed) {
          this.sendRemoteClientMessage.send(message);
        }
      };

      const end = () => {
        this.activeElements.delete(progress);
        this.remoteServerProgressBars.delete(id);
        closed = true;
      };

      const progress = {
        render() {
          // Don't do anything

          // This is called when columns have updated and we want to force a rerender
        },

        setCurrent: (current) => {
          dispatch(
            {
              type: 'PROGRESS_SET_CURRENT',
              current,
              id,
            },
          );
        },

        setTotal: (total, approximate = false) => {
          dispatch(
            {
              type: 'PROGRESS_SET_TOTAL',
              total,
              approximate,
              id,
            },
          );
        },

        setTitle: (title) => {
          dispatch(
            {
              type: 'PROGRESS_SET_TITLE',
              title,
              id,
            },
          );
        },

        setText: (text) => {
          dispatch(
            {
              type: 'PROGRESS_SET_TEXT',
              text,
              id,
            },
          );
        },

        setApproximateETA: (duration) => {
          dispatch(
            {
              type: 'PROGRESS_SET_APPROXIMATE_ETA',
              duration,
              id,
            },
          );
        },

        pushText: (text) => {
          dispatch(
            {
              type: 'PROGRESS_PUSH_TEXT',
              text,
              id,
            },
          );
        },

        popText: (text) => {
          dispatch(
            {
              type: 'PROGRESS_POP_TEXT',
              text,
              id,
            },
          );
        },

        tick: () => {
          dispatch(
            {
              type: 'PROGRESS_TICK',
              id,
            },
          );
        },

        end: () => {
          dispatch(
            {
              type: 'PROGRESS_END',
              id,
            },
          );
        },

        pause: () => {
          dispatch(
            {
              type: 'PROGRESS_PAUSE',
              id,
            },
          );
        },

        resume: () => {
          dispatch(
            {
              type: 'PROGRESS_RESUME',
              id,
            },
          );
        },
      };

      this.remoteServerProgressBars.set(
        id,
        {
          end,
        },
      );

      this.activeElements.add(progress);

      return progress;
    }
  }

  ___R$project$rome$$romejs$cli$reporter$Reporter_ts$default.DEFAULT_COLUMNS =
    100;

  // project-rome/@romejs/cli-reporter/types.ts
const ___R$project$rome$$romejs$cli$reporter$types_ts = {
  };

  // project-rome/@romejs/cli-reporter/index.ts


  // project-rome/@romejs/cli-diagnostics/ansiHighlightCode.ts
// 100KB
  const ___R$$priv$project$rome$$romejs$cli$diagnostics$ansiHighlightCode_ts$FILE_SIZE_MAX = 100000;

  function ___R$project$rome$$romejs$cli$diagnostics$ansiHighlightCode_ts$default(opts) {
    if (opts.input.length > ___R$$priv$project$rome$$romejs$cli$diagnostics$ansiHighlightCode_ts$FILE_SIZE_MAX) {
      return opts.input;
    }

    if (opts.language === 'js') {
      // js-parser does not accept an "unknown" sourceType
      return (
        ___R$$priv$project$rome$$romejs$cli$diagnostics$ansiHighlightCode_ts$ansiHighlightJS(
          opts.input,
          opts.sourceType === 'unknown'
            ? 'script' : opts.sourceType,
        )
      );
    }

    if (opts.language === 'json') {
      return ___R$$priv$project$rome$$romejs$cli$diagnostics$ansiHighlightCode_ts$ansiHighlightJSON(opts.path, opts.input);
    }

    return opts.input;
  }

  function ___R$$priv$project$rome$$romejs$cli$diagnostics$ansiHighlightCode_ts$reduce(
    input,
    tokens,
    callback,
  ) {
    let prevEnd = 0;
    let buff = '';

    for (const token of tokens) {
      const start = ___R$project$rome$$romejs$ob1$index_ts$get0(token.start);
      const end = ___R$project$rome$$romejs$ob1$index_ts$get0(token.end);
      let value = input.slice(start, end);

      // Add on text between tokens
      buff += input.slice(prevEnd, start);
      prevEnd = end;

      // We need to break up the token text into lines, so that we can easily split the highlighted newlines and have the ansi codes be unbroken
      const lines = value.split('\n');

      const values = lines.map(
        (line) => {
          return callback(token, line);
        },
      );

      buff += values.join('\n');
    }

    return buff;
  }

  function ___R$$priv$project$rome$$romejs$cli$diagnostics$ansiHighlightCode_ts$invalidHighlight(line) {
    return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bold(___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bgRed(line));
  }

  function ___R$$priv$project$rome$$romejs$cli$diagnostics$ansiHighlightCode_ts$ansiHighlightJSON(path, input) {
    const tokens = ___R$project$rome$$romejs$codec$json$index_ts$tokenizeJSON(
      {
        input,
        // Wont be used anywhere but activates JSON extensions if necessary
        path,
      },
    );

    return (
      ___R$$priv$project$rome$$romejs$cli$diagnostics$ansiHighlightCode_ts$reduce(
        input,
        tokens,
        (token, line) => {
          // Try to keep the highlighting in line with JS where possible
          switch (token.type) {
            case 'BlockComment':
            case 'LineComment':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.brightBlack(line);

            case 'String':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.green(line);

            case 'Number':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.magenta(line);

            case 'Word':
              switch (token.value) {
                case 'true':
                case 'false':
                case 'null':
                  return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.cyan(line);

                default:
                  return line;
              }

            case 'Comma':
            case 'Colon':
            case 'Dot':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.yellow(line);

            case 'BracketOpen':
            case 'BracketClose':
            case 'BraceOpen':
            case 'BraceClose':
            case 'Minus':
            case 'Plus':
              return line;

            case 'Invalid':
              return ___R$$priv$project$rome$$romejs$cli$diagnostics$ansiHighlightCode_ts$invalidHighlight(line);

            // Will never be hit
            case 'EOF':
            case 'SOF':
              return '';
          }
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$cli$diagnostics$ansiHighlightCode_ts$ansiHighlightJS(input, sourceType) {
    const tokens = ___R$project$rome$$romejs$js$parser$index_ts$tokenizeJS(
      input,
      {
        sourceType,
        // js-parser requires a filename. Doesn't really matter since we'll never be producing an AST or diagnostics
        path: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath('unknown'),
      },
    );

    return (
      ___R$$priv$project$rome$$romejs$cli$diagnostics$ansiHighlightCode_ts$reduce(
        input,
        tokens,
        (token, line) => {
          const {type} = token;

          switch (type.label) {
            case 'break':
            case 'case':
            case 'catch':
            case 'continue':
            case 'debugger':
            case 'default':
            case 'do':
            case 'else':
            case 'finally':
            case 'for':
            case 'function':
            case 'if':
            case 'return':
            case 'switch':
            case 'throw':
            case 'try':
            case 'var':
            case 'const':
            case 'while':
            case 'with':
            case 'new':
            case 'this':
            case 'super':
            case 'class':
            case 'extends':
            case 'export':
            case 'import':
            case 'null':
            case 'true':
            case 'false':
            case 'in':
            case 'instanceof':
            case 'typeof':
            case 'void':
            case 'delete':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.cyan(line);

            case 'num':
            case 'bigint':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.magenta(line);

            case 'regexp':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.magenta(line);

            case 'string':
            case 'template':
            case '`':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.green(line);

            case 'invalid':
              return ___R$$priv$project$rome$$romejs$cli$diagnostics$ansiHighlightCode_ts$invalidHighlight(line);

            case 'comment':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.brightBlack(line);

            case ',':
            case ';':
            case ':':
            case '::':
            case '${':
            case '.':
            case '?':
            case '?.':
              return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.yellow(line);

            case '[':
            case ']':
            case '{':
            case '{|':
            case '}':
            case '|}':
            case '(':
            case ')':
              return line;

            case '=>':
            case '...':
            case '@':
            case '#':
            case '=':
            case '_=':
            case '++/--':
            case '!':
            case '~':
            case '??':
            case '||':
            case '&&':
            case '|':
            case '^':
            case '&':
            case '==/!=':
            case '</>':
            case '<</>>':
            case '+/-':
            case '%':
            case '*':
            case '/':
            case '**':
            case 'jsxName':
            case 'jsxText':
            case 'jsxTagStart':
            case 'jsxTagEnd':
            case 'name':
            case 'eof':
              return line;
          }
        },
      )
    );
  }

  // project-rome/@romejs/cli-diagnostics/utils.ts
function ___R$project$rome$$romejs$cli$diagnostics$utils_ts$showInvisibles(str) {
    let ret = '';
    for (const cha of str) {
      switch (cha) {
        case ' ':
          ret += '\xb7'; // Middle Dot, \u00B7
          break;
        case '\r':
          ret += '\u240d';
          break;
        case '\n':
          ret += '\u23ce'; // Return Symbol, \u23ce
          break;
        case '\t':
          ret += '\u21b9'; // Left Arrow To Bar Over Right Arrow To Bar, \u21b9
          break;
        default:
          ret += cha;
          break;
      }
    }
    return ret;
  }

  function ___R$project$rome$$romejs$cli$diagnostics$utils_ts$cleanEquivalentString(str) {
    // Strip ansi
    str = ___R$project$rome$$romejs$string$ansi$format_ts$stripAnsi(str);

    // Replace all whitespace with spaces
    str = str.replace(/[\s\n]+/g, ' ');

    // Remove trailing dot
    str = str.replace(/\.+$/, '');

    // Remove surrounding quotes
    str = str.replace(/^"(.*?)"$/, '$1');

    return str;
  }

  function ___R$project$rome$$romejs$cli$diagnostics$utils_ts$splitLines(src) {
    return src.replace(/\t/g, ' ').split(___R$project$rome$$romejs$js$parser$utils$whitespace_ts$NEWLINE);
  }

  function ___R$project$rome$$romejs$cli$diagnostics$utils_ts$toLines(opts) {
    const highlighted = ___R$project$rome$$romejs$cli$diagnostics$ansiHighlightCode_ts$default(opts);
    const lines = ___R$project$rome$$romejs$cli$diagnostics$utils_ts$splitLines(highlighted);
    return lines;
  }

  // project-rome/@romejs/string-diff/index.ts
/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
  const ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_DELETE = -1;
  const ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_INSERT = 1;
  const ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_EQUAL = 0;
  const ___R$project$rome$$romejs$string$diff$index_ts$constants = {
    DELETE: ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_DELETE,
    EQUAL: ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_EQUAL,
    ADD: ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_INSERT,
  };

  function ___R$project$rome$$romejs$string$diff$index_ts$groupDiffByLines(rawDiffs) {
    const diffsByLine = [];

    // Refers to the current line array being built
    let line = [];
    function flushLine() {
      if (line.length > 0) {
        diffsByLine.push(line);
        line = [];
      }
    }

    for (const tuple of rawDiffs) {
      const [type, text] = tuple;

      // Deleted lines don't affect the line count
      if (type === ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_DELETE) {
        line.push(tuple);
        continue;
      }

      // Get all the lines
      const parts = text.split('\n');

      // Doesn't contain a newline
      if (parts.length <= 1) {
        line.push(tuple);
        continue;
      }

      // Deconstruct each text chunk
      const [currentLine, ...futureLines] = parts;

      // The first chunk belongs to the current line
      if (currentLine !== '') {
        line.push([type, currentLine]);
      }

      // Create unique lines for each other chunk
      for (const newLine of futureLines) {
        flushLine();
        line.push([type, newLine]);
      }
    }

    flushLine();

    return diffsByLine;
  }

  function ___R$project$rome$$romejs$string$diff$index_ts$default(text1, text2) {
    // only pass fix_unicode=true at the top level, not when main is

    // recursively invoked
    return ___R$$priv$project$rome$$romejs$string$diff$index_ts$main(text1, text2, true);
  }

  /**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {Int|Object} [cursor_pos] Edit position in text1 or object with more info
 * @return {Array} Array of diff tuples.
 */
  function ___R$$priv$project$rome$$romejs$string$diff$index_ts$main(text1, text2, fixUnicode = false) {
    // Check for equality
    if (text1 === text2) {
      if (text1) {
        return [[___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_EQUAL, text1]];
      }
      return [];
    }

    // Trim off common prefix (speedup).
    let commonlength = ___R$$priv$project$rome$$romejs$string$diff$index_ts$commonPrefix(text1, text2);
    let commonprefix = text1.substring(0, commonlength);
    text1 = text1.substring(commonlength);
    text2 = text2.substring(commonlength);

    // Trim off common suffix (speedup).
    commonlength = ___R$$priv$project$rome$$romejs$string$diff$index_ts$commonSuffix(text1, text2);
    let commonsuffix = text1.substring(text1.length - commonlength);
    text1 = text1.substring(0, text1.length - commonlength);
    text2 = text2.substring(0, text2.length - commonlength);

    // Compute the diff on the middle block.
    let diffs = ___R$$priv$project$rome$$romejs$string$diff$index_ts$compute(text1, text2);

    // Restore the prefix and suffix.
    if (commonprefix) {
      diffs.unshift([___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_EQUAL, commonprefix]);
    }
    if (commonsuffix) {
      diffs.push([___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_EQUAL, commonsuffix]);
    }
    ___R$$priv$project$rome$$romejs$string$diff$index_ts$cleanupMerge(diffs, fixUnicode);
    return diffs;
  }

  /**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {Array} Array of diff tuples.
 */
  function ___R$$priv$project$rome$$romejs$string$diff$index_ts$compute(text1, text2) {
    let diffs = [];

    if (!text1) {
      // Just add some text (speedup).
      return [[___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_INSERT, text2]];
    }

    if (!text2) {
      // Just delete some text (speedup).
      return [[___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_DELETE, text1]];
    }

    let longtext = text1.length > text2.length ? text1 : text2;
    let shorttext = text1.length > text2.length ? text2 : text1;
    let i = longtext.indexOf(shorttext);
    if (i !== -1) {
      // Shorter text is inside the longer text (speedup).
      diffs =
        [
          [___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_INSERT, longtext.substring(0, i)],
          [___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_EQUAL, shorttext],
          [___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_INSERT, longtext.substring(i + shorttext.length)],
        ];
      // Swap insertions for deletions if diff is reversed.
      if (text1.length > text2.length) {
        diffs[0][0] = diffs[2][0] = ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_DELETE;
      }
      return diffs;
    }

    if (shorttext.length === 1) {
      // Single character string.

      // After the previous speedup, the character can't be an equality.
      return (
        [
          [___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_DELETE, text1],
          [___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_INSERT, text2],
        ]
      );
    }

    // Check to see if the problem can be split in two.
    let hm = ___R$$priv$project$rome$$romejs$string$diff$index_ts$halfMatch(text1, text2);
    if (hm) {
      // A half-match was found, sort out the return data.
      let text1_a = hm[0];
      let text1_b = hm[1];
      let text2_a = hm[2];
      let text2_b = hm[3];
      let mid_common = hm[4];
      // Send both pairs off for separate processing.
      let diffs_a = ___R$$priv$project$rome$$romejs$string$diff$index_ts$main(text1_a, text2_a);
      let diffs_b = ___R$$priv$project$rome$$romejs$string$diff$index_ts$main(text1_b, text2_b);
      // Merge the results.
      return diffs_a.concat([[___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_EQUAL, mid_common]], diffs_b);
    }

    return ___R$$priv$project$rome$$romejs$string$diff$index_ts$bisect(text1, text2);
  }

  /**
 * Find the 'middle snake' of a diff, split the problem in two
 * and return the recursively constructed diff.
 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {Array} Array of diff tuples.
 * @private
 */
  function ___R$$priv$project$rome$$romejs$string$diff$index_ts$bisect(text1, text2) {
    // Cache the text lengths to prevent multiple calls.
    let text1_length = text1.length;
    let text2_length = text2.length;
    let max_d = Math.ceil((text1_length + text2_length) / 2);
    let v_offset = max_d;
    let v_length = 2 * max_d;
    let v1 = new Array(v_length);
    let v2 = new Array(v_length);
    // Setting all elements to -1 is faster in Chrome & Firefox than mixing

    // integers and undefined.
    for (let x = 0;
    x < v_length;
    x++) {
      v1[x] = -1;
      v2[x] = -1;
    }
    v1[v_offset + 1] = 0;
    v2[v_offset + 1] = 0;
    let delta = text1_length - text2_length;
    // If the total number of characters is odd, then the front path will collide

    // with the reverse path.
    let front = delta % 2 !== 0;
    // Offsets for start and end of k loop.

    // Prevents mapping of space beyond the grid.
    let k1start = 0;
    let k1end = 0;
    let k2start = 0;
    let k2end = 0;
    for (let d = 0;
    d < max_d;
    d++) {
      // Walk the front path one step.
      for (let k1 = -d + k1start;
      k1 <= d - k1end;
      k1 += 2) {
        let k1_offset = v_offset + k1;
        let x1;
        if (k1 === -d || k1 !== d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
          x1 = v1[k1_offset + 1];
        } else {
          x1 = v1[k1_offset - 1] + 1;
        }
        let y1 = x1 - k1;
        while (x1 < text1_length && y1 < text2_length &&
          text1.charAt(x1) ===
          text2.charAt(y1)) {
          x1++;
          y1++;
        }
        v1[k1_offset] = x1;
        if (x1 > text1_length) {
          // Ran off the right of the graph.
          k1end += 2;
        } else if (y1 > text2_length) {
          // Ran off the bottom of the graph.
          k1start += 2;
        } else if (front) {
          let k2_offset = v_offset + delta - k1;
          if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {
            // Mirror x2 onto top-left coordinate system.
            let x2 = text1_length - v2[k2_offset];
            if (x1 >= x2) {
              // Overlap detected.
              return ___R$$priv$project$rome$$romejs$string$diff$index_ts$bisectSplit(text1, text2, x1, y1);
            }
          }
        }
      }

      // Walk the reverse path one step.
      for (let k2 = -d + k2start;
      k2 <= d - k2end;
      k2 += 2) {
        let k2_offset = v_offset + k2;
        let x2;
        if (k2 === -d || k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
          x2 = v2[k2_offset + 1];
        } else {
          x2 = v2[k2_offset - 1] + 1;
        }
        let y2 = x2 - k2;
        while (x2 < text1_length && y2 < text2_length &&
          text1.charAt(
            text1_length - x2 - 1,
          ) ===
          text2.charAt(text2_length - y2 - 1)) {
          x2++;
          y2++;
        }
        v2[k2_offset] = x2;
        if (x2 > text1_length) {
          // Ran off the left of the graph.
          k2end += 2;
        } else if (y2 > text2_length) {
          // Ran off the top of the graph.
          k2start += 2;
        } else if (!front) {
          let k1_offset = v_offset + delta - k2;
          if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {
            let x1 = v1[k1_offset];
            let y1 = v_offset + x1 - k1_offset;
            // Mirror x2 onto top-left coordinate system.
            x2 = text1_length - x2;
            if (x1 >= x2) {
              // Overlap detected.
              return ___R$$priv$project$rome$$romejs$string$diff$index_ts$bisectSplit(text1, text2, x1, y1);
            }
          }
        }
      }
    }
    // Diff took too long and hit the deadline or

    // number of diffs equals number of characters, no commonality at all.
    return (
      [
        [___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_DELETE, text1],
        [___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_INSERT, text2],
      ]
    );
  }

  /**
 * Given the location of the 'middle snake', split the diff in two parts
 * and recurse.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} x Index of split point in text1.
 * @param {number} y Index of split point in text2.
 * @return {Array} Array of diff tuples.
 */
  function ___R$$priv$project$rome$$romejs$string$diff$index_ts$bisectSplit(text1, text2, x, y) {
    let text1a = text1.substring(0, x);
    let text2a = text2.substring(0, y);
    let text1b = text1.substring(x);
    let text2b = text2.substring(y);

    // Compute both diffs serially.
    let diffs = ___R$$priv$project$rome$$romejs$string$diff$index_ts$main(text1a, text2a);
    let diffsb = ___R$$priv$project$rome$$romejs$string$diff$index_ts$main(text1b, text2b);

    return diffs.concat(diffsb);
  }

  /**
 * Determine the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
  function ___R$$priv$project$rome$$romejs$string$diff$index_ts$commonPrefix(text1, text2) {
    // Quick check for common null cases.
    if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
      return 0;
    }

    // Binary search.

    // Performance analysis: http://neil.fraser.name/news/2007/10/09/
    let pointermin = 0;
    let pointermax = Math.min(text1.length, text2.length);
    let pointermid = pointermax;
    let pointerstart = 0;
    while (pointermin < pointermid) {
      if (text1.substring(pointerstart, pointermid) ==
      text2.substring(
        pointerstart,
        pointermid,
      )) {
        pointermin = pointermid;
        pointerstart = pointermin;
      } else {
        pointermax = pointermid;
      }
      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    }

    if (___R$$priv$project$rome$$romejs$string$diff$index_ts$is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) {
      pointermid--;
    }

    return pointermid;
  }

  /**
 * Determine the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
  function ___R$$priv$project$rome$$romejs$string$diff$index_ts$commonSuffix(text1, text2) {
    // Quick check for common null cases.
    if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {
      return 0;
    }

    // Binary search.

    // Performance analysis: http://neil.fraser.name/news/2007/10/09/
    let pointermin = 0;
    let pointermax = Math.min(text1.length, text2.length);
    let pointermid = pointermax;
    let pointerend = 0;
    while (pointermin < pointermid) {
      if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
      text2.substring(text2.length - pointermid, text2.length - pointerend)) {
        pointermin = pointermid;
        pointerend = pointermin;
      } else {
        pointermax = pointermid;
      }
      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    }

    if (___R$$priv$project$rome$$romejs$string$diff$index_ts$is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) {
      pointermid--;
    }

    return pointermid;
  }

  /**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 */
  function ___R$$priv$project$rome$$romejs$string$diff$index_ts$halfMatch(text1, text2) {
    let longtext = text1.length > text2.length ? text1 : text2;
    let shorttext = text1.length > text2.length ? text2 : text1;
    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
      return undefined; // Pointless.
    }

    // First check if the second quarter is the seed for a half-match.
    let hm1 = ___R$$priv$project$rome$$romejs$string$diff$index_ts$halfMatchI(longtext, shorttext, Math.ceil(longtext.length / 4));

    // Check again based on the third quarter.
    let hm2 = ___R$$priv$project$rome$$romejs$string$diff$index_ts$halfMatchI(longtext, shorttext, Math.ceil(longtext.length / 2));

    let hm;
    if (!hm1 && !hm2) {
      return undefined;
    } else if (!hm2) {
      hm = hm1;
    } else if (!hm1) {
      hm = hm2;
    } else {
      // Both matched.  Select the longest.
      hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
    }

    if (hm === undefined) {
      throw new Error('Expected half match');
    }

    // A half-match was found, sort out the return data.
    let text1_a, text1_b, text2_a, text2_b;
    if (text1.length > text2.length) {
      text1_a = hm[0];
      text1_b = hm[1];
      text2_a = hm[2];
      text2_b = hm[3];
    } else {
      text2_a = hm[0];
      text2_b = hm[1];
      text1_a = hm[2];
      text1_b = hm[3];
    }
    let mid_common = hm[4];
    return [text1_a, text1_b, text2_a, text2_b, mid_common];
  }

  /**
 * Does a substring of shorttext exist within longtext such that the substring
 * is at least half the length of longtext?
 * Closure, but does not reference any external variables.
 * @param {string} longtext Longer string.
 * @param {string} shorttext Shorter string.
 * @param {number} i Start index of quarter length substring within longtext.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
 *     of shorttext and the common middle.  Or null if there was no match.
 * @private
 */
  function ___R$$priv$project$rome$$romejs$string$diff$index_ts$halfMatchI(
    longtext,
    shorttext,
    i,
  ) {
    // Start with a 1/4 length substring at position i as a seed.
    let seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    let j = -1;
    let best_common = '';
    let best_longtext_a = '';
    let best_longtext_b = '';
    let best_shorttext_a = '';
    let best_shorttext_b = '';
    while ((j = shorttext.indexOf(seed, j + 1)) !== -1) {
      let prefixLength = ___R$$priv$project$rome$$romejs$string$diff$index_ts$commonPrefix(
        longtext.substring(i),
        shorttext.substring(j),
      );
      let suffixLength = ___R$$priv$project$rome$$romejs$string$diff$index_ts$commonSuffix(
        longtext.substring(0, i),
        shorttext.substring(0, j),
      );
      if (best_common.length < suffixLength + prefixLength) {
        best_common =
          shorttext.substring(j - suffixLength, j) +
          shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }

    if (best_common.length * 2 >= longtext.length) {
      return (
        [
          best_longtext_a,
          best_longtext_b,
          best_shorttext_a,
          best_shorttext_b,
          best_common,
        ]
      );
    } else {
      return undefined;
    }
  }

  /**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {Array} diffs Array of diff tuples.
 * @param {boolean} fix_unicode Whether to normalize to a unicode-correct diff
 */
  function ___R$$priv$project$rome$$romejs$string$diff$index_ts$cleanupMerge(diffs, fix_unicode) {
    diffs.push([___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_EQUAL, '']); // Add a dummy entry at the end.
    let pointer = 0;
    let count_delete = 0;
    let count_insert = 0;
    let text_delete = '';
    let text_insert = '';
    let commonlength;
    while (pointer < diffs.length) {
      if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
        diffs.splice(pointer, 1);
        continue;
      }
      switch (diffs[pointer][0]) {
        case ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_INSERT:
          count_insert++;
          text_insert += diffs[pointer][1];
          pointer++;
          break;
        case ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_DELETE:
          count_delete++;
          text_delete += diffs[pointer][1];
          pointer++;
          break;
        case ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_EQUAL:
          let previous_equality = pointer - count_insert - count_delete - 1;
          if (fix_unicode) {
            // prevent splitting of unicode surrogate pairs.  when fix_unicode is true,

            // we assume that the old and new text in the diff are complete and correct

            // unicode-encoded JS strings, but the tuple boundaries may fall between

            // surrogate pairs.  we fix this by shaving off stray surrogates from the end

            // of the previous equality and the beginning of this equality.  this may create

            // empty equalities or a common prefix or suffix.  for example, if AB and AC are

            // emojis, `[[0, 'A'], [-1, 'BA'], [0, 'C']]` would turn into deleting 'ABAC' and

            // inserting 'AC', and then the common suffix 'AC' will be eliminated.  in this

            // particular case, both equalities go away, we absorb any previous inequalities,

            // and we keep scanning for the next equality before rewriting the tuples.
            if (previous_equality >= 0 &&
              ___R$$priv$project$rome$$romejs$string$diff$index_ts$ends_with_pair_start(
                diffs[previous_equality][1],
              )) {
              let stray = diffs[previous_equality][1].slice(-1);
              diffs[previous_equality][1] =
                diffs[previous_equality][1].slice(
                  0,
                  -1,
                );
              text_delete = stray + text_delete;
              text_insert = stray + text_insert;
              if (!diffs[previous_equality][1]) {
                // emptied out previous equality, so delete it and include previous delete/insert
                diffs.splice(previous_equality, 1);
                pointer--;
                let k = previous_equality - 1;
                if (diffs[k] && diffs[k][0] === ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_INSERT) {
                  count_insert++;
                  text_insert = diffs[k][1] + text_insert;
                  k--;
                }
                if (diffs[k] && diffs[k][0] === ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_DELETE) {
                  count_delete++;
                  text_delete = diffs[k][1] + text_delete;
                  k--;
                }
                previous_equality = k;
              }
            }
            if (___R$$priv$project$rome$$romejs$string$diff$index_ts$starts_with_pair_end(diffs[pointer][1])) {
              let stray = diffs[pointer][1].charAt(0);
              diffs[pointer][1] = diffs[pointer][1].slice(1);
              text_delete += stray;
              text_insert += stray;
            }
          }
          if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
            // for empty equality not at end, wait for next equality
            diffs.splice(pointer, 1);
            break;
          }
          if (text_delete.length > 0 || text_insert.length > 0) {
            // note that commonPrefix and commonSuffix are unicode-aware
            if (text_delete.length > 0 && text_insert.length > 0) {
              // Factor out any common prefixes.
              commonlength = ___R$$priv$project$rome$$romejs$string$diff$index_ts$commonPrefix(text_insert, text_delete);
              if (commonlength !== 0) {
                if (previous_equality >= 0) {
                  diffs[previous_equality][1] +=
                    text_insert.substring(
                      0,
                      commonlength,
                    );
                } else {
                  diffs.splice(
                    0,
                    0,
                    [
                      ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_EQUAL,
                      text_insert.substring(0, commonlength),
                    ],
                  );
                  pointer++;
                }
                text_insert = text_insert.substring(commonlength);
                text_delete = text_delete.substring(commonlength);
              }

              // Factor out any common suffixes.
              commonlength = ___R$$priv$project$rome$$romejs$string$diff$index_ts$commonSuffix(text_insert, text_delete);
              if (commonlength !== 0) {
                diffs[pointer][1] =
                  text_insert.substring(
                    text_insert.length -
                    commonlength,
                  ) +
                  diffs[pointer][1];
                text_insert =
                  text_insert.substring(
                    0,
                    text_insert.length -
                    commonlength,
                  );
                text_delete =
                  text_delete.substring(
                    0,
                    text_delete.length -
                    commonlength,
                  );
              }
            }

            // Delete the offending records and add the merged ones.
            let n = count_insert + count_delete;
            if (text_delete.length === 0 && text_insert.length === 0) {
              diffs.splice(pointer - n, n);
              pointer = pointer - n;
            } else if (text_delete.length === 0) {
              diffs.splice(pointer - n, n, [___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_INSERT, text_insert]);
              pointer = pointer - n + 1;
            } else if (text_insert.length === 0) {
              diffs.splice(pointer - n, n, [___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_DELETE, text_delete]);
              pointer = pointer - n + 1;
            } else {
              diffs.splice(
                pointer - n,
                n,
                [___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_DELETE, text_delete],
                [
                  ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_INSERT,
                  text_insert,
                ],
              );
              pointer = pointer - n + 2;
            }
          }
          if (pointer !== 0 && diffs[pointer - 1][0] === ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_EQUAL) {
            // Merge this equality with the previous one.
            diffs[pointer - 1][1] += diffs[pointer][1];
            diffs.splice(pointer, 1);
          } else {
            pointer++;
          }
          count_insert = 0;
          count_delete = 0;
          text_delete = '';
          text_insert = '';
          break;
      }
    }
    if (diffs[diffs.length - 1][1] === '') {
      diffs.pop(); // Remove the dummy entry at the end.
    }

    // Second pass: look for single edits surrounded on both sides by equalities

    // which can be shifted sideways to eliminate an equality.

    // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
    let changes = false;
    pointer = 1;
    // Intentionally ignore the first and last element (don't need checking).

    while (pointer < diffs.length - 1) {
      if (diffs[pointer - 1][0] === ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_EQUAL &&
        diffs[pointer + 1][0] ===
        ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_EQUAL) {
        // This is a single edit surrounded by equalities.
        if (diffs[pointer][1].substring(
          diffs[pointer][1].length -
          diffs[pointer -
          1][1].length,
        ) ===
        diffs[pointer - 1][1]) {
          // Shift the edit over the previous equality.
          diffs[pointer][1] =
            diffs[pointer - 1][1] +
            diffs[pointer][1].substring(
              0,
              diffs[pointer][1].length - diffs[pointer - 1][1].length,
            );
          diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
          diffs.splice(pointer - 1, 1);
          changes = true;
        } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
        diffs[pointer + 1][1]) {
          // Shift the edit over the next equality.
          diffs[pointer - 1][1] += diffs[pointer + 1][1];
          diffs[pointer][1] =
            diffs[pointer][1].substring(
              diffs[pointer + 1][1].length,
            ) +
            diffs[pointer + 1][1];
          diffs.splice(pointer + 1, 1);
          changes = true;
        }
      }
      pointer++;
    }
    // If shifts were made, the diff needs reordering and another shift sweep.
    if (changes) {
      ___R$$priv$project$rome$$romejs$string$diff$index_ts$cleanupMerge(diffs, fix_unicode);
    }
  }

  function ___R$$priv$project$rome$$romejs$string$diff$index_ts$is_surrogate_pair_start(charCode) {
    return charCode >= 55296 && charCode <= 56319;
  }

  function ___R$$priv$project$rome$$romejs$string$diff$index_ts$is_surrogate_pair_end(charCode) {
    return charCode >= 56320 && charCode <= 57343;
  }

  function ___R$$priv$project$rome$$romejs$string$diff$index_ts$starts_with_pair_end(str) {
    return ___R$$priv$project$rome$$romejs$string$diff$index_ts$is_surrogate_pair_end(str.charCodeAt(0));
  }

  function ___R$$priv$project$rome$$romejs$string$diff$index_ts$ends_with_pair_start(str) {
    return ___R$$priv$project$rome$$romejs$string$diff$index_ts$is_surrogate_pair_start(str.charCodeAt(str.length - 1));
  }

  // project-rome/@romejs/cli-diagnostics/constants.ts
const ___R$project$rome$$romejs$cli$diagnostics$constants_ts = {
    get GUTTER() {
      return (
        ___R$project$rome$$romejs$cli$diagnostics$constants_ts$GUTTER
      );
    },

    get CODE_FRAME_INDENT() {
      return (
        ___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT
      );
    },

    get CODE_FRAME_SELECTED_INDENT() {
      return (
        ___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_SELECTED_INDENT
      );
    },

    get FILENAME_INDENT() {
      return (
        ___R$project$rome$$romejs$cli$diagnostics$constants_ts$FILENAME_INDENT
      );
    },

    get MAX_CODE_FRAME_LINES() {
      return (
        ___R$project$rome$$romejs$cli$diagnostics$constants_ts$MAX_CODE_FRAME_LINES
      );
    },

    get HALF_MAX_CODE_FRAME_LINES() {
      return (
        ___R$project$rome$$romejs$cli$diagnostics$constants_ts$HALF_MAX_CODE_FRAME_LINES
      );
    },

    get CODE_FRAME_CONTEXT_LINES() {
      return (
        ___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_CONTEXT_LINES
      );
    },
  };
  const ___R$project$rome$$romejs$cli$diagnostics$constants_ts$GUTTER = ' \u2502 ';
  const ___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT = '  ';
  const ___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_SELECTED_INDENT = ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.red('>') +
  ' ';
  const ___R$project$rome$$romejs$cli$diagnostics$constants_ts$FILENAME_INDENT = '  ';

  const ___R$project$rome$$romejs$cli$diagnostics$constants_ts$MAX_CODE_FRAME_LINES = 8;
  const ___R$project$rome$$romejs$cli$diagnostics$constants_ts$HALF_MAX_CODE_FRAME_LINES = ___R$project$rome$$romejs$cli$diagnostics$constants_ts$MAX_CODE_FRAME_LINES / 2;
  const ___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_CONTEXT_LINES = 2;

  // project-rome/@romejs/cli-diagnostics/buildPatchCodeFrame.ts
function ___R$$priv$project$rome$$romejs$cli$diagnostics$buildPatchCodeFrame_ts$formatDiffLine(diffs) {
    return (
      diffs.map(
        ([type, text]) => {
          if (type === ___R$project$rome$$romejs$string$diff$index_ts$constants.DELETE) {
            return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.red(___R$project$rome$$romejs$cli$diagnostics$utils_ts$showInvisibles(text));
          } else if (type === ___R$project$rome$$romejs$string$diff$index_ts$constants.ADD) {
            return ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.green(___R$project$rome$$romejs$cli$diagnostics$utils_ts$showInvisibles(text));
          } else {
            // type === diffConstants.EQUAL
            return text;
          }
        },
      ).join(
        '',
      )
    );
  }

  const ___R$$priv$project$rome$$romejs$cli$diagnostics$buildPatchCodeFrame_ts$DELETE_MARKER = ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.red('-');
  const ___R$$priv$project$rome$$romejs$cli$diagnostics$buildPatchCodeFrame_ts$ADD_MARKER = ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.green('+');

  function ___R$project$rome$$romejs$cli$diagnostics$buildPatchCodeFrame_ts$default(rawDiffs) {
    const diffsByLine = ___R$project$rome$$romejs$string$diff$index_ts$groupDiffByLines(rawDiffs);
    let lastVisibleLine = -1;

    // Calculate the parts of the diff we should show
    const shownLines = new Set();
    for (let i = 0;
    i < diffsByLine.length;
    i++) {
      const diffs = diffsByLine[i];

      let hasChange = false;
      for (const [type] of diffs) {
        if (type === ___R$project$rome$$romejs$string$diff$index_ts$constants.DELETE || type === ___R$project$rome$$romejs$string$diff$index_ts$constants.ADD) {
          hasChange = true;
          break;
        }
      }

      if (hasChange) {
        for (let start = i - ___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_CONTEXT_LINES;
        start < i + ___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_CONTEXT_LINES;
        start++) {
          shownLines.add(start);

          if (start > lastVisibleLine) {
            lastVisibleLine = start;
          }
        }
      }
    }

    const lineLength = String(lastVisibleLine).length;

    // Don't output a gutter if there's only a single line
    const noGutter = diffsByLine.length === 1;

    // Build the actual frame
    const frame = [];
    let lastDisplayedLine = -1;
    for (let i = 0;
    i < diffsByLine.length;
    i++) {
      if (shownLines.has(i) === false) {
        continue;
      }

      const diffs = diffsByLine[i];
      const lineNo = i + 1;

      if (noGutter) {
        frame.push('  ' +
        ___R$$priv$project$rome$$romejs$cli$diagnostics$buildPatchCodeFrame_ts$formatDiffLine(diffs));
        lastDisplayedLine = lineNo;
        continue;
      }

      const deletions = [];
      const addition = [];

      let hasDeletions = false;
      let hasAddition = false;

      for (const tuple of diffs) {
        let [type] = tuple;

        if (type === ___R$project$rome$$romejs$string$diff$index_ts$constants.DELETE) {
          hasDeletions = true;
          deletions.push(tuple);
        }

        if (type === ___R$project$rome$$romejs$string$diff$index_ts$constants.ADD) {
          hasAddition = true;
          addition.push(tuple);
        }

        if (type === ___R$project$rome$$romejs$string$diff$index_ts$constants.EQUAL) {
          addition.push(tuple);
          deletions.push(tuple);
        }
      }

      if (lastDisplayedLine !== lineNo - 1 && lastDisplayedLine !== -1) {
        frame.push(
          ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bold(
            '' +
            ___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT +
            '.'.repeat(lineLength) +
            ___R$project$rome$$romejs$cli$diagnostics$constants_ts$GUTTER,
          ),
        );
      }

      const gutter = ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bold(
        '' +
        ___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT +
        ___R$project$rome$$romejs$string$ansi$pad_ts$leftPad(
          String(lineNo),
          lineLength,
        ) +
        ___R$project$rome$$romejs$cli$diagnostics$constants_ts$GUTTER,
      );

      if (hasAddition) {
        frame.push('' +
        gutter +
        ___R$$priv$project$rome$$romejs$cli$diagnostics$buildPatchCodeFrame_ts$ADD_MARKER +
        ' ' +
        ___R$$priv$project$rome$$romejs$cli$diagnostics$buildPatchCodeFrame_ts$formatDiffLine(addition));
      }

      if (hasDeletions) {
        frame.push('' +
        gutter +
        ___R$$priv$project$rome$$romejs$cli$diagnostics$buildPatchCodeFrame_ts$DELETE_MARKER +
        ' ' +
        ___R$$priv$project$rome$$romejs$cli$diagnostics$buildPatchCodeFrame_ts$formatDiffLine(deletions));
      }

      if (!hasAddition && !hasDeletions) {
        // Output one of the lines, they're the same
        frame.push(gutter +
        '  ' +
        ___R$$priv$project$rome$$romejs$cli$diagnostics$buildPatchCodeFrame_ts$formatDiffLine(addition));
      }

      lastDisplayedLine = lineNo;
    }

    return frame.join('\n');
  }

  // project-rome/@romejs/cli-diagnostics/buildMessageCodeFrame.ts
function ___R$project$rome$$romejs$cli$diagnostics$buildMessageCodeFrame_ts$default(
    allLines,
    start,
    end,
    maybeMarkerMessage,
  ) {
    let markerMessage = maybeMarkerMessage === undefined
      ? '' : maybeMarkerMessage;

    const startLineIndex = ___R$project$rome$$romejs$ob1$index_ts$coerce1to0(start.line);

    let endLineIndex = ___R$project$rome$$romejs$ob1$index_ts$coerce1to0(end.line);
    let endLineCol = end.column;

    let markerOffset = end.column;
    let markerSize = ___R$project$rome$$romejs$ob1$index_ts$number0;

    // Increase the amount of lines we should show for "context"
    let contextStartIndex = ___R$project$rome$$romejs$ob1$index_ts$coerce0(
      Math.max(
        0,
        ___R$project$rome$$romejs$ob1$index_ts$get0(startLineIndex) -
        ___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_CONTEXT_LINES,
      ),
    );
    let contextEndIndex = ___R$project$rome$$romejs$ob1$index_ts$coerce0(
      Math.min(
        allLines.length - 1,
        ___R$project$rome$$romejs$ob1$index_ts$get0(endLineIndex) + ___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_CONTEXT_LINES,
      ),
    );

    let formattedLines = [];
    for (let i = contextStartIndex;
    i <= contextEndIndex;
    i = ___R$project$rome$$romejs$ob1$index_ts$inc(i)) {
      let line = allLines[___R$project$rome$$romejs$ob1$index_ts$get0(i)];
      if (line === undefined) {
        continue;
      }

      // Ensure that the frame doesn't start with whitespace
      if (line.trim() === '' && formattedLines.length === 0 && i !== startLineIndex) {
        continue;
      }

      // If this is within the highlighted line range
      const shouldHighlight = i >= startLineIndex && i <= endLineIndex;

      if (shouldHighlight) {
        // Range to highlight
        let startCol = ___R$project$rome$$romejs$ob1$index_ts$number0;
        let endCol = ___R$project$rome$$romejs$ob1$index_ts$coerce0(line.length);

        // First line in selection
        if (i === startLineIndex) {
          startCol = start.column;
        }

        // Last line in selection
        if (i === endLineIndex) {
          endCol = endLineCol;

          // Sometimes the end will be the same as the start if we just want to make a single place

          // and not perform highlighting
          if (endCol > startCol) {
            markerSize = ___R$project$rome$$romejs$ob1$index_ts$sub(endCol, startCol);
            markerOffset = ___R$project$rome$$romejs$ob1$index_ts$sub(markerOffset, markerSize);
          }
        }
      }

      const lineNo = ___R$project$rome$$romejs$ob1$index_ts$coerce0to1(i);
      let gutter = '' +
      String(lineNo) +
      ___R$project$rome$$romejs$cli$diagnostics$constants_ts$GUTTER;

      if (shouldHighlight) {
        gutter = '' +
        ___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_SELECTED_INDENT +
        gutter;
      } else {
        gutter = '' +
        ___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT +
        gutter;
      }

      formattedLines.push(
        {
          gutter,
          line: ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(line),
          lineIndex: i,
        },
      );
    }

    // If we have too many lines in our selection, then collapse them to an ellipsis
    const pruned = formattedLines.length > ___R$project$rome$$romejs$cli$diagnostics$constants_ts$MAX_CODE_FRAME_LINES + 2;
    if (pruned) {
      const start = formattedLines.slice(0, ___R$project$rome$$romejs$cli$diagnostics$constants_ts$HALF_MAX_CODE_FRAME_LINES);
      const end = formattedLines.slice(-___R$project$rome$$romejs$cli$diagnostics$constants_ts$HALF_MAX_CODE_FRAME_LINES);
      formattedLines = start.concat([undefined], end);
    }

    // Remove trailing blank lines
    for (let i = formattedLines.length - 1;
    i >= 0;
    i--) {
      const info = formattedLines[i];
      if (info !== undefined && info.line === '') {
        formattedLines.pop();
      } else {
        break;
      }
    }

    // If there's no lines to target then return the normal marker
    if (formattedLines.length === 0 || end.line === ___R$project$rome$$romejs$ob1$index_ts$number1Neg1 ||
    start.line ===
    ___R$project$rome$$romejs$ob1$index_ts$number1Neg1) {
      return ___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT + markerMessage;
    }

    // Don't output a gutter if there's only a single line
    const noGutter = allLines.length === 1;

    // Calculate max size of gutter, this is the maximum visible line plus the futter length plus the frame indent
    const lastLine = formattedLines[formattedLines.length - 1];
    if (lastLine === undefined) {
      throw new Error('Expected there to be a last line');
    }

    // Calculate the max width of the gutter based on the line count
    const maxVisibleLineNo = ___R$project$rome$$romejs$ob1$index_ts$get0(lastLine.lineIndex) + 1;
    const maxGutterLength = String(maxVisibleLineNo).length + ___R$project$rome$$romejs$cli$diagnostics$constants_ts$GUTTER.length +
    ___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT.length;

    // If what the marker is highlighting equals the marker message then it's redundant so don't show the message
    if (markerMessage !== '' && start.line === end.line) {
      const markerLine = ___R$project$rome$$romejs$string$ansi$format_ts$stripAnsi(allLines[___R$project$rome$$romejs$ob1$index_ts$get0(___R$project$rome$$romejs$ob1$index_ts$coerce1to0(start.line))]);
      const text = markerLine.slice(___R$project$rome$$romejs$ob1$index_ts$get0(start.column), ___R$project$rome$$romejs$ob1$index_ts$get0(end.column));
      if (___R$project$rome$$romejs$cli$diagnostics$utils_ts$cleanEquivalentString(text) === ___R$project$rome$$romejs$cli$diagnostics$utils_ts$cleanEquivalentString(markerMessage)) {
        markerMessage = '';
      }
    }

    const pointerLength = Math.max(___R$project$rome$$romejs$ob1$index_ts$get0(markerSize), 1);
    const pointer = ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.red(
      ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bold(
        '^'.repeat(
          pointerLength,
        ),
      ),
    );
    const pointerIndent = ' '.repeat(___R$project$rome$$romejs$ob1$index_ts$get0(markerOffset));

    // If the marker is just pointing to the first character and we have no message, no point showing it
    const noMarkerLine = ___R$project$rome$$romejs$ob1$index_ts$get0(markerOffset) === 0 && pointerLength === 1 &&
      markerMessage === '';

    // Output no gutter with a soft indent if this is true
    if (noGutter) {
      const result = [...allLines].map((line) => ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(line));
      if (!noMarkerLine) {
        result.push('' +
        pointerIndent +
        pointer +
        ' ' +
        markerMessage);
      }
      return ___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT + result.join('\n' +
      ___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT);
    }

    // Build marker
    const markerGutterIndent = ' '.repeat(maxGutterLength - ___R$project$rome$$romejs$cli$diagnostics$constants_ts$GUTTER.length);
    const markerLine = '' +
    markerGutterIndent +
    ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bold(___R$project$rome$$romejs$cli$diagnostics$constants_ts$GUTTER) +
    pointerIndent +
    pointer +
    ' ' +
    markerMessage;

    // Build up the line we display when source lines are omitted
    const omittedDots = '...';
    const omittedLine = ___R$project$rome$$romejs$string$ansi$pad_ts$leftPad(
      ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bold(omittedDots) + ___R$project$rome$$romejs$cli$diagnostics$constants_ts$GUTTER,
      maxGutterLength,
    );

    // Build the frame
    const result = [];
    for (const selection of formattedLines) {
      if (!selection) {
        result.push(omittedLine);
        continue;
      }

      const {gutter, line, lineIndex} = selection;

      if (noGutter) {
        result.push(line);
      } else {
        result.push(___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bold(___R$project$rome$$romejs$string$ansi$pad_ts$leftPad(gutter, maxGutterLength)) + line);
      }
      if (lineIndex === endLineIndex && !noMarkerLine) {
        result.push(markerLine);
      }
    }

    const frame = result.join('\n');
    return frame;
  }

  // project-rome/@romejs/cli-diagnostics/printAdvice.ts
function ___R$project$rome$$romejs$cli$diagnostics$printAdvice_ts$default(
    item,
    opts,
  ) {
    switch (item.type) {
      case 'log':
        return ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printLog(item, opts);

      case 'list':
        return ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printList(item, opts);

      case 'diff':
        return ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printDiff(item, opts);

      case 'code':
        return ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printCode(item, opts);

      case 'frame':
        return ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printFrame(item, opts);

      case 'stacktrace':
        return ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printStacktrace(item, opts);

      case 'inspect':
        return ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printInspect(item, opts);
    }
  }

  function ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printInspect(
    item,
    opts,
  ) {
    const {reporter} = opts;
    reporter.indent(
      () => {
        reporter.inspect(item.data);
      },
    );
    return false;
  }

  function ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printDiff(
    item,
    opts,
  ) {
    const frame = ___R$project$rome$$romejs$cli$diagnostics$buildPatchCodeFrame_ts$default(item.diff);
    if (frame === '') {
      return true;
    }

    opts.reporter.logAll(___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(frame));

    const {legend} = item;
    if (legend !== undefined) {
      opts.reporter.spacer();
      opts.reporter.logAll('<green>+ ' +
      ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(legend.add) +
      '</green>');
      opts.reporter.logAll('<red>- ' +
      ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(legend.delete) +
      '</red>');
      opts.reporter.spacer();
    }

    return false;
  }

  function ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printList(
    item,
    opts,
  ) {
    if (item.list.length === 0) {
      return true;
    } else {
      opts.reporter.list(
        item.list,
        {
          truncate: opts.flags.verboseDiagnostics ? undefined : 20,
          reverse: item.reverse,
          ordered: item.ordered,
        },
      );
      return false;
    }
  }

  function ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printCode(
    item,
    opts,
  ) {
    const {reporter} = opts;
    const {code} = item;
    reporter.indent(
      () => {
        reporter.logAll(___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(code));
      },
    );
    return false;
  }

  function ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printFrame(
    item,
    opts,
  ) {
    const {reporter} = opts;
    const {start, end, filename, sourceText, marker} = item;
    const path = ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(filename);

    let cleanMarker = '';
    if (marker !== undefined) {
      cleanMarker = ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bold(___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$cleanMessage(marker));
    }

    let lines;
    if (sourceText !== undefined) {
      lines =
        ___R$project$rome$$romejs$cli$diagnostics$utils_ts$toLines(
          {
            path,
            input: sourceText,
            sourceType: item.sourceType,
            language: item.language,
          },
        );
    } else if (filename !== undefined) {
      lines = opts.fileSources.get(path);
    } else if (path.isAbsolute() &&
      opts.missingFileSources.has(
        path.assertAbsolute(),
      )) {
      lines = [___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.dim('file does not exist')];
    }

    if (lines === undefined) {
      lines = [];
    }

    const frame = ___R$project$rome$$romejs$cli$diagnostics$buildMessageCodeFrame_ts$default(lines, start, end, cleanMarker);
    if (frame.trim() === '') {
      return true;
    }

    reporter.logAll(___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(frame));
    return false;
  }

  function ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printStacktrace(
    item,
    opts,
  ) {
    // Here we duplicate some of the list logic that is in Reporter

    // This is different as we also want to push frames after some of the items

    const {diagnostic} = opts;
    const {frames} = item;

    let shownCodeFrames = 0;

    const isFirstPart = diagnostic.advice[0] === item;
    if (!isFirstPart) {
      opts.reporter.info(item.title === undefined ? 'Stack trace' : item.title);
      opts.reporter.forceSpacer();
    }

    opts.reporter.processedList(
      frames,
      (frame, display) => {
        const {
          filename,
          object,
          suffix,
          property,
          prefix,
          line,
          column,
          language,
          sourceText: code,
        } = frame;

        const logParts = [];

        // Add prefix
        if (prefix !== undefined) {
          logParts.push(___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.dim(___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(prefix)));
        }

        // Build path
        const objParts = [];
        if (object !== undefined) {
          objParts.push(___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.magenta(___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(object)));
        }
        if (property !== undefined) {
          objParts.push(___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.cyan(___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(property)));
        }
        if (objParts.length > 0) {
          logParts.push(objParts.join('.'));
        }

        // Add suffix
        if (suffix !== undefined) {
          logParts.push(___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.green(___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(suffix)));
        }

        // Add source
        if (filename !== undefined && line !== undefined && column !== undefined) {
          const header = ___R$project$rome$$romejs$diagnostics$derive_ts$getDiagnosticHeader(
            {
              filename,
              start: {
                index: ___R$project$rome$$romejs$ob1$index_ts$number0Neg1,
                line,
                column,
              },
            },
          );

          if (logParts.length === 0) {
            logParts.push(header);
          } else {
            logParts.push('(' +
            ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.dim(header) +
            ')');
          }
        }

        display(logParts.join(' '));

        // Push on frame
        if (shownCodeFrames < 2 && filename !== undefined && line !== undefined &&
          column !== undefined) {
          const pos = {
            index: ___R$project$rome$$romejs$ob1$index_ts$number0Neg1,
            line,
            column,
          };

          const skipped = ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printFrame(
            {
              type: 'frame',
              language,
              filename,
              sourceType: 'module',
              marker: undefined,
              mtime: undefined,
              start: pos,
              end: pos,
              sourceText: code,
            },
            opts,
          );
          if (!skipped) {
            opts.reporter.forceSpacer();
            shownCodeFrames++;
          }
        }
      },
      {
        ordered: true,
        truncate: opts.flags.verboseDiagnostics ? undefined : 20,
      },
    );

    return false;
  }

  function ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printLog(
    item,
    opts,
  ) {
    const {reporter} = opts;
    const {message, category} = item;

    if (message !== undefined) {
      switch (category) {
        case 'none':
          reporter.logAll(message);
          break;

        case 'warn':
          reporter.warn(message);
          break;

        case 'info':
          reporter.info(message);
          break;

        case 'error':
          reporter.error(message);
          break;

        default:
          throw new Error('Unknown message item log category ' +
          category);
      }
    }

    return item.compact;
  }

  function ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$cleanMessage(msg) {
    msg = msg.trim();
    if (msg.endsWith('.')) {
      msg = msg.slice(0, -1);
    }
    return msg;
  }

  // project-rome/@romejs/cli-diagnostics/banners/success.json
const ___R$project$rome$$romejs$cli$diagnostics$banners$success_json$default = {'palettes': [[240, 240, 240], [240, 240, 225], [225, 225, 210], [225, 210, 210], [240, 225, 225], [210, 210, 195], [210, 195, 180], [195, 195, 165], [195, 180, 165], [225, 210, 195], [195, 195, 180], [225, 225, 225], [180, 180, 150], [180, 165, 150], [195, 180, 150], [195, 165, 150], [180, 165, 135], [180, 150, 135], [195, 165, 135], [225, 225, 195], [210, 210, 180], [210, 180, 150], [210, 180, 165], [225, 180, 180], [240, 180, 165], [240, 195, 195], [225, 195, 180], [165, 135, 120], [165, 150, 120], [195, 135, 120], [225, 150, 135], [240, 165, 165], [225, 180, 165], [225, 195, 165], [150, 120, 105], [150, 135, 105], [180, 150, 120], [195, 120, 105], [210, 135, 105], [210, 150, 120], [195, 150, 135], [210, 195, 165], [180, 105, 75], [195, 105, 90], [180, 90, 75], [240, 180, 180], [240, 225, 210], [240, 240, 210], [150, 120, 90], [180, 135, 120], [210, 150, 135], [210, 165, 150], [195, 150, 120], [225, 180, 150], [195, 120, 90], [180, 105, 90], [225, 165, 135], [225, 210, 180], [240, 210, 195], [225, 195, 195], [180, 135, 105], [225, 180, 135], [210, 135, 120], [225, 165, 150], [240, 180, 150], [210, 180, 180], [165, 135, 90], [180, 120, 90], [195, 135, 105], [225, 150, 120], [180, 135, 135], [210, 150, 150], [210, 195, 195], [210, 195, 210], [150, 135, 135], [195, 195, 195], [225, 210, 225], [180, 180, 135], [165, 120, 90], [240, 150, 135], [240, 165, 135], [240, 165, 150], [180, 90, 60], [180, 165, 165], [165, 135, 135], [180, 180, 180], [165, 150, 135], [150, 90, 45], [150, 75, 45], [210, 165, 135], [165, 165, 165], [165, 120, 75], [180, 135, 90], [150, 60, 45], [165, 105, 60], [165, 90, 60], [150, 105, 105], [210, 210, 210], [165, 105, 75], [225, 165, 165], [180, 120, 75], [165, 90, 75], [135, 90, 75], [195, 180, 180], [240, 195, 180], [135, 120, 120], [165, 135, 105], [150, 105, 75], [225, 150, 150], [240, 210, 180], [165, 150, 150], [165, 150, 105], [225, 135, 120], [210, 120, 105], [150, 90, 75], [180, 120, 105], [180, 150, 105], [240, 195, 165], [180, 165, 120], [225, 135, 135], [180, 105, 105], [195, 120, 120], [150, 75, 60], [105, 15, 15], [105, 15, 0], [120, 30, 30], [120, 30, 15], [105, 45, 30], [150, 90, 60], [210, 120, 120], [165, 75, 75], [90, 30, 30], [90, 15, 15], [120, 15, 30], [120, 15, 15], [90, 0, 0], [135, 45, 45], [165, 105, 90], [210, 105, 90], [135, 75, 45], [240, 210, 210], [225, 240, 225], [60, 30, 15], [45, 0, 0], [60, 15, 15], [75, 30, 15], [120, 60, 60], [195, 90, 75], [150, 45, 45], [75, 0, 15], [60, 0, 0], [75, 0, 0], [150, 105, 60], [135, 90, 45], [60, 45, 30], [105, 30, 30], [120, 15, 0], [150, 75, 75], [120, 105, 90], [105, 60, 45], [120, 75, 45], [60, 15, 0], [75, 15, 15], [105, 30, 15], [195, 105, 105], [165, 60, 60], [135, 15, 15], [180, 180, 165], [105, 90, 90], [30, 15, 15], [60, 30, 30], [135, 60, 60], [150, 45, 30], [150, 75, 30], [240, 225, 195], [75, 15, 0], [90, 15, 0], [120, 45, 30], [240, 150, 150], [105, 90, 75], [105, 75, 60], [105, 105, 105], [45, 45, 45], [30, 30, 15], [180, 60, 45], [165, 60, 30], [180, 90, 45], [135, 75, 30], [195, 135, 90], [135, 60, 45], [135, 75, 60], [90, 60, 30], [90, 60, 45], [30, 15, 0], [15, 15, 15], [45, 30, 15], [195, 90, 60], [180, 105, 60], [120, 75, 30], [105, 60, 30], [120, 60, 30], [15, 0, 0], [75, 45, 45], [180, 75, 30], [180, 120, 60], [90, 45, 30], [60, 45, 45], [60, 45, 60], [45, 30, 30], [75, 45, 30], [75, 45, 15], [195, 105, 75], [165, 45, 30], [165, 45, 15], [30, 0, 15], [45, 15, 15], [135, 60, 30], [210, 105, 60], [195, 120, 75], [75, 60, 30], [120, 120, 105], [165, 75, 60], [135, 45, 15], [195, 60, 45], [90, 30, 45], [165, 75, 30], [135, 90, 60], [135, 105, 60], [165, 90, 90], [120, 45, 45], [165, 75, 45], [210, 135, 60], [135, 90, 30], [165, 60, 45], [105, 75, 45], [195, 135, 45], [135, 105, 75], [75, 30, 30], [135, 105, 90], [195, 120, 45], [180, 105, 30], [135, 120, 90], [150, 60, 60], [180, 75, 75], [150, 60, 15], [150, 75, 15], [165, 120, 105], [180, 90, 90], [195, 90, 105], [210, 105, 105], [0, 0, 0], [15, 0, 15], [180, 105, 45], [120, 60, 45], [120, 60, 15], [90, 30, 15], [30, 0, 0], [15, 15, 0], [165, 90, 45], [180, 90, 30], [105, 30, 0], [180, 75, 45], [135, 45, 0], [120, 45, 15], [105, 45, 15], [45, 15, 0], [195, 90, 90], [90, 60, 60], [120, 75, 60], [135, 45, 30], [90, 45, 15], [225, 240, 240], [105, 75, 75], [150, 60, 30], [165, 180, 180], [180, 45, 60], [150, 45, 15], [135, 135, 135], [180, 60, 30], [90, 105, 105], [150, 135, 120], [105, 60, 60], [105, 45, 45], [225, 150, 105], [120, 120, 120], [105, 30, 45], [210, 150, 105], [90, 90, 90], [15, 30, 15], [45, 0, 15], [135, 30, 30], [180, 45, 30], [135, 30, 15], [75, 75, 75], [15, 15, 30], [0, 0, 15], [195, 60, 30], [210, 60, 45], [195, 90, 45], [210, 105, 75], [120, 90, 90], [45, 30, 45], [90, 45, 45], [0, 15, 0], [195, 75, 45], [195, 75, 60], [30, 30, 0], [135, 120, 105], [225, 195, 210], [60, 60, 60], [0, 15, 15], [15, 30, 45], [45, 45, 60], [30, 15, 30], [150, 30, 15], [30, 30, 30], [90, 75, 90], [90, 15, 30], [165, 165, 150], [120, 105, 60], [120, 120, 60], [60, 60, 45], [30, 45, 30], [60, 15, 30], [120, 30, 45], [60, 30, 45], [90, 90, 75], [135, 150, 60], [90, 90, 30], [30, 45, 45], [90, 75, 75], [120, 105, 105], [75, 30, 45], [60, 75, 60], [75, 15, 30], [45, 15, 30], [45, 60, 45], [120, 120, 90], [90, 15, 45], [75, 75, 60], [150, 150, 135], [75, 75, 45], [225, 120, 120], [75, 60, 60], [105, 105, 75], [120, 135, 90], [90, 90, 60], [135, 45, 60], [135, 30, 45], [75, 90, 75], [60, 75, 45], [210, 90, 60], [120, 45, 60], [150, 150, 150], [105, 120, 60], [105, 105, 60], [30, 30, 45], [135, 75, 75], [150, 45, 60], [225, 135, 90], [195, 105, 60], [195, 210, 195], [120, 75, 75], [90, 60, 75], [195, 135, 75], [210, 120, 75], [210, 225, 225], [150, 75, 90], [225, 135, 75], [210, 90, 75], [165, 120, 120], [210, 135, 75], [225, 105, 75], [180, 75, 60], [105, 45, 60], [225, 120, 75], [150, 90, 30], [165, 60, 75], [75, 45, 60], [225, 105, 60], [225, 90, 45], [225, 60, 30], [150, 30, 30], [150, 90, 90], [210, 135, 90], [150, 135, 90], [240, 75, 45], [135, 60, 75], [150, 105, 90], [240, 90, 60], [240, 105, 75], [210, 105, 45], [195, 150, 105], [240, 90, 45], [210, 120, 90], [45, 45, 30], [240, 105, 45], [210, 120, 45], [240, 90, 30], [210, 90, 45], [225, 120, 90], [195, 240, 195], [135, 240, 135], [75, 255, 60], [45, 255, 30], [45, 240, 30], [90, 225, 60], [105, 210, 75], [120, 135, 75], [195, 165, 165], [120, 150, 60], [30, 255, 0], [180, 180, 105], [165, 105, 105], [45, 240, 0], [45, 210, 0], [75, 105, 30], [30, 195, 0], [30, 225, 0], [30, 240, 0], [60, 240, 15], [90, 225, 30], [60, 195, 15], [30, 120, 15], [45, 105, 30], [105, 195, 30], [90, 225, 15], [75, 240, 30], [120, 195, 45], [105, 135, 30], [150, 165, 75], [180, 195, 30], [240, 75, 30], [165, 165, 45], [90, 225, 45], [105, 210, 45], [195, 165, 90], [135, 255, 135], [75, 255, 75], [90, 255, 90], [135, 240, 120], [165, 240, 150], [225, 240, 210], [90, 180, 75], [30, 135, 0], [135, 165, 45], [75, 210, 60], [90, 180, 30], [45, 210, 15], [150, 150, 60], [165, 195, 30], [225, 135, 60], [150, 210, 15], [135, 180, 45], [135, 225, 60], [210, 240, 210], [210, 240, 195], [195, 225, 195], [45, 165, 30], [30, 210, 15], [30, 150, 15], [15, 135, 0], [120, 165, 45], [45, 195, 15], [105, 90, 30], [105, 135, 45], [120, 180, 45], [105, 210, 30], [105, 195, 60], [120, 210, 45], [90, 120, 30], [210, 180, 105], [180, 180, 90], [135, 195, 60], [120, 210, 60], [135, 165, 60], [240, 135, 45], [180, 165, 75], [120, 165, 75], [195, 150, 75], [165, 180, 45], [120, 225, 30], [105, 165, 15], [75, 255, 45], [165, 240, 165], [150, 240, 150], [45, 135, 45], [30, 210, 0], [45, 120, 15], [150, 165, 60], [135, 195, 30], [90, 210, 30], [210, 120, 60], [135, 225, 105], [90, 255, 75], [120, 150, 45], [150, 240, 135], [90, 210, 75], [105, 90, 45], [60, 210, 15], [195, 180, 105], [195, 165, 105], [150, 165, 45], [195, 75, 15], [195, 60, 0], [135, 210, 15], [60, 240, 0], [150, 120, 15], [60, 195, 0], [75, 240, 15], [180, 240, 180], [105, 255, 90], [105, 150, 45], [105, 150, 30], [60, 240, 30], [75, 240, 60], [45, 225, 0], [150, 120, 75], [195, 180, 120], [210, 165, 120], [180, 165, 105], [210, 180, 120], [240, 105, 15], [165, 180, 30], [105, 240, 0], [135, 210, 30], [150, 165, 15], [120, 180, 30], [105, 240, 90], [60, 255, 45], [45, 255, 15], [90, 150, 30], [90, 240, 75], [90, 210, 15], [120, 90, 45], [105, 225, 60], [225, 195, 135], [165, 150, 90], [150, 165, 90], [225, 105, 30], [225, 120, 15], [120, 210, 15], [195, 120, 30], [150, 255, 150], [75, 135, 15], [105, 165, 75], [105, 210, 15], [180, 150, 90], [225, 165, 120], [210, 195, 135], [165, 135, 75], [210, 165, 105], [195, 165, 30], [75, 240, 0], [135, 210, 0], [165, 165, 30], [120, 165, 105], [75, 225, 0], [150, 180, 90], [180, 195, 105], [165, 180, 75], [150, 210, 30], [90, 240, 0], [210, 90, 30], [165, 90, 30], [195, 150, 90], [75, 210, 30], [225, 180, 120], [180, 135, 75], [225, 165, 90], [150, 180, 75], [225, 90, 30], [195, 120, 60], [210, 120, 30], [210, 180, 30], [135, 225, 0], [195, 150, 15], [225, 75, 30], [210, 75, 30], [195, 195, 150], [60, 255, 30], [195, 240, 180], [195, 30, 0], [165, 30, 15], [120, 150, 75], [210, 165, 75], [225, 165, 60], [195, 195, 45], [150, 165, 30], [195, 135, 60], [210, 195, 120], [240, 75, 15], [225, 150, 15], [240, 180, 15], [210, 165, 15], [210, 165, 45], [225, 90, 15], [210, 90, 15], [240, 120, 30], [210, 225, 180], [150, 120, 30], [45, 75, 0], [75, 120, 15], [75, 180, 30], [75, 195, 15], [195, 150, 60], [90, 195, 15], [120, 210, 30], [180, 165, 60], [195, 195, 105], [150, 225, 90], [135, 225, 75], [210, 150, 90], [195, 180, 30], [180, 180, 45], [225, 120, 30], [165, 195, 0], [165, 180, 15], [195, 165, 15], [225, 180, 30], [240, 180, 30], [225, 195, 15], [150, 225, 15], [135, 75, 15], [180, 180, 15], [195, 135, 30], [135, 225, 90], [180, 240, 165], [105, 255, 105], [150, 225, 135], [75, 225, 15], [195, 150, 45], [210, 165, 60], [120, 195, 30], [120, 225, 60], [195, 195, 75], [225, 180, 105], [225, 180, 45], [180, 225, 15], [180, 195, 90], [195, 210, 180], [90, 195, 30], [60, 225, 0], [105, 195, 45], [135, 150, 75], [165, 105, 45], [150, 135, 30], [105, 240, 15], [90, 240, 45], [195, 210, 105], [195, 195, 90], [210, 180, 90], [210, 195, 45], [150, 240, 0], [210, 180, 45], [225, 150, 90], [225, 150, 75], [60, 180, 0], [75, 210, 15], [90, 240, 15], [90, 240, 60], [210, 135, 45], [210, 150, 15], [225, 165, 30], [120, 90, 75], [225, 195, 120], [225, 165, 105], [240, 195, 30], [240, 195, 15], [210, 135, 30], [240, 165, 60], [210, 150, 30], [240, 195, 45], [240, 210, 30], [240, 180, 45], [225, 165, 45], [225, 150, 45], [225, 90, 60], [240, 150, 45], [150, 105, 45], [165, 105, 30], [210, 180, 135], [225, 195, 45], [225, 120, 45], [225, 180, 75], [225, 135, 30], [210, 165, 90], [240, 165, 45], [210, 105, 30], [225, 105, 45], [225, 75, 45], [225, 135, 45], [240, 150, 30], [150, 120, 60], [165, 120, 60], [180, 135, 15], [210, 150, 45], [225, 165, 75], [225, 150, 30], [240, 210, 15], [195, 90, 30], [240, 210, 150]], 'rows': [[[0, 95]], [[0, 95]], [[0, 95]], [[0, 25], 1, 1, 2, 1, 1, 3, 4, 1, 1, 5, 5, 2, 0, [1, 3], [0, 54]], [[0, 24], 2, 2, 5, 6, 7, 7, 8, 7, 9, 9, 7, 7, 10, 1, 5, 5, 1, [0, 54]], [[0, 22], 11, 1, 2, 12, 6, 13, 14, 15, 14, 14, 13, [14, 3], 8, 10, 7, 10, 11, [0, 54]], [[0, 21], 11, 3, 6, 7, 12, 15, [16, 3], 14, 14, 16, 16, [14, 4], 8, 8, 2, 1, 1, [0, 52]], [[0, 20], 11, 2, 8, [14, 3], 15, 15, 16, 16, 17, 18, 15, 17, [15, 4], 14, 8, 19, 20, 20, 1, [0, 18], 1, 3, 3, 1, [0, 29]], [[0, 19], 11, 5, 8, 14, 14, 21, 22, 16, 21, 14, 15, 15, 17, 17, 15, 17, 15, 18, 15, 16, 14, 8, 12, 5, 1, [0, 18], 23, 24, 25, 26, 1, [0, 28]], [[0, 17], 1, 1, 10, 12, 13, 15, 14, [21, 4], 18, 15, 17, 15, 27, 17, 28, 16, 16, 15, 28, 13, 16, 13, 6, 5, 11, [0, 16], 4, 29, 30, 31, 32, 4, [0, 28]], [[0, 17], 2, 10, 8, 14, 16, 15, 15, 21, 22, 18, 22, 33, 21, 14, 17, 17, 34, 35, 16, 15, 17, 36, 17, 16, 16, 13, 8, 5, [0, 16], 6, 37, 38, 39, 30, 2, [0, 28]], [[0, 17], 11, 6, 14, 16, 16, 18, 40, 17, 41, 17, 17, [22, 3], 17, 22, 21, 15, 21, 15, 17, 16, 36, 17, 27, 16, 14, 9, 1, [0, 15], 6, 42, 43, 37, 39, 2, [0, 4], 1, 1, [0, 22]], [[0, 17], 1, 10, 16, 18, 15, 22, 27, 27, 18, 17, 17, 15, 22, 22, 16, 21, 15, 22, 22, 21, 18, 36, 36, 27, 27, 16, 13, 8, 5, [0, 15], 8, 42, 44, 43, 39, 9, 0, 0, 1, 26, 45, 26, 46, [0, 21]], [[0, 17], 2, 47, 41, 18, 15, 21, 15, 48, 49, 50, 51, 40, 51, 40, 40, 52, 40, 51, 53, 51, 27, 18, 18, 17, 28, 16, 13, 16, 10, [0, 15], 15, 54, 42, 55, 56, 57, 1, 0, 6, 56, 24, 58, 59, 4, [0, 20]], [[0, 17], 11, 8, 14, [36, 3], 52, 60, 29, [50, 5], [39, 4], 52, 18, 15, 21, 21, 27, 27, 28, 15, 16, 8, 1, [0, 14], 17, 54, 54, 38, 61, 33, 0, 1, 29, 62, 63, 64, 24, 65, 3, 2, 1, [0, 17]], [[0, 17], 11, 8, 18, 66, 67, 67, 68, 39, [30, 7], 62, [69, 3], 40, 15, 22, 18, 36, 18, 15, 14, 14, 8, 1, [0, 14], 70, 67, 67, 37, 56, 53, 1, 9, 55, 37, 38, 38, 71, 72, 73, 74, 75, 3, 76, [0, 15]], [[0, 15], 1, 5, 7, 77, 18, 78, 54, 37, 38, 69, 30, 79, 80, 80, 30, 80, 81, 30, 69, 38, 38, 52, 15, 22, 22, 21, 16, 16, 15, 14, 14, 2, [0, 14], 15, 54, 42, 55, 38, 30, 26, 40, 42, 82, 82, 54, 22, 0, 83, 84, 3, 76, 85, 85, 2, [0, 13]], [[0, 15], 1, 19, 86, 16, 18, 78, 54, 38, 62, 30, 81, 64, [81, 3], 24, 24, 63, 30, 69, 38, 52, 15, 14, 22, 21, 14, 15, 14, 15, 8, 2, [0, 14], 65, 38, 68, 68, 39, 54, 42, 67, 42, 87, 88, 42, 89, 26, 27, 8, 4, 72, 72, 90, 90, [0, 13]], [[0, 16], 1, 5, 14, 36, 91, 67, 38, 39, 81, [24, 6], 45, 24, 63, 69, 38, 52, 51, 21, 21, 14, [15, 3], 16, 14, 32, 26, 46, 1, [0, 11], 22, 67, 67, 92, 92, 42, 93, 42, 94, 95, 95, 54, 69, 39, 39, 40, 18, 96, 15, 11, 97, [0, 13]], [[0, 17], 2, 7, 36, 98, 54, 68, 69, 81, [24, 8], 81, 30, 62, 29, 18, 21, 51, [16, 4], 18, 52, 63, 31, 99, 22, 46, [0, 9], 9, 60, 42, 98, 42, 100, 42, 101, 67, 98, 88, 88, 67, 63, 64, 81, 56, 39, 67, 102, 103, 11, 11, [0, 12]], [[0, 17], 2, 13, 36, 98, 54, 38, 39, 81, 31, 31, [24, 6], 64, 79, 62, 62, 40, 40, 51, 18, 40, 36, 18, 36, 52, 30, 81, 31, 31, 99, 23, 58, 46, 4, 1, 0, 1, 2, 15, 60, 68, 68, 42, 98, 67, 37, 39, 68, 98, 98, 42, 39, 33, 104, 64, 56, 56, 39, 50, 27, 105, 103, [0, 12]], [[0, 17], 2, 8, 106, 107, 54, 38, 39, 63, [31, 3], [24, 5], 81, 30, [62, 3], 40, 40, 18, [36, 4], 60, 39, 30, 81, 31, 31, 24, 81, 108, 50, 51, 22, 51, 50, 68, 68, 29, 68, 37, 68, 68, 29, 39, 50, 78, 95, 82, 39, [109, 2], 63, 39, 69, 56, 56, 39, 96, 110, [0, 12]], [[0, 17], 1, 12, 111, 98, 54, 68, 39, 81, 63, [81, 4], 31, 24, 63, 56, 112, 113, 37, 37, 67, 114, 78, 52, 29, [115, 2], 116, 52, 62, 81, 81, 31, 24, 64, 56, 50, 39, 39, 30, 56, 50, 50, 29, 115, [67, 4], 37, 68, 68, 67, 100, 89, 109, 117, 39, 39, 56, 63, 64, 56, 49, 83, [0, 12]], [[0, 17], 1, 2, 118, 98, 37, 38, 62, 69, 56, 81, 63, 30, 119, 62, 50, 120, 121, 122, 123, 124, [125, 2], 126, 127, 78, 52, 37, 44, 49, 47, 22, 39, 30, 81, 63, 56, 50, 50, 62, 68, 39, 89, 56, 56, 39, 67, 98, 95, [128, 2], 95, 94, 42, 67, 68, 39, 53, 64, 56, 81, [24, 4], 51, 5, [0, 12]], [[0, 18], 5, 118, 128, 98, 101, 37, 37, 62, 30, 30, 129, 130, [131, 2], 132, 133, 134, [135, 2], 123, [136, 2], 137, 52, 52, 38, 138, 37, 3, 1, 72, 49, 39, 38, 39, 62, 38, 38, 68, 89, 89, 50, 69, 62, 54, 98, 94, [87, 3], [139, 3], 128, 92, 68, 56, 30, 63, 64, 24, 63, 24, 24, 140, [0, 12]], [[0, 18], 141, 12, 142, 143, 144, 145, 146, 122, 147, 44, 148, 123, 149, [150, 3], [151, 2], 124, 136, 43, 38, 37, 67, 68, 37, 138, 68, 13, 97, 0, 4, 6, 18, 60, [67, 4], 68, 52, 68, 68, 54, 98, 128, [87, 3], 128, 152, [128, 2], 139, 153, 98, 68, 39, 30, 81, 64, 64, 24, 24, 32, 4, [0, 11]], [[0, 19], 5, 154, [143, 4], 155, 44, 112, 130, 156, 124, [123, 3], [134, 2], 157, 62, 69, 38, 54, 54, [38, 3], 37, 36, 5, [0, 4], 1, 9, 158, 159, 160, 114, [98, 5], 94, [128, 2], 87, [153, 2], 87, 139, 87, 128, 139, 101, 68, 62, 39, 81, 64, 81, 69, 98, 18, 1, [0, 10]], [[0, 19], 1, 105, [143, 2], 161, 162, 163, 164, 81, 30, 165, 156, 166, 156, 166, 148, 164, 30, 69, 62, 37, 54, 54, 62, 69, 113, 68, 16, 167, 2, 1, 0, 0, 11, 168, 169, 170, 171, 172, 173, 88, 128, 95, 94, 98, [100, 3], [98, 3], 128, [87, 4], 128, 68, 38, 80, 63, 80, 62, 78, 21, 174, [0, 10]], [[0, 19], 1, 167, 161, 151, 175, 176, 177, 62, 178, 81, 30, [129, 2], 113, 62, [81, 3], 30, 62, 38, 37, 37, 54, 62, 38, 67, 48, 179, 180, 16, 10, 181, 182, 183, 170, 136, 184, 185, 186, 42, 42, [88, 3], 128, 95, 94, 94, [98, 3], 128, [87, 3], 187, 128, 188, 62, 81, 24, 50, 107, 36, 57, 1, [0, 9]], [[0, 20], 2, 114, 189, 190, 101, 55, 30, 81, 81, 63, 30, 81, 31, 24, 24, 81, 81, 30, 62, 38, 38, 113, 54, 38, 37, 43, 191, 160, 145, 192, 193, 194, 169, 195, 145, 184, 185, 196, 54, 54, 42, 95, 197, 94, 94, 87, 87, 153, 187, 198, 199, 198, 160, 187, 87, 187, 200, 101, 37, 63, 25, 104, 64, 68, 16, 5, [0, 9]], [[0, 20], 1, 67, 113, 30, 119, 55, 112, [30, 3], 62, 29, 63, 24, 24, 63, 30, 69, [38, 3], 37, 54, 37, 43, 67, 127, 185, 144, 194, 201, [169, 2], 202, 95, 203, 82, 54, 68, 68, 67, 94, [197, 2], 204, [94, 3], 128, 205, [206, 2], 207, 208, 154, 209, 210, 205, 60, 62, 63, 32, 117, 89, 8, 11, [0, 9]], [[0, 20], 1, 60, 211, 62, 113, 44, 112, 79, 30, 119, 62, 62, 68, 30, 80, 30, 69, 69, [38, 3], 37, 54, 42, 82, 94, 212, 213, 214, 201, [169, 2], 215, 131, 216, 217, 218, 68, 62, 68, 42, 197, 42, [100, 3], 98, 98, 94, 128, 200, 205, [209, 2], [205, 2], 219, 220, 1, 51, 62, 32, 109, 22, 1, [0, 10]], [[0, 21], 18, 100, 38, 42, 122, 37, 62, 37, 164, 62, 30, 37, 38, 69, 39, 39, 38, 38, 37, 37, 54, 54, 42, 221, 222, 223, 126, 169, 194, [169, 2], 224, 155, 225, 186, 54, 68, 29, 68, [42, 3], [100, 4], 98, 98, 152, 87, 87, 139, 187, 153, 226, 227, 167, 0, 3, 53, 104, 58, 32, 1, [0, 10]], [[0, 21], 14, 197, 54, 95, 88, [122, 2], 228, 55, 55, 37, 37, 54, [38, 4], 37, [54, 4], 55, 229, 212, 230, 143, [169, 3], 215, 180, 189, 230, 231, 60, [68, 3], 42, 94, 42, [100, 4], 91, 98, 94, 87, [187, 2], 232, 153, 227, 48, 46, 1, 4, 63, 117, 104, 23, 1, [0, 10]], [[0, 21], 9, 98, 42, 94, 216, 95, 101, 115, 55, 37, 55, 55, 95, [38, 3], 37, 37, 54, 55, 67, 54, 55, 177, 233, 144, [169, 2], 194, 169, 215, 234, 199, 216, 235, 67, [68, 3], 100, 94, 98, 100, 67, 100, 91, 91, 98, 128, 87, 187, 198, 232, 226, 236, 5, 0, 0, 1, 51, 117, 104, 24, 1, [0, 10]], [[0, 21], 1, 106, 98, 218, 139, 95, 54, 68, 37, 54, 55, 55, 101, 54, 38, 37, 54, 54, 55, 42, 42, 100, 101, 127, 131, 214, 169, [194, 2], 169, 237, 221, 82, 173, 235, 128, [68, 3], 100, 94, 94, 98, [100, 2], 91, 98, 152, 87, 87, 139, 232, 153, 238, 20, 1, [0, 3], 22, 24, 24, 53, 46, [0, 10]], [[0, 22], 6, 98, 218, 87, 216, 177, 101, 55, 228, 177, 189, 190, 98, 38, 54, 54, 42, 98, 98, 42, 42, 160, 193, 201, [169, 2], [194, 3], 144, 95, 225, 239, 240, 187, 67, 68, 68, 67, [94, 5], [128, 2], 87, [187, 3], 198, 241, 2, [0, 5], 72, 24, 117, 32, 2, [0, 10]], [[0, 23], 17, 42, 67, 128, 189, 125, 242, [243, 2], 130, 189, 101, 54, 54, 42, 98, 101, 98, 42, 114, 144, [201, 2], [169, 2], [194, 3], 170, 101, 244, 245, 94, 232, 160, 100, 92, 67, 42, 95, 87, 88, [139, 2], 187, 216, [200, 3], 160, 9, [0, 6], 2, 63, 45, 58, 46, [0, 10]], [[0, 23], 4, 246, 54, 67, 29, 101, 247, 248, 249, 130, 37, 98, 188, 100, 42, 95, 98, 42, 98, 237, 169, 250, 251, 169, [194, 3], 201, 193, 170, 127, 252, 173, 199, 253, 226, 78, 137, 98, 94, 128, 187, 200, 254, 200, [254, 2], 199, 160, 255, 140, [0, 7], 22, 32, 26, 4, [0, 10]], [[0, 24], 2, 48, 98, 37, 62, 130, 129, 71, 115, 62, 54, 95, 42, 94, 95, 42, 42, 159, 256, 194, 250, 194, 169, 194, [169, 2], 194, 257, 102, 258, 203, 259, 258, 216, 127, 159, 128, 94, 94, [87, 3], 187, 216, [200, 2], 159, 145, 124, 6, [0, 7], 1, 3, 2, 1, [0, 10]], [[0, 25], 6, 226, 67, 37, 37, 129, 71, 121, 37, 54, 101, 122, 95, 95, 42, 128, 215, 169, 251, 256, 169, [194, 6], 142, 144, 260, 261, 262, 263, [205, 2], 264, 200, 139, 187, 216, [200, 2], [139, 2], 199, 265, 144, 124, 17, [0, 21]], [[0, 25], 1, 17, 98, 42, 43, 266, [249, 2], 42, 54, 55, 127, 122, 95, 94, 205, 169, 257, 251, 237, 170, [194, 6], 257, 267, 268, 177, 93, 189, 131, 162, 127, 264, 260, 264, [263, 2], 216, 88, 253, 265, 201, 144, 163, 114, 1, [0, 20]], [[0, 25], 1, 2, 102, 98, 101, 247, 44, 221, 44, 55, 98, 205, 253, 122, 253, 215, 194, 257, 215, 268, 237, [194, 6], [257, 2], 209, 145, 139, 264, 269, 255, 162, 127, 270, 264, 163, 260, 263, 93, 155, 215, 201, 143, 134, 189, 5, [0, 20]], [[0, 26], 271, 272, 98, 98, 87, 226, 98, 42, 42, 137, [131, 2], 205, 195, 169, 194, 169, 202, 148, 144, 194, [251, 2], [194, 4], 251, 201, 159, 263, 177, 222, 172, 124, 175, 145, 163, 216, 273, 230, 216, 145, 195, 193, 201, 123, 93, 274, [0, 20]], [[0, 26], 1, 267, 190, 68, 100, 67, 67, 54, 67, 190, 144, 142, 265, [169, 2], 201, 215, 267, 275, 144, [194, 8], 193, 144, 255, 264, 263, 276, 185, 172, 263, 126, 173, 258, 88, 255, 145, 142, 215, 257, 161, 269, 277, [0, 20]], [[0, 25], 1, 15, 125, 142, 246, 98, 42, 95, 55, 98, 205, 215, 237, 142, 169, 194, 169, 170, 272, 134, 215, [194, 8], 214, 237, 256, 131, 126, 269, 273, 278, 217, 258, 216, 200, 163, 264, 270, 145, 144, 257, 256, 216, 279, [0, 20]], [[0, 24], 1, 280, 148, 162, 169, 237, 190, 94, 88, 139, 205, 144, 237, 255, 161, [194, 2], 215, 237, 281, 127, 215, [194, 2], 251, [194, 5], 256, 282, 170, [256, 2], 265, 175, 230, 203, 283, 101, 270, 177, [264, 2], 255, 142, 194, 145, 233, 182, 11, [0, 19]], [[0, 23], 11, 284, 282, 132, 169, 194, 169, 205, 87, 139, 199, 255, 177, 155, 145, 193, 194, [215, 2], 155, 285, 237, 169, [194, 6], 251, 194, 214, 282, 205, [201, 2], 256, 215, 155, 185, 211, 286, 98, 127, [264, 2], 270, 142, 251, 177, 222, 169, 97, [0, 19]], [[0, 22], 11, 287, 144, 215, 257, [194, 2], 169, 145, 198, 187, 200, 216, 222, 163, 162, 169, 250, 288, 145, 229, 155, 170, [194, 9], 251, 255, 253, 144, [250, 2], 251, 289, 290, 291, 196, 69, 226, [127, 2], 270, 142, 256, 292, 216, 183, 75, [0, 19]], [[0, 21], 97, 293, [169, 2], 201, 194, 257, 194, 294, 169, 205, 200, 216, 95, 216, 163, 205, 214, 250, 215, 134, 292, 255, 215, [194, 5], 251, [194, 4], 265, 253, 127, 193, 250, 295, 201, 143, 233, 296, 69, 37, 255, 205, 270, 142, 162, 172, 264, 257, 75, [0, 19]], [[0, 20], 11, 293, 194, 169, 250, [194, 4], 294, 194, 193, 215, 131, 221, 93, 190, 192, 201, 250, 289, 123, 273, 255, 208, 169, [194, 5], 251, [194, 3], 193, 127, 177, 145, 201, [250, 2], 201, 131, 297, 298, 299, 253, 142, 205, 215, 126, 225, 199, 288, 85, [0, 19]], [[0, 20], 284, [194, 2], 169, 201, [194, 2], 251, [194, 2], [169, 2], 194, 144, 177, 101, 22, 300, [250, 2], 251, 301, 302, 145, 169, [194, 6], [251, 2], [194, 2], 257, 144, 189, 253, 215, 201, 303, 250, 251, 290, 304, 305, 255, 265, 151, 163, 263, 255, 306, 257, 75, [0, 19]], [[0, 19], 85, 169, [194, 5], 251, 201, 251, [194, 2], [169, 3], 307, 59, 308, 309, [201, 2], 310, 311, 312, 313, [169, 3], [194, 3], 257, [194, 5], 214, 302, 253, 155, 256, 201, 250, 295, 214, 82, 223, [134, 2], 314, 123, 169, 194, 169, 315, 85, [0, 19]], [[0, 18], 97, 315, [194, 3], 182, 181, 168, 206, [194, 7], 316, 73, 103, 194, [201, 2], [194, 2], 294, 194, [169, 4], 215, 162, 317, 162, 215, 256, [194, 3], 215, [253, 2], 145, 256, 169, 265, 256, 145, 296, 213, 184, 177, 169, 313, 315, 313, 301, 318, [0, 19]], [[0, 17], 97, 287, [194, 2], 169, 315, 287, 319, 320, 321, 322, [194, 3], 251, [194, 3], 83, 110, 257, 201, 250, 194, [169, 7], 323, 155, 324, 136, 253, 285, 289, 256, [194, 2], 209, 253, 229, 144, 194, 215, 162, 144, 273, 298, 263, [169, 2], [194, 2], 315, 325, 277, [0, 19]], [[0, 16], 2, 309, [194, 3], 313, 309, 326, 327, 328, 321, 329, [194, 7], 330, 331, 201, [250, 2], [194, 2], [169, 10], 215, 302, 229, 162, 169, 194, 214, 229, 160, 159, 289, 251, 143, 155, 317, 142, 169, 208, 332, [194, 2], 215, 170, 277, [0, 19]], [[0, 15], 141, 287, [194, 2], 294, 194, 315, [333, 3], 309, 333, 182, 315, 194, 169, [194, 4], 251, 169, 295, 250, [194, 2], [169, 8], [313, 3], [169, 2], 145, 229, 255, 214, 194, 144, 160, 139, 200, 144, 313, 334, 189, 162, 215, 335, 146, 215, 194, 224, 317, 287, [0, 19]], [[0, 15], 85, 169, 170, [169, 3], 315, 207, 309, 336, 326, 337, 326, 182, [194, 6], 201, 144, 256, 303, 194, [169, 10], [313, 3], 183, 313, 144, 253, 131, 214, 194, 205, [128, 2], 253, 335, 313, 159, 242, 144, 294, 302, 170, 169, 282, 338, 309, 141, [0, 18]], [[0, 15], 168, 96, 121, 180, [169, 2], 315, 309, 339, 337, 340, 220, 341, 182, [194, 7], 144, 237, 144, 193, 194, [169, 10], [313, 2], 169, [313, 2], 144, 253, 127, 169, 144, 190, [107, 2], 136, 334, 170, 242, 177, [215, 2], 267, 215, 229, 131, 206, 3, [0, 18]], [[0, 14], 11, 208, 120, 342, 228, 215, 169, 194, 343, 344, 345, 346, 287, 293, 321, [194, 5], 251, 194, 257, 162, 347, 237, [169, 9], [313, 6], 315, 313, 237, 189, 255, 215, 237, 98, 91, 196, 348, 335, 302, 122, 132, 183, 302, 237, 347, 317, 170, 103, [0, 18]], [[0, 14], 97, 251, 120, 112, 55, 142, 294, 194, 315, 309, 333, 349, [350, 2], 182, 315, [194, 6], 257, 256, 127, 282, 169, 313, [169, 2], 313, [169, 2], [313, 3], [169, 2], [313, 5], 315, 127, 171, 144, 208, 159, 196, 351, 101, 282, 144, 171, 136, 169, 131, 224, 352, 237, 208, 105, [0, 18]], [[0, 14], 353, 169, 115, 62, 43, 145, 294, 169, 315, 301, 329, 350, 354, 355, 287, 356, 201, [194, 7], 215, 229, [169, 2], 215, 237, 335, 169, 183, 315, 313, [183, 2], 315, [313, 2], 169, 313, 335, 313, 208, 357, 146, 183, 144, 351, 196, 78, 101, 317, 170, 358, 144, 237, 334, 144, 224, 208, 343, 2, [0, 17]], [[0, 13], 11, 182, 209, 62, 62, 44, 142, 294, [169, 2], 183, 315, 309, 326, 168, 287, 194, 201, [194, 5], 169, 194, 169, 282, 142, 169, 215, 224, 335, 208, 323, 335, 215, 313, [335, 2], 313, 169, [313, 2], [335, 2], 315, 170, 228, 131, 170, 359, 360, 78, 91, 122, 162, 131, 237, 335, 208, 170, 157, 209, 170, 10, [0, 17]], [[0, 13], 361, 194, 362, 62, 38, 114, 193, [169, 2], [194, 3], 182, 363, 330, 315, 194, 251, [194, 6], [169, 2], 282, 177, 169, 215, 282, 323, 332, 352, 171, 229, 131, 215, [313, 5], [335, 2], 313, 315, 302, 228, 145, 364, 365, 101, 78, 91, 165, 162, 142, [215, 2], 170, 165, 282, 208, 74, [0, 17]], [[0, 13], 366, 154, 37, 62, 37, 146, 194, [169, 3], [194, 2], 201, [169, 4], [194, 4], [251, 2], [194, 3], 237, 122, 145, 215, 352, 131, 215, 313, 144, 282, 189, 282, 145, 169, [313, 2], 335, 313, [335, 2], 208, 195, [367, 2], 94, 368, 172, 55, 211, 351, 369, 299, 94, 195, 215, 242, 131, 208, 168, 1, [0, 16]], [[0, 12], 1, 2, 49, 30, 39, 78, 237, 251, [169, 3], 194, 257, 250, 289, [169, 2], 194, 169, 251, [194, 3], 251, 194, 169, 313, 215, [171, 2], 142, 334, 171, 144, 313, 315, 215, 335, 237, [282, 2], 144, 313, 335, 315, 215, 323, [208, 2], 202, 370, 102, 371, 196, 148, 196, 360, 196, 299, 364, 101, 215, 282, 352, 169, 206, 2, [0, 16]], [[0, 11], 1, 20, 246, 98, 54, 68, 114, 215, 251, [169, 3], 194, [201, 2], 323, 169, 313, [169, 2], 251, 169, [194, 3], [169, 2], 313, 169, 237, 157, 171, 144, 347, 171, [335, 2], [313, 2], 169, 215, 282, 189, 237, 313, 169, 334, 224, [335, 2], 195, 96, 78, 82, 372, 172, 102, 106, 55, 157, 145, 190, 281, 215, 146, 323, 315, 5, [0, 16]], [[0, 11], 72, 107, 42, 95, 128, 55, 190, 256, 310, 251, 169, 194, 251, 201, 256, 317, [169, 4], [194, 2], [169, 2], [194, 2], 313, 169, 313, 335, 159, 130, 229, 237, 101, 131, 313, 315, 169, 335, 195, 215, [189, 2], 162, 169, 282, 131, 215, 323, 162, 122, 42, 101, [360, 2], 163, 246, 67, 228, 324, 335, 170, 208, 237, 224, 335, 340, [0, 16]], [[0, 10], 46, 137, 82, 211, 43, 122, 128, 226, 193, 310, 201, 257, [251, 3], 144, 285, 256, 169, 313, 169, 313, 194, 313, 169, [194, 2], 315, 183, 315, 335, 302, 247, 171, 162, 44, 347, [313, 3], [208, 3], 282, 44, 189, 215, 155, 131, 237, 229, 44, 147, [351, 2], 261, 365, 373, 253, 78, 137, 130, 323, 313, 285, 144, 374, 206, 321, 11, [0, 15]], [[0, 9], 1, 28, 258, 95, 95, 112, 42, 128, 268, [201, 4], [251, 2], 194, 334, 324, 256, 194, [169, 2], 313, 194, [169, 3], 214, [194, 3], 214, 302, 171, 145, 144, 242, 136, 215, 315, [208, 4], 237, 228, 221, 317, 155, 189, [195, 2], 215, 144, 157, 43, 211, 138, 375, 273, 228, 48, 44, 285, 208, 229, 282, 352, 282, 136, 103, [0, 15]], [[0, 9], 14, 376, 42, 67, 95, 43, 42, 101, 237, 257, 201, 142, 169, 201, 251, 194, 237, 324, 193, [194, 2], [169, 2], 313, [169, 2], 335, 323, [169, 2], 335, 237, 137, 228, 170, 208, 114, 101, 155, 301, 335, [313, 2], 169, 144, 190, 221, 324, 302, 130, 334, [335, 3], 202, 115, 67, 43, 365, 217, 93, 107, 98, 347, 215, 242, 155, 377, 157, 184, 370, [0, 15]], [[0, 8], 9, 88, 261, 43, 54, 68, 37, 54, 98, 268, 209, 265, 205, 170, 201, [295, 2], 237, 324, 193, 251, 194, [169, 2], 313, [169, 2], 215, 237, 313, 315, 215, 142, 98, 101, 142, 208, 146, 55, 242, [208, 2], 335, 315, 183, 215, 242, 95, 136, 205, 130, 155, 208, 315, 335, 195, 102, 106, 78, 95, 299, 351, 197, 98, 130, 162, 130, 131, 253, 44, 82, 127, 4, [0, 14]], [[0, 7], 2, 236, 230, 95, 43, 54, 67, 54, 38, 38, 68, 68, 67, 114, 159, 142, 201, 250, 265, 155, 215, 251, [194, 2], [169, 2], 315, 169, 144, 131, 294, 313, 378, 363, 98, 211, 229, 145, 323, 101, 44, 125, 208, 301, 170, [208, 2], 157, 55, 221, 145, 228, 148, 144, [315, 2], 335, 170, 48, 78, 78, 82, 379, 304, 373, 130, 131, 130, 125, 317, 373, 304, 165, 5, [0, 14]], [[0, 7], 6, 87, 173, 95, 54, 37, 55, 54, 38, 38, 62, 39, 30, 69, 38, 29, 246, 281, 201, 237, 144, [251, 2], 194, [169, 2], 208, 315, 131, 253, 214, 313, 325, 343, 128, 95, 130, 228, 282, 229, 101, 122, 131, 325, 285, [170, 2], 101, 67, 247, 131, 357, 266, 131, 170, [315, 2], 335, 159, 66, 246, 98, 217, 379, 297, 373, 125, 101, 290, 317, 290, 304, 351, 103, [0, 14]], [[0, 6], 4, 280, 88, 173, 95, 113, 38, 38, 42, 101, 42, 54, 68, 62, 62, 38, 39, 108, 30, 202, 256, 170, 169, [194, 3], 294, 313, 315, 229, 130, 289, [313, 2], 208, 102, 101, 155, 268, 55, 253, 190, 137, 157, 133, 229, 323, 155, 44, 67, 247, 131, 237, [247, 2], 131, 208, [301, 2], 170, 236, 106, 66, 211, 379, 380, 381, 382, 101, 136, [215, 2], 216, 304, 83, [0, 14]], [[0, 6], 3, 236, 173, 87, 94, 54, 37, 38, 38, 62, 38, 55, 122, 189, 122, 114, 55, 50, 62, 202, 201, [215, 2], 257, [194, 2], [169, 3], 282, 130, 215, 313, 315, 335, 357, 247, 285, 144, 226, 42, 177, 383, 98, 305, 136, 323, 155, 147, 188, 384, 93, 237, 282, 43, 157, 170, [208, 3], 209, 106, 385, 211, 380, 372, 386, 223, 130, 387, 215, 313, 215, 185, 89, [0, 14]], [[0, 6], 5, 36, 88, 87, 98, 54, 42, 42, 54, 38, 39, 30, 56, 39, 115, 388, 268, 159, 237, 215, [201, 2], 215, 169, 201, 194, [169, 3], 282, 242, 323, [313, 2], 215, 281, 44, 189, 215, 142, 98, 221, 177, 98, 188, 95, 170, 215, 157, 94, 54, 54, 101, 155, 268, 55, 189, 142, [208, 2], 237, 102, 60, 211, 389, 390, 379, 391, 197, 221, 162, 335, 313, 162, 373, 9, [0, 13]], [[0, 6], 83, 48, 88, 88, 95, 54, 54, 42, 44, 54, 54, 68, [39, 4], 50, 63, 246, 265, 169, 201, 169, 215, 144, 193, [215, 2], 169, 237, 228, 237, 313, 169, 215, 237, 114, 122, 170, 313, 253, 211, 155, 190, 392, 42, 136, 334, 190, 91, 101, 122, 42, 44, 125, 107, 91, 200, 334, 155, 224, 255, 44, 82, [393, 2], 365, 394, 371, 373, 127, [144, 2], 170, 131, 37, 47, [0, 12]], [[0, 6], 72, 281, [216, 2], 88, 98, 113, 68, 78, 42, 221, 128, 98, 67, 43, 37, 62, 63, 115, 161, 145, 331, 395, 143, 145, 162, 237, 282, 334, 215, [114, 2], 323, 313, 335, 215, 190, 101, 131, 335, 237, 82, 93, 237, 38, 100, 373, 131, 159, 66, 137, 165, 190, 78, 101, 229, 137, 42, 253, 242, 334, 173, 196, 211, 396, 393, 217, 37, 371, 211, 233, 101, 233, 125, 144, 136, 89, [0, 12]], [[0, 6], 11, 202, 253, 88, 139, 216, 114, 33, 51, 30, 108, 39, 54, 137, 146, 132, 127, 146, 255, 175, 161, 5, 181, 289, [255, 2], 215, 323, 282, 237, 159, 247, 136, 208, 335, 208, 205, 98, 189, 215, 208, 95, 221, 144, 98, 188, 95, 357, 131, 246, 78, 101, 317, 101, 91, 189, 146, 67, 365, 221, 132, 397, 244, 373, 393, 398, 399, 115, 188, 359, 261, 189, 298, 400, 139, 162, 230, 59, [0, 11]], [0, 0, 401, 402, 403, 404, 403, 405, 406, 407, 408, 357, 409, 13, 410, [411, 3], 412, 30, 30, 413, 151, 414, [411, 2], 415, 11, 284, 256, 255, 127, 416, 417, 418, 414, 419, 420, 421, 422, 423, 335, 208, 137, 101, 334, 424, 425, 426, [414, 2], 427, 426, 428, 429, 98, 78, 430, [411, 9], 431, 259, 292, 380, 432, 433, 434, 420, 414, [420, 2], 426, 435, 436, 177, 282, 42, 174, 401, 437, 438, 404, 403, 439, 440, 441, 442, 0], [0, 441, [411, 8], 443, 272, 300, 202, 444, [411, 3], 445, 101, 62, 120, 151, 414, [411, 2], 446, 0, 90, 201, 205, 447, 419, [411, 7], 448, 323, 208, 357, 37, 447, 419, [411, 7], 421, 122, 78, 449, [411, 9], 450, 451, 126, 217, 452, [411, 8], 453, 360, 162, 173, 454, [411, 8], 401, 0], [455, [411, 2], 403, 456, 1, 1, 457, 458, 459, 460, 208, [201, 2], 461, [411, 3], 462, 200, 255, 162, 175, 414, [411, 2], 440, 0, 75, 201, 463, [411, 3], 459, 423, 191, 464, 465, 466, 467, 334, 208, 237, 468, [411, 3], 469, 470, 199, 471, 472, 473, 474, 136, 60, 475, [411, 3], 475, 221, 190, 115, 128, 114, 100, 476, 203, 477, [411, 2], 420, 478, 78, 226, 479, 480, 481, 482, 211, 200, 429, [411, 2], 483, 455, 1, 1, 442, 401, 402, 401, 0], [484, [411, 2], 485, [0, 3], 1, 340, 193, [251, 2], 295, 310, 461, [411, 3], 462, 253, 145, 144, 161, 414, [411, 2], 402, 0, 0, 486, [411, 3], 487, 313, 169, 162, 136, 162, 190, 55, 229, 144, 488, [411, 3], 454, 100, 253, 130, 68, 61, 188, 92, 221, 98, 430, [411, 3], 489, 44, 163, 388, 137, 132, 128, 391, 399, 490, [411, 2], 491, 128, 114, 139, 365, 492, [298, 2], 189, 42, 422, [411, 2], 493, [0, 8]], [441, [411, 2], 494, 442, [0, 3], 11, 179, 195, [201, 3], 444, [411, 3], 495, 253, 142, 215, 161, 419, [411, 2], 496, 0, 0, 497, [411, 2], 419, 498, [169, 2], 317, 377, 131, 268, 107, 98, 177, 499, [411, 2], 414, 500, 392, 101, [114, 2], 152, 91, 501, 286, 101, 327, [411, 3], 502, 373, 172, 189, 197, 131, 127, 503, 504, 505, [411, 2], 506, 507, 185, 82, 492, 196, 503, 298, 189, 211, 508, [411, 2], 509, 456, [0, 7]], [510, [411, 4], 511, 441, 401, 141, 10, 234, 191, [205, 2], 512, [411, 3], 513, 199, 142, 161, 144, 514, [411, 2], 496, 0, 0, 515, [411, 2], 516, 228, 202, 169, 285, 243, 282, 302, 517, 92, 216, 420, [411, 2], 421, 518, 519, [60, 3], 106, 66, 520, 521, 92, 327, [411, 3], 489, 373, 189, 42, 239, 273, 127, 298, 522, 523, [411, 4], 524, 525, 526, 376, 391, 186, 122, 365, 527, [411, 4], 528, 441, 401, 141, [0, 3]], [141, 529, [411, 6], 530, 485, 12, 199, 127, 177, 429, [411, 3], 531, 179, 340, 83, 103, 532, [411, 2], 496, 0, 0, [411, 3], 533, 216, 268, 170, 229, 130, 282, 237, 78, 116, 534, [411, 3], 535, 521, 536, 392, 60, 60, 78, 78, 66, 521, 537, 538, [411, 9], 163, 221, 539, 540, 506, [411, 6], 419, 541, 542, 186, 211, 239, 506, [411, 6], 530, 543, 0, 0], [0, 455, 494, [411, 7], 402, 6, 180, 270, 544, [411, 3], 545, 3, [0, 3], 494, [411, 2], 496, 0, 0, [411, 3], 546, 273, 192, 323, 131, 242, 155, 208, 92, 547, 227, [411, 3], 491, 548, 549, 392, 92, [78, 3], 550, 551, 537, 538, [411, 9], 225, 122, 298, 398, 552, 553, [411, 7], 554, 380, 351, 196, 555, 553, [411, 7], 496, 0], [[0, 3], 401, 485, 494, [411, 5], 141, 3, 220, 556, [411, 3], 401, [0, 4], 494, [411, 2], 496, 0, 0, 532, [411, 2], 557, 82, 127, 317, 215, 189, 155, 335, 67, 392, 78, 414, [411, 2], 421, 68, 549, 519, 91, 66, 78, 66, 66, 501, 66, 558, [411, 3], 559, 269, 142, 209, 139, 451, 298, 304, 360, 365, 364, 92, 560, 561, 562, [411, 5], 540, 380, [196, 2], 563, 480, 525, 427, [411, 5], 141], [[0, 6], 141, 402, [411, 3], 455, 0, 0, 442, [411, 3], 401, [0, 4], 403, [411, 2], 441, 0, 0, 485, [411, 2], 414, 564, 291, 172, 155, 93, 269, 162, 107, 565, 66, 566, [411, 2], 414, 94, 567, 364, 286, 66, 91, 568, 479, 569, 568, 570, [411, 3], 560, 231, 519, 518, 501, 568, 399, 432, 571, 360, 66, [106, 2], 572, 573, 574, 575, [411, 3], 576, 577, 571, 563, 578, [571, 2], 380, 579, 402, [411, 3], 455], [[0, 7], 442, [411, 3], 442, [0, 3], 580, [411, 2], 484, [0, 3], 141, [411, 3], 581, 0, 0, 455, [411, 3], 541, 582, 583, 290, 101, 190, 132, 242, 572, 568, 584, [411, 3], 467, 360, 371, 567, 392, 188, 568, 565, 585, 586, 587, [411, 3], 588, 589, 519, [590, 2], 436, 360, 577, 591, 577, 197, 218, 100, 572, 592, 593, 594, [411, 3], 595, 596, 577, 571, 597, 598, [577, 2], 360, 599, [411, 3], 442], [510, 496, 401, 442, 1, 0, 141, 485, [411, 2], 494, [0, 4], 485, [411, 2], 403, 456, 0, 141, 440, [411, 2], 529, 141, [0, 3], 484, [411, 3], 541, 600, 199, 601, 602, 603, 604, 94, 589, 605, 606, [411, 3], 607, 608, 521, 471, 609, 610, 611, 521, 612, 613, [411, 3], 614, 564, 67, 501, 590, 521, 548, 492, 615, 616, 554, 617, 618, 619, 620, 621, 622, [411, 2], 414, 623, 397, 450, 505, 624, 619, 573, 571, 625, 626, [411, 2], 494, 0], [627, [411, 8], 530, 456, [0, 4], 1, 628, [411, 7], 404, 401, [0, 5], 629, 419, [411, 7], 630, 258, 173, 631, 632, 633, 419, [411, 7], 634, 521, 590, 635, [411, 9], 611, 636, 637, 638, [411, 8], 414, 639, 197, 187, 447, [411, 8], 530, 456, 0], [141, 510, 496, 628, 494, 404, 529, 511, 441, 442, [0, 7], 581, 440, 403, 404, 529, 628, 441, 141, [0, 6], 271, 640, 641, 630, 506, [414, 2], 642, 643, 644, 60, 189, 175, 645, 239, 646, 633, 647, 506, 414, 420, 648, 610, 649, 536, 590, 650, [411, 9], 474, 636, 651, 652, 638, 653, 524, 562, 414, 506, 562, 622, 654, 655, 656, 631, 470, 657, 658, 659, 553, [414, 2], 660, 441, 442, 0, 0], [[0, 29], 4, 9, 33, 53, 365, 351, 54, 98, 252, 269, 122, 94, 551, 364, 226, 128, 661, 595, 589, 662, 663, 254, 302, 664, [549, 2], 536, 665, 666, 667, 668, 589, 67, 669, 670, 185, 88, 67, 92, 60, 519, 548, 671, 672, 673, 668, [667, 3], 663, 674, 586, 359, 231, 586, 589, 258, 397, 661, 675, 676, 53, [0, 4]], [[0, 27], 1, 57, 364, [676, 2], 391, 677, 360, 128, 244, 678, [186, 2], 669, 542, 98, 153, 679, 235, 631, 204, 680, 671, 637, 680, 190, 392, 519, 681, 590, 636, 682, 667, 671, 92, 93, 564, 397, 683, 231, 371, 218, 384, [371, 2], 612, 684, 637, [667, 2], 620, 586, 675, 620, 675, 669, 397, 676, [685, 2], 573, 542, 573, 53, [0, 4]], [[0, 27], 1, 686, 670, 687, 688, 689, 690, 223, 244, 691, 692, 88, 211, 615, 685, 94, 693, 694, 572, 645, 534, 160, 679, 695, 672, 696, 204, 218, 188, 392, 521, 697, 672, 619, 605, 67, 268, 255, 263, 254, 564, 674, 235, 263, 127, 177, 492, 698, 682, 699, 673, 632, 569, 673, 699, 687, 700, 259, 685, [573, 3], 698, 701, [0, 4]]]};

  // project-rome/@romejs/cli-diagnostics/banners/error.json
const ___R$project$rome$$romejs$cli$diagnostics$banners$error_json$default = {'palettes': [[0, 0, 0], [15, 0, 0], [30, 15, 15], [30, 15, 30], [15, 15, 15], [75, 60, 60], [45, 30, 30], [30, 30, 30], [90, 75, 75], [120, 90, 90], [105, 75, 75], [60, 45, 45], [90, 75, 60], [90, 60, 60], [105, 90, 90], [180, 135, 135], [150, 120, 120], [165, 135, 120], [120, 105, 90], [150, 120, 105], [105, 75, 90], [45, 45, 45], [30, 30, 15], [195, 165, 165], [195, 165, 150], [165, 120, 120], [180, 150, 150], [165, 135, 135], [15, 0, 15], [75, 60, 45], [165, 150, 135], [210, 165, 165], [210, 180, 180], [225, 180, 180], [135, 105, 105], [60, 30, 30], [60, 60, 45], [210, 180, 165], [225, 195, 180], [225, 195, 195], [75, 45, 45], [45, 15, 15], [135, 120, 105], [180, 150, 135], [195, 150, 150], [135, 105, 90], [240, 210, 195], [240, 195, 195], [30, 15, 0], [150, 135, 120], [180, 165, 150], [240, 210, 210], [240, 195, 180], [105, 90, 75], [135, 120, 120], [225, 180, 165], [210, 165, 150], [240, 210, 180], [60, 45, 30], [120, 105, 105], [240, 225, 210], [225, 210, 195], [195, 150, 135], [75, 75, 60], [180, 165, 165], [240, 225, 225], [225, 195, 165], [195, 165, 135], [210, 150, 135], [210, 180, 150], [180, 135, 105], [195, 180, 165], [165, 120, 90], [165, 105, 75], [180, 120, 105], [210, 165, 135], [195, 135, 120], [225, 165, 150], [195, 150, 120], [210, 195, 180], [150, 90, 75], [225, 180, 150], [180, 120, 90], [195, 135, 105], [150, 75, 45], [180, 135, 120], [45, 15, 30], [210, 150, 120], [165, 105, 90], [165, 120, 105], [135, 90, 75], [135, 90, 90], [180, 120, 75], [165, 90, 60], [150, 90, 45], [135, 60, 30], [135, 75, 60], [150, 105, 75], [180, 150, 120], [15, 15, 0], [165, 135, 105], [240, 195, 165], [180, 105, 75], [165, 90, 45], [195, 135, 90], [150, 90, 60], [135, 90, 60], [150, 105, 90], [150, 135, 105], [45, 45, 30], [210, 135, 120], [195, 120, 90], [180, 105, 60], [165, 75, 45], [105, 75, 60], [210, 135, 105], [225, 150, 105], [225, 135, 105], [210, 120, 90], [195, 105, 75], [195, 120, 75], [195, 90, 60], [180, 90, 45], [150, 75, 30], [135, 75, 45], [240, 150, 105], [240, 135, 105], [210, 105, 75], [180, 90, 60], [195, 105, 60], [150, 75, 60], [135, 90, 45], [255, 150, 105], [240, 150, 120], [240, 165, 120], [240, 165, 135], [225, 120, 90], [180, 75, 45], [180, 75, 30], [165, 75, 30], [225, 150, 135], [255, 165, 120], [240, 180, 150], [255, 195, 165], [240, 150, 135], [210, 105, 60], [195, 90, 45], [150, 60, 15], [150, 60, 30], [45, 30, 45], [225, 165, 135], [255, 150, 120], [255, 210, 180], [225, 120, 75], [165, 90, 75], [195, 120, 105], [255, 210, 195], [255, 195, 180], [255, 180, 165], [240, 120, 90], [180, 105, 105], [120, 90, 75], [240, 135, 90], [255, 135, 105], [255, 180, 150], [195, 120, 120], [135, 120, 90], [255, 165, 135], [240, 180, 165], [165, 60, 30], [150, 60, 45], [180, 105, 90], [240, 165, 150], [255, 165, 150], [165, 75, 60], [165, 105, 60], [120, 105, 75], [240, 135, 120], [240, 120, 105], [195, 90, 75], [135, 45, 30], [255, 135, 90], [210, 120, 75], [225, 150, 120], [225, 135, 90], [240, 120, 75], [135, 45, 15], [75, 45, 30], [150, 120, 90], [240, 135, 75], [180, 75, 60], [150, 105, 105], [210, 105, 90], [135, 75, 30], [120, 90, 60], [255, 150, 135], [225, 120, 105], [120, 45, 15], [120, 60, 15], [210, 135, 90], [165, 60, 45], [105, 45, 0], [135, 105, 75], [180, 90, 75], [105, 60, 15], [225, 105, 75], [210, 90, 75], [210, 90, 60], [195, 75, 45], [105, 30, 0], [120, 75, 45], [120, 60, 30], [120, 30, 15], [120, 30, 0], [135, 30, 0], [150, 45, 15], [165, 45, 15], [165, 60, 15], [105, 30, 15], [105, 45, 15], [75, 60, 30], [105, 15, 0], [105, 0, 0], [120, 0, 0], [120, 15, 0], [135, 15, 0], [150, 30, 0], [90, 0, 0], [75, 0, 0], [75, 15, 0], [90, 15, 0], [90, 30, 0], [120, 60, 45], [45, 30, 15], [150, 45, 0], [165, 30, 0], [165, 45, 0], [180, 60, 30], [135, 45, 0], [120, 45, 0], [225, 165, 165], [105, 75, 45], [90, 30, 15], [120, 45, 30], [60, 30, 15], [180, 45, 0], [45, 0, 0], [90, 30, 30], [150, 45, 30], [120, 45, 45], [105, 60, 45], [30, 0, 0], [180, 60, 45], [195, 15, 0], [225, 135, 75], [105, 30, 30], [105, 15, 15], [60, 0, 0], [135, 30, 30], [180, 0, 0], [210, 0, 0], [195, 105, 90], [120, 30, 30], [165, 0, 0], [120, 75, 60], [210, 150, 105], [240, 150, 90], [135, 60, 45], [135, 60, 15], [165, 15, 0], [195, 0, 0], [195, 75, 30], [195, 60, 30], [180, 15, 0], [255, 150, 90], [165, 30, 15], [165, 45, 30], [105, 45, 30], [195, 75, 60], [90, 45, 15], [150, 30, 15], [180, 45, 30], [225, 105, 60], [225, 105, 90], [150, 15, 0], [210, 90, 45], [210, 120, 105], [90, 60, 45], [225, 135, 120], [225, 120, 60], [90, 45, 30], [135, 30, 15], [195, 105, 45], [75, 30, 15], [45, 15, 0], [180, 60, 15], [60, 15, 15], [195, 90, 30], [180, 75, 15], [165, 60, 0], [150, 75, 15], [105, 60, 60], [150, 60, 0], [180, 90, 30], [165, 75, 15], [180, 105, 45], [165, 90, 30], [180, 120, 60], [165, 105, 45], [150, 90, 30], [135, 60, 0], [120, 90, 105], [165, 150, 150], [75, 30, 0], [75, 30, 30], [135, 105, 120], [60, 15, 0], [135, 120, 135], [165, 135, 150], [90, 60, 75], [60, 60, 60], [75, 60, 75], [150, 135, 135], [255, 0, 0], [240, 0, 0], [225, 45, 15], [135, 75, 15], [105, 90, 105], [60, 45, 60], [195, 60, 15], [60, 30, 0], [75, 15, 15], [225, 30, 0], [120, 60, 0], [45, 30, 0], [225, 0, 0], [225, 15, 0], [195, 165, 180], [90, 75, 90], [150, 0, 0], [195, 30, 0], [210, 15, 15], [180, 150, 165], [150, 120, 135], [75, 75, 75], [75, 45, 15], [195, 45, 0], [210, 30, 30], [225, 60, 30], [210, 75, 30], [240, 45, 15], [210, 30, 15], [225, 75, 30], [180, 30, 0], [210, 15, 0], [105, 90, 60], [240, 210, 165], [225, 105, 45], [75, 45, 60], [60, 60, 30], [165, 120, 75], [60, 45, 15], [210, 105, 45], [225, 90, 45], [210, 30, 0], [240, 60, 30], [240, 45, 30], [210, 45, 15], [195, 150, 105], [105, 45, 45], [240, 15, 0], [240, 75, 45], [150, 45, 45], [150, 105, 60], [255, 75, 60], [45, 45, 15], [90, 90, 75], [180, 60, 0]], 'rows': [[[0, 52], 1, [0, 47]], [[0, 51], 2, [0, 4], 1, [0, 43]], [[0, 46], 3, 0, 0, 4, 1, 5, 6, 6, 1, 7, 2, 2, 4, 4, [0, 40]], [[0, 46], 5, 1, 0, 4, 8, 9, 10, 10, 8, 11, 12, 13, 11, 5, [0, 40]], [[0, 42], 4, [0, 3], 14, 6, 2, 5, 9, 15, 16, 17, 16, 18, 16, 19, 14, 20, 0, 1, 1, [0, 37]], [[0, 40], 11, 6, 21, 2, 3, 22, 16, 9, 8, 16, 17, 23, 23, 24, 25, 26, 23, 27, 27, 9, 0, 28, 14, [0, 37]], [[0, 37], 7, 0, 0, 6, 19, 5, 11, 29, 9, 30, 27, 15, 24, 23, 31, 23, 24, 32, 31, 32, 33, 24, 27, 11, 5, 34, 9, 35, 6, [0, 4], 11, 28, [0, 28]], [[0, 31], 4, [0, 3], 2, 36, 12, 6, 13, 18, 18, 27, 13, 19, 16, 24, 31, 33, 32, 32, 37, 31, 24, 32, 38, 38, 39, 32, 26, 34, 10, 34, 23, 13, 40, 28, 41, 2, 10, 42, 2, [0, 28]], [[0, 31], 7, 0, 0, 1, 12, 9, 19, 19, 10, 24, 17, 43, 24, 31, 44, 31, 38, [33, 4], 37, 37, 33, [39, 4], 33, 44, 19, 16, 31, 23, 27, 45, 17, 16, 14, 9, 6, [0, 28]], [[0, 27], 4, 0, 7, 0, 11, 21, 11, 11, 14, 43, 26, 17, 43, 38, 31, 31, 33, 46, [38, 7], 33, 38, [39, 3], 38, 39, 38, 47, 37, 17, 23, 31, 44, 27, 27, 9, 16, 15, 48, 0, 1, 1, [0, 25]], [[0, 27], 4, 11, 13, 8, 16, 9, 16, 18, 49, 26, 39, 16, 50, 46, 39, 38, 39, 51, 46, 52, 38, 52, 38, 38, 52, 38, 38, 39, 39, 46, 38, 47, 46, 47, 47, 33, 32, 37, 31, 17, 27, 23, 31, 31, 16, 53, 8, 1, [0, 25]], [[0, 25], 21, 11, 5, 8, 54, 27, 37, 27, 26, 31, 33, 49, 32, 55, 24, 38, 46, 47, 47, 51, 46, 38, [55, 3], 52, 52, 33, 56, 47, 39, [47, 3], 46, 47, 46, 47, 38, 33, 37, 31, 31, 32, 31, 26, 16, 16, 10, [0, 26]], [[0, 26], 14, 18, 14, 16, 37, 33, 38, 38, 24, 38, 24, 37, 38, 56, 52, 46, 57, 38, 46, 47, 31, 56, 37, 37, 55, 52, 55, 37, 52, [33, 3], 38, 39, 39, 46, 47, 46, 38, 55, 33, 32, 33, 24, 16, 32, 27, 34, 12, 5, 6, [0, 23]], [[0, 25], 28, 58, 26, 59, 43, 38, 33, 39, 60, 61, 38, 57, 24, 38, 55, 46, 55, 56, 37, 46, 33, 24, 56, 24, 38, 31, 37, 62, 55, 33, 55, 37, 31, 33, 47, 39, 33, 52, 46, 38, 55, 38, 33, 33, 31, 17, 23, 27, 27, 63, 14, 1, 0, 7, [0, 21]], [[0, 25], 1, 0, 64, 5, 49, 39, 38, 47, 65, 60, 38, 46, 66, 57, 52, 52, 67, 68, 69, 46, 55, 38, 56, 70, 62, 55, 56, 56, 31, 31, 37, 55, 55, 37, 39, 38, 38, 33, 52, 47, 38, 38, [33, 3], 44, 31, 26, 27, 8, 6, 13, 20, 13, [0, 21]], [[0, 23], 4, 6, 8, 1, 71, 34, 34, [46, 3], 60, 51, 46, 57, 66, 66, 55, 52, 62, 72, 66, 55, 55, 31, 55, 73, 74, 68, 68, 62, 62, 56, 37, 56, 33, 55, 37, 33, 52, 38, 33, 46, 38, 33, 37, 33, 33, 37, 37, 23, 44, 17, 27, 42, 34, 13, 1, [0, 20]], [[0, 24], 14, 5, 59, 23, 44, 19, 38, [46, 4], 52, 55, 55, 75, 55, 69, 76, 73, 56, 62, 77, 55, 55, 68, 74, 62, 76, 78, 74, 62, [56, 3], 55, 37, 31, 33, 55, 33, 47, 33, 33, 37, 39, 38, 37, 37, 32, 26, 34, 53, 27, 9, 7, [0, 21]], [[0, 21], 1, 2, 2, 8, 16, 42, 79, 37, 19, 17, 46, 57, 52, 52, 55, 56, 55, 75, 69, 75, 70, 76, 76, 62, 56, 38, 56, 56, 55, 56, 74, 80, 76, 70, 75, [62, 4], 24, 55, 56, 37, 31, 33, 55, 33, 33, 38, [37, 3], 19, 53, 43, 27, 63, 0, 4, [0, 20]], [[0, 22], 2, 13, 45, 43, 43, 37, 52, 31, 67, 81, [52, 3], 69, 69, 55, 81, 56, 56, 76, 68, 82, 83, 75, 55, 62, 56, 56, 75, 80, 84, 72, 83, 85, 78, 78, 72, 78, 24, 69, 78, 56, 62, 31, 24, [37, 5], 31, 17, 30, 62, 34, 0, 11, 4, 2, [0, 19]], [[0, 22], 86, 11, 42, 17, 37, 62, 55, 38, 56, 75, [55, 4], 67, 75, 81, 56, 75, 75, 87, 73, 73, 88, 69, 78, 70, 70, 62, 72, 84, 80, 75, 74, 85, 89, 90, 72, 85, 75, 85, [62, 3], 56, 37, 56, 37, 55, 37, 31, 17, 24, 44, 35, 5, 5, 36, 11, [0, 19]], [[0, 21], 4, 4, 91, 53, 17, 37, 55, 69, 52, 66, 75, 62, 81, 56, 81, 75, 68, 81, 69, 70, 78, 87, 92, 93, 94, 78, 83, 82, 82, 88, 82, 95, 96, 78, 82, 74, 97, 72, 97, 74, 89, 85, 85, 98, 62, 56, 62, 56, 56, 62, 56, 31, 44, 43, 44, 9, 16, 12, 8, 11, 21, 99, [0, 17]], [[0, 20], 7, 2, 40, 19, 37, 43, 100, 38, 66, 66, 101, 75, 78, 62, 68, 68, 87, 75, 78, 77, 74, 83, 76, 83, 102, 103, 102, 104, 102, 105, 95, 82, 95, 105, 100, 76, 106, 107, 96, 72, 80, 90, 72, 89, 85, 56, 43, 43, 62, 67, 62, 24, 37, 56, 24, 43, 108, 43, 26, 34, 8, 109, 1, [0, 17]], [[0, 20], 11, 11, 9, 45, 17, 69, 55, 85, 55, 55, 66, 75, 70, 83, 83, 110, 87, 87, 111, 87, 83, 82, 82, 111, 112, 113, 103, [102, 2], 84, 84, 73, 95, 88, 97, 88, 106, 96, 106, 88, 97, 97, 72, 72, 85, 62, 85, 85, 98, 98, 62, [24, 3], 56, 62, 62, 17, 18, 63, 4, 21, 6, [0, 17]], [[0, 21], 12, 53, 114, 107, 43, 66, 66, 52, 55, 81, 87, 83, 115, 116, [117, 3], [115, 2], 118, 119, 102, 120, 119, 121, 122, 113, 93, 123, 93, 84, 105, 73, [124, 4], 97, 106, [105, 2], 97, 80, 70, 76, 85, 85, 98, 17, 62, 62, 56, 44, 24, 56, 43, 19, 12, 22, 29, 8, 1, [0, 17]], [[0, 20], 58, 58, 34, 43, 56, 24, 56, 55, 81, 81, 75, 68, 110, 117, [125, 2], [126, 2], 117, [115, 2], 118, 115, 117, 118, 127, 121, 128, [122, 2], 129, 128, 94, 94, 105, 130, 84, [124, 3], [105, 2], 131, 73, 83, 72, 74, 70, [62, 3], 98, 24, 43, 43, 56, 62, 45, 19, 18, 5, 99, [0, 18]], [[0, 20], 8, 114, 40, 34, [55, 3], 66, 66, 56, 78, 76, 110, 126, 125, [132, 2], 133, 134, [135, 5], 133, 136, 127, 121, 137, 122, 138, 122, 103, 139, [123, 3], 95, 95, 84, 84, 124, 105, [82, 4], 72, 89, 62, 67, [62, 3], 43, 24, 62, 17, 19, 13, 1, [0, 19]], [[0, 20], 5, 50, 19, 43, 56, 55, [66, 3], 81, 75, 140, 133, [125, 2], [132, 2], 141, 142, 143, [101, 3], 142, 144, 126, 136, 145, 121, 146, 122, 138, [139, 3], 147, [148, 2], 123, 84, 84, 105, 88, [82, 3], 73, 88, 89, 85, 67, 56, [62, 3], 24, 24, 43, 17, 44, 40, [0, 19]], [[0, 20], 149, 42, 37, [107, 2], 85, 69, 66, 55, 56, 77, 150, 133, 125, 126, 132, 151, 135, 143, 152, [52, 3], 101, 144, 126, 136, 153, 127, 145, 121, 122, 137, 138, [139, 2], [123, 2], 84, 84, 130, 154, 74, 74, 155, 82, 73, 154, 89, 76, [85, 3], 62, 43, 24, 37, 56, 43, 45, 1, [0, 19]], [[0, 21], 109, 18, 69, 55, [66, 3], 69, 56, 81, 135, 125, [126, 3], 151, 142, 143, 156, 152, 101, 157, 158, 133, 126, 159, [153, 3], 145, 121, 146, 122, [137, 2], 113, 139, 113, 130, 154, 160, 74, 76, 83, 82, 73, 154, 82, 68, 56, 85, 43, 62, 44, 44, 56, 62, 114, 161, 2, 5, 6, [0, 17]], [[0, 20], 4, 29, 45, 90, 98, 69, 66, 55, 75, 56, 55, 135, 126, [162, 2], 163, 151, 164, 157, 152, 52, [157, 2], 164, 133, 126, 136, [153, 3], 127, [121, 2], 122, 137, 113, 139, [148, 2], 84, 154, 160, 165, 83, [155, 2], 73, 73, 72, 62, 33, 55, 31, 56, 37, 55, 55, 56, 43, 25, 27, 19, 11, [0, 17]], [[0, 19], 6, 58, 10, 166, 75, 81, 69, 69, 75, 77, 75, 142, 144, [162, 3], 163, 132, 167, 164, 158, 168, 143, 142, 144, 126, [136, 2], [153, 2], [127, 2], [121, 2], 128, 137, 113, 169, [148, 2], 170, 130, 154, 171, 82, 76, 155, 73, 73, 74, 85, 31, 33, 52, 38, 38, 46, 38, 38, 33, 24, 15, 10, 5, 6, [0, 16]], [[0, 19], 6, 10, 5, 42, 98, 81, 55, 55, 81, 75, 150, 172, 133, [162, 4], 163, 133, 135, 167, 164, 173, 144, 133, 126, [136, 2], 153, [127, 3], 121, [128, 3], 113, [148, 4], 170, 174, 154, 155, 76, 155, 93, 175, 74, 62, 62, 24, 55, [46, 3], 47, 39, 38, 37, 24, 27, 9, 6, 1, [0, 15]], [[0, 19], 6, 176, 17, 43, 67, 75, 75, 55, 81, 75, 77, 150, 125, [162, 4], 126, 125, 133, [135, 3], 133, 177, 178, [136, 2], 153, [127, 2], 119, 179, [128, 2], 93, 174, 84, [148, 2], 180, 95, 84, 93, 171, 155, 171, [105, 2], 88, 76, 62, 62, 24, 37, 55, 38, 33, 47, 33, 23, 17, 27, 34, 9, 6, [0, 15]], [[0, 19], 4, 6, 161, 43, 24, 75, 81, 52, 81, 77, 81, 150, 117, [162, 2], 181, 162, 126, 163, 151, 133, [144, 2], 133, 126, [136, 2], 118, 182, 127, [119, 3], 128, 93, 93, 174, 170, 148, 95, 180, 95, 95, 130, 154, [171, 2], 94, 105, 88, 76, [85, 3], [62, 3], 56, 31, 24, 37, 24, 62, 34, 6, [0, 16]], [[0, 18], 4, 6, 29, 40, 161, 98, 56, 66, 55, 55, 77, 150, 183, 184, 185, 162, 181, [163, 2], 126, 133, [135, 2], 144, 133, 177, 117, [136, 2], 118, 182, [119, 3], 128, 93, 174, 113, 170, 95, 180, [186, 2], 95, 84, 154, 73, 93, 93, 154, 74, 85, [62, 4], 98, 62, 24, 56, 56, 31, 43, 17, 9, 6, [0, 16]], [[0, 18], 99, 187, 114, 188, 45, 89, 69, 66, 55, 81, 87, 87, 183, 184, 159, 162, 163, [126, 2], 151, [135, 4], 133, 177, [136, 3], [118, 2], 127, [119, 2], [128, 2], 174, 113, 148, 95, 95, [186, 2], 95, 95, 130, 171, 103, [105, 2], 74, 56, 62, 17, 85, 85, 43, 62, 62, 24, 56, 37, 37, 43, 34, 161, 11, [0, 15]], [[0, 18], 1, 22, 35, 107, 43, 56, 37, 69, 69, 75, 87, 150, 183, 153, 189, [162, 2], 163, 132, 151, [167, 2], [135, 2], [133, 2], 117, [136, 2], [118, 2], [127, 2], 119, 179, 190, 113, [170, 2], 148, [95, 4], 84, 95, 95, 123, 84, 80, 89, 191, 43, 85, 89, [85, 3], 62, 24, 56, 37, 55, 24, 16, 59, 5, 2, [0, 14]], [[0, 20], 6, 161, 17, 43, 24, 56, 75, 87, [150, 2], 117, 184, 189, [162, 2], [163, 2], 151, [135, 3], [133, 2], 126, 117, 136, [118, 2], 136, 192, 127, 119, 179, 128, 113, 170, [148, 3], [95, 6], 193, 84, 80, 88, 89, 107, 89, 85, 17, 85, [62, 3], 55, 55, 56, 19, 9, 10, 11, [0, 15]], [[0, 21], 29, 194, 45, 67, 67, 68, 87, 83, 115, 184, [162, 4], [163, 2], 151, 195, [167, 2], 133, 126, 196, 136, 118, 127, [136, 2], 118, 127, 119, 179, 128, 113, 169, [148, 4], [95, 5], 197, 198, 124, 97, [107, 4], 19, 89, 85, 62, 56, [55, 3], 24, 42, 29, 4, [0, 15]], [[0, 20], 6, 40, 45, [98, 3], 78, 78, 83, 199, 153, [162, 3], 181, [163, 4], 151, 133, [126, 2], 117, 136, [127, 2], 118, 136, 118, 127, 119, 179, 128, 174, 200, [148, 5], [95, 4], [201, 2], 198, 106, 107, 188, 107, 202, 89, 85, 98, 56, 55, 52, 38, 24, 19, 29, 2, 1, [0, 15]], [[0, 21], 4, 29, 187, 58, 70, 70, 73, 92, 182, [162, 4], 181, [162, 4], [126, 2], 196, [136, 2], [127, 4], 136, 127, 119, [179, 2], 203, 174, 170, 148, [95, 7], 198, [201, 3], 204, 106, 107, [89, 3], 85, 85, 56, 37, 55, 55, 44, 45, 5, 6, [0, 16]], [[0, 23], 29, 161, 70, 70, 72, 102, 153, [162, 5], 126, 162, [159, 3], [136, 2], 205, [127, 2], 121, [179, 2], 127, 206, 179, 121, [128, 2], 84, 84, 170, [95, 4], 84, 84, 95, 197, [201, 5], 96, 97, 107, 19, 85, 85, 62, 56, 56, 24, 62, 16, 10, 6, [0, 16]], [[0, 23], 36, 42, 100, 78, 82, 118, 162, 189, 162, 153, 159, 162, [126, 2], 159, [136, 2], 127, [207, 2], 121, 208, 121, [128, 2], 127, 207, 128, 190, [174, 2], 130, 174, 84, 170, [84, 4], 130, 84, 197, 201, [209, 2], [201, 3], 210, 72, 107, 89, 85, 98, 56, 56, 24, 62, 19, 53, 11, 2, [0, 15]], [[0, 22], 1, 187, 12, 85, 78, 83, 184, 189, [153, 3], 146, 122, 119, 179, [128, 2], [113, 3], [137, 2], 138, [137, 3], 121, 208, 139, [148, 2], 170, 84, 84, [124, 2], 84, 84, 93, 93, 73, 93, 211, 201, [209, 3], [201, 2], 204, 106, 188, 107, 89, 98, 62, 24, 56, 24, 43, 9, 5, 7, [0, 15]], [[0, 22], 1, 161, 100, 78, 78, 82, 184, 136, [153, 2], 121, 137, 148, 186, 180, 197, 212, [213, 2], 214, [215, 2], 216, [137, 2], 113, 137, 138, 217, [186, 2], 212, [218, 2], 219, 197, 211, [198, 2], 124, 105, 93, 124, 201, [209, 3], [201, 2], 204, 106, 89, 202, 107, 89, 43, 62, 89, 161, 13, 11, 2, 2, [0, 15]], [[0, 22], 99, 220, 89, 75, 83, 111, 184, [153, 2], 145, 146, 139, 148, 186, 213, 221, 222, 223, 224, 225, [226, 2], 216, 138, 137, 113, 137, 169, 215, 214, 213, 221, 227, [228, 2], [229, 2], 230, [231, 2], 219, 84, 130, 197, [209, 4], 201, 198, 232, 188, 90, 89, 43, 56, 56, 15, 45, 19, 18, 53, 5, 2, [0, 14]], [[0, 23], 233, 90, 150, 83, 118, 162, 189, 153, 129, [122, 2], 113, [169, 3], 216, [234, 2], 235, [226, 2], 236, 237, [137, 2], 139, 215, 238, 213, 209, [213, 2], [209, 2], 212, [197, 2], 219, [209, 2], 219, 95, 198, [201, 2], 239, [197, 3], 106, 89, 89, 85, 85, 77, 240, 55, 62, 45, 29, 109, 11, [0, 15]], [[0, 23], 109, 241, 83, 111, 199, [162, 2], 153, 145, 146, 208, 237, 215, 186, 218, 230, 228, 221, 214, 234, [226, 2], 138, 129, 121, 113, 186, 239, 213, [209, 2], 221, 227, 229, [242, 2], 219, 243, 218, [209, 2], 197, 201, 209, 201, 197, 198, 95, 95, 105, 70, 62, 85, 62, 155, 179, 78, 62, 17, 6, 0, 4, [0, 15]], [[0, 23], 4, 244, 83, 111, 184, [162, 2], 153, 145, 146, 245, 225, 223, 218, 246, 2, 40, 247, 180, 215, 248, 234, 146, 184, 127, 113, 238, 239, [197, 2], 213, 224, 249, 250, 35, 21, 251, 246, 229, [209, 3], [201, 2], 239, 198, 95, [193, 2], 105, 72, 98, 62, 74, 252, 253, 111, 85, 27, 49, 13, 28, [0, 15]], [[0, 24], 58, 87, 111, 254, [189, 2], 162, 185, 145, 208, 121, 252, 170, 255, 227, 256, 180, 248, 169, 200, 217, 136, 133, 118, 137, 238, 239, [197, 3], 248, 170, 96, 228, [257, 2], 247, 230, 227, 230, 209, [201, 2], 239, 198, 95, 193, 84, 175, 72, 70, 85, 258, 259, 260, 102, 17, 16, 34, 12, [0, 16]], [[0, 22], 1, 6, 90, 87, 119, 153, [189, 2], 162, 126, 162, 125, 133, 117, 261, 203, [200, 4], 113, 200, 121, 125, 133, 118, 137, 186, [239, 2], 197, 95, [170, 2], 248, 180, [262, 2], 197, 212, [209, 2], 201, [239, 3], 95, 124, 95, 193, 73, 82, 70, 171, 223, 263, 260, 190, 58, 2, 2, 5, 11, [0, 15]], [[0, 22], 2, 1, 264, 265, 112, 153, [189, 2], 266, 151, 134, 162, [136, 2], 127, 121, 252, [237, 2], 169, 137, 121, 126, 167, 133, 127, 169, 215, [239, 2], 197, 186, [148, 3], [170, 2], [267, 2], 95, 197, 209, 201, [239, 2], 197, [95, 3], 268, 105, 82, 72, 130, 223, 269, 270, 171, 13, 6, [0, 18]], [[0, 24], 244, 92, 122, 153, 185, 162, 132, [125, 2], 126, 205, 271, 272, [237, 3], 137, 121, 127, 162, 133, 135, 117, 121, 169, 215, 238, [239, 2], 186, [170, 2], 148, 215, 180, 148, 95, 186, [239, 2], 197, 95, 95, 148, 170, 95, 95, 268, 84, 175, 82, 148, 214, 235, 273, 155, 19, 11, [0, 18]], [[0, 23], 1, 251, 124, 122, 153, 185, 162, 274, 132, 125, 126, 159, 205, 127, [207, 2], 127, 118, 136, [126, 2], 151, 135, 136, 121, 148, 215, 186, [239, 2], 238, [148, 2], 170, [148, 3], [186, 3], 95, 84, 93, [174, 2], 84, 95, [268, 2], 95, 84, 93, 214, 226, 275, 276, 85, 12, 48, [0, 18]], [[0, 25], 277, 145, 153, 185, 162, 181, 132, 133, 167, 151, [133, 4], [144, 2], 133, [163, 2], 195, 135, 136, 121, 215, [186, 2], 239, 213, 238, 215, [148, 3], 169, [148, 2], 169, [148, 4], 113, 93, 93, 84, 268, 239, 268, 130, 174, [226, 2], 216, 154, 19, 114, 6, [0, 18]], [[0, 25], 277, 205, 153, 185, 189, 181, 163, 132, [167, 6], 173, 167, 151, [126, 2], 167, 173, 196, 278, 215, 213, 186, [239, 2], 238, 148, [169, 7], 148, [215, 2], [148, 2], 113, 93, 84, 268, 197, 84, [203, 2], 226, 235, 216, 171, 34, 19, 233, [0, 18]], [[0, 25], 279, [153, 2], [185, 2], [181, 2], 132, 167, [173, 3], [167, 3], 151, 126, [162, 2], 151, 144, 136, 278, 186, 213, [239, 2], 238, 186, [200, 2], [137, 2], [169, 5], 148, 147, 268, 95, 84, 93, 93, 123, 84, 93, 111, 261, 280, 275, 281, 78, 62, 89, 11, 1, [0, 17]], [[0, 25], 277, 205, 153, [185, 2], 181, [163, 2], 133, 167, 164, 173, 195, 177, 126, 205, 282, 162, 125, 167, 144, 283, 137, 186, 209, 201, [239, 2], 148, 113, [137, 4], 138, 237, 137, [113, 2], 148, [268, 2], 148, 113, 93, 84, 84, 128, 102, 179, 284, 216, 237, 70, 45, 233, 11, 22, [0, 17]], [[0, 25], 211, 127, 153, [185, 2], 181, [163, 2], 126, 144, 135, [178, 2], 159, 205, 285, 153, [125, 2], 173, 133, 127, 252, 186, 213, [209, 2], 239, 95, 113, 137, [128, 2], [137, 4], 113, 93, 174, 148, 268, 84, 113, 93, 84, 84, 93, 102, 119, 286, 128, 190, 89, 45, 287, 2, [0, 18]], [[0, 25], 211, 127, 153, [185, 2], [181, 3], 126, 151, 126, 283, 205, 127, 207, 271, [126, 3], 177, 118, 179, 113, 186, 213, 209, 239, 201, 197, 169, 137, [128, 3], [137, 2], [113, 2], [93, 3], 84, 123, 93, 128, 84, 84, 103, 128, 261, 288, 118, 286, 75, 98, 13, [0, 19]], [[0, 25], 124, 127, 289, [185, 2], [159, 3], [126, 3], 136, 207, 146, 271, 208, [153, 3], 145, 208, 137, 148, 186, [213, 5], 215, [137, 2], [128, 3], 137, 169, 148, 113, [93, 3], 84, 103, 93, 103, 123, 84, 93, 203, 261, [140, 2], 89, 6, 11, 2, [0, 18]], [[0, 25], 211, 145, 289, [185, 5], [159, 2], 136, 127, 207, [208, 3], 272, 216, 146, 138, 217, 234, 238, 213, [209, 2], [213, 3], 214, 113, 137, [128, 3], 113, 148, 215, 148, 84, 84, [103, 3], 93, 103, [84, 3], 102, 288, 286, 155, 264, 22, [0, 20]], [[0, 25], 290, 145, 289, [185, 6], [205, 2], 127, 121, 137, 127, 177, 283, 275, [226, 2], 214, 213, 209, 221, 218, [221, 3], 213, 186, 148, [137, 3], 190, 113, 148, 248, 186, 268, [123, 2], 84, 113, 93, 103, 123, 84, 84, 93, 192, 133, 111, 287, [0, 21]], [[0, 25], 241, [145, 2], [153, 4], [205, 3], 145, 121, 137, 127, 177, 133, 144, 127, 137, 291, 224, [221, 2], [230, 2], [221, 3], 212, 180, 148, 113, [137, 2], 113, 200, [148, 2], 186, 197, 95, 95, 148, 123, 93, 103, [123, 2], 84, 103, 252, 208, 119, 175, 48, [0, 20]], [[0, 25], 73, [145, 2], [153, 2], [282, 4], 207, 121, 208, 121, 136, [126, 2], 177, 127, 128, 148, 213, 212, 221, 230, [221, 4], 212, 243, 170, 113, [169, 3], 148, 147, 268, [239, 3], 197, 186, 148, 113, 103, 123, 148, 123, 113, 248, 280, 80, [277, 2], [0, 20]], [[0, 25], 219, 292, [145, 2], [282, 3], 207, 285, [208, 2], 137, [121, 2], [127, 3], 128, 169, 215, 213, 243, 212, 209, 221, 209, 230, [221, 2], 243, 180, [148, 2], 169, [147, 2], 186, 238, 239, 213, [209, 2], 239, [268, 2], 103, 123, 84, 148, 139, 102, 130, 293, 294, 279, [0, 20]], [[0, 25], 209, 93, [145, 3], [285, 3], 271, [138, 3], 137, 139, [137, 2], 139, [147, 2], 238, 213, 197, 239, 209, 221, [230, 4], 221, 209, 213, 238, [215, 2], [238, 3], 239, 213, [209, 2], 239, [268, 2], 84, 123, [148, 2], 123, 261, 210, 294, 187, 244, [0, 20]], [[0, 25], 246, 139, [145, 2], [285, 2], 146, 271, 295, 236, [147, 3], 238, [123, 2], 139, 147, 238, 186, [209, 2], 239, 213, 209, [230, 2], [229, 3], [230, 2], 209, 213, [238, 3], [213, 3], [209, 3], 186, 268, 123, 268, [148, 2], 123, 119, 105, 210, 296, [0, 21]], [[0, 26], 277, 129, 121, 146, 297, 271, 298, 299, 234, [238, 2], [239, 2], 268, 147, 300, 147, [238, 2], [214, 2], 186, [213, 2], 221, [230, 2], 257, 228, 257, 228, 230, 221, 213, [238, 2], [213, 2], [209, 4], 239, [268, 5], 148, 113, 123, 277, 1, [0, 21]], [[0, 26], 294, 122, [146, 2], [138, 2], 295, 299, 217, 147, 239, 230, 221, 213, 224, 214, [225, 2], 284, [226, 3], 225, 224, 222, [227, 2], 228, 229, [257, 3], 229, 213, 238, 239, 213, [209, 4], 231, 209, [239, 4], 186, 148, 107, 301, [0, 23]], [[0, 27], 84, [146, 2], 138, [298, 2], [138, 2], 302, 239, 230, 224, 214, 226, 169, 137, 200, 169, 248, 215, [291, 2], 186, 291, 212, 213, 221, 230, 228, [246, 2], 228, 213, 238, 239, [209, 3], [231, 3], 209, 201, 239, [201, 2], 239, 95, 25, 8, 3, [0, 22]], [[0, 27], 277, 146, 208, 138, 298, [138, 3], 234, 209, 221, 215, 137, [121, 2], 129, 138, 139, [169, 2], [215, 2], 248, 95, 186, 213, 209, 213, 209, 229, 246, 257, 209, 213, 209, [231, 3], [209, 2], 231, [209, 5], 239, 267, 16, 13, 11, [0, 22]], [[0, 27], 294, 137, [138, 5], 217, 238, 221, 214, 137, 145, [127, 2], 122, 303, 139, 103, 147, [186, 2], 268, [239, 2], [213, 4], 209, 228, 257, 221, [209, 2], [231, 2], [209, 4], 230, [231, 3], 209, 239, 107, 59, 11, 59, 11, [0, 21]], [[0, 28], 95, [138, 4], 304, 302, 213, 230, 239, 139, 121, 127, 145, 292, [305, 2], 306, 268, 193, [268, 2], 239, 268, 238, [213, 2], 209, 230, 228, 257, 230, 209, 221, [231, 2], [209, 4], [230, 4], 209, 201, 27, 35, 21, 14, 20, [0, 21]], [[0, 28], 244, 139, 138, [298, 2], 217, 234, 213, 219, 239, 147, 121, 127, 145, 119, 182, 307, 308, 103, 308, 309, 123, [300, 2], 310, 238, 213, 209, 229, 257, 246, 229, 230, 221, [209, 6], [230, 2], 229, [231, 2], 250, 14, 2, 8, 311, 14, [0, 21]], [[0, 29], 95, 217, 295, [217, 2], 234, 238, 209, 239, 148, 121, 127, 118, [184, 2], 199, [112, 2], 120, 112, 103, 139, 300, 268, 239, 209, 230, 257, [246, 2], 229, 230, [209, 2], 201, [239, 2], [209, 2], 230, [229, 2], 230, 231, 9, 6, 6, 8, 312, 6, [0, 21]], [[0, 29], 293, [217, 3], 299, [302, 2], [239, 2], 148, 121, 127, 126, 117, 118, 119, 129, 122, 129, 92, 175, 148, 147, 268, 197, 209, 228, 246, [251, 2], 229, 231, [209, 2], [239, 3], 209, [230, 2], 229, 230, 229, 13, 5, 2, 11, 312, 8, 8, 1, [0, 20]], [[0, 30], 186, [217, 4], 302, 209, 239, 123, 129, 127, 136, 118, 127, [129, 2], 112, [139, 2], 103, 148, [239, 3], 231, 257, 246, 251, 246, 313, [209, 3], [239, 2], [209, 2], 230, [229, 3], 314, 8, 2, 7, 54, 54, 8, 315, 11, 2, 22, [0, 18]], [[0, 30], 293, [234, 2], [299, 2], 302, 209, 239, 123, 122, 207, 127, 128, 112, 137, [122, 2], 139, 234, 186, 95, 239, 197, 230, 229, 257, [251, 2], 294, [231, 2], 209, 201, 239, [209, 2], 230, [229, 3], 316, 13, 86, 4, 14, 311, 5, 317, 318, 319, 1, 6, 5, 6, [0, 16]], [[0, 30], 1, 95, [234, 2], 302, 234, 230, 231, 239, 139, 146, 121, 139, 122, 103, 175, 123, 139, 147, 238, 197, 213, 209, 229, 316, 246, [251, 2], 246, 231, [209, 5], [230, 2], 229, 313, 229, 5, 11, 1, 320, 14, 5, 8, 23, 16, 5, 1, 1, 6, 5, 5, 4, [0, 14]], [[0, 30], 11, 290, 234, 238, 234, 238, 213, 228, 231, 197, 148, 139, 147, 103, [175, 2], 123, 103, 268, [209, 2], 230, 229, 257, [246, 2], [251, 2], 246, 231, [209, 4], [230, 3], 229, 316, 6, 11, 1, 6, 321, 5, 320, 322, 54, 311, 319, 6, 2, 6, 11, 5, 8, 21, [0, 13]], [[0, 22], 260, [323, 11], 324, 213, 209, [229, 2], 230, 275, [323, 5], 325, 123, 326, 209, 229, 257, [246, 2], 251, 260, [323, 4], [231, 4], 260, [323, 4], 8, 1, 4, [11, 3], 14, 311, 8, 5, 8, 11, 4, 0, 1, 6, 8, 327, 8, 6, [0, 11]], [[0, 22], 260, [323, 11], 324, [209, 2], 231, [229, 2], 260, [323, 5], 324, 268, 198, 231, 257, 246, [251, 3], 260, [323, 4], [230, 4], 260, [323, 4], 2, 1, 21, 109, 7, 321, 8, 328, 14, 10, 2, 22, 1, 0, 2, 14, 5, 5, 8, 327, 8, 2, [0, 9]], [[0, 22], 260, [323, 11], 324, 201, 230, 229, 230, 221, 324, [323, 6], 329, 198, 231, 246, 251, 1, [251, 2], 260, [323, 4], [230, 4], 260, [323, 4], 0, 7, 2, 2, 11, 5, 11, 11, 54, 8, 2, 29, 6, 1, 6, 5, 59, 322, 315, 8, 322, 54, 8, 4, [0, 7]], [[0, 22], 260, [323, 4], 220, 330, [244, 2], 294, 331, 123, 231, [209, 2], 230, 228, 259, [323, 7], 332, 333, 231, [251, 5], 260, [323, 4], 229, [230, 2], 229, 260, [323, 4], 4, 2, 28, 6, 11, 11, 7, 322, 9, 5, 2, 14, 40, 1, 22, 8, 64, 26, 16, 315, 14, 26, 318, 322, 59, 11, [0, 5]], [[0, 22], 260, [323, 4], 244, 334, 244, 294, 246, 229, 122, 239, [221, 2], [227, 2], 335, [323, 3], 336, [323, 4], 302, 230, 246, 251, [246, 3], 260, [323, 4], 228, 229, 257, 246, 260, [323, 4], 0, 1, 7, 6, 6, 2, 8, 27, 10, 35, 5, 59, 40, 1, 6, 322, 337, 26, 59, 20, 14, 338, 14, 311, 59, 59, 14, 6, [0, 3]], [[0, 22], 260, [323, 4], 334, 187, 41, 316, 246, 257, 122, 137, 213, [221, 2], 339, [323, 4], 236, 336, [323, 3], 340, 229, [257, 2], [229, 2], 257, 260, [323, 4], 246, [251, 2], 6, 341, [323, 4], 0, 4, 7, [2, 3], 54, 9, 14, 58, 14, 9, 35, 1, 8, 312, 342, 343, 13, 58, 5, 8, [14, 3], 8, 321, 5, 344, 5, 2], [[0, 22], 260, [323, 4], [244, 2], 316, 257, 246, 345, [292, 2], 146, 238, 224, 260, [323, 3], 335, 238, 346, [323, 3], 324, 230, 228, [230, 3], 229, 260, [323, 4], 1, 1, 11, 11, 347, [323, 4], 1, 4, 4, [2, 3], 317, 311, 8, 13, 59, 10, 41, 2, 59, 322, 16, 10, 58, 58, 35, 35, 8, [311, 3], 59, 311, 14, 8, 14], [[0, 22], 260, [323, 11], 348, 292, 146, 234, 324, [323, 3], 253, 238, 122, 324, [323, 3], 263, [221, 2], 230, 231, 230, 260, [323, 4], 1, 6, 8, 14, 260, [323, 4], 1, 1, 2, 6, 1, 6, 54, 54, 13, 10, 311, 13, 251, 6, 343, 59, 13, 11, 58, 58, [233, 2], 5, 54, 322, 16, 311, 14, 315, 54, 59], [[0, 22], 260, [323, 11], 348, 146, 292, 349, [323, 3], 324, 284, 225, 147, 350, [323, 3], 260, [221, 2], [209, 3], 260, [323, 4], 109, 8, 34, 5, 260, [323, 4], 1, 1, 6, 2, 0, 320, 54, 54, 5, 319, 8, 11, 1, 5, 315, 13, 11, 40, 6, [233, 2], 6, 14, 343, 311, 20, 20, 54, [322, 2], 318], [[0, 20], 1, 2, 351, [323, 11], 352, 297, 146, 325, [323, 3], 335, [214, 3], 353, [323, 3], 324, 214, [213, 2], 221, 230, 260, [323, 4], 8, 5, 5, 1, 260, [323, 4], 1, 7, 22, 1, 1, 8, [315, 2], 20, 319, 29, 6, 2, 8, 10, 35, 5, 40, 6, [233, 2], 29, [8, 3], 311, 343, 318, 322, 16, 343], [[0, 15], 99, 2, 2, 22, 233, 109, 58, 341, [323, 4], 330, 313, 294, 175, 306, 122, [282, 2], 285, 271, 324, [323, 3], 340, [226, 4], 324, [323, 3], 273, 224, 221, 227, 228, 260, [323, 4], 14, 0, 1, 0, 260, [323, 4], 2, 7, 4, 0, 4, 14, 54, 54, 14, 13, 35, 251, 2, 11, 58, 11, 5, 40, [233, 2], 58, 29, 5, 5, 14, 315, 54, 59, 59, 34, 315], [[0, 12], 99, 22, 22, 6, [109, 3], [58, 3], 354, [323, 4], 293, 294, 355, 356, 210, 128, 357, [282, 2], 352, [323, 13], 335, [213, 3], 221, 260, [323, 4], 6, [0, 3], 260, [323, 4], 22, 2, 1, 0, 4, 327, 54, 54, 14, 358, 6, 1, 233, 58, 58, 5, 5, 58, [233, 2], 58, 58, 29, 8, 14, 14, 8, 20, 59, 311, 322], [[0, 9], 99, 7, 11, 5, 11, [109, 3], [58, 3], 359, 233, 260, [323, 4], 316, 294, 287, 360, 112, 145, [282, 3], 350, [323, 14], 236, 234, 214, 224, 260, [323, 4], [0, 4], 260, [323, 4], 22, 1, 0, 0, 7, 14, 59, 9, 8, 11, 2, 48, 6, 11, 11, 40, 13, 6, 233, 361, 58, 58, 5, 13, 8, 13, 13, 5, 5, 8, 322], [[0, 7], 4, 6, 36, 5, 5, 11, 58, [109, 2], 58, 11, 11, 29, 58, 251, 260, [323, 4], 251, 233, 114, 89, 112, 153, 289, 362, 363, [323, 15], 364, 234, 214, 224, 260, [323, 4], [0, 4], 260, [323, 4], 2, [0, 3], 21, 338, 8, 319, 5, 35, 48, 22, 11, 5, 11, 40, 40, [233, 2], 361, 58, 40, [5, 3], 29, 6, 6, 11, 14, 59], [[0, 6], 21, [5, 4], 36, 11, 58, 58, 11, 29, [58, 3], 48, 2, 260, [323, 4], 1, 279, 193, 105, 113, 162, 153, 145, 365, [323, 3], 366, 185, 153, 205, 145, [146, 2], 138, 367, [323, 3], 324, 234, 214, 221, 260, [323, 4], [0, 4], 260, [323, 4], 1, 0, 0, 1, 5, 8, 8, 5, 358, 6, 99, 6, 5, 319, 8, 5, [233, 2], 361, 58, 58, 29, 29, 11, 6, 233, 6, 11, 5, 20, 14], [[0, 4], 4, 11, 5, 8, 8, 5, 36, 5, 36, 11, 36, 29, 58, 58, 109, 48, 41, 41, 260, [323, 4], 233, 219, 368, 369, 137, [162, 2], 282, 370, [323, 3], 371, [153, 3], 145, 285, 146, 138, 329, [323, 4], 353, 213, 229, 354, [323, 4], [0, 4], 260, [323, 12], 372, 2, 48, 58, 13, 13, 319, 5, [233, 2], 58, 58, 29, 29, 11, 58, 22, 22, 11, 36, 5, 20, 14], [[0, 3], 2, 5, 63, 344, 5, 5, 36, 29, 63, 63, 29, 29, [58, 3], 233, 2, 48, 251, 260, [323, 4], 244, 290, 373, 124, 121, 162, 181, 185, [323, 4], 363, [282, 2], 145, 285, 146, 297, 271, 138, 370, [323, 3], 336, 230, 40, 351, [323, 4], [0, 4], 260, [323, 12], 258, 2, 233, 36, 8, 5, 5, 40, 233, 361, 58, 29, 29, 58, 11, 109, 22, 6, 36, 29, 8, 14, 8], [0, 0, 2, 29, 63, 344, 5, 5, 36, 36, [12, 3], 5, [58, 3], 6, [233, 2], 48, 251, 260, [323, 4], 187, 244, 72, 93, 207, [162, 2], 374, [323, 3], 370, [282, 2], [145, 3], [362, 2], 146, 271, 325, [323, 3], 324, 232, 58, 260, [323, 4], [0, 4], 260, [323, 12], 291, 1, 109, 5, 8, 13, 29, 58, 375, [58, 3], [22, 3], 2, 22, 11, 11, 36, 8, 8, 319], [0, 4, [5, 5], 29, 29, 12, 376, 12, 12, 11, 359, 36, 6, 109, 22, 233, 48, [251, 2], 233, 48, 1, 48, 293, 290, 106, 113, 153, 132, [181, 2], 163, 126, 153, 362, [282, 6], 145, 285, 146, 271, 377, 235, 284, 242, 58, 1, [0, 10], [1, 3], [0, 3], 22, 5, 5, 58, 5, 11, 2, 2, 58, 8, 8, 13, 29, 58, 58, 220, 35, 99, 4, 109, 6, 4, 6, 29, 29, 11, [5, 3]]]};

  // project-rome/@romejs/cli-diagnostics/DiagnosticsPrinter.ts
function ___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$readDiagnosticsFileLocal(
    path,
  ) {
    if (!___R$project$rome$$romejs$fs$index_ts$existsSync(path)) {
      return;
    }

    const src = ___R$project$rome$$romejs$fs$index_ts$readFileTextSync(path);
    const mtime = ___R$project$rome$$romejs$fs$index_ts$lstatSync(path).mtimeMs;
    return {content: src, mtime};
  }

  function ___R$$priv$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$equalPosition(
    a,
    b,
  ) {
    if (a === undefined || b === undefined) {
      return false;
    }

    if (a.line !== b.line || a.column !== b.column) {
      return false;
    }

    return true;
  }

  const ___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$DEFAULT_PRINTER_FLAGS = {
    grep: '',
    inverseGrep: false,
    focus: '',
    showAllDiagnostics: true,
    fieri: false,
    verboseDiagnostics: false,
    maxDiagnostics: 100,
  };

  class ___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$default extends Error {
    constructor(opts) {
      super(
        'Diagnostics printer. If you\'re seeing this then it wasn\'t caught and printed correctly.',
      );
      const {cwd, reporter, flags = ___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$DEFAULT_PRINTER_FLAGS} = opts;

      this.reporter = reporter;
      this.flags = flags;
      this.readFile =
        opts.readFile === undefined
          ? ___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$readDiagnosticsFileLocal : opts.readFile;
      this.cwd = cwd === undefined ? ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(process.cwd()) : cwd;
      this.processor =
        new ___R$project$rome$$romejs$diagnostics$DiagnosticsProcessor_ts$default(
          {
            filters: opts.filters,
            origins: opts.origins,
          },
        );

      this.displayedCount = 0;
      this.problemCount = 0;
      this.filteredCount = 0;
      this.truncatedCount = 0;

      this.missingFileSources = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet();
      this.fileSources = new ___R$project$rome$$romejs$path$collections_ts$UnknownFilePathMap();
      this.fileMtimes = new ___R$project$rome$$romejs$path$collections_ts$UnknownFilePathMap();
      this.beforeFooterPrint = [];
    }

    throwIfAny() {
      if (this.hasDiagnostics()) {
        throw this;
      }
    }

    hasDiagnostics() {
      return this.processor.hasDiagnostics();
    }

    getDisplayedProblemsCount() {
      return this.problemCount - this.filteredCount;
    }

    shouldTruncate() {
      if (!this.flags.showAllDiagnostics &&
        this.displayedCount >
        this.flags.maxDiagnostics) {
        return true;
      } else {
        return false;
      }
    }

    getDiagnostics() {
      return (
        this.processor.getCompleteSortedDiagnostics(
          this.reporter.markupOptions,
        )
      );
    }

    isFocused(diag) {
      const focusFlag = this.flags.focus;
      const focusEnabled = focusFlag !== undefined && focusFlag !== '';

      const {filename, start, end} = diag;

      // If focus is enabled, exclude locationless errors
      if (focusEnabled && (filename === undefined || start === undefined)) {
        return true;
      }

      // If focus is enabled, check if we should ignore this message
      if (filename !== undefined && start !== undefined && end !== undefined) {
        const niceFilename = ___R$project$rome$$romejs$string$markup$format_ts$humanizeMarkupFilename(
          [filename],
          this.reporter.markupOptions,
        );
        const focusId = ___R$project$rome$$romejs$diagnostics$derive_ts$getDiagnosticHeader(
          {
            filename,
            start,
          },
        );
        if (focusEnabled && focusId !== focusFlag && focusId !== niceFilename) {
          return true;
        }
      }

      return false;
    }

    shouldIgnore(diag) {
      const {focus, grep, inverseGrep} = this.flags;
      const focusEnabled = focus !== undefined && focus !== '';

      // If focus is enabled, exclude locationless errors
      if (focusEnabled && this.isFocused(diag) === false) {
        return true;
      }

      // An empty grep pattern means show everything
      if (grep === undefined || grep === '') {
        return false;
      }

      // Match against the supplied grep pattern
      let ignored = diag.message.toLowerCase().includes(grep) === false;
      if (inverseGrep) {
        ignored = !ignored;
      }
      return ignored;
    }

    addFileSource(info, stats) {
      this.fileMtimes.set(info.path, stats.mtime);

      if (info.type === 'reference') {
        this.fileSources.set(
          info.path,
          ___R$project$rome$$romejs$cli$diagnostics$utils_ts$toLines(
            {
              path: info.path,
              input: stats.content,
              sourceType: info.sourceType,
              language: info.language,
            },
          ),
        );
      }
    }

    getDependenciesFromDiagnostics(diagnostics) {
      const deps = [];

      for (const {
        advice,
        filename,
        dependencies,
        language,
        sourceType,
        mtime,
      } of diagnostics) {
        if (filename !== undefined) {
          deps.push(
            {
              type: 'reference',
              path: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(filename),
              mtime,
              language,
              sourceType,
            },
          );
        }

        for (const {filename, mtime} of dependencies) {
          deps.push(
            {
              type: 'change',
              path: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(filename),
              mtime,
            },
          );
        }

        for (const item of advice) {
          if (item.type === 'frame' && item.filename !== undefined &&
            item.sourceText === undefined) {
            deps.push(
              {
                type: 'reference',
                path: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(item.filename),
                language: item.language,
                sourceType: item.sourceType,
                mtime: item.mtime,
              },
            );
          }
        }
      }

      const depsMap = new ___R$project$rome$$romejs$path$collections_ts$UnknownFilePathMap();

      // Remove non-absolute filenames and normalize sourceType and language for conflicts
      for (const dep of deps) {
        const path = dep.path;
        if (!path.isAbsolute()) {
          continue;
        }

        const existing = depsMap.get(path);

        // reference dependency can override change since it has more metadata that needs conflict resolution
        if (existing === undefined || existing.type === 'change') {
          depsMap.set(dep.path, dep);
          continue;
        }

        if (dep.type === 'reference') {
          if (existing.sourceType !== dep.sourceType) {
            existing.sourceType = 'unknown';
          }

          if (existing.language !== dep.language) {
            existing.language = 'unknown';
          }
        }
      }

      return Array.from(depsMap.values());
    }

    fetchFileSources(diagnostics) {
      for (const dep of this.getDependenciesFromDiagnostics(diagnostics)) {
        const {path} = dep;
        if (!path.isAbsolute()) {
          continue;
        }

        const abs = path.assertAbsolute();
        const stats = this.readFile(abs);
        if (stats === undefined) {
          this.missingFileSources.add(abs);
        } else {
          this.addFileSource(dep, stats);
        }
      }
    }

    addDiagnostic(partialDiagnostic, origin) {
      this.addDiagnostics([partialDiagnostic], origin);
    }

    addDiagnostics(partials, origin) {
      if (partials.length === 0) {
        return;
      }

      this.processor.addDiagnostics(partials, origin);
    }

    print() {
      const filteredDiagnostics = this.filterDiagnostics();
      this.fetchFileSources(filteredDiagnostics);
      this.displayDiagnostics(filteredDiagnostics);
    }

    displayDiagnostics(diagnostics) {
      this.reporter.redirectOutToErr(true);
      for (const diag of diagnostics) {
        this.displayDiagnostic(diag);
      }
      this.reporter.redirectOutToErr(false);
    }

    displayDiagnostic(diag) {
      const {reporter} = this;
      const {start, end, filename} = diag;

      // Determine if we should skip showing the frame at the top of the diagnostic output

      // We check if there are any frame advice entries that match us exactly, this is

      // useful for stuff like reporting call stacks
      let skipFrame = false;
      if (start !== undefined && end !== undefined) {
        adviceLoop: for (const item of diag.advice) {
          if (item.type === 'frame' && item.filename === filename &&
            ___R$$priv$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$equalPosition(item.start, start) &&
            ___R$$priv$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$equalPosition(item.end, end)) {
            skipFrame = true;
            break;
          }

          if (item.type === 'stacktrace') {
            for (const frame of item.frames) {
              if (frame.filename === filename && ___R$$priv$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$equalPosition(frame, start)) {
                skipFrame = true;
                break adviceLoop;
              }
            }
          }
        }
      }

      // Check if any files this diagnostic depends on have changed
      let outdatedFiles = new ___R$project$rome$$romejs$path$collections_ts$UnknownFilePathSet();
      for (const {
        path,
        mtime: expectedMtime,
      } of this.getDependenciesFromDiagnostics([diag])) {
        const mtime = this.fileMtimes.get(path);
        if (mtime !== undefined && expectedMtime !== undefined &&
          mtime >
          expectedMtime) {
          outdatedFiles.add(path);
        }
      }

      const outdatedAdvice = [];
      const isOutdated = outdatedFiles.size > 0;
      if (isOutdated) {
        const outdatedFilesArr = Array.from(outdatedFiles, (path) => path.join());

        if (outdatedFilesArr.length === 1 && outdatedFilesArr[0] === filename) {
          outdatedAdvice.push(
            {
              type: 'log',
              category: 'warn',
              message: 'This file has been changed since the diagnostic was produced and may be out of date',
            },
          );
        } else {
          outdatedAdvice.push(
            {
              type: 'log',
              category: 'warn',
              message: 'This diagnostic may be out of date as it relies on the following files that have been changed since the diagnostic was generated',
            },
          );

          outdatedAdvice.push(
            {
              type: 'list',
              list: outdatedFilesArr.map(
                (
                  filename,
                ) =>
                  '<filelink target="' +
                  filename +
                  '" />',
              ),
            },
          );
        }
      }

      const derived = ___R$project$rome$$romejs$diagnostics$derive_ts$deriveRootAdviceFromDiagnostic(
        diag,
        {
          skipFrame,
          includeHeaderInAdvice: false,
          outdated: isOutdated,
        },
      );

      reporter.hr(derived.header);

      reporter.indent(
        () => {
          // Concat all the advice together
          const derivedAdvice = [
            ...derived.advice,
            ...outdatedAdvice,
          ].map(
            (
              item,
            ) =>
              ___R$project$rome$$romejs$diagnostics$normalize_ts$normalizeDiagnosticAdviceItem(diag, item, this.reporter.markupOptions),
          );
          const advice = derivedAdvice.concat(diag.advice);

          // Print advice
          for (const item of advice) {
            const noSpacer = ___R$project$rome$$romejs$cli$diagnostics$printAdvice_ts$default(
              item,
              {
                flags: this.flags,
                missingFileSources: this.missingFileSources,
                fileSources: this.fileSources,
                diagnostic: diag,
                reporter,
              },
            );
            if (!noSpacer) {
              reporter.spacer();
            }
          }

          // Print verbose information
          if (this.flags.verboseDiagnostics) {
            const {origins} = diag;

            if (origins.length > 0) {
              reporter.spacer();
              reporter.info('Why are you seeing this diagnostic?');
              reporter.forceSpacer();
              reporter.list(
                origins.map(
                  (origin) => {
                    let res = '<emphasis>' +
                    origin.category +
                    '</emphasis>';
                    if (origin.message !== undefined) {
                      res += ': ' +
                      origin.message;
                    }
                    return res;
                  },
                ),
                {ordered: true},
              );
            }
          }
        },
      );
    }

    filterDiagnostics() {
      const diagnostics = this.getDiagnostics();
      const filteredDiagnostics = [];

      for (const diag of diagnostics) {
        this.problemCount++;

        if (this.shouldIgnore(diag)) {
          this.filteredCount++;
        } else if (this.shouldTruncate()) {
          this.truncatedCount++;
        } else {
          this.displayedCount++;
          filteredDiagnostics.push(diag);
        }
      }

      return filteredDiagnostics;
    }

    onBeforeFooterPrint(fn) {
      this.beforeFooterPrint.push(fn);
    }

    footer() {
      const {reporter, problemCount} = this;

      const isError = problemCount > 0;

      if (isError) {
        reporter.hr();
      }

      for (const handler of this.beforeFooterPrint) {
        handler(reporter, isError);
      }

      if (isError) {
        this.footerError();
      } else {
        this.footerSuccess();
      }
    }

    showBanner(banner) {
      for (const stream of this.reporter.getStreams(false)) {
        for (const row of banner.rows) {
          for (const field of row) {
            let palleteIndex;
            let times = 1;
            if (Array.isArray(field)) {
              [palleteIndex, times] = field;
            } else {
              palleteIndex = field;
            }

            const pallete = banner.palettes[palleteIndex];
            stream.write(
              ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.bgRgb(
                ' ',
                {
                  r: pallete[0],
                  g: pallete[1],
                  b: pallete[2],
                },
              ).repeat(
                times,
              ),
            );
          }
          stream.write('\n');
        }
      }
    }

    footerSuccess() {
      const {reporter} = this;

      if (this.flags.fieri) {
        this.showBanner(___R$project$rome$$romejs$cli$diagnostics$banners$success_json$default);
      }

      reporter.success('No known problems!');
    }

    footerError() {
      const {reporter, filteredCount} = this;

      if (this.flags.fieri) {
        this.showBanner(___R$project$rome$$romejs$cli$diagnostics$banners$error_json$default);
      }

      const displayableProblems = this.getDisplayedProblemsCount();
      let str = 'Found <number emphasis>' +
      displayableProblems +
      '</number> problem';
      if (displayableProblems > 1 || displayableProblems == 0) {
        str += 's';
      }

      if (filteredCount > 0) {
        str += ___R$project$rome$$romejs$string$ansi$format_ts$formatAnsi.brightBlack(' (' +
        filteredCount +
        ' filtered)');
      }

      reporter.error(str);

      if (this.truncatedCount > 0) {
        const {maxDiagnostics} = this.flags;
        reporter.warn(
          'Only <number>' +
          maxDiagnostics +
          '</number> errors shown, add the <emphasis>--show-all-diagnostics</emphasis> flag to view the remaining <number>' +
          (displayableProblems -
          maxDiagnostics) +
          '</number> errors',
        );
      }
    }
  }

  // project-rome/@romejs/cli-diagnostics/index.ts
async function ___R$project$rome$$romejs$cli$diagnostics$index_ts$printDiagnostics(
    diagnostics,
    opts,
  ) {
    const printer = new ___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$default(opts);
    printer.addDiagnostics(diagnostics);
    await printer.print();
    return printer;
  }

  function ___R$project$rome$$romejs$cli$diagnostics$index_ts$printDiagnosticsSync(
    diagnostics,
    opts,
  ) {
    const printer = new ___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$default(opts);
    printer.addDiagnostics(diagnostics);
    printer.print();
    return printer;
  }

  function ___R$project$rome$$romejs$cli$diagnostics$index_ts$printDiagnosticsToString(
    diagnostics,
    opts = {},
    format = 'none',
  ) {
    let buff = '';

    const reporter = new ___R$project$rome$$romejs$cli$reporter$Reporter_ts$default(
      {
        streams: [
          {
            type: 'all',
            format,
            columns: 400,
            write(chunk) {
              buff += chunk;
            },
          },
        ],
      },
    );

    const printer = new ___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$default(
      Object.assign(
        {
        },
        opts,
        {
          reporter,
        },
      ),
    );
    printer.addDiagnostics(diagnostics);
    printer.print();
    return buff;
  }

  // project-rome/@romejs/diagnostics/errors.ts
const ___R$project$rome$$romejs$diagnostics$errors_ts = {
    get DiagnosticsError() {
      return (
        ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError
      );
    },

    createSingleDiagnosticError: ___R$project$rome$$romejs$diagnostics$errors_ts$createSingleDiagnosticError,
    getDiagnosticsFromError: ___R$project$rome$$romejs$diagnostics$errors_ts$getDiagnosticsFromError,
  };
  class ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError extends Error {
    constructor(message, diagnostics, suppressions = []) {
      if (diagnostics.length === 0) {
        throw new Error('No diagnostics');
      }

      message += '\n';
      message +=
        ___R$project$rome$$romejs$string$ansi$format_ts$stripAnsi(
          ___R$project$rome$$romejs$cli$diagnostics$index_ts$printDiagnosticsToString(
            diagnostics,
            {
              origins: [],
            },
          ),
        );
      message +=
        ___R$project$rome$$romejs$string$ansi$format_ts$stripAnsi(
          diagnostics.map((diag) => '- ' +
          diag.message).join(
            '\n',
          ),
        );

      super(___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(message));
      this.diagnostics = diagnostics;
      this.suppressions = suppressions;
      this.name = 'DiagnosticsError';
    }
  }

  function ___R$project$rome$$romejs$diagnostics$errors_ts$createSingleDiagnosticError(
    diag,
    suppressions,
  ) {
    return new ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError(diag.message, [diag], suppressions);
  }

  function ___R$project$rome$$romejs$diagnostics$errors_ts$getDiagnosticsFromError(
    err,
  ) {
    if (err instanceof ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError) {
      const processor = new ___R$project$rome$$romejs$diagnostics$DiagnosticsProcessor_ts$default({});
      processor.addSuppressions(err.suppressions);
      processor.addDiagnostics(err.diagnostics);
      return processor.getPartialDiagnostics();
    }

    return undefined;
  }

  // project-rome/@romejs/diagnostics/types.ts
const ___R$project$rome$$romejs$diagnostics$types_ts = {
  };

  // project-rome/@romejs/diagnostics/derive.ts
const ___R$project$rome$$romejs$diagnostics$derive_ts = {
    mergeDiagnostics: ___R$project$rome$$romejs$diagnostics$derive_ts$mergeDiagnostics,
    getDiagnosticHeader: ___R$project$rome$$romejs$diagnostics$derive_ts$getDiagnosticHeader,
    deriveRootAdviceFromDiagnostic: ___R$project$rome$$romejs$diagnostics$derive_ts$deriveRootAdviceFromDiagnostic,
    deriveDiagnosticFromError: ___R$project$rome$$romejs$diagnostics$derive_ts$deriveDiagnosticFromError,
    getErrorStackAdvice: ___R$project$rome$$romejs$diagnostics$derive_ts$getErrorStackAdvice,
    addOriginsToDiagnostics: ___R$project$rome$$romejs$diagnostics$derive_ts$addOriginsToDiagnostics,
    addOriginsToDiagnostic: ___R$project$rome$$romejs$diagnostics$derive_ts$addOriginsToDiagnostic,
  };
  function ___R$$priv$project$rome$$romejs$diagnostics$derive_ts$normalizeArray(val) {
    if (Array.isArray(val)) {
      return val;
    } else {
      return [];
    }
  }

  function ___R$project$rome$$romejs$diagnostics$derive_ts$mergeDiagnostics(
    rootDiag,
  ...diags) {
    let mergedAdvice = [
      ...___R$$priv$project$rome$$romejs$diagnostics$derive_ts$normalizeArray(rootDiag.advice),
    ];

    for (const diag of diags) {
      mergedAdvice =
        [
          ...mergedAdvice,
          ...___R$project$rome$$romejs$diagnostics$derive_ts$deriveRootAdviceFromDiagnostic(diag).advice,
          ...___R$$priv$project$rome$$romejs$diagnostics$derive_ts$normalizeArray(diag.advice),
        ];
    }

    return (
      Object.assign(
        {
        },
        rootDiag,
        {
          advice: mergedAdvice,
        },
      )
    );
  }

  function ___R$project$rome$$romejs$diagnostics$derive_ts$getDiagnosticHeader(
    opts,
  ) {
    const {start, filename} = opts;

    if (filename === undefined) {
      return 'unknown';
    }

    if (start === undefined) {
      return '<filelink target="' +
      filename +
      '" />';
    }

    return (
      '<filelink target="' +
      filename +
      '" line="' +
      start.line +
      '" column="' +
      start.column +
      '" />'
    );
  }

  function ___R$project$rome$$romejs$diagnostics$derive_ts$deriveRootAdviceFromDiagnostic(
    diag,
    opts = {
      skipFrame: false,
      includeHeaderInAdvice: true,
      outdated: false,
    },
  ) {
    const advice = [];

    let header = ___R$project$rome$$romejs$diagnostics$derive_ts$getDiagnosticHeader(
      {
        start: diag.start,
        filename: diag.filename,
      },
    );

    if (diag.label !== undefined) {
      header += ' <emphasis>' +
      diag.label +
      '</emphasis>';

      if (diag.category !== undefined) {
        header += ' <dim>' +
        diag.category +
        '</dim>';
      }
    } else {
      if (diag.category !== undefined) {
        header += ' <emphasis>' +
        diag.category +
        '</emphasis>';
      }
    }

    if (diag.fixable === true) {
      header += ' <inverse>FIXABLE</inverse>';
    }

    if (opts.outdated === true) {
      header += ' <inverse>OUTDATED</inverse>';
    }

    if (opts.includeHeaderInAdvice === true) {
      advice.push(
        {
          type: 'log',
          category: 'none',
          message: header,
        },
      );
    }

    advice.push(
      {
        type: 'log',
        category: 'error',
        message: diag.message,
      },
    );

    if (opts.skipFrame === false) {
      if (diag.start !== undefined && diag.end !== undefined) {
        advice.push(
          {
            type: 'frame',
            sourceText: diag.sourceText,
            filename: diag.filename,
            mtime: diag.mtime,
            marker: diag.marker,
            start: diag.start,
            end: diag.end,
          },
        );
      } else if (diag.marker !== undefined) {
        // If we have no start/end, but we do have a marker then output is a log error
        advice.push(
          {
            type: 'log',
            category: 'error',
            message: diag.marker,
          },
        );
      }
    }

    return {header, advice};
  }

  function ___R$project$rome$$romejs$diagnostics$derive_ts$deriveDiagnosticFromError(
    opts,
  ) {
    const {error, filename} = opts;

    let targetFilename = filename;
    let targetCode = undefined;
    let targetLoc = undefined;

    const structErr = ___R$project$rome$$romejs$v8$errors_ts$getErrorStructure(error);
    let {frames, message, advice} = structErr;

    const {cleanFrames} = opts;
    if (cleanFrames !== undefined) {
      frames = cleanFrames(frames);
    }

    // Point the target to the closest frame with a filename
    for (const frame of frames) {
      if (frame.filename === undefined) {
        continue;
      }

      targetFilename = frame.filename;
      targetLoc = ___R$project$rome$$romejs$v8$errors_ts$getSourceLocationFromErrorFrame(frame);
      break;
    }

    advice = [...___R$project$rome$$romejs$diagnostics$derive_ts$getErrorStackAdvice(error, undefined, frames), ...advice];

    return (
      {
        filename: targetFilename,
        start: targetLoc === undefined ? undefined : targetLoc.start,
        end: targetLoc === undefined ? undefined : targetLoc.end,
        sourceText: targetCode,
        category: opts.category,
        label: opts.label,
        message,
        advice,
      }
    );
  }

  function ___R$project$rome$$romejs$diagnostics$derive_ts$getErrorStackAdvice(
    errorLike,
    title,
    _frames,
  ) {
    const error = ___R$project$rome$$romejs$v8$errors_ts$getErrorStructure(errorLike);
    const {stack} = error;

    const advice = [];
    const frames = _frames === undefined ? error.frames : _frames;

    if (frames.length === 0 && stack !== undefined) {
      // Just in case we didn't get the frames for some reason

      if (title !== undefined) {
        advice.push(
          {
            type: 'log',
            category: 'info',
            message: title,
          },
        );
      }

      // Remove the `message` from the `stack`
      let cleanStack = stack;
      let removeMessage = error.name +
      ': ' +
      error.message;
      if (cleanStack.startsWith(removeMessage)) {
        cleanStack = cleanStack.slice(removeMessage.length);
      }

      advice.push(
        {
          type: 'log',
          category: 'error',
          message: ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(cleanStack),
        },
      );
    } else {
      const adviceFrames = frames.map(
        (frame) => {
          const {
            typeName,
            functionName,
            methodName,
            filename,
            lineNumber,
            columnNumber,
            isEval,
            isNative,
            isConstructor,
            isAsync,
          } = frame;

          const prefixes = [];
          if (isAsync) {
            prefixes.push('await');
          }
          if (isEval) {
            prefixes.push('eval');
          }
          if (isConstructor) {
            prefixes.push('new');
          }
          const prefix = prefixes.length === 0 ? undefined : prefixes.join(' ');

          let object = typeName;
          let property = '<anonymous>';
          if (functionName !== undefined) {
            property = functionName;
          }
          if (methodName !== undefined) {
            property = methodName;
          }

          let suffix;
          if (isNative) {
            suffix = 'native';
          }

          return (
            {
              suffix,
              prefix,
              object,
              property,
              filename,
              line: lineNumber,
              column: columnNumber,
            }
          );
        },
      );

      advice.push(
        {
          type: 'stacktrace',
          title,
          frames: adviceFrames,
        },
      );
    }

    return advice;
  }

  function ___R$project$rome$$romejs$diagnostics$derive_ts$addOriginsToDiagnostics(
    origins,
    diagnostics,
  ) {
    return (
      diagnostics.map(
        (diag) => {
          return ___R$project$rome$$romejs$diagnostics$derive_ts$addOriginsToDiagnostic(origins, diag);
        },
      )
    );
  }

  function ___R$project$rome$$romejs$diagnostics$derive_ts$addOriginsToDiagnostic(
    origins,
    diag,
  ) {
    const newOrigins = diag.origins === undefined
      ? origins : [
        ...origins,
        ...diag.origins,
      ];
    return (
      Object.assign(
        {
        },
        diag,
        {
          origins: newOrigins,
        },
      )
    );
  }

  // project-rome/@romejs/diagnostics/wrap.ts
const ___R$project$rome$$romejs$diagnostics$wrap_ts = {
    catchDiagnostics: ___R$project$rome$$romejs$diagnostics$wrap_ts$catchDiagnostics,
  };

  async function ___R$project$rome$$romejs$diagnostics$wrap_ts$catchDiagnostics(
    origin,
    promise,
  ) {
    try {
      const value = await promise();

      return {value, diagnostics: undefined};
    } catch (err) {
      const diagnostics = ___R$project$rome$$romejs$diagnostics$errors_ts$getDiagnosticsFromError(err);

      if (diagnostics) {
        return (
          {
            value: undefined,
            diagnostics: ___R$project$rome$$romejs$diagnostics$derive_ts$addOriginsToDiagnostics([origin], diagnostics),
          }
        );
      } else {
        throw err;
      }
    }
  }

  // project-rome/@romejs/diagnostics/helpers.ts
const ___R$project$rome$$romejs$diagnostics$helpers_ts = {
    buildSuggestionAdvice: ___R$project$rome$$romejs$diagnostics$helpers_ts$buildSuggestionAdvice,
    truncateSourceText: ___R$project$rome$$romejs$diagnostics$helpers_ts$truncateSourceText,
  };

  function ___R$project$rome$$romejs$diagnostics$helpers_ts$buildSuggestionAdvice(
    value,
    items,
    {minRating = 0.5, ignoreCase, formatItem} = {},
  ) {
    const advice = [];

    const ratings = ___R$project$rome$$romejs$string$utils$orderBySimilarity_ts$orderBySimilarity(
      value,
      items,
      {
        minRating,
        formatItem,
        ignoreCase,
      },
    );

    const strings = ratings.map(
      (item) => {
        const {target} = item;
        if (formatItem === undefined) {
          return target;
        } else {
          return formatItem(target);
        }
      },
    );

    const topRatingFormatted = strings.shift();
    if (topRatingFormatted === undefined) {
      return advice;
    }

    // Raw rating that hasn't been formatted
    const topRatingRaw = ratings[0].target;

    if (topRatingRaw === value) {
      // TODO produce a better example
    }

    // If there's only 2 suggestions then just say "Did you mean A or B?" rather than printing the list
    if (strings.length === 1) {
      advice.push(
        {
          type: 'log',
          category: 'info',
          message: 'Did you mean <emphasis>' +
          topRatingFormatted +
          '</emphasis> or <emphasis>' +
          strings[0] +
          '</emphasis>?',
        },
      );
    } else {
      advice.push(
        {
          type: 'log',
          category: 'info',
          message: 'Did you mean <emphasis>' +
          topRatingFormatted +
          '</emphasis>?',
        },
      );

      advice.push(
        {
          type: 'diff',
          diff: ___R$project$rome$$romejs$string$diff$index_ts$default(value, topRatingRaw),
        },
      );

      if (strings.length > 0) {
        advice.push(
          {
            type: 'log',
            category: 'info',
            message: 'Or one of these?',
          },
        );

        advice.push(
          {
            type: 'list',
            list: strings,
            truncate: true,
          },
        );
      }
    }

    // TODO check if ANY of the suggestions match
    if (topRatingRaw !== value &&
      topRatingRaw.toLowerCase() ===
      value.toLowerCase()) {
      advice.push(
        {
          type: 'log',
          category: 'warn',
          message: 'This operation is case sensitive',
        },
      );
    }

    return advice;
  }

  function ___R$project$rome$$romejs$diagnostics$helpers_ts$truncateSourceText(
    code,
    start,
    end,
  ) {
    const lines = code.split(___R$project$rome$$romejs$js$parser$utils$whitespace_ts$NEWLINE);

    // Pad the starting and ending lines by 10
    const fromLine = Math.max(___R$project$rome$$romejs$ob1$index_ts$get1(start.line) - 10, 0);
    const toLine = Math.max(___R$project$rome$$romejs$ob1$index_ts$get1(end.line) + 10, lines.length);

    const capturedLines = lines.slice(fromLine, toLine);
    return '\n'.repeat(fromLine) + capturedLines.join('\n');
  }

  // project-rome/@romejs/diagnostics/DiagnosticsProcessor.ts
const ___R$$priv$project$rome$$romejs$diagnostics$DiagnosticsProcessor_ts$DEFAULT_UNIQUE = [
    ['category', 'filename', 'message', 'start.line', 'start.column'],
  ];

  class ___R$project$rome$$romejs$diagnostics$DiagnosticsProcessor_ts$default {
    constructor(options) {
      this.diagnostics = [];
      this.filters = [];
      this.allowedUnusedSuppressionPrefixes = new Set();
      this.usedSuppressions = new Set();
      this.suppressions = new Set();
      this.options = options;
      this.includedKeys = new Set();
      this.unique = options.unique === undefined ? ___R$$priv$project$rome$$romejs$diagnostics$DiagnosticsProcessor_ts$DEFAULT_UNIQUE : options.unique;
      this.throwAfter = undefined;
    }

    static createImmediateThrower(origins) {
      const diagnostics = new ___R$project$rome$$romejs$diagnostics$DiagnosticsProcessor_ts$default(
        {
          origins,
          onDiagnostics() {
            diagnostics.maybeThrowDiagnosticsError();
          },
        },
      );
      return diagnostics;
    }

    setThrowAfter(num) {
      this.throwAfter = num;
    }

    maybeThrowDiagnosticsError() {
      if (this.hasDiagnostics()) {
        throw (
          new ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError(
            'Thrown by DiagnosticsProcessor',
            this.getPartialDiagnostics(),
          )
        );
      }
    }

    hasDiagnostics() {
      return this.diagnostics.length > 0;
    }

    addAllowedUnusedSuppressionPrefix(prefix) {
      this.allowedUnusedSuppressionPrefixes.add(prefix);
    }

    addSuppressions(suppressions) {
      for (const suppression of suppressions) {
        this.suppressions.add(suppression);
      }
    }

    addFilters(filters) {
      this.filters = this.filters.concat(filters);
    }

    addFilter(filter) {
      this.filters.push(filter);
    }

    doesMatchFilter(diag) {
      for (const suppression of this.suppressions) {
        const targetLine = ___R$project$rome$$romejs$ob1$index_ts$add(suppression.loc.end.line, 1);
        if (diag.filename !== undefined && diag.start !== undefined &&
          diag.filename === suppression.loc.filename &&
          diag.start.line ===
          targetLine) {
          this.usedSuppressions.add(suppression);
          return true;
        }
      }

      for (const filter of this.filters) {
        if (filter.message !== undefined && filter.message !== diag.message) {
          continue;
        }

        if (filter.filename !== undefined && filter.filename !== diag.filename) {
          continue;
        }

        if (filter.category !== undefined && filter.category !== diag.category) {
          continue;
        }

        if (filter.start !== undefined && diag.start !== undefined) {
          if (filter.start.line !== diag.start.line ||
          filter.start.column !==
          diag.start.column) {
            continue;
          }
        }

        if (filter.line !== undefined && diag.start !== undefined &&
          diag.start.line !== filter.line) {
          continue;
        }

        if (filter.test !== undefined && !filter.test(diag)) {
          continue;
        }

        return true;
      }

      return false;
    }

    buildDedupeKeys(diag) {
      // We don't do anything with `end` in this method, it's fairly meaningless for deduping errors
      let {start} = diag;

      const keys = [];

      for (const rule of this.unique) {
        const parts = [];

        if (rule.includes('category')) {
          parts.push('category:' +
          diag.category);
        }

        if (rule.includes('filename')) {
          parts.push('filename:' +
          String(diag.filename));
        }

        if (rule.includes('message')) {
          parts.push('message:' +
          diag.message);
        }

        if (start !== undefined) {
          if (rule.includes('start.line')) {
            parts.push('start.line:' +
            start.line);
          }

          if (rule.includes('start.column')) {
            parts.push('start.column:' +
            start.column);
          }
        }

        const key = parts.join(',');
        keys.push(key);
      }

      return keys;
    }

    addDiagnostic(diag, origin) {
      return this.addDiagnostics([diag], origin).length > 0;
    }

    addDiagnostics(diags, origin) {
      if (diags.length === 0) {
        return diags;
      }

      const {max} = this.options;
      const added = [];

      // Add origins to diagnostics
      const origins = this.options.origins === undefined
        ? [] : [...this.options.origins];
      if (origin !== undefined) {
        origins.push(origin);
      }
      diags = ___R$project$rome$$romejs$diagnostics$derive_ts$addOriginsToDiagnostics(origins, diags);

      // Filter diagnostics
      diagLoop: for (const diag of diags) {
        if (max !== undefined && this.diagnostics.length > max) {
          break;
        }

        if (this.doesMatchFilter(diag)) {
          continue;
        }

        const keys = this.buildDedupeKeys(diag);

        for (const key of keys) {
          if (this.includedKeys.has(key)) {
            continue diagLoop;
          }
        }

        this.diagnostics.push(diag);
        added.push(diag);

        for (const key of keys) {
          this.includedKeys.add(key);
        }
      }

      const {onDiagnostics} = this.options;
      if (onDiagnostics !== undefined && added.length > 0) {
        onDiagnostics(added);
      }

      const {throwAfter} = this;
      if (throwAfter !== undefined && this.diagnostics.length >= throwAfter) {
        this.maybeThrowDiagnosticsError();
      }

      return added;
    }

    getPartialDiagnostics() {
      const diagnostics = [...this.diagnostics];

      // Add errors for remaining suppressions
      for (const suppression of this.suppressions) {
        if (this.usedSuppressions.has(suppression)) {
          continue;
        }

        const [categoryPrefix] = suppression.category.split('/');
        if (this.allowedUnusedSuppressionPrefixes.has(categoryPrefix)) {
          continue;
        }

        diagnostics.push(
          Object.assign(
            {
            },
            suppression.loc,
            {
              message: 'Did not hide any error',
              category: 'suppressions/unused',
            },
          ),
        );
      }

      return diagnostics;
    }

    getCompleteDiagnostics(markupOptions = {}) {
      return ___R$project$rome$$romejs$diagnostics$normalize_ts$normalizeDiagnostics(this.getPartialDiagnostics(), markupOptions);
    }

    getCompleteSortedDiagnostics(markupOptions = {}) {
      // Sort files by filename to ensure they're always in the same order

      // TODO also sort by line/column
      return (
        this.getCompleteDiagnostics(markupOptions).sort(
          (a, b) => {
            if (a.filename === undefined || b.filename === undefined) {
              return 0;
            } else {
              return ___R$project$rome$$romejs$string$utils$naturalCompare_ts$naturalCompare(a.filename, b.filename);
            }
          },
        )
      );
    }

    clear() {
      this.includedKeys = new Set();
      this.diagnostics = [];
    }
  }

  // project-rome/@romejs/diagnostics/constants.ts
const ___R$project$rome$$romejs$diagnostics$constants_ts = {
    get INTERNAL_ERROR_LOG_ADVICE() {
      return (
        ___R$project$rome$$romejs$diagnostics$constants_ts$INTERNAL_ERROR_LOG_ADVICE
      );
    },
  };
  const ___R$project$rome$$romejs$diagnostics$constants_ts$INTERNAL_ERROR_LOG_ADVICE = {
    type: 'log',
    category: 'warn',
    message: 'This diagnostic was derived from an internal Rome error. The problem likely isn\'t with your code. Please report this if necessary',
  };

  // project-rome/@romejs/diagnostics/categories.ts
const ___R$project$rome$$romejs$diagnostics$categories_ts = {
  };

  // project-rome/@romejs/diagnostics/index.ts


  // project-rome/@romejs/core/package.json
const ___R$project$rome$$romejs$core$package_json$default = {'name': '@romejs/core', 'version': '0.0.52', 'type': 'module', 'private': true, 'main': 'index.ts'};

  // project-rome/@romejs/core/common/constants.ts
const ___R$project$rome$$romejs$core$common$constants_ts = {
    get CHILD_ARGS() {
      return (
        ___R$project$rome$$romejs$core$common$constants_ts$CHILD_ARGS
      );
    },

    get BIN() {
      return (
        ___R$project$rome$$romejs$core$common$constants_ts$BIN
      );
    },

    get MAP() {
      return (
        ___R$project$rome$$romejs$core$common$constants_ts$MAP
      );
    },

    get MAX_MASTER_BYTES_BEFORE_WORKERS() {
      return (
        ___R$project$rome$$romejs$core$common$constants_ts$MAX_MASTER_BYTES_BEFORE_WORKERS
      );
    },

    get MAX_WORKER_BYTES_BEFORE_ADD() {
      return (
        ___R$project$rome$$romejs$core$common$constants_ts$MAX_WORKER_BYTES_BEFORE_ADD
      );
    },

    get MAX_WORKER_COUNT() {
      return (
        ___R$project$rome$$romejs$core$common$constants_ts$MAX_WORKER_COUNT
      );
    },

    get VERSION() {
      return (
        ___R$project$rome$$romejs$core$common$constants_ts$VERSION
      );
    },

    get SOCKET_PATH() {
      return (
        ___R$project$rome$$romejs$core$common$constants_ts$SOCKET_PATH
      );
    },

    get CLI_SOCKET_PATH() {
      return (
        ___R$project$rome$$romejs$core$common$constants_ts$CLI_SOCKET_PATH
      );
    },

    get MOCKS_FOLDER_NAME() {
      return (
        ___R$project$rome$$romejs$core$common$constants_ts$MOCKS_FOLDER_NAME
      );
    },
  };
  const ___R$$priv$project$rome$$romejs$core$common$constants_ts$os = require(
    'os',
  );
  const ___R$project$rome$$romejs$core$common$constants_ts$CHILD_ARGS = ['--max-old-space-size=8192'];

  const ___R$project$rome$$romejs$core$common$constants_ts$BIN = ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(process.mainModule.filename);
  const ___R$project$rome$$romejs$core$common$constants_ts$MAP = ___R$project$rome$$romejs$core$common$constants_ts$BIN.addExtension('.map');

  const ___R$$priv$project$rome$$romejs$core$common$constants_ts$MEGABYTE = 10000;

  const ___R$project$rome$$romejs$core$common$constants_ts$MAX_MASTER_BYTES_BEFORE_WORKERS = 0.5 * ___R$$priv$project$rome$$romejs$core$common$constants_ts$MEGABYTE;

  const ___R$project$rome$$romejs$core$common$constants_ts$MAX_WORKER_BYTES_BEFORE_ADD = 1 * ___R$$priv$project$rome$$romejs$core$common$constants_ts$MEGABYTE;

  const ___R$$priv$project$rome$$romejs$core$common$constants_ts$CPU_COUNT = ___R$$priv$project$rome$$romejs$core$common$constants_ts$os.cpus().length;
  const ___R$project$rome$$romejs$core$common$constants_ts$MAX_WORKER_COUNT = Math.min(___R$$priv$project$rome$$romejs$core$common$constants_ts$CPU_COUNT, 4);

  const ___R$project$rome$$romejs$core$common$constants_ts$VERSION = String(___R$project$rome$$romejs$core$package_json$default.version);

  const ___R$project$rome$$romejs$core$common$constants_ts$SOCKET_PATH = ___R$project$rome$$romejs$path$index_ts$TEMP_PATH.append('rome-' +
  ___R$project$rome$$romejs$core$common$constants_ts$VERSION +
  '.sock');

  const ___R$project$rome$$romejs$core$common$constants_ts$CLI_SOCKET_PATH = ___R$project$rome$$romejs$path$index_ts$TEMP_PATH.append('rome-wait-' +
  ___R$project$rome$$romejs$core$common$constants_ts$VERSION +
  '.sock');

  const ___R$project$rome$$romejs$core$common$constants_ts$MOCKS_FOLDER_NAME = '__rmocks__';

  // project-rome/@romejs/core/common/types/client.ts
const ___R$project$rome$$romejs$core$common$types$client_ts = {
    get DEFAULT_CLIENT_FLAGS() {
      return (
        ___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_FLAGS
      );
    },

    get DEFAULT_CLIENT_REQUEST_FLAGS() {
      return (
        ___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS
      );
    },
  };
  const ___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_FLAGS = {
    clientName: 'unknown',
    cwd: ___R$project$rome$$romejs$path$index_ts$CWD_PATH,
    silent: false,
    verbose: false,
  };

  const ___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS = Object.assign(
    {
      collectMarkers: false,

      benchmark: false,
      benchmarkIterations: 10,

      watch: false,
      resolverPlatform: undefined,
      resolverScale: undefined,
      resolverMocks: false,
    },
    ___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$DEFAULT_PRINTER_FLAGS,
  );

  // project-rome/@romejs/core/commands.ts
function ___R$project$rome$$romejs$core$commands_ts$createMasterCommand(cmd) {
    return cmd;
  }

  const ___R$project$rome$$romejs$core$commands_ts$commandCategories = {
    PROCESS_MANAGEMENT: 'Process Management',
    CODE_QUALITY: 'Code Quality',
    SOURCE_CODE: 'Source Code',
    PROJECT_MANAGEMENT: 'Project Management',
    SOURCE_CONTROL: 'Source Control',
    INTERNAL: 'Internal',
  };

  // project-rome/@romejs/core/common/utils/executeMain.ts
const ___R$$priv$project$rome$$romejs$core$common$utils$executeMain_ts$internalModule = require(
    'module',
  );
  const ___R$$priv$project$rome$$romejs$core$common$utils$executeMain_ts$vm = require(
    'vm',
  );

  async function ___R$project$rome$$romejs$core$common$utils$executeMain_ts$default(
    opts,
  ) {
    const {path, code, sourceMap, globals} = opts;

    const filename = path.join();

    // Create global context
    const sandbox = Object.assign(
      {
      },
      globals,
      {
        process: {
          argv: [process.argv[0], filename],
          __proto__: process,
        },

        Buffer,
        clearImmediate,
        clearInterval,
        clearTimeout,
        setImmediate,
        setInterval,
        setTimeout,
        require: ___R$$priv$project$rome$$romejs$core$common$utils$executeMain_ts$internalModule.createRequire
          ? ___R$$priv$project$rome$$romejs$core$common$utils$executeMain_ts$internalModule.createRequire(
            filename,
          ) : ___R$$priv$project$rome$$romejs$core$common$utils$executeMain_ts$internalModule.createRequireFromPath(filename),
        console,
        __dirname: path.getParent().join(),
        __filename: filename,
      },
    );
    sandbox.global = sandbox;
    const context = ___R$$priv$project$rome$$romejs$core$common$utils$executeMain_ts$vm.createContext(sandbox);

    // Here we do some gymnastics to catch a syntax error to correctly identify it as being our fault
    let script;
    try {
      script =
        new ___R$$priv$project$rome$$romejs$core$common$utils$executeMain_ts$vm.Script(
          code,
          {
            filename,
            displayErrors: true,
          },
        );
    } catch (err) {
      if (err instanceof SyntaxError && err.stack !== undefined) {
        const lineMatch = err.stack.match(/^(.*?):(\d+)/);
        if (lineMatch == null) {
          throw err;
        }

        const line = Number(lineMatch[2]);

        const pos = {
          index: ___R$project$rome$$romejs$ob1$index_ts$number0Neg1,
          column: ___R$project$rome$$romejs$ob1$index_ts$number0,
          line: ___R$project$rome$$romejs$ob1$index_ts$coerce1(line),
        };

        const syntaxError = {
          message: err.message,
          category: 'v8/syntaxError',
          start: pos,
          end: pos,
          filename,
          sourceText: ___R$project$rome$$romejs$diagnostics$helpers_ts$truncateSourceText(code, pos, pos),
          advice: [___R$project$rome$$romejs$diagnostics$constants_ts$INTERNAL_ERROR_LOG_ADVICE],
        };
        return {syntaxError};
      }

      throw err;
    }

    // Execute the script if there was no syntax error
    ___R$project$rome$$romejs$v8$index_ts$sourceMapManager.addSourceMap(filename, sourceMap);
    await script.runInContext(context);
    return {syntaxError: undefined};
  }

  // project-rome/@romejs/core/client/commands.ts
const ___R$project$rome$$romejs$core$client$commands_ts$localCommands = new Map();

  ___R$project$rome$$romejs$core$client$commands_ts$localCommands.set(
    'init',
    {
      category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.PROJECT_MANAGEMENT,
      description: 'create a project config',

      defineFlags(consumer) {
        return (
          {
            defaults: consumer.get('defaults').asBoolean(false),
          }
        );
      },

      async callback(req, flags) {
        const {reporter} = req.client;

        const config = {};

        const configPath = req.client.flags.cwd.append('rome.json');
        if (await ___R$project$rome$$romejs$fs$index_ts$exists(configPath)) {
          reporter.error(
            '<filelink target="' +
            configPath.join() +
            '" emphasis>rome.json</filelink> file already exists',
          );
          reporter.info(
            'Use <command>rome config</command> to update an existing config',
          );
          return false;
        }

        reporter.heading('Welcome to Rome!');

        if (flags.defaults === false) {
          const useDefaults = await reporter.radioConfirm(
            'Use recommended settings?',
          );
          if (useDefaults) {
            flags = {defaults: true};
          }
        }

        const name = await reporter.question('Project name', {yes: flags.defaults});
        if (name !== '') {
          config.name = name;
        }

        config.version = '^' +
        ___R$project$rome$$romejs$core$common$constants_ts$VERSION;

        const enabledComponents = await reporter.select(
          'Features enabled',
          {
            yes: flags.defaults,
            options: {
              lint: {
                label: 'Lint',
              },
              format: {
                label: 'Format',
              },
              tests: {
                label: 'Testing',
              },
            },
            defaults: ['lint'],
          },
        );
        if (enabledComponents.has('lint')) {
          config.lint = {enabled: true};
        }
        if (enabledComponents.has('format')) {
          config.format = {enabled: true};
        }
        if (enabledComponents.has('tests')) {
          config.tests = {enabled: true};
        }

        await ___R$project$rome$$romejs$fs$index_ts$writeFile(configPath, JSON.stringify(config, null, '  ') +
        '\n');

        reporter.success(
          'Created config <filelink emphasis target="' +
          configPath.join() +
          '" />',
        );

        return true;
      },
    },
  );

  ___R$project$rome$$romejs$core$client$commands_ts$localCommands.set(
    'start',
    {
      category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.PROCESS_MANAGEMENT,
      description: 'start daemon (if none running)',
      async callback(req) {
        const existingServer = await req.client.tryConnectToExistingDaemon();
        if (existingServer) {
          req.client.reporter.success('Already running server.');
          return true;
        }

        const bridge = await req.client.startDaemon();
        return bridge !== undefined;
      },
    },
  );

  ___R$project$rome$$romejs$core$client$commands_ts$localCommands.set(
    'develop',
    {
      category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.PROCESS_MANAGEMENT,
      description: 'TODO',
      async callback(req) {
        const existingServer = await req.client.tryConnectToExistingDaemon();
        const hasExistingServer = existingServer !== undefined;

        if (!hasExistingServer) {
          await req.client.forceStartDaemon();
        }

        await req.client.query(
          Object.assign(
            {
            },
            req.query,
            {
              terminateWhenIdle: true,
            },
          ),
          'master',
        );

        return true;
      },
    },
  );

  ___R$project$rome$$romejs$core$client$commands_ts$localCommands.set(
    'stop',
    {
      category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.PROCESS_MANAGEMENT,
      description: 'stop a running daemon if one exists',
      async callback(req) {
        // We might want to use `terminateWhenIdle` here combined with a timeout instead of forcing it to die straight away
        const {reporter} = req.client;
        const bridge = await req.client.tryConnectToExistingDaemon();
        if (bridge) {
          const stop = await req.client.query(
            {
              command: 'stop',
            },
            'master',
          );
          if (stop.type === 'ERROR' && stop.fatal) {
            reporter.success('Stopped server.');
          } else {
            reporter.error('Failed to stop server.');
            return false;
          }
        } else {
          reporter.warn('No running server to stop.');
        }
        return true;
      },
    },
  );

  ___R$project$rome$$romejs$core$client$commands_ts$localCommands.set(
    'run',
    {
      category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.PROJECT_MANAGEMENT,
      description: 'TODO',
      async callback(req) {
        const bridge = await req.client.findOrStartMaster();
        if (bridge === undefined) {
          return false;
        }

        process.on(
          'unhandledRejection',
          (error) => {
            error;
            //console.log('unhandledRejection', error.stack);
          },
        );

        const res = await req.client.query(
          {
            command: 'run',
            args: req.query.args,
          },
          'master',
        );

        if (res.type !== 'SUCCESS') {
          return false;
        }

        const data = ___R$project$rome$$romejs$consume$index_ts$consumeUnknown(res.data, 'parse/json');

        if (data.exists()) {
          const type = data.get('type').asString();

          switch (type) {
            case 'executeCode':
              process.execArgv = [...process.execArgv, process.argv[1], 'run'];
              process.argv =
                [
                  process.argv[0],
                  String(data.filename),
                  ...process.argv.slice(4),
                ];
              const {syntaxError} = await ___R$project$rome$$romejs$core$common$utils$executeMain_ts$default(
                {
                  path: ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(data.get('filename').asString()),
                  code: data.get('code').asString(),
                  sourceMap: data.get('map').asAny(),
                },
              );
              if (syntaxError !== undefined) {
                throw ___R$project$rome$$romejs$diagnostics$errors_ts$createSingleDiagnosticError(syntaxError);
              }
              await new Promise(() => {});
              break;
          }
        }

        return true;
      },
    },
  );

  ___R$project$rome$$romejs$core$client$commands_ts$localCommands.set(
    'restart',
    {
      category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.PROCESS_MANAGEMENT,
      description: 'restart daemon',
      async callback(req) {
        const stopped = await req.client.query(
          {
            command: 'stop',
          },
        );

        if (stopped.type === 'SUCCESS' && stopped.data === true) {
          const started = await req.client.query(
            {
              command: 'start',
            },
          );
          return started.type === 'SUCCESS' && started.data === true;
        } else {
          return false;
        }
      },
    },
  );

  ___R$project$rome$$romejs$core$client$commands_ts$localCommands.set(
    'status',
    {
      description: 'get the current daemon status',
      category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.PROCESS_MANAGEMENT,
      async callback(req) {
        const {reporter} = req.client;
        const bridge = await req.client.tryConnectToExistingDaemon();
        if (bridge) {
          const status = await req.client.query(
            {
              command: 'status',
            },
            'master',
          );
          if (status.type === 'SUCCESS') {
            reporter.inspect(status.data);
            return true;
          } else {
            return false;
          }
        } else {
          reporter.error('Server not running.');
          return false;
        }
      },
    },
  );

  // project-rome/@romejs/core/client/ClientRequest.ts
class ___R$project$rome$$romejs$core$client$ClientRequest_ts$default {
    constructor(client, type = 'local', query) {
      this.client = client;
      this.type = type;
      this.query = query;
    }

    async init() {
      try {
        return await this.initCommand();
      } catch (err) {
        return (
          {
            type: 'ERROR',
            fatal: false,
            handled: false,
            name: err.name,
            message: err.message,
            stack: err.stack,
          }
        );
      }
    }

    async initCommand() {
      const localCommand = ___R$project$rome$$romejs$core$client$commands_ts$localCommands.get(this.query.command);

      if (this.type === 'master' || localCommand === undefined) {
        return this.initFromMaster();
      } else {
        return this.initFromLocal(localCommand);
      }
    }

    async initFromLocal( // rome-suppress lint/noExplicitAny
    localCommand) {
      const {query} = this;

      let flags;
      if (localCommand.defineFlags !== undefined) {
        flags =
          localCommand.defineFlags(
            ___R$project$rome$$romejs$consume$index_ts$consumeUnknown(
              query.commandFlags,
              'flags/invalid',
            ),
          );
      }

      const success = await localCommand.callback(this, flags);
      if (success) {
        return (
          {
            type: 'SUCCESS',
            data: undefined,
            hasData: false,
            markers: [],
          }
        );
      } else {
        return (
          {
            type: 'ERROR',
            fatal: false,
            // Local command would have printed something
            handled: true,
            name: 'Error',
            message: 'Command was not successful',
            stack: undefined,
          }
        );
      }
    }

    async initFromMaster() {
      const {client} = this;

      try {
        const bridge = await client.findOrStartMaster();
        return await bridge.query.call(this.query);
      } catch (err) {
        if (err instanceof ___R$project$rome$$romejs$events$BridgeError_ts$default) {
          return (
            {
              type: 'ERROR',
              fatal: true,
              handled: false,
              name: 'Error',
              message: 'Server died while processing command. Results may be incomplete.',
              stack: undefined,
            }
          );
        } else {
          throw err;
        }
      }
    }
  }

  // project-rome/@romejs/cli-flags/serializeCLIFlags.ts
const ___R$project$rome$$romejs$cli$flags$serializeCLIFlags_ts = {
    serializeCLIFlags: ___R$project$rome$$romejs$cli$flags$serializeCLIFlags_ts$serializeCLIFlags,
  };

  function ___R$$priv$project$rome$$romejs$cli$flags$serializeCLIFlags_ts$normalizeFlagValue(val) {
    if (val === 'true') {
      return true;
    } else if (typeof val === 'object' && val != null) {
      return String(val);
    } else {
      return val;
    }
  }

  function ___R$project$rome$$romejs$cli$flags$serializeCLIFlags_ts$serializeCLIFlags(
    data,
    cliTarget,
  ) {
    const {args, flags, defaultFlags} = data;

    let code = '$ ';
    if (data.prefix !== undefined) {
      code += data.prefix +
      ' ';
    }
    let startColumn = ___R$project$rome$$romejs$ob1$index_ts$number0Neg1;
    let endColumn = ___R$project$rome$$romejs$ob1$index_ts$number0Neg1;

    // Add args
    for (let i = 0;
    i < args.length;
    i++) {
      const arg = args[i];

      let isTarget = false;
      if (cliTarget.type === 'arg' && i === cliTarget.key) {
        isTarget = true;
      }
      if (cliTarget.type === 'arg-range' && cliTarget.from === i) {
        isTarget = true;
      }

      if (isTarget) {
        startColumn = ___R$project$rome$$romejs$ob1$index_ts$coerce0(code.length);
      }

      code += arg +
      ' ';

      let isEndTarget = isTarget;

      // We are the end target if we're within the from-to range or we're greater than from with no to
      if (cliTarget.type === 'arg-range' && i > cliTarget.from &&
        (cliTarget.to === undefined || cliTarget.to <= i)) {
        isEndTarget = true;
      }

      if (isEndTarget) {
        endColumn = ___R$project$rome$$romejs$ob1$index_ts$coerce0(code.length - 1);
      }
    }

    // Add flags
    for (const key in flags) {
      const val = ___R$$priv$project$rome$$romejs$cli$flags$serializeCLIFlags_ts$normalizeFlagValue(flags[key]);

      // Ignore pointless default values
      if (val === ___R$$priv$project$rome$$romejs$cli$flags$serializeCLIFlags_ts$normalizeFlagValue(defaultFlags[key])) {
        continue;
      }

      const isTarget = cliTarget.type === 'flag' && key === cliTarget.key;

      if (isTarget) {
        startColumn = ___R$project$rome$$romejs$ob1$index_ts$coerce0(code.length);
      }

      const flagPrefix = data.shorthandFlags.has(key) ? '-' : '--';
      const kebabKey = ___R$project$rome$$romejs$string$utils$toKebabCase_ts$toKebabCase(key);
      if (val === false) {
        code += flagPrefix +
        'no-' +
        kebabKey +
        ' ';
      } else {
        code += '' +
        flagPrefix +
        kebabKey +
        ' ';
      }

      // Booleans are always indicated with just their flag
      if (typeof val !== 'boolean') {
        // Only point to the value for flags that specify it
        if (isTarget && cliTarget.type === 'flag' &&
          (cliTarget.target === 'value' || cliTarget.target === 'inner-value')) {
          startColumn = ___R$project$rome$$romejs$ob1$index_ts$coerce0(code.length);
        }

        // Number or string
        code += String(val) +
        ' ';
      }

      if (isTarget) {
        endColumn = ___R$project$rome$$romejs$ob1$index_ts$coerce0(code.length - 1);
      }
    }

    if (startColumn === ___R$project$rome$$romejs$ob1$index_ts$number0Neg1 || endColumn === ___R$project$rome$$romejs$ob1$index_ts$number0Neg1) {
      startColumn = ___R$project$rome$$romejs$ob1$index_ts$coerce0(code.length - 1);
      endColumn = startColumn;
    }

    return (
      {
        language: 'shell',
        mtime: undefined,
        sourceText: code,
        filename: 'argv',
        start: {
          line: ___R$project$rome$$romejs$ob1$index_ts$number1,
          column: startColumn,
          index: startColumn,
        },
        end: {
          line: ___R$project$rome$$romejs$ob1$index_ts$number1,
          column: endColumn,
          index: endColumn,
        },
      }
    );
  }

  // project-rome/@romejs/cli-flags/Parser.ts
function ___R$$priv$project$rome$$romejs$cli$flags$Parser_ts$splitCommandName(cmd) {
    return cmd.split(' ');
  }

  class ___R$project$rome$$romejs$cli$flags$Parser_ts$default {
    constructor(reporter, opts, rawArgs) {
      this.reporter = reporter;
      this.opts = opts;

      this.shorthandFlags = new Set();
      this.declaredFlags = new Map();
      this.defaultFlags = new Map();
      this.flags = new Map();
      this.args = [];

      this.consumeRawArgs(rawArgs);

      this.commands = new Map();
      this.ranCommand = undefined;
      this.currentCommand = undefined;

      if (opts.version !== undefined) {
        this.declareArgument(
          {
            command: undefined,
            name: 'version',
            definition: {
              type: 'boolean',
              objectPath: ['version'],
              default: false,
              required: false,
              metadata: {
                description: 'show the version',
              },
            },
          },
        );
      }

      this.declareArgument(
        {
          command: undefined,
          name: 'help',
          definition: {
            type: 'boolean',
            objectPath: ['help'],
            default: false,
            required: false,
            metadata: {
              description: 'show this help screen',
            },
          },
        },
      );

      this.helpMode = this.flags.has('help');
    }

    looksLikeFlag(flag) {
      return flag !== undefined && flag[0] === '-';
    }

    consumeRawArgs(rawArgs) {
      while (rawArgs.length > 0) {
        const arg = String(rawArgs.shift());

        if (arg === '--') {
          // We consider a -- by itself to halt parsing of args, the rest of the remaining args are added to _
          this.args = this.args.concat(rawArgs);
          break;
        } else if (arg[0] === '-') {
          // Clean the argument by stripping off the dashes
          const name = arg[1] === '-' ? arg.slice(2) : arg.slice(1);

          // Flags beginning with no- are always false
          if (name.startsWith('no-')) {
            this.flags.set(name.slice(3), false);
            continue;
          }

          // If the next argument is a flag or we're at the end of the args then just set it to `true`
          if (rawArgs.length === 0 || this.looksLikeFlag(rawArgs[0])) {
            this.flags.set(name, true);
          } else {
            // Otherwise, take that value
            this.flags.set(name, String(rawArgs.shift()));
          }

          if (arg[0] === '-' && arg[1] !== '-') {
            this.shorthandFlags.add(name);
          }
        } else {
          // Not a flag and hasn't been consumed already by a previous arg so it must be a file
          this.args.push(arg);
        }
      }
    }

    setFlagAlias(key, alias) {
      const value = this.flags.get(key);
      if (value !== undefined) {
        this.flags.delete(key);
        this.flags.set(alias, value);
      }
    }

    getFlagsConsumer() {
      const defaultFlags = {};

      const flags = {};
      for (const [key, value] of this.flags) {
        flags[___R$project$rome$$romejs$string$utils$toCamelCase_ts$toCamelCase(key)] = value;
      }

      return (
        ___R$project$rome$$romejs$consume$index_ts$consume(
          {
            filePath: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath('argv'),
            value: flags,

            onDefinition: (def) => {
              const key = def.objectPath.join('.');

              // Detect root object
              if (key === '') {
                return;
              }

              this.declareArgument(
                {
                  name: key,
                  command: this.currentCommand,
                  definition: def,
                },
              );
              defaultFlags[key] = def.default;
            },

            context: {
              category: 'flags/invalid',
              getOriginalValue: (keys) => {
                return flags[keys[0]];
              },
              getDiagnosticPointer: (
                keys,
                target,
              ) => {
                const {programName} = this.opts;
                const prefixParts = [programName];
                if (this.currentCommand !== undefined) {
                  prefixParts.push(this.currentCommand);
                }

                return (
                  ___R$project$rome$$romejs$cli$flags$serializeCLIFlags_ts$serializeCLIFlags(
                    {
                      prefix: prefixParts.join(' '),
                      args: this.args,
                      defaultFlags,
                      flags,
                      shorthandFlags: this.shorthandFlags,
                    },
                    {
                      type: 'flag',
                      key: String(keys[0]),
                      target,
                    },
                  )
                );
              },
            },
          },
        )
      );
    }

    hasArg(name) {
      return this.flags.has(name) && this.flags.get(name) !== undefined;
    }

    declareArgument(decl) {
      // Commands may have colliding flags, this is only a problem in help mode, so make it unique
      const key = decl.command === undefined
        ? decl.name : decl.command +
        '.' +
        decl.name;

      // Ensure it hasn't been declared more than once
      if (this.declaredFlags.has(key)) {
        throw new Error('Already declared argument ' +
        key);
      }

      // Declare argument
      this.setFlagAlias(___R$project$rome$$romejs$string$utils$toKebabCase_ts$toKebabCase(key), key);
      this.declaredFlags.set(key, decl);
      this.defaultFlags.set(key, decl.definition.default);
    }

    getInterface() {
      return new ___R$project$rome$$romejs$cli$flags$Parser_ts$ParserInterface(this);
    }

    async shouldRunCommand(commandName, consumer) {
      // A command name could be made of multiple strings
      const commandParts = ___R$$priv$project$rome$$romejs$cli$flags$Parser_ts$splitCommandName(commandName);
      for (let i = 0;
      i < commandParts.length;
      i++) {
        if (commandParts[i] !== this.args[i]) {
          return;
        }
      }

      // Remove command name from arguments
      this.args = this.args.slice(commandParts.length);
      return await this.defineCommandFlags(commandName, consumer);
    }

    async init() {
      // Show help for --version
      if (this.flags.has('version')) {
        this.reporter.logAll(String(this.opts.version));
        process.exit(0);
      }

      // We've parsed arguments like `--foo bar` as `{foo: 'bar}`

      // However, --foo may be a boolean flag, so `bar` needs to be correctly added to args
      for (const [key, value] of this.flags) {
        const declared = this.declaredFlags.get(key);

        if (declared !== undefined && declared.definition.type === 'boolean' &&
          value !== true &&
          value !== false) {
          // This isn't necessarily the correct position... Probably doesn't matter?
          this.args.push(value);

          //
          this.flags.set(key, true);
        }
      }

      const consumer = this.getFlagsConsumer();

      let definedCommand;

      const {diagnostics, result} = await consumer.capture(
        async (consumer) => {
          for (const shorthandName of this.shorthandFlags) {
            consumer.get(shorthandName).unexpected(
              'Shorthand flags are not supported',
            );
          }

          const result = this.opts.defineFlags(consumer);

          for (const key of this.commands.keys()) {
            const defined = await this.shouldRunCommand(key, consumer);
            if (defined) {
              this.currentCommand = key;
              definedCommand = defined;
              break;
            }
          }

          consumer.enforceUsedProperties('flag', false);
          this.currentCommand = undefined;

          return result;
        },
      );

      if (result === undefined) {
        throw new ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError('CLI flag parsing diagnostics', diagnostics);
      }

      // Show help for --help
      if (this.helpMode) {
        await this.showHelp(
          definedCommand === undefined
            ? undefined : definedCommand.command.name,
        );
        process.exit(1);
      }

      if (definedCommand !== undefined) {
        this.ranCommand = definedCommand.command.name;
        await definedCommand.command.callback(definedCommand.flags);
      }

      return result;
    }

    buildOptionsHelp(keys) {
      const lines = [];

      const optionOutput = [];
      let argColumnLength = 0;

      // Build up options, we need to do this to line up the columns correctly
      for (const key of keys) {
        const decl = this.declaredFlags.get(key);
        if (decl === undefined) {
          throw new Error('Expected argument declaration');
        }

        const {definition: def} = decl;
        const {metadata} = def;
        let argName = decl.name;
        let argCol = ___R$project$rome$$romejs$string$utils$toKebabCase_ts$toKebabCase(decl.name);

        // For booleans that default to `true`, show the --no- version as that'll be what users should use
        if (def.type === 'boolean' && def.default === true) {
          argCol = '--no-' +
          argCol;
          argName = 'no-' +
          argName;
        } else {
          argCol = '--' +
          argCol;
        }

        // Add input specifier unless a boolean
        if (def.type !== 'boolean') {
          // TODO some way to customize this

          // Property metadata in the consumer is a fine place but we want this to be non-CLI specific
          let inputName = undefined;

          if (inputName === undefined) {
            if (def.type === 'number' || def.type === 'number-range') {
              inputName = 'num';
            } else {
              inputName = 'input';
            }
          }

          argCol += ' <' +
          inputName +
          '>';
        }

        // Set arg col length if we'll be longer
        if (argColumnLength < argCol.length) {
          argColumnLength = argCol.length;
        }

        const descCol = metadata === undefined ||
        metadata.description ===
        undefined
          ? 'no description found' : metadata.description;

        optionOutput.push(
          {
            argName,
            arg: argCol,
            description: descCol,
          },
        );
      }

      // Sort options by argument name
      optionOutput.sort((a, b) => ___R$project$rome$$romejs$string$utils$naturalCompare_ts$naturalCompare(a.argName, b.argName));

      // Output options
      for (const {arg, description} of optionOutput) {
        lines.push(
          ___R$project$rome$$romejs$string$markup$escape_ts$markup`<brightBlack>${___R$project$rome$$romejs$string$ansi$pad_ts$rightPad(arg, argColumnLength, ' ')}</brightBlack>  ${description}`,
        );
      }

      return lines;
    }

    showUsageHelp(description, usage = '[flags]', prefix) {
      const {reporter} = this;
      const {programName} = this.opts;

      reporter.section(
        'Usage',
        () => {
          if (description !== undefined) {
            reporter.logAll(description);
            reporter.forceSpacer();
          }

          const commandParts = [programName];
          if (prefix !== undefined) {
            commandParts.push(prefix);
          }
          commandParts.push(usage);

          const command = commandParts.join(' ');
          reporter.command(command);
        },
      );
    }

    showFocusedCommandHelp(commandName) {
      const command = this.commands.get(commandName);
      if (command === undefined) {
        throw new Error('Unknown command ' +
        commandName);
      }

      const {reporter} = this;
      const {name, usage, description, examples} = command;

      reporter.forceSpacer();
      this.showUsageHelp(description, usage, name);
      this.showHelpExamples(examples, name);

      // Find arguments that belong to this command
      const argKeys = [];
      for (const [key, decl] of this.declaredFlags) {
        if (decl.command === name) {
          argKeys.push(key);
        }
      }

      const optLines = this.buildOptionsHelp(argKeys);
      if (optLines.length > 0) {
        reporter.section(
          'Command Flags',
          () => {
            for (const line of optLines) {
              reporter.logAll(line);
            }
          },
        );
      }
    }

    async showHelp(commandName = this.ranCommand) {
      if (commandName !== undefined) {
        this.showFocusedCommandHelp(commandName);
        return;
      }

      const {description, usage, examples, programName} = this.opts;

      const consumer = this.getFlagsConsumer();
      await this.opts.defineFlags(consumer);

      for (const key of this.commands.keys()) {
        await this.defineCommandFlags(key, consumer);
      }

      this.showUsageHelp(description, usage);

      const {reporter} = this;
      reporter.section(
        'Global Flags',
        () => {
          // Show options not attached to any commands
          const lonerArgKeys = [];
          for (const [key, decl] of this.declaredFlags) {
            if (decl.command === undefined) {
              lonerArgKeys.push(key);
            }
          }

          for (const line of this.buildOptionsHelp(lonerArgKeys)) {
            reporter.logAll(line);
          }
        },
      );

      // Sort commands into their appropriate categories for output
      const commandsByCategory = new Map();
      const categoryNames = new Set();
      for (const [name, command] of this.commands) {
        if (name[0] === '_') {
          continue;
        }

        const {category} = command;
        let commandsForCategory = commandsByCategory.get(category);
        if (commandsForCategory === undefined) {
          commandsForCategory = [];
          commandsByCategory.set(category, commandsForCategory);
        }
        commandsForCategory.push(command);
        categoryNames.add(category);
      }

      reporter.section(
        'Commands',
        () => {
          const sortedCategoryNames = Array.from(
            categoryNames,
          ).sort();

          // Always make sure categoryless commands are displayed first
          if (sortedCategoryNames.includes(undefined)) {
            sortedCategoryNames.splice(sortedCategoryNames.indexOf(undefined), 1);
            sortedCategoryNames.unshift(undefined);
          }

          for (const category of sortedCategoryNames) {
            const commands = commandsByCategory.get(category);
            if (commands === undefined) {
              throw new Error('Impossible. Should always be populated.');
            }

            if (category !== undefined) {
              reporter.logAll('<emphasis>' +
              category +
              ' Commands</emphasis>');
            }

            // Sort by name
            commands.sort((a, b) => a.name.localeCompare(b.name));

            reporter.list(
              commands.map(
                (cmd) => {
                  return (
                    '<emphasis>' +
                    cmd.name +
                    '</emphasis> ' +
                    (cmd.description ===
                    undefined
                      ? '' : cmd.description)
                  );
                },
              ),
            );
            reporter.spacer();
          }

          reporter.info('To view help for a specific command run');
          reporter.command(programName +
          ' command_name --help');
        },
      );

      this.showHelpExamples(examples);
    }

    showHelpExamples(examples, prefix) {
      const {programName} = this.opts;
      const {reporter} = this;

      if (examples === undefined) {
        return;
      }

      reporter.section(
        'Examples',
        () => {
          for (const {description, command} of examples) {
            const commandParts = [];
            if (programName !== undefined) {
              commandParts.push(programName);
            }
            if (prefix !== undefined) {
              commandParts.push(prefix);
            }
            commandParts.push(command);

            const builtCommand = commandParts.join(' ');

            reporter.spacer();
            if (description !== undefined) {
              reporter.logAll(description);
            }
            reporter.command(builtCommand);
          }
        },
      );
    }

    commandRequired() {
      if (this.ranCommand) {
        return;
      }

      if (this.args.length === 0) {
        this.reporter.error(
          'No command specified. Run --help to see available commands.',
        );
      } else {
        // TODO command name is not sanitized for markup

        // TODO produce a diagnostic instead
        this.reporter.error(
          'Unknown command <emphasis>' +
          this.args.join(' ') +
          '</emphasis>. Run --help to see available commands.',
        );
      }

      process.exit(1);
    }

    addCommand(opts) {
      if (this.currentCommand !== undefined) {
        throw new Error('Nested commands aren\'t allowed');
      }

      this.commands.set(opts.name, opts);
    }

    async defineCommandFlags(cmd, consumer) {
      const opts = this.commands.get(cmd);
      if (opts === undefined) {
        throw new Error('Expected options');
      }

      this.currentCommand = cmd;

      let flags = {};
      if (opts.defineFlags !== undefined) {
        flags = opts.defineFlags(consumer);
      }

      this.currentCommand = undefined;

      return (
        {
          flags,
          command: opts,
        }
      );
    }
  }

  class ___R$project$rome$$romejs$cli$flags$Parser_ts$ParserInterface {
    constructor(parser) {
      this.parser = parser;
    }

    init() {
      return this.parser.init();
    }

    showHelp() {
      return this.parser.showHelp();
    }

    getArgs() {
      return this.parser.args;
    }

    commandRequired() {
      this.parser.commandRequired();
    }

    command(opts) {
      this.parser.addCommand(opts);
    }
  }

  // project-rome/@romejs/cli-flags/index.ts
function ___R$project$rome$$romejs$cli$flags$index_ts$parseCLIFlags(
    reporter,
    args,
    opts,
  ) {
    const parser = new ___R$project$rome$$romejs$cli$flags$Parser_ts$default(reporter, opts, args);
    return parser.getInterface();
  }

  function ___R$project$rome$$romejs$cli$flags$index_ts$parseCLIFlagsFromProcess(
    opts,
  ) {
    return (
      ___R$project$rome$$romejs$cli$flags$index_ts$parseCLIFlags(
        ___R$project$rome$$romejs$cli$reporter$Reporter_ts$default.fromProcess(),
        process.argv.slice(2),
        Object.assign(
          {
          },
          opts,
          {
            programName: opts.programName === undefined
              ? process.argv[1] : opts.programName,
          },
        ),
      )
    );
  }

  // project-rome/@romejs/core/master/MasterRequest.ts
const ___R$$priv$project$rome$$romejs$core$master$MasterRequest_ts$crypto = require(
    'crypto',
  );

  let ___R$$priv$project$rome$$romejs$core$master$MasterRequest_ts$requestIdCounter = 0;

  class ___R$project$rome$$romejs$core$master$MasterRequest_ts$MasterRequestInvalid extends ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError {}

  class ___R$project$rome$$romejs$core$master$MasterRequest_ts$default {
    constructor(opts) {
      this.query = opts.query;
      this.master = opts.master;
      this.bridge = opts.bridge;
      this.reporter = opts.reporter;
      this.markerEvent =
        new ___R$project$rome$$romejs$events$Event_ts$default(
          {
            name: 'MasterRequest.marker',
            onError: this.master.onFatalErrorBound,
          },
        );
      this.endEvent =
        new ___R$project$rome$$romejs$events$Event_ts$default(
          {
            name: 'MasterRequest.teardown',
            onError: this.master.onFatalErrorBound,
            serial: true,
          },
        );
      this.client = opts.client;
      this.id = ___R$$priv$project$rome$$romejs$core$master$MasterRequest_ts$requestIdCounter++;

      this.normalizedCommandFlags =
        {
          flags: {},
          defaultFlags: {},
        };
    }

    setNormalizedCommandFlags(normalized) {
      this.normalizedCommandFlags = normalized;
    }

    teardown(response) {
      this.reporter.teardown();
      this.endEvent.send(response);
    }

    async assertClientCwdProject() {
      const pointer = this.getDiagnosticPointerForClientCwd();
      return (
        this.master.projectManager.assertProject(
          this.client.flags.cwd,
          pointer,
        )
      );
    }

    createDiagnosticsPrinter(origin) {
      return (
        new ___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$default(
          {
            origins: [
              {
                category: 'master',
                message: this.query.commandName +
                ' command was dispatched',
              },
              origin,
            ],
            reporter: this.reporter,
            cwd: this.client.flags.cwd,
            flags: this.getDiagnosticsPrinterFlags(),
            readFile: this.master.readDiagnosticsPrinterFile.bind(this.master),
          },
        )
      );
    }

    getDiagnosticsPrinterFlags() {
      const {requestFlags} = this.query;
      return (
        {
          grep: requestFlags.grep,
          inverseGrep: requestFlags.inverseGrep,
          focus: requestFlags.focus,
          showAllDiagnostics: requestFlags.showAllDiagnostics,
          verboseDiagnostics: requestFlags.verboseDiagnostics,
          maxDiagnostics: requestFlags.maxDiagnostics,
          fieri: requestFlags.fieri,
        }
      );
    }

    expectArgumentLength(min, max = min) {
      const {args} = this.query;
      let message;

      let excessive = false;

      if (min === max) {
        if (args.length !== min) {
          message = 'Expected exactly <number emphasis>' +
          min +
          '</number> arguments';
        }
      } else {
        if (args.length < min) {
          message = 'Expected at least <number emphasis>' +
          min +
          '</number> arguments';
        }

        if (args.length > max) {
          excessive = true;
          message =
            'Expected no more than <number emphasis>' +
            min +
            '</number> arguments';
        }
      }

      if (message !== undefined) {
        this.throwDiagnosticFlagError(
          excessive
            ? 'Too many arguments' : 'Missing arguments',
          {
            type: 'arg-range',
            from: min,
            to: max,
          },
          [
            {
              type: 'log',
              category: 'info',
              message,
            },
          ],
        );
      }
    }

    throwDiagnosticFlagError(message, target = {type: 'none'}, advice) {
      const pointer = this.getDiagnosticPointerFromFlags(target);
      throw (
        new ___R$project$rome$$romejs$core$master$MasterRequest_ts$MasterRequestInvalid(
          message,
          [
            Object.assign(
              {
                message,
                filename: 'argv',
                category: target.type === 'arg' || target.type === 'arg-range'
                  ? 'args/invalid' : 'flags/invalid',
              },
              pointer,
              {
                advice,
              },
            ),
          ],
        )
      );
    }

    getDiagnosticPointerForClientCwd() {
      const cwd = this.client.flags.cwd.join();
      return (
        {
          sourceText: cwd,
          start: {
            index: ___R$project$rome$$romejs$ob1$index_ts$number0,
            line: ___R$project$rome$$romejs$ob1$index_ts$number1,
            column: ___R$project$rome$$romejs$ob1$index_ts$number0,
          },
          end: {
            index: ___R$project$rome$$romejs$ob1$index_ts$coerce0(cwd.length),
            line: ___R$project$rome$$romejs$ob1$index_ts$number1,
            column: ___R$project$rome$$romejs$ob1$index_ts$coerce0(cwd.length),
          },
          filename: 'cwd',
        }
      );
    }

    getDiagnosticPointerFromFlags(target) {
      const {query} = this;
      return (
        ___R$project$rome$$romejs$cli$flags$serializeCLIFlags_ts$serializeCLIFlags(
          {
            prefix: 'rome ' +
            query.commandName,
            flags: (Object.assign(
              {
              },
              this.client.flags,
              query.requestFlags,
              this.normalizedCommandFlags.flags,
            )),
            args: query.args,
            defaultFlags: Object.assign(
              {
              },
              ___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_FLAGS,
              ___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS,
              this.normalizedCommandFlags.defaultFlags,
              {
                clientName: this.client.flags.clientName,
              },
            ),
            shorthandFlags: new Set(),
          },
          target,
        )
      );
    }

    getResolverOptionsFromFlags() {
      const {requestFlags} = this.query;
      return (
        {
          origin: this.client.flags.cwd,
          platform: requestFlags.resolverPlatform,
          scale: requestFlags.resolverScale,
          mocks: requestFlags.resolverMocks,
        }
      );
    }

    getBundlerConfigFromFlags(resolverOpts) {
      return (
        {
          inlineSourceMap: false,
          cwd: this.client.flags.cwd,
          resolver: Object.assign(
            {
            },
            this.getResolverOptionsFromFlags(),
            resolverOpts,
          ),
        }
      );
    }

    async getFilesFromArgs(
      globOpts = {},
    ) {
      const {master} = this;
      const {flags} = this.client;
      const projects = new Set();

      // Build up args, defaulting to the current project dir if none passed
      const rawArgs = [...this.query.args];
      const resolvedArgs = [];
      if (rawArgs.length === 0) {
        const pointer = this.getDiagnosticPointerForClientCwd();
        const project = await this.assertClientCwdProject();
        resolvedArgs.push(
          {
            path: project.folder,
            pointer,
            project,
          },
        );
        projects.add(project);
      } else {
        for (let i = 0;
        i < rawArgs.length;
        i++) {
          const arg = rawArgs[i];

          const pointer = this.getDiagnosticPointerFromFlags(
            {
              type: 'arg',
              key: i,
            },
          );

          const resolved = await this.master.resolver.resolveEntryAssert(
            {
              origin: flags.cwd,
              source: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(arg),
              requestedType: 'folder',
            },
            {
              pointer,
            },
          );

          const project = this.master.projectManager.assertProjectExisting(
            resolved.path,
          );
          projects.add(project);

          resolvedArgs.push(
            {
              project,
              path: resolved.path,
              pointer,
            },
          );
        }
      }

      // Build up files
      const paths = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet();
      for (const {path, pointer, project} of resolvedArgs) {
        const matches = master.memoryFs.glob(path, globOpts);

        if (matches.size > 0) {
          for (const path of matches) {
            paths.add(path);
          }
          continue;
        }

        let category = 'args/fileNotFound';

        let advice = globOpts.advice === undefined
          ? [] : [...globOpts.advice];

        // Hint if `path` failed `globOpts.test`
        if (globOpts.getProjectEnabled !== undefined) {
          const test = globOpts.getProjectEnabled(project);

          if (!test.enabled && test.source !== undefined) {
            const testSource = test.source;

            const explanationPrefix = globOpts.verb === undefined
              ? 'Files excluded' : 'Files excluded from ' +
              globOpts.verb;

            if (globOpts.disabledDiagnosticCategory !== undefined) {
              category = globOpts.disabledDiagnosticCategory;
            }

            if (testSource.value === undefined) {
              let explanation = explanationPrefix +
              ' as it\'s not enabled for this project';
              if (globOpts.configCategory !== undefined) {
                explanation +=
                  '. Run <command>rome config enable-category ' +
                  globOpts.configCategory +
                  '</command> to enable it.';
              }
              advice.push(
                {
                  type: 'log',
                  category: 'info',
                  message: explanation,
                },
              );
            } else {
              advice.push(
                {
                  type: 'log',
                  category: 'info',
                  message: explanationPrefix +
                  ' as it\'s explicitly disabled in this project config',
                },
              );

              const disabledPointer = testSource.value.getDiagnosticPointer(
                'value',
              );
              if (disabledPointer !== undefined) {
                advice.push(
                  Object.assign(
                    {
                      type: 'frame',
                    },
                    disabledPointer,
                  ),
                );
              }
            }
          }
        }

        // Hint if all files were ignored
        if (globOpts.getProjectIgnore !== undefined) {
          const ignore = globOpts.getProjectIgnore(project);

          const {paths: withoutIgnore} = await this.getFilesFromArgs(
            Object.assign(
              {
              },
              globOpts,
              {
                getProjectIgnore: undefined,
              },
            ),
          );

          if (withoutIgnore.size > 0) {
            advice.push(
              {
                type: 'log',
                category: 'info',
                message: 'The following files were ignored',
              },
            );

            advice.push(
              {
                type: 'list',
                list: Array.from(
                  withoutIgnore,
                  (
                    path,
                  ) =>
                    '<filelink target="' +
                    path.join() +
                    '" />',
                ),
                truncate: true,
              },
            );

            if (ignore.source !== undefined && ignore.source.value !== undefined) {
              const ignorePointer = ignore.source.value.getDiagnosticPointer(
                'value',
              );

              if (ignorePointer !== undefined) {
                advice.push(
                  {
                    type: 'log',
                    category: 'info',
                    message: 'Ignore patterns were defined here',
                  },
                );

                advice.push(
                  Object.assign(
                    {
                      type: 'frame',
                    },
                    ignorePointer,
                  ),
                );
              }
            }
          }
        }

        throw (
          ___R$project$rome$$romejs$diagnostics$errors_ts$createSingleDiagnosticError(
            Object.assign(
              {
              },
              pointer,
              {
                category,
                message: globOpts.noun === undefined
                  ? 'No files found' : 'No files to ' +
                  globOpts.noun +
                  ' found',
                advice,
              },
            ),
          )
        );
      }

      return {paths, projects};
    }

    normalizeCompileResult(res) {
      const {projectManager} = this.master;

      // Turn all the cacheDependencies entries from 'absolute paths to UIDs
      return (
        Object.assign(
          {
          },
          res,
          {
            cacheDependencies: res.cacheDependencies.map(
              (filename) => {
                return (
                  projectManager.getFileReference(___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(filename)).uid
                );
              },
            ),
          },
        )
      );
    }

    startMarker(opts) {
      this.master.logger.info('Started marker %s', opts.label);
      return (
        Object.assign(
          {
          },
          opts,
          {
            start: Date.now(),
          },
        )
      );
    }

    endMarker(startMarker) {
      const endMarker = Object.assign(
        {
        },
        startMarker,
        {
          end: Date.now(),
        },
      );
      this.master.logger.info('Finished marker %s', startMarker.label);
      this.markerEvent.send(endMarker);
      return endMarker;
    }

    async wrapRequestDiagnostic(method, path, factory) {
      const {master} = this;
      const owner = await master.fileAllocator.getOrAssignOwner(path);
      const ref = master.projectManager.getTransportFileReference(path);

      const marker = this.startMarker(
        {
          label: method +
          ': ' +
          ref.uid,
          facet: method,
          rowId: 'worker ' +
          owner.id,
        },
      );

      try {
        const res = await factory(owner.bridge, ref);
        this.endMarker(marker);
        return res;
      } catch (err) {
        let diagnostics = ___R$project$rome$$romejs$diagnostics$errors_ts$getDiagnosticsFromError(err);

        if (diagnostics === undefined) {
          const info = ___R$project$rome$$romejs$v8$errors_ts$getErrorStructure(err);

          throw (
            ___R$project$rome$$romejs$v8$errors_ts$createErrorFromStructure(
              Object.assign(
                {
                },
                info,
                {
                  advice: [
                    ...info.advice,
                    {
                      type: 'log',
                      category: 'info',
                      message: 'Error occurred while requesting ' +
                      method +
                      ' for <filelink emphasis target="' +
                      ref.uid +
                      '" />',
                    },
                  ],
                },
              ),
            )
          );
        } else {
          // We don't want to tamper with these
          throw err;
        }
      }
    }

    async requestWorkerParse(filename, opts) {
      return (
        this.wrapRequestDiagnostic(
          'parse',
          filename,
          (
            bridge,
            file,
          ) =>
            bridge.parseJS.call({file, opts}),
        )
      );
    }

    async requestWorkerLint(filename, fix) {
      const {cache} = this.master;
      const cacheEntry = await cache.get(filename);
      if (cacheEntry.lint !== undefined) {
        return cacheEntry.lint;
      }

      const prefetchedModuleSignatures = await this.maybePrefetchModuleSignatures(
        filename,
      );

      const res = await this.wrapRequestDiagnostic(
        'lint',
        filename,
        (bridge, file) => bridge.lint.call({file, fix, prefetchedModuleSignatures}),
      );

      await cache.update(
        filename,
        {
          lint: res,
        },
      );

      return res;
    }

    async requestWorkerFormat(path) {
      return (
        await this.wrapRequestDiagnostic(
          'format',
          path,
          (
            bridge,
            file,
          ) =>
            bridge.format.call({file}),
        )
      );
    }

    async requestWorkerCompile(path, stage, options) {
      const {cache} = this.master;

      // Create a cache key comprised of the stage and hash of the options
      const optionsHash = options === undefined
        ? 'none' : ___R$$priv$project$rome$$romejs$core$master$MasterRequest_ts$crypto.createHash(
          'sha256',
        ).update(
          JSON.stringify(options),
        ).digest(
          'hex',
        );
      const cacheKey = stage +
      ':' +
      optionsHash;

      // Check cache for this stage and options
      const cacheEntry = await cache.get(path);
      const cached = cacheEntry.compile[cacheKey];
      if (cached !== undefined) {
        // TODO check cacheDependencies
        return cached;
      }

      const compileRes = await this.wrapRequestDiagnostic(
        'compile',
        path,
        (
          bridge,
          file,
        ) => {
          // We allow options to be passed in as undefined so we can compute an easy cache key
          if (options === undefined) {
            options = {};
          }

          return bridge.compileJS.call({file, stage, options});
        },
      );

      const res = this.normalizeCompileResult(
        Object.assign(
          {
          },
          compileRes,
          {
            cached: false,
          },
        ),
      );

      // There's a race condition here between the file being opened and then rewritten
      await cache.update(
        path,
        (
          cacheEntry,
        ) =>
          ({
            compile: Object.assign(
              {
              },
              cacheEntry.compile,
              {
                [cacheKey]: Object.assign(
                  {
                  },
                  res,
                  {
                    cached: true,
                  },
                ),
              },
            ),
          }),
      );

      return res;
    }

    async requestWorkerAnalyzeDependencies(path) {
      const {cache} = this.master;

      const cacheEntry = await cache.get(path);
      if (cacheEntry.analyzeDependencies !== undefined) {
        return cacheEntry.analyzeDependencies;
      }

      const res = await this.wrapRequestDiagnostic(
        'analyzeDependencies',
        path,
        (
          bridge,
          file,
        ) =>
          bridge.analyzeDependencies.call({file}),
      );
      await cache.update(
        path,
        {
          analyzeDependencies: Object.assign(
            {
            },
            res,
            {
              cached: true,
            },
          ),
        },
      );

      return (
        Object.assign(
          {
          },
          res,
          {
            cached: false,
          },
        )
      );
    }

    async requestWorkerModuleSignature(filename) {
      const {cache} = this.master;

      const cacheEntry = await cache.get(filename);
      if (cacheEntry.moduleSignature !== undefined) {
        return cacheEntry.moduleSignature;
      }

      const res = await this.wrapRequestDiagnostic(
        'moduleSignature',
        filename,
        (
          bridge,
          file,
        ) =>
          bridge.moduleSignatureJS.call({file}),
      );
      await cache.update(
        filename,
        {
          moduleSignature: res,
        },
      );
      return res;
    }

    async maybePrefetchModuleSignatures(filename) {
      const {projectManager} = this.master;

      const prefetchedModuleSignatures = {};
      const project = await projectManager.assertProject(filename);
      if (project.config.typeCheck.enabled === false) {
        return prefetchedModuleSignatures;
      }

      // get the owner of this file

      /*const rootOwner = await fileAllocator.getOrAssignOwner(filename);
    const rootOwnerId = workerManager.getIdFromBridge(rootOwner);

    // absolute filenames to redupe export graphs
    const absoluteFilenameToGraphKey: Map<string, string> = new Map();

    // TODO exclude graphs that aren't a part of the root graph
    for (const dep of await dependencyGraph.getTransitiveDependencies(
      filename,
    )) {
      const key = `${dep.origin}:${dep.relative}`;
      const absolute = dep.absoluteMocked;

      // TODO check if we have this graph by another key and point to it if necessary
      const existingEntryKey = absoluteFilenameToGraphKey.get(absolute);
      if (existingEntryKey !== undefined) {
        invariant(existingEntryKey !== key, 'duplicate transitive dependency key %s', key);
        prefetchedModuleSignatures[key] = {
          type: 'POINTER',
          key: existingEntryKey,
        };
        continue;
      }

      // set the key so we point to the value instead of reproducing the whole graph
      absoluteFilenameToGraphKey.set(absolute, key);

      // fetch the owner so we can leave out graphs owned by the worker
      const owner = await fileAllocator.getOrAssignOwner(absolute);
      if (owner === rootOwner) {
        const project = await projectManager.assertProject(absolute);
        prefetchedModuleSignatures[key] = {
          type: 'OWNED',
          filename: absolute,
          projectId: project.id,
        };
        continue;
      }

      // get mtime so we can use it for a cache
      const mtime = this.master.memoryFs.getMtime(absolute);

      // check if this worker has it cached
      // TODO figure out some way to evict this on file deletion
      const cacheKey = `moduleSignature:${absolute}`;
      const cachedMtime = workerManager.getValueFromWorkerCache(
        rootOwnerId,
        cacheKey,
      );
      if (cachedMtime === mtime) {
        prefetchedModuleSignatures[key] = {
          type: 'USE_CACHED',
          filename: absolute,
        };
        continue;
      } else {
        workerManager.setWorkerCacheValue(rootOwnerId, cacheKey, mtime);
      }

      // calculate the graph
      const graph = await this.moduleSignature(absolute);
      prefetchedModuleSignatures[key] = {
        type: 'RESOLVED',
        graph,
      };
    }*/
      return prefetchedModuleSignatures;
    }
  }

  // project-rome/@romejs/core/master/project/ProjectManager.ts
function ___R$$priv$project$rome$$romejs$core$master$project$ProjectManager_ts$cleanUidParts(parts) {
    let uid = '';

    let lastPart = '';
    for (const part of parts) {
      if (uid !== '') {
        uid += '/';
      }

      // Prune off any prefix shared with the last part
      let sharedPrefix = '';
      for (let i = 0;
      i < part.length && lastPart[i] === part[i];
      i++) {
        sharedPrefix += part[i];
      }

      uid += part.slice(sharedPrefix.length);

      lastPart = part;
    }

    return uid;
  }

  // If a UID has a relative path that's just index.js, index.ts etc then omit it
  function ___R$$priv$project$rome$$romejs$core$master$project$ProjectManager_ts$cleanRelativeUidPath(relative) {
    return relative.join();

    const segments = relative.getSegments();

    // Quick deopt if there last segment is not index.
    if (!segments[segments.length - 1].startsWith('index.')) {
      return relative.join();
    }

    // Verify and pop off the last segment if it matches index.VALID_JS_EXTENSION
    const basename = relative.getBasename();
    for (const ext of ___R$project$rome$$romejs$core$common$fileHandlers_ts$IMPLICIT_JS_EXTENSIONS) {
      // Got a matching basename that we should omit
      if (basename === 'index.' +
      ext) {
        if (segments.length === 1) {
          // If there's a single segment then we don't want anything
          return undefined;
        } else {
          return relative.getParent().join();
        }
      }
    }

    // No matches, we hit the index. check above but not any of the valid extensions
    return relative.join();
  }

  class ___R$project$rome$$romejs$core$master$project$ProjectManager_ts$default {
    constructor(master) {
      this.master = master;

      this.isAddingProject = false;
      this.pendingAddProjects = [];

      this.projectIdCounter = 0;
      this.projectFolderToId = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
      this.projectConfigDependenciesToIds = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
      this.fileToProject = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
      this.projects = new Map();

      // We maintain these maps so we can reverse any uids, and protect against collisions
      this.uidToFilename = new Map();
      this.filenameToUid = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
      this.remoteToLocalPath = new ___R$project$rome$$romejs$path$collections_ts$UnknownFilePathMap();
      this.localPathToRemote = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
    }

    async init() {
      this.master.memoryFs.deletedFileEvent.subscribe(
        (path) => {
          this.handleDeleted(path);
        },
      );

      const vendorProjectConfig = Object.assign(
        {
        },
        ___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG,
        {
          name: 'rome-internal-remote',
        },
      );
      const defaultVendorPath = vendorProjectConfig.files.vendorPath;
      await ___R$project$rome$$romejs$fs$index_ts$createDirectory(defaultVendorPath, {recursive: true});
      await this.addProjectWithConfig(
        {
          projectFolder: defaultVendorPath,
          meta: ___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG_META,
          config: vendorProjectConfig,
        },
      );
      await this.master.memoryFs.watch(defaultVendorPath, vendorProjectConfig);
    }

    handleDeleted(path) {
      const filename = path.join();

      this.projectConfigDependenciesToIds.delete(path);
      this.fileToProject.delete(path);

      // Remove uids
      const uid = this.filenameToUid.get(path);
      this.filenameToUid.delete(path);
      if (uid !== undefined) {
        this.uidToFilename.delete(filename);
      }
    }

    getRemoteFromLocalPath(path) {
      return this.localPathToRemote.get(path);
    }

    getFilePathFromUid(uid) {
      return this.uidToFilename.get(uid);
    }

    setUid(path, uid) {
      const filename = path.join();

      // Verify we didn't already generate this uid for another file
      const collided = this.uidToFilename.get(uid);
      if (collided !== undefined && !collided.equal(path)) {
        throw (
          new Error(
            'UID collision between ' +
            filename +
            ' and ' +
            collided +
            ': ' +
            uid,
          )
        );
      }

      this.uidToFilename.set(uid, path);
      this.filenameToUid.set(path, uid);
    }

    getUid(path) {
      // Allow passing in a UID
      const filename = path.join();
      if (this.uidToFilename.has(filename)) {
        return filename;
      }

      // Check if we've already calculated and saved a UID
      const existing = this.filenameToUid.get(path);
      if (existing !== undefined) {
        return existing;
      }

      const project = this.assertProjectExisting(path);

      // For haste projects, use the haste name as the uid. If the user has multiple projects

      // with colliding uids then that's fine, it will just cause more cache misses as we compare

      // mtime, project config hash etc stored in the cache.
      if (this.isHasteDeclared(path, project)) {
        const hasteName = this.master.memoryFs.getHasteName(path);
        if (hasteName === undefined) {
          throw (
            new Error(
              'isHasteDeclared returned true so this should always return a valid name',
            )
          );
        }
        this.setUid(path, hasteName);
        return hasteName;
      }

      // Format of uids will be <PROJECT_NAME>/<PACKAGE_NAME>/<RELATIVE>
      const parts = [];

      let root = project.folder;

      // Push on parent package names
      let targetPackagePath = path;
      while (true) {
        const pkg = this.master.memoryFs.getOwnedManifest(targetPackagePath);
        if (pkg === undefined || pkg.folder.equal(project.folder)) {
          break;
        } else {
          const name = pkg.manifest.name;
          if (name !== undefined) {
            parts.unshift(name);

            if (targetPackagePath === path) {
              root = pkg.folder;
            }
          }
          targetPackagePath = pkg.folder.getParent();
        }
      }

      parts.unshift(project.config.name);

      const relative = ___R$$priv$project$rome$$romejs$core$master$project$ProjectManager_ts$cleanRelativeUidPath(root.relative(path));
      if (relative !== undefined) {
        parts.push(relative);
      }

      const uid = ___R$$priv$project$rome$$romejs$core$master$project$ProjectManager_ts$cleanUidParts(parts);
      this.setUid(path, uid);
      return uid;
    }

    getFileReference(path) {
      const project = this.assertProjectExisting(path);
      const uid = this.getUid(path);
      const pkg = this.master.memoryFs.getOwnedManifest(path);
      return (
        {
          uid,
          project: project.id,
          real: path,
          manifest: pkg === undefined ? undefined : pkg.id,
          remote: this.localPathToRemote.has(path),
        }
      );
    }

    getURLFileReference(local, url) {
      if (!this.remoteToLocalPath.has(url)) {
        this.remoteToLocalPath.set(url, local);
        this.localPathToRemote.set(local, url);
      }

      return this.getFileReference(local);
    }

    getTransportFileReference(path) {
      return (
        Object.assign(
          {
          },
          this.getFileReference(path),
          {
            real: path.join(),
          },
        )
      );
    }

    async maybeEvictPossibleConfig(path) {
      // TODO not sure if this case handles new manifests?

      // check if this filename is a rome config dependency
      const projectIds = this.projectConfigDependenciesToIds.get(path);
      if (projectIds === undefined) {
        return false;
      }

      const projectsToEvict = new Set();

      function getAllProjects(project) {
        let children = [];
        for (const child of project.children) {
          children = children.concat(getAllProjects(child));
        }
        return [project, ...children];
      }

      for (const evictProjectId of projectIds) {
        // Fetch the project
        const project = this.projects.get(evictProjectId);
        if (project === undefined) {
          throw (
            new Error(
              'Expected project of id ' +
              evictProjectId +
              ' since it was declared in projectConfigLocsToId',
            )
          );
        }

        // Add all parent projects
        let topProject = project;
        while (topProject.parent !== undefined) {
          topProject = topProject.parent;
        }
        for (const project of getAllProjects(topProject)) {
          projectsToEvict.add(project);
        }
      }

      for (const project of projectsToEvict) {
        await this.evictProject(project);
      }

      return true;
    }

    async evictProject(project) {
      const evictProjectId = project.id;

      // Remove the config locs from 'our internal map that belong to this project
      for (const [configLoc, projectIds] of this.projectConfigDependenciesToIds) {
        if (projectIds.has(evictProjectId)) {
          projectIds.delete(evictProjectId);
        }

        if (projectIds.size === 0) {
          this.projectConfigDependenciesToIds.delete(configLoc);
        }
      }

      // Notify all workers that it should delete the project
      for (const {bridge} of this.master.workerManager.getWorkers()) {
        // Evict project
        bridge.updateProjects.send(
          {
            projects: [
              {
                id: evictProjectId,
                folder: project.folder.join(),
                config: undefined,
              },
            ],
          },
        );

        // Evict packages
        bridge.updateManifests.send(
          {
            manifests: Array.from(
              project.manifests.values(),
              (
                def,
              ) =>
                ({
                  id: def.id,
                  manifest: undefined,
                }),
            ),
          },
        );
      }

      // Delete the project from 'our internal map
      this.projects.delete(evictProjectId);
      this.projectFolderToId.delete(project.folder);

      // Evict all files that belong to this project and delete their project mapping
      const ownedFiles = [];
      for (const {projectId, path} of this.fileToProject.values()) {
        if (evictProjectId === projectId) {
          this.handleDeleted(path);
          ownedFiles.push(path);
        }
      }
      await Promise.all(
        ownedFiles.map(
          (
            path,
          ) =>
            this.master.fileAllocator.evict(path),
        ),
      );

      // Tell the MemoryFileSystem to stop watching and clear it's maps
      this.master.memoryFs.unwatch(project.folder);
    }

    getProjects() {
      return Array.from(this.projects.values());
    }

    async queueAddProject(projectFolder, configPath) {
      // Check if we've already loaded this project
      const maybeProject = this.findProjectExisting(projectFolder);
      if (maybeProject !== undefined) {
        return maybeProject;
      }

      // If we're currently adding a project then add it to the queue
      if (this.isAddingProject) {
        return (
          new Promise(
            (resolve) => {
              this.pendingAddProjects.push({projectFolder, configPath, resolve});
            },
          )
        );
      }

      // First time loading this project
      this.isAddingProject = true;

      // fetch this project
      const mainProject = await this.addProject(projectFolder, configPath);
      const resolvedProjectsByDir = new Map();
      resolvedProjectsByDir.set(projectFolder.join(), mainProject);

      // Resolve all pending projects that were added while we were adding the current project
      const resolvedProjects = [];
      for (const {projectFolder, configPath, resolve} of this.pendingAddProjects) {
        // Check if the project has already been resolved
        const existing = resolvedProjectsByDir.get(projectFolder.join());
        if (existing !== undefined) {
          resolvedProjects.push({project: existing, resolve});
        } else {
          // It hasn't been resolved yet so let's add it
          const project = await this.addProject(projectFolder, configPath);
          resolvedProjects.push({project, resolve});
        }
      }

      // Resolve all promises
      for (const {project, resolve} of resolvedProjects) {
        resolve(project);
      }

      // Cleanup
      this.pendingAddProjects = [];
      this.isAddingProject = false;

      return mainProject;
    }

    addDependencyToProjectId(path, projectId) {
      const ids = this.projectConfigDependenciesToIds.get(path);

      if (ids === undefined) {
        this.projectConfigDependenciesToIds.set(path, new Set([projectId]));
      } else {
        ids.add(projectId);
      }
    }

    findProjectConfigConsumer(def, test) {
      const meta = ___R$project$rome$$romejs$project$utils_ts$assertHardMeta(def.meta);

      for (const consumer of meta.consumersChain) {
        const value = test(consumer);
        if (value !== undefined && value.exists()) {
          return {value, consumer: meta.consumer};
        }
      }

      return {value: undefined, consumer: meta.consumer};
    }

    async addProject(projectFolder, configPath) {
      const {config, meta} = ___R$project$rome$$romejs$project$load_ts$loadCompleteProjectConfig(projectFolder, configPath);

      return (
        this.addProjectWithConfig(
          {
            projectFolder,
            meta,
            config,
          },
        )
      );
    }

    async addProjectWithConfig({
      projectFolder,
      meta,
      config,
    }) {
      // Make sure there's no project with the same `name` as us
      for (const project of this.projects.values()) {
        if (project.config.name === config.name) {
          throw (
            new Error(
              'Conflicting project names. ' +
              projectFolder +
              ' and ' +
              project.folder,
            )
          );
        }
      }

      // Declare the project
      const parentProject = this.findProjectExisting(projectFolder.getParent());
      const project = {
        config,
        meta,
        folder: projectFolder,
        id: this.projectIdCounter++,
        packages: new Map(),
        manifests: new Map(),
        hasteMap: new Map(),
        parent: parentProject,
        children: new Set(),
      };

      this.projects.set(project.id, project);
      this.fileToProject.set(
        projectFolder,
        {
          path: projectFolder,
          projectId: project.id,
        },
      );
      this.projectFolderToId.set(projectFolder, project.id);

      if (parentProject !== undefined) {
        parentProject.children.add(project);
      }

      // Add all project config dependencies so changes invalidate the whole project
      if (meta.configPath !== undefined) {
        this.addDependencyToProjectId(meta.configPath, project.id);
      }
      for (const loc of meta.configDependencies) {
        this.addDependencyToProjectId(loc, project.id);
      }

      // Notify other pieces of our creation
      this.master.workerManager.onNewProject(project);

      // Start watching and crawl this project folder
      await this.master.memoryFs.watch(projectFolder, config);

      return project;
    }

    declareManifest(project, isProjectPackage, def, diagnostics) {
      const {name} = def.manifest;

      // Declare this package in all projects
      const projects = this.getHierarchyFromProject(project);

      // Check for collisions
      if (isProjectPackage && name !== undefined) {
        for (const project of projects) {
          // If there is no package then there's nothing to collide
          const existingPackage = project.packages.get(name);
          if (existingPackage === undefined) {
            continue;
          }

          diagnostics.addDiagnostic(
            Object.assign(
              {
                category: 'projectManager/nameCollision',
                filename: def.path.join(),
                message: 'Duplicate package name <emphasis>' +
                name +
                '</emphasis>',
              },
              def.consumer.get('name').getDiagnosticPointer('inner-value'),
              {
                advice: [
                  {
                    type: 'log',
                    category: 'info',
                    message: 'Defined already by <filelink target="' +
                    existingPackage.path +
                    '" />',
                  },
                ],
              },
            ),
          );
          return;
        }
      }

      // Set as a package
      for (const project of projects) {
        this.addDependencyToProjectId(def.path, project.id);
        project.manifests.set(def.id, def);

        if (isProjectPackage && name !== undefined) {
          project.packages.set(name, def);
        }
      }
    }

    isHasteIgnored(path, config) {
      return ___R$project$rome$$romejs$path$match$index_ts$matchPathPatterns(path, config.haste.ignore) !== 'NO_MATCH';
    }

    isHasteDeclared(path, project) {
      if (project.config.haste.enabled === false) {
        return false;
      }

      const hasteName = this.master.memoryFs.getHasteName(path);
      if (hasteName === undefined) {
        return false;
      }

      const existing = project.hasteMap.get(hasteName);
      if (existing === undefined) {
        return false;
      }

      return existing.equal(path);
    }

    declareHaste(path, hasteName, hastePath, diagnostics) {
      for (const project of this.getHierarchyFromFilename(path)) {
        const {hasteMap, config} = project;

        if (config.haste.enabled === false) {
          break;
        }

        if (this.isHasteIgnored(path, config)) {
          continue;
        }

        let existing = hasteMap.get(hasteName);
        if (existing !== undefined && !existing.equal(hastePath)) {
          const existingResolved = this.master.resolver.resolvePath(
            {
              // `existing` will be absolute so the origin doesn't really matter
              origin: existing,
              source: existing,
            },
          );

          // If both resolve to the same location then this isn't a collision and we should just ignore it
          if (existingResolved.type === 'FOUND' &&
            hastePath.equal(
              existingResolved.ref.real,
            )) {
            continue;
          }

          diagnostics.addDiagnostic(
            {
              category: 'projectManager/nameCollision',
              filename: hastePath.join(),
              message: 'Found a haste collision for <emphasis>' +
              hasteName +
              '</emphasis>',
              advice: [
                {
                  type: 'log',
                  category: 'info',
                  message: 'Defined already by <filelink emphasis target="' +
                  existing +
                  '" />',
                },
              ],
            },
          );
          continue;
        }

        hasteMap.set(hasteName, hastePath);
      }
    }

    async notifyWorkersOfProjects(workers, projects) {
      if (projects === undefined) {
        projects = Array.from(this.projects.values());
      }

      const manifestsSerial = [];
      const projectsSerial = [];
      for (const project of projects) {
        projectsSerial.push(
          {
            config: ___R$project$rome$$romejs$project$transport_ts$serializeJSONProjectConfig(project.config),
            id: project.id,
            folder: project.folder.join(),
          },
        );

        for (const def of project.manifests.values()) {
          manifestsSerial.push(
            {
              id: def.id,
              manifest: this.master.memoryFs.getPartialManifest(def),
            },
          );
        }
      }

      const promises = [];

      for (const worker of workers) {
        promises.push(
          worker.bridge.updateProjects.call({projects: projectsSerial}),
        );
        promises.push(
          worker.bridge.updateManifests.call(
            {
              manifests: manifestsSerial,
            },
          ),
        );
      }

      await Promise.all(promises);
    }

    async assertProject(path, pointer) {
      // We won't recurse up and check a parent project if we've already visited it
      const syncProject = this.findProjectExisting(path);
      const project = syncProject || (await this.findProject(path));

      if (project) {
        // Continue searching for projects up the directory

        // We don't do this for root projects since it would be a waste, but there's no implications other than some unnecessary work if we did
        if (project.config.root === false && syncProject === undefined) {
          await this.findProject(project.folder.getParent());
        }

        return project;
      }

      if (pointer === undefined) {
        throw (
          new Error(
            'Couldn\'t find a project. Checked ' +
            ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_FILENAMES.join(' or ') +
            ' for ' +
            path.join(),
          )
        );
      }

      throw (
        ___R$project$rome$$romejs$diagnostics$errors_ts$createSingleDiagnosticError(
          Object.assign(
            {
            },
            pointer,
            {
              category: 'projectManager/missing',
              message: 'Couldn\'t find a project',
              advice: [
                {
                  type: 'log',
                  category: 'info',
                  message: 'Run <command>rome init</command> in this folder to initialize a project',
                },
              ],
            },
          ),
        )
      );
    }

    // Convenience method to get the project config and pass it to the file handler class
    getHandlerWithProject(path) {
      const project = this.findProjectExisting(path);
      if (project === undefined) {
        return {ext: '', handler: undefined};
      } else {
        return ___R$project$rome$$romejs$core$common$fileHandlers_ts$getFileHandler(path, project.config);
      }
    }

    getHierarchyFromFilename(filename) {
      const project = this.findProjectExisting(filename);
      if (project === undefined) {
        return [];
      } else {
        return this.getHierarchyFromProject(project);
      }
    }

    getHierarchyFromProject(project) {
      const projects = [];

      let currProject = project;
      while (currProject !== undefined) {
        projects.push(currProject);

        // root projects shouldn't be considered to have any parents
        if (currProject.config.root) {
          break;
        }

        currProject = project.parent;
      }

      return projects;
    }

    assertProjectExisting(path) {
      const project = this.findProjectExisting(path);
      if (project === undefined) {
        throw new Error('Expected existing project for ' +
        path.join());
      }
      return project;
    }

    findProjectExisting(cwd) {
      const tried = [];

      for (const dir of cwd.getChain()) {
        const cached = this.fileToProject.get(dir);
        if (cached === undefined) {
          tried.push(dir);
        } else {
          for (const dir of tried) {
            this.fileToProject.set(dir, cached);
          }

          const project = this.projects.get(cached.projectId);
          if (project === undefined) {
            throw (
              new Error(
                'Expected project from project id found in fileToProject',
              )
            );
          }
          return project;
        }
      }

      return undefined;
    }

    async findProject(cwd) {
      // Check if we have an existing project
      const syncProject = this.findProjectExisting(cwd);
      if (syncProject !== undefined) {
        return syncProject;
      }

      const parentDirectories = cwd.getChain();

      // If not then let's access the file system and try to find one
      for (const dir of parentDirectories) {
        // Check for dedicated project configs
        for (const configFilename of ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_FILENAMES) {
          // Check in root
          const configPath = dir.append(configFilename);
          const hasProject = await this.master.memoryFs.existsHard(configPath);
          if (hasProject) {
            return this.queueAddProject(dir, configPath);
          }

          // Check a .config folder
          const configPathNested = dir.append(___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_FOLDER).append(
            configFilename,
          );
          const hasProjectNested = await this.master.memoryFs.existsHard(
            configPathNested,
          );
          if (hasProjectNested) {
            return this.queueAddProject(dir, configPathNested);
          }
        }

        // Check for package.json
        const packagePath = dir.append('package.json');
        if (await this.master.memoryFs.existsHard(packagePath)) {
          const input = await ___R$project$rome$$romejs$fs$index_ts$readFileText(packagePath);
          const json = await ___R$project$rome$$romejs$codec$json$index_ts$consumeJSON({input, path: packagePath});
          if (json.has(___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_PACKAGE_JSON_FIELD)) {
            return this.queueAddProject(dir, packagePath);
          }
        }
      }

      // If we didn't find a project config then check for incorrect config filenames
      for (const dir of parentDirectories) {
        for (const basename of ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_WARN_FILENAMES) {
          const path = dir.append(basename);

          if (await this.master.memoryFs.existsHard(path)) {
            this.warnIncorrectConfigFile(
              path,
              ___R$project$rome$$romejs$diagnostics$DiagnosticsProcessor_ts$default.createImmediateThrower(
                [
                  {
                    category: 'project-manager',
                    message: 'Find project',
                  },
                ],
              ),
            );
          }
        }
      }

      return undefined;
    }

    checkConfigFile(path, diagnostics) {
      if (___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_WARN_FILENAMES.includes(path.getBasename())) {
        this.warnIncorrectConfigFile(path, diagnostics);
      }
    }

    warnIncorrectConfigFile(path, diagnostics) {
      diagnostics.addDiagnostic(
        {
          category: 'projectManager/incorrectConfigFilename',
          filename: path.join(),
          message: 'Invalid rome config filename, <emphasis>' +
          ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_FILENAMES.join(
            ' or ',
          ) +
          '</emphasis> are the only valid filename',
        },
      );
    }
  }

  // project-rome/@romejs/core/common/utils/fork.ts
const ___R$$priv$project$rome$$romejs$core$common$utils$fork_ts$child = require(
    'child_process',
  );
  function ___R$project$rome$$romejs$core$common$utils$fork_ts$default(
    processType,
    opts,
  ) {
    return (
      ___R$$priv$project$rome$$romejs$core$common$utils$fork_ts$child.fork(
        ___R$project$rome$$romejs$core$common$constants_ts$BIN.join(),
        [],
        Object.assign(
          {
            stdio: 'inherit',
            execArgv: ___R$project$rome$$romejs$core$common$constants_ts$CHILD_ARGS,
          },
          opts,
          {
            env: Object.assign(
              {
              },
              process.env,
              {
                ROME_PROCESS_VERSION: ___R$project$rome$$romejs$core$common$constants_ts$VERSION,
                ROME_PROCESS_TYPE: processType,
              },
            ),
          },
        ),
      )
    );
  }

  // project-rome/@romejs/core/common/utils/Locker.ts
class ___R$$priv$project$rome$$romejs$core$common$utils$Locker_ts$Lock {
    constructor(locker, key) {
      this.locker = locker;
      this.resolves = [];
      this.key = key;
    }

    addResolve(resolve) {
      this.resolves.push(resolve);
    }

    release() {
      const {resolves} = this;

      if (resolves.length === 0) {
        this.locker.locks.delete(this.key);
      } else {
        const resolve = resolves.shift();
        if (resolve === undefined) {
          throw new Error('Already validated resolved.length aboved');
        }
        resolve(this);
      }
    }
  }

  class ___R$project$rome$$romejs$core$common$utils$Locker_ts$default {
    constructor() {
      this.locks = new Map();
    }

    hasLock(id) {
      return this.locks.has(id);
    }

    getNewLock(key) {
      if (this.locks.has(key)) {
        throw new Error('Expected no lock to exist');
      }

      const lock = new ___R$$priv$project$rome$$romejs$core$common$utils$Locker_ts$Lock(this, key);
      this.locks.set(key, lock);
      return lock;
    }

    async getLock(key) {
      const existingLock = this.locks.get(key);

      if (existingLock === undefined) {
        return this.getNewLock(key);
      } else {
        return (
          new Promise(
            (resolve) => {
              existingLock.addResolve(resolve);
            },
          )
        );
      }
    }

    async waitLock(key) {
      if (this.hasLock(key)) {
        const lock = await this.getLock(key);
        lock.release();
      }
    }
  }

  // project-rome/@romejs/core/master/WorkerManager.ts
const ___R$$priv$project$rome$$romejs$core$master$WorkerManager_ts$child = require(
    'child_process',
  );

  class ___R$project$rome$$romejs$core$master$WorkerManager_ts$default {
    constructor(master) {
      this.master = master;

      this.workerStartEvent =
        new ___R$project$rome$$romejs$events$Event_ts$default(
          {
            name: 'WorkerManager.workerStart',
            onError: master.onFatalErrorBound,
          },
        );
      this.selfWorker = true;
      this.locker = new ___R$project$rome$$romejs$core$common$utils$Locker_ts$default();
      this.workers = new Map();
      this.idCounter = 0;
    }

    getNextWorkerId() {
      return this.idCounter++;
    }

    getWorkerAssert(id) {
      const worker = this.workers.get(id);
      if (worker === undefined) {
        throw new Error('Expected worker');
      }
      return worker;
    }

    getWorkers() {
      return Array.from(this.workers.values());
    }

    // Get worker count, excluding ghost workers
    getWorkerCount() {
      let count = 0;
      for (const worker of this.workers.values()) {
        if (worker.ghost === false) {
          count++;
        }
      }
      return count;
    }

    // Get all the workers that live in external processes
    getExternalWorkers() {
      return this.getWorkers().filter((worker) => worker.process !== undefined);
    }

    end() {
      // Shutdown all workers, no need to clean up any internal data structures since they will never be used
      for (const {bridge} of this.workers.values()) {
        bridge.end();
      }
    }

    getLowestByteCountWorker() {
      // Find the worker with the lowest byteCount value
      let smallestWorker;
      let byteCount;
      for (const worker of this.workers.values()) {
        if (!worker.ghost &&
          (byteCount === undefined ||
          byteCount >
          worker.byteCount)) {
          smallestWorker = worker;
          byteCount = worker.byteCount;
        }
      }

      if (smallestWorker === undefined) {
        // This shouldn't be possible
        throw new Error('No worker found');
      } else {
        return smallestWorker;
      }
    }

    async init() {
      // Create the worker
      const bridge = ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromLocal(___R$project$rome$$romejs$core$common$bridges$WorkerBridge_ts$default, {});
      const worker = new ___R$project$rome$$romejs$core$worker$Worker_ts$default(
        {
          bridge,
          globalErrorHandlers: false,
        },
      );

      // We make an assumption elsewhere in the code that this is always the first worker

      // Let's use an invariant here for completeness
      const id = this.getNextWorkerId();
      if (id !== 0) {
        throw new Error('Expected master worker id to be 0');
      }

      const container = {
        id: 0,
        fileCount: 0,
        byteCount: 0,
        process: undefined,
        bridge,
        ghost: false,
        ready: false,
      };
      this.workers.set(0, container);
      await worker.init();

      await Promise.all([this.workerHandshake(container), bridge.handshake()]);

      this.workerStartEvent.send(bridge);
    }

    async replaceOwnWorker() {
      const lock = this.locker.getNewLock(0);

      try {
        const masterWorker = this.getWorkerAssert(0);
        this.master.logger.info(
          '[WorkerManager] Spawning first worker outside of master after exceeding ' +
          ___R$project$rome$$romejs$core$common$constants_ts$MAX_MASTER_BYTES_BEFORE_WORKERS +
          ' bytes',
        );
        this.selfWorker = false;

        // Spawn a new worker
        const newWorker = await this.spawnWorker(this.getNextWorkerId(), true);

        // End the old worker, will automatically cleanup
        masterWorker.bridge.end();

        // Swap the workers

        // We perform this as a single atomic operation rather than doing it in spawnWorker so we have predictable worker retrieval
        this.workers.set(
          0,
          {
            id: 0,
            fileCount: masterWorker.fileCount,
            byteCount: masterWorker.byteCount,
            bridge: newWorker.bridge,
            process: newWorker.process,
            ghost: false,
            ready: true,
          },
        );
        this.workers.delete(newWorker.id);
      } finally {
        lock.release();
      }
    }

    onNewProject(newProject) {
      this.master.projectManager.notifyWorkersOfProjects(
        this.getWorkers(),
        [
          newProject,
        ],
      );
    }

    async workerHandshake(worker) {
      const {bridge} = worker;
      await bridge.handshake({timeout: 3000});
      await this.master.projectManager.notifyWorkersOfProjects([worker]);
      worker.ready = true;
    }

    async spawnWorker(workerId, isGhost = false) {
      const lock = this.locker.getNewLock(workerId);
      try {
        return await this._spawnWorker(workerId, isGhost);
      } finally {
        lock.release();
      }
    }

    async _spawnWorker(workerId, isGhost) {
      const start = Date.now();

      const process = ___R$project$rome$$romejs$core$common$utils$fork_ts$default('worker');

      const bridge = ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromChildProcess(
        ___R$project$rome$$romejs$core$common$bridges$WorkerBridge_ts$default,
        process,
        {
          type: 'client',
          onSendMessage: (data) => {
            this.master.logger.info(
              '[WorkerManager] Sending worker request to %s:',
              workerId,
              data,
            );
          },
        },
      );

      const worker = {
        id: workerId,
        fileCount: 0,
        byteCount: 0,
        process,
        bridge,
        ghost: isGhost,
        ready: false,
      };
      this.workers.set(workerId, worker);

      process.once(
        'error',
        (err) => {
          // The process could not be spawned, or

          // The process could not be killed, or

          // Sending a message to the child process failed.
          this.master.onFatalError(err);
          process.kill();
        },
      );

      process.once(
        'exit',
        () => {
          //bridge.end(`Worker ${String(workerId)} died`);
          this.master.onFatalError(new Error('Worker ' +
          String(workerId) +
          ' died'));
        },
      );

      await this.workerHandshake(worker);

      // If a worker is spawned while we're profiling then make sure it's profiling too
      if (this.master.profiling !== undefined) {
        await bridge.profilingStart.call(this.master.profiling);
      }

      this.workerStartEvent.send(bridge);

      this.master.logger.info(
        '[WorkerManager] Worker %s started after %sms',
        workerId,
        Date.now() - start,
      );

      return worker;
    }

    own(workerId, stats) {
      const worker = this.getWorkerAssert(workerId);
      worker.byteCount += stats.size;
      worker.fileCount++;
    }

    disown(workerId, stats) {
      const worker = this.getWorkerAssert(workerId);
      worker.byteCount -= stats.size;
      worker.fileCount--;
    }

    async getNextWorker(path) {
      const {logger, memoryFs, fileAllocator} = this.master;

      // Get stats first
      const stats = memoryFs.getFileStats(path);
      if (stats === undefined) {
        throw new Error('The file ' +
        path.join() +
        ' doesn\'t exist');
      }

      // Verify that this file doesn't exceed any size limit
      fileAllocator.verifySize(path, stats);

      // Lock in case we're in the process of swapping the master worker with a dedicated worker
      await this.locker.waitLock(0);

      // If the worker is running in the master process and we've exceed our byte limit

      // then start up a dedicated worker process
      if (this.selfWorker) {
        const worker = this.getWorkerAssert(0);
        if (worker.byteCount > ___R$project$rome$$romejs$core$common$constants_ts$MAX_MASTER_BYTES_BEFORE_WORKERS) {
          await this.replaceOwnWorker();
        }
      }

      // Find the worker with the lowest owned byte size
      const smallestWorker = this.getLowestByteCountWorker();
      let workerId = smallestWorker.id;

      // When the smallest worker exceeds the max worker byte limit and we're still under

      // our max worker limit, then let's start a new one
      if (smallestWorker.byteCount > ___R$project$rome$$romejs$core$common$constants_ts$MAX_WORKER_BYTES_BEFORE_ADD &&
        this.getWorkerCount() < ___R$project$rome$$romejs$core$common$constants_ts$MAX_WORKER_COUNT) {
        logger.info(
          '[WorkerManager] Spawning a new worker as we\'ve exceeded ' +
          ___R$project$rome$$romejs$core$common$constants_ts$MAX_WORKER_BYTES_BEFORE_ADD +
          ' bytes across each worker',
        );
        workerId = this.getNextWorkerId();
        await this.spawnWorker(workerId);
      }

      // Register size of file
      this.own(workerId, stats);

      // Just in case we've chosen a worker that's still spawning
      await this.locker.waitLock(workerId);

      return this.getWorkerAssert(workerId);
    }
  }

  // project-rome/@romejs/core/common/types/platform.ts
const ___R$project$rome$$romejs$core$common$types$platform_ts = {
    get PLATFORMS() {
      return (
        ___R$project$rome$$romejs$core$common$types$platform_ts$PLATFORMS
      );
    },

    get PLATFORM_ALIASES() {
      return (
        ___R$project$rome$$romejs$core$common$types$platform_ts$PLATFORM_ALIASES
      );
    },
  };

  const ___R$project$rome$$romejs$core$common$types$platform_ts$PLATFORMS = [
    'ios',
    'android',
    'mobile',
    'electron',
    'web',
    'node',
  ];

  const ___R$project$rome$$romejs$core$common$types$platform_ts$PLATFORM_ALIASES = {
    ios: ['mobile'],
    android: ['mobile'],
    electron: ['web'],
    mobile: [],
    node: [],
    web: [],
  };

  // project-rome/@romejs/core/master/fs/resolverSuggest.ts
function ___R$project$rome$$romejs$core$master$fs$resolverSuggest_ts$default(
    resolver,
    query,
    resolved,

    origQuerySource,
  ) {
    let errMsg = '';
    if (resolved.type === 'UNSUPPORTED') {
      errMsg = 'Unsupported path format';
    } else if (resolved.type === 'MISSING') {
      errMsg = 'Cannot find';
    } else if (resolved.type === 'FETCH_ERROR') {
      errMsg = 'Failed to fetch';
    }

    errMsg += ' "' +
    query.source.join() +
    '" from "' +
    query.origin.join() +
    '"';

    // Use the querySource returned by the resolution which will be the one that actually triggered this error, otherwise use the query source provided to us
    const querySource = resolved.source === undefined
      ? origQuerySource : resolved.source;
    if (querySource === undefined || querySource.pointer === undefined) {
      // TODO do something about the `advice` on some `resolved` that may contain metadata?
      throw new Error(errMsg);
    }

    const {pointer} = querySource;

    let advice = [];

    if (query.origin.isAbsolute()) {
      const localQuery = Object.assign(
        {
        },
        query,
        {
          origin: query.origin.assertAbsolute(),
        },
      );

      // Provide advice in strict-mode if a non-strict version existed
      if (query.strict) {
        const nonStrictResolved = resolver.resolveLocal(
          Object.assign(
            {
            },
            localQuery,
            {
              strict: false,
            },
          ),
        );

        if (nonStrictResolved.type === 'FOUND') {
          if (nonStrictResolved.types.includes('implicitIndex')) {
            advice.push(
              {
                type: 'log',
                category: 'info',
                message: 'This successfully resolves as an implicit index file. Trying adding <emphasis>/index' +
                nonStrictResolved.path.getExtensions() +
                '</emphasis> to the end of the import source',
              },
            );
          } else if (nonStrictResolved.types.includes('implicitExtension')) {
            advice.push(
              {
                type: 'log',
                category: 'info',
                message: 'This successfully resolves as an implicit extension. Try adding the extension <emphasis>' +
                nonStrictResolved.path.getExtensions() +
                '</emphasis>',
              },
            );
          }
        }
      }

      // We may set this to `true` for stuff like forgetting a platform
      let skipSimilaritySuggestions = false;

      // Try other platforms
      const validPlatforms = [];
      for (const PLATFORM of ___R$project$rome$$romejs$core$common$types$platform_ts$PLATFORMS) {
        if (PLATFORM === query.platform) {
          continue;
        }

        const resolved = resolver.resolveLocal(
          Object.assign(
            {
            },
            localQuery,
            {
              platform: PLATFORM,
            },
          ),
        );

        if (resolved.type === 'FOUND') {
          validPlatforms.push(
            '<emphasis>' +
            PLATFORM +
            '</emphasis> at <filelink emphasis target="' +
            resolved.ref.uid +
            '" />',
          );
        }
      }
      if (validPlatforms.length > 0) {
        if (query.platform === undefined) {
          advice.push(
            {
              type: 'log',
              category: 'info',
              message: 'No platform was specified but we found modules for the following platforms',
            },
          );
        } else {
          advice.push(
            {
              type: 'log',
              category: 'info',
              message: 'No module found for the platform <emphasis>' +
              query.platform +
              '</emphasis> but we found these others',
            },
          );
        }

        skipSimilaritySuggestions = true;

        advice.push(
          {
            type: 'list',
            list: validPlatforms,
          },
        );
      }

      // Hint on any indirection
      if (origQuerySource !== undefined && origQuerySource.pointer !== undefined &&
        resolved.source !== undefined) {
        advice.push(
          {
            type: 'log',
            category: 'info',
            message: 'Found while resolving <emphasis>' +
            query.source +
            '</emphasis> from <filelink emphasis target="' +
            query.origin +
            '" />',
          },
        );

        const origPointer = origQuerySource.pointer;

        advice.push(
          Object.assign(
            {
              type: 'frame',
            },
            origPointer,
          ),
        );
      }

      // Suggestions based on similarity to paths and packages on disk
      if (!skipSimilaritySuggestions) {
        const suggestions = ___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$getSuggestions(resolver, localQuery);
        if (suggestions.size > 0) {
          const originFolder = resolver.getOriginFolder(localQuery);

          // Relative paths to absolute
          const relativeToAbsolute = new Map();

          const relativeSuggestions = Array.from(
            suggestions,
            ([human, absolute]) => {
              if (human !== absolute) {
                relativeToAbsolute.set(human, absolute);
                return human;
              }

              let relativePath = originFolder.relative(absolute);

              // If the user didn't use extensions, then neither should we
              if (!query.source.hasExtensions()) {
                // TODO only do this if it's an implicit extension
                relativePath =
                  relativePath.changeBasename(
                    relativePath.getExtensionlessBasename(),
                  );
              }

              const relativeStr = relativePath.toExplicitRelative().join();
              relativeToAbsolute.set(relativeStr, absolute);
              return relativeStr;
            },
          );

          advice =
            [
              ...advice,
              ...___R$project$rome$$romejs$diagnostics$helpers_ts$buildSuggestionAdvice(
                query.source.join(),
                relativeSuggestions,
                {
                  formatItem: (relative) => {
                    const absolute = relativeToAbsolute.get(relative);
                    if (absolute === undefined) {
                      throw new Error('Should be valid');
                    }

                    return '<filelink target="' +
                    absolute +
                    '">' +
                    relative +
                    '</filelink>';
                  },
                },
              ),
            ];
        }
      }

      // Hint if this was an entry resolve and the cwd wasn't a project
      if (query.entry === true &&
        resolver.master.projectManager.findProjectExisting(localQuery.origin) ===
        undefined) {
        advice.push(
          {
            type: 'log',
            category: 'warn',
            message: 'You aren\'t in a Rome project',
          },
        );
      }
    }

    // TODO check if this would have been successful if not for exports access control
    const source = querySource.source === undefined
      ? query.source.join() : querySource.source;
    let message = '';
    let category = 'resolver/notFound';

    if (resolved.type === 'UNSUPPORTED') {
      message = 'Unsupported';
      category = 'resolver/unsupported';
    } else if (resolved.type === 'MISSING') {
      message = 'Cannot find';
    } else if (resolved.type === 'FETCH_ERROR') {
      message = 'Failed to fetch';
      category = 'resolver/fetchFailed';
    }

    if (resolved.advice !== undefined) {
      advice = advice.concat(resolved.advice);
    }

    message +=
      ' <emphasis>' +
      source +
      '</emphasis> from <filelink emphasis target="' +
      pointer.filename +
      '" />';

    throw (
      ___R$project$rome$$romejs$diagnostics$errors_ts$createSingleDiagnosticError(
        Object.assign(
          {
          },
          pointer,
          {
            category,
            message,
            advice,
          },
        ),
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$getPathSuggestions(
    resolver,
    query,
  ) {
    const {source} = query;
    const originFolder = resolver.getOriginFolder(query);
    const suggestions = new Map();

    // Try normal resolved
    ___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$tryPathSuggestions(resolver, suggestions, originFolder.resolve(source));

    // Remove . and .. entries from beginning
    const sourceParts = [...source.getSegments()];
    while (sourceParts[0] === '.' || sourceParts[0] === '..') {
      sourceParts.shift();
    }

    // Try parent directories of the origin
    for (const path of originFolder.getChain()) {
      ___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$tryPathSuggestions(resolver, suggestions, path.append(sourceParts));
    }

    return suggestions;
  }

  const ___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$MIN_SIMILARITY = 0.8;

  function ___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$tryPathSuggestions(
    resolver,
    suggestions,
    path,
  ) {
    const {memoryFs} = resolver.master;

    const segments = path.getSegments();
    const chain = path.getChain();

    // Get all segments that are unknown
    for (let i = chain.length - 1;
    i >= 0;
    i--) {
      const path = chain[i];

      if (memoryFs.exists(path)) {
        // If this is an absolute match then we should be a suggestion
        if (i === chain.length) {
          const filename = path.join();
          suggestions.set(filename, filename);
        }

        // Otherwise this segment exists and should have been dealt with previously in the loop
        break;
      }

      const parentPath = path.getParent();

      // Our basename isn't valid, but our parent exists
      if (!memoryFs.exists(path) && memoryFs.exists(parentPath)) {
        const entries = Array.from(
          memoryFs.readdir(parentPath),
          (
            path,
          ) =>
            path.join(),
        );
        if (entries.length === 0) {
          continue;
        }

        const ratings = ___R$project$rome$$romejs$string$utils$orderBySimilarity_ts$orderBySimilarity(
          path.getExtensionlessBasename(),
          entries,
          {
            minRating: ___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$MIN_SIMILARITY,
            formatItem: (target) => {
              return ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(target).getExtensionlessBasename();
            },
          },
        );

        for (const rating of ratings) {
          ___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$tryPathSuggestions(
            resolver,
            suggestions,
            ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
              rating.target,
            ).append(
              segments.slice(1),
            ).assertAbsolute(),
          );
        }
      }
    }
  }

  function ___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$getPackageSuggestions(
    resolver,
    query,
  ) {
    const possibleGlobalPackages = new Map();

    const mainProject = resolver.master.projectManager.findProjectExisting(
      query.origin,
    );
    if (mainProject !== undefined) {
      const projects = resolver.master.projectManager.getHierarchyFromProject(
        mainProject,
      );

      for (const project of projects) {
        for (const [name, value] of project.hasteMap) {
          possibleGlobalPackages.set(name, value.join());
        }

        for (const [name, value] of project.packages) {
          possibleGlobalPackages.set(name, value.folder.join());
        }
      }
    }

    // TODO Add node_modules
    const matches = ___R$project$rome$$romejs$string$utils$orderBySimilarity_ts$orderBySimilarity(
      query.source.join(),
      Array.from(possibleGlobalPackages.keys()),
      {minRating: ___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$MIN_SIMILARITY},
    ).map(
      (item) => {
        const name = item.target;

        const absolute = possibleGlobalPackages.get(name);
        if (absolute === undefined) {
          throw new Error('Should exist');
        }

        return [name, absolute];
      },
    );
    return new Map(matches);
  }

  function ___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$getSuggestions(
    resolver,
    query,
  ) {
    if (query.entry === true) {
      return (
        new Map(
          [
            ...___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$getPathSuggestions(resolver, query),
            ...___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$getPackageSuggestions(resolver, query),
          ],
        )
      );
    } else if (___R$project$rome$$romejs$core$master$fs$Resolver_ts$isPathLike(query.source)) {
      return ___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$getPathSuggestions(resolver, query);
    } else {
      return ___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$getPackageSuggestions(resolver, query);
    }
  }

  // project-rome/@romejs/core/master/fs/Resolver.ts
const ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$https = require(
    'https',
  );
  function ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$request(
    url,
  ) {
    return (
      new Promise(
        (resolve) => {
          const req = ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$https.get(
            url,
            (res) => {
              if (res.statusCode !== 200) {
                console.log('non-200 return');
                resolve(
                  {
                    type: 'FETCH_ERROR',
                    source: undefined,
                    advice: [
                      {
                        type: 'log',
                        category: 'info',
                        message: '<hyperlink target="' +
                        url +
                        '" /> returned a ' +
                        res.statusCode +
                        ' status code',
                      },
                    ],
                  },
                );
                return;
              }

              let data = '';

              res.on(
                'data',
                (chunk) => {
                  data += chunk;
                },
              );

              res.on(
                'end',
                () => {
                  resolve({type: 'DOWNLOADED', content: data});
                },
              );
            },
          );

          req.on(
            'error',
            (err) => {
              resolve(
                {
                  type: 'FETCH_ERROR',
                  source: undefined,
                  advice: [
                    {
                      type: 'log',
                      category: 'info',
                      message: '<hyperlink target="' +
                      url +
                      '" /> resulted in the error "' +
                      err.message +
                      '"',
                    },
                  ],
                },
              );
            },
          );
        },
      )
    );
  }

  const ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$NODE_MODULES = 'node_modules';

  const ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING = {
    type: 'MISSING',
    source: undefined,
  };

  function ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$shouldReturnQueryResponse(res) {
    return res.type === 'FOUND' || res.source !== undefined;
  }

  function ___R$project$rome$$romejs$core$master$fs$Resolver_ts$isPathLike(source) {
    return source.isAbsolute() || source.isExplicitRelative();
  }

  function ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$appendTypeQueryResponse(
    res,
    types,
  ) {
    if (res.type === 'FOUND') {
      return (
        Object.assign(
          {
          },
          res,
          {
            types: [...res.types, ...types],
          },
        )
      );
    } else {
      return res;
    }
  }

  function ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$attachExportAliasIfUnresolved(
    res,
    alias,
  ) {
    if (res.type === 'FOUND') {
      return res;
    }

    const pointer = alias.key.getDiagnosticPointer('value');

    return (
      Object.assign(
        {
        },
        res,
        {
          source: pointer === undefined
            ? undefined : {
              pointer,
              source: alias.value.join(),
            },
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$getExportsAlias(
    {
      manifest,
      relative,
      platform,
    },
  ) {
    if (typeof manifest.exports === 'boolean') {
      return;
    }

    if (platform === undefined) {
      return;
    }

    if (!relative.isRelative()) {
      return;
    }

    const aliases = manifest.exports.get(relative.assertRelative());
    if (aliases === undefined) {
      return;
    }

    const alias = aliases.get(platform);
    if (alias !== undefined) {
      return (
        {
          key: alias.consumer,
          value: alias.relative,
        }
      );
    }

    const def = aliases.get('default');
    if (def !== undefined) {
      return (
        {
          key: def.consumer,
          value: def.relative,
        }
      );
    }

    // TODO check for folder aliases
  }

  function ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$getPreferredMainKey(
    consumer,
    manifest,
    platform,
  ) {
    const alias = ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$getExportsAlias(
      {
        manifest,
        relative: ___R$project$rome$$romejs$path$index_ts$createRelativeFilePath('.'),
        platform,
      },
    );
    if (alias !== undefined) {
      return alias;
    }

    if (manifest.main !== undefined) {
      return (
        {
          key: consumer.get('main'),
          value: ___R$project$rome$$romejs$path$index_ts$createRelativeFilePath(manifest.main),
        }
      );
    }
  }

  class ___R$project$rome$$romejs$core$master$fs$Resolver_ts$default {
    constructor(master) {
      this.master = master;
    }

    init() {}

    async findProjectFromQuery(query) {
      // If we were passed an absolute path then we should find and add the project it belongs to
      if (query.source.isAbsolute()) {
        await this.master.projectManager.findProject(query.source.assertAbsolute());
      } else if (query.origin.isAbsolute()) {
        const origin = query.origin.assertAbsolute();
        await this.master.projectManager.findProject(origin);
        await this.master.projectManager.findProject(
          origin.append(
            query.source.assertRelative(),
          ),
        );
      }
    }

    async resolveEntryAssert(query, querySource) {
      await this.findProjectFromQuery(query);
      return this.resolveAssert(Object.assign(
        {
        },
        query,
        {
          entry: true,
        },
      ), querySource);
    }

    // I found myself wanting only `ref.path` a lot so this is just a helper method
    async resolveEntryAssertPath(query, querySource) {
      const res = await this.resolveEntryAssert(query, querySource);
      return res.path;
    }

    async resolveEntry(query) {
      await this.findProjectFromQuery(query);
      return this.resolveRemote(Object.assign(
        {
        },
        query,
        {
          entry: true,
        },
      ));
    }

    async resolveAssert(query, origQuerySource) {
      const resolved = await this.resolveRemote(query);
      if (resolved.type === 'FOUND') {
        return resolved;
      } else {
        throw ___R$project$rome$$romejs$core$master$fs$resolverSuggest_ts$default(this, query, resolved, origQuerySource);
      }
    }

    async resolveRemote(query) {
      const {origin, source} = query;

      if (source.isURL()) {
        const sourceURL = source.assertURL();
        const protocol = sourceURL.getProtocol();

        switch (protocol) {
          case 'http':
          case 'https':
            {
              let projectConfig = ___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG;

              if (origin.isAbsolute()) {
                const project = this.master.projectManager.findProjectExisting(
                  query.origin.assertAbsolute(),
                );
                if (project !== undefined) {
                  projectConfig = project.config;
                }
              }

              const remotePath = projectConfig.files.vendorPath.append(
                source.join().replace(/[\/:]/g, '$').replace(/\$+/g, '$'),
              );

              if (!this.master.memoryFs.exists(remotePath)) {
                const result = await ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$request(source.join());
                if (result.type === 'DOWNLOADED') {
                  await ___R$project$rome$$romejs$fs$index_ts$writeFile(remotePath, result.content);
                } else {
                  return result;
                }
              }

              return (
                {
                  type: 'FOUND',
                  types: [],
                  ref: this.master.projectManager.getURLFileReference(
                    remotePath,
                    sourceURL,
                  ),
                  path: remotePath,
                }
              );
            }

          default:
            return (
              {
                type: 'UNSUPPORTED',
                source: undefined,
                advice: [
                  {
                    type: 'log',
                    category: 'info',
                    message: '<emphasis>' +
                    protocol +
                    '</emphasis> is not a supported remote protocol',
                  },
                ],
              }
            );
        }
      }

      if (origin.isURL()) {
        if (source.isAbsolute() || source.isExplicitRelative()) {
          // Relative to the origin
          return (
            this.resolveRemote(
              Object.assign(
                {
                },
                query,
                {
                  source: origin.resolve(source),
                },
              ),
            )
          );
        } else {
          // TODO add support for import maps
          return (
            {
              type: 'MISSING',
              source: undefined,
            }
          );
        }
      }

      return (
        this.resolveLocal(
          Object.assign(
            {
            },
            query,
            {
              origin: query.origin.assertAbsolute(),
            },
          ),
        )
      );
    }

    resolveLocal(query) {
      // Do some basic checks to determine if this is an absolute or relative path
      if (___R$project$rome$$romejs$core$master$fs$Resolver_ts$isPathLike(query.source)) {
        return this.resolvePath(query);
      }

      // Now resolve it as a module
      const resolved = this.resolveModule(query);

      // If we didn't resolve to a module, and we were asked to resolve relative, then do that
      if (resolved.type === 'MISSING' && query.entry === true) {
        return this.resolvePath(query);
      }

      return resolved;
    }

    *getFilenameVariants(query, path) {
      const seen = new Set();
      for (const variant of this._getFilenameVariants(query, path, [])) {
        const filename = variant.path.join();
        if (seen.has(filename)) {
          continue;
        }

        seen.add(filename);
        yield variant;
      }
    }

    *_getFilenameVariants(query, path, callees) {
      const {platform} = query;

      yield {path, types: callees};

      //
      const {handler} = this.master.projectManager.getHandlerWithProject(
        path.isAbsolute() ? path.assertAbsolute() : query.origin,
      );
      const usesUnknownExtension = !query.strict && handler === undefined;

      // Check with appended `platform`
      if (platform !== undefined && !callees.includes('implicitPlatform')) {
        yield* this._getFilenameVariants(
          query,
          path.addExtension('.' +
          platform),
          [...callees, 'implicitPlatform'],
        );

        // Check if this platform has any subplatforms
        const platformAliases = ___R$project$rome$$romejs$core$common$types$platform_ts$PLATFORM_ALIASES[platform];
        if (platformAliases !== undefined) {
          for (const platform of platformAliases) {
            yield* this._getFilenameVariants(
              query,
              path.addExtension(
                '.' +
                platform,
                true,
              ),
              [...callees, 'implicitPlatform'],
            );
          }
        }
      }

      // Check with appended extensions
      if (usesUnknownExtension && !callees.includes('implicitExtension')) {
        for (const ext of ___R$project$rome$$romejs$core$common$fileHandlers_ts$IMPLICIT_JS_EXTENSIONS) {
          yield* this._getFilenameVariants(
            query,
            path.addExtension('.' +
            ext),
            [
              ...callees,
              'implicitExtension',
            ],
          );
        }
      }

      // Check with appended `scale`, other.filename
      if (handler !== undefined && handler.canHaveScale === true &&
        !callees.includes('implicitScale')) {
        const scale = query.scale === undefined ? 3 : query.scale;
        for (let i = scale;
        i >= 1;
        i--) {
          yield* this._getFilenameVariants(
            query,
            path.changeBasename(
              path.getExtensionlessBasename() +
              '@' +
              String(i) +
              'x' +
              path.memoizedExtension,
            ),
            [...callees, 'implicitScale'],
          );
        }
      }
    }

    finishResolverQueryResponse(path, types) {
      return (
        {
          type: 'FOUND',
          types: types === undefined ? [] : types,
          ref: this.master.projectManager.getFileReference(path),
          path,
        }
      );
    }

    getOriginFolder(query) {
      const {memoryFs} = this.master;
      const {origin} = query;

      if (memoryFs.isFile(origin)) {
        return origin.getParent();
      } else {
        return origin;
      }
    }

    resolvePath(query, checkVariants = true, types) {
      const {memoryFs} = this.master;

      // Resolve the path heiarchy
      const originFolder = this.getOriginFolder(query);
      const resolvedOrigin = originFolder.resolve(query.source);

      // Check if this is an absolute filename
      if (memoryFs.isFile(resolvedOrigin)) {
        // If we're querying a package then we should never return a file
        if (query.requestedType === 'package') {
          return ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
        }

        return this.finishResolverQueryResponse(resolvedOrigin, types);
      }

      // Check variants
      if (checkVariants) {
        for (const variant of this.getFilenameVariants(query, resolvedOrigin)) {
          if (variant.path.equal(resolvedOrigin)) {
            continue;
          }

          const resolved = this.resolvePath(
            Object.assign(
              {
              },
              query,
              {
                source: variant.path,
              },
            ),
            false,
            variant.types,
          );

          if (___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$shouldReturnQueryResponse(resolved)) {
            return ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$appendTypeQueryResponse(resolved, variant.types);
          }
        }
      }

      // check if this is a folder
      if (memoryFs.isDirectory(resolvedOrigin)) {
        if (query.requestedType === 'folder') {
          return this.finishResolverQueryResponse(resolvedOrigin, types);
        }

        // If this has a package.json then follow the `main` field
        const manifestDef = memoryFs.getManifestDefinition(resolvedOrigin);
        if (manifestDef !== undefined) {
          // If we're resolving a package then don't follow this
          if (query.requestedType === 'package') {
            return this.finishResolverQueryResponse(resolvedOrigin, types);
          }

          const main = ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$getPreferredMainKey(
            manifestDef.consumer,
            manifestDef.manifest,
            query.platform,
          );
          if (main !== undefined) {
            const resolved = this.resolvePath(
              Object.assign(
                {
                },
                query,
                {
                  origin: resolvedOrigin,
                  source: main.value,
                },
              ),
              true,
              ['package'],
            );

            return ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$attachExportAliasIfUnresolved(resolved, main);
          }
        }

        if (!query.strict) {
          // Check if it has an index.* file
          for (const ext of ___R$project$rome$$romejs$core$common$fileHandlers_ts$IMPLICIT_JS_EXTENSIONS) {
            const indexResolved = this.resolvePath(
              Object.assign(
                {
                },
                query,
                {
                  source: resolvedOrigin.append('index.' +
                  ext),
                },
              ),
              true,
              ['implicitIndex'],
            );

            if (___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$shouldReturnQueryResponse(indexResolved)) {
              return indexResolved;
            }
          }
        }
      }

      return ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
    }

    resolvePackageFolder(query, moduleName) {
      // Find the project
      const project = this.master.projectManager.findProjectExisting(query.origin);
      if (project === undefined) {
        return;
      }

      // Find the package
      const projects = this.master.projectManager.getHierarchyFromProject(project);

      for (const project of projects) {
        const pkg = project.packages.get(moduleName);
        if (pkg !== undefined) {
          return pkg;
        }
      }
    }

    resolvePackage(query, moduleName, moduleNameParts) {
      const manifestDef = this.resolvePackageFolder(query, moduleName);
      return this.resolveManifest(query, manifestDef, moduleNameParts);
    }

    resolveManifest(query, manifestDef, moduleNameParts) {
      if (manifestDef === undefined) {
        return ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
      }

      if (moduleNameParts.length > 0) {
        // Submodules of this package are private
        if (manifestDef.manifest.exports === false) {
          return ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
        }

        // Check if we're allowed to touch this submodule
        if (manifestDef.manifest.exports !== true) {
          const alias = ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$getExportsAlias(
            {
              manifest: manifestDef.manifest,
              relative: ___R$project$rome$$romejs$path$index_ts$createFilePathFromSegments(moduleNameParts),
              platform: query.platform,
            },
          );

          if (alias === undefined) {
            // No submodule found
            return ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
          }

          // Alias found!
          const resolved = this.resolvePath(
            Object.assign(
              {
              },
              query,
              {
                source: manifestDef.folder.append(alias.value),
              },
            ),
            true,
            ['package'],
          );
          return ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$attachExportAliasIfUnresolved(resolved, alias);
        }
      }

      // All exports are enabled or we are importing the root
      return (
        this.resolvePath(
          Object.assign(
            {
            },
            query,
            {
              source: manifestDef.folder.append(moduleNameParts),
            },
          ),
          true,
          ['package'],
        )
      );
    }

    resolveMock(query, project, parentDirectories) {
      if (project === undefined) {
        return ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
      }

      const moduleName = query.source.assertRelative();

      for (const dir of parentDirectories) {
        const mocksDir = dir.append(___R$project$rome$$romejs$core$common$constants_ts$MOCKS_FOLDER_NAME);

        // No use resolving against a directory that doesn't exist
        if (!this.master.memoryFs.exists(mocksDir)) {
          continue;
        }

        const resolved = this.resolveLocal(
          Object.assign(
            {
            },
            query,
            {
              source: mocksDir.append(moduleName),
            },
          ),
        );

        if (___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$shouldReturnQueryResponse(resolved)) {
          return ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$appendTypeQueryResponse(resolved, ['mock']);
        }
      }

      return ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
    }

    resolveHaste(query, mainProject, moduleName, moduleNameParts) {
      const projects = this.master.projectManager.getHierarchyFromProject(
        mainProject,
      );

      for (const project of projects) {
        // Check for an entry for the direct name, in the case we're given something like react-relay/modern/ReactRelayQueryFetcher we'll resolve react-relay then resolve from it with the rest of the path
        const resolved = project.hasteMap.get(moduleName);
        if (resolved !== undefined) {
          if (moduleNameParts.length === 0) {
            return this.finishResolverQueryResponse(resolved, ['haste']);
          } else {
            return (
              this.resolvePath(
                Object.assign(
                  {
                  },
                  query,
                  {
                    source: resolved.append(moduleNameParts),
                  },
                ),
                true,
                ['haste'],
              )
            );
          }
        }

        // Check all filename variants, we use the full module path here so using the parts separately isn't necessary
        for (const {path} of this.getFilenameVariants(query, query.source)) {
          const resolved = project.hasteMap.get(path.join());
          if (resolved !== undefined) {
            return this.finishResolverQueryResponse(resolved, ['haste']);
          }
        }
      }

      return ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
    }

    // Given a reference to a module, extract the module name and any trailing relative paths
    splitModuleName(path) {
      // fetch the first part of the path as that's the module name

      // possible values of `moduleNameFull` could be `react` or `react/lib/whatever`
      const [moduleName, ...moduleNameParts] = path.getSegments();

      // For scoped modules in the form of `@romejs/bar`, make sure we keep the `/bar` on the module name
      if (moduleName[0] === '@' && moduleNameParts.length > 0) {
        return [moduleName +
        '/' +
        moduleNameParts.shift(), moduleNameParts];
      }

      return [moduleName, moduleNameParts];
    }

    resolveModule(query) {
      const {origin, source} = query;

      // get project for the origin
      const project = this.master.projectManager.findProjectExisting(origin);

      // get all the parent directories for when we crawl up
      const parentDirectories = this.getOriginFolder(query).getChain();

      // if mocks are enabled for this query then check all parent mocks folder
      if (query.mocks === true) {
        const mockResolved = this.resolveMock(query, project, parentDirectories);
        if (___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$shouldReturnQueryResponse(mockResolved)) {
          return mockResolved;
        }
      }

      // Extract the module name and it's relative file parts
      const [moduleName, moduleNameParts] = this.splitModuleName(source);

      // Check the haste map
      if (project !== undefined && project.hasteMap.size > 0) {
        const hasteResolved = this.resolveHaste(
          query,
          project,
          moduleName,
          moduleNameParts,
        );
        if (___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$shouldReturnQueryResponse(hasteResolved)) {
          return hasteResolved;
        }
      }

      // Check if it matches any of our project packages
      const packageResolved = this.resolvePackage(
        query,
        moduleName,
        moduleNameParts,
      );
      if (___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$shouldReturnQueryResponse(packageResolved)) {
        return packageResolved;
      }

      // Check all parent directories for node_modules
      for (const dir of parentDirectories) {
        const modulePath = dir.append(___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$NODE_MODULES).append(moduleName);
        const manifestDef = this.master.memoryFs.getManifestDefinition(modulePath);
        if (manifestDef !== undefined) {
          return this.resolveManifest(query, manifestDef, moduleNameParts);
        }
      }

      return ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
    }
  }

  // project-rome/@romejs/core/master/fs/FileAllocator.ts
class ___R$project$rome$$romejs$core$master$fs$FileAllocator_ts$default {
    constructor(master) {
      this.master = master;
      this.fileToWorker = new Map();
      this.locker = new ___R$project$rome$$romejs$core$common$utils$Locker_ts$default();
    }

    init() {
      this.master.memoryFs.deletedFileEvent.subscribe(
        (path) => {
          return this.handleDeleted(path);
        },
      );

      this.master.memoryFs.changedFileEvent.subscribe(
        ({path, oldStats, newStats}) => {
          return this.handleChange(path, oldStats, newStats);
        },
      );
    }

    getAllOwnedFilenames() {
      return Array.from(this.fileToWorker.keys());
    }

    hasOwner(path) {
      return this.getOwnerId(path) !== undefined;
    }

    getOwnerId(path) {
      return this.fileToWorker.get(path.join());
    }

    verifySize(path, stats) {
      const project = this.master.projectManager.assertProjectExisting(path);
      const maxSize = project.config.files.maxSize;

      if (stats.size > maxSize) {
        throw (
          new Error(
            'The file ' +
            path.join() +
            ' exceeds the project config max size of ' +
            maxSize +
            ' bytes',
          )
        );
      }
    }

    getOwnerAssert(path) {
      const {workerManager} = this.master;
      const workerId = this.getOwnerId(path);
      if (workerId === undefined) {
        throw new Error('No worker found for ' +
        path);
      }

      const worker = workerManager.getWorkerAssert(workerId);
      if (!worker.ready) {
        throw new Error('Worker ' +
        workerId +
        ' isn\'t ready');
      }
      return worker;
    }

    async getOrAssignOwner(path) {
      const {workerManager} = this.master;

      const workerId = this.getOwnerId(path);
      if (workerId === undefined) {
        return this.assignOwner(path);
      } else {
        await workerManager.locker.waitLock(workerId);
        return workerManager.getWorkerAssert(workerId);
      }
    }

    async groupPathsByWorker(paths) {
      const pathsByWorker = new Map();

      // Populate our queues
      await Promise.all(
        Array.from(
          paths,
          async (path) => {
            const worker = await this.getOrAssignOwner(path);

            let queue = pathsByWorker.get(worker.id);
            if (queue === undefined) {
              queue = [];
              pathsByWorker.set(worker.id, queue);
            }
            queue.push(path);
          },
        ),
      );

      return Array.from(pathsByWorker.values());
    }

    async evict(path) {
      // Find owner
      const workerId = this.getOwnerId(path);
      if (workerId === undefined) {
        return;
      }

      // Notify the worker to remove it from 'it's cache
      const filename = path.join();
      const worker = this.master.workerManager.getWorkerAssert(workerId);
      await worker.bridge.evict.call(
        {
          filename,
        },
      );

      this.master.logger.info('[FileAllocator] Evicted %s', filename);
    }

    async handleDeleted(path) {
      // Find owner
      const workerId = this.getOwnerId(path);
      if (workerId === undefined) {
        return;
      }

      // Evict file from 'worker cache
      await this.evict(path);

      // Disown it from 'our internal map
      this.fileToWorker.delete(path.join());

      // Remove the total size from 'this worker so it'll be assigned next
      const stats = this.master.memoryFs.getFileStatsAssert(path);
      this.master.workerManager.disown(workerId, stats);
    }

    async handleChange(path, oldStats, newStats) {
      const filename = path.join();
      const {logger, workerManager} = this.master;

      // Send update to worker owner
      if (this.hasOwner(path)) {
        // Get the worker
        const workerId = this.getOwnerId(path);
        if (workerId === undefined) {
          throw new Error('Expected worker id for ' +
          filename);
        }

        // Evict the file from 'cache
        await this.evict(path);

        // Verify that this file doesn't exceed any size limit
        this.verifySize(path, newStats);

        // Add on the new size, and remove the old
        if (oldStats === undefined) {
          throw (
            new Error(
              'File already has an owner so expected to have old stats but had none',
            )
          );
        }
        workerManager.disown(workerId, oldStats);
        workerManager.own(workerId, newStats);
      } else if (await this.master.projectManager.maybeEvictPossibleConfig(path)) {
        logger.info(
          '[FileAllocator] Evicted the project belonging to config %s',
          filename,
        );
      } else {
        logger.info('[FileAllocator] No owner for eviction %s', filename);
      }
    }

    async assignOwner(path) {
      const {workerManager, logger} = this.master;

      const filename = path.join();
      const lock = await this.locker.getLock(filename);

      // We may have waited on the lock and could already have an owner
      if (this.hasOwner(path)) {
        lock.release();
        return this.getOwnerAssert(path);
      }

      const worker = await workerManager.getNextWorker(path);

      // Add ourselves to the file map
      logger.info(
        '[FileAllocator] File %s assigned to worker %s',
        filename,
        worker.id,
      );
      this.fileToWorker.set(filename, worker.id);

      // Release and continue
      lock.release();

      return worker;
    }
  }

  // project-rome/@romejs/core/common/utils/Logger.ts
class ___R$project$rome$$romejs$core$common$utils$Logger_ts$default extends ___R$project$rome$$romejs$cli$reporter$Reporter_ts$default {
    constructor(name, isEnabled, opts) {
      super(
        Object.assign(
          {
            verbose: true,
          },
          opts,
        ),
      );
      this._loggerName = name;
      this.isEnabled = isEnabled;
    }

    getMessagePrefix(stream) {
      if (stream.format === 'none') {
        return '[' +
        this._loggerName +
        ' ' +
        process.pid +
        '] ';
      } else {
        return '<dim>[' +
        this._loggerName +
        ' ' +
        process.pid +
        ']</dim> ';
      }
    }
  }

  // project-rome/@romejs/codec-spdx-license/data.ts
const ___R$project$rome$$romejs$codec$spdx$license$data_ts$default = {
    licenseListVersion: '3.8-4-gd79c632',
    licenses: [
      {
        reference: './0BSD.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/0BSD.json',
        referenceNumber: '231',
        name: 'BSD Zero Clause License',
        licenseId: '0BSD',
        seeAlso: ['http://landley.net/toybox/license.html'],
        isOsiApproved: true,
      },
      {
        reference: './AAL.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/AAL.json',
        referenceNumber: '57',
        name: 'Attribution Assurance License',
        licenseId: 'AAL',
        seeAlso: ['https://opensource.org/licenses/attribution'],
        isOsiApproved: true,
      },
      {
        reference: './ADSL.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/ADSL.json',
        referenceNumber: '210',
        name: 'Amazon Digital Services License',
        licenseId: 'ADSL',
        seeAlso: [
          'https://fedoraproject.org/wiki/Licensing/AmazonDigitalServicesLicense',
        ],
        isOsiApproved: false,
      },
      {
        reference: './AFL-1.1.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/AFL-1.1.json',
        referenceNumber: '28',
        name: 'Academic Free License v1.1',
        licenseId: 'AFL-1.1',
        seeAlso: [
          'http://opensource.linux-mirror.org/licenses/afl-1.1.txt',
          'http://wayback.archive.org/web/20021004124254/http://www.opensource.org/licenses/academic.php',
        ],
        isOsiApproved: true,
      },
      {
        reference: './AFL-1.2.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/AFL-1.2.json',
        referenceNumber: '215',
        name: 'Academic Free License v1.2',
        licenseId: 'AFL-1.2',
        seeAlso: [
          'http://opensource.linux-mirror.org/licenses/afl-1.2.txt',
          'http://wayback.archive.org/web/20021204204652/http://www.opensource.org/licenses/academic.php',
        ],
        isOsiApproved: true,
      },
      {
        reference: './AFL-2.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/AFL-2.0.json',
        referenceNumber: '330',
        name: 'Academic Free License v2.0',
        licenseId: 'AFL-2.0',
        seeAlso: [
          'http://wayback.archive.org/web/20060924134533/http://www.opensource.org/licenses/afl-2.0.txt',
        ],
        isOsiApproved: true,
      },
      {
        reference: './AFL-2.1.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/AFL-2.1.json',
        referenceNumber: '241',
        name: 'Academic Free License v2.1',
        licenseId: 'AFL-2.1',
        seeAlso: ['http://opensource.linux-mirror.org/licenses/afl-2.1.txt'],
        isOsiApproved: true,
      },
      {
        reference: './AFL-3.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/AFL-3.0.json',
        referenceNumber: '350',
        name: 'Academic Free License v3.0',
        licenseId: 'AFL-3.0',
        seeAlso: [
          'http://www.rosenlaw.com/AFL3.0.htm',
          'https://opensource.org/licenses/afl-3.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './AGPL-1.0.html',
        isDeprecatedLicenseId: true,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/AGPL-1.0.json',
        referenceNumber: '169',
        name: 'Affero General Public License v1.0',
        licenseId: 'AGPL-1.0',
        seeAlso: ['http://www.affero.org/oagpl.html'],
        isOsiApproved: false,
      },
      {
        reference: './AGPL-1.0-only.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/AGPL-1.0-only.json',
        referenceNumber: '68',
        name: 'Affero General Public License v1.0 only',
        licenseId: 'AGPL-1.0-only',
        seeAlso: ['http://www.affero.org/oagpl.html'],
        isOsiApproved: false,
      },
      {
        reference: './AGPL-1.0-or-later.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/AGPL-1.0-or-later.json',
        referenceNumber: '162',
        name: 'Affero General Public License v1.0 or later',
        licenseId: 'AGPL-1.0-or-later',
        seeAlso: ['http://www.affero.org/oagpl.html'],
        isOsiApproved: false,
      },
      {
        reference: './AGPL-3.0.html',
        isDeprecatedLicenseId: true,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/AGPL-3.0.json',
        referenceNumber: '143',
        name: 'GNU Affero General Public License v3.0',
        licenseId: 'AGPL-3.0',
        seeAlso: [
          'https://www.gnu.org/licenses/agpl.txt',
          'https://opensource.org/licenses/AGPL-3.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './AGPL-3.0-only.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/AGPL-3.0-only.json',
        referenceNumber: '287',
        name: 'GNU Affero General Public License v3.0 only',
        licenseId: 'AGPL-3.0-only',
        seeAlso: [
          'https://www.gnu.org/licenses/agpl.txt',
          'https://opensource.org/licenses/AGPL-3.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './AGPL-3.0-or-later.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/AGPL-3.0-or-later.json',
        referenceNumber: '154',
        name: 'GNU Affero General Public License v3.0 or later',
        licenseId: 'AGPL-3.0-or-later',
        seeAlso: [
          'https://www.gnu.org/licenses/agpl.txt',
          'https://opensource.org/licenses/AGPL-3.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './AMDPLPA.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/AMDPLPA.json',
        referenceNumber: '128',
        name: 'AMD\'s plpa_map.c License',
        licenseId: 'AMDPLPA',
        seeAlso: [
          'https://fedoraproject.org/wiki/Licensing/AMD_plpa_map_License',
        ],
        isOsiApproved: false,
      },
      {
        reference: './AML.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/AML.json',
        referenceNumber: '151',
        name: 'Apple MIT License',
        licenseId: 'AML',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/Apple_MIT_License'],
        isOsiApproved: false,
      },
      {
        reference: './AMPAS.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/AMPAS.json',
        referenceNumber: '131',
        name: 'Academy of Motion Picture Arts and Sciences BSD',
        licenseId: 'AMPAS',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/BSD#AMPASBSD'],
        isOsiApproved: false,
      },
      {
        reference: './ANTLR-PD.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/ANTLR-PD.json',
        referenceNumber: '44',
        name: 'ANTLR Software Rights Notice',
        licenseId: 'ANTLR-PD',
        seeAlso: ['http://www.antlr2.org/license.html'],
        isOsiApproved: false,
      },
      {
        reference: './APAFML.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/APAFML.json',
        referenceNumber: '240',
        name: 'Adobe Postscript AFM License',
        licenseId: 'APAFML',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/AdobePostscriptAFM'],
        isOsiApproved: false,
      },
      {
        reference: './APL-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/APL-1.0.json',
        referenceNumber: '268',
        name: 'Adaptive Public License 1.0',
        licenseId: 'APL-1.0',
        seeAlso: ['https://opensource.org/licenses/APL-1.0'],
        isOsiApproved: true,
      },
      {
        reference: './APSL-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/APSL-1.0.json',
        referenceNumber: '375',
        name: 'Apple Public Source License 1.0',
        licenseId: 'APSL-1.0',
        seeAlso: [
          'https://fedoraproject.org/wiki/Licensing/Apple_Public_Source_License_1.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './APSL-1.1.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/APSL-1.1.json',
        referenceNumber: '327',
        name: 'Apple Public Source License 1.1',
        licenseId: 'APSL-1.1',
        seeAlso: [
          'http://www.opensource.apple.com/source/IOSerialFamily/IOSerialFamily-7/APPLE_LICENSE',
        ],
        isOsiApproved: true,
      },
      {
        reference: './APSL-1.2.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/APSL-1.2.json',
        referenceNumber: '194',
        name: 'Apple Public Source License 1.2',
        licenseId: 'APSL-1.2',
        seeAlso: [
          'http://www.samurajdata.se/opensource/mirror/licenses/apsl.php',
        ],
        isOsiApproved: true,
      },
      {
        reference: './APSL-2.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/APSL-2.0.json',
        referenceNumber: '136',
        name: 'Apple Public Source License 2.0',
        licenseId: 'APSL-2.0',
        seeAlso: ['http://www.opensource.apple.com/license/apsl/'],
        isOsiApproved: true,
      },
      {
        reference: './Abstyles.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Abstyles.json',
        referenceNumber: '72',
        name: 'Abstyles License',
        licenseId: 'Abstyles',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/Abstyles'],
        isOsiApproved: false,
      },
      {
        reference: './Adobe-2006.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Adobe-2006.json',
        referenceNumber: '299',
        name: 'Adobe Systems Incorporated Source Code License Agreement',
        licenseId: 'Adobe-2006',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/AdobeLicense'],
        isOsiApproved: false,
      },
      {
        reference: './Adobe-Glyph.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Adobe-Glyph.json',
        referenceNumber: '332',
        name: 'Adobe Glyph List License',
        licenseId: 'Adobe-Glyph',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/MIT#AdobeGlyph'],
        isOsiApproved: false,
      },
      {
        reference: './Afmparse.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Afmparse.json',
        referenceNumber: '321',
        name: 'Afmparse License',
        licenseId: 'Afmparse',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/Afmparse'],
        isOsiApproved: false,
      },
      {
        reference: './Aladdin.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Aladdin.json',
        referenceNumber: '304',
        name: 'Aladdin Free Public License',
        licenseId: 'Aladdin',
        seeAlso: ['http://pages.cs.wisc.edu/~ghost/doc/AFPL/6.01/Public.htm'],
        isOsiApproved: false,
      },
      {
        reference: './Apache-1.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/Apache-1.0.json',
        referenceNumber: '32',
        name: 'Apache License 1.0',
        licenseId: 'Apache-1.0',
        seeAlso: ['http://www.apache.org/licenses/LICENSE-1.0'],
        isOsiApproved: false,
      },
      {
        reference: './Apache-1.1.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/Apache-1.1.json',
        referenceNumber: '264',
        name: 'Apache License 1.1',
        licenseId: 'Apache-1.1',
        seeAlso: [
          'http://apache.org/licenses/LICENSE-1.1',
          'https://opensource.org/licenses/Apache-1.1',
        ],
        isOsiApproved: true,
      },
      {
        reference: './Apache-2.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/Apache-2.0.json',
        referenceNumber: '355',
        name: 'Apache License 2.0',
        licenseId: 'Apache-2.0',
        seeAlso: [
          'http://www.apache.org/licenses/LICENSE-2.0',
          'https://opensource.org/licenses/Apache-2.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './Artistic-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Artistic-1.0.json',
        referenceNumber: '263',
        name: 'Artistic License 1.0',
        licenseId: 'Artistic-1.0',
        seeAlso: ['https://opensource.org/licenses/Artistic-1.0'],
        isOsiApproved: true,
      },
      {
        reference: './Artistic-1.0-Perl.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Artistic-1.0-Perl.json',
        referenceNumber: '295',
        name: 'Artistic License 1.0 (Perl)',
        licenseId: 'Artistic-1.0-Perl',
        seeAlso: ['http://dev.perl.org/licenses/artistic.html'],
        isOsiApproved: true,
      },
      {
        reference: './Artistic-1.0-cl8.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Artistic-1.0-cl8.json',
        referenceNumber: '221',
        name: 'Artistic License 1.0 w/clause 8',
        licenseId: 'Artistic-1.0-cl8',
        seeAlso: ['https://opensource.org/licenses/Artistic-1.0'],
        isOsiApproved: true,
      },
      {
        reference: './Artistic-2.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/Artistic-2.0.json',
        referenceNumber: '75',
        name: 'Artistic License 2.0',
        licenseId: 'Artistic-2.0',
        seeAlso: [
          'http://www.perlfoundation.org/artistic_license_2_0',
          'https://opensource.org/licenses/artistic-license-2.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './BSD-1-Clause.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/BSD-1-Clause.json',
        referenceNumber: '377',
        name: 'BSD 1-Clause License',
        licenseId: 'BSD-1-Clause',
        seeAlso: [
          'https://svnweb.freebsd.org/base/head/include/ifaddrs.h?revision=326823',
        ],
        isOsiApproved: false,
      },
      {
        reference: './BSD-2-Clause.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/BSD-2-Clause.json',
        referenceNumber: '296',
        name: 'BSD 2-Clause "Simplified" License',
        licenseId: 'BSD-2-Clause',
        seeAlso: ['https://opensource.org/licenses/BSD-2-Clause'],
        isOsiApproved: true,
      },
      {
        reference: './BSD-2-Clause-FreeBSD.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/BSD-2-Clause-FreeBSD.json',
        referenceNumber: '271',
        name: 'BSD 2-Clause FreeBSD License',
        licenseId: 'BSD-2-Clause-FreeBSD',
        seeAlso: ['http://www.freebsd.org/copyright/freebsd-license.html'],
        isOsiApproved: false,
      },
      {
        reference: './BSD-2-Clause-NetBSD.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/BSD-2-Clause-NetBSD.json',
        referenceNumber: '179',
        name: 'BSD 2-Clause NetBSD License',
        licenseId: 'BSD-2-Clause-NetBSD',
        seeAlso: ['http://www.netbsd.org/about/redistribution.html#default'],
        isOsiApproved: false,
      },
      {
        reference: './BSD-2-Clause-Patent.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/BSD-2-Clause-Patent.json',
        referenceNumber: '351',
        name: 'BSD-2-Clause Plus Patent License',
        licenseId: 'BSD-2-Clause-Patent',
        seeAlso: ['https://opensource.org/licenses/BSDplusPatent'],
        isOsiApproved: true,
      },
      {
        reference: './BSD-3-Clause.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/BSD-3-Clause.json',
        referenceNumber: '195',
        name: 'BSD 3-Clause "New" or "Revised" License',
        licenseId: 'BSD-3-Clause',
        seeAlso: ['https://opensource.org/licenses/BSD-3-Clause'],
        isOsiApproved: true,
      },
      {
        reference: './BSD-3-Clause-Attribution.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/BSD-3-Clause-Attribution.json',
        referenceNumber: '39',
        name: 'BSD with attribution',
        licenseId: 'BSD-3-Clause-Attribution',
        seeAlso: [
          'https://fedoraproject.org/wiki/Licensing/BSD_with_Attribution',
        ],
        isOsiApproved: false,
      },
      {
        reference: './BSD-3-Clause-Clear.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/BSD-3-Clause-Clear.json',
        referenceNumber: '84',
        name: 'BSD 3-Clause Clear License',
        licenseId: 'BSD-3-Clause-Clear',
        seeAlso: ['http://labs.metacarta.com/license-explanation.html#license'],
        isOsiApproved: false,
      },
      {
        reference: './BSD-3-Clause-LBNL.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/BSD-3-Clause-LBNL.json',
        referenceNumber: '142',
        name: 'Lawrence Berkeley National Labs BSD variant license',
        licenseId: 'BSD-3-Clause-LBNL',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/LBNLBSD'],
        isOsiApproved: true,
      },
      {
        reference: './BSD-3-Clause-No-Nuclear-License.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/BSD-3-Clause-No-Nuclear-License.json',
        referenceNumber: '59',
        name: 'BSD 3-Clause No Nuclear License',
        licenseId: 'BSD-3-Clause-No-Nuclear-License',
        seeAlso: [
          'http://download.oracle.com/otn-pub/java/licenses/bsd.txt?AuthParam=1467140197_43d516ce1776bd08a58235a7785be1cc',
        ],
        isOsiApproved: false,
      },
      {
        reference: './BSD-3-Clause-No-Nuclear-License-2014.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/BSD-3-Clause-No-Nuclear-License-2014.json',
        referenceNumber: '331',
        name: 'BSD 3-Clause No Nuclear License 2014',
        licenseId: 'BSD-3-Clause-No-Nuclear-License-2014',
        seeAlso: [
          'https://java.net/projects/javaeetutorial/pages/BerkeleyLicense',
        ],
        isOsiApproved: false,
      },
      {
        reference: './BSD-3-Clause-No-Nuclear-Warranty.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/BSD-3-Clause-No-Nuclear-Warranty.json',
        referenceNumber: '113',
        name: 'BSD 3-Clause No Nuclear Warranty',
        licenseId: 'BSD-3-Clause-No-Nuclear-Warranty',
        seeAlso: [
          'https://jogamp.org/git/?p=gluegen.git;a=blob_plain;f=LICENSE.txt',
        ],
        isOsiApproved: false,
      },
      {
        reference: './BSD-3-Clause-Open-MPI.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/BSD-3-Clause-Open-MPI.json',
        referenceNumber: '207',
        name: 'BSD 3-Clause Open MPI variant',
        licenseId: 'BSD-3-Clause-Open-MPI',
        seeAlso: [
          'https://www.open-mpi.org/community/license.php',
          'http://www.netlib.org/lapack/LICENSE.txt',
        ],
        isOsiApproved: false,
      },
      {
        reference: './BSD-4-Clause.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/BSD-4-Clause.json',
        referenceNumber: '66',
        name: 'BSD 4-Clause "Original" or "Old" License',
        licenseId: 'BSD-4-Clause',
        seeAlso: ['http://directory.fsf.org/wiki/License:BSD_4Clause'],
        isOsiApproved: false,
      },
      {
        reference: './BSD-4-Clause-UC.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/BSD-4-Clause-UC.json',
        referenceNumber: '361',
        name: 'BSD-4-Clause (University of California-Specific)',
        licenseId: 'BSD-4-Clause-UC',
        seeAlso: ['http://www.freebsd.org/copyright/license.html'],
        isOsiApproved: false,
      },
      {
        reference: './BSD-Protection.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/BSD-Protection.json',
        referenceNumber: '388',
        name: 'BSD Protection License',
        licenseId: 'BSD-Protection',
        seeAlso: [
          'https://fedoraproject.org/wiki/Licensing/BSD_Protection_License',
        ],
        isOsiApproved: false,
      },
      {
        reference: './BSD-Source-Code.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/BSD-Source-Code.json',
        referenceNumber: '163',
        name: 'BSD Source Code Attribution',
        licenseId: 'BSD-Source-Code',
        seeAlso: [
          'https://github.com/robbiehanson/CocoaHTTPServer/blob/master/LICENSE.txt',
        ],
        isOsiApproved: false,
      },
      {
        reference: './BSL-1.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/BSL-1.0.json',
        referenceNumber: '284',
        name: 'Boost Software License 1.0',
        licenseId: 'BSL-1.0',
        seeAlso: [
          'http://www.boost.org/LICENSE_1_0.txt',
          'https://opensource.org/licenses/BSL-1.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './Bahyph.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Bahyph.json',
        referenceNumber: '146',
        name: 'Bahyph License',
        licenseId: 'Bahyph',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/Bahyph'],
        isOsiApproved: false,
      },
      {
        reference: './Barr.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Barr.json',
        referenceNumber: '123',
        name: 'Barr License',
        licenseId: 'Barr',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/Barr'],
        isOsiApproved: false,
      },
      {
        reference: './Beerware.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Beerware.json',
        referenceNumber: '243',
        name: 'Beerware License',
        licenseId: 'Beerware',
        seeAlso: [
          'https://fedoraproject.org/wiki/Licensing/Beerware',
          'https://people.freebsd.org/~phk/',
        ],
        isOsiApproved: false,
      },
      {
        reference: './BitTorrent-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/BitTorrent-1.0.json',
        referenceNumber: '200',
        name: 'BitTorrent Open Source License v1.0',
        licenseId: 'BitTorrent-1.0',
        seeAlso: [
          'http://sources.gentoo.org/cgi-bin/viewvc.cgi/gentoo-x86/licenses/BitTorrent?r1=1.1&r2=1.1.1.1&diff_format=s',
        ],
        isOsiApproved: false,
      },
      {
        reference: './BitTorrent-1.1.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/BitTorrent-1.1.json',
        referenceNumber: '181',
        name: 'BitTorrent Open Source License v1.1',
        licenseId: 'BitTorrent-1.1',
        seeAlso: ['http://directory.fsf.org/wiki/License:BitTorrentOSL1.1'],
        isOsiApproved: false,
      },
      {
        reference: './BlueOak-1.0.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/BlueOak-1.0.0.json',
        referenceNumber: '204',
        name: 'Blue Oak Model License 1.0.0',
        licenseId: 'BlueOak-1.0.0',
        seeAlso: ['https://blueoakcouncil.org/license/1.0.0'],
        isOsiApproved: false,
      },
      {
        reference: './Borceux.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Borceux.json',
        referenceNumber: '294',
        name: 'Borceux license',
        licenseId: 'Borceux',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/Borceux'],
        isOsiApproved: false,
      },
      {
        reference: './CATOSL-1.1.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CATOSL-1.1.json',
        referenceNumber: '226',
        name: 'Computer Associates Trusted Open Source License 1.1',
        licenseId: 'CATOSL-1.1',
        seeAlso: ['https://opensource.org/licenses/CATOSL-1.1'],
        isOsiApproved: true,
      },
      {
        reference: './CC-BY-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-1.0.json',
        referenceNumber: '23',
        name: 'Creative Commons Attribution 1.0 Generic',
        licenseId: 'CC-BY-1.0',
        seeAlso: ['https://creativecommons.org/licenses/by/1.0/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-2.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-2.0.json',
        referenceNumber: '58',
        name: 'Creative Commons Attribution 2.0 Generic',
        licenseId: 'CC-BY-2.0',
        seeAlso: ['https://creativecommons.org/licenses/by/2.0/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-2.5.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-2.5.json',
        referenceNumber: '180',
        name: 'Creative Commons Attribution 2.5 Generic',
        licenseId: 'CC-BY-2.5',
        seeAlso: ['https://creativecommons.org/licenses/by/2.5/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-3.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-3.0.json',
        referenceNumber: '333',
        name: 'Creative Commons Attribution 3.0 Unported',
        licenseId: 'CC-BY-3.0',
        seeAlso: ['https://creativecommons.org/licenses/by/3.0/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-4.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-4.0.json',
        referenceNumber: '211',
        name: 'Creative Commons Attribution 4.0 International',
        licenseId: 'CC-BY-4.0',
        seeAlso: ['https://creativecommons.org/licenses/by/4.0/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-NC-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-1.0.json',
        referenceNumber: '223',
        name: 'Creative Commons Attribution Non Commercial 1.0 Generic',
        licenseId: 'CC-BY-NC-1.0',
        seeAlso: ['https://creativecommons.org/licenses/by-nc/1.0/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-NC-2.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-2.0.json',
        referenceNumber: '315',
        name: 'Creative Commons Attribution Non Commercial 2.0 Generic',
        licenseId: 'CC-BY-NC-2.0',
        seeAlso: ['https://creativecommons.org/licenses/by-nc/2.0/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-NC-2.5.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-2.5.json',
        referenceNumber: '386',
        name: 'Creative Commons Attribution Non Commercial 2.5 Generic',
        licenseId: 'CC-BY-NC-2.5',
        seeAlso: ['https://creativecommons.org/licenses/by-nc/2.5/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-NC-3.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-3.0.json',
        referenceNumber: '325',
        name: 'Creative Commons Attribution Non Commercial 3.0 Unported',
        licenseId: 'CC-BY-NC-3.0',
        seeAlso: ['https://creativecommons.org/licenses/by-nc/3.0/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-NC-4.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-4.0.json',
        referenceNumber: '262',
        name: 'Creative Commons Attribution Non Commercial 4.0 International',
        licenseId: 'CC-BY-NC-4.0',
        seeAlso: ['https://creativecommons.org/licenses/by-nc/4.0/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-NC-ND-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-ND-1.0.json',
        referenceNumber: '98',
        name: 'Creative Commons Attribution Non Commercial No Derivatives 1.0 Generic',
        licenseId: 'CC-BY-NC-ND-1.0',
        seeAlso: ['https://creativecommons.org/licenses/by-nd-nc/1.0/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-NC-ND-2.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-ND-2.0.json',
        referenceNumber: '133',
        name: 'Creative Commons Attribution Non Commercial No Derivatives 2.0 Generic',
        licenseId: 'CC-BY-NC-ND-2.0',
        seeAlso: ['https://creativecommons.org/licenses/by-nc-nd/2.0/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-NC-ND-2.5.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-ND-2.5.json',
        referenceNumber: '30',
        name: 'Creative Commons Attribution Non Commercial No Derivatives 2.5 Generic',
        licenseId: 'CC-BY-NC-ND-2.5',
        seeAlso: ['https://creativecommons.org/licenses/by-nc-nd/2.5/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-NC-ND-3.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-ND-3.0.json',
        referenceNumber: '41',
        name: 'Creative Commons Attribution Non Commercial No Derivatives 3.0 Unported',
        licenseId: 'CC-BY-NC-ND-3.0',
        seeAlso: ['https://creativecommons.org/licenses/by-nc-nd/3.0/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-NC-ND-4.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-ND-4.0.json',
        referenceNumber: '166',
        name: 'Creative Commons Attribution Non Commercial No Derivatives 4.0 International',
        licenseId: 'CC-BY-NC-ND-4.0',
        seeAlso: ['https://creativecommons.org/licenses/by-nc-nd/4.0/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-NC-SA-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-SA-1.0.json',
        referenceNumber: '116',
        name: 'Creative Commons Attribution Non Commercial Share Alike 1.0 Generic',
        licenseId: 'CC-BY-NC-SA-1.0',
        seeAlso: ['https://creativecommons.org/licenses/by-nc-sa/1.0/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-NC-SA-2.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-SA-2.0.json',
        referenceNumber: '398',
        name: 'Creative Commons Attribution Non Commercial Share Alike 2.0 Generic',
        licenseId: 'CC-BY-NC-SA-2.0',
        seeAlso: ['https://creativecommons.org/licenses/by-nc-sa/2.0/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-NC-SA-2.5.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-SA-2.5.json',
        referenceNumber: '208',
        name: 'Creative Commons Attribution Non Commercial Share Alike 2.5 Generic',
        licenseId: 'CC-BY-NC-SA-2.5',
        seeAlso: ['https://creativecommons.org/licenses/by-nc-sa/2.5/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-NC-SA-3.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-SA-3.0.json',
        referenceNumber: '349',
        name: 'Creative Commons Attribution Non Commercial Share Alike 3.0 Unported',
        licenseId: 'CC-BY-NC-SA-3.0',
        seeAlso: ['https://creativecommons.org/licenses/by-nc-sa/3.0/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-NC-SA-4.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-SA-4.0.json',
        referenceNumber: '320',
        name: 'Creative Commons Attribution Non Commercial Share Alike 4.0 International',
        licenseId: 'CC-BY-NC-SA-4.0',
        seeAlso: ['https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-ND-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-ND-1.0.json',
        referenceNumber: '90',
        name: 'Creative Commons Attribution No Derivatives 1.0 Generic',
        licenseId: 'CC-BY-ND-1.0',
        seeAlso: ['https://creativecommons.org/licenses/by-nd/1.0/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-ND-2.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-ND-2.0.json',
        referenceNumber: '46',
        name: 'Creative Commons Attribution No Derivatives 2.0 Generic',
        licenseId: 'CC-BY-ND-2.0',
        seeAlso: ['https://creativecommons.org/licenses/by-nd/2.0/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-ND-2.5.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-ND-2.5.json',
        referenceNumber: '27',
        name: 'Creative Commons Attribution No Derivatives 2.5 Generic',
        licenseId: 'CC-BY-ND-2.5',
        seeAlso: ['https://creativecommons.org/licenses/by-nd/2.5/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-ND-3.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-ND-3.0.json',
        referenceNumber: '274',
        name: 'Creative Commons Attribution No Derivatives 3.0 Unported',
        licenseId: 'CC-BY-ND-3.0',
        seeAlso: ['https://creativecommons.org/licenses/by-nd/3.0/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-ND-4.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-ND-4.0.json',
        referenceNumber: '307',
        name: 'Creative Commons Attribution No Derivatives 4.0 International',
        licenseId: 'CC-BY-ND-4.0',
        seeAlso: ['https://creativecommons.org/licenses/by-nd/4.0/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-SA-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-SA-1.0.json',
        referenceNumber: '391',
        name: 'Creative Commons Attribution Share Alike 1.0 Generic',
        licenseId: 'CC-BY-SA-1.0',
        seeAlso: ['https://creativecommons.org/licenses/by-sa/1.0/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-SA-2.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-SA-2.0.json',
        referenceNumber: '356',
        name: 'Creative Commons Attribution Share Alike 2.0 Generic',
        licenseId: 'CC-BY-SA-2.0',
        seeAlso: ['https://creativecommons.org/licenses/by-sa/2.0/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-SA-2.5.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-SA-2.5.json',
        referenceNumber: '196',
        name: 'Creative Commons Attribution Share Alike 2.5 Generic',
        licenseId: 'CC-BY-SA-2.5',
        seeAlso: ['https://creativecommons.org/licenses/by-sa/2.5/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-SA-3.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-SA-3.0.json',
        referenceNumber: '225',
        name: 'Creative Commons Attribution Share Alike 3.0 Unported',
        licenseId: 'CC-BY-SA-3.0',
        seeAlso: ['https://creativecommons.org/licenses/by-sa/3.0/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-BY-SA-4.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/CC-BY-SA-4.0.json',
        referenceNumber: '286',
        name: 'Creative Commons Attribution Share Alike 4.0 International',
        licenseId: 'CC-BY-SA-4.0',
        seeAlso: ['https://creativecommons.org/licenses/by-sa/4.0/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CC-PDDC.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CC-PDDC.json',
        referenceNumber: '88',
        name: 'Creative Commons Public Domain Dedication and Certification',
        licenseId: 'CC-PDDC',
        seeAlso: ['https://creativecommons.org/licenses/publicdomain/'],
        isOsiApproved: false,
      },
      {
        reference: './CC0-1.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/CC0-1.0.json',
        referenceNumber: '63',
        name: 'Creative Commons Zero v1.0 Universal',
        licenseId: 'CC0-1.0',
        seeAlso: ['https://creativecommons.org/publicdomain/zero/1.0/legalcode'],
        isOsiApproved: false,
      },
      {
        reference: './CDDL-1.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/CDDL-1.0.json',
        referenceNumber: '324',
        name: 'Common Development and Distribution License 1.0',
        licenseId: 'CDDL-1.0',
        seeAlso: ['https://opensource.org/licenses/cddl1'],
        isOsiApproved: true,
      },
      {
        reference: './CDDL-1.1.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CDDL-1.1.json',
        referenceNumber: '273',
        name: 'Common Development and Distribution License 1.1',
        licenseId: 'CDDL-1.1',
        seeAlso: [
          'http://glassfish.java.net/public/CDDL+GPL_1_1.html',
          'https://javaee.github.io/glassfish/LICENSE',
        ],
        isOsiApproved: false,
      },
      {
        reference: './CDLA-Permissive-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CDLA-Permissive-1.0.json',
        referenceNumber: '104',
        name: 'Community Data License Agreement Permissive 1.0',
        licenseId: 'CDLA-Permissive-1.0',
        seeAlso: ['https://cdla.io/permissive-1-0'],
        isOsiApproved: false,
      },
      {
        reference: './CDLA-Sharing-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CDLA-Sharing-1.0.json',
        referenceNumber: '172',
        name: 'Community Data License Agreement Sharing 1.0',
        licenseId: 'CDLA-Sharing-1.0',
        seeAlso: ['https://cdla.io/sharing-1-0'],
        isOsiApproved: false,
      },
      {
        reference: './CECILL-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CECILL-1.0.json',
        referenceNumber: '10',
        name: 'CeCILL Free Software License Agreement v1.0',
        licenseId: 'CECILL-1.0',
        seeAlso: ['http://www.cecill.info/licences/Licence_CeCILL_V1-fr.html'],
        isOsiApproved: false,
      },
      {
        reference: './CECILL-1.1.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CECILL-1.1.json',
        referenceNumber: '130',
        name: 'CeCILL Free Software License Agreement v1.1',
        licenseId: 'CECILL-1.1',
        seeAlso: ['http://www.cecill.info/licences/Licence_CeCILL_V1.1-US.html'],
        isOsiApproved: false,
      },
      {
        reference: './CECILL-2.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/CECILL-2.0.json',
        referenceNumber: '5',
        name: 'CeCILL Free Software License Agreement v2.0',
        licenseId: 'CECILL-2.0',
        seeAlso: ['http://www.cecill.info/licences/Licence_CeCILL_V2-en.html'],
        isOsiApproved: false,
      },
      {
        reference: './CECILL-2.1.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CECILL-2.1.json',
        referenceNumber: '140',
        name: 'CeCILL Free Software License Agreement v2.1',
        licenseId: 'CECILL-2.1',
        seeAlso: ['http://www.cecill.info/licences/Licence_CeCILL_V2.1-en.html'],
        isOsiApproved: true,
      },
      {
        reference: './CECILL-B.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/CECILL-B.json',
        referenceNumber: '89',
        name: 'CeCILL-B Free Software License Agreement',
        licenseId: 'CECILL-B',
        seeAlso: ['http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html'],
        isOsiApproved: false,
      },
      {
        reference: './CECILL-C.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/CECILL-C.json',
        referenceNumber: '232',
        name: 'CeCILL-C Free Software License Agreement',
        licenseId: 'CECILL-C',
        seeAlso: ['http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html'],
        isOsiApproved: false,
      },
      {
        reference: './CERN-OHL-1.1.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CERN-OHL-1.1.json',
        referenceNumber: '118',
        name: 'CERN Open Hardware Licence v1.1',
        licenseId: 'CERN-OHL-1.1',
        seeAlso: ['https://www.ohwr.org/project/licenses/wikis/cern-ohl-v1.1'],
        isOsiApproved: false,
      },
      {
        reference: './CERN-OHL-1.2.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CERN-OHL-1.2.json',
        referenceNumber: '161',
        name: 'CERN Open Hardware Licence v1.2',
        licenseId: 'CERN-OHL-1.2',
        seeAlso: ['https://www.ohwr.org/project/licenses/wikis/cern-ohl-v1.2'],
        isOsiApproved: false,
      },
      {
        reference: './CNRI-Jython.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CNRI-Jython.json',
        referenceNumber: '74',
        name: 'CNRI Jython License',
        licenseId: 'CNRI-Jython',
        seeAlso: ['http://www.jython.org/license.html'],
        isOsiApproved: false,
      },
      {
        reference: './CNRI-Python.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CNRI-Python.json',
        referenceNumber: '92',
        name: 'CNRI Python License',
        licenseId: 'CNRI-Python',
        seeAlso: ['https://opensource.org/licenses/CNRI-Python'],
        isOsiApproved: true,
      },
      {
        reference: './CNRI-Python-GPL-Compatible.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CNRI-Python-GPL-Compatible.json',
        referenceNumber: '337',
        name: 'CNRI Python Open Source GPL Compatible License Agreement',
        licenseId: 'CNRI-Python-GPL-Compatible',
        seeAlso: ['http://www.python.org/download/releases/1.6.1/download_win/'],
        isOsiApproved: false,
      },
      {
        reference: './CPAL-1.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/CPAL-1.0.json',
        referenceNumber: '275',
        name: 'Common Public Attribution License 1.0',
        licenseId: 'CPAL-1.0',
        seeAlso: ['https://opensource.org/licenses/CPAL-1.0'],
        isOsiApproved: true,
      },
      {
        reference: './CPL-1.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/CPL-1.0.json',
        referenceNumber: '228',
        name: 'Common Public License 1.0',
        licenseId: 'CPL-1.0',
        seeAlso: ['https://opensource.org/licenses/CPL-1.0'],
        isOsiApproved: true,
      },
      {
        reference: './CPOL-1.02.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CPOL-1.02.json',
        referenceNumber: '222',
        name: 'Code Project Open License 1.02',
        licenseId: 'CPOL-1.02',
        seeAlso: ['http://www.codeproject.com/info/cpol10.aspx'],
        isOsiApproved: false,
      },
      {
        reference: './CUA-OPL-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CUA-OPL-1.0.json',
        referenceNumber: '159',
        name: 'CUA Office Public License v1.0',
        licenseId: 'CUA-OPL-1.0',
        seeAlso: ['https://opensource.org/licenses/CUA-OPL-1.0'],
        isOsiApproved: true,
      },
      {
        reference: './Caldera.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Caldera.json',
        referenceNumber: '242',
        name: 'Caldera License',
        licenseId: 'Caldera',
        seeAlso: ['http://www.lemis.com/grog/UNIX/ancient-source-all.pdf'],
        isOsiApproved: false,
      },
      {
        reference: './ClArtistic.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/ClArtistic.json',
        referenceNumber: '237',
        name: 'Clarified Artistic License',
        licenseId: 'ClArtistic',
        seeAlso: [
          'http://gianluca.dellavedova.org/2011/01/03/clarified-artistic-license/',
          'http://www.ncftp.com/ncftp/doc/LICENSE.txt',
        ],
        isOsiApproved: false,
      },
      {
        reference: './Condor-1.1.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/Condor-1.1.json',
        referenceNumber: '145',
        name: 'Condor Public License v1.1',
        licenseId: 'Condor-1.1',
        seeAlso: [
          'http://research.cs.wisc.edu/condor/license.html#condor',
          'http://web.archive.org/web/20111123062036/http://research.cs.wisc.edu/condor/license.html#condor',
        ],
        isOsiApproved: false,
      },
      {
        reference: './Crossword.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Crossword.json',
        referenceNumber: '97',
        name: 'Crossword License',
        licenseId: 'Crossword',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/Crossword'],
        isOsiApproved: false,
      },
      {
        reference: './CrystalStacker.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/CrystalStacker.json',
        referenceNumber: '38',
        name: 'CrystalStacker License',
        licenseId: 'CrystalStacker',
        seeAlso: [
          'https://fedoraproject.org/wiki/Licensing:CrystalStacker?rd=Licensing/CrystalStacker',
        ],
        isOsiApproved: false,
      },
      {
        reference: './Cube.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Cube.json',
        referenceNumber: '379',
        name: 'Cube License',
        licenseId: 'Cube',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/Cube'],
        isOsiApproved: false,
      },
      {
        reference: './D-FSL-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/D-FSL-1.0.json',
        referenceNumber: '347',
        name: 'Deutsche Freie Software Lizenz',
        licenseId: 'D-FSL-1.0',
        seeAlso: [
          'http://www.dipp.nrw.de/d-fsl/lizenzen/',
          'http://www.dipp.nrw.de/d-fsl/index_html/lizenzen/de/D-FSL-1_0_de.txt',
          'http://www.dipp.nrw.de/d-fsl/index_html/lizenzen/en/D-FSL-1_0_en.txt',
          'https://www.hbz-nrw.de/produkte/open-access/lizenzen/dfsl',
          'https://www.hbz-nrw.de/produkte/open-access/lizenzen/dfsl/deutsche-freie-software-lizenz',
          'https://www.hbz-nrw.de/produkte/open-access/lizenzen/dfsl/german-free-software-license',
          'https://www.hbz-nrw.de/produkte/open-access/lizenzen/dfsl/D-FSL-1_0_de.txt/at_download/file',
          'https://www.hbz-nrw.de/produkte/open-access/lizenzen/dfsl/D-FSL-1_0_en.txt/at_download/file',
        ],
        isOsiApproved: false,
      },
      {
        reference: './DOC.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/DOC.json',
        referenceNumber: '265',
        name: 'DOC License',
        licenseId: 'DOC',
        seeAlso: ['http://www.cs.wustl.edu/~schmidt/ACE-copying.html'],
        isOsiApproved: false,
      },
      {
        reference: './DSDP.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/DSDP.json',
        referenceNumber: '257',
        name: 'DSDP License',
        licenseId: 'DSDP',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/DSDP'],
        isOsiApproved: false,
      },
      {
        reference: './Dotseqn.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Dotseqn.json',
        referenceNumber: '33',
        name: 'Dotseqn License',
        licenseId: 'Dotseqn',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/Dotseqn'],
        isOsiApproved: false,
      },
      {
        reference: './ECL-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/ECL-1.0.json',
        referenceNumber: '405',
        name: 'Educational Community License v1.0',
        licenseId: 'ECL-1.0',
        seeAlso: ['https://opensource.org/licenses/ECL-1.0'],
        isOsiApproved: true,
      },
      {
        reference: './ECL-2.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/ECL-2.0.json',
        referenceNumber: '1',
        name: 'Educational Community License v2.0',
        licenseId: 'ECL-2.0',
        seeAlso: ['https://opensource.org/licenses/ECL-2.0'],
        isOsiApproved: true,
      },
      {
        reference: './EFL-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/EFL-1.0.json',
        referenceNumber: '73',
        name: 'Eiffel Forum License v1.0',
        licenseId: 'EFL-1.0',
        seeAlso: [
          'http://www.eiffel-nice.org/license/forum.txt',
          'https://opensource.org/licenses/EFL-1.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './EFL-2.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/EFL-2.0.json',
        referenceNumber: '7',
        name: 'Eiffel Forum License v2.0',
        licenseId: 'EFL-2.0',
        seeAlso: [
          'http://www.eiffel-nice.org/license/eiffel-forum-license-2.html',
          'https://opensource.org/licenses/EFL-2.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './EPL-1.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/EPL-1.0.json',
        referenceNumber: '267',
        name: 'Eclipse Public License 1.0',
        licenseId: 'EPL-1.0',
        seeAlso: [
          'http://www.eclipse.org/legal/epl-v10.html',
          'https://opensource.org/licenses/EPL-1.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './EPL-2.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/EPL-2.0.json',
        referenceNumber: '403',
        name: 'Eclipse Public License 2.0',
        licenseId: 'EPL-2.0',
        seeAlso: [
          'https://www.eclipse.org/legal/epl-2.0',
          'https://www.opensource.org/licenses/EPL-2.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './EUDatagrid.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/EUDatagrid.json',
        referenceNumber: '254',
        name: 'EU DataGrid Software License',
        licenseId: 'EUDatagrid',
        seeAlso: [
          'http://eu-datagrid.web.cern.ch/eu-datagrid/license.html',
          'https://opensource.org/licenses/EUDatagrid',
        ],
        isOsiApproved: true,
      },
      {
        reference: './EUPL-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/EUPL-1.0.json',
        referenceNumber: '94',
        name: 'European Union Public License 1.0',
        licenseId: 'EUPL-1.0',
        seeAlso: [
          'http://ec.europa.eu/idabc/en/document/7330.html',
          'http://ec.europa.eu/idabc/servlets/Doc027f.pdf?id=31096',
        ],
        isOsiApproved: false,
      },
      {
        reference: './EUPL-1.1.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/EUPL-1.1.json',
        referenceNumber: '396',
        name: 'European Union Public License 1.1',
        licenseId: 'EUPL-1.1',
        seeAlso: [
          'https://joinup.ec.europa.eu/software/page/eupl/licence-eupl',
          'https://joinup.ec.europa.eu/sites/default/files/custom-page/attachment/eupl1.1.-licence-en_0.pdf',
          'https://opensource.org/licenses/EUPL-1.1',
        ],
        isOsiApproved: true,
      },
      {
        reference: './EUPL-1.2.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/EUPL-1.2.json',
        referenceNumber: '261',
        name: 'European Union Public License 1.2',
        licenseId: 'EUPL-1.2',
        seeAlso: [
          'https://joinup.ec.europa.eu/page/eupl-text-11-12',
          'https://joinup.ec.europa.eu/sites/default/files/custom-page/attachment/eupl_v1.2_en.pdf',
          'https://joinup.ec.europa.eu/sites/default/files/inline-files/EUPL%20v1_2%20EN(1).txt',
          'http://eur-lex.europa.eu/legal-content/EN/TXT/HTML/?uri=CELEX:32017D0863',
          'https://opensource.org/licenses/EUPL-1.1',
        ],
        isOsiApproved: true,
      },
      {
        reference: './Entessa.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Entessa.json',
        referenceNumber: '374',
        name: 'Entessa Public License v1.0',
        licenseId: 'Entessa',
        seeAlso: ['https://opensource.org/licenses/Entessa'],
        isOsiApproved: true,
      },
      {
        reference: './ErlPL-1.1.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/ErlPL-1.1.json',
        referenceNumber: '395',
        name: 'Erlang Public License v1.1',
        licenseId: 'ErlPL-1.1',
        seeAlso: ['http://www.erlang.org/EPLICENSE'],
        isOsiApproved: false,
      },
      {
        reference: './Eurosym.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Eurosym.json',
        referenceNumber: '165',
        name: 'Eurosym License',
        licenseId: 'Eurosym',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/Eurosym'],
        isOsiApproved: false,
      },
      {
        reference: './FSFAP.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/FSFAP.json',
        referenceNumber: '382',
        name: 'FSF All Permissive License',
        licenseId: 'FSFAP',
        seeAlso: [
          'https://www.gnu.org/prep/maintain/html_node/License-Notices-for-Other-Files.html',
        ],
        isOsiApproved: false,
      },
      {
        reference: './FSFUL.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/FSFUL.json',
        referenceNumber: '2',
        name: 'FSF Unlimited License',
        licenseId: 'FSFUL',
        seeAlso: [
          'https://fedoraproject.org/wiki/Licensing/FSF_Unlimited_License',
        ],
        isOsiApproved: false,
      },
      {
        reference: './FSFULLR.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/FSFULLR.json',
        referenceNumber: '297',
        name: 'FSF Unlimited License (with License Retention)',
        licenseId: 'FSFULLR',
        seeAlso: [
          'https://fedoraproject.org/wiki/Licensing/FSF_Unlimited_License#License_Retention_Variant',
        ],
        isOsiApproved: false,
      },
      {
        reference: './FTL.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/FTL.json',
        referenceNumber: '363',
        name: 'Freetype Project License',
        licenseId: 'FTL',
        seeAlso: [
          'http://freetype.fis.uniroma2.it/FTL.TXT',
          'http://git.savannah.gnu.org/cgit/freetype/freetype2.git/tree/docs/FTL.TXT',
        ],
        isOsiApproved: false,
      },
      {
        reference: './Fair.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Fair.json',
        referenceNumber: '253',
        name: 'Fair License',
        licenseId: 'Fair',
        seeAlso: [
          'http://fairlicense.org/',
          'https://opensource.org/licenses/Fair',
        ],
        isOsiApproved: true,
      },
      {
        reference: './Frameworx-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Frameworx-1.0.json',
        referenceNumber: '362',
        name: 'Frameworx Open License 1.0',
        licenseId: 'Frameworx-1.0',
        seeAlso: ['https://opensource.org/licenses/Frameworx-1.0'],
        isOsiApproved: true,
      },
      {
        reference: './FreeImage.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/FreeImage.json',
        referenceNumber: '359',
        name: 'FreeImage Public License v1.0',
        licenseId: 'FreeImage',
        seeAlso: ['http://freeimage.sourceforge.net/freeimage-license.txt'],
        isOsiApproved: false,
      },
      {
        reference: './GFDL-1.1.html',
        isDeprecatedLicenseId: true,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/GFDL-1.1.json',
        referenceNumber: '248',
        name: 'GNU Free Documentation License v1.1',
        licenseId: 'GFDL-1.1',
        seeAlso: ['https://www.gnu.org/licenses/old-licenses/fdl-1.1.txt'],
        isOsiApproved: false,
      },
      {
        reference: './GFDL-1.1-only.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/GFDL-1.1-only.json',
        referenceNumber: '100',
        name: 'GNU Free Documentation License v1.1 only',
        licenseId: 'GFDL-1.1-only',
        seeAlso: ['https://www.gnu.org/licenses/old-licenses/fdl-1.1.txt'],
        isOsiApproved: false,
      },
      {
        reference: './GFDL-1.1-or-later.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/GFDL-1.1-or-later.json',
        referenceNumber: '119',
        name: 'GNU Free Documentation License v1.1 or later',
        licenseId: 'GFDL-1.1-or-later',
        seeAlso: ['https://www.gnu.org/licenses/old-licenses/fdl-1.1.txt'],
        isOsiApproved: false,
      },
      {
        reference: './GFDL-1.2.html',
        isDeprecatedLicenseId: true,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/GFDL-1.2.json',
        referenceNumber: '190',
        name: 'GNU Free Documentation License v1.2',
        licenseId: 'GFDL-1.2',
        seeAlso: ['https://www.gnu.org/licenses/old-licenses/fdl-1.2.txt'],
        isOsiApproved: false,
      },
      {
        reference: './GFDL-1.2-only.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/GFDL-1.2-only.json',
        referenceNumber: '86',
        name: 'GNU Free Documentation License v1.2 only',
        licenseId: 'GFDL-1.2-only',
        seeAlso: ['https://www.gnu.org/licenses/old-licenses/fdl-1.2.txt'],
        isOsiApproved: false,
      },
      {
        reference: './GFDL-1.2-or-later.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/GFDL-1.2-or-later.json',
        referenceNumber: '127',
        name: 'GNU Free Documentation License v1.2 or later',
        licenseId: 'GFDL-1.2-or-later',
        seeAlso: ['https://www.gnu.org/licenses/old-licenses/fdl-1.2.txt'],
        isOsiApproved: false,
      },
      {
        reference: './GFDL-1.3.html',
        isDeprecatedLicenseId: true,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/GFDL-1.3.json',
        referenceNumber: '354',
        name: 'GNU Free Documentation License v1.3',
        licenseId: 'GFDL-1.3',
        seeAlso: ['https://www.gnu.org/licenses/fdl-1.3.txt'],
        isOsiApproved: false,
      },
      {
        reference: './GFDL-1.3-only.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/GFDL-1.3-only.json',
        referenceNumber: '193',
        name: 'GNU Free Documentation License v1.3 only',
        licenseId: 'GFDL-1.3-only',
        seeAlso: ['https://www.gnu.org/licenses/fdl-1.3.txt'],
        isOsiApproved: false,
      },
      {
        reference: './GFDL-1.3-or-later.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/GFDL-1.3-or-later.json',
        referenceNumber: '51',
        name: 'GNU Free Documentation License v1.3 or later',
        licenseId: 'GFDL-1.3-or-later',
        seeAlso: ['https://www.gnu.org/licenses/fdl-1.3.txt'],
        isOsiApproved: false,
      },
      {
        reference: './GL2PS.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/GL2PS.json',
        referenceNumber: '303',
        name: 'GL2PS License',
        licenseId: 'GL2PS',
        seeAlso: ['http://www.geuz.org/gl2ps/COPYING.GL2PS'],
        isOsiApproved: false,
      },
      {
        reference: './GPL-1.0.html',
        isDeprecatedLicenseId: true,
        detailsUrl: 'http://spdx.org/licenses/GPL-1.0.json',
        referenceNumber: '319',
        name: 'GNU General Public License v1.0 only',
        licenseId: 'GPL-1.0',
        seeAlso: [
          'https://www.gnu.org/licenses/old-licenses/gpl-1.0-standalone.html',
        ],
        isOsiApproved: false,
      },
      {
        reference: './GPL-1.0+.html',
        isDeprecatedLicenseId: true,
        detailsUrl: 'http://spdx.org/licenses/GPL-1.0+.json',
        referenceNumber: '198',
        name: 'GNU General Public License v1.0 or later',
        licenseId: 'GPL-1.0+',
        seeAlso: [
          'https://www.gnu.org/licenses/old-licenses/gpl-1.0-standalone.html',
        ],
        isOsiApproved: false,
      },
      {
        reference: './GPL-1.0-only.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/GPL-1.0-only.json',
        referenceNumber: '15',
        name: 'GNU General Public License v1.0 only',
        licenseId: 'GPL-1.0-only',
        seeAlso: [
          'https://www.gnu.org/licenses/old-licenses/gpl-1.0-standalone.html',
        ],
        isOsiApproved: false,
      },
      {
        reference: './GPL-1.0-or-later.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/GPL-1.0-or-later.json',
        referenceNumber: '129',
        name: 'GNU General Public License v1.0 or later',
        licenseId: 'GPL-1.0-or-later',
        seeAlso: [
          'https://www.gnu.org/licenses/old-licenses/gpl-1.0-standalone.html',
        ],
        isOsiApproved: false,
      },
      {
        reference: './GPL-2.0.html',
        isDeprecatedLicenseId: true,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/GPL-2.0.json',
        referenceNumber: '345',
        name: 'GNU General Public License v2.0 only',
        licenseId: 'GPL-2.0',
        seeAlso: [
          'https://www.gnu.org/licenses/old-licenses/gpl-2.0-standalone.html',
          'https://opensource.org/licenses/GPL-2.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './GPL-2.0+.html',
        isDeprecatedLicenseId: true,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/GPL-2.0+.json',
        referenceNumber: '389',
        name: 'GNU General Public License v2.0 or later',
        licenseId: 'GPL-2.0+',
        seeAlso: [
          'https://www.gnu.org/licenses/old-licenses/gpl-2.0-standalone.html',
          'https://opensource.org/licenses/GPL-2.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './GPL-2.0-only.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/GPL-2.0-only.json',
        referenceNumber: '227',
        name: 'GNU General Public License v2.0 only',
        licenseId: 'GPL-2.0-only',
        seeAlso: [
          'https://www.gnu.org/licenses/old-licenses/gpl-2.0-standalone.html',
          'https://opensource.org/licenses/GPL-2.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './GPL-2.0-or-later.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/GPL-2.0-or-later.json',
        referenceNumber: '249',
        name: 'GNU General Public License v2.0 or later',
        licenseId: 'GPL-2.0-or-later',
        seeAlso: [
          'https://www.gnu.org/licenses/old-licenses/gpl-2.0-standalone.html',
          'https://opensource.org/licenses/GPL-2.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './GPL-2.0-with-GCC-exception.html',
        isDeprecatedLicenseId: true,
        detailsUrl: 'http://spdx.org/licenses/GPL-2.0-with-GCC-exception.json',
        referenceNumber: '329',
        name: 'GNU General Public License v2.0 w/GCC Runtime Library exception',
        licenseId: 'GPL-2.0-with-GCC-exception',
        seeAlso: [
          'https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=gcc/libgcc1.c;h=762f5143fc6eed57b6797c82710f3538aa52b40b;hb=cb143a3ce4fb417c68f5fa2691a1b1b1053dfba9#l10',
        ],
        isOsiApproved: false,
      },
      {
        reference: './GPL-2.0-with-autoconf-exception.html',
        isDeprecatedLicenseId: true,
        detailsUrl: 'http://spdx.org/licenses/GPL-2.0-with-autoconf-exception.json',
        referenceNumber: '36',
        name: 'GNU General Public License v2.0 w/Autoconf exception',
        licenseId: 'GPL-2.0-with-autoconf-exception',
        seeAlso: ['http://ac-archive.sourceforge.net/doc/copyright.html'],
        isOsiApproved: false,
      },
      {
        reference: './GPL-2.0-with-bison-exception.html',
        isDeprecatedLicenseId: true,
        detailsUrl: 'http://spdx.org/licenses/GPL-2.0-with-bison-exception.json',
        referenceNumber: '360',
        name: 'GNU General Public License v2.0 w/Bison exception',
        licenseId: 'GPL-2.0-with-bison-exception',
        seeAlso: [
          'http://git.savannah.gnu.org/cgit/bison.git/tree/data/yacc.c?id=193d7c7054ba7197b0789e14965b739162319b5e#n141',
        ],
        isOsiApproved: false,
      },
      {
        reference: './GPL-2.0-with-classpath-exception.html',
        isDeprecatedLicenseId: true,
        detailsUrl: 'http://spdx.org/licenses/GPL-2.0-with-classpath-exception.json',
        referenceNumber: '219',
        name: 'GNU General Public License v2.0 w/Classpath exception',
        licenseId: 'GPL-2.0-with-classpath-exception',
        seeAlso: ['https://www.gnu.org/software/classpath/license.html'],
        isOsiApproved: false,
      },
      {
        reference: './GPL-2.0-with-font-exception.html',
        isDeprecatedLicenseId: true,
        detailsUrl: 'http://spdx.org/licenses/GPL-2.0-with-font-exception.json',
        referenceNumber: '24',
        name: 'GNU General Public License v2.0 w/Font exception',
        licenseId: 'GPL-2.0-with-font-exception',
        seeAlso: ['https://www.gnu.org/licenses/gpl-faq.html#FontException'],
        isOsiApproved: false,
      },
      {
        reference: './GPL-3.0.html',
        isDeprecatedLicenseId: true,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/GPL-3.0.json',
        referenceNumber: '401',
        name: 'GNU General Public License v3.0 only',
        licenseId: 'GPL-3.0',
        seeAlso: [
          'https://www.gnu.org/licenses/gpl-3.0-standalone.html',
          'https://opensource.org/licenses/GPL-3.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './GPL-3.0+.html',
        isDeprecatedLicenseId: true,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/GPL-3.0+.json',
        referenceNumber: '147',
        name: 'GNU General Public License v3.0 or later',
        licenseId: 'GPL-3.0+',
        seeAlso: [
          'https://www.gnu.org/licenses/gpl-3.0-standalone.html',
          'https://opensource.org/licenses/GPL-3.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './GPL-3.0-only.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/GPL-3.0-only.json',
        referenceNumber: '122',
        name: 'GNU General Public License v3.0 only',
        licenseId: 'GPL-3.0-only',
        seeAlso: [
          'https://www.gnu.org/licenses/gpl-3.0-standalone.html',
          'https://opensource.org/licenses/GPL-3.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './GPL-3.0-or-later.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/GPL-3.0-or-later.json',
        referenceNumber: '387',
        name: 'GNU General Public License v3.0 or later',
        licenseId: 'GPL-3.0-or-later',
        seeAlso: [
          'https://www.gnu.org/licenses/gpl-3.0-standalone.html',
          'https://opensource.org/licenses/GPL-3.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './GPL-3.0-with-GCC-exception.html',
        isDeprecatedLicenseId: true,
        detailsUrl: 'http://spdx.org/licenses/GPL-3.0-with-GCC-exception.json',
        referenceNumber: '6',
        name: 'GNU General Public License v3.0 w/GCC Runtime Library exception',
        licenseId: 'GPL-3.0-with-GCC-exception',
        seeAlso: ['https://www.gnu.org/licenses/gcc-exception-3.1.html'],
        isOsiApproved: true,
      },
      {
        reference: './GPL-3.0-with-autoconf-exception.html',
        isDeprecatedLicenseId: true,
        detailsUrl: 'http://spdx.org/licenses/GPL-3.0-with-autoconf-exception.json',
        referenceNumber: '8',
        name: 'GNU General Public License v3.0 w/Autoconf exception',
        licenseId: 'GPL-3.0-with-autoconf-exception',
        seeAlso: ['https://www.gnu.org/licenses/autoconf-exception-3.0.html'],
        isOsiApproved: false,
      },
      {
        reference: './Giftware.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Giftware.json',
        referenceNumber: '367',
        name: 'Giftware License',
        licenseId: 'Giftware',
        seeAlso: [
          'http://liballeg.org/license.html#allegro-4-the-giftware-license',
        ],
        isOsiApproved: false,
      },
      {
        reference: './Glide.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Glide.json',
        referenceNumber: '117',
        name: '3dfx Glide License',
        licenseId: 'Glide',
        seeAlso: ['http://www.users.on.net/~triforce/glidexp/COPYING.txt'],
        isOsiApproved: false,
      },
      {
        reference: './Glulxe.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Glulxe.json',
        referenceNumber: '199',
        name: 'Glulxe License',
        licenseId: 'Glulxe',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/Glulxe'],
        isOsiApproved: false,
      },
      {
        reference: './HPND.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/HPND.json',
        referenceNumber: '148',
        name: 'Historical Permission Notice and Disclaimer',
        licenseId: 'HPND',
        seeAlso: ['https://opensource.org/licenses/HPND'],
        isOsiApproved: true,
      },
      {
        reference: './HPND-sell-variant.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/HPND-sell-variant.json',
        referenceNumber: '158',
        name: 'Historical Permission Notice and Disclaimer - sell variant',
        licenseId: 'HPND-sell-variant',
        seeAlso: [
          'https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/auth_gss/gss_generic_token.c?h=v4.19',
        ],
        isOsiApproved: false,
      },
      {
        reference: './HaskellReport.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/HaskellReport.json',
        referenceNumber: '205',
        name: 'Haskell Language Report License',
        licenseId: 'HaskellReport',
        seeAlso: [
          'https://fedoraproject.org/wiki/Licensing/Haskell_Language_Report_License',
        ],
        isOsiApproved: false,
      },
      {
        reference: './IBM-pibs.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/IBM-pibs.json',
        referenceNumber: '233',
        name: 'IBM PowerPC Initialization and Boot Software',
        licenseId: 'IBM-pibs',
        seeAlso: [
          'http://git.denx.de/?p=u-boot.git;a=blob;f=arch/powerpc/cpu/ppc4xx/miiphy.c;h=297155fdafa064b955e53e9832de93bfb0cfb85b;hb=9fab4bf4cc077c21e43941866f3f2c196f28670d',
        ],
        isOsiApproved: false,
      },
      {
        reference: './ICU.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/ICU.json',
        referenceNumber: '174',
        name: 'ICU License',
        licenseId: 'ICU',
        seeAlso: [
          'http://source.icu-project.org/repos/icu/icu/trunk/license.html',
        ],
        isOsiApproved: false,
      },
      {
        reference: './IJG.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/IJG.json',
        referenceNumber: '236',
        name: 'Independent JPEG Group License',
        licenseId: 'IJG',
        seeAlso: [
          'http://dev.w3.org/cvsweb/Amaya/libjpeg/Attic/README?rev=1.2',
        ],
        isOsiApproved: false,
      },
      {
        reference: './IPA.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/IPA.json',
        referenceNumber: '310',
        name: 'IPA Font License',
        licenseId: 'IPA',
        seeAlso: ['https://opensource.org/licenses/IPA'],
        isOsiApproved: true,
      },
      {
        reference: './IPL-1.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/IPL-1.0.json',
        referenceNumber: '309',
        name: 'IBM Public License v1.0',
        licenseId: 'IPL-1.0',
        seeAlso: ['https://opensource.org/licenses/IPL-1.0'],
        isOsiApproved: true,
      },
      {
        reference: './ISC.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/ISC.json',
        referenceNumber: '353',
        name: 'ISC License',
        licenseId: 'ISC',
        seeAlso: [
          'https://www.isc.org/downloads/software-support-policy/isc-license/',
          'https://opensource.org/licenses/ISC',
        ],
        isOsiApproved: true,
      },
      {
        reference: './ImageMagick.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/ImageMagick.json',
        referenceNumber: '326',
        name: 'ImageMagick License',
        licenseId: 'ImageMagick',
        seeAlso: ['http://www.imagemagick.org/script/license.php'],
        isOsiApproved: false,
      },
      {
        reference: './Imlib2.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/Imlib2.json',
        referenceNumber: '135',
        name: 'Imlib2 License',
        licenseId: 'Imlib2',
        seeAlso: [
          'http://trac.enlightenment.org/e/browser/trunk/imlib2/COPYING',
          'https://git.enlightenment.org/legacy/imlib2.git/tree/COPYING',
        ],
        isOsiApproved: false,
      },
      {
        reference: './Info-ZIP.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Info-ZIP.json',
        referenceNumber: '283',
        name: 'Info-ZIP License',
        licenseId: 'Info-ZIP',
        seeAlso: ['http://www.info-zip.org/license.html'],
        isOsiApproved: false,
      },
      {
        reference: './Intel.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/Intel.json',
        referenceNumber: '29',
        name: 'Intel Open Source License',
        licenseId: 'Intel',
        seeAlso: ['https://opensource.org/licenses/Intel'],
        isOsiApproved: true,
      },
      {
        reference: './Intel-ACPI.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Intel-ACPI.json',
        referenceNumber: '235',
        name: 'Intel ACPI Software License Agreement',
        licenseId: 'Intel-ACPI',
        seeAlso: [
          'https://fedoraproject.org/wiki/Licensing/Intel_ACPI_Software_License_Agreement',
        ],
        isOsiApproved: false,
      },
      {
        reference: './Interbase-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Interbase-1.0.json',
        referenceNumber: '323',
        name: 'Interbase Public License v1.0',
        licenseId: 'Interbase-1.0',
        seeAlso: [
          'https://web.archive.org/web/20060319014854/http://info.borland.com/devsupport/interbase/opensource/IPL.html',
        ],
        isOsiApproved: false,
      },
      {
        reference: './JPNIC.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/JPNIC.json',
        referenceNumber: '316',
        name: 'Japan Network Information Center License',
        licenseId: 'JPNIC',
        seeAlso: [
          'https://gitlab.isc.org/isc-projects/bind9/blob/master/COPYRIGHT#L366',
        ],
        isOsiApproved: false,
      },
      {
        reference: './JSON.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/JSON.json',
        referenceNumber: '197',
        name: 'JSON License',
        licenseId: 'JSON',
        seeAlso: ['http://www.json.org/license.html'],
        isOsiApproved: false,
      },
      {
        reference: './JasPer-2.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/JasPer-2.0.json',
        referenceNumber: '77',
        name: 'JasPer License',
        licenseId: 'JasPer-2.0',
        seeAlso: ['http://www.ece.uvic.ca/~mdadams/jasper/LICENSE'],
        isOsiApproved: false,
      },
      {
        reference: './LAL-1.2.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/LAL-1.2.json',
        referenceNumber: '153',
        name: 'Licence Art Libre 1.2',
        licenseId: 'LAL-1.2',
        seeAlso: ['http://artlibre.org/licence/lal/licence-art-libre-12/'],
        isOsiApproved: false,
      },
      {
        reference: './LAL-1.3.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/LAL-1.3.json',
        referenceNumber: '357',
        name: 'Licence Art Libre 1.3',
        licenseId: 'LAL-1.3',
        seeAlso: ['https://artlibre.org/'],
        isOsiApproved: false,
      },
      {
        reference: './LGPL-2.0.html',
        isDeprecatedLicenseId: true,
        detailsUrl: 'http://spdx.org/licenses/LGPL-2.0.json',
        referenceNumber: '276',
        name: 'GNU Library General Public License v2 only',
        licenseId: 'LGPL-2.0',
        seeAlso: [
          'https://www.gnu.org/licenses/old-licenses/lgpl-2.0-standalone.html',
        ],
        isOsiApproved: true,
      },
      {
        reference: './LGPL-2.0+.html',
        isDeprecatedLicenseId: true,
        detailsUrl: 'http://spdx.org/licenses/LGPL-2.0+.json',
        referenceNumber: '139',
        name: 'GNU Library General Public License v2 or later',
        licenseId: 'LGPL-2.0+',
        seeAlso: [
          'https://www.gnu.org/licenses/old-licenses/lgpl-2.0-standalone.html',
        ],
        isOsiApproved: true,
      },
      {
        reference: './LGPL-2.0-only.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/LGPL-2.0-only.json',
        referenceNumber: '328',
        name: 'GNU Library General Public License v2 only',
        licenseId: 'LGPL-2.0-only',
        seeAlso: [
          'https://www.gnu.org/licenses/old-licenses/lgpl-2.0-standalone.html',
        ],
        isOsiApproved: true,
      },
      {
        reference: './LGPL-2.0-or-later.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/LGPL-2.0-or-later.json',
        referenceNumber: '35',
        name: 'GNU Library General Public License v2 or later',
        licenseId: 'LGPL-2.0-or-later',
        seeAlso: [
          'https://www.gnu.org/licenses/old-licenses/lgpl-2.0-standalone.html',
        ],
        isOsiApproved: true,
      },
      {
        reference: './LGPL-2.1.html',
        isDeprecatedLicenseId: true,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/LGPL-2.1.json',
        referenceNumber: '182',
        name: 'GNU Lesser General Public License v2.1 only',
        licenseId: 'LGPL-2.1',
        seeAlso: [
          'https://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html',
          'https://opensource.org/licenses/LGPL-2.1',
        ],
        isOsiApproved: true,
      },
      {
        reference: './LGPL-2.1+.html',
        isDeprecatedLicenseId: true,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/LGPL-2.1+.json',
        referenceNumber: '202',
        name: 'GNU Library General Public License v2.1 or later',
        licenseId: 'LGPL-2.1+',
        seeAlso: [
          'https://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html',
          'https://opensource.org/licenses/LGPL-2.1',
        ],
        isOsiApproved: true,
      },
      {
        reference: './LGPL-2.1-only.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/LGPL-2.1-only.json',
        referenceNumber: '138',
        name: 'GNU Lesser General Public License v2.1 only',
        licenseId: 'LGPL-2.1-only',
        seeAlso: [
          'https://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html',
          'https://opensource.org/licenses/LGPL-2.1',
        ],
        isOsiApproved: true,
      },
      {
        reference: './LGPL-2.1-or-later.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/LGPL-2.1-or-later.json',
        referenceNumber: '269',
        name: 'GNU Lesser General Public License v2.1 or later',
        licenseId: 'LGPL-2.1-or-later',
        seeAlso: [
          'https://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html',
          'https://opensource.org/licenses/LGPL-2.1',
        ],
        isOsiApproved: true,
      },
      {
        reference: './LGPL-3.0.html',
        isDeprecatedLicenseId: true,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/LGPL-3.0.json',
        referenceNumber: '209',
        name: 'GNU Lesser General Public License v3.0 only',
        licenseId: 'LGPL-3.0',
        seeAlso: [
          'https://www.gnu.org/licenses/lgpl-3.0-standalone.html',
          'https://opensource.org/licenses/LGPL-3.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './LGPL-3.0+.html',
        isDeprecatedLicenseId: true,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/LGPL-3.0+.json',
        referenceNumber: '220',
        name: 'GNU Lesser General Public License v3.0 or later',
        licenseId: 'LGPL-3.0+',
        seeAlso: [
          'https://www.gnu.org/licenses/lgpl-3.0-standalone.html',
          'https://opensource.org/licenses/LGPL-3.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './LGPL-3.0-only.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/LGPL-3.0-only.json',
        referenceNumber: '47',
        name: 'GNU Lesser General Public License v3.0 only',
        licenseId: 'LGPL-3.0-only',
        seeAlso: [
          'https://www.gnu.org/licenses/lgpl-3.0-standalone.html',
          'https://opensource.org/licenses/LGPL-3.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './LGPL-3.0-or-later.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/LGPL-3.0-or-later.json',
        referenceNumber: '317',
        name: 'GNU Lesser General Public License v3.0 or later',
        licenseId: 'LGPL-3.0-or-later',
        seeAlso: [
          'https://www.gnu.org/licenses/lgpl-3.0-standalone.html',
          'https://opensource.org/licenses/LGPL-3.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './LGPLLR.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/LGPLLR.json',
        referenceNumber: '404',
        name: 'Lesser General Public License For Linguistic Resources',
        licenseId: 'LGPLLR',
        seeAlso: ['http://www-igm.univ-mlv.fr/~unitex/lgpllr.html'],
        isOsiApproved: false,
      },
      {
        reference: './LPL-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/LPL-1.0.json',
        referenceNumber: '371',
        name: 'Lucent Public License Version 1.0',
        licenseId: 'LPL-1.0',
        seeAlso: ['https://opensource.org/licenses/LPL-1.0'],
        isOsiApproved: true,
      },
      {
        reference: './LPL-1.02.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/LPL-1.02.json',
        referenceNumber: '120',
        name: 'Lucent Public License v1.02',
        licenseId: 'LPL-1.02',
        seeAlso: [
          'http://plan9.bell-labs.com/plan9/license.html',
          'https://opensource.org/licenses/LPL-1.02',
        ],
        isOsiApproved: true,
      },
      {
        reference: './LPPL-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/LPPL-1.0.json',
        referenceNumber: '82',
        name: 'LaTeX Project Public License v1.0',
        licenseId: 'LPPL-1.0',
        seeAlso: ['http://www.latex-project.org/lppl/lppl-1-0.txt'],
        isOsiApproved: false,
      },
      {
        reference: './LPPL-1.1.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/LPPL-1.1.json',
        referenceNumber: '168',
        name: 'LaTeX Project Public License v1.1',
        licenseId: 'LPPL-1.1',
        seeAlso: ['http://www.latex-project.org/lppl/lppl-1-1.txt'],
        isOsiApproved: false,
      },
      {
        reference: './LPPL-1.2.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/LPPL-1.2.json',
        referenceNumber: '160',
        name: 'LaTeX Project Public License v1.2',
        licenseId: 'LPPL-1.2',
        seeAlso: ['http://www.latex-project.org/lppl/lppl-1-2.txt'],
        isOsiApproved: false,
      },
      {
        reference: './LPPL-1.3a.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/LPPL-1.3a.json',
        referenceNumber: '270',
        name: 'LaTeX Project Public License v1.3a',
        licenseId: 'LPPL-1.3a',
        seeAlso: ['http://www.latex-project.org/lppl/lppl-1-3a.txt'],
        isOsiApproved: false,
      },
      {
        reference: './LPPL-1.3c.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/LPPL-1.3c.json',
        referenceNumber: '126',
        name: 'LaTeX Project Public License v1.3c',
        licenseId: 'LPPL-1.3c',
        seeAlso: [
          'http://www.latex-project.org/lppl/lppl-1-3c.txt',
          'https://opensource.org/licenses/LPPL-1.3c',
        ],
        isOsiApproved: true,
      },
      {
        reference: './Latex2e.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Latex2e.json',
        referenceNumber: '37',
        name: 'Latex2e License',
        licenseId: 'Latex2e',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/Latex2e'],
        isOsiApproved: false,
      },
      {
        reference: './Leptonica.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Leptonica.json',
        referenceNumber: '300',
        name: 'Leptonica License',
        licenseId: 'Leptonica',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/Leptonica'],
        isOsiApproved: false,
      },
      {
        reference: './LiLiQ-P-1.1.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/LiLiQ-P-1.1.json',
        referenceNumber: '79',
        name: 'Licence Libre du Qu\xe9bec \u2013 Permissive version 1.1',
        licenseId: 'LiLiQ-P-1.1',
        seeAlso: [
          'https://forge.gouv.qc.ca/licence/fr/liliq-v1-1/',
          'http://opensource.org/licenses/LiLiQ-P-1.1',
        ],
        isOsiApproved: true,
      },
      {
        reference: './LiLiQ-R-1.1.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/LiLiQ-R-1.1.json',
        referenceNumber: '290',
        name: 'Licence Libre du Qu\xe9bec \u2013 R\xe9ciprocit\xe9 version 1.1',
        licenseId: 'LiLiQ-R-1.1',
        seeAlso: [
          'https://www.forge.gouv.qc.ca/participez/licence-logicielle/licence-libre-du-quebec-liliq-en-francais/licence-libre-du-quebec-reciprocite-liliq-r-v1-1/',
          'http://opensource.org/licenses/LiLiQ-R-1.1',
        ],
        isOsiApproved: true,
      },
      {
        reference: './LiLiQ-Rplus-1.1.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/LiLiQ-Rplus-1.1.json',
        referenceNumber: '335',
        name: 'Licence Libre du Qu\xe9bec \u2013 R\xe9ciprocit\xe9 forte version 1.1',
        licenseId: 'LiLiQ-Rplus-1.1',
        seeAlso: [
          'https://www.forge.gouv.qc.ca/participez/licence-logicielle/licence-libre-du-quebec-liliq-en-francais/licence-libre-du-quebec-reciprocite-forte-liliq-r-v1-1/',
          'http://opensource.org/licenses/LiLiQ-Rplus-1.1',
        ],
        isOsiApproved: true,
      },
      {
        reference: './Libpng.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Libpng.json',
        referenceNumber: '376',
        name: 'libpng License',
        licenseId: 'Libpng',
        seeAlso: ['http://www.libpng.org/pub/png/src/libpng-LICENSE.txt'],
        isOsiApproved: false,
      },
      {
        reference: './Linux-OpenIB.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Linux-OpenIB.json',
        referenceNumber: '217',
        name: 'Linux Kernel Variant of OpenIB.org license',
        licenseId: 'Linux-OpenIB',
        seeAlso: [
          'https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/infiniband/core/sa.h',
        ],
        isOsiApproved: false,
      },
      {
        reference: './MIT.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/MIT.json',
        referenceNumber: '256',
        name: 'MIT License',
        licenseId: 'MIT',
        seeAlso: ['https://opensource.org/licenses/MIT'],
        isOsiApproved: true,
      },
      {
        reference: './MIT-0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/MIT-0.json',
        referenceNumber: '76',
        name: 'MIT No Attribution',
        licenseId: 'MIT-0',
        seeAlso: [
          'https://github.com/aws/mit-0',
          'https://romanrm.net/mit-zero',
          'https://github.com/awsdocs/aws-cloud9-user-guide/blob/master/LICENSE-SAMPLECODE',
        ],
        isOsiApproved: false,
      },
      {
        reference: './MIT-CMU.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/MIT-CMU.json',
        referenceNumber: '344',
        name: 'CMU License',
        licenseId: 'MIT-CMU',
        seeAlso: [
          'https://fedoraproject.org/wiki/Licensing:MIT?rd=Licensing/MIT#CMU_Style',
          'https://github.com/python-pillow/Pillow/blob/fffb426092c8db24a5f4b6df243a8a3c01fb63cd/LICENSE',
        ],
        isOsiApproved: false,
      },
      {
        reference: './MIT-advertising.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/MIT-advertising.json',
        referenceNumber: '192',
        name: 'Enlightenment License (e16)',
        licenseId: 'MIT-advertising',
        seeAlso: [
          'https://fedoraproject.org/wiki/Licensing/MIT_With_Advertising',
        ],
        isOsiApproved: false,
      },
      {
        reference: './MIT-enna.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/MIT-enna.json',
        referenceNumber: '52',
        name: 'enna License',
        licenseId: 'MIT-enna',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/MIT#enna'],
        isOsiApproved: false,
      },
      {
        reference: './MIT-feh.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/MIT-feh.json',
        referenceNumber: '365',
        name: 'feh License',
        licenseId: 'MIT-feh',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/MIT#feh'],
        isOsiApproved: false,
      },
      {
        reference: './MITNFA.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/MITNFA.json',
        referenceNumber: '336',
        name: 'MIT +no-false-attribs license',
        licenseId: 'MITNFA',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/MITNFA'],
        isOsiApproved: false,
      },
      {
        reference: './MPL-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/MPL-1.0.json',
        referenceNumber: '239',
        name: 'Mozilla Public License 1.0',
        licenseId: 'MPL-1.0',
        seeAlso: [
          'http://www.mozilla.org/MPL/MPL-1.0.html',
          'https://opensource.org/licenses/MPL-1.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './MPL-1.1.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/MPL-1.1.json',
        referenceNumber: '394',
        name: 'Mozilla Public License 1.1',
        licenseId: 'MPL-1.1',
        seeAlso: [
          'http://www.mozilla.org/MPL/MPL-1.1.html',
          'https://opensource.org/licenses/MPL-1.1',
        ],
        isOsiApproved: true,
      },
      {
        reference: './MPL-2.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/MPL-2.0.json',
        referenceNumber: '121',
        name: 'Mozilla Public License 2.0',
        licenseId: 'MPL-2.0',
        seeAlso: [
          'http://www.mozilla.org/MPL/2.0/',
          'https://opensource.org/licenses/MPL-2.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './MPL-2.0-no-copyleft-exception.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/MPL-2.0-no-copyleft-exception.json',
        referenceNumber: '183',
        name: 'Mozilla Public License 2.0 (no copyleft exception)',
        licenseId: 'MPL-2.0-no-copyleft-exception',
        seeAlso: [
          'http://www.mozilla.org/MPL/2.0/',
          'https://opensource.org/licenses/MPL-2.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './MS-PL.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/MS-PL.json',
        referenceNumber: '366',
        name: 'Microsoft Public License',
        licenseId: 'MS-PL',
        seeAlso: [
          'http://www.microsoft.com/opensource/licenses.mspx',
          'https://opensource.org/licenses/MS-PL',
        ],
        isOsiApproved: true,
      },
      {
        reference: './MS-RL.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/MS-RL.json',
        referenceNumber: '4',
        name: 'Microsoft Reciprocal License',
        licenseId: 'MS-RL',
        seeAlso: [
          'http://www.microsoft.com/opensource/licenses.mspx',
          'https://opensource.org/licenses/MS-RL',
        ],
        isOsiApproved: true,
      },
      {
        reference: './MTLL.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/MTLL.json',
        referenceNumber: '102',
        name: 'Matrix Template Library License',
        licenseId: 'MTLL',
        seeAlso: [
          'https://fedoraproject.org/wiki/Licensing/Matrix_Template_Library_License',
        ],
        isOsiApproved: false,
      },
      {
        reference: './MakeIndex.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/MakeIndex.json',
        referenceNumber: '343',
        name: 'MakeIndex License',
        licenseId: 'MakeIndex',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/MakeIndex'],
        isOsiApproved: false,
      },
      {
        reference: './MirOS.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/MirOS.json',
        referenceNumber: '369',
        name: 'The MirOS Licence',
        licenseId: 'MirOS',
        seeAlso: ['https://opensource.org/licenses/MirOS'],
        isOsiApproved: true,
      },
      {
        reference: './Motosoto.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Motosoto.json',
        referenceNumber: '12',
        name: 'Motosoto License',
        licenseId: 'Motosoto',
        seeAlso: ['https://opensource.org/licenses/Motosoto'],
        isOsiApproved: true,
      },
      {
        reference: './MulanPSL-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/MulanPSL-1.0.json',
        referenceNumber: '201',
        name: 'Mulan Permissive Software License, Version 1',
        licenseId: 'MulanPSL-1.0',
        seeAlso: [
          'https://license.coscl.org.cn/MulanPSL/',
          'https://github.com/yuwenlong/longphp/blob/25dfb70cc2a466dc4bb55ba30901cbce08d164b5/LICENSE',
        ],
        isOsiApproved: false,
      },
      {
        reference: './Multics.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Multics.json',
        referenceNumber: '164',
        name: 'Multics License',
        licenseId: 'Multics',
        seeAlso: ['https://opensource.org/licenses/Multics'],
        isOsiApproved: true,
      },
      {
        reference: './Mup.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Mup.json',
        referenceNumber: '305',
        name: 'Mup License',
        licenseId: 'Mup',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/Mup'],
        isOsiApproved: false,
      },
      {
        reference: './NASA-1.3.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/NASA-1.3.json',
        referenceNumber: '110',
        name: 'NASA Open Source Agreement 1.3',
        licenseId: 'NASA-1.3',
        seeAlso: [
          'http://ti.arc.nasa.gov/opensource/nosa/',
          'https://opensource.org/licenses/NASA-1.3',
        ],
        isOsiApproved: true,
      },
      {
        reference: './NBPL-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/NBPL-1.0.json',
        referenceNumber: '17',
        name: 'Net Boolean Public License v1',
        licenseId: 'NBPL-1.0',
        seeAlso: [
          'http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=37b4b3f6cc4bf34e1d3dec61e69914b9819d8894',
        ],
        isOsiApproved: false,
      },
      {
        reference: './NCSA.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/NCSA.json',
        referenceNumber: '187',
        name: 'University of Illinois/NCSA Open Source License',
        licenseId: 'NCSA',
        seeAlso: [
          'http://otm.illinois.edu/uiuc_openSource',
          'https://opensource.org/licenses/NCSA',
        ],
        isOsiApproved: true,
      },
      {
        reference: './NGPL.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/NGPL.json',
        referenceNumber: '308',
        name: 'Nethack General Public License',
        licenseId: 'NGPL',
        seeAlso: ['https://opensource.org/licenses/NGPL'],
        isOsiApproved: true,
      },
      {
        reference: './NLOD-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/NLOD-1.0.json',
        referenceNumber: '134',
        name: 'Norwegian Licence for Open Government Data',
        licenseId: 'NLOD-1.0',
        seeAlso: ['http://data.norge.no/nlod/en/1.0'],
        isOsiApproved: false,
      },
      {
        reference: './NLPL.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/NLPL.json',
        referenceNumber: '306',
        name: 'No Limit Public License',
        licenseId: 'NLPL',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/NLPL'],
        isOsiApproved: false,
      },
      {
        reference: './NOSL.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/NOSL.json',
        referenceNumber: '380',
        name: 'Netizen Open Source License',
        licenseId: 'NOSL',
        seeAlso: ['http://bits.netizen.com.au/licenses/NOSL/nosl.txt'],
        isOsiApproved: false,
      },
      {
        reference: './NPL-1.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/NPL-1.0.json',
        referenceNumber: '245',
        name: 'Netscape Public License v1.0',
        licenseId: 'NPL-1.0',
        seeAlso: ['http://www.mozilla.org/MPL/NPL/1.0/'],
        isOsiApproved: false,
      },
      {
        reference: './NPL-1.1.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/NPL-1.1.json',
        referenceNumber: '409',
        name: 'Netscape Public License v1.1',
        licenseId: 'NPL-1.1',
        seeAlso: ['http://www.mozilla.org/MPL/NPL/1.1/'],
        isOsiApproved: false,
      },
      {
        reference: './NPOSL-3.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/NPOSL-3.0.json',
        referenceNumber: '150',
        name: 'Non-Profit Open Software License 3.0',
        licenseId: 'NPOSL-3.0',
        seeAlso: ['https://opensource.org/licenses/NOSL3.0'],
        isOsiApproved: true,
      },
      {
        reference: './NRL.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/NRL.json',
        referenceNumber: '101',
        name: 'NRL License',
        licenseId: 'NRL',
        seeAlso: ['http://web.mit.edu/network/isakmp/nrllicense.html'],
        isOsiApproved: false,
      },
      {
        reference: './NTP.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/NTP.json',
        referenceNumber: '258',
        name: 'NTP License',
        licenseId: 'NTP',
        seeAlso: ['https://opensource.org/licenses/NTP'],
        isOsiApproved: true,
      },
      {
        reference: './NTP-0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/NTP-0.json',
        referenceNumber: '185',
        name: 'NTP No Attribution',
        licenseId: 'NTP-0',
        seeAlso: [
          'https://github.com/tytso/e2fsprogs/blob/master/lib/et/et_name.c',
        ],
        isOsiApproved: false,
      },
      {
        reference: './Naumen.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Naumen.json',
        referenceNumber: '282',
        name: 'Naumen Public License',
        licenseId: 'Naumen',
        seeAlso: ['https://opensource.org/licenses/Naumen'],
        isOsiApproved: true,
      },
      {
        reference: './Net-SNMP.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Net-SNMP.json',
        referenceNumber: '278',
        name: 'Net-SNMP License',
        licenseId: 'Net-SNMP',
        seeAlso: ['http://net-snmp.sourceforge.net/about/license.html'],
        isOsiApproved: false,
      },
      {
        reference: './NetCDF.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/NetCDF.json',
        referenceNumber: '212',
        name: 'NetCDF license',
        licenseId: 'NetCDF',
        seeAlso: ['http://www.unidata.ucar.edu/software/netcdf/copyright.html'],
        isOsiApproved: false,
      },
      {
        reference: './Newsletr.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Newsletr.json',
        referenceNumber: '358',
        name: 'Newsletr License',
        licenseId: 'Newsletr',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/Newsletr'],
        isOsiApproved: false,
      },
      {
        reference: './Nokia.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/Nokia.json',
        referenceNumber: '125',
        name: 'Nokia Open Source License',
        licenseId: 'Nokia',
        seeAlso: ['https://opensource.org/licenses/nokia'],
        isOsiApproved: true,
      },
      {
        reference: './Noweb.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Noweb.json',
        referenceNumber: '70',
        name: 'Noweb License',
        licenseId: 'Noweb',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/Noweb'],
        isOsiApproved: false,
      },
      {
        reference: './Nunit.html',
        isDeprecatedLicenseId: true,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/Nunit.json',
        referenceNumber: '87',
        name: 'Nunit License',
        licenseId: 'Nunit',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/Nunit'],
        isOsiApproved: false,
      },
      {
        reference: './OCCT-PL.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OCCT-PL.json',
        referenceNumber: '65',
        name: 'Open CASCADE Technology Public License',
        licenseId: 'OCCT-PL',
        seeAlso: ['http://www.opencascade.com/content/occt-public-license'],
        isOsiApproved: false,
      },
      {
        reference: './OCLC-2.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OCLC-2.0.json',
        referenceNumber: '341',
        name: 'OCLC Research Public License 2.0',
        licenseId: 'OCLC-2.0',
        seeAlso: [
          'http://www.oclc.org/research/activities/software/license/v2final.htm',
          'https://opensource.org/licenses/OCLC-2.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './ODC-By-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/ODC-By-1.0.json',
        referenceNumber: '381',
        name: 'Open Data Commons Attribution License v1.0',
        licenseId: 'ODC-By-1.0',
        seeAlso: ['https://opendatacommons.org/licenses/by/1.0/'],
        isOsiApproved: false,
      },
      {
        reference: './ODbL-1.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/ODbL-1.0.json',
        referenceNumber: '340',
        name: 'ODC Open Database License v1.0',
        licenseId: 'ODbL-1.0',
        seeAlso: ['http://www.opendatacommons.org/licenses/odbl/1.0/'],
        isOsiApproved: false,
      },
      {
        reference: './OFL-1.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/OFL-1.0.json',
        referenceNumber: '80',
        name: 'SIL Open Font License 1.0',
        licenseId: 'OFL-1.0',
        seeAlso: [
          'http://scripts.sil.org/cms/scripts/page.php?item_id=OFL10_web',
        ],
        isOsiApproved: false,
      },
      {
        reference: './OFL-1.0-RFN.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OFL-1.0-RFN.json',
        referenceNumber: '298',
        name: 'SIL Open Font License 1.0 with Reserved Font Name',
        licenseId: 'OFL-1.0-RFN',
        seeAlso: [
          'http://scripts.sil.org/cms/scripts/page.php?item_id=OFL10_web',
        ],
        isOsiApproved: false,
      },
      {
        reference: './OFL-1.0-no-RFN.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OFL-1.0-no-RFN.json',
        referenceNumber: '71',
        name: 'SIL Open Font License 1.0 with no Reserved Font Name',
        licenseId: 'OFL-1.0-no-RFN',
        seeAlso: [
          'http://scripts.sil.org/cms/scripts/page.php?item_id=OFL10_web',
        ],
        isOsiApproved: false,
      },
      {
        reference: './OFL-1.1.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/OFL-1.1.json',
        referenceNumber: '311',
        name: 'SIL Open Font License 1.1',
        licenseId: 'OFL-1.1',
        seeAlso: [
          'http://scripts.sil.org/cms/scripts/page.php?item_id=OFL_web',
          'https://opensource.org/licenses/OFL-1.1',
        ],
        isOsiApproved: true,
      },
      {
        reference: './OFL-1.1-RFN.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OFL-1.1-RFN.json',
        referenceNumber: '43',
        name: 'SIL Open Font License 1.1 with Reserved Font Name',
        licenseId: 'OFL-1.1-RFN',
        seeAlso: [
          'http://scripts.sil.org/cms/scripts/page.php?item_id=OFL_web',
          'https://opensource.org/licenses/OFL-1.1',
        ],
        isOsiApproved: true,
      },
      {
        reference: './OFL-1.1-no-RFN.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OFL-1.1-no-RFN.json',
        referenceNumber: '238',
        name: 'SIL Open Font License 1.1 with no Reserved Font Name',
        licenseId: 'OFL-1.1-no-RFN',
        seeAlso: [
          'http://scripts.sil.org/cms/scripts/page.php?item_id=OFL_web',
          'https://opensource.org/licenses/OFL-1.1',
        ],
        isOsiApproved: true,
      },
      {
        reference: './OGL-Canada-2.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OGL-Canada-2.0.json',
        referenceNumber: '346',
        name: 'Open Government Licence - Canada',
        licenseId: 'OGL-Canada-2.0',
        seeAlso: ['https://open.canada.ca/en/open-government-licence-canada'],
        isOsiApproved: false,
      },
      {
        reference: './OGL-UK-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OGL-UK-1.0.json',
        referenceNumber: '348',
        name: 'Open Government Licence v1.0',
        licenseId: 'OGL-UK-1.0',
        seeAlso: [
          'http://www.nationalarchives.gov.uk/doc/open-government-licence/version/1/',
        ],
        isOsiApproved: false,
      },
      {
        reference: './OGL-UK-2.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OGL-UK-2.0.json',
        referenceNumber: '13',
        name: 'Open Government Licence v2.0',
        licenseId: 'OGL-UK-2.0',
        seeAlso: [
          'http://www.nationalarchives.gov.uk/doc/open-government-licence/version/2/',
        ],
        isOsiApproved: false,
      },
      {
        reference: './OGL-UK-3.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OGL-UK-3.0.json',
        referenceNumber: '21',
        name: 'Open Government Licence v3.0',
        licenseId: 'OGL-UK-3.0',
        seeAlso: [
          'http://www.nationalarchives.gov.uk/doc/open-government-licence/version/3/',
        ],
        isOsiApproved: false,
      },
      {
        reference: './OGTSL.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OGTSL.json',
        referenceNumber: '26',
        name: 'Open Group Test Suite License',
        licenseId: 'OGTSL',
        seeAlso: [
          'http://www.opengroup.org/testing/downloads/The_Open_Group_TSL.txt',
          'https://opensource.org/licenses/OGTSL',
        ],
        isOsiApproved: true,
      },
      {
        reference: './OLDAP-1.1.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OLDAP-1.1.json',
        referenceNumber: '55',
        name: 'Open LDAP Public License v1.1',
        licenseId: 'OLDAP-1.1',
        seeAlso: [
          'http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=806557a5ad59804ef3a44d5abfbe91d706b0791f',
        ],
        isOsiApproved: false,
      },
      {
        reference: './OLDAP-1.2.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OLDAP-1.2.json',
        referenceNumber: '48',
        name: 'Open LDAP Public License v1.2',
        licenseId: 'OLDAP-1.2',
        seeAlso: [
          'http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=42b0383c50c299977b5893ee695cf4e486fb0dc7',
        ],
        isOsiApproved: false,
      },
      {
        reference: './OLDAP-1.3.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OLDAP-1.3.json',
        referenceNumber: '42',
        name: 'Open LDAP Public License v1.3',
        licenseId: 'OLDAP-1.3',
        seeAlso: [
          'http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=e5f8117f0ce088d0bd7a8e18ddf37eaa40eb09b1',
        ],
        isOsiApproved: false,
      },
      {
        reference: './OLDAP-1.4.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OLDAP-1.4.json',
        referenceNumber: '50',
        name: 'Open LDAP Public License v1.4',
        licenseId: 'OLDAP-1.4',
        seeAlso: [
          'http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=c9f95c2f3f2ffb5e0ae55fe7388af75547660941',
        ],
        isOsiApproved: false,
      },
      {
        reference: './OLDAP-2.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OLDAP-2.0.json',
        referenceNumber: '25',
        name: 'Open LDAP Public License v2.0 (or possibly 2.0A and 2.0B)',
        licenseId: 'OLDAP-2.0',
        seeAlso: [
          'http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=cbf50f4e1185a21abd4c0a54d3f4341fe28f36ea',
        ],
        isOsiApproved: false,
      },
      {
        reference: './OLDAP-2.0.1.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OLDAP-2.0.1.json',
        referenceNumber: '280',
        name: 'Open LDAP Public License v2.0.1',
        licenseId: 'OLDAP-2.0.1',
        seeAlso: [
          'http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=b6d68acd14e51ca3aab4428bf26522aa74873f0e',
        ],
        isOsiApproved: false,
      },
      {
        reference: './OLDAP-2.1.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OLDAP-2.1.json',
        referenceNumber: '400',
        name: 'Open LDAP Public License v2.1',
        licenseId: 'OLDAP-2.1',
        seeAlso: [
          'http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=b0d176738e96a0d3b9f85cb51e140a86f21be715',
        ],
        isOsiApproved: false,
      },
      {
        reference: './OLDAP-2.2.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OLDAP-2.2.json',
        referenceNumber: '318',
        name: 'Open LDAP Public License v2.2',
        licenseId: 'OLDAP-2.2',
        seeAlso: [
          'http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=470b0c18ec67621c85881b2733057fecf4a1acc3',
        ],
        isOsiApproved: false,
      },
      {
        reference: './OLDAP-2.2.1.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OLDAP-2.2.1.json',
        referenceNumber: '384',
        name: 'Open LDAP Public License v2.2.1',
        licenseId: 'OLDAP-2.2.1',
        seeAlso: [
          'http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=4bc786f34b50aa301be6f5600f58a980070f481e',
        ],
        isOsiApproved: false,
      },
      {
        reference: './OLDAP-2.2.2.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OLDAP-2.2.2.json',
        referenceNumber: '170',
        name: 'Open LDAP Public License 2.2.2',
        licenseId: 'OLDAP-2.2.2',
        seeAlso: [
          'http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=df2cc1e21eb7c160695f5b7cffd6296c151ba188',
        ],
        isOsiApproved: false,
      },
      {
        reference: './OLDAP-2.3.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/OLDAP-2.3.json',
        referenceNumber: '230',
        name: 'Open LDAP Public License v2.3',
        licenseId: 'OLDAP-2.3',
        seeAlso: [
          'http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=d32cf54a32d581ab475d23c810b0a7fbaf8d63c3',
        ],
        isOsiApproved: false,
      },
      {
        reference: './OLDAP-2.4.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OLDAP-2.4.json',
        referenceNumber: '115',
        name: 'Open LDAP Public License v2.4',
        licenseId: 'OLDAP-2.4',
        seeAlso: [
          'http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=cd1284c4a91a8a380d904eee68d1583f989ed386',
        ],
        isOsiApproved: false,
      },
      {
        reference: './OLDAP-2.5.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OLDAP-2.5.json',
        referenceNumber: '108',
        name: 'Open LDAP Public License v2.5',
        licenseId: 'OLDAP-2.5',
        seeAlso: [
          'http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=6852b9d90022e8593c98205413380536b1b5a7cf',
        ],
        isOsiApproved: false,
      },
      {
        reference: './OLDAP-2.6.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OLDAP-2.6.json',
        referenceNumber: '109',
        name: 'Open LDAP Public License v2.6',
        licenseId: 'OLDAP-2.6',
        seeAlso: [
          'http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=1cae062821881f41b73012ba816434897abf4205',
        ],
        isOsiApproved: false,
      },
      {
        reference: './OLDAP-2.7.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/OLDAP-2.7.json',
        referenceNumber: '229',
        name: 'Open LDAP Public License v2.7',
        licenseId: 'OLDAP-2.7',
        seeAlso: [
          'http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=47c2415c1df81556eeb39be6cad458ef87c534a2',
        ],
        isOsiApproved: false,
      },
      {
        reference: './OLDAP-2.8.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OLDAP-2.8.json',
        referenceNumber: '252',
        name: 'Open LDAP Public License v2.8',
        licenseId: 'OLDAP-2.8',
        seeAlso: ['http://www.openldap.org/software/release/license.html'],
        isOsiApproved: false,
      },
      {
        reference: './OML.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OML.json',
        referenceNumber: '171',
        name: 'Open Market License',
        licenseId: 'OML',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/Open_Market_License'],
        isOsiApproved: false,
      },
      {
        reference: './OPL-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OPL-1.0.json',
        referenceNumber: '338',
        name: 'Open Public License v1.0',
        licenseId: 'OPL-1.0',
        seeAlso: [
          'http://old.koalateam.com/jackaroo/OPL_1_0.TXT',
          'https://fedoraproject.org/wiki/Licensing/Open_Public_License',
        ],
        isOsiApproved: false,
      },
      {
        reference: './OSET-PL-2.1.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/OSET-PL-2.1.json',
        referenceNumber: '203',
        name: 'OSET Public License version 2.1',
        licenseId: 'OSET-PL-2.1',
        seeAlso: [
          'http://www.osetfoundation.org/public-license',
          'https://opensource.org/licenses/OPL-2.1',
        ],
        isOsiApproved: true,
      },
      {
        reference: './OSL-1.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/OSL-1.0.json',
        referenceNumber: '95',
        name: 'Open Software License 1.0',
        licenseId: 'OSL-1.0',
        seeAlso: ['https://opensource.org/licenses/OSL-1.0'],
        isOsiApproved: true,
      },
      {
        reference: './OSL-1.1.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/OSL-1.1.json',
        referenceNumber: '178',
        name: 'Open Software License 1.1',
        licenseId: 'OSL-1.1',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/OSL1.1'],
        isOsiApproved: false,
      },
      {
        reference: './OSL-2.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/OSL-2.0.json',
        referenceNumber: '364',
        name: 'Open Software License 2.0',
        licenseId: 'OSL-2.0',
        seeAlso: [
          'http://web.archive.org/web/20041020171434/http://www.rosenlaw.com/osl2.0.html',
        ],
        isOsiApproved: true,
      },
      {
        reference: './OSL-2.1.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/OSL-2.1.json',
        referenceNumber: '157',
        name: 'Open Software License 2.1',
        licenseId: 'OSL-2.1',
        seeAlso: [
          'http://web.archive.org/web/20050212003940/http://www.rosenlaw.com/osl21.htm',
          'https://opensource.org/licenses/OSL-2.1',
        ],
        isOsiApproved: true,
      },
      {
        reference: './OSL-3.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/OSL-3.0.json',
        referenceNumber: '149',
        name: 'Open Software License 3.0',
        licenseId: 'OSL-3.0',
        seeAlso: [
          'https://web.archive.org/web/20120101081418/http://rosenlaw.com:80/OSL3.0.htm',
          'https://opensource.org/licenses/OSL-3.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './OpenSSL.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/OpenSSL.json',
        referenceNumber: '83',
        name: 'OpenSSL License',
        licenseId: 'OpenSSL',
        seeAlso: ['http://www.openssl.org/source/license.html'],
        isOsiApproved: false,
      },
      {
        reference: './PDDL-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/PDDL-1.0.json',
        referenceNumber: '132',
        name: 'ODC Public Domain Dedication & License 1.0',
        licenseId: 'PDDL-1.0',
        seeAlso: ['http://opendatacommons.org/licenses/pddl/1.0/'],
        isOsiApproved: false,
      },
      {
        reference: './PHP-3.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/PHP-3.0.json',
        referenceNumber: '191',
        name: 'PHP License v3.0',
        licenseId: 'PHP-3.0',
        seeAlso: [
          'http://www.php.net/license/3_0.txt',
          'https://opensource.org/licenses/PHP-3.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './PHP-3.01.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/PHP-3.01.json',
        referenceNumber: '3',
        name: 'PHP License v3.01',
        licenseId: 'PHP-3.01',
        seeAlso: ['http://www.php.net/license/3_01.txt'],
        isOsiApproved: false,
      },
      {
        reference: './PSF-2.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/PSF-2.0.json',
        referenceNumber: '91',
        name: 'Python Software Foundation License 2.0',
        licenseId: 'PSF-2.0',
        seeAlso: ['https://opensource.org/licenses/Python-2.0'],
        isOsiApproved: false,
      },
      {
        reference: './Parity-6.0.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Parity-6.0.0.json',
        referenceNumber: '406',
        name: 'The Parity Public License 6.0.0',
        licenseId: 'Parity-6.0.0',
        seeAlso: ['https://paritylicense.com/versions/6.0.0.html'],
        isOsiApproved: false,
      },
      {
        reference: './Plexus.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Plexus.json',
        referenceNumber: '156',
        name: 'Plexus Classworlds License',
        licenseId: 'Plexus',
        seeAlso: [
          'https://fedoraproject.org/wiki/Licensing/Plexus_Classworlds_License',
        ],
        isOsiApproved: false,
      },
      {
        reference: './PostgreSQL.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/PostgreSQL.json',
        referenceNumber: '11',
        name: 'PostgreSQL License',
        licenseId: 'PostgreSQL',
        seeAlso: [
          'http://www.postgresql.org/about/licence',
          'https://opensource.org/licenses/PostgreSQL',
        ],
        isOsiApproved: true,
      },
      {
        reference: './Python-2.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/Python-2.0.json',
        referenceNumber: '393',
        name: 'Python License 2.0',
        licenseId: 'Python-2.0',
        seeAlso: ['https://opensource.org/licenses/Python-2.0'],
        isOsiApproved: true,
      },
      {
        reference: './QPL-1.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/QPL-1.0.json',
        referenceNumber: '289',
        name: 'Q Public License 1.0',
        licenseId: 'QPL-1.0',
        seeAlso: [
          'http://doc.qt.nokia.com/3.3/license.html',
          'https://opensource.org/licenses/QPL-1.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './Qhull.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Qhull.json',
        referenceNumber: '124',
        name: 'Qhull License',
        licenseId: 'Qhull',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/Qhull'],
        isOsiApproved: false,
      },
      {
        reference: './RHeCos-1.1.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/RHeCos-1.1.json',
        referenceNumber: '61',
        name: 'Red Hat eCos Public License v1.1',
        licenseId: 'RHeCos-1.1',
        seeAlso: ['http://ecos.sourceware.org/old-license.html'],
        isOsiApproved: false,
      },
      {
        reference: './RPL-1.1.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/RPL-1.1.json',
        referenceNumber: '216',
        name: 'Reciprocal Public License 1.1',
        licenseId: 'RPL-1.1',
        seeAlso: ['https://opensource.org/licenses/RPL-1.1'],
        isOsiApproved: true,
      },
      {
        reference: './RPL-1.5.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/RPL-1.5.json',
        referenceNumber: '105',
        name: 'Reciprocal Public License 1.5',
        licenseId: 'RPL-1.5',
        seeAlso: ['https://opensource.org/licenses/RPL-1.5'],
        isOsiApproved: true,
      },
      {
        reference: './RPSL-1.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/RPSL-1.0.json',
        referenceNumber: '53',
        name: 'RealNetworks Public Source License v1.0',
        licenseId: 'RPSL-1.0',
        seeAlso: [
          'https://helixcommunity.org/content/rpsl',
          'https://opensource.org/licenses/RPSL-1.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './RSA-MD.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/RSA-MD.json',
        referenceNumber: '279',
        name: 'RSA Message-Digest License ',
        licenseId: 'RSA-MD',
        seeAlso: ['http://www.faqs.org/rfcs/rfc1321.html'],
        isOsiApproved: false,
      },
      {
        reference: './RSCPL.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/RSCPL.json',
        referenceNumber: '339',
        name: 'Ricoh Source Code Public License',
        licenseId: 'RSCPL',
        seeAlso: [
          'http://wayback.archive.org/web/20060715140826/http://www.risource.org/RPL/RPL-1.0A.shtml',
          'https://opensource.org/licenses/RSCPL',
        ],
        isOsiApproved: true,
      },
      {
        reference: './Rdisc.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Rdisc.json',
        referenceNumber: '322',
        name: 'Rdisc License',
        licenseId: 'Rdisc',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/Rdisc_License'],
        isOsiApproved: false,
      },
      {
        reference: './Ruby.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/Ruby.json',
        referenceNumber: '14',
        name: 'Ruby License',
        licenseId: 'Ruby',
        seeAlso: ['http://www.ruby-lang.org/en/LICENSE.txt'],
        isOsiApproved: false,
      },
      {
        reference: './SAX-PD.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/SAX-PD.json',
        referenceNumber: '152',
        name: 'Sax Public Domain Notice',
        licenseId: 'SAX-PD',
        seeAlso: ['http://www.saxproject.org/copying.html'],
        isOsiApproved: false,
      },
      {
        reference: './SCEA.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/SCEA.json',
        referenceNumber: '137',
        name: 'SCEA Shared Source License',
        licenseId: 'SCEA',
        seeAlso: ['http://research.scea.com/scea_shared_source_license.html'],
        isOsiApproved: false,
      },
      {
        reference: './SGI-B-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/SGI-B-1.0.json',
        referenceNumber: '189',
        name: 'SGI Free Software License B v1.0',
        licenseId: 'SGI-B-1.0',
        seeAlso: ['http://oss.sgi.com/projects/FreeB/SGIFreeSWLicB.1.0.html'],
        isOsiApproved: false,
      },
      {
        reference: './SGI-B-1.1.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/SGI-B-1.1.json',
        referenceNumber: '288',
        name: 'SGI Free Software License B v1.1',
        licenseId: 'SGI-B-1.1',
        seeAlso: ['http://oss.sgi.com/projects/FreeB/'],
        isOsiApproved: false,
      },
      {
        reference: './SGI-B-2.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/SGI-B-2.0.json',
        referenceNumber: '31',
        name: 'SGI Free Software License B v2.0',
        licenseId: 'SGI-B-2.0',
        seeAlso: ['http://oss.sgi.com/projects/FreeB/SGIFreeSWLicB.2.0.pdf'],
        isOsiApproved: false,
      },
      {
        reference: './SHL-0.5.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/SHL-0.5.json',
        referenceNumber: '49',
        name: 'Solderpad Hardware License v0.5',
        licenseId: 'SHL-0.5',
        seeAlso: ['https://solderpad.org/licenses/SHL-0.5/'],
        isOsiApproved: false,
      },
      {
        reference: './SHL-0.51.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/SHL-0.51.json',
        referenceNumber: '281',
        name: 'Solderpad Hardware License, Version 0.51',
        licenseId: 'SHL-0.51',
        seeAlso: ['https://solderpad.org/licenses/SHL-0.51/'],
        isOsiApproved: false,
      },
      {
        reference: './SISSL.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/SISSL.json',
        referenceNumber: '78',
        name: 'Sun Industry Standards Source License v1.1',
        licenseId: 'SISSL',
        seeAlso: [
          'http://www.openoffice.org/licenses/sissl_license.html',
          'https://opensource.org/licenses/SISSL',
        ],
        isOsiApproved: true,
      },
      {
        reference: './SISSL-1.2.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/SISSL-1.2.json',
        referenceNumber: '62',
        name: 'Sun Industry Standards Source License v1.2',
        licenseId: 'SISSL-1.2',
        seeAlso: [
          'http://gridscheduler.sourceforge.net/Gridengine_SISSL_license.html',
        ],
        isOsiApproved: false,
      },
      {
        reference: './SMLNJ.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/SMLNJ.json',
        referenceNumber: '218',
        name: 'Standard ML of New Jersey License',
        licenseId: 'SMLNJ',
        seeAlso: ['https://www.smlnj.org/license.html'],
        isOsiApproved: false,
      },
      {
        reference: './SMPPL.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/SMPPL.json',
        referenceNumber: '106',
        name: 'Secure Messaging Protocol Public License',
        licenseId: 'SMPPL',
        seeAlso: [
          'https://github.com/dcblake/SMP/blob/master/Documentation/License.txt',
        ],
        isOsiApproved: false,
      },
      {
        reference: './SNIA.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/SNIA.json',
        referenceNumber: '302',
        name: 'SNIA Public License 1.1',
        licenseId: 'SNIA',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/SNIA_Public_License'],
        isOsiApproved: false,
      },
      {
        reference: './SPL-1.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/SPL-1.0.json',
        referenceNumber: '247',
        name: 'Sun Public License v1.0',
        licenseId: 'SPL-1.0',
        seeAlso: ['https://opensource.org/licenses/SPL-1.0'],
        isOsiApproved: true,
      },
      {
        reference: './SSH-OpenSSH.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/SSH-OpenSSH.json',
        referenceNumber: '22',
        name: 'SSH OpenSSH license',
        licenseId: 'SSH-OpenSSH',
        seeAlso: [
          'https://github.com/openssh/openssh-portable/blob/1b11ea7c58cd5c59838b5fa574cd456d6047b2d4/LICENCE#L10',
        ],
        isOsiApproved: false,
      },
      {
        reference: './SSH-short.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/SSH-short.json',
        referenceNumber: '67',
        name: 'SSH short notice',
        licenseId: 'SSH-short',
        seeAlso: [
          'https://github.com/openssh/openssh-portable/blob/1b11ea7c58cd5c59838b5fa574cd456d6047b2d4/pathnames.h',
          'http://web.mit.edu/kolya/.f/root/athena.mit.edu/sipb.mit.edu/project/openssh/OldFiles/src/openssh-2.9.9p2/ssh-add.1',
          'https://joinup.ec.europa.eu/svn/lesoll/trunk/italc/lib/src/dsa_key.cpp',
        ],
        isOsiApproved: false,
      },
      {
        reference: './SSPL-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/SSPL-1.0.json',
        referenceNumber: '334',
        name: 'Server Side Public License, v 1',
        licenseId: 'SSPL-1.0',
        seeAlso: ['https://www.mongodb.com/licensing/server-side-public-license'],
        isOsiApproved: false,
      },
      {
        reference: './SWL.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/SWL.json',
        referenceNumber: '93',
        name: 'Scheme Widget Library (SWL) Software License Agreement',
        licenseId: 'SWL',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/SWL'],
        isOsiApproved: false,
      },
      {
        reference: './Saxpath.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Saxpath.json',
        referenceNumber: '34',
        name: 'Saxpath License',
        licenseId: 'Saxpath',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/Saxpath_License'],
        isOsiApproved: false,
      },
      {
        reference: './Sendmail.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Sendmail.json',
        referenceNumber: '293',
        name: 'Sendmail License',
        licenseId: 'Sendmail',
        seeAlso: [
          'http://www.sendmail.com/pdfs/open_source/sendmail_license.pdf',
          'https://web.archive.org/web/20160322142305/https://www.sendmail.com/pdfs/open_source/sendmail_license.pdf',
        ],
        isOsiApproved: false,
      },
      {
        reference: './Sendmail-8.23.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Sendmail-8.23.json',
        referenceNumber: '176',
        name: 'Sendmail License 8.23',
        licenseId: 'Sendmail-8.23',
        seeAlso: [
          'https://www.proofpoint.com/sites/default/files/sendmail-license.pdf',
          'https://web.archive.org/web/20181003101040/https://www.proofpoint.com/sites/default/files/sendmail-license.pdf',
        ],
        isOsiApproved: false,
      },
      {
        reference: './SimPL-2.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/SimPL-2.0.json',
        referenceNumber: '250',
        name: 'Simple Public License 2.0',
        licenseId: 'SimPL-2.0',
        seeAlso: ['https://opensource.org/licenses/SimPL-2.0'],
        isOsiApproved: true,
      },
      {
        reference: './Sleepycat.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/Sleepycat.json',
        referenceNumber: '56',
        name: 'Sleepycat License',
        licenseId: 'Sleepycat',
        seeAlso: ['https://opensource.org/licenses/Sleepycat'],
        isOsiApproved: true,
      },
      {
        reference: './Spencer-86.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Spencer-86.json',
        referenceNumber: '184',
        name: 'Spencer License 86',
        licenseId: 'Spencer-86',
        seeAlso: [
          'https://fedoraproject.org/wiki/Licensing/Henry_Spencer_Reg-Ex_Library_License',
        ],
        isOsiApproved: false,
      },
      {
        reference: './Spencer-94.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Spencer-94.json',
        referenceNumber: '213',
        name: 'Spencer License 94',
        licenseId: 'Spencer-94',
        seeAlso: [
          'https://fedoraproject.org/wiki/Licensing/Henry_Spencer_Reg-Ex_Library_License',
        ],
        isOsiApproved: false,
      },
      {
        reference: './Spencer-99.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Spencer-99.json',
        referenceNumber: '64',
        name: 'Spencer License 99',
        licenseId: 'Spencer-99',
        seeAlso: [
          'http://www.opensource.apple.com/source/tcl/tcl-5/tcl/generic/regfronts.c',
        ],
        isOsiApproved: false,
      },
      {
        reference: './StandardML-NJ.html',
        isDeprecatedLicenseId: true,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/StandardML-NJ.json',
        referenceNumber: '285',
        name: 'Standard ML of New Jersey License',
        licenseId: 'StandardML-NJ',
        seeAlso: ['http://www.smlnj.org//license.html'],
        isOsiApproved: false,
      },
      {
        reference: './SugarCRM-1.1.3.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/SugarCRM-1.1.3.json',
        referenceNumber: '342',
        name: 'SugarCRM Public License v1.1.3',
        licenseId: 'SugarCRM-1.1.3',
        seeAlso: ['http://www.sugarcrm.com/crm/SPL'],
        isOsiApproved: false,
      },
      {
        reference: './TAPR-OHL-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/TAPR-OHL-1.0.json',
        referenceNumber: '9',
        name: 'TAPR Open Hardware License v1.0',
        licenseId: 'TAPR-OHL-1.0',
        seeAlso: ['https://www.tapr.org/OHL'],
        isOsiApproved: false,
      },
      {
        reference: './TCL.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/TCL.json',
        referenceNumber: '54',
        name: 'TCL/TK License',
        licenseId: 'TCL',
        seeAlso: [
          'http://www.tcl.tk/software/tcltk/license.html',
          'https://fedoraproject.org/wiki/Licensing/TCL',
        ],
        isOsiApproved: false,
      },
      {
        reference: './TCP-wrappers.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/TCP-wrappers.json',
        referenceNumber: '234',
        name: 'TCP Wrappers License',
        licenseId: 'TCP-wrappers',
        seeAlso: ['http://rc.quest.com/topics/openssh/license.php#tcpwrappers'],
        isOsiApproved: false,
      },
      {
        reference: './TMate.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/TMate.json',
        referenceNumber: '402',
        name: 'TMate Open Source License',
        licenseId: 'TMate',
        seeAlso: ['http://svnkit.com/license.html'],
        isOsiApproved: false,
      },
      {
        reference: './TORQUE-1.1.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/TORQUE-1.1.json',
        referenceNumber: '188',
        name: 'TORQUE v2.5+ Software License v1.1',
        licenseId: 'TORQUE-1.1',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/TORQUEv1.1'],
        isOsiApproved: false,
      },
      {
        reference: './TOSL.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/TOSL.json',
        referenceNumber: '251',
        name: 'Trusster Open Source License',
        licenseId: 'TOSL',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/TOSL'],
        isOsiApproved: false,
      },
      {
        reference: './TU-Berlin-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/TU-Berlin-1.0.json',
        referenceNumber: '372',
        name: 'Technische Universitaet Berlin License 1.0',
        licenseId: 'TU-Berlin-1.0',
        seeAlso: [
          'https://github.com/swh/ladspa/blob/7bf6f3799fdba70fda297c2d8fd9f526803d9680/gsm/COPYRIGHT',
        ],
        isOsiApproved: false,
      },
      {
        reference: './TU-Berlin-2.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/TU-Berlin-2.0.json',
        referenceNumber: '392',
        name: 'Technische Universitaet Berlin License 2.0',
        licenseId: 'TU-Berlin-2.0',
        seeAlso: [
          'https://github.com/CorsixTH/deps/blob/fd339a9f526d1d9c9f01ccf39e438a015da50035/licences/libgsm.txt',
        ],
        isOsiApproved: false,
      },
      {
        reference: './UCL-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/UCL-1.0.json',
        referenceNumber: '291',
        name: 'Upstream Compatibility License v1.0',
        licenseId: 'UCL-1.0',
        seeAlso: ['https://opensource.org/licenses/UCL-1.0'],
        isOsiApproved: true,
      },
      {
        reference: './UPL-1.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/UPL-1.0.json',
        referenceNumber: '144',
        name: 'Universal Permissive License v1.0',
        licenseId: 'UPL-1.0',
        seeAlso: ['https://opensource.org/licenses/UPL'],
        isOsiApproved: true,
      },
      {
        reference: './Unicode-DFS-2015.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Unicode-DFS-2015.json',
        referenceNumber: '260',
        name: 'Unicode License Agreement - Data Files and Software (2015)',
        licenseId: 'Unicode-DFS-2015',
        seeAlso: [
          'https://web.archive.org/web/20151224134844/http://unicode.org/copyright.html',
        ],
        isOsiApproved: false,
      },
      {
        reference: './Unicode-DFS-2016.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Unicode-DFS-2016.json',
        referenceNumber: '370',
        name: 'Unicode License Agreement - Data Files and Software (2016)',
        licenseId: 'Unicode-DFS-2016',
        seeAlso: ['http://www.unicode.org/copyright.html'],
        isOsiApproved: false,
      },
      {
        reference: './Unicode-TOU.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Unicode-TOU.json',
        referenceNumber: '16',
        name: 'Unicode Terms of Use',
        licenseId: 'Unicode-TOU',
        seeAlso: ['http://www.unicode.org/copyright.html'],
        isOsiApproved: false,
      },
      {
        reference: './Unlicense.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/Unlicense.json',
        referenceNumber: '173',
        name: 'The Unlicense',
        licenseId: 'Unlicense',
        seeAlso: ['https://unlicense.org/'],
        isOsiApproved: false,
      },
      {
        reference: './VOSTROM.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/VOSTROM.json',
        referenceNumber: '352',
        name: 'VOSTROM Public License for Open Source',
        licenseId: 'VOSTROM',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/VOSTROM'],
        isOsiApproved: false,
      },
      {
        reference: './VSL-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/VSL-1.0.json',
        referenceNumber: '390',
        name: 'Vovida Software License v1.0',
        licenseId: 'VSL-1.0',
        seeAlso: ['https://opensource.org/licenses/VSL-1.0'],
        isOsiApproved: true,
      },
      {
        reference: './Vim.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/Vim.json',
        referenceNumber: '206',
        name: 'Vim License',
        licenseId: 'Vim',
        seeAlso: ['http://vimdoc.sourceforge.net/htmldoc/uganda.html'],
        isOsiApproved: false,
      },
      {
        reference: './W3C.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/W3C.json',
        referenceNumber: '107',
        name: 'W3C Software Notice and License (2002-12-31)',
        licenseId: 'W3C',
        seeAlso: [
          'http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231.html',
          'https://opensource.org/licenses/W3C',
        ],
        isOsiApproved: true,
      },
      {
        reference: './W3C-19980720.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/W3C-19980720.json',
        referenceNumber: '266',
        name: 'W3C Software Notice and License (1998-07-20)',
        licenseId: 'W3C-19980720',
        seeAlso: [
          'http://www.w3.org/Consortium/Legal/copyright-software-19980720.html',
        ],
        isOsiApproved: false,
      },
      {
        reference: './W3C-20150513.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/W3C-20150513.json',
        referenceNumber: '111',
        name: 'W3C Software Notice and Document License (2015-05-13)',
        licenseId: 'W3C-20150513',
        seeAlso: [
          'https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document',
        ],
        isOsiApproved: false,
      },
      {
        reference: './WTFPL.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/WTFPL.json',
        referenceNumber: '20',
        name: 'Do What The F*ck You Want To Public License',
        licenseId: 'WTFPL',
        seeAlso: ['http://sam.zoy.org/wtfpl/COPYING'],
        isOsiApproved: false,
      },
      {
        reference: './Watcom-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Watcom-1.0.json',
        referenceNumber: '141',
        name: 'Sybase Open Watcom Public License 1.0',
        licenseId: 'Watcom-1.0',
        seeAlso: ['https://opensource.org/licenses/Watcom-1.0'],
        isOsiApproved: true,
      },
      {
        reference: './Wsuipa.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Wsuipa.json',
        referenceNumber: '255',
        name: 'Wsuipa License',
        licenseId: 'Wsuipa',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/Wsuipa'],
        isOsiApproved: false,
      },
      {
        reference: './X11.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/X11.json',
        referenceNumber: '99',
        name: 'X11 License',
        licenseId: 'X11',
        seeAlso: ['http://www.xfree86.org/3.3.6/COPYRIGHT2.html#3'],
        isOsiApproved: false,
      },
      {
        reference: './XFree86-1.1.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/XFree86-1.1.json',
        referenceNumber: '155',
        name: 'XFree86 License 1.1',
        licenseId: 'XFree86-1.1',
        seeAlso: ['http://www.xfree86.org/current/LICENSE4.html'],
        isOsiApproved: false,
      },
      {
        reference: './XSkat.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/XSkat.json',
        referenceNumber: '81',
        name: 'XSkat License',
        licenseId: 'XSkat',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/XSkat_License'],
        isOsiApproved: false,
      },
      {
        reference: './Xerox.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Xerox.json',
        referenceNumber: '224',
        name: 'Xerox License',
        licenseId: 'Xerox',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/Xerox'],
        isOsiApproved: false,
      },
      {
        reference: './Xnet.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Xnet.json',
        referenceNumber: '313',
        name: 'X.Net License',
        licenseId: 'Xnet',
        seeAlso: ['https://opensource.org/licenses/Xnet'],
        isOsiApproved: true,
      },
      {
        reference: './YPL-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/YPL-1.0.json',
        referenceNumber: '292',
        name: 'Yahoo! Public License v1.0',
        licenseId: 'YPL-1.0',
        seeAlso: ['http://www.zimbra.com/license/yahoo_public_license_1.0.html'],
        isOsiApproved: false,
      },
      {
        reference: './YPL-1.1.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/YPL-1.1.json',
        referenceNumber: '40',
        name: 'Yahoo! Public License v1.1',
        licenseId: 'YPL-1.1',
        seeAlso: ['http://www.zimbra.com/license/yahoo_public_license_1.1.html'],
        isOsiApproved: false,
      },
      {
        reference: './ZPL-1.1.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/ZPL-1.1.json',
        referenceNumber: '85',
        name: 'Zope Public License 1.1',
        licenseId: 'ZPL-1.1',
        seeAlso: ['http://old.zope.org/Resources/License/ZPL-1.1'],
        isOsiApproved: false,
      },
      {
        reference: './ZPL-2.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/ZPL-2.0.json',
        referenceNumber: '112',
        name: 'Zope Public License 2.0',
        licenseId: 'ZPL-2.0',
        seeAlso: [
          'http://old.zope.org/Resources/License/ZPL-2.0',
          'https://opensource.org/licenses/ZPL-2.0',
        ],
        isOsiApproved: true,
      },
      {
        reference: './ZPL-2.1.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/ZPL-2.1.json',
        referenceNumber: '368',
        name: 'Zope Public License 2.1',
        licenseId: 'ZPL-2.1',
        seeAlso: ['http://old.zope.org/Resources/ZPL/'],
        isOsiApproved: false,
      },
      {
        reference: './Zed.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Zed.json',
        referenceNumber: '114',
        name: 'Zed License',
        licenseId: 'Zed',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/Zed'],
        isOsiApproved: false,
      },
      {
        reference: './Zend-2.0.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/Zend-2.0.json',
        referenceNumber: '373',
        name: 'Zend License v2.0',
        licenseId: 'Zend-2.0',
        seeAlso: [
          'https://web.archive.org/web/20130517195954/http://www.zend.com/license/2_00.txt',
        ],
        isOsiApproved: false,
      },
      {
        reference: './Zimbra-1.3.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/Zimbra-1.3.json',
        referenceNumber: '175',
        name: 'Zimbra Public License v1.3',
        licenseId: 'Zimbra-1.3',
        seeAlso: [
          'http://web.archive.org/web/20100302225219/http://www.zimbra.com/license/zimbra-public-license-1-3.html',
        ],
        isOsiApproved: false,
      },
      {
        reference: './Zimbra-1.4.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/Zimbra-1.4.json',
        referenceNumber: '385',
        name: 'Zimbra Public License v1.4',
        licenseId: 'Zimbra-1.4',
        seeAlso: ['http://www.zimbra.com/legal/zimbra-public-license-1-4'],
        isOsiApproved: false,
      },
      {
        reference: './Zlib.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/Zlib.json',
        referenceNumber: '45',
        name: 'zlib License',
        licenseId: 'Zlib',
        seeAlso: [
          'http://www.zlib.net/zlib_license.html',
          'https://opensource.org/licenses/Zlib',
        ],
        isOsiApproved: true,
      },
      {
        reference: './blessing.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/blessing.json',
        referenceNumber: '301',
        name: 'SQLite Blessing',
        licenseId: 'blessing',
        seeAlso: [
          'https://www.sqlite.org/src/artifact/e33a4df7e32d742a?ln=4-9',
          'https://sqlite.org/src/artifact/df5091916dbb40e6',
        ],
        isOsiApproved: false,
      },
      {
        reference: './bzip2-1.0.5.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/bzip2-1.0.5.json',
        referenceNumber: '186',
        name: 'bzip2 and libbzip2 License v1.0.5',
        licenseId: 'bzip2-1.0.5',
        seeAlso: ['http://bzip.org/1.0.5/bzip2-manual-1.0.5.html'],
        isOsiApproved: false,
      },
      {
        reference: './bzip2-1.0.6.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/bzip2-1.0.6.json',
        referenceNumber: '69',
        name: 'bzip2 and libbzip2 License v1.0.6',
        licenseId: 'bzip2-1.0.6',
        seeAlso: ['https://github.com/asimonov-im/bzip2/blob/master/LICENSE'],
        isOsiApproved: false,
      },
      {
        reference: './copyleft-next-0.3.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/copyleft-next-0.3.0.json',
        referenceNumber: '312',
        name: 'copyleft-next 0.3.0',
        licenseId: 'copyleft-next-0.3.0',
        seeAlso: [
          'https://github.com/copyleft-next/copyleft-next/blob/master/Releases/copyleft-next-0.3.0',
        ],
        isOsiApproved: false,
      },
      {
        reference: './copyleft-next-0.3.1.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/copyleft-next-0.3.1.json',
        referenceNumber: '378',
        name: 'copyleft-next 0.3.1',
        licenseId: 'copyleft-next-0.3.1',
        seeAlso: [
          'https://github.com/copyleft-next/copyleft-next/blob/master/Releases/copyleft-next-0.3.1',
        ],
        isOsiApproved: false,
      },
      {
        reference: './curl.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/curl.json',
        referenceNumber: '314',
        name: 'curl License',
        licenseId: 'curl',
        seeAlso: ['https://github.com/bagder/curl/blob/master/COPYING'],
        isOsiApproved: false,
      },
      {
        reference: './diffmark.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/diffmark.json',
        referenceNumber: '397',
        name: 'diffmark license',
        licenseId: 'diffmark',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/diffmark'],
        isOsiApproved: false,
      },
      {
        reference: './dvipdfm.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/dvipdfm.json',
        referenceNumber: '19',
        name: 'dvipdfm License',
        licenseId: 'dvipdfm',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/dvipdfm'],
        isOsiApproved: false,
      },
      {
        reference: './eCos-2.0.html',
        isDeprecatedLicenseId: true,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/eCos-2.0.json',
        referenceNumber: '272',
        name: 'eCos license version 2.0',
        licenseId: 'eCos-2.0',
        seeAlso: ['https://www.gnu.org/licenses/ecos-license.html'],
        isOsiApproved: false,
      },
      {
        reference: './eGenix.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/eGenix.json',
        referenceNumber: '214',
        name: 'eGenix.com Public License 1.1.0',
        licenseId: 'eGenix',
        seeAlso: [
          'http://www.egenix.com/products/eGenix.com-Public-License-1.1.0.pdf',
          'https://fedoraproject.org/wiki/Licensing/eGenix.com_Public_License_1.1.0',
        ],
        isOsiApproved: false,
      },
      {
        reference: './etalab-2.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/etalab-2.0.json',
        referenceNumber: '259',
        name: 'Etalab Open License 2.0',
        licenseId: 'etalab-2.0',
        seeAlso: [
          'https://github.com/DISIC/politique-de-contribution-open-source/blob/master/LICENSE.pdf',
          'https://raw.githubusercontent.com/DISIC/politique-de-contribution-open-source/master/LICENSE',
        ],
        isOsiApproved: false,
      },
      {
        reference: './gSOAP-1.3b.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/gSOAP-1.3b.json',
        referenceNumber: '167',
        name: 'gSOAP Public License v1.3b',
        licenseId: 'gSOAP-1.3b',
        seeAlso: ['http://www.cs.fsu.edu/~engelen/license.html'],
        isOsiApproved: false,
      },
      {
        reference: './gnuplot.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/gnuplot.json',
        referenceNumber: '383',
        name: 'gnuplot License',
        licenseId: 'gnuplot',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/Gnuplot'],
        isOsiApproved: false,
      },
      {
        reference: './iMatix.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/iMatix.json',
        referenceNumber: '177',
        name: 'iMatix Standard Function Library Agreement',
        licenseId: 'iMatix',
        seeAlso: ['http://legacy.imatix.com/html/sfl/sfl4.htm#license'],
        isOsiApproved: false,
      },
      {
        reference: './libpng-2.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/libpng-2.0.json',
        referenceNumber: '103',
        name: 'PNG Reference Library version 2',
        licenseId: 'libpng-2.0',
        seeAlso: ['http://www.libpng.org/pub/png/src/libpng-LICENSE.txt'],
        isOsiApproved: false,
      },
      {
        reference: './libselinux-1.0.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/libselinux-1.0.json',
        referenceNumber: '18',
        name: 'libselinux public domain notice',
        licenseId: 'libselinux-1.0',
        seeAlso: [
          'https://github.com/SELinuxProject/selinux/blob/master/libselinux/LICENSE',
        ],
        isOsiApproved: false,
      },
      {
        reference: './libtiff.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/libtiff.json',
        referenceNumber: '407',
        name: 'libtiff License',
        licenseId: 'libtiff',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/libtiff'],
        isOsiApproved: false,
      },
      {
        reference: './mpich2.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/mpich2.json',
        referenceNumber: '60',
        name: 'mpich2 License',
        licenseId: 'mpich2',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/MIT'],
        isOsiApproved: false,
      },
      {
        reference: './psfrag.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/psfrag.json',
        referenceNumber: '408',
        name: 'psfrag License',
        licenseId: 'psfrag',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/psfrag'],
        isOsiApproved: false,
      },
      {
        reference: './psutils.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/psutils.json',
        referenceNumber: '277',
        name: 'psutils License',
        licenseId: 'psutils',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/psutils'],
        isOsiApproved: false,
      },
      {
        reference: './wxWindows.html',
        isDeprecatedLicenseId: true,
        detailsUrl: 'http://spdx.org/licenses/wxWindows.json',
        referenceNumber: '244',
        name: 'wxWindows Library License',
        licenseId: 'wxWindows',
        seeAlso: ['https://opensource.org/licenses/WXwindows'],
        isOsiApproved: false,
      },
      {
        reference: './xinetd.html',
        isDeprecatedLicenseId: false,
        isFsfLibre: true,
        detailsUrl: 'http://spdx.org/licenses/xinetd.json',
        referenceNumber: '399',
        name: 'xinetd License',
        licenseId: 'xinetd',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/Xinetd_License'],
        isOsiApproved: false,
      },
      {
        reference: './xpp.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/xpp.json',
        referenceNumber: '96',
        name: 'XPP License',
        licenseId: 'xpp',
        seeAlso: ['https://fedoraproject.org/wiki/Licensing/xpp'],
        isOsiApproved: false,
      },
      {
        reference: './zlib-acknowledgement.html',
        isDeprecatedLicenseId: false,
        detailsUrl: 'http://spdx.org/licenses/zlib-acknowledgement.json',
        referenceNumber: '246',
        name: 'zlib/libpng License with Acknowledgement',
        licenseId: 'zlib-acknowledgement',
        seeAlso: [
          'https://fedoraproject.org/wiki/Licensing/ZlibWithAcknowledgement',
        ],
        isOsiApproved: false,
      },
    ],
    releaseDate: '2020-02-13',
  };

  // project-rome/@romejs/codec-spdx-license/parse.ts
function ___R$$priv$project$rome$$romejs$codec$spdx$license$parse_ts$isWordChar(char) {
    return ___R$project$rome$$romejs$parser$core$index_ts$isAlpha(char) || ___R$project$rome$$romejs$parser$core$index_ts$isDigit(char) || char === '-' || char === '.';
  }

  const ___R$$priv$project$rome$$romejs$codec$spdx$license$parse_ts$createSPDXLicenseParser = ___R$project$rome$$romejs$parser$core$index_ts$createParser(
    (
      ParserCore,
    ) =>
      (() => {
        class SPDXLicenseParser extends ParserCore {
          constructor(opts) {
            super(opts, 'parse/spdxLicense');
            this.loose = opts.loose === true;
          }

          // For some reason Flow will throw an error without the type casts...
          tokenize(index, input) {
            const char = input[___R$project$rome$$romejs$ob1$index_ts$get0(index)];

            if (char === '+') {
              return this.finishToken('Plus');
            }

            if (char === '(') {
              return this.finishToken('ParenOpen');
            }

            if (char === ')') {
              return this.finishToken('ParenClose');
            }

            // Skip spaces
            if (char === ' ') {
              return this.lookaheadToken(___R$project$rome$$romejs$ob1$index_ts$inc(index));
            }

            if (___R$$priv$project$rome$$romejs$codec$spdx$license$parse_ts$isWordChar(char)) {
              const [value, end] = this.readInputFrom(index, ___R$$priv$project$rome$$romejs$codec$spdx$license$parse_ts$isWordChar);

              if (value === 'AND') {
                return this.finishToken('And', end);
              } else if (value === 'OR') {
                return this.finishToken('Or', end);
              } else if (value === 'WITH') {
                return this.finishToken('With', end);
              } else {
                return this.finishValueToken('Word', value, end);
              }
            }
          }

          parseLicense(token) {
            const startPos = this.getPosition();
            this.nextToken();

            // Validate id
            const id = token.value;
            let licenseInfo = ___R$project$rome$$romejs$codec$spdx$license$index_ts$getSPDXLicense(id);
            const nextToken = this.getToken();

            // Sometimes licenses will be specified as "Apache 2.0" but what they actually meant was "Apache-2.0"

            // In loose mode, just make it equivalent, otherwise, complain
            if (licenseInfo === undefined && nextToken.type === 'Word') {
              const possibleCorrectLicense = id +
              '-' +
              nextToken.value;
              const possibleLicenseInfo = ___R$project$rome$$romejs$codec$spdx$license$index_ts$getSPDXLicense(possibleCorrectLicense);

              if (possibleLicenseInfo !== undefined) {
                if (this.loose) {
                  // Just allow it...
                  licenseInfo = possibleLicenseInfo;
                  this.nextToken();
                } else {
                  throw (
                    this.unexpected(
                      {
                        message: 'Missing dash between SPDX license name and version',
                        start: this.getPositionFromIndex(token.start),
                        end: this.getPositionFromIndex(nextToken.end),
                        advice: [
                          {
                            type: 'log',
                            category: 'info',
                            message: 'Did you mean <emphasis>' +
                            possibleCorrectLicense +
                            '</emphasis>?',
                          },
                        ],
                      },
                    )
                  );
                }
              }
            }

            if (licenseInfo === undefined) {
              throw (
                this.unexpected(
                  {
                    message: 'Unknown SPDX license <emphasis>' +
                    id +
                    '</emphasis>',
                    start: this.getPositionFromIndex(token.start),
                    end: this.getPositionFromIndex(token.end),
                    advice: ___R$project$rome$$romejs$diagnostics$helpers_ts$buildSuggestionAdvice(id, ___R$project$rome$$romejs$codec$spdx$license$index_ts$licenseNames),
                  },
                )
              );
            }

            // Is this a plus? (wtf is this)
            const plus = this.eatToken('Plus') !== undefined;

            // Get exception
            let exception;
            if (this.eatToken('With')) {
              const token = this.getToken();
              if (token.type === 'Word') {
                exception = token.value;
                this.nextToken();
              } else {
                throw (
                  this.unexpected(
                    {
                      message: 'Only a license id can be on the right side of a WITH',
                    },
                  )
                );
              }
            }

            return (
              {
                type: 'License',
                loc: this.finishLoc(startPos),
                id,
                exception,
                plus,
              }
            );
          }

          parseExpression() {
            const startPos = this.getPosition();
            const startToken = this.getToken();

            let value;

            switch (startToken.type) {
              case 'ParenOpen':
                this.nextToken();
                value = this.parseExpression();
                this.expectToken('ParenClose');
                break;

              case 'Word':
                value = this.parseLicense(startToken);
                break;

              case 'Or':
              case 'And':
                throw (
                  this.unexpected(
                    {
                      message: 'Can only use AND/OR in between an expression',
                    },
                  )
                );

              case 'Plus':
                throw (
                  this.unexpected(
                    {
                      message: 'A plus can only come after a license id',
                    },
                  )
                );

              case 'ParenClose':
                throw this.unexpected({message: 'Nothing open to close'});

              case 'EOF':
                throw this.unexpected({message: 'Unexpected end of file'});

              default:
                throw this.unexpected();
            }

            // Parse and/or
            const nextToken = this.getToken();
            switch (nextToken.type) {
              case 'Or':
                this.nextToken();
                return (
                  {
                    type: 'Or',
                    loc: this.finishLoc(startPos),
                    left: value,
                    right: this.parseExpression(),
                  }
                );

              case 'And':
                this.nextToken();
                return (
                  {
                    type: 'And',
                    loc: this.finishLoc(startPos),
                    left: value,
                    right: this.parseExpression(),
                  }
                );

              default:
                return value;
            }
          }

          parse() {
            const expr = this.parseExpression();
            this.finalize();
            return expr;
          }
        }

        return (
          SPDXLicenseParser
        );
      })(),
  );

  function ___R$project$rome$$romejs$codec$spdx$license$parse_ts$default(opts) {
    return ___R$$priv$project$rome$$romejs$codec$spdx$license$parse_ts$createSPDXLicenseParser(opts).parse();
  }

  // project-rome/@romejs/codec-spdx-license/stringify.ts
function ___R$project$rome$$romejs$codec$spdx$license$stringify_ts$default(node) {
    // TODO parens

    switch (node.type) {
      case 'Or':
        return ___R$project$rome$$romejs$codec$spdx$license$stringify_ts$default(node.left) +
        ' OR ' +
        ___R$project$rome$$romejs$codec$spdx$license$stringify_ts$default(node.right);

      case 'And':
        return ___R$project$rome$$romejs$codec$spdx$license$stringify_ts$default(node.left) +
        ' AND ' +
        ___R$project$rome$$romejs$codec$spdx$license$stringify_ts$default(node.right);

      case 'License':
        {
          let str = node.id;
          if (node.plus) {
            str += '+';
          }
          if (node.exception !== undefined) {
            str += ' WITH ' +
            node.exception;
          }
          return str;
        }
    }
  }

  // project-rome/@romejs/codec-spdx-license/index.ts
const ___R$$priv$project$rome$$romejs$codec$spdx$license$index_ts$idToLicense = new Map();
  const ___R$project$rome$$romejs$codec$spdx$license$index_ts$licenseNames = [];
  for (const license of ___R$project$rome$$romejs$codec$spdx$license$data_ts$default.licenses) {
    ___R$project$rome$$romejs$codec$spdx$license$index_ts$licenseNames.push(license.licenseId);
    ___R$$priv$project$rome$$romejs$codec$spdx$license$index_ts$idToLicense.set(license.licenseId, license);
  }

  function ___R$project$rome$$romejs$codec$spdx$license$index_ts$getSPDXLicense(licenseId) {
    return ___R$$priv$project$rome$$romejs$codec$spdx$license$index_ts$idToLicense.get(licenseId);
  }

  // project-rome/@romejs/codec-js-manifest/name.ts
function ___R$$priv$project$rome$$romejs$codec$js$manifest$name_ts$validateNamePart(
    {loose, unexpected},
    {name, isOrg, isOrgPart, offset},
  ) {
    let normalizedName = '';

    for (let i = 0;
    i < name.length;
    i++) {
      const char = name[i];

      if (isOrg && char === '@' && i === 0) {
        unexpected(
          {
            message: 'Redundant <emphasis>@</emphasis> in org name',
            start: ___R$project$rome$$romejs$ob1$index_ts$add(offset, i),
          },
        );
      } else if (!isOrgPart && char === '/') {
        /*unexpected({
        at: 'prefix',
        message: `cannot contain any slashes`,
        start: add(offset, i),
        advice: [
          {
            type: 'log',
            category: 'info',
            message:
              'Did you forget a <emphasis>@</emphasis> prefix to make this a scope?',
          },
        ],
      });*/
        normalizedName = '@' +
        normalizedName +
        '/';
      } else if (!loose && char.match(/[A-Z]/)) {
        /*unexpected({
          at: 'prefix',
          message: `cannot contain uppercase letters`,
          start: add(offset, i),
        });*/
        normalizedName += char.toLowerCase();
      } else if (char.match(/[A-Za-z0-9\-_.]/)) {
        normalizedName += char;
      } else {
        unexpected(
          {
            message: 'The character <emphasis>' +
            ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(char) +
            '</emphasis> isn\'t allowed',
            start: ___R$project$rome$$romejs$ob1$index_ts$add(offset, i),
          },
        );
      }
    }

    return normalizedName;
  }

  function ___R$project$rome$$romejs$codec$js$manifest$name_ts$normalizeName(opts) {
    const {unexpected} = opts;
    let {name} = opts;

    if (name.length > 214) {
      unexpected(
        {
          at: 'prefix',
          message: 'cannot exceed 214 characters',
        },
      );
      name = name.slice(0, 214);
    }

    if (name[0] === '.' || name[0] === '_') {
      unexpected(
        {
          at: 'prefix',
          message: 'cannot start with a dot or underscore',
          start: ___R$project$rome$$romejs$ob1$index_ts$number0,
        },
      );
      name = name.slice(1);
    }

    if (name[0] === '@') {
      // Validate org and package name separately
      const [org, packageName, ...other] = name.slice(1).split('/');

      // Leading @
      let offset = ___R$project$rome$$romejs$ob1$index_ts$coerce0(1);

      // Org
      const sanitizedOrg = ___R$$priv$project$rome$$romejs$codec$js$manifest$name_ts$validateNamePart(
        opts,
        {
          isOrg: true,
          isOrgPart: true,
          name: org,
          offset,
        },
      );
      offset = ___R$project$rome$$romejs$ob1$index_ts$add(offset, org.length);

      if (packageName === undefined) {
        unexpected(
          {
            at: 'prefix',
            message: 'contains an org but no package name',
            start: offset,
          },
        );

        name = '@' +
        sanitizedOrg +
        '/unknown';
      } else {
        // Forward slashSeparator
        offset = ___R$project$rome$$romejs$ob1$index_ts$inc(offset);

        // Package name
        const sanitizedPackageName = ___R$$priv$project$rome$$romejs$codec$js$manifest$name_ts$validateNamePart(
          opts,
          {
            isOrg: false,
            isOrgPart: true,
            name: packageName,
            offset,
          },
        );
        offset = ___R$project$rome$$romejs$ob1$index_ts$add(offset, packageName.length);

        // Complain on excess separators
        if (other.length > 0) {
          unexpected(
            {
              at: 'prefix',
              message: 'contains too many name separators',
              start: offset,
            },
          );
        }

        name = '@' +
        sanitizedOrg +
        '/' +
        sanitizedPackageName;
      }
    } else {
      name =
        ___R$$priv$project$rome$$romejs$codec$js$manifest$name_ts$validateNamePart(
          opts,
          {
            name,
            offset: ___R$project$rome$$romejs$ob1$index_ts$number0,
            isOrg: false,
            isOrgPart: false,
          },
        );
    }

    return name;
  }

  // project-rome/@romejs/codec-js-manifest/dependencies.ts
function ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$stringifyDependencyPattern(pattern) {
    switch (pattern.type) {
      case 'hosted-git':
        {
          let str = pattern.host +
          ':' +
          pattern.user +
          '/' +
          pattern.repo;
          if (pattern.commitish !== undefined) {
            str += '#' +
            pattern.commitish;
          }
          return str;
        }

      case 'file':
        return 'file:' +
        pattern.path;

      case 'semver':
        return ___R$project$rome$$romejs$codec$semver$stringify_ts$default(pattern.range);

      case 'tag':
        return pattern.tag;

      case 'git':
      case 'http-tarball':
        if (pattern.hash === undefined) {
          return pattern.url;
        } else {
          return pattern.url +
          '#' +
          pattern.hash;
        }

      case 'npm':
        {
          let str = '' +
          ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$NPM_PREFIX +
          pattern.name;
          if (pattern.range !== undefined) {
            str += '@' +
            ___R$project$rome$$romejs$codec$semver$stringify_ts$default(pattern.range);
          }
          return str;
        }

      case 'link':
        return '' +
        ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$LINK_PREFIX +
        pattern.path.join();
    }
  }

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$explodeHashUrl(pattern, consumer) {
    const parts = pattern.split('#');

    if (parts.length > 2) {
      consumer.unexpected('Too many hashes');
    }

    return (
      {
        hash: parts[1],
        url: parts[0],
      }
    );
  }

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$removePrefix(prefix, value) {
    if (value.startsWith(prefix)) {
      return value.slice(prefix.length);
    } else {
      return value;
    }
  }

  //# HOSTED GIT

  const ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$GITHUB_SHORTHAND = /^[^:@%\/\s.\-][^:@%\/\s]*[\/][^:@\s\/%]+(?:#.*)?$/;

  const ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$HOSTED_GIT_PREFIXES = [
    'bitbucket',
    'github',
    'gist',
    'gitlab',
  ];

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseHostedGit(
    host,
    pattern,
    consumer,
  ) {
    // Extract and trim hash
    let commitish;
    if (pattern.includes('#')) {
      const hashIndex = pattern.indexOf('#');
      commitish = pattern.slice(hashIndex + 1);
      pattern = pattern.slice(0, hashIndex - 1);
    }

    const parts = pattern.split('/');
    if (parts.length > 2) {
      consumer.unexpected('Expected only 2 parts');
    }

    let user = parts[0];
    if (user === undefined) {
      consumer.unexpected('We are missing a user!');
      user = 'unknown';
    }

    let repo = parts[1];
    if (repo === undefined) {
      consumer.unexpected('We are missing a repo!');
      repo = 'unknown';
    }

    const incomplete = {
      type: 'hosted-git',
      host,
      user,
      repo,
      commitish,
    };

    return (
      Object.assign(
        {
        },
        incomplete,
        {
          url: ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$getHostedGitURL(incomplete),
        },
      )
    );
  }

  function ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$getHostedGitURL(pattern) {
    switch (pattern.host) {
      case 'bitbucket':
        return '';

      case 'gitlab':
      case 'gist':
        return '';

      case 'github':
        return '';
    }
  }

  const ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$GIT_PATTERN_MATCHERS = [
    /^git:/,
    /^git\+.+:/,
    /^ssh:/,
    /^https?:.+\.git$/,
    /^https?:.+\.git#.+/,
  ];

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseGit(pattern, consumer) {
    return (
      Object.assign(
        {
          type: 'git',
        },
        ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$explodeHashUrl(pattern, consumer),
      )
    );
  }

  //# TARBALL

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseHttpTarball(
    pattern,
    consumer,
  ) {
    return (
      Object.assign(
        {
          type: 'http-tarball',
        },
        ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$explodeHashUrl(pattern, consumer),
      )
    );
  }

  //# SEMVER

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseSemver(
    pattern,
    consumer,
    loose,
  ) {
    const ast = ___R$project$rome$$romejs$parser$core$index_ts$tryParseWithOptionalOffsetPosition(
      {
        loose,
        path: consumer.path,
        input: pattern,
      },
      {
        getOffsetPosition: () => consumer.getLocation('inner-value').start,
        parse: (opts) => ___R$project$rome$$romejs$codec$semver$parse_ts$parseSemverRange(opts),
      },
    );

    return (
      {
        type: 'semver',
        range: ast,
      }
    );
  }

  //# FILE
  const ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$FILE_PREFIX_REGEX = /^\.\{1,2\}\//;

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseFile(pattern) {
    return (
      {
        type: 'file',
        path: ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$removePrefix('file:', pattern),
      }
    );
  }

  //# TAG

  // This regex will likely need to be refined, not sure what the allowable characters of a tag are
  const ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$TAG_REGEX = /^[a-z]+$/g;

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseTag(pattern) {
    return (
      {
        type: 'tag',
        tag: pattern,
      }
    );
  }

  //# LINK
  const ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$LINK_PREFIX = 'link:';

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseLink(pattern) {
    return (
      {
        type: 'link',
        path: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(pattern.slice(___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$LINK_PREFIX.length)),
      }
    );
  }

  //# NPM
  const ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$NPM_PREFIX = 'npm:';

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseNpm(
    pattern,
    consumer,
    loose,
  ) {
    // Prune prefix
    let offset = ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$NPM_PREFIX.length;
    pattern = pattern.slice(___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$NPM_PREFIX.length);

    if (pattern === '') {
      consumer.unexpected('Missing rest of pattern');
      return (
        {
          type: 'npm',
          name: 'unknown',
          range: undefined,
        }
      );
    }

    // Split and verify count
    const parts = pattern.split('@');
    let nameRaw = '';
    let rangeRaw;

    // Org signifier
    if (parts[0] === '') {
      nameRaw += '@';
      parts.shift();
    }

    // Name - We know there'll be at least two due to the empty string conditional
    nameRaw = String(parts.shift());

    // Range
    rangeRaw = parts.shift();

    if (parts.length > 0) {
      consumer.unexpected('Too many @ signs');
    }

    const name = ___R$project$rome$$romejs$codec$js$manifest$name_ts$normalizeName(
      {
        name: nameRaw,
        loose,
        unexpected({message, at, start, end, advice}) {
          consumer.unexpected(
            message,
            {
              advice,
              at,
              loc: start === undefined
                ? undefined : consumer.getLocationRange(
                  ___R$project$rome$$romejs$ob1$index_ts$add(
                    start,
                    offset,
                  ),
                  end === undefined ? undefined : ___R$project$rome$$romejs$ob1$index_ts$add(end, offset),
                  'inner-value',
                ),
            },
          );
        },
      },
    );

    // Increase offset passed name
    offset += name.length;
    offset++;

    let range;
    if (rangeRaw !== undefined) {
      range =
        ___R$project$rome$$romejs$parser$core$index_ts$tryParseWithOptionalOffsetPosition(
          {
            loose,
            path: consumer.path,
            input: rangeRaw,
          },
          {
            getOffsetPosition: () => {
              const pos = consumer.getLocation('inner-value').start;
              return (
                Object.assign(
                  {
                  },
                  pos,
                  {
                    column: ___R$project$rome$$romejs$ob1$index_ts$add(pos.column, offset),
                  },
                )
              );
            },
            parse: (opts) => ___R$project$rome$$romejs$codec$semver$parse_ts$parseSemverRange(opts),
          },
        );
    }

    return (
      {
        type: 'npm',
        name,
        range,
      }
    );
  }

  //#
  function ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseGitDependencyPattern(
    consumer,
  ) {
    const pattern = consumer.asString();

    for (const host of ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$HOSTED_GIT_PREFIXES) {
      const prefix = host +
      ':';
      if (pattern.startsWith(prefix)) {
        return ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseHostedGit(host, ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$removePrefix(prefix, pattern), consumer);
      }
    }

    for (const matcher of ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$GIT_PATTERN_MATCHERS) {
      if (matcher.test(pattern)) {
        return ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseGit(pattern, consumer);
      }
    }

    if (___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$GITHUB_SHORTHAND.test(pattern)) {
      return ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseHostedGit('github', pattern, consumer);
    }
  }

  function ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseDependencyPattern(
    consumer,
    loose,
  ) {
    const pattern = consumer.asString();

    const gitPattern = ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseGitDependencyPattern(consumer);
    if (gitPattern !== undefined) {
      return gitPattern;
    }

    if (pattern.startsWith('http://') || pattern.startsWith('https://')) {
      return ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseHttpTarball(pattern, consumer);
    }

    if (pattern.startsWith(___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$NPM_PREFIX)) {
      return ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseNpm(pattern, consumer, loose);
    }

    if (pattern.startsWith(___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$LINK_PREFIX)) {
      return ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseLink(pattern);
    }

    if (___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$FILE_PREFIX_REGEX.test(pattern) ||
    ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(pattern).isAbsolute() ||
    pattern.startsWith('file:')) {
      return ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseFile(pattern);
    }

    if (pattern.match(___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$TAG_REGEX)) {
      return ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseTag(pattern);
    }

    return ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseSemver(pattern, consumer, loose);
  }

  function ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$normalizeDependencies(
    root,
    key,
    loose,
  ) {
    const map = new Map();

    if (!root.has(key)) {
      return map;
    }

    const consumer = root.get(key);

    // Some ridiculous code has the dependencies property as an empty array
    if (Array.isArray(consumer.asUnknown()) && loose) {
      return map;
    }

    for (const [name, value] of consumer.asMap()) {
      ___R$project$rome$$romejs$codec$js$manifest$name_ts$normalizeName(
        {
          name,
          loose,
          unexpected: ({message, at, advice}) => {
            value.unexpected(
              message,
              {
                at,
                advice,
                target: 'key',
              },
            );
          },
        },
      );

      map.set(name, ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseDependencyPattern(value, loose));
    }

    return map;
  }

  // project-rome/@romejs/codec-js-manifest/types.ts
const ___R$project$rome$$romejs$codec$js$manifest$types_ts = {
  };

  // project-rome/@romejs/codec-js-manifest/convert.ts
const ___R$project$rome$$romejs$codec$js$manifest$convert_ts = {
    convertManifestToJSON: ___R$project$rome$$romejs$codec$js$manifest$convert_ts$convertManifestToJSON,
  };
  function ___R$project$rome$$romejs$codec$js$manifest$convert_ts$convertManifestToJSON(manifest) {
    return (
      Object.assign(
        {
        },
        manifest.raw,
        {
          name: manifest.name,
          description: manifest.description,
          private: manifest.private,
          type: manifest.type,

          homepage: manifest.homepage,
          repository: manifest.repository,
          bugs: manifest.bugs,

          main: manifest.main,
          exports: ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$exportsToObject(manifest.exports),

          author: manifest.author,
          contributors: manifest.contributors,
          maintainers: manifest.maintainers,

          version: manifest.version === undefined
            ? undefined : ___R$project$rome$$romejs$codec$semver$stringify_ts$default(
              manifest.version,
            ),
          license: manifest.license === undefined
            ? undefined : ___R$project$rome$$romejs$codec$spdx$license$stringify_ts$default(
              manifest.license,
            ),

          files: ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$maybeArray(
            manifest.files.map(
              (
                pattern,
              ) =>
                ___R$project$rome$$romejs$path$match$stringify_ts$stringifyPathPattern(pattern),
            ),
          ),
          keywords: ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$maybeArray(manifest.keywords),
          cpu: ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$maybeArray(manifest.cpu),
          os: ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$maybeArray(manifest.os),

          bin: ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$mapToObject(manifest.bin),
          scripts: ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$mapToObject(manifest.scripts),
          engines: ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$mapToObject(manifest.engines),

          dependencies: ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$dependencyMapToObject(manifest.dependencies),
          devDependencies: ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$dependencyMapToObject(manifest.devDependencies),
          optionalDependencies: ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$dependencyMapToObject(manifest.optionalDependencies),
          peerDependencies: ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$dependencyMapToObject(manifest.peerDependencies),

          // Common misspelling. If this existed then it was turned into bundledDependencies
          bundleDependencies: undefined,
          bundledDependencies: ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$maybeArray(manifest.bundledDependencies),
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$exportsToObject(
    exports,
  ) {
    if (exports === false) {
      return false;
    }

    if (exports === true) {
      return;
    }

    if (exports.size === 0) {
      return {};
    }

    const obj = {};

    for (const [key, entries] of exports) {
      if (entries.size === 1) {
        const def = entries.get('default');
        if (def !== undefined) {
          obj[key.join()] = def.relative.join();
          continue;
        }
      }

      const entriesObj = {};
      for (const [type, alias] of entries) {
        entriesObj[type] = alias.relative.join();
      }
      obj[key.join()] = entriesObj;
    }

    return obj;
  }

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$maybeArray(items) {
    if (items.length === 0) {
      return undefined;
    } else {
      return items;
    }
  }

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$mapToObject(map) {
    if (map.size === 0) {
      return;
    }

    const obj = {};
    for (const [key, value] of map) {
      obj[key] = value;
    }
    return obj;
  }

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$dependencyMapToObject(
    map,
  ) {
    if (map.size === 0) {
      return;
    }

    const obj = {};
    for (const [key, pattern] of map) {
      obj[key] = ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$stringifyDependencyPattern(pattern);
    }
    return obj;
  }

  // project-rome/@romejs/codec-js-manifest/index.ts
const ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$TYPO_KEYS = new Map(
    [
      ['autohr', 'author'],
      ['autor', 'author'],
      ['contributers', 'contributors'],
      ['depends', 'dependencies'],
      ['hampage', 'homepage'],
      ['hompage', 'homepage'],
      ['prefereGlobal', 'preferGlobal'],
      ['publicationConfig', 'publishConfig'],
      ['repo', 'repository'],
      ['repostitory', 'repository'],
      ['script', 'scripts'],
    ],
  );

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeBoolean(consumer, key) {
    if (consumer.has(key)) {
      return consumer.get(key).asBoolean();
    } else {
      return undefined;
    }
  }

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeString(consumer, key) {
    if (consumer.has(key)) {
      return consumer.get(key).asString();
    } else {
      return undefined;
    }
  }

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizePathPatterns(consumer, loose) {
    return (
      ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeStringArray(consumer, loose).map(
        (
          str,
        ) =>
          ___R$project$rome$$romejs$path$match$parse_ts$parsePattern({input: str}),
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeStringArray(consumer, loose) {
    if (consumer.exists()) {
      // When we are loose and expect an array but got a string, consider it to be a single element
      if (loose) {
        const val = consumer.asUnknown();

        if (typeof val === 'string') {
          return [consumer.asString()];
        }

        // npm for some reason sometimes populates bundleDependencies as false? Despite it being a misspelling?
        if (val === false) {
          return [];
        }
      }

      return consumer.asArray().map((item) => item.asString());
    } else {
      return [];
    }
  }

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeStringMap(
    root,
    key,
    loose,
  ) {
    const map = new Map();

    if (!root.has(key)) {
      return map;
    }

    const consumer = root.get(key);

    // Some code uses arrays for this case... Maybe we can normalize them. A `engines` array becomes an object with '*' properties etc
    if (Array.isArray(consumer.asUnknown()) && loose) {
      return map;
    }

    for (const [name, value] of consumer.asMap()) {
      // In loose mode let's be really generous
      if (loose && typeof value.asUnknown() !== 'string') {
        continue;
      }

      map.set(name, value.asString());
    }

    return map;
  }

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeBin(
    consumer,
    name,
    loose,
  ) {
    const map = new Map();
    if (!consumer.has('bin')) {
      return map;
    }

    // Allow a `bin` string
    const obj = consumer.get('bin');
    if (typeof obj.asUnknown() === 'string') {
      if (name === undefined) {
        obj.unexpected(
          'A string bin is only allowed if the manifest has a name property',
        );
      } else {
        map.set(name, obj.asString());
        return map;
      }
    }

    // Otherwise expect it to be an object
    return ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeStringMap(consumer, 'bin', loose);
  }

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$extractLicenseFromObjectConsumer(consumer) {
    const prop = consumer.get('type');
    const value = prop.asString();
    return [value, prop];
  }

  // These are all licenses I found that are wrong, we should eventually remove this as we update those deps
  const ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$INVALID_IGNORE_LICENSES = [
    'UNLICENSED',
    'none',
    'Facebook Platform License',
    'BSD',
    'MIT/X11',
    'Public Domain',
    'MIT License',
    'BSD-like',
  ];

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeLicense(
    consumer,
    loose,
  ) {
    if (!consumer.has('license')) {
      return undefined;
    }

    let licenseProp = consumer.get('license');

    let licenseId;

    // Support some legacy ways of specifying licenses: https://docs.npmjs.com/files/package.json#license
    const raw = licenseProp.asUnknown();
    if (loose && Array.isArray(raw)) {
      const licenseIds = licenseProp.asArray().map(
        (
          consumer,
        ) =>
          ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$extractLicenseFromObjectConsumer(consumer)[0],
      );
      licenseId = '(' +
      licenseIds.join(' OR ') +
      ')';
    } else if (loose && typeof raw === 'object') {
      [licenseId, licenseProp] = ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$extractLicenseFromObjectConsumer(licenseProp);
    } else {
      licenseId = licenseProp.asString();
    }

    // Allow referring to a custom license
    if (licenseId.startsWith('SEE LICENSE IN ')) {
      return undefined;
    }

    // Not valid licenses...
    if (___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$INVALID_IGNORE_LICENSES.includes(licenseId)) {
      return undefined;
    }

    // Parse as a SPDX expression
    return (
      ___R$project$rome$$romejs$parser$core$index_ts$tryParseWithOptionalOffsetPosition(
        {
          loose,
          path: consumer.path,
          input: licenseId,
        },
        {
          getOffsetPosition: () => licenseProp.getLocation('inner-value').start,
          parse: (opts) => ___R$project$rome$$romejs$codec$spdx$license$parse_ts$default(opts),
        },
      )
    );
  }

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeVersion(
    consumer,
    loose,
  ) {
    if (!consumer.has('version')) {
      return undefined;
    }

    const prop = consumer.get('version');
    const rawVersion = prop.asString();

    // Used in some package.json templates
    if (rawVersion === 'VERSION_STRING') {
      return undefined;
    }

    const ast = ___R$project$rome$$romejs$parser$core$index_ts$tryParseWithOptionalOffsetPosition(
      {
        path: consumer.path,
        input: rawVersion,
        // Some node_modules have bogus versions, like being prefixed with a v like:
        // https://github.com/itinance/react-native-fs/commit/6232d4e392d5b52cca0792fdfe5903b7fb6b1c5c#diff-b9cfc7f2cdf78a7f4b91a753d10865a2R3
        loose,
      },
      {
        getOffsetPosition: () => prop.getLocation('inner-value').start,
        parse: (opts) => ___R$project$rome$$romejs$codec$semver$parse_ts$parseSemverVersion(opts),
      },
    );
    return ast;
  }

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizePerson(consumer, loose) {
    if (typeof consumer.asUnknown() === 'string') {
      // Parse the string. Format: name (url) <email>
      const str = consumer.asString();

      const nameMatch = str.match(/^([^(<]+)/);
      let name;
      if (nameMatch) {
        name = nameMatch[0].trim();
      }

      const person = {
        name,
        url: undefined,
        email: undefined,
        twitter: undefined,
        github: undefined,
      };

      const emailMatch = str.match(/<([^>]+)>/);
      if (emailMatch) {
        person.email = emailMatch[1];
      }

      const urlMatch = str.match(/\(([^)]+)\)/);
      if (urlMatch) {
        person.url = urlMatch[1];
      }

      return person;
    } else {
      // Validate as an object
      let url = consumer.get('url').asStringOrVoid();

      // Some packages use "web" or "website" instead of "url"
      if (loose) {
        if (url === undefined) {
          url = consumer.get('web').asStringOrVoid();
        }

        if (url === undefined) {
          url = consumer.get('website').asStringOrVoid();
        }
      }

      let github = consumer.get('github').asStringOrVoid();

      if (loose && github === undefined) {
        // Some rando packages use this
        github =
          consumer.get('githubUsername').asStringOrVoid() ||
          consumer.get(
            'github-username',
          ).asStringOrVoid();
      }

      const person = {
        name: consumer.get('name').asString(loose ? '' : undefined),
        email: consumer.get('email').asStringOrVoid(),
        twitter: consumer.get('twitter').asStringOrVoid(),
        github,
        url,
      };
      if (!loose) {
        consumer.enforceUsedProperties();
      }
      return person;
    }
  }

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizePeople(
    consumer,
    loose,
  ) {
    if (!consumer.exists()) {
      return;
    }

    // Some packages have a single maintainer object instead of an array
    if (loose && consumer.isObject()) {
      return [___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizePerson(consumer, loose)];
    }

    // If it's not an array then just leave it. Some people put a URL here.
    if (loose && !Array.isArray(consumer.asUnknown())) {
      return;
    }

    const people = [];

    for (const item of consumer.asArray()) {
      people.push(___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizePerson(item, loose));
    }

    return people;
  }

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeRepo(
    consumer,
    loose,
  ) {
    if (!consumer.exists()) {
      return;
    }

    if (typeof consumer.asUnknown() === 'string') {
      let url = consumer.asString();

      // If this is a hosted git shorthand then explode it
      const parsed = ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseGitDependencyPattern(consumer);
      if (parsed !== undefined && parsed.type === 'hosted-git') {
        url = parsed.url;
      }

      return (
        {
          type: 'git',
          url,
          directory: undefined,
        }
      );
    } else {
      let url;
      let type;

      if (loose) {
        // A lot of packages omit the "type"
        type = consumer.get('type').asString('git');

        // thanks i hate it
        consumer.markUsedProperty('web');
        consumer.markUsedProperty('git');
        consumer.markUsedProperty('dist');

        // Some gross packages use "repository" instead of "url"
        let looseUrl = consumer.get('url').asStringOrVoid();

        if (looseUrl === undefined) {
          looseUrl = consumer.get('repository').asStringOrVoid();
        }

        if (looseUrl === undefined) {
          consumer.unexpected('No url found');
          url = '';
        } else {
          url = looseUrl;
        }
      } else {
        url = consumer.get('url').asString();
        type = consumer.get('type').asString();
      }

      const repo = {
        type,
        url,
        directory: consumer.get('directory').asStringOrVoid(),
      };
      if (!loose) {
        consumer.enforceUsedProperties();
      }
      return repo;
    }
  }

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeExports(consumer) {
    if (typeof consumer.asUnknown() === 'boolean') {
      return consumer.asBoolean();
    }

    if (!consumer.exists()) {
      return true;
    }

    const exports = new ___R$project$rome$$romejs$path$collections_ts$RelativeFilePathMap();

    const dotConditions = new Map();

    for (const [relative, value] of consumer.asMap()) {
      // If it's not a relative path then it's a platform for the root
      if (relative[0] !== '.') {
        if (exports.size > 0) {
          value.unexpected(
            'Cannot mix a root conditional export with relative paths',
          );
        }

        dotConditions.set(
          relative,
          {
            consumer: value,
            relative: value.asExplicitRelativeFilePath(),
          },
        );
        continue;
      }

      if (dotConditions.size > 0) {
        value.unexpected(
          'Cannot mix a root conditional export with relative paths',
        );
      }

      const conditions = new Map();

      if (typeof value.asUnknown() === 'string') {
        conditions.set(
          'default',
          {
            consumer: value,
            relative: value.asExplicitRelativeFilePath(),
          },
        );
      } else {
        for (const [type, relativeAlias] of value.asMap()) {
          conditions.set(
            type,
            {
              consumer: relativeAlias,
              relative: relativeAlias.asExplicitRelativeFilePath(),
            },
          );
        }
      }

      if (dotConditions.size > 0) {
        exports.set(___R$project$rome$$romejs$path$index_ts$createRelativeFilePath('.'), dotConditions);
      }

      exports.set(value.getKey().asExplicitRelativeFilePath(), conditions);
    }

    return exports;
  }

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeBugs(
    consumer,
    loose,
  ) {
    if (!consumer.exists()) {
      return;
    }

    if (typeof consumer.asUnknown() === 'string') {
      return (
        {
          email: undefined,
          url: consumer.asString(),
        }
      );
    } else {
      let email = consumer.get('email').asStringOrVoid();

      // Some use a `mail` property
      if (loose && email === undefined) {
        email = consumer.get('mail').asStringOrVoid();
      }

      // TODO remove this
      consumer.markUsedProperty('type');

      const bugs = {
        email,
        url: consumer.get('url').asStringOrVoid(),
      };
      if (!loose) {
        consumer.enforceUsedProperties();
      }
      return bugs;
    }
  }

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeRootName(consumer, loose) {
    if (!consumer.has('name')) {
      return;
    }

    const prop = consumer.get('name');

    return (
      ___R$project$rome$$romejs$codec$js$manifest$name_ts$normalizeName(
        {
          name: prop.asString(),
          loose,
          unexpected: ({message, at, start, end, advice}) => {
            prop.unexpected(
              message,
              {
                advice,
                at,
                loc: start === undefined
                  ? undefined : prop.getLocationRange(
                    start,
                    end,
                    'inner-value',
                  ),
              },
            );
          },
        },
      )
    );
  }

  const ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$DEPENDENCIES_KEYS = ['', 'dev', 'peer', 'optional'];

  const ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$INCORRECT_DEPENDENCIES_SUFFIXES = [
    'depdenencies',
    'dependancies',
    'dependecies',
  ];

  function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$checkDependencyKeyTypo(key, prop) {
    for (const depPrefixKey of ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$DEPENDENCIES_KEYS) {
      // Ignore if the key is a valid dependency key
      const depKey = depPrefixKey === ''
        ? 'dependencies' : depPrefixKey +
        'Dependencies';
      if (key === depKey) {
        return;
      }

      // Check for casing issues
      const lowerKey = key.toLowerCase();
      if (lowerKey === depKey) {
        prop.unexpected(key +
        ' has incorrect casing, should be ' +
        depKey);
      }

      // Check for common suffix misspellings
      for (const suffix of ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$INCORRECT_DEPENDENCIES_SUFFIXES) {
        if (lowerKey === '' +
        depPrefixKey +
        suffix) {
          prop.unexpected(key +
          ' has a typo, should be ' +
          depKey);
        }
      }

      // Check for kebab casing
      if (___R$project$rome$$romejs$string$utils$toCamelCase_ts$toCamelCase(depKey) === lowerKey) {
        prop.unexpected(
          key +
          ' isn\'t correctly camel cased when it should be ' +
          depKey,
        );
      }
    }
  }

  async function ___R$project$rome$$romejs$codec$js$manifest$index_ts$normalizeManifest(
    path,
    consumer,
  ) {
    const loose = path.getSegments().includes('node_modules');

    const {result: manifest, diagnostics} = await consumer.capture(
      (consumer) => {
        // FIXME: There's this ridiculous node module that includes it's tests... which deliberately includes an invalid package.json
        if (path.join().includes('resolve/test/resolver/invalid_main')) {
          consumer.setValue({});
        }

        //
        if (!loose) {
          for (const [key, prop] of consumer.asMap()) {
            // Check for typos for dependencies
            ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$checkDependencyKeyTypo(key, prop);

            // Check for other typos
            const correctKey = ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$TYPO_KEYS.get(key);
            if (correctKey !== undefined) {
              prop.unexpected(key +
              ' is a typo of ' +
              correctKey);
            }
          }
        }

        const name = ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeRootName(consumer, loose);

        const manifest = {
          name,
          version: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeVersion(consumer, loose),
          private: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeBoolean(consumer, 'private') === true,
          description: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeString(consumer, 'description'),
          license: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeLicense(consumer, loose),
          type: consumer.get('type').asStringSetOrVoid(['module', 'commonjs']),

          bin: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeBin(consumer, name, loose),
          scripts: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeStringMap(consumer, 'scripts', loose),
          homepage: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeString(consumer, 'homepage'),
          repository: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeRepo(consumer.get('repository'), loose),
          bugs: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeBugs(consumer.get('bugs'), loose),
          engines: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeStringMap(consumer, 'engines', loose),

          files: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizePathPatterns(consumer.get('files'), loose),
          keywords: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeStringArray(consumer.get('keywords'), loose),
          cpu: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeStringArray(consumer.get('cpu'), loose),
          os: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeStringArray(consumer.get('os'), loose),

          main: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeString(consumer, 'main'),
          exports: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeExports(consumer.get('exports')),

          // Dependency fields
          dependencies: ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$normalizeDependencies(consumer, 'dependencies', loose),
          devDependencies: ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$normalizeDependencies(consumer, 'devDependencies', loose),
          optionalDependencies: ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$normalizeDependencies(
            consumer,
            'optionalDependencies',
            loose,
          ),
          peerDependencies: ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$normalizeDependencies(
            consumer,
            'peerDependencies',
            loose,
          ),
          bundledDependencies: [
            ...___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeStringArray(consumer.get('bundledDependencies'), loose),

            // Common misspelling. We error on the existence of this for strict manifests already.
            ...___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeStringArray(consumer.get('bundleDependencies'), loose),
          ],

          // People fields
          author: consumer.has('author')
            ? ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizePerson(
              consumer.get('author'),
              loose,
            ) : undefined,
          contributors: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizePeople(consumer.get('contributors'), loose),
          maintainers: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizePeople(consumer.get('maintainers'), loose),

          raw: consumer.asJSONObject(),
        };

        return manifest;
      },
    );

    return (
      {
        manifest,
        diagnostics,
      }
    );
  }

  // project-rome/@romejs/codec-watchman/bser.ts
const ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$os = require(
    'os',
  );
  // BSER uses the local endianness to reduce byte swapping overheads

  // (the protocol is expressly local IPC only).  We need to tell node

  // to use the native endianness when reading various native values.
  const ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$isBigEndian = ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$os.endianness() == 'BE';

  // Find the next power-of-2 >= size
  function ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$nextPow2(size) {
    return Math.pow(2, Math.ceil(Math.log(size) / Math.LN2));
  }

  // Expandable buffer that we can provide a size hint for
  class ___R$project$rome$$romejs$codec$watchman$bser_ts$Accumulator {
    constructor(initsize = 8192) {
      this.buffer = Buffer.alloc(___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$nextPow2(initsize));
      this.readOffset = 0;
      this.writeOffset = 0;
    }

    canRead(size) {
      return this.readAvail() > size;
    }

    // How much we can write into this buffer without allocating
    writeAvail() {
      return this.buffer.length - this.writeOffset;
    }

    // How much we can read
    readAvail() {
      return this.writeOffset - this.readOffset;
    }

    // Ensure that we have enough space for size bytes
    reserve(size) {
      if (size < this.writeAvail()) {
        return;
      }

      // If we can make room by shunting down, do so
      if (this.readOffset > 0) {
        this.buffer.copy(this.buffer, 0, this.readOffset, this.writeOffset);
        this.writeOffset -= this.readOffset;
        this.readOffset = 0;
      }

      // If we made enough room, no need to allocate more
      if (size < this.writeAvail()) {
        return;
      }

      // Allocate a replacement and copy it in
      const buf = Buffer.alloc(
        ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$nextPow2(
          this.buffer.length + size -
          this.writeAvail(),
        ),
      );
      this.buffer.copy(buf);
      this.buffer = buf;
    }

    // Append buffer or string.  Will resize as needed
    append(buf) {
      if (Buffer.isBuffer(buf)) {
        this.reserve(buf.length);
        buf.copy(this.buffer, this.writeOffset, 0, buf.length);
        this.writeOffset += buf.length;
      } else {
        const size = Buffer.byteLength(buf);
        this.reserve(size);
        this.buffer.write(buf, this.writeOffset);
        this.writeOffset += size;
      }
    }

    assertReadableSize(size) {
      if (this.readAvail() < size) {
        throw (
          new Error(
            'wanted to read ' +
            size +
            ' bytes but only have ' +
            this.readAvail(),
          )
        );
      }
    }

    peekString(size) {
      this.assertReadableSize(size);
      return this.buffer.toString('utf-8', this.readOffset, this.readOffset + size);
    }

    readString(size) {
      const str = this.peekString(size);
      this.readOffset += size;
      return str;
    }

    peekInt(size) {
      this.assertReadableSize(size);

      switch (size) {
        case 1:
          return this.buffer.readInt8(this.readOffset);

        case 2:
          return (
            ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$isBigEndian
              ? this.buffer.readInt16BE(this.readOffset) : this.buffer.readInt16LE(
                this.readOffset,
              )
          );

        case 4:
          return (
            ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$isBigEndian
              ? this.buffer.readInt32BE(this.readOffset) : this.buffer.readInt32LE(
                this.readOffset,
              )
          );

        case 8:
          throw new Error('64-bit numbers aren\'t supported');

        default:
          throw new Error('invalid integer size ' +
          size);
      }
    }

    readInt(bytes) {
      const ival = this.peekInt(bytes);
      this.readOffset += bytes;
      return ival;
    }

    peekDouble() {
      this.assertReadableSize(8);
      return (
        ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$isBigEndian
          ? this.buffer.readDoubleBE(this.readOffset) : this.buffer.readDoubleLE(
            this.readOffset,
          )
      );
    }

    readDouble() {
      const dval = this.peekDouble();
      this.readOffset += 8;
      return dval;
    }

    readAdvance(size) {
      if (size > 0) {
        this.assertReadableSize(size);
      } else if (size < 0 && this.readOffset + size < 0) {
        throw (
          new Error(
            'advance with negative offset ' +
            size +
            ' would seek off the start of the buffer',
          )
        );
      }

      this.readOffset += size;
    }

    writeByte(value) {
      this.reserve(1);
      this.buffer.writeInt8(value, this.writeOffset);
      ++this.writeOffset;
    }

    writeInt(value, size) {
      this.reserve(size);
      switch (size) {
        case 1:
          this.buffer.writeInt8(value, this.writeOffset);
          break;

        case 2:
          if (___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$isBigEndian) {
            this.buffer.writeInt16BE(value, this.writeOffset);
          } else {
            this.buffer.writeInt16LE(value, this.writeOffset);
          }
          break;

        case 4:
          if (___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$isBigEndian) {
            this.buffer.writeInt32BE(value, this.writeOffset);
          } else {
            this.buffer.writeInt32LE(value, this.writeOffset);
          }
          break;

        default:
          throw new Error('unsupported integer size ' +
          size);
      }
      this.writeOffset += size;
    }

    writeDouble(value) {
      this.reserve(8);
      if (___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$isBigEndian) {
        this.buffer.writeDoubleBE(value, this.writeOffset);
      } else {
        this.buffer.writeDoubleLE(value, this.writeOffset);
      }
      this.writeOffset += 8;
    }
  }

  const ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_ARRAY = 0;
  const ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_OBJECT = 1;
  const ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_STRING = 2;
  const ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_INT8 = 3;
  const ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_INT16 = 4;
  const ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_INT32 = 5;
  const ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_INT64 = 6;
  const ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_REAL = 7;
  const ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_TRUE = 8;
  const ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_FALSE = 9;
  const ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_NULL = 10;
  const ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_TEMPLATE = 11;
  const ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_SKIP = 12;

  const ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$ST_NEED_PDU = 0; // Need to read and decode PDU length
  const ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$ST_FILL_PDU = 1; // Know the length, need to read whole content
  const ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$MAX_INT8 = 127;
  const ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$MAX_INT16 = 32767;
  const ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$MAX_INT32 = 2147483647;

  class ___R$project$rome$$romejs$codec$watchman$bser_ts$BunserBuf {
    constructor() {
      this.acc = new ___R$project$rome$$romejs$codec$watchman$bser_ts$Accumulator();
      this.state = ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$ST_NEED_PDU;

      this.errorEvent =
        new ___R$project$rome$$romejs$events$Event_ts$default(
          {
            name: 'BunserBuf.error',
          },
        );

      this.valueEvent =
        new ___R$project$rome$$romejs$events$Event_ts$default(
          {
            name: 'BunserBuf.value',
          },
        );

      this.pduLen = false;
    }

    append(buf, synchronous = false) {
      if (synchronous) {
        this.acc.append(buf);
        return this.process(synchronous);
      }

      try {
        this.acc.append(buf);
      } catch (err) {
        this.errorEvent.send(err);
        return;
      }

      // Arrange to decode later.  This allows the consuming

      // application to make progress with other work in the

      // case that we have a lot of subscription updates coming

      // in from a large tree.
      this.processLater();
    }

    processLater() {
      process.nextTick(
        () => {
          try {
            this.process(false);
          } catch (err) {
            this.errorEvent.send(err);
          }
        },
      );
    }

    // Do something with the buffer to advance our state.

    // If we're running synchronously we'll return either

    // the value we've decoded or undefined if we don't

    // yet have enought data.

    // If we're running asynchronously, we'll emit the value

    // when it becomes ready and schedule another invocation

    // of process on the next tick if we still have data we

    // can process.
    process(synchronous) {
      if (this.state == ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$ST_NEED_PDU) {
        if (this.acc.readAvail() < 2) {
          return;
        }

        // Validate BSER header
        this.expectCode(0);
        this.expectCode(1);
        this.pduLen = this.decodePDUInt();
        if (this.pduLen === false) {
          // Need more data, walk backwards
          this.acc.readAdvance(-2);
          return;
        }

        // Ensure that we have a big enough buffer to read the rest of the PDU
        this.acc.reserve(this.pduLen);
        this.state = ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$ST_FILL_PDU;
      }

      if (this.state == ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$ST_FILL_PDU) {
        if (this.acc.readAvail() < this.pduLen) {
          // Need more data
          return;
        }

        // We have enough to decode it
        const val = this.decodeAny();
        if (synchronous) {
          return val;
        }
        this.valueEvent.send(val);
        this.state = ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$ST_NEED_PDU;
      }

      if (!synchronous && this.acc.readAvail() > 0) {
        this.processLater();
      }
    }

    raise(reason) {
      const bufferLength = this.acc.buffer.length;
      const readableLength = this.acc.readAvail();
      const readOffset = this.acc.readOffset;
      const buffer = JSON.stringify(
        this.acc.buffer.slice(
          this.acc.readOffset,
          this.acc.readOffset + 32,
        ).toJSON(),
      );

      throw (
        new Error(
          reason +
          ' in Buffer of length ' +
          bufferLength +
          ', ' +
          readableLength +
          ' readable at offset ' +
          readOffset +
          ' buffer: ' +
          buffer,
        )
      );
    }

    expectCode(expected) {
      const code = this.acc.readInt(1);
      if (code != expected) {
        this.raise('Expected bser opcode ' +
        expected +
        ' but got ' +
        code);
      }
    }

    decodeAny() {
      const code = this.acc.peekInt(1);
      switch (code) {
        case ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_INT8:
        case ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_INT16:
        case ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_INT32:
        case ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_INT64:
          return this.decodeInt();

        case ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_REAL:
          this.acc.readAdvance(1);
          return this.acc.readDouble();

        case ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_TRUE:
          this.acc.readAdvance(1);
          return true;

        case ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_FALSE:
          this.acc.readAdvance(1);
          return false;

        case ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_NULL:
          this.acc.readAdvance(1);
          return null;

        case ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_STRING:
          return this.decodeString();

        case ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_ARRAY:
          return this.decodeArray();

        case ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_OBJECT:
          return this.decodeObject();

        case ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_TEMPLATE:
          return this.decodeTemplate();

        default:
          this.raise('Unhandled bser opcode ' +
          code);
      }
    }

    decodeArray() {
      this.expectCode(___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_ARRAY);
      const nitems = this.decodeInt();
      const arr = [];
      for (let i = 0;
      i < nitems;
      ++i) {
        arr.push(this.decodeAny());
      }
      return arr;
    }

    decodeObject() {
      this.expectCode(___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_OBJECT);
      const nitems = this.decodeInt();
      const res = {};
      for (let i = 0;
      i < nitems;
      ++i) {
        const key = this.decodeString();
        const val = this.decodeAny();
        res[key] = val;
      }
      return res;
    }

    decodeTemplate() {
      this.expectCode(___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_TEMPLATE);
      const keys = this.decodeArray();
      const nitems = this.decodeInt();
      const arr = [];
      for (let i = 0;
      i < nitems;
      ++i) {
        const obj = {};
        for (let keyidx = 0;
        keyidx < keys.length;
        ++keyidx) {
          if (this.acc.peekInt(1) == ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_SKIP) {
            this.acc.readAdvance(1);
            continue;
          }
          const val = this.decodeAny();
          obj[String(keys[keyidx])] = val;
        }
        arr.push(obj);
      }
      return arr;
    }

    decodeString() {
      this.expectCode(___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_STRING);
      const len = this.decodeInt();
      return this.acc.readString(len);
    }

    // This is unusual compared to the other decode functions in that

    // we may not have enough data available to satisfy the read, and

    // we don't want to throw.
    decodePDUInt() {
      if (this.acc.canRead(1)) {
        const size = this.getDecodeIntSize();
        if (this.acc.canRead(1 + size)) {
          return this.decodeInt();
        }
      }

      return false;
    }

    getDecodeIntSize() {
      let size = 0;

      const code = this.acc.peekInt(1);
      switch (code) {
        case ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_INT8:
          size = 1;
          break;

        case ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_INT16:
          size = 2;
          break;

        case ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_INT32:
          size = 4;
          break;

        case ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_INT64:
          size = 8;
          break;

        default:
          throw this.raise('invalid bser int encoding ' +
          code);
      }

      return size;
    }

    decodeInt() {
      this.acc.assertReadableSize(1);
      const size = this.getDecodeIntSize();
      this.acc.readAdvance(1);
      return this.acc.readInt(size);
    }
  }

  function ___R$project$rome$$romejs$codec$watchman$bser_ts$loadFromBuffer(input) {
    const buf = new ___R$project$rome$$romejs$codec$watchman$bser_ts$BunserBuf();
    const result = buf.append(input, true);

    if (buf.acc.readAvail()) {
      throw Error('Excess data found after input buffer, use BunserBuf instead');
    }

    if (typeof result === 'undefined') {
      throw Error('No bser found in string and no error raised!?');
    }

    return result;
  }

  function ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$dumpInt(buf, val) {
    const abs = Math.abs(val);
    if (abs <= ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$MAX_INT8) {
      buf.writeByte(___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_INT8);
      buf.writeInt(val, 1);
    } else if (abs <= ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$MAX_INT16) {
      buf.writeByte(___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_INT16);
      buf.writeInt(val, 2);
    } else if (abs <= ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$MAX_INT32) {
      buf.writeByte(___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_INT32);
      buf.writeInt(val, 4);
    } else {
      throw new Error('???');
    }
  }

  function ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$dumpArray(buf, val) {
    buf.writeByte(___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_ARRAY);
    ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$dumpInt(buf, val.length);
    for (let i = 0;
    i < val.length;
    ++i) {
      ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$dumpUnknown(buf, val[i]);
    }
  }

  function ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$dumpObject(buf, val) {
    if (val === null) {
      buf.writeByte(___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_NULL);
      return;
    }

    if (Array.isArray(val)) {
      ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$dumpArray(buf, val);
      return;
    }

    if (!___R$project$rome$$romejs$typescript$helpers$index_ts$isPlainObject(val)) {
      throw new Error('Expected a plain object');
    }

    buf.writeByte(___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_OBJECT);

    const keys = Object.keys(val);

    // First pass to compute number of defined keys
    let num_keys = keys.length;
    for (let i = 0;
    i < keys.length;
    ++i) {
      const key = keys[i];
      const v = val[key];
      if (typeof v === 'undefined') {
        num_keys--;
      }
    }

    ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$dumpInt(buf, num_keys);

    for (let i = 0;
    i < keys.length;
    ++i) {
      const key = keys[i];
      const v = val[key];
      if (typeof v === 'undefined') {
        // Don't include it
        continue;
      }

      ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$dumpUnknown(buf, key);
      try {
        ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$dumpUnknown(buf, v);
      } catch (err) {
        throw (
          new Error(
            err.message +
            '  (while serializing object property with name ' +
            key,
          )
        );
      }
    }
  }

  function ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$dumpUnknown(buf, val) {
    switch (typeof val) {
      case 'number':
        // check if it is an integer or a float
        if (isFinite(val) && Math.floor(val) === val) {
          ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$dumpInt(buf, val);
        } else {
          buf.writeByte(___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_REAL);
          buf.writeDouble(val);
        }
        return;

      case 'bigint':
        throw new Error('bigint isn\'t supported yet');

      case 'string':
        buf.writeByte(___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_STRING);
        ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$dumpInt(buf, Buffer.byteLength(val));
        buf.append(val);
        return;

      case 'boolean':
        buf.writeByte(val ? ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_TRUE : ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_FALSE);
        return;

      case 'object':
        ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$dumpObject(buf, val);
        return;

      default:
        throw new Error('Cannot serialize type ' +
        typeof val +
        ' to BSER');
    }
  }

  // BSER encode value and return a buffer of the contents
  function ___R$project$rome$$romejs$codec$watchman$bser_ts$dumpToBuffer(val) {
    const buf = new ___R$project$rome$$romejs$codec$watchman$bser_ts$Accumulator();
    // Build out the header
    buf.writeByte(0);
    buf.writeByte(1);
    // Reserve room for an int32 to hold our PDU length
    buf.writeByte(___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$BSER_INT32);
    buf.writeInt(0, 4); // We'll come back and fill this in at the end
    ___R$$priv$project$rome$$romejs$codec$watchman$bser_ts$dumpUnknown(buf, val);

    // Compute PDU length
    const off = buf.writeOffset;
    const len = off - 7 /* the header length */;
    buf.writeOffset = 3; // The length value to fill in
    buf.writeInt(len, 4); // write the length in the space we reserved
    buf.writeOffset = off;

    return buf.buffer.slice(0, off);
  }

  // project-rome/@romejs/codec-watchman/index.ts
const ___R$$priv$project$rome$$romejs$codec$watchman$index_ts$child_process = require(
    'child_process',
  );
  const ___R$$priv$project$rome$$romejs$codec$watchman$index_ts$util = require(
    'util',
  );
  const ___R$$priv$project$rome$$romejs$codec$watchman$index_ts$net = require(
    'net',
  );
  const ___R$$priv$project$rome$$romejs$codec$watchman$index_ts$exec = ___R$$priv$project$rome$$romejs$codec$watchman$index_ts$util.promisify(___R$$priv$project$rome$$romejs$codec$watchman$index_ts$child_process.exec);

  function ___R$$priv$project$rome$$romejs$codec$watchman$index_ts$normalizeWatchmanSubscription(res) {
    return (
      {
        'state-enter': res.get('state-enter').asStringOrVoid(),
        'state-leave': res.get('state-leave').asStringOrVoid(),
        unilateral: res.get('unilateral').asBoolean(),
        subscription: res.get('subscription').asString(),
        root: res.get('root').asString(),

        // This can be a massive array... We should still probably efficiently validate it though somehow
        files: res.get('files').asAny(),

        is_fresh_instance: res.get('is_fresh_instance').asBoolean(),
        version: res.get('version').asString(),
        since: res.get('since').asString(),
        clock: res.get('clock').asString(),
      }
    );
  }

  class ___R$project$rome$$romejs$codec$watchman$index_ts$WatchmanClient {
    constructor(socket, reporter) {
      this.reporter = reporter;
      this.socket = socket;

      this.subscriptionCounter = 0;
      this.subscriptions = new Map();

      this.logEvent = new ___R$project$rome$$romejs$events$Event_ts$default({name: 'WatchmanClient.log'});

      this.callbacks = [];
      this.listen();
    }

    listen() {
      const {socket} = this;

      socket.on(
        'error',
        function() {
          //
        },
      );

      const bunser = new ___R$project$rome$$romejs$codec$watchman$bser_ts$BunserBuf();

      bunser.valueEvent.subscribe(
        (obj) => {
          this.processResponse(___R$project$rome$$romejs$consume$index_ts$consumeUnknown(obj, 'parse/json'));
        },
      );

      socket.on(
        'data',
        (chunk) => {
          bunser.append(chunk);
        },
      );

      socket.on(
        'end',
        () => {
          this.end();
        },
      );
    }

    processResponse(res) {
      if (res.has('warn')) {
        this.reporter.warn(res.get('warn').asString());
      }

      if (res.has('subscription')) {
        const name = res.get('subscription').asString();
        const event = this.subscriptions.get(name);
        if (event === undefined) {
          this.reporter.warn(
            'Received a watchman subscription event for %s that we aren\'t listening for',
            name,
          );
        } else {
          event.send(___R$$priv$project$rome$$romejs$codec$watchman$index_ts$normalizeWatchmanSubscription(res));
        }
        return;
      }

      if (res.has('log')) {
        // TODO
        return;
      }

      if (res.get('unilateral').asBooleanOrVoid() === true) {
        this.reporter.warn(
          'Received a watchman unilateral event that we don\'t support',
          res.asUnknown(),
        );
        return;
      }

      const callback = this.callbacks.shift();
      if (callback === undefined) {
        throw new Error('Received message but no callback');
      }

      if (res.has('error')) {
        callback.reject(new Error(res.get('error').asString()));
      } else {
        callback.resolve(res);
      }
    }

    async createSubscription(dir, opts) {
      const name = 'rome-' +
      process.pid +
      '.' +
      String(this.subscriptionCounter++);
      const event = new ___R$project$rome$$romejs$events$Event_ts$default(
        {
          name,
        },
      );
      this.subscriptions.set(name, event);

      const consumer = await this.command(['watch-project', dir]);

      // Refine any filter to specifically files from the requested directory if we weren't the watchman root
      if (consumer.has('relative_path')) {
        opts =
          Object.assign(
            {
            },
            opts,
            {
              relative_root: consumer.get('relative_path').asString(),
            },
          );
      }

      const root = consumer.get('watch').asString();
      await this.command(['subscribe', root, name, opts]);
      return event;
    }

    async command(args) {
      return (
        new Promise(
          (resolve, reject) => {
            this.callbacks.push({resolve, reject});
            this.socket.write(___R$project$rome$$romejs$codec$watchman$bser_ts$dumpToBuffer(args));
          },
        )
      );
    }

    end() {
      for (const {reject} of this.callbacks) {
        reject(new Error('The watchman connection was closed'));
      }
      this.socket.end();
    }
  }

  async function ___R$project$rome$$romejs$codec$watchman$index_ts$getWatchmanSocketLocation() {
    // Environment variable may be set by invoking tools
    if (typeof process.env.WATCHMAN_SOCK === 'string') {
      return process.env.WATCHMAN_SOCK;
    }

    try {
      const {stdout, stderr} = await ___R$$priv$project$rome$$romejs$codec$watchman$index_ts$exec('watchman --no-pretty get-sockname');

      // Parse response
      try {
        const data = JSON.parse(stdout);

        // Validate JSON result
        if (typeof data !== 'object' || data == null ||
        typeof data.sockname !==
        'string') {
          throw (
            new Error(
              'Watchman returned JSON payload that wasnt an object with a sockname property',
            )
          );
        }

        return data.sockname;
      } catch (err) {
        // Better error message for syntatically invalid JSON
        if (err instanceof SyntaxError) {
          err = new Error('Watchman returned malformed JSON payload');
        }

        // Always add the stdout and stderr to messages for better readability
        err.message += ' ' +
        JSON.stringify({stdout, stderr});
        throw err;
      }
    } catch (err) {
      if (err.code === 127) {
        // Exit code for command not found
        throw new Error('No watchman binary command found');
      } else {
        throw err;
      }
    }
  }

  async function ___R$project$rome$$romejs$codec$watchman$index_ts$createWatchmanClient(
    reporter,
  ) {
    const sockname = await ___R$project$rome$$romejs$codec$watchman$index_ts$getWatchmanSocketLocation();
    const socket = ___R$$priv$project$rome$$romejs$codec$watchman$index_ts$net.createConnection(sockname);

    return (
      new Promise(
        (resolve, reject) => {
          socket.on(
            'error',
            (err) => {
              reject(err);
            },
          );

          socket.on(
            'connect',
            () => {
              resolve(new ___R$project$rome$$romejs$codec$watchman$index_ts$WatchmanClient(socket, reporter));
            },
          );
        },
      )
    );
  }

  // project-rome/@romejs/core/master/fs/MemoryFileSystem.ts
const ___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$crypto = require(
    'crypto',
  );
  const ___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$fs = require(
    'fs',
  );
  const ___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$DEFAULT_DENYLIST = ['.hg', '.git'];

  const ___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$PACKAGE_JSON = 'package.json';

  const ___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$GLOB_IGNORE = [
    ___R$project$rome$$romejs$path$match$parse_ts$parsePattern({input: 'node_modules'}),
    ___R$project$rome$$romejs$path$match$parse_ts$parsePattern({input: '.git'}),
    ___R$project$rome$$romejs$path$match$parse_ts$parsePattern({input: '.hg'}),
  ];

  function ___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$concatGlobIgnore(patterns) {
    // If there are any negate patterns then it'll never include GLOB_IGNORE
    for (const {negate} of patterns) {
      if (negate) {
        return patterns;
      }
    }

    return [...___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$GLOB_IGNORE, ...patterns];
  }

  // Whenever we're performing an operation on a set of files, always do these first as they may influence how the rest are processed
  const ___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$PRIORITY_FILES = new Set(___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_FILENAMES);

  async function ___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$createRegularWatcher(
    memoryFs,
    diagnostics,
    projectFolderPath,
  ) {
    const projectFolder = projectFolderPath.join();
    const {logger} = memoryFs.master;

    // Create activity spinners for all connected reporters
    const activity = memoryFs.master.connectedReporters.progress(
      {
        initDelay: 1000,
      },
    );
    activity.setTitle('Adding project ' +
    projectFolder);

    const watchers = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();

    try {
      function onFoundDirectory(folderPath) {
        if (watchers.has(folderPath)) {
          return;
        }

        if (process.platform === 'linux') {
          // Node on Linux doesn't support recursive directory watching so we need an fs.watch for every directory...
        } else if (!folderPath.equal(projectFolderPath)) {
          // If we're on any other platform then only watch the root project folder
          return;
        }

        const watcher = ___R$project$rome$$romejs$fs$index_ts$watch(
          folderPath,
          {recursive: true, persistent: false},
          (
            eventType,
            filename,
          ) => {
            if (filename === null) {
              // TODO not sure how we want to handle this?
              return;
            }

            const path = folderPath.resolve(filename);

            memoryFs.stat(path).then(
              (newStats) => {
                const diagnostics = memoryFs.master.createDisconnectedDiagnosticsProcessor(
                  [
                    {
                      category: 'memory-fs',
                      message: 'Processing fs.watch changes',
                    },
                  ],
                );

                if (newStats.type === 'file') {
                  memoryFs.handleFileChange(
                    path,
                    newStats,
                    {
                      diagnostics,
                      crawl: true,
                    },
                  );
                } else if (newStats.type === 'directory') {
                  memoryFs.addDirectory(
                    path,
                    newStats,
                    {
                      crawl: true,
                      diagnostics,
                      onFoundDirectory,
                    },
                  );
                }
              },
            ).catch(
              (err) => {
                if (err.code === 'ENOENT') {
                  memoryFs.handleDeletion(path);
                } else {
                  throw err;
                }
              },
            );
          },
        );
        watchers.set(folderPath, watcher);
      }

      // No need to call watch() on the projectFolder since it will call us

      // Perform an initial crawl
      const stats = await memoryFs.stat(projectFolderPath);
      await memoryFs.addDirectory(
        projectFolderPath,
        stats,
        {
          crawl: true,
          diagnostics,
          onFoundDirectory,
        },
      );
      logger.info(
        '[MemoryFileSystem] Finished initial crawl for ' +
        projectFolder +
        ' - added ' +
        ___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(
          memoryFs.countFiles(projectFolderPath),
        ) +
        ' files',
      );
    } finally {
      activity.end();
    }

    return (
      () => {
        for (const watcher of watchers.values()) {
          watcher.close();
        }
      }
    );
  }

  async function ___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$createWatchmanWatcher(
    memoryFs,
    diagnostics,
    projectFolderPath,
    projectConfig,
  ) {
    const projectFolder = projectFolderPath.join();
    const {connectedReporters} = memoryFs.master;

    const activity = connectedReporters.progress();
    activity.setTitle('Adding project ' +
    projectFolder +
    ' with watchman');

    let timeout;

    function queueCallout() {
      timeout =
        setTimeout(
          memoryFs.master.wrapFatal(
            () => {
              connectedReporters.warn(
                'Watchman is taking a while to respond. Watchman may have just started and is still crawling the disk.',
              );

              // Show an even more aggressive message when watchman takes longer
              queueCallout();
            },
          ),
          5000,
        );
    }

    // Show a message when watchman takes too long
    queueCallout();

    try {
      const client = await ___R$project$rome$$romejs$codec$watchman$index_ts$createWatchmanClient(___R$project$rome$$romejs$cli$reporter$Reporter_ts$default.fromProcess());

      const event = await client.createSubscription(
        projectFolder,
        {
          fields: ['mtime', 'name', 'size', 'type', 'exists'],
          expression: [
            'anyof',
            ['type', 'd'],
            ['suffix', ___R$project$rome$$romejs$core$common$fileHandlers_ts$getFileHandlerExtensions(projectConfig)],
          ],
        },
      );

      const initial = await event.wait();
      if (initial.is_fresh_instance !== true) {
        throw new Error('Expected this to be a fresh instance');
      }
      clearTimeout(timeout);

      async function processChanges(
        data,
        diagnostics,
      ) {
        if (data['state-enter'] || data['state-leave']) {
          return;
        }

        // rome-suppress lint/noExplicitAny
        const dirs = [];
        // rome-suppress lint/noExplicitAny
        const files = [];

        for (const file of data.files) {
          const path = projectFolderPath.append(file.name);

          if (file.exists === false) {
            memoryFs.handleDeletion(path);
            continue;
          }

          if (file.type === 'f') {
            const basename = path.getBasename();

            if (___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$PRIORITY_FILES.has(basename)) {
              files.unshift([path, file]);
            } else {
              files.push([path, file]);
            }
          } else if (file.type === 'd') {
            dirs.push([path, file]);
          }
        }

        await Promise.all(
          dirs.map(
            async ([path, info]) => {
              await memoryFs.addDirectory(
                path,
                {
                  size: info.size,
                  mtime: info.mtime,
                  type: 'directory',
                },
                {diagnostics, crawl: false},
              );
            },
          ),
        );

        await Promise.all(
          files.map(
            async ([path, info]) => {
              const stats = {
                size: info.size,
                mtime: info.mtime,
                type: 'file',
              };

              if (memoryFs.files.has(path)) {
                await memoryFs.handleFileChange(
                  path,
                  stats,
                  {
                    diagnostics,
                    crawl: false,
                  },
                );
              } else {
                await memoryFs.addFile(
                  path,
                  stats,
                  {
                    diagnostics,
                    crawl: false,
                  },
                );
              }
            },
          ),
        );
      }

      activity.setText('Processing results');
      await processChanges(initial, diagnostics);

      event.subscribe(
        (data) => {
          processChanges(
            data,
            memoryFs.master.createDisconnectedDiagnosticsProcessor(
              [
                {
                  category: 'memory-fs',
                  message: 'Processing watchman changes',
                },
              ],
            ),
          );
        },
      );

      activity.end();

      return (
        () => {
          // TODO close
        }
      );
    } catch (err) {
      activity.end();

      if (err.message.includes('RootResolveError')) {
        // Fallback to node processor
        memoryFs.master.connectedReporters.error(
          'Failed to use watchman: ' +
          err.message,
        );
        return ___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$createRegularWatcher(memoryFs, diagnostics, projectFolderPath);
      } else {
        throw err;
      }
    } finally {
      clearTimeout(timeout);
    }
  }

  class ___R$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$default {
    constructor(master) {
      this.master = master;

      this.watchPromises = new Map();
      this.directoryListings = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
      this.directories = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
      this.files = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
      this.manifests = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
      this.watchers = new Map();
      this.manifestCounter = 0;

      this.changedFileEvent =
        new ___R$project$rome$$romejs$events$Event_ts$default(
          {
            name: 'MemoryFileSystem.changedFile',
            onError: master.onFatalErrorBound,
          },
        );
      this.deletedFileEvent =
        new ___R$project$rome$$romejs$events$Event_ts$default(
          {
            name: 'MemoryFileSystem.deletedFile',
            onError: master.onFatalErrorBound,
          },
        );
    }

    init() {}

    unwatch(dirPath) {
      const dir = dirPath.join();
      const watcher = this.watchers.get(dir);
      if (watcher === undefined) {
        return;
      }

      this.watchers.delete(dir);
      watcher.close();

      // Go through and clear all files and directories from our internal maps

      // NOTE: We deliberately do not call 'deletedFileEvent' as the code that

      // calls us will already be cleaning up
      let queue = [dirPath];
      while (queue.length > 0) {
        const path = queue.pop();
        if (path === undefined) {
          throw new Error('Unknown path');
        }

        this.directories.delete(path);
        this.manifests.delete(path);
        this.files.delete(path);

        const listing = this.directoryListings.get(path);
        if (listing !== undefined) {
          this.directoryListings.delete(path);
          queue = queue.concat(Array.from(listing.values()));
        }
      }
    }

    unwatchAll() {
      for (const {close} of this.watchers.values()) {
        close();
      }
    }

    readdir(path) {
      const listing = this.directoryListings.get(path);
      if (listing === undefined) {
        return [];
      } else {
        return listing.values();
      }
    }

    isDirectory(filename) {
      return this.directories.has(filename);
    }

    isFile(filename) {
      return this.files.has(filename);
    }

    getFiles() {
      return Array.from(this.files.values());
    }

    getManifestDefinition(dirname) {
      return this.manifests.get(dirname);
    }

    getManifest(dirname) {
      const def = this.getManifestDefinition(dirname);
      if (def === undefined) {
        return undefined;
      } else {
        return def.manifest;
      }
    }

    getOwnedManifest(path) {
      for (const dir of path.getChain()) {
        const def = this.master.memoryFs.getManifestDefinition(dir);
        if (def !== undefined) {
          return def;
        }
      }
    }

    getPartialManifest(def) {
      return (
        {
          path: def.path.join(),
          type: def.manifest.type,
        }
      );
    }

    addFileToDirectoryListing(path) {
      const dirname = path.getParent();
      let listing = this.directoryListings.get(dirname);
      if (listing === undefined) {
        listing = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
        this.directoryListings.set(dirname, listing);
      }
      listing.set(path, path);
    }

    handleDeletion(path) {
      // If a folder then evict all children
      const folderInfo = this.directories.get(path);
      if (folderInfo !== undefined) {
        this.directories.delete(path);

        const listing = this.directoryListings.get(path);
        if (listing !== undefined) {
          this.directoryListings.delete(path);
          for (const path of listing.values()) {
            this.handleDeletion(path);
          }
        }
      }

      // Remove from 'all possible caches
      this.files.delete(path);

      // Remove from 'haste maps
      this.handleDeletedHaste(path);

      // If this is a manifest filename then clear it from 'any possible package and our internal module map
      const basename = path.getBasename();
      if (basename === 'package.json') {
        this.handleDeletedManifest(path);
      }

      // Remove from 'parent directory listing
      const dirname = path.getParent();
      const parentListing = this.directoryListings.get(dirname);
      if (parentListing !== undefined) {
        parentListing.delete(path);
      }

      this.deletedFileEvent.send(path);
    }

    handleDeletedHaste(path) {
      const hasteName = this.getHasteName(path);
      if (hasteName === undefined) {
        return undefined;
      }

      const projects = this.master.projectManager.getHierarchyFromFilename(path);
      for (const {hasteMap} of projects) {
        const existing = hasteMap.get(hasteName);
        if (existing !== undefined && existing.equal(path)) {
          hasteMap.delete(hasteName);
        }
      }
    }

    handleDeletedManifest(path) {
      const folder = path.getParent();
      const def = this.manifests.get(folder);
      if (def !== undefined) {
        this.manifests.delete(folder);
      }
    }

    async handleFileChange(path, stats, opts) {
      const oldStats = this.getFileStats(path);
      const changed = await this.addFile(path, stats, opts);
      if (changed) {
        const newStats = this.getFileStatsAssert(path);
        this.changedFileEvent.send({path, oldStats, newStats});
      }
      return changed;
    }

    async watch(projectFolderPath, projectConfig) {
      const {logger} = this.master;
      const projectFolder = projectFolderPath.join();

      // Defer if we're already currently initializing this project
      const cached = this.watchPromises.get(projectFolder);
      if (cached !== undefined) {
        await cached;
        return undefined;
      }

      // Check if we're already watching this folder
      if (this.watchers.has(projectFolder)) {
        return undefined;
      }

      // Check if we're already watching a parent directory
      for (const {path} of this.watchers.values()) {
        if (projectFolderPath.isRelativeTo(path)) {
          logger.info(
            '[MemoryFileSystem] Skipped crawl for ' +
            projectFolder +
            ' because we\'re already watching the parent directory ' +
            path.join(),
          );
          return undefined;
        }
      }

      // Defer if we're initializing a parent folder
      for (const {promise, path} of this.watchPromises.values()) {
        if (projectFolderPath.isRelativeTo(path)) {
          await promise;
          return undefined;
        }
      }

      // Wait if we're initializing descendents
      for (const {path, promise} of this.watchPromises.values()) {
        if (path.isRelativeTo(projectFolderPath)) {
          await promise;
        }
      }

      // New watch target
      logger.info('[MemoryFileSystem] Adding new project folder ' +
      projectFolder);

      // Remove watchers that are descedents of this folder as this watcher will handle them
      for (const [loc, {close, path}] of this.watchers) {
        if (path.isRelativeTo(projectFolderPath)) {
          this.watchers.delete(loc);
          close();
        }
      }

      const diagnostics = new ___R$project$rome$$romejs$diagnostics$DiagnosticsProcessor_ts$default(
        {
          origins: [
            {
              category: 'memory-fs',
              message: 'Crawling project folder',
            },
          ],
        },
      );

      let promise;
      if (projectConfig.files.watchman) {
        logger.info('[MemoryFileSystem] Watching ' +
        projectFolder +
        ' with watchman');
        promise =
          ___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$createWatchmanWatcher(
            this,
            diagnostics,
            projectFolderPath,
            projectConfig,
          );
      } else {
        logger.info('[MemoryFileSystem] Watching ' +
        projectFolder +
        ' with fs.watch');
        promise = ___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$createRegularWatcher(this, diagnostics, projectFolderPath);
      }
      this.watchPromises.set(
        projectFolder,
        {
          path: projectFolderPath,
          promise,
        },
      );

      const watcherClose = await promise;
      this.watchers.set(
        projectFolder,
        {
          path: projectFolderPath,
          close: watcherClose,
        },
      );
      this.watchPromises.delete(projectFolder);

      diagnostics.maybeThrowDiagnosticsError();
    }

    async stat(path) {
      const stats = await ___R$project$rome$$romejs$fs$index_ts$lstat(path);

      let type = 'unknown';
      if (stats.isDirectory()) {
        type = 'directory';
      } else if (stats.isFile()) {
        type = 'file';
      }

      return (
        {
          type,
          size: stats.size,
          mtime: stats.mtimeMs,
        }
      );
    }

    getMtime(filename) {
      const stats = this.getFileStats(filename);
      if (stats === undefined) {
        throw (
          new Error(
            'File ' +
            filename.join() +
            ' not in database, cannot get mtime',
          )
        );
      } else {
        return stats.mtime;
      }
    }

    getFileStats(filename) {
      return this.files.get(filename);
    }

    getFileStatsAssert(filename) {
      const stats = this.getFileStats(filename);
      if (stats === undefined) {
        throw new Error('Expected file stats for ' +
        filename);
      }
      return stats;
    }

    isIgnored(path, type) {
      const project = this.master.projectManager.findProjectExisting(path);
      if (project === undefined) {
        return false;
      }

      // If we're a file and don't have an extension handler so there's no reason for us to care about it
      if (type === 'file' && ___R$project$rome$$romejs$core$common$fileHandlers_ts$getFileHandler(path, project.config) === undefined) {
        return true;
      }

      // Ensure we aren't in any of the default denylists
      const basename = path.getBasename();
      if (___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$DEFAULT_DENYLIST.includes(basename)) {
        return true;
      }

      return false;
    }

    isInsideProject(path) {
      return path.getSegments().includes('node_modules') === false;
    }

    isInsideHaste(path) {
      if (!this.isInsideProject(path)) {
        return false;
      }

      // Check if we're inside a haste package, child files of a haste package shouldn't be added to the haste map
      for (const dir of path.getChain()) {
        const packagePath = dir.append(___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$PACKAGE_JSON);
        if (path.equal(packagePath)) {
          // isInsideHaste will be called after we declare a haste package, all it's subfiles wont be inside the haste map but we should still be
          continue;
        }

        const manifest = this.getManifest(packagePath);
        if (manifest !== undefined && manifest.raw.haste_commonjs === true) {
          return false;
        }
      }

      return true;
    }

    getHasteName(path) {
      const filename = path.join();

      let {handler, ext} = this.master.projectManager.getHandlerWithProject(path);
      if (handler === undefined || handler.hasteMode === undefined) {
        return undefined;
      }

      const basename = path.getBasename();

      if (handler.hasteMode === 'ext') {
        ext = '.' +
        ext; // we also want to remove the dot suffix from the haste name
        if (!filename.endsWith(ext)) {
          throw (
            new Error(
              'Expected ' +
              filename +
              ' to end with ' +
              ext +
              ' as it was returned as the extension name',
            )
          );
        }

        return basename.slice(0, -ext.length);
      } else if (handler.hasteMode === 'noext') {
        return basename;
      }

      return undefined;
    }

    // This is a wrapper around _declareManifest as it can produce diagnostics
    async declareManifest(opts) {
      try {
        return await this._declareManifest(opts);
      } catch (err) {
        const diagnostics = ___R$project$rome$$romejs$diagnostics$errors_ts$getDiagnosticsFromError(err);

        if (diagnostics === undefined) {
          throw err;
        } else {
          opts.diagnostics.addDiagnostics(diagnostics);
        }
        return undefined;
      }
    }

    async _declareManifest({
      path,
      hasteName,
      diagnostics,
    }) {
      // Fetch the manifest
      const manifestRaw = await ___R$project$rome$$romejs$fs$index_ts$readFileText(path);
      const hash = ___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$crypto.createHash('sha256').update(manifestRaw).digest('hex');

      const consumer = ___R$project$rome$$romejs$codec$json$index_ts$consumeJSON(
        {
          path,
          input: manifestRaw,
          consumeDiagnosticCategory: 'parse/manifest',
        },
      );

      const {
        manifest,
        diagnostics: normalizedDiagnostics,
      } = await ___R$project$rome$$romejs$codec$js$manifest$index_ts$normalizeManifest(path, consumer);

      // If manifest is undefined then we failed to validate and have diagnostics
      if (normalizedDiagnostics.length > 0) {
        diagnostics.addDiagnostics(normalizedDiagnostics);
        return;
      }

      const folder = path.getParent();
      const manifestId = this.manifestCounter++;
      const def = {
        id: manifestId,
        path,
        folder,
        consumer,
        manifest,
        hash,
      };

      this.manifests.set(folder, def);

      // Set haste name and haste location to the directory itself
      if (manifest.name !== undefined) {
        hasteName = manifest.name;
      }

      // If we aren't in node_modules then this is a project package
      const isProjectPackage = this.isInsideProject(path);
      const {projectManager} = this.master;
      const project = projectManager.findProjectExisting(path);
      if (project !== undefined) {
        projectManager.declareManifest(project, isProjectPackage, def, diagnostics);
      }

      // Tell all workers of our discovery
      for (const worker of this.master.workerManager.getWorkers()) {
        worker.bridge.updateManifests.call(
          {
            manifests: [{id: def.id, manifest: this.getPartialManifest(def)}],
          },
        );
      }

      return hasteName;
    }

    glob(cwd, opts = {}) {
      const {
        extensions,
        getProjectIgnore,
        getProjectEnabled,
        test,
        overrideIgnore = [],
      } = opts;

      const paths = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet();

      let crawl = [cwd];

      const ignoresByProject = new Map();

      while (crawl.length > 0) {
        const path = crawl.pop();
        if (path === undefined) {
          throw new Error('crawl.length already validated');
        }

        const project = this.master.projectManager.assertProjectExisting(path);

        let ignore = overrideIgnore;

        // Get ignore patterns
        if (getProjectIgnore !== undefined) {
          const projectIgnore = ignoresByProject.get(project);
          if (projectIgnore === undefined) {
            ignore =
              ___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$concatGlobIgnore(
                [
                  ...ignore,
                  ...getProjectIgnore(project).patterns,
                ],
              );
            ignoresByProject.set(project, ignore);
          } else {
            ignore = projectIgnore;
          }
        }

        const ignoreMatched = ___R$project$rome$$romejs$path$match$index_ts$matchPathPatterns(path, ignore, cwd);

        // Don't even recurse into explicit matches
        if (ignoreMatched === 'EXPLICIT_MATCH') {
          continue;
        }

        // Add if a matching file
        if (this.files.has(path) && ignoreMatched === 'NO_MATCH') {
          if (getProjectEnabled !== undefined &&
            !getProjectEnabled(project).enabled) {
            continue;
          }

          if (test !== undefined && !test(path)) {
            continue;
          }

          // Check extensions
          if (extensions !== undefined) {
            let matchedExt = false;
            for (const ext of extensions) {
              matchedExt = path.hasEndExtension(ext);
              if (matchedExt) {
                break;
              }
            }
            if (!matchedExt) {
              continue;
            }
          }

          paths.add(path);
          continue;
        }

        // Crawl if we're a folder

        // NOTE: We still continue crawling on implicit matches
        const listing = this.directoryListings.get(path);
        if (listing !== undefined) {
          crawl = crawl.concat(Array.from(listing.values()));
          continue;
        }

        // TODO maybe throw? not a file or folder, doesn't exist!
      }

      return paths;
    }

    getAllFilesInFolder(folder) {
      let files = [];

      const listing = this.directoryListings.get(folder);
      if (listing !== undefined) {
        for (const file of listing.keys()) {
          if (this.files.has(file)) {
            files.push(file);
          } else {
            files = files.concat(this.getAllFilesInFolder(file));
          }
        }
      }

      return files;
    }

    countFiles(folder) {
      let count = 0;

      const listing = this.directoryListings.get(folder);
      if (listing !== undefined) {
        for (const file of listing.keys()) {
          count++;
          count += this.countFiles(file);
        }
      }

      return count;
    }

    hasStatsChanged(filename, newStats) {
      const oldStats = this.directories.get(filename) || this.files.get(filename);
      return oldStats === undefined || newStats.mtime !== oldStats.mtime;
    }

    async addDirectory(folderPath, stats, opts) {
      if (!this.hasStatsChanged(folderPath, stats)) {
        return false;
      }

      // Check if this folder has been ignored
      if (this.isIgnored(folderPath, 'directory')) {
        return false;
      }

      if (opts.tick !== undefined) {
        opts.tick(folderPath);
      }

      this.addFileToDirectoryListing(folderPath);
      this.directories.set(folderPath, stats);

      if (opts.onFoundDirectory !== undefined) {
        opts.onFoundDirectory(folderPath);
      }

      if (opts.crawl) {
        // Crawl the folder
        const files = await ___R$project$rome$$romejs$fs$index_ts$readdir(folderPath);

        // Declare the file
        const declareItem = async (path) => {
          const stats = await this.stat(path);
          if (stats.type === 'file') {
            await this.addFile(path, stats, opts);
          } else if (stats.type === 'directory') {
            await this.addDirectory(path, stats, opts);
          }
        };

        // Give priority to package.json as we base some haste heuristics on it's entry
        for (const file of files) {
          if (___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$PRIORITY_FILES.has(file.getBasename())) {
            files.delete(file);
            await declareItem(file);
          }
        }

        // Add the rest of the items
        await Promise.all(Array.from(files, declareItem));
      }

      return true;
    }

    exists(path) {
      // if we have this in our cache then the file exists
      if (this.files.has(path) || this.directories.has(path)) {
        return true;
      }

      // If we're still performing an initial crawl of any path higher in the tree then we don't know if it exists yet
      for (const {path: projectFolder} of this.watchPromises.values()) {
        if (path.isRelativeTo(projectFolder)) {
          return undefined;
        }
      }

      // if we're watching the parent folder then we'd have it in our cache if it existed
      const parent = path.getParent();
      if (this.directories.has(parent)) {
        return false;
      }

      return undefined;
    }

    async existsHard(path) {
      const resolvedExistence = this.exists(path);
      if (resolvedExistence === undefined) {
        return ___R$project$rome$$romejs$fs$index_ts$exists(path);
      } else {
        return resolvedExistence;
      }
    }

    async addFile(path, stats, opts) {
      if (!this.hasStatsChanged(path, stats)) {
        return false;
      }

      // Check if this file has been ignored
      if (this.isIgnored(path, 'file')) {
        return false;
      }

      if (opts.tick !== undefined) {
        opts.tick(path);
      }

      this.files.set(path, stats);
      this.addFileToDirectoryListing(path);

      let hastePath = path;
      let hasteName = this.getHasteName(path);

      const basename = path.getBasename();
      const dirname = path.getParent();

      // Warn about potentially incorrect Rome config filenames
      const {projectManager} = this.master;
      projectManager.checkConfigFile(path, opts.diagnostics);

      // Add project if this is a config
      if (___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_FILENAMES.includes(basename)) {
        await projectManager.queueAddProject(dirname, path);
      }

      // If this is a package.json then declare this module and setup the correct haste variables
      if (basename === 'package.json') {
        hasteName =
          await this.declareManifest(
            {
              diagnostics: opts.diagnostics,
              dirname,
              path,
              hasteName,
              hastePath,
            },
          );
        hastePath = dirname;
      }

      // Add to haste map
      if (hasteName !== undefined && this.isInsideHaste(path)) {
        projectManager.declareHaste(path, hasteName, hastePath, opts.diagnostics);
      }

      return true;
    }
  }

  // project-rome/@romejs/core/master/Cache.ts
// Basic checks to determine if we can consider a and b to be mergable
  function ___R$$priv$project$rome$$romejs$core$master$Cache_ts$areEntriesEqual(a, b) {
    if (a.version !== b.version) {
      // Outdated cache file
      return false;
    }

    if (a.configHash !== b.configHash) {
      // Project config has been changed since this was last updated
      return false;
    }

    if (a.mtime !== b.mtime) {
      // File has been changed
      return false;
    }

    return true;
  }

  class ___R$project$rome$$romejs$core$master$Cache_ts$default {
    constructor(master) {
      this.master = master;
      this.loadedEntries = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
      this.disabled = process.env.ROME_CACHE === '0';
      this.cachePath = master.userConfig.cachePath;
    }

    async init() {
      this.master.memoryFs.deletedFileEvent.subscribe(
        (filename) => {
          return this.master.cache.handleDeleted(filename);
        },
      );

      const {memoryFs} = this.master;
      await ___R$project$rome$$romejs$fs$index_ts$createDirectory(this.cachePath, {recursive: true});
      await memoryFs.watch(this.cachePath, ___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG);
    }

    async createEmptyEntry(filename) {
      const {projectManager, memoryFs} = this.master;

      const project = await projectManager.assertProject(
        filename,
      );

      const configHashes = [...project.meta.configHashes];
      const pkg = this.master.memoryFs.getOwnedManifest(filename);
      if (pkg !== undefined) {
        configHashes.push(pkg.hash);
      }

      const entry = {
        version: ___R$project$rome$$romejs$core$common$constants_ts$VERSION,
        projectDir: project.folder.join(),
        configHash: configHashes.join(';'),
        mtime: memoryFs.getMtime(filename),
        compile: {},
        analyzeDependencies: undefined,
        moduleSignature: undefined,
        lint: undefined,
      };

      return entry;
    }

    getCacheFilename(filename) {
      const uid = this.master.projectManager.getUid(filename);
      return this.cachePath.append(uid);
    }

    async handleDeleted(filename) {
      // Handle the file not existing
      const cacheFilename = this.getCacheFilename(filename);
      await ___R$project$rome$$romejs$fs$index_ts$unlink(cacheFilename);
      this.loadedEntries.delete(filename);
    }

    async get(filename) {
      const emptyEntry = await this.createEmptyEntry(filename);

      // If we have a loaded memory entry, make sure it's valid compared to the default entry (file changes etc)
      let loaded = this.loadedEntries.get(filename);
      if (loaded !== undefined && ___R$$priv$project$rome$$romejs$core$master$Cache_ts$areEntriesEqual(loaded, emptyEntry)) {
        return emptyEntry;
      }

      if (this.disabled) {
        return emptyEntry;
      }

      const cacheFilename = this.getCacheFilename(filename);
      const entry = await this.checkPossibleDiskCacheEntry(
        cacheFilename,
        emptyEntry,
      );
      this.loadedEntries.set(filename, entry);
      return entry;
    }

    async checkPossibleDiskCacheEntry(cacheFilename, emptyEntry) {
      const {memoryFs} = this.master;

      if (!memoryFs.exists(cacheFilename)) {
        return emptyEntry;
      }

      try {
        const json = await ___R$project$rome$$romejs$fs$index_ts$readFileText(cacheFilename);
        const obj = JSON.parse(json);

        if (___R$$priv$project$rome$$romejs$core$master$Cache_ts$areEntriesEqual(emptyEntry, obj)) {
          return Object.assign(
            {
            },
            emptyEntry,
            obj,
          );
        } else {
          // If the entries aren't equal then there's something wrong with the cache entry
          await this.handleDeleted(cacheFilename);
          return emptyEntry;
        }
      } catch (err) {
        // TODO add some heuristic to only catch json and cache permission errors
        return emptyEntry;
      }
    }

    async update(filename, partialEntryCallback) {
      const currEntry = await this.get(filename);
      const partialEntry = typeof partialEntryCallback ===
      'function'
        ? partialEntryCallback(currEntry) : partialEntryCallback;

      const entry = Object.assign(
        {
        },
        currEntry,
        partialEntry,
      );

      // TODO should batch these and write during idle time
      const cacheFilename = this.getCacheFilename(filename);
      this.loadedEntries.set(filename, entry);

      if (this.disabled) {
        return;
      }

      await ___R$project$rome$$romejs$fs$index_ts$createDirectory(
        cacheFilename.getParent(),
        {
          recursive: true,
        },
      );
      await ___R$project$rome$$romejs$fs$index_ts$writeFile(cacheFilename, JSON.stringify(entry, null, '  '));
    }
  }

  // project-rome/@romejs/core/master/WorkerQueue.ts
class ___R$project$rome$$romejs$core$master$WorkerQueue_ts$default {
    constructor(master) {
      this.master = master;
      this.queue = [];
      this.callbacks = [];
      this.promises = [];
      this.workers = new Map();
      this.open = true;
    }

    pushQueue(filename, metadata) {
      if (!this.open) {
        throw new Error('WorkerQueue has already closed');
      }

      this.queue.push([filename, metadata]);
    }

    addCallback(callback) {
      this.callbacks.push(callback);
    }

    // Take all the root queue items, assign them to a worker, and start the worker queue if it's not running
    async updateWorkerQueues() {
      const {queue} = this;

      while (queue.length > 0) {
        const item = queue.shift();
        if (item === undefined) {
          throw new Error('Already validated queue.length above');
        }

        const path = item[0];
        const workerContainer = await this.master.fileAllocator.getOrAssignOwner(
          path,
        );

        // Populate the worker queue for this item
        let worker = this.workers.get(workerContainer);
        if (worker === undefined) {
          worker =
            {
              running: false,
              queue: [],
            };
          this.workers.set(workerContainer, worker);
        }
        worker.queue.push(item);

        // Start this worker if it isn't already
        if (worker.running === false) {
          const promise = this.processWorker(worker);
          // Add a `catch` so that we aren't considered an unhandled promise if it rejects before a handler is attached
          promise.catch(() => {});
          this.promises.push(promise);
        }
      }
    }

    async processWorker(item) {
      item.running = true;

      const {queue} = item;

      while (queue.length > 0) {
        const item = queue.shift();
        if (item === undefined) {
          throw new Error('Already validated queue.length above');
        }

        const [filename, metadata] = item;
        for (const callback of this.callbacks) {
          await callback(filename, metadata);
        }
        await this.updateWorkerQueues();
      }

      item.running = false;
    }

    async spin() {
      const {queue} = this;

      // Create the initial queue
      await this.updateWorkerQueues();

      // Keep consuming all the promises until we're exhausted
      while (this.promises.length > 0) {
        const {promises} = this;
        this.promises = [];
        await Promise.all(promises);
      }

      // Ensure we never receive anymore queue items
      this.open = false;

      // Ensure main queue has been drained
      if (queue.length > 0) {
        throw new Error('Expected no queue items to remain');
      }

      // Ensure worker queues have been drained
      for (const [worker, {queue}] of this.workers) {
        if (queue.length > 0) {
          throw (
            new Error(
              'Expected no queue items to remain for worker ' +
              worker.id,
            )
          );
        }
      }
    }
  }

  // project-rome/@romejs/core/master/dependencies/DependencyOrderer.ts
class ___R$project$rome$$romejs$core$master$dependencies$DependencyOrderer_ts$default {
    constructor(graph) {
      this.graph = graph;
      this.orderedNodes = new Set();
      this.visitedNodes = new Set();
      this.possibleCyclePaths = new Map();
      this.diagnostics = [];
      this.firstTopAwaitLocations = [];
    }

    handleAlreadyVisitedFile(node, path, ancestry) {
      const filename = path.join();

      // We flag a possible cycle when a dependency has yet to have it's own transitive dependencies resolve but it ends up going back to itself
      const isPossibleCycle = this.orderedNodes.has(node) === false &&
        ancestry.includes(filename);
      if (isPossibleCycle) {
        const ourCyclePath = ancestry.concat([filename]);
        const existingCycle = this.possibleCyclePaths.get(node);

        // We want to get the shortest cycle path since it's likely the most easily resolved
        const isShortestCycle = existingCycle === undefined ||
        existingCycle.length > ourCyclePath.length;
        if (isShortestCycle) {
          this.possibleCyclePaths.set(node, ourCyclePath);
        }
      }
    }

    addFile(path, ancestry) {
      const node = this.graph.getNode(path);

      if (this.visitedNodes.has(node)) {
        this.handleAlreadyVisitedFile(node, path, ancestry);
        return undefined;
      }

      this.visitedNodes.add(node);

      const {firstTopAwaitLocation} = node.analyze;
      if (firstTopAwaitLocation !== undefined) {
        this.firstTopAwaitLocations.push(
          {
            mtime: node.getMtime(),
            loc: firstTopAwaitLocation,
          },
        );
      }

      const subAncestry = ancestry.concat([path.join()]);
      for (const depPath of node.getAbsoluteDependencies()) {
        const dep = node.getDependencyInfoFromAbsolute(depPath).analyze;
        if (dep.kind === 'value') {
          this.addFile(depPath, subAncestry);
        }
      }

      this.orderedNodes.add(node);
    }

    // We detect cycles by determining if there were any references to imports at the top level that

    // are for a module that will be initialized before
    detectCycles() {
      const flatOrder = Array.from(this.orderedNodes);

      for (let i = 0;
      i < flatOrder.length;
      i++) {
        const node = flatOrder[i];

        for (const imp of node.analyze.importFirstUsage) {
          const resolved = node.getNodeFromRelativeDependency(imp.source).resolveImport(
            imp.imported,
            imp.loc,
          );
          if (resolved.type !== 'FOUND') {
            continue;
          }

          // Hoisted exports will always be accessible
          if (resolved.record.valueType === 'function') {
            continue;
          }

          const dep = resolved.node;

          const isBefore = flatOrder.indexOf(dep) > i;
          if (isBefore) {
            this.flagCycle(node, dep, imp);
          }
        }
      }
    }

    flagCycle(node, dep, imp) {
      const path = this.possibleCyclePaths.get(dep);
      if (!path) {
        // idk??
        return undefined;
      }

      const target = path[path.length - 1];
      const culprit = String(
        path.find(
          (value, index) => path[index - 1] === target,
        ),
      );

      function formatPart(part, index) {
        const tagged = '<filelink target="' +
        part +
        '" />';
        if (part === culprit) {
          return '<magenta>' +
          tagged +
          '</magenta><dim>[1]</dim>';
        } else if (part === target) {
          return '<cyan>' +
          tagged +
          '</cyan><dim>[2]</dim>';
        } else if (index === 0) {
          return tagged +
          ' <inverse>ENTRY</inverse>';
        } else {
          return tagged;
        }
      }

      this.diagnostics.push(
        {
          category: 'bundler/moduleCycle',
          filename: node.path.join(),
          mtime: node.getMtime(),
          start: imp.loc === undefined ? undefined : imp.loc.start,
          end: imp.loc === undefined ? undefined : imp.loc.end,
          message: 'The variable <emphasis>' +
          imp.local +
          '</emphasis> won\'t be initialized yet',
          advice: [
            {
              type: 'log',
              category: 'info',
              message: 'This is because the module it belongs to wont be executed yet. This is due to a circular dependency creating a module cycle.',
            },
            {
              type: 'log',
              category: 'info',
              message: 'The likely cause is the file ' +
              formatPart(culprit) +
              ' that was required by ' +
              formatPart(
                target,
              ) +
              ' which created a circular dependency:',
            },
            {
              type: 'list',
              reverse: true,
              ordered: true,
              list: path.map(formatPart),
            },
          ],
        },
      );
    }

    order(path) {
      this.addFile(path, []);
      // TODO only enable when bundlerMode === 'modern'

      // this.detectCycles();
      return (
        {
          firstTopAwaitLocations: this.firstTopAwaitLocations,
          diagnostics: this.diagnostics,
          files: Array.from(this.orderedNodes, (node) => node.path),
        }
      );
    }
  }

  // project-rome/@romejs/core/master/dependencies/DependencyNode.ts
function ___R$$priv$project$rome$$romejs$core$master$dependencies$DependencyNode_ts$equalKind(
    producer,
    consumerKind,
  ) {
    // Allow importing functions and classes as `type` and `typeof`
    if ((producer.valueType === 'class' || producer.valueType === 'function') &&
      (consumerKind === 'type' || consumerKind === 'typeof')) {
      return true;
    }

    // You can only import a type or a class as a type
    if (producer.kind === 'type') {
      return consumerKind === 'type';
    }

    // You can only import a value as a value or typeof
    if (producer.kind === 'value') {
      return consumerKind === 'typeof' || consumerKind === 'value';
    }

    return false;
  }

  class ___R$project$rome$$romejs$core$master$dependencies$DependencyNode_ts$default {
    constructor(graph, id, path, res) {
      this.graph = graph;

      this.project = graph.master.projectManager.assertProjectExisting(path);
      this.path = path;
      this.id = id;
      this.type = res.moduleType;

      this.usedAsync = false;
      this.all = false;
      this.relativeToAbsolutePath = new Map();
      this.absoluteToAnalyzeDependency = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();

      this.analyze = res;

      const {handler} = ___R$project$rome$$romejs$core$common$fileHandlers_ts$getFileHandler(path, this.project.config);
      this.handler = handler;
    }

    getMtime() {
      return this.graph.master.memoryFs.getMtime(this.path);
    }

    setUsedAsync(usedAsync) {
      this.usedAsync = usedAsync;
    }

    setAll(all) {
      this.all = all;
    }

    hasEscapedExports() {
      for (const exp of this.analyze.exports) {
        if (exp.type === 'local' && exp.name === '*') {
          return true;
        }
      }
      return false;
    }

    getDependents() {
      const dependents = [];
      for (const node of this.graph.nodes.values()) {
        if (node.absoluteToAnalyzeDependency.has(this.path)) {
          dependents.push(node);
        }
      }
      return dependents;
    }

    addDependency(relative, absolute, dep) {
      this.relativeToAbsolutePath.set(relative, absolute);
      this.absoluteToAnalyzeDependency.set(
        absolute,
        {
          analyze: dep,
          path: absolute,
        },
      );
    }

    getDependencyInfoFromAbsolute(path) {
      const dep = this.absoluteToAnalyzeDependency.get(path);
      if (dep === undefined) {
        throw new Error('Expected dependency');
      }
      return dep;
    }

    getNodeFromRelativeDependency(relative) {
      const absolute = this.relativeToAbsolutePath.get(relative);
      if (absolute === undefined) {
        throw new Error('Expected dependency ' +
        relative +
        ' in ' +
        this.path);
      }
      return this.graph.getNode(absolute);
    }

    getAbsoluteDependencies() {
      return Array.from(this.relativeToAbsolutePath.values());
    }

    getTransitiveDependencies() {
      let queue = [this];

      const nodes = new Set();

      while (queue.length > 0) {
        const node = queue.shift();
        if (node === undefined) {
          throw new Error('Already validated queue.length');
        }

        nodes.add(node);

        for (const absolute of node.getAbsoluteDependencies()) {
          const node = this.graph.getNode(absolute);

          if (!nodes.has(node)) {
            queue.push(node);
          }
        }
      }

      return Array.from(nodes);
    }

    getDependencyOrder() {
      const orderer = new ___R$project$rome$$romejs$core$master$dependencies$DependencyOrderer_ts$default(this.graph);
      return orderer.order(this.path);
    }

    getExportedNames(kind, seen = new Set()) {
      if (seen.has(this)) {
        return new Set();
      } else {
        seen.add(this);
      }

      let names = new Set();

      for (const exp of this.analyze.exports) {
        if (exp.type === 'local' && ___R$$priv$project$rome$$romejs$core$master$dependencies$DependencyNode_ts$equalKind(exp, kind)) {
          names.add(exp.name);
        }

        if (exp.type === 'external') {
          const resolved = this.getNodeFromRelativeDependency(exp.source).resolveImport(
            exp.imported,
            exp.loc,
          );
          if (resolved.type === 'FOUND' && ___R$$priv$project$rome$$romejs$core$master$dependencies$DependencyNode_ts$equalKind(resolved.record, kind)) {
            names.add(exp.exported);
          }
        }

        if (exp.type === 'externalAll') {
          names =
            new Set(
              [
                ...names,
                ...this.getNodeFromRelativeDependency(exp.source).getExportedNames(
                  kind,
                  seen,
                ),
              ],
            );
        }
      }

      return names;
    }

    buildDiagnosticForUnknownExport(kind, resolved) {
      const resolvedFileLink = '<filelink emphasis target="' +
      resolved.node.id +
      '" />';

      const message = 'Couldn\'t find export <emphasis>' +
      resolved.name +
      '</emphasis> in ' +
      resolvedFileLink;
      let advice = [];

      if (resolved.node.analyze.exports.length === 0) {
        advice.push(
          {
            type: 'log',
            category: 'info',
            message: 'This file doesn\'t have any exports',
          },
        );
      } else {
        // Provide suggestion on unknown import
        const exportedNames = resolved.node.getExportedNames(kind);

        advice =
          advice.concat(
            ___R$project$rome$$romejs$diagnostics$helpers_ts$buildSuggestionAdvice(
              resolved.name,
              Array.from(
                exportedNames,
              ),
              {
                formatItem: (name) => {
                  const exportInfo = resolved.node.resolveImport(name, undefined);

                  if (exportInfo.type === 'NOT_FOUND') {
                    throw (
                      new Error(
                        'mod.resolveImport returned NOT_FOUND for an export ' +
                        name +
                        ' in ' +
                        exportInfo.node.path +
                        ' despite being returned by getExportedNames',
                      )
                    );
                  }

                  const {record} = exportInfo;

                  const {loc} = record;
                  if (loc !== undefined) {
                    name =
                      '<filelink target="' +
                      loc.filename +
                      '" line="' +
                      loc.start.line +
                      '" column="' +
                      loc.start.column +
                      '">' +
                      name +
                      '</filelink>';

                    if (exportInfo.node !== resolved.node) {
                      name +=
                        ' <dim>(from <filelink target="' +
                        exportInfo.node.path.join() +
                        '" />)</dim>';
                    }
                  }

                  return name;
                },
              },
            ),
          );
      }

      return (
        Object.assign(
          {
            category: 'bundler/unknownExport',
          },
          resolved.loc,
          {
            message,
            advice,
            mtime: this.getMtime(),
          },
        )
      );
    }

    buildDiagnosticForTypeMismatch(resolved, node, nameInfo) {
      const {name, kind, loc} = nameInfo;
      const advice = [];

      const {record} = resolved;

      if (record.loc !== undefined) {
        advice.push(
          {
            type: 'log',
            category: 'info',
            message: 'Export was defined here in <filelink emphasis target="' +
            record.loc.filename +
            '" />',
          },
        );

        advice.push(
          Object.assign(
            {
              type: 'frame',
            },
            record.loc,
          ),
        );
      }

      return (
        Object.assign(
          {
            category: 'bundler/importTypeMismatch',
          },
          loc,
          {
            message: 'The export <emphasis>' +
            name +
            '</emphasis> in <filelink emphasis target="' +
            node.id +
            '" /> was incorrectly imported as a <emphasis>' +
            kind +
            '</emphasis> when it\'s actually a <emphasis>' +
            record.kind +
            '</emphasis>',
            advice,
            mtime: this.getMtime(),
          },
        )
      );
    }

    resolveImports() {
      const {graph} = this;
      const deps = this.relativeToAbsolutePath;

      // Build up a map of any forwarded imports
      const resolvedImports = {};

      // Diagnostics for unknown imports
      const diagnostics = [];

      // Go through all of our dependencies and check if they have any external exports to forward
      const allowTypeImportsAsValue = this.analyze.syntax.includes('ts');
      for (const absolute of deps.values()) {
        const mod = graph.getNode(absolute);

        // We can't follow CJS names
        if (mod.type === 'cjs') {
          continue;
        }

        const usedNames = this.getDependencyInfoFromAbsolute(absolute).analyze.names;

        // Try to resolve these exports
        for (const nameInfo of usedNames) {
          const {name, kind, loc} = nameInfo;
          if (kind === 'type' || kind === 'typeof') {
            // Disable resolving typed imports for now as there's ridiculous code that hides some behind $FlowFixMe
            continue;
          }

          const resolved = mod.resolveImport(name, loc);

          // Unknown import
          if (resolved.type === 'NOT_FOUND') {
            diagnostics.push(this.buildDiagnosticForUnknownExport(kind, resolved));
            continue;
          }

          // Flag imports of the wrong type
          if (!allowTypeImportsAsValue && !___R$$priv$project$rome$$romejs$core$master$dependencies$DependencyNode_ts$equalKind(resolved.record, kind)) {
            diagnostics.push(
              this.buildDiagnosticForTypeMismatch(
                resolved,
                mod,
                nameInfo,
              ),
            );
            continue;
          }

          // If the resolved target isn't the same as the file then forward it
          if (resolved.node.id !== mod.id) {
            resolvedImports[mod.id +
            ':' +
            name] =
              {
                id: resolved.node.id,
                name: resolved.record.name,
              };
          }
        }
      }

      return (
        {
          resolved: resolvedImports,
          diagnostics,
        }
      );
    }

    resolveImport(name, loc, ignoreDefault = false, ancestry = []) {
      if (ancestry.includes(this)) {
        return (
          {
            type: 'NOT_FOUND',
            loc,
            node: this,
            name,
          }
        );
      }

      const subAncestry = [...ancestry, this];

      // We always want to resolve exports from the bottom up
      const exports = this.analyze.exports.reverse();

      for (const record of exports) {
        // When resolving exportAll we never want to include the default export of those modules
        if (record.type === 'local' && record.name === 'default' && ignoreDefault) {
          continue;
        }

        if (record.type === 'local' &&
          (record.name === name || record.name === '*')) {
          return (
            {
              type: 'FOUND',
              node: this,
              record,
            }
          );
        }

        if (record.type === 'external' && record.exported === name) {
          return (
            this.getNodeFromRelativeDependency(record.source).resolveImport(
              record.imported,
              record.loc,
              false,
              subAncestry,
            )
          );
        }

        if (record.type === 'externalAll') {
          const resolved = this.getNodeFromRelativeDependency(record.source).resolveImport(
            name,
            record.loc,
            true,
            subAncestry,
          );

          if (resolved.type === 'FOUND') {
            return resolved;
          }
        }
      }

      return (
        {
          type: 'NOT_FOUND',
          loc,
          node: this,
          name,
        }
      );
    }
  }

  // project-rome/@romejs/core/master/dependencies/DependencyGraph.ts
const ___R$$priv$project$rome$$romejs$core$master$dependencies$DependencyGraph_ts$BUILTINS = [
    'electron',
    'buffer',
    'child_process',
    'crypto',
    'dgram',
    'dns',
    'fs',
    'http',
    'https',
    'net',
    'os',
    'readline',
    'stream',
    'string_decoder',
    'tls',
    'tty',
    'zlib',
    'constants',
    'events',
    'url',
    'assert',
    'util',
    'path',
    'punycode',
    'querystring',
    'cluster',
    'console',
    'module',
    'process',
    'vm',
    'domain',
    'v8',
    'repl',
    'timers',
    'inspector',
  ];

  class ___R$project$rome$$romejs$core$master$dependencies$DependencyGraph_ts$default {
    constructor(request, resolverOpts) {
      this.request = request;
      this.master = request.master;
      this.nodes = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
      this.resolverOpts = resolverOpts;

      this.locker = new ___R$project$rome$$romejs$core$common$utils$Locker_ts$default();
      this.closeEvent = new ___R$project$rome$$romejs$events$Event_ts$default({name: 'DependencyGraph.closeEvent'});
    }

    watch(callback) {
      const watchSubscription = this.master.fileChangeEvent.subscribe(
        async (path) => {
          if (this.nodes.has(path)) {
            this.nodes.delete(path);
          } else {
            return;
          }

          const diagnosticsProcessor = new ___R$project$rome$$romejs$diagnostics$DiagnosticsProcessor_ts$default({origins: []});
          await this.seed({paths: [path], diagnosticsProcessor});
          diagnosticsProcessor.maybeThrowDiagnosticsError();

          if (callback !== undefined) {
            callback({path});
          }
        },
      );

      this.closeEvent.subscribe(
        () => {
          watchSubscription.unsubscribe();
        },
      );
    }

    close() {
      this.closeEvent.send();
    }

    isExternal(source) {
      return ___R$$priv$project$rome$$romejs$core$master$dependencies$DependencyGraph_ts$BUILTINS.includes(source);
    }

    getBundleBuddyStats(entries) {
      const stats = [];

      for (const node of this.nodes.values()) {
        const source = node.id;

        for (const absoluteTarget of node.relativeToAbsolutePath.values()) {
          const target = this.getNode(absoluteTarget).id;
          stats.push(
            {
              target,
              source,
            },
          );
        }
      }

      for (const absoluteEntry of entries) {
        const source = this.getNode(absoluteEntry).id;
        stats.push(
          {
            source,
            target: undefined,
          },
        );
      }

      return stats;
    }

    addNode(filename, res) {
      const module = new ___R$project$rome$$romejs$core$master$dependencies$DependencyNode_ts$default(
        this,
        this.master.projectManager.getUid(
          filename,
        ),
        filename,
        res,
      );
      this.nodes.set(filename, module);
      return module;
    }

    getNode(path) {
      const mod = this.nodes.get(path);
      if (mod === undefined) {
        throw new Error('No module found for ' +
        path.join());
      }
      return mod;
    }

    async seed({
      paths,
      diagnosticsProcessor,
      analyzeProgress,
      validate = false,
    }) {
      const workerQueue = new ___R$project$rome$$romejs$core$master$WorkerQueue_ts$default(this.master);

      workerQueue.addCallback(
        async (path, item) => {
          await this.resolve(
            path,
            {
              workerQueue,
              all: item.all,
              async: item.async,
              ancestry: item.ancestry,
            },
            diagnosticsProcessor,
            analyzeProgress,
          );
        },
      );

      // Add initial queue items
      const roots = await Promise.all(
        paths.map(
          (
            path,
          ) =>
            this.resolve(
              path,
              {
                workerQueue,
                all: true,
                async: false,
                ancestry: [],
              },
              diagnosticsProcessor,
              analyzeProgress,
            ),
        ),
      );

      await workerQueue.spin();

      if (diagnosticsProcessor.hasDiagnostics()) {
        return;
      }

      if (validate) {
        for (const root of roots) {
          this.validateTransitive(root, diagnosticsProcessor);
        }
      }
    }

    validate(node, diagnosticsProcessor) {
      const resolvedImports = node.resolveImports();
      diagnosticsProcessor.addDiagnostics(resolvedImports.diagnostics);
    }

    validateTransitive(node, diagnosticsProcessor) {
      const order = node.getDependencyOrder();
      diagnosticsProcessor.addDiagnostics(order.diagnostics);

      for (const path of order.files) {
        this.validate(this.getNode(path), diagnosticsProcessor);
      }
    }

    async resolve(path, opts, diagnosticsProcessor, analyzeProgress) {
      const filename = path.join();
      const {async, all, ancestry} = opts;
      const {master} = this;

      // We have a lock here in case we hit `this.resolve` while we're waiting for the `analyzeDependencies` result
      const lock = await this.locker.getLock(filename);

      if (this.nodes.has(path)) {
        const node = this.getNode(path);

        if (all) {
          node.setAll(true);
        }

        if (async) {
          node.setUsedAsync(true);
        }

        lock.release();

        return node;
      }

      const progressText = '<filelink target="' +
      filename +
      '" />';

      if (analyzeProgress !== undefined) {
        analyzeProgress.pushText(progressText);
      }

      const res = await this.request.requestWorkerAnalyzeDependencies(path);

      const node = this.addNode(path, res);
      node.setAll(all);
      node.setUsedAsync(async);
      lock.release();

      const {dependencies, diagnostics} = res;

      if (diagnostics.length > 0) {
        diagnosticsProcessor.addDiagnostics(diagnostics);
      }

      // If we're a remote path then the origin should be the URL and not our local path
      const remote = this.master.projectManager.getRemoteFromLocalPath(path);
      const origin = remote === undefined ? path : remote.getParent();

      // Resolve full locations
      await Promise.all(
        dependencies.map(
          async (dep) => {
            const {source, optional} = dep;
            if (this.isExternal(source)) {
              return;
            }

            const {diagnostics} = await ___R$project$rome$$romejs$diagnostics$wrap_ts$catchDiagnostics(
              {
                category: 'DependencyGraph',
                message: 'Caught by resolve',
              },
              async () => {
                const resolved = await master.resolver.resolveAssert(
                  Object.assign(
                    {
                    },
                    this.resolverOpts,
                    {
                      origin,
                      source: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(source),
                    },
                  ),
                  dep.loc === undefined
                    ? undefined : {
                      pointer: Object.assign(
                        {
                          sourceText: undefined,
                        },
                        dep.loc,
                        {
                          language: 'js',
                          mtime: undefined,
                        },
                      ),
                    },
                );

                node.addDependency(source, resolved.path, dep);
              },
            );

            if (diagnostics !== undefined && !optional) {
              diagnosticsProcessor.addDiagnostics(diagnostics);
            }
          },
        ),
      );

      // Queue our dependencies...
      const subAncestry = [...ancestry, filename];
      for (const path of node.getAbsoluteDependencies()) {
        const dep = node.getDependencyInfoFromAbsolute(path).analyze;
        opts.workerQueue.pushQueue(
          path,
          {
            all: dep.all,
            async: dep.async,
            type: dep.type,
            loc: dep.loc,
            ancestry: subAncestry,
          },
        );
      }

      if (analyzeProgress !== undefined) {
        analyzeProgress.popText(progressText);
        analyzeProgress.tick();
      }

      return node;
    }
  }

  // project-rome/@romejs/core/master/bundler/BundleRequest.ts
const ___R$$priv$project$rome$$romejs$core$master$bundler$BundleRequest_ts$crypto = require(
    'crypto',
  );

  class ___R$project$rome$$romejs$core$master$bundler$BundleRequest_ts$default {
    constructor({
      bundler,
      reporter,
      mode,
      resolvedEntry,
      options,
    }) {
      this.reporter = reporter;
      this.interpreter = options.interpreter;
      this.bundler = bundler;
      this.cached = true;
      this.mode = mode;

      this.resolvedEntry = resolvedEntry;
      this.resolvedEntryUid = bundler.master.projectManager.getUid(resolvedEntry);

      this.diagnostics =
        new ___R$project$rome$$romejs$diagnostics$DiagnosticsProcessor_ts$default(
          {
            origins: [
              {
                category: 'bundler',
                message: 'Requested bundle for <filelink target="' +
                this.resolvedEntryUid +
                '" />',
              },
            ],
          },
        );
      this.diagnostics.addAllowedUnusedSuppressionPrefix('lint');

      this.compiles = new Map();
      this.assets = new Map();

      this.sourceMap =
        new ___R$project$rome$$romejs$codec$source$map$SourceMapGenerator_ts$default(
          {
            file: 'TODO-something',
          },
        );
    }

    async stepAnalyze() {
      const {graph} = this.bundler;
      const {reporter} = this;

      const analyzeProgress = reporter.progress(
        {
          name: 'bundler:analyze:' +
          this.resolvedEntryUid,
        },
      );
      analyzeProgress.setTitle('Analyzing');
      this.diagnostics.setThrowAfter(100);
      try {
        await graph.seed(
          {
            paths: [this.resolvedEntry],
            diagnosticsProcessor: this.diagnostics,
            analyzeProgress,
          },
        );
      } finally {
        analyzeProgress.end();
      }

      return this.bundler.graph.getNode(this.resolvedEntry).getDependencyOrder();
    }

    async stepCompile(paths) {
      const {master} = this.bundler;
      const {reporter} = this;
      this.diagnostics.setThrowAfter(undefined);

      const compilingSpinner = reporter.progress(
        {
          name: 'bundler:compile:' +
          this.resolvedEntryUid,
        },
      );
      compilingSpinner.setTotal(paths.length);
      compilingSpinner.setTitle('Compiling');

      const groupedPaths = await master.fileAllocator.groupPathsByWorker(paths);
      await Promise.all(
        groupedPaths.map(
          async (paths) => {
            for (const path of paths) {
              const progressText = '<filelink target="' +
              path.join() +
              '" />';
              compilingSpinner.pushText(progressText);
              await this.compileJS(path);
              compilingSpinner.tick();
              compilingSpinner.popText(progressText);
            }
          },
        ),
      );
      compilingSpinner.end();
    }

    async compileJS(path) {
      const {graph} = this.bundler;

      const source = path.join();
      const mod = graph.getNode(path);

      // Build a map of relative module sources to module id
      const relativeSourcesToModuleId = {};
      for (const [relative, absolute] of mod.relativeToAbsolutePath) {
        const moduleId = graph.getNode(absolute).id;
        relativeSourcesToModuleId[relative] = moduleId;
      }

      // Diagnostics would have already been added during the initial DependencyGraph.seed

      // We're doing the work of resolving everything again, maybe we should cache it?
      const resolvedImports = mod.resolveImports().resolved;

      let assetPath;
      if (mod.handler !== undefined && mod.handler.isAsset) {
        const buffer = await ___R$project$rome$$romejs$fs$index_ts$readFile(mod.path);

        // Asset path in the form of: BASENAME-SHA1HASH.EXTENSIONS
        const hash = ___R$$priv$project$rome$$romejs$core$master$bundler$BundleRequest_ts$crypto.createHash('sha1').update(buffer).digest('hex');
        const basename = mod.path.getExtensionlessBasename();
        const exts = mod.path.getExtensions();

        assetPath = basename +
        '-' +
        hash +
        exts;
        this.assets.set(assetPath, buffer);
      }

      const opts = {
        mode: this.mode,
        moduleAll: mod.all,
        moduleId: mod.id,
        relativeSourcesToModuleId,
        resolvedImports,
        assetPath,
      };

      const res = await this.bundler.request.requestWorkerCompile(
        path,
        'compileForBundle',
        {
          bundle: opts,
        },
      );

      if (!res.cached) {
        this.cached = false;
      }

      this.diagnostics.addSuppressions(res.suppressions);
      this.diagnostics.addDiagnostics(res.diagnostics);

      this.compiles.set(source, res);
      return res;
    }

    async stepCombine(order) {
      const {files} = order;
      const {inlineSourceMap} = this.bundler.config;
      const {graph} = this.bundler;
      const {resolvedEntry, mode, sourceMap} = this;

      let content = '';
      let lineOffset = 0;

      function push(str) {
        str += '\n';
        content += str;
        for (let cha of str) {
          if (cha === '\n') {
            lineOffset++;
          }
        }
      }

      function addMappings(
        filename,
        sourceContent,
        mappings,
      ) {
        return;
        sourceMap.setSourceContent(filename, sourceContent);
        for (const mapping of mappings) {
          sourceMap.addMapping(
            Object.assign(
              {
              },
              mapping,
              {
                generated: Object.assign(
                  {
                  },
                  mapping.generated,
                  {
                    line: ___R$project$rome$$romejs$ob1$index_ts$add(lineOffset, mapping.generated.line),
                  },
                ),
              },
            ),
          );
        }
      }

      const {interpreter} = this;
      if (interpreter !== undefined) {
        push('#!' +
        interpreter +
        '\n');
      }

      // add on bootstrap
      if (order.firstTopAwaitLocations.length > 0) {
        if (mode === 'legacy') {
          for (const {loc, mtime} of order.firstTopAwaitLocations) {
            this.diagnostics.addDiagnostic(
              {
                category: 'bundler/topLevelAwait',
                filename: loc.filename,
                start: loc.start,
                end: loc.end,
                message: 'This module contains a top level await which isn\'t supported in wrapper mode',
                mtime,
              },
            );
          }
        }

        push('(async function(global) {');
      } else {
        push('(function(global) {');
      }

      if (mode === 'modern') {
        push('  \'use strict\';');
      }

      // TODO prelude

      /*
    const path = createAbsoluteFilePath(loc);
    const res = await this.bundler.request.requestWorkerCompile(
      path,
      'compile',
    );
    push('(function() {');
    addMappings(
      this.bundler.master.projectManager.getUid(path),
      res.src,
      res.mappings,
    );
    push(res.code);
    push('})();');
    */
      const declaredCJS = new Set();
      function declareCJS(module) {
        if (mode !== 'modern' || module.type !== 'cjs' || declaredCJS.has(module)) {
          return;
        }

        declaredCJS.add(module);

        push('  var ' +
        ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(module.id) +
        ' = {};');
      }

      // Add on files
      for (const source of files) {
        const module = graph.getNode(source);

        for (const path of module.getAbsoluteDependencies()) {
          declareCJS(graph.getNode(path));
        }

        const compileResult = this.compiles.get(source.join());
        if (compileResult === undefined) {
          continue;
          throw new Error('Expected compile result');
        }

        // Only do this in modern mode, the module id will already be in the wrapper otherwise
        if (mode === 'modern') {
          push('  // ' +
          module.id);
        }

        declareCJS(module);

        addMappings(module.id, compileResult.sourceText, compileResult.mappings);
        push(compileResult.compiledCode);
        push('');
      }

      // push on initial entry require
      const entryModule = graph.getNode(resolvedEntry);
      if (mode === 'modern') {
        push('  return ' +
        ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(entryModule.id) +
        ';');
      } else {
        push('  return Rome.requireNamespace("' +
        entryModule.id +
        '");');
      }

      // push footer
      push(
        '})(typeof global !== \'undefined\' ? global : typeof window !== \'undefined\' ? window : this);',
      );

      //
      if (inlineSourceMap === true) {
        const sourceMapComment = sourceMap.toComment();
        content += sourceMapComment;
      }

      return (
        {
          diagnostics: this.diagnostics.getPartialDiagnostics(),
          content,
          map: sourceMap.toJSON(),
          cached: this.cached,
          assets: this.assets,
        }
      );
    }

    shouldAbort() {
      return this.diagnostics.hasDiagnostics();
    }

    abort() {
      return (
        {
          map: this.sourceMap.toJSON(),
          content: '',
          diagnostics: this.diagnostics.getPartialDiagnostics(),
          cached: false,
          assets: this.assets,
        }
      );
    }

    async bundle() {
      const order = await this.stepAnalyze();
      if (this.shouldAbort()) {
        return this.abort();
      }

      // Compile
      await this.stepCompile(order.files);
      if (this.shouldAbort()) {
        return this.abort();
      }

      // Combine
      return await this.stepCombine(order);
    }
  }

  // project-rome/@romejs/core/master/bundler/Bundler.ts
class ___R$project$rome$$romejs$core$master$bundler$Bundler_ts$default {
    constructor(req, config) {
      this.config = config;
      this.master = req.master;
      this.reporter = req.reporter;
      this.request = req;

      this.entries = [];

      this.graph = new ___R$project$rome$$romejs$core$master$dependencies$DependencyGraph_ts$default(req, config.resolver);
    }

    static createFromMasterRequest(req) {
      return new ___R$project$rome$$romejs$core$master$bundler$Bundler_ts$default(req, req.getBundlerConfigFromFlags());
    }

    async getResolvedEntry(unresolvedEntry) {
      const {cwd} = this.config;

      const res = await this.master.resolver.resolveEntryAssert(
        Object.assign(
          {
          },
          this.config.resolver,
          {
            origin: cwd,
            source: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(unresolvedEntry),
          },
        ),
      );

      const {master} = this;
      const resolvedEntry = res.path;

      // Now do the same resolver request but with a package
      const manifestRootResolved = master.resolver.resolveLocal(
        Object.assign(
          {
          },
          this.config.resolver,
          {
            origin: cwd,
            requestedType: 'package',
            source: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(unresolvedEntry),
          },
        ),
      );
      const manifestRoot = manifestRootResolved.type === 'FOUND'
        ? manifestRootResolved.path : undefined;
      let manifestDef;
      if (manifestRoot !== undefined) {
        const def = master.memoryFs.getManifestDefinition(manifestRoot);
        if (def !== undefined) {
          manifestDef = def;
        }
      }

      return {manifestDef, resolvedEntry};
    }

    createBundleRequest(resolvedEntry, options, reporter) {
      const project = this.master.projectManager.assertProjectExisting(
        resolvedEntry,
      );
      const mode = project.config.bundler.mode;

      this.entries.push(resolvedEntry);
      return (
        new ___R$project$rome$$romejs$core$master$bundler$BundleRequest_ts$default(
          {
            bundler: this,
            mode,
            resolvedEntry,
            options,
            reporter,
          },
        )
      );
    }

    async compile(path) {
      const bundleRequest = this.createBundleRequest(path, {}, this.reporter);
      await bundleRequest.stepAnalyze();
      bundleRequest.diagnostics.maybeThrowDiagnosticsError();
      return await bundleRequest.compileJS(path);
    }

    // This will take multiple entry points and do some magic to make them more efficient to build in parallel
    async bundleMultiple(entries) {
      // Clone so we can mess with it
      entries = [...entries];

      // Seed the dependency graph with all the entries at the same time
      const processor = new ___R$project$rome$$romejs$diagnostics$DiagnosticsProcessor_ts$default(
        {
          origins: [
            {
              category: 'Bundler',
              message: 'Analyzing dependencies for bundleMultiple',
            },
          ],
        },
      );
      const entryUids = entries.map(
        (
          entry,
        ) =>
          this.master.projectManager.getUid(entry),
      );
      const analyzeProgress = this.reporter.progress(
        {
          name: 'bundler:analyze:' +
          entryUids.join(','),
        },
      );
      analyzeProgress.setTitle('Analyzing');
      processor.setThrowAfter(100);
      await this.graph.seed(
        {
          paths: entries,
          diagnosticsProcessor: processor,
          analyzeProgress,
          validate: false,
        },
      );
      analyzeProgress.end();
      processor.maybeThrowDiagnosticsError();

      // Now actually bundle them
      const map = new Map();

      const progress = this.reporter.progress();
      progress.setTitle('Bundling');
      progress.setTotal(entries.length);

      const silentReporter = this.reporter.fork(
        {
          silent: true,
        },
      );

      const promises = new Set();

      // Could maybe do some of this in parallel?
      while (entries.length > 0) {
        const entry = entries.shift();
        if (entry === undefined) {
          throw new Error('Impossible. We just checked.');
        }

        const promise = (async () => {
          const text = '<filelink target="' +
          entry.join() +
          '" />';
          progress.pushText(text);
          map.set(entry, await this.bundle(entry, {}, silentReporter));
          progress.popText(text);
          progress.tick();
        })();
        promise.then(
          () => {
            promises.delete(promise);
          },
        );
        promises.add(promise);

        if (promises.size > 5) {
          await Promise.race(Array.from(promises));
        }
      }

      await Promise.all(Array.from(promises));

      progress.end();

      return map;
    }

    async bundleManifest({resolvedEntry, manifestDef}) {
      let bundles = [];
      const files = new Map();

      const createBundle = async (
        resolvedSegment,
        options,
      ) => {
        const bundle = await this.bundle(resolvedSegment, options);
        for (const [path, content] of bundle.files) {
          files.set(path, content);
        }
        bundles = bundles.concat(bundle.bundles);
        return bundle.entry;
      };

      const entryBundle = await createBundle(resolvedEntry, {});

      //
      const bundleBuddyStats = this.graph.getBundleBuddyStats(this.entries);
      files.set(
        'bundlebuddy.json',
        {
          kind: 'stats',
          content: JSON.stringify(bundleBuddyStats, null, '  '),
        },
      );

      // TODO ensure that __dirname is relative to the project root
      if (manifestDef !== undefined) {
        const newManifest = await this.deriveManifest(
          manifestDef,
          entryBundle,
          createBundle,
          (relative, buffer) => {
            if (!files.has(relative)) {
              files.set(
                relative,
                {
                  kind: 'file',
                  content: buffer,
                },
              );
            }
          },
        );

        // Add a package.json with updated values
        files.set(
          'package.json',
          {
            kind: 'manifest',
            content: JSON.stringify(newManifest, undefined, '  '),
          },
        );
      }

      return (
        {
          files,
          bundles,
          entry: entryBundle,
        }
      );
    }

    async deriveManifest(manifestDef, entryBundle, createBundle, addFile) {
      // TODO figure out some way to use bundleMultiple here
      const manifest = manifestDef.manifest;

      const newManifest = Object.assign(
        {
        },
        ___R$project$rome$$romejs$codec$js$manifest$convert_ts$convertManifestToJSON(manifest),
        {
          main: entryBundle.js.path,
        },
      );

      // TODO inherit some manifest properties from project configs
      const project = this.master.projectManager.findProjectExisting(
        manifestDef.folder,
      );
      if (project !== undefined) {
        if (newManifest.name === undefined) {
          newManifest.name = project.config.name;
        }
      }

      // TODO remove dependencies fields, probably?

      // TODO Compile a index.d.ts

      // Copy manifest.files
      if (manifest.files !== undefined) {
        const paths = await this.master.memoryFs.glob(
          manifestDef.folder,
          {
            overrideIgnore: ___R$project$rome$$romejs$path$match$index_ts$flipPathPatterns(manifest.files),
          },
        );

        for (const path of paths) {
          const relative = manifestDef.folder.relative(path).join();
          const buffer = await ___R$project$rome$$romejs$fs$index_ts$readFile(path);
          addFile(relative, buffer);
        }
      }

      // Compile manifest.bin files
      const bin = manifest.bin;
      if (bin !== undefined) {
        const newBin = {};
        newManifest.bin = newBin;

        const binConsumer = manifestDef.consumer.get('bin');
        const isBinShorthand = typeof binConsumer.asUnknown() === 'string';

        for (const [binName, relative] of manifest.bin) {
          const pointer = (isBinShorthand ? binConsumer : binConsumer.get(binName)).getDiagnosticPointer(
            'inner-value',
          );

          const absolute = await this.master.resolver.resolveAssert(
            Object.assign(
              {
              },
              this.config.resolver,
              {
                origin: manifestDef.folder,
                source: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(relative).toExplicitRelative(),
              },
            ),
            {
              pointer,
            },
          );

          const res = await createBundle(
            absolute.path,
            {
              prefix: 'bin/' +
              binName,
              interpreter: '/usr/bin/env node',
            },
          );
          newBin[binName] = res.js.path;
        }
      }

      // TODO `{type: "module"}` will always fail since we've produced CJS bundles
      delete newManifest.type;

      return newManifest;
    }

    async bundle(resolvedEntry, options = {}, reporter = this.reporter) {
      reporter.info(
        'Bundling <filelink emphasis target="' +
        resolvedEntry.join() +
        '" />',
      );

      const req = this.createBundleRequest(resolvedEntry, options, reporter);
      const res = await req.bundle();

      const processor = new ___R$project$rome$$romejs$diagnostics$DiagnosticsProcessor_ts$default({origins: []});
      processor.addDiagnostics(res.diagnostics);
      processor.maybeThrowDiagnosticsError();

      if (res.cached) {
        reporter.warn('Bundle was built completely from cache');
      }

      const serialMap = JSON.stringify(res.map);

      const prefix = options.prefix === undefined ? '' : options.prefix +
      '/';
      const jsPath = prefix +
      'index.js';
      const mapPath = jsPath +
      '.map';

      const files = new Map();
      files.set(
        jsPath,
        {
          kind: 'entry',
          content: res.content,
        },
      );
      files.set(
        mapPath,
        {
          kind: 'sourcemap',
          content: serialMap,
        },
      );

      for (const [relative, buffer] of res.assets) {
        files.set(
          relative,
          {
            kind: 'asset',
            content: buffer,
          },
        );
      }

      const bundle = {
        js: {
          path: jsPath,
          content: res.content,
        },
        sourceMap: {
          path: mapPath,
          map: res.map,
          content: serialMap,
        },
      };
      return (
        {
          entry: bundle,
          bundles: [bundle],
          files,
        }
      );
    }
  }

  // project-rome/@romejs/core/master/commands/run.ts
const ___R$project$rome$$romejs$core$master$commands$run_ts$default = ___R$project$rome$$romejs$core$commands_ts$createMasterCommand(
    {
      category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.PROJECT_MANAGEMENT,
      description: 'TODO',

      async default(req) {
        const {args} = req.query;
        const {flags} = req.client;
        const {master} = req;
        req.expectArgumentLength(1);

        async function executeCode(path) {
          const bundler = ___R$project$rome$$romejs$core$master$bundler$Bundler_ts$default.createFromMasterRequest(req);
          const {entry} = await bundler.bundle(path);
          return (
            {
              type: 'executeCode',
              filename: path.join(),
              code: entry.js.content,
              map: entry.sourceMap.map,
            }
          );
        }

        // Get the current project
        const project = await master.projectManager.findProject(flags.cwd);

        // check for absolute paths
        const target = args[0];
        const resolved = await master.resolver.resolveEntry(
          Object.assign(
            {
            },
            req.getResolverOptionsFromFlags(),
            {
              source: ___R$project$rome$$romejs$path$index_ts$createRelativeFilePath(target),
            },
          ),
        );
        if (resolved.type === 'FOUND') {
          return executeCode(resolved.path);
        }

        // check for bin files in any manifests that belong to any projects
        if (project !== undefined) {
          for (const {manifest, folder} of project.packages.values()) {
            const relative = manifest.bin.get(target);
            if (relative === undefined) {
              continue;
            }

            const resolved = await master.resolver.resolveEntryAssertPath(
              Object.assign(
                {
                },
                req.getResolverOptionsFromFlags(),
                {
                  origin: folder,
                  platform: 'node',
                  source: ___R$project$rome$$romejs$path$index_ts$createRelativeFilePath(relative),
                },
              ),
            );

            return executeCode(resolved);
          }
        }

        // TODO check node_modules/.bin

        // TODO check package.json scripts
        throw new Error('Failed to find "' +
        target +
        '"');
      },
    },
  );

  // project-rome/@romejs/core/master/commands/publish.ts
const ___R$project$rome$$romejs$core$master$commands$publish_ts$default = ___R$project$rome$$romejs$core$commands_ts$createMasterCommand(
    {
      category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.PROJECT_MANAGEMENT,
      description: 'TODO',

      async default(req) {
        req.expectArgumentLength(1);

        // TODO
      },
    },
  );

  // project-rome/@romejs/core/master/commands/status.ts
const ___R$project$rome$$romejs$core$master$commands$status_ts$default = ___R$project$rome$$romejs$core$commands_ts$createMasterCommand(
    {
      category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.PROCESS_MANAGEMENT,
      description: 'dump memory and process info of master and workers',

      async default({master}) {
        const workers = await Promise.all(
          master.workerManager.getWorkers().map(
            async (worker) => {
              const workerStatus = await worker.bridge.status.call();

              return (
                {
                  astCacheSize: workerStatus.astCacheSize,
                  heapTotal: workerStatus.memoryUsage.heapTotal,
                  pid: workerStatus.pid,
                  uptime: workerStatus.uptime,
                  ownedBytes: worker.byteCount,
                  ownedFileCount: worker.fileCount,
                }
              );
            },
          ),
        );

        const {heapTotal} = process.memoryUsage();
        return (
          {
            master: {
              heapTotal,
              pid: process.pid,
              uptime: process.uptime(),
            },
            workers,
            projects: master.projectManager.getProjects().map(
              (project) => {
                return (
                  {
                    id: project.id,
                  }
                );
              },
            ),
          }
        );
      },
    },
  );

  // project-rome/@romejs/core/master/commands/stop.ts
const ___R$project$rome$$romejs$core$master$commands$stop_ts$default = ___R$project$rome$$romejs$core$commands_ts$createMasterCommand(
    {
      category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.PROCESS_MANAGEMENT,
      description: 'stop daemon',

      async default({master}) {
        master.end();
      },
    },
  );

  // project-rome/@romejs/codec-websocket/types.ts
const ___R$project$rome$$romejs$codec$websocket$types_ts$OPCODES = {
    CONTINUATION: 0,
    TEXT: 1,
    BINARY: 2,
    TERMINATE: 8,
    PING: 9,
    PONG: 10,
  };

  const ___R$project$rome$$romejs$codec$websocket$types_ts$GUID = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';

  // project-rome/@romejs/codec-websocket/frame.ts
const ___R$$priv$project$rome$$romejs$codec$websocket$frame_ts$crypto = require(
    'crypto',
  );
  function ___R$project$rome$$romejs$codec$websocket$frame_ts$isCompleteFrame(frame) {
    return Buffer.byteLength(frame.payload) >= frame.payloadLength;
  }

  function ___R$project$rome$$romejs$codec$websocket$frame_ts$unmaskPayload(
    payload,
    mask,
    offset,
  ) {
    if (mask === undefined) {
      return payload;
    }

    for (let i = 0;
    i < payload.length;
    i++) {
      payload[i] ^= mask[offset + i & 3];
    }

    return payload;
  }

  function ___R$project$rome$$romejs$codec$websocket$frame_ts$buildFrame(opts, shouldMask) {
    const {opcode, fin, data} = opts;

    let offset = shouldMask ? 6 : 2;
    let dataLength = data.length;

    if (dataLength >= 65536) {
      offset += 8;
      dataLength = 127;
    } else if (dataLength > 125) {
      offset += 2;
      dataLength = 126;
    }

    const head = Buffer.allocUnsafe(offset);

    head[0] = fin ? opcode | 128 : opcode;
    head[1] = dataLength;

    if (dataLength === 126) {
      head.writeUInt16BE(data.length, 2);
    } else if (dataLength === 127) {
      head.writeUInt32BE(0, 2);
      head.writeUInt32BE(data.length, 6);
    }

    if (shouldMask) {
      const mask = ___R$$priv$project$rome$$romejs$codec$websocket$frame_ts$crypto.randomBytes(4);
      head[1] |= 128;
      head[offset - 4] = mask[0];
      head[offset - 3] = mask[1];
      head[offset - 2] = mask[2];
      head[offset - 1] = mask[3];

      const masked = Buffer.alloc(dataLength);
      for (let i = 0;
      i < dataLength;
      ++i) {
        masked[i] = data[i] ^ mask[i & 3];
      }

      return Buffer.concat([head, masked]);
    } else {
      return Buffer.concat([head, data]);
    }
  }

  function ___R$project$rome$$romejs$codec$websocket$frame_ts$parseFrame(buffer) {
    const firstByte = buffer.readUInt8(0);
    const isFinalFrame = Boolean(firstByte >>> 7 & 1);
    const opcode = firstByte & 15;

    const [reserved1, reserved2, reserved3] = [
      (firstByte >>> 6 & 1) === 1,
      (firstByte >>> 5 & 1) === 1,
      (firstByte >>> 4 & 1) === 1,
    ];
    reserved1;
    reserved2;
    reserved3;

    const secondByte = buffer.readUInt8(1);
    const isMasked = Boolean(secondByte >>> 7 & 1);

    // Keep track of our current position as we advance through the buffer
    let currentOffset = 2;
    let payloadLength = secondByte & 127;
    if (payloadLength > 125) {
      if (payloadLength === 126) {
        payloadLength = buffer.readUInt16BE(currentOffset);
        currentOffset += 2;
      } else if (payloadLength === 127) {
        const leftPart = buffer.readUInt32BE(currentOffset);
        currentOffset += 4;

        // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned

        // if payload length is greater than this number.
        if (leftPart >= Number.MAX_SAFE_INTEGER) {
          throw new Error('Unsupported WebSocket frame: payload length > 2^53 - 1');
        }

        const rightPart = buffer.readUInt32BE(currentOffset);
        currentOffset += 4;

        payloadLength = leftPart * Math.pow(2, 32) + rightPart;
      } else {
        throw new Error('Unknown payload length');
      }
    }

    // Get the masking key if one exists
    let mask;
    if (isMasked) {
      mask = buffer.slice(currentOffset, currentOffset + 4);
      currentOffset += 4;
    }

    let payload = ___R$project$rome$$romejs$codec$websocket$frame_ts$unmaskPayload(buffer.slice(currentOffset), mask, 0);

    return (
      {
        fin: isFinalFrame,
        opcode,
        mask,
        payload,
        payloadLength,
      }
    );
  }

  // project-rome/@romejs/codec-websocket/index.ts
const ___R$$priv$project$rome$$romejs$codec$websocket$index_ts$crypto = require(
    'crypto',
  );
  const ___R$$priv$project$rome$$romejs$codec$websocket$index_ts$url = require(
    'url',
  );
  const ___R$$priv$project$rome$$romejs$codec$websocket$index_ts$http = require(
    'http',
  );
  const ___R$$priv$project$rome$$romejs$codec$websocket$index_ts$net = require(
    'net',
  );
  function ___R$project$rome$$romejs$codec$websocket$index_ts$createKey(key) {
    return ___R$$priv$project$rome$$romejs$codec$websocket$index_ts$crypto.createHash('sha1').update('' +
    key +
    ___R$project$rome$$romejs$codec$websocket$types_ts$GUID).digest('base64');
  }

  class ___R$project$rome$$romejs$codec$websocket$index_ts$WebSocketInterface {
    constructor(type, socket, reporter) {
      // When a frame is set here then any additional continuation frames payloads will be appended
      this.unfinishedFrame = undefined;

      // When a frame is set here, all additional chunks will be appended until we reach the correct payloadLength
      this.incompleteFrame = undefined;

      this.reporter = reporter;
      this.socket = socket;
      this.alive = true;
      this.type = type;

      this.completeFrameEvent = new ___R$project$rome$$romejs$events$Event_ts$default({name: 'WebSocketInterface.message'});
      this.errorEvent = new ___R$project$rome$$romejs$events$Event_ts$default({name: 'WebSocketInterface.error'});
      this.endEvent = new ___R$project$rome$$romejs$events$Event_ts$default({name: 'WebSocketInterface.end', serial: true});

      socket.on(
        'data',
        (buff) => {
          this.addBuffer(buff);
        },
      );

      socket.on(
        'error',
        (err) => {
          if (err.code === 'ECONNRESET') {
            this.endEvent.send();
          } else {
            this.errorEvent.send(err);
          }
        },
      );

      socket.on(
        'close',
        () => {
          this.end();
        },
      );
    }

    end() {
      if (!this.alive) {
        return;
      }

      this.alive = false;
      this.endEvent.send();
      this.socket.end();
    }

    send(buff) {
      if (typeof buff === 'string') {
        this.sendFrame(
          {
            opcode: ___R$project$rome$$romejs$codec$websocket$types_ts$OPCODES.TEXT,
            fin: true,
            data: Buffer.from(buff),
          },
        );
      } else if (buff instanceof Buffer) {
        this.sendFrame(
          {
            opcode: ___R$project$rome$$romejs$codec$websocket$types_ts$OPCODES.BINARY,
            fin: true,
            data: buff,
          },
        );
      } else {
        throw new Error('Don\'t know how to send this');
      }
    }

    sendJSON(val) {
      this.send(String(JSON.stringify(val)));
    }

    sendFrame(frameOpts) {
      if (this.reporter !== undefined) {
        this.reporter.info(
          'Sending frame',
          {
            fin: frameOpts.fin,
            opcode: frameOpts.opcode,
            msg: frameOpts.data,
          },
        );
      }
      this.socket.write(___R$project$rome$$romejs$codec$websocket$frame_ts$buildFrame(frameOpts, this.type === 'client'));
    }

    completeFrame(frame) {
      // If we have an unfinished frame then only allow continuations
      const {unfinishedFrame} = this;
      if (unfinishedFrame !== undefined) {
        if (frame.opcode === ___R$project$rome$$romejs$codec$websocket$types_ts$OPCODES.CONTINUATION) {
          unfinishedFrame.payload =
            Buffer.concat(
              [
                unfinishedFrame.payload,
                ___R$project$rome$$romejs$codec$websocket$frame_ts$unmaskPayload(
                  frame.payload,
                  unfinishedFrame.mask,
                  unfinishedFrame.payload.length,
                ),
              ],
            );

          if (frame.fin) {
            this.unfinishedFrame = undefined;
            this.completeFrame(unfinishedFrame);
          }
          return undefined;
        } else {
          // Silently ignore the previous frame...
          this.unfinishedFrame = undefined;
          /*throw new Error(
          `We're waiting for a frame to finish so only allow continuation frames. Received frame: ${JSON.stringify(
            frame,
          )} Unfinished frame: ${JSON.stringify(unfinishedFrame)}`,
        );*/
        }
      }

      if (frame.fin) {
        if (frame.opcode === ___R$project$rome$$romejs$codec$websocket$types_ts$OPCODES.PING) {
          this.sendFrame(
            {
              opcode: ___R$project$rome$$romejs$codec$websocket$types_ts$OPCODES.PONG,
              fin: true,
              data: frame.payload,
            },
          );
        } else {
          // Trim off any excess payload
          let excess;
          if (frame.payload.length > frame.payloadLength) {
            excess = frame.payload.slice(frame.payloadLength);
            frame.payload = frame.payload.slice(0, frame.payloadLength);
          }

          if (this.reporter !== undefined) {
            this.reporter.info(
              'Received complete frame',
              {
                opcode: frame.opcode,
                length: frame.payloadLength,
                msg: frame.payload,
              },
            );
          }

          this.completeFrameEvent.send(frame);

          if (excess !== undefined) {
            this.addBuffer(excess);
          }
        }
      } else {
        this.unfinishedFrame = frame;
      }
    }

    addBufferToIncompleteFrame(incompleteFrame, buff) {
      incompleteFrame.payload =
        Buffer.concat(
          [
            incompleteFrame.payload,
            ___R$project$rome$$romejs$codec$websocket$frame_ts$unmaskPayload(buff, incompleteFrame.mask, incompleteFrame.payload.length),
          ],
        );

      if (___R$project$rome$$romejs$codec$websocket$frame_ts$isCompleteFrame(incompleteFrame)) {
        this.incompleteFrame = undefined;
        this.completeFrame(incompleteFrame);
      }
    }

    addBuffer(buff) {
      // Check if we're still waiting for the rest of a payload
      const {incompleteFrame} = this;
      if (incompleteFrame !== undefined) {
        this.addBufferToIncompleteFrame(incompleteFrame, buff);
        return undefined;
      }

      const frame = ___R$project$rome$$romejs$codec$websocket$frame_ts$parseFrame(buff);

      if (___R$project$rome$$romejs$codec$websocket$frame_ts$isCompleteFrame(frame)) {
        // Frame has been completed!
        this.completeFrame(frame);
      } else {
        this.incompleteFrame = frame;
      }
    }
  }

  async function ___R$project$rome$$romejs$codec$websocket$index_ts$createClient(rawUrl) {
    const parts = ___R$$priv$project$rome$$romejs$codec$websocket$index_ts$url.parse(rawUrl);

    return (
      new Promise(
        (resolve, reject) => {
          const key = ___R$$priv$project$rome$$romejs$codec$websocket$index_ts$crypto.randomBytes(16).toString('base64');
          const digest = ___R$project$rome$$romejs$codec$websocket$index_ts$createKey(key);

          const req = ___R$$priv$project$rome$$romejs$codec$websocket$index_ts$http.request(
            {
              hostname: parts.hostname,
              port: parts.port,
              path: parts.path,
              method: 'GET',
              headers: {
                Connection: 'Upgrade',
                Upgrade: 'websocket',
                'Sec-WebSocket-Key': key,
                'Sec-WebSocket-Version': '13',
              },
            },
          );

          req.on(
            'response',
            (res) => {
              if (res.statusCode && res.statusCode >= 400) {
                process.stderr.write('Unexpected HTTP code: ' +
                res.statusCode +
                '\n');
                res.pipe(process.stderr);
              } else {
                res.pipe(process.stderr);
              }
            },
          );

          req.on(
            'upgrade',
            (res, socket, head) => {
              if (res.headers['sec-websocket-accept'] !== digest) {
                socket.end();
                reject(
                  new Error(
                    'Digest mismatch ' +
                    digest +
                    ' !== ' +
                    res.headers['sec-websocket-accept'],
                  ),
                );
                return undefined;
              }

              const client = new ___R$project$rome$$romejs$codec$websocket$index_ts$WebSocketInterface('client', socket);
              //client.addBuffer(head);
              head;
              resolve(client);
            },
          );

          req.on(
            'error',
            (err) => {
              reject(err);
            },
          );

          req.end();
        },
      )
    );
  }

  // project-rome/@romejs/codec-url/index.ts
const ___R$$priv$project$rome$$romejs$codec$url$index_ts$url = require(
    'url',
  );

  function ___R$project$rome$$romejs$codec$url$index_ts$consumeUrl(rawUrl) {
    const parts = ___R$$priv$project$rome$$romejs$codec$url$index_ts$url.parse(rawUrl, true);

    const query = ___R$project$rome$$romejs$consume$index_ts$consumeUnknown(Object.assign(
      {
      },
      parts.query,
    ), 'parse/url/query');

    const path = ___R$project$rome$$romejs$consume$index_ts$consume(
      {
        value: parts.pathname,
        context: {
          category: 'parse/url',

          getDiagnosticPointer() {
            return (
              {
                language: 'url',
                mtime: undefined,
                sourceText: rawUrl,
                filename: 'url',
                start: {
                  index: ___R$project$rome$$romejs$ob1$index_ts$number0,
                  line: ___R$project$rome$$romejs$ob1$index_ts$number1,
                  column: ___R$project$rome$$romejs$ob1$index_ts$number0,
                },
                end: {
                  index: ___R$project$rome$$romejs$ob1$index_ts$coerce0(rawUrl.length - 1),
                  line: ___R$project$rome$$romejs$ob1$index_ts$number1,
                  column: ___R$project$rome$$romejs$ob1$index_ts$coerce0(rawUrl.length - 1),
                },
              }
            );
          },
        },
      },
    );

    return {query, path};
  }

  // project-rome/@romejs/core/master/web/WebRequest.ts
const ___R$$priv$project$rome$$romejs$core$master$web$WebRequest_ts$http = require(
    'http',
  );
  const ___R$$priv$project$rome$$romejs$core$master$web$WebRequest_ts$waitForever = new Promise(() => {});

  function ___R$project$rome$$romejs$core$master$web$WebRequest_ts$stripBundleSuffix(pathname) {
    return ___R$project$rome$$romejs$string$utils$removePrefix_ts$removePrefix(___R$project$rome$$romejs$string$utils$removeSuffix_ts$removeSuffix(pathname, '.bundle'), '/');
  }

  class ___R$project$rome$$romejs$core$master$web$WebRequest_ts$default {
    constructor(server, req, res) {
      this.req = req;
      this.res = res;
      this.server = server;
      this.reporter = server.reporter;
      this.masterRequest = server.masterRequest;
      this.master = server.master;

      const reqUrl = req.url;
      if (reqUrl === undefined) {
        throw new Error('req.url should not be undefined');
      }
      this.url = ___R$project$rome$$romejs$codec$url$index_ts$consumeUrl(reqUrl);
    }

    loadRawBody() {
      const {req} = this;

      req.setEncoding('utf8');
      let rawBody = '';

      return (
        new Promise(
          (resolve) => {
            req.on(
              'data',
              (chunk) => {
                rawBody += chunk;
              },
            );

            req.on(
              'end',
              () => {
                resolve(rawBody);
              },
            );
          },
        )
      );
    }

    async dispatch() {
      const {res} = this;

      try {
        const rawBody = await this.loadRawBody();
        await this.dispatchWithBody(rawBody);
        res.end();
      } catch (err) {
        res.writeHead(500, {'Content-Type': 'text/plain'});

        let diagnostics = ___R$project$rome$$romejs$diagnostics$errors_ts$getDiagnosticsFromError(err);
        if (diagnostics === undefined) {
          diagnostics =
            [
              ___R$project$rome$$romejs$diagnostics$derive_ts$deriveDiagnosticFromError(
                {
                  category: 'internalError/httpServer',
                  error: err,
                },
              ),
            ];
        }

        //this.request.reporter.clear();
        try {
          const printer = this.masterRequest.createDiagnosticsPrinter(
            {
              category: 'WebRequest',
            },
          );
          printer.addDiagnostics(diagnostics);
          await printer.print();
        } catch (err) {
          this.reporter.warn('Failed trying to print diagnostics');
          this.reporter.error(err.stack);
        }

        res.end('Diagnostics available, see console');
      }
    }

    async dispatchWithBody(body) {
      const {res} = this;
      const pathname = this.url.path.asString();
      body;

      switch (pathname) {
        case '/favicon.ico':
          res.end('');
          break;

        case '/__rome__/websocket':
          return this.handleFrontendWebsocket();

        case '/__rome__/script.js':
          return this.handleFrontendScript();

        case '/__rome__':
          res.writeHead(200, {'Content-Type': 'text/html'});
          res.end(
            '\n          <!doctype html>\n          <html>\n            <head>\n              <meta charset="utf-8"/>\n              <title>Rome</title>\n              <link rel="stylesheet" href="https://meyerweb.com/eric/tools/css/reset/reset.css">\n            </head>\n            <body>\n              <div id="app"></div>\n              <script src="/__rome__/script.js"></script>\n            </body>\n          </html>\n        ',
          );
          break;

        case '/hot':
          return this.handleDeviceWebsocket();

        default:
          return this.handleWildcard(pathname);
      }
    }

    async handleWildcard(pathname) {
      const {req, res} = this;

      // Check for *.bundle
      if (pathname.endsWith('.bundle')) {
        const handled = await this.handleBundleRequest();
        if (handled) {
          return;
        }
      }

      // Look up static file
      const project = await this.masterRequest.assertClientCwdProject();
      if (project.config.develop.serveStatic) {
        const handled = await this.handlePossibleStatic(pathname, project);
        if (handled) {
          return;
        }
      }

      this.reporter.error('Unknown request for', req.url);
      res.writeHead(404);
      res.end('Not found');
    }

    async handlePossibleStatic(pathname, project) {
      project;

      const possibleStaticPath = await this.server.pathnameToAbsolutePath(pathname);

      // TODO check if it is a file
      if (possibleStaticPath !== undefined &&
        (await this.master.memoryFs.existsHard(possibleStaticPath))) {
        return true;
      }

      return false;
    }

    async handleFrontendScript() {
      const {res} = this;
      res.writeHead(200, {'Content-Type': 'application/javascript'});

      const bundler = new ___R$project$rome$$romejs$core$master$bundler$Bundler_ts$default(
        this.masterRequest,
        {
          inlineSourceMap: false,
          cwd: this.masterRequest.client.flags.cwd,
          resolver: {
            platform: 'web',
          },
        },
      );
      const resolved = await this.master.resolver.resolveEntryAssertPath(
        {
          origin: this.masterRequest.client.flags.cwd,
          source: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath('@romejs-web/frontend'),
        },
      );
      const bundle = await bundler.bundle(resolved);
      res.end(bundle.entry.js);
    }

    negotiateWebsocket() {
      const {req} = this;

      const digest = ___R$project$rome$$romejs$codec$websocket$index_ts$createKey(String(req.headers['sec-websocket-key']));

      const headers = [
        'HTTP/1.1 101 Switching Protocols',
        'Upgrade: websocket',
        'Connection: Upgrade',
        'Sec-WebSocket-Protocol: rome',
        'Sec-WebSocket-Accept: ' +
        digest,
        '',
        '',
      ];

      req.socket.write(headers.join('\r\n'));
    }

    async handleDeviceWebsocketMessage(socket, data) {
      switch (data.type) {
        case 'log':
          return this.server.printConsoleLog(data);

        case 'log-opt-in':
          // ???
          return;

        case 'register-entrypoints':
          /// ???
          return;

        default:
          console.log('UNKNOWN MESSAGE', data);
      }
    }

    async handleDeviceWebsocket() {
      const {req} = this;
      this.negotiateWebsocket();

      const socket = new ___R$project$rome$$romejs$codec$websocket$index_ts$WebSocketInterface('server', req.socket);
      this.server.deviceWebsockets.add(socket);

      req.socket.on(
        'error',
        (err) => {
          console.log(err.stack);
        },
      );

      this.reporter.success('Device websocket client connected');

      socket.completeFrameEvent.subscribe(
        (frame) => {
          const text = frame.payload.toString();
          try {
            const json = JSON.parse(text);
            this.handleDeviceWebsocketMessage(socket, json);
          } catch (err) {
            if (err instanceof SyntaxError) {
              console.log('UNKNOWN FRAME', text);
              return;
            } else {
              throw err;
            }
          }
        },
      );

      socket.errorEvent.subscribe(
        (err) => {
          console.log(err);
        },
      );

      socket.endEvent.subscribe(
        () => {
          console.log('END');
          this.server.deviceWebsockets.delete(socket);
        },
      );

      await ___R$$priv$project$rome$$romejs$core$master$web$WebRequest_ts$waitForever;
    }

    async handleFrontendWebsocket() {
      const {req} = this;
      this.negotiateWebsocket();

      const socket = new ___R$project$rome$$romejs$codec$websocket$index_ts$WebSocketInterface('server', req.socket);
      const bridge = ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromWebSocketInterface(
        ___R$project$rome$$romejs$core$common$bridges$WebBridge_ts$default,
        socket,
        {
          type: 'client',
        },
      );
      this.server.frontendWebsocketBridges.add(bridge);

      req.socket.on(
        'close',
        () => {
          this.server.frontendWebsocketBridges.delete(bridge);
        },
      );

      await bridge.handshake();

      this.reporter.success('Frontend websocket client connected');

      this.server.sendRequests(bridge);

      await ___R$$priv$project$rome$$romejs$core$master$web$WebRequest_ts$waitForever;
    }

    async handleBundleRequest() {
      const {res} = this;

      const {bundler, path} = await this.server.getBundler(this.url);
      const bundle = await bundler.bundle(path);
      const content = bundle.entry.js.content;

      res.writeHead(200, {'Content-Type': 'application/javascript'});
      res.end(content);
      return true;
    }
  }

  // project-rome/@romejs/core/master/web/index.ts
const ___R$$priv$project$rome$$romejs$core$master$web$index_ts$http = require(
    'http',
  );

  class ___R$project$rome$$romejs$core$master$web$index_ts$WebServer {
    constructor(req) {
      const {master} = req;

      this.masterRequest = req;
      this.reporter = req.reporter;
      this.master = master;

      this.bundlerCache = new Map();

      this.savingRequests = false;
      this.clientRequestHistory = new Map();
      this.clientHistory = new Map();

      this.deviceWebsockets = new Set();
      this.frontendWebsocketBridges = new Set();

      this.server =
        ___R$$priv$project$rome$$romejs$core$master$web$index_ts$http.createServer(
          (req, res) => {
            const webRequest = new ___R$project$rome$$romejs$core$master$web$WebRequest_ts$default(this, req, res);
            webRequest.dispatch();
          },
        );

      master.clientStartEvent.subscribe(
        (client) => {
          if (!this.savingRequests) {
            return;
          }

          const data = {
            id: client.id,
            flags: client.flags,
            startTime: Date.now(),
            endTime: undefined,
            stdoutAnsi: '',
            stdoutHTML: '',
          };
          this.clientHistory.set(client.id, data);
          this.refreshRequests();

          const ansiReporterStream = {
            type: 'all',
            format: 'ansi',
            columns: 100,
            write(chunk) {
              data.stdoutAnsi += chunk;
            },
          };

          const htmlReporterStream = {
            type: 'all',
            format: 'html',
            columns: 100,
            write(chunk) {
              data.stdoutAnsi += chunk;
            },
          };

          client.reporter.addStream(ansiReporterStream);
          master.connectedReporters.addStream(ansiReporterStream);

          client.reporter.addStream(htmlReporterStream);
          master.connectedReporters.addStream(htmlReporterStream);

          client.bridge.endEvent.subscribe(
            () => {
              master.connectedReporters.removeStream(ansiReporterStream);
              master.connectedReporters.removeStream(htmlReporterStream);

              data.endTime = Date.now();
              this.refreshRequests();
            },
          );
        },
      );

      master.requestStartEvent.subscribe(
        (request) => {
          if (!this.savingRequests) {
            return;
          }

          const data = {
            id: request.id,
            client: request.client.id,
            query: request.query,
            markers: [],
            response: undefined,
            startTime: Date.now(),
            endTime: undefined,
          };
          this.clientRequestHistory.set(request.id, data);
          this.refreshRequests();

          request.markerEvent.subscribe(
            (marker) => {
              data.markers.push(marker);
              this.refreshRequests();
            },
          );

          request.endEvent.subscribe(
            (response) => {
              // Update completion fields
              data.response = response;
              data.endTime = Date.now();
              this.refreshRequests();
            },
          );
        },
      );
    }

    sendRequests(bridge) {
      bridge.requests.send(
        {
          requests: Array.from(this.clientRequestHistory.values()),
          clients: Array.from(this.clientHistory.values()),
        },
      );
    }

    refreshRequests() {
      for (const bridge of this.frontendWebsocketBridges) {
        this.sendRequests(bridge);
      }
    }

    close() {
      this.server.close();
    }

    listen(port) {
      this.server.listen(port);

      //this.reporter.clear();
      const url = 'http://localhost:' +
      String(port);
      this.reporter.success('Listening on <hyperlink emphasis>' +
      url +
      '</hyperlink>');
      this.reporter.info(
        'Web console available at <hyperlink emphasis>' +
        url +
        '/__rome__</hyperlink>',
      );
    }

    printConsoleLog(msg) {
      const {reporter} = this.masterRequest;

      let buf = msg.data.map(
        (arg) => {
          if (typeof arg === 'string') {
            return ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(arg);
          } else {
            return ___R$project$rome$$romejs$pretty$format$index_ts$default(arg, {escapeMarkup: true, color: true});
          }
        },
      ).join(
        ' ',
      );

      switch (msg.level) {
        case 'info':
          reporter.info(buf);
          break;

        case 'warn':
          reporter.warn(buf);
          break;

        case 'log':
        case 'trace':
          reporter.verboseForce(buf);
          break;

        case 'group':
        case 'groupCollapsed':
        case 'groupEnd':
          reporter.logAll('TODO');
      }
    }

    async pathnameToAbsolutePath(pathname) {
      const project = await this.masterRequest.assertClientCwdProject();
      const possibleStaticPath = project.folder.append(pathname);

      // This check makes sure that files outside of the project directory cannot be served
      if (possibleStaticPath.isRelativeTo(project.folder)) {
        return possibleStaticPath;
      }
    }

    sendToAllDeviceWebsockets(msg) {
      const text = JSON.stringify(msg);
      for (const socket of this.deviceWebsockets) {
        socket.send(text);
      }
    }

    async getBundler(
      url,
    ) {
      const pathname = ___R$project$rome$$romejs$core$master$web$WebRequest_ts$stripBundleSuffix(String(url.path.asString()));

      const absolute = await this.pathnameToAbsolutePath(pathname);
      if (absolute === undefined) {
        throw new Error('Pathname is attempting to escalate out of cwd');
      }

      const pathPointer = url.path.getDiagnosticPointer();
      const path = await this.master.resolver.resolveEntryAssertPath(
        {
          origin: this.masterRequest.client.flags.cwd,
          source: absolute,
        },
        pathPointer === undefined ? undefined : {pointer: pathPointer},
      );

      const platform = url.query.get('platform').asStringSetOrVoid(___R$project$rome$$romejs$core$common$types$platform_ts$PLATFORMS);
      const cacheKey = JSON.stringify(
        {
          platform,
        },
      );

      const cached = this.bundlerCache.get(cacheKey);
      if (cached !== undefined) {
        return {bundler: cached, path};
      }

      const bundlerConfig = this.masterRequest.getBundlerConfigFromFlags(
        {
          platform,
        },
      );

      const bundler = new ___R$project$rome$$romejs$core$master$bundler$Bundler_ts$default(this.masterRequest, bundlerConfig);

      bundler.graph.watch(
        async () => {
          // TODO HMR
        },
      );

      this.bundlerCache.set(cacheKey, bundler);

      return {bundler, path};
    }
  }

  // project-rome/@romejs/core/master/commands/develop.ts
const ___R$$priv$project$rome$$romejs$core$master$commands$develop_ts$DEFAULT_PORT = 8081;
  const ___R$project$rome$$romejs$core$master$commands$develop_ts$default = ___R$project$rome$$romejs$core$commands_ts$createMasterCommand(
    {
      category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.SOURCE_CODE,
      description: 'start a web server',

      defineFlags(c) {
        return (
          {
            port: c.get('port').asNumber(___R$$priv$project$rome$$romejs$core$master$commands$develop_ts$DEFAULT_PORT),
          }
        );
      },

      async default(req, flags) {
        // Initialize cwd early since we'll need it for any requests
        await req.master.projectManager.findProject(req.client.flags.cwd);

        const web = new ___R$project$rome$$romejs$core$master$web$index_ts$WebServer(req);
        web.listen(flags.port);

        req.endEvent.subscribe(
          () => {
            web.close();
          },
        );

        await new Promise(() => {});
      },
    },
  );

  // project-rome/@romejs/core/master/commands/config.ts
const ___R$project$rome$$romejs$core$master$commands$config_ts$default = ___R$project$rome$$romejs$core$commands_ts$createMasterCommand(
    {
      category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.PROJECT_MANAGEMENT,
      description: 'Modify a project config',

      usage: '(enable|disable|enable-category|disable-category|set) key [value]',

      examples: [
        {
          command: 'enable-category lint',
          description: 'Enable linting',
        },
        {
          command: 'set name my_awesome_project',
          description: 'Set the project name',
        },
      ],

      async default(req) {
        const {reporter} = req;
        req.expectArgumentLength(2, 3);

        const project = await req.assertClientCwdProject();

        let keyParts;
        let value;

        const [action] = req.query.args;
        switch (action) {
          case 'enable':
            {
              req.expectArgumentLength(2);
              keyParts = req.query.args[1];
              value = true;
              break;
            }

          case 'disable':
            {
              req.expectArgumentLength(2);
              keyParts = req.query.args[1];
              value = false;
              break;
            }

          case 'enable-category':
            {
              req.expectArgumentLength(2);
              const category = req.query.args[1];
              keyParts = category +
              '.enabled';
              value = true;
              break;
            }

          case 'disable-category':
            {
              req.expectArgumentLength(2);
              const category = req.query.args[1];
              keyParts = category +
              '.enabled';
              value = false;
              break;
            }

          case 'set':
            {
              req.expectArgumentLength(3);
              [keyParts, value] = req.query.args;
              break;
            }

          default:
            throw (
              req.throwDiagnosticFlagError(
                'Unknown action ' +
                action,
                {
                  type: 'arg',
                  key: 0,
                },
              )
            );
        }

        try {
          await ___R$project$rome$$romejs$project$save_ts$modifyProjectConfig(
            project.meta,
            {
              pre: (meta) => {
                reporter.success(
                  'Setting <emphasis>' +
                  keyParts +
                  '</emphasis> to <emphasis>' +
                  JSON.stringify(
                    value,
                  ) +
                  '</emphasis> in the project config <filelink emphasis target="' +
                  meta.configPath.join() +
                  '" />',
                );

                if (value === 'true' || value === 'false') {
                  const suggestedCommand = value === 'true' ? 'enable' : 'disable';
                  reporter.warn(
                    'Value is the string <emphasis>' +
                    value +
                    '</emphasis> but it looks like a boolean. You probably meant to use the command:',
                  );
                  reporter.command('config ' +
                  suggestedCommand +
                  ' ' +
                  keyParts);
                }
              },

              modify: (consumer) => {
                // Set the specified value
                let keyConsumer = consumer;
                for (const key of keyParts.split('.')) {
                  if (!keyConsumer.exists()) {
                    keyConsumer.setValue({});
                  }
                  keyConsumer = keyConsumer.get(key);
                }
                keyConsumer.setValue(value);
              },
            },
          );
        } catch (err) {
          reporter.error(
            'Error occured while testing new project config. Your changes have not been saved.',
          );
          throw err;
        }
      },
    },
  );

  // project-rome/@romejs/core/master/commands/compile.ts
const ___R$project$rome$$romejs$core$master$commands$compile_ts$default = ___R$project$rome$$romejs$core$commands_ts$createMasterCommand(
    {
      category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.SOURCE_CODE,
      description: 'compile a single file',

      defineFlags(c) {
        return (
          {
            bundle: c.get('bundle').asBoolean(false),
          }
        );
      },

      async default(req, commandFlags) {
        const {master, reporter} = req;
        const {args} = req.query;
        req.expectArgumentLength(1);

        const resolved = await master.resolver.resolveEntryAssert(
          Object.assign(
            {
            },
            req.getResolverOptionsFromFlags(),
            {
              source: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(args[0]),
            },
          ),
          {pointer: req.getDiagnosticPointerFromFlags({type: 'arg', key: 0})},
        );

        let res;
        if (commandFlags.bundle) {
          const bundler = ___R$project$rome$$romejs$core$master$bundler$Bundler_ts$default.createFromMasterRequest(req);
          res = await bundler.compile(resolved.path);
        } else {
          res = await req.requestWorkerCompile(resolved.path, 'compile');
        }

        const {compiledCode, diagnostics, suppressions} = res;

        if (diagnostics.length > 0) {
          throw (
            new ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError(
              'Compile diagnostics',
              diagnostics,
              suppressions,
            )
          );
        }

        reporter.writeAll(compiledCode);
      },
    },
  );

  // project-rome/@romejs/core/master/commands/resolve.ts
const ___R$project$rome$$romejs$core$master$commands$resolve_ts$default = ___R$project$rome$$romejs$core$commands_ts$createMasterCommand(
    {
      category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.SOURCE_CODE,
      description: 'resolve a file',

      async default(req) {
        const {master, reporter} = req;
        const {args} = req.query;
        const {flags} = req.client;
        req.expectArgumentLength(1, 2);

        let origin;
        let relative = '';
        let key;

        if (args.length === 2) {
          origin = flags.cwd.resolveMaybeUrl(args[0]);
          relative = args[1];
          key = 1;
        } else {
          origin = flags.cwd;
          relative = args[0];
          key = 0;
        }

        const query = Object.assign(
          {
          },
          req.getResolverOptionsFromFlags(),
          {
            origin,
            source: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(relative),
          },
        );

        const resolved = await master.resolver.resolveEntryAssert(
          query,
          {
            pointer: req.getDiagnosticPointerFromFlags({type: 'arg', key}),
          },
        );
        const filename = resolved.ref.real.join();
        reporter.logAll(filename);
        return filename;
      },
    },
  );

  // project-rome/@romejs/core/master/commands/analyzeDependencies.ts
function ___R$$priv$project$rome$$romejs$core$master$commands$analyzeDependencies_ts$removeLoc(obj) {
    const ___R$ = obj;
    const locless = Object.assign(
      {
      },
      ___R$,
    );
    delete locless.loc;
    const {
      loc,
    } = ___R$;
    loc;
    return locless;
  }

  const ___R$project$rome$$romejs$core$master$commands$analyzeDependencies_ts$default = ___R$project$rome$$romejs$core$commands_ts$createMasterCommand(
    {
      category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.SOURCE_CODE,
      description: 'analyze and dump the dependencies of a file',

      defineFlags(c) {
        return (
          {
            compact: c.get('compact').asBoolean(false),
            focusSource: c.get('focusSource').asStringOrVoid(),
          }
        );
      },

      async default(req, commandFlags) {
        const {master, reporter} = req;
        const {args} = req.query;
        req.expectArgumentLength(1);

        const filename = await master.resolver.resolveEntryAssertPath(
          Object.assign(
            {
            },
            req.getResolverOptionsFromFlags(),
            {
              source: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(args[0]),
            },
          ),
          {pointer: req.getDiagnosticPointerFromFlags({type: 'arg', key: 0})},
        );

        let res = await req.requestWorkerAnalyzeDependencies(filename);

        const {focusSource} = commandFlags;
        if (focusSource !== undefined) {
          res =
            Object.assign(
              {
              },
              res,
              {
                importFirstUsage: res.importFirstUsage.filter(
                  (dep) => {
                    return dep.source === focusSource;
                  },
                ),
                dependencies: res.dependencies.filter(
                  (dep) => {
                    return dep.source === focusSource;
                  },
                ),
              },
            );
        }

        if (commandFlags.compact) {
          res =
            Object.assign(
              {
              },
              res,
              {
                importFirstUsage: res.importFirstUsage.map(
                  (imp) => {
                    return ___R$$priv$project$rome$$romejs$core$master$commands$analyzeDependencies_ts$removeLoc(imp);
                  },
                ),
                exports: res.exports.map(
                  (exp) => {
                    // This weird switch is because TS only returns an object with the properties common amongst all
                    switch (exp.type) {
                      case 'local':
                        return ___R$$priv$project$rome$$romejs$core$master$commands$analyzeDependencies_ts$removeLoc(exp);

                      case 'external':
                        return ___R$$priv$project$rome$$romejs$core$master$commands$analyzeDependencies_ts$removeLoc(exp);

                      case 'externalAll':
                        return ___R$$priv$project$rome$$romejs$core$master$commands$analyzeDependencies_ts$removeLoc(exp);
                    }
                  },
                ),
                dependencies: res.dependencies.map(
                  (dep) => {
                    return (
                      Object.assign(
                        {
                        },
                        ___R$$priv$project$rome$$romejs$core$master$commands$analyzeDependencies_ts$removeLoc(dep),
                        {
                          names: dep.names.map(
                            (name) => {
                              return ___R$$priv$project$rome$$romejs$core$master$commands$analyzeDependencies_ts$removeLoc(name);
                            },
                          ),
                        },
                      )
                    );
                  },
                ),
              },
            );
        }

        reporter.inspect(res);
      },
    },
  );

  // project-rome/@romejs/core/master/commands/parse.ts
const ___R$project$rome$$romejs$core$master$commands$parse_ts$default = ___R$project$rome$$romejs$core$commands_ts$createMasterCommand(
    {
      category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.SOURCE_CODE,
      description: 'parse a single file and dump its ast',

      defineFlags(c) {
        return (
          {
            showDespiteDiagnostics: c.get('showDespiteDiagnostics').asBoolean(false),
            compact: c.get('compact').asBoolean(true),
            sourceType: c.get('sourceType').asStringSetOrVoid(['module', 'script']),
          }
        );
      },

      async default(req, commandFlags) {
        const {master, reporter} = req;
        const {args} = req.query;
        req.expectArgumentLength(1);

        const filename = await master.resolver.resolveEntryAssertPath(
          Object.assign(
            {
            },
            req.getResolverOptionsFromFlags(),
            {
              source: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(args[0]),
            },
          ),
          {pointer: req.getDiagnosticPointerFromFlags({type: 'arg', key: 0})},
        );

        const ast = await req.requestWorkerParse(
          filename,
          {
            compact: commandFlags.compact,
            sourceType: commandFlags.sourceType,
          },
        );

        const hasErrors = ast.diagnostics.length > 0;
        if (!hasErrors || commandFlags.showDespiteDiagnostics) {
          reporter.inspect(ast);
        }

        if (hasErrors) {
          throw new ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError('Parsing failed', ast.diagnostics);
        }
      },
    },
  );

  // project-rome/@romejs/core/master/commands/bundle.ts
const ___R$project$rome$$romejs$core$master$commands$bundle_ts$default = ___R$project$rome$$romejs$core$commands_ts$createMasterCommand(
    {
      category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.SOURCE_CODE,
      description: 'build a standalone js bundle for a package',

      defineFlags(consumer) {
        return (
          {
            quiet: consumer.get('quiet').asBoolean(false),
          }
        );
      },

      async default(
        req,
        commandFlags,
      ) {
        const {flags} = req.client;
        const {args} = req.query;
        const {reporter} = req;
        req.expectArgumentLength(2);

        const [entryFilename, outputFolder] = args;
        const bundler = ___R$project$rome$$romejs$core$master$bundler$Bundler_ts$default.createFromMasterRequest(req);

        const resolution = await bundler.getResolvedEntry(entryFilename);
        const {files: outFiles, entry} = await bundler.bundleManifest(resolution);

        const savedList = [];
        const dir = flags.cwd.resolve(outputFolder);
        for (const [filename, {kind, content}] of outFiles) {
          const file = dir.append(filename);
          const loc = file.join();
          savedList.push(
            '<filelink target="' +
            loc +
            '">' +
            filename +
            '</filelink> <filesize dim>' +
            Buffer.byteLength(
              content,
            ) +
            '</filesize> <inverse>' +
            kind +
            '</inverse>',
          );
          await ___R$project$rome$$romejs$fs$index_ts$createDirectory(file.getParent(), {recursive: true});
          await ___R$project$rome$$romejs$fs$index_ts$writeFile(file, content);
        }

        if (commandFlags.quiet) {
          reporter.success(
            'Saved to <filelink target="' +
            dir.join() +
            '" />',
          );
        } else {
          reporter.success(
            'Saved the following files to <filelink target="' +
            dir.join() +
            '" />',
          );
          reporter.list(savedList);
        }

        return (
          {
            content: entry.js.content,
            map: entry.sourceMap.content,
          }
        );
      },
    },
  );

  // project-rome/@romejs/core/master/commands/format.ts
const ___R$project$rome$$romejs$core$master$commands$format_ts$default = ___R$project$rome$$romejs$core$commands_ts$createMasterCommand(
    {
      category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.INTERNAL,
      description: 'TODO',

      defineFlags(consumer) {
        return (
          {
            write: consumer.get('write').asBoolean(false),
          }
        );
      },

      async default(req, flags) {
        const {reporter, master} = req;

        const {paths} = await req.getFilesFromArgs(
          {
            getProjectIgnore: (
              project,
            ) =>
              ({
                patterns: project.config.format.ignore,
                source: master.projectManager.findProjectConfigConsumer(
                  project,
                  (
                    consumer,
                  ) =>
                    consumer.has('format') && consumer.get('format').has('ignore')
                      ? consumer.get('format').get('ignore') : undefined,
                ),
              }),
            getProjectEnabled: (
              project,
            ) =>
              ({
                enabled: project.config.format.enabled,
                source: master.projectManager.findProjectConfigConsumer(
                  project,
                  (
                    consumer,
                  ) =>
                    consumer.has('format')
                      ? consumer.get('format').get('enabled') : undefined,
                ),
              }),
            noun: 'formatting',
            verb: 'linting',
            configCategory: 'format',
            extensions: ___R$project$rome$$romejs$core$common$fileHandlers_ts$FORMATTABLE_EXTENSIONS,
            disabledDiagnosticCategory: 'format/disabled',
          },
        );

        if (paths.size === 0) {
          reporter.warn('No files formatted');
          return;
        }

        const pathsByWorker = await req.master.fileAllocator.groupPathsByWorker(
          paths,
        );

        const progress = reporter.progress();
        progress.setTotal(paths.size);
        progress.setTitle('Formatting');

        const diagnosticsProcessor = new ___R$project$rome$$romejs$diagnostics$DiagnosticsProcessor_ts$default({});

        // TODO probably add the same logic in CompilerLinter if the project config disables formatting
        await Promise.all(
          pathsByWorker.map(
            async (paths) => {
              for (const path of paths) {
                progress.setText('<filelink target="' +
                path.join() +
                '" />');
                progress.tick();

                const res = await req.requestWorkerFormat(path);
                if (res === undefined) {
                  continue;
                }

                if (res.diagnostics.length > 0) {
                  diagnosticsProcessor.addDiagnostics(res.diagnostics);
                  continue;
                }

                if (!flags.write && res.formatted !== res.original) {
                  // TODO abstract this and the pendingFixes diagnostic in WorkerAPI
                  diagnosticsProcessor.addDiagnostic(
                    {
                      category: 'lint/pendingFixes',
                      filename: path.join(),
                      message: 'Pending fixes',
                      advice: [
                        {
                          type: 'diff',
                          diff: ___R$project$rome$$romejs$string$diff$index_ts$default(res.original, res.formatted),
                        },
                        {
                          type: 'code',
                          code: res.formatted,
                        },
                      ],
                    },
                  );
                } else {
                  //await writeFile(path, res.formatted);
                }
              }
            },
          ),
        );

        diagnosticsProcessor.maybeThrowDiagnosticsError();

        if (flags.write) {
          reporter.success(
            '<number emphasis>' +
            paths.size +
            '</number> files formatted successfully',
          );
        } else {
          reporter.success(
            '<number emphasis>' +
            paths.size +
            '</number> files formatted correctly',
          );
        }
      },
    },
  );

  // project-rome/@romejs/core/master/linter/CompilerLinter.ts
class ___R$project$rome$$romejs$core$master$linter$CompilerLinter_ts$default {
    constructor(req, printer, fix) {
      this.request = req;
      this.fix = fix;
      this.printer = printer;
    }

    async lint(paths) {
      const {request, printer} = this;
      const {master, reporter} = request;

      const pathsByWorker = await master.fileAllocator.groupPathsByWorker(paths);

      const spinner = reporter.progress();
      spinner.setTitle('Linting');
      spinner.setTotal(paths.size);

      await Promise.all(
        pathsByWorker.map(
          async (paths) => {
            for (const path of paths) {
              const text = '<filelink target="' +
              path.join() +
              '" />';
              spinner.pushText(text);

              const {
                diagnostics,
                suppressions,
              } = await this.request.requestWorkerLint(path, this.fix);
              printer.processor.addSuppressions(suppressions);
              printer.addDiagnostics(diagnostics);

              spinner.popText(text);
              spinner.tick();
            }
          },
        ),
      );

      spinner.end();
    }
  }

  // project-rome/@romejs/core/master/linter/Linter.ts
class ___R$project$rome$$romejs$core$master$linter$Linter_ts$default {
    constructor(req, fix) {
      this.request = req;
      this.fix = fix;
    }

    async lint(throwAlways = true) {
      const {request} = this;
      const {reporter, master} = request;

      const printer = request.createDiagnosticsPrinter(
        {
          category: 'lint',
          message: 'Dispatched',
        },
      );

      printer.processor.addAllowedUnusedSuppressionPrefix('bundler');

      const {paths, projects} = await request.getFilesFromArgs(
        {
          getProjectIgnore: (
            project,
          ) =>
            ({
              patterns: project.config.lint.ignore,
              source: master.projectManager.findProjectConfigConsumer(
                project,
                (
                  consumer,
                ) =>
                  consumer.has('lint') && consumer.get('lint').has('ignore')
                    ? consumer.get('lint').get('ignore') : undefined,
              ),
            }),
          getProjectEnabled: (
            project,
          ) =>
            ({
              enabled: project.config.lint.enabled,
              source: master.projectManager.findProjectConfigConsumer(
                project,
                (
                  consumer,
                ) =>
                  consumer.has('lint')
                    ? consumer.get('lint').get('enabled') : undefined,
              ),
            }),
          noun: 'lint',
          verb: 'linting',
          configCategory: 'lint',
          extensions: ___R$project$rome$$romejs$core$common$fileHandlers_ts$LINTABLE_EXTENSIONS,
          disabledDiagnosticCategory: 'lint/disabled',
        },
      );

      const {fix} = this;
      const shouldFix = fix !== undefined;

      if (fix !== undefined) {
        for (const project of projects) {
          if (!project.config.format.enabled) {
            printer.addDiagnostic(
              Object.assign(
                {
                },
                fix,
                {
                  category: 'format/disabled',
                  message: 'Format is disabled for this project',
                  // TODO advice and better error message
                },
              ),
            );
          }
        }
      }

      printer.onBeforeFooterPrint(
        (reporter, isError) => {
          if (isError) {
            let couldFix = false;
            let hasPendingFixes = false;

            for (const {category, fixable} of printer.processor.getPartialDiagnostics()) {
              if (category === 'lint/pendingFixes') {
                hasPendingFixes = true;
              }

              if (fixable) {
                couldFix = true;
              }
            }

            if (hasPendingFixes) {
              reporter.info(
                'Fixes available. Run <command>rome lint --fix</command> to apply.',
              );
            } else if (couldFix) {
              reporter.warn(
                'Autofixes are available for some of these errors when formatting is enabled. Run <command>rome config enable-category format</command> to enable.',
              );
            }
          } else {
            const fileCount = paths.size;
            if (fileCount === 0) {
              reporter.warn('No files linted');
            } else if (fileCount === 1) {
              reporter.info('<emphasis>1</emphasis> file linted');
            } else {
              reporter.info('<number emphasis>' +
              fileCount +
              '</number> files linted');
            }
          }
        },
      );

      // Add a filter so that only files that are explicitly referenced will be included

      // For example, we don't want to show analysis or parse errors for transitive dependencies if the user only requested a specific file
      printer.processor.addFilter(
        {
          test: (diag) => {
            const {filename} = diag;
            if (filename === undefined) {
              return false;
            }

            const path = request.master.projectManager.getFilePathFromUid(filename);
            if (path === undefined) {
              return false;
            }

            return !paths.has(path);
          },
        },
      );

      await reporter.steps(
        [
          {
            clear: true,
            message: 'Analyzing files',
            callback: async () => {
              const compilerLinter = new ___R$project$rome$$romejs$core$master$linter$CompilerLinter_ts$default(request, printer, shouldFix);
              await compilerLinter.lint(paths);
            },
          },
          {
            clear: true,
            message: 'Analyzing dependencies',
            async callback() {
              const analyzeProgress = reporter.progress();
              analyzeProgress.setTitle('Analyzing');

              const graph = new ___R$project$rome$$romejs$core$master$dependencies$DependencyGraph_ts$default(request, {});
              await graph.seed(
                {
                  paths: Array.from(paths),
                  diagnosticsProcessor: printer.processor,
                  validate: false,
                  analyzeProgress,
                },
              );

              for (const path of paths) {
                graph.validate(graph.getNode(path), printer.processor);
              }
            },
          },
        ],
      );

      if (throwAlways || printer.hasDiagnostics()) {
        throw printer;
      } else {
        printer.footer();
      }
    }
  }

  // project-rome/@romejs/core/master/commands/lint.ts
const ___R$project$rome$$romejs$core$master$commands$lint_ts$default = ___R$project$rome$$romejs$core$commands_ts$createMasterCommand(
    {
      category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.CODE_QUALITY,
      description: 'run lint against a set of files',

      defineFlags(consumer) {
        return (
          {
            fix: consumer.get('fix').asBoolean(false),
          }
        );
      },

      async default(req, flags) {
        return (
          new Promise(
            (resolve, reject) => {
              if (req.query.requestFlags.watch) {
                ___R$$priv$project$rome$$romejs$core$master$commands$lint_ts$initWatchLint(req, reject);
              } else {
                resolve(___R$$priv$project$rome$$romejs$core$master$commands$lint_ts$runLint(req, flags.fix));
              }
            },
          )
        );
      },
    },
  );
  function ___R$$priv$project$rome$$romejs$core$master$commands$lint_ts$initWatchLint(req, reject) {
    const {master, reporter} = req;

    // whenever a file change happens, we wait 250ms to do lint, this is in case there's multiple

    // files being linted, like if an autofix is triggered
    let queued = false;

    // whether or not we're currently linting
    let running = false;

    // if a file event happens while we're linting then we'll need to run the full lint again to make

    // sure it's up to date
    let runAgainAfterComplete = false;

    function runWatchLint() {
      if (running) {
        runAgainAfterComplete = true;
        return undefined;
      }

      queued = false;
      running = true;
      reporter.clear();

      ___R$$priv$project$rome$$romejs$core$master$commands$lint_ts$runLint(req, false).then(
        () => {
          running = false;

          if (runAgainAfterComplete) {
            runAgainAfterComplete = false;
            runWatchLint();
          }
        },
        reject,
      );
    }

    const listener = master.fileChangeEvent.subscribe(
      () => {
        if (running) {
          // queue up a lint to happen afterwards
          runWatchLint();
          return undefined;
        }

        if (queued) {
          // already have a timer waiting
          return undefined;
        }

        // queue up a lint
        queued = true;
        setTimeout(runWatchLint, 250);
      },
    );

    req.endEvent.subscribe(
      () => {
        listener.unsubscribe();
      },
    );

    runWatchLint();
  }

  async function ___R$$priv$project$rome$$romejs$core$master$commands$lint_ts$runLint(
    req,
    fix,
  ) {
    const linter = new ___R$project$rome$$romejs$core$master$linter$Linter_ts$default(req, fix);
    await linter.lint();
  }

  // project-rome/@romejs/core/master/testing/utils.ts
function ___R$project$rome$$romejs$core$master$testing$utils_ts$sortMapKeys(map) {
    const sortedKeys = Array.from(map.keys()).sort(___R$project$rome$$romejs$string$utils$naturalCompare_ts$naturalCompare);
    const newMap = new Map();
    for (const key of sortedKeys) {
      const val = map.get(key);
      if (val === undefined) {
        throw new Error('Expected value');
      }
      newMap.set(key, val);
    }
    return newMap;
  }

  function ___R$project$rome$$romejs$core$master$testing$utils_ts$formatPercent(num) {
    const str = String(Math.floor(num));
    if (num > 80) {
      return '<green>' +
      str +
      '</green>';
    } else if (num > 40) {
      return '<yellow>' +
      str +
      '</yellow>';
    } else {
      return '<red>' +
      str +
      '</red>';
    }
  }

  function ___R$project$rome$$romejs$core$master$testing$utils_ts$percentInsideCoverageFolder(
    folder,
  ) {
    let totalFiles = 0;
    let functions = 0;
    let branches = 0;
    let lines = 0;

    const folders = [folder];
    while (folders.length > 0) {
      const folder = folders.shift();
      if (folder === undefined) {
        throw new Error('folders.length has already been validated');
      }

      for (const file of folder.files.values()) {
        totalFiles++;
        functions += file.functions.percent;
        branches += file.branches.percent;
        lines += file.lines.percent;
      }

      for (const subFolder of folder.folders.values()) {
        folders.push(subFolder);
      }
    }

    return (
      {
        functions: totalFiles === 0 ? 100 : functions / totalFiles,
        branches: totalFiles === 0 ? 100 : branches / totalFiles,
        lines: totalFiles === 0 ? 100 : lines / totalFiles,
      }
    );
  }

  // project-rome/@romejs/core/master/testing/TestRunner.ts
class ___R$$priv$project$rome$$romejs$core$master$testing$TestRunner_ts$BridgeStructuredError extends ___R$project$rome$$romejs$v8$errors_ts$NativeStructuredError {
    constructor(struct, bridge) {
      super(struct);
      this.bridge = bridge;
    }
  }

  function ___R$$priv$project$rome$$romejs$core$master$testing$TestRunner_ts$getProgressTestRefText(ref) {
    return '<filelink target="' +
    ref.filename +
    '" />: ' +
    ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(ref.testName);
  }

  class ___R$project$rome$$romejs$core$master$testing$TestRunner_ts$default {
    constructor(opts) {
      this.sources = opts.sources;
      this.reporter = opts.request.reporter;
      this.master = opts.request.master;
      this.cwd = opts.request.client.flags.cwd;
      this.request = opts.request;
      this.options = opts.options;

      this.ignoreBridgeEndError = new Set();

      this.sourcesQueue = Array.from(opts.sources.entries());

      this.coverageCollector = new ___R$project$rome$$romejs$v8$CoverageCollector_ts$default();

      this.progress =
        {
          total: 0,
          started: 0,
          finished: 0,
        };

      this.runningTests = new Map();
      this.testFileCounter = 0;

      this.printer =
        opts.request.createDiagnosticsPrinter(
          {
            category: 'test',
            message: 'Run initiated',
          },
        );
      this.printer.addDiagnostics(opts.addDiagnostics);
    }

    async runWorker({bridge, process, inspector}) {
      const {options: opts, sourcesQueue} = this;
      const req = this.request;
      const {flags} = req.client;

      if (inspector !== undefined && opts.coverage === true) {
        await inspector.call('Profiler.enable');
        await inspector.call(
          'Profiler.startPreciseCoverage',
          {
            // Turning this on disables V8 optimizations https://v8.dev/blog/javascript-code-coverage#precise-coverage-(function-granularity)
            callCount: false,
            // Otherwise coverage will only have function granularity
            detailed: true,
          },
        );
      }

      const nextTest = async () => {
        if (sourcesQueue.length === 0) {
          return undefined;
        }

        const item = sourcesQueue.pop();
        if (item === undefined) {
          throw new Error('testQueue.length was validated above');
        }
        const [filename, {path, code, sourceMap}] = item;

        this.coverageCollector.addSourceMap(filename, code, sourceMap);

        // Source map locations will always be resolved in the worker, but this is in case we need to resolve them in master in the case of an unresponsive worker

        // TODO remove this after test has ran
        const removeSourceMap = ___R$project$rome$$romejs$v8$index_ts$sourceMapManager.addSourceMap(filename, sourceMap);

        const id = this.testFileCounter;
        this.testFileCounter++;

        try {
          await bridge.prepareTest.call(
            {
              id,
              options: opts,
              projectFolder: req.master.projectManager.assertProjectExisting(path).folder.join(),
              file: req.master.projectManager.getTransportFileReference(path),
              cwd: flags.cwd.join(),
              code,
              sourceMap,
            },
          );

          await bridge.runTest.call(id);
        } finally {
          removeSourceMap();
        }

        await nextTest();
      };

      try {
        await nextTest();
      } catch (err) {
        if (err instanceof ___R$project$rome$$romejs$events$BridgeError_ts$default || err instanceof ___R$$priv$project$rome$$romejs$core$master$testing$TestRunner_ts$BridgeStructuredError) {
          if (!this.ignoreBridgeEndError.has(err.bridge)) {
            this.printer.addDiagnostic(
              ___R$project$rome$$romejs$diagnostics$derive_ts$deriveDiagnosticFromError(
                {
                  category: 'tests/timeout',
                  error: err,
                },
              ),
            );
          }
        } else {
          throw err;
        }
      } finally {
        if (inspector !== undefined) {
          if (opts.coverage) {
            if (inspector.alive) {
              const profile = await inspector.call('Profiler.takePreciseCoverage');
              this.coverageCollector.addCoverage(profile.get('result').asAny());

              // Not really necessary but let's clean up anyway for completeness
              await inspector.call('Profiler.stopPreciseCoverage');
              await inspector.call('Profiler.disable');
            } else {
              // TODO log that we failed to fetch some coverage
            }
          }

          inspector.end();
        }

        process.kill();
      }
    }

    async spawnWorker() {
      const proc = ___R$project$rome$$romejs$core$common$utils$fork_ts$default(
        'test-worker',
        {
          stdio: 'pipe',
        },
      );

      const {stdout, stderr} = proc;
      if (stdout == null || stderr == null) {
        throw new Error('stdout or stderr was undefined for a spawned Worker');
      }

      stdout.on(
        'data',
        (chunk) => {
          process.stdout.write(chunk);
        },
      );

      // Suppress any debugger logs
      stderr.on(
        'data',
        (chunk) => {
          const str = chunk.toString();

          if (str.startsWith('Debugger listening on ws://')) {
            return;
          }

          if (str.startsWith('For help, see: https://nodejs.org/en/docs/inspector')) {
            return;
          }

          if (str.startsWith('Debugger attached')) {
            return;
          }

          process.stderr.write(chunk);
        },
      );

      const bridge = ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromChildProcess(
        ___R$project$rome$$romejs$core$common$bridges$TestWorkerBridge_ts$default,
        proc,
        {
          type: 'client',
        },
      );
      await bridge.handshake();

      const {inspectorUrl} = await bridge.inspectorDetails.call();

      let inspector;
      if (inspectorUrl !== undefined) {
        const locInspector = new ___R$project$rome$$romejs$v8$InspectorClient_ts$default(await ___R$project$rome$$romejs$codec$websocket$index_ts$createClient(inspectorUrl));
        inspector = locInspector;
        await locInspector.call('Debugger.enable');

        bridge.endEvent.subscribe(
          () => {
            locInspector.end();
          },
        );
      }

      return (
        {
          bridge,
          process: proc,
          inspector,
        }
      );
    }

    async setupWorkers() {
      const containers = [await this.spawnWorker()];

      // Every 5 seconds, ping the worker and wait a max of 5 seconds, if we receive no response then consider the worker dead
      for (const container of containers) {
        container.bridge.monitorHeartbeat(
          5000,
          async () => {
            this.handleWorkerTimeout('10 seconds', container);
          },
        );
      }

      return containers;
    }

    async init() {
      this.workers = await this.setupWorkers();
      const teardown = this.setupProgress();

      const workerContainers = this.getWorkers();

      await Promise.all(
        workerContainers.map(
          (
            container,
          ) =>
            this.runWorker(container),
        ),
      );

      teardown();

      this.printTestResults();
    }

    async handleWorkerTimeout(duration, container) {
      return (
        new Promise(
          (resolve, reject) => {
            const timeout = setTimeout(
              () => {
                resolve(
                  container.bridge.end(
                    'Test worker was unresponsive for ' +
                    duration +
                    '. We tried to collect some additional metadata but we timed out again trying to fetch it...',
                  ),
                );
              },
              3000,
            );

            this._handleWorkerTimeout(duration, container).then(
              () => {
                clearTimeout(timeout);
                resolve();
              },
            ).catch(
              (err) => {
                clearTimeout(timeout);
                if (err instanceof ___R$project$rome$$romejs$v8$InspectorClient_ts$InspectorClientCloseError) {
                  return (
                    container.bridge.end(
                      'Test worker was unresponsive for ' +
                      duration +
                      '. We tried to collect some additional metadata but the inspector connection closed abruptly',
                    )
                  );
                } else {
                  reject(err);
                }
              },
            );
          },
        )
      );
    }

    async _handleWorkerTimeout(duration, {bridge, inspector}) {
      if (inspector === undefined) {
        bridge.end(
          'Test worker was unresponsive for ' +
          duration +
          '. There was no inspector connected so we were unable to capture stack frames before it was terminated.',
        );
        return undefined;
      }

      inspector.call('Debugger.pause');

      const params = await inspector.wait('Debugger.paused');

      const frames = [];

      const callFrames = params.get('callFrames').asArray().slice(0, 20);
      for (const callFrame of callFrames) {
        const loc = callFrame.get('location');

        const resolved = ___R$project$rome$$romejs$v8$index_ts$sourceMapManager.resolveLocation(
          ___R$project$rome$$romejs$v8$utils_ts$urlToFilename(
            callFrame.get('url').asString(),
          ),
          ___R$project$rome$$romejs$ob1$index_ts$coerce0to1(loc.get('lineNumber').asZeroIndexedNumber()),
          loc.get(
            'columnNumber',
          ).asZeroIndexedNumber(),
        );

        const name = callFrame.get('scopeChain').asArray()[0].get('name').asString('').split(
          '$',
        ).pop();

        frames.push(
          {
            resolvedLocation: resolved.found,
            typeName: undefined,
            functionName: name,
            methodName: undefined,
            filename: resolved.filename,
            lineNumber: resolved.line,
            columnNumber: resolved.column,
            isTopLevel: false,
            isEval: false,
            isNative: false,
            isConstructor: false,
            isAsync: false,
          },
        );
      }

      bridge.endWithError(
        new ___R$$priv$project$rome$$romejs$core$master$testing$TestRunner_ts$BridgeStructuredError(
          {
            message: 'Test worker was unresponsive for <emphasis>' +
            duration +
            '</emphasis>. Possible infinite loop. Below is a stack trace before the test was terminated.',
            frames,
            advice: [
              {
                type: 'log',
                category: 'info',
                message: 'You can find the specific test that caused this by running <command>rome test --sync-tests</command>',
              },
            ],
          },
          bridge,
        ),
      );
    }

    getWorkers() {
      if (this.workers === undefined) {
        throw new Error('TestRunner.init has not been called yet');
      } else {
        return this.workers;
      }
    }

    refToKey(ref) {
      return ref.filename +
      ': ' +
      ref.testName;
    }

    onTestStart(container, ref, timeoutMs) {
      this.progress.started++;

      let timeout = undefined;
      if (timeoutMs !== undefined) {
        timeout =
          setTimeout(
            () => {
              // TODO This will kill the whole worker, maybe it's possible to just terminate the current test? Throw an error, see if the next test was ran, or else terminate completely
              this.handleWorkerTimeout(String(timeoutMs) +
              'ms', container);
            },
            timeoutMs,
          );
      }

      this.runningTests.set(
        this.refToKey(ref),
        {
          ref,
          timeout,
        },
      );
    }

    onTestFound(data, isSkipped) {
      if (isSkipped) {
        return;
      }

      data;
      this.progress.total++;
    }

    onTestFinished(ref) {
      const key = this.refToKey(ref);
      const running = this.runningTests.get(key);
      if (running === undefined) {
        throw new Error('Expected there to be a running test');
      }

      if (running.timeout !== undefined) {
        clearTimeout(running.timeout);
      }
      this.runningTests.delete(key);

      this.progress.finished++;
    }

    setupProgress() {
      const workers = this.getWorkers();

      const progress = this.request.reporter.progress(
        {
          persistent: true,
        },
      );
      progress.setTitle('Running tests');

      for (let i = 0;
      i < workers.length;
      i++) {
        const container = workers[i];
        const {bridge} = container;

        const ourRunningTests = new Set();

        bridge.endEvent.subscribe(
          (error) => {
            // Cancel all currently running tests

            const cancelTests = [];

            for (const key of ourRunningTests) {
              const test = this.runningTests.get(key);
              if (test !== undefined) {
                cancelTests.push(test.ref);
              }
            }

            for (const ref of cancelTests) {
              this.onTestFinished(ref);

              if (cancelTests.length === 1) {
                // If we only have one test to cancel then let's only point the bridge error to this test
                this.ignoreBridgeEndError.add(bridge);

                this.printer.addDiagnostic(
                  Object.assign(
                    {
                    },
                    ___R$project$rome$$romejs$diagnostics$derive_ts$deriveDiagnosticFromError(
                      {
                        label: ref.testName,
                        category: 'tests/failure',
                        filename: ref.filename,
                        error,
                      },
                    ),
                    {
                      // We don't care about the advice
                      advice: [],
                    },
                  ),
                );
              } else {
                this.printer.addDiagnostic(
                  {
                    label: ref.testName,
                    category: 'tests/failure',
                    filename: ref.filename,
                    message: 'Test was cancelled',
                  },
                );
              }
            }
          },
        );

        bridge.testsFound.subscribe(
          (tests) => {
            for (const {ref, isSkipped} of tests) {
              this.onTestFound(ref, isSkipped);
            }
            progress.setTotal(this.progress.total);
          },
        );

        bridge.testStart.subscribe(
          (data) => {
            ourRunningTests.add(this.refToKey(data.ref));
            this.onTestStart(container, data.ref, data.timeout);
            progress.pushText(___R$$priv$project$rome$$romejs$core$master$testing$TestRunner_ts$getProgressTestRefText(data.ref));
          },
        );

        bridge.testError.subscribe(
          (data) => {
            let origin = {
              category: 'test/error',
              message: 'Generated from a test worker without being attached to a test',
            };

            const {ref} = data;
            if (ref !== undefined) {
              const uid = this.master.projectManager.getUid(
                ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
                  ref.filename,
                ),
              );
              origin.message =
                'Generated from the file <filelink target="' +
                uid +
                '" /> and test name "' +
                ref.testName +
                '"';
              this.onTestFinished(ref);
              progress.popText(___R$$priv$project$rome$$romejs$core$master$testing$TestRunner_ts$getProgressTestRefText(ref));
              progress.tick();
            }

            this.printer.addDiagnostic(data.diagnostic, origin);
          },
        );

        bridge.testSuccess.subscribe(
          (data) => {
            this.onTestFinished(data.ref);
            progress.popText(___R$$priv$project$rome$$romejs$core$master$testing$TestRunner_ts$getProgressTestRefText(data.ref));
            progress.tick();
          },
        );
      }

      return (
        function() {
          progress.end();
        }
      );
    }

    printCoverageReport() {
      const {reporter, master} = this;

      // Fetch coverage entries
      const files = this.coverageCollector.generate();
      if (files.length === 0) {
        return undefined;
      }

      reporter.heading('Code coverage');

      // Get the packages associated with all the ran tests, we will filter code coverage to those packages only
      const testedPackages = new Set();
      for (const {path} of this.sources.values()) {
        testedPackages.add(master.memoryFs.getOwnedManifest(path));
      }

      let root = {
        name: undefined,
        folders: new Map(),
        files: new Map(),
      };

      let totalFiles = 0;

      // Turn the flat list of filenames into a directory tree
      for (const file of files) {
        const {filename} = file;

        // Get the absolute filename
        const absolute = master.projectManager.getFilePathFromUid(filename);
        if (absolute === undefined) {
          continue;
        }

        // Filter out untested packages
        const pkg = master.memoryFs.getOwnedManifest(absolute);
        if (testedPackages.has(pkg) === false) {
          continue;
        }

        // TODO maybe filter out test files too?

        // Track unfiltered files
        totalFiles++;

        const filenameParts = filename.split('/');
        const basename = filenameParts.pop();
        if (basename === undefined) {
          throw new Error('Should always be at least one element from a split()');
        }

        let target = root;

        for (const part of filenameParts) {
          const existingFolder = target.folders.get(part);
          if (existingFolder === undefined) {
            const newFolder = {
              name: part,
              folders: new Map(),
              files: new Map(),
            };
            target.folders.set(part, newFolder);
            target = newFolder;
          } else {
            target = existingFolder;
          }
        }

        target.files.set(basename, file);
      }

      // Continuously merge all entries with only a single folder from the root
      while (root.folders.size === 1 && root.files.size === 0) {
        // Awkward way to get the first value out of the folders map...
        const newRoot = root.folders.values().next().value;
        root =
          Object.assign(
            {
            },
            newRoot,
            {
              name: root.name !== undefined && newRoot.name !== undefined
                ? root.name +
                '/' +
                newRoot.name : newRoot.name,
            },
          );
      }

      const rows = [];

      // If there's more than 15 files to show, and we don't have the explicit showAllCoverage flag

      // then truncate the output
      const showAllCoverage = this.options.showAllCoverage || totalFiles < 15;

      function buildRows(folder, depth) {
        const name = folder.name === undefined ? 'All files' : folder.name +
        '/';
        const folderPercent = ___R$project$rome$$romejs$core$master$testing$utils_ts$percentInsideCoverageFolder(folder);

        rows.push(
          [
            ' '.repeat(depth) + ('<emphasis>' +
            name +
            '</emphasis>'),
            ___R$project$rome$$romejs$core$master$testing$utils_ts$formatPercent(folderPercent.functions),
            ___R$project$rome$$romejs$core$master$testing$utils_ts$formatPercent(folderPercent.branches),
            ___R$project$rome$$romejs$core$master$testing$utils_ts$formatPercent(folderPercent.lines),
          ],
        );

        // Don't ever show anything deeper than a single level when showAllCoverage is off
        if (!showAllCoverage && depth > 0) {
          return undefined;
        }

        const fileIndent = ' '.repeat(depth + 1);
        for (const [name, file] of ___R$project$rome$$romejs$core$master$testing$utils_ts$sortMapKeys(folder.files)) {
          let absolute = file.filename;

          // Exchange any UIDs
          const absolutePath = master.projectManager.getFilePathFromUid(
            file.filename,
          );
          if (absolutePath !== undefined) {
            absolute = absolutePath.join();
          }

          rows.push(
            [
              fileIndent + ('<filelink target="' +
              absolute +
              '">' +
              name +
              '</filelink>'),
              ___R$project$rome$$romejs$core$master$testing$utils_ts$formatPercent(file.functions.percent),
              ___R$project$rome$$romejs$core$master$testing$utils_ts$formatPercent(file.branches.percent),
              ___R$project$rome$$romejs$core$master$testing$utils_ts$formatPercent(file.lines.percent),
            ],
          );
        }

        for (const subFolder of ___R$project$rome$$romejs$core$master$testing$utils_ts$sortMapKeys(folder.folders).values()) {
          buildRows(subFolder, depth + 1);
        }
      }

      buildRows(root, 0);

      reporter.table(['File', '% Functions', '% Branches', '% Lines'], rows);

      if (!showAllCoverage) {
        reporter.spacer();
        reporter.info(
          'Additional coverage information available. Refine the executed tests or add the <emphasis>--show-all-coverage</emphasis> flag',
        );
      }

      reporter.hr();
    }

    printTestResults() {
      if (this.printer.hasDiagnostics()) {
        this.throwErrorDiagnosticsPrinter();
      } else {
        this.printTestSuccess();
      }
    }

    printTestSuccess() {
      this.printCoverageReport();
      this.reporter.success(
        'All <emphasis>' +
        ___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(this.progress.total) +
        '</emphasis> tests passed!',
      );
    }

    getSourceCode(filename) {
      const testSource = this.sources.get(filename);
      if (testSource === undefined) {
        return undefined;
      } else {
        return testSource.code;
      }
    }

    throwErrorDiagnosticsPrinter() {
      const {printer} = this;

      // Only show code coverage for errors when `--show-all-coverage` has been passed
      if (this.options.showAllCoverage) {
        printer.onBeforeFooterPrint(
          () => {
            this.printCoverageReport();
          },
        );
      }

      throw printer;
    }
  }

  // project-rome/@romejs/core/master/commands/test.ts
const ___R$project$rome$$romejs$core$master$commands$test_ts$default = ___R$project$rome$$romejs$core$commands_ts$createMasterCommand(
    {
      category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.CODE_QUALITY,
      description: 'run tests',

      defineFlags(c) {
        return (
          {
            coverage: c.get('coverage').asBoolean(true),
            showAllCoverage: c.get('showAllCoverage').asBoolean(false),
            updateSnapshots: c.get('updateSnapshots').asBoolean(false),
            freezeSnapshots: c.get('freezeSnapshots').asBoolean(false),
            syncTests: c.get('syncTests').asBoolean(false),
          }
        );
      },

      async default(req, commandFlags) {
        const {reporter, master} = req;

        const {paths} = await req.getFilesFromArgs(
          {
            getProjectIgnore: (
              project,
            ) =>
              ({
                patterns: project.config.tests.ignore,
                source: master.projectManager.findProjectConfigConsumer(
                  project,
                  (
                    consumer,
                  ) =>
                    consumer.has('tests') && consumer.get('tests').has('ignore')
                      ? consumer.get('tests').get('ignore') : undefined,
                ),
              }),
            getProjectEnabled: (
              project,
            ) =>
              ({
                enabled: project.config.tests.enabled,
                source: master.projectManager.findProjectConfigConsumer(
                  project,
                  (
                    consumer,
                  ) =>
                    consumer.has('tests')
                      ? consumer.get('tests').get('enabled') : undefined,
                ),
              }),
            test: (path) => path.hasExtension('test'),
            noun: 'test',
            verb: 'testing',
            configCategory: 'tests',
            advice: [
              {
                type: 'log',
                category: 'info',
                message: 'Searched for files with <emphasis>.test.*</emphasis> file extension',
              },
            ],
            extensions: ___R$project$rome$$romejs$core$common$fileHandlers_ts$JS_EXTENSIONS,
            disabledDiagnosticCategory: 'tests/disabled',
          },
        );

        if (paths.size === 0) {
          reporter.warn('No tests ran');
          return;
        }

        reporter.info('Bundling test files');

        let addDiagnostics = [];

        const tests = new Map();

        const bundler = new ___R$project$rome$$romejs$core$master$bundler$Bundler_ts$default(
          req,
          req.getBundlerConfigFromFlags(
            {
              mocks: true,
            },
          ),
        );

        for (const [path, res] of await bundler.bundleMultiple(Array.from(paths))) {
          tests.set(
            path.join(),
            {
              code: res.entry.js.content,
              sourceMap: res.entry.sourceMap.map,
              path,
            },
          );
        }

        reporter.info('Running tests');

        const runner = new ___R$project$rome$$romejs$core$master$testing$TestRunner_ts$default(
          {
            addDiagnostics,
            options: {
              coverage: commandFlags.coverage,
              showAllCoverage: commandFlags.showAllCoverage,
              updateSnapshots: commandFlags.updateSnapshots,
              freezeSnapshots: commandFlags.freezeSnapshots,
              syncTests: commandFlags.syncTests,
              verboseDiagnostics: req.query.requestFlags.verboseDiagnostics,
            },
            sources: tests,
            request: req,
          },
        );
        await runner.init();
      },
    },
  );

  // project-rome/@romejs/core/master/commands/ci.ts
const ___R$project$rome$$romejs$core$master$commands$ci_ts$default = ___R$project$rome$$romejs$core$commands_ts$createMasterCommand(
    {
      category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.CODE_QUALITY,
      description: 'run lint and tests',

      async default(req) {
        const {reporter} = req;

        reporter.heading('Running lint');
        const linter = new ___R$project$rome$$romejs$core$master$linter$Linter_ts$default(req, false);
        await linter.lint(false);

        reporter.heading('Running tests');
        await ___R$project$rome$$romejs$core$master$commands$test_ts$default.default(
          req,
          {
            coverage: true,
            freezeSnapshots: true,
            updateSnapshots: false,
            showAllCoverage: true,
            syncTests: false,
          },
        );
      },
    },
  );

  // project-rome/@romejs/core/master/commands/_evict.ts
const ___R$project$rome$$romejs$core$master$commands$_evict_ts$default = ___R$project$rome$$romejs$core$commands_ts$createMasterCommand(
    {
      description: 'evict a file from the memory cache',
      category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.INTERNAL,

      async default(req) {
        const {
          master,
          reporter,
          client,
          query: {args},
        } = req;

        const files = args.length === 0
          ? master.fileAllocator.getAllOwnedFilenames() : args;

        for (const file of files) {
          await master.fileAllocator.evict(client.flags.cwd.resolve(file));
          reporter.success('Evicted ' +
          file);
        }

        reporter.info('Evicted ' +
        String(files.length) +
        ' files');
      },
    },
  );

  // project-rome/@romejs/core/master/commands/_moduleSignature.ts
const ___R$project$rome$$romejs$core$master$commands$_moduleSignature_ts$default = ___R$project$rome$$romejs$core$commands_ts$createMasterCommand(
    {
      category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.INTERNAL,
      description: 'get the module type signature of a file',

      async default(req) {
        const {master, reporter} = req;
        const {args} = req.query;
        req.expectArgumentLength(1);

        const filename = await master.resolver.resolveEntryAssertPath(
          Object.assign(
            {
            },
            req.getResolverOptionsFromFlags(),
            {
              source: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(args[0]),
            },
          ),
          {pointer: req.getDiagnosticPointerFromFlags({type: 'arg', key: 0})},
        );
        reporter.inspect(await req.requestWorkerModuleSignature(filename));
      },
    },
  );

  // project-rome/@romejs/core/master/commands/noop.ts
const ___R$project$rome$$romejs$core$master$commands$noop_ts$default = ___R$project$rome$$romejs$core$commands_ts$createMasterCommand(
    {
      category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.INTERNAL,
      description: 'TODO',

      async default(req) {
        req;
      },
    },
  );

  // project-rome/@romejs/core/master/commands/index.ts
const ___R$project$rome$$romejs$core$master$commands$index_ts$masterCommands = new Map();
  ___R$project$rome$$romejs$core$master$commands$index_ts$masterCommands.set('_moduleSignature', ___R$project$rome$$romejs$core$master$commands$_moduleSignature_ts$default);
  ___R$project$rome$$romejs$core$master$commands$index_ts$masterCommands.set('evict', ___R$project$rome$$romejs$core$master$commands$_evict_ts$default);
  ___R$project$rome$$romejs$core$master$commands$index_ts$masterCommands.set('test', ___R$project$rome$$romejs$core$master$commands$test_ts$default);
  ___R$project$rome$$romejs$core$master$commands$index_ts$masterCommands.set('lint', ___R$project$rome$$romejs$core$master$commands$lint_ts$default);
  ___R$project$rome$$romejs$core$master$commands$index_ts$masterCommands.set('config', ___R$project$rome$$romejs$core$master$commands$config_ts$default);
  ___R$project$rome$$romejs$core$master$commands$index_ts$masterCommands.set('bundle', ___R$project$rome$$romejs$core$master$commands$bundle_ts$default);
  ___R$project$rome$$romejs$core$master$commands$index_ts$masterCommands.set('parse', ___R$project$rome$$romejs$core$master$commands$parse_ts$default);
  ___R$project$rome$$romejs$core$master$commands$index_ts$masterCommands.set('analyzeDependencies', ___R$project$rome$$romejs$core$master$commands$analyzeDependencies_ts$default);
  ___R$project$rome$$romejs$core$master$commands$index_ts$masterCommands.set('resolve', ___R$project$rome$$romejs$core$master$commands$resolve_ts$default);
  ___R$project$rome$$romejs$core$master$commands$index_ts$masterCommands.set('compile', ___R$project$rome$$romejs$core$master$commands$compile_ts$default);
  ___R$project$rome$$romejs$core$master$commands$index_ts$masterCommands.set('stop', ___R$project$rome$$romejs$core$master$commands$stop_ts$default);
  ___R$project$rome$$romejs$core$master$commands$index_ts$masterCommands.set('status', ___R$project$rome$$romejs$core$master$commands$status_ts$default);
  ___R$project$rome$$romejs$core$master$commands$index_ts$masterCommands.set('run', ___R$project$rome$$romejs$core$master$commands$run_ts$default);
  ___R$project$rome$$romejs$core$master$commands$index_ts$masterCommands.set('publish', ___R$project$rome$$romejs$core$master$commands$publish_ts$default);
  ___R$project$rome$$romejs$core$master$commands$index_ts$masterCommands.set('ci', ___R$project$rome$$romejs$core$master$commands$ci_ts$default);
  ___R$project$rome$$romejs$core$master$commands$index_ts$masterCommands.set('develop', ___R$project$rome$$romejs$core$master$commands$develop_ts$default);
  ___R$project$rome$$romejs$core$master$commands$index_ts$masterCommands.set('format', ___R$project$rome$$romejs$core$master$commands$format_ts$default);
  ___R$project$rome$$romejs$core$master$commands$index_ts$masterCommands.set('_noop', ___R$project$rome$$romejs$core$master$commands$noop_ts$default);

  // project-rome/@romejs/core/common/utils/setupGlobalErrorHandlers.ts
function ___R$project$rome$$romejs$core$common$utils$setupGlobalErrorHandlers_ts$default(
    callback,
  ) {
    const onUncaughtException = (err) => {
      callback(err);
    };
    process.on('uncaughtException', onUncaughtException);

    const onUnhandledRejection = (
      reason,
      promise,
    ) => {
      console.log(reason, promise);
      promise.then(
        () => {
          throw new Error('Promise is rejected so should never hit this condition');
        },
      ).catch(
        (err) => {
          callback(err);
        },
      );
    };
    process.on('unhandledRejection', onUnhandledRejection);

    return (
      () => {
        process.removeListener('uncaughtException', onUncaughtException);
        process.removeListener('unhandledRejection', onUnhandledRejection);
      }
    );
  }

  // project-rome/@romejs/core/common/userConfig.ts
const ___R$project$rome$$romejs$core$common$userConfig_ts$DEFAULT_USER_CONFIG = {
    cachePath: ___R$project$rome$$romejs$path$index_ts$TEMP_PATH.append('rome-' +
    ___R$project$rome$$romejs$core$common$constants_ts$VERSION),
  };

  function ___R$project$rome$$romejs$core$common$userConfig_ts$loadUserConfig() {
    for (const configFilename of ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_FILENAMES) {
      const configPath = ___R$project$rome$$romejs$path$index_ts$HOME_PATH.append(['.config', configFilename]);

      if (!___R$project$rome$$romejs$fs$index_ts$existsSync(configPath)) {
        continue;
      }

      const configFile = ___R$project$rome$$romejs$fs$index_ts$readFileTextSync(configPath);
      const consumer = ___R$project$rome$$romejs$codec$json$index_ts$consumeJSON(
        {
          path: configPath,
          input: configFile,
        },
      );

      const userConfig = Object.assign(
        {
        },
        ___R$project$rome$$romejs$core$common$userConfig_ts$DEFAULT_USER_CONFIG,
      );

      if (consumer.has('cachePath')) {
        userConfig.cachePath =
          ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
            consumer.get('cachePath').asString(),
          );
      }

      consumer.enforceUsedProperties('config property');

      return userConfig;
    }

    return ___R$project$rome$$romejs$core$common$userConfig_ts$DEFAULT_USER_CONFIG;
  }

  // project-rome/@romejs/core/master/Master.ts
const ___R$$priv$project$rome$$romejs$core$master$Master_ts$STDOUT_MAX_CHUNK_LENGTH = 100000;

  class ___R$project$rome$$romejs$core$master$Master_ts$default {
    constructor(opts) {
      this.onFatalErrorBound = this.onFatalError.bind(this);

      this.profiling = undefined;
      this.options = opts;

      this.userConfig = ___R$project$rome$$romejs$core$common$userConfig_ts$loadUserConfig();

      this.fileChangeEvent =
        new ___R$project$rome$$romejs$events$Event_ts$default(
          {
            name: 'Master.fileChange',
            onError: this.onFatalErrorBound,
          },
        );

      this.clientStartEvent =
        new ___R$project$rome$$romejs$events$Event_ts$default(
          {
            name: 'Master.clientStart',
            onError: this.onFatalErrorBound,
          },
        );

      this.requestStartEvent =
        new ___R$project$rome$$romejs$events$Event_ts$default(
          {
            name: 'Master.requestStart',
            onError: this.onFatalErrorBound,
          },
        );

      this.logEvent =
        new ___R$project$rome$$romejs$events$Event_ts$default(
          {
            name: 'Master.log',
            onError: this.onFatalErrorBound,
          },
        );

      this.endEvent =
        new ___R$project$rome$$romejs$events$Event_ts$default(
          {
            name: 'Master.end',
            onError: this.onFatalErrorBound,
            serial: true,
          },
        );

      this.logger =
        new ___R$project$rome$$romejs$core$common$utils$Logger_ts$default(
          'master',
          () => {
            return (
              this.logEvent.hasSubscribers() ||
              this.connectedClientsListeningForLogs.size > 0
            );
          },
          {
            streams: [
              {
                type: 'all',
                format: 'none',
                columns: 0,
                write: (chunk) => {
                  this.emitMasterLog(chunk);
                },
              },
            ],
          },
        );

      this.connectedReporters =
        new ___R$project$rome$$romejs$cli$reporter$Reporter_ts$default(
          {
            wrapperFactory: this.wrapFatal.bind(this),
          },
        );

      this.connectedClientsListeningForLogs = new Set();
      this.connectedClients = new Set();

      this.memoryFs = new ___R$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$default(this);
      this.projectManager = new ___R$project$rome$$romejs$core$master$project$ProjectManager_ts$default(this);
      this.workerManager = new ___R$project$rome$$romejs$core$master$WorkerManager_ts$default(this);
      this.fileAllocator = new ___R$project$rome$$romejs$core$master$fs$FileAllocator_ts$default(this);
      this.resolver = new ___R$project$rome$$romejs$core$master$fs$Resolver_ts$default(this);
      this.cache = new ___R$project$rome$$romejs$core$master$Cache_ts$default(this);

      this.memoryFs.deletedFileEvent.subscribe(
        (path) => {
          return this.handleFileDelete(path);
        },
      );

      this.memoryFs.changedFileEvent.subscribe(
        ({path}) => {
          return this.handleFileChange(path);
        },
      );

      this.warnedCacheClients = new WeakSet();

      this.clientIdCounter = 0;

      this.requestRunningCounter = 0;
      this.terminateWhenIdle = false;
    }

    emitMasterLog(chunk) {
      this.logEvent.send(chunk);

      for (const {bridge} of this.connectedClientsListeningForLogs) {
        bridge.log.send({chunk, origin: 'master'});
      }
    }

    onFatalError(err) {
      const message = '<emphasis>Fatal error occurred</emphasis>: ' +
      ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(
        err.stack || err.message,
      );
      this.logger.error(message);
      this.connectedReporters.error(message);
      process.exit();
    }

    // rome-suppress lint/noExplicitAny
    wrapFatal(callback) {
      // rome-suppress lint/noExplicitAny
      return (
        (((...args) => {
          try {
            const res = callback.apply(null, [
              ...args,
            ]);
            if (res instanceof Promise) {
              res.catch(this.onFatalErrorBound);
            }
            return res;
          } catch (err) {
            throw this.onFatalError(err);
          }
        }))
      );
    }

    async handleDisconnectedDiagnostics(diagnostics) {
      this.connectedReporters.error(
        'Generated diagnostics without a current request',
      );
      const printer = new ___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$default(
        {
          origins: [],
          reporter: this.connectedReporters,
          readFile: this.readDiagnosticsPrinterFile.bind(this),
        },
      );
      printer.addDiagnostics(diagnostics);
      await printer.print();
    }

    readDiagnosticsPrinterFile(path) {
      const remoteToLocal = this.projectManager.remoteToLocalPath.get(path);

      if (remoteToLocal === undefined) {
        return ___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$readDiagnosticsFileLocal(path);
      } else {
        return ___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$readDiagnosticsFileLocal(remoteToLocal);
      }
    }

    createDisconnectedDiagnosticsProcessor(origins) {
      return (
        new ___R$project$rome$$romejs$diagnostics$DiagnosticsProcessor_ts$default(
          {
            onDiagnostics: (diagnostics) => {
              this.handleDisconnectedDiagnostics(diagnostics);
            },
            origins: [
              ...origins,
              {
                category: 'master',
                message: 'Created disconnected diagnostics collector',
              },
            ],
          },
        )
      );
    }

    maybeSetupGlobalErrorHandlers() {
      if (!this.options.globalErrorHandlers) {
        return;
      }

      const teardown = ___R$project$rome$$romejs$core$common$utils$setupGlobalErrorHandlers_ts$default(
        (err) => {
          this.onFatalError(err);
        },
      );

      this.endEvent.subscribe(
        () => {
          teardown();
        },
      );
    }

    async init() {
      this.maybeSetupGlobalErrorHandlers();
      this.memoryFs.init();
      await this.projectManager.init();
      this.fileAllocator.init();
      this.resolver.init();
      await this.cache.init();
      await this.workerManager.init();
    }

    async end() {
      // We should remove everything that has an external dependency like a socket or process

      // TODO terminate all queries in flight

      await this.endEvent.callOptional();
      this.workerManager.end();
      this.memoryFs.unwatchAll();
    }

    async attachToBridge(bridge) {
      let profiler;

      // If we aren't a dedicated process then we should only expect a single connection

      // and when that ends. End the Master.
      if (this.options.dedicated === false) {
        bridge.endEvent.subscribe(
          () => {
            this.end();
          },
        );
      }

      bridge.profilingStart.subscribe(
        async (data) => {
          if (profiler !== undefined) {
            throw new Error('Expected no profiler to be running');
          }
          profiler = new ___R$project$rome$$romejs$v8$Profiler_ts$default();
          await profiler.startProfiling(data.samplingInterval);
          this.profiling = data;
          for (const {bridge} of this.workerManager.getExternalWorkers()) {
            await bridge.profilingStart.call(data);
          }
        },
      );

      bridge.profilingStop.subscribe(
        async () => {
          if (profiler === undefined) {
            throw new Error('Expected profiler to be running');
          }
          const masterProfile = await profiler.stopProfiling();
          profiler = undefined;
          this.profiling = undefined;
          return masterProfile;
        },
      );

      bridge.profilingGetWorkers.subscribe(
        async () => {
          const ids = [];
          for (const {id} of this.workerManager.getExternalWorkers()) {
            ids.push(id);
          }
          return ids;
        },
      );

      bridge.profilingStopWorker.subscribe(
        async (id) => {
          const worker = this.workerManager.getWorkerAssert(id);
          return await worker.bridge.profilingStop.call();
        },
      );

      await bridge.handshake();

      const client = await this.createClient(bridge);

      if (client.version !== ___R$project$rome$$romejs$core$common$constants_ts$VERSION) {
        // TODO this wont ever actually be printed?
        client.reporter.error(
          'Client version ' +
          client.version +
          ' does not match server version ' +
          ___R$project$rome$$romejs$core$common$constants_ts$VERSION +
          '. Goodbye lol.',
        );
        client.bridge.end();
        return;
      }

      await this.clientStartEvent.callOptional(client);

      bridge.query.subscribe(
        async (request) => {
          return await this.handleRequest(client, request);
        },
      );
    }

    async createClient(bridge) {
      const {
        flags: rawFlags,
        useRemoteReporter,
        hasClearScreen,
        columns,
        format,
        version,
      } = await bridge.getClientInfo.call();

      // Turn the cwd back into a AbsoluteFilePath
      const flags = Object.assign(
        {
        },
        rawFlags,
        {
          cwd: ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(rawFlags.cwd),
        },
      );

      const outStream = {
        type: 'out',
        columns,
        format,
        write(chunk) {
          if (flags.silent === true) {
            return;
          }

          // Split up stdout chunks
          if (chunk.length < ___R$$priv$project$rome$$romejs$core$master$Master_ts$STDOUT_MAX_CHUNK_LENGTH) {
            bridge.stdout.send(chunk);
          } else {
            while (chunk.length > 0) {
              const subChunk = chunk.slice(0, ___R$$priv$project$rome$$romejs$core$master$Master_ts$STDOUT_MAX_CHUNK_LENGTH);
              chunk = chunk.slice(___R$$priv$project$rome$$romejs$core$master$Master_ts$STDOUT_MAX_CHUNK_LENGTH);
              bridge.stdout.send(subChunk);
            }
          }
        },
      };

      const errStream = Object.assign(
        {
        },
        outStream,
        {
          type: 'error',

          write(chunk) {
            bridge.stderr.send(chunk);
          },
        },
      );

      bridge.setColumns.subscribe(
        (columns) => {
          reporter.setStreamColumns([outStream, errStream], columns);
        },
      );

      // Initialize the reporter
      const reporter = new ___R$project$rome$$romejs$cli$reporter$Reporter_ts$default(
        {
          hasClearScreen,
          wrapperFactory: this.wrapFatal.bind(this),
          streams: [outStream, errStream],
          verbose: flags.verbose,
          silent: flags.silent,
          markupOptions: {
            cwd: flags.cwd,
            humanizeFilename: (filename) => {
              const path = ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(filename);
              if (path.isAbsolute()) {
                const remote = this.projectManager.getRemoteFromLocalPath(
                  path.assertAbsolute(),
                );
                if (remote !== undefined) {
                  return remote.join();
                }
              }
            },
            normalizeFilename: (filename) => {
              const path = this.projectManager.getFilePathFromUid(filename);
              if (path === undefined) {
                return filename;
              } else {
                return path.join();
              }
            },
          },
          useRemoteProgressBars: useRemoteReporter,
        },
      );

      reporter.sendRemoteClientMessage.subscribe(
        (msg) => {
          bridge.reporterRemoteServerMessage.send(msg);
        },
      );

      bridge.reporterRemoteClientMessage.subscribe(
        (msg) => {
          reporter.receivedRemoteServerMessage(msg);
        },
      );

      // Add reporter to connected set, important logs may be output to these
      this.connectedReporters.addStream(errStream);
      this.connectedReporters.addStream(outStream);

      const client = {
        id: this.clientIdCounter++,
        bridge,
        reporter,
        flags,
        version,
      };

      this.connectedClients.add(client);

      // When enableWorkerLogs is called we setup subscriptions to the worker logs

      // Logs are never transported from workers to the master unless there is a subscription
      let subscribedWorkers = false;
      bridge.enableWorkerLogs.subscribe(
        () => {
          // enableWorkerLogs could be called twice in the case of `--logs --rage`. We'll only want to setup the subscriptions once
          if (subscribedWorkers) {
            return;
          } else {
            subscribedWorkers = true;
          }

          function onLog(chunk) {
            bridge.log.call({origin: 'worker', chunk});
          }

          // Add on existing workers if there are any
          for (const worker of this.workerManager.getWorkers()) {
            bridge.attachEndSubscriptionRemoval(worker.bridge.log.subscribe(onLog));
          }

          // Listen for logs for any workers that start later
          this.workerManager.workerStartEvent.subscribe(
            (worker) => {
              bridge.attachEndSubscriptionRemoval(worker.log.subscribe(onLog));
            },
          );
        },
      );

      bridge.updatedListenersEvent.subscribe(
        (listeners) => {
          if (listeners.has('log')) {
            this.connectedClientsListeningForLogs.add(client);
          } else {
            this.connectedClientsListeningForLogs.delete(client);
          }
        },
      );

      bridge.endEvent.subscribe(
        () => {
          this.connectedClients.delete(client);
          this.connectedClientsListeningForLogs.delete(client);
          this.connectedReporters.removeStream(errStream);
          this.connectedReporters.removeStream(outStream);
        },
      );

      return client;
    }

    async handleFileDelete(path) {
      this.logger.info('[Master] File delete:', path.join());
      this.fileChangeEvent.send(path);
    }

    async handleFileChange(path) {
      this.logger.info('[Master] File change:', path.join());
      this.fileChangeEvent.send(path);
    }

    async handleRequest(client, partialQuery) {
      const requestFlags = Object.assign(
        {
        },
        ___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS,
        partialQuery.requestFlags,
      );

      const query = {
        commandName: partialQuery.command,
        args: partialQuery.args === undefined ? [] : partialQuery.args,
        noData: partialQuery.noData === true,
        requestFlags,
        silent: partialQuery.silent === true || requestFlags.benchmark,
        terminateWhenIdle: partialQuery.terminateWhenIdle === true,
        commandFlags: partialQuery.commandFlags === undefined
          ? {} : partialQuery.commandFlags,
      };

      const {bridge} = client;
      this.logger.info('[Master] Handling CLI request:', query);

      // Create a promise for the client dying so we can race it later
      let bridgeEndEvent;
      const bridgeEndPromise = new Promise(
        (resolve, reject) => {
          bridgeEndEvent =
            bridge.endEvent.subscribe(
              (err) => {
                reject(err);
              },
            );
        },
      );
      if (bridgeEndEvent === undefined) {
        throw new Error('Expected bridgeEndEvent to have been initialized');
      }

      // Support a silent option on requests so they don't write output
      let reporter = client.reporter;
      if (query.silent) {
        reporter =
          reporter.fork(
            {
              streams: [],
            },
          );
      }

      // Create master request wrapper which is just a bucket of objects
      const req = new ___R$project$rome$$romejs$core$master$MasterRequest_ts$default(
        {
          client,
          query,
          master: this,
          reporter,
          bridge,
        },
      );

      // Hook used by the web server to track and collect master requests
      await this.requestStartEvent.callOptional(req);

      // Track the amount of running queries for terminateWhenIdle
      this.requestRunningCounter++;

      // Sometimes we'll want to terminate the process once all queries have finished
      if (query.terminateWhenIdle) {
        this.terminateWhenIdle = true;
      }

      try {
        const res = await this.dispatchRequest(
          req,
          bridgeEndPromise,
          [],
        );

        req.teardown(res);

        // If the query asked for no data then strip all diagnostics and data values
        if (query.noData) {
          if (res.type === 'SUCCESS') {
            return (
              {
                type: 'SUCCESS',
                hasData: res.data !== undefined,
                data: undefined,
                markers: res.markers,
              }
            );
          } else if (res.type === 'DIAGNOSTICS') {
            return (
              {
                type: 'DIAGNOSTICS',
                diagnostics: [],
              }
            );
          } else if (res.type === 'INVALID_REQUEST') {
            return (
              {
                type: 'INVALID_REQUEST',
                diagnostics: [],
              }
            );
          }
        }

        return res;
      } finally {
        this.requestRunningCounter--;

        this.logger.info('[Master] Replying to CLI request:', query);

        // We no longer care if the client dies
        bridgeEndEvent.unsubscribe();

        // If we're waiting to terminate ourselves when idle, then do so when there's no running requests
        if (this.terminateWhenIdle && this.requestRunningCounter === 0) {
          this.end();
        }
      }
    }

    async dispatchBenchmarkRequest(req, bridgeEndPromise) {
      const {client} = req;
      const {reporter} = client;
      const {benchmarkIterations} = req.query.requestFlags;

      // Warmup
      const warmupStart = Date.now();
      const result = await this.dispatchRequest(
        req,
        bridgeEndPromise,
        [
          'benchmark',
        ],
      );
      const warmupTook = Date.now() - warmupStart;

      // Benchmark
      const progress = client.reporter.progress();
      progress.setTitle('Running benchmark');
      progress.setTotal(benchmarkIterations);
      const benchmarkStart = Date.now();
      for (let i = 0;
      i < benchmarkIterations;
      i++) {
        await this.dispatchRequest(req, bridgeEndPromise, ['benchmark']);
        progress.tick();
      }
      progress.end();
      const benchmarkTook = Date.now() - benchmarkStart;

      reporter.section(
        'Benchmark results',
        () => {
          reporter.info(
            'Request artifacts may have been cached after the first run, artificially decreasing subsequent run time',
          );
          reporter.heading('Query');
          reporter.inspect(req.query);
          reporter.heading('Stats');
          reporter.list(
            [
              'Warmup took <duration emphasis>' +
              warmupTook +
              '</duration>',
              '<number emphasis>' +
              benchmarkIterations +
              '</number> runs',
              '<duration emphasis>' +
              benchmarkTook +
              '</duration> total',
              '<duration emphasis approx>' +
              benchmarkTook / benchmarkIterations +
              '</duration> per run',
            ],
          );
        },
      );

      return result;
    }

    async dispatchRequest(req, bridgeEndPromise, origins) {
      const {query, reporter, bridge} = req;

      if (query.requestFlags.benchmark && !origins.includes('benchmark')) {
        return this.dispatchBenchmarkRequest(req, bridgeEndPromise);
      }

      const markers = [];

      if (query.requestFlags.collectMarkers) {
        req.markerEvent.subscribe(
          (marker) => {
            markers.push(marker);
          },
        );
      }

      try {
        const defaultCommandFlags = {};

        // A type-safe wrapper for retrieving command flags

        // TODO perhaps present this as JSON or something if this isn't a request from the CLI?
        const commandFlagsConsumer = ___R$project$rome$$romejs$consume$index_ts$consume(
          {
            filePath: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath('argv'),
            parent: undefined,
            value: query.commandFlags,
            onDefinition(def) {
              // objectPath should only have a depth of 1
              defaultCommandFlags[def.objectPath[0]] = def.default;
            },

            objectPath: [],
            context: {
              category: 'flags/invalid',

              getOriginalValue: () => {
                return undefined;
              },

              getDiagnosticPointer: (keys) => {
                return (
                  req.getDiagnosticPointerFromFlags(
                    {
                      type: 'flag',
                      key: String(keys[0]),
                      target: 'value',
                    },
                  )
                );
              },
            },
          },
        );

        // An array of promises that we'll race, the only promise that will ever resolve will be the command one
        let promises = [bridgeEndPromise];

        // Get command
        const commandOpts = ___R$project$rome$$romejs$core$master$commands$index_ts$masterCommands.get(query.commandName);
        if (commandOpts) {
          // Warn about disabled disk caching
          if (process.env.ROME_CACHE === '0' &&
            !this.warnedCacheClients.has(
              bridge,
            )) {
            reporter.warn(
              'Disk caching has been disabled due to the <emphasis>ROME_CACHE=0</emphasis> environment variable',
            );
            this.warnedCacheClients.add(bridge);
          }

          let commandFlags;
          if (commandOpts.defineFlags !== undefined) {
            commandFlags = commandOpts.defineFlags(commandFlagsConsumer);
          }

          req.setNormalizedCommandFlags(
            {
              flags: commandFlags,
              defaultFlags: defaultCommandFlags,
            },
          );

          // @ts-ignore
          const commandPromise = commandOpts.default(req, commandFlags);
          promises.push(commandPromise);

          await Promise.race(promises);

          // Only the command promise should have won the race with a resolve
          const data = await commandPromise;
          return (
            {
              type: 'SUCCESS',
              hasData: data !== undefined,
              data,
              markers,
            }
          );
        } else {
          throw new Error('Unknown command ' +
          String(query.commandName));
        }
      } catch (err) {
        let diagnostics = await this.handleRequestError(
          req,
          err,
        );

        if (diagnostics === undefined) {
          return (
            {
              type: 'ERROR',
              fatal: false,
              handled: true,
              name: err.name,
              message: err.message,
              stack: err.stack,
            }
          );
        } else if (diagnostics.length === 0) {
          // Maybe DIAGNOSTICS and an empty array still makes sense instead of SUCCESS?
          return (
            {
              type: 'SUCCESS',
              hasData: false,
              data: undefined,
              markers,
            }
          );
        } else {
          if (err instanceof ___R$project$rome$$romejs$core$master$MasterRequest_ts$MasterRequestInvalid) {
            return (
              {
                type: 'INVALID_REQUEST',
                diagnostics,
              }
            );
          } else {
            return (
              {
                type: 'DIAGNOSTICS',
                diagnostics,
              }
            );
          }
        }
      }
    }

    async handleRequestError(req, rawErr) {
      let err = rawErr;

      // If we can derive diagnostics from the error then create a diagnostics printer
      const diagnostics = ___R$project$rome$$romejs$diagnostics$errors_ts$getDiagnosticsFromError(err);
      if (diagnostics !== undefined) {
        const printer = req.createDiagnosticsPrinter(
          {
            category: 'internal',
            message: 'Derived diagnostics from thrown error',
          },
        );
        printer.addDiagnostics(diagnostics);
        err = printer;
      }

      // Print it!
      if (err instanceof ___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$default) {
        const printer = err;
        if (req.bridge.alive) {
          await printer.print();

          // Don't output the footer if this is a notifier for an invalid request as it will be followed by a help screen
          if (!(rawErr instanceof ___R$project$rome$$romejs$core$master$MasterRequest_ts$MasterRequestInvalid)) {
            printer.footer();
          }
        }
        return printer.getDiagnostics();
      }

      if (!req.bridge.alive) {
        return;
      }

      const printer = req.createDiagnosticsPrinter(
        {
          category: 'internal',
          message: 'Error captured and converted into a diagnostic',
        },
      );
      const errorDiag = ___R$project$rome$$romejs$diagnostics$derive_ts$deriveDiagnosticFromError(
        {
          category: 'internalError/request',
          error: err,
        },
      );
      printer.addDiagnostic(
        Object.assign(
          {
          },
          errorDiag,
          {
            advice: [...(errorDiag.advice || []), ___R$project$rome$$romejs$diagnostics$constants_ts$INTERNAL_ERROR_LOG_ADVICE],
          },
        ),
      );
      await printer.print();

      // We could probably return printer.getDiagnostics() but we just want to print to the console

      // We will still want to send the `error` property
      return;
    }
  }

  // project-rome/@romejs/codec-tar/index.ts
const ___R$$priv$project$rome$$romejs$codec$tar$index_ts$stream = require(
    'stream',
  );

  const ___R$$priv$project$rome$$romejs$codec$tar$index_ts$END_OF_TAR = Buffer.alloc(1024);
  const ___R$$priv$project$rome$$romejs$codec$tar$index_ts$ZEROS = '0000000000000000000';
  const ___R$$priv$project$rome$$romejs$codec$tar$index_ts$SEVENS = '7777777777777777777';
  const ___R$$priv$project$rome$$romejs$codec$tar$index_ts$ZERO_OFFSET = '0'.charCodeAt(0);
  const ___R$$priv$project$rome$$romejs$codec$tar$index_ts$USTAR = 'ustar\x0000';
  const ___R$$priv$project$rome$$romejs$codec$tar$index_ts$MASK = 4095;
  const ___R$$priv$project$rome$$romejs$codec$tar$index_ts$DMODE = 493;
  const ___R$$priv$project$rome$$romejs$codec$tar$index_ts$FMODE = 420;

  function ___R$$priv$project$rome$$romejs$codec$tar$index_ts$encodeOct(num, n) {
    const oct = num.toString(8);
    if (oct.length > n) {
      return ___R$$priv$project$rome$$romejs$codec$tar$index_ts$SEVENS.slice(0, n) +
      ' ';
    } else {
      return '' +
      ___R$$priv$project$rome$$romejs$codec$tar$index_ts$ZEROS.slice(0, n - oct.length) +
      oct +
      ' ';
    }
  }

  function ___R$$priv$project$rome$$romejs$codec$tar$index_ts$checksum(block) {
    let sum = 8 * 32;
    for (let i = 0;
    i < 148;
    i++) {
      sum += block[i];
    }
    for (let j = 156;
    j < 512;
    j++) {
      sum += block[j];
    }
    return sum;
  }

  function ___R$$priv$project$rome$$romejs$codec$tar$index_ts$toTypeflag(type) {
    switch (type) {
      case 'file':
        return 0;
      case 'link':
        return 1;
      case 'symlink':
        return 2;
      case 'character-device':
        return 3;
      case 'block-device':
        return 4;
      case 'directory':
        return 5;
      case 'fifo':
        return 6;
      case 'contiguous-file':
        return 7;
    }

    return 0;
  }

  function ___R$$priv$project$rome$$romejs$codec$tar$index_ts$encodeHeader(header) {
    const buf = Buffer.alloc(512);

    let name = header.name;
    let prefix = '';

    if (Buffer.byteLength(name) !== name.length) {
      throw (
        new Error(
          'utf-8 filename is only supported in PAX, we only support USTAR',
        )
      );
    }

    // If a filename is over 100 characters then split it up if possible (requires a directory)
    while (Buffer.byteLength(name) > 100) {
      const i = name.indexOf('/');
      if (i === -1) {
        throw (
          new Error(
            'filename is too long for USTAR and it was in no directory',
          )
        );
      }

      prefix += prefix ? '/' +
      name.slice(0, i) : name.slice(0, i);
      name = name.slice(i + 1);
    }

    if (Buffer.byteLength(name) > 100) {
      throw new Error('filename is too long for USTAR');
    }

    if (Buffer.byteLength(prefix) > 155) {
      throw new Error('prefix is too long for USTAR');
    }

    if (header.linkname !== undefined && Buffer.byteLength(header.linkname) > 100) {
      throw new Error('linkname is too long for USTAR');
    }

    buf.write(name);
    buf.write(___R$$priv$project$rome$$romejs$codec$tar$index_ts$encodeOct(header.mode & ___R$$priv$project$rome$$romejs$codec$tar$index_ts$MASK, 6), 100);
    buf.write(___R$$priv$project$rome$$romejs$codec$tar$index_ts$encodeOct(header.uid, 6), 108);
    buf.write(___R$$priv$project$rome$$romejs$codec$tar$index_ts$encodeOct(header.gid, 6), 116);
    buf.write(___R$$priv$project$rome$$romejs$codec$tar$index_ts$encodeOct(header.size, 11), 124);
    buf.write(___R$$priv$project$rome$$romejs$codec$tar$index_ts$encodeOct(header.mtime.getTime() / 1000 | 0, 11), 136);

    buf[156] = ___R$$priv$project$rome$$romejs$codec$tar$index_ts$ZERO_OFFSET + ___R$$priv$project$rome$$romejs$codec$tar$index_ts$toTypeflag(header.type);

    if (header.linkname !== undefined) {
      buf.write(header.linkname, 157);
    }

    buf.write(___R$$priv$project$rome$$romejs$codec$tar$index_ts$USTAR, 257);
    if (header.uname !== undefined) {
      buf.write(header.uname, 265);
    }
    if (header.gname !== undefined) {
      buf.write(header.gname, 297);
    }
    buf.write(___R$$priv$project$rome$$romejs$codec$tar$index_ts$encodeOct(header.devmajor || 0, 6), 329);
    buf.write(___R$$priv$project$rome$$romejs$codec$tar$index_ts$encodeOct(header.devminor || 0, 6), 337);

    if (prefix !== '') {
      buf.write(prefix, 345);
    }

    buf.write(___R$$priv$project$rome$$romejs$codec$tar$index_ts$encodeOct(___R$$priv$project$rome$$romejs$codec$tar$index_ts$checksum(buf), 6), 148);

    return buf;
  }

  class ___R$project$rome$$romejs$codec$tar$index_ts$TarWriter {
    constructor(stream) {
      this.finalized = false;
      this.stream = stream;
    }

    static normalizeHeader(partial, size) {
      let mode = partial.mode;
      if (mode === undefined) {
        if (partial.type === 'directory') {
          mode = ___R$$priv$project$rome$$romejs$codec$tar$index_ts$DMODE;
        } else {
          mode = ___R$$priv$project$rome$$romejs$codec$tar$index_ts$FMODE;
        }
      }

      return (
        {
          name: partial.name,
          size,
          mode,
          mtime: partial.mtime === undefined ? new Date() : partial.mtime,
          type: partial.type === undefined ? 'file' : partial.type,
          linkname: partial.linkname,
          uid: partial.uid === undefined ? 0 : partial.uid,
          gid: partial.gid === undefined ? 0 : partial.gid,
          uname: partial.uname,
          gname: partial.gname,
          devmajor: partial.devmajor === undefined ? 0 : partial.devmajor,
          devminor: partial.devminor === undefined ? 0 : partial.devminor,
        }
      );
    }

    overflow(size) {
      size &= 511;
      if (size > 0) {
        this.stream.write(___R$$priv$project$rome$$romejs$codec$tar$index_ts$END_OF_TAR.slice(0, 512 - size));
      }
    }

    append(rawHeader, rawBuffer) {
      if (this.finalized) {
        throw new Error('Already finalized file');
      }

      const buffer = rawBuffer instanceof Buffer
        ? rawBuffer : Buffer.from(rawBuffer);
      const header = ___R$project$rome$$romejs$codec$tar$index_ts$TarWriter.normalizeHeader(rawHeader, buffer.length);

      this.stream.write(___R$$priv$project$rome$$romejs$codec$tar$index_ts$encodeHeader(header));
      this.stream.write(buffer);
      this.overflow(header.size);
    }

    finalize() {
      this.finalized = true;

      return (
        new Promise(
          (resolve, reject) => {
            const {stream} = this;

            stream.on(
              'close',
              () => {
                resolve();
              },
            );

            stream.on(
              'error',
              (err) => {
                reject(err);
              },
            );

            stream.write(___R$$priv$project$rome$$romejs$codec$tar$index_ts$END_OF_TAR);
            stream.end();
          },
        )
      );
    }
  }

  // project-rome/@romejs/core/client/Client.ts
const ___R$$priv$project$rome$$romejs$core$client$Client_ts$stream = require(
    'stream',
  );
  const ___R$$priv$project$rome$$romejs$core$client$Client_ts$net = require(
    'net',
  );
  const ___R$$priv$project$rome$$romejs$core$client$Client_ts$zlib = require(
    'zlib',
  );
  const ___R$$priv$project$rome$$romejs$core$client$Client_ts$fs = require(
    'fs',
  );
  const ___R$$priv$project$rome$$romejs$core$client$Client_ts$child = require(
    'child_process',
  );
  function ___R$project$rome$$romejs$core$client$Client_ts$getFilenameTimestamp() {
    return new Date().toISOString().replace(/[^0-9a-zA-Z]/g, '');
  }

  const ___R$$priv$project$rome$$romejs$core$client$Client_ts$NEW_SERVER_INIT_TIMEOUT = 10000;

  class ___R$project$rome$$romejs$core$client$Client_ts$default {
    constructor(opts) {
      this.options = opts;
      this.userConfig = ___R$project$rome$$romejs$core$common$userConfig_ts$loadUserConfig();

      this.flags =
        Object.assign(
          {
          },
          ___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_FLAGS,
          opts.flags,
        );

      this.requestResponseEvent =
        new ___R$project$rome$$romejs$events$Event_ts$default(
          {
            name: 'Client.requestResponseEvent',
          },
        );
      this.endEvent = new ___R$project$rome$$romejs$events$Event_ts$default({name: 'Client.endEvent', serial: true});
      this.bridgeStatus = undefined;

      this.bridgeAttachedEvent =
        new ___R$project$rome$$romejs$events$Event_ts$default(
          {
            name: 'Client.bridgeAttached',
          },
        );

      this.reporter =
        new ___R$project$rome$$romejs$cli$reporter$Reporter_ts$default(
          {
            stdin: opts.stdin,
            silent: this.flags.silent === true || opts.stdout === undefined ||
            opts.stderr === undefined,
            verbose: this.flags.verbose === true,
            markupOptions: {
              cwd: this.flags.cwd,
            },
          },
        );

      this.derivedReporterStreams =
        this.reporter.attachStdoutStreams(
          opts.stdout,
          opts.stderr,
        );

      this.endEvent.subscribe(
        () => {
          this.reporter.teardown();
        },
      );
    }

    getBridgeJSONFlags() {
      return (
        Object.assign(
          {
          },
          this.flags,
          {
            cwd: this.flags.cwd.join(),
          },
        )
      );
    }

    async profile(opts, callback) {
      const {samplingInterval, timeoutInterval, includeWorkers} = opts;

      this.reporter.info('Starting CPU profile...');

      // Start server and start profiling
      const bridge = await this.findOrStartMaster();
      await bridge.profilingStart.call(
        {
          samplingInterval,
        },
      );

      // Start cli profiling
      let cliProfiler;
      const bridgeStatus = this.getBridge();
      if (bridgeStatus === undefined || bridgeStatus.dedicated) {
        cliProfiler = new ___R$project$rome$$romejs$v8$Profiler_ts$default();
        await cliProfiler.startProfiling(samplingInterval);
      }

      // Start a profile timer if one was specified
      let hasProfiled;
      let timeout;
      if (timeoutInterval > 0) {
        timeout =
          setTimeout(
            () => {
              hasProfiled = stopProfile(true);
            },
            timeoutInterval,
          );
      }

      const stopProfile = async (isTimeout) => {
        // This is to prevent stopping the profile multiple times via the timeout and then at the end

        // It's a promise so that the final stopProfile call will block until the first has finished
        if (hasProfiled) {
          return hasProfiled;
        }

        // Stop the timeout if it hasn't been triggered
        if (timeout !== undefined) {
          clearTimeout(timeout);
        }

        //
        const trace = new ___R$project$rome$$romejs$v8$Trace_ts$default();
        const fetchers = [];

        // CLI
        if (cliProfiler !== undefined) {
          const cliProfilerAssert = cliProfiler;
          fetchers.push(
            [
              'CLI',
              async () => {
                return cliProfilerAssert.stopProfiling();
              },
            ],
          );
        }

        // Master
        fetchers.push(
          [
            cliProfiler === undefined ? 'Master/CLI' : 'Master',
            async () => {
              return (
                await bridge.profilingStop.call(
                  undefined,
                  {
                    priority: true,
                  },
                )
              );
            },
          ],
        );

        // Workers
        if (includeWorkers) {
          const workerIds = await bridge.profilingGetWorkers.call();
          for (const id of workerIds) {
            fetchers.push(
              [
                'Worker ' +
                id,
                async () => {
                  return (
                    await bridge.profilingStopWorker.call(
                      id,
                      {
                        priority: true,
                      },
                    )
                  );
                },
              ],
            );
          }
        }

        // Fetch profiles
        const progress = this.reporter.progress();
        progress.setTotal(fetchers.length);
        progress.setTitle('Fetching profiles');
        for (const [text, callback] of fetchers) {
          progress.setText(text);
          const profile = await callback();
          trace.addProfile(text, profile);
          progress.tick();
        }
        progress.end();

        const events = trace.build();
        await callback(events);

        // If we're a timeout than separate these logs from the
        if (isTimeout) {
          this.reporter.hr();
        }
      };

      this.endEvent.subscribe(
        () => {
          return stopProfile(false);
        },
      );
    }

    async subscribeLogs(includeWorkerLogs, callback) {
      const bridge = await this.findOrStartMaster();

      if (includeWorkerLogs) {
        await bridge.enableWorkerLogs.call();
      }

      bridge.log.subscribe(
        ({origin, chunk}) => {
          if (origin === 'worker' && !includeWorkerLogs) {
            // We allow multiple calls to bridge.enableWorkerLogs

            // Filter the event if necessary if it wasn't requested by this log subscription
            return;
          }

          callback(chunk);
        },
      );
    }

    async rage(ragePath, profileOpts) {
      if (this.bridgeStatus !== undefined) {
        throw (
          new Error(
            'rage() can only be called before a query has been dispatched',
          )
        );
      }

      let logs = '';
      await this.subscribeLogs(
        true,
        (chunk) => {
          logs += chunk;
        },
      );

      // Collect CPU profile

      // Callback will be called later once it has been collected

      // Initial async work is just connecting to the processes and setting up handlers
      let profileEvents = [];
      await this.profile(
        profileOpts,
        async (_profileEvents) => {
          profileEvents = _profileEvents;
        },
      );

      // Collect all responses
      const responses = [];
      this.requestResponseEvent.subscribe(
        (result) => {
          responses.push(result);
        },
      );

      this.endEvent.subscribe(
        async () => {
          const stream = ___R$$priv$project$rome$$romejs$core$client$Client_ts$zlib.createGzip();
          stream.pipe(___R$$priv$project$rome$$romejs$core$client$Client_ts$fs.createWriteStream(ragePath));

          const writer = new ___R$project$rome$$romejs$codec$tar$index_ts$TarWriter(stream);

          writer.append({name: 'profile.json'}, stringify(profileEvents));
          writer.append({name: 'logs.txt'}, logs);

          // Add requests
          for (let i = 0;
          i < responses.length;
          i++) {
            const {request, response} = responses[i];
            const dirname = 'requests/' +
            i +
            '-' +
            request.commandName;
            writer.append({name: dirname +
            '/request.json'}, stringify(request));
            writer.append({name: dirname +
            '/response.json'}, stringify(response));
          }

          // Add client flags
          writer.append(
            {name: 'clientFlags.json'},
            stringify(
              this.getBridgeJSONFlags(),
            ),
          );

          function stringify(val) {
            return JSON.stringify(val, null, '  ');
          }

          function indent(val) {
            const str = typeof val === 'string'
              ? val : ___R$project$rome$$romejs$pretty$format$index_ts$default(
                val,
                {
                  compact: true,
                },
              );
            const lines = str.trim().split('\n');
            const indented = lines.join('\n  ');
            return '\n  ' +
            indented;
          }

          const env = [];
          env.push('PATH: ' +
          indent(process.env.PATH));
          env.push('Rome version: ' +
          indent(___R$project$rome$$romejs$core$common$constants_ts$VERSION));
          env.push('Node version: ' +
          indent(process.versions.node));
          env.push('Platform: ' +
          indent(process.platform +
          ' ' +
          process.arch));
          writer.append({name: 'environment.txt'}, env.join('\n\n') +
          '\n');

          // Don't do this if we never connected to the master
          const bridgeStatus = this.getBridge();
          if (bridgeStatus !== undefined) {
            const status = await this.query(
              {
                silent: true,
                command: 'status',
              },
            );
            if (status.type === 'SUCCESS') {
              writer.append(
                {name: 'status.txt'},
                ___R$project$rome$$romejs$pretty$format$index_ts$default(
                  status.data,
                  {
                    compact: true,
                  },
                ) +
                '\n',
              );
            }
          }

          await writer.finalize();
          this.reporter.success('Rage archive written to', ragePath);
        },
      );
    }

    async query(query, type) {
      const request = new ___R$project$rome$$romejs$core$client$ClientRequest_ts$default(this, type, query);
      const res = await request.init();
      this.requestResponseEvent.send({request: query, response: res});
      return res;
    }

    getBridge() {
      return this.bridgeStatus;
    }

    async end() {
      await this.endEvent.callOptional();

      const status = this.bridgeStatus;
      if (status !== undefined) {
        status.bridge.end();
        this.bridgeStatus = undefined;
      }
    }

    async attachBridge(bridge, dedicated) {
      const {stdout, stderr, columnsUpdated} = this.derivedReporterStreams;

      if (this.bridgeStatus !== undefined) {
        throw new Error('Already attached bridge to API');
      }

      this.bridgeStatus = {bridge, dedicated};

      bridge.stderr.subscribe(
        (chunk) => {
          stderr.write(chunk);
        },
      );

      bridge.stdout.subscribe(
        (chunk) => {
          stdout.write(chunk);
        },
      );

      bridge.reporterRemoteServerMessage.subscribe(
        (msg) => {
          this.reporter.processRemoteClientMessage(msg);
        },
      );

      this.reporter.sendRemoteServerMessage.subscribe(
        (msg) => {
          bridge.reporterRemoteClientMessage.send(msg);
        },
      );

      // Listen for resize column events if stdout is a TTY
      columnsUpdated.subscribe(
        (columns) => {
          bridge.setColumns.call(columns);
        },
      );

      await Promise.all(
        [
          bridge.getClientInfo.wait(
            {
              version: ___R$project$rome$$romejs$core$common$constants_ts$VERSION,
              format: stdout.format,
              hasClearScreen: this.reporter.hasClearScreen,
              columns: stdout.columns,
              useRemoteReporter: true,
              flags: this.getBridgeJSONFlags(),
            },
          ),

          bridge.handshake(),
        ],
      );

      await this.bridgeAttachedEvent.call();
    }

    async findOrStartMaster() {
      // First check if we already have a bridge connection
      const connected = this.getBridge();
      if (connected !== undefined) {
        return connected.bridge;
      }

      // Then check if there's already a running daemon
      const runningDaemon = await this.tryConnectToExistingDaemon();
      if (runningDaemon) {
        return runningDaemon;
      }

      // Otherwise, start a master inside this process
      const master = new ___R$project$rome$$romejs$core$master$Master_ts$default(
        {
          dedicated: false,
          globalErrorHandlers: this.options.globalErrorHandlers === true,
        },
      );
      await master.init();

      const bridge = ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromLocal(___R$project$rome$$romejs$core$common$bridges$MasterBridge_ts$default, {});
      await Promise.all(
        [
          master.attachToBridge(bridge),
          this.attachBridge(bridge, false),
        ],
      );

      this.endEvent.subscribe(
        async () => {
          await master.end();
        },
      );

      return bridge;
    }

    async forceStartDaemon() {
      const daemon = await this.startDaemon();
      if (daemon === undefined) {
        this.reporter.error('Failed to start daemon');
        throw new Error('Failed to start daemon');
      } else {
        return daemon;
      }
    }

    async startDaemon() {
      const {reporter} = this;

      if (this.bridgeStatus !== undefined) {
        throw new Error('Already started master');
      }

      reporter.info('No running daemon found. Starting one...');

      let exited = false;
      let proc;

      const newDaemon = await new Promise(
        (resolve) => {
          const timeout = setTimeout(
            () => {
              reporter.error('Daemon connection timed out');
              cleanup();
              resolve();
            },
            ___R$$priv$project$rome$$romejs$core$client$Client_ts$NEW_SERVER_INIT_TIMEOUT,
          );

          const socketServer = ___R$$priv$project$rome$$romejs$core$client$Client_ts$net.createServer(
            () => {
              cleanup();
              resolve(this.tryConnectToNewDaemon());
            },
          );

          function listen() {
            socketServer.listen(___R$project$rome$$romejs$core$common$constants_ts$CLI_SOCKET_PATH.join());

            proc =
              ___R$project$rome$$romejs$core$common$utils$fork_ts$default(
                'master',
                {
                  detached: true,
                },
              );
            proc.unref();

            proc.on(
              'close',
              () => {
                exited = true;
                cleanup();
                resolve();
              },
            );
          }

          ___R$project$rome$$romejs$fs$index_ts$unlink(___R$project$rome$$romejs$core$common$constants_ts$CLI_SOCKET_PATH).finally(
            () => {
              listen();
            },
          );

          function cleanup() {
            clearTimeout(timeout);
            socketServer.close();
          }
        },
      );
      if (newDaemon) {
        return newDaemon;
      }

      // as a final precaution kill the server
      if (exited) {
        reporter.error('Daemon died while initialising.');
      } else {
        reporter.error('Failed to connect. Killing daemon.');
      }

      if (proc !== undefined) {
        proc.kill();
      }

      console.log('ughhh???');
      return undefined;
    }

    async tryConnectToNewDaemon() {
      const bridge = await this.tryConnectToExistingDaemon();
      if (bridge !== undefined) {
        this.reporter.success('Started daemon!');
        return bridge;
      }
    }

    async tryConnectToExistingDaemon() {
      const promise = new Promise(
        (
          resolve,
          reject,
        ) => {
          const socket = ___R$$priv$project$rome$$romejs$core$client$Client_ts$net.createConnection(
            {
              path: ___R$project$rome$$romejs$core$common$constants_ts$SOCKET_PATH.join(),
            },
            () => {
              resolve(socket);
            },
          );

          socket.on(
            'error',
            (err) => {
              if (err.code === 'ENOENT' || err.code === 'ECONNREFUSED' ||
              err.code ===
              'EADDRINUSE') {
                resolve();
              } else {
                reject(err);
              }
            },
          );
        },
      );

      const socket = await promise;
      if (socket === undefined) {
        return undefined;
      }

      const server = ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromSocket(
        ___R$project$rome$$romejs$core$common$bridges$MasterBridge_ts$default,
        socket,
        {
          type: 'server',
        },
      );
      await this.attachBridge(server, true);
      this.reporter.success('Connected to daemon');
      return server;
    }
  }

  // project-rome/@romejs/core/common/types/bundler.ts
const ___R$project$rome$$romejs$core$common$types$bundler_ts = {
    get BUNDLER_MODES() {
      return (
        ___R$project$rome$$romejs$core$common$types$bundler_ts$BUNDLER_MODES
      );
    },
  };

  const ___R$project$rome$$romejs$core$common$types$bundler_ts$BUNDLER_MODES = ['modern', 'legacy'];

  // project-rome/@romejs/core/common/types/files.ts
const ___R$project$rome$$romejs$core$common$types$files_ts = {
    convertTransportFileReference: ___R$project$rome$$romejs$core$common$types$files_ts$convertTransportFileReference,
  };

  function ___R$project$rome$$romejs$core$common$types$files_ts$convertTransportFileReference(
    ref,
  ) {
    return (
      Object.assign(
        {
        },
        ref,
        {
          real: ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(ref.real),
        },
      )
    );
  }

  // project-rome/@romejs/core/worker/WorkerAPI.ts
class ___R$project$rome$$romejs$core$worker$WorkerAPI_ts$default {
    constructor(worker) {
      this.worker = worker;
      this.logger = worker.logger;
    }

    interceptAndAddGeneratedToDiagnostics(val, generated) {
      if (generated) {
        const diagnostics = val.diagnostics.map(
          (diag) => {
            const diagAdvice = diag.advice === undefined ? [] : diag.advice;
            return (
              Object.assign(
                {
                },
                diag,
                {
                  advice: [
                    ...diagAdvice,
                    {
                      type: 'log',
                      category: 'warn',
                      message: 'This diagnostic was generated on a file that has been converted to JavaScript. The source locations are most likely incorrect',
                    },
                  ],
                },
              )
            );
          },
        );

        return Object.assign(
          {
          },
          val,
          {
            diagnostics,
          },
        );
      } else {
        return val;
      }
    }

    async moduleSignatureJS(ref) {
      const {ast, project} = await this.worker.parseJS(ref);

      this.logger.info('Generating export types:', ref.real);

      return (
        await ___R$project$rome$$romejs$js$analysis$index_ts.getModuleSignature(
          {
            ast,
            project,
            provider: await this.worker.getTypeCheckProvider(ref.project),
          },
        )
      );
    }

    async analyzeDependencies(ref) {
      const project = this.worker.getProject(ref.project);
      const {handler} = ___R$project$rome$$romejs$core$common$fileHandlers_ts$getFileHandlerAssert(ref.real, project.config);
      this.logger.info('Analyze dependencies:', ref.real);

      const {analyzeDependencies} = handler;
      if (analyzeDependencies === undefined) {
        return ___R$project$rome$$romejs$core$common$types$analyzeDependencies_ts$UNKNOWN_ANALYZE_DEPENDENCIES_RESULT;
      }

      return (
        analyzeDependencies(
          {
            file: ref,
            project,
            worker: this.worker,
          },
        )
      );
    }

    async workerCompilerOptionsToCompilerOptions(ref, workerOptions) {
      const ___R$ = workerOptions;
      const options = Object.assign(
        {
        },
        ___R$,
      );
      delete options.bundle;
      const {
        bundle,
      } = ___R$;
      if (bundle === undefined) {
        return options;
      } else {
        return (
          Object.assign(
            {
            },
            options,
            {
              bundle: Object.assign(
                {
                },
                bundle,
                {
                  analyze: await this.analyzeDependencies(ref),
                },
              ),
            },
          )
        );
      }
    }

    async compileJS(ref, stage, workerOptions) {
      const {ast, project, sourceText, generated} = await this.worker.parseJS(ref);
      this.logger.info('Compiling:', ref.real);

      const options = await this.workerCompilerOptionsToCompilerOptions(
        ref,
        workerOptions,
      );
      return (
        this.interceptAndAddGeneratedToDiagnostics(
          await ___R$project$rome$$romejs$js$compiler$api$compile_ts$default(
            {
              ast,
              sourceText,
              options,
              project,
              stage,
            },
          ),
          generated,
        )
      );
    }

    async parseJS(ref, opts) {
      let {ast, generated} = await this.worker.parseJS(
        ref,
        {
          sourceType: opts.sourceType,
          cache: false,
        },
      );

      ast = this.interceptAndAddGeneratedToDiagnostics(ast, generated);

      if (opts.compact) {
        return ___R$project$rome$$romejs$js$ast$core$Program_ts$program.assert(___R$project$rome$$romejs$js$ast$utils$removeLoc_ts$default(ast));
      } else {
        return ast;
      }
    }

    async format(ref) {
      const res = await this._format(ref);
      if (res === undefined) {
        return undefined;
      } else {
        return (
          {
            formatted: res.formatted,
            original: res.sourceText,
            diagnostics: res.diagnostics,
          }
        );
      }
    }

    shouldFormat(ref) {
      const project = this.worker.getProject(ref.project);

      return (
        project.config.format.enabled &&
          ___R$project$rome$$romejs$path$match$index_ts$matchPathPatterns(
            ref.real,
            project.config.format.ignore,
          ) ===
          'NO_MATCH'
      );
    }

    async _format(ref) {
      const project = this.worker.getProject(ref.project);
      this.logger.info('Formatting:', ref.real);

      if (!this.shouldFormat(ref)) {
        return;
      }

      const {handler} = ___R$project$rome$$romejs$core$common$fileHandlers_ts$getFileHandlerAssert(ref.real, project.config);
      const {format} = handler;
      if (format === undefined) {
        return;
      }

      const res = await format(
        {
          file: ref,
          project,
          worker: this.worker,
        },
      );

      return res;
    }

    async lint(ref, prefetchedModuleSignatures, fix) {
      const project = this.worker.getProject(ref.project);
      this.logger.info('Linting:', ref.real);

      // Get the extension handler
      const {handler} = ___R$project$rome$$romejs$core$common$fileHandlers_ts$getFileHandlerAssert(ref.real, project.config);

      const {lint} = handler;
      if (lint === undefined && handler.format === undefined) {
        return (
          {
            diagnostics: [],
            suppressions: [],
          }
        );
      }

      // Catch any diagnostics, in the case of syntax errors etc
      const res = await ___R$project$rome$$romejs$diagnostics$wrap_ts$catchDiagnostics(
        {
          category: 'lint',
          message: 'Caught by WorkerAPI.lint',
        },
        () => {
          if (lint === undefined) {
            return this._format(ref);
          } else {
            return (
              lint(
                {
                  format: this.shouldFormat(ref),
                  file: ref,
                  project,
                  prefetchedModuleSignatures,
                  worker: this.worker,
                },
              )
            );
          }
        },
      );

      // These are fatal diagnostics
      if (res.diagnostics !== undefined) {
        return (
          {
            suppressions: [],
            diagnostics: res.diagnostics,
          }
        );
      }

      // `format` could have return undefined
      if (res.value === undefined) {
        return (
          {
            diagnostics: [],
            suppressions: [],
          }
        );
      }

      // These are normal diagnostics returned from the linter
      const {
        formatted,
        sourceText: raw,
        diagnostics,
        suppressions,
      } = res.value;

      // If the file has pending fixes
      const needsFix = formatted !== raw;

      // Autofix if necessary
      if (fix && needsFix) {
        // Save the file and evict it from the cache
        await this.worker.writeFile(ref.real, formatted);

        // Relint this file without fixing it, we do this to prevent false positive error messages
        return this.lint(ref, prefetchedModuleSignatures, false);
      }

      // If there's no pending fix then no need for diagnostics
      if (!needsFix) {
        return (
          {
            diagnostics,
            suppressions,
          }
        );
      }

      // Add pending autofix diagnostic
      return (
        {
          suppressions,
          diagnostics: [
            ...diagnostics,
            {
              category: 'lint/pendingFixes',
              filename: ref.uid,
              message: 'Pending fixes',
              advice: [
                {
                  type: 'diff',
                  diff: ___R$project$rome$$romejs$string$diff$index_ts$default(raw, formatted),
                  legend: {
                    add: 'Code to be added',
                    delete: 'Code to be removed',
                  },
                },
              ],
            },
          ],
        }
      );
    }
  }

  // project-rome/@romejs/core/worker/Worker.ts
class ___R$project$rome$$romejs$core$worker$Worker_ts$default {
    constructor(opts) {
      this.bridge = opts.bridge;

      this.userConfig = ___R$project$rome$$romejs$core$common$userConfig_ts$loadUserConfig();
      this.partialManifests = new Map();
      this.projects = new Map();
      this.astCache = new ___R$project$rome$$romejs$path$collections_ts$UnknownFilePathMap();
      this.moduleSignatureCache = new ___R$project$rome$$romejs$path$collections_ts$UnknownFilePathMap();

      this.logger =
        new ___R$project$rome$$romejs$core$common$utils$Logger_ts$default(
          'worker',
          () => opts.bridge.log.hasSubscribers(),
          {
            streams: [
              {
                type: 'all',
                format: 'none',
                columns: ___R$project$rome$$romejs$cli$reporter$Reporter_ts$default.DEFAULT_COLUMNS,
                write(chunk) {
                  opts.bridge.log.send(chunk.toString());
                },
              },
            ],
          },
        );

      //
      this.api = new ___R$project$rome$$romejs$core$worker$WorkerAPI_ts$default(this);

      if (opts.globalErrorHandlers) {
        ___R$project$rome$$romejs$core$common$utils$setupGlobalErrorHandlers_ts$default(
          (err) => {
            // TODO
            err;
          },
        );
      }
    }

    getPartialManifest(id) {
      const manifest = this.partialManifests.get(id);
      if (manifest === undefined) {
        throw new Error('Requested manifest ' +
        id +
        ' but we don\'t have it');
      }
      return manifest;
    }

    end() {
      // This will only actually be called when a Worker is created inside of the Master

      // Clear internal maps for memory, in case the Worker instance sticks around
      this.astCache.clear();
      this.projects.clear();
      this.moduleSignatureCache.clear();
    }

    async init() {
      const bridge = this.bridge;

      bridge.endEvent.subscribe(
        () => {
          this.end();
        },
      );

      let profiler;
      bridge.profilingStart.subscribe(
        async (data) => {
          if (profiler !== undefined) {
            throw new Error('Expected no profiler to be running');
          }
          profiler = new ___R$project$rome$$romejs$v8$Profiler_ts$default();
          await profiler.startProfiling(data.samplingInterval);
        },
      );

      bridge.profilingStop.subscribe(
        async () => {
          if (profiler === undefined) {
            throw new Error('Expected a profiler to be running');
          }
          const workerProfile = await profiler.stopProfiling();
          profiler = undefined;
          return workerProfile;
        },
      );

      bridge.compileJS.subscribe(
        (payload) => {
          return (
            this.api.compileJS(
              ___R$project$rome$$romejs$core$common$types$files_ts$convertTransportFileReference(payload.file),
              payload.stage,
              payload.options,
            )
          );
        },
      );

      bridge.parseJS.subscribe(
        (payload) => {
          return (
            this.api.parseJS(
              ___R$project$rome$$romejs$core$common$types$files_ts$convertTransportFileReference(payload.file),
              payload.opts,
            )
          );
        },
      );

      bridge.lint.subscribe(
        (payload) => {
          return (
            this.api.lint(
              ___R$project$rome$$romejs$core$common$types$files_ts$convertTransportFileReference(payload.file),
              payload.prefetchedModuleSignatures,
              payload.fix,
            )
          );
        },
      );

      bridge.format.subscribe(
        (payload) => {
          return this.api.format(___R$project$rome$$romejs$core$common$types$files_ts$convertTransportFileReference(payload.file));
        },
      );

      bridge.analyzeDependencies.subscribe(
        (payload) => {
          return (
            this.api.analyzeDependencies(
              ___R$project$rome$$romejs$core$common$types$files_ts$convertTransportFileReference(
                payload.file,
              ),
            )
          );
        },
      );

      bridge.evict.subscribe(
        (payload) => {
          this.evict(___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(payload.filename));
          return undefined;
        },
      );

      bridge.moduleSignatureJS.subscribe(
        (payload) => {
          return (
            this.api.moduleSignatureJS(
              ___R$project$rome$$romejs$core$common$types$files_ts$convertTransportFileReference(
                payload.file,
              ),
            )
          );
        },
      );

      bridge.updateProjects.subscribe(
        (payload) => {
          return this.updateProjects(payload.projects);
        },
      );

      bridge.updateManifests.subscribe(
        (payload) => {
          return this.updateManifests(payload.manifests);
        },
      );

      bridge.status.subscribe(
        () => {
          return (
            {
              astCacheSize: this.astCache.size,
              pid: process.pid,
              memoryUsage: process.memoryUsage(),
              uptime: process.uptime(),
            }
          );
        },
      );
    }

    async getTypeCheckProvider(projectId, prefetchedModuleSignatures = {}) {
      const libs = [];

      // TODO Figure out how to get the uids for the libraries, probably adding some additional stuff to ProjectConfig?

      /*
    const projectConfig = this.getProjectConfig(projectId);
    for (const filename of projectConfig.typeChecking.libs) {
      const {ast, err} = await this.parse(filename, uid, projectId);
      if (err) {
        throw err;
      } else {
        invariant(ast, 'expected ast');
        libs.push(ast);
      }
    }
    */
      const resolveGraph = async (
        key,
      ) => {
        const value = prefetchedModuleSignatures[key];
        if (value === undefined) {
          return undefined;
        }

        switch (value.type) {
          case 'RESOLVED':
            this.moduleSignatureCache.set(
              ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
                value.graph.filename,
              ),
              value.graph,
            );
            return value.graph;

          case 'OWNED':
            return (
              this.api.moduleSignatureJS(
                ___R$project$rome$$romejs$core$common$types$files_ts$convertTransportFileReference(
                  value.file,
                ),
              )
            );

          case 'POINTER':
            return resolveGraph(value.key);

          case 'USE_CACHED':
            const cached = this.moduleSignatureCache.get(
              ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
                value.filename,
              ),
            );
            if (cached === undefined) {
              throw (
                new Error(
                  'Master told us we have the export types for ' +
                  value.filename +
                  ' cached but we dont!',
                )
              );
            }
            return cached;
        }
      };

      return (
        {
          getExportTypes: async (
            origin,
            relative,
          ) => {
            return resolveGraph(origin +
            ':' +
            relative);
          },
          libs,
        }
      );
    }

    populateDiagnosticsMtime(diagnostics) {
      return diagnostics;
    }

    async parseJS(ref, opts = {}) {
      const path = ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(ref.real);

      const {project: projectId, uid} = ref;
      const project = this.getProject(projectId);

      // Fetch and validate extension handler
      const {handler} = ___R$project$rome$$romejs$core$common$fileHandlers_ts$getFileHandlerAssert(ref.real, project.config);
      if (handler.toJavaScript === undefined) {
        throw new Error('We don\'t know how to convert the file ' +
        path +
        ' to js');
      }

      // Get syntax
      let syntax = [];
      if (opts.syntax !== undefined) {
        syntax = opts.syntax;
      } else if (handler.syntax !== undefined) {
        syntax = handler.syntax;
      }

      // Get source type
      let sourceType;
      if (opts.sourceType !== undefined) {
        sourceType = opts.sourceType;
      } else if (handler.sourceType !== undefined) {
        sourceType = handler.sourceType;
      } else {
        sourceType = 'script';

        if (ref.manifest !== undefined) {
          const manifest = this.getPartialManifest(ref.manifest);
          if (manifest.type === 'module') {
            sourceType = 'module';
          }
        }
      }

      if (project.config.bundler.mode === 'legacy') {
        sourceType = 'module';
      }

      const cacheEnabled = opts.cache !== false;
      if (cacheEnabled) {
        // Update the lastAccessed of the ast cache and return it, it will be evicted on

        // any file change
        const cachedResult = this.astCache.get(path);
        if (cachedResult && cachedResult.ast.sourceType === sourceType) {
          this.astCache.set(
            path,
            Object.assign(
              {
              },
              cachedResult,
              {
                lastAccessed: Date.now(),
              },
            ),
          );
          return cachedResult;
        }
      }

      this.logger.info('Parsing:', path);

      const stat = await ___R$project$rome$$romejs$fs$index_ts$lstat(path);

      const {sourceText, generated} = await handler.toJavaScript(
        {
          file: ref,
          worker: this,
          project,
        },
      );

      let manifestPath;
      if (ref.manifest !== undefined) {
        manifestPath = this.getPartialManifest(ref.manifest).path;
      }

      const ast = ___R$project$rome$$romejs$js$parser$index_ts$parseJS(
        {
          input: sourceText,
          mtime: stat.mtimeMs,
          manifestPath,
          path: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(uid),
          sourceType,
          syntax,
        },
      );

      const res = {
        ast,
        lastAccessed: Date.now(),
        sourceText,
        project,
        path,
        generated,
      };

      if (cacheEnabled) {
        this.astCache.set(path, res);
      }

      return res;
    }

    getProject(id) {
      const config = this.projects.get(id);
      if (config === undefined) {
        throw (
          new Error(
            'Unknown project ' +
            id +
            ', known projects are ' +
            this.projects.keys(),
          )
        );
      }
      return config;
    }

    async writeFile(filename, content) {
      // Write the file out
      await ___R$project$rome$$romejs$fs$index_ts$writeFile(filename, content);

      // We just wrote the file but the server watcher hasn't had time to notify us
      this.evict(filename);
    }

    evict(filename) {
      this.astCache.delete(filename);
      this.moduleSignatureCache.delete(filename);
    }

    updateManifests(manifests) {
      for (const {id, manifest} of manifests) {
        if (manifest === undefined) {
          this.partialManifests.delete(id);
        } else {
          this.partialManifests.set(id, manifest);
        }
      }
    }

    updateProjects(projects) {
      for (const {config, folder, id} of projects) {
        if (config === undefined) {
          this.projects.delete(id);
        } else {
          this.projects.set(
            id,
            {
              folder: ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(folder),
              config: ___R$project$rome$$romejs$project$transport_ts$hydrateJSONProjectConfig(config),
            },
          );
        }
      }
    }
  }

  // project-rome/@romejs/core/test-worker/TestAPI.ts
function ___R$$priv$project$rome$$romejs$core$test$worker$TestAPI_ts$removeCRLF(str) {
    return str.replace(/\r/g, '');
  }

  function ___R$$priv$project$rome$$romejs$core$test$worker$TestAPI_ts$formatExpectedError(expected) {
    if (typeof expected === 'string') {
      return JSON.stringify(expected);
    }

    if (expected instanceof RegExp) {
      return String(expected);
    }

    if (typeof expected === 'function') {
      return expected.name;
    }

    return 'unknown';
  }

  function ___R$$priv$project$rome$$romejs$core$test$worker$TestAPI_ts$matchExpectedError(error, expected) {
    if (expected === undefined) {
      return true;
    }

    if (typeof expected === 'string') {
      return error.message.includes(expected);
    }

    if (expected instanceof RegExp) {
      return expected.test(error.message);
    }

    if (typeof expected === 'function') {
      return error instanceof expected;
    }

    return false;
  }

  const ___R$$priv$project$rome$$romejs$core$test$worker$TestAPI_ts$TRUNCATION_MATCH_LIMIT = 500;

  function ___R$$priv$project$rome$$romejs$core$test$worker$TestAPI_ts$maybeTruncate(str, noTruncate) {
    if (noTruncate || str.length < ___R$$priv$project$rome$$romejs$core$test$worker$TestAPI_ts$TRUNCATION_MATCH_LIMIT) {
      return str;
    } else {
      return str.slice(0, ___R$$priv$project$rome$$romejs$core$test$worker$TestAPI_ts$TRUNCATION_MATCH_LIMIT) +
      '...';
    }
  }

  class ___R$project$rome$$romejs$core$test$worker$TestAPI_ts$default {
    constructor({
      testName,
      onTimeout,
      file,
      snapshotManager,
      options,
    }) {
      this.testName = testName;
      this.options = options;
      this.snapshotManager = snapshotManager;
      this.snapshotCounter = 0;
      this.file = file;

      this.teardownEvent = new ___R$project$rome$$romejs$events$Event_ts$default({name: 'TestAPI.teardown'});

      this.startTime = Date.now();
      this.onTimeout = onTimeout;
      this.timeoutMax = 0;
      this.timeoutId = undefined;
      this.setTimeout(5000);

      this.advice = [];
    }

    buildMatchAdvice(received, expected, {
      visualMethod,
      expectedAlias,
      receivedAlias,
    } = {}) {
      let expectedFormat;
      let receivedFormat;
      if (typeof received === 'string' && typeof expected === 'string') {
        expectedFormat = expected;
        receivedFormat = received;
      } else {
        expectedFormat = ___R$project$rome$$romejs$pretty$format$index_ts$default(expected);
        receivedFormat = ___R$project$rome$$romejs$pretty$format$index_ts$default(received);
      }

      const expectedFormatCode = ___R$$priv$project$rome$$romejs$core$test$worker$TestAPI_ts$maybeTruncate(
        expectedFormat,
        this.options.verboseDiagnostics,
      );
      const receivedFormatCode = ___R$$priv$project$rome$$romejs$core$test$worker$TestAPI_ts$maybeTruncate(
        receivedFormat,
        this.options.verboseDiagnostics,
      );
      const hasTruncated = expectedFormatCode !== expectedFormat ||
      receivedFormatCode !== receivedFormat;
      const hasAllTruncated = expectedFormatCode !== expectedFormat &&
        receivedFormatCode !== receivedFormat;

      const advice = [];

      if (expectedFormat === receivedFormat) {
        // Better error message when both values are visually identical
        advice.push(
          {
            type: 'log',
            category: 'info',
            message: 'Both the received and expected values are visually identical',
          },
        );

        advice.push(
          {
            type: 'code',
            code: expectedFormatCode,
          },
        );

        if (visualMethod !== undefined) {
          advice.push(
            {
              type: 'log',
              category: 'info',
              message: 'Try using t.' +
              visualMethod +
              ' if you wanted a visual match',
            },
          );
        }
      } else {
        if (expectedFormat.trim() === receivedFormat.trim()) {
          advice.push(
            {
              type: 'log',
              category: 'info',
              message: 'Only difference is leading and trailing whitespace',
            },
          );
        }

        const expectedFormatNoCRLF = ___R$$priv$project$rome$$romejs$core$test$worker$TestAPI_ts$removeCRLF(expectedFormat);
        const receivedFormatNoCRLF = ___R$$priv$project$rome$$romejs$core$test$worker$TestAPI_ts$removeCRLF(receivedFormat);
        if (expectedFormat === receivedFormatNoCRLF) {
          advice.push(
            {
              type: 'log',
              category: 'info',
              message: 'Identical except the received uses CRLF newlines, while the expected does not',
            },
          );
        }
        if (receivedFormat === expectedFormatNoCRLF) {
          advice.push(
            {
              type: 'log',
              category: 'info',
              message: 'Identical except the expected uses CRLF newlines, while the received does not',
            },
          );
        }

        if (!hasAllTruncated) {
          // TODO detect newlines

          // If there was no truncation then display the full code of both values
          advice.push(
            {
              type: 'log',
              category: 'info',
              message: 'Expected to receive',
            },
          );

          advice.push(
            {
              type: 'code',
              code: expectedFormatCode,
            },
          );

          advice.push(
            {
              type: 'log',
              category: 'info',
              message: 'But got',
            },
          );

          advice.push(
            {
              type: 'code',
              code: receivedFormatCode,
            },
          );
        }

        // Produce a diff to better visualize differences

        // TODO what about truncation...?
        advice.push(
          {
            type: 'log',
            category: 'info',
            message: 'Diff',
          },
        );

        advice.push(
          {
            type: 'diff',
            diff: ___R$project$rome$$romejs$string$diff$index_ts$default(expectedFormat, receivedFormat),
            legend: {
              add: receivedAlias ? receivedAlias : 'What we received',
              delete: expectedAlias ? expectedAlias : 'What we expected<',
            },
          },
        );
      }

      // If there was truncation then warn
      if (hasAllTruncated) {
        advice.push(
          {
            type: 'log',
            category: 'info',
            message: 'Add the --verbose-diagnostics flag to show the values being compared',
          },
        );
      } else if (hasTruncated) {
        advice.push(
          {
            type: 'log',
            category: 'info',
            message: 'Some values have been truncated for being too long, add the --verbose-diagnostics flag to disable truncation',
          },
        );
      }

      return advice;
    }

    addToAdvice(item) {
      this.advice.push(item);
    }

    onTeardown(callback) {
      this.teardownEvent.subscribe(callback);
    }

    clearTimeout() {
      if (this.timeoutId !== undefined) {
        clearTimeout(this.timeoutId);
      }

      this.timeoutMax = undefined;
      this.timeoutStart = undefined;
    }

    extendTimeout(time) {
      const {timeoutMax, timeoutStart} = this;
      if (timeoutMax === undefined || timeoutStart === undefined) {
        throw new Error('No timeout set');
      }

      const elapsed = Date.now() - timeoutStart;
      const newTime = timeoutMax - elapsed + time;
      this.setTimeout(newTime);
    }

    setTimeout(time) {
      this.clearTimeout();

      this.timeoutStart = Date.now();
      this.timeoutMax = time;

      this.timeoutId =
        setTimeout(
          () => {
            this.onTimeout(time);
          },
          time,
        );
    }

    checkTimeout() {
      const {startTime, timeoutMax} = this;
      if (timeoutMax === undefined) {
        return undefined;
      }

      const delta = Date.now() - startTime;
      if (delta > timeoutMax) {
        throw new Error('Test timeout - exceeded ' +
        String(timeoutMax) +
        'ms');
      }
    }

    fail(message = 'Test failure triggered by t.fail()', advice = [], framesToPop = 0) {
      throw (
        ___R$project$rome$$romejs$v8$errors_ts$createErrorFromStructure(
          {
            message,
            advice,
            framesToPop: framesToPop + 1,
          },
        )
      );
    }

    truthy(value, message = 'Expected value to be truthy') {
      if (Boolean(value) === false) {
        this.fail(
          message,
          [
            {
              type: 'log',
              category: 'info',
              message: 'Received',
            },
            {
              type: 'code',
              code: ___R$project$rome$$romejs$pretty$format$index_ts$default(value),
            },
          ],
          1,
        );
      }
    }

    falsy(value, message = 'Expected value to be falsy') {
      if (Boolean(value) === true) {
        this.fail(
          message,
          [
            {
              type: 'log',
              category: 'info',
              message: 'Received',
            },
            {
              type: 'code',
              code: ___R$project$rome$$romejs$pretty$format$index_ts$default(value),
            },
          ],
          1,
        );
      }
    }

    true(value, message = 'Expected value to be true') {
      if (value !== true) {
        this.fail(
          message,
          [
            {
              type: 'log',
              category: 'info',
              message: 'Received',
            },
            {
              type: 'code',
              code: ___R$project$rome$$romejs$pretty$format$index_ts$default(value),
            },
          ],
          1,
        );
      }
    }

    false(value, message = 'Expected value to be false') {
      if (value !== false) {
        this.fail(
          message,
          [
            {
              type: 'log',
              category: 'info',
              message: 'Received',
            },
            {
              type: 'code',
              code: ___R$project$rome$$romejs$pretty$format$index_ts$default(value),
            },
          ],
          1,
        );
      }
    }

    is(received, expected, message = 't.is() failed, using Object.is semantics') {
      if (Object.is(received, expected) !== true) {
        this.fail(
          message,
          this.buildMatchAdvice(
            received,
            expected,
            {
              visualMethod: 'looksLike',
            },
          ),
          1,
        );
      }
    }

    not(received, expected, message = 't.not() failed, using !Object.is() semantics') {
      if (Object.is(received, expected) === true) {
        this.fail(
          message,
          this.buildMatchAdvice(
            received,
            expected,
            {
              visualMethod: 'notLooksLike',
            },
          ),
          1,
        );
      }
    }

    looksLike(received, expected, message = 't.looksLike() failed, using prettyFormat semantics') {
      const actualInspect = ___R$project$rome$$romejs$pretty$format$index_ts$default(received);
      const expectedInspect = ___R$project$rome$$romejs$pretty$format$index_ts$default(expected);

      if (actualInspect !== expectedInspect) {
        this.fail(message, this.buildMatchAdvice(received, expected), 1);
      }
    }

    notLooksLike(received, expected, message = 't.notLooksLike() failed, using !prettyFormat semantics') {
      const actualInspect = ___R$project$rome$$romejs$pretty$format$index_ts$default(received);
      const expectedInspect = ___R$project$rome$$romejs$pretty$format$index_ts$default(expected);

      if (actualInspect === expectedInspect) {
        this.fail(message, this.buildMatchAdvice(received, expected), 1);
      }
    }

    throws(thrower, expected, message = 't.throws() failed, callback did not throw an error') {
      try {
        thrower();
      } catch (err) {
        if (___R$$priv$project$rome$$romejs$core$test$worker$TestAPI_ts$matchExpectedError(err, expected)) {
          return undefined;
        } else {
          this.fail(
            't.throws() expected an error to be thrown that matches ' +
            ___R$$priv$project$rome$$romejs$core$test$worker$TestAPI_ts$formatExpectedError(
              expected,
            ) +
            ' but got ' +
            err.name +
            ': ' +
            JSON.stringify(err.message),
            ___R$project$rome$$romejs$diagnostics$derive_ts$getErrorStackAdvice(err, 'Incorrect error stack trace'),
            1,
          );
        }
      }

      this.fail(message, undefined, 1);
    }

    async throwsAsync(thrower, expected, message) {
      throw new Error('unimplemented');
    }

    notThrows(nonThrower, message) {
      try {
        nonThrower();
      } catch (err) {
        // TODO
        message;
        throw err;
      }
    }

    async notThrowsAsync(nonThrower, message) {
      throw new Error('unimplemented');
    }

    regex(contents, regex, message) {
      throw new Error('unimplemented');
    }

    notRegex(contents, regex, message) {
      throw new Error('unimplemented');
    }

    snapshot(expected, message) {
      const id = this.snapshotCounter++;
      return this._snapshotNamed(String(id), expected, message, 2);
    }

    snapshotNamed(name, expected, message) {
      return this._snapshotNamed(name, expected, message, 1);
    }

    getSnapshot(snapshotName) {
      return this.snapshotManager.get(this.testName, snapshotName);
    }

    _snapshotNamed(name, expected, message, framesToPop) {
      let language;

      let formatted = '';
      if (typeof expected === 'string') {
        formatted = expected;
      } else {
        language = 'javascript';
        formatted = ___R$project$rome$$romejs$pretty$format$index_ts$default(expected);
      }

      // Get the current snapshot
      const existingSnapshot = this.snapshotManager.get(this.testName, name);
      if (existingSnapshot === undefined) {
        // No snapshot exists, let's save this one!
        this.snapshotManager.set(
          {
            testName: this.testName,
            snapshotName: String(name),
            value: formatted,
            language,
          },
        );
        return undefined;
      }

      // Compare the snapshots
      if (formatted !== existingSnapshot) {
        const advice = this.buildMatchAdvice(
          formatted,
          existingSnapshot,
          {
            receivedAlias: 'What the code gave us',
            expectedAlias: 'Existing snapshot',
          },
        );

        if (message === undefined) {
          message =
            ___R$project$rome$$romejs$string$markup$escape_ts$markup`Snapshot ${name} at <filelink emphasis target="${this.snapshotManager.path.join()}" /> doesn't match`;
        } else {
          advice.push(
            {
              type: 'log',
              category: 'info',
              message: 'Snapshot can be found at <filelink emphasis target="' +
              this.snapshotManager.path.join() +
              '" />',
            },
          );
        }

        advice.push(
          {
            type: 'log',
            category: 'info',
            message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Run <command>rome test <filelink target="${this.file.uid}" /> --update-snapshots</command> to update this snapshot`,
          },
        );

        this.fail(message, advice, framesToPop);
      }
    }
  }

  // project-rome/@romejs/core/test-worker/SnapshotParser.ts
function ___R$$priv$project$rome$$romejs$core$test$worker$SnapshotParser_ts$isHash(char) {
    return char === '#';
  }

  function ___R$$priv$project$rome$$romejs$core$test$worker$SnapshotParser_ts$isCodeBlockEnd(index, input) {
    return (
      input[___R$project$rome$$romejs$ob1$index_ts$get0(index)] === '`' && !___R$project$rome$$romejs$parser$core$index_ts$isEscaped(index, input) &&
        input[___R$project$rome$$romejs$ob1$index_ts$get0(
          ___R$project$rome$$romejs$ob1$index_ts$add(index, 1),
        )] ===
        '`' &&
        input[___R$project$rome$$romejs$ob1$index_ts$get0(___R$project$rome$$romejs$ob1$index_ts$add(index, 2))] === '`'
    );
  }

  function ___R$$priv$project$rome$$romejs$core$test$worker$SnapshotParser_ts$isInCodeBlock(char, index, input) {
    return !___R$$priv$project$rome$$romejs$core$test$worker$SnapshotParser_ts$isCodeBlockEnd(index, input);
  }

  function ___R$$priv$project$rome$$romejs$core$test$worker$SnapshotParser_ts$isntNewline(char) {
    return char !== '\n';
  }

  function ___R$$priv$project$rome$$romejs$core$test$worker$SnapshotParser_ts$unescapeTicks(code) {
    return code;
  }

  const ___R$project$rome$$romejs$core$test$worker$SnapshotParser_ts$default = ___R$project$rome$$romejs$parser$core$index_ts$createParser(
    (
      ParserCore,
    ) =>
      class SnapshotParser extends ParserCore {
        constructor(opts) {
          super(opts, 'parse/snapshots');
          this.ignoreWhitespaceTokens = true;
        }

        tokenize(index, input) {
          const char = input[___R$project$rome$$romejs$ob1$index_ts$get0(index)];

          switch (char) {
            case '#':
              const [hashes] = this.readInputFrom(index, ___R$$priv$project$rome$$romejs$core$test$worker$SnapshotParser_ts$isHash);
              const level = hashes.length;
              return this.finishValueToken('Hashes', level, ___R$project$rome$$romejs$ob1$index_ts$add(index, level));

            case '`':
              const nextChar = input[___R$project$rome$$romejs$ob1$index_ts$get0(___R$project$rome$$romejs$ob1$index_ts$add(index, 1))];
              const nextNextChar = input[___R$project$rome$$romejs$ob1$index_ts$get0(___R$project$rome$$romejs$ob1$index_ts$add(index, 2))];

              if (nextChar === '`' && nextNextChar === '`') {
                let codeOffset = ___R$project$rome$$romejs$ob1$index_ts$add(index, 3);

                let language;
                if (input[___R$project$rome$$romejs$ob1$index_ts$get0(codeOffset)] !== '\n') {
                  [language, codeOffset] =
                    this.readInputFrom(
                      codeOffset,
                      ___R$$priv$project$rome$$romejs$core$test$worker$SnapshotParser_ts$isntNewline,
                    );
                }

                // Expect the first offset character to be a newline
                if (input[___R$project$rome$$romejs$ob1$index_ts$get0(codeOffset)] === '\n') {
                  // Skip leading newline
                  codeOffset = ___R$project$rome$$romejs$ob1$index_ts$add(codeOffset, 1);
                } else {
                  throw (
                    this.unexpected(
                      {
                        message: 'Newline required after code block',
                        start: this.getPositionFromIndex(codeOffset),
                      },
                    )
                  );
                }

                let [code] = this.readInputFrom(codeOffset, ___R$$priv$project$rome$$romejs$core$test$worker$SnapshotParser_ts$isInCodeBlock);

                let end = ___R$project$rome$$romejs$ob1$index_ts$add(codeOffset, code.length);

                if (___R$$priv$project$rome$$romejs$core$test$worker$SnapshotParser_ts$isCodeBlockEnd(end, input)) {
                  // Check for trailing newline
                  if (code[code.length - 1] === '\n') {
                    // Trim trailing newline
                    code = code.slice(0, -1);

                    // Skip closing ticks
                    end = ___R$project$rome$$romejs$ob1$index_ts$add(end, 3);

                    return (
                      this.finishValueToken(
                        'CodeBlock',
                        {
                          language,
                          text: ___R$$priv$project$rome$$romejs$core$test$worker$SnapshotParser_ts$unescapeTicks(code),
                        },
                        end,
                      )
                    );
                  } else {
                    throw (
                      this.unexpected(
                        {
                          message: 'Newline required before code block end',
                          start: this.getPositionFromIndex(end),
                        },
                      )
                    );
                  }
                } else {
                  throw (
                    this.unexpected(
                      {
                        message: 'Unclosed code block',
                        start: this.getPositionFromIndex(end),
                      },
                    )
                  );
                }
              }
          }

          const [text, end] = this.readInputFrom(index, ___R$$priv$project$rome$$romejs$core$test$worker$SnapshotParser_ts$isntNewline);
          return this.finishValueToken('TextLine', text, end);
        }

        parse() {
          const nodes = [];

          while (!this.matchToken('EOF')) {
            const start = this.getPosition();
            const token = this.getToken();

            switch (token.type) {
              case 'Hashes':
                const level = token.value;
                this.nextToken();
                const text = this.expectToken('TextLine').value;
                nodes.push(
                  {
                    type: 'Heading',
                    level,
                    text,
                    loc: this.finishLoc(start),
                  },
                );
                break;

              case 'CodeBlock':
                nodes.push(
                  Object.assign(
                    {
                      type: 'CodeBlock',
                    },
                    token.value,
                    {
                      loc: this.finishLoc(start),
                    },
                  ),
                );
                this.nextToken();
                break;

              case 'TextLine':
                nodes.push(
                  {
                    type: 'TextLine',
                    text: token.value,
                    loc: this.finishLoc(start),
                  },
                );
                this.nextToken();
                break;

              default:
                throw this.unexpected();
            }
          }

          return nodes;
        }
      },
  );

  // project-rome/@romejs/core/test-worker/SnapshotManager.ts
function ___R$$priv$project$rome$$romejs$core$test$worker$SnapshotManager_ts$cleanHeading(key) {
    if (key[0] === '`') {
      key = key.slice(1);
    }

    if (key[key.length - 1] === '`') {
      key = key.slice(0, -1);
    }

    return key.trim();
  }

  class ___R$project$rome$$romejs$core$test$worker$SnapshotManager_ts$default {
    constructor(runner, testPath) {
      this.path =
        testPath.getParent().append(
          testPath.getExtensionlessBasename() +
          '.test.md',
        );
      this.testPath = testPath;

      this.runner = runner;
      this.options = runner.options;

      this.exists = false;
      this.raw = '';

      this.entries = new Map();
    }

    async emitDiagnostic(category, message, advice) {
      await this.runner.emitDiagnostic(
        {
          category,
          filename: this.path.join(),
          message,
          advice,
        },
      );
    }

    async load() {
      const {path: snapshotFilename} = this;
      if (!(await ___R$project$rome$$romejs$fs$index_ts$exists(snapshotFilename))) {
        return;
      }

      this.exists = true;

      // If we're force updating, pretend that no snapshots exist on disk
      if (this.options.updateSnapshots) {
        return;
      }

      const file = await ___R$project$rome$$romejs$fs$index_ts$readFileText(snapshotFilename);
      this.raw = file;

      const parser = ___R$project$rome$$romejs$core$test$worker$SnapshotParser_ts$default(
        {
          path: snapshotFilename,
          input: file,
        },
      );

      const nodes = parser.parse();

      while (nodes.length > 0) {
        const node = nodes.shift();
        if (node === undefined) {
          throw new Error('Impossible');
        }

        if (node.type === 'Heading' && node.level === 1) {
          // Title
          continue;
        }

        if (node.type === 'Heading' && node.level === 2) {
          const testName = ___R$$priv$project$rome$$romejs$core$test$worker$SnapshotManager_ts$cleanHeading(node.text);

          while (nodes.length > 0) {
            const node = nodes[0];

            if (node.type === 'Heading' && node.level === 3) {
              nodes.shift();

              const snapshotName = ___R$$priv$project$rome$$romejs$core$test$worker$SnapshotManager_ts$cleanHeading(node.text);

              const codeBlock = nodes.shift();
              if (codeBlock === undefined || codeBlock.type !== 'CodeBlock') {
                throw (
                  parser.unexpected(
                    {
                      message: 'Expected a code block after this heading',
                      loc: node.loc,
                    },
                  )
                );
              }

              this.set(
                {
                  testName,
                  snapshotName,
                  language: codeBlock.language,
                  value: codeBlock.text,
                },
              );
              continue;
            }

            if (node.type === 'CodeBlock') {
              nodes.shift();

              this.set(
                {
                  testName,
                  snapshotName: '0',
                  language: node.language,
                  value: node.text,
                },
              );
            }

            break;
          }

          continue;
        }
      }
    }

    async save() {
      const {path} = this;

      // If there'a s focused test then we don't write or validate a snapshot
      if (this.runner.hasFocusedTest) {
        return;
      }

      // No point producing an empty snapshot file
      if (this.entries.size === 0) {
        if (this.exists) {
          if (this.options.freezeSnapshots) {
            await this.emitDiagnostic(
              'tests/snapshots/redundant',
              'Snapshot should not exist',
            );
          } else {
            // Remove the snapshot file as there were none ran
            await ___R$project$rome$$romejs$fs$index_ts$unlink(path);
          }
        }
        return;
      }

      // Build the snapshot
      let lines = [];

      function pushNewline() {
        if (lines[lines.length - 1] !== '') {
          lines.push('');
        }
      }

      lines.push('# `' +
      this.testPath.getBasename() +
      '`');
      pushNewline();
      const relativeTestPath = this.runner.projectFolder.relative(this.testPath).join();
      lines.push(
        '**DO NOT MODIFY**. This file has been autogenerated. Run `rome test ' +
        relativeTestPath +
        ' --update-snapshots` to update.',
      );
      pushNewline();

      // Get test names and sort them so they are in a predictable
      const testNames = Array.from(this.entries.keys()).sort();

      for (const testName of testNames) {
        const entries = this.entries.get(testName);
        if (entries === undefined) {
          throw new Error('Impossible');
        }

        lines.push('## `' +
        testName +
        '`');
        pushNewline();

        const snapshotNames = Array.from(entries.keys()).sort();

        for (const snapshotName of snapshotNames) {
          const entry = entries.get(snapshotName);
          if (entry === undefined) {
            throw new Error('Impossible');
          }

          const {value} = entry;
          const language = entry.language === undefined ? '' : entry.language;

          // If the test only has one snapshot then omit the heading
          const skipHeading = snapshotName === '0' && snapshotNames.length === 1;
          if (!skipHeading) {
            lines.push('### `' +
            snapshotName +
            '`');
          }

          pushNewline();
          lines.push('```' + language);
          // TODO escape triple backquotes
          lines.push(value);
          lines.push('```');
          pushNewline();
        }
      }

      const formatted = lines.join('\n');

      if (this.options.freezeSnapshots) {
        if (!this.exists) {
          await this.emitDiagnostic(
            'tests/snapshots/missing',
            'Snapshot does not exist',
          );
        } else if (formatted !== this.raw) {
          await this.emitDiagnostic(
            'tests/snapshots/incorrect',
            'Snapshots do not match',
            [
              {
                type: 'diff',
                diff: ___R$project$rome$$romejs$string$diff$index_ts$default(this.raw, formatted),
              },
            ],
          );
        }
      } else if (formatted !== this.raw) {
        // Save the file
        await ___R$project$rome$$romejs$fs$index_ts$writeFile(path, formatted);
      }
    }

    get(testName, snapshotName) {
      const entries = this.entries.get(testName);
      if (entries !== undefined) {
        const entry = entries.get(snapshotName);
        if (entry !== undefined) {
          return entry.value;
        }
      }
    }

    set({
      value,
      language,
      testName,
      snapshotName,
    }) {
      let entries = this.entries.get(testName);
      if (entries === undefined) {
        entries = new Map();
        this.entries.set(testName, entries);
      }

      entries.set(snapshotName, {value, language});
    }
  }

  // project-rome/@romejs/core/test-worker/TestWorkerRunner.ts
const ___R$$priv$project$rome$$romejs$core$test$worker$TestWorkerRunner_ts$MAX_RUNNING_TESTS = 20;

  class ___R$project$rome$$romejs$core$test$worker$TestWorkerRunner_ts$default {
    constructor(opts, bridge) {
      this.opts = opts;
      this.locked = false;
      this.file = ___R$project$rome$$romejs$core$common$types$files_ts$convertTransportFileReference(opts.file);
      this.options = opts.options;
      this.bridge = bridge;
      this.projectFolder = ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(opts.projectFolder);

      this.snapshotManager =
        new ___R$project$rome$$romejs$core$test$worker$SnapshotManager_ts$default(
          this,
          ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
            opts.file.real,
          ),
        );

      this.hasFocusedTest = false;
      this.foundTests = new Map();
    }

    //  Global variables to expose to tests
    getEnvironment() {
      const testOptions = {
        dirname: this.file.real.getParent().join(),
        register: (
          callsiteError,
          opts,
          callback,
        ) => {
          this.registerTest(callsiteError, opts, callback);
        },
      };

      return (
        {
          __ROME__TEST_OPTIONS__: testOptions,
        }
      );
    }

    async emitDiagnostic(diagnostic) {
      await this.bridge.testError.call(
        {
          ref: undefined,
          diagnostic,
        },
      );
    }

    // execute the test file and discover tests
    async discoverTests() {
      const {code, sourceMap} = this.opts;

      const res = await ___R$project$rome$$romejs$core$common$utils$executeMain_ts$default(
        {
          path: this.file.real,
          code,
          sourceMap,
          globals: this.getEnvironment(),
        },
      );

      if (res.syntaxError !== undefined) {
        const message = 'A bundle was generated that contained a syntax error: ' +
        res.syntaxError.message;

        throw (
          ___R$project$rome$$romejs$diagnostics$errors_ts$createSingleDiagnosticError(
            Object.assign(
              {
              },
              res.syntaxError,
              {
                message,
                filename: this.file.uid,
                advice: [___R$project$rome$$romejs$diagnostics$constants_ts$INTERNAL_ERROR_LOG_ADVICE],
              },
            ),
          )
        );
      }
    }

    lockTests() {
      this.locked = true;
    }

    registerTest(callsiteError, options, callback) {
      if (this.locked) {
        throw new Error('Test can\'t be added outside of init');
      }

      let testName = options.name;
      if (Array.isArray(testName)) {
        testName = testName.join(' > ');
      }

      if (this.foundTests.has(testName)) {
        throw new Error('Test ' +
        testName +
        ' has already been defined');
      }

      this.foundTests.set(
        testName,
        {
          callback,
          options,
          callsiteError,
        },
      );

      if (options.only === true) {
        this.hasFocusedTest = true;
      }
    }

    onError(testName, opts) {
      const filename = this.file.real.join();

      let ref = undefined;
      if (testName === undefined) {
        testName = 'unknown';
      } else {
        ref =
          {
            filename,
            testName,
          };
      }

      let diagnostic = ___R$project$rome$$romejs$diagnostics$derive_ts$deriveDiagnosticFromError(
        {
          error: opts.error,
          category: 'tests/failure',
          label: testName,
          filename,
          cleanFrames(frames) {
            // TODO we should actually get the frames before module init and do it that way

            // Remove everything before the original module factory
            let latestTestWorkerFrame = frames.find(
              (frame, i) => {
                if (frame.typeName === 'global' && frame.methodName === undefined &&
                  frame.functionName === undefined) {
                  // We are the global.<anonymous> frame

                  // Now check for Script.runInContext
                  const nextFrame = frames[i + 1];
                  if (nextFrame !== undefined && nextFrame.typeName === 'Script' &&
                    nextFrame.methodName === 'runInContext') {
                    // Yes!

                    // TODO also check for ___$romejs$core$common$utils$executeMain_ts$default (packages/romejs/core/common/utils/executeMain.ts:69:17)
                    return true;
                  }
                }

                return false;
              },
            );

            // And if there was no module factory frame, then we must be inside of a test
            if (latestTestWorkerFrame === undefined) {
              latestTestWorkerFrame =
                frames.find(
                  (frame) => {
                    return (
                      frame.filename !== undefined &&
                        frame.filename.includes(
                          'core/test-worker',
                        )
                    );
                  },
                );
            }

            if (latestTestWorkerFrame === undefined) {
              return frames;
            }

            return frames.slice(0, frames.indexOf(latestTestWorkerFrame));
          },
        },
      );

      diagnostic =
        Object.assign(
          {
          },
          diagnostic,
          {
            advice: [
              ...opts.firstAdvice,
              ...(diagnostic.advice || []),
              ...opts.lastAdvice,
            ],
          },
        );

      this.bridge.testError.send(
        {
          ref,
          diagnostic,
        },
      );
    }

    async teardownTest(testName, api) {
      api.clearTimeout();

      try {
        await api.teardownEvent.callOptional();
      } catch (err) {
        this.onError(
          testName,
          {
            error: err,
            firstAdvice: [],
            lastAdvice: [
              {
                type: 'log',
                category: 'info',
                message: 'Error occured while running <emphasis>teardown</emphasis> for test <emphasis>' +
                testName +
                '</emphasis>',
              },
            ],
          },
        );
      }
    }

    async runTest(testName, callback) {
      let onTimeout = () => {
        throw new Error('Promise wasn\'t created. Should be impossible.');
      };

      const timeoutPromise = new Promise(
        (resolve, reject) => {
          onTimeout =
            (time) => {
              reject(new Error('Test timeout - exceeded ' +
              String(time) +
              'ms'));
            };
        },
      );

      const api = new ___R$project$rome$$romejs$core$test$worker$TestAPI_ts$default(
        {
          file: this.file,
          testName,
          onTimeout,
          snapshotManager: this.snapshotManager,
          options: this.options,
        },
      );

      try {
        const res = callback(api);

        // Ducktyping this to detect a cross-realm Promise
        if (res !== undefined && typeof res.then === 'function') {
          await Promise.race([timeoutPromise, res]);
        }

        this.bridge.testSuccess.send(
          {
            ref: {
              filename: this.file.real.join(),
              testName,
            },
          },
        );
      } catch (err) {
        this.onError(
          testName,
          {
            error: err,
            firstAdvice: [],
            lastAdvice: api.advice,
          },
        );
      } finally {
        await this.teardownTest(testName, api);
      }
    }

    async run() {
      const promises = new Set();

      const {foundTests} = this;
      if (foundTests.size === 0) {
        this.bridge.testError.send(
          {
            ref: undefined,
            diagnostic: {
              filename: this.file.uid,
              message: 'No tests declared in this file',
              category: 'tests/noneDeclared',
            },
          },
        );
      }

      // Execute all the tests
      for (const [testName, {options, callback}] of foundTests) {
        if (callback === undefined) {
          continue;
        }

        this.bridge.testStart.send(
          {
            ref: {
              filename: this.file.real.join(),
              testName,
            },
            timeout: options.timeout,
          },
        );

        const promise = this.runTest(testName, callback);

        if (this.options.syncTests) {
          await promise;
        } else {
          promise.then(
            () => {
              promises.delete(promise);
            },
          );
          promises.add(promise);

          // if there's 5 promises, then wait for one of them to finish
          if (promises.size > ___R$$priv$project$rome$$romejs$core$test$worker$TestWorkerRunner_ts$MAX_RUNNING_TESTS) {
            await Promise.race(Array.from(promises));
          }
        }
      }

      // Execute the remaining tests
      await Promise.all(Array.from(promises));

      // Save the snapshot
      await this.snapshotManager.save();
    }

    async emitFoundTests() {
      const tests = [];

      for (const [testName, {callback, options}] of this.foundTests) {
        let isSkipped = callback === undefined;
        if (this.hasFocusedTest && options.only !== true) {
          isSkipped = true;
        }

        tests.push(
          {
            ref: {
              filename: this.file.real.join(),
              testName,
            },
            isSkipped,
          },
        );
      }

      await this.bridge.testsFound.call(tests);
    }

    async wrap(callback) {
      try {
        await callback();
      } catch (err) {
        const diagnostics = ___R$project$rome$$romejs$diagnostics$errors_ts$getDiagnosticsFromError(err);
        if (diagnostics === undefined) {
          this.onError(
            undefined,
            {
              error: err,
              firstAdvice: [],
              lastAdvice: [
                {
                  type: 'log',
                  category: 'info',
                  message: 'Error occured while executing test file <filelink emphasis target="' +
                  this.file.uid +
                  '" />',
                },
                ___R$project$rome$$romejs$diagnostics$constants_ts$INTERNAL_ERROR_LOG_ADVICE,
              ],
            },
          );
        } else {
          for (const diagnostic of diagnostics) {
            await this.bridge.testError.call(
              {
                ref: undefined,
                diagnostic,
              },
            );
          }
        }
      }
    }

    async prepare() {
      return (
        this.wrap(
          async () => {
            // Setup
            await this.snapshotManager.load();
            await this.discoverTests();
            await this.emitFoundTests();

            // Execute
            this.lockTests();
          },
        )
      );
    }
  }

  // project-rome/@romejs/core/test-worker/TestWorker.ts
const ___R$$priv$project$rome$$romejs$core$test$worker$TestWorker_ts$inspector = require(
    'inspector',
  );
  class ___R$project$rome$$romejs$core$test$worker$TestWorker_ts$default {
    constructor() {
      this.bridge = this.buildBridge();
      this.runners = new Map();
    }

    async init() {
      // TODO randomly generate an open port
      ___R$$priv$project$rome$$romejs$core$test$worker$TestWorker_ts$inspector.open();

      await this.bridge.handshake();
    }

    buildBridge() {
      const bridge = ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromParentProcess(
        ___R$project$rome$$romejs$core$common$bridges$TestWorkerBridge_ts$default,
        {
          type: 'server',
        },
      );

      process.on(
        'unhandledRejection',
        (err) => {
          bridge.testError.send(
            {
              ref: undefined,
              diagnostic: ___R$project$rome$$romejs$diagnostics$derive_ts$deriveDiagnosticFromError(
                {
                  error: err,
                  category: 'tests/unhandledRejection',
                },
              ),
            },
          );
        },
      );

      bridge.inspectorDetails.subscribe(
        () => {
          return (
            {
              inspectorUrl: ___R$$priv$project$rome$$romejs$core$test$worker$TestWorker_ts$inspector.url(),
            }
          );
        },
      );

      bridge.prepareTest.subscribe(
        (data) => {
          return this.prepareTest(data);
        },
      );

      bridge.runTest.subscribe(
        (id) => {
          return this.runTest(id);
        },
      );

      return bridge;
    }

    async runTest(id) {
      const runner = this.runners.get(id);
      if (runner === undefined) {
        throw new Error('No runner ' +
        id +
        ' found');
      } else {
        await runner.run();
      }
    }

    async prepareTest(opts) {
      const runner = new ___R$project$rome$$romejs$core$test$worker$TestWorkerRunner_ts$default(opts, this.bridge);
      await runner.prepare();
      this.runners.set(opts.id, runner);
    }
  }

  // project-rome/@romejs/core/common/bridges/WorkerBridge.ts
class ___R$project$rome$$romejs$core$common$bridges$WorkerBridge_ts$default extends ___R$project$rome$$romejs$events$Bridge_ts$default {
    constructor(...args) {
      super(
        ...args,
      );
      this.log =
        this.createEvent(
          {
            name: 'log',
            direction: 'server->client',
          },
        );
      this.updateProjects =
        this.createEvent(
          {
            name: 'updateProjects',
            direction: 'server->client',
          },
        );
      this.updateManifests =
        this.createEvent(
          {
            name: 'updateManifests',
            direction: 'server->client',
          },
        );
      this.profilingStart =
        this.createEvent(
          {
            name: 'profiling.start',
            direction: 'server->client',
          },
        );
      this.profilingStop =
        this.createEvent(
          {
            name: 'profiling.stop',
            direction: 'server->client',
          },
        );
      this.status =
        this.createEvent(
          {
            name: 'status',
            direction: 'server->client',
          },
        );
      this.evict =
        this.createEvent(
          {
            name: 'evict',
            direction: 'server->client',
          },
        );
      this.format =
        this.createEvent(
          {
            name: 'format',
            direction: 'server->client',
          },
        );
      this.moduleSignatureJS =
        this.createEvent(
          {
            name: 'moduleSignatureJS',
            direction: 'server->client',
          },
        );
      this.analyzeDependencies =
        this.createEvent(
          {
            name: 'analyzeDependencies',
            direction: 'server->client',
          },
        );
      this.lint =
        this.createEvent(
          {name: 'lint', direction: 'server->client'},
        );
      this.compileJS =
        this.createEvent(
          {name: 'compileJS', direction: 'server->client'},
        );
      this.parseJS =
        this.createEvent(
          {name: 'parseJS', direction: 'server->client'},
        );
    }

    init() {
      this.addErrorTransport(
        'DiagnosticsError',
        {
          serialize(err) {
            if (!(err instanceof ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError)) {
              throw new Error('Expected DiagnosticsError');
            }

            return (
              {
                diagnostic: err.diagnostics,
              }
            );
          },

          hydrate(err, data) {
            return (
              new ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError(
                String(err.message),
                ( // rome-suppress lint/noExplicitAny
                data.diagnostics),
              )
            );
          },
        },
      );
    }
  }

  // project-rome/@romejs/core/common/bridges/MasterBridge.ts
class ___R$project$rome$$romejs$core$common$bridges$MasterBridge_ts$default extends ___R$project$rome$$romejs$events$Bridge_ts$default {
    constructor(...args) {
      super(
        ...args,
      );
      this.getClientInfo =
        this.createEvent(
          {
            name: 'getClientInfo',
            direction: 'server->client',
          },
        );
      this.stdout =
        this.createEvent(
          {
            name: 'stdout',
            direction: 'server->client',
          },
        );
      this.stderr =
        this.createEvent(
          {
            name: 'stderr',
            direction: 'server->client',
          },
        );
      this.enableWorkerLogs =
        this.createEvent(
          {
            name: 'enableWorkerLogs',
            direction: 'server<-client',
          },
        );
      this.log =
        this.createEvent(
          {
            name: 'log',
            direction: 'server->client',
          },
        );
      this.setColumns =
        this.createEvent(
          {
            name: 'columns.set',
            direction: 'server<-client',
          },
        );
      this.reporterRemoteServerMessage =
        this.createEvent(
          {
            name: 'reporterRemoteToLocalMessage',
            direction: 'server->client',
          },
        );
      this.reporterRemoteClientMessage =
        this.createEvent(
          {
            name: 'reporterLocalToRemoteMessage',
            direction: 'server<-client',
          },
        );
      this.query =
        this.createEvent(
          {
            name: 'query',
            direction: 'server<-client',
          },
        );
      this.profilingGetWorkers =
        this.createEvent(
          {
            name: 'profiling.getWorkers',
            direction: 'server<-client',
          },
        );
      this.profilingStart =
        this.createEvent(
          {
            name: 'profiling.start',
            direction: 'server<-client',
          },
        );
      this.profilingStop =
        this.createEvent(
          {
            name: 'profiling.stop',
            direction: 'server<-client',
          },
        );
      this.profilingStopWorker =
        this.createEvent(
          {
            name: 'profile.stopWorker',
            direction: 'server<-client',
          },
        );
    }
  }

  // project-rome/@romejs/core/common/bridges/WebBridge.ts
class ___R$project$rome$$romejs$core$common$bridges$WebBridge_ts$default extends ___R$project$rome$$romejs$events$Bridge_ts$default {
    constructor(...args) {
      super(
        ...args,
      );
      this.requests =
        this.createEvent(
          {
            name: 'WebBridge.requests',
            direction: 'server->client',
          },
        );
    }
  }

  // project-rome/@romejs/core/common/bridges/TestWorkerBridge.ts
class ___R$project$rome$$romejs$core$common$bridges$TestWorkerBridge_ts$default extends ___R$project$rome$$romejs$events$Bridge_ts$default {
    constructor(...args) {
      super(
        ...args,
      );
      this.inspectorDetails =
        this.createEvent(
          {
            name: 'inspectorDetails',
            direction: 'server->client',
          },
        );
      this.prepareTest =
        this.createEvent(
          {
            name: 'prepareTest',
            direction: 'server->client',
          },
        );
      this.runTest =
        this.createEvent(
          {
            name: 'runTest',
            direction: 'server->client',
          },
        );
      this.testsFound =
        this.createEvent(
          {
            name: 'onTestFounds',
            direction: 'server<-client',
          },
        );
      this.testStart =
        this.createEvent(
          {
            name: 'onTestStart',
            direction: 'server<-client',
          },
        );
      this.testError =
        this.createEvent(
          {name: 'onTestError', direction: 'server<-client'},
        );
      this.testSuccess =
        this.createEvent(
          {
            name: 'onTestSuccess',
            direction: 'server<-client',
          },
        );
    }
  }

  // project-rome/@romejs/core/index.ts


  // project-rome/@romejs/cli/utils/setProcessTitle.ts
function ___R$project$rome$$romejs$cli$utils$setProcessTitle_ts$default(title) {
    process.title = 'rome-' +
    title;
  }

  // project-rome/@romejs/cli/cli.ts
const ___R$$priv$project$rome$$romejs$cli$cli_ts$fs = require(
    'fs',
  );

  async function ___R$project$rome$$romejs$cli$cli_ts$default() {
    ___R$project$rome$$romejs$cli$utils$setProcessTitle_ts$default('cli');

    const p = ___R$project$rome$$romejs$cli$flags$index_ts$parseCLIFlagsFromProcess(
      {
        programName: 'rome',
        usage: '[command] [flags]',
        defineFlags(
          c,
        ) {
          return (
            {
              clientFlags: Object.assign(
                {
                  clientName: 'cli',
                  cwd: ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(c.get('cwd').asString(process.cwd())),
                  verbose: c.get('verbose').asBoolean(___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_FLAGS.verbose),
                  silent: c.get('silent').asBoolean(___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_FLAGS.silent),
                },
                overrideClientFlags,
              ),

              cliFlags: Object.assign(
                {
                  markersPath: ___R$project$rome$$romejs$path$index_ts$maybeCreateAbsoluteFilePath(
                    c.get('markersPath').asStringOrVoid(),
                  ),
                  profile: c.get('profile').asBoolean(false),
                  profilePath: ___R$project$rome$$romejs$path$index_ts$maybeCreateAbsoluteFilePath(
                    c.get('profilePath').asStringOrVoid(),
                  ),
                  profileTimeout: c.get('profileTimeout').asNumber(0),
                  profileWorkers: c.get('profileWorkers').asBoolean(true),
                  profileSampling: c.get('profileSampling').asNumber(100),
                  temporaryDaemon: c.get('temporaryDaemon').asBoolean(false),
                  rage: c.get('rage').asBoolean(false),
                  ragePath: ___R$project$rome$$romejs$path$index_ts$maybeCreateAbsoluteFilePath(
                    c.get('ragePath').asStringOrVoid(),
                  ),
                  logs: c.get('logs').asBoolean(false),
                  logWorkers: c.get('logWorkers').asBooleanOrVoid(),
                  logPath: ___R$project$rome$$romejs$path$index_ts$maybeCreateAbsoluteFilePath(c.get('logPath').asStringOrVoid()),
                },
                overrideCLIFlags,
              ),

              requestFlags: Object.assign(
                {
                  benchmark: c.get('benchmark').asBoolean(
                    ___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.benchmark,
                  ),
                  benchmarkIterations: c.get('benchmarkIterations').asNumber(
                    ___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.benchmarkIterations,
                  ),
                  collectMarkers: c.get('collectMarkers').asBoolean(
                    ___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.collectMarkers,
                  ),
                  watch: c.get('watch').asBoolean(___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.watch),
                  fieri: c.get('fieri').asBoolean(___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.fieri),
                  focus: c.get('focus').asString(___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.focus),
                  grep: c.get('grep').asString(___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.grep),
                  maxDiagnostics: c.get('maxDiagnostics').asNumber(
                    ___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.maxDiagnostics,
                  ),
                  verboseDiagnostics: c.get('verboseDiagnostics').asBoolean(
                    ___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.verboseDiagnostics,
                  ),
                  showAllDiagnostics: c.get('showAllDiagnostics').asBoolean(
                    ___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.showAllDiagnostics,
                  ),
                  inverseGrep: c.get('inverseGrep').asBoolean(
                    ___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.inverseGrep,
                  ),
                  resolverPlatform: c.get('resolverPlatform').asStringSetOrVoid(
                    ___R$project$rome$$romejs$core$common$types$platform_ts$PLATFORMS,
                  ),
                  resolverScale: c.get('resolverScale').asNumberOrVoid(),
                  resolverMocks: c.get('resolverMocks').asBoolean(
                    ___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.resolverMocks,
                  ),
                },
                overrideRequestFlags,
              ),
            }
          );
        },
      },
    );

    let command = '';
    let overrideClientFlags = {};
    let overrideRequestFlags = {};
    let overrideCLIFlags = {};
    let commandFlags = {};
    let args = [];

    // Create command handlers. We use a set here since we may have some conflicting master and local command names. We always want the local command to take precedence.
    const commandNames = new Set(
      [
        ...___R$project$rome$$romejs$core$client$commands_ts$localCommands.keys(),
        ...___R$project$rome$$romejs$core$master$commands$index_ts$masterCommands.keys(),
      ],
    );
    for (const cmd of commandNames) {
      const local = ___R$project$rome$$romejs$core$client$commands_ts$localCommands.get(cmd);
      if (local !== undefined) {
        p.command(
          {
            name: cmd,
            category: local.category,
            description: local.description,
            defineFlags: local.defineFlags,
            examples: local.examples,
            usage: local.usage,
            callback(_commandFlags) {
              if (local.defineFlags !== undefined) {
                commandFlags = _commandFlags;
              }

              args = p.getArgs();
              command = cmd;
            },
          },
        );
        continue;
      }

      const master = ___R$project$rome$$romejs$core$master$commands$index_ts$masterCommands.get(cmd);
      if (master !== undefined) {
        p.command(
          {
            name: cmd,
            category: master.category,
            description: master.description,
            defineFlags: master.defineFlags,
            usage: master.usage,
            examples: master.examples,

            callback(_commandFlags) {
              if (master.defineFlags !== undefined) {
                commandFlags = _commandFlags;
              }

              if (master.overrideClientFlags !== undefined) {
                overrideClientFlags = master.overrideClientFlags;
              }

              if (master.overrideRequestFlags !== undefined) {
                overrideRequestFlags = master.overrideRequestFlags;
              }

              args = p.getArgs();
              command = cmd;
            },
          },
        );
      }
    }

    // Mock `rage` command that just uses the master noop command and adds the --rage flag
    p.command(
      {
        name: 'rage',
        category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.INTERNAL,
        description: 'TODO',

        callback() {
          overrideCLIFlags =
            {
              rage: true,
            };

          command = '_noop';
        },
      },
    );

    // Mock `logs` command that just uses the master noop command and adds the --logs flag
    p.command(
      {
        name: 'logs',
        category: ___R$project$rome$$romejs$core$commands_ts$commandCategories.INTERNAL,
        description: 'TODO',

        callback() {
          overrideCLIFlags =
            {
              logs: true,
            };

          command = '_noop';
        },
      },
    );

    // Initialize flags
    let {clientFlags, cliFlags, requestFlags} = await p.init();

    // Force collection of markers if markersPath or we are raging
    if (cliFlags.markersPath || cliFlags.rage) {
      requestFlags.collectMarkers = true;
    }

    // Force logs when logPath or logWorkers is set
    if (cliFlags.logPath !== undefined || cliFlags.logWorkers === true) {
      cliFlags.logs = true;
    }

    p.commandRequired();

    const client = new ___R$project$rome$$romejs$core$client$Client_ts$default(
      {
        globalErrorHandlers: true,
        flags: clientFlags,
        stdin: process.stdin,
        stdout: process.stdout,
        stderr: process.stderr,
      },
    );

    client.bridgeAttachedEvent.subscribe(
      async () => {
        const profileOptions = {
          samplingInterval: cliFlags.profileSampling,
          timeoutInterval: cliFlags.profileTimeout,
          includeWorkers: cliFlags.profileWorkers,
        };

        if (cliFlags.rage) {
          const {ragePath} = cliFlags;
          const filename = clientFlags.cwd.resolve(
            ragePath === undefined
              ? 'rome-rage-' +
              ___R$project$rome$$romejs$core$client$Client_ts$getFilenameTimestamp() +
              '.tar.gz' : ragePath,
          ).join();
          await client.rage(filename, profileOptions);
          return;
        }

        if (cliFlags.profile) {
          await client.profile(
            profileOptions,
            async (events) => {
              const {cwd} = clientFlags;
              const {profilePath} = cliFlags;

              const resolvedProfilePath = cwd.resolve(
                profilePath === undefined
                  ? 'Profile-' +
                  ___R$project$rome$$romejs$core$client$Client_ts$getFilenameTimestamp() +
                  '.json' : profilePath,
              );

              const str = JSON.stringify(events, undefined, '  ');
              await ___R$project$rome$$romejs$fs$index_ts$writeFile(resolvedProfilePath, str);

              client.reporter.success(
                'Wrote CPU profile to <filelink emphasis target="' +
                resolvedProfilePath.join() +
                '" />',
              );
            },
          );
        }

        if (cliFlags.logs) {
          let fileout;
          if (cliFlags.logPath !== undefined) {
            fileout =
              ___R$$priv$project$rome$$romejs$cli$cli_ts$fs.createWriteStream(
                clientFlags.cwd.resolve(cliFlags.logPath).join(),
              );

            client.endEvent.subscribe(
              () => {
                if (fileout !== undefined) {
                  fileout.end();
                }
              },
            );
          }

          await client.subscribeLogs(
            cliFlags.logWorkers === true,
            (chunk) => {
              if (fileout === undefined) {
                client.reporter.writeAll(chunk);
              } else {
                fileout.write(___R$project$rome$$romejs$string$ansi$format_ts$stripAnsi(chunk));
              }
            },
          );
        }
      },
    );

    if (cliFlags.temporaryDaemon) {
      await client.forceStartDaemon();
    }

    const res = await client.query(
      {
        command,
        commandFlags,
        args,
        requestFlags,
        // Daemon would have been started before, so terminate when we complete
        terminateWhenIdle: cliFlags.temporaryDaemon,
        // We don't use the data result, so no point transporting it over the bridge
        noData: true,
      },
    );

    await client.end();

    if (res.type === 'SUCCESS') {
      // Write markers if we were collecting them
      if (requestFlags.collectMarkers) {
        const markersPath = clientFlags.cwd.resolve(
          cliFlags.markersPath ===
          undefined
            ? 'Markers-' +
            ___R$project$rome$$romejs$core$client$Client_ts$getFilenameTimestamp() +
            '.json' : cliFlags.markersPath,
        );

        await ___R$project$rome$$romejs$fs$index_ts$writeFile(markersPath, JSON.stringify(res.markers, null, '  '));

        client.reporter.success(
          'Wrote markers to <filelink emphasis target="' +
          markersPath.join() +
          '" />',
        );
      }
    }

    switch (res.type) {
      case 'ERROR':
        if (!res.handled) {
          console.error('Unhandled CLI query error');
          console.error(res.stack);
        }
        process.exit(1);
        break;

      case 'INVALID_REQUEST':
        await p.showHelp();
        process.exit(1);
        break;

      case 'DIAGNOSTICS':
        process.exit(1);
        break;

      case 'SUCCESS':
        process.exit(0);
        break;
    }
  }

  // project-rome/@romejs/cli/master.ts
const ___R$$priv$project$rome$$romejs$cli$master_ts$net = require(
    'net',
  );
  async function ___R$project$rome$$romejs$cli$master_ts$default() {
    ___R$project$rome$$romejs$cli$utils$setProcessTitle_ts$default('master');

    const master = new ___R$project$rome$$romejs$core$master$Master_ts$default(
      {
        dedicated: true,
        globalErrorHandlers: true,
      },
    );

    await master.init();

    const socketServer = ___R$$priv$project$rome$$romejs$cli$master_ts$net.createServer(
      function(socket) {
        const client = ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromSocket(
          ___R$project$rome$$romejs$core$common$bridges$MasterBridge_ts$default,
          socket,
          {
            type: 'client',
          },
        );
        master.attachToBridge(client);
      },
    );

    if (await ___R$project$rome$$romejs$fs$index_ts$exists(___R$project$rome$$romejs$core$common$constants_ts$SOCKET_PATH)) {
      await ___R$project$rome$$romejs$fs$index_ts$unlink(___R$project$rome$$romejs$core$common$constants_ts$SOCKET_PATH);
    }

    socketServer.listen(
      ___R$project$rome$$romejs$core$common$constants_ts$SOCKET_PATH.join(),
      () => {
        const socket = ___R$$priv$project$rome$$romejs$cli$master_ts$net.createConnection(
          ___R$project$rome$$romejs$core$common$constants_ts$CLI_SOCKET_PATH.join(),
          () => {
            socket.end();
          },
        );

        socket.on(
          'error',
          (err) => {
            // Socket error occured, cli could have died before it caught us
            err;
            console.log(err);
            process.exit();
          },
        );
      },
    );
  }

  // project-rome/@romejs/cli/testWorker.ts
function ___R$project$rome$$romejs$cli$testWorker_ts$default() {
    ___R$project$rome$$romejs$cli$utils$setProcessTitle_ts$default('test-worker');
    const worker = new ___R$project$rome$$romejs$core$test$worker$TestWorker_ts$default();
    worker.init();
  }

  // project-rome/@romejs/cli/worker.ts
async function ___R$project$rome$$romejs$cli$worker_ts$default() {
    ___R$project$rome$$romejs$cli$utils$setProcessTitle_ts$default('worker');
    const bridge = ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromParentProcess(
      ___R$project$rome$$romejs$core$common$bridges$WorkerBridge_ts$default,
      {
        type: 'server',
      },
    );
    const worker = new ___R$project$rome$$romejs$core$worker$Worker_ts$default(
      {
        bridge,
        globalErrorHandlers: true,
      },
    );
    await worker.init();
    bridge.handshake();
  }

  // project-rome/@romejs/cli/bin/rome.ts
async function ___R$$priv$project$rome$$romejs$cli$bin$rome_ts$main() {
    switch (process.env.ROME_PROCESS_VERSION === ___R$project$rome$$romejs$core$common$constants_ts$VERSION &&
      process.env.ROME_PROCESS_TYPE) {
      case 'master':
        return ___R$project$rome$$romejs$cli$master_ts$default();

      case 'worker':
        return ___R$project$rome$$romejs$cli$worker_ts$default();

      case 'test-worker':
        return ___R$project$rome$$romejs$cli$testWorker_ts$default();

      default:
        return ___R$project$rome$$romejs$cli$cli_ts$default();
    }
  }

  ___R$project$rome$$romejs$v8$index_ts$sourceMapManager.init();
  ___R$project$rome$$romejs$v8$index_ts$sourceMapManager.addSourceMapFactory(
    ___R$project$rome$$romejs$core$common$constants_ts$BIN.join(),
    () =>
      JSON.parse(___R$project$rome$$romejs$fs$index_ts$readFileTextSync(___R$project$rome$$romejs$core$common$constants_ts$MAP)),
  );

  ___R$$priv$project$rome$$romejs$cli$bin$rome_ts$main().catch(
    (err) => {
      const diags = ___R$project$rome$$romejs$diagnostics$errors_ts$getDiagnosticsFromError(err);
      if (diags === undefined) {
        console.error('Error thrown inside the CLI handler');
        console.error(___R$project$rome$$romejs$v8$errors_ts$getErrorStructure(err).stack);
      } else {
        const reporter = ___R$project$rome$$romejs$cli$reporter$Reporter_ts$default.fromProcess();
        ___R$project$rome$$romejs$cli$diagnostics$index_ts$printDiagnosticsSync(
          diags,
          {
            origins: [],
            reporter,
          },
        );
      }
      process.exit(1);
    },
  );

  // project-rome/rome/bin/rome.ts
const ___R$project$rome$rome$bin$rome_ts = {
  };

  return ___R$project$rome$rome$bin$rome_ts;
})(typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
