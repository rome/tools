#!/usr/bin/env node

(function(res) {
	if (typeof module !== "undefined") {
		module.exports = res;
	}
	return res;
})(
(function(global) {
  'use strict';
  // project-rome/@internal/codec-source-map/base64.ts
const ___R$project$rome$$internal$codec$source$map$base64_ts = {
		encode: ___R$project$rome$$internal$codec$source$map$base64_ts$encode,
		encodeVLQ: ___R$project$rome$$internal$codec$source$map$base64_ts$encodeVLQ,
		decode: ___R$project$rome$$internal$codec$source$map$base64_ts$decode,
		decodeVLQ: ___R$project$rome$$internal$codec$source$map$base64_ts$decodeVLQ,
	};
	/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from 'this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * 'AS IS' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

	const ___R$$priv$project$rome$$internal$codec$source$map$base64_ts$intToCharMap = Array.from(
		"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
	);

	/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
	function ___R$project$rome$$internal$codec$source$map$base64_ts$encode(number) {
		if (
			0 <= number &&
			number <
			___R$$priv$project$rome$$internal$codec$source$map$base64_ts$intToCharMap.length
		) {
			return ___R$$priv$project$rome$$internal$codec$source$map$base64_ts$intToCharMap[number];
		} else {
			throw new TypeError("Must be between 0 and 63: " + number);
		}
	}

	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011
	const ___R$$priv$project$rome$$internal$codec$source$map$base64_ts$VLQ_BASE_SHIFT = 5;

	// binary: 100000
	const ___R$$priv$project$rome$$internal$codec$source$map$base64_ts$VLQ_BASE =
		1 <<
		___R$$priv$project$rome$$internal$codec$source$map$base64_ts$VLQ_BASE_SHIFT;

	// binary: 011111
	const ___R$$priv$project$rome$$internal$codec$source$map$base64_ts$VLQ_BASE_MASK =
		___R$$priv$project$rome$$internal$codec$source$map$base64_ts$VLQ_BASE - 1;

	// binary: 100000
	const ___R$$priv$project$rome$$internal$codec$source$map$base64_ts$VLQ_CONTINUATION_BIT = ___R$$priv$project$rome$$internal$codec$source$map$base64_ts$VLQ_BASE;

	/**
 * Converts from 'a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
	function ___R$$priv$project$rome$$internal$codec$source$map$base64_ts$toVLQSigned(
		aValue,
	) {
		return aValue < 0 ? (-aValue << 1) + 1 : aValue << 1;
	}

	/**
 * Converts to a two-complement value from 'a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
	// eslint-disable-next-line no-unused-vars
	function ___R$$priv$project$rome$$internal$codec$source$map$base64_ts$fromVLQSigned(
		value,
	) {
		const isNegative = (value & 1) === 1;
		const shifted = value >> 1;
		return isNegative ? -shifted : shifted;
	}

	/**
 * Returns the base 64 VLQ encoded value.
 */
	function ___R$project$rome$$internal$codec$source$map$base64_ts$encodeVLQ(
		value,
	) {
		let encoded = "";
		let vlq = ___R$$priv$project$rome$$internal$codec$source$map$base64_ts$toVLQSigned(
			value,
		);

		do {
			let digit =
				vlq &
				___R$$priv$project$rome$$internal$codec$source$map$base64_ts$VLQ_BASE_MASK;
			vlq >>>= ___R$$priv$project$rome$$internal$codec$source$map$base64_ts$VLQ_BASE_SHIFT;
			if (vlq > 0) {
				// There are still more digits in this value, so we must make sure the
				// continuation bit is marked.
				digit |= ___R$$priv$project$rome$$internal$codec$source$map$base64_ts$VLQ_CONTINUATION_BIT;
			}
			encoded += ___R$project$rome$$internal$codec$source$map$base64_ts$encode(
				digit,
			);
		} while (vlq > 0);

		return encoded;
	}

	function ___R$project$rome$$internal$codec$source$map$base64_ts$decode(
		charCode,
	) {
		const uppercaseA = 65; // 'A'
		const uppercaseZ = 90; // 'Z'
		const lowercaseA = 97; // 'a'
		const lowercaseZ = 122; // 'z'
		const zero = 48; // '0'
		const nine = 57; // '9'
		const plus = 43; // '+'
		const slash = 47; // '/'
		const lowercaseOffset = 26;
		const numberOffset = 52;

		// 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
		if (uppercaseA <= charCode && charCode <= uppercaseZ) {
			return charCode - uppercaseA;
		}

		// 26 - 51: abcdefghijklmnopqrstuvwxyz
		if (lowercaseA <= charCode && charCode <= lowercaseZ) {
			return charCode - lowercaseA + lowercaseOffset;
		}

		// 52 - 61: 0123456789
		if (zero <= charCode && charCode <= nine) {
			return charCode - zero + numberOffset;
		}

		// 62: +
		if (charCode === plus) {
			return 62;
		}

		// 63: /
		if (charCode === slash) {
			return 63;
		}

		// Invalid base64 digit.
		return -1;
	}

	function ___R$project$rome$$internal$codec$source$map$base64_ts$decodeVLQ(
		aStr,
		aIndex,
	) {
		let strLen = aStr.length;
		let result = 0;
		let shift = 0;
		let continuation = false;

		do {
			if (aIndex >= strLen) {
				throw new Error("Expected more digits in base 64 VLQ value.");
			}

			let digit = ___R$project$rome$$internal$codec$source$map$base64_ts$decode(
				aStr.charCodeAt(aIndex++),
			);
			if (digit === -1) {
				throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
			}

			continuation = !!(digit &
			___R$$priv$project$rome$$internal$codec$source$map$base64_ts$VLQ_CONTINUATION_BIT);
			digit &= ___R$$priv$project$rome$$internal$codec$source$map$base64_ts$VLQ_BASE_MASK;
			result = result + (digit << shift);
			shift += ___R$$priv$project$rome$$internal$codec$source$map$base64_ts$VLQ_BASE_SHIFT;
		} while (continuation);

		return [
			___R$$priv$project$rome$$internal$codec$source$map$base64_ts$fromVLQSigned(
				result,
			),
			aIndex,
		];
	}


  // project-rome/@internal/ob1/index.ts
function ___R$project$rome$$internal$ob1$index_ts$ob1Add(a, b) {
		// @ts-ignore
		return a + b;
	}

	function ___R$project$rome$$internal$ob1$index_ts$ob1Sub(a, b) {
		// @ts-ignore
		return a - b;
	}

	function ___R$project$rome$$internal$ob1$index_ts$ob1Get0(x) {
		// @ts-ignore
		return x;
	}

	function ___R$project$rome$$internal$ob1$index_ts$ob1Get1(x) {
		// @ts-ignore
		return x;
	}

	function ___R$project$rome$$internal$ob1$index_ts$ob1Get(x) {
		// @ts-ignore
		return x;
	}

	function ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(x) {
		return (x);
	}

	const ___R$project$rome$$internal$ob1$index_ts$ob1Number0 = ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(
		0,
	);
	const ___R$project$rome$$internal$ob1$index_ts$ob1Number0Neg1 = ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(
		-1,
	);

	function ___R$project$rome$$internal$ob1$index_ts$ob1Coerce1(x) {
		return (x);
	}

	const ___R$project$rome$$internal$ob1$index_ts$ob1Number1 = ___R$project$rome$$internal$ob1$index_ts$ob1Coerce1(
		1,
	);
	const ___R$project$rome$$internal$ob1$index_ts$ob1Number1Neg1 = ___R$project$rome$$internal$ob1$index_ts$ob1Coerce1(
		-1,
	);

	function ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0To1(x) {
		// @ts-ignore
		return (x + 1);
	}

	function ___R$project$rome$$internal$ob1$index_ts$ob1Coerce1To0(x) {
		// @ts-ignore
		return (x - 1);
	}

	function ___R$project$rome$$internal$ob1$index_ts$ob1Inc(x) {
		// @ts-ignore
		return x + 1;
	}

	function ___R$project$rome$$internal$ob1$index_ts$ob1Dec(x) {
		// @ts-ignore
		return x - 1;
	}


  // project-rome/@internal/codec-source-map/util.ts
function ___R$$priv$project$rome$$internal$codec$source$map$util_ts$strcmp(a, b) {
		if (a === b) {
			return 0;
		}

		if (a === undefined) {
			return 1;
		}

		if (b === undefined) {
			return -1;
		}

		if (a > b) {
			return 1;
		}

		return -1;
	}

	/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
	function ___R$project$rome$$internal$codec$source$map$util_ts$compareByGeneratedPositionsInflated(
		mappingA,
		mappingB,
	) {
		let cmp =
			___R$project$rome$$internal$ob1$index_ts$ob1Get1(mappingA.generated.line) -
			___R$project$rome$$internal$ob1$index_ts$ob1Get1(mappingB.generated.line);
		if (cmp !== 0) {
			return cmp;
		}

		cmp =
			___R$project$rome$$internal$ob1$index_ts$ob1Get0(
				mappingA.generated.column,
			) -
			___R$project$rome$$internal$ob1$index_ts$ob1Get0(
				mappingB.generated.column,
			);
		if (cmp !== 0) {
			return cmp;
		}

		cmp = ___R$$priv$project$rome$$internal$codec$source$map$util_ts$strcmp(
			mappingA.source,
			mappingB.source,
		);
		if (cmp !== 0) {
			return cmp;
		}

		if (mappingA.original == null) {
			if (mappingB.original != null) {
				return 1;
			}
		} else if (mappingB.original == null) {
			return -1;
		} else {
			cmp =
				___R$project$rome$$internal$ob1$index_ts$ob1Get1(mappingA.original.line) -
				___R$project$rome$$internal$ob1$index_ts$ob1Get1(mappingB.original.line);
			if (cmp !== 0) {
				return cmp;
			}

			cmp =
				___R$project$rome$$internal$ob1$index_ts$ob1Get0(
					mappingA.original.column,
				) -
				___R$project$rome$$internal$ob1$index_ts$ob1Get0(
					mappingB.original.column,
				);
			if (cmp !== 0) {
				return cmp;
			}
		}

		return ___R$$priv$project$rome$$internal$codec$source$map$util_ts$strcmp(
			mappingA.name,
			mappingB.name,
		);
	}

	function ___R$project$rome$$internal$codec$source$map$util_ts$toRelativeUrl(
		root,
		path,
	) {
		if (root === "") {
			root = ".";
		}

		root = root.replace(/\/$/, "");

		// It is possible for the path to be above the root. In this case, simply

		// checking whether the root is a prefix of the path won't work. Instead, we

		// need to remove components from the root one by one, until either we find

		// a prefix that fits, or we run out of components to remove.
		let level = 0;
		while (path.indexOf(root + "/") !== 0) {
			const index = root.lastIndexOf("/");
			if (index < 0) {
				return path;
			}

			// If the only part of the root that is left is the scheme (i.e. http://,

			// file:///, etc.), one or more slashes (/), or simply nothing at all, we

			// have exhausted all components, so the path is not relative to the root.
			root = root.slice(0, index);
			if (root.match(/^([^\/]+:\/)?\/*$/)) {
				return path;
			}

			++level;
		}

		// Make sure we add a '../' for each component we removed from the root.

		return "../".repeat(level) + path.substr(root.length + 1);
	}


  // project-rome/@internal/codec-source-map/ArraySet.ts
class ___R$project$rome$$internal$codec$source$map$ArraySet_ts$default {
		constructor() {
			this.array = [];
			this.set = new Map();
		}

		/**
   * Add the given string to this set.
   */
		add(str, allowDuplicates) {
			const isDuplicate = this.has(str);
			const idx = this.array.length;

			if (!isDuplicate || allowDuplicates === true) {
				this.array.push(str);
			}

			if (!isDuplicate) {
				this.set.set(str, idx);
			}
		}

		/**
   * Is the given string a member of this set?
   */
		has(str) {
			return this.set.has(str);
		}

		/**
   * What is the index of the given string in the array?
   */
		indexOf(str) {
			const idx = this.set.get(str);
			if (idx === undefined || idx < 0) {
				throw new Error(str + " is not in the set");
			}
			return idx;
		}

		/**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
		toArray() {
			return this.array.slice();
		}
	}


  // project-rome/@internal/codec-source-map/MappingList.ts
/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
	function ___R$$priv$project$rome$$internal$codec$source$map$MappingList_ts$generatedPositionAfter(
		mappingA,
		mappingB,
	) {
		// Optimized for most common case
		const lineA = mappingA.generated.line;
		const lineB = mappingB.generated.line;
		const columnA = mappingA.generated.column;
		const columnB = mappingB.generated.column;
		return (
			lineB > lineA ||
			(lineB === lineA && columnB >= columnA) ||
			___R$project$rome$$internal$codec$source$map$util_ts$compareByGeneratedPositionsInflated(
				mappingA,
				mappingB,
			) <= 0
		);
	}

	/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a negligible overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
	class ___R$project$rome$$internal$codec$source$map$MappingList_ts$default {
		constructor() {
			this.array = [];
			this.sorted = true;
			this.last = {
				generated: {
					index: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
					line: ___R$project$rome$$internal$ob1$index_ts$ob1Number1Neg1,
					column: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
				},
				// TODO: original: undefined
				original: {
					line: ___R$project$rome$$internal$ob1$index_ts$ob1Number1Neg1,
					column: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
				},
				source: undefined,
				name: undefined,
			};
		}

		/**
   * Add the given source mapping.
   */
		add(mapping) {
			if (
				___R$$priv$project$rome$$internal$codec$source$map$MappingList_ts$generatedPositionAfter(
					this.last,
					mapping,
				)
			) {
				this.last = mapping;
				this.array.push(mapping);
			} else {
				this.sorted = false;
				this.array.push(mapping);
			}
		}

		/**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */
		toArray() {
			if (!this.sorted) {
				this.array.sort(
					___R$project$rome$$internal$codec$source$map$util_ts$compareByGeneratedPositionsInflated,
				);
				this.sorted = true;
			}
			return this.array;
		}
	}


  // project-rome/@internal/codec-source-map/SourceMapConsumer.ts
function ___R$project$rome$$internal$codec$source$map$SourceMapConsumer_ts$getParsedMappingKey(
		line,
		column,
	) {
		return String(line) + ":" + String(column);
	}

	class ___R$project$rome$$internal$codec$source$map$SourceMapConsumer_ts$default {
		constructor(file, getMappings) {
			this.file = file;
			this._getMappings = getMappings;
			this.mappings = undefined;
		}

		static charIsMappingSeparator(str, index) {
			const c = str.charAt(index);
			return c === ";" || c === ",";
		}

		static fromJSON(sourceMap) {
			return new ___R$project$rome$$internal$codec$source$map$SourceMapConsumer_ts$default(
				sourceMap.file,
				() =>
					___R$project$rome$$internal$codec$source$map$SourceMapConsumer_ts$default.parseMappings(
						sourceMap,
					)
				,
			);
		}

		static fromJSONLazy(file, getSourceMap) {
			return new ___R$project$rome$$internal$codec$source$map$SourceMapConsumer_ts$default(
				file,
				() =>
					___R$project$rome$$internal$codec$source$map$SourceMapConsumer_ts$default.parseMappings(
						getSourceMap(),
					)
				,
			);
		}

		static parseMappings(sourceMap) {
			const rawStr = sourceMap.mappings;
			const map = new Map();

			let generatedLine = ___R$project$rome$$internal$ob1$index_ts$ob1Number1;
			let previousGeneratedColumn = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;
			let previousOriginalLine = ___R$project$rome$$internal$ob1$index_ts$ob1Number1;
			let previousOriginalColumn = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;
			let previousSource = 0;
			let previousName = 0;
			let length = rawStr.length;
			let index = 0;
			let cachedSegments = {};
			let value;

			while (index < length) {
				const char = rawStr[index];
				if (char === ";") {
					generatedLine = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(
						generatedLine,
					);
					index++;
					previousGeneratedColumn = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;
				} else if (char === ",") {
					index++;
				} else {
					const mapping = {
						generated: {
							line: generatedLine,
							column: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
						},
						original: {
							line: ___R$project$rome$$internal$ob1$index_ts$ob1Number1,
							column: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
						},
						source: undefined,
						name: undefined,
					};

					// Because each offset is encoded relative to the previous one,
					// many segments often have the same encoding. We can exploit this
					// fact by caching the parsed variable length fields of each segment,
					// allowing us to avoid a second parse if we encounter the same
					// segment again.
					let end = index;
					for (; end < length; end++) {
						if (
							___R$project$rome$$internal$codec$source$map$SourceMapConsumer_ts$default.charIsMappingSeparator(
								rawStr,
								end,
							)
						) {
							break;
						}
					}
					const str = rawStr.slice(index, end);

					let segment = cachedSegments[str];
					if (segment) {
						index += str.length;
					} else {
						segment = [];
						while (index < end) {
							[value, index] = ___R$project$rome$$internal$codec$source$map$base64_ts$decodeVLQ(
								rawStr,
								index,
							);
							segment.push(value);
						}

						if (segment.length === 2) {
							throw new Error("Found a source, but no line and column");
						}

						if (segment.length === 3) {
							throw new Error("Found a source and line, but no column");
						}

						cachedSegments[str] = segment;
					}

					// Generated column
					mapping.generated.column = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
						previousGeneratedColumn,
						segment[0],
					);
					previousGeneratedColumn = mapping.generated.column;

					if (segment.length > 1) {
						// Original source
						mapping.source = sourceMap.sources[previousSource + segment[1]];
						previousSource += segment[1];

						// Original line
						const newOriginalLine = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
							previousOriginalLine,
							segment[2],
						);
						previousOriginalLine = newOriginalLine;

						// Lines are stored 0-based
						mapping.original.line = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
							newOriginalLine,
							1,
						);

						// Original column
						const newOriginalColumn = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
							previousOriginalColumn,
							segment[3],
						);
						mapping.original.column = newOriginalColumn;
						previousOriginalColumn = newOriginalColumn;

						if (segment.length > 4) {
							// Original name
							mapping.name = sourceMap.names[previousName + segment[4]];
							previousName += segment[4];
						}
					}

					map.set(
						___R$project$rome$$internal$codec$source$map$SourceMapConsumer_ts$getParsedMappingKey(
							mapping.generated.line,
							mapping.generated.column,
						),
						mapping,
					);
				}
			}

			return map;
		}

		clearCache() {
			this.mappings = undefined;
		}

		getMappings() {
			if (this.mappings === undefined) {
				const mappings = this._getMappings();
				this.mappings = mappings;
				return mappings;
			} else {
				return this.mappings;
			}
		}

		approxOriginalPositionFor(line, column) {
			while (___R$project$rome$$internal$ob1$index_ts$ob1Get0(column) >= 0) {
				const mapping = this.exactOriginalPositionFor(line, column);
				if (mapping === undefined) {
					column = ___R$project$rome$$internal$ob1$index_ts$ob1Dec(column);
				} else {
					return mapping;
				}
			}

			return undefined;
		}

		exactOriginalPositionFor(line, column) {
			const key = ___R$project$rome$$internal$codec$source$map$SourceMapConsumer_ts$getParsedMappingKey(
				line,
				column,
			);
			const mapping = this.getMappings().get(key);
			if (mapping === undefined) {
				return undefined;
			}

			const source = mapping.source == null ? this.file : mapping.source;
			if (source === undefined) {
				throw new Error("Mapping provided unknown source");
			}

			return {
				found: true,
				source,
				line: mapping.original.line,
				column: mapping.original.column,
				name: mapping.name,
			};
		}
	}


  // project-rome/@internal/collections/index.ts
class ___R$project$rome$$internal$collections$index_ts$ExtendedMap {
		constructor(name, getDefaultValue) {
			this.map = new Map();
			this.name = name;
			this.getDefaultValue = getDefaultValue;
		}

		toMap() {
			return this.map;
		}

		assert(key, allowDefault = true) {
			const val = this.map.get(key);
			if (val !== undefined) {
				return val;
			}

			const {getDefaultValue} = this;
			if (getDefaultValue !== undefined && allowDefault) {
				const value = getDefaultValue(key);
				this.set(key, value);
				return value;
			} else {
				throw new Error(
					"Map " + this.name + " does not contain key " + String(key),
				);
			}
		}

		get size() {
			return this.map.size;
		}

		has(key) {
			return this.map.has(key);
		}

		get(key) {
			return this.map.get(key);
		}

		set(key, value) {
			this.map.set(key, value);
		}

		delete(key) {
			return this.map.delete(key);
		}

		keys() {
			return this.map.keys();
		}

		values() {
			return this.map.values();
		}

		[Symbol.iterator]() {
			return this.map[Symbol.iterator]();
		}
	}


  // project-rome/@internal/codec-source-map/SourceMapGenerator.ts
class ___R$project$rome$$internal$codec$source$map$SourceMapGenerator_ts$default {
		constructor(args) {
			this.file = args.file;
			this.sourceRoot = args.sourceRoot;

			this.sourcesContents = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
				"sourcesContents",
			);
			this.map = undefined;
			this.sources = new ___R$project$rome$$internal$codec$source$map$ArraySet_ts$default();
			this.names = new ___R$project$rome$$internal$codec$source$map$ArraySet_ts$default();
			this.mappings = new ___R$project$rome$$internal$codec$source$map$MappingList_ts$default();
			this.materializeCallbacks = [];
		}

		assertUnlocked() {
			if (this.map !== undefined) {
				throw new Error(
					"Source map has already been materialized, serialize() should be your final call",
				);
			}
		}

		addMaterializer(fn) {
			this.materializeCallbacks.push(fn);
		}

		/**
   * Add a single mapping from 'original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
		addMapping(mapping) {
			this.assertUnlocked();

			const {name, source} = mapping;

			this.validatePosition(
				"generated",
				mapping.generated.line,
				mapping.generated.column,
			);

			if (mapping.original) {
				this.validatePosition(
					"original",
					mapping.original.line,
					mapping.original.column,
				);
			}

			if (source !== undefined) {
				this.sources.add(source);
			}

			if (name !== undefined) {
				this.names.add(name);
			}

			this.mappings.add(mapping);
		}

		/**
   * Set the source content for a source file.
   */
		setSourceContent(source, sourceContent) {
			this.assertUnlocked();

			if (this.sourceRoot !== undefined) {
				source = ___R$project$rome$$internal$codec$source$map$util_ts$toRelativeUrl(
					this.sourceRoot,
					source,
				);
			}

			if (sourceContent !== undefined) {
				// Add the source content to the _sourcesContents map.
				this.sourcesContents.set(source, sourceContent);
			} else {
				// Remove the source file from the _sourcesContents map.
				this.sourcesContents.delete(source);
			}
		}

		validatePosition(key, line, column) {
			if (___R$project$rome$$internal$ob1$index_ts$ob1Get1(line) <= 0) {
				throw new Error(key + " line should be >= 1 but is " + line);
			}

			if (___R$project$rome$$internal$ob1$index_ts$ob1Get0(column) < 0) {
				throw new Error(key + " column should be >= 0 but is " + column);
			}
		}

		/**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
		serializeMappings() {
			let previousGeneratedColumn = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;
			let previousGeneratedLine = ___R$project$rome$$internal$ob1$index_ts$ob1Number1;
			let previousOriginalColumn = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;
			let previousOriginalLine = ___R$project$rome$$internal$ob1$index_ts$ob1Number1;
			let previousName = 0;
			let previousSource = 0;
			let result = "";

			const mappings = this.mappings.toArray();
			for (let i = 0; i < mappings.length; i++) {
				const mapping = mappings[i];
				let next = "";

				if (mapping.generated.line !== previousGeneratedLine) {
					previousGeneratedColumn = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;
					while (mapping.generated.line !== previousGeneratedLine) {
						next += ";";
						previousGeneratedLine = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(
							previousGeneratedLine,
						);
					}
				} else if (i > 0) {
					if (
						!___R$project$rome$$internal$codec$source$map$util_ts$compareByGeneratedPositionsInflated(
							mapping,
							mappings[i - 1],
						)
					) {
						continue;
					}
					next += ",";
				}

				next += ___R$project$rome$$internal$codec$source$map$base64_ts.encodeVLQ(
					___R$project$rome$$internal$ob1$index_ts$ob1Get0(
						mapping.generated.column,
					) -
					___R$project$rome$$internal$ob1$index_ts$ob1Get0(
						previousGeneratedColumn,
					),
				);
				previousGeneratedColumn = mapping.generated.column;

				if (mapping.source !== undefined) {
					const sourceIdx = this.sources.indexOf(mapping.source);
					next += ___R$project$rome$$internal$codec$source$map$base64_ts.encodeVLQ(
						sourceIdx - previousSource,
					);
					previousSource = sourceIdx;

					if (mapping.original) {
						next += ___R$project$rome$$internal$codec$source$map$base64_ts.encodeVLQ(
							___R$project$rome$$internal$ob1$index_ts$ob1Get1(
								mapping.original.line,
							) -
							___R$project$rome$$internal$ob1$index_ts$ob1Get1(
								previousOriginalLine,
							),
						);
						previousOriginalLine = mapping.original.line;

						next += ___R$project$rome$$internal$codec$source$map$base64_ts.encodeVLQ(
							___R$project$rome$$internal$ob1$index_ts$ob1Get0(
								mapping.original.column,
							) -
							___R$project$rome$$internal$ob1$index_ts$ob1Get0(
								previousOriginalColumn,
							),
						);
						previousOriginalColumn = mapping.original.column;

						if (mapping.name !== undefined) {
							const nameIdx = this.names.indexOf(mapping.name);
							next += ___R$project$rome$$internal$codec$source$map$base64_ts.encodeVLQ(
								nameIdx - previousName,
							);
							previousName = nameIdx;
						}
					}

					// TODO: else, assert mapping.name is undefined since it can't be encoded without an original position
				}

				// TODO: else, assert mapping.original is undefined since it can't be encoded without a source
				result += next;
			}

			return result;
		}

		generateSourcesContent(sources, sourceRoot) {
			return sources.map((source) => {
				if (sourceRoot !== undefined) {
					source = ___R$project$rome$$internal$codec$source$map$util_ts$toRelativeUrl(
						sourceRoot,
						source,
					);
				}
				return this.sourcesContents.assert(source);
			});
		}

		materialize() {
			for (const fn of this.materializeCallbacks) {
				fn();
			}
			this.materializeCallbacks = [];
		}

		/**
   * Externalize the source map.
   */
		serialize() {
			if (this.map !== undefined) {
				return this.map;
			}

			this.materialize();

			const sources = this.sources.toArray();
			this.map = {
				version: 3,
				file: this.file,
				names: this.names.toArray(),
				mappings: this.serializeMappings(),
				sourceRoot: this.sourceRoot,
				sources,
				sourcesContent: this.generateSourcesContent(sources, this.sourceRoot),
			};
			return this.map;
		}

		toComment() {
			const jsonMap = this.toJSON();
			const base64Map = Buffer.from(jsonMap).toString("base64");
			const comment =
				"//# sourceMappingURL=data:application/json;charset=utf-8;base64," +
				base64Map;
			return comment;
		}

		toConsumer() {
			return new ___R$project$rome$$internal$codec$source$map$SourceMapConsumer_ts$default(
				this.file,
				() => {
					const parsedMappings = new Map();

					for (const mapping of this.getMappings()) {
						parsedMappings.set(
							___R$project$rome$$internal$codec$source$map$SourceMapConsumer_ts$getParsedMappingKey(
								mapping.generated.line,
								mapping.generated.column,
							),
							mapping,
						);
					}

					return parsedMappings;
				},
			);
		}

		getMappings() {
			this.materialize();
			return this.mappings.toArray();
		}

		toJSON() {
			return JSON.stringify(this.serialize());
		}
	}


  // project-rome/@internal/codec-source-map/SourceMapConsumerCollection.ts
class ___R$project$rome$$internal$codec$source$map$SourceMapConsumerCollection_ts$default {
		constructor() {
			this.maps = new Map();
		}

		hasAny() {
			return this.maps.size > 0;
		}

		has(file) {
			return file !== undefined && this.maps.has(file);
		}

		add(file, map) {
			this.maps.set(file, map);
		}

		get(file) {
			return this.maps.get(file);
		}

		normalizeResolved(source, line, column, loc) {
			if (loc === undefined) {
				return {
					found: false,
					source,
					line,
					column,
					name: undefined,
				};
			} else {
				return loc;
			}
		}

		assertApproxOriginalPositionFor(file, line, column) {
			return this.normalizeResolved(
				file,
				line,
				column,
				this.approxOriginalPositionFor(file, line, column),
			);
		}

		assertExactOriginalPositionFor(file, line, column) {
			return this.normalizeResolved(
				file,
				line,
				column,
				this.exactOriginalPositionFor(file, line, column),
			);
		}

		approxOriginalPositionFor(file, line, column) {
			const map = this.get(file);
			if (map === undefined) {
				return undefined;
			} else {
				return map.approxOriginalPositionFor(line, column);
			}
		}

		exactOriginalPositionFor(file, line, column) {
			const map = this.get(file);
			if (map === undefined) {
				return undefined;
			} else {
				return map.exactOriginalPositionFor(line, column);
			}
		}
	}


  // project-rome/@internal/codec-source-map/types.ts



  // project-rome/@internal/codec-source-map/index.ts



  // project-rome/@internal/v8/types.ts
const ___R$project$rome$$internal$v8$types_ts = {};
	const ___R$$priv$project$rome$$internal$v8$types_ts$inspector = require(
		"inspector",
	);


  // project-rome/@internal/typescript-helpers/index.ts
function ___R$project$rome$$internal$typescript$helpers$index_ts$isPlainObject(
		obj,
	) {
		return typeof obj === "object" && obj !== null && !Array.isArray(obj);
	}

	function ___R$project$rome$$internal$typescript$helpers$index_ts$isIterable(
		obj,
	) {
		if (typeof obj === "object" && obj != null) {
			// @ts-ignore
			return typeof obj[Symbol.iterator] === "function";
		} else {
			return false;
		}
	}

	function ___R$project$rome$$internal$typescript$helpers$index_ts$mergeObjects(
		a,
		b,
	) {
		if (b === undefined) {
			return a;
		}

		const newObj = Object.assign({}, a, b);

		// If b contains undefined properties then use the value from A
		for (const key in b) {
			if (b[key] === undefined) {
				// @ts-ignore
				newObj[key] = a[key];
			}
		}

		return newObj;
	}


  // project-rome/@internal/cli-diagnostics/types.ts
const ___R$project$rome$$internal$cli$diagnostics$types_ts = {};


  // project-rome/@internal/string-utils/dedent.ts
function ___R$project$rome$$internal$string$utils$dedent_ts$dedent(
		literals,
		...values
	) {
		var ___R$;
		let string = "";

		if (typeof literals === "string") {
			string = literals;
		} else {
			const parts = [];

			if (literals.raw) {
				// Perform the interpolation
				for (let i = 0; i < literals.raw.length; i++) {
					parts.push(literals.raw[i]);
					if (i < values.length) {
						parts.push(values[i]);
					}
				}
			}

			string = parts.join("");
		}

		// Find min indentation
		const match = string.match(/^[ \t]*(?=\S)/gm);
		if (match === null) {
			return string;
		}

		const indent =
			(___R$ = Math, ___R$.min.apply(___R$, [...match.map((x) => x.length)]));

		// Remove indentation
		return string.replace(new RegExp("^[ \\t]{" + indent + "}", "gm"), "").trim();
	}


  // project-rome/@internal/string-utils/isEscaped.ts
function ___R$project$rome$$internal$string$utils$isEscaped_ts$isEscaped(
		index,
		input,
	) {
		const prevChar = input[___R$project$rome$$internal$ob1$index_ts$ob1Get0(
			index,
		) - 1];

		if (prevChar === "\\") {
			return !___R$project$rome$$internal$string$utils$isEscaped_ts$isEscaped(
				___R$project$rome$$internal$ob1$index_ts$ob1Dec(index),
				input,
			);
		} else {
			return false;
		}
	}


  // project-rome/@internal/string-utils/escapeSplit.ts
function ___R$project$rome$$internal$string$utils$escapeSplit_ts$escapeSplit(
		input,
		splitChar,
	) {
		const parts = [];
		const unescapeRegex = new RegExp("\\\\" + splitChar, "g");

		let buff = "";

		function push() {
			buff = buff.replace(unescapeRegex, splitChar);
			parts.push(buff);
			buff = "";
		}

		for (let i = 0; i < input.length; i++) {
			let char = input[i];

			if (
				!___R$project$rome$$internal$string$utils$isEscaped_ts$isEscaped(
					___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(i),
					input,
				) &&
				char === splitChar
			) {
				push();
			} else {
				buff += char;
			}
		}

		push();

		return parts;
	}


  // project-rome/@internal/string-utils/orderBySimilarity.ts
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

	function ___R$$priv$project$rome$$internal$string$utils$orderBySimilarity_ts$getMap(
		map,
		key,
		defaultValue,
	) {
		const existing = map.get(key);

		if (existing === undefined) {
			if (defaultValue === undefined) {
				throw new Error("Key didn't exist and no defaultValue passed");
			}

			map.set(key, defaultValue);
			return defaultValue;
		} else {
			return existing;
		}
	}

	/**
 * Forked from the project https://github.com/aceakash/string-similarity by Akash K, licensed under ISC
 */
	function ___R$project$rome$$internal$string$utils$orderBySimilarity_ts$compareTwoStrings(
		aStr,
		bStr,
	) {
		const a = aStr.replace(/\s+/g, "");
		const b = bStr.replace(/\s+/g, "");

		// If both are empty strings
		if (!a.length && !b.length) {
			return 1;
		}

		// If only one is empty string
		if (!a.length || !b.length) {
			return 0;
		}

		// Identical
		if (a === b) {
			return 1;
		}

		// Both are 1-letter strings
		if (a.length === 1 && b.length === 1) {
			return 0;
		}

		// If either is a 1-letter string
		if (a.length < 2 || b.length < 2) {
			return 0;
		}

		let firstBigrams = new Map();
		for (let i = 0; i < a.length - 1; i++) {
			const bigram = a.substring(i, i + 2);

			const count = firstBigrams.has(bigram)
				? ___R$$priv$project$rome$$internal$string$utils$orderBySimilarity_ts$getMap(
						firstBigrams,
						bigram,
					) + 1
				: 1;
			if (count === undefined) {
				throw new Error("Already used has() above");
			}

			firstBigrams.set(bigram, count);
		}

		let intersectionSize = 0;
		for (let i = 0; i < b.length - 1; i++) {
			const bigram = b.substring(i, i + 2);

			const count = ___R$$priv$project$rome$$internal$string$utils$orderBySimilarity_ts$getMap(
				firstBigrams,
				bigram,
				0,
			);
			if (count === undefined) {
				throw new Error("Already used has() above");
			}

			if (count > 0) {
				firstBigrams.set(bigram, count - 1);
				intersectionSize++;
			}
		}

		return 2 * intersectionSize / (a.length + b.length - 2);
	}

	function ___R$project$rome$$internal$string$utils$orderBySimilarity_ts$orderBySimilarity(
		compareStr,
		targets,
		{minRating, ignoreCase = false} = {},
	) {
		if (targets.length === 0) {
			return [];
		}

		// Calculate the rating for each target string
		const ratings = Array.from(
			targets,
			(target) => {
				if (ignoreCase) {
					return {
						target,
						rating: ___R$project$rome$$internal$string$utils$orderBySimilarity_ts$compareTwoStrings(
							compareStr.toLowerCase(),
							target.toLowerCase(),
						),
					};
				}

				return {
					target,
					rating: ___R$project$rome$$internal$string$utils$orderBySimilarity_ts$compareTwoStrings(
						compareStr,
						target,
					),
				};
			},
		);

		// Sort ratings, with the highest at the beginning
		const sortedRatings = ratings.sort((a, b) => {
			return b.rating - a.rating;
		}).filter((item) => minRating === undefined || item.rating >= minRating);

		return sortedRatings;
	}


  // project-rome/@internal/string-utils/findClosestStringMatch.ts
function ___R$project$rome$$internal$string$utils$findClosestStringMatch_ts$findClosestStringMatch(
		name,
		matches,
		minRating = 0.8,
	) {
		if (matches.length === 0) {
			return undefined;
		}

		if (matches.length === 1) {
			return matches[0];
		}

		const ratings = ___R$project$rome$$internal$string$utils$orderBySimilarity_ts$orderBySimilarity(
			name,
			matches,
		);
		const bestMatch = ratings[0];

		if (bestMatch.rating >= minRating) {
			return bestMatch.target;
		} else {
			return undefined;
		}
	}


  // project-rome/@internal/string-utils/humanizeNumber.ts
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

	const ___R$$priv$project$rome$$internal$string$utils$humanizeNumber_ts$SCIENTIFIC_NOTATION = /e/i;

	function ___R$project$rome$$internal$string$utils$humanizeNumber_ts$humanizeNumber(
		num,
		sep = "_",
	) {
		let str = String(num);

		if (num < 1_000) {
			return str;
		}

		if (
			___R$$priv$project$rome$$internal$string$utils$humanizeNumber_ts$SCIENTIFIC_NOTATION.test(
				str,
			)
		) {
			return str;
		}

		const decimals = str.split(".");

		let intChars = String(decimals.shift()).split("");
		let intParts = [];

		while (intChars.length > 0) {
			const part = intChars.slice(-3).join("");
			intParts.unshift(part);

			intChars = intChars.slice(0, -3);
		}

		return [intParts.join(sep), ...decimals].join(".");
	}


  // project-rome/@internal/string-utils/humanizeFileSize.ts
const ___R$$priv$project$rome$$internal$string$utils$humanizeFileSize_ts$UNITS = [
		"B",
		"kB",
		"MB",
		"GB",
		"TB",
		"PB",
		"EB",
		"ZB",
		"YB",
	];

	function ___R$project$rome$$internal$string$utils$humanizeFileSize_ts$humanizeFileSize(
		bytes,
	) {
		if (bytes === 0) {
			return "0B";
		}

		const exponent = Math.min(
			Math.floor(Math.log10(bytes) / 3),
			___R$$priv$project$rome$$internal$string$utils$humanizeFileSize_ts$UNITS.length -
			1,
		);
		const specific = Number((bytes / Math.pow(1_000, exponent)).toPrecision(3));
		const unit = ___R$$priv$project$rome$$internal$string$utils$humanizeFileSize_ts$UNITS[exponent];
		return (
			___R$project$rome$$internal$string$utils$humanizeNumber_ts$humanizeNumber(
				specific,
			) + unit
		);
	}


  // project-rome/@internal/string-utils/humanizeTime.ts
function ___R$project$rome$$internal$string$utils$humanizeTime_ts$humanizeTime(
		ms,
		allowMilliseconds = false,
	) {
		if (ms === 0) {
			if (allowMilliseconds) {
				return "0ms";
			} else {
				return "0s";
			}
		}

		const s = Math.floor(ms / 1_000);
		const m = Math.floor(s / 60);
		const h = Math.floor(m / 60);

		if (h === 0 && m === 0 && s === 0) {
			if (allowMilliseconds) {
				return ms + "ms";
			} else {
				return (ms / 1_000).toFixed(2) + "s";
			}
		}

		let buf = "";
		if (h > 0) {
			buf += String(h) + "h";
		}
		if (m > 0) {
			buf += String(m % 60) + "m";
		}
		buf += String(s % 60) + "s";
		return buf;
	}


  // project-rome/@internal/string-charcodes/index.ts
const ___R$project$rome$$internal$string$charcodes$index_ts = {
		get backSpace() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$backSpace;
		},
		get tab() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$tab;
		},
		get lineFeed() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lineFeed;
		},
		get carriageReturn() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$carriageReturn;
		},
		get shiftOut() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$shiftOut;
		},
		get space() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$space;
		},
		get exclamationMark() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$exclamationMark;
		},
		get quotationMark() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$quotationMark;
		},
		get numberSign() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$numberSign;
		},
		get dollarSign() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$dollarSign;
		},
		get percentSign() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$percentSign;
		},
		get ampersand() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$ampersand;
		},
		get apostrophe() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$apostrophe;
		},
		get leftParenthesis() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$leftParenthesis;
		},
		get rightParenthesis() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$rightParenthesis;
		},
		get asterisk() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$asterisk;
		},
		get plusSign() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$plusSign;
		},
		get comma() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$comma;
		},
		get dash() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$dash;
		},
		get dot() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$dot;
		},
		get slash() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$slash;
		},
		get digit0() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$digit0;
		},
		get digit1() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$digit1;
		},
		get digit2() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$digit2;
		},
		get digit3() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$digit3;
		},
		get digit4() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$digit4;
		},
		get digit5() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$digit5;
		},
		get digit6() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$digit6;
		},
		get digit7() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$digit7;
		},
		get digit8() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$digit8;
		},
		get digit9() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$digit9;
		},
		get colon() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$colon;
		},
		get semicolon() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$semicolon;
		},
		get lessThan() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lessThan;
		},
		get equalsTo() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$equalsTo;
		},
		get greaterThan() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$greaterThan;
		},
		get questionMark() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$questionMark;
		},
		get atSign() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$atSign;
		},
		get uppercaseA() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseA;
		},
		get uppercaseB() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseB;
		},
		get uppercaseC() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseC;
		},
		get uppercaseD() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseD;
		},
		get uppercaseE() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseE;
		},
		get uppercaseF() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseF;
		},
		get uppercaseG() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseG;
		},
		get uppercaseH() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseH;
		},
		get uppercaseI() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseI;
		},
		get uppercaseJ() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseJ;
		},
		get uppercaseK() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseK;
		},
		get uppercaseL() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseL;
		},
		get uppercaseM() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseM;
		},
		get uppercaseN() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseN;
		},
		get uppercaseO() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseO;
		},
		get uppercaseP() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseP;
		},
		get uppercaseQ() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseQ;
		},
		get uppercaseR() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseR;
		},
		get uppercaseS() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseS;
		},
		get uppercaseT() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseT;
		},
		get uppercaseU() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseU;
		},
		get uppercaseV() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseV;
		},
		get uppercaseW() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseW;
		},
		get uppercaseX() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseX;
		},
		get uppercaseY() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseY;
		},
		get uppercaseZ() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseZ;
		},
		get leftSquareBracket() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$leftSquareBracket;
		},
		get backslash() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$backslash;
		},
		get rightSquareBracket() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$rightSquareBracket;
		},
		get caret() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$caret;
		},
		get underscore() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$underscore;
		},
		get graveAccent() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$graveAccent;
		},
		get lowercaseA() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseA;
		},
		get lowercaseB() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseB;
		},
		get lowercaseC() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseC;
		},
		get lowercaseD() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseD;
		},
		get lowercaseE() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseE;
		},
		get lowercaseF() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseF;
		},
		get lowercaseG() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseG;
		},
		get lowercaseH() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseH;
		},
		get lowercaseI() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseI;
		},
		get lowercaseJ() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseJ;
		},
		get lowercaseK() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseK;
		},
		get lowercaseL() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseL;
		},
		get lowercaseM() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseM;
		},
		get lowercaseN() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseN;
		},
		get lowercaseO() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseO;
		},
		get lowercaseP() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseP;
		},
		get lowercaseQ() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseQ;
		},
		get lowercaseR() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseR;
		},
		get lowercaseS() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseS;
		},
		get lowercaseT() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseT;
		},
		get lowercaseU() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseU;
		},
		get lowercaseV() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseV;
		},
		get lowercaseW() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseW;
		},
		get lowercaseX() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseX;
		},
		get lowercaseY() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseY;
		},
		get lowercaseZ() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseZ;
		},
		get leftCurlyBrace() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$leftCurlyBrace;
		},
		get verticalBar() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$verticalBar;
		},
		get rightCurlyBrace() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$rightCurlyBrace;
		},
		get tilde() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$tilde;
		},
		get nonBreakingSpace() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$nonBreakingSpace;
		},
		get oghamSpaceMark() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$oghamSpaceMark;
		},
		get lineSeparator() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$lineSeparator;
		},
		get paragraphSeparator() {
			return ___R$project$rome$$internal$string$charcodes$index_ts$paragraphSeparator;
		},
		isDigit: ___R$project$rome$$internal$string$charcodes$index_ts$isDigit,
	};
	const ___R$project$rome$$internal$string$charcodes$index_ts$backSpace = 8;
	const ___R$project$rome$$internal$string$charcodes$index_ts$tab = 9;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lineFeed = 10;
	const ___R$project$rome$$internal$string$charcodes$index_ts$carriageReturn = 13;
	const ___R$project$rome$$internal$string$charcodes$index_ts$shiftOut = 14;
	const ___R$project$rome$$internal$string$charcodes$index_ts$space = 32;
	const ___R$project$rome$$internal$string$charcodes$index_ts$exclamationMark = 33;
	const ___R$project$rome$$internal$string$charcodes$index_ts$quotationMark = 34;
	const ___R$project$rome$$internal$string$charcodes$index_ts$numberSign = 35;
	const ___R$project$rome$$internal$string$charcodes$index_ts$dollarSign = 36;
	const ___R$project$rome$$internal$string$charcodes$index_ts$percentSign = 37;
	const ___R$project$rome$$internal$string$charcodes$index_ts$ampersand = 38;
	const ___R$project$rome$$internal$string$charcodes$index_ts$apostrophe = 39;
	const ___R$project$rome$$internal$string$charcodes$index_ts$leftParenthesis = 40;
	const ___R$project$rome$$internal$string$charcodes$index_ts$rightParenthesis = 41;
	const ___R$project$rome$$internal$string$charcodes$index_ts$asterisk = 42;
	const ___R$project$rome$$internal$string$charcodes$index_ts$plusSign = 43;
	const ___R$project$rome$$internal$string$charcodes$index_ts$comma = 44;
	const ___R$project$rome$$internal$string$charcodes$index_ts$dash = 45;
	const ___R$project$rome$$internal$string$charcodes$index_ts$dot = 46;
	const ___R$project$rome$$internal$string$charcodes$index_ts$slash = 47;
	const ___R$project$rome$$internal$string$charcodes$index_ts$digit0 = 48;
	const ___R$project$rome$$internal$string$charcodes$index_ts$digit1 = 49;
	const ___R$project$rome$$internal$string$charcodes$index_ts$digit2 = 50;
	const ___R$project$rome$$internal$string$charcodes$index_ts$digit3 = 51;
	const ___R$project$rome$$internal$string$charcodes$index_ts$digit4 = 52;
	const ___R$project$rome$$internal$string$charcodes$index_ts$digit5 = 53;
	const ___R$project$rome$$internal$string$charcodes$index_ts$digit6 = 54;
	const ___R$project$rome$$internal$string$charcodes$index_ts$digit7 = 55;
	const ___R$project$rome$$internal$string$charcodes$index_ts$digit8 = 56;
	const ___R$project$rome$$internal$string$charcodes$index_ts$digit9 = 57;
	const ___R$project$rome$$internal$string$charcodes$index_ts$colon = 58;
	const ___R$project$rome$$internal$string$charcodes$index_ts$semicolon = 59;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lessThan = 60;
	const ___R$project$rome$$internal$string$charcodes$index_ts$equalsTo = 61;
	const ___R$project$rome$$internal$string$charcodes$index_ts$greaterThan = 62;
	const ___R$project$rome$$internal$string$charcodes$index_ts$questionMark = 63;
	const ___R$project$rome$$internal$string$charcodes$index_ts$atSign = 64;
	const ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseA = 65;
	const ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseB = 66;
	const ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseC = 67;
	const ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseD = 68;
	const ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseE = 69;
	const ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseF = 70;
	const ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseG = 71;
	const ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseH = 72;
	const ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseI = 73;
	const ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseJ = 74;
	const ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseK = 75;
	const ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseL = 76;
	const ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseM = 77;
	const ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseN = 78;
	const ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseO = 79;
	const ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseP = 80;
	const ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseQ = 81;
	const ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseR = 82;
	const ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseS = 83;
	const ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseT = 84;
	const ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseU = 85;
	const ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseV = 86;
	const ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseW = 87;
	const ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseX = 88;
	const ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseY = 89;
	const ___R$project$rome$$internal$string$charcodes$index_ts$uppercaseZ = 90;
	const ___R$project$rome$$internal$string$charcodes$index_ts$leftSquareBracket = 91;
	const ___R$project$rome$$internal$string$charcodes$index_ts$backslash = 92;
	const ___R$project$rome$$internal$string$charcodes$index_ts$rightSquareBracket = 93;
	const ___R$project$rome$$internal$string$charcodes$index_ts$caret = 94;
	const ___R$project$rome$$internal$string$charcodes$index_ts$underscore = 95;
	const ___R$project$rome$$internal$string$charcodes$index_ts$graveAccent = 96;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseA = 97;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseB = 98;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseC = 99;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseD = 100;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseE = 101;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseF = 102;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseG = 103;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseH = 104;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseI = 105;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseJ = 106;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseK = 107;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseL = 108;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseM = 109;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseN = 110;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseO = 111;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseP = 112;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseQ = 113;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseR = 114;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseS = 115;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseT = 116;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseU = 117;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseV = 118;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseW = 119;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseX = 120;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseY = 121;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lowercaseZ = 122;
	const ___R$project$rome$$internal$string$charcodes$index_ts$leftCurlyBrace = 123;
	const ___R$project$rome$$internal$string$charcodes$index_ts$verticalBar = 124;
	const ___R$project$rome$$internal$string$charcodes$index_ts$rightCurlyBrace = 125;
	const ___R$project$rome$$internal$string$charcodes$index_ts$tilde = 126;
	const ___R$project$rome$$internal$string$charcodes$index_ts$nonBreakingSpace = 160;
	const ___R$project$rome$$internal$string$charcodes$index_ts$oghamSpaceMark = 5_760;
	const ___R$project$rome$$internal$string$charcodes$index_ts$lineSeparator = 8_232;
	const ___R$project$rome$$internal$string$charcodes$index_ts$paragraphSeparator = 8_233;

	function ___R$project$rome$$internal$string$charcodes$index_ts$isDigit(code) {
		return (
			code >= ___R$project$rome$$internal$string$charcodes$index_ts$digit0 &&
			code <= ___R$project$rome$$internal$string$charcodes$index_ts$digit9
		);
	}


  // project-rome/@internal/string-utils/naturalCompare.ts
function ___R$project$rome$$internal$string$utils$naturalCompare_ts$naturalCompare(
		a,
		b,
		insensitive = true,
	) {
		if (insensitive) {
			a = a.toLowerCase();
			b = b.toLowerCase();
		}

		const lengthA = a.length;
		const lengthB = b.length;

		let aIndex = 0;
		let bIndex = 0;

		while (aIndex < lengthA && bIndex < lengthB) {
			let charCodeA = a.charCodeAt(aIndex);
			let charCodeB = b.charCodeAt(bIndex);

			if (
				___R$project$rome$$internal$string$charcodes$index_ts$isDigit(charCodeA)
			) {
				if (
					!___R$project$rome$$internal$string$charcodes$index_ts$isDigit(
						charCodeB,
					)
				) {
					return charCodeA - charCodeB;
				}

				let numStartA = aIndex;
				let numStartB = bIndex;

				while (charCodeA === 48 && ++numStartA < lengthA) {
					charCodeA = a.charCodeAt(numStartA);
				}
				while (charCodeB === 48 && ++numStartB < lengthB) {
					charCodeB = b.charCodeAt(numStartB);
				}

				let numEndA = numStartA;
				let numEndB = numStartB;

				while (
					numEndA < lengthA &&
					___R$project$rome$$internal$string$charcodes$index_ts$isDigit(
						a.charCodeAt(numEndA),
					)
				) {
					++numEndA;
				}
				while (
					numEndB < lengthB &&
					___R$project$rome$$internal$string$charcodes$index_ts$isDigit(
						b.charCodeAt(numEndB),
					)
				) {
					++numEndB;
				}

				let difference = numEndA - numStartA - numEndB + numStartB; // numA length - numB length
				if (difference) {
					return difference;
				}

				while (numStartA < numEndA) {
					difference = a.charCodeAt(numStartA++) - b.charCodeAt(numStartB++);
					if (difference) {
						return difference;
					}
				}

				aIndex = numEndA;
				bIndex = numEndB;
				continue;
			}

			if (charCodeA !== charCodeB) {
				return charCodeA - charCodeB;
			}

			++aIndex;
			++bIndex;
		}

		return lengthA - lengthB;
	}


  // project-rome/@internal/string-utils/orderByNatural.ts
function ___R$project$rome$$internal$string$utils$orderByNatural_ts$orderByNatural(
		strs,
		insensitive = true,
	) {
		return strs.sort((a, b) =>
			___R$project$rome$$internal$string$utils$naturalCompare_ts$naturalCompare(
				a,
				b,
				insensitive,
			)
		);
	}


  // project-rome/@internal/string-utils/preserveCasing.ts
function ___R$project$rome$$internal$string$utils$preserveCasing_ts$preserveCasing(
		a,
		b,
	) {
		if (a === a.toUpperCase()) {
			// If a is upper case then make b uppercase
			return b.toUpperCase();
		} else if (a[0] === a[0].toUpperCase()) {
			// First letter is capitalized
			return b[0].toUpperCase() + b.slice(1);
		} else {
			return b;
		}
	}


  // project-rome/@internal/string-utils/removeCarriageReturn.ts
function ___R$project$rome$$internal$string$utils$removeCarriageReturn_ts$removeCarriageReturn(
		str,
	) {
		return str.replace(/\r/g, "");
	}


  // project-rome/@internal/string-utils/removePrefix.ts
function ___R$project$rome$$internal$string$utils$removePrefix_ts$removePrefix(
		value,
		prefix,
	) {
		if (value.startsWith(prefix)) {
			return value.slice(prefix.length);
		} else {
			return value;
		}
	}


  // project-rome/@internal/string-utils/removeSuffix.ts
function ___R$project$rome$$internal$string$utils$removeSuffix_ts$removeSuffix(
		value,
		suffix,
	) {
		if (value.endsWith(suffix)) {
			return value.slice(0, -suffix.length);
		} else {
			return value;
		}
	}


  // project-rome/@internal/string-utils/toCamelCase.ts
function ___R$project$rome$$internal$string$utils$toCamelCase_ts$removeMatch(
		inner,
		regex,
		suffix,
	) {
		const match = inner.match(regex);
		if (match == null) {
			return [inner, ""];
		} else {
			const edge = match[1];
			if (suffix) {
				return [inner.slice(0, -edge.length), edge];
			} else {
				return [inner.slice(edge.length), edge];
			}
		}
	}

	function ___R$project$rome$$internal$string$utils$toCamelCase_ts$toCamelCase(
		inner,
		opts = {},
	) {
		// Rest of the code expects at least 1 character
		if (inner.length === 0) {
			return inner;
		}

		let prefix = "";
		let suffix = "";

		// ALLOW_STRINGS_LIKE_THIS
		if (opts.allowShouty) {
			[inner, prefix] = ___R$project$rome$$internal$string$utils$toCamelCase_ts$removeMatch(
				inner,
				/^([A-Z0-9_]+)/,
				false,
			);
			[inner, suffix] = ___R$project$rome$$internal$string$utils$toCamelCase_ts$removeMatch(
				inner,
				/([A-Z0-9_]+)$/,
				true,
			);
		} else if (opts.allowPascal || opts.forcePascal) {
			// Retain leading capitals only
			[inner, prefix] = ___R$project$rome$$internal$string$utils$toCamelCase_ts$removeMatch(
				inner,
				/^([A-Z]+)/,
				false,
			);
		}

		// Prepend uppercase letters with a space
		inner = inner.replace(/([A-Z]+)/g, " $1");

		// Split into parts
		const parts = inner.split(/[_.\- ]+|(\d+)/g);

		// Build it
		let camel = prefix;
		let first = true;
		for (let i = 0; i < parts.length; i++) {
			let part = parts[i];
			if (part === undefined) {
				// Empty capture group
				continue;
			}

			// Don't capitalize the first part unless we want pascal case
			if (!first || (opts.forcePascal && prefix === "")) {
				// Needs at least one
				if (part.length > 0) {
					part = part[0].toUpperCase() + part.slice(1);
				}
			}

			if (first) {
				first = false;
			}

			camel += part;
		}
		camel += suffix;
		return camel;
	}


  // project-rome/@internal/string-utils/toKebabCase.ts
function ___R$project$rome$$internal$string$utils$toKebabCase_ts$toKebabCase(
		str,
	) {
		return str.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
	}


  // project-rome/@internal/string-utils/sliceEscaped.ts
function ___R$project$rome$$internal$string$utils$sliceEscaped_ts$sliceEscaped(
		str,
		end,
	) {
		if (str.length > end) {
			let sliced = str.slice(0, end);
			while (
				sliced[sliced.length - 1] === "\\" &&
				!___R$project$rome$$internal$string$utils$isEscaped_ts$isEscaped(
					___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(str.length - 1),
					str,
				)
			) {
				sliced = sliced.slice(0, -1);
			}
			return sliced;
		} else {
			return str;
		}
	}


  // project-rome/@internal/string-utils/splitLines.ts
const ___R$$priv$project$rome$$internal$string$utils$splitLines_ts$NEWLINE = /\r\n|[\n\r\u2028\u2029]/;

	function ___R$project$rome$$internal$string$utils$splitLines_ts$splitLines(
		src,
	) {
		return src.split(
			___R$$priv$project$rome$$internal$string$utils$splitLines_ts$NEWLINE,
		);
	}


  // project-rome/@internal/string-utils/splitChars.ts
function ___R$project$rome$$internal$string$utils$splitChars_ts$splitChars(str) {
		return str.split(/(?:){1}/u);
	}


  // project-rome/@internal/string-utils/index.ts



  // project-rome/@internal/html-parser/tags.ts
const ___R$$priv$project$rome$$internal$html$parser$tags_ts$selfClosingTagNames = new Set([
		"area",
		"base",
		"br",
		"embed",
		"hr",
		"img",
		"input",
		"link",
		"meta",
		"param",
		"source",
		"track",
		"wbr",
		"command",
		"keygen",
		"menuitem",
	]);

	function ___R$project$rome$$internal$html$parser$tags_ts$isSelfClosingTagName(
		tagName,
	) {
		return ___R$$priv$project$rome$$internal$html$parser$tags_ts$selfClosingTagNames.has(
			tagName,
		);
	}


  // project-rome/@internal/html-parser/xhtmlEntities.ts
const ___R$project$rome$$internal$html$parser$xhtmlEntities_ts = {
		get xhtmlEntityNameToChar() {
			return ___R$project$rome$$internal$html$parser$xhtmlEntities_ts$xhtmlEntityNameToChar;
		},
		get xhtmlEntityCharToName() {
			return ___R$project$rome$$internal$html$parser$xhtmlEntities_ts$xhtmlEntityCharToName;
		},
		escapeXHTMLEntities: ___R$project$rome$$internal$html$parser$xhtmlEntities_ts$escapeXHTMLEntities,
	};
	const ___R$project$rome$$internal$html$parser$xhtmlEntities_ts$xhtmlEntityNameToChar = {
		quot: '"',
		amp: "&",
		apos: "'",
		lt: "<",
		gt: ">",
		nbsp: "\xa0",
		iexcl: "\xa1",
		cent: "\xa2",
		pound: "\xa3",
		curren: "\xa4",
		yen: "\xa5",
		brvbar: "\xa6",
		sect: "\xa7",
		uml: "\xa8",
		copy: "\xa9",
		ordf: "\xaa",
		laquo: "\xab",
		not: "\xac",
		shy: "\xad",
		reg: "\xae",
		macr: "\xaf",
		deg: "\xb0",
		plusmn: "\xb1",
		sup2: "\xb2",
		sup3: "\xb3",
		acute: "\xb4",
		micro: "\xb5",
		para: "\xb6",
		middot: "\xb7",
		cedil: "\xb8",
		sup1: "\xb9",
		ordm: "\xba",
		raquo: "\xbb",
		frac14: "\xbc",
		frac12: "\xbd",
		frac34: "\xbe",
		iquest: "\xbf",
		Agrave: "\xc0",
		Aacute: "\xc1",
		Acirc: "\xc2",
		Atilde: "\xc3",
		Auml: "\xc4",
		Aring: "\xc5",
		AElig: "\xc6",
		Ccedil: "\xc7",
		Egrave: "\xc8",
		Eacute: "\xc9",
		Ecirc: "\xca",
		Euml: "\xcb",
		Igrave: "\xcc",
		Iacute: "\xcd",
		Icirc: "\xce",
		Iuml: "\xcf",
		ETH: "\xd0",
		Ntilde: "\xd1",
		Ograve: "\xd2",
		Oacute: "\xd3",
		Ocirc: "\xd4",
		Otilde: "\xd5",
		Ouml: "\xd6",
		times: "\xd7",
		Oslash: "\xd8",
		Ugrave: "\xd9",
		Uacute: "\xda",
		Ucirc: "\xdb",
		Uuml: "\xdc",
		Yacute: "\xdd",
		THORN: "\xde",
		szlig: "\xdf",
		agrave: "\xe0",
		aacute: "\xe1",
		acirc: "\xe2",
		atilde: "\xe3",
		auml: "\xe4",
		aring: "\xe5",
		aelig: "\xe6",
		ccedil: "\xe7",
		egrave: "\xe8",
		eacute: "\xe9",
		ecirc: "\xea",
		euml: "\xeb",
		igrave: "\xec",
		iacute: "\xed",
		icirc: "\xee",
		iuml: "\xef",
		eth: "\xf0",
		ntilde: "\xf1",
		ograve: "\xf2",
		oacute: "\xf3",
		ocirc: "\xf4",
		otilde: "\xf5",
		ouml: "\xf6",
		divide: "\xf7",
		oslash: "\xf8",
		ugrave: "\xf9",
		uacute: "\xfa",
		ucirc: "\xfb",
		uuml: "\xfc",
		yacute: "\xfd",
		thorn: "\xfe",
		yuml: "\xff",
		OElig: "\u0152",
		oelig: "\u0153",
		Scaron: "\u0160",
		scaron: "\u0161",
		Yuml: "\u0178",
		fnof: "\u0192",
		circ: "\u02c6",
		tilde: "\u02dc",
		Alpha: "\u0391",
		Beta: "\u0392",
		Gamma: "\u0393",
		Delta: "\u0394",
		Epsilon: "\u0395",
		Zeta: "\u0396",
		Eta: "\u0397",
		Theta: "\u0398",
		Iota: "\u0399",
		Kappa: "\u039a",
		Lambda: "\u039b",
		Mu: "\u039c",
		Nu: "\u039d",
		Xi: "\u039e",
		Omicron: "\u039f",
		Pi: "\u03a0",
		Rho: "\u03a1",
		Sigma: "\u03a3",
		Tau: "\u03a4",
		Upsilon: "\u03a5",
		Phi: "\u03a6",
		Chi: "\u03a7",
		Psi: "\u03a8",
		Omega: "\u03a9",
		alpha: "\u03b1",
		beta: "\u03b2",
		gamma: "\u03b3",
		delta: "\u03b4",
		epsilon: "\u03b5",
		zeta: "\u03b6",
		eta: "\u03b7",
		theta: "\u03b8",
		iota: "\u03b9",
		kappa: "\u03ba",
		lambda: "\u03bb",
		mu: "\u03bc",
		nu: "\u03bd",
		xi: "\u03be",
		omicron: "\u03bf",
		pi: "\u03c0",
		rho: "\u03c1",
		sigmaf: "\u03c2",
		sigma: "\u03c3",
		tau: "\u03c4",
		upsilon: "\u03c5",
		phi: "\u03c6",
		chi: "\u03c7",
		psi: "\u03c8",
		omega: "\u03c9",
		thetasym: "\u03d1",
		upsih: "\u03d2",
		piv: "\u03d6",
		ensp: "\u2002",
		emsp: "\u2003",
		thinsp: "\u2009",
		zwnj: "\u200c",
		zwj: "\u200d",
		lrm: "\u200e",
		rlm: "\u200f",
		ndash: "\u2013",
		mdash: "\u2014",
		lsquo: "\u2018",
		rsquo: "\u2019",
		sbquo: "\u201a",
		ldquo: "\u201c",
		rdquo: "\u201d",
		bdquo: "\u201e",
		dagger: "\u2020",
		Dagger: "\u2021",
		bull: "\u2022",
		hellip: "\u2026",
		permil: "\u2030",
		prime: "\u2032",
		Prime: "\u2033",
		lsaquo: "\u2039",
		rsaquo: "\u203a",
		oline: "\u203e",
		frasl: "\u2044",
		euro: "\u20ac",
		image: "\u2111",
		weierp: "\u2118",
		real: "\u211c",
		trade: "\u2122",
		alefsym: "\u2135",
		larr: "\u2190",
		uarr: "\u2191",
		rarr: "\u2192",
		darr: "\u2193",
		harr: "\u2194",
		crarr: "\u21b5",
		lArr: "\u21d0",
		uArr: "\u21d1",
		rArr: "\u21d2",
		dArr: "\u21d3",
		hArr: "\u21d4",
		forall: "\u2200",
		part: "\u2202",
		exist: "\u2203",
		empty: "\u2205",
		nabla: "\u2207",
		isin: "\u2208",
		notin: "\u2209",
		ni: "\u220b",
		prod: "\u220f",
		sum: "\u2211",
		minus: "\u2212",
		lowast: "\u2217",
		radic: "\u221a",
		prop: "\u221d",
		infin: "\u221e",
		ang: "\u2220",
		and: "\u2227",
		or: "\u2228",
		cap: "\u2229",
		cup: "\u222a",
		int: "\u222b",
		there4: "\u2234",
		sim: "\u223c",
		cong: "\u2245",
		asymp: "\u2248",
		ne: "\u2260",
		equiv: "\u2261",
		le: "\u2264",
		ge: "\u2265",
		sub: "\u2282",
		sup: "\u2283",
		nsub: "\u2284",
		sube: "\u2286",
		supe: "\u2287",
		oplus: "\u2295",
		otimes: "\u2297",
		perp: "\u22a5",
		sdot: "\u22c5",
		lceil: "\u2308",
		rceil: "\u2309",
		lfloor: "\u230a",
		rfloor: "\u230b",
		lang: "\u2329",
		rang: "\u232a",
		loz: "\u25ca",
		spades: "\u2660",
		clubs: "\u2663",
		hearts: "\u2665",
		diams: "\u2666",
	};

	const ___R$project$rome$$internal$html$parser$xhtmlEntities_ts$xhtmlEntityCharToName = {

	};
	for (const key in ___R$project$rome$$internal$html$parser$xhtmlEntities_ts$xhtmlEntityNameToChar) {
		___R$project$rome$$internal$html$parser$xhtmlEntities_ts$xhtmlEntityCharToName[___R$project$rome$$internal$html$parser$xhtmlEntities_ts$xhtmlEntityNameToChar[key]] = key;
	}

	function ___R$project$rome$$internal$html$parser$xhtmlEntities_ts$escapeXHTMLEntities(
		value,
		only,
	) {
		let escaped = "";
		for (const char of value) {
			const entity = ___R$project$rome$$internal$html$parser$xhtmlEntities_ts$xhtmlEntityCharToName[char];
			if (entity === undefined || (only !== undefined && !only.includes(char))) {
				escaped += char;
			} else {
				escaped += "&" + entity + ";";
			}
		}
		return escaped;
	}


  // project-rome/@internal/html-parser/index.ts
function ___R$$priv$project$rome$$internal$html$parser$index_ts$isTagStartChar(
		index,
		input,
	) {
		const i = ___R$project$rome$$internal$ob1$index_ts$ob1Get0(index);
		return (
			input[i] === "<" &&
			!___R$project$rome$$internal$string$utils$isEscaped_ts$isEscaped(
				index,
				input,
			)
		);
	}

	function ___R$$priv$project$rome$$internal$html$parser$index_ts$isStringValueChar(
		char,
		index,
		input,
	) {
		if (
			char === '"' &&
			!___R$project$rome$$internal$string$utils$isEscaped_ts$isEscaped(
				index,
				input,
			)
		) {
			return false;
		}

		return true;
	}

	function ___R$$priv$project$rome$$internal$html$parser$index_ts$isIdentifierChar(
		char,
	) {
		return (
			___R$project$rome$$internal$parser$core$utils_ts$isDigit(char) ||
			___R$project$rome$$internal$parser$core$utils_ts$isAlpha(char) ||
			char === "-"
		);
	}

	function ___R$$priv$project$rome$$internal$html$parser$index_ts$isTextChar(
		char,
		index,
		input,
	) {
		return !___R$$priv$project$rome$$internal$html$parser$index_ts$isTagStartChar(
			index,
			input,
		);
	}

	function ___R$$priv$project$rome$$internal$html$parser$index_ts$isntCommentEnd(
		char,
		index,
		input,
	) {
		const isCommentEnd =
			char === "-" &&
			!___R$project$rome$$internal$string$utils$isEscaped_ts$isEscaped(
				index,
				input,
			) &&
			input[___R$project$rome$$internal$ob1$index_ts$ob1Get0(index) + 1] === "-" &&
			input[___R$project$rome$$internal$ob1$index_ts$ob1Get0(index) + 2] === ">";
		return !isCommentEnd;
	}

	const ___R$$priv$project$rome$$internal$html$parser$index_ts$createHTMLParser = ___R$project$rome$$internal$parser$core$utils_ts$createParser({
		ignoreWhitespaceTokens: true,
		diagnosticCategory: "parse/html",
		getInitialState: () => ({inTagHead: false}),

		tokenizeWithState(parser, index, state) {
			const escaped = ___R$project$rome$$internal$string$utils$isEscaped_ts$isEscaped(
				index,
				parser.input,
			);
			const char = parser.getInputCharOnly(index);

			if (!escaped && state.inTagHead) {
				if (char === "=") {
					return {
						state,
						token: parser.finishToken("Equals"),
					};
				}

				if (char === "/" && parser.getInputCharOnly(index, 1)) {
					return {
						state,
						token: parser.finishToken(
							"TagSelfClosing",
							___R$project$rome$$internal$ob1$index_ts$ob1Add(index, 2),
						),
					};
				}

				if (
					___R$$priv$project$rome$$internal$html$parser$index_ts$isIdentifierChar(
						char,
					)
				) {
					const [value, end] = parser.readInputFrom(
						index,
						___R$$priv$project$rome$$internal$html$parser$index_ts$isIdentifierChar,
					);
					return {
						state,
						token: parser.finishValueToken("Identifier", value, end),
					};
				}

				if (char === '"') {
					const [value, stringValueEnd, unclosed] = parser.readInputFrom(
						___R$project$rome$$internal$ob1$index_ts$ob1Inc(index),
						___R$$priv$project$rome$$internal$html$parser$index_ts$isStringValueChar,
					);

					if (unclosed) {
						// TODO
					}

					const end = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
						stringValueEnd,
						1,
					);
					return {
						state,
						token: parser.finishValueToken("String", value, end),
					};
				}

				if (char === ">") {
					return {
						state: Object.assign({}, state, {inTagHead: false}),
						token: parser.finishToken("TagEnd"),
					};
				}
			}

			if (
				parser.getInputCharOnly(index) === "<" &&
				parser.getInputCharOnly(index, 1) === "!" &&
				parser.getInputCharOnly(index, 2) === "-" &&
				parser.getInputCharOnly(index, 3) === "-"
			) {
				// Skip <!--
				const start = ___R$project$rome$$internal$ob1$index_ts$ob1Add(index, 4);
				const [value, valueEnd, overflow] = parser.readInputFrom(
					start,
					___R$$priv$project$rome$$internal$html$parser$index_ts$isntCommentEnd,
				);

				// Check for unclosed comment
				if (overflow) {
					// TODO
				}

				// Skip -->
				const end = ___R$project$rome$$internal$ob1$index_ts$ob1Add(valueEnd, 3);

				return {
					state: Object.assign({}, state, {inTagHead: false}),
					token: parser.finishValueToken("Comment", value, end),
				};
			}

			if (
				___R$$priv$project$rome$$internal$html$parser$index_ts$isTagStartChar(
					index,
					parser.input,
				)
			) {
				let token;

				if (parser.getInputCharOnly(index, 1) === "/") {
					token = parser.finishToken(
						"TagEndOpen",
						___R$project$rome$$internal$ob1$index_ts$ob1Add(index, 2),
					);
				} else {
					token = parser.finishToken("TagStartOpen");
				}

				return {
					state: Object.assign({}, state, {inTagHead: true}),
					token,
				};
			}

			// Keep eating text until we hit a <
			const [value, end] = parser.readInputFrom(
				index,
				___R$$priv$project$rome$$internal$html$parser$index_ts$isTextChar,
			);
			return {
				state,
				token: {
					type: "Text",
					value,
					start: index,
					end,
				},
			};
		},
	});

	function ___R$$priv$project$rome$$internal$html$parser$index_ts$parseIdentifier(
		parser,
	) {
		const start = parser.getPosition();
		const token = parser.expectToken("Identifier");
		return parser.finishNode(
			start,
			{
				type: "HTMLIdentifier",
				name: token.value,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$html$parser$index_ts$parseString(
		parser,
	) {
		const start = parser.getPosition();
		const value = parser.expectToken("String").value;
		return parser.finishNode(
			start,
			{
				type: "HTMLString",
				value,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$html$parser$index_ts$parseAttribute(
		parser,
	) {
		const start = parser.getPosition();
		const name = ___R$$priv$project$rome$$internal$html$parser$index_ts$parseIdentifier(
			parser,
		);
		parser.expectToken("Equals");
		const value = ___R$$priv$project$rome$$internal$html$parser$index_ts$parseString(
			parser,
		);
		return parser.finishNode(
			start,
			{
				type: "HTMLAttribute",
				name,
				value,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$html$parser$index_ts$parseTag(
		parser,
	) {
		const headStart = parser.getPosition();
		parser.expectToken("TagStartOpen");

		const attributes = [];
		const children = [];

		const name = ___R$$priv$project$rome$$internal$html$parser$index_ts$parseIdentifier(
			parser,
		);
		const tagName = name.name;
		let selfClosing = ___R$project$rome$$internal$html$parser$tags_ts$isSelfClosingTagName(
			tagName,
		);

		// Parse attributes
		while (
			!parser.matchToken("EOF") &&
			!parser.matchToken("TagSelfClosing") &&
			!parser.matchToken("TagEnd")
		) {
			const keyToken = parser.getToken();

			if (keyToken.type === "Identifier") {
				attributes.push(
					___R$$priv$project$rome$$internal$html$parser$index_ts$parseAttribute(
						parser,
					),
				);
			} else {
				throw parser.unexpected({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.HTML_PARSER.EXPECTED_ATTRIBUTE_NAME,
				});
			}
		}

		if (parser.eatToken("TagSelfClosing")) {
			selfClosing = true;
		} else {
			parser.expectToken("TagEnd");
		}

		const headEnd = parser.getPosition();

		// Verify closing tag
		if (!selfClosing) {
			while (
				// Build children
				!parser.matchToken("EOF") &&
				!parser.matchToken("TagEndOpen")
			) {
				const child = ___R$$priv$project$rome$$internal$html$parser$index_ts$parseChild(
					parser,
				);
				if (child !== undefined) {
					children.push(child);
				}
			}

			if (parser.matchToken("EOF")) {
				throw parser.unexpected({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.HTML_PARSER.UNCLOSED_TAG(
						tagName,
						parser.finishLocAt(headStart, headEnd),
					),
				});
			} else {
				parser.expectToken("TagEndOpen");

				const name = parser.getToken();
				if (name.type === "Identifier") {
					if (name.value !== tagName) {
						throw parser.unexpected({
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.HTML_PARSER.INCORRECT_CLOSING_TAG_NAME(
								tagName,
								name.value,
							),
						});
					}

					parser.nextToken();
				} else {
					throw parser.unexpected({
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.HTML_PARSER.EXPECTED_CLOSING_TAG_NAME,
					});
				}

				parser.expectToken("TagEnd");
			}
		}

		return parser.finishNode(
			headStart,
			{
				type: "HTMLElement",
				selfClosing,
				name,
				attributes,
				children,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$html$parser$index_ts$parseComment(
		parser,
	) {
		const start = parser.getPosition();
		const token = parser.expectToken("Comment");

		parser.registerComment(
			parser.comments.createComment({
				value: token.value,
				type: "CommentBlock",
				loc: parser.finishLoc(start),
			}),
		);
		return undefined;
	}

	function ___R$$priv$project$rome$$internal$html$parser$index_ts$parseText(
		parser,
	) {
		const start = parser.getPosition();
		const token = parser.expectToken("Text");

		const lines = [];
		let line = "";

		function pushLine() {
			line = line.trim();

			if (line !== "") {
				lines.push(line);
				line = "";
			}
		}

		let lineStart = true;

		for (const char of token.value) {
			switch (char) {
				case "\n": {
					lineStart = true;
					break;
				}

				case "\t":
				case " ": {
					if (!lineStart) {
						line += " ";
					}
					break;
				}

				default: {
					lineStart = false;
					line += char;
					break;
				}
			}
		}

		pushLine();

		const value = lines.join(" ").replace(/\s+/g, " ");

		return parser.finishNode(
			start,
			{
				type: "HTMLText",
				value,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$html$parser$index_ts$parseChild(
		parser,
	) {
		const token = parser.getToken();

		switch (token.type) {
			case "TagStartOpen":
				return ___R$$priv$project$rome$$internal$html$parser$index_ts$parseTag(
					parser,
				);

			case "Text":
				return ___R$$priv$project$rome$$internal$html$parser$index_ts$parseText(
					parser,
				);

			case "Comment":
				return ___R$$priv$project$rome$$internal$html$parser$index_ts$parseComment(
					parser,
				);

			case "TagEndOpen": {
				parser.unexpectedDiagnostic({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.HTML_PARSER.UNOPENED_TAG,
				});
				parser.nextToken();
				return undefined;
			}

			default: {
				parser.unexpectedDiagnostic();
				parser.nextToken();
				return undefined;
			}
		}
	}

	function ___R$project$rome$$internal$html$parser$index_ts$parseHTML(opts) {
		const parser = ___R$$priv$project$rome$$internal$html$parser$index_ts$createHTMLParser(
			opts,
		);
		const start = parser.getPosition();
		const body = [];

		while (!parser.matchToken("EOF")) {
			const child = ___R$$priv$project$rome$$internal$html$parser$index_ts$parseChild(
				parser,
			);
			if (child !== undefined) {
				body.push(child);
			}
		}

		parser.finalize();

		return parser.finishNode(
			start,
			parser.finishRoot({
				type: "HTMLRoot",
				body,
			}),
		);
	}

	function ___R$project$rome$$internal$html$parser$index_ts$tokenizeHTML(opts) {
		return ___R$$priv$project$rome$$internal$html$parser$index_ts$createHTMLParser(
			opts,
		).tokenizeAll();
	}


  // project-rome/@internal/cli-layout/ansi.ts
const ___R$project$rome$$internal$cli$layout$ansi_ts = {
		formatAnsiRGB: ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsiRGB,
		get formatAnsi() {
			return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi;
		},
		get ansiEscapes() {
			return ___R$project$rome$$internal$cli$layout$ansi_ts$ansiEscapes;
		},
	};
	const ___R$$priv$project$rome$$internal$cli$layout$ansi_ts$ESC = "\x1b";

	function ___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
		num,
	) {
		return (
			___R$$priv$project$rome$$internal$cli$layout$ansi_ts$ESC +
			"[" +
			String(num) +
			"m"
		);
	}

	function ___R$$priv$project$rome$$internal$cli$layout$ansi_ts$rgbTo8BitAnsi(
		[r, g, b],
	) {
		if (r === g && g === b) {
			if (r < 8) {
				return 16;
			}

			if (r > 248) {
				return 231;
			}

			return Math.round((r - 8) / 247 * 24) + 232;
		}

		return (
			16 +
			36 * Math.round(r / 255 * 5) +
			6 * Math.round(g / 255 * 5) +
			Math.round(b / 255 * 5)
		);
	}

	function ___R$$priv$project$rome$$internal$cli$layout$ansi_ts$saturation(rgb) {
		const r = rgb[0] / 255;
		const g = rgb[1] / 255;
		const b = rgb[2] / 255;
		const v = Math.max(r, g, b);
		const diff = v - Math.min(r, g, b);

		let s;
		if (diff === 0) {
			s = 0;
		} else {
			s = diff / v;
		}

		return s * 100;
	}

	function ___R$$priv$project$rome$$internal$cli$layout$ansi_ts$rgbTo4BitAnsi(
		color,
	) {
		const [r, g, b] = color;
		let value = ___R$$priv$project$rome$$internal$cli$layout$ansi_ts$saturation(
			color,
		);

		value = Math.round(value / 50);

		if (value === 0) {
			return 30;
		}

		let ansi =
			30 +
			(Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));

		if (value === 2) {
			ansi += 60;
		}

		return ansi;
	}

	// 4 and 8 bit ANSi color codes can be switched from foreground to background by adding 10
	function ___R$$priv$project$rome$$internal$cli$layout$ansi_ts$fgToMaybeBgCode(
		code,
		opts,
	) {
		return String(opts.background ? code + 10 : code);
	}

	function ___R$$priv$project$rome$$internal$cli$layout$ansi_ts$formatAnsiRGBReset(
		opts,
	) {
		return ___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
			___R$$priv$project$rome$$internal$cli$layout$ansi_ts$fgToMaybeBgCode(
				39,
				opts,
			),
		);
	}

	function ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsiRGB(opts) {
		const {color, value} = opts;
		switch (opts.features.colorDepth) {
			case 1:
				return value;

			case 4: {
				const colorCode = ___R$$priv$project$rome$$internal$cli$layout$ansi_ts$fgToMaybeBgCode(
					___R$$priv$project$rome$$internal$cli$layout$ansi_ts$rgbTo4BitAnsi(
						color,
					),
					opts,
				);
				return (
					___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
						colorCode,
					) +
					value +
					___R$$priv$project$rome$$internal$cli$layout$ansi_ts$formatAnsiRGBReset(
						opts,
					)
				);
			}

			case 8: {
				const tableCode = ___R$$priv$project$rome$$internal$cli$layout$ansi_ts$rgbTo8BitAnsi(
					color,
				);
				const colorCode =
					___R$$priv$project$rome$$internal$cli$layout$ansi_ts$fgToMaybeBgCode(
						38,
						opts,
					) +
					";5;" +
					String(tableCode);
				return (
					___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
						colorCode,
					) +
					value +
					___R$$priv$project$rome$$internal$cli$layout$ansi_ts$formatAnsiRGBReset(
						opts,
					)
				);
			}

			case 24: {
				const tuple = color.join(";");
				const colorCode =
					___R$$priv$project$rome$$internal$cli$layout$ansi_ts$fgToMaybeBgCode(
						38,
						opts,
					) +
					";2;" +
					tuple;
				return (
					___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
						colorCode,
					) +
					value +
					___R$$priv$project$rome$$internal$cli$layout$ansi_ts$formatAnsiRGBReset(
						opts,
					)
				);
			}
		}
	}

	const ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi = {
		reset(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					0,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					0,
				)
			);
		},
		fileHyperlink(name, filename) {
			let href = "file://";
			const {HOSTNAME} = process.env;
			if (HOSTNAME != null) {
				href += HOSTNAME + "/";
			}
			href += filename;
			return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.hyperlink(
				name,
				href,
			);
		},
		hyperlink(name, href) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$ESC +
				"]8;;" +
				href +
				"\x07" +
				name +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$ESC +
				"]8;;\x07"
			);
		},
		bold(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					1,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					22,
				)
			);
		},
		dim(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					2,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					22,
				)
			);
		},
		italic(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					3,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					23,
				)
			);
		},
		underline(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					4,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					24,
				)
			);
		},
		inverse(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					7,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					27,
				)
			);
		},
		hidden(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					8,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					28,
				)
			);
		},
		strikethrough(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					9,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					29,
				)
			);
		},
		black(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					30,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					39,
				)
			);
		},
		brightBlack(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					90,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					39,
				)
			);
		},
		red(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					31,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					39,
				)
			);
		},
		brightRed(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					91,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					39,
				)
			);
		},
		green(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					32,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					39,
				)
			);
		},
		brightGreen(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					92,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					39,
				)
			);
		},
		yellow(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					33,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					39,
				)
			);
		},
		brightYellow(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					93,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					39,
				)
			);
		},
		blue(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					34,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					39,
				)
			);
		},
		brightBlue(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					94,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					39,
				)
			);
		},
		magenta(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					35,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					39,
				)
			);
		},
		brightMagenta(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					95,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					39,
				)
			);
		},
		cyan(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					36,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					39,
				)
			);
		},
		brightCyan(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					96,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					39,
				)
			);
		},
		white(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					37,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					39,
				)
			);
		},
		brightWhite(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					97,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					39,
				)
			);
		},
		bgBlack(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					40,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					49,
				)
			);
		},
		bgBrightBlack(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					100,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					49,
				)
			);
		},
		bgRed(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					41,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					49,
				)
			);
		},
		bgBrightRed(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					101,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					49,
				)
			);
		},
		bgGreen(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					42,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					49,
				)
			);
		},
		bgBrightGreen(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					102,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					49,
				)
			);
		},
		bgYellow(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					43,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					49,
				)
			);
		},
		bgBrightYellow(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					103,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					49,
				)
			);
		},
		bgBlue(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					44,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					49,
				)
			);
		},
		bgBrightBlue(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					104,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					49,
				)
			);
		},
		bgMagenta(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					45,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					49,
				)
			);
		},
		bgBrightMagenta(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					105,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					49,
				)
			);
		},
		bgCyan(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					46,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					49,
				)
			);
		},
		bgBrightCyan(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					106,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					49,
				)
			);
		},
		bgWhite(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					47,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					49,
				)
			);
		},
		bgBrightWhite(str) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					107,
				) +
				str +
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$createColorEscape(
					49,
				)
			);
		},
	};

	const ___R$project$rome$$internal$cli$layout$ansi_ts$ansiEscapes = {
		clearScreen: "\x1bc",
		eraseLine: ___R$$priv$project$rome$$internal$cli$layout$ansi_ts$ESC + "[2K",
		cursorUp(count = 1) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$ESC +
				"[" +
				count +
				"A"
			);
		},
		cursorDown(count = 1) {
			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$ESC +
				"[" +
				count +
				"B"
			);
		},
		cursorTo(x, y) {
			if (y === undefined) {
				return (
					___R$$priv$project$rome$$internal$cli$layout$ansi_ts$ESC +
					"[" +
					(x + 1) +
					"G"
				);
			}

			return (
				___R$$priv$project$rome$$internal$cli$layout$ansi_ts$ESC +
				"[" +
				(y + 1) +
				";" +
				(x + 1) +
				"H"
			);
		},
	};


  // project-rome/@internal/cli-layout/syntax-theme/OneDarkPro.json
const ___R$project$rome$$internal$cli$layout$syntax$theme$OneDarkPro_json$default = {
		"name": "One Dark Pro",
		"type": "dark",
		"semanticHighlighting": true,
		"semanticTokenColors": {
			"enumMember": {"foreground": "#56b6c2"},
			"variable.constant": {"foreground": "#d19a66"},
			"variable.defaultLibrary": {"foreground": "#e5c07b"},
		},
		"tokenColors": [
			{
				"name": "unison punctuation",
				"scope": "punctuation.definition.delayed.unison,punctuation.definition.list.begin.unison,punctuation.definition.list.end.unison,punctuation.definition.ability.begin.unison,punctuation.definition.ability.end.unison,punctuation.operator.assignment.as.unison,punctuation.separator.pipe.unison,punctuation.separator.delimiter.unison,punctuation.definition.hash.unison",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "haskell variable generic-type",
				"scope": "variable.other.generic-type.haskell",
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "haskell storage type",
				"scope": "storage.type.haskell",
				"settings": {"foreground": "#d19a66"},
			},
			{
				"name": "support.variable.magic.python",
				"scope": "support.variable.magic.python",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "punctuation.separator.parameters.python",
				"scope": "punctuation.separator.period.python,punctuation.separator.element.python,punctuation.parenthesis.begin.python,punctuation.parenthesis.end.python",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "variable.parameter.function.language.special.self.python",
				"scope": "variable.parameter.function.language.special.self.python",
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "storage.modifier.lifetime.rust",
				"scope": "storage.modifier.lifetime.rust",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "support.function.std.rust",
				"scope": "support.function.std.rust",
				"settings": {"foreground": "#61afef"},
			},
			{
				"name": "entity.name.lifetime.rust",
				"scope": "entity.name.lifetime.rust",
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "variable.language.rust",
				"scope": "variable.language.rust",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "support.constant.edge",
				"scope": "support.constant.edge",
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "regexp constant character-class",
				"scope": "constant.other.character-class.regexp",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "regexp operator.quantifier",
				"scope": "keyword.operator.quantifier.regexp",
				"settings": {"foreground": "#d19a66"},
			},
			{
				"name": "punctuation.definition",
				"scope": "punctuation.definition.string.begin,punctuation.definition.string.end",
				"settings": {"foreground": "#98c379"},
			},
			{
				"name": "Text",
				"scope": "variable.parameter.function",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "Comment Markup Link",
				"scope": "comment markup.link",
				"settings": {"foreground": "#5c6370"},
			},
			{
				"name": "markup diff",
				"scope": "markup.changed.diff",
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "diff",
				"scope": "meta.diff.header.from-file,meta.diff.header.to-file,punctuation.definition.from-file.diff,punctuation.definition.to-file.diff",
				"settings": {"foreground": "#61afef"},
			},
			{
				"name": "inserted.diff",
				"scope": "markup.inserted.diff",
				"settings": {"foreground": "#98c379"},
			},
			{
				"name": "deleted.diff",
				"scope": "markup.deleted.diff",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "c++ function",
				"scope": "meta.function.c,meta.function.cpp",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "c++ block",
				"scope": "punctuation.section.block.begin.bracket.curly.cpp,punctuation.section.block.end.bracket.curly.cpp,punctuation.terminator.statement.c,punctuation.section.block.begin.bracket.curly.c,punctuation.section.block.end.bracket.curly.c,punctuation.section.parens.begin.bracket.round.c,punctuation.section.parens.end.bracket.round.c,punctuation.section.parameters.begin.bracket.round.c,punctuation.section.parameters.end.bracket.round.c",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "js/ts punctuation separator key-value",
				"scope": "punctuation.separator.key-value",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "js/ts import keyword",
				"scope": "keyword.operator.expression.import",
				"settings": {"foreground": "#61afef"},
			},
			{
				"name": "math js/ts",
				"scope": "support.constant.math",
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "math property js/ts",
				"scope": "support.constant.property.math",
				"settings": {"foreground": "#d19a66"},
			},
			{
				"name": "js/ts variable.other.constant",
				"scope": "variable.other.constant",
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "java type",
				"scope": [
					"storage.type.annotation.java",
					"storage.type.object.array.java",
				],
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "java source",
				"scope": "source.java",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "java modifier.import",
				"scope": "punctuation.section.block.begin.java,punctuation.section.block.end.java,punctuation.definition.method-parameters.begin.java,punctuation.definition.method-parameters.end.java,meta.method.identifier.java,punctuation.section.method.begin.java,punctuation.section.method.end.java,punctuation.terminator.java,punctuation.section.class.begin.java,punctuation.section.class.end.java,punctuation.section.inner-class.begin.java,punctuation.section.inner-class.end.java,meta.method-call.java,punctuation.section.class.begin.bracket.curly.java,punctuation.section.class.end.bracket.curly.java,punctuation.section.method.begin.bracket.curly.java,punctuation.section.method.end.bracket.curly.java,punctuation.separator.period.java,punctuation.bracket.angle.java,punctuation.definition.annotation.java,meta.method.body.java",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "java modifier.import",
				"scope": "meta.method.java",
				"settings": {"foreground": "#61afef"},
			},
			{
				"name": "java modifier.import",
				"scope": "storage.modifier.import.java,storage.type.java,storage.type.generic.java",
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "java instanceof",
				"scope": "keyword.operator.instanceof.java",
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "java variable.name",
				"scope": "meta.definition.variable.name.java",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "operator logical",
				"scope": "keyword.operator.logical",
				"settings": {"foreground": "#56b6c2"},
			},
			{
				"name": "operator bitwise",
				"scope": "keyword.operator.bitwise",
				"settings": {"foreground": "#56b6c2"},
			},
			{
				"name": "operator channel",
				"scope": "keyword.operator.channel",
				"settings": {"foreground": "#56b6c2"},
			},
			{
				"name": "support.constant.property-value.scss",
				"scope": "support.constant.property-value.scss,support.constant.property-value.css",
				"settings": {"foreground": "#d19a66"},
			},
			{
				"name": "CSS/SCSS/LESS Operators",
				"scope": "keyword.operator.css,keyword.operator.scss,keyword.operator.less",
				"settings": {"foreground": "#56b6c2"},
			},
			{
				"name": "css color standard name",
				"scope": "support.constant.color.w3c-standard-color-name.css,support.constant.color.w3c-standard-color-name.scss",
				"settings": {"foreground": "#d19a66"},
			},
			{
				"name": "css comma",
				"scope": "punctuation.separator.list.comma.css",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "css attribute-name.id",
				"scope": "support.constant.color.w3c-standard-color-name.css",
				"settings": {"foreground": "#d19a66"},
			},
			{
				"name": "css property-name",
				"scope": "support.type.vendored.property-name.css",
				"settings": {"foreground": "#56b6c2"},
			},
			{
				"name": "js/ts module",
				"scope": "support.module.node,support.type.object.module,support.module.node",
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "entity.name.type.module",
				"scope": "entity.name.type.module",
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "js variable readwrite",
				"scope": "variable.other.readwrite,meta.object-literal.key,support.variable.property,support.variable.object.process,support.variable.object.node",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "js/ts json",
				"scope": "support.constant.json",
				"settings": {"foreground": "#d19a66"},
			},
			{
				"name": "js/ts Keyword",
				"scope": [
					"keyword.operator.expression.instanceof",
					"keyword.operator.new",
					"keyword.operator.ternary",
					"keyword.operator.optional",
					"keyword.operator.expression.keyof",
				],
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "js/ts console",
				"scope": "support.type.object.console",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "js/ts support.variable.property.process",
				"scope": "support.variable.property.process",
				"settings": {"foreground": "#d19a66"},
			},
			{
				"name": "js console function",
				"scope": "entity.name.function,support.function.console",
				"settings": {"foreground": "#61afef"},
			},
			{
				"name": "keyword.operator.misc.rust",
				"scope": "keyword.operator.misc.rust",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "operator",
				"scope": "keyword.operator.delete",
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "js dom",
				"scope": "support.type.object.dom",
				"settings": {"foreground": "#56b6c2"},
			},
			{
				"name": "js dom variable",
				"scope": "support.variable.dom,support.variable.property.dom",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "keyword.operator",
				"scope": "keyword.operator.arithmetic,keyword.operator.comparison,keyword.operator.decrement,keyword.operator.increment,keyword.operator.relational",
				"settings": {"foreground": "#56b6c2"},
			},
			{
				"name": "C operator assignment",
				"scope": "keyword.operator.assignment.c,keyword.operator.comparison.c,keyword.operator.c,keyword.operator.increment.c,keyword.operator.decrement.c,keyword.operator.bitwise.shift.c,keyword.operator.assignment.cpp,keyword.operator.comparison.cpp,keyword.operator.cpp,keyword.operator.increment.cpp,keyword.operator.decrement.cpp,keyword.operator.bitwise.shift.cpp",
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "Punctuation",
				"scope": "punctuation.separator.delimiter",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "Other punctuation .c",
				"scope": "punctuation.separator.c,punctuation.separator.cpp",
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "C type posix-reserved",
				"scope": "support.type.posix-reserved.c,support.type.posix-reserved.cpp",
				"settings": {"foreground": "#56b6c2"},
			},
			{
				"name": "keyword.operator.sizeof.c",
				"scope": "keyword.operator.sizeof.c,keyword.operator.sizeof.cpp",
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "python parameter",
				"scope": "variable.parameter.function.language.python",
				"settings": {"foreground": "#d19a66"},
			},
			{
				"name": "python type",
				"scope": "support.type.python",
				"settings": {"foreground": "#56b6c2"},
			},
			{
				"name": "python logical",
				"scope": "keyword.operator.logical.python",
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "pyCs",
				"scope": "variable.parameter.function.python",
				"settings": {"foreground": "#d19a66"},
			},
			{
				"name": "python block",
				"scope": "punctuation.definition.arguments.begin.python,punctuation.definition.arguments.end.python,punctuation.separator.arguments.python,punctuation.definition.list.begin.python,punctuation.definition.list.end.python",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "python function-call.generic",
				"scope": "meta.function-call.generic.python",
				"settings": {"foreground": "#61afef"},
			},
			{
				"name": "python placeholder reset to normal string",
				"scope": "constant.character.format.placeholder.other.python",
				"settings": {"foreground": "#d19a66"},
			},
			{
				"name": "Operators",
				"scope": "keyword.operator",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "Compound Assignment Operators",
				"scope": "keyword.operator.assignment.compound",
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "Keywords",
				"scope": "keyword",
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "Variables",
				"scope": "variable",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "Variables",
				"scope": "variable.c",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "Language variables",
				"scope": "variable.language",
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "Java Variables",
				"scope": "token.variable.parameter.java",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "Java Imports",
				"scope": "import.storage.java",
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "Packages",
				"scope": "token.package.keyword",
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "Packages",
				"scope": "token.package",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "Functions",
				"scope": [
					"entity.name.function",
					"meta.require",
					"support.function.any-method",
					"variable.function",
				],
				"settings": {"foreground": "#61afef"},
			},
			{
				"name": "Classes",
				"scope": "entity.name.type.namespace",
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "Classes",
				"scope": "support.class, entity.name.type.class",
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "Class name",
				"scope": "entity.name.class.identifier.namespace.type",
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "Class name",
				"scope": [
					"entity.name.class",
					"variable.other.class.js",
					"variable.other.class.ts",
				],
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "Class name php",
				"scope": "variable.other.class.php",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "Type Name",
				"scope": "entity.name.type",
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "Keyword Control",
				"scope": "keyword.control",
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "Control Elements",
				"scope": "control.elements, keyword.operator.less",
				"settings": {"foreground": "#d19a66"},
			},
			{
				"name": "Methods",
				"scope": "keyword.other.special-method",
				"settings": {"foreground": "#61afef"},
			},
			{
				"name": "Storage",
				"scope": "storage",
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "Storage JS TS",
				"scope": "token.storage",
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "Source Js Keyword Operator Delete,source Js Keyword Operator In,source Js Keyword Operator Of,source Js Keyword Operator Instanceof,source Js Keyword Operator New,source Js Keyword Operator Typeof,source Js Keyword Operator Void",
				"scope": "keyword.operator.expression.delete,keyword.operator.expression.in,keyword.operator.expression.of,keyword.operator.expression.instanceof,keyword.operator.new,keyword.operator.expression.typeof,keyword.operator.expression.void",
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "Java Storage",
				"scope": "token.storage.type.java",
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "Support",
				"scope": "support.function",
				"settings": {"foreground": "#56b6c2"},
			},
			{
				"name": "Support type",
				"scope": "support.type.property-name",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "Support type",
				"scope": "support.constant.property-value",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "Support type",
				"scope": "support.constant.font-name",
				"settings": {"foreground": "#d19a66"},
			},
			{
				"name": "Meta tag",
				"scope": "meta.tag",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "Strings",
				"scope": "string",
				"settings": {"foreground": "#98c379"},
			},
			{
				"name": "Inherited Class",
				"scope": "entity.other.inherited-class",
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "Constant other symbol",
				"scope": "constant.other.symbol",
				"settings": {"foreground": "#56b6c2"},
			},
			{
				"name": "Integers",
				"scope": "constant.numeric",
				"settings": {"foreground": "#d19a66"},
			},
			{
				"name": "Constants",
				"scope": "constant",
				"settings": {"foreground": "#d19a66"},
			},
			{
				"name": "Constants",
				"scope": "punctuation.definition.constant",
				"settings": {"foreground": "#d19a66"},
			},
			{
				"name": "Tags",
				"scope": "entity.name.tag",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "Attributes",
				"scope": "entity.other.attribute-name",
				"settings": {"foreground": "#d19a66"},
			},
			{
				"name": "Attribute IDs",
				"scope": "entity.other.attribute-name.id",
				"settings": {"fontStyle": "normal", "foreground": "#61afef"},
			},
			{
				"name": "Attribute class",
				"scope": "entity.other.attribute-name.class.css",
				"settings": {"fontStyle": "normal", "foreground": "#d19a66"},
			},
			{
				"name": "Selector",
				"scope": "meta.selector",
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "Headings",
				"scope": "markup.heading",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "Headings",
				"scope": "markup.heading punctuation.definition.heading, entity.name.section",
				"settings": {"foreground": "#61afef"},
			},
			{
				"name": "Units",
				"scope": "keyword.other.unit",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "Bold",
				"scope": "markup.bold,todo.bold",
				"settings": {"foreground": "#d19a66"},
			},
			{
				"name": "Bold",
				"scope": "punctuation.definition.bold",
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "markup Italic",
				"scope": "markup.italic, punctuation.definition.italic,todo.emphasis",
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "emphasis md",
				"scope": "emphasis md",
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "[VSCODE-CUSTOM] Markdown headings",
				"scope": "entity.name.section.markdown",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "[VSCODE-CUSTOM] Markdown heading Punctuation Definition",
				"scope": "punctuation.definition.heading.markdown",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "punctuation.definition.list.begin.markdown",
				"scope": "punctuation.definition.list.begin.markdown",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "[VSCODE-CUSTOM] Markdown heading setext",
				"scope": "markup.heading.setext",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "[VSCODE-CUSTOM] Markdown Punctuation Definition Bold",
				"scope": "punctuation.definition.bold.markdown",
				"settings": {"foreground": "#d19a66"},
			},
			{
				"name": "[VSCODE-CUSTOM] Markdown Inline Raw",
				"scope": "markup.inline.raw.markdown",
				"settings": {"foreground": "#98c379"},
			},
			{
				"name": "[VSCODE-CUSTOM] Markdown Inline Raw",
				"scope": "markup.inline.raw.string.markdown",
				"settings": {"foreground": "#98c379"},
			},
			{
				"name": "[VSCODE-CUSTOM] Markdown List Punctuation Definition",
				"scope": "punctuation.definition.list.markdown",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "[VSCODE-CUSTOM] Markdown Punctuation Definition String",
				"scope": [
					"punctuation.definition.string.begin.markdown",
					"punctuation.definition.string.end.markdown",
					"punctuation.definition.metadata.markdown",
				],
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "beginning.punctuation.definition.list.markdown",
				"scope": ["beginning.punctuation.definition.list.markdown"],
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "[VSCODE-CUSTOM] Markdown Punctuation Definition Link",
				"scope": "punctuation.definition.metadata.markdown",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "[VSCODE-CUSTOM] Markdown Underline Link/Image",
				"scope": "markup.underline.link.markdown,markup.underline.link.image.markdown",
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "[VSCODE-CUSTOM] Markdown Link Title/Description",
				"scope": "string.other.link.title.markdown,string.other.link.description.markdown",
				"settings": {"foreground": "#61afef"},
			},
			{
				"name": "Regular Expressions",
				"scope": "string.regexp",
				"settings": {"foreground": "#56b6c2"},
			},
			{
				"name": "Escape Characters",
				"scope": "constant.character.escape",
				"settings": {"foreground": "#56b6c2"},
			},
			{
				"name": "Embedded",
				"scope": "punctuation.section.embedded, variable.interpolation",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "Embedded",
				"scope": "punctuation.section.embedded.begin,punctuation.section.embedded.end",
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "illegal",
				"scope": "invalid.illegal",
				"settings": {"foreground": "#ffffff"},
			},
			{
				"name": "illegal",
				"scope": "invalid.illegal.bad-ampersand.html",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "Broken",
				"scope": "invalid.broken",
				"settings": {"foreground": "#ffffff"},
			},
			{
				"name": "Deprecated",
				"scope": "invalid.deprecated",
				"settings": {"foreground": "#ffffff"},
			},
			{
				"name": "Unimplemented",
				"scope": "invalid.unimplemented",
				"settings": {"foreground": "#ffffff"},
			},
			{
				"name": "Source Json Meta Structure Dictionary Json > String Quoted Json",
				"scope": "source.json meta.structure.dictionary.json > string.quoted.json",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "Source Json Meta Structure Dictionary Json > String Quoted Json > Punctuation String",
				"scope": "source.json meta.structure.dictionary.json > string.quoted.json > punctuation.string",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "Source Json Meta Structure Dictionary Json > Value Json > String Quoted Json,source Json Meta Structure Array Json > Value Json > String Quoted Json,source Json Meta Structure Dictionary Json > Value Json > String Quoted Json > Punctuation,source Json Meta Structure Array Json > Value Json > String Quoted Json > Punctuation",
				"scope": "source.json meta.structure.dictionary.json > value.json > string.quoted.json,source.json meta.structure.array.json > value.json > string.quoted.json,source.json meta.structure.dictionary.json > value.json > string.quoted.json > punctuation,source.json meta.structure.array.json > value.json > string.quoted.json > punctuation",
				"settings": {"foreground": "#98c379"},
			},
			{
				"name": "Source Json Meta Structure Dictionary Json > Constant Language Json,source Json Meta Structure Array Json > Constant Language Json",
				"scope": "source.json meta.structure.dictionary.json > constant.language.json,source.json meta.structure.array.json > constant.language.json",
				"settings": {"foreground": "#56b6c2"},
			},
			{
				"name": "[VSCODE-CUSTOM] JSON Property Name",
				"scope": "support.type.property-name.json",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "[VSCODE-CUSTOM] JSON Punctuation for Property Name",
				"scope": "support.type.property-name.json punctuation",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "laravel blade tag",
				"scope": "text.html.laravel-blade source.php.embedded.line.html entity.name.tag.laravel-blade",
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "laravel blade @",
				"scope": "text.html.laravel-blade source.php.embedded.line.html support.constant.laravel-blade",
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "use statement for other classes",
				"scope": "support.other.namespace.use.php,support.other.namespace.use-as.php,support.other.namespace.php,entity.other.alias.php,meta.interface.php",
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "error suppression",
				"scope": "keyword.operator.error-control.php",
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "php instanceof",
				"scope": "keyword.operator.type.php",
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "style double quoted array index normal begin",
				"scope": "punctuation.section.array.begin.php",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "style double quoted array index normal end",
				"scope": "punctuation.section.array.end.php",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "php illegal.non-null-typehinted",
				"scope": "invalid.illegal.non-null-typehinted.php",
				"settings": {"foreground": "#f44747"},
			},
			{
				"name": "php types",
				"scope": "storage.type.php,meta.other.type.phpdoc.php,keyword.other.type.php,keyword.other.array.phpdoc.php",
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "php call-function",
				"scope": "meta.function-call.php,meta.function-call.object.php,meta.function-call.static.php",
				"settings": {"foreground": "#61afef"},
			},
			{
				"name": "php function-resets",
				"scope": "punctuation.definition.parameters.begin.bracket.round.php,punctuation.definition.parameters.end.bracket.round.php,punctuation.separator.delimiter.php,punctuation.section.scope.begin.php,punctuation.section.scope.end.php,punctuation.terminator.expression.php,punctuation.definition.arguments.begin.bracket.round.php,punctuation.definition.arguments.end.bracket.round.php,punctuation.definition.storage-type.begin.bracket.round.php,punctuation.definition.storage-type.end.bracket.round.php,punctuation.definition.array.begin.bracket.round.php,punctuation.definition.array.end.bracket.round.php,punctuation.definition.begin.bracket.round.php,punctuation.definition.end.bracket.round.php,punctuation.definition.begin.bracket.curly.php,punctuation.definition.end.bracket.curly.php,punctuation.definition.section.switch-block.end.bracket.curly.php,punctuation.definition.section.switch-block.start.bracket.curly.php,punctuation.definition.section.switch-block.begin.bracket.curly.php,punctuation.definition.section.switch-block.end.bracket.curly.php",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "support php constants",
				"scope": "support.constant.core.rust",
				"settings": {"foreground": "#d19a66"},
			},
			{
				"name": "support php constants",
				"scope": "support.constant.ext.php,support.constant.std.php,support.constant.core.php,support.constant.parser-token.php",
				"settings": {"foreground": "#d19a66"},
			},
			{
				"name": "php goto",
				"scope": "entity.name.goto-label.php,support.other.php",
				"settings": {"foreground": "#61afef"},
			},
			{
				"name": "php logical/bitwise operator",
				"scope": "keyword.operator.logical.php,keyword.operator.bitwise.php,keyword.operator.arithmetic.php",
				"settings": {"foreground": "#56b6c2"},
			},
			{
				"name": "php regexp operator",
				"scope": "keyword.operator.regexp.php",
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "php comparison",
				"scope": "keyword.operator.comparison.php",
				"settings": {"foreground": "#56b6c2"},
			},
			{
				"name": "php heredoc/nowdoc",
				"scope": "keyword.operator.heredoc.php,keyword.operator.nowdoc.php",
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "python function decorator @",
				"scope": "meta.function.decorator.python",
				"settings": {"foreground": "#61afef"},
			},
			{
				"name": "python function support",
				"scope": "support.token.decorator.python,meta.function.decorator.identifier.python",
				"settings": {"foreground": "#56b6c2"},
			},
			{
				"name": "parameter function js/ts",
				"scope": "function.parameter",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "brace function",
				"scope": "function.brace",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "parameter function ruby cs",
				"scope": "function.parameter.ruby, function.parameter.cs",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "constant.language.symbol.ruby",
				"scope": "constant.language.symbol.ruby",
				"settings": {"foreground": "#56b6c2"},
			},
			{
				"name": "rgb-value",
				"scope": "rgb-value",
				"settings": {"foreground": "#56b6c2"},
			},
			{
				"name": "rgb value",
				"scope": "inline-color-decoration rgb-value",
				"settings": {"foreground": "#d19a66"},
			},
			{
				"name": "rgb value less",
				"scope": "less rgb-value",
				"settings": {"foreground": "#d19a66"},
			},
			{
				"name": "sass selector",
				"scope": "selector.sass",
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "ts primitive/builtin types",
				"scope": "support.type.primitive.ts,support.type.builtin.ts,support.type.primitive.tsx,support.type.builtin.tsx",
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "block scope",
				"scope": "block.scope.end,block.scope.begin",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "cs storage type",
				"scope": "storage.type.cs",
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "cs local variable",
				"scope": "entity.name.variable.local.cs",
				"settings": {"foreground": "#e06c75"},
			},
			{"scope": "token.info-token", "settings": {"foreground": "#61afef"}},
			{"scope": "token.warn-token", "settings": {"foreground": "#d19a66"}},
			{"scope": "token.error-token", "settings": {"foreground": "#f44747"}},
			{"scope": "token.debug-token", "settings": {"foreground": "#c678dd"}},
			{
				"name": "String interpolation",
				"scope": [
					"punctuation.definition.template-expression.begin",
					"punctuation.definition.template-expression.end",
					"punctuation.section.embedded",
				],
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "Reset JavaScript string interpolation expression",
				"scope": ["meta.template.expression"],
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "Import module JS",
				"scope": ["keyword.operator.module"],
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "js Flowtype",
				"scope": ["support.type.type.flowtype"],
				"settings": {"foreground": "#61afef"},
			},
			{
				"name": "js Flow",
				"scope": ["support.type.primitive"],
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "js class prop",
				"scope": ["meta.property.object"],
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "js func parameter",
				"scope": ["variable.parameter.function.js"],
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "js template literals begin",
				"scope": ["keyword.other.template.begin"],
				"settings": {"foreground": "#98c379"},
			},
			{
				"name": "js template literals end",
				"scope": ["keyword.other.template.end"],
				"settings": {"foreground": "#98c379"},
			},
			{
				"name": "js template literals variable braces begin",
				"scope": ["keyword.other.substitution.begin"],
				"settings": {"foreground": "#98c379"},
			},
			{
				"name": "js template literals variable braces end",
				"scope": ["keyword.other.substitution.end"],
				"settings": {"foreground": "#98c379"},
			},
			{
				"name": "js operator.assignment",
				"scope": ["keyword.operator.assignment"],
				"settings": {"foreground": "#56b6c2"},
			},
			{
				"name": "go operator",
				"scope": [
					"keyword.operator.assignment.go",
					"keyword.operator.address.go",
				],
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "Go package name",
				"scope": ["entity.name.package.go"],
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "elm prelude",
				"scope": ["support.type.prelude.elm"],
				"settings": {"foreground": "#56b6c2"},
			},
			{
				"name": "elm constant",
				"scope": ["support.constant.elm"],
				"settings": {"foreground": "#d19a66"},
			},
			{
				"name": "template literal",
				"scope": ["punctuation.quasi.element"],
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "html/pug (jade) escaped characters and entities",
				"scope": ["constant.character.entity"],
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "styling css pseudo-elements/classes to be able to differentiate from classes which are the same colour",
				"scope": [
					"entity.other.attribute-name.pseudo-element",
					"entity.other.attribute-name.pseudo-class",
				],
				"settings": {"foreground": "#56b6c2"},
			},
			{
				"name": "Clojure globals",
				"scope": ["entity.global.clojure"],
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "Clojure symbols",
				"scope": ["meta.symbol.clojure"],
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "Clojure constants",
				"scope": ["constant.keyword.clojure"],
				"settings": {"foreground": "#56b6c2"},
			},
			{
				"name": "CoffeeScript Function Argument",
				"scope": ["meta.arguments.coffee", "variable.parameter.function.coffee"],
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "Ini Default Text",
				"scope": ["source.ini"],
				"settings": {"foreground": "#98c379"},
			},
			{
				"name": "Makefile prerequisities",
				"scope": ["meta.scope.prerequisites.makefile"],
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "Makefile text colour",
				"scope": ["source.makefile"],
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "Groovy import names",
				"scope": ["storage.modifier.import.groovy"],
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "Groovy Methods",
				"scope": ["meta.method.groovy"],
				"settings": {"foreground": "#61afef"},
			},
			{
				"name": "Groovy Variables",
				"scope": ["meta.definition.variable.name.groovy"],
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "Groovy Inheritance",
				"scope": ["meta.definition.class.inherited.classes.groovy"],
				"settings": {"foreground": "#98c379"},
			},
			{
				"name": "HLSL Semantic",
				"scope": ["support.variable.semantic.hlsl"],
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "HLSL Types",
				"scope": [
					"support.type.texture.hlsl",
					"support.type.sampler.hlsl",
					"support.type.object.hlsl",
					"support.type.object.rw.hlsl",
					"support.type.fx.hlsl",
					"support.type.object.hlsl",
				],
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "SQL Variables",
				"scope": ["text.variable", "text.bracketed"],
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "types",
				"scope": ["support.type.swift", "support.type.vb.asp"],
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "heading 1, keyword",
				"scope": ["entity.name.function.xi"],
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "heading 2, callable",
				"scope": ["entity.name.class.xi"],
				"settings": {"foreground": "#56b6c2"},
			},
			{
				"name": "heading 3, property",
				"scope": ["constant.character.character-class.regexp.xi"],
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "heading 4, type, class, interface",
				"scope": ["constant.regexp.xi"],
				"settings": {"foreground": "#c678dd"},
			},
			{
				"name": "heading 5, enums, preprocessor, constant, decorator",
				"scope": ["keyword.control.xi"],
				"settings": {"foreground": "#56b6c2"},
			},
			{
				"name": "heading 6, number",
				"scope": ["invalid.xi"],
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "string",
				"scope": ["beginning.punctuation.definition.quote.markdown.xi"],
				"settings": {"foreground": "#98c379"},
			},
			{
				"name": "comments",
				"scope": ["beginning.punctuation.definition.list.markdown.xi"],
				"settings": {"foreground": "#7f848e"},
			},
			{
				"name": "link",
				"scope": ["constant.character.xi"],
				"settings": {"foreground": "#61afef"},
			},
			{
				"name": "accent",
				"scope": ["accent.xi"],
				"settings": {"foreground": "#61afef"},
			},
			{
				"name": "wikiword",
				"scope": ["wikiword.xi"],
				"settings": {"foreground": "#d19a66"},
			},
			{
				"name": "language operators like '+', '-' etc",
				"scope": ["constant.other.color.rgb-value.xi"],
				"settings": {"foreground": "#ffffff"},
			},
			{
				"name": "elements to dim",
				"scope": ["punctuation.definition.tag.xi"],
				"settings": {"foreground": "#5c6370"},
			},
			{
				"name": "C++/C#",
				"scope": [
					"entity.name.label.cs",
					"entity.name.scope-resolution.function.call",
					"entity.name.scope-resolution.function.definition",
				],
				"settings": {"foreground": "#e5c07b"},
			},
			{
				"name": "Markdown underscore-style headers",
				"scope": [
					"entity.name.label.cs",
					"markup.heading.setext.1.markdown",
					"markup.heading.setext.2.markdown",
				],
				"settings": {"foreground": "#e06c75"},
			},
			{
				"name": "meta.brace.square",
				"scope": [" meta.brace.square"],
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "Comments",
				"scope": "comment, punctuation.definition.comment",
				"settings": {"fontStyle": "italic", "foreground": "#7f848e"},
			},
			{
				"name": "[VSCODE-CUSTOM] Markdown Quote",
				"scope": "markup.quote.markdown",
				"settings": {"foreground": "#5c6370"},
			},
			{
				"name": "punctuation.definition.block.sequence.item.yaml",
				"scope": "punctuation.definition.block.sequence.item.yaml",
				"settings": {"foreground": "#abb2bf"},
			},
			{
				"name": "js/ts italic",
				"scope": "entity.other.attribute-name.js,entity.other.attribute-name.ts,entity.other.attribute-name.jsx,entity.other.attribute-name.tsx,variable.parameter,variable.language.super",
				"settings": {"fontStyle": "italic"},
			},
			{
				"name": "comment",
				"scope": "comment.line.double-slash,comment.block.documentation",
				"settings": {"fontStyle": "italic"},
			},
			{
				"name": "Python Keyword Control",
				"scope": "keyword.control.import.python,keyword.control.flow.python",
				"settings": {"fontStyle": "italic"},
			},
			{
				"name": "markup.italic.markdown",
				"scope": "markup.italic.markdown",
				"settings": {"fontStyle": "italic"},
			},
		],
		"colors": {
			"activityBar.background": "#282c34",
			"activityBar.foreground": "#d7dae0",
			"activityBarBadge.background": "#4d78cc",
			"activityBarBadge.foreground": "#f8fafd",
			"badge.background": "#282c34",
			"button.background": "#404754",
			"debugToolBar.background": "#21252b",
			"diffEditor.insertedTextBackground": "#00809b33",
			"dropdown.background": "#21252b",
			"dropdown.border": "#21252b",
			"editor.background": "#282c34",
			"editor.findMatchBackground": "#42557b",
			"editor.findMatchBorder": "#457dff",
			"editor.findMatchHighlightBackground": "#6199ff2f",
			"editor.foreground": "#abb2bf",
			"editor.lineHighlightBackground": "#2c313c",
			"editor.selectionBackground": "#67769660",
			"editor.selectionHighlightBackground": "#ffffff10",
			"editor.selectionHighlightBorder": "#dddddd",
			"editor.wordHighlightBackground": "#d2e0ff2f",
			"editor.wordHighlightBorder": "#7f848e",
			"editor.wordHighlightStrongBackground": "#abb2bf26",
			"editor.wordHighlightStrongBorder": "#7f848e",
			"editorActiveLineNumber.foreground": "#737984",
			"editorBracketMatch.background": "#515a6b",
			"editorBracketMatch.border": "#515a6b",
			"editorCursor.background": "#ffffffc9",
			"editorCursor.foreground": "#528bff",
			"editorError.foreground": "#c24038",
			"editorGroup.background": "#181a1f",
			"editorGroup.border": "#181a1f",
			"editorGroupHeader.tabsBackground": "#21252b",
			"editorHoverWidget.background": "#21252b",
			"editorHoverWidget.border": "#181a1f",
			"editorIndentGuide.activeBackground": "#c8c8c859",
			"editorIndentGuide.background": "#3b4048",
			"editorLineNumber.foreground": "#495162",
			"editorMarkerNavigation.background": "#21252b",
			"editorRuler.foreground": "#abb2bf26",
			"editorSuggestWidget.background": "#21252b",
			"editorSuggestWidget.border": "#181a1f",
			"editorSuggestWidget.selectedBackground": "#2c313a",
			"editorWarning.foreground": "#d19a66",
			"editorWhitespace.foreground": "#3b4048",
			"editorWidget.background": "#21252b",
			"focusBorder": "#464646",
			"input.background": "#1d1f23",
			"list.activeSelectionBackground": "#2c313a",
			"list.activeSelectionForeground": "#d7dae0",
			"list.focusBackground": "#383e4a",
			"list.highlightForeground": "#c5c5c5",
			"list.hoverBackground": "#292d35",
			"list.inactiveSelectionBackground": "#2c313a",
			"list.inactiveSelectionForeground": "#d7dae0",
			"list.warningForeground": "#d19a66",
			"menu.foreground": "#c8c8c8",
			"panelSectionHeader.background": "#21252b",
			"peekViewEditor.background": "#1b1d23",
			"peekViewEditor.matchHighlightBackground": "#29244b",
			"peekViewResult.background": "#22262b",
			"scrollbarSlider.activeBackground": "#747d9180",
			"scrollbarSlider.background": "#4e566660",
			"scrollbarSlider.hoverBackground": "#5a637580",
			"sideBar.background": "#21252b",
			"sideBarSectionHeader.background": "#282c34",
			"statusBar.background": "#21252b",
			"statusBar.debuggingBackground": "#cc6633",
			"statusBar.debuggingBorder": "#66017a",
			"statusBar.debuggingForeground": "#ffffff",
			"statusBar.foreground": "#9da5b4",
			"statusBar.noFolderBackground": "#21252b",
			"statusBarItem.hoverBackground": "#2c313a",
			"statusBarItem.remoteBackground": "#4d78cc",
			"statusBarItem.remoteForeground": "#f8fafd",
			"tab.activeBackground": "#282c34",
			"tab.activeForeground": "#dcdcdc",
			"tab.border": "#181a1f",
			"tab.hoverBackground": "#323842",
			"tab.inactiveBackground": "#21252b",
			"tab.unfocusedHoverBackground": "#323842",
			"terminal.ansiBlack": "#3f4451",
			"terminal.ansiBlue": "#4aa5f0",
			"terminal.ansiBrightBlack": "#4f5666",
			"terminal.ansiBrightBlue": "#4dc4ff",
			"terminal.ansiBrightCyan": "#4cd1e0",
			"terminal.ansiBrightGreen": "#a5e075",
			"terminal.ansiBrightMagenta": "#de73ff",
			"terminal.ansiBrightRed": "#ff616e",
			"terminal.ansiBrightWhite": "#d7dae0",
			"terminal.ansiBrightYellow": "#f0a45d",
			"terminal.ansiCyan": "#42b3c2",
			"terminal.ansiGreen": "#8cc265",
			"terminal.ansiMagenta": "#c162de",
			"terminal.ansiRed": "#e05561",
			"terminal.ansiWhite": "#e6e6e6",
			"terminal.ansiYellow": "#d18f52",
			"terminal.background": "#282c34",
			"terminal.border": "#abb2bf",
			"terminal.foreground": "#abb2bf",
			"terminal.selectionBackground": "#abb2bf30",
			"textLink.foreground": "#61afef",
			"titleBar.activeBackground": "#282c34",
			"titleBar.activeForeground": "#9da5b4",
			"titleBar.inactiveBackground": "#21252b",
			"titleBar.inactiveForeground": "#6b717d",
		},
	};


  // project-rome/@internal/consume/types.ts
const ___R$project$rome$$internal$consume$types_ts = {};


  // project-rome/@internal/js-ast-utils/assertMultipleNodes.ts
function ___R$project$rome$$internal$js$ast$utils$assertMultipleNodes_ts$assertMultipleNodes(
		result,
	) {
		if (Array.isArray(result)) {
			return result;
		} else if (result === undefined) {
			return [];
		} else {
			return [result];
		}
	}


  // project-rome/@internal/js-ast-utils/assertSingleNode.ts
function ___R$project$rome$$internal$js$ast$utils$assertSingleNode_ts$assertSingleNode(
		result,
	) {
		if (Array.isArray(result)) {
			if (result.length !== 1) {
				throw new Error(
					"Expected node list length of 1 but got " + result.length,
				);
			}
			return result[0];
		} else if (result === undefined) {
			throw new Error("Expected node or node list but got undefined");
		} else {
			return result;
		}
	}


  // project-rome/@internal/js-ast-utils/assertSingleOrMultipleNodes.ts
function ___R$project$rome$$internal$js$ast$utils$assertSingleOrMultipleNodes_ts$assertSingleOrMultipleNodes(
		result,
	) {
		if (result === undefined) {
			throw new Error("Expected node or node list but got null");
		} else if (typeof result === "symbol") {
			throw new Error("No symbols expected here");
		} else {
			return result;
		}
	}


  // project-rome/@internal/js-ast-utils/isIdentifierish.ts
function ___R$project$rome$$internal$js$ast$utils$isIdentifierish_ts$isIdentifierish(
		node,
	) {
		return (
			node.type === "JSIdentifier" ||
			node.type === "JSXIdentifier" ||
			node.type === "JSXReferenceIdentifier" ||
			node.type === "JSBindingIdentifier" ||
			node.type === "JSAssignmentIdentifier" ||
			node.type === "JSReferenceIdentifier"
		);
	}


  // project-rome/@internal/js-ast-utils/getNodeReferenceParts.ts
const ___R$$priv$project$rome$$internal$js$ast$utils$getNodeReferenceParts_ts$cache = new WeakMap();

	const ___R$$priv$project$rome$$internal$js$ast$utils$getNodeReferenceParts_ts$EMPTY = {
		bailed: true,
		parts: [],
	};

	function ___R$project$rome$$internal$js$ast$utils$getNodeReferenceParts_ts$getNodeReferenceParts(
		node,
	) {
		if (node === undefined) {
			return ___R$$priv$project$rome$$internal$js$ast$utils$getNodeReferenceParts_ts$EMPTY;
		}

		const cached = ___R$$priv$project$rome$$internal$js$ast$utils$getNodeReferenceParts_ts$cache.get(
			node,
		);
		if (cached !== undefined) {
			return cached;
		}

		const parts = [];

		function add(node) {
			if (
				___R$project$rome$$internal$js$ast$utils$isIdentifierish_ts$isIdentifierish(
					node,
				)
			) {
				parts.push({node, value: node.name});
				return false;
			}

			switch (node.type) {
				case "JSThisExpression": {
					parts.push({node, value: "this"});
					return false;
				}

				case "JSComputedMemberProperty": {
					if (node.value.type === "JSStringLiteral") {
						return add(node.value);
					} else {
						return true;
					}
				}

				case "TSStringLiteralTypeAnnotation":
				case "JSStringLiteral": {
					parts.push({node, value: node.value});
					return false;
				}

				case "JSMetaProperty": {
					parts.push({node, value: node.meta.name});
					parts.push({node, value: node.property.name});
					return false;
				}

				case "TSQualifiedName": {
					add(node.left);
					add(node.right);
					return false;
				}

				case "TSIndexedAccessType": {
					const stop = add(node.objectType);
					if (stop) {
						return true;
					} else {
						return add(node.indexType);
					}
				}

				case "JSMemberExpression":
				case "JSXMemberExpression": {
					const stop = add(node.object);
					if (stop) {
						return true;
					} else {
						return add(node.property);
					}
				}

				case "JSStaticMemberProperty":
					return add(node.value);

				default:
					return true;
			}
		}

		const bailed = add(node);
		const result = {bailed, parts};
		___R$$priv$project$rome$$internal$js$ast$utils$getNodeReferenceParts_ts$cache.set(
			node,
			result,
		);
		return result;
	}


  // project-rome/@internal/js-ast-utils/doesNodeMatchPattern.ts
const ___R$$priv$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$splitCache = new Map();

	function ___R$$priv$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$split(
		str,
	) {
		const cached = ___R$$priv$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$splitCache.get(
			str,
		);
		if (cached !== undefined) {
			return cached;
		}

		const parts = str.split(".");

		let hasDoubleStar = false;
		for (const part of parts) {
			if (part === "**") {
				hasDoubleStar = true;
				break;
			}
		}

		const result = {parts, hasDoubleStar};
		___R$$priv$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$splitCache.set(
			str,
			result,
		);
		return result;
	}

	function ___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
		node,
		match,
	) {
		if (node === undefined) {
			return false;
		}

		// Not a member expression
		if (
			node.type !== "JSMemberExpression" &&
			node.type !== "JSXMemberExpression" &&
			!___R$project$rome$$internal$js$ast$utils$isIdentifierish_ts$isIdentifierish(
				node,
			)
		) {
			return false;
		}

		const {parts: expectedParts, hasDoubleStar} = ___R$$priv$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$split(
			match,
		);

		// Fast path for single part pattern matching
		if (expectedParts.length === 1 && expectedParts[0] !== "*" && !hasDoubleStar) {
			return (
				___R$project$rome$$internal$js$ast$utils$isIdentifierish_ts$isIdentifierish(
					node,
				) && node.name === expectedParts[0]
			);
		}

		const {bailed, parts: actualParts} = ___R$project$rome$$internal$js$ast$utils$getNodeReferenceParts_ts$getNodeReferenceParts(
			node,
		);

		// Bailed will be true if we were unable to derive a name for one of the parts
		if (bailed && !hasDoubleStar) {
			return false;
		}

		// If there's less parts than the amount we expect then it's never going to match
		if (actualParts.length < expectedParts.length) {
			return false;
		}

		// I there's more parts than we expect then it's never going to match either
		if (!hasDoubleStar && actualParts.length > expectedParts.length) {
			return false;
		}

		let nextActualIndex = 0;
		let nextExpectedIndex = 0;

		// Loop over the parts we received and match them
		while (nextActualIndex < actualParts.length) {
			// If we have no more expected parts then we can't possibly match it
			if (nextActualIndex >= expectedParts.length) {
				return false;
			}

			const actual = actualParts[nextActualIndex].value;
			nextActualIndex++;

			const expected = expectedParts[nextExpectedIndex];
			nextExpectedIndex++;

			// A star part can accept anything
			if (expected === "*") {
				continue;
			}

			if (expected === "**") {
				// Ran out of matches but we've accepted the current part
				if (nextExpectedIndex >= expectedParts.length) {
					return true;
				}

				const next = expectedParts[nextExpectedIndex];
				nextExpectedIndex++;

				if (next === "*" || next === "**") {
					throw new Error(
						"The next expected part was " +
						next +
						" but this isn't allowed since we're processing a double star",
					);
				}

				let found = false;

				// Eat as many parts until we find the next expected part
				while (nextActualIndex < actualParts.length) {
					const actual = actualParts[nextActualIndex].value;
					nextActualIndex++;
					if (actual === next) {
						found = true;
						break;
					}
				}

				if (found) {
					continue;
				} else {
					return false;
				}
			}

			if (expected !== actual) {
				return false;
			}
		}

		return true;
	}


  // project-rome/@internal/ast/base.ts
const ___R$project$rome$$internal$ast$base_ts = {};


  // project-rome/@internal/ast/js/constants.ts
const ___R$project$rome$$internal$ast$js$constants_ts = {};


  // project-rome/@internal/ast/html/unions.ts
const ___R$project$rome$$internal$ast$html$unions_ts = {};


  // project-rome/@internal/ast/js/unions.ts
const ___R$project$rome$$internal$ast$js$unions_ts = {};


  // project-rome/@internal/ast/markdown/unions.ts
const ___R$project$rome$$internal$ast$markdown$unions_ts = {};


  // project-rome/@internal/ast/unions.ts
const ___R$project$rome$$internal$ast$unions_ts = {};


  // project-rome/@internal/ast/utils.ts
const ___R$project$rome$$internal$ast$utils_ts$bindingKeys = new Map();
	const ___R$project$rome$$internal$ast$utils_ts$visitorKeys = new Map();
	const ___R$project$rome$$internal$ast$utils_ts$nodeNames = new Set();

	function ___R$$priv$project$rome$$internal$ast$utils_ts$declareBuilder(
		type,
		opts,
	) {
		___R$project$rome$$internal$ast$utils_ts$nodeNames.add(type);

		if (opts.visitorKeys !== undefined) {
			___R$project$rome$$internal$ast$utils_ts$visitorKeys.set(
				type,
				Object.keys(opts.visitorKeys),
			);
		}

		if (opts.bindingKeys !== undefined) {
			___R$project$rome$$internal$ast$utils_ts$bindingKeys.set(
				type,
				Object.keys(opts.bindingKeys),
			);
		}
	}

	// TODO only allow this method to be called on a node with only one required property
	function ___R$project$rome$$internal$ast$utils_ts$createQuickBuilder(
		type,
		quickKey,
		opts,
	) {
		___R$$priv$project$rome$$internal$ast$utils_ts$declareBuilder(type, opts);
		return new ___R$$priv$project$rome$$internal$ast$utils_ts$QuickBuilder(
			type,
			quickKey,
		);
	}

	function ___R$project$rome$$internal$ast$utils_ts$createBuilder(type, opts) {
		___R$$priv$project$rome$$internal$ast$utils_ts$declareBuilder(type, opts);
		return new ___R$$priv$project$rome$$internal$ast$utils_ts$Builder(type);
	}

	class ___R$$priv$project$rome$$internal$ast$utils_ts$Builder {
		constructor(type) {
			this.type = type;
		}

		create(opts, inheritNode) {
			// @ts-ignore
			return Object.freeze(
				Object.assign(
					{
						loc: inheritNode === undefined
							? undefined
							: ___R$project$rome$$internal$js$ast$utils$inheritLoc_ts$inheritLoc(
									inheritNode,
								),
					},
					opts,
					{type: this.type},
				),
			);
		}

		assert(res) {
			if (res === undefined) {
				throw new Error("Expected " + this.type + " Node but got undefined");
			}

			const node = ___R$project$rome$$internal$js$ast$utils$assertSingleNode_ts$assertSingleNode(
				res,
			);

			if (node.type !== this.type) {
				throw new Error("Expected " + this.type + " Node but got " + node.type);
			}

			// @ts-ignore
			return node;
		}
	}

	class ___R$$priv$project$rome$$internal$ast$utils_ts$QuickBuilder
		extends ___R$$priv$project$rome$$internal$ast$utils_ts$Builder {
		constructor(type, quickKey) {
			super(type);
			this.quickKey = quickKey;
		}

		quick(arg, opts, inheritNode) {
			const node = (Object.assign({}, opts, {[this.quickKey]: arg}));

			return this.create(node, inheritNode);
		}
	}


  // project-rome/@internal/ast/common/comments/CommentBlock.ts
const ___R$project$rome$$internal$ast$common$comments$CommentBlock_ts = {
		get jsCommentBlock() {
			return ___R$project$rome$$internal$ast$common$comments$CommentBlock_ts$jsCommentBlock;
		},
	};
	const ___R$project$rome$$internal$ast$common$comments$CommentBlock_ts$jsCommentBlock = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"CommentBlock",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/common/comments/CommentLine.ts
const ___R$project$rome$$internal$ast$common$comments$CommentLine_ts = {
		get jsCommentLine() {
			return ___R$project$rome$$internal$ast$common$comments$CommentLine_ts$jsCommentLine;
		},
	};
	const ___R$project$rome$$internal$ast$common$comments$CommentLine_ts$jsCommentLine = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"CommentLine",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/common/commit/CommitRoot.ts
const ___R$project$rome$$internal$ast$common$commit$CommitRoot_ts = {
		get commitRoot() {
			return ___R$project$rome$$internal$ast$common$commit$CommitRoot_ts$commitRoot;
		},
	};
	const ___R$project$rome$$internal$ast$common$commit$CommitRoot_ts$commitRoot = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"CommitRoot",
		{
			bindingKeys: {},
			visitorKeys: {
				comments: true,
			},
		},
	);


  // project-rome/@internal/ast/css/core/CSSAtRule.ts
const ___R$project$rome$$internal$ast$css$core$CSSAtRule_ts = {
		get cssAtRule() {
			return ___R$project$rome$$internal$ast$css$core$CSSAtRule_ts$cssAtRule;
		},
	};
	const ___R$project$rome$$internal$ast$css$core$CSSAtRule_ts$cssAtRule = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"CSSAtRule",
		{
			bindingKeys: {},
			visitorKeys: {
				block: true,
				prelude: true,
			},
		},
	);


  // project-rome/@internal/ast/css/core/CSSBlock.ts
const ___R$project$rome$$internal$ast$css$core$CSSBlock_ts = {
		get cssBlock() {
			return ___R$project$rome$$internal$ast$css$core$CSSBlock_ts$cssBlock;
		},
	};
	const ___R$project$rome$$internal$ast$css$core$CSSBlock_ts$cssBlock = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"CSSBlock",
		{
			bindingKeys: {},
			visitorKeys: {
				value: true,
			},
		},
	);


  // project-rome/@internal/ast/css/core/CSSDeclaration.ts
const ___R$project$rome$$internal$ast$css$core$CSSDeclaration_ts = {
		get cssDeclaration() {
			return ___R$project$rome$$internal$ast$css$core$CSSDeclaration_ts$cssDeclaration;
		},
	};
	const ___R$project$rome$$internal$ast$css$core$CSSDeclaration_ts$cssDeclaration = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"CSSDeclaration",
		{
			bindingKeys: {},
			visitorKeys: {
				value: true,
			},
		},
	);


  // project-rome/@internal/ast/css/core/CSSDimension.ts
const ___R$project$rome$$internal$ast$css$core$CSSDimension_ts = {
		get cssDimension() {
			return ___R$project$rome$$internal$ast$css$core$CSSDimension_ts$cssDimension;
		},
	};
	const ___R$project$rome$$internal$ast$css$core$CSSDimension_ts$cssDimension = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"CSSDimension",
		{
			bindingKeys: {},
			visitorKeys: {
				value: true,
			},
		},
	);


  // project-rome/@internal/ast/css/core/CSSFunction.ts
const ___R$project$rome$$internal$ast$css$core$CSSFunction_ts = {
		get cssFunction() {
			return ___R$project$rome$$internal$ast$css$core$CSSFunction_ts$cssFunction;
		},
	};
	const ___R$project$rome$$internal$ast$css$core$CSSFunction_ts$cssFunction = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"CSSFunction",
		{
			bindingKeys: {},
			visitorKeys: {
				value: true,
			},
		},
	);


  // project-rome/@internal/ast/css/core/CSSIdentifier.ts
const ___R$project$rome$$internal$ast$css$core$CSSIdentifier_ts = {
		get cssIdentifier() {
			return ___R$project$rome$$internal$ast$css$core$CSSIdentifier_ts$cssIdentifier;
		},
	};
	const ___R$project$rome$$internal$ast$css$core$CSSIdentifier_ts$cssIdentifier = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"CSSIdentifier",
		{
			bindingKeys: {},
			visitorKeys: {
				value: true,
			},
		},
	);


  // project-rome/@internal/ast/css/core/CSSNumber.ts
const ___R$project$rome$$internal$ast$css$core$CSSNumber_ts = {
		get cssNumber() {
			return ___R$project$rome$$internal$ast$css$core$CSSNumber_ts$cssNumber;
		},
	};
	const ___R$project$rome$$internal$ast$css$core$CSSNumber_ts$cssNumber = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"CSSNumber",
		{
			bindingKeys: {},
			visitorKeys: {
				value: true,
			},
		},
	);


  // project-rome/@internal/ast/css/core/CSSPercentage.ts
const ___R$project$rome$$internal$ast$css$core$CSSPercentage_ts = {
		get cssPercentage() {
			return ___R$project$rome$$internal$ast$css$core$CSSPercentage_ts$cssPercentage;
		},
	};
	const ___R$project$rome$$internal$ast$css$core$CSSPercentage_ts$cssPercentage = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"CSSPercentage",
		{
			bindingKeys: {},
			visitorKeys: {
				value: true,
			},
		},
	);


  // project-rome/@internal/ast/css/core/CSSRaw.ts
const ___R$project$rome$$internal$ast$css$core$CSSRaw_ts = {
		get cssRaw() {
			return ___R$project$rome$$internal$ast$css$core$CSSRaw_ts$cssRaw;
		},
	};
	const ___R$project$rome$$internal$ast$css$core$CSSRaw_ts$cssRaw = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"CSSRaw",
		{
			bindingKeys: {},
			visitorKeys: {
				value: true,
			},
		},
	);


  // project-rome/@internal/ast/css/core/CSSRoot.ts
const ___R$project$rome$$internal$ast$css$core$CSSRoot_ts = {
		get cssRoot() {
			return ___R$project$rome$$internal$ast$css$core$CSSRoot_ts$cssRoot;
		},
	};
	const ___R$project$rome$$internal$ast$css$core$CSSRoot_ts$cssRoot = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"CSSRoot",
		{
			bindingKeys: {},
			visitorKeys: {
				body: true,
				comments: true,
			},
		},
	);


  // project-rome/@internal/ast/css/core/CSSRule.ts
const ___R$project$rome$$internal$ast$css$core$CSSRule_ts = {
		get cssRule() {
			return ___R$project$rome$$internal$ast$css$core$CSSRule_ts$cssRule;
		},
	};
	const ___R$project$rome$$internal$ast$css$core$CSSRule_ts$cssRule = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"CSSRule",
		{
			bindingKeys: {},
			visitorKeys: {
				prelude: true,
				block: true,
			},
		},
	);


  // project-rome/@internal/ast/html/attributes/HTMLAttribute.ts
const ___R$project$rome$$internal$ast$html$attributes$HTMLAttribute_ts = {
		get htmlAttribute() {
			return ___R$project$rome$$internal$ast$html$attributes$HTMLAttribute_ts$htmlAttribute;
		},
	};
	const ___R$project$rome$$internal$ast$html$attributes$HTMLAttribute_ts$htmlAttribute = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"HTMLAttribute",
		{
			bindingKeys: {},
			visitorKeys: {
				name: true,
				value: true,
			},
		},
	);


  // project-rome/@internal/ast/html/tags/HTMLDoctypeTag.ts
const ___R$project$rome$$internal$ast$html$tags$HTMLDoctypeTag_ts = {
		get htmlDoctypeTag() {
			return ___R$project$rome$$internal$ast$html$tags$HTMLDoctypeTag_ts$htmlDoctypeTag;
		},
	};
	const ___R$project$rome$$internal$ast$html$tags$HTMLDoctypeTag_ts$htmlDoctypeTag = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"HTMLDoctypeTag",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/html/tags/HTMLElement.ts
const ___R$project$rome$$internal$ast$html$tags$HTMLElement_ts = {
		get htmlElement() {
			return ___R$project$rome$$internal$ast$html$tags$HTMLElement_ts$htmlElement;
		},
	};
	const ___R$project$rome$$internal$ast$html$tags$HTMLElement_ts$htmlElement = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"HTMLElement",
		{
			bindingKeys: {},
			visitorKeys: {
				name: true,
				attributes: true,
				children: true,
			},
		},
	);


  // project-rome/@internal/ast/html/core/HTMLIdentifier.ts
const ___R$project$rome$$internal$ast$html$core$HTMLIdentifier_ts = {
		get htmlIdentifier() {
			return ___R$project$rome$$internal$ast$html$core$HTMLIdentifier_ts$htmlIdentifier;
		},
	};
	const ___R$project$rome$$internal$ast$html$core$HTMLIdentifier_ts$htmlIdentifier = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"HTMLIdentifier",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/html/core/HTMLRoot.ts
const ___R$project$rome$$internal$ast$html$core$HTMLRoot_ts = {
		get htmlRoot() {
			return ___R$project$rome$$internal$ast$html$core$HTMLRoot_ts$htmlRoot;
		},
	};
	const ___R$project$rome$$internal$ast$html$core$HTMLRoot_ts$htmlRoot = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"HTMLRoot",
		{
			bindingKeys: {},
			visitorKeys: {
				body: true,
				comments: true,
			},
		},
	);


  // project-rome/@internal/ast/html/core/HTMLString.ts
const ___R$project$rome$$internal$ast$html$core$HTMLString_ts = {
		get htmlString() {
			return ___R$project$rome$$internal$ast$html$core$HTMLString_ts$htmlString;
		},
	};
	const ___R$project$rome$$internal$ast$html$core$HTMLString_ts$htmlString = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"HTMLString",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/html/core/HTMLText.ts
const ___R$project$rome$$internal$ast$html$core$HTMLText_ts = {
		get htmlText() {
			return ___R$project$rome$$internal$ast$html$core$HTMLText_ts$htmlText;
		},
	};
	const ___R$project$rome$$internal$ast$html$core$HTMLText_ts$htmlText = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"HTMLText",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/temp/JSAmbiguousFlowTypeCastExpression.ts
const ___R$project$rome$$internal$ast$js$temp$JSAmbiguousFlowTypeCastExpression_ts = {
		get jsAmbiguousFlowTypeCastExpression() {
			return ___R$project$rome$$internal$ast$js$temp$JSAmbiguousFlowTypeCastExpression_ts$jsAmbiguousFlowTypeCastExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$temp$JSAmbiguousFlowTypeCastExpression_ts$jsAmbiguousFlowTypeCastExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSAmbiguousFlowTypeCastExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				expression: true,
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@internal/ast/js/expressions/JSArrayExpression.ts
const ___R$project$rome$$internal$ast$js$expressions$JSArrayExpression_ts = {
		get jsArrayExpression() {
			return ___R$project$rome$$internal$ast$js$expressions$JSArrayExpression_ts$jsArrayExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$expressions$JSArrayExpression_ts$jsArrayExpression = ___R$project$rome$$internal$ast$utils_ts$createQuickBuilder(
		"JSArrayExpression",
		"elements",
		{
			bindingKeys: {},
			visitorKeys: {
				elements: true,
			},
		},
	);


  // project-rome/@internal/ast/js/auxiliary/JSArrayHole.ts
const ___R$project$rome$$internal$ast$js$auxiliary$JSArrayHole_ts = {
		get jsArrayHole() {
			return ___R$project$rome$$internal$ast$js$auxiliary$JSArrayHole_ts$jsArrayHole;
		},
	};
	const ___R$project$rome$$internal$ast$js$auxiliary$JSArrayHole_ts$jsArrayHole = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"ArrayHole",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/expressions/JSArrowFunctionExpression.ts
const ___R$project$rome$$internal$ast$js$expressions$JSArrowFunctionExpression_ts = {
		get jsArrowFunctionExpression() {
			return ___R$project$rome$$internal$ast$js$expressions$JSArrowFunctionExpression_ts$jsArrowFunctionExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$expressions$JSArrowFunctionExpression_ts$jsArrowFunctionExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSArrowFunctionExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				head: true,
				body: true,
			},
		},
	);


  // project-rome/@internal/ast/js/patterns/JSAssignmentArrayPattern.ts
const ___R$project$rome$$internal$ast$js$patterns$JSAssignmentArrayPattern_ts = {
		get jsAssignmentArrayPattern() {
			return ___R$project$rome$$internal$ast$js$patterns$JSAssignmentArrayPattern_ts$jsAssignmentArrayPattern;
		},
	};
	const ___R$project$rome$$internal$ast$js$patterns$JSAssignmentArrayPattern_ts$jsAssignmentArrayPattern = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSAssignmentArrayPattern",
		{
			bindingKeys: {},
			visitorKeys: {
				elements: true,
				rest: true,
				meta: true,
			},
		},
	);


  // project-rome/@internal/ast/js/patterns/JSAssignmentAssignmentPattern.ts
const ___R$project$rome$$internal$ast$js$patterns$JSAssignmentAssignmentPattern_ts = {
		get jsAssignmentAssignmentPattern() {
			return ___R$project$rome$$internal$ast$js$patterns$JSAssignmentAssignmentPattern_ts$jsAssignmentAssignmentPattern;
		},
	};
	const ___R$project$rome$$internal$ast$js$patterns$JSAssignmentAssignmentPattern_ts$jsAssignmentAssignmentPattern = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSAssignmentAssignmentPattern",
		{
			bindingKeys: {},
			visitorKeys: {
				left: true,
				right: true,
				meta: true,
			},
		},
	);


  // project-rome/@internal/ast/js/expressions/JSAssignmentExpression.ts
const ___R$project$rome$$internal$ast$js$expressions$JSAssignmentExpression_ts = {
		get jsAssignmentExpression() {
			return ___R$project$rome$$internal$ast$js$expressions$JSAssignmentExpression_ts$jsAssignmentExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$expressions$JSAssignmentExpression_ts$jsAssignmentExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSAssignmentExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				left: true,
				right: true,
			},
		},
	);


  // project-rome/@internal/ast/js/patterns/JSAssignmentIdentifier.ts
const ___R$project$rome$$internal$ast$js$patterns$JSAssignmentIdentifier_ts = {
		get jsAssignmentIdentifier() {
			return ___R$project$rome$$internal$ast$js$patterns$JSAssignmentIdentifier_ts$jsAssignmentIdentifier;
		},
	};
	const ___R$project$rome$$internal$ast$js$patterns$JSAssignmentIdentifier_ts$jsAssignmentIdentifier = ___R$project$rome$$internal$ast$utils_ts$createQuickBuilder(
		"JSAssignmentIdentifier",
		"name",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/patterns/JSAssignmentObjectPattern.ts
const ___R$project$rome$$internal$ast$js$patterns$JSAssignmentObjectPattern_ts = {
		get jsAssignmentObjectPattern() {
			return ___R$project$rome$$internal$ast$js$patterns$JSAssignmentObjectPattern_ts$jsAssignmentObjectPattern;
		},
	};
	const ___R$project$rome$$internal$ast$js$patterns$JSAssignmentObjectPattern_ts$jsAssignmentObjectPattern = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSAssignmentObjectPattern",
		{
			bindingKeys: {},
			visitorKeys: {
				properties: true,
				rest: true,
				meta: true,
			},
		},
	);


  // project-rome/@internal/ast/js/patterns/JSAssignmentObjectPatternProperty.ts
const ___R$project$rome$$internal$ast$js$patterns$JSAssignmentObjectPatternProperty_ts = {
		get jsAssignmentObjectPatternProperty() {
			return ___R$project$rome$$internal$ast$js$patterns$JSAssignmentObjectPatternProperty_ts$jsAssignmentObjectPatternProperty;
		},
	};
	const ___R$project$rome$$internal$ast$js$patterns$JSAssignmentObjectPatternProperty_ts$jsAssignmentObjectPatternProperty = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSAssignmentObjectPatternProperty",
		{
			bindingKeys: {},
			visitorKeys: {
				key: true,
				value: true,
			},
		},
	);


  // project-rome/@internal/ast/js/expressions/JSAwaitExpression.ts
const ___R$project$rome$$internal$ast$js$expressions$JSAwaitExpression_ts = {
		get jsAwaitExpression() {
			return ___R$project$rome$$internal$ast$js$expressions$JSAwaitExpression_ts$jsAwaitExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$expressions$JSAwaitExpression_ts$jsAwaitExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSAwaitExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				argument: true,
			},
		},
	);


  // project-rome/@internal/ast/js/literals/JSBigIntLiteral.ts
const ___R$project$rome$$internal$ast$js$literals$JSBigIntLiteral_ts = {
		get jsBigIntLiteral() {
			return ___R$project$rome$$internal$ast$js$literals$JSBigIntLiteral_ts$jsBigIntLiteral;
		},
	};
	const ___R$project$rome$$internal$ast$js$literals$JSBigIntLiteral_ts$jsBigIntLiteral = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSBigIntLiteral",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/expressions/JSBinaryExpression.ts
const ___R$project$rome$$internal$ast$js$expressions$JSBinaryExpression_ts = {
		get jsBinaryExpression() {
			return ___R$project$rome$$internal$ast$js$expressions$JSBinaryExpression_ts$jsBinaryExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$expressions$JSBinaryExpression_ts$jsBinaryExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSBinaryExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				left: true,
				right: true,
			},
		},
	);


  // project-rome/@internal/ast/js/patterns/JSBindingArrayPattern.ts
const ___R$project$rome$$internal$ast$js$patterns$JSBindingArrayPattern_ts = {
		get jsBindingArrayPattern() {
			return ___R$project$rome$$internal$ast$js$patterns$JSBindingArrayPattern_ts$jsBindingArrayPattern;
		},
	};
	const ___R$project$rome$$internal$ast$js$patterns$JSBindingArrayPattern_ts$jsBindingArrayPattern = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSBindingArrayPattern",
		{
			bindingKeys: {
				elements: true,
				rest: true,
			},
			visitorKeys: {
				elements: true,
				rest: true,
				meta: true,
			},
		},
	);


  // project-rome/@internal/ast/js/patterns/JSBindingAssignmentPattern.ts
const ___R$project$rome$$internal$ast$js$patterns$JSBindingAssignmentPattern_ts = {
		get jsBindingAssignmentPattern() {
			return ___R$project$rome$$internal$ast$js$patterns$JSBindingAssignmentPattern_ts$jsBindingAssignmentPattern;
		},
	};
	const ___R$project$rome$$internal$ast$js$patterns$JSBindingAssignmentPattern_ts$jsBindingAssignmentPattern = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSBindingAssignmentPattern",
		{
			bindingKeys: {
				left: true,
			},
			visitorKeys: {
				left: true,
				right: true,
				meta: true,
			},
		},
	);


  // project-rome/@internal/ast/js/patterns/JSBindingIdentifier.ts
const ___R$project$rome$$internal$ast$js$patterns$JSBindingIdentifier_ts = {
		get jsBindingIdentifier() {
			return ___R$project$rome$$internal$ast$js$patterns$JSBindingIdentifier_ts$jsBindingIdentifier;
		},
	};
	const ___R$project$rome$$internal$ast$js$patterns$JSBindingIdentifier_ts$jsBindingIdentifier = ___R$project$rome$$internal$ast$utils_ts$createQuickBuilder(
		"JSBindingIdentifier",
		"name",
		{
			bindingKeys: {},
			visitorKeys: {
				meta: true,
			},
		},
	);


  // project-rome/@internal/ast/js/patterns/JSBindingObjectPattern.ts
const ___R$project$rome$$internal$ast$js$patterns$JSBindingObjectPattern_ts = {
		get jsBindingObjectPattern() {
			return ___R$project$rome$$internal$ast$js$patterns$JSBindingObjectPattern_ts$jsBindingObjectPattern;
		},
	};
	const ___R$project$rome$$internal$ast$js$patterns$JSBindingObjectPattern_ts$jsBindingObjectPattern = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSBindingObjectPattern",
		{
			bindingKeys: {
				properties: true,
				rest: true,
			},
			visitorKeys: {
				properties: true,
				rest: true,
				meta: true,
			},
		},
	);


  // project-rome/@internal/ast/js/patterns/JSBindingObjectPatternProperty.ts
const ___R$project$rome$$internal$ast$js$patterns$JSBindingObjectPatternProperty_ts = {
		get jsBindingObjectPatternProperty() {
			return ___R$project$rome$$internal$ast$js$patterns$JSBindingObjectPatternProperty_ts$jsBindingObjectPatternProperty;
		},
	};
	const ___R$project$rome$$internal$ast$js$patterns$JSBindingObjectPatternProperty_ts$jsBindingObjectPatternProperty = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSBindingObjectPatternProperty",
		{
			bindingKeys: {
				value: true,
			},
			visitorKeys: {
				key: true,
				value: true,
			},
		},
	);


  // project-rome/@internal/ast/js/statements/JSBlockStatement.ts
const ___R$project$rome$$internal$ast$js$statements$JSBlockStatement_ts = {
		get jsBlockStatement() {
			return ___R$project$rome$$internal$ast$js$statements$JSBlockStatement_ts$jsBlockStatement;
		},
	};
	const ___R$project$rome$$internal$ast$js$statements$JSBlockStatement_ts$jsBlockStatement = ___R$project$rome$$internal$ast$utils_ts$createQuickBuilder(
		"JSBlockStatement",
		"body",
		{
			bindingKeys: {},
			visitorKeys: {
				body: true,
				directives: true,
			},
		},
	);


  // project-rome/@internal/ast/js/literals/JSBooleanLiteral.ts
const ___R$project$rome$$internal$ast$js$literals$JSBooleanLiteral_ts = {
		get jsBooleanLiteral() {
			return ___R$project$rome$$internal$ast$js$literals$JSBooleanLiteral_ts$jsBooleanLiteral;
		},
	};
	const ___R$project$rome$$internal$ast$js$literals$JSBooleanLiteral_ts$jsBooleanLiteral = ___R$project$rome$$internal$ast$utils_ts$createQuickBuilder(
		"JSBooleanLiteral",
		"value",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/statements/JSBreakStatement.ts
const ___R$project$rome$$internal$ast$js$statements$JSBreakStatement_ts = {
		get jsBreakStatement() {
			return ___R$project$rome$$internal$ast$js$statements$JSBreakStatement_ts$jsBreakStatement;
		},
	};
	const ___R$project$rome$$internal$ast$js$statements$JSBreakStatement_ts$jsBreakStatement = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSBreakStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				label: true,
			},
		},
	);


  // project-rome/@internal/ast/js/expressions/JSCallExpression.ts
const ___R$project$rome$$internal$ast$js$expressions$JSCallExpression_ts = {
		get jsCallExpression() {
			return ___R$project$rome$$internal$ast$js$expressions$JSCallExpression_ts$jsCallExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$expressions$JSCallExpression_ts$jsCallExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSCallExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				callee: true,
				arguments: true,
				typeArguments: true,
			},
		},
	);


  // project-rome/@internal/ast/js/auxiliary/JSCatchClause.ts
const ___R$project$rome$$internal$ast$js$auxiliary$JSCatchClause_ts = {
		get jsCatchClause() {
			return ___R$project$rome$$internal$ast$js$auxiliary$JSCatchClause_ts$jsCatchClause;
		},
	};
	const ___R$project$rome$$internal$ast$js$auxiliary$JSCatchClause_ts$jsCatchClause = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSCatchClause",
		{
			bindingKeys: {
				param: true,
			},
			visitorKeys: {
				param: true,
				body: true,
			},
		},
	);


  // project-rome/@internal/ast/js/classes/JSClassDeclaration.ts
const ___R$project$rome$$internal$ast$js$classes$JSClassDeclaration_ts = {
		get jsClassDeclaration() {
			return ___R$project$rome$$internal$ast$js$classes$JSClassDeclaration_ts$jsClassDeclaration;
		},
	};
	const ___R$project$rome$$internal$ast$js$classes$JSClassDeclaration_ts$jsClassDeclaration = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSClassDeclaration",
		{
			bindingKeys: {
				id: true,
			},
			visitorKeys: {
				id: true,
				meta: true,
			},
		},
	);


  // project-rome/@internal/ast/js/classes/JSClassExpression.ts
const ___R$project$rome$$internal$ast$js$classes$JSClassExpression_ts = {
		get jsClassExpression() {
			return ___R$project$rome$$internal$ast$js$classes$JSClassExpression_ts$jsClassExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$classes$JSClassExpression_ts$jsClassExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSClassExpression",
		{
			bindingKeys: {
				id: true,
			},
			visitorKeys: {
				id: true,
				meta: true,
			},
		},
	);


  // project-rome/@internal/ast/js/classes/JSClassHead.ts
const ___R$project$rome$$internal$ast$js$classes$JSClassHead_ts = {
		get jsClassHead() {
			return ___R$project$rome$$internal$ast$js$classes$JSClassHead_ts$jsClassHead;
		},
	};
	const ___R$project$rome$$internal$ast$js$classes$JSClassHead_ts$jsClassHead = ___R$project$rome$$internal$ast$utils_ts$createQuickBuilder(
		"JSClassHead",
		"body",
		{
			bindingKeys: {},
			visitorKeys: {
				superClass: true,
				body: true,
				typeParameters: true,
				superTypeParameters: true,
				implements: true,
			},
		},
	);


  // project-rome/@internal/ast/js/classes/JSClassMethod.ts
const ___R$project$rome$$internal$ast$js$classes$JSClassMethod_ts = {
		get jsClassMethod() {
			return ___R$project$rome$$internal$ast$js$classes$JSClassMethod_ts$jsClassMethod;
		},
	};
	const ___R$project$rome$$internal$ast$js$classes$JSClassMethod_ts$jsClassMethod = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSClassMethod",
		{
			bindingKeys: {},
			visitorKeys: {
				key: true,
				meta: true,
				head: true,
				body: true,
			},
		},
	);


  // project-rome/@internal/ast/js/classes/JSClassPrivateMethod.ts
const ___R$project$rome$$internal$ast$js$classes$JSClassPrivateMethod_ts = {
		get jsClassPrivateMethod() {
			return ___R$project$rome$$internal$ast$js$classes$JSClassPrivateMethod_ts$jsClassPrivateMethod;
		},
	};
	const ___R$project$rome$$internal$ast$js$classes$JSClassPrivateMethod_ts$jsClassPrivateMethod = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSClassPrivateMethod",
		{
			bindingKeys: {},
			visitorKeys: {
				key: true,
				meta: true,
				head: true,
				body: true,
			},
		},
	);


  // project-rome/@internal/ast/js/classes/JSClassPrivateProperty.ts
const ___R$project$rome$$internal$ast$js$classes$JSClassPrivateProperty_ts = {
		get jsClassPrivateProperty() {
			return ___R$project$rome$$internal$ast$js$classes$JSClassPrivateProperty_ts$jsClassPrivateProperty;
		},
	};
	const ___R$project$rome$$internal$ast$js$classes$JSClassPrivateProperty_ts$jsClassPrivateProperty = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSClassPrivateProperty",
		{
			bindingKeys: {},
			visitorKeys: {
				key: true,
				meta: true,
				value: true,
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@internal/ast/js/classes/JSClassProperty.ts
const ___R$project$rome$$internal$ast$js$classes$JSClassProperty_ts = {
		get jsClassProperty() {
			return ___R$project$rome$$internal$ast$js$classes$JSClassProperty_ts$jsClassProperty;
		},
	};
	const ___R$project$rome$$internal$ast$js$classes$JSClassProperty_ts$jsClassProperty = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSClassProperty",
		{
			bindingKeys: {},
			visitorKeys: {
				key: true,
				meta: true,
				value: true,
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@internal/ast/js/classes/JSClassPropertyMeta.ts
const ___R$project$rome$$internal$ast$js$classes$JSClassPropertyMeta_ts = {
		get jsClassPropertyMeta() {
			return ___R$project$rome$$internal$ast$js$classes$JSClassPropertyMeta_ts$jsClassPropertyMeta;
		},
	};
	const ___R$project$rome$$internal$ast$js$classes$JSClassPropertyMeta_ts$jsClassPropertyMeta = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSClassPropertyMeta",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/auxiliary/JSComputedMemberProperty.ts
const ___R$project$rome$$internal$ast$js$auxiliary$JSComputedMemberProperty_ts = {
		get jsComputedMemberProperty() {
			return ___R$project$rome$$internal$ast$js$auxiliary$JSComputedMemberProperty_ts$jsComputedMemberProperty;
		},
	};
	const ___R$project$rome$$internal$ast$js$auxiliary$JSComputedMemberProperty_ts$jsComputedMemberProperty = ___R$project$rome$$internal$ast$utils_ts$createQuickBuilder(
		"JSComputedMemberProperty",
		"value",
		{
			bindingKeys: {},
			visitorKeys: {
				value: true,
			},
		},
	);


  // project-rome/@internal/ast/js/objects/JSComputedPropertyKey.ts
const ___R$project$rome$$internal$ast$js$objects$JSComputedPropertyKey_ts = {
		get jsComputedPropertyKey() {
			return ___R$project$rome$$internal$ast$js$objects$JSComputedPropertyKey_ts$jsComputedPropertyKey;
		},
	};
	const ___R$project$rome$$internal$ast$js$objects$JSComputedPropertyKey_ts$jsComputedPropertyKey = ___R$project$rome$$internal$ast$utils_ts$createQuickBuilder(
		"JSComputedPropertyKey",
		"value",
		{
			bindingKeys: {},
			visitorKeys: {
				value: true,
			},
		},
	);


  // project-rome/@internal/ast/js/expressions/JSConditionalExpression.ts
const ___R$project$rome$$internal$ast$js$expressions$JSConditionalExpression_ts = {
		get jsConditionalExpression() {
			return ___R$project$rome$$internal$ast$js$expressions$JSConditionalExpression_ts$jsConditionalExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$expressions$JSConditionalExpression_ts$jsConditionalExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSConditionalExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				test: true,
				consequent: true,
				alternate: true,
			},
		},
	);


  // project-rome/@internal/ast/js/statements/JSContinueStatement.ts
const ___R$project$rome$$internal$ast$js$statements$JSContinueStatement_ts = {
		get jsContinueStatement() {
			return ___R$project$rome$$internal$ast$js$statements$JSContinueStatement_ts$jsContinueStatement;
		},
	};
	const ___R$project$rome$$internal$ast$js$statements$JSContinueStatement_ts$jsContinueStatement = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSContinueStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				label: true,
			},
		},
	);


  // project-rome/@internal/ast/js/statements/JSDebuggerStatement.ts
const ___R$project$rome$$internal$ast$js$statements$JSDebuggerStatement_ts = {
		get jsDebuggerStatement() {
			return ___R$project$rome$$internal$ast$js$statements$JSDebuggerStatement_ts$jsDebuggerStatement;
		},
	};
	const ___R$project$rome$$internal$ast$js$statements$JSDebuggerStatement_ts$jsDebuggerStatement = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSDebuggerStatement",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/core/JSDirective.ts
const ___R$project$rome$$internal$ast$js$core$JSDirective_ts = {
		get jsDirective() {
			return ___R$project$rome$$internal$ast$js$core$JSDirective_ts$jsDirective;
		},
	};
	const ___R$project$rome$$internal$ast$js$core$JSDirective_ts$jsDirective = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSDirective",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/expressions/JSDoExpression.ts
const ___R$project$rome$$internal$ast$js$expressions$JSDoExpression_ts = {
		get jsDoExpression() {
			return ___R$project$rome$$internal$ast$js$expressions$JSDoExpression_ts$jsDoExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$expressions$JSDoExpression_ts$jsDoExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSDoExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				body: true,
			},
		},
	);


  // project-rome/@internal/ast/js/statements/JSDoWhileStatement.ts
const ___R$project$rome$$internal$ast$js$statements$JSDoWhileStatement_ts = {
		get jsDoWhileStatement() {
			return ___R$project$rome$$internal$ast$js$statements$JSDoWhileStatement_ts$jsDoWhileStatement;
		},
	};
	const ___R$project$rome$$internal$ast$js$statements$JSDoWhileStatement_ts$jsDoWhileStatement = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSDoWhileStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				test: true,
				body: true,
			},
		},
	);


  // project-rome/@internal/ast/js/statements/JSEmptyStatement.ts
const ___R$project$rome$$internal$ast$js$statements$JSEmptyStatement_ts = {
		get jsEmptyStatement() {
			return ___R$project$rome$$internal$ast$js$statements$JSEmptyStatement_ts$jsEmptyStatement;
		},
	};
	const ___R$project$rome$$internal$ast$js$statements$JSEmptyStatement_ts$jsEmptyStatement = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSEmptyStatement",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/modules/JSExportAllDeclaration.ts
const ___R$project$rome$$internal$ast$js$modules$JSExportAllDeclaration_ts = {
		get jsExportAllDeclaration() {
			return ___R$project$rome$$internal$ast$js$modules$JSExportAllDeclaration_ts$jsExportAllDeclaration;
		},
	};
	const ___R$project$rome$$internal$ast$js$modules$JSExportAllDeclaration_ts$jsExportAllDeclaration = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSExportAllDeclaration",
		{
			bindingKeys: {},
			visitorKeys: {
				source: true,
			},
		},
	);


  // project-rome/@internal/ast/js/modules/JSExportDefaultDeclaration.ts
const ___R$project$rome$$internal$ast$js$modules$JSExportDefaultDeclaration_ts = {
		get jsExportDefaultDeclaration() {
			return ___R$project$rome$$internal$ast$js$modules$JSExportDefaultDeclaration_ts$jsExportDefaultDeclaration;
		},
	};
	const ___R$project$rome$$internal$ast$js$modules$JSExportDefaultDeclaration_ts$jsExportDefaultDeclaration = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSExportDefaultDeclaration",
		{
			bindingKeys: {},
			visitorKeys: {
				declaration: true,
			},
		},
	);


  // project-rome/@internal/ast/js/modules/JSExportDefaultSpecifier.ts
const ___R$project$rome$$internal$ast$js$modules$JSExportDefaultSpecifier_ts = {
		get jsExportDefaultSpecifier() {
			return ___R$project$rome$$internal$ast$js$modules$JSExportDefaultSpecifier_ts$jsExportDefaultSpecifier;
		},
	};
	const ___R$project$rome$$internal$ast$js$modules$JSExportDefaultSpecifier_ts$jsExportDefaultSpecifier = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSExportDefaultSpecifier",
		{
			bindingKeys: {},
			visitorKeys: {
				exported: true,
			},
		},
	);


  // project-rome/@internal/ast/js/modules/JSExportExternalDeclaration.ts
const ___R$project$rome$$internal$ast$js$modules$JSExportExternalDeclaration_ts = {
		get jsExportExternalDeclaration() {
			return ___R$project$rome$$internal$ast$js$modules$JSExportExternalDeclaration_ts$jsExportExternalDeclaration;
		},
	};
	const ___R$project$rome$$internal$ast$js$modules$JSExportExternalDeclaration_ts$jsExportExternalDeclaration = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSExportExternalDeclaration",
		{
			bindingKeys: {},
			visitorKeys: {
				defaultSpecifier: true,
				namespaceSpecifier: true,
				namedSpecifiers: true,
				source: true,
			},
		},
	);


  // project-rome/@internal/ast/js/modules/JSExportExternalSpecifier.ts
const ___R$project$rome$$internal$ast$js$modules$JSExportExternalSpecifier_ts = {
		get jsExportExternalSpecifier() {
			return ___R$project$rome$$internal$ast$js$modules$JSExportExternalSpecifier_ts$jsExportExternalSpecifier;
		},
	};
	const ___R$project$rome$$internal$ast$js$modules$JSExportExternalSpecifier_ts$jsExportExternalSpecifier = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSExportExternalSpecifier",
		{
			bindingKeys: {},
			visitorKeys: {
				exported: true,
				local: true,
			},
		},
	);


  // project-rome/@internal/ast/js/modules/JSExportLocalDeclaration.ts
const ___R$project$rome$$internal$ast$js$modules$JSExportLocalDeclaration_ts = {
		get jsExportLocalDeclaration() {
			return ___R$project$rome$$internal$ast$js$modules$JSExportLocalDeclaration_ts$jsExportLocalDeclaration;
		},
	};
	const ___R$project$rome$$internal$ast$js$modules$JSExportLocalDeclaration_ts$jsExportLocalDeclaration = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSExportLocalDeclaration",
		{
			bindingKeys: {
				declaration: true,
			},
			visitorKeys: {
				declaration: true,
				specifiers: true,
			},
		},
	);


  // project-rome/@internal/ast/js/modules/JSExportLocalSpecifier.ts
const ___R$project$rome$$internal$ast$js$modules$JSExportLocalSpecifier_ts = {
		get jsExportLocalSpecifier() {
			return ___R$project$rome$$internal$ast$js$modules$JSExportLocalSpecifier_ts$jsExportLocalSpecifier;
		},
	};
	const ___R$project$rome$$internal$ast$js$modules$JSExportLocalSpecifier_ts$jsExportLocalSpecifier = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSExportLocalSpecifier",
		{
			bindingKeys: {},
			visitorKeys: {
				local: true,
				exported: true,
			},
		},
	);


  // project-rome/@internal/ast/js/modules/JSExportNamespaceSpecifier.ts
const ___R$project$rome$$internal$ast$js$modules$JSExportNamespaceSpecifier_ts = {
		get jsExportNamespaceSpecifier() {
			return ___R$project$rome$$internal$ast$js$modules$JSExportNamespaceSpecifier_ts$jsExportNamespaceSpecifier;
		},
	};
	const ___R$project$rome$$internal$ast$js$modules$JSExportNamespaceSpecifier_ts$jsExportNamespaceSpecifier = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSExportNamespaceSpecifier",
		{
			bindingKeys: {},
			visitorKeys: {
				exported: true,
			},
		},
	);


  // project-rome/@internal/ast/js/statements/JSExpressionStatement.ts
const ___R$project$rome$$internal$ast$js$statements$JSExpressionStatement_ts = {
		get jsExpressionStatement() {
			return ___R$project$rome$$internal$ast$js$statements$JSExpressionStatement_ts$jsExpressionStatement;
		},
	};
	const ___R$project$rome$$internal$ast$js$statements$JSExpressionStatement_ts$jsExpressionStatement = ___R$project$rome$$internal$ast$utils_ts$createQuickBuilder(
		"JSExpressionStatement",
		"expression",
		{
			bindingKeys: {},
			visitorKeys: {
				expression: true,
			},
		},
	);


  // project-rome/@internal/ast/js/statements/JSForInStatement.ts
const ___R$project$rome$$internal$ast$js$statements$JSForInStatement_ts = {
		get jsForInStatement() {
			return ___R$project$rome$$internal$ast$js$statements$JSForInStatement_ts$jsForInStatement;
		},
	};
	const ___R$project$rome$$internal$ast$js$statements$JSForInStatement_ts$jsForInStatement = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSForInStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				left: true,
				right: true,
				body: true,
			},
		},
	);


  // project-rome/@internal/ast/js/statements/JSForOfStatement.ts
const ___R$project$rome$$internal$ast$js$statements$JSForOfStatement_ts = {
		get jsForOfStatement() {
			return ___R$project$rome$$internal$ast$js$statements$JSForOfStatement_ts$jsForOfStatement;
		},
	};
	const ___R$project$rome$$internal$ast$js$statements$JSForOfStatement_ts$jsForOfStatement = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSForOfStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				left: true,
				right: true,
				body: true,
			},
		},
	);


  // project-rome/@internal/ast/js/statements/JSForStatement.ts
const ___R$project$rome$$internal$ast$js$statements$JSForStatement_ts = {
		get jsForStatement() {
			return ___R$project$rome$$internal$ast$js$statements$JSForStatement_ts$jsForStatement;
		},
	};
	const ___R$project$rome$$internal$ast$js$statements$JSForStatement_ts$jsForStatement = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSForStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				init: true,
				test: true,
				update: true,
				body: true,
			},
		},
	);


  // project-rome/@internal/ast/js/statements/JSFunctionDeclaration.ts
const ___R$project$rome$$internal$ast$js$statements$JSFunctionDeclaration_ts = {
		get jsFunctionDeclaration() {
			return ___R$project$rome$$internal$ast$js$statements$JSFunctionDeclaration_ts$jsFunctionDeclaration;
		},
	};
	const ___R$project$rome$$internal$ast$js$statements$JSFunctionDeclaration_ts$jsFunctionDeclaration = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSFunctionDeclaration",
		{
			bindingKeys: {
				id: true,
			},
			visitorKeys: {
				head: true,
				id: true,
				body: true,
			},
		},
	);


  // project-rome/@internal/ast/js/expressions/JSFunctionExpression.ts
const ___R$project$rome$$internal$ast$js$expressions$JSFunctionExpression_ts = {
		get jsFunctionExpression() {
			return ___R$project$rome$$internal$ast$js$expressions$JSFunctionExpression_ts$jsFunctionExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$expressions$JSFunctionExpression_ts$jsFunctionExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSFunctionExpression",
		{
			bindingKeys: {
				id: true,
			},
			visitorKeys: {
				head: true,
				id: true,
				body: true,
			},
		},
	);


  // project-rome/@internal/ast/js/auxiliary/JSFunctionHead.ts
const ___R$project$rome$$internal$ast$js$auxiliary$JSFunctionHead_ts = {
		get jsFunctionHead() {
			return ___R$project$rome$$internal$ast$js$auxiliary$JSFunctionHead_ts$jsFunctionHead;
		},
	};
	const ___R$project$rome$$internal$ast$js$auxiliary$JSFunctionHead_ts$jsFunctionHead = ___R$project$rome$$internal$ast$utils_ts$createQuickBuilder(
		"JSFunctionHead",
		"params",
		{
			bindingKeys: {
				params: true,
				rest: true,
			},
			visitorKeys: {
				params: true,
				thisType: true,
				rest: true,
				returnType: true,
				typeParameters: true,
			},
		},
	);


  // project-rome/@internal/ast/js/auxiliary/JSIdentifier.ts
const ___R$project$rome$$internal$ast$js$auxiliary$JSIdentifier_ts = {
		get jsIdentifier() {
			return ___R$project$rome$$internal$ast$js$auxiliary$JSIdentifier_ts$jsIdentifier;
		},
	};
	const ___R$project$rome$$internal$ast$js$auxiliary$JSIdentifier_ts$jsIdentifier = ___R$project$rome$$internal$ast$utils_ts$createQuickBuilder(
		"JSIdentifier",
		"name",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/statements/JSIfStatement.ts
const ___R$project$rome$$internal$ast$js$statements$JSIfStatement_ts = {
		get jsIfStatement() {
			return ___R$project$rome$$internal$ast$js$statements$JSIfStatement_ts$jsIfStatement;
		},
	};
	const ___R$project$rome$$internal$ast$js$statements$JSIfStatement_ts$jsIfStatement = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSIfStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				test: true,
				consequent: true,
				alternate: true,
			},
		},
	);


  // project-rome/@internal/ast/js/modules/JSImportCall.ts
const ___R$project$rome$$internal$ast$js$modules$JSImportCall_ts = {
		get jsImportCall() {
			return ___R$project$rome$$internal$ast$js$modules$JSImportCall_ts$jsImportCall;
		},
	};
	const ___R$project$rome$$internal$ast$js$modules$JSImportCall_ts$jsImportCall = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSImportCall",
		{
			bindingKeys: {},
			visitorKeys: {
				argument: true,
			},
		},
	);


  // project-rome/@internal/ast/js/modules/JSImportDeclaration.ts
const ___R$project$rome$$internal$ast$js$modules$JSImportDeclaration_ts = {
		get jsImportDeclaration() {
			return ___R$project$rome$$internal$ast$js$modules$JSImportDeclaration_ts$jsImportDeclaration;
		},
	};
	const ___R$project$rome$$internal$ast$js$modules$JSImportDeclaration_ts$jsImportDeclaration = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSImportDeclaration",
		{
			bindingKeys: {
				defaultSpecifier: true,
				namespaceSpecifier: true,
				namedSpecifiers: true,
			},
			visitorKeys: {
				defaultSpecifier: true,
				namespaceSpecifier: true,
				namedSpecifiers: true,
				source: true,
			},
		},
	);


  // project-rome/@internal/ast/js/modules/JSImportDefaultSpecifier.ts
const ___R$project$rome$$internal$ast$js$modules$JSImportDefaultSpecifier_ts = {
		get jsImportDefaultSpecifier() {
			return ___R$project$rome$$internal$ast$js$modules$JSImportDefaultSpecifier_ts$jsImportDefaultSpecifier;
		},
	};
	const ___R$project$rome$$internal$ast$js$modules$JSImportDefaultSpecifier_ts$jsImportDefaultSpecifier = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSImportDefaultSpecifier",
		{
			bindingKeys: {
				local: true,
			},
			visitorKeys: {
				local: true,
			},
		},
	);


  // project-rome/@internal/ast/js/modules/JSImportNamespaceSpecifier.ts
const ___R$project$rome$$internal$ast$js$modules$JSImportNamespaceSpecifier_ts = {
		get jsImportNamespaceSpecifier() {
			return ___R$project$rome$$internal$ast$js$modules$JSImportNamespaceSpecifier_ts$jsImportNamespaceSpecifier;
		},
	};
	const ___R$project$rome$$internal$ast$js$modules$JSImportNamespaceSpecifier_ts$jsImportNamespaceSpecifier = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSImportNamespaceSpecifier",
		{
			bindingKeys: {
				local: true,
			},
			visitorKeys: {
				local: true,
			},
		},
	);


  // project-rome/@internal/ast/js/modules/JSImportSpecifier.ts
const ___R$project$rome$$internal$ast$js$modules$JSImportSpecifier_ts = {
		get jsImportSpecifier() {
			return ___R$project$rome$$internal$ast$js$modules$JSImportSpecifier_ts$jsImportSpecifier;
		},
	};
	const ___R$project$rome$$internal$ast$js$modules$JSImportSpecifier_ts$jsImportSpecifier = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSImportSpecifier",
		{
			bindingKeys: {
				local: true,
			},
			visitorKeys: {
				imported: true,
				local: true,
			},
		},
	);


  // project-rome/@internal/ast/js/modules/JSImportSpecifierLocal.ts
const ___R$project$rome$$internal$ast$js$modules$JSImportSpecifierLocal_ts = {
		get jsImportSpecifierLocal() {
			return ___R$project$rome$$internal$ast$js$modules$JSImportSpecifierLocal_ts$jsImportSpecifierLocal;
		},
	};
	const ___R$project$rome$$internal$ast$js$modules$JSImportSpecifierLocal_ts$jsImportSpecifierLocal = ___R$project$rome$$internal$ast$utils_ts$createQuickBuilder(
		"JSImportSpecifierLocal",
		"name",
		{
			bindingKeys: {
				name: true,
			},
			visitorKeys: {
				name: true,
			},
		},
	);


  // project-rome/@internal/ast/js/core/JSInterpreterDirective.ts
const ___R$project$rome$$internal$ast$js$core$JSInterpreterDirective_ts = {
		get jsInterpreterDirective() {
			return ___R$project$rome$$internal$ast$js$core$JSInterpreterDirective_ts$jsInterpreterDirective;
		},
	};
	const ___R$project$rome$$internal$ast$js$core$JSInterpreterDirective_ts$jsInterpreterDirective = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSInterpreterDirective",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/statements/JSLabeledStatement.ts
const ___R$project$rome$$internal$ast$js$statements$JSLabeledStatement_ts = {
		get jsLabeledStatement() {
			return ___R$project$rome$$internal$ast$js$statements$JSLabeledStatement_ts$jsLabeledStatement;
		},
	};
	const ___R$project$rome$$internal$ast$js$statements$JSLabeledStatement_ts$jsLabeledStatement = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSLabeledStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				label: true,
				body: true,
			},
		},
	);


  // project-rome/@internal/ast/js/expressions/JSLogicalExpression.ts
const ___R$project$rome$$internal$ast$js$expressions$JSLogicalExpression_ts = {
		get jsLogicalExpression() {
			return ___R$project$rome$$internal$ast$js$expressions$JSLogicalExpression_ts$jsLogicalExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$expressions$JSLogicalExpression_ts$jsLogicalExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSLogicalExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				left: true,
				right: true,
			},
		},
	);


  // project-rome/@internal/ast/js/expressions/JSMemberExpression.ts
const ___R$project$rome$$internal$ast$js$expressions$JSMemberExpression_ts = {
		get jsMemberExpression() {
			return ___R$project$rome$$internal$ast$js$expressions$JSMemberExpression_ts$jsMemberExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$expressions$JSMemberExpression_ts$jsMemberExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSMemberExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				object: true,
				property: true,
			},
		},
	);


  // project-rome/@internal/ast/js/expressions/JSMetaProperty.ts
const ___R$project$rome$$internal$ast$js$expressions$JSMetaProperty_ts = {
		get jsMetaProperty() {
			return ___R$project$rome$$internal$ast$js$expressions$JSMetaProperty_ts$jsMetaProperty;
		},
	};
	const ___R$project$rome$$internal$ast$js$expressions$JSMetaProperty_ts$jsMetaProperty = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSMetaProperty",
		{
			bindingKeys: {},
			visitorKeys: {
				meta: true,
				property: true,
			},
		},
	);


  // project-rome/@internal/ast/js/expressions/JSNewExpression.ts
const ___R$project$rome$$internal$ast$js$expressions$JSNewExpression_ts = {
		get jsNewExpression() {
			return ___R$project$rome$$internal$ast$js$expressions$JSNewExpression_ts$jsNewExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$expressions$JSNewExpression_ts$jsNewExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSNewExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				callee: true,
				arguments: true,
				typeArguments: true,
			},
		},
	);


  // project-rome/@internal/ast/js/literals/JSNullLiteral.ts
const ___R$project$rome$$internal$ast$js$literals$JSNullLiteral_ts = {
		get jsNullLiteral() {
			return ___R$project$rome$$internal$ast$js$literals$JSNullLiteral_ts$jsNullLiteral;
		},
	};
	const ___R$project$rome$$internal$ast$js$literals$JSNullLiteral_ts$jsNullLiteral = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSNullLiteral",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/literals/JSNumericLiteral.ts
const ___R$project$rome$$internal$ast$js$literals$JSNumericLiteral_ts = {
		get jsNumericLiteral() {
			return ___R$project$rome$$internal$ast$js$literals$JSNumericLiteral_ts$jsNumericLiteral;
		},
	};
	const ___R$project$rome$$internal$ast$js$literals$JSNumericLiteral_ts$jsNumericLiteral = ___R$project$rome$$internal$ast$utils_ts$createQuickBuilder(
		"JSNumericLiteral",
		"value",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/objects/JSObjectExpression.ts
const ___R$project$rome$$internal$ast$js$objects$JSObjectExpression_ts = {
		get jsObjectExpression() {
			return ___R$project$rome$$internal$ast$js$objects$JSObjectExpression_ts$jsObjectExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$objects$JSObjectExpression_ts$jsObjectExpression = ___R$project$rome$$internal$ast$utils_ts$createQuickBuilder(
		"JSObjectExpression",
		"properties",
		{
			bindingKeys: {},
			visitorKeys: {
				properties: true,
			},
		},
	);


  // project-rome/@internal/ast/js/objects/JSObjectMethod.ts
const ___R$project$rome$$internal$ast$js$objects$JSObjectMethod_ts = {
		get jsObjectMethod() {
			return ___R$project$rome$$internal$ast$js$objects$JSObjectMethod_ts$jsObjectMethod;
		},
	};
	const ___R$project$rome$$internal$ast$js$objects$JSObjectMethod_ts$jsObjectMethod = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSObjectMethod",
		{
			bindingKeys: {},
			visitorKeys: {
				key: true,
				head: true,
				body: true,
			},
		},
	);


  // project-rome/@internal/ast/js/objects/JSObjectProperty.ts
const ___R$project$rome$$internal$ast$js$objects$JSObjectProperty_ts = {
		get jsObjectProperty() {
			return ___R$project$rome$$internal$ast$js$objects$JSObjectProperty_ts$jsObjectProperty;
		},
	};
	const ___R$project$rome$$internal$ast$js$objects$JSObjectProperty_ts$jsObjectProperty = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSObjectProperty",
		{
			bindingKeys: {},
			visitorKeys: {
				key: true,
				value: true,
			},
		},
	);


  // project-rome/@internal/ast/js/expressions/JSOptionalCallExpression.ts
const ___R$project$rome$$internal$ast$js$expressions$JSOptionalCallExpression_ts = {
		get jsOptionalCallExpression() {
			return ___R$project$rome$$internal$ast$js$expressions$JSOptionalCallExpression_ts$jsOptionalCallExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$expressions$JSOptionalCallExpression_ts$jsOptionalCallExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSOptionalCallExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				callee: true,
				arguments: true,
				typeArguments: true,
			},
		},
	);


  // project-rome/@internal/ast/js/patterns/JSPatternMeta.ts
const ___R$project$rome$$internal$ast$js$patterns$JSPatternMeta_ts = {
		get jsPatternMeta() {
			return ___R$project$rome$$internal$ast$js$patterns$JSPatternMeta_ts$jsPatternMeta;
		},
	};
	const ___R$project$rome$$internal$ast$js$patterns$JSPatternMeta_ts$jsPatternMeta = ___R$project$rome$$internal$ast$utils_ts$createQuickBuilder(
		"JSPatternMeta",
		"typeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@internal/ast/js/classes/JSPrivateName.ts
const ___R$project$rome$$internal$ast$js$classes$JSPrivateName_ts = {
		get jsPrivateName() {
			return ___R$project$rome$$internal$ast$js$classes$JSPrivateName_ts$jsPrivateName;
		},
	};
	const ___R$project$rome$$internal$ast$js$classes$JSPrivateName_ts$jsPrivateName = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSPrivateName",
		{
			bindingKeys: {},
			visitorKeys: {
				id: true,
			},
		},
	);


  // project-rome/@internal/ast/js/expressions/JSReferenceIdentifier.ts
const ___R$project$rome$$internal$ast$js$expressions$JSReferenceIdentifier_ts = {
		get jsReferenceIdentifier() {
			return ___R$project$rome$$internal$ast$js$expressions$JSReferenceIdentifier_ts$jsReferenceIdentifier;
		},
	};
	const ___R$project$rome$$internal$ast$js$expressions$JSReferenceIdentifier_ts$jsReferenceIdentifier = ___R$project$rome$$internal$ast$utils_ts$createQuickBuilder(
		"JSReferenceIdentifier",
		"name",
		{
			bindingKeys: {},
			visitorKeys: {
				meta: true,
			},
		},
	);


  // project-rome/@internal/ast/js/regex/JSRegExpAlternation.ts
const ___R$project$rome$$internal$ast$js$regex$JSRegExpAlternation_ts = {
		get jsRegExpAlternation() {
			return ___R$project$rome$$internal$ast$js$regex$JSRegExpAlternation_ts$jsRegExpAlternation;
		},
	};
	const ___R$project$rome$$internal$ast$js$regex$JSRegExpAlternation_ts$jsRegExpAlternation = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSRegExpAlternation",
		{
			bindingKeys: {},
			visitorKeys: {
				left: true,
				right: true,
			},
		},
	);


  // project-rome/@internal/ast/js/regex/JSRegExpAnyCharacter.ts
const ___R$project$rome$$internal$ast$js$regex$JSRegExpAnyCharacter_ts = {
		get jsRegExpAnyCharacter() {
			return ___R$project$rome$$internal$ast$js$regex$JSRegExpAnyCharacter_ts$jsRegExpAnyCharacter;
		},
	};
	const ___R$project$rome$$internal$ast$js$regex$JSRegExpAnyCharacter_ts$jsRegExpAnyCharacter = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSRegExpAnyCharacter",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/regex/JSRegExpCharacter.ts
const ___R$project$rome$$internal$ast$js$regex$JSRegExpCharacter_ts = {
		get jsRegExpCharacter() {
			return ___R$project$rome$$internal$ast$js$regex$JSRegExpCharacter_ts$jsRegExpCharacter;
		},
	};
	const ___R$project$rome$$internal$ast$js$regex$JSRegExpCharacter_ts$jsRegExpCharacter = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSRegExpCharacter",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/regex/JSRegExpCharSet.ts
const ___R$project$rome$$internal$ast$js$regex$JSRegExpCharSet_ts = {
		get jsRegExpCharSet() {
			return ___R$project$rome$$internal$ast$js$regex$JSRegExpCharSet_ts$jsRegExpCharSet;
		},
	};
	const ___R$project$rome$$internal$ast$js$regex$JSRegExpCharSet_ts$jsRegExpCharSet = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSRegExpCharSet",
		{
			bindingKeys: {},
			visitorKeys: {
				body: true,
			},
		},
	);


  // project-rome/@internal/ast/js/regex/JSRegExpCharSetRange.ts
const ___R$project$rome$$internal$ast$js$regex$JSRegExpCharSetRange_ts = {
		get jsRegExpCharSetRange() {
			return ___R$project$rome$$internal$ast$js$regex$JSRegExpCharSetRange_ts$jsRegExpCharSetRange;
		},
	};
	const ___R$project$rome$$internal$ast$js$regex$JSRegExpCharSetRange_ts$jsRegExpCharSetRange = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSRegExpCharSetRange",
		{
			bindingKeys: {},
			visitorKeys: {
				start: true,
				end: true,
			},
		},
	);


  // project-rome/@internal/ast/js/regex/JSRegExpControlCharacter.ts
const ___R$project$rome$$internal$ast$js$regex$JSRegExpControlCharacter_ts = {
		get jsRegExpControlCharacter() {
			return ___R$project$rome$$internal$ast$js$regex$JSRegExpControlCharacter_ts$jsRegExpControlCharacter;
		},
	};
	const ___R$project$rome$$internal$ast$js$regex$JSRegExpControlCharacter_ts$jsRegExpControlCharacter = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSRegExpControlCharacter",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/regex/JSRegExpDigitCharacter.ts
const ___R$project$rome$$internal$ast$js$regex$JSRegExpDigitCharacter_ts = {
		get jsRegExpDigitCharacter() {
			return ___R$project$rome$$internal$ast$js$regex$JSRegExpDigitCharacter_ts$jsRegExpDigitCharacter;
		},
	};
	const ___R$project$rome$$internal$ast$js$regex$JSRegExpDigitCharacter_ts$jsRegExpDigitCharacter = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSRegExpDigitCharacter",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/regex/JSRegExpEndCharacter.ts
const ___R$project$rome$$internal$ast$js$regex$JSRegExpEndCharacter_ts = {
		get jsRegExpEndCharacter() {
			return ___R$project$rome$$internal$ast$js$regex$JSRegExpEndCharacter_ts$jsRegExpEndCharacter;
		},
	};
	const ___R$project$rome$$internal$ast$js$regex$JSRegExpEndCharacter_ts$jsRegExpEndCharacter = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSRegExpEndCharacter",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/regex/JSRegExpGroupCapture.ts
const ___R$project$rome$$internal$ast$js$regex$JSRegExpGroupCapture_ts = {
		get jsRegExpGroupCapture() {
			return ___R$project$rome$$internal$ast$js$regex$JSRegExpGroupCapture_ts$jsRegExpGroupCapture;
		},
	};
	const ___R$project$rome$$internal$ast$js$regex$JSRegExpGroupCapture_ts$jsRegExpGroupCapture = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSRegExpGroupCapture",
		{
			bindingKeys: {},
			visitorKeys: {
				expression: true,
			},
		},
	);


  // project-rome/@internal/ast/js/regex/JSRegExpGroupNonCapture.ts
const ___R$project$rome$$internal$ast$js$regex$JSRegExpGroupNonCapture_ts = {
		get jsRegExpGroupNonCapture() {
			return ___R$project$rome$$internal$ast$js$regex$JSRegExpGroupNonCapture_ts$jsRegExpGroupNonCapture;
		},
	};
	const ___R$project$rome$$internal$ast$js$regex$JSRegExpGroupNonCapture_ts$jsRegExpGroupNonCapture = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSRegExpGroupNonCapture",
		{
			bindingKeys: {},
			visitorKeys: {
				expression: true,
			},
		},
	);


  // project-rome/@internal/ast/js/literals/JSRegExpLiteral.ts
const ___R$project$rome$$internal$ast$js$literals$JSRegExpLiteral_ts = {
		get jsRegExpLiteral() {
			return ___R$project$rome$$internal$ast$js$literals$JSRegExpLiteral_ts$jsRegExpLiteral;
		},
	};
	const ___R$project$rome$$internal$ast$js$literals$JSRegExpLiteral_ts$jsRegExpLiteral = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSRegExpLiteral",
		{
			bindingKeys: {},
			visitorKeys: {
				expression: true,
			},
		},
	);


  // project-rome/@internal/ast/js/regex/JSRegExpNamedBackReference.ts
const ___R$project$rome$$internal$ast$js$regex$JSRegExpNamedBackReference_ts = {
		get jsRegExpNamedBackReference() {
			return ___R$project$rome$$internal$ast$js$regex$JSRegExpNamedBackReference_ts$jsRegExpNamedBackReference;
		},
	};
	const ___R$project$rome$$internal$ast$js$regex$JSRegExpNamedBackReference_ts$jsRegExpNamedBackReference = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSRegExpNamedBackReference",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/regex/JSRegExpNonDigitCharacter.ts
const ___R$project$rome$$internal$ast$js$regex$JSRegExpNonDigitCharacter_ts = {
		get jsRegExpNonDigitCharacter() {
			return ___R$project$rome$$internal$ast$js$regex$JSRegExpNonDigitCharacter_ts$jsRegExpNonDigitCharacter;
		},
	};
	const ___R$project$rome$$internal$ast$js$regex$JSRegExpNonDigitCharacter_ts$jsRegExpNonDigitCharacter = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSRegExpNonDigitCharacter",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/regex/JSRegExpNonWhiteSpaceCharacter.ts
const ___R$project$rome$$internal$ast$js$regex$JSRegExpNonWhiteSpaceCharacter_ts = {
		get jsRegExpNonWhiteSpaceCharacter() {
			return ___R$project$rome$$internal$ast$js$regex$JSRegExpNonWhiteSpaceCharacter_ts$jsRegExpNonWhiteSpaceCharacter;
		},
	};
	const ___R$project$rome$$internal$ast$js$regex$JSRegExpNonWhiteSpaceCharacter_ts$jsRegExpNonWhiteSpaceCharacter = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSRegExpNonWhiteSpaceCharacter",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/regex/JSRegExpNonWordBoundaryCharacter.ts
const ___R$project$rome$$internal$ast$js$regex$JSRegExpNonWordBoundaryCharacter_ts = {
		get jsRegExpNonWordBoundaryCharacter() {
			return ___R$project$rome$$internal$ast$js$regex$JSRegExpNonWordBoundaryCharacter_ts$jsRegExpNonWordBoundaryCharacter;
		},
	};
	const ___R$project$rome$$internal$ast$js$regex$JSRegExpNonWordBoundaryCharacter_ts$jsRegExpNonWordBoundaryCharacter = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSRegExpNonWordBoundaryCharacter",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/regex/JSRegExpNonWordCharacter.ts
const ___R$project$rome$$internal$ast$js$regex$JSRegExpNonWordCharacter_ts = {
		get jsRegExpNonWordCharacter() {
			return ___R$project$rome$$internal$ast$js$regex$JSRegExpNonWordCharacter_ts$jsRegExpNonWordCharacter;
		},
	};
	const ___R$project$rome$$internal$ast$js$regex$JSRegExpNonWordCharacter_ts$jsRegExpNonWordCharacter = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSRegExpNonWordCharacter",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/regex/JSRegExpNumericBackReference.ts
const ___R$project$rome$$internal$ast$js$regex$JSRegExpNumericBackReference_ts = {
		get jsRegExpNumericBackReference() {
			return ___R$project$rome$$internal$ast$js$regex$JSRegExpNumericBackReference_ts$jsRegExpNumericBackReference;
		},
	};
	const ___R$project$rome$$internal$ast$js$regex$JSRegExpNumericBackReference_ts$jsRegExpNumericBackReference = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSRegExpNumericBackReference",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/regex/JSRegExpQuantified.ts
const ___R$project$rome$$internal$ast$js$regex$JSRegExpQuantified_ts = {
		get jsRegExpQuantified() {
			return ___R$project$rome$$internal$ast$js$regex$JSRegExpQuantified_ts$jsRegExpQuantified;
		},
	};
	const ___R$project$rome$$internal$ast$js$regex$JSRegExpQuantified_ts$jsRegExpQuantified = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSRegExpQuantified",
		{
			bindingKeys: {},
			visitorKeys: {
				target: true,
			},
		},
	);


  // project-rome/@internal/ast/js/regex/JSRegExpStartCharacter.ts
const ___R$project$rome$$internal$ast$js$regex$JSRegExpStartCharacter_ts = {
		get jsRegExpStartCharacter() {
			return ___R$project$rome$$internal$ast$js$regex$JSRegExpStartCharacter_ts$jsRegExpStartCharacter;
		},
	};
	const ___R$project$rome$$internal$ast$js$regex$JSRegExpStartCharacter_ts$jsRegExpStartCharacter = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSRegExpStartCharacter",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/regex/JSRegExpSubExpression.ts
const ___R$project$rome$$internal$ast$js$regex$JSRegExpSubExpression_ts = {
		get jsRegExpSubExpression() {
			return ___R$project$rome$$internal$ast$js$regex$JSRegExpSubExpression_ts$jsRegExpSubExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$regex$JSRegExpSubExpression_ts$jsRegExpSubExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSRegExpSubExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				body: true,
			},
		},
	);


  // project-rome/@internal/ast/js/regex/JSRegExpWhiteSpaceCharacter.ts
const ___R$project$rome$$internal$ast$js$regex$JSRegExpWhiteSpaceCharacter_ts = {
		get jsRegExpWhiteSpaceCharacter() {
			return ___R$project$rome$$internal$ast$js$regex$JSRegExpWhiteSpaceCharacter_ts$jsRegExpWhiteSpaceCharacter;
		},
	};
	const ___R$project$rome$$internal$ast$js$regex$JSRegExpWhiteSpaceCharacter_ts$jsRegExpWhiteSpaceCharacter = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSRegExpWhiteSpaceCharacter",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/regex/JSRegExpWordBoundaryCharacter.ts
const ___R$project$rome$$internal$ast$js$regex$JSRegExpWordBoundaryCharacter_ts = {
		get jsRegExpWordBoundaryCharacter() {
			return ___R$project$rome$$internal$ast$js$regex$JSRegExpWordBoundaryCharacter_ts$jsRegExpWordBoundaryCharacter;
		},
	};
	const ___R$project$rome$$internal$ast$js$regex$JSRegExpWordBoundaryCharacter_ts$jsRegExpWordBoundaryCharacter = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSRegExpWordBoundaryCharacter",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/regex/JSRegExpWordCharacter.ts
const ___R$project$rome$$internal$ast$js$regex$JSRegExpWordCharacter_ts = {
		get jsRegExpWordCharacter() {
			return ___R$project$rome$$internal$ast$js$regex$JSRegExpWordCharacter_ts$jsRegExpWordCharacter;
		},
	};
	const ___R$project$rome$$internal$ast$js$regex$JSRegExpWordCharacter_ts$jsRegExpWordCharacter = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSRegExpWordCharacter",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/statements/JSReturnStatement.ts
const ___R$project$rome$$internal$ast$js$statements$JSReturnStatement_ts = {
		get jsReturnStatement() {
			return ___R$project$rome$$internal$ast$js$statements$JSReturnStatement_ts$jsReturnStatement;
		},
	};
	const ___R$project$rome$$internal$ast$js$statements$JSReturnStatement_ts$jsReturnStatement = ___R$project$rome$$internal$ast$utils_ts$createQuickBuilder(
		"JSReturnStatement",
		"argument",
		{
			bindingKeys: {},
			visitorKeys: {
				argument: true,
			},
		},
	);


  // project-rome/@internal/ast/js/core/JSRoot.ts
const ___R$project$rome$$internal$ast$js$core$JSRoot_ts = {
		get MOCK_PROGRAM() {
			return ___R$project$rome$$internal$ast$js$core$JSRoot_ts$MOCK_PROGRAM;
		},
		get jsRoot() {
			return ___R$project$rome$$internal$ast$js$core$JSRoot_ts$jsRoot;
		},
	};
	const ___R$project$rome$$internal$ast$js$core$JSRoot_ts$MOCK_PROGRAM = {
		type: "JSRoot",
		directives: [],
		body: [],
		filename: "unknown",
		mtime: undefined,
		interpreter: undefined,
		corrupt: false,
		sourceType: "module",
		diagnostics: [],
		comments: [],
		syntax: [],
		hasHoistedVars: false,
	};

	const ___R$project$rome$$internal$ast$js$core$JSRoot_ts$jsRoot = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSRoot",
		{
			bindingKeys: {},
			visitorKeys: {
				interpreter: true,
				directives: true,
				body: true,
				comments: true,
			},
		},
	);


  // project-rome/@internal/ast/js/expressions/JSSequenceExpression.ts
const ___R$project$rome$$internal$ast$js$expressions$JSSequenceExpression_ts = {
		get jsSequenceExpression() {
			return ___R$project$rome$$internal$ast$js$expressions$JSSequenceExpression_ts$jsSequenceExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$expressions$JSSequenceExpression_ts$jsSequenceExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSSequenceExpression",
		{bindingKeys: {}, visitorKeys: {expressions: true}},
	);


  // project-rome/@internal/ast/js/auxiliary/JSSpreadElement.ts
const ___R$project$rome$$internal$ast$js$auxiliary$JSSpreadElement_ts = {
		get jsSpreadElement() {
			return ___R$project$rome$$internal$ast$js$auxiliary$JSSpreadElement_ts$jsSpreadElement;
		},
	};
	const ___R$project$rome$$internal$ast$js$auxiliary$JSSpreadElement_ts$jsSpreadElement = ___R$project$rome$$internal$ast$utils_ts$createQuickBuilder(
		"JSSpreadElement",
		"argument",
		{
			bindingKeys: {},
			visitorKeys: {
				argument: true,
			},
		},
	);


  // project-rome/@internal/ast/js/objects/JSSpreadProperty.ts
const ___R$project$rome$$internal$ast$js$objects$JSSpreadProperty_ts = {
		get jsSpreadProperty() {
			return ___R$project$rome$$internal$ast$js$objects$JSSpreadProperty_ts$jsSpreadProperty;
		},
	};
	const ___R$project$rome$$internal$ast$js$objects$JSSpreadProperty_ts$jsSpreadProperty = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSSpreadProperty",
		{
			bindingKeys: {},
			visitorKeys: {
				argument: true,
			},
		},
	);


  // project-rome/@internal/ast/js/auxiliary/JSStaticMemberProperty.ts
const ___R$project$rome$$internal$ast$js$auxiliary$JSStaticMemberProperty_ts = {
		get jsStaticMemberProperty() {
			return ___R$project$rome$$internal$ast$js$auxiliary$JSStaticMemberProperty_ts$jsStaticMemberProperty;
		},
	};
	const ___R$project$rome$$internal$ast$js$auxiliary$JSStaticMemberProperty_ts$jsStaticMemberProperty = ___R$project$rome$$internal$ast$utils_ts$createQuickBuilder(
		"JSStaticMemberProperty",
		"value",
		{
			bindingKeys: {},
			visitorKeys: {
				value: true,
			},
		},
	);


  // project-rome/@internal/ast/js/objects/JSStaticPropertyKey.ts
const ___R$project$rome$$internal$ast$js$objects$JSStaticPropertyKey_ts = {
		get jsStaticPropertyKey() {
			return ___R$project$rome$$internal$ast$js$objects$JSStaticPropertyKey_ts$jsStaticPropertyKey;
		},
	};
	const ___R$project$rome$$internal$ast$js$objects$JSStaticPropertyKey_ts$jsStaticPropertyKey = ___R$project$rome$$internal$ast$utils_ts$createQuickBuilder(
		"JSStaticPropertyKey",
		"value",
		{
			bindingKeys: {},
			visitorKeys: {
				value: true,
			},
		},
	);


  // project-rome/@internal/ast/js/literals/JSStringLiteral.ts
const ___R$project$rome$$internal$ast$js$literals$JSStringLiteral_ts = {
		get jsStringLiteral() {
			return ___R$project$rome$$internal$ast$js$literals$JSStringLiteral_ts$jsStringLiteral;
		},
	};
	const ___R$project$rome$$internal$ast$js$literals$JSStringLiteral_ts$jsStringLiteral = ___R$project$rome$$internal$ast$utils_ts$createQuickBuilder(
		"JSStringLiteral",
		"value",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/expressions/JSSuper.ts
const ___R$project$rome$$internal$ast$js$expressions$JSSuper_ts = {
		get jsSuper() {
			return ___R$project$rome$$internal$ast$js$expressions$JSSuper_ts$jsSuper;
		},
	};
	const ___R$project$rome$$internal$ast$js$expressions$JSSuper_ts$jsSuper = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSSuper",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/auxiliary/JSSwitchCase.ts
const ___R$project$rome$$internal$ast$js$auxiliary$JSSwitchCase_ts = {
		get jsSwitchCase() {
			return ___R$project$rome$$internal$ast$js$auxiliary$JSSwitchCase_ts$jsSwitchCase;
		},
	};
	const ___R$project$rome$$internal$ast$js$auxiliary$JSSwitchCase_ts$jsSwitchCase = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSSwitchCase",
		{
			bindingKeys: {},
			visitorKeys: {
				test: true,
				consequent: true,
			},
		},
	);


  // project-rome/@internal/ast/js/statements/JSSwitchStatement.ts
const ___R$project$rome$$internal$ast$js$statements$JSSwitchStatement_ts = {
		get jsSwitchStatement() {
			return ___R$project$rome$$internal$ast$js$statements$JSSwitchStatement_ts$jsSwitchStatement;
		},
	};
	const ___R$project$rome$$internal$ast$js$statements$JSSwitchStatement_ts$jsSwitchStatement = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSSwitchStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				discriminant: true,
				cases: true,
			},
		},
	);


  // project-rome/@internal/ast/js/expressions/JSTaggedTemplateExpression.ts
const ___R$project$rome$$internal$ast$js$expressions$JSTaggedTemplateExpression_ts = {
		get jsTaggedTemplateExpression() {
			return ___R$project$rome$$internal$ast$js$expressions$JSTaggedTemplateExpression_ts$jsTaggedTemplateExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$expressions$JSTaggedTemplateExpression_ts$jsTaggedTemplateExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSTaggedTemplateExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				tag: true,
				quasi: true,
				typeArguments: true,
			},
		},
	);


  // project-rome/@internal/ast/js/auxiliary/JSTemplateElement.ts
const ___R$project$rome$$internal$ast$js$auxiliary$JSTemplateElement_ts = {
		get jsTemplateElement() {
			return ___R$project$rome$$internal$ast$js$auxiliary$JSTemplateElement_ts$jsTemplateElement;
		},
	};
	const ___R$project$rome$$internal$ast$js$auxiliary$JSTemplateElement_ts$jsTemplateElement = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSTemplateElement",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/literals/JSTemplateLiteral.ts
const ___R$project$rome$$internal$ast$js$literals$JSTemplateLiteral_ts = {
		get jsTemplateLiteral() {
			return ___R$project$rome$$internal$ast$js$literals$JSTemplateLiteral_ts$jsTemplateLiteral;
		},
	};
	const ___R$project$rome$$internal$ast$js$literals$JSTemplateLiteral_ts$jsTemplateLiteral = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSTemplateLiteral",
		{
			bindingKeys: {},
			visitorKeys: {
				quasis: true,
				expressions: true,
			},
		},
	);


  // project-rome/@internal/ast/js/expressions/JSThisExpression.ts
const ___R$project$rome$$internal$ast$js$expressions$JSThisExpression_ts = {
		get jsThisExpression() {
			return ___R$project$rome$$internal$ast$js$expressions$JSThisExpression_ts$jsThisExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$expressions$JSThisExpression_ts$jsThisExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSThisExpression",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/statements/JSThrowStatement.ts
const ___R$project$rome$$internal$ast$js$statements$JSThrowStatement_ts = {
		get jsThrowStatement() {
			return ___R$project$rome$$internal$ast$js$statements$JSThrowStatement_ts$jsThrowStatement;
		},
	};
	const ___R$project$rome$$internal$ast$js$statements$JSThrowStatement_ts$jsThrowStatement = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSThrowStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				argument: true,
			},
		},
	);


  // project-rome/@internal/ast/js/statements/JSTryStatement.ts
const ___R$project$rome$$internal$ast$js$statements$JSTryStatement_ts = {
		get jsTryStatement() {
			return ___R$project$rome$$internal$ast$js$statements$JSTryStatement_ts$jsTryStatement;
		},
	};
	const ___R$project$rome$$internal$ast$js$statements$JSTryStatement_ts$jsTryStatement = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSTryStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				block: true,
				handler: true,
				finalizer: true,
			},
		},
	);


  // project-rome/@internal/ast/js/expressions/JSUnaryExpression.ts
const ___R$project$rome$$internal$ast$js$expressions$JSUnaryExpression_ts = {
		get jsUnaryExpression() {
			return ___R$project$rome$$internal$ast$js$expressions$JSUnaryExpression_ts$jsUnaryExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$expressions$JSUnaryExpression_ts$jsUnaryExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSUnaryExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				argument: true,
			},
		},
	);


  // project-rome/@internal/ast/js/expressions/JSUpdateExpression.ts
const ___R$project$rome$$internal$ast$js$expressions$JSUpdateExpression_ts = {
		get jsUpdateExpression() {
			return ___R$project$rome$$internal$ast$js$expressions$JSUpdateExpression_ts$jsUpdateExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$expressions$JSUpdateExpression_ts$jsUpdateExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSUpdateExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				argument: true,
			},
		},
	);


  // project-rome/@internal/ast/js/auxiliary/JSVariableDeclaration.ts
const ___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclaration_ts = {
		get jsVariableDeclaration() {
			return ___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclaration_ts$jsVariableDeclaration;
		},
	};
	const ___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclaration_ts$jsVariableDeclaration = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSVariableDeclaration",
		{
			bindingKeys: {
				declarations: true,
			},
			visitorKeys: {
				declarations: true,
			},
		},
	);


  // project-rome/@internal/ast/js/statements/JSVariableDeclarationStatement.ts
const ___R$project$rome$$internal$ast$js$statements$JSVariableDeclarationStatement_ts = {
		get jsVariableDeclarationStatement() {
			return ___R$project$rome$$internal$ast$js$statements$JSVariableDeclarationStatement_ts$jsVariableDeclarationStatement;
		},
	};
	const ___R$project$rome$$internal$ast$js$statements$JSVariableDeclarationStatement_ts$jsVariableDeclarationStatement = ___R$project$rome$$internal$ast$utils_ts$createQuickBuilder(
		"JSVariableDeclarationStatement",
		"declaration",
		{
			bindingKeys: {
				declaration: true,
			},
			visitorKeys: {
				declaration: true,
			},
		},
	);


  // project-rome/@internal/ast/js/auxiliary/JSVariableDeclarator.ts
const ___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclarator_ts = {
		get jsVariableDeclarator() {
			return ___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclarator_ts$jsVariableDeclarator;
		},
	};
	const ___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclarator_ts$jsVariableDeclarator = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSVariableDeclarator",
		{
			bindingKeys: {
				id: true,
			},
			visitorKeys: {
				id: true,
				init: true,
			},
		},
	);


  // project-rome/@internal/ast/js/statements/JSWhileStatement.ts
const ___R$project$rome$$internal$ast$js$statements$JSWhileStatement_ts = {
		get jsWhileStatement() {
			return ___R$project$rome$$internal$ast$js$statements$JSWhileStatement_ts$jsWhileStatement;
		},
	};
	const ___R$project$rome$$internal$ast$js$statements$JSWhileStatement_ts$jsWhileStatement = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSWhileStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				test: true,
				body: true,
			},
		},
	);


  // project-rome/@internal/ast/js/statements/JSWithStatement.ts
const ___R$project$rome$$internal$ast$js$statements$JSWithStatement_ts = {
		get jsWithStatement() {
			return ___R$project$rome$$internal$ast$js$statements$JSWithStatement_ts$jsWithStatement;
		},
	};
	const ___R$project$rome$$internal$ast$js$statements$JSWithStatement_ts$jsWithStatement = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSWithStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				object: true,
				body: true,
			},
		},
	);


  // project-rome/@internal/ast/js/jsx/JSXAttribute.ts
const ___R$project$rome$$internal$ast$js$jsx$JSXAttribute_ts = {
		get jsxAttribute() {
			return ___R$project$rome$$internal$ast$js$jsx$JSXAttribute_ts$jsxAttribute;
		},
	};
	const ___R$project$rome$$internal$ast$js$jsx$JSXAttribute_ts$jsxAttribute = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSXAttribute",
		{
			bindingKeys: {},
			visitorKeys: {
				name: true,
				value: true,
			},
		},
	);


  // project-rome/@internal/ast/js/jsx/JSXElement.ts
const ___R$project$rome$$internal$ast$js$jsx$JSXElement_ts = {
		get jsxElement() {
			return ___R$project$rome$$internal$ast$js$jsx$JSXElement_ts$jsxElement;
		},
	};
	const ___R$project$rome$$internal$ast$js$jsx$JSXElement_ts$jsxElement = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSXElement",
		{
			bindingKeys: {},
			visitorKeys: {
				name: true,
				typeArguments: true,
				attributes: true,
				children: true,
			},
		},
	);


  // project-rome/@internal/ast/js/jsx/JSXEmptyExpression.ts
const ___R$project$rome$$internal$ast$js$jsx$JSXEmptyExpression_ts = {
		get jsxEmptyExpression() {
			return ___R$project$rome$$internal$ast$js$jsx$JSXEmptyExpression_ts$jsxEmptyExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$jsx$JSXEmptyExpression_ts$jsxEmptyExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSXEmptyExpression",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/jsx/JSXExpressionContainer.ts
const ___R$project$rome$$internal$ast$js$jsx$JSXExpressionContainer_ts = {
		get jsxExpressionContainer() {
			return ___R$project$rome$$internal$ast$js$jsx$JSXExpressionContainer_ts$jsxExpressionContainer;
		},
	};
	const ___R$project$rome$$internal$ast$js$jsx$JSXExpressionContainer_ts$jsxExpressionContainer = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSXExpressionContainer",
		{
			bindingKeys: {},
			visitorKeys: {
				expression: true,
			},
		},
	);


  // project-rome/@internal/ast/js/jsx/JSXFragment.ts
const ___R$project$rome$$internal$ast$js$jsx$JSXFragment_ts = {
		get jsxFragment() {
			return ___R$project$rome$$internal$ast$js$jsx$JSXFragment_ts$jsxFragment;
		},
	};
	const ___R$project$rome$$internal$ast$js$jsx$JSXFragment_ts$jsxFragment = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSXFragment",
		{
			bindingKeys: {},
			visitorKeys: {
				children: true,
			},
		},
	);


  // project-rome/@internal/ast/js/jsx/JSXIdentifier.ts
const ___R$project$rome$$internal$ast$js$jsx$JSXIdentifier_ts = {
		get jsxIdentifier() {
			return ___R$project$rome$$internal$ast$js$jsx$JSXIdentifier_ts$jsxIdentifier;
		},
	};
	const ___R$project$rome$$internal$ast$js$jsx$JSXIdentifier_ts$jsxIdentifier = ___R$project$rome$$internal$ast$utils_ts$createQuickBuilder(
		"JSXIdentifier",
		"name",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/jsx/JSXMemberExpression.ts
const ___R$project$rome$$internal$ast$js$jsx$JSXMemberExpression_ts = {
		get jsxMemberExpression() {
			return ___R$project$rome$$internal$ast$js$jsx$JSXMemberExpression_ts$jsxMemberExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$jsx$JSXMemberExpression_ts$jsxMemberExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSXMemberExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				object: true,
				property: true,
			},
		},
	);


  // project-rome/@internal/ast/js/jsx/JSXNamespacedName.ts
const ___R$project$rome$$internal$ast$js$jsx$JSXNamespacedName_ts = {
		get jsxNamespacedName() {
			return ___R$project$rome$$internal$ast$js$jsx$JSXNamespacedName_ts$jsxNamespacedName;
		},
	};
	const ___R$project$rome$$internal$ast$js$jsx$JSXNamespacedName_ts$jsxNamespacedName = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSXNamespacedName",
		{
			bindingKeys: {},
			visitorKeys: {
				namespace: true,
				name: true,
			},
		},
	);


  // project-rome/@internal/ast/js/jsx/JSXReferenceIdentifier.ts
const ___R$project$rome$$internal$ast$js$jsx$JSXReferenceIdentifier_ts = {
		get jsxReferenceIdentifier() {
			return ___R$project$rome$$internal$ast$js$jsx$JSXReferenceIdentifier_ts$jsxReferenceIdentifier;
		},
	};
	const ___R$project$rome$$internal$ast$js$jsx$JSXReferenceIdentifier_ts$jsxReferenceIdentifier = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSXReferenceIdentifier",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/jsx/JSXSpreadAttribute.ts
const ___R$project$rome$$internal$ast$js$jsx$JSXSpreadAttribute_ts = {
		get jsxSpreadAttribute() {
			return ___R$project$rome$$internal$ast$js$jsx$JSXSpreadAttribute_ts$jsxSpreadAttribute;
		},
	};
	const ___R$project$rome$$internal$ast$js$jsx$JSXSpreadAttribute_ts$jsxSpreadAttribute = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSXSpreadAttribute",
		{
			bindingKeys: {},
			visitorKeys: {
				argument: true,
			},
		},
	);


  // project-rome/@internal/ast/js/jsx/JSXSpreadChild.ts
const ___R$project$rome$$internal$ast$js$jsx$JSXSpreadChild_ts = {
		get jsxSpreadChild() {
			return ___R$project$rome$$internal$ast$js$jsx$JSXSpreadChild_ts$jsxSpreadChild;
		},
	};
	const ___R$project$rome$$internal$ast$js$jsx$JSXSpreadChild_ts$jsxSpreadChild = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSXSpreadChild",
		{
			bindingKeys: {},
			visitorKeys: {
				expression: true,
			},
		},
	);


  // project-rome/@internal/ast/js/jsx/JSXText.ts
const ___R$project$rome$$internal$ast$js$jsx$JSXText_ts = {
		get jsxText() {
			return ___R$project$rome$$internal$ast$js$jsx$JSXText_ts$jsxText;
		},
	};
	const ___R$project$rome$$internal$ast$js$jsx$JSXText_ts$jsxText = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSXText",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/expressions/JSYieldExpression.ts
const ___R$project$rome$$internal$ast$js$expressions$JSYieldExpression_ts = {
		get jsYieldExpression() {
			return ___R$project$rome$$internal$ast$js$expressions$JSYieldExpression_ts$jsYieldExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$expressions$JSYieldExpression_ts$jsYieldExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"JSYieldExpression",
		{bindingKeys: {}, visitorKeys: {argument: true}},
	);


  // project-rome/@internal/ast/markdown/inline/MarkdownAutomaticLinkInline.ts
const ___R$project$rome$$internal$ast$markdown$inline$MarkdownAutomaticLinkInline_ts = {
		get markdownAutomaticLinkInline() {
			return ___R$project$rome$$internal$ast$markdown$inline$MarkdownAutomaticLinkInline_ts$markdownAutomaticLinkInline;
		},
	};
	const ___R$project$rome$$internal$ast$markdown$inline$MarkdownAutomaticLinkInline_ts$markdownAutomaticLinkInline = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"MarkdownAutomaticLinkInline",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/markdown/inline/MarkdownBoldInline.ts
const ___R$project$rome$$internal$ast$markdown$inline$MarkdownBoldInline_ts = {
		get markdownBoldInline() {
			return ___R$project$rome$$internal$ast$markdown$inline$MarkdownBoldInline_ts$markdownBoldInline;
		},
	};
	const ___R$project$rome$$internal$ast$markdown$inline$MarkdownBoldInline_ts$markdownBoldInline = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"MarkdownBoldInline",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/markdown/blocks/MarkdownCodeBlock.ts
const ___R$project$rome$$internal$ast$markdown$blocks$MarkdownCodeBlock_ts = {
		get markdownCodeBlock() {
			return ___R$project$rome$$internal$ast$markdown$blocks$MarkdownCodeBlock_ts$markdownCodeBlock;
		},
	};
	const ___R$project$rome$$internal$ast$markdown$blocks$MarkdownCodeBlock_ts$markdownCodeBlock = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"MarkdownCodeBlock",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/markdown/inline/MarkdownCodeInline.ts
const ___R$project$rome$$internal$ast$markdown$inline$MarkdownCodeInline_ts = {
		get markdownCodeInline() {
			return ___R$project$rome$$internal$ast$markdown$inline$MarkdownCodeInline_ts$markdownCodeInline;
		},
	};
	const ___R$project$rome$$internal$ast$markdown$inline$MarkdownCodeInline_ts$markdownCodeInline = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"MarkdownCodeInline",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/markdown/inline/MarkdownDefinitionInline.ts
const ___R$project$rome$$internal$ast$markdown$inline$MarkdownDefinitionInline_ts = {
		get markdownDefinitionInline() {
			return ___R$project$rome$$internal$ast$markdown$inline$MarkdownDefinitionInline_ts$markdownDefinitionInline;
		},
	};
	const ___R$project$rome$$internal$ast$markdown$inline$MarkdownDefinitionInline_ts$markdownDefinitionInline = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"MarkdownDefinitionInline",
		{
			bindingKeys: {},
			visitorKeys: {
				url: true,
				title: true,
				identifier: true,
			},
		},
	);


  // project-rome/@internal/ast/markdown/blocks/MarkdownDividerBlock.ts
const ___R$project$rome$$internal$ast$markdown$blocks$MarkdownDividerBlock_ts = {
		get markdownDividerBlock() {
			return ___R$project$rome$$internal$ast$markdown$blocks$MarkdownDividerBlock_ts$markdownDividerBlock;
		},
	};
	const ___R$project$rome$$internal$ast$markdown$blocks$MarkdownDividerBlock_ts$markdownDividerBlock = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"MarkdownDividerBlock",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/markdown/inline/MarkdownEmphasisInline.ts
const ___R$project$rome$$internal$ast$markdown$inline$MarkdownEmphasisInline_ts = {
		get markdownEmphasisInline() {
			return ___R$project$rome$$internal$ast$markdown$inline$MarkdownEmphasisInline_ts$markdownEmphasisInline;
		},
	};
	const ___R$project$rome$$internal$ast$markdown$inline$MarkdownEmphasisInline_ts$markdownEmphasisInline = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"MarkdownEmphasisInline",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/markdown/blocks/MarkdownHeadingBlock.ts
const ___R$project$rome$$internal$ast$markdown$blocks$MarkdownHeadingBlock_ts = {
		get markdownHeadingBlock() {
			return ___R$project$rome$$internal$ast$markdown$blocks$MarkdownHeadingBlock_ts$markdownHeadingBlock;
		},
	};
	const ___R$project$rome$$internal$ast$markdown$blocks$MarkdownHeadingBlock_ts$markdownHeadingBlock = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"MarkdownHeadingBlock",
		{
			bindingKeys: {},
			visitorKeys: {
				level: true,
			},
		},
	);


  // project-rome/@internal/ast/markdown/inline/MarkdownImageInline.ts
const ___R$project$rome$$internal$ast$markdown$inline$MarkdownImageInline_ts = {
		get markdownImageInline() {
			return ___R$project$rome$$internal$ast$markdown$inline$MarkdownImageInline_ts$markdownImageInline;
		},
	};
	const ___R$project$rome$$internal$ast$markdown$inline$MarkdownImageInline_ts$markdownImageInline = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"MarkdownImageInline",
		{
			bindingKeys: {},
			visitorKeys: {
				url: true,
			},
		},
	);


  // project-rome/@internal/ast/markdown/inline/MarkdownLinkInline.ts
const ___R$project$rome$$internal$ast$markdown$inline$MarkdownLinkInline_ts = {
		get markdownLinkInline() {
			return ___R$project$rome$$internal$ast$markdown$inline$MarkdownLinkInline_ts$markdownLinkInline;
		},
	};
	const ___R$project$rome$$internal$ast$markdown$inline$MarkdownLinkInline_ts$markdownLinkInline = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"MarkdownLinkInline",
		{
			bindingKeys: {},
			visitorKeys: {
				url: true,
			},
		},
	);


  // project-rome/@internal/ast/markdown/blocks/MarkdownListBlock.ts
const ___R$project$rome$$internal$ast$markdown$blocks$MarkdownListBlock_ts = {
		get markdownListBlock() {
			return ___R$project$rome$$internal$ast$markdown$blocks$MarkdownListBlock_ts$markdownListBlock;
		},
	};
	const ___R$project$rome$$internal$ast$markdown$blocks$MarkdownListBlock_ts$markdownListBlock = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"MarkdownListBlock",
		{
			bindingKeys: {},
			visitorKeys: {
				children: true,
			},
		},
	);


  // project-rome/@internal/ast/markdown/core/MarkdownListItem.ts
const ___R$project$rome$$internal$ast$markdown$core$MarkdownListItem_ts = {
		get markdownListItem() {
			return ___R$project$rome$$internal$ast$markdown$core$MarkdownListItem_ts$markdownListItem;
		},
	};
	const ___R$project$rome$$internal$ast$markdown$core$MarkdownListItem_ts$markdownListItem = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"MarkdownListItem",
		{
			bindingKeys: {},
			visitorKeys: {
				children: true,
			},
		},
	);


  // project-rome/@internal/ast/markdown/core/MarkdownParagraph.ts
const ___R$project$rome$$internal$ast$markdown$core$MarkdownParagraph_ts = {
		get markdownParagraph() {
			return ___R$project$rome$$internal$ast$markdown$core$MarkdownParagraph_ts$markdownParagraph;
		},
	};
	const ___R$project$rome$$internal$ast$markdown$core$MarkdownParagraph_ts$markdownParagraph = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"MarkdownParagraph",
		{
			bindingKeys: {},
			visitorKeys: {
				children: true,
			},
		},
	);


  // project-rome/@internal/ast/markdown/blocks/MarkdownQuoteBlock.ts
const ___R$project$rome$$internal$ast$markdown$blocks$MarkdownQuoteBlock_ts = {
		get markdownQuoteBlock() {
			return ___R$project$rome$$internal$ast$markdown$blocks$MarkdownQuoteBlock_ts$markdownQuoteBlock;
		},
	};
	const ___R$project$rome$$internal$ast$markdown$blocks$MarkdownQuoteBlock_ts$markdownQuoteBlock = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"MarkdownQuoteBlock",
		{
			bindingKeys: {},
			visitorKeys: {
				children: true,
			},
		},
	);


  // project-rome/@internal/ast/markdown/core/MarkdownRoot.ts
const ___R$project$rome$$internal$ast$markdown$core$MarkdownRoot_ts = {
		get markdownRoot() {
			return ___R$project$rome$$internal$ast$markdown$core$MarkdownRoot_ts$markdownRoot;
		},
	};
	const ___R$project$rome$$internal$ast$markdown$core$MarkdownRoot_ts$markdownRoot = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"MarkdownRoot",
		{
			bindingKeys: {},
			visitorKeys: {
				body: true,
				comments: true,
			},
		},
	);


  // project-rome/@internal/ast/markdown/core/MarkdownText.ts
const ___R$project$rome$$internal$ast$markdown$core$MarkdownText_ts = {
		get markdownText() {
			return ___R$project$rome$$internal$ast$markdown$core$MarkdownText_ts$markdownText;
		},
	};
	const ___R$project$rome$$internal$ast$markdown$core$MarkdownText_ts$markdownText = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"MarkdownText",
		{
			bindingKeys: {},
			visitorKeys: {
				value: true,
			},
		},
	);


  // project-rome/@internal/ast/common/core/MockParent.ts
const ___R$project$rome$$internal$ast$common$core$MockParent_ts = {
		get jsMockParent() {
			return ___R$project$rome$$internal$ast$common$core$MockParent_ts$jsMockParent;
		},
		get MOCK_PARENT() {
			return ___R$project$rome$$internal$ast$common$core$MockParent_ts$MOCK_PARENT;
		},
	};
	const ___R$project$rome$$internal$ast$common$core$MockParent_ts$jsMockParent = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"MockParent",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);

	const ___R$project$rome$$internal$ast$common$core$MockParent_ts$MOCK_PARENT = {
		type: "MockParent",
	};


  // project-rome/@internal/ast/js/typescript/TSAnyKeywordTypeAnnotation.ts
const ___R$project$rome$$internal$ast$js$typescript$TSAnyKeywordTypeAnnotation_ts = {
		get tsAnyKeywordTypeAnnotation() {
			return ___R$project$rome$$internal$ast$js$typescript$TSAnyKeywordTypeAnnotation_ts$tsAnyKeywordTypeAnnotation;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSAnyKeywordTypeAnnotation_ts$tsAnyKeywordTypeAnnotation = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSAnyKeywordTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSArrayType.ts
const ___R$project$rome$$internal$ast$js$typescript$TSArrayType_ts = {
		get tsArrayType() {
			return ___R$project$rome$$internal$ast$js$typescript$TSArrayType_ts$tsArrayType;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSArrayType_ts$tsArrayType = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSArrayType",
		{
			bindingKeys: {},
			visitorKeys: {elementType: true},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSAsExpression.ts
const ___R$project$rome$$internal$ast$js$typescript$TSAsExpression_ts = {
		get tsAsExpression() {
			return ___R$project$rome$$internal$ast$js$typescript$TSAsExpression_ts$tsAsExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSAsExpression_ts$tsAsExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSAsExpression",
		{
			bindingKeys: {},
			visitorKeys: {expression: true, typeAnnotation: true},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSAssignmentAsExpression.ts
const ___R$project$rome$$internal$ast$js$typescript$TSAssignmentAsExpression_ts = {
		get tsAssignmentAsExpression() {
			return ___R$project$rome$$internal$ast$js$typescript$TSAssignmentAsExpression_ts$tsAssignmentAsExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSAssignmentAsExpression_ts$tsAssignmentAsExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSAssignmentAsExpression",
		{
			bindingKeys: {},
			visitorKeys: {expression: true, typeAnnotation: true},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSAssignmentNonNullExpression.ts
const ___R$project$rome$$internal$ast$js$typescript$TSAssignmentNonNullExpression_ts = {
		get tsAssignmentNonNullExpression() {
			return ___R$project$rome$$internal$ast$js$typescript$TSAssignmentNonNullExpression_ts$tsAssignmentNonNullExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSAssignmentNonNullExpression_ts$tsAssignmentNonNullExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSAssignmentNonNullExpression",
		{
			bindingKeys: {},
			visitorKeys: {expression: true},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSAssignmentTypeAssertion.ts
const ___R$project$rome$$internal$ast$js$typescript$TSAssignmentTypeAssertion_ts = {
		get tsAssignmentTypeAssertion() {
			return ___R$project$rome$$internal$ast$js$typescript$TSAssignmentTypeAssertion_ts$tsAssignmentTypeAssertion;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSAssignmentTypeAssertion_ts$tsAssignmentTypeAssertion = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSAssignmentTypeAssertion",
		{
			bindingKeys: {},
			visitorKeys: {expression: true, typeAnnotation: true},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSBigIntKeywordTypeAnnotation.ts
const ___R$project$rome$$internal$ast$js$typescript$TSBigIntKeywordTypeAnnotation_ts = {
		get tsBigIntKeywordTypeAnnotation() {
			return ___R$project$rome$$internal$ast$js$typescript$TSBigIntKeywordTypeAnnotation_ts$tsBigIntKeywordTypeAnnotation;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSBigIntKeywordTypeAnnotation_ts$tsBigIntKeywordTypeAnnotation = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSBigIntKeywordTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSBigIntLiteralTypeAnnotation.ts
const ___R$project$rome$$internal$ast$js$typescript$TSBigIntLiteralTypeAnnotation_ts = {
		get tsBigIntLiteralTypeAnnotation() {
			return ___R$project$rome$$internal$ast$js$typescript$TSBigIntLiteralTypeAnnotation_ts$tsBigIntLiteralTypeAnnotation;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSBigIntLiteralTypeAnnotation_ts$tsBigIntLiteralTypeAnnotation = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSBigIntLiteralTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSBooleanKeywordTypeAnnotation.ts
const ___R$project$rome$$internal$ast$js$typescript$TSBooleanKeywordTypeAnnotation_ts = {
		get tsBooleanKeywordTypeAnnotation() {
			return ___R$project$rome$$internal$ast$js$typescript$TSBooleanKeywordTypeAnnotation_ts$tsBooleanKeywordTypeAnnotation;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSBooleanKeywordTypeAnnotation_ts$tsBooleanKeywordTypeAnnotation = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSBooleanKeywordTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSBooleanLiteralTypeAnnotation.ts
const ___R$project$rome$$internal$ast$js$typescript$TSBooleanLiteralTypeAnnotation_ts = {
		get tsBooleanLiteralTypeAnnotation() {
			return ___R$project$rome$$internal$ast$js$typescript$TSBooleanLiteralTypeAnnotation_ts$tsBooleanLiteralTypeAnnotation;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSBooleanLiteralTypeAnnotation_ts$tsBooleanLiteralTypeAnnotation = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSBooleanLiteralTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSCallSignatureDeclaration.ts
const ___R$project$rome$$internal$ast$js$typescript$TSCallSignatureDeclaration_ts = {
		get tsCallSignatureDeclaration() {
			return ___R$project$rome$$internal$ast$js$typescript$TSCallSignatureDeclaration_ts$tsCallSignatureDeclaration;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSCallSignatureDeclaration_ts$tsCallSignatureDeclaration = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSCallSignatureDeclaration",
		{
			bindingKeys: {},
			visitorKeys: {
				meta: true,
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSConditionalType.ts
const ___R$project$rome$$internal$ast$js$typescript$TSConditionalType_ts = {
		get tsConditionalType() {
			return ___R$project$rome$$internal$ast$js$typescript$TSConditionalType_ts$tsConditionalType;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSConditionalType_ts$tsConditionalType = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSConditionalType",
		{
			bindingKeys: {},
			visitorKeys: {
				checkType: true,
				extendsType: true,
				trueType: true,
				falseType: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSConstKeyword.ts
const ___R$project$rome$$internal$ast$js$typescript$TSConstKeyword_ts = {
		get tsConstKeyword() {
			return ___R$project$rome$$internal$ast$js$typescript$TSConstKeyword_ts$tsConstKeyword;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSConstKeyword_ts$tsConstKeyword = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSConstKeyword",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSConstructorType.ts
const ___R$project$rome$$internal$ast$js$typescript$TSConstructorType_ts = {
		get tsConstructorType() {
			return ___R$project$rome$$internal$ast$js$typescript$TSConstructorType_ts$tsConstructorType;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSConstructorType_ts$tsConstructorType = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSConstructorType",
		{
			bindingKeys: {},
			visitorKeys: {
				meta: true,
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSConstructSignatureDeclaration.ts
const ___R$project$rome$$internal$ast$js$typescript$TSConstructSignatureDeclaration_ts = {
		get tsConstructSignatureDeclaration() {
			return ___R$project$rome$$internal$ast$js$typescript$TSConstructSignatureDeclaration_ts$tsConstructSignatureDeclaration;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSConstructSignatureDeclaration_ts$tsConstructSignatureDeclaration = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSConstructSignatureDeclaration",
		{
			bindingKeys: {},
			visitorKeys: {
				meta: true,
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSDeclareFunction.ts
const ___R$project$rome$$internal$ast$js$typescript$TSDeclareFunction_ts = {
		get tsDeclareFunction() {
			return ___R$project$rome$$internal$ast$js$typescript$TSDeclareFunction_ts$tsDeclareFunction;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSDeclareFunction_ts$tsDeclareFunction = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSDeclareFunction",
		{
			bindingKeys: {
				id: true,
			},
			visitorKeys: {
				id: true,
				head: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSDeclareMethod.ts
const ___R$project$rome$$internal$ast$js$typescript$TSDeclareMethod_ts = {
		get tsDeclareMethod() {
			return ___R$project$rome$$internal$ast$js$typescript$TSDeclareMethod_ts$tsDeclareMethod;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSDeclareMethod_ts$tsDeclareMethod = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSDeclareMethod",
		{
			bindingKeys: {},
			visitorKeys: {
				meta: true,
				key: true,
				head: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSEmptyKeywordTypeAnnotation.ts
const ___R$project$rome$$internal$ast$js$typescript$TSEmptyKeywordTypeAnnotation_ts = {
		get tsEmptyKeywordTypeAnnotation() {
			return ___R$project$rome$$internal$ast$js$typescript$TSEmptyKeywordTypeAnnotation_ts$tsEmptyKeywordTypeAnnotation;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSEmptyKeywordTypeAnnotation_ts$tsEmptyKeywordTypeAnnotation = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSEmptyKeywordTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSEnumDeclaration.ts
const ___R$project$rome$$internal$ast$js$typescript$TSEnumDeclaration_ts = {
		get tsEnumDeclaration() {
			return ___R$project$rome$$internal$ast$js$typescript$TSEnumDeclaration_ts$tsEnumDeclaration;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSEnumDeclaration_ts$tsEnumDeclaration = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSEnumDeclaration",
		{
			bindingKeys: {
				id: true,
			},
			visitorKeys: {
				id: true,
				members: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSEnumMember.ts
const ___R$project$rome$$internal$ast$js$typescript$TSEnumMember_ts = {
		get tsEnumMember() {
			return ___R$project$rome$$internal$ast$js$typescript$TSEnumMember_ts$tsEnumMember;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSEnumMember_ts$tsEnumMember = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSEnumMember",
		{
			bindingKeys: {},
			visitorKeys: {
				id: true,
				initializer: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSExportAssignment.ts
const ___R$project$rome$$internal$ast$js$typescript$TSExportAssignment_ts = {
		get tsExportAssignment() {
			return ___R$project$rome$$internal$ast$js$typescript$TSExportAssignment_ts$tsExportAssignment;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSExportAssignment_ts$tsExportAssignment = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSExportAssignment",
		{bindingKeys: {}, visitorKeys: {expression: true}},
	);


  // project-rome/@internal/ast/js/typescript/TSExpressionWithTypeArguments.ts
const ___R$project$rome$$internal$ast$js$typescript$TSExpressionWithTypeArguments_ts = {
		get tsExpressionWithTypeArguments() {
			return ___R$project$rome$$internal$ast$js$typescript$TSExpressionWithTypeArguments_ts$tsExpressionWithTypeArguments;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSExpressionWithTypeArguments_ts$tsExpressionWithTypeArguments = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSExpressionWithTypeArguments",
		{
			bindingKeys: {},
			visitorKeys: {
				expression: true,
				typeParameters: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSExternalModuleReference.ts
const ___R$project$rome$$internal$ast$js$typescript$TSExternalModuleReference_ts = {
		get tsExternalModuleReference() {
			return ___R$project$rome$$internal$ast$js$typescript$TSExternalModuleReference_ts$tsExternalModuleReference;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSExternalModuleReference_ts$tsExternalModuleReference = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSExternalModuleReference",
		{
			bindingKeys: {},
			visitorKeys: {expression: true},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSFunctionType.ts
const ___R$project$rome$$internal$ast$js$typescript$TSFunctionType_ts = {
		get tsFunctionType() {
			return ___R$project$rome$$internal$ast$js$typescript$TSFunctionType_ts$tsFunctionType;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSFunctionType_ts$tsFunctionType = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSFunctionType",
		{
			bindingKeys: {},
			visitorKeys: {
				meta: true,
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSImportEqualsDeclaration.ts
const ___R$project$rome$$internal$ast$js$typescript$TSImportEqualsDeclaration_ts = {
		get tsImportEqualsDeclaration() {
			return ___R$project$rome$$internal$ast$js$typescript$TSImportEqualsDeclaration_ts$tsImportEqualsDeclaration;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSImportEqualsDeclaration_ts$tsImportEqualsDeclaration = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSImportEqualsDeclaration",
		{
			bindingKeys: {
				id: true,
			},
			visitorKeys: {id: true, moduleReference: true},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSImportType.ts
const ___R$project$rome$$internal$ast$js$typescript$TSImportType_ts = {
		get tsImportType() {
			return ___R$project$rome$$internal$ast$js$typescript$TSImportType_ts$tsImportType;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSImportType_ts$tsImportType = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSImportType",
		{
			bindingKeys: {},
			visitorKeys: {
				argument: true,
				typeParameters: true,
				qualifier: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSIndexedAccessType.ts
const ___R$project$rome$$internal$ast$js$typescript$TSIndexedAccessType_ts = {
		get tsIndexedAccessType() {
			return ___R$project$rome$$internal$ast$js$typescript$TSIndexedAccessType_ts$tsIndexedAccessType;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSIndexedAccessType_ts$tsIndexedAccessType = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSIndexedAccessType",
		{
			bindingKeys: {},
			visitorKeys: {
				objectType: true,
				indexType: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSIndexSignature.ts
const ___R$project$rome$$internal$ast$js$typescript$TSIndexSignature_ts = {
		get tsIndexSignature() {
			return ___R$project$rome$$internal$ast$js$typescript$TSIndexSignature_ts$tsIndexSignature;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSIndexSignature_ts$tsIndexSignature = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSIndexSignature",
		{
			bindingKeys: {
				key: true,
			},
			visitorKeys: {
				typeAnnotation: true,
				key: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSInferType.ts
const ___R$project$rome$$internal$ast$js$typescript$TSInferType_ts = {
		get tsInferType() {
			return ___R$project$rome$$internal$ast$js$typescript$TSInferType_ts$tsInferType;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSInferType_ts$tsInferType = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSInferType",
		{
			bindingKeys: {},
			visitorKeys: {
				typeParameter: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSInterfaceBody.ts
const ___R$project$rome$$internal$ast$js$typescript$TSInterfaceBody_ts = {
		get tsInterfaceBody() {
			return ___R$project$rome$$internal$ast$js$typescript$TSInterfaceBody_ts$tsInterfaceBody;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSInterfaceBody_ts$tsInterfaceBody = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSInterfaceBody",
		{
			bindingKeys: {},
			visitorKeys: {
				body: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSInterfaceDeclaration.ts
const ___R$project$rome$$internal$ast$js$typescript$TSInterfaceDeclaration_ts = {
		get tsInterfaceDeclaration() {
			return ___R$project$rome$$internal$ast$js$typescript$TSInterfaceDeclaration_ts$tsInterfaceDeclaration;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSInterfaceDeclaration_ts$tsInterfaceDeclaration = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSInterfaceDeclaration",
		{
			bindingKeys: {
				id: true,
			},
			visitorKeys: {
				id: true,
				body: true,
				typeParameters: true,
				extends: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSIntersectionTypeAnnotation.ts
const ___R$project$rome$$internal$ast$js$typescript$TSIntersectionTypeAnnotation_ts = {
		get tsIntersectionTypeAnnotation() {
			return ___R$project$rome$$internal$ast$js$typescript$TSIntersectionTypeAnnotation_ts$tsIntersectionTypeAnnotation;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSIntersectionTypeAnnotation_ts$tsIntersectionTypeAnnotation = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSIntersectionTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {
				types: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSMappedType.ts
const ___R$project$rome$$internal$ast$js$typescript$TSMappedType_ts = {
		get tsMappedType() {
			return ___R$project$rome$$internal$ast$js$typescript$TSMappedType_ts$tsMappedType;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSMappedType_ts$tsMappedType = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSMappedType",
		{
			bindingKeys: {},
			visitorKeys: {
				typeParameter: true,
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSMethodSignature.ts
const ___R$project$rome$$internal$ast$js$typescript$TSMethodSignature_ts = {
		get tsMethodSignature() {
			return ___R$project$rome$$internal$ast$js$typescript$TSMethodSignature_ts$tsMethodSignature;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSMethodSignature_ts$tsMethodSignature = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSMethodSignature",
		{
			bindingKeys: {},
			visitorKeys: {
				key: true,
				meta: true,
				returnType: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSMixedKeywordTypeAnnotation.ts
const ___R$project$rome$$internal$ast$js$typescript$TSMixedKeywordTypeAnnotation_ts = {
		get tsMixedKeywordTypeAnnotation() {
			return ___R$project$rome$$internal$ast$js$typescript$TSMixedKeywordTypeAnnotation_ts$tsMixedKeywordTypeAnnotation;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSMixedKeywordTypeAnnotation_ts$tsMixedKeywordTypeAnnotation = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSMixedKeywordTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSModuleBlock.ts
const ___R$project$rome$$internal$ast$js$typescript$TSModuleBlock_ts = {
		get tsModuleBlock() {
			return ___R$project$rome$$internal$ast$js$typescript$TSModuleBlock_ts$tsModuleBlock;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSModuleBlock_ts$tsModuleBlock = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSModuleBlock",
		{
			bindingKeys: {},
			visitorKeys: {
				body: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSModuleDeclaration.ts
const ___R$project$rome$$internal$ast$js$typescript$TSModuleDeclaration_ts = {
		get tsModuleDeclaration() {
			return ___R$project$rome$$internal$ast$js$typescript$TSModuleDeclaration_ts$tsModuleDeclaration;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSModuleDeclaration_ts$tsModuleDeclaration = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSModuleDeclaration",
		{
			bindingKeys: {},
			visitorKeys: {
				id: true,
				body: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSNamespaceExportDeclaration.ts
const ___R$project$rome$$internal$ast$js$typescript$TSNamespaceExportDeclaration_ts = {
		get tsNamespaceExportDeclaration() {
			return ___R$project$rome$$internal$ast$js$typescript$TSNamespaceExportDeclaration_ts$tsNamespaceExportDeclaration;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSNamespaceExportDeclaration_ts$tsNamespaceExportDeclaration = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSNamespaceExportDeclaration",
		{bindingKeys: {}, visitorKeys: {id: true}},
	);


  // project-rome/@internal/ast/js/typescript/TSNeverKeywordTypeAnnotation.ts
const ___R$project$rome$$internal$ast$js$typescript$TSNeverKeywordTypeAnnotation_ts = {
		get tsNeverKeywordTypeAnnotation() {
			return ___R$project$rome$$internal$ast$js$typescript$TSNeverKeywordTypeAnnotation_ts$tsNeverKeywordTypeAnnotation;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSNeverKeywordTypeAnnotation_ts$tsNeverKeywordTypeAnnotation = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSNeverKeywordTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSNonNullExpression.ts
const ___R$project$rome$$internal$ast$js$typescript$TSNonNullExpression_ts = {
		get tsNonNullExpression() {
			return ___R$project$rome$$internal$ast$js$typescript$TSNonNullExpression_ts$tsNonNullExpression;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSNonNullExpression_ts$tsNonNullExpression = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSNonNullExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				expression: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSNullKeywordTypeAnnotation.ts
const ___R$project$rome$$internal$ast$js$typescript$TSNullKeywordTypeAnnotation_ts = {
		get tsNullKeywordTypeAnnotation() {
			return ___R$project$rome$$internal$ast$js$typescript$TSNullKeywordTypeAnnotation_ts$tsNullKeywordTypeAnnotation;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSNullKeywordTypeAnnotation_ts$tsNullKeywordTypeAnnotation = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSNullKeywordTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSNumberKeywordTypeAnnotation.ts
const ___R$project$rome$$internal$ast$js$typescript$TSNumberKeywordTypeAnnotation_ts = {
		get tsNumberKeywordTypeAnnotation() {
			return ___R$project$rome$$internal$ast$js$typescript$TSNumberKeywordTypeAnnotation_ts$tsNumberKeywordTypeAnnotation;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSNumberKeywordTypeAnnotation_ts$tsNumberKeywordTypeAnnotation = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSNumberKeywordTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSNumericLiteralTypeAnnotation.ts
const ___R$project$rome$$internal$ast$js$typescript$TSNumericLiteralTypeAnnotation_ts = {
		get tsNumericLiteralTypeAnnotation() {
			return ___R$project$rome$$internal$ast$js$typescript$TSNumericLiteralTypeAnnotation_ts$tsNumericLiteralTypeAnnotation;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSNumericLiteralTypeAnnotation_ts$tsNumericLiteralTypeAnnotation = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSNumericLiteralTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSObjectKeywordTypeAnnotation.ts
const ___R$project$rome$$internal$ast$js$typescript$TSObjectKeywordTypeAnnotation_ts = {
		get tsObjectKeywordTypeAnnotation() {
			return ___R$project$rome$$internal$ast$js$typescript$TSObjectKeywordTypeAnnotation_ts$tsObjectKeywordTypeAnnotation;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSObjectKeywordTypeAnnotation_ts$tsObjectKeywordTypeAnnotation = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSObjectKeywordTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSObjectTypeAnnotation.ts
const ___R$project$rome$$internal$ast$js$typescript$TSObjectTypeAnnotation_ts = {
		get tsObjectTypeAnnotation() {
			return ___R$project$rome$$internal$ast$js$typescript$TSObjectTypeAnnotation_ts$tsObjectTypeAnnotation;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSObjectTypeAnnotation_ts$tsObjectTypeAnnotation = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSObjectTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {
				members: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSParenthesizedType.ts
const ___R$project$rome$$internal$ast$js$typescript$TSParenthesizedType_ts = {
		get tsParenthesizedType() {
			return ___R$project$rome$$internal$ast$js$typescript$TSParenthesizedType_ts$tsParenthesizedType;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSParenthesizedType_ts$tsParenthesizedType = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSParenthesizedType",
		{
			bindingKeys: {},
			visitorKeys: {
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSPropertySignature.ts
const ___R$project$rome$$internal$ast$js$typescript$TSPropertySignature_ts = {
		get tsPropertySignature() {
			return ___R$project$rome$$internal$ast$js$typescript$TSPropertySignature_ts$tsPropertySignature;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSPropertySignature_ts$tsPropertySignature = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSPropertySignature",
		{
			bindingKeys: {},
			visitorKeys: {
				key: true,
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSQualifiedName.ts
const ___R$project$rome$$internal$ast$js$typescript$TSQualifiedName_ts = {
		get tsQualifiedName() {
			return ___R$project$rome$$internal$ast$js$typescript$TSQualifiedName_ts$tsQualifiedName;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSQualifiedName_ts$tsQualifiedName = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSQualifiedName",
		{
			bindingKeys: {},
			visitorKeys: {
				left: true,
				right: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSSignatureDeclarationMeta.ts
const ___R$project$rome$$internal$ast$js$typescript$TSSignatureDeclarationMeta_ts = {
		get tsSignatureDeclarationMeta() {
			return ___R$project$rome$$internal$ast$js$typescript$TSSignatureDeclarationMeta_ts$tsSignatureDeclarationMeta;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSSignatureDeclarationMeta_ts$tsSignatureDeclarationMeta = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSSignatureDeclarationMeta",
		{
			bindingKeys: {},
			visitorKeys: {
				parameters: true,
				rest: true,
				typeParameters: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSStringKeywordTypeAnnotation.ts
const ___R$project$rome$$internal$ast$js$typescript$TSStringKeywordTypeAnnotation_ts = {
		get tsStringKeywordTypeAnnotation() {
			return ___R$project$rome$$internal$ast$js$typescript$TSStringKeywordTypeAnnotation_ts$tsStringKeywordTypeAnnotation;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSStringKeywordTypeAnnotation_ts$tsStringKeywordTypeAnnotation = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSStringKeywordTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSStringLiteralTypeAnnotation.ts
const ___R$project$rome$$internal$ast$js$typescript$TSStringLiteralTypeAnnotation_ts = {
		get tsStringLiteralTypeAnnotation() {
			return ___R$project$rome$$internal$ast$js$typescript$TSStringLiteralTypeAnnotation_ts$tsStringLiteralTypeAnnotation;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSStringLiteralTypeAnnotation_ts$tsStringLiteralTypeAnnotation = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSStringLiteralTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSSymbolKeywordTypeAnnotation.ts
const ___R$project$rome$$internal$ast$js$typescript$TSSymbolKeywordTypeAnnotation_ts = {
		get tsSymbolKeywordTypeAnnotation() {
			return ___R$project$rome$$internal$ast$js$typescript$TSSymbolKeywordTypeAnnotation_ts$tsSymbolKeywordTypeAnnotation;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSSymbolKeywordTypeAnnotation_ts$tsSymbolKeywordTypeAnnotation = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSSymbolKeywordTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSTemplateLiteralTypeAnnotation.ts
const ___R$project$rome$$internal$ast$js$typescript$TSTemplateLiteralTypeAnnotation_ts = {
		get tsTemplateLiteralTypeAnnotation() {
			return ___R$project$rome$$internal$ast$js$typescript$TSTemplateLiteralTypeAnnotation_ts$tsTemplateLiteralTypeAnnotation;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSTemplateLiteralTypeAnnotation_ts$tsTemplateLiteralTypeAnnotation = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSTemplateLiteralTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSThisType.ts
const ___R$project$rome$$internal$ast$js$typescript$TSThisType_ts = {
		get tsThisType() {
			return ___R$project$rome$$internal$ast$js$typescript$TSThisType_ts$tsThisType;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSThisType_ts$tsThisType = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSThisType",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSTupleElement.ts
const ___R$project$rome$$internal$ast$js$typescript$TSTupleElement_ts = {
		get tsTupleElement() {
			return ___R$project$rome$$internal$ast$js$typescript$TSTupleElement_ts$tsTupleElement;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSTupleElement_ts$tsTupleElement = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSTupleElement",
		{
			bindingKeys: {},
			visitorKeys: {
				name: true,
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSTupleType.ts
const ___R$project$rome$$internal$ast$js$typescript$TSTupleType_ts = {
		get tsTupleType() {
			return ___R$project$rome$$internal$ast$js$typescript$TSTupleType_ts$tsTupleType;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSTupleType_ts$tsTupleType = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSTupleType",
		{
			bindingKeys: {},
			visitorKeys: {
				elementTypes: true,
				rest: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSTypeAlias.ts
const ___R$project$rome$$internal$ast$js$typescript$TSTypeAlias_ts = {
		get tsTypeAlias() {
			return ___R$project$rome$$internal$ast$js$typescript$TSTypeAlias_ts$tsTypeAlias;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSTypeAlias_ts$tsTypeAlias = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSTypeAlias",
		{
			bindingKeys: {
				id: true,
			},
			visitorKeys: {
				id: true,
				typeParameters: true,
				right: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSTypeAssertion.ts
const ___R$project$rome$$internal$ast$js$typescript$TSTypeAssertion_ts = {
		get tsTypeAssertion() {
			return ___R$project$rome$$internal$ast$js$typescript$TSTypeAssertion_ts$tsTypeAssertion;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSTypeAssertion_ts$tsTypeAssertion = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSTypeAssertion",
		{
			bindingKeys: {},
			visitorKeys: {
				expression: true,
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSTypeOperator.ts
const ___R$project$rome$$internal$ast$js$typescript$TSTypeOperator_ts = {
		get tsTypeOperator() {
			return ___R$project$rome$$internal$ast$js$typescript$TSTypeOperator_ts$tsTypeOperator;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSTypeOperator_ts$tsTypeOperator = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSTypeOperator",
		{
			bindingKeys: {},
			visitorKeys: {
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSTypeParameter.ts
const ___R$project$rome$$internal$ast$js$typescript$TSTypeParameter_ts = {
		get tsTypeParameter() {
			return ___R$project$rome$$internal$ast$js$typescript$TSTypeParameter_ts$tsTypeParameter;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSTypeParameter_ts$tsTypeParameter = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSTypeParameter",
		{
			bindingKeys: {},
			visitorKeys: {
				default: true,
				constraint: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSTypeParameterDeclaration.ts
const ___R$project$rome$$internal$ast$js$typescript$TSTypeParameterDeclaration_ts = {
		get tsTypeParameterDeclaration() {
			return ___R$project$rome$$internal$ast$js$typescript$TSTypeParameterDeclaration_ts$tsTypeParameterDeclaration;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSTypeParameterDeclaration_ts$tsTypeParameterDeclaration = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSTypeParameterDeclaration",
		{
			bindingKeys: {},
			visitorKeys: {
				params: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSTypeParameterInstantiation.ts
const ___R$project$rome$$internal$ast$js$typescript$TSTypeParameterInstantiation_ts = {
		get tsTypeParameterInstantiation() {
			return ___R$project$rome$$internal$ast$js$typescript$TSTypeParameterInstantiation_ts$tsTypeParameterInstantiation;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSTypeParameterInstantiation_ts$tsTypeParameterInstantiation = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSTypeParameterInstantiation",
		{
			bindingKeys: {},
			visitorKeys: {
				params: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSTypePredicate.ts
const ___R$project$rome$$internal$ast$js$typescript$TSTypePredicate_ts = {
		get tsTypePredicate() {
			return ___R$project$rome$$internal$ast$js$typescript$TSTypePredicate_ts$tsTypePredicate;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSTypePredicate_ts$tsTypePredicate = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSTypePredicate",
		{
			bindingKeys: {},
			visitorKeys: {
				parameterName: true,
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSTypeQuery.ts
const ___R$project$rome$$internal$ast$js$typescript$TSTypeQuery_ts = {
		get tsTypeQuery() {
			return ___R$project$rome$$internal$ast$js$typescript$TSTypeQuery_ts$tsTypeQuery;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSTypeQuery_ts$tsTypeQuery = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSTypeQuery",
		{
			bindingKeys: {},
			visitorKeys: {
				exprName: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSTypeReference.ts
const ___R$project$rome$$internal$ast$js$typescript$TSTypeReference_ts = {
		get tsTypeReference() {
			return ___R$project$rome$$internal$ast$js$typescript$TSTypeReference_ts$tsTypeReference;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSTypeReference_ts$tsTypeReference = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSTypeReference",
		{
			bindingKeys: {},
			visitorKeys: {
				typeName: true,
				typeParameters: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSUndefinedKeywordTypeAnnotation.ts
const ___R$project$rome$$internal$ast$js$typescript$TSUndefinedKeywordTypeAnnotation_ts = {
		get tsUndefinedKeywordTypeAnnotation() {
			return ___R$project$rome$$internal$ast$js$typescript$TSUndefinedKeywordTypeAnnotation_ts$tsUndefinedKeywordTypeAnnotation;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSUndefinedKeywordTypeAnnotation_ts$tsUndefinedKeywordTypeAnnotation = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSUndefinedKeywordTypeAnnotation",
		{bindingKeys: {}, visitorKeys: {}},
	);


  // project-rome/@internal/ast/js/typescript/TSUnionTypeAnnotation.ts
const ___R$project$rome$$internal$ast$js$typescript$TSUnionTypeAnnotation_ts = {
		get tsUnionTypeAnnotation() {
			return ___R$project$rome$$internal$ast$js$typescript$TSUnionTypeAnnotation_ts$tsUnionTypeAnnotation;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSUnionTypeAnnotation_ts$tsUnionTypeAnnotation = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSUnionTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {
				types: true,
			},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSUnknownKeywordTypeAnnotation.ts
const ___R$project$rome$$internal$ast$js$typescript$TSUnknownKeywordTypeAnnotation_ts = {
		get tsUnknownKeywordTypeAnnotation() {
			return ___R$project$rome$$internal$ast$js$typescript$TSUnknownKeywordTypeAnnotation_ts$tsUnknownKeywordTypeAnnotation;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSUnknownKeywordTypeAnnotation_ts$tsUnknownKeywordTypeAnnotation = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSUnknownKeywordTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/js/typescript/TSVoidKeywordTypeAnnotation.ts
const ___R$project$rome$$internal$ast$js$typescript$TSVoidKeywordTypeAnnotation_ts = {
		get tsVoidKeywordTypeAnnotation() {
			return ___R$project$rome$$internal$ast$js$typescript$TSVoidKeywordTypeAnnotation_ts$tsVoidKeywordTypeAnnotation;
		},
	};
	const ___R$project$rome$$internal$ast$js$typescript$TSVoidKeywordTypeAnnotation_ts$tsVoidKeywordTypeAnnotation = ___R$project$rome$$internal$ast$utils_ts$createBuilder(
		"TSVoidKeywordTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@internal/ast/index.ts
const ___R$project$rome$$internal$ast$index_ts = {
		get bindingKeys() {
			return ___R$project$rome$$internal$ast$utils_ts$bindingKeys;
		},
		get nodeNames() {
			return ___R$project$rome$$internal$ast$utils_ts$nodeNames;
		},
		get visitorKeys() {
			return ___R$project$rome$$internal$ast$utils_ts$visitorKeys;
		},
	};
	Object.keys(___R$project$rome$$internal$ast$base_ts).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$base_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$constants_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$constants_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$html$unions_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$html$unions_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$unions_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$unions_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$markdown$unions_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$markdown$unions_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$unions_ts).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$unions_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$common$comments$CommentBlock_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$common$comments$CommentBlock_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$common$comments$CommentLine_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$common$comments$CommentLine_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$common$commit$CommitRoot_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$common$commit$CommitRoot_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$css$core$CSSAtRule_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$css$core$CSSAtRule_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$css$core$CSSBlock_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$css$core$CSSBlock_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$css$core$CSSDeclaration_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$css$core$CSSDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$css$core$CSSDimension_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$css$core$CSSDimension_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$css$core$CSSFunction_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$css$core$CSSFunction_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$css$core$CSSIdentifier_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$css$core$CSSIdentifier_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$css$core$CSSNumber_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$css$core$CSSNumber_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$css$core$CSSPercentage_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$css$core$CSSPercentage_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$css$core$CSSRaw_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$css$core$CSSRaw_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$css$core$CSSRoot_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$css$core$CSSRoot_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$css$core$CSSRule_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$css$core$CSSRule_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$html$attributes$HTMLAttribute_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$html$attributes$HTMLAttribute_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$html$tags$HTMLDoctypeTag_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$html$tags$HTMLDoctypeTag_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$html$tags$HTMLElement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$html$tags$HTMLElement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$html$core$HTMLIdentifier_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$html$core$HTMLIdentifier_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$html$core$HTMLRoot_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$html$core$HTMLRoot_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$html$core$HTMLString_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$html$core$HTMLString_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$html$core$HTMLText_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$html$core$HTMLText_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$temp$JSAmbiguousFlowTypeCastExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$temp$JSAmbiguousFlowTypeCastExpression_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$expressions$JSArrayExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$expressions$JSArrayExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$auxiliary$JSArrayHole_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$auxiliary$JSArrayHole_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$expressions$JSArrowFunctionExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$expressions$JSArrowFunctionExpression_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$patterns$JSAssignmentArrayPattern_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$patterns$JSAssignmentArrayPattern_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$patterns$JSAssignmentAssignmentPattern_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$patterns$JSAssignmentAssignmentPattern_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$expressions$JSAssignmentExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$expressions$JSAssignmentExpression_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$patterns$JSAssignmentIdentifier_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$patterns$JSAssignmentIdentifier_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$patterns$JSAssignmentObjectPattern_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$patterns$JSAssignmentObjectPattern_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$patterns$JSAssignmentObjectPatternProperty_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$patterns$JSAssignmentObjectPatternProperty_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$expressions$JSAwaitExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$expressions$JSAwaitExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$literals$JSBigIntLiteral_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$literals$JSBigIntLiteral_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$expressions$JSBinaryExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$expressions$JSBinaryExpression_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$patterns$JSBindingArrayPattern_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$patterns$JSBindingArrayPattern_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$patterns$JSBindingAssignmentPattern_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$patterns$JSBindingAssignmentPattern_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$patterns$JSBindingIdentifier_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$patterns$JSBindingIdentifier_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$patterns$JSBindingObjectPattern_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$patterns$JSBindingObjectPattern_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$patterns$JSBindingObjectPatternProperty_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$patterns$JSBindingObjectPatternProperty_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$statements$JSBlockStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$statements$JSBlockStatement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$literals$JSBooleanLiteral_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$literals$JSBooleanLiteral_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$statements$JSBreakStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$statements$JSBreakStatement_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$expressions$JSCallExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$expressions$JSCallExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$auxiliary$JSCatchClause_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$auxiliary$JSCatchClause_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$classes$JSClassDeclaration_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$classes$JSClassDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$classes$JSClassExpression_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$classes$JSClassExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$classes$JSClassHead_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$classes$JSClassHead_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$classes$JSClassMethod_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$classes$JSClassMethod_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$classes$JSClassPrivateMethod_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$classes$JSClassPrivateMethod_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$classes$JSClassPrivateProperty_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$classes$JSClassPrivateProperty_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$classes$JSClassProperty_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$classes$JSClassProperty_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$classes$JSClassPropertyMeta_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$classes$JSClassPropertyMeta_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$auxiliary$JSComputedMemberProperty_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$auxiliary$JSComputedMemberProperty_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$objects$JSComputedPropertyKey_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$objects$JSComputedPropertyKey_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$expressions$JSConditionalExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$expressions$JSConditionalExpression_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$statements$JSContinueStatement_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$statements$JSContinueStatement_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$statements$JSDebuggerStatement_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$statements$JSDebuggerStatement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$core$JSDirective_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$core$JSDirective_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$expressions$JSDoExpression_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$expressions$JSDoExpression_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$statements$JSDoWhileStatement_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$statements$JSDoWhileStatement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$statements$JSEmptyStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$statements$JSEmptyStatement_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$modules$JSExportAllDeclaration_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$modules$JSExportAllDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$modules$JSExportDefaultDeclaration_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$modules$JSExportDefaultDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$modules$JSExportDefaultSpecifier_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$modules$JSExportDefaultSpecifier_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$modules$JSExportExternalDeclaration_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$modules$JSExportExternalDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$modules$JSExportExternalSpecifier_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$modules$JSExportExternalSpecifier_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$modules$JSExportLocalDeclaration_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$modules$JSExportLocalDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$modules$JSExportLocalSpecifier_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$modules$JSExportLocalSpecifier_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$modules$JSExportNamespaceSpecifier_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$modules$JSExportNamespaceSpecifier_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$statements$JSExpressionStatement_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$statements$JSExpressionStatement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$statements$JSForInStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$statements$JSForInStatement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$statements$JSForOfStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$statements$JSForOfStatement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$statements$JSForStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$statements$JSForStatement_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$statements$JSFunctionDeclaration_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$statements$JSFunctionDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$expressions$JSFunctionExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$expressions$JSFunctionExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$auxiliary$JSFunctionHead_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$auxiliary$JSFunctionHead_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$auxiliary$JSIdentifier_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$auxiliary$JSIdentifier_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$statements$JSIfStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$statements$JSIfStatement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$modules$JSImportCall_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$modules$JSImportCall_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$modules$JSImportDeclaration_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$modules$JSImportDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$modules$JSImportDefaultSpecifier_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$modules$JSImportDefaultSpecifier_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$modules$JSImportNamespaceSpecifier_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$modules$JSImportNamespaceSpecifier_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$modules$JSImportSpecifier_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$modules$JSImportSpecifier_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$modules$JSImportSpecifierLocal_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$modules$JSImportSpecifierLocal_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$core$JSInterpreterDirective_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$core$JSInterpreterDirective_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$statements$JSLabeledStatement_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$statements$JSLabeledStatement_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$expressions$JSLogicalExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$expressions$JSLogicalExpression_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$expressions$JSMemberExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$expressions$JSMemberExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$expressions$JSMetaProperty_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$expressions$JSMetaProperty_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$expressions$JSNewExpression_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$expressions$JSNewExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$literals$JSNullLiteral_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$literals$JSNullLiteral_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$literals$JSNumericLiteral_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$literals$JSNumericLiteral_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$objects$JSObjectExpression_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$objects$JSObjectExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$objects$JSObjectMethod_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$objects$JSObjectMethod_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$objects$JSObjectProperty_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$objects$JSObjectProperty_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$expressions$JSOptionalCallExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$expressions$JSOptionalCallExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$patterns$JSPatternMeta_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$patterns$JSPatternMeta_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$classes$JSPrivateName_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$classes$JSPrivateName_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$expressions$JSReferenceIdentifier_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$expressions$JSReferenceIdentifier_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$regex$JSRegExpAlternation_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$regex$JSRegExpAlternation_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$regex$JSRegExpAnyCharacter_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$regex$JSRegExpAnyCharacter_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$regex$JSRegExpCharacter_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$regex$JSRegExpCharacter_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$regex$JSRegExpCharSet_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$regex$JSRegExpCharSet_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$regex$JSRegExpCharSetRange_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$regex$JSRegExpCharSetRange_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$regex$JSRegExpControlCharacter_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$regex$JSRegExpControlCharacter_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$regex$JSRegExpDigitCharacter_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$regex$JSRegExpDigitCharacter_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$regex$JSRegExpEndCharacter_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$regex$JSRegExpEndCharacter_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$regex$JSRegExpGroupCapture_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$regex$JSRegExpGroupCapture_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$regex$JSRegExpGroupNonCapture_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$regex$JSRegExpGroupNonCapture_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$literals$JSRegExpLiteral_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$literals$JSRegExpLiteral_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$regex$JSRegExpNamedBackReference_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$regex$JSRegExpNamedBackReference_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$regex$JSRegExpNonDigitCharacter_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$regex$JSRegExpNonDigitCharacter_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$regex$JSRegExpNonWhiteSpaceCharacter_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$regex$JSRegExpNonWhiteSpaceCharacter_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$regex$JSRegExpNonWordBoundaryCharacter_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$regex$JSRegExpNonWordBoundaryCharacter_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$regex$JSRegExpNonWordCharacter_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$regex$JSRegExpNonWordCharacter_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$regex$JSRegExpNumericBackReference_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$regex$JSRegExpNumericBackReference_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$regex$JSRegExpQuantified_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$regex$JSRegExpQuantified_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$regex$JSRegExpStartCharacter_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$regex$JSRegExpStartCharacter_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$regex$JSRegExpSubExpression_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$regex$JSRegExpSubExpression_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$regex$JSRegExpWhiteSpaceCharacter_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$regex$JSRegExpWhiteSpaceCharacter_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$regex$JSRegExpWordBoundaryCharacter_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$regex$JSRegExpWordBoundaryCharacter_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$regex$JSRegExpWordCharacter_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$regex$JSRegExpWordCharacter_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$statements$JSReturnStatement_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$statements$JSReturnStatement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$core$JSRoot_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$core$JSRoot_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$expressions$JSSequenceExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$expressions$JSSequenceExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$auxiliary$JSSpreadElement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$auxiliary$JSSpreadElement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$objects$JSSpreadProperty_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$objects$JSSpreadProperty_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$auxiliary$JSStaticMemberProperty_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$auxiliary$JSStaticMemberProperty_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$objects$JSStaticPropertyKey_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$objects$JSStaticPropertyKey_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$literals$JSStringLiteral_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$literals$JSStringLiteral_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$expressions$JSSuper_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$expressions$JSSuper_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$auxiliary$JSSwitchCase_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$auxiliary$JSSwitchCase_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$statements$JSSwitchStatement_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$statements$JSSwitchStatement_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$expressions$JSTaggedTemplateExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$expressions$JSTaggedTemplateExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$auxiliary$JSTemplateElement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$auxiliary$JSTemplateElement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$literals$JSTemplateLiteral_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$literals$JSTemplateLiteral_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$expressions$JSThisExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$expressions$JSThisExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$statements$JSThrowStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$statements$JSThrowStatement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$statements$JSTryStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$statements$JSTryStatement_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$expressions$JSUnaryExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$expressions$JSUnaryExpression_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$expressions$JSUpdateExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$expressions$JSUpdateExpression_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclaration_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$statements$JSVariableDeclarationStatement_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$statements$JSVariableDeclarationStatement_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclarator_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclarator_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$statements$JSWhileStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$statements$JSWhileStatement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$statements$JSWithStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$statements$JSWithStatement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$jsx$JSXAttribute_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$jsx$JSXAttribute_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$jsx$JSXElement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$jsx$JSXElement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$jsx$JSXEmptyExpression_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$jsx$JSXEmptyExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$jsx$JSXExpressionContainer_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$jsx$JSXExpressionContainer_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$jsx$JSXFragment_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$jsx$JSXFragment_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$jsx$JSXIdentifier_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$jsx$JSXIdentifier_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$jsx$JSXMemberExpression_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$jsx$JSXMemberExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$jsx$JSXNamespacedName_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$jsx$JSXNamespacedName_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$jsx$JSXReferenceIdentifier_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$jsx$JSXReferenceIdentifier_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$jsx$JSXSpreadAttribute_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$jsx$JSXSpreadAttribute_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$jsx$JSXSpreadChild_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$jsx$JSXSpreadChild_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$jsx$JSXText_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$jsx$JSXText_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$expressions$JSYieldExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$expressions$JSYieldExpression_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$markdown$inline$MarkdownAutomaticLinkInline_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$markdown$inline$MarkdownAutomaticLinkInline_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$markdown$inline$MarkdownBoldInline_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$markdown$inline$MarkdownBoldInline_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$markdown$blocks$MarkdownCodeBlock_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$markdown$blocks$MarkdownCodeBlock_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$markdown$inline$MarkdownCodeInline_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$markdown$inline$MarkdownCodeInline_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$markdown$inline$MarkdownDefinitionInline_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$markdown$inline$MarkdownDefinitionInline_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$markdown$blocks$MarkdownDividerBlock_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$markdown$blocks$MarkdownDividerBlock_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$markdown$inline$MarkdownEmphasisInline_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$markdown$inline$MarkdownEmphasisInline_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$markdown$blocks$MarkdownHeadingBlock_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$markdown$blocks$MarkdownHeadingBlock_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$markdown$inline$MarkdownImageInline_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$markdown$inline$MarkdownImageInline_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$markdown$inline$MarkdownLinkInline_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$markdown$inline$MarkdownLinkInline_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$markdown$blocks$MarkdownListBlock_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$markdown$blocks$MarkdownListBlock_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$markdown$core$MarkdownListItem_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$markdown$core$MarkdownListItem_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$markdown$core$MarkdownParagraph_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$markdown$core$MarkdownParagraph_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$markdown$blocks$MarkdownQuoteBlock_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$markdown$blocks$MarkdownQuoteBlock_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$markdown$core$MarkdownRoot_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$markdown$core$MarkdownRoot_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$markdown$core$MarkdownText_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$markdown$core$MarkdownText_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$common$core$MockParent_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$common$core$MockParent_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSAnyKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSAnyKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$typescript$TSArrayType_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSArrayType_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$typescript$TSAsExpression_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSAsExpression_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSAssignmentAsExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSAssignmentAsExpression_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSAssignmentNonNullExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSAssignmentNonNullExpression_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSAssignmentTypeAssertion_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSAssignmentTypeAssertion_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSBigIntKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSBigIntKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSBigIntLiteralTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSBigIntLiteralTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSBooleanKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSBooleanKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSBooleanLiteralTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSBooleanLiteralTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSCallSignatureDeclaration_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSCallSignatureDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSConditionalType_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSConditionalType_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$typescript$TSConstKeyword_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSConstKeyword_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSConstructorType_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSConstructorType_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSConstructSignatureDeclaration_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSConstructSignatureDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSDeclareFunction_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSDeclareFunction_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$typescript$TSDeclareMethod_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSDeclareMethod_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSEmptyKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSEmptyKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSEnumDeclaration_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSEnumDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$typescript$TSEnumMember_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSEnumMember_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSExportAssignment_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSExportAssignment_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSExpressionWithTypeArguments_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSExpressionWithTypeArguments_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSExternalModuleReference_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSExternalModuleReference_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$typescript$TSFunctionType_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSFunctionType_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSImportEqualsDeclaration_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSImportEqualsDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$typescript$TSImportType_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSImportType_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSIndexedAccessType_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSIndexedAccessType_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$typescript$TSIndexSignature_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSIndexSignature_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$typescript$TSInferType_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSInferType_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$typescript$TSInterfaceBody_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSInterfaceBody_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSInterfaceDeclaration_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSInterfaceDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSIntersectionTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSIntersectionTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$typescript$TSMappedType_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSMappedType_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSMethodSignature_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSMethodSignature_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSMixedKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSMixedKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$typescript$TSModuleBlock_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSModuleBlock_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSModuleDeclaration_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSModuleDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSNamespaceExportDeclaration_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSNamespaceExportDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSNeverKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSNeverKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSNonNullExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSNonNullExpression_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSNullKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSNullKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSNumberKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSNumberKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSNumericLiteralTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSNumericLiteralTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSObjectKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSObjectKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSObjectTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSObjectTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSParenthesizedType_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSParenthesizedType_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSPropertySignature_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSPropertySignature_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$typescript$TSQualifiedName_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSQualifiedName_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSSignatureDeclarationMeta_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSSignatureDeclarationMeta_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSStringKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSStringKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSStringLiteralTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSStringLiteralTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSSymbolKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSSymbolKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSTemplateLiteralTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSTemplateLiteralTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$typescript$TSThisType_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSThisType_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$typescript$TSTupleElement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSTupleElement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$typescript$TSTupleType_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSTupleType_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$typescript$TSTypeAlias_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSTypeAlias_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$typescript$TSTypeAssertion_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSTypeAssertion_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$typescript$TSTypeOperator_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSTypeOperator_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$typescript$TSTypeParameter_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSTypeParameter_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSTypeParameterDeclaration_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSTypeParameterDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSTypeParameterInstantiation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSTypeParameterInstantiation_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$typescript$TSTypePredicate_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSTypePredicate_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$typescript$TSTypeQuery_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSTypeQuery_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$ast$js$typescript$TSTypeReference_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSTypeReference_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSUndefinedKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSUndefinedKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSUnionTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSUnionTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSUnknownKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSUnknownKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$internal$ast$js$typescript$TSVoidKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$ast$js$typescript$TSVoidKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});


  // project-rome/@internal/js-ast-utils/getBindingIdentifiers.ts
function ___R$project$rome$$internal$js$ast$utils$getBindingIdentifiers_ts$getBindingIdentifiers(
		node,
	) {
		const ids = [];
		let queue = Array.isArray(node) ? [...node] : [node];

		while (queue.length) {
			const node = queue.pop();
			if (node === undefined) {
				continue;
			}

			if (node.type === "JSBindingIdentifier") {
				ids.push(node);
				continue;
			}

			const keys = ___R$project$rome$$internal$ast$utils_ts$bindingKeys.get(
				node.type,
			);
			if (keys === undefined) {
				continue;
			}

			for (const key of keys) {
				// rome-ignore lint/ts/noExplicitAny: future cleanup
				const val = (node)[key];
				if (val === undefined) {
					continue;
				} else if (Array.isArray(val)) {
					queue = queue.concat(val);
				} else {
					queue.push(val);
				}
			}
		}

		return ids;
	}


  // project-rome/@internal/js-ast-utils/getCompletionRecords.ts
function ___R$$priv$project$rome$$internal$js$ast$utils$getCompletionRecords_ts$getIfCompletionRecords(
		node,
		parent,
		key,
	) {
		if (node === undefined) {
			return [
				{
					type: "INVALID",
					description: "empty " + key,
					node: parent,
				},
			];
		} else {
			return ___R$project$rome$$internal$js$ast$utils$getCompletionRecords_ts$getCompletionRecords(
				node,
			);
		}
	}

	function ___R$$priv$project$rome$$internal$js$ast$utils$getCompletionRecords_ts$getLastCompletionRecordFromNodes(
		nodes,
	) {
		// Get the last node to produce records
		for (let i = nodes.length - 1; i >= 0; i--) {
			const node = nodes[i];
			const records = ___R$$priv$project$rome$$internal$js$ast$utils$getCompletionRecords_ts$_getCompletionRecords(
				node,
			);
			if (records !== undefined) {
				return records;
			}
		}
		return undefined;
	}

	function ___R$$priv$project$rome$$internal$js$ast$utils$getCompletionRecords_ts$_getCompletionRecords(
		node,
	) {
		if (node.type === "JSBlockStatement") {
			const records = ___R$$priv$project$rome$$internal$js$ast$utils$getCompletionRecords_ts$getLastCompletionRecordFromNodes(
				node.body,
			);
			if (records !== undefined) {
				return records;
			}

			return [
				{
					type: "INVALID",
					description: "empty block",
					node,
				},
			];
		}

		if (node.type === "JSSwitchStatement") {
			for (const caseNode of node.cases) {
				if (caseNode.test === undefined) {
					const records = ___R$$priv$project$rome$$internal$js$ast$utils$getCompletionRecords_ts$getLastCompletionRecordFromNodes(
						caseNode.consequent,
					);
					if (records === undefined) {
						return [
							{
								type: "INVALID",
								description: "default switch clause with no completions",
								node: caseNode,
							},
						];
					} else {
						return records;
					}
				}
			}

			return [
				{
					type: "INVALID",
					description: "switch with no default clause",
					node,
				},
			];
		}

		if (node.type === "JSIfStatement") {
			return [
				...___R$$priv$project$rome$$internal$js$ast$utils$getCompletionRecords_ts$getIfCompletionRecords(
					node.consequent,
					node,
					"consequent",
				),
				...___R$$priv$project$rome$$internal$js$ast$utils$getCompletionRecords_ts$getIfCompletionRecords(
					node.alternate,
					node,
					"alternate",
				),
			];
		}

		if (
			node.type === "JSReturnStatement" ||
			node.type === "JSContinueStatement" ||
			node.type === "JSBreakStatement" ||
			node.type === "JSThrowStatement"
		) {
			return [
				{
					type: "COMPLETION",
					node,
				},
			];
		}

		return undefined;
	}

	function ___R$project$rome$$internal$js$ast$utils$getCompletionRecords_ts$getCompletionRecords(
		node,
	) {
		const records = ___R$$priv$project$rome$$internal$js$ast$utils$getCompletionRecords_ts$_getCompletionRecords(
			node,
		);
		if (records === undefined) {
			return [
				{
					type: "INVALID",
					description: "invalid node",
					node,
				},
			];
		} else {
			return records;
		}
	}


  // project-rome/@internal/js-ast-utils/getImportSpecifiers.ts
function ___R$project$rome$$internal$js$ast$utils$getImportSpecifiers_ts$getImportSpecifiers(
		node,
	) {
		let specifiers = [];

		if (node.defaultSpecifier !== undefined) {
			specifiers.push(node.defaultSpecifier);
		}

		if (node.namespaceSpecifier !== undefined) {
			specifiers.push(node.namespaceSpecifier);
		}

		specifiers = specifiers.concat(node.namedSpecifiers);

		return specifiers;
	}


  // project-rome/@internal/js-ast-utils/getPrecedence.ts
const ___R$$priv$project$rome$$internal$js$ast$utils$getPrecedence_ts$PRECEDENCE = {
		"||": 0,
		"&&": 1,
		"??": 1,
		"|": 2,
		"^": 3,
		"&": 4,
		"==": 5,
		"===": 5,
		"!=": 5,
		"!==": 5,
		"<": 6,
		">": 6,
		"<=": 6,
		">=": 6,
		in: 6,
		instanceof: 6,
		">>": 7,
		"<<": 7,
		">>>": 7,
		"+": 8,
		"-": 8,
		"*": 9,
		"/": 9,
		"%": 9,
		"**": 10,
	};

	function ___R$project$rome$$internal$js$ast$utils$getPrecedence_ts$getPrecedence(
		operator,
	) {
		return ___R$$priv$project$rome$$internal$js$ast$utils$getPrecedence_ts$PRECEDENCE[operator];
	}


  // project-rome/@internal/js-ast-utils/getRequireSource.ts
function ___R$project$rome$$internal$js$ast$utils$getRequireSource_ts$getRequireSource(
		node,
		scope,
		allowStaticMember = false,
	) {
		if (node === undefined) {
			return undefined;
		}

		if (
			allowStaticMember &&
			node.type === "JSMemberExpression" &&
			node.property.type === "JSStaticMemberProperty"
		) {
			node = node.object;
		}

		if (node.type !== "JSCallExpression") {
			return undefined;
		}

		const {arguments: args, callee} = node;

		const [firstArg] = args;
		if (args.length !== 1 || firstArg.type !== "JSStringLiteral") {
			return undefined;
		}

		const validRequireCallee =
			callee.type === "JSReferenceIdentifier" &&
			callee.name === "require" &&
			scope.getBinding("require") === undefined;

		const validRomeRequreCallee =
			(___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
				callee,
				"Rome.requireDefault",
			) ||
			___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
				callee,
				"Rome.requireNamespace",
			)) &&
			scope.getBinding("Rome") === undefined;

		if (validRequireCallee || validRomeRequreCallee) {
			return firstArg.value;
		}

		return undefined;
	}


  // project-rome/@internal/js-ast-utils/hasPotentialSideEffects.ts
function ___R$project$rome$$internal$js$ast$utils$hasPotentialSideEffects_ts$hasPotentialSideEffects(
		node,
		scope,
	) {
		if (node === undefined) {
			return false;
		}

		switch (node.type) {
			case "JSExportLocalDeclaration":
				if (node.declaration === undefined) {
					return false;
				} else {
					return ___R$project$rome$$internal$js$ast$utils$hasPotentialSideEffects_ts$hasPotentialSideEffects(
						node.declaration,
						scope,
					);
				}

			case "JSExportExternalDeclaration":
				return true;

			case "JSFunctionExpression":
			case "JSFunctionDeclaration":
				return false;

			case "JSClassDeclaration":
				return (
					node.meta.superClass !== undefined ||
					!___R$project$rome$$internal$js$ast$utils$hasPotentialSideEffects_ts$hasPotentialSideEffects(
						node.meta.superClass,
						scope,
					)
				);

			case "JSReferenceIdentifier":
				// Variables that aren't in scope and aren't registered globals could trigger a getter
				// Unlikely but let's aim for 100% correctness
				return (
					scope.getRootScope().isGlobal(node.name) ||
					scope.hasBinding(node.name)
				);

			case "JSVariableDeclaration": {
				for (const declarator of node.declarations) {
					if (
						___R$project$rome$$internal$js$ast$utils$hasPotentialSideEffects_ts$hasPotentialSideEffects(
							declarator,
							scope,
						)
					) {
						return true;
					}
				}
				return false;
			}

			case "JSVariableDeclarator":
				return (
					___R$project$rome$$internal$js$ast$utils$hasPotentialSideEffects_ts$hasPotentialSideEffects(
						node.id,
						scope,
					) ||
					___R$project$rome$$internal$js$ast$utils$hasPotentialSideEffects_ts$hasPotentialSideEffects(
						node.init,
						scope,
					)
				);

			case "JSSpreadProperty":
			case "JSSpreadElement":
				return ___R$project$rome$$internal$js$ast$utils$hasPotentialSideEffects_ts$hasPotentialSideEffects(
					node.argument,
					scope,
				);

			case "JSBindingAssignmentPattern":
				return ___R$project$rome$$internal$js$ast$utils$hasPotentialSideEffects_ts$hasPotentialSideEffects(
					node.right,
					scope,
				);

			case "JSObjectExpression":
			case "JSBindingObjectPattern": {
				for (const prop of node.properties) {
					if (
						___R$project$rome$$internal$js$ast$utils$hasPotentialSideEffects_ts$hasPotentialSideEffects(
							prop,
							scope,
						)
					) {
						return true;
					}
				}
				return false;
			}

			case "JSStaticPropertyKey":
				return false;

			case "JSComputedPropertyKey":
				return ___R$project$rome$$internal$js$ast$utils$hasPotentialSideEffects_ts$hasPotentialSideEffects(
					node.value,
					scope,
				);

			case "JSBindingObjectPatternProperty":
			case "JSObjectProperty":
				return (
					___R$project$rome$$internal$js$ast$utils$hasPotentialSideEffects_ts$hasPotentialSideEffects(
						node.key,
						scope,
					) ||
					___R$project$rome$$internal$js$ast$utils$hasPotentialSideEffects_ts$hasPotentialSideEffects(
						node.value,
						scope,
					)
				);

			case "JSBindingArrayPattern":
			case "JSArrayExpression": {
				for (const elem of node.elements) {
					if (
						___R$project$rome$$internal$js$ast$utils$hasPotentialSideEffects_ts$hasPotentialSideEffects(
							elem,
							scope,
						)
					) {
						return true;
					}
				}
				return false;
			}

			case "JSStringLiteral":
			case "JSNumericLiteral":
			case "JSBooleanLiteral":
			case "JSNullLiteral":
				return false;
		}

		return true;
	}


  // project-rome/@internal/js-ast-utils/inheritLoc.ts
function ___R$project$rome$$internal$js$ast$utils$inheritLoc_ts$inheritLoc(
		node,
		name,
	) {
		const {loc} = node;
		if (loc === undefined) {
			return undefined;
		}

		// Inherit new name if specified
		if (name !== undefined) {
			return Object.assign({}, loc, {identifierName: name});
		}

		// Don't infer a name if it already has one
		if (loc.identifierName !== undefined) {
			return loc;
		}

		// If this location has no identifierName and we're an JSIdentifier then inherit it

		// TODO maybe handle other identifier types? JSXIdentifier etc?
		if (node.type === "JSIdentifier") {
			return Object.assign({}, loc, {identifierName: node.name});
		}

		return loc;
	}


  // project-rome/@internal/js-ast-utils/isBinary.ts
function ___R$project$rome$$internal$js$ast$utils$isBinary_ts$isBinary(node) {
		if (node === undefined) {
			return false;
		}

		switch (node.type) {
			case "JSBinaryExpression":
			case "JSLogicalExpression":
				return true;

			default:
				return false;
		}
	}


  // project-rome/@internal/js-ast-utils/isConditional.ts
function ___R$project$rome$$internal$js$ast$utils$isConditional_ts$isConditional(
		node,
	) {
		if (node === undefined) {
			return false;
		}

		switch (node.type) {
			case "JSConditionalExpression":
			case "JSIfStatement":
				return true;

			case "JSLogicalExpression":
				return true;

			default:
				return false;
		}
	}


  // project-rome/@internal/js-ast-utils/isDeclaration.ts
function ___R$project$rome$$internal$js$ast$utils$isDeclaration_ts$isDeclaration(
		node,
	) {
		if (node === undefined) {
			return false;
		}

		switch (node.type) {
			case "JSFunctionDeclaration":
			case "JSClassDeclaration":
			case "JSExportAllDeclaration":
			case "JSExportDefaultDeclaration":
			case "JSExportLocalDeclaration":
			case "JSImportDeclaration":
			case "JSVariableDeclarationStatement":
			case "JSExportExternalDeclaration":
			case "TSDeclareFunction":
			case "TSEnumDeclaration":
			case "TSTypeAlias":
			case "TSExportAssignment":
			case "TSImportEqualsDeclaration":
			case "TSInterfaceDeclaration":
			case "TSModuleDeclaration":
			case "TSNamespaceExportDeclaration": {
				const declaration = node;
				declaration;
				return true;
			}

			default: {
				const notDeclaration = node;
				notDeclaration;
				return false;
			}
		}
	}


  // project-rome/@internal/js-ast-utils/isFor.ts
function ___R$project$rome$$internal$js$ast$utils$isFor_ts$isFor(node) {
		if (node === undefined) {
			return false;
		}

		switch (node.type) {
			case "JSForStatement":
			case "JSForInStatement":
			case "JSForOfStatement":
				return true;

			default:
				return false;
		}
	}


  // project-rome/@internal/js-ast-utils/isFunctionNode.ts
function ___R$project$rome$$internal$js$ast$utils$isFunctionNode_ts$isFunctionNode(
		node,
	) {
		return (
			node.type === "JSFunctionDeclaration" ||
			node.type === "JSFunctionExpression" ||
			node.type === "JSObjectMethod" ||
			node.type === "JSArrowFunctionExpression" ||
			node.type === "JSClassMethod"
		);
	}


  // project-rome/@internal/js-ast-utils/isTypeNode.ts
function ___R$project$rome$$internal$js$ast$utils$isTypeNode_ts$isTypeNode(node) {
		if (
			node.type.startsWith("Flow") ||
			node.type.startsWith("TS") ||
			node.type.endsWith("TypeAnnotation")
		) {
			return true;
		} else if (node.type === "JSImportDeclaration") {
			return node.importKind === "type" || node.importKind === "typeof";
		} else if (
			node.type === "JSExportDefaultDeclaration" ||
			node.type === "JSExportLocalDeclaration" ||
			node.type === "JSExportAllDeclaration"
		) {
			return node.exportKind === "type";
		} else {
			return false;
		}
	}


  // project-rome/@internal/js-ast-utils/isTypeExpressionWrapperNode.ts
function ___R$project$rome$$internal$js$ast$utils$isTypeExpressionWrapperNode_ts$isTypeExpressionWrapperNode(
		node,
	) {
		return (
			node.type === "TSAsExpression" ||
			node.type === "TSTypeAssertion" ||
			node.type === "TSNonNullExpression"
		);
	}


  // project-rome/@internal/js-ast-utils/isInTypeAnnotation.ts
// Is this honestly the best heuristics?
	function ___R$$priv$project$rome$$internal$js$ast$utils$isInTypeAnnotation_ts$getTypeNode(
		path,
	) {
		const {parent, parentPath} = path;
		if (parent === undefined || parentPath === undefined) {
			return undefined;
		}

		if (
			___R$project$rome$$internal$js$ast$utils$isTypeNode_ts$isTypeNode(parent)
		) {
			return parent;
		}

		if (
			___R$project$rome$$internal$js$ast$utils$isTypeNode_ts$isTypeNode(
				parentPath.parent,
			)
		) {
			return parentPath.parent;
		}

		return undefined;
	}

	function ___R$project$rome$$internal$js$ast$utils$isInTypeAnnotation_ts$isInTypeAnnotation(
		path,
	) {
		const match = ___R$$priv$project$rome$$internal$js$ast$utils$isInTypeAnnotation_ts$getTypeNode(
			path,
		);
		if (match === undefined) {
			return false;
		}

		return !___R$project$rome$$internal$js$ast$utils$isTypeExpressionWrapperNode_ts$isTypeExpressionWrapperNode(
			match,
		);
	}


  // project-rome/@internal/js-ast-utils/isNodeLike.ts
function ___R$project$rome$$internal$js$ast$utils$isNodeLike_ts$isNodeLike(node) {
		if (node == null) {
			return false;
		} else {
			return (
				___R$project$rome$$internal$typescript$helpers$index_ts$isPlainObject(
					node,
				) && typeof node.type === "string"
			);
		}
	}


  // project-rome/@internal/js-ast-utils/isStatement.ts
function ___R$project$rome$$internal$js$ast$utils$isStatement_ts$isStatement(
		node,
	) {
		if (node === undefined) {
			return false;
		}

		if (
			___R$project$rome$$internal$js$ast$utils$isDeclaration_ts$isDeclaration(
				node,
			)
		) {
			return true;
		}

		switch (node.type) {
			case "JSBlockStatement":
			case "JSBreakStatement":
			case "JSContinueStatement":
			case "JSDebuggerStatement":
			case "JSDoWhileStatement":
			case "JSEmptyStatement":
			case "JSExpressionStatement":
			case "JSForInStatement":
			case "JSForStatement":
			case "JSIfStatement":
			case "JSLabeledStatement":
			case "JSReturnStatement":
			case "JSSwitchStatement":
			case "JSThrowStatement":
			case "JSTryStatement":
			case "JSWhileStatement":
			case "JSWithStatement":
			case "JSForOfStatement": {
				const statement = node;
				statement;
				return true;
			}

			default: {
				// Assert that all statements were handled
				const notStatement = node;
				notStatement;
				return false;
			}
		}
	}


  // project-rome/@internal/js-ast-utils/isUnaryLike.ts
function ___R$project$rome$$internal$js$ast$utils$isUnaryLike_ts$isUnaryLike(
		node,
	) {
		if (node === undefined) {
			return false;
		}

		switch (node.type) {
			case "JSUnaryExpression":
			case "JSSpreadElement":
			case "JSSpreadProperty":
				return true;

			default:
				return false;
		}
	}


  // project-rome/@internal/js-parser-utils/identifier.ts
const ___R$project$rome$$internal$js$parser$utils$identifier_ts = {
		get keywordRelationalOperator() {
			return ___R$project$rome$$internal$js$parser$utils$identifier_ts$keywordRelationalOperator;
		},
		isES2015ReservedWord: ___R$project$rome$$internal$js$parser$utils$identifier_ts$isES2015ReservedWord,
		isReservedWord: ___R$project$rome$$internal$js$parser$utils$identifier_ts$isReservedWord,
		isStrictReservedWord: ___R$project$rome$$internal$js$parser$utils$identifier_ts$isStrictReservedWord,
		isStrictBindReservedWord: ___R$project$rome$$internal$js$parser$utils$identifier_ts$isStrictBindReservedWord,
		isKeyword: ___R$project$rome$$internal$js$parser$utils$identifier_ts$isKeyword,
		getFullCharCodeAt: ___R$project$rome$$internal$js$parser$utils$identifier_ts$getFullCharCodeAt,
		isIdentifierStart: ___R$project$rome$$internal$js$parser$utils$identifier_ts$isIdentifierStart,
		isIdentifierChar: ___R$project$rome$$internal$js$parser$utils$identifier_ts$isIdentifierChar,
	};
	const ___R$project$rome$$internal$js$parser$utils$identifier_ts$keywordRelationalOperator = /^in(stanceof)?$/;

	function ___R$project$rome$$internal$js$parser$utils$identifier_ts$isES2015ReservedWord(
		word,
	) {
		return word === "enum" || word === "await";
	}

	function ___R$project$rome$$internal$js$parser$utils$identifier_ts$isReservedWord(
		word,
		inModule,
	) {
		return (inModule && word === "await") || word === "enum";
	}

	const ___R$$priv$project$rome$$internal$js$parser$utils$identifier_ts$reservedWordsStrict = new Set([
		"implements",
		"interface",
		"let",
		"package",
		"private",
		"protected",
		"public",
		"static",
		"yield",
	]);
	function ___R$project$rome$$internal$js$parser$utils$identifier_ts$isStrictReservedWord(
		word,
		inModule,
	) {
		return (
			___R$project$rome$$internal$js$parser$utils$identifier_ts$isReservedWord(
				word,
				inModule,
			) ||
			___R$$priv$project$rome$$internal$js$parser$utils$identifier_ts$reservedWordsStrict.has(
				word,
			)
		);
	}

	function ___R$project$rome$$internal$js$parser$utils$identifier_ts$isStrictBindReservedWord(
		word,
		inModule,
	) {
		return (
			___R$project$rome$$internal$js$parser$utils$identifier_ts$isStrictReservedWord(
				word,
				inModule,
			) ||
			word === "eval" ||
			word === "arguments"
		);
	}

	const ___R$$priv$project$rome$$internal$js$parser$utils$identifier_ts$keywords = new Set([
		"break",
		"case",
		"catch",
		"continue",
		"debugger",
		"default",
		"do",
		"else",
		"finally",
		"for",
		"function",
		"if",
		"return",
		"switch",
		"throw",
		"try",
		"var",
		"const",
		"while",
		"with",
		"new",
		"this",
		"super",
		"class",
		"extends",
		"export",
		"import",
		"null",
		"true",
		"false",
		"in",
		"instanceof",
		"typeof",
		"void",
		"delete",
	]);

	function ___R$project$rome$$internal$js$parser$utils$identifier_ts$isKeyword(
		word,
	) {
		return ___R$$priv$project$rome$$internal$js$parser$utils$identifier_ts$keywords.has(
			word,
		);
	}

	// ## Character categories
	// Big ugly regular expressions that match characters in the
	// whitespace, identifier, and identifier-start categories. These
	// are only applied when a character is found to actually have a
	// code point above 128.
	// Generated by `bin/generate-identifier-regex.js`.
	let ___R$$priv$project$rome$$internal$js$parser$utils$identifier_ts$nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312e\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fea\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ae\ua7b0-\ua7b7\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";

	let ___R$$priv$project$rome$$internal$js$parser$utils$identifier_ts$nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d4-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

	const ___R$$priv$project$rome$$internal$js$parser$utils$identifier_ts$nonASCIIidentifierStart = new RegExp(
		"[" +
		___R$$priv$project$rome$$internal$js$parser$utils$identifier_ts$nonASCIIidentifierStartChars +
		"]",
	);
	const ___R$$priv$project$rome$$internal$js$parser$utils$identifier_ts$nonASCIIidentifier = new RegExp(
		"[" +
		___R$$priv$project$rome$$internal$js$parser$utils$identifier_ts$nonASCIIidentifierStartChars +
		___R$$priv$project$rome$$internal$js$parser$utils$identifier_ts$nonASCIIidentifierChars +
		"]",
	);

	// These are a run-length and offset encoded representation of the
	// >0xffff code points that are a valid part of identifiers. The
	// offset starts at 0x10000, and each pair of numbers represents an
	// offset to the next range, and then a size of the range. They were
	// generated by `bin/generate-identifier-regex.js`.

	/* prettier-ignore */
	const ___R$$priv$project$rome$$internal$js$parser$utils$identifier_ts$astralIdentifierStartCodes = [
		0,
		11,
		2,
		25,
		2,
		18,
		2,
		1,
		2,
		14,
		3,
		13,
		35,
		122,
		70,
		52,
		268,
		28,
		4,
		48,
		48,
		31,
		14,
		29,
		6,
		37,
		11,
		29,
		3,
		35,
		5,
		7,
		2,
		4,
		43,
		157,
		19,
		35,
		5,
		35,
		5,
		39,
		9,
		51,
		157,
		310,
		10,
		21,
		11,
		7,
		153,
		5,
		3,
		0,
		2,
		43,
		2,
		1,
		4,
		0,
		3,
		22,
		11,
		22,
		10,
		30,
		66,
		18,
		2,
		1,
		11,
		21,
		11,
		25,
		71,
		55,
		7,
		1,
		65,
		0,
		16,
		3,
		2,
		2,
		2,
		26,
		45,
		28,
		4,
		28,
		36,
		7,
		2,
		27,
		28,
		53,
		11,
		21,
		11,
		18,
		14,
		17,
		111,
		72,
		56,
		50,
		14,
		50,
		785,
		52,
		76,
		44,
		33,
		24,
		27,
		35,
		42,
		34,
		4,
		0,
		13,
		47,
		15,
		3,
		22,
		0,
		2,
		0,
		36,
		17,
		2,
		24,
		85,
		6,
		2,
		0,
		2,
		3,
		2,
		14,
		2,
		9,
		8,
		46,
		39,
		7,
		3,
		1,
		3,
		21,
		2,
		6,
		2,
		1,
		2,
		4,
		4,
		0,
		19,
		0,
		13,
		4,
		159,
		52,
		19,
		3,
		54,
		47,
		21,
		1,
		2,
		0,
		185,
		46,
		42,
		3,
		37,
		47,
		21,
		0,
		60,
		42,
		86,
		25,
		391,
		63,
		32,
		0,
		257,
		0,
		11,
		39,
		8,
		0,
		22,
		0,
		12,
		39,
		3,
		3,
		55,
		56,
		264,
		8,
		2,
		36,
		18,
		0,
		50,
		29,
		113,
		6,
		2,
		1,
		2,
		37,
		22,
		0,
		698,
		921,
		103,
		110,
		18,
		195,
		2_749,
		1_070,
		4_050,
		582,
		8_634,
		568,
		8,
		30,
		114,
		29,
		19,
		47,
		17,
		3,
		32,
		20,
		6,
		18,
		881,
		68,
		12,
		0,
		67,
		12,
		65,
		1,
		31,
		6_124,
		20,
		754,
		9_486,
		286,
		82,
		395,
		2_309,
		106,
		6,
		12,
		4,
		8,
		8,
		9,
		5_991,
		84,
		2,
		70,
		2,
		1,
		3,
		0,
		3,
		1,
		3,
		3,
		2,
		11,
		2,
		0,
		2,
		6,
		2,
		64,
		2,
		3,
		3,
		7,
		2,
		6,
		2,
		27,
		2,
		3,
		2,
		4,
		2,
		0,
		4,
		6,
		2,
		339,
		3,
		24,
		2,
		24,
		2,
		30,
		2,
		24,
		2,
		30,
		2,
		24,
		2,
		30,
		2,
		24,
		2,
		30,
		2,
		24,
		2,
		7,
		4_149,
		196,
		60,
		67,
		1_213,
		3,
		2,
		26,
		2,
		1,
		2,
		0,
		3,
		0,
		2,
		9,
		2,
		3,
		2,
		0,
		2,
		0,
		7,
		0,
		5,
		0,
		2,
		0,
		2,
		0,
		2,
		2,
		2,
		1,
		2,
		0,
		3,
		0,
		2,
		0,
		2,
		0,
		2,
		0,
		2,
		0,
		2,
		1,
		2,
		0,
		3,
		3,
		2,
		6,
		2,
		3,
		2,
		3,
		2,
		0,
		2,
		9,
		2,
		16,
		6,
		2,
		2,
		4,
		2,
		16,
		4_421,
		42_710,
		42,
		4_148,
		12,
		221,
		3,
		5_761,
		15,
		7_472,
		3_104,
		541,
	];
	/* prettier-ignore */
	const ___R$$priv$project$rome$$internal$js$parser$utils$identifier_ts$astralIdentifierCodes = [
		509,
		0,
		227,
		0,
		150,
		4,
		294,
		9,
		1_368,
		2,
		2,
		1,
		6,
		3,
		41,
		2,
		5,
		0,
		166,
		1,
		1_306,
		2,
		54,
		14,
		32,
		9,
		16,
		3,
		46,
		10,
		54,
		9,
		7,
		2,
		37,
		13,
		2,
		9,
		52,
		0,
		13,
		2,
		49,
		13,
		10,
		2,
		4,
		9,
		83,
		11,
		7,
		0,
		161,
		11,
		6,
		9,
		7,
		3,
		57,
		0,
		2,
		6,
		3,
		1,
		3,
		2,
		10,
		0,
		11,
		1,
		3,
		6,
		4,
		4,
		193,
		17,
		10,
		9,
		87,
		19,
		13,
		9,
		214,
		6,
		3,
		8,
		28,
		1,
		83,
		16,
		16,
		9,
		82,
		12,
		9,
		9,
		84,
		14,
		5,
		9,
		423,
		9,
		280,
		9,
		41,
		6,
		2,
		3,
		9,
		0,
		10,
		10,
		47,
		15,
		406,
		7,
		2,
		7,
		17,
		9,
		57,
		21,
		2,
		13,
		123,
		5,
		4,
		0,
		2,
		1,
		2,
		6,
		2,
		0,
		9,
		9,
		19_719,
		9,
		135,
		4,
		60,
		6,
		26,
		9,
		1_016,
		45,
		17,
		3,
		19_723,
		1,
		5_319,
		4,
		4,
		5,
		9,
		7,
		3,
		6,
		31,
		3,
		149,
		2,
		1_418,
		49,
		513,
		54,
		5,
		49,
		9,
		0,
		15,
		0,
		23,
		4,
		2,
		14,
		1_361,
		6,
		2,
		16,
		3,
		6,
		2,
		1,
		2,
		4,
		2_214,
		6,
		110,
		6,
		6,
		9,
		792_487,
		239,
	];

	// Get the full char code at a certain position
	function ___R$project$rome$$internal$js$parser$utils$identifier_ts$getFullCharCodeAt(
		str,
		offset,
	) {
		const code = str.charCodeAt(offset);
		if (code <= 55_295 || code >= 57_344) {
			return code;
		}

		const next = str.charCodeAt(offset + 1);
		return (code << 10) + next - 56_613_888;
	}

	// This has a complexity linear to the value of the code. The
	// assumption is that looking up astral identifier characters is
	// rare.
	function ___R$$priv$project$rome$$internal$js$parser$utils$identifier_ts$isInAstralSet(
		code,
		set,
	) {
		let pos = 65_536;
		for (let i = 0; i < set.length; i += 2) {
			pos += set[i];
			if (pos > code) {
				return false;
			}

			pos += set[i + 1];
			if (pos >= code) {
				return true;
			}
		}
		return false;
	}

	// Test whether a given character code starts an identifier.
	function ___R$project$rome$$internal$js$parser$utils$identifier_ts$isIdentifierStart(
		code,
	) {
		if (code === undefined) {
			return false;
		}

		if (code < 65) {
			return code === 36;
		}

		if (code < 91) {
			return true;
		}

		if (code < 97) {
			return code === 95;
		}

		if (code < 123) {
			return true;
		}

		if (code <= 65_535) {
			return (
				code >= 170 &&
				___R$$priv$project$rome$$internal$js$parser$utils$identifier_ts$nonASCIIidentifierStart.test(
					String.fromCharCode(code),
				)
			);
		}

		return ___R$$priv$project$rome$$internal$js$parser$utils$identifier_ts$isInAstralSet(
			code,
			___R$$priv$project$rome$$internal$js$parser$utils$identifier_ts$astralIdentifierStartCodes,
		);
	}

	function ___R$project$rome$$internal$js$parser$utils$identifier_ts$isIdentifierChar(
		code,
	) {
		if (code < 48) {
			return code === 36;
		}

		if (code < 58) {
			return true;
		}

		if (code < 65) {
			return false;
		}

		if (code < 91) {
			return true;
		}

		if (code < 97) {
			return code === 95;
		}

		if (code < 123) {
			return true;
		}

		if (code <= 65_535) {
			return (
				code >= 170 &&
				___R$$priv$project$rome$$internal$js$parser$utils$identifier_ts$nonASCIIidentifier.test(
					String.fromCharCode(code),
				)
			);
		}

		return (
			___R$$priv$project$rome$$internal$js$parser$utils$identifier_ts$isInAstralSet(
				code,
				___R$$priv$project$rome$$internal$js$parser$utils$identifier_ts$astralIdentifierStartCodes,
			) ||
			___R$$priv$project$rome$$internal$js$parser$utils$identifier_ts$isInAstralSet(
				code,
				___R$$priv$project$rome$$internal$js$parser$utils$identifier_ts$astralIdentifierCodes,
			)
		);
	}


  // project-rome/@internal/js-parser-utils/location.ts
const ___R$project$rome$$internal$js$parser$utils$location_ts = {
		createIndexTracker: ___R$project$rome$$internal$js$parser$utils$location_ts$createIndexTracker,
	};
	function ___R$project$rome$$internal$js$parser$utils$location_ts$createIndexTracker() {
		return {index: ___R$project$rome$$internal$ob1$index_ts$ob1Number0};
	}



  // project-rome/@internal/js-parser-utils/regex.ts
const ___R$project$rome$$internal$js$parser$utils$regex_ts = {
		validateRegexFlags: ___R$project$rome$$internal$js$parser$utils$regex_ts$validateRegexFlags,
	};
	const ___R$$priv$project$rome$$internal$js$parser$utils$regex_ts$VALID_REGEX_FLAGS = "gmsiyu".split(
		"",
	);

	// This is used by both rome-json and rome-js-parser to validate regex flags
	function ___R$project$rome$$internal$js$parser$utils$regex_ts$validateRegexFlags(
		flags,
		onUnexpected,
	) {
		const foundFlags = new Set();
		for (let i = 0; i < flags.length; i++) {
			const flag = flags[i];

			if (
				___R$$priv$project$rome$$internal$js$parser$utils$regex_ts$VALID_REGEX_FLAGS.includes(
					flag,
				)
			) {
				if (foundFlags.has(flag)) {
					onUnexpected(
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.REGEX_PARSER.DUPLICATE_FLAG,
						i,
					);
				} else {
					foundFlags.add(flag);
				}
			} else {
				onUnexpected(
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.REGEX_PARSER.INVALID_FLAG,
					i,
				);
			}
		}

		return foundFlags;
	}


  // project-rome/@internal/js-parser-utils/whitespace.ts
const ___R$project$rome$$internal$js$parser$utils$whitespace_ts = {
		get lineBreak() {
			return ___R$project$rome$$internal$js$parser$utils$whitespace_ts$lineBreak;
		},
		get lineBreakG() {
			return ___R$project$rome$$internal$js$parser$utils$whitespace_ts$lineBreakG;
		},
		isNewLine: ___R$project$rome$$internal$js$parser$utils$whitespace_ts$isNewLine,
		get nonASCIIwhitespace() {
			return ___R$project$rome$$internal$js$parser$utils$whitespace_ts$nonASCIIwhitespace;
		},
		get skipWhiteSpace() {
			return ___R$project$rome$$internal$js$parser$utils$whitespace_ts$skipWhiteSpace;
		},
	};
	const ___R$project$rome$$internal$js$parser$utils$whitespace_ts$lineBreak = /\r\n?|\n|u2028|u2029/;
	const ___R$project$rome$$internal$js$parser$utils$whitespace_ts$lineBreakG = new RegExp(
		___R$project$rome$$internal$js$parser$utils$whitespace_ts$lineBreak.source,
		"g",
	);

	function ___R$project$rome$$internal$js$parser$utils$whitespace_ts$isNewLine(
		code,
	) {
		return code === 10 || code === 13 || code === 8_232 || code === 8_233;
	}

	const ___R$project$rome$$internal$js$parser$utils$whitespace_ts$nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

	const ___R$project$rome$$internal$js$parser$utils$whitespace_ts$skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;


  // project-rome/@internal/js-parser-utils/index.ts



  // project-rome/@internal/js-ast-utils/isValidIdentifierName.ts
function ___R$project$rome$$internal$js$ast$utils$isValidIdentifierName_ts$isValidIdentifierName(
		name,
	) {
		if (name.length === 0) {
			return false;
		}

		if (
			___R$project$rome$$internal$js$parser$utils$identifier_ts$isStrictReservedWord(
				name,
				true,
			)
		) {
			return false;
		}

		if (
			___R$project$rome$$internal$js$parser$utils$identifier_ts$isStrictBindReservedWord(
				name,
				true,
			)
		) {
			return false;
		}

		if (
			___R$project$rome$$internal$js$parser$utils$identifier_ts$isES2015ReservedWord(
				name,
			)
		) {
			return false;
		}

		if (
			___R$project$rome$$internal$js$parser$utils$identifier_ts$isKeyword(name)
		) {
			return false;
		}

		if (
			!___R$project$rome$$internal$js$parser$utils$identifier_ts$isIdentifierStart(
				___R$project$rome$$internal$js$parser$utils$identifier_ts$getFullCharCodeAt(
					name,
					0,
				),
			)
		) {
			return false;
		}

		let i = 1;
		while (i < name.length) {
			const code = ___R$project$rome$$internal$js$parser$utils$identifier_ts$getFullCharCodeAt(
				name,
				i,
			);
			if (
				___R$project$rome$$internal$js$parser$utils$identifier_ts$isIdentifierChar(
					code,
				)
			) {
				i += code <= 65_535 ? 1 : 2;
			} else {
				return false;
			}
		}

		return true;
	}


  // project-rome/@internal/js-ast-utils/isVariableIdentifier.ts
function ___R$project$rome$$internal$js$ast$utils$isVariableIdentifier_ts$isVariableIdentifier(
		node,
	) {
		return (
			node.type === "JSBindingIdentifier" ||
			node.type === "JSAssignmentIdentifier" ||
			node.type === "JSReferenceIdentifier" ||
			node.type === "JSXReferenceIdentifier"
		);
	}


  // project-rome/@internal/js-ast-utils/removeShallowLoc.ts
function ___R$project$rome$$internal$js$ast$utils$removeShallowLoc_ts$removeShallowLoc(
		node,
	) {
		return Object.assign({}, node, {loc: undefined});
	}


  // project-rome/@internal/compiler/constants.ts
const ___R$project$rome$$internal$compiler$constants_ts = {
		get SCOPE_PRIVATE_PREFIX() {
			return ___R$project$rome$$internal$compiler$constants_ts$SCOPE_PRIVATE_PREFIX;
		},
	};
	const ___R$project$rome$$internal$compiler$constants_ts$SCOPE_PRIVATE_PREFIX = "___R$";


  // project-rome/@internal/compiler/scope/evaluators/TSTypeParameterDeclaration.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$TSTypeParameterDeclaration_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		inject(node, parent, scope) {
			node = ___R$project$rome$$internal$ast$js$typescript$TSTypeParameterDeclaration_ts$tsTypeParameterDeclaration.assert(
				node,
			);
			for (const param of node.params) {
				scope.injectEvaluate(param, node);
			}
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/TSTypeParameter.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$TSTypeParameter_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		inject(node, parent, scope) {
			node = ___R$project$rome$$internal$ast$js$typescript$TSTypeParameter_ts$tsTypeParameter.assert(
				node,
			);
			scope.addBinding(
				new ___R$project$rome$$internal$compiler$scope$bindings_ts$TypeBinding(
					{
						node,
						name: node.name,
						scope,
					},
					node,
					parent.type === "TSMappedType" ? "mapped type" : "parameter",
				),
			);
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/JSClassExpression.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$JSClassExpression_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		enter(node, parent, scope) {
			node =
				node.type === "JSClassExpression"
					? node
					: ___R$project$rome$$internal$ast$js$classes$JSClassDeclaration_ts$jsClassDeclaration.assert(
							node,
						);
			const newScope = scope.fork("class", node);
			newScope.injectEvaluate(node.meta.typeParameters, node);
			return newScope;
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/JSClassDeclaration.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$JSClassDeclaration_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		inject(node, parent, scope) {
			node = ___R$project$rome$$internal$ast$js$classes$JSClassDeclaration_ts$jsClassDeclaration.assert(
				node,
			);
			if (node.id !== undefined) {
				scope.addBinding(
					new ___R$project$rome$$internal$compiler$scope$bindings_ts$ClassBinding({
						name: node.id.name,
						node: node.id,
						scope,
					}),
				);
			}
		},
		enter(node, parent, scope) {
			return ___R$project$rome$$internal$compiler$scope$evaluators$JSClassExpression_ts$default.enter(
				node,
				parent,
				scope,
			);
		},
	});


  // project-rome/@internal/compiler/scope/bindings.ts
const ___R$project$rome$$internal$compiler$scope$bindings_ts = {
		get Binding() {
			return ___R$project$rome$$internal$compiler$scope$bindings_ts$Binding;
		},
		get ConstBinding() {
			return ___R$project$rome$$internal$compiler$scope$bindings_ts$ConstBinding;
		},
		get LetBinding() {
			return ___R$project$rome$$internal$compiler$scope$bindings_ts$LetBinding;
		},
		get VarBinding() {
			return ___R$project$rome$$internal$compiler$scope$bindings_ts$VarBinding;
		},
		get ImportBinding() {
			return ___R$project$rome$$internal$compiler$scope$bindings_ts$ImportBinding;
		},
		get ArgumentsBinding() {
			return ___R$project$rome$$internal$compiler$scope$bindings_ts$ArgumentsBinding;
		},
		get FunctionBinding() {
			return ___R$project$rome$$internal$compiler$scope$bindings_ts$FunctionBinding;
		},
		get TypeBinding() {
			return ___R$project$rome$$internal$compiler$scope$bindings_ts$TypeBinding;
		},
		get ClassBinding() {
			return ___R$project$rome$$internal$compiler$scope$bindings_ts$ClassBinding;
		},
	};
	class ___R$project$rome$$internal$compiler$scope$bindings_ts$Binding {
		constructor(opts, defaultKind) {
			this.isExported = false;
			this.scope = opts.scope;
			this.name = opts.name;
			this.node = opts.node;
			this.kind = opts.kind == null ? defaultKind : opts.kind;
		}

		setExported(isExported) {
			this.isExported = isExported;
		}
	}

	class ___R$project$rome$$internal$compiler$scope$bindings_ts$ConstBinding
		extends ___R$project$rome$$internal$compiler$scope$bindings_ts$Binding {
		constructor(opts, value, defaultKind = "const") {
			super(opts, defaultKind);
			this.value = value;
		}
	}

	class ___R$project$rome$$internal$compiler$scope$bindings_ts$LetBinding
		extends ___R$project$rome$$internal$compiler$scope$bindings_ts$Binding {
		constructor(opts) {
			super(opts, "let");
		}
	}

	class ___R$project$rome$$internal$compiler$scope$bindings_ts$VarBinding
		extends ___R$project$rome$$internal$compiler$scope$bindings_ts$Binding {
		constructor(opts) {
			super(opts, "var");
		}
	}

	class ___R$project$rome$$internal$compiler$scope$bindings_ts$ImportBinding
		extends ___R$project$rome$$internal$compiler$scope$bindings_ts$Binding {
		constructor(opts, meta) {
			super(opts, "import");
			this.meta = meta;
		}
	}

	class ___R$project$rome$$internal$compiler$scope$bindings_ts$ArgumentsBinding
		extends ___R$project$rome$$internal$compiler$scope$bindings_ts$Binding {
		constructor(opts) {
			super(opts, "arguments");
		}
	}

	class ___R$project$rome$$internal$compiler$scope$bindings_ts$FunctionBinding
		extends ___R$project$rome$$internal$compiler$scope$bindings_ts$Binding {
		constructor(opts) {
			super(opts, "function");
		}
	}

	class ___R$project$rome$$internal$compiler$scope$bindings_ts$TypeBinding
		extends ___R$project$rome$$internal$compiler$scope$bindings_ts$ConstBinding {
		constructor(opts, valueNode, kind) {
			super(opts, valueNode, "type");
			this.typeKind = kind;
		}
	}

	class ___R$project$rome$$internal$compiler$scope$bindings_ts$ClassBinding
		extends ___R$project$rome$$internal$compiler$scope$bindings_ts$Binding {
		constructor(opts) {
			super(opts, "class");
		}
	}


  // project-rome/@internal/compiler/scope/utils.ts
function ___R$project$rome$$internal$compiler$scope$utils_ts$buildFunctionScope(
		node,
		parentScope,
	) {
		const {head} = node;

		const scope = parentScope.fork("function", node);

		if (node.type === "JSFunctionExpression") {
			const {id} = node;
			if (id !== undefined) {
				scope.addBinding(
					new ___R$project$rome$$internal$compiler$scope$bindings_ts$LetBinding({
						node: id,
						name: id.name,
						scope,
					}),
				);
			}
		}

		// Add type parameters
		scope.injectEvaluate(head.typeParameters, head);

		const params =
			head.rest === undefined ? head.params : [...head.params, head.rest];

		// Add parameters
		for (const param of params) {
			for (const id of ___R$project$rome$$internal$js$ast$utils$getBindingIdentifiers_ts$getBindingIdentifiers(
				param,
			)) {
				scope.addBinding(
					new ___R$project$rome$$internal$compiler$scope$bindings_ts$LetBinding({
						node: id,
						name: id.name,
						scope,
						kind: "parameter",
					}),
				);
			}
		}

		// Add `arguments` binding
		if (node.type !== "JSArrowFunctionExpression") {
			scope.addBinding(
				new ___R$project$rome$$internal$compiler$scope$bindings_ts$ArgumentsBinding({
					name: "arguments",
					node: head,
					scope,
				}),
			);
		}

		return scope;
	}

	function ___R$project$rome$$internal$compiler$scope$utils_ts$addVarBindings(
		scope,
		topNode,
	) {
		const {context} = scope.getRootScope();

		context.reduce(
			topNode,
			[
				{
					name: "scopeVarFunc",
					enter: (path) => {
						const {node} = path;

						if (
							___R$project$rome$$internal$js$ast$utils$isFunctionNode_ts$isFunctionNode(
								node,
							) &&
							node !== topNode
						) {
							return ___R$project$rome$$internal$compiler$index_ts$signals.skip;
						}

						if (node.type === "JSVariableDeclaration" && node.kind === "var") {
							for (const decl of node.declarations) {
								for (const id of ___R$project$rome$$internal$js$ast$utils$getBindingIdentifiers_ts$getBindingIdentifiers(
									decl,
								)) {
									scope.addBinding(
										new ___R$project$rome$$internal$compiler$scope$bindings_ts$VarBinding({
											node: id,
											name: id.name,
											scope,
										}),
									);
								}
							}
						}

						return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
					},
				},
			],
			{
				scope,
				noScopeCreation: true,
			},
		);
	}


  // project-rome/@internal/compiler/scope/evaluators/JSFunctionDeclaration.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$JSFunctionDeclaration_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		inject(node, parent, scope) {
			node = ___R$project$rome$$internal$ast$js$statements$JSFunctionDeclaration_ts$jsFunctionDeclaration.assert(
				node,
			);
			if (node.id !== undefined) {
				scope.addBinding(
					new ___R$project$rome$$internal$compiler$scope$bindings_ts$FunctionBinding({
						node: node.id,
						name: node.id.name,
						scope,
					}),
				);
			}
		},
		enter(node, parent, scope) {
			return ___R$project$rome$$internal$compiler$scope$utils_ts$buildFunctionScope(
				___R$project$rome$$internal$ast$js$statements$JSFunctionDeclaration_ts$jsFunctionDeclaration.assert(
					node,
				),
				scope,
			);
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/JSVariableDeclaration.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$JSVariableDeclaration_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		inject(node, parent, scope) {
			node = ___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclaration_ts$jsVariableDeclaration.assert(
				node,
			);

			for (const decl of node.declarations) {
				for (const id of ___R$project$rome$$internal$js$ast$utils$getBindingIdentifiers_ts$getBindingIdentifiers(
					decl,
				)) {
					switch (node.kind) {
						case "let": {
							scope.addBinding(
								new ___R$project$rome$$internal$compiler$scope$bindings_ts$LetBinding({
									node: id,
									name: id.name,
									scope,
								}),
							);
							break;
						}

						case "const": {
							// Only set the value for simple declarations
							let valueNode = id === decl.id ? decl.init : undefined;
							scope.addBinding(
								new ___R$project$rome$$internal$compiler$scope$bindings_ts$ConstBinding(
									{
										node: id,
										name: id.name,
										scope,
									},
									valueNode,
								),
							);
							break;
						}

						case "var": {
							// Should be injected manually by `addVarBindings`
							break;
						}
					}
				}
			}
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/TSTypeAlias.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$TSTypeAlias_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		inject(node, parent, scope) {
			node = ___R$project$rome$$internal$ast$js$typescript$TSTypeAlias_ts$tsTypeAlias.assert(
				node,
			);
			scope.addBinding(
				new ___R$project$rome$$internal$compiler$scope$bindings_ts$TypeBinding(
					{
						node: node.id,
						name: node.id.name,
						scope,
					},
					node,
					"alias",
				),
			);
		},

		enter(node, parent, scope) {
			node = ___R$project$rome$$internal$ast$js$typescript$TSTypeAlias_ts$tsTypeAlias.assert(
				node,
			);
			const newScope = scope.fork("type-generic", node);
			newScope.injectEvaluate(node.typeParameters, node);
			return newScope;
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/JSExportDefaultDeclaration.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$JSExportDefaultDeclaration_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		inject(node, parent, scope) {
			node = ___R$project$rome$$internal$ast$js$modules$JSExportDefaultDeclaration_ts$jsExportDefaultDeclaration.assert(
				node,
			);

			const {declaration} = node;
			scope.injectEvaluate(declaration, node);

			if (
				declaration.type === "JSClassDeclaration" ||
				declaration.type === "JSFunctionDeclaration"
			) {
				const id = declaration.id;
				if (id !== undefined) {
					scope.getBindingAssert(id.name).setExported(true);
				}
			}
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/JSExportLocalDeclaration.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$JSExportLocalDeclaration_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		inject(node, parent, scope) {
			node = ___R$project$rome$$internal$ast$js$modules$JSExportLocalDeclaration_ts$jsExportLocalDeclaration.assert(
				node,
			);
			scope.injectEvaluate(node.declaration, node);
			for (const id of ___R$project$rome$$internal$js$ast$utils$getBindingIdentifiers_ts$getBindingIdentifiers(
				node,
			)) {
				const binding = scope.getBinding(id.name);
				if (binding !== undefined) {
					binding.setExported(true);
				}
			}
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/JSImportDeclaration.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$JSImportDeclaration_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		inject(node, parent, scope) {
			node = ___R$project$rome$$internal$ast$js$modules$JSImportDeclaration_ts$jsImportDeclaration.assert(
				node,
			);

			const source = node.source.value;

			for (const specifier of ___R$project$rome$$internal$js$ast$utils$getImportSpecifiers_ts$getImportSpecifiers(
				node,
			)) {
				let kind = node.importKind || "value";
				let meta;

				if (specifier.type === "JSImportNamespaceSpecifier") {
					meta = {
						kind,
						type: "namespace",
						source,
					};
				} else if (specifier.type === "JSImportDefaultSpecifier") {
					meta = {
						kind,
						type: "name",
						imported: "default",
						source,
					};
				} else if (specifier.type === "JSImportSpecifier") {
					meta = {
						kind,
						type: "name",
						imported: specifier.imported.name,
						source,
					};
				}

				if (meta === undefined) {
					return;
				}

				scope.addBinding(
					new ___R$project$rome$$internal$compiler$scope$bindings_ts$ImportBinding(
						{
							node: specifier.local.name,
							name: specifier.local.name.name,
							scope,
						},
						meta,
					),
				);
			}
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/JSSwitchCase.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$JSSwitchCase_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		inject(node, parent, scope) {
			node = ___R$project$rome$$internal$ast$js$auxiliary$JSSwitchCase_ts$jsSwitchCase.assert(
				node,
			);
			for (const child of node.consequent) {
				scope.injectEvaluate(child, node);
			}
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/JSSwitchStatement.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$JSSwitchStatement_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		inject(node, parent, scope) {
			node = ___R$project$rome$$internal$ast$js$statements$JSSwitchStatement_ts$jsSwitchStatement.assert(
				node,
			);

			for (const child of node.cases) {
				scope.injectEvaluate(child, node);
			}
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/TSImportEqualsDeclaration.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$TSImportEqualsDeclaration_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		inject(node, parent, scope) {
			const {moduleReference, id} = ___R$project$rome$$internal$ast$js$typescript$TSImportEqualsDeclaration_ts$tsImportEqualsDeclaration.assert(
				node,
			);

			if (moduleReference.type === "TSExternalModuleReference") {
				scope.addBinding(
					new ___R$project$rome$$internal$compiler$scope$bindings_ts$ImportBinding(
						{
							node: id,
							name: id.name,
							scope,
						},
						{
							type: "namespace",
							kind: "value",
							source: moduleReference.expression.value,
						},
					),
				);
			} else {
				// TODO
			}
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/JSArrowFunctionExpression.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$JSArrowFunctionExpression_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		enter(node, parent, scope) {
			return ___R$project$rome$$internal$compiler$scope$utils_ts$buildFunctionScope(
				___R$project$rome$$internal$ast$js$expressions$JSArrowFunctionExpression_ts$jsArrowFunctionExpression.assert(
					node,
				),
				scope,
			);
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/JSBlockStatement.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$JSBlockStatement_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		enter(node, parent, scope) {
			node = ___R$project$rome$$internal$ast$js$statements$JSBlockStatement_ts$jsBlockStatement.assert(
				node,
			);
			const newScope = scope.fork("block", node);

			if (
				___R$project$rome$$internal$js$ast$utils$isFunctionNode_ts$isFunctionNode(
					parent,
				) &&
				parent.head.hasHoistedVars
			) {
				___R$project$rome$$internal$compiler$scope$utils_ts$addVarBindings(
					newScope,
					parent,
				);
			}

			for (const child of node.body) {
				newScope.injectEvaluate(child, node);
			}

			return newScope;
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/JSCatchClause.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$JSCatchClause_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		enter(node, parent, scope) {
			node = ___R$project$rome$$internal$ast$js$auxiliary$JSCatchClause_ts$jsCatchClause.assert(
				node,
			);
			const newScope = scope.fork("block", node);
			if (node.param !== undefined) {
				for (const id of ___R$project$rome$$internal$js$ast$utils$getBindingIdentifiers_ts$getBindingIdentifiers(
					node.param,
				)) {
					newScope.addBinding(
						new ___R$project$rome$$internal$compiler$scope$bindings_ts$LetBinding({
							node: id,
							name: id.name,
							scope: newScope,
							kind: "catch",
						}),
					);
				}
			}
			return newScope;
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/JSRoot.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$JSRoot_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		enter(node, parent, scope) {
			node = ___R$project$rome$$internal$ast$js$core$JSRoot_ts$jsRoot.assert(
				node,
			);

			const newScope = scope.fork("program", node);

			if (node.hasHoistedVars) {
				___R$project$rome$$internal$compiler$scope$utils_ts$addVarBindings(
					newScope,
					node,
				);
			}

			for (const child of node.body) {
				newScope.injectEvaluate(child, node);
			}

			return newScope;
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/JSForStatement.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$JSForStatement_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		enter(node, parent, scope) {
			node = ___R$project$rome$$internal$ast$js$statements$JSForStatement_ts$jsForStatement.assert(
				node,
			);
			const newScope = scope.fork("loop", node);
			newScope.injectEvaluate(node.init, node);
			return newScope;
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/JSForOfStatement.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$JSForOfStatement_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		enter(node, parent, scope) {
			node = ___R$project$rome$$internal$ast$js$statements$JSForOfStatement_ts$jsForOfStatement.assert(
				node,
			);
			const newScope = scope.fork("loop", node);
			newScope.injectEvaluate(node.left, node);
			return newScope;
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/JSVariableDeclarationStatement.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$JSVariableDeclarationStatement_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		inject(node, parent, scope) {
			node = ___R$project$rome$$internal$ast$js$statements$JSVariableDeclarationStatement_ts$jsVariableDeclarationStatement.assert(
				node,
			);

			if (node.declare) {
				for (const {name} of ___R$project$rome$$internal$js$ast$utils$getBindingIdentifiers_ts$getBindingIdentifiers(
					node,
				)) {
					scope.addGlobal(name);
				}
			} else {
				scope.injectEvaluate(node.declaration, node);
			}
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/TSInterfaceDeclaration.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$TSInterfaceDeclaration_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		inject(node, parent, scope) {
			node = ___R$project$rome$$internal$ast$js$typescript$TSInterfaceDeclaration_ts$tsInterfaceDeclaration.assert(
				node,
			);
			scope.addBinding(
				new ___R$project$rome$$internal$compiler$scope$bindings_ts$TypeBinding(
					{
						node: node.id,
						name: node.id.name,
						scope,
					},
					node,
					"interface",
				),
			);
		},

		enter(node, parent, scope) {
			node = ___R$project$rome$$internal$ast$js$typescript$TSInterfaceDeclaration_ts$tsInterfaceDeclaration.assert(
				node,
			);
			const newScope = scope.fork("type-generic", node);
			newScope.injectEvaluate(node.typeParameters, node);
			return newScope;
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/TSDeclareFunction.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$TSDeclareFunction_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		inject(node, parent, scope) {
			node = ___R$project$rome$$internal$ast$js$typescript$TSDeclareFunction_ts$tsDeclareFunction.assert(
				node,
			);
			scope.addBinding(
				new ___R$project$rome$$internal$compiler$scope$bindings_ts$FunctionBinding({
					node: node.id,
					name: node.id.name,
					scope,
				}),
			);
		},
		enter(node, parent, scope) {
			return ___R$project$rome$$internal$compiler$scope$utils_ts$buildFunctionScope(
				___R$project$rome$$internal$ast$js$typescript$TSDeclareFunction_ts$tsDeclareFunction.assert(
					node,
				),
				scope,
			);
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/TSEnumDeclaration.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$TSEnumDeclaration_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		inject(node, parent, scope) {
			node = ___R$project$rome$$internal$ast$js$typescript$TSEnumDeclaration_ts$tsEnumDeclaration.assert(
				node,
			);
			scope.addBinding(
				new ___R$project$rome$$internal$compiler$scope$bindings_ts$TypeBinding(
					{
						node: node.id,
						name: node.id.name,
						scope,
					},
					node,
					"enum",
				),
			);
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/JSFunctionExpression.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$JSFunctionExpression_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		enter(node, parent, scope) {
			return ___R$project$rome$$internal$compiler$scope$utils_ts$buildFunctionScope(
				___R$project$rome$$internal$ast$js$expressions$JSFunctionExpression_ts$jsFunctionExpression.assert(
					node,
				),
				scope,
			);
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/JSObjectMethod.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$JSObjectMethod_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		enter(node, parent, scope) {
			return ___R$project$rome$$internal$compiler$scope$utils_ts$buildFunctionScope(
				___R$project$rome$$internal$ast$js$objects$JSObjectMethod_ts$jsObjectMethod.assert(
					node,
				),
				scope,
			);
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/JSClassMethod.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$JSClassMethod_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		enter(node, parent, scope) {
			return ___R$project$rome$$internal$compiler$scope$utils_ts$buildFunctionScope(
				___R$project$rome$$internal$ast$js$classes$JSClassMethod_ts$jsClassMethod.assert(
					node,
				),
				scope,
			);
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/TSDeclareMethod.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$TSDeclareMethod_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		enter(node, parent, scope) {
			return ___R$project$rome$$internal$compiler$scope$utils_ts$buildFunctionScope(
				___R$project$rome$$internal$ast$js$typescript$TSDeclareMethod_ts$tsDeclareMethod.assert(
					node,
				),
				scope,
			);
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/JSForInStatement.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$JSForInStatement_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		enter(node, parent, scope) {
			node = ___R$project$rome$$internal$ast$js$statements$JSForInStatement_ts$jsForInStatement.assert(
				node,
			);
			const newScope = scope.fork("loop", node);
			newScope.injectEvaluate(node.left, node);
			return newScope;
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/TSMappedType.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$TSMappedType_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		enter(node, parent, scope) {
			node = ___R$project$rome$$internal$ast$js$typescript$TSMappedType_ts$tsMappedType.assert(
				node,
			);
			const newScope = scope.fork("type-generic", node);
			newScope.injectEvaluate(node.typeParameter, node);
			return newScope;
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/TSFunctionType.ts
const ___R$project$rome$$internal$compiler$scope$evaluators$TSFunctionType_ts$default = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator({
		enter(node, parent, scope) {
			node = ___R$project$rome$$internal$ast$js$typescript$TSFunctionType_ts$tsFunctionType.assert(
				node,
			);
			const newScope = scope.fork("type-generic", node);
			newScope.injectEvaluate(node.meta.typeParameters, node);
			return newScope;
		},
	});


  // project-rome/@internal/compiler/scope/evaluators/index.ts
function ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$createScopeEvaluator(
		obj,
	) {
		return obj;
	}

	const ___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators = new Map();

	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"TSFunctionType",
		___R$project$rome$$internal$compiler$scope$evaluators$TSFunctionType_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"TSMappedType",
		___R$project$rome$$internal$compiler$scope$evaluators$TSMappedType_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"TSTypeParameter",
		___R$project$rome$$internal$compiler$scope$evaluators$TSTypeParameter_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"TSTypeParameterDeclaration",
		___R$project$rome$$internal$compiler$scope$evaluators$TSTypeParameterDeclaration_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"TSDeclareMethod",
		___R$project$rome$$internal$compiler$scope$evaluators$TSDeclareMethod_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"TSDeclareFunction",
		___R$project$rome$$internal$compiler$scope$evaluators$TSDeclareFunction_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"JSClassDeclaration",
		___R$project$rome$$internal$compiler$scope$evaluators$JSClassDeclaration_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"JSFunctionDeclaration",
		___R$project$rome$$internal$compiler$scope$evaluators$JSFunctionDeclaration_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"JSVariableDeclarationStatement",
		___R$project$rome$$internal$compiler$scope$evaluators$JSVariableDeclarationStatement_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"JSVariableDeclaration",
		___R$project$rome$$internal$compiler$scope$evaluators$JSVariableDeclaration_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"JSExportDefaultDeclaration",
		___R$project$rome$$internal$compiler$scope$evaluators$JSExportDefaultDeclaration_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"JSExportLocalDeclaration",
		___R$project$rome$$internal$compiler$scope$evaluators$JSExportLocalDeclaration_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"JSFunctionExpression",
		___R$project$rome$$internal$compiler$scope$evaluators$JSFunctionExpression_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"JSImportDeclaration",
		___R$project$rome$$internal$compiler$scope$evaluators$JSImportDeclaration_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"JSSwitchCase",
		___R$project$rome$$internal$compiler$scope$evaluators$JSSwitchCase_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"JSSwitchStatement",
		___R$project$rome$$internal$compiler$scope$evaluators$JSSwitchStatement_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"TSTypeAlias",
		___R$project$rome$$internal$compiler$scope$evaluators$TSTypeAlias_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"TSImportEqualsDeclaration",
		___R$project$rome$$internal$compiler$scope$evaluators$TSImportEqualsDeclaration_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"JSArrowFunctionExpression",
		___R$project$rome$$internal$compiler$scope$evaluators$JSArrowFunctionExpression_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"JSBlockStatement",
		___R$project$rome$$internal$compiler$scope$evaluators$JSBlockStatement_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"JSClassExpression",
		___R$project$rome$$internal$compiler$scope$evaluators$JSClassExpression_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"JSCatchClause",
		___R$project$rome$$internal$compiler$scope$evaluators$JSCatchClause_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"JSRoot",
		___R$project$rome$$internal$compiler$scope$evaluators$JSRoot_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"JSForStatement",
		___R$project$rome$$internal$compiler$scope$evaluators$JSForStatement_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"JSForOfStatement",
		___R$project$rome$$internal$compiler$scope$evaluators$JSForOfStatement_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"JSForInStatement",
		___R$project$rome$$internal$compiler$scope$evaluators$JSForInStatement_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"JSClassMethod",
		___R$project$rome$$internal$compiler$scope$evaluators$JSClassMethod_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"JSObjectMethod",
		___R$project$rome$$internal$compiler$scope$evaluators$JSObjectMethod_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"TSInterfaceDeclaration",
		___R$project$rome$$internal$compiler$scope$evaluators$TSInterfaceDeclaration_ts$default,
	);
	___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators.set(
		"TSEnumDeclaration",
		___R$project$rome$$internal$compiler$scope$evaluators$TSEnumDeclaration_ts$default,
	);
	const ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$default = ___R$$priv$project$rome$$internal$compiler$scope$evaluators$index_ts$evaluators;


  // project-rome/@internal/compiler/scope/globals.ts
const ___R$project$rome$$internal$compiler$scope$globals_ts = {
		get builtin() {
			return ___R$project$rome$$internal$compiler$scope$globals_ts$builtin;
		},
		get es5() {
			return ___R$project$rome$$internal$compiler$scope$globals_ts$es5;
		},
		get es2015() {
			return ___R$project$rome$$internal$compiler$scope$globals_ts$es2015;
		},
		get es2017() {
			return ___R$project$rome$$internal$compiler$scope$globals_ts$es2017;
		},
		get browser() {
			return ___R$project$rome$$internal$compiler$scope$globals_ts$browser;
		},
		get worker() {
			return ___R$project$rome$$internal$compiler$scope$globals_ts$worker;
		},
		get node() {
			return ___R$project$rome$$internal$compiler$scope$globals_ts$node;
		},
		get commonjs() {
			return ___R$project$rome$$internal$compiler$scope$globals_ts$commonjs;
		},
		get serviceworker() {
			return ___R$project$rome$$internal$compiler$scope$globals_ts$serviceworker;
		},
	};
	const ___R$project$rome$$internal$compiler$scope$globals_ts$builtin = [
		"Array",
		"ArrayBuffer",
		"Atomics",
		"BigInt",
		"BigInt64Array",
		"BigUint64Array",
		"Boolean",
		"constructor",
		"DataView",
		"Date",
		"decodeURI",
		"decodeURIComponent",
		"encodeURI",
		"encodeURIComponent",
		"Error",
		"escape",
		"eval",
		"EvalError",
		"Float32Array",
		"Float64Array",
		"Function",
		"globalThis",
		"hasOwnProperty",
		"Infinity",
		"Int16Array",
		"Int32Array",
		"Int8Array",
		"isFinite",
		"isNaN",
		"isPrototypeOf",
		"JSON",
		"Map",
		"Math",
		"NaN",
		"Number",
		"Object",
		"parseFloat",
		"parseInt",
		"Promise",
		"propertyIsEnumerable",
		"Proxy",
		"RangeError",
		"ReferenceError",
		"Reflect",
		"RegExp",
		"Set",
		"SharedArrayBuffer",
		"String",
		"Symbol",
		"SyntaxError",
		"toLocaleString",
		"toString",
		"TypeError",
		"Uint16Array",
		"Uint32Array",
		"Uint8Array",
		"Uint8ClampedArray",
		"undefined",
		"unescape",
		"URIError",
		"valueOf",
		"WeakMap",
		"WeakSet",
	];

	const ___R$project$rome$$internal$compiler$scope$globals_ts$es5 = [
		"Array",
		"Boolean",
		"constructor",
		"Date",
		"decodeURI",
		"decodeURIComponent",
		"encodeURI",
		"encodeURIComponent",
		"Error",
		"escape",
		"eval",
		"EvalError",
		"Function",
		"hasOwnProperty",
		"Infinity",
		"isFinite",
		"isNaN",
		"isPrototypeOf",
		"JSON",
		"Math",
		"NaN",
		"Number",
		"Object",
		"parseFloat",
		"parseInt",
		"propertyIsEnumerable",
		"RangeError",
		"ReferenceError",
		"RegExp",
		"String",
		"SyntaxError",
		"toLocaleString",
		"toString",
		"TypeError",
		"undefined",
		"unescape",
		"URIError",
		"valueOf",
	];

	const ___R$project$rome$$internal$compiler$scope$globals_ts$es2015 = [
		"Array",
		"ArrayBuffer",
		"Boolean",
		"constructor",
		"DataView",
		"Date",
		"decodeURI",
		"decodeURIComponent",
		"encodeURI",
		"encodeURIComponent",
		"Error",
		"escape",
		"eval",
		"EvalError",
		"Float32Array",
		"Float64Array",
		"Function",
		"hasOwnProperty",
		"Infinity",
		"Int16Array",
		"Int32Array",
		"Int8Array",
		"isFinite",
		"isNaN",
		"isPrototypeOf",
		"JSON",
		"Map",
		"Math",
		"NaN",
		"Number",
		"Object",
		"parseFloat",
		"parseInt",
		"Promise",
		"propertyIsEnumerable",
		"Proxy",
		"RangeError",
		"ReferenceError",
		"Reflect",
		"RegExp",
		"Set",
		"String",
		"Symbol",
		"SyntaxError",
		"toLocaleString",
		"toString",
		"TypeError",
		"Uint16Array",
		"Uint32Array",
		"Uint8Array",
		"Uint8ClampedArray",
		"undefined",
		"unescape",
		"URIError",
		"valueOf",
		"WeakMap",
		"WeakSet",
	];

	const ___R$project$rome$$internal$compiler$scope$globals_ts$es2017 = [
		"Array",
		"ArrayBuffer",
		"Atomics",
		"Boolean",
		"constructor",
		"DataView",
		"Date",
		"decodeURI",
		"decodeURIComponent",
		"encodeURI",
		"encodeURIComponent",
		"Error",
		"escape",
		"eval",
		"EvalError",
		"Float32Array",
		"Float64Array",
		"Function",
		"hasOwnProperty",
		"Infinity",
		"Int16Array",
		"Int32Array",
		"Int8Array",
		"isFinite",
		"isNaN",
		"isPrototypeOf",
		"JSON",
		"Map",
		"Math",
		"NaN",
		"Number",
		"Object",
		"parseFloat",
		"parseInt",
		"Promise",
		"propertyIsEnumerable",
		"Proxy",
		"RangeError",
		"ReferenceError",
		"Reflect",
		"RegExp",
		"Set",
		"SharedArrayBuffer",
		"String",
		"Symbol",
		"SyntaxError",
		"toLocaleString",
		"toString",
		"TypeError",
		"Uint16Array",
		"Uint32Array",
		"Uint8Array",
		"Uint8ClampedArray",
		"undefined",
		"unescape",
		"URIError",
		"valueOf",
		"WeakMap",
		"WeakSet",
	];

	const ___R$project$rome$$internal$compiler$scope$globals_ts$browser = [
		"AbortController",
		"AbortSignal",
		"addEventListener",
		"alert",
		"AnalyserNode",
		"Animation",
		"AnimationEffectReadOnly",
		"AnimationEffectTiming",
		"AnimationEffectTimingReadOnly",
		"AnimationEvent",
		"AnimationPlaybackEvent",
		"AnimationTimeline",
		"applicationCache",
		"ApplicationCache",
		"ApplicationCacheErrorEvent",
		"atob",
		"Attr",
		"Audio",
		"AudioBuffer",
		"AudioBufferSourceNode",
		"AudioContext",
		"AudioDestinationNode",
		"AudioListener",
		"AudioNode",
		"AudioParam",
		"AudioProcessingEvent",
		"AudioScheduledSourceNode",
		"AudioWorkletGlobalScope ",
		"AudioWorkletNode",
		"AudioWorkletProcessor",
		"BarProp",
		"BaseAudioContext",
		"BatteryManager",
		"BeforeUnloadEvent",
		"BiquadFilterNode",
		"Blob",
		"BlobEvent",
		"blur",
		"BroadcastChannel",
		"btoa",
		"BudgetService",
		"ByteLengthQueuingStrategy",
		"Cache",
		"caches",
		"CacheStorage",
		"cancelAnimationFrame",
		"cancelIdleCallback",
		"CanvasCaptureMediaStreamTrack",
		"CanvasGradient",
		"CanvasPattern",
		"CanvasRenderingContext2D",
		"ChannelMergerNode",
		"ChannelSplitterNode",
		"CharacterData",
		"clearInterval",
		"clearTimeout",
		"clientInformation",
		"ClipboardEvent",
		"close",
		"closed",
		"CloseEvent",
		"Comment",
		"CompositionEvent",
		"confirm",
		"console",
		"ConstantSourceNode",
		"ConvolverNode",
		"CountQueuingStrategy",
		"createImageBitmap",
		"Credential",
		"CredentialsContainer",
		"crypto",
		"Crypto",
		"CryptoKey",
		"CSS",
		"CSSConditionRule",
		"CSSFontFaceRule",
		"CSSGroupingRule",
		"CSSImportRule",
		"CSSKeyframeRule",
		"CSSKeyframesRule",
		"CSSMediaRule",
		"CSSNamespaceRule",
		"CSSPageRule",
		"CSSRule",
		"CSSRuleList",
		"CSSStyleDeclaration",
		"CSSStyleRule",
		"CSSRoot",
		"CSSSupportsRule",
		"CustomElementRegistry",
		"customElements",
		"CustomEvent",
		"DataTransfer",
		"DataTransferItem",
		"DataTransferItemList",
		"defaultstatus",
		"defaultStatus",
		"DelayNode",
		"DeviceMotionEvent",
		"DeviceOrientationEvent",
		"devicePixelRatio",
		"dispatchEvent",
		"document",
		"Document",
		"DocumentFragment",
		"DocumentType",
		"DOMError",
		"DOMException",
		"DOMImplementation",
		"DOMMatrix",
		"DOMMatrixReadOnly",
		"DOMParser",
		"DOMPoint",
		"DOMPointReadOnly",
		"DOMQuad",
		"DOMRect",
		"DOMRectReadOnly",
		"DOMStringList",
		"DOMStringMap",
		"DOMTokenList",
		"DragEvent",
		"DynamicsCompressorNode",
		"Element",
		"ErrorEvent",
		"event",
		"Event",
		"EventSource",
		"EventTarget",
		"external",
		"fetch",
		"File",
		"FileList",
		"FileReader",
		"find",
		"focus",
		"FocusEvent",
		"FontFace",
		"FontFaceSetLoadEvent",
		"FormData",
		"frameElement",
		"frames",
		"GainNode",
		"Gamepad",
		"GamepadButton",
		"GamepadEvent",
		"getComputedStyle",
		"getSelection",
		"HashChangeEvent",
		"Headers",
		"history",
		"History",
		"HTMLAllCollection",
		"HTMLAnchorElement",
		"HTMLAreaElement",
		"HTMLAudioElement",
		"HTMLBaseElement",
		"HTMLBodyElement",
		"HTMLBRElement",
		"HTMLButtonElement",
		"HTMLCanvasElement",
		"HTMLCollection",
		"HTMLContentElement",
		"HTMLDataElement",
		"HTMLDataListElement",
		"HTMLDetailsElement",
		"HTMLDialogElement",
		"HTMLDirectoryElement",
		"HTMLDivElement",
		"HTMLDListElement",
		"HTMLDocument",
		"HTMLElement",
		"HTMLEmbedElement",
		"HTMLFieldSetElement",
		"HTMLFontElement",
		"HTMLFormControlsCollection",
		"HTMLFormElement",
		"HTMLFrameElement",
		"HTMLFrameSetElement",
		"HTMLHeadElement",
		"HTMLHeadingElement",
		"HTMLHRElement",
		"HTMLHtmlElement",
		"HTMLIFrameElement",
		"HTMLImageElement",
		"HTMLInputElement",
		"HTMLLabelElement",
		"HTMLLegendElement",
		"HTMLLIElement",
		"HTMLLinkElement",
		"HTMLMapElement",
		"HTMLMarqueeElement",
		"HTMLMediaElement",
		"HTMLMenuElement",
		"HTMLMetaElement",
		"HTMLMeterElement",
		"HTMLModElement",
		"HTMLObjectElement",
		"HTMLOListElement",
		"HTMLOptGroupElement",
		"HTMLOptionElement",
		"HTMLOptionsCollection",
		"HTMLOutputElement",
		"HTMLParagraphElement",
		"HTMLParamElement",
		"HTMLPictureElement",
		"HTMLPreElement",
		"HTMLProgressElement",
		"HTMLQuoteElement",
		"HTMLScriptElement",
		"HTMLSelectElement",
		"HTMLShadowElement",
		"HTMLSlotElement",
		"HTMLSourceElement",
		"HTMLSpanElement",
		"HTMLStyleElement",
		"HTMLTableCaptionElement",
		"HTMLTableCellElement",
		"HTMLTableColElement",
		"HTMLTableElement",
		"HTMLTableRowElement",
		"HTMLTableSectionElement",
		"HTMLTemplateElement",
		"HTMLTextAreaElement",
		"HTMLTimeElement",
		"HTMLTitleElement",
		"HTMLTrackElement",
		"HTMLUListElement",
		"HTMLUnknownElement",
		"HTMLVideoElement",
		"IDBCursor",
		"IDBCursorWithValue",
		"IDBDatabase",
		"IDBFactory",
		"IDBIndex",
		"IDBKeyRange",
		"IDBObjectStore",
		"IDBOpenDBRequest",
		"IDBRequest",
		"IDBTransaction",
		"IDBVersionChangeEvent",
		"IdleDeadline",
		"IIRFilterNode",
		"Image",
		"ImageBitmap",
		"ImageBitmapRenderingContext",
		"ImageCapture",
		"ImageData",
		"indexedDB",
		"innerHeight",
		"innerWidth",
		"InputEvent",
		"IntersectionObserver",
		"IntersectionObserverEntry",
		"Intl",
		"isSecureContext",
		"KeyboardEvent",
		"KeyframeEffect",
		"KeyframeEffectReadOnly",
		"length",
		"localStorage",
		"location",
		"Location",
		"locationbar",
		"matchMedia",
		"MediaDeviceInfo",
		"MediaDevices",
		"MediaElementAudioSourceNode",
		"MediaEncryptedEvent",
		"MediaError",
		"MediaKeyMessageEvent",
		"MediaKeySession",
		"MediaKeyStatusMap",
		"MediaKeySystemAccess",
		"MediaList",
		"MediaQueryList",
		"MediaQueryListEvent",
		"MediaRecorder",
		"MediaSettingsRange",
		"MediaSource",
		"MediaStream",
		"MediaStreamAudioDestinationNode",
		"MediaStreamAudioSourceNode",
		"MediaStreamEvent",
		"MediaStreamTrack",
		"MediaStreamTrackEvent",
		"menubar",
		"MessageChannel",
		"MessageEvent",
		"MessagePort",
		"MIDIAccess",
		"MIDIConnectionEvent",
		"MIDIInput",
		"MIDIInputMap",
		"MIDIMessageEvent",
		"MIDIOutput",
		"MIDIOutputMap",
		"MIDIPort",
		"MimeType",
		"MimeTypeArray",
		"MouseEvent",
		"moveBy",
		"moveTo",
		"MutationEvent",
		"MutationObserver",
		"MutationRecord",
		"name",
		"NamedNodeMap",
		"NavigationPreloadManager",
		"navigator",
		"Navigator",
		"NetworkInformation",
		"Node",
		"NodeFilter",
		"NodeIterator",
		"NodeList",
		"Notification",
		"OfflineAudioCompletionEvent",
		"OfflineAudioContext",
		"offscreenBuffering",
		"OffscreenCanvas",
		"onabort",
		"onafterprint",
		"onanimationend",
		"onanimationiteration",
		"onanimationstart",
		"onappinstalled",
		"onauxclick",
		"onbeforeinstallprompt",
		"onbeforeprint",
		"onbeforeunload",
		"onblur",
		"oncancel",
		"oncanplay",
		"oncanplaythrough",
		"onchange",
		"onclick",
		"onclose",
		"oncontextmenu",
		"oncuechange",
		"ondblclick",
		"ondevicemotion",
		"ondeviceorientation",
		"ondeviceorientationabsolute",
		"ondrag",
		"ondragend",
		"ondragenter",
		"ondragleave",
		"ondragover",
		"ondragstart",
		"ondrop",
		"ondurationchange",
		"onemptied",
		"onended",
		"onerror",
		"onfocus",
		"ongotpointercapture",
		"onhashchange",
		"oninput",
		"oninvalid",
		"onkeydown",
		"onkeypress",
		"onkeyup",
		"onlanguagechange",
		"onload",
		"onloadeddata",
		"onloadedmetadata",
		"onloadstart",
		"onlostpointercapture",
		"onmessage",
		"onmessageerror",
		"onmousedown",
		"onmouseenter",
		"onmouseleave",
		"onmousemove",
		"onmouseout",
		"onmouseover",
		"onmouseup",
		"onmousewheel",
		"onoffline",
		"ononline",
		"onpagehide",
		"onpageshow",
		"onpause",
		"onplay",
		"onplaying",
		"onpointercancel",
		"onpointerdown",
		"onpointerenter",
		"onpointerleave",
		"onpointermove",
		"onpointerout",
		"onpointerover",
		"onpointerup",
		"onpopstate",
		"onprogress",
		"onratechange",
		"onrejectionhandled",
		"onreset",
		"onresize",
		"onscroll",
		"onsearch",
		"onseeked",
		"onseeking",
		"onselect",
		"onstalled",
		"onstorage",
		"onsubmit",
		"onsuspend",
		"ontimeupdate",
		"ontoggle",
		"ontransitionend",
		"onunhandledrejection",
		"onunload",
		"onvolumechange",
		"onwaiting",
		"onwheel",
		"open",
		"openDatabase",
		"opener",
		"Option",
		"origin",
		"OscillatorNode",
		"outerHeight",
		"outerWidth",
		"PageTransitionEvent",
		"pageXOffset",
		"pageYOffset",
		"PannerNode",
		"parent",
		"Path2D",
		"PaymentAddress",
		"PaymentRequest",
		"PaymentRequestUpdateEvent",
		"PaymentResponse",
		"performance",
		"Performance",
		"PerformanceEntry",
		"PerformanceLongTaskTiming",
		"PerformanceMark",
		"PerformanceMeasure",
		"PerformanceNavigation",
		"PerformanceNavigationTiming",
		"PerformanceObserver",
		"PerformanceObserverEntryList",
		"PerformancePaintTiming",
		"PerformanceResourceTiming",
		"PerformanceTiming",
		"PeriodicWave",
		"Permissions",
		"PermissionStatus",
		"personalbar",
		"PhotoCapabilities",
		"Plugin",
		"PluginArray",
		"PointerEvent",
		"PopStateEvent",
		"postMessage",
		"Presentation",
		"PresentationAvailability",
		"PresentationConnection",
		"PresentationConnectionAvailableEvent",
		"PresentationConnectionCloseEvent",
		"PresentationConnectionList",
		"PresentationReceiver",
		"PresentationRequest",
		"print",
		"ProcessingInstruction",
		"ProgressEvent",
		"PromiseRejectionEvent",
		"prompt",
		"PushManager",
		"PushSubscription",
		"PushSubscriptionOptions",
		"queueMicrotask",
		"RadioNodeList",
		"Range",
		"ReadableStream",
		"registerProcessor",
		"RemotePlayback",
		"removeEventListener",
		"Request",
		"requestAnimationFrame",
		"requestIdleCallback",
		"resizeBy",
		"ResizeObserver",
		"ResizeObserverEntry",
		"resizeTo",
		"Response",
		"RTCCertificate",
		"RTCDataChannel",
		"RTCDataChannelEvent",
		"RTCDtlsTransport",
		"RTCIceCandidate",
		"RTCIceGatherer",
		"RTCIceTransport",
		"RTCPeerConnection",
		"RTCPeerConnectionIceEvent",
		"RTCRtpContributingSource",
		"RTCRtpReceiver",
		"RTCRtpSender",
		"RTCSctpTransport",
		"RTCSessionDescription",
		"RTCStatsReport",
		"RTCTrackEvent",
		"screen",
		"Screen",
		"screenLeft",
		"ScreenOrientation",
		"screenTop",
		"screenX",
		"screenY",
		"ScriptProcessorNode",
		"scroll",
		"scrollbars",
		"scrollBy",
		"scrollTo",
		"scrollX",
		"scrollY",
		"SecurityPolicyViolationEvent",
		"Selection",
		"self",
		"ServiceWorker",
		"ServiceWorkerContainer",
		"ServiceWorkerRegistration",
		"sessionStorage",
		"setInterval",
		"setTimeout",
		"ShadowRoot",
		"SharedWorker",
		"SourceBuffer",
		"SourceBufferList",
		"speechSynthesis",
		"SpeechSynthesisEvent",
		"SpeechSynthesisUtterance",
		"StaticRange",
		"status",
		"statusbar",
		"StereoPannerNode",
		"stop",
		"Storage",
		"StorageEvent",
		"StorageManager",
		"styleMedia",
		"StyleSheet",
		"StyleSheetList",
		"SubtleCrypto",
		"SVGAElement",
		"SVGAngle",
		"SVGAnimatedAngle",
		"SVGAnimatedBoolean",
		"SVGAnimatedEnumeration",
		"SVGAnimatedInteger",
		"SVGAnimatedLength",
		"SVGAnimatedLengthList",
		"SVGAnimatedNumber",
		"SVGAnimatedNumberList",
		"SVGAnimatedPreserveAspectRatio",
		"SVGAnimatedRect",
		"SVGAnimatedString",
		"SVGAnimatedTransformList",
		"SVGAnimateElement",
		"SVGAnimateMotionElement",
		"SVGAnimateTransformElement",
		"SVGAnimationElement",
		"SVGCircleElement",
		"SVGClipPathElement",
		"SVGComponentTransferFunctionElement",
		"SVGDefsElement",
		"SVGDescElement",
		"SVGDiscardElement",
		"SVGElement",
		"SVGEllipseElement",
		"SVGFEBlendElement",
		"SVGFEColorMatrixElement",
		"SVGFEComponentTransferElement",
		"SVGFECompositeElement",
		"SVGFEConvolveMatrixElement",
		"SVGFEDiffuseLightingElement",
		"SVGFEDisplacementMapElement",
		"SVGFEDistantLightElement",
		"SVGFEDropShadowElement",
		"SVGFEFloodElement",
		"SVGFEFuncAElement",
		"SVGFEFuncBElement",
		"SVGFEFuncGElement",
		"SVGFEFuncRElement",
		"SVGFEGaussianBlurElement",
		"SVGFEImageElement",
		"SVGFEMergeElement",
		"SVGFEMergeNodeElement",
		"SVGFEMorphologyElement",
		"SVGFEOffsetElement",
		"SVGFEPointLightElement",
		"SVGFESpecularLightingElement",
		"SVGFESpotLightElement",
		"SVGFETileElement",
		"SVGFETurbulenceElement",
		"SVGFilterElement",
		"SVGForeignObjectElement",
		"SVGGElement",
		"SVGGeometryElement",
		"SVGGradientElement",
		"SVGGraphicsElement",
		"SVGImageElement",
		"SVGLength",
		"SVGLengthList",
		"SVGLinearGradientElement",
		"SVGLineElement",
		"SVGMarkerElement",
		"SVGMaskElement",
		"SVGMatrix",
		"SVGMetadataElement",
		"SVGMPathElement",
		"SVGNumber",
		"SVGNumberList",
		"SVGPathElement",
		"SVGPatternElement",
		"SVGPoint",
		"SVGPointList",
		"SVGPolygonElement",
		"SVGPolylineElement",
		"SVGPreserveAspectRatio",
		"SVGRadialGradientElement",
		"SVGRect",
		"SVGRectElement",
		"SVGScriptElement",
		"SVGSetElement",
		"SVGStopElement",
		"SVGStringList",
		"SVGStyleElement",
		"SVGSVGElement",
		"SVGSwitchElement",
		"SVGSymbolElement",
		"SVGTextContentElement",
		"SVGTextElement",
		"SVGTextPathElement",
		"SVGTextPositioningElement",
		"SVGTitleElement",
		"SVGTransform",
		"SVGTransformList",
		"SVGTSpanElement",
		"SVGUnitTypes",
		"SVGUseElement",
		"SVGViewElement",
		"TaskAttributionTiming",
		"Text",
		"TextDecoder",
		"TextEncoder",
		"TextEvent",
		"TextMetrics",
		"TextTrack",
		"TextTrackCue",
		"TextTrackCueList",
		"TextTrackList",
		"TimeRanges",
		"toolbar",
		"top",
		"Touch",
		"TouchEvent",
		"TouchList",
		"TrackEvent",
		"TransitionEvent",
		"TreeWalker",
		"UIEvent",
		"URL",
		"URLSearchParams",
		"ValidityState",
		"visualViewport",
		"VisualViewport",
		"VTTCue",
		"WaveShaperNode",
		"WebAssembly",
		"WebGL2RenderingContext",
		"WebGLActiveInfo",
		"WebGLBuffer",
		"WebGLContextEvent",
		"WebGLFramebuffer",
		"WebGLProgram",
		"WebGLQuery",
		"WebGLRenderbuffer",
		"WebGLRenderingContext",
		"WebGLSampler",
		"WebGLShader",
		"WebGLShaderPrecisionFormat",
		"WebGLSync",
		"WebGLTexture",
		"WebGLTransformFeedback",
		"WebGLUniformLocation",
		"WebGLVertexArrayObject",
		"WebSocket",
		"WheelEvent",
		"window",
		"Window",
		"Worker",
		"WritableStream",
		"XMLDocument",
		"XMLHttpRequest",
		"XMLHttpRequestEventTarget",
		"XMLHttpRequestUpload",
		"XMLSerializer",
		"XPathEvaluator",
		"XPathExpression",
		"XPathResult",
		"XSLTProcessor",
	];

	const ___R$project$rome$$internal$compiler$scope$globals_ts$worker = [
		"addEventListener",
		"applicationCache",
		"atob",
		"Blob",
		"BroadcastChannel",
		"btoa",
		"Cache",
		"caches",
		"clearInterval",
		"clearTimeout",
		"close",
		"console",
		"fetch",
		"FileReaderSync",
		"FormData",
		"Headers",
		"IDBCursor",
		"IDBCursorWithValue",
		"IDBDatabase",
		"IDBFactory",
		"IDBIndex",
		"IDBKeyRange",
		"IDBObjectStore",
		"IDBOpenDBRequest",
		"IDBRequest",
		"IDBTransaction",
		"IDBVersionChangeEvent",
		"ImageData",
		"importScripts",
		"indexedDB",
		"location",
		"MessageChannel",
		"MessagePort",
		"name",
		"navigator",
		"Notification",
		"onclose",
		"onconnect",
		"onerror",
		"onlanguagechange",
		"onmessage",
		"onoffline",
		"ononline",
		"onrejectionhandled",
		"onunhandledrejection",
		"performance",
		"Performance",
		"PerformanceEntry",
		"PerformanceMark",
		"PerformanceMeasure",
		"PerformanceNavigation",
		"PerformanceResourceTiming",
		"PerformanceTiming",
		"postMessage",
		"Promise",
		"queueMicrotask",
		"removeEventListener",
		"Request",
		"Response",
		"self",
		"ServiceWorkerRegistration",
		"setInterval",
		"setTimeout",
		"TextDecoder",
		"TextEncoder",
		"URL",
		"URLSearchParams",
		"WebSocket",
		"Worker",
		"WorkerGlobalScope",
		"XMLHttpRequest",
	];

	const ___R$project$rome$$internal$compiler$scope$globals_ts$node = [
		"__dirname",
		"__filename",
		"Buffer",
		"clearImmediate",
		"clearInterval",
		"clearTimeout",
		"console",
		"exports",
		"global",
		"Intl",
		"module",
		"process",
		"queueMicrotask",
		"require",
		"setImmediate",
		"setInterval",
		"setTimeout",
		"TextDecoder",
		"TextEncoder",
		"URL",
		"URLSearchParams",
	];

	const ___R$project$rome$$internal$compiler$scope$globals_ts$commonjs = [
		"exports",
		"global",
		"module",
		"require",
	];

	const ___R$project$rome$$internal$compiler$scope$globals_ts$serviceworker = [
		"addEventListener",
		"applicationCache",
		"atob",
		"Blob",
		"BroadcastChannel",
		"btoa",
		"Cache",
		"caches",
		"CacheStorage",
		"clearInterval",
		"clearTimeout",
		"Client",
		"clients",
		"Clients",
		"close",
		"console",
		"ExtendableEvent",
		"ExtendableMessageEvent",
		"fetch",
		"FetchEvent",
		"FileReaderSync",
		"FormData",
		"Headers",
		"IDBCursor",
		"IDBCursorWithValue",
		"IDBDatabase",
		"IDBFactory",
		"IDBIndex",
		"IDBKeyRange",
		"IDBObjectStore",
		"IDBOpenDBRequest",
		"IDBRequest",
		"IDBTransaction",
		"IDBVersionChangeEvent",
		"ImageData",
		"importScripts",
		"indexedDB",
		"location",
		"MessageChannel",
		"MessagePort",
		"name",
		"navigator",
		"Notification",
		"onclose",
		"onconnect",
		"onerror",
		"onfetch",
		"oninstall",
		"onlanguagechange",
		"onmessage",
		"onmessageerror",
		"onnotificationclick",
		"onnotificationclose",
		"onoffline",
		"ononline",
		"onpush",
		"onpushsubscriptionchange",
		"onrejectionhandled",
		"onsync",
		"onunhandledrejection",
		"performance",
		"Performance",
		"PerformanceEntry",
		"PerformanceMark",
		"PerformanceMeasure",
		"PerformanceNavigation",
		"PerformanceResourceTiming",
		"PerformanceTiming",
		"postMessage",
		"Promise",
		"queueMicrotask",
		"registration",
		"removeEventListener",
		"Request",
		"Response",
		"self",
		"ServiceWorker",
		"ServiceWorkerContainer",
		"ServiceWorkerGlobalScope",
		"ServiceWorkerMessageEvent",
		"ServiceWorkerRegistration",
		"setInterval",
		"setTimeout",
		"skipWaiting",
		"TextDecoder",
		"TextEncoder",
		"URL",
		"URLSearchParams",
		"WebSocket",
		"WindowClient",
		"Worker",
		"WorkerGlobalScope",
		"XMLHttpRequest",
	];


  // project-rome/@internal/compiler/scope/Scope.ts
Error.stackTraceLimit = Infinity;

	class ___R$project$rome$$internal$compiler$scope$Scope_ts$default {
		constructor(
			{
				kind,
				node,
				parentScope,
				rootScope,
			},
		) {
			this.parentScope = parentScope;
			this.rootScope = rootScope;
			this.node = node;
			this.kind = kind;
			this.bindings = new Map();
			this.globals = new Set();
			this.childScopeCache = new WeakMap();
		}

		getOwnBindings() {
			return this.bindings;
		}

		getBindingNames() {
			let bindingNames = [];

			let scope = this;
			while (scope !== undefined) {
				bindingNames = [...bindingNames, ...scope.getOwnBindingNames()];
				scope = scope.parentScope;
			}

			return Array.from(new Set(bindingNames));
		}

		getOwnBindingNames() {
			return Array.from(this.bindings.keys());
		}

		getRootScope() {
			const {rootScope} = this;
			if (rootScope === undefined) {
				throw new Error("Expected rootScope");
			}
			return rootScope;
		}

		enterEvaluate(
			node,
			parent = ___R$project$rome$$internal$ast$common$core$MockParent_ts$MOCK_PARENT,
			force = false,
		) {
			if (node === undefined) {
				return this;
			}

			if (!force && node === this.node) {
				return this;
			}

			const cached = this.childScopeCache.get(node);
			if (cached !== undefined) {
				return cached;
			}

			const evaluator = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$default.get(
				node.type,
			);
			if (evaluator === undefined || evaluator.enter === undefined) {
				return this;
			}

			let scope = evaluator.enter(node, parent, this);
			this.childScopeCache.set(node, scope);

			return scope;
		}

		injectEvaluate(node, parent) {
			if (node === undefined) {
				return;
			}

			const evaluator = ___R$project$rome$$internal$compiler$scope$evaluators$index_ts$default.get(
				node.type,
			);
			if (evaluator === undefined || evaluator.inject === undefined) {
				return;
			}

			evaluator.inject(node, parent, this);
		}

		fork(kind, node) {
			const rootScope = this.getRootScope();
			return new ___R$project$rome$$internal$compiler$scope$Scope_ts$default({
				kind,
				node,
				parentScope: this,
				rootScope,
			});
		}

		// Debug utility for dumping scope information
		dump() {
			const lines = [];

			lines.push("# Scope " + this.kind);

			if (this.globals.size > 0) {
				const filteredGlobals = [];
				for (const name of this.globals) {
					if (
						___R$$priv$project$rome$$internal$compiler$scope$Scope_ts$globalGlobals.includes(
							name,
						)
					) {
						continue;
					}

					filteredGlobals.push(name);
				}

				if (filteredGlobals.length > 0) {
					lines.push("## Globals");

					for (const name of filteredGlobals) {
						lines.push(" * " + name);
					}
				}
			}

			if (this.bindings.size > 0) {
				lines.push("## Variables");
				for (const [name, binding] of this.bindings) {
					lines.push(" * " + binding.kind + " " + name);
				}
			}

			return lines.join("\n");
		}

		getBindingFromPath(path) {
			const {node} = path;
			if (
				___R$project$rome$$internal$js$ast$utils$isVariableIdentifier_ts$isVariableIdentifier(
					node,
				)
			) {
				// TODO we can do some isInTypeAnnotation magic to get the proper "type" binding
				return this.getBinding(node.name);
			} else {
				return undefined;
			}
		}

		getBinding(name) {
			const binding = this.bindings.get(name);
			if (binding !== undefined) {
				return binding;
			}

			const {parentScope} = this;
			if (parentScope !== undefined) {
				return parentScope.getBinding(name);
			}

			return undefined;
		}

		getBindingAssert(name) {
			const binding = this.getBinding(name);
			if (binding === undefined) {
				this.dump();
				throw new Error("Expected " + name + " binding");
			}
			return binding;
		}

		addBinding(binding) {
			this.bindings.set(binding.name, binding);
			return binding;
		}

		hasBinding(name) {
			return this.getBinding(name) !== undefined;
		}

		generateUid(name) {
			return this.getRootScope().generateUid(name);
		}

		addGlobal(name) {
			this.globals.add(name);
		}

		isGlobal(name) {
			if (this.globals.has(name)) {
				return true;
			}

			if (this.parentScope !== undefined) {
				return this.parentScope.isGlobal(name);
			}

			return false;
		}
	}

	const ___R$$priv$project$rome$$internal$compiler$scope$Scope_ts$GLOBAL_COMMENT_START = /^([\s+]|)global /;
	const ___R$$priv$project$rome$$internal$compiler$scope$Scope_ts$GLOBAL_COMMENT_COLON = /:(.*?)$/;

	// lol global globals
	const ___R$$priv$project$rome$$internal$compiler$scope$Scope_ts$globalGlobals = [
		...___R$project$rome$$internal$compiler$scope$globals_ts.builtin,
		...___R$project$rome$$internal$compiler$scope$globals_ts.es5,
		...___R$project$rome$$internal$compiler$scope$globals_ts.es2015,
		...___R$project$rome$$internal$compiler$scope$globals_ts.es2017,
		...___R$project$rome$$internal$compiler$scope$globals_ts.browser,
		...___R$project$rome$$internal$compiler$scope$globals_ts.worker,
		...___R$project$rome$$internal$compiler$scope$globals_ts.node,
		...___R$project$rome$$internal$compiler$scope$globals_ts.commonjs,
		...___R$project$rome$$internal$compiler$scope$globals_ts.serviceworker,
	];

	class ___R$project$rome$$internal$compiler$scope$Scope_ts$RootScope
		extends ___R$project$rome$$internal$compiler$scope$Scope_ts$default {
		constructor(context, ast) {
			super({
				kind: "root",
				parentScope: undefined,
				rootScope: undefined,
				node: undefined,
			});
			this.uids = new Set();
			this.context = context;

			this.globals = new Set([
				...___R$$priv$project$rome$$internal$compiler$scope$Scope_ts$globalGlobals,
				...context.project.config.lint.globals,
				...this.parseGlobalComments(ast),
			]);
		}

		parseGlobalComments(ast) {
			const globals = [];

			for (const {value} of ast.comments) {
				// Check if comment starts with "global ", ignoring any leading whitespace
				if (
					!___R$$priv$project$rome$$internal$compiler$scope$Scope_ts$GLOBAL_COMMENT_START.test(
						value,
					)
				) {
					continue;
				}

				// Remove prefix
				const clean = value.replace(
					___R$$priv$project$rome$$internal$compiler$scope$Scope_ts$GLOBAL_COMMENT_START,
					"",
				);

				// Split by commas, supports comments like "foo, bar"
				const parts = clean.split(",");

				for (const part of parts) {
					let name = part.trim();

					// Support comments like "foo: true" amd "bar: false"
					if (
						___R$$priv$project$rome$$internal$compiler$scope$Scope_ts$GLOBAL_COMMENT_COLON.test(
							name,
						)
					) {
						const match = part.match(
							___R$$priv$project$rome$$internal$compiler$scope$Scope_ts$GLOBAL_COMMENT_COLON,
						);
						if (match == null) {
							throw new Error(
								"Used RegExp.test already so know this will always match",
							);
						}

						// Remove everything after the colon
						name = name.replace(
							___R$$priv$project$rome$$internal$compiler$scope$Scope_ts$GLOBAL_COMMENT_COLON,
							"",
						);

						const value = match[1].trim();

						// Other tools would flag these as unavailable and remove them from the server set
						// We don't do that, we might want to later though?
						// Also, we should maybe validate the value to only true/false
						if (value === "false") {
							break;
						}
					}

					globals.push(name);
				}
			}

			return globals;
		}

		getRootScope() {
			return this;
		}

		generateUid(name) {
			const prefixed =
				"" +
				___R$project$rome$$internal$compiler$constants_ts$SCOPE_PRIVATE_PREFIX +
				(name == null ? "" : name);

			// Check for invalid names
			if (
				name !== undefined &&
				!___R$project$rome$$internal$js$ast$utils$isValidIdentifierName_ts$isValidIdentifierName(
					name,
				)
			) {
				throw new Error(name + " is not a valid identifier name");
			}

			// TODO find some way to remove the possibility of user bindings colliding with our private prefix
			let counter = 0;

			while (true) {
				const suffix = counter === 0 ? "" : String(counter);
				const name = prefixed + suffix;

				if (this.uids.has(name)) {
					counter++;
				} else {
					this.uids.add(name);
					return name;
				}
			}

			throw new Error("Unreachable");
		}
	}


  // project-rome/@internal/string-escape/constants.ts
const ___R$project$rome$$internal$string$escape$constants_ts = {
		get DOUBLE_QUOTE() {
			return ___R$project$rome$$internal$string$escape$constants_ts$DOUBLE_QUOTE;
		},
		get SINGLE_QUOTE() {
			return ___R$project$rome$$internal$string$escape$constants_ts$SINGLE_QUOTE;
		},
		get TICK_QUOTE() {
			return ___R$project$rome$$internal$string$escape$constants_ts$TICK_QUOTE;
		},
	};
	const ___R$project$rome$$internal$string$escape$constants_ts$DOUBLE_QUOTE = '"';
	const ___R$project$rome$$internal$string$escape$constants_ts$SINGLE_QUOTE = "'";
	const ___R$project$rome$$internal$string$escape$constants_ts$TICK_QUOTE = "`";


  // project-rome/@internal/string-escape/escapeJSString.ts
// This regex represents printable ASCII characters, except the characters: '"\`
	const ___R$$priv$project$rome$$internal$string$escape$escapeJSString_ts$PRINTABLE_ASCII = /[ !#-&\(-\[\]-_a-~]/;

	function ___R$$priv$project$rome$$internal$string$escape$escapeJSString_ts$escapeChar(
		char,
		ignoreWhitespaceEscapes,
	) {
		switch (char) {
			case '"':
				return '\\"';

			case "'":
				return "\\'";

			case "\b":
				return "\\b";

			case "\f":
				return "\\f";

			case "\\":
				return "\\\\";
		}

		switch (char) {
			case "\n":
				return ignoreWhitespaceEscapes ? char : "\\n";

			case "\r":
				return ignoreWhitespaceEscapes ? char : "\\r";

			case "\t":
				return ignoreWhitespaceEscapes ? char : "\\t";
		}

		return undefined;
	}

	function ___R$project$rome$$internal$string$escape$escapeJSString_ts$default(
		str,
		opts = {},
	) {
		let index = -1;
		let result = "";

		const {
			ignoreWhitespaceEscapes = false,
			quote = "",
			json = false,
			unicodeOnly = false,
		} = opts;

		// Loop over each code unit in the string and escape it
		while (++index < str.length) {
			const char = str[index];

			// Handle surrogate pairs in non-JSON mode
			if (!json) {
				const charCode = str.charCodeAt(index);
				const isHighSurrogate = charCode >= 55_296 && charCode <= 56_319;
				const hasNextCodePoint = str.length > index + 1;
				const isSurrogatePairStart = isHighSurrogate && hasNextCodePoint;

				if (isSurrogatePairStart) {
					const nextCharCode = str.charCodeAt(index + 1);
					const isLowSurrogate =
						nextCharCode >= 56_320 && nextCharCode <= 57_343;
					if (isLowSurrogate) {
						// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
						const codePoint =
							(charCode - 55_296) * 1_024 + nextCharCode - 56_320 + 65_536;
						const hex = codePoint.toString(16);
						result += "\\u{" + hex + "}";
						index++;
						continue;
					}
				}
			}

			//
			if (
				___R$$priv$project$rome$$internal$string$escape$escapeJSString_ts$PRINTABLE_ASCII.test(
					char,
				)
			) {
				// It’s a printable ASCII character that is not `"`, `'` or `\`,
				// so don’t escape it.
				result += char;
				continue;
			}

			// Escape double quotes
			if (
				char ===
				___R$project$rome$$internal$string$escape$constants_ts$DOUBLE_QUOTE
			) {
				result += quote === char ? '\\"' : char;
				continue;
			}

			// Escape single quotes
			if (
				char ===
				___R$project$rome$$internal$string$escape$constants_ts$SINGLE_QUOTE
			) {
				result += quote === char ? "\\'" : char;
				continue;
			}

			// Escape back tick
			if (
				char ===
				___R$project$rome$$internal$string$escape$constants_ts$TICK_QUOTE
			) {
				result += quote === char ? "\\`" : char;
				continue;
			}

			// Null escape
			if (
				char === "\0" &&
				!json &&
				!___R$project$rome$$internal$parser$core$utils_ts$isDigit(
					str[index + 1],
				)
			) {
				result += "\\0";
				continue;
			}

			// Simple escapes
			if (!unicodeOnly) {
				const replacement = ___R$$priv$project$rome$$internal$string$escape$escapeJSString_ts$escapeChar(
					char,
					ignoreWhitespaceEscapes,
				);
				if (replacement !== undefined) {
					result += replacement;
					continue;
				}
			}

			// Unicode escape
			const hex = char.charCodeAt(0).toString(16);
			const isLonghand = json || hex.length > 2;
			const modifier = isLonghand ? "u" : "x";
			const code = ("0000" + hex).slice(isLonghand ? -4 : -2);
			const escaped = "\\" + modifier + code;
			result += escaped;
		}

		return "" + quote + result + quote;
	}


  // project-rome/@internal/string-escape/unescapeJSONString.ts
function ___R$$priv$project$rome$$internal$string$escape$unescapeJSONString_ts$unescapeChar(
		modifier,
	) {
		switch (modifier) {
			case "b":
				return "\b";

			case "f":
				return "\f";

			case "n":
				return "\n";

			case "r":
				return "\r";

			case "t":
				return "\t";

			case "v":
				return "\x0b";

			default:
				return modifier;
		}
	}

	const ___R$$priv$project$rome$$internal$string$escape$unescapeJSONString_ts$UNEXPECTED_DEFAULT_THROWER = (
		metadata,
		index,
	) => {
		throw new TypeError(
			___R$project$rome$$internal$markup$escape_ts$readMarkup(metadata.message) +
			" (" +
			String(index) +
			")",
		);
	};

	function ___R$project$rome$$internal$string$escape$unescapeJSONString_ts$default(
		input,
		unexpected = ___R$$priv$project$rome$$internal$string$escape$unescapeJSONString_ts$UNEXPECTED_DEFAULT_THROWER,
		allowWhitespace = false,
	) {
		let buffer = "";

		let index = 0;

		while (index < input.length) {
			const char = input[index];

			if (allowWhitespace) {
				if (char === "\r") {
					// Ignore it
					index++;
					continue;
				}

				if (char === "\n" || char === "\t") {
					// Add it verbatim
					buffer += char;
					index++;
					continue;
				}
			}

			// It's verbatim if it's an escaped backslash or not a backslash
			if (
				(___R$project$rome$$internal$string$utils$isEscaped_ts$isEscaped(
					___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(index),
					input,
				) &&
				char === "\\") ||
				char !== "\\"
			) {
				// Validate that this is a valid character
				const codePoint = char.codePointAt(0);
				if (codePoint === undefined) {
					throw new Error("Already validated that this index exists");
				}
				if (codePoint >= 0 && codePoint <= 31) {
					throw unexpected(
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.STRING_ESCAPE.INVALID_STRING_CHARACTER,
						index,
					);
				}

				// Add it verbatim
				buffer += char;
				index++;
				continue;
			}

			// Anything after here is escaped
			const modifierIndex = index + 1;
			const modifier = input[modifierIndex];

			if (modifier === "u") {
				// Get the next 4 characters as the code point
				const codeStartIndex = modifierIndex + 1;
				const rawCode = input.slice(codeStartIndex, codeStartIndex + 4);

				// Validate that we have at least 4 digits
				if (rawCode.length < 4) {
					// (index of the point start + total point digits)
					const lastDigitIndex = codeStartIndex + rawCode.length - 1;
					throw unexpected(
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.STRING_ESCAPE.NOT_ENOUGH_CODE_POINTS,
						lastDigitIndex,
					);
				}

				// Validate that each character is a valid hex digit
				for (let i = 0; i < rawCode.length; i++) {
					const char = rawCode[i];
					if (!___R$project$rome$$internal$parser$core$utils_ts$isHexDigit(char)) {
						// Get the current source index for this character
						// (code start index + digit index)
						const pos = codeStartIndex + i;
						throw unexpected(
							___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.STRING_ESCAPE.INVALID_HEX_DIGIT_FOR_ESCAPE,
							pos,
						);
					}
				}

				// Validate the code point
				const code = parseInt(rawCode, 16);

				// Get the character for this code point
				buffer += String.fromCodePoint(code);

				// Skip ahead six indexes (1 escape char +  1 modifier + 4 hex digits)
				index += 6;
			} else {
				// Unescape a basic modifier like \t
				buffer += ___R$$priv$project$rome$$internal$string$escape$unescapeJSONString_ts$unescapeChar(
					modifier,
				);

				// Skip ahead two indexes to also take along the modifier
				index += 2;
			}
		}

		return buffer;
	}


  // project-rome/@internal/string-escape/escapeRegex.ts
function ___R$project$rome$$internal$string$escape$escapeRegex_ts$regex(
		strs,
		...values
	) {
		let pattern = "";

		for (let i = 0; i < strs.length; i++) {
			const str = strs.raw[i];
			pattern += str;
			if (i === strs.length - 1) {
				continue;
			}

			const value = values[i];
			if (value instanceof RegExp) {
				pattern += value.source;
			} else {
				pattern += ___R$project$rome$$internal$string$escape$escapeRegex_ts$escapeRegex(
					value,
				);
			}
		}

		return new RegExp(pattern);
	}

	function ___R$project$rome$$internal$string$escape$escapeRegex_ts$escapeRegex(
		part,
	) {
		return part.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
	}


  // project-rome/@internal/string-escape/index.ts



  // project-rome/@internal/pretty-format/index.ts
const ___R$$priv$project$rome$$internal$pretty$format$index_ts$DEFAULT_OPTIONS = {
		allowCustom: true,
		maxDepth: Infinity,
		depth: 0,
		stack: [],
		compact: false,
	};

	const ___R$project$rome$$internal$pretty$format$index_ts$CUSTOM_PRETTY_FORMAT = Symbol.for(
		"custom-pretty-format",
	);

	function ___R$project$rome$$internal$pretty$format$index_ts$prettyFormatToString(
		value,
	) {
		return ___R$project$rome$$internal$cli$layout$format_ts$markupToJoinedPlainText(
			___R$project$rome$$internal$markup$escape_ts$markup`${___R$project$rome$$internal$pretty$format$index_ts$default(
				value,
			)}`,
		);
	}

	function ___R$project$rome$$internal$pretty$format$index_ts$pretty(
		strs,
		...values
	) {
		let out = "";

		for (let i = 0; i < strs.length; i++) {
			const str = strs[i];
			out += str;
			if (i === strs.length - 1) {
				continue;
			}

			const value = values[i];
			out += ___R$project$rome$$internal$pretty$format$index_ts$prettyFormatToString(
				value,
			);
		}

		return out;
	}

	function ___R$project$rome$$internal$pretty$format$index_ts$prettyFormatEager(
		obj,
		opts,
	) {
		return ___R$project$rome$$internal$markup$escape_ts$serializeLazyMarkup(
			___R$project$rome$$internal$pretty$format$index_ts$default(obj, opts),
		);
	}

	function ___R$project$rome$$internal$pretty$format$index_ts$default(
		obj,
		rawOpts = {},
	) {
		return () => {
			const opts = ___R$project$rome$$internal$typescript$helpers$index_ts$mergeObjects(
				___R$$priv$project$rome$$internal$pretty$format$index_ts$DEFAULT_OPTIONS,
				rawOpts,
			);

			if (opts.maxDepth === opts.depth) {
				return ___R$project$rome$$internal$markup$escape_ts$markup`[depth exceeded]`;
			}

			switch (typeof obj) {
				case "symbol": {
					return ___R$project$rome$$internal$markup$escape_ts$markupTag(
						"token",
						___R$$priv$project$rome$$internal$pretty$format$index_ts$formatSymbol(
							obj,
						),
						{type: "string"},
					);
				}

				case "string": {
					return ___R$project$rome$$internal$markup$escape_ts$markupTag(
						"token",
						___R$$priv$project$rome$$internal$pretty$format$index_ts$formatString(
							obj,
						),
						{type: "string"},
					);
				}

				case "bigint":
				case "number": {
					return ___R$project$rome$$internal$markup$escape_ts$markupTag(
						"token",
						___R$project$rome$$internal$pretty$format$index_ts$formatNumber(obj),
						{type: "number"},
					);
				}

				case "boolean": {
					return ___R$project$rome$$internal$markup$escape_ts$markupTag(
						"token",
						___R$$priv$project$rome$$internal$pretty$format$index_ts$formatBoolean(
							obj,
						),
						{type: "boolean"},
					);
				}

				case "undefined": {
					return ___R$project$rome$$internal$markup$escape_ts$markupTag(
						"color",
						___R$$priv$project$rome$$internal$pretty$format$index_ts$formatUndefined(),
						{fg: "brightBlack"},
					);
				}

				case "function":
					return ___R$$priv$project$rome$$internal$pretty$format$index_ts$formatFunction(
						obj,
						opts,
					);

				case "object":
					return ___R$$priv$project$rome$$internal$pretty$format$index_ts$formatObjectish(
						(obj),
						opts,
					);

				default:
					throw new Error("Unknown type");
			}
		};
	}

	function ___R$$priv$project$rome$$internal$pretty$format$index_ts$isNativeFunction(
		val,
	) {
		return val.toString().endsWith("{ [native code] }");
	}

	function ___R$$priv$project$rome$$internal$pretty$format$index_ts$formatSymbol(
		val,
	) {
		return ___R$project$rome$$internal$markup$escape_ts$markup`${String(val)}`;
	}

	function ___R$$priv$project$rome$$internal$pretty$format$index_ts$formatString(
		val,
	) {
		return ___R$project$rome$$internal$markup$escape_ts$markup`${___R$project$rome$$internal$string$escape$escapeJSString_ts$default(
			val,
			{
				quote: '"',
			},
		)}`;
	}

	// This function is used by rome-json so make sure it can parse whatever you return here
	function ___R$project$rome$$internal$pretty$format$index_ts$formatNumber(val) {
		if (typeof val === "bigint") {
			return ___R$project$rome$$internal$markup$escape_ts$markup`<number>${String(
				val,
			)}</number>n`;
		} else if (isNaN(val)) {
			return ___R$project$rome$$internal$markup$escape_ts$markup`NaN`;
		} else if (Object.is(val, -0)) {
			return ___R$project$rome$$internal$markup$escape_ts$markup`-0`;
		} else if (isFinite(val)) {
			return ___R$project$rome$$internal$markup$escape_ts$markup`${val}`;
		} else if (Object.is(val, -Infinity)) {
			return ___R$project$rome$$internal$markup$escape_ts$markup`-Infinity`;
		} else if (Object.is(val, +Infinity)) {
			return ___R$project$rome$$internal$markup$escape_ts$markup`Infinity`;
		} else {
			throw new Error("Don't know how to format this number");
		}
	}

	function ___R$$priv$project$rome$$internal$pretty$format$index_ts$formatUndefined() {
		return ___R$project$rome$$internal$markup$escape_ts$markup`undefined`;
	}

	function ___R$$priv$project$rome$$internal$pretty$format$index_ts$formatNull() {
		return ___R$project$rome$$internal$markup$escape_ts$markup`null`;
	}

	function ___R$$priv$project$rome$$internal$pretty$format$index_ts$formatBoolean(
		val,
	) {
		return val
			? ___R$project$rome$$internal$markup$escape_ts$markup`true`
			: ___R$project$rome$$internal$markup$escape_ts$markup`false`;
	}

	function ___R$$priv$project$rome$$internal$pretty$format$index_ts$formatFunction(
		val,
		opts,
	) {
		const name = val.name === "" ? "anonymous" : val.name;
		let label = ___R$project$rome$$internal$markup$escape_ts$markup`Function ${name}`;

		if (
			___R$$priv$project$rome$$internal$pretty$format$index_ts$isNativeFunction(
				val,
			)
		) {
			label = ___R$project$rome$$internal$markup$escape_ts$markup`Native${label}`;
		}

		if (Object.keys(val).length === 0) {
			return label;
		}

		// rome-ignore lint/ts/noExplicitAny: future cleanup
		return ___R$$priv$project$rome$$internal$pretty$format$index_ts$formatObject(
			label,
			(val),
			opts,
			[],
		);
	}

	function ___R$$priv$project$rome$$internal$pretty$format$index_ts$getExtraObjectProps(
		obj,
		opts,
	) {
		const props = [];
		const ignoreKeys = {};

		if (___R$project$rome$$internal$typescript$helpers$index_ts$isIterable(obj)) {
			// Duck typing Map check
			if (
				typeof obj.keys === "function" &&
				typeof obj.values === "function" &&
				typeof obj.size === "number"
			) {
				for (const item of obj) {
					if (Array.isArray(item) && item.length === 2) {
						const [key, val] = item;
						const formattedKey =
							typeof key === "string"
								? ___R$$priv$project$rome$$internal$pretty$format$index_ts$formatKey(
										key,
									)
								: ___R$project$rome$$internal$pretty$format$index_ts$default(
										key,
										opts,
									);
						props.push(
							___R$project$rome$$internal$markup$escape_ts$markup`${formattedKey} => ${___R$project$rome$$internal$pretty$format$index_ts$default(
								val,
								opts,
							)}`,
						);
					} else {
						props.push(
							___R$project$rome$$internal$markup$escape_ts$markup`${___R$project$rome$$internal$pretty$format$index_ts$default(
								item,
								opts,
							)}`,
						);
					}
				}
			} else {
				let i = 0;
				for (const val of obj) {
					ignoreKeys[String(i++)] = val;
					props.push(
						___R$project$rome$$internal$markup$escape_ts$markup`${___R$project$rome$$internal$pretty$format$index_ts$default(
							val,
							opts,
						)}`,
					);
				}
			}
		}

		return {ignoreKeys, props};
	}

	function ___R$$priv$project$rome$$internal$pretty$format$index_ts$formatKey(
		rawKey,
	) {
		// Format as a string if it contains any special characters
		if (/[^A-Za-z0-9_$]/g.test(rawKey)) {
			return ___R$$priv$project$rome$$internal$pretty$format$index_ts$formatString(
				rawKey,
			);
		} else {
			return ___R$project$rome$$internal$markup$escape_ts$markup`${rawKey}`;
		}
	}

	// These are object keys that should always go at the top and ignore any alphabetization
	// This is fairly arbitrary but should include generic identifier keys
	const ___R$project$rome$$internal$pretty$format$index_ts$PRIORITIZE_KEYS = [
		"id",
		"type",
		"kind",
		"key",
		"name",
		"value",
	];

	function ___R$$priv$project$rome$$internal$pretty$format$index_ts$sortKeys(
		obj,
	) {
		const sortedKeys = new Set(
			Object.keys(obj).sort(
				___R$project$rome$$internal$string$utils$naturalCompare_ts$naturalCompare,
			),
		);

		const priorityKeys = [];
		const otherKeys = [];
		const objectKeys = [];

		for (const key of ___R$project$rome$$internal$pretty$format$index_ts$PRIORITIZE_KEYS) {
			if (sortedKeys.has(key)) {
				priorityKeys.push({key, object: false});
				sortedKeys.delete(key);
			}
		}

		for (const key of sortedKeys) {
			const val = obj[key];

			// Objects with properties should be at the bottom
			let isObject = false;
			if (typeof val === "object" && val != null && Object.keys(val).length > 0) {
				isObject = true;
			}
			if (Array.isArray(val) && val.length > 0) {
				isObject = true;
			}
			if (isObject) {
				objectKeys.push({key, object: true});
			} else {
				otherKeys.push({key, object: false});
			}
		}

		return [...priorityKeys, ...otherKeys, ...objectKeys];
	}

	function ___R$$priv$project$rome$$internal$pretty$format$index_ts$lineCount(
		str,
	) {
		return str.split("\n").length;
	}

	function ___R$$priv$project$rome$$internal$pretty$format$index_ts$lineCountCompare(
		a,
		b,
	) {
		return (
			___R$$priv$project$rome$$internal$pretty$format$index_ts$lineCount(a) -
			___R$$priv$project$rome$$internal$pretty$format$index_ts$lineCount(b)
		);
	}

	function ___R$$priv$project$rome$$internal$pretty$format$index_ts$formatObjectLabel(
		label,
	) {
		return ___R$project$rome$$internal$markup$escape_ts$markupTag(
			"color",
			label,
			{fg: "cyan"},
		);
	}

	function ___R$$priv$project$rome$$internal$pretty$format$index_ts$formatObject(
		label,
		obj,
		opts,
		labelKeys,
	) {
		// Detect circular references, and create a pointer to the specific value
		const {stack} = opts;
		if (stack.length > 0 && stack.includes(obj)) {
			label = ___R$project$rome$$internal$markup$escape_ts$markup`Circular ${label} ${String(
				stack.indexOf(obj),
			)}`;
			return ___R$$priv$project$rome$$internal$pretty$format$index_ts$formatObjectLabel(
				label,
			);
		}

		const customFormat = obj[___R$project$rome$$internal$pretty$format$index_ts$CUSTOM_PRETTY_FORMAT];
		if (opts.allowCustom && typeof customFormat === "function") {
			return ___R$project$rome$$internal$markup$escape_ts$markupTag(
				"dim",
				___R$project$rome$$internal$markup$escape_ts$markup`${String(
					customFormat.call(obj),
				)}`,
			);
		}

		//
		const nextOpts = Object.assign(
			{},
			opts,
			{stack: [...stack, obj], depth: opts.depth + 1},
		);
		const {ignoreKeys, props} = ___R$$priv$project$rome$$internal$pretty$format$index_ts$getExtraObjectProps(
			obj,
			nextOpts,
		);

		// For props that have object values, we always put them at the end, sorted by line count
		const objProps = [];

		// Get string props
		for (const {key, object} of ___R$$priv$project$rome$$internal$pretty$format$index_ts$sortKeys(
			obj,
		)) {
			const val = obj[key];
			if (key in ignoreKeys && ignoreKeys[key] === val) {
				continue;
			}

			if (opts.compact && val === undefined) {
				continue;
			}

			// Ignore any properties already displayed in the label
			if (labelKeys.includes(key)) {
				continue;
			}

			const prop = ___R$project$rome$$internal$markup$escape_ts$markup`${___R$$priv$project$rome$$internal$pretty$format$index_ts$formatKey(
				key,
			)}: ${___R$project$rome$$internal$pretty$format$index_ts$default(
				val,
				nextOpts,
			)}`;
			if (object) {
				objProps.push(prop);
			} else {
				props.push(prop);
			}
		}

		// Sort object props by line count and push them on
		for (const prop of objProps.sort((a, b) =>
			___R$$priv$project$rome$$internal$pretty$format$index_ts$lineCountCompare(
				___R$project$rome$$internal$markup$escape_ts$readMarkup(a),
				___R$project$rome$$internal$markup$escape_ts$readMarkup(b),
			)
		)) {
			props.push(prop);
		}

		// Get symbol props
		for (const sym of Object.getOwnPropertySymbols(obj)) {
			const val = Reflect.get(obj, sym);
			props.push(
				___R$project$rome$$internal$markup$escape_ts$markup`${___R$project$rome$$internal$pretty$format$index_ts$default(
					sym,
					opts,
				)}: ${___R$project$rome$$internal$pretty$format$index_ts$default(
					val,
					nextOpts,
				)}`,
			);
		}

		//
		let open = "{";
		let close = "}";
		if (___R$project$rome$$internal$typescript$helpers$index_ts$isIterable(obj)) {
			open = "[";
			close = "]";
		}

		//
		let inner = ___R$project$rome$$internal$markup$escape_ts$concatMarkup(
			props,
			___R$project$rome$$internal$markup$escape_ts$markup`\n`,
		);
		if (
			props.length > 1 ||
			___R$project$rome$$internal$markup$escape_ts$readMarkup(inner).includes(
				"\n",
			)
		) {
			inner = ___R$project$rome$$internal$markup$escape_ts$markup`\n<indent>${inner}</indent>\n`;
		}

		return ___R$project$rome$$internal$markup$escape_ts$markup`${___R$$priv$project$rome$$internal$pretty$format$index_ts$formatObjectLabel(
			label,
		)} ${open}${inner}${close}`;
	}

	function ___R$$priv$project$rome$$internal$pretty$format$index_ts$formatRegExp(
		val,
	) {
		return ___R$project$rome$$internal$markup$escape_ts$markup`${String(val)}`;
	}

	function ___R$$priv$project$rome$$internal$pretty$format$index_ts$formatDate(
		val,
	) {
		return ___R$project$rome$$internal$markup$escape_ts$markup`${val.toISOString()}`;
	}

	function ___R$$priv$project$rome$$internal$pretty$format$index_ts$formatObjectish(
		val,
		opts,
	) {
		if (val === null) {
			return ___R$project$rome$$internal$markup$escape_ts$markupTag(
				"emphasis",
				___R$$priv$project$rome$$internal$pretty$format$index_ts$formatNull(),
			);
		}

		if (val instanceof RegExp) {
			return ___R$project$rome$$internal$markup$escape_ts$markupTag(
				"color",
				___R$$priv$project$rome$$internal$pretty$format$index_ts$formatRegExp(
					val,
				),
				{fg: "red"},
			);
		}

		if (val instanceof Date) {
			const str = ___R$$priv$project$rome$$internal$pretty$format$index_ts$formatDate(
				val,
			);
			return ___R$project$rome$$internal$markup$escape_ts$markupTag(
				"color",
				str,
				{fg: "magenta"},
			);
		}

		let labelKeys = [];

		let label = ___R$project$rome$$internal$markup$escape_ts$markup`null`;

		if (val.constructor !== undefined) {
			label = ___R$project$rome$$internal$markup$escape_ts$markup`${val.constructor.name}`;

			if (val.constructor.name === "Object") {
				if (typeof val.type === "string") {
					label = ___R$project$rome$$internal$markup$escape_ts$markup`${val.type}`;
					labelKeys.push("type");
				} else if (typeof val.kind === "string") {
					label = ___R$project$rome$$internal$markup$escape_ts$markup`${val.kind}`;
					labelKeys.push("kind");
				}
			}
		}

		return ___R$$priv$project$rome$$internal$pretty$format$index_ts$formatObject(
			label,
			val,
			opts,
			labelKeys,
		);
	}


  // project-rome/@internal/compiler/methods/reduce.ts
/**
 * Validate the return value of an enter or exit transform
 */
	function ___R$$priv$project$rome$$internal$compiler$methods$reduce_ts$validateSignal(
		transformName,
		signal,
		path,
	) {
		// Verify common mistake of forgetting to return something
		if (typeof signal === "undefined") {
			throw new Error(
				"Returned `undefined` from transform " +
				transformName +
				". If you meant to delete this node then use `return" +
				" REDUCE_REMOVE`, otherwise if you want to keep it then use `return path.node;`",
			);
		}

		// Ignore some constants that will be handled later
		if (signal.type === "REMOVE") {
			return;
		}

		// Handle returning an array of nodes
		if (signal.type === "REPLACE" && Array.isArray(signal.value)) {
			// keyed nodes cannot be replaced with an array of nodes
			if (path.opts.noArrays === true) {
				throw new Error(
					"Cannot replace this keyed node " +
					path.parent.type +
					"[" +
					path.opts.nodeKey +
					"] with an array of nodes - originated from transform " +
					transformName,
				);
			}
			return;
		}

		// Verify that it's a valid node
		if (
			signal.type === "REPLACE" &&
			!___R$project$rome$$internal$js$ast$utils$isNodeLike_ts$isNodeLike(
				signal.value,
			)
		) {
			throw new Error(
				"Expected a return value of a plain object with a `type` property or a reduce constant - originated from 'transform " +
				transformName,
			);
		}
	}

	// Consider a replace signal with the same value as the path to be a retain signal
	// Many reasons we could emit a replace when we mean a retain just by nature of
	// passing nodes around.
	function ___R$$priv$project$rome$$internal$compiler$methods$reduce_ts$isRetainSignal(
		node,
		signal,
	) {
		switch (signal.type) {
			case "RETAIN":
				return true;

			case "REPLACE":
				return node === signal.value;

			default:
				return false;
		}
	}

	function ___R$$priv$project$rome$$internal$compiler$methods$reduce_ts$maybeFork(
		path,
		signal,
	) {
		if (
			___R$$priv$project$rome$$internal$compiler$methods$reduce_ts$isRetainSignal(
				path.node,
				signal,
			)
		) {
			return path;
		} else {
			const {value} = signal;
			if (Array.isArray(value)) {
				throw new Error(
					"Should have already refined away a replace of Arrays with shouldBailReduce",
				);
			}
			return path.fork(value);
		}
	}

	// Process a parent signal. If it refers to this node, it's a replacement, otherwise bubble it up.
	function ___R$$priv$project$rome$$internal$compiler$methods$reduce_ts$normalizeParentSignalReturn(
		node,
		signal,
	) {
		if (signal.parent === node) {
			return signal.signal;
		} else {
			return signal;
		}
	}

	/**
 * Given a return value from a transform, determine if we should bail out.
 * Bailing out means returning the actual signal and making the parent reduce
 * call handle it (if any).
 */
	function ___R$$priv$project$rome$$internal$compiler$methods$reduce_ts$shouldBailReduce(
		signal,
	) {
		if (signal.type === "REPLACE" && Array.isArray(signal.value)) {
			// We just return the array of nodes, without transforming them
			// reduce() calls higher in the chain will splice this array and do it's
			// own transform call so when the transform is performed on the node it's
			// in it's correct place in the tree
			return true;
		}

		// This node is being removed, no point recursing into it
		if (signal.type === "REMOVE") {
			return true;
		}

		// Bail on parent signals. We'll be handled higher in the tree.
		if (signal.type === "PARENT") {
			return true;
		}

		return false;
	}

	function ___R$project$rome$$internal$compiler$methods$reduce_ts$reduceNode(
		ast,
		visitors,
		context,
		pathOpts = {},
	) {
		const res = ___R$$priv$project$rome$$internal$compiler$methods$reduce_ts$_reduceSignal(
			ast,
			Array.isArray(visitors) ? visitors : [visitors],
			context,
			pathOpts,
		);

		switch (res.type) {
			case "REMOVE":
				throw new Error(
					___R$project$rome$$internal$pretty$format$index_ts$pretty`reduceEntry: Invalid symbol returned from reduceChild. Result: ${res}`,
				);

			case "PARENT":
				throw new Error(
					___R$project$rome$$internal$pretty$format$index_ts$pretty`reduceEntry: Invalid parent signal returned from reduceChild. Parent was not in the tree. Result: ${res}`,
				);

			case "RETAIN":
				return ast;

			case "REPLACE":
				return res.value;
		}
	}

	function ___R$project$rome$$internal$compiler$methods$reduce_ts$reduceSignal(
		ast,
		visitors,
		context,
		pathOpts = {},
	) {
		return ___R$$priv$project$rome$$internal$compiler$methods$reduce_ts$_reduceSignal(
			ast,
			Array.isArray(visitors) ? visitors : [visitors],
			context,
			pathOpts,
		);
	}

	// This method is pretty gnarly and deeply nested but is very important from a performance perspective
	function ___R$$priv$project$rome$$internal$compiler$methods$reduce_ts$_reduceSignal(
		origNode,
		visitors,
		context,
		pathOpts,
	) {
		// Initialize first path
		let path = new ___R$project$rome$$internal$compiler$lib$Path_ts$default(
			origNode,
			context,
			pathOpts,
		);

		const popState = new Set();

		try {
			// Perform enter transforms
			for (const visitor of visitors) {
				const {enter} = visitor;
				if (enter === undefined) {
					continue;
				}

				// Fetch state
				const state = context.getVisitorState(visitor);
				state.setCurrentPath(path);

				// Call transformer
				let signal = enter(path, state);
				if (state.checkPushed()) {
					// If we inserted new state then remember to pop it off when we're done
					popState.add(state);
				}

				if (!path.context.frozen) {
					// When returning this symbol, it indicates we should skip the subtree
					if (signal.type === "SKIP") {
						return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
					}

					// Validate the return value
					___R$$priv$project$rome$$internal$compiler$methods$reduce_ts$validateSignal(
						visitor.name,
						signal,
						path,
					);

					// Check if we need to bail out. See the comment for shouldBailReduce on what that means
					if (
						___R$$priv$project$rome$$internal$compiler$methods$reduce_ts$shouldBailReduce(
							signal,
						)
					) {
						return signal;
					}

					// Create new path if node has been changed
					path = ___R$$priv$project$rome$$internal$compiler$methods$reduce_ts$maybeFork(
						path,
						signal,
					);
				}
			}

			// Reduce the children
			let {node} = path;
			const visitorKeys = ___R$project$rome$$internal$ast$utils_ts$visitorKeys.get(
				node.type,
			);
			if (visitorKeys !== undefined) {
				// Build the ancestry paths that we'll pass to each child path
				const ancestryPaths = pathOpts.ancestryPaths || [];
				let childAncestryPaths = [path].concat(ancestryPaths);

				// Reduce the children
				for (const key of visitorKeys) {
					// rome-ignore lint/ts/noExplicitAny: future cleanup
					const oldVal = (node)[key];

					if (Array.isArray(oldVal)) {
						let children = oldVal;

						// When removing items from the children array, we decrement this offset and subtract it
						// whenever looking up to get the correct position
						let childrenOffset = 0;

						// This needs to be calculated beforehand as the length of the array may change when removing
						// items
						let length = children.length;

						for (let i = 0; i < length; i++) {
							// Calculate the correct index that this children can be found at
							const correctedIndex = childrenOffset + i;

							// Get the child
							const child = children[correctedIndex];

							// An array may be mixed containing [undefined, Node] etc so check that it's actually a valid node
							// An example of a property with empty elements is an JSArrayExpression with holes
							if (
								___R$project$rome$$internal$js$ast$utils$isNodeLike_ts$isNodeLike(
									child,
								)
							) {
								// Run transforms on this node
								const newSignal = ___R$$priv$project$rome$$internal$compiler$methods$reduce_ts$_reduceSignal(
									child,
									visitors,
									context,
									{
										noScopeCreation: pathOpts.noScopeCreation,
										parentScope: path.scope,
										ancestryPaths: childAncestryPaths,
										listKey: correctedIndex,
										nodeKey: key,
									},
								);

								if (newSignal.type === "PARENT") {
									return ___R$$priv$project$rome$$internal$compiler$methods$reduce_ts$normalizeParentSignalReturn(
										node,
										newSignal,
									);
								}

								// If this item has been changed then...
								if (
									!___R$$priv$project$rome$$internal$compiler$methods$reduce_ts$isRetainSignal(
										child,
										newSignal,
									) &&
									!context.frozen
								) {
									// Clone the children array
									children = children.slice();

									// Check if the item is to be deleted
									// REDUCE_REMOVE or an empty array are considered equivalent
									if (
										newSignal.type === "REMOVE" ||
										(Array.isArray(newSignal.value) &&
										newSignal.value.length === 0)
									) {
										// Remove the item from the array
										children.splice(correctedIndex, 1);

										// Since the array now has one less item, change the offset so all
										// future indices will be correct
										childrenOffset--;
									} else if (Array.isArray(newSignal.value)) {
										var ___R$;
										// Remove the previous, and add the new items to the array
										___R$ = children,
											___R$.splice.apply(
												___R$,
												[correctedIndex, 1, ...newSignal.value],
											);

										// We increase the length of the array so that this loop covers
										// the newly inserted nodes
										// `childrenOffset` is not used here because that's just used to
										// skip elements
										length += newSignal.value.length;

										// Revisit the current index, this is necessary as there's now a
										// new node at this position
										i--;
									} else {
										// Otherwise it's a valid node so set it
										children[correctedIndex] = newSignal.value;

										// Revisit the current index, the node has changed and some
										// transforms may care about it
										i--;
									}

									// Mutate the original node - funky typing since Flow doesn't understand the mutation
									node = (Object.assign({}, node, {[key]: children}));

									// Create a new node path
									path = path.fork(node);

									// And create a new ancestry array for subsequent children
									childAncestryPaths = [path].concat(ancestryPaths);
								}
							}
						}
					} else if (
						___R$project$rome$$internal$js$ast$utils$isNodeLike_ts$isNodeLike(
							oldVal,
						)
					) {
						// Run transforms on this node
						let newSignal = ___R$$priv$project$rome$$internal$compiler$methods$reduce_ts$_reduceSignal(
							oldVal,
							visitors,
							context,
							{
								noScopeCreation: pathOpts.noScopeCreation,
								parentScope: path.scope,
								ancestryPaths: childAncestryPaths,
								noArrays: true,
								nodeKey: key,
							},
						);

						if (newSignal.type === "PARENT") {
							return ___R$$priv$project$rome$$internal$compiler$methods$reduce_ts$normalizeParentSignalReturn(
								node,
								newSignal,
							);
						}

						// If this value has been changed then...
						if (
							!___R$$priv$project$rome$$internal$compiler$methods$reduce_ts$isRetainSignal(
								oldVal,
								newSignal,
							) &&
							!context.frozen
						) {
							let newValue = undefined;
							if (newSignal.type === "REPLACE") {
								newValue = newSignal.value;
							} else if (newSignal.type === "REMOVE") {
								// If the node is deleted then use `undefined` instead
								newValue = undefined;
							}

							// When replacing a key value, we cannot replace it with an array
							if (Array.isArray(newValue)) {
								throw new Error(
									"Cannot replace a key value node with an array of nodes",
								);
							}

							// Mutate the original object - funky typing since Flow doesn't understand the mutation
							node = (Object.assign({}, node, {[key]: newValue}));

							// Create a new node path for it
							path = path.fork(node);

							// And create a new ancestry array for subsequent children
							childAncestryPaths = [path].concat(ancestryPaths);
						}
					} else {
						// not sure what this is...
					}
				}
			}

			// Run exit visitors
			for (const visitor of visitors) {
				if (visitor.exit === undefined) {
					continue;
				}

				const state = context.getVisitorState(visitor);
				state.setCurrentPath(path);

				const signal = visitor.exit(path, state);

				if (!path.context.frozen) {
					___R$$priv$project$rome$$internal$compiler$methods$reduce_ts$validateSignal(
						visitor.name,
						signal,
						path,
					);

					if (
						___R$$priv$project$rome$$internal$compiler$methods$reduce_ts$shouldBailReduce(
							signal,
						)
					) {
						return signal;
					} else {
						path = ___R$$priv$project$rome$$internal$compiler$methods$reduce_ts$maybeFork(
							path,
							signal,
						);
					}
				}
			}

			if (context.frozen) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
			} else {
				return ___R$project$rome$$internal$compiler$index_ts$signals.maybeReplace(
					origNode,
					path.node,
				);
			}
		} finally {
			for (const state of popState) {
				state.pop();
			}
		}
	}


  // project-rome/@internal/path/collections.ts
const ___R$project$rome$$internal$path$collections_ts = {
		get AbsoluteFilePathMap() {
			return ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap;
		},
		get RelativeFilePathMap() {
			return ___R$project$rome$$internal$path$collections_ts$RelativeFilePathMap;
		},
		get UnknownPathMap() {
			return ___R$project$rome$$internal$path$collections_ts$UnknownPathMap;
		},
		get AbsoluteFilePathSet() {
			return ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet;
		},
		get RelativeFilePathSet() {
			return ___R$project$rome$$internal$path$collections_ts$RelativeFilePathSet;
		},
		get UnknownPathSet() {
			return ___R$project$rome$$internal$path$collections_ts$UnknownPathSet;
		},
	};
	// Sometimes we don't want to have to deal with what a FilePath serializes into
	// For those purposes we have these wrappers around Map and Set. Here we can add some custom logic
	// to speed up the usage of FilePaths in these scenarios.
	// The API here attempts to match what is expected from the native classes, however we may deviate from it
	// to avoid the usage of getters and generator/symbol indirection for iteration.
	class ___R$$priv$project$rome$$internal$path$collections_ts$BasePathMap {
		constructor(entries) {
			this.joinedToValue = new Map();
			this.joinedToPath = new Map();
			this.size = 0;

			if (entries !== undefined) {
				for (const [key, value] of entries) {
					this.set(key, value);
				}
			}
		}

		_updateSize() {
			this.size = this.joinedToValue.size;
		}

		*[Symbol.iterator]() {
			for (const [joined, value] of this.joinedToValue) {
				const path = this.joinedToPath.get(joined);
				yield [path, value];
			}
		}

		clear() {
			this.joinedToValue.clear();
			this.joinedToPath.clear();
			this._updateSize();
		}

		entries() {
			return this[Symbol.iterator]();
		}

		keys() {
			return this.joinedToPath.values();
		}

		values() {
			return this.joinedToValue.values();
		}

		delete(path) {
			const joined = path.getUnique().join();
			if (!this.joinedToValue.has(joined)) {
				return false;
			}

			this.joinedToValue.delete(joined);
			this.joinedToPath.delete(joined);
			this._updateSize();
			return true;
		}

		has(path) {
			return this.joinedToValue.has(path.getUnique().join());
		}

		assert(path) {
			const item = this.get(path);
			if (item === undefined) {
				throw new Error("Could not find element for " + path.join());
			} else {
				return item;
			}
		}

		get(path) {
			return this.joinedToValue.get(path.getUnique().join());
		}

		setString(path, value) {
			this.set(this.createKey(path), value);
		}

		set(path, value) {
			const uniq = (path.getUnique());
			const joined = uniq.join();
			this.joinedToValue.set(joined, value);
			this.joinedToPath.set(joined, uniq);
			this._updateSize();
			return this;
		}
	}

	class ___R$$priv$project$rome$$internal$path$collections_ts$BasePathSet {
		constructor(entries) {
			this.map = this.createMap();
			this.size = 0;

			if (entries !== undefined) {
				for (const path of entries) {
					this.add(path);
				}
			}
		}

		createKey(str) {
			return this.map.createKey(str);
		}

		_updateSize() {
			this.size = this.map.size;
		}

		[Symbol.iterator]() {
			return this.map.keys()[Symbol.iterator]();
		}

		toJoined(callback = (filename) => filename) {
			return Array.from(this.map.joinedToPath.keys(), callback);
		}

		has(path) {
			return this.map.has(path);
		}

		add(path) {
			this.map.set(path);
			this._updateSize();
			return this;
		}

		addString(str) {
			this.add(this.createKey(str));
		}

		delete(path) {
			if (this.map.has(path)) {
				this.map.delete(path);
				this._updateSize();
				return true;
			} else {
				return false;
			}
		}

		clear() {
			this.map.clear();
			this._updateSize();
		}
	}

	class ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap
		extends ___R$$priv$project$rome$$internal$path$collections_ts$BasePathMap {
		constructor(...args) {
			super(...args);
			this.type = "absolute";
		}
		createKey(str) {
			return ___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
				str,
			);
		}

		keysToSet() {
			return new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet(
				this.keys(),
			);
		}
	}

	class ___R$project$rome$$internal$path$collections_ts$RelativeFilePathMap
		extends ___R$$priv$project$rome$$internal$path$collections_ts$BasePathMap {
		constructor(...args) {
			super(...args);
			this.type = "relative";
		}
		createKey(str) {
			return ___R$project$rome$$internal$path$index_ts$createRelativeFilePath(
				str,
			);
		}

		keysToSet() {
			return new ___R$project$rome$$internal$path$collections_ts$RelativeFilePathSet(
				this.keys(),
			);
		}
	}

	class ___R$project$rome$$internal$path$collections_ts$UnknownPathMap
		extends ___R$$priv$project$rome$$internal$path$collections_ts$BasePathMap {
		constructor(...args) {
			super(...args);
			this.type = "unknown";
		}
		createKey(str) {
			return ___R$project$rome$$internal$path$index_ts$createUnknownPath(str);
		}

		keysToSet() {
			return new ___R$project$rome$$internal$path$collections_ts$UnknownPathSet(
				this.keys(),
			);
		}
	}

	class ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet
		extends ___R$$priv$project$rome$$internal$path$collections_ts$BasePathSet {
		constructor(...args) {
			super(...args);
			this.type = "absolute";
		}
		createMap() {
			return new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
		}
	}

	class ___R$project$rome$$internal$path$collections_ts$RelativeFilePathSet
		extends ___R$$priv$project$rome$$internal$path$collections_ts$BasePathSet {
		constructor(...args) {
			super(...args);
			this.type = "relative";
		}
		createMap() {
			return new ___R$project$rome$$internal$path$collections_ts$RelativeFilePathMap();
		}
	}

	class ___R$project$rome$$internal$path$collections_ts$UnknownPathSet
		extends ___R$$priv$project$rome$$internal$path$collections_ts$BasePathSet {
		constructor(...args) {
			super(...args);
			this.type = "unknown";
		}
		createMap() {
			return new ___R$project$rome$$internal$path$collections_ts$UnknownPathMap();
		}
	}



  // project-rome/@internal/path/index.ts
const ___R$$priv$project$rome$$internal$path$index_ts$os = require("os");
	function ___R$$priv$project$rome$$internal$path$index_ts$createEmptyMemo() {
		return {
			filename: undefined,
			ext: undefined,
			parent: undefined,
			unique: undefined,
		};
	}

	function ___R$$priv$project$rome$$internal$path$index_ts$toFilePath(
		pathOrString,
		hint,
	) {
		if (typeof pathOrString === "string") {
			return ___R$project$rome$$internal$path$index_ts$createUnknownPath(
				pathOrString,
				hint,
			);
		} else {
			return pathOrString;
		}
	}

	class ___R$project$rome$$internal$path$index_ts$BasePath {
		constructor(parsed, memo) {
			this.segments = parsed.segments;
			this.parsed = parsed;
			this.memo = memo;
			this.memoizedChildren = new Map();
		}

		// Actually meant to be CUSTOM_PRETTY_FORMAT from "@internal/pretty-format" but it causes a module cycle
		[Symbol.for("custom-pretty-format")]() {
			return this.constructor.name + ": " + this.join();
		}

		getPortableMemo() {
			return {
				parent: undefined,
				unique: undefined,
				filename: this.memo.filename,
				ext: this.memo.ext,
			};
		}

		toUnknown() {
			return new ___R$project$rome$$internal$path$index_ts$UnknownPath(
				this.parsed,
				this.getPortableMemo(),
			);
		}

		addExtension(ext, clearExt = false) {
			const newBasename = clearExt
				? this.getExtensionlessBasename()
				: this.getBasename();
			const newExt = clearExt ? ext : this.memo.ext + ext;
			const segments = this.getParentSegments().concat(newBasename + ext);

			return this._fork(
				Object.assign({}, this.parsed, {segments}),
				Object.assign(
					{},
					___R$$priv$project$rome$$internal$path$index_ts$createEmptyMemo(),
					{ext: newExt, parent: this.memo.parent},
				),
			);
		}

		changeBasename(newBasename) {
			const segments = this.getParentSegments().concat(newBasename);
			return this._fork(
				Object.assign({}, this.parsed, {segments}),
				Object.assign(
					{},
					___R$$priv$project$rome$$internal$path$index_ts$createEmptyMemo(),
					{parent: this.memo.parent},
				),
			);
		}

		getBasename() {
			const {segments} = this;
			const offset = this.isExplicitDirectory() ? 2 : 1;
			return segments[segments.length - offset] || "";
		}

		getExtensionlessBasename() {
			const basename = this.getBasename();
			const ext = this.getExtensions();

			if (ext === "") {
				return basename;
			} else {
				return basename.slice(0, -ext.length);
			}
		}

		hasParent() {
			return !this.isRoot() && this.getParentSegments().length > 0;
		}

		getParent() {
			if (this.memo.parent !== undefined) {
				return this.memo.parent;
			}

			const segments = this.getParentSegments();
			if (segments.length === 0) {
				throw new Error("No parent segments");
			}

			const parent = this._fork(
				Object.assign(
					{},
					this.parsed,
					{
						//explicitDirectory: true,
						segments,
					},
				),
				___R$$priv$project$rome$$internal$path$index_ts$createEmptyMemo(),
			);
			this.memo.parent = parent;
			return parent;
		}

		getParentSegments() {
			// Should we throw an error?
			if (this.isRoot()) {
				return this.segments;
			}

			return this.getSegments().slice(0, -1);
		}

		preferExplicitRelative() {
			if (this.isRelative()) {
				return this.toExplicitRelative();
			} else {
				return this._assert();
			}
		}

		toExplicitRelative() {
			if (this.isExplicitRelative()) {
				return this.assertRelative();
			} else {
				var ___R$;
				return (
					___R$ = ___R$project$rome$$internal$path$index_ts$createRelativeFilePath(
						".",
					),
					___R$.append.apply(___R$, [...this.getSegments()])
				);
			}
		}

		assertRelative() {
			if (this.isAbsolute()) {
				throw new Error(
					"Expected relative file path but got: " + JSON.stringify(this.join()),
				);
			} else {
				return new ___R$project$rome$$internal$path$index_ts$RelativeFilePath(
					this.parsed,
					this.getPortableMemo(),
				);
			}
		}

		assertAbsolute() {
			if (this.isAbsolute()) {
				return new ___R$project$rome$$internal$path$index_ts$AbsoluteFilePath(
					this.parsed,
					this.getPortableMemo(),
				);
			} else {
				throw new Error(
					"Expected absolute file path but got: " + JSON.stringify(this.join()),
				);
			}
		}

		assertURL() {
			if (this.isURL()) {
				return new ___R$project$rome$$internal$path$index_ts$URLPath(
					this.parsed,
					this.getPortableMemo(),
				);
			} else {
				throw new Error(
					"Expected URL file path but got: " + JSON.stringify(this.join()),
				);
			}
		}

		isRoot() {
			if (this.segments.length <= 1) {
				return true;
			}

			if (this.segments.length === 2) {
				// Explicit directory reference
				return this.parsed.absoluteType === "windows-drive";
			}

			if (this.segments.length === 3) {
				return this.parsed.absoluteType === "windows-unc";
			}

			return false;
		}

		isWindows() {
			const {absoluteType} = this.parsed;
			return absoluteType === "windows-drive" || absoluteType === "windows-unc";
		}

		isPosix() {
			return !this.isWindows();
		}

		isURL() {
			return this.parsed.absoluteType === "url";
		}

		isAbsolute() {
			return (
				this.parsed.absoluteTarget !== undefined &&
				this.parsed.absoluteType !== "url"
			);
		}

		isRelative() {
			return !this.isAbsolute();
		}

		isRelativeTo(otherRaw) {
			const other = ___R$$priv$project$rome$$internal$path$index_ts$toFilePath(
				otherRaw,
				"absolute",
			);
			const otherSegments = other.getSegments();
			const ourSegments = this.getSegments();

			// We can't be relative to a path with more segments than us
			if (otherSegments.length > ourSegments.length) {
				return false;
			}

			// Check that we start with the same segments as the other
			for (let i = 0; i < otherSegments.length; i++) {
				if (otherSegments[i] !== ourSegments[i]) {
					return false;
				}
			}

			return true;
		}

		isImplicitRelative() {
			return !this.isExplicitRelative() && !this.isAbsolute() && !this.isURL();
		}

		isExplicitRelative() {
			return this.parsed.explicitRelative;
		}

		isExplicitDirectory() {
			return this.parsed.explicitDirectory;
		}

		hasEndExtension(ext) {
			return this.getExtensions().endsWith("." + ext);
		}

		hasExtension(ext) {
			return (
				this.hasEndExtension(ext) ||
				this.getExtensions().includes("." + ext + ".")
			);
		}

		getExtensions() {
			const memoExt = this.memo.ext;
			if (memoExt === undefined) {
				const ext = ___R$$priv$project$rome$$internal$path$index_ts$getExtension(
					this.getBasename(),
				);
				this.memo.ext = ext;
				return ext;
			} else {
				return memoExt;
			}
		}

		hasExtensions() {
			return this.getExtensions() !== "";
		}

		getSegments() {
			return this.segments;
		}

		getUnique() {
			const memoUnique = this.memo.unique;
			if (memoUnique !== undefined) {
				return memoUnique;
			}

			// If we don't satisfy the below conditions then we're already unique
			if (
				!this.isRoot() &&
				!this.isExplicitRelative() &&
				!this.isExplicitDirectory()
			) {
				return this._assert();
			}

			// Treat all Windows drive paths as case insensitive
			// Convert all segments to lowercase. Bail if they were all lowercase.
			// TODO this causes issues with file maps/sets
			/*if (this.absoluteType === "windows-drive") {
			const hadSegments = segments !== undefined;
			if (segments === undefined) {
				segments = this.getRawSegments();
			}

			let didModify = false;
			segments = segments.map((part) => {
				const lower = part.toLowerCase();
				if (lower !== part) {
					didModify = true;
				}
				return lower;
			});
			if (!didModify && !hadSegments) {
				segments = undefined;
			}
		}*/

			const path = this._fork(
				___R$$priv$project$rome$$internal$path$index_ts$parsePathSegments(
					this.segments,
					this.parsed.hint,
				),
				___R$$priv$project$rome$$internal$path$index_ts$createEmptyMemo(),
			);
			this.memo.unique = path;
			return path;
		}

		// Support some bad string coercion. Such as serialization in CLI flags.
		toString() {
			return this.join();
		}

		join() {
			const memoJoined = this.memo.filename;
			if (memoJoined !== undefined) {
				return memoJoined;
			}

			const segments = [...this.segments];

			if (this.isExplicitDirectory()) {
				segments.push("");
			}

			if (this.isExplicitRelative() && segments[0] !== "..") {
				segments.unshift(".");
			}

			if (segments.length === 0) {
				segments.push(".");
			}

			let filename;
			if (this.isWindows()) {
				filename = segments.join("\\");
			} else {
				filename = segments.join("/");
			}
			this.memo.filename = filename;
			return filename;
		}

		equal(other) {
			// @ts-ignore
			if (other === this) {
				return true;
			}

			const a = this.getUnique().getSegments();
			const b = other.getUnique().getSegments();

			// Quick check
			if (a.length !== b.length) {
				return false;
			}

			// Check validity of a
			for (let i = 0; i < a.length; i++) {
				if (a[i] !== b[i]) {
					return false;
				}
			}

			return true;
		}

		format(cwd) {
			const filename = this.join();
			const names = [];
			names.push(filename);

			// Get a path relative to HOME
			if (this.isRelativeTo(___R$project$rome$$internal$path$index_ts$HOME_PATH)) {
				// Path starts with the home directory, so let's trim it off
				const relativeToHome = ___R$project$rome$$internal$path$index_ts$HOME_PATH.relative(
					this._assert(),
				);

				// Add tilde and push it as a possible name
				// We construct this manually to get around the segment normalization which would explode ~
				names.push(
					new ___R$project$rome$$internal$path$index_ts$RelativeFilePath(
						{
							hint: "relative",
							segments: ["~", ...relativeToHome.getSegments()],
							absoluteType: "posix",
							absoluteTarget: undefined,
							explicitDirectory: this.parsed.explicitDirectory,
							explicitRelative: false,
						},
						___R$$priv$project$rome$$internal$path$index_ts$createEmptyMemo(),
					).join(),
				);
			}

			// Get a path relative to the cwd
			if (cwd !== undefined) {
				names.push(cwd.relative(filename).join());
			}

			// Get the shortest name
			const human = names.sort((a, b) => a.length - b.length)[0];
			if (human === "") {
				return "./";
			} else {
				return human;
			}
		}

		append(...items) {
			if (items.length === 0) {
				return this._assert();
			}

			if (items.length === 1) {
				return this._append(items[0]);
			}

			let target = this._assert();
			for (const item of items) {
				// @ts-ignore
				target = target._append(item);
			}
			return target;
		}

		_append(item) {
			if (typeof item === "string") {
				const cached = this.memoizedChildren.get(item);
				if (cached !== undefined) {
					return cached;
				}
			}

			const parsed = ___R$$priv$project$rome$$internal$path$index_ts$parsePathSegments(
				[
					...this.getSegments(),
					...___R$$priv$project$rome$$internal$path$index_ts$toFilePath(
						item,
						"relative",
					).getSegments(),
				],
				this.parsed.hint,
				this.parsed,
			);
			const child = this._fork(
				parsed,
				___R$$priv$project$rome$$internal$path$index_ts$createEmptyMemo(),
			);

			if (typeof item === "string") {
				this.memoizedChildren.set(item, child);
			}

			return child;
		}
	}

	class ___R$project$rome$$internal$path$index_ts$UnknownPath
		extends ___R$project$rome$$internal$path$index_ts$BasePath {
		_fork(parsed, opts) {
			return new ___R$project$rome$$internal$path$index_ts$UnknownPath(
				parsed,
				opts,
			);
		}

		_assert() {
			return this;
		}
	}

	class ___R$project$rome$$internal$path$index_ts$RelativeFilePath
		extends ___R$project$rome$$internal$path$index_ts$BasePath {
		constructor(...args) {
			super(...args);
			this.type = "relative";
		}
		_assert() {
			return this;
		}

		_fork(parsed, opts) {
			return new ___R$project$rome$$internal$path$index_ts$RelativeFilePath(
				parsed,
				opts,
			);
		}

		assertRelative() {
			return this;
		}
	}

	class ___R$project$rome$$internal$path$index_ts$AbsoluteFilePath
		extends ___R$project$rome$$internal$path$index_ts$BasePath {
		constructor(...args) {
			super(...args);
			this.type = "absolute";
		}
		_assert() {
			return this;
		}

		_fork(parsed, opts) {
			return new ___R$project$rome$$internal$path$index_ts$AbsoluteFilePath(
				parsed,
				opts,
			);
		}

		assertAbsolute() {
			return this;
		}

		getChain() {
			if (this.chain !== undefined) {
				return this.chain;
			}

			const paths = [];
			this.chain = paths;

			// We use getParent here so we can reuse as much memoized information as possible
			let target = this;
			while (true) {
				paths.push(target);
				if (target.isRoot()) {
					break;
				} else {
					target = target.getParent();
				}
			}

			return paths;
		}

		resolveMaybeUrl(otherRaw) {
			const other = ___R$$priv$project$rome$$internal$path$index_ts$toFilePath(
				otherRaw,
				"url",
			);
			if (other.isURL()) {
				return other.assertURL();
			} else {
				return this.resolve(other);
			}
		}

		resolve(otherRaw) {
			const other = ___R$$priv$project$rome$$internal$path$index_ts$toFilePath(
				otherRaw,
				"auto",
			);
			if (other.isAbsolute()) {
				return other.assertAbsolute();
			}

			return new ___R$project$rome$$internal$path$index_ts$AbsoluteFilePath(
				___R$$priv$project$rome$$internal$path$index_ts$parsePathSegments(
					[...this.getSegments(), ...other.getSegments()],
					"absolute",
					{
						explicitDirectory: other.isExplicitDirectory(),
					},
				),
				___R$$priv$project$rome$$internal$path$index_ts$createEmptyMemo(),
			);
		}

		relative(otherRaw) {
			const other = this.resolve(
				___R$$priv$project$rome$$internal$path$index_ts$toFilePath(
					otherRaw,
					"relative",
				),
			);

			if (other.equal(this)) {
				return ___R$project$rome$$internal$path$index_ts$createRelativeFilePath(
					".",
				);
			}

			const absolute = this.getSegments().slice();
			const relative = other.getSegments().slice();

			// Impossible to relativize two absolute paths with different roots
			if (absolute[0] !== relative[0]) {
				return other;
			}

			// Remove common starting segments
			while (absolute[0] === relative[0]) {
				absolute.shift();
				relative.shift();
			}

			let finalSegments = [];
			for (let i = 0; i < absolute.length; i++) {
				finalSegments.push("..");
			}
			finalSegments = finalSegments.concat(relative);

			return new ___R$project$rome$$internal$path$index_ts$UnknownPath(
				___R$$priv$project$rome$$internal$path$index_ts$parsePathSegments(
					finalSegments,
					"relative",
				),
				___R$$priv$project$rome$$internal$path$index_ts$createEmptyMemo(),
			);
		}
	}

	class ___R$project$rome$$internal$path$index_ts$URLPath
		extends ___R$project$rome$$internal$path$index_ts$BasePath {
		constructor(...args) {
			super(...args);
			this.type = "url";
		}
		_assert() {
			return this;
		}

		_fork(parsed, opts) {
			return new ___R$project$rome$$internal$path$index_ts$URLPath(parsed, opts);
		}

		assertURL() {
			return this;
		}

		isURL() {
			return true;
		}

		getDomain() {
			return this.segments[2];
		}

		getProtocol() {
			const {absoluteTarget} = this.parsed;
			if (absoluteTarget === undefined) {
				throw new Error("Expected a URLPath to always have an absoluteTarget");
			}
			return absoluteTarget;
		}

		resolve(path) {
			if (path.isURL()) {
				return path.assertURL();
			} else if (path.isAbsolute()) {
				// Get the segments that include the protocol and domain
				const domainSegments = this.getSegments().slice(0, 3);
				const finalSegments = [...domainSegments, ...path.getSegments()];
				return new ___R$project$rome$$internal$path$index_ts$URLPath(
					___R$$priv$project$rome$$internal$path$index_ts$parsePathSegments(
						finalSegments,
						"auto",
					),
					___R$$priv$project$rome$$internal$path$index_ts$createEmptyMemo(),
				);
			} else {
				return this.append(path.assertRelative());
			}
		}
	}

	const ___R$project$rome$$internal$path$index_ts$HOME_PATH = ___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
		___R$$priv$project$rome$$internal$path$index_ts$os.userInfo().homedir,
	);
	const ___R$project$rome$$internal$path$index_ts$TEMP_PATH = ___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
		___R$$priv$project$rome$$internal$path$index_ts$os.tmpdir(),
	);
	const ___R$project$rome$$internal$path$index_ts$CWD_PATH = ___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
		process.cwd(),
	);

	function ___R$$priv$project$rome$$internal$path$index_ts$getExtension(
		basename,
	) {
		const match = basename.match(/\.(.*?)$/);
		if (match == null) {
			return "";
		} else {
			return match[0];
		}
	}

	function ___R$$priv$project$rome$$internal$path$index_ts$isWindowsDrive(first) {
		return first.length === 2 && first[1] === ":" && /[A-Z]/i.test(first[0]);
	}

	function ___R$$priv$project$rome$$internal$path$index_ts$parsePathSegments(
		segments,
		hint,
		overrides = {},
	) {
		let absoluteType = "posix";
		let absoluteTarget;
		let firstSeg = (segments[0]);

		// Detect URL
		if (
			firstSeg !== undefined &&
			!___R$$priv$project$rome$$internal$path$index_ts$isWindowsDrive(firstSeg) &&
			firstSeg[firstSeg.length - 1] === ":" &&
			segments[1] === ""
		) {
			absoluteTarget = firstSeg.slice(0, -1);

			switch (absoluteTarget) {
				case "file":
					// Automatically normalize a file scheme into an absolute path
					return ___R$$priv$project$rome$$internal$path$index_ts$parsePathSegments(
						segments.slice(2).map((segment) => decodeURIComponent(segment)),
						"absolute",
					);

				default: {
					const absoluteSegments = segments.slice(0, 3);
					return Object.assign(
						{hint: "absolute", absoluteType: "url", absoluteTarget},
						___R$$priv$project$rome$$internal$path$index_ts$normalizeSegments(
							segments,
							absoluteSegments.length,
							absoluteSegments,
						),
					);
				}
			}
		}

		// Explode home directory
		if ((hint === "absolute" || hint === "auto") && firstSeg === "~") {
			segments = [
				...___R$project$rome$$internal$path$index_ts$HOME_PATH.getSegments(),
			];
			firstSeg = segments[0];
		}

		let segmentOffset = 0;

		// We first extract the "absolute" portion of a path, this includes any Windows drive letters, UNC hostnames etc
		const absoluteSegments = [];
		if (firstSeg === "") {
			// POSIX path
			absoluteSegments.push("");
			absoluteTarget = "posix";
			segmentOffset++;

			// Windows UNC
			if (segments[1] === "" && segments.length >= 3 && segments[2] !== "") {
				const name = segments[2];
				segmentOffset += 2;
				absoluteSegments.push("");
				absoluteSegments.push(name);
				absoluteType = "windows-unc";
				absoluteTarget = "unc:" + name;
			}
		} else if (
			firstSeg !== undefined &&
			___R$$priv$project$rome$$internal$path$index_ts$isWindowsDrive(firstSeg)
		) {
			const drive = firstSeg.toUpperCase();
			absoluteSegments.push(drive);
			absoluteType = "windows-drive";
			absoluteTarget = "drive:" + drive;
			segmentOffset++;
		}

		const {
			explicitDirectory,
			explicitRelative,
			segments: pathSegments,
		} = ___R$$priv$project$rome$$internal$path$index_ts$normalizeSegments(
			segments,
			segmentOffset,
			absoluteSegments,
		);

		return {
			explicitDirectory: overrides.explicitDirectory || explicitDirectory,
			explicitRelative: overrides.explicitRelative || explicitRelative,
			segments: pathSegments,
			absoluteType,
			absoluteTarget,
			hint,
		};
	}

	function ___R$$priv$project$rome$$internal$path$index_ts$normalizeSegments(
		segments,
		offset,
		absoluteSegments,
	) {
		let explicitDirectory = false;
		let explicitRelative = false;

		const relativeSegments = [];
		for (let i = offset; i < segments.length; i++) {
			let seg = segments[i];

			// Ignore dots, we check for explicit relative below
			if (seg === ".") {
				continue;
			}

			// Ignore empty segments
			if (seg === "") {
				continue;
			}

			// Remove the previous segment, as long as it's not also ..
			if (
				seg === ".." &&
				relativeSegments.length > 0 &&
				relativeSegments[relativeSegments.length - 1] !== ".."
			) {
				relativeSegments.pop();
				continue;
			}

			relativeSegments.push(seg);
		}

		const finalSegments = [...absoluteSegments, ...relativeSegments];

		// Retain explicit directory
		if (
			segments[segments.length - 1] === "" &&
			finalSegments[finalSegments.length - 1] !== "" &&
			relativeSegments.length !== 0
		) {
			explicitDirectory = true;
		}

		explicitRelative =
			absoluteSegments.length === 0 &&
			(segments[0] === "." || segments[0] === "..");

		return {
			explicitDirectory,
			explicitRelative,
			segments: finalSegments,
		};
	}

	function ___R$project$rome$$internal$path$index_ts$createFilePathFromSegments(
		segments,
		hint,
	) {
		const parsed = ___R$$priv$project$rome$$internal$path$index_ts$parsePathSegments(
			segments,
			hint,
		);
		return new ___R$project$rome$$internal$path$index_ts$UnknownPath(
			parsed,
			___R$$priv$project$rome$$internal$path$index_ts$createEmptyMemo(),
		);
	}

	function ___R$project$rome$$internal$path$index_ts$createRelativeFilePath(
		filename,
	) {
		return ___R$project$rome$$internal$path$index_ts$createUnknownPath(
			filename,
			"relative",
		).assertRelative();
	}

	function ___R$project$rome$$internal$path$index_ts$createURLPath(filename) {
		return ___R$project$rome$$internal$path$index_ts$createUnknownPath(
			filename,
			"auto",
		).assertURL();
	}

	function ___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
		filename,
	) {
		return ___R$project$rome$$internal$path$index_ts$createUnknownPath(
			filename,
			"absolute",
		).assertAbsolute();
	}

	function ___R$project$rome$$internal$path$index_ts$createUnknownPath(
		filename,
		hint = "auto",
	) {
		// Allows using the create methods above to be used in places where strings are more ergonomic (eg. in third-party code)
		if (filename instanceof ___R$project$rome$$internal$path$index_ts$BasePath) {
			return filename.toUnknown();
		}

		// Might be better to do a manual loop to detect escaped slashes or some other weirdness
		const segments = filename.split(/[\\\/]/g);
		const parsed = ___R$$priv$project$rome$$internal$path$index_ts$parsePathSegments(
			segments,
			hint,
		);
		return new ___R$project$rome$$internal$path$index_ts$UnknownPath(
			parsed,
			___R$$priv$project$rome$$internal$path$index_ts$createEmptyMemo(),
		);
	}

	function ___R$project$rome$$internal$path$index_ts$maybeCreateURLPath(
		filename,
	) {
		if (filename !== undefined) {
			return ___R$project$rome$$internal$path$index_ts$createURLPath(filename);
		} else {
			return undefined;
		}
	}

	function ___R$project$rome$$internal$path$index_ts$maybeCreateRelativeFilePath(
		filename,
	) {
		if (filename !== undefined) {
			return ___R$project$rome$$internal$path$index_ts$createRelativeFilePath(
				filename,
			);
		} else {
			return undefined;
		}
	}

	function ___R$project$rome$$internal$path$index_ts$maybeCreateAbsoluteFilePath(
		filename,
	) {
		if (filename !== undefined) {
			return ___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
				filename,
			);
		} else {
			return undefined;
		}
	}

	function ___R$project$rome$$internal$path$index_ts$maybeCreateUnknownPath(
		filename,
	) {
		if (filename !== undefined) {
			return ___R$project$rome$$internal$path$index_ts$createUnknownPath(
				filename,
				"auto",
			);
		} else {
			return undefined;
		}
	}


  // project-rome/@internal/compiler/signals.ts
const ___R$project$rome$$internal$compiler$signals_ts = {
		get skip() {
			return ___R$project$rome$$internal$compiler$signals_ts$skip;
		},
		get remove() {
			return ___R$project$rome$$internal$compiler$signals_ts$remove;
		},
		get retain() {
			return ___R$project$rome$$internal$compiler$signals_ts$retain;
		},
		maybeReplace: ___R$project$rome$$internal$compiler$signals_ts$maybeReplace,
		replace: ___R$project$rome$$internal$compiler$signals_ts$replace,
		parent: ___R$project$rome$$internal$compiler$signals_ts$parent,
	};
	const ___R$project$rome$$internal$compiler$signals_ts$skip = {
		type: "SKIP",
	};

	const ___R$project$rome$$internal$compiler$signals_ts$remove = {
		type: "REMOVE",
	};

	const ___R$project$rome$$internal$compiler$signals_ts$retain = {
		type: "RETAIN",
	};

	function ___R$project$rome$$internal$compiler$signals_ts$maybeReplace(
		old,
		node,
	) {
		if (old === node) {
			return ___R$project$rome$$internal$compiler$signals_ts$retain;
		} else {
			return {
				type: "REPLACE",
				value: node,
			};
		}
	}

	function ___R$project$rome$$internal$compiler$signals_ts$replace(node) {
		return {
			type: "REPLACE",
			value: node,
		};
	}

	function ___R$project$rome$$internal$compiler$signals_ts$parent(node, signal) {
		return {
			type: "PARENT",
			parent: node,
			signal,
		};
	}


  // project-rome/@internal/compiler/utils.ts
const ___R$project$rome$$internal$compiler$utils_ts = {
		createVisitor: ___R$project$rome$$internal$compiler$utils_ts$createVisitor,
	};
	function ___R$project$rome$$internal$compiler$utils_ts$createVisitor(visitor) {
		return visitor;
	}


  // project-rome/@internal/compiler/suppressions.ts
const ___R$project$rome$$internal$compiler$suppressions_ts$SUPPRESSION_START = "rome-ignore";
	const ___R$project$rome$$internal$compiler$suppressions_ts$INCORRECT_SUPPRESSION_START = [
		"rome-disable",
		"@rome-ignore",
		"@rome-disable",
		"romefrontend-ignore",
		"romefrontend-disable",
		"@romefrontend-ignore",
		"@romefrontend-disable",
	];

	function ___R$$priv$project$rome$$internal$compiler$suppressions_ts$extractSuppressionsFromComment(
		context,
		comment,
		targetNode,
	) {
		const commentLocation = comment.loc;
		if (commentLocation === undefined) {
			return undefined;
		}

		const suppressedCategories = new Set();
		const diagnostics = [];
		const suppressions = [];

		const lines = comment.value.split("\n");
		const cleanLines = lines.map((line) => {
			// Trim line and remove leading star
			return line.trim().replace(/\*[\s]/, "");
		});

		for (const line of cleanLines) {
			if (
				___R$project$rome$$internal$compiler$suppressions_ts$INCORRECT_SUPPRESSION_START.some((
					incorrectStart,
				) => line.startsWith(incorrectStart))
			) {
				diagnostics.push({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SUPPRESSIONS.INCORRECT_SUPPRESSION_START,
					location: commentLocation,
				});
			}

			if (
				!line.startsWith(
					___R$project$rome$$internal$compiler$suppressions_ts$SUPPRESSION_START,
				)
			) {
				continue;
			}

			if (targetNode === undefined || targetNode.loc === undefined) {
				diagnostics.push({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SUPPRESSIONS.MISSING_TARGET,
					location: commentLocation,
				});
				break;
			}

			const startLine = targetNode.loc.start.line;
			const endLine = targetNode.loc.end.line;

			const lineWithoutPrefix = line.slice(
				___R$project$rome$$internal$compiler$suppressions_ts$SUPPRESSION_START.length,
			);
			if (lineWithoutPrefix[0] !== " ") {
				diagnostics.push({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SUPPRESSIONS.MISSING_SPACE,
					location: commentLocation,
				});
				continue;
			}

			const categories = lineWithoutPrefix.trim().split(" ");
			const cleanCategories = categories.map((category) => category.trim());
			let explanation;

			for (let i = 0; i < cleanCategories.length; i++) {
				let category = cleanCategories[i];

				if (category === "") {
					continue;
				}

				// If a category ends with a colon then all the things that follow it are an explanation
				if (category[category.length - 1] === ":") {
					category = category.slice(0, -1);
					explanation = cleanCategories.slice(i + 1);
				}
				if (suppressedCategories.has(category)) {
					diagnostics.push({
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SUPPRESSIONS.DUPLICATE(
							category,
						),
						location: commentLocation,
					});
				} else {
					suppressedCategories.add(category);

					suppressions.push({
						filename: context.filename,
						category,
						commentLocation,
						startLine,
						endLine,
					});
				}

				if (explanation !== undefined) {
					break;
				}
			}

			if (!explanation || explanation.length === 0) {
				diagnostics.push({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SUPPRESSIONS.MISSING_EXPLANATION,
					location: commentLocation,
				});
			}
		}

		if (suppressions.length === 0 && diagnostics.length === 0) {
			return undefined;
		} else {
			return {diagnostics, suppressions};
		}
	}

	function ___R$project$rome$$internal$compiler$suppressions_ts$createSuppressionsVisitor() {
		const visitedComments = new Set();

		// TODO verify all comments

		return ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
			name: "suppressions",

			enter(path) {
				const {node, context} = path;

				if (node.loc !== undefined && node.leadingComments !== undefined) {
					for (const comment of context.comments.getCommentsFromIds(
						node.leadingComments,
					)) {
						if (visitedComments.has(comment)) {
							continue;
						}

						visitedComments.add(comment);
						const result = ___R$$priv$project$rome$$internal$compiler$suppressions_ts$extractSuppressionsFromComment(
							context,
							comment,
							node,
						);
						if (result !== undefined) {
							context.diagnostics.addDiagnostics(result.diagnostics);
							context.suppressions = context.suppressions.concat(
								result.suppressions,
							);
						}
					}
				}

				return ___R$project$rome$$internal$compiler$signals_ts.retain;
			},
		});
	}

	function ___R$project$rome$$internal$compiler$suppressions_ts$matchesSuppression(
		category,
		{filename, start, end},
		suppression,
	) {
		return (
			category === suppression.category &&
			filename === suppression.filename &&
			start !== undefined &&
			end !== undefined &&
			start.line >= suppression.startLine &&
			end.line <= suppression.endLine
		);
	}


  // project-rome/@internal/js-parser/options.ts
const ___R$$priv$project$rome$$internal$js$parser$options_ts$DEFAULT_USER_OPTIONS = {
		// I want to kill this option very badly
		allowReturnOutsideFunction: false,
		// Source type ("template", "script" or "module") for different semantics
		sourceType: "script",
		// Whether we should be tracking tokens when parsing this file
		// NOTE: This is memory-intensive
		tokens: false,
		syntax: [],
		manifestPath: "package.json",
	};

	// Interpret and default an options object
	function ___R$project$rome$$internal$js$parser$options_ts$normalizeOptions(
		opts,
	) {
		return Object.assign(
			{},
			___R$$priv$project$rome$$internal$js$parser$options_ts$DEFAULT_USER_OPTIONS,
			opts,
		);
	}


  // project-rome/@internal/js-parser/ParserBranchFinder.ts
class ___R$project$rome$$internal$js$parser$ParserBranchFinder_ts$default {
		constructor(parser) {
			this.parser = parser;
			this.branch = undefined;
			this.picked = false;
		}

		hasOptimalBranch() {
			return this.branch !== undefined && this.branch.optimal;
		}

		hasBranch() {
			return this.branch !== undefined;
		}

		add(callback, opts = {}) {
			const topBranch = this.branch;

			// If we already have a branch that produced no errors then no point continuing
			if (topBranch !== undefined && topBranch.optimal) {
				return this;
			}

			const {maxNewDiagnostics, diagnosticsPriority} = opts;
			const {parser} = this;
			const prevState = ___R$project$rome$$internal$js$parser$parser_ts$cloneState(
				parser,
			);

			___R$project$rome$$internal$js$parser$parser_ts$pushScope(
				parser,
				"MAX_NEW_DIAGNOSTICS",
				maxNewDiagnostics,
			);

			let result;
			try {
				result = callback(parser);
			} catch (err) {
				if (
					err instanceof
					___R$project$rome$$internal$js$parser$parser_ts$DiagnosticsFatalError
				) {
					___R$project$rome$$internal$js$parser$parser_ts$setState(
						parser,
						prevState,
					);
					return this;
				} else {
					throw err;
				}
			}

			if (result === undefined) {
				___R$project$rome$$internal$js$parser$parser_ts$setState(
					parser,
					prevState,
				);
				return this;
			}

			// We capture the state at this point because it could have been previously changed
			const newState = parser.state;
			___R$project$rome$$internal$js$parser$parser_ts$popScope(
				parser,
				"MAX_NEW_DIAGNOSTICS",
			);
			___R$project$rome$$internal$js$parser$parser_ts$setState(
				parser,
				prevState,
			);

			// Verify that we didn't exceed the maxDiagnostics, this should have already been done in Parser#addDiagnostic

			// but do it again as a sanity check. Previously some code caused the state to be manipulated in odd ways
			const newDiagnosticCount = newState.diagnostics.length;
			const prevDiagnosticCount = prevState.diagnostics.length;
			if (
				maxNewDiagnostics !== undefined &&
				newDiagnosticCount - prevDiagnosticCount > maxNewDiagnostics
			) {
				throw new Error(
					"Max diagnostics unexpectedly exceeded " +
					maxNewDiagnostics +
					". Prev: " +
					prevDiagnosticCount +
					" New: " +
					newDiagnosticCount,
				);
			}

			const branch = {
				diagnosticsPriority,
				result,
				state: newState,
				newDiagnosticCount: newDiagnosticCount - prevDiagnosticCount,
				diagnosticCount: newDiagnosticCount,
				optimal: newDiagnosticCount === prevDiagnosticCount,
			};

			// Promote this branch to the leader if it's the first, or if it has less diagnostics than the current
			let shouldPromote = false;

			if (topBranch === undefined || branch.optimal) {
				shouldPromote = true;
			} else {
				// Promote if the branch has less diagnostics than the top branch
				if (branch.diagnosticCount < topBranch.diagnosticCount) {
					shouldPromote = true;
				}

				// Promote if we have a priority but the top branch doesn't
				if (
					branch.diagnosticsPriority !== undefined &&
					topBranch.diagnosticsPriority === undefined
				) {
					shouldPromote = true;
				}

				// Promote if we have a priority, and the top branch does, and we're higher
				if (
					branch.diagnosticsPriority !== undefined &&
					topBranch.diagnosticsPriority !== undefined &&
					branch.diagnosticsPriority > topBranch.diagnosticsPriority
				) {
					shouldPromote = true;
				}

				// Don't promote if the top branch has a priority but we don't
				if (
					topBranch.diagnosticsPriority !== undefined &&
					branch.diagnosticsPriority === undefined
				) {
					shouldPromote = false;
				}
			}

			if (shouldPromote) {
				this.branch = branch;
			}

			return this;
		}

		getBranch() {
			if (this.branch === undefined) {
				throw new Error("No branch");
			} else {
				return this.branch;
			}
		}

		pickOptional() {
			if (this.hasBranch()) {
				return this.pick();
			} else {
				return undefined;
			}
		}

		pick() {
			if (this.picked) {
				throw new Error("Already been picked");
			}
			this.picked = true;

			const {parser} = this;
			const branch = this.getBranch();

			const {result, state} = branch;
			___R$project$rome$$internal$js$parser$parser_ts$setState(parser, state);
			return result;
		}
	}


  // project-rome/@internal/js-parser/tokenizer/types.ts
// ## Token types
	// The assignment of fine-grained, information-carrying type objects
	// allows the tokenizer to store the information it has about a
	// token in a way that is very cheap for the parser to look up.
	// All token type variables start with an underscore, to make them
	// easy to recognize.
	// The `beforeExpr` property is used to disambiguate between regular
	// expressions and divisions. It is set on all token types that can
	// be followed by an expression (thus, a slash after them would be a
	// regular expression).
	//
	// `isLoop` marks a keyword as starting a loop, which is important
	// to know when parsing a label, in order to allow or disallow
	// continue jumps to that label.
	const ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr = true;
	const ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr = true;
	const ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$isLoop = true;
	const ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$isAssign = true;
	const ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$prefix = true;
	const ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$postfix = true;

	class ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType {
		constructor(label, conf = {}) {
			this.label = label;
			this.keyword = conf.keyword;
			this.beforeExpr = !!conf.beforeExpr;
			this.startsExpr = !!conf.startsExpr;
			this.rightAssociative = !!conf.rightAssociative;
			this.isLoop = !!conf.isLoop;
			this.isAssign = !!conf.isAssign;
			this.prefix = !!conf.prefix;
			this.postfix = !!conf.postfix;
			this.binop = typeof conf.binop === "number" ? conf.binop : undefined;
			this.updateContext = undefined;
		}

		getBinop() {
			const {binop} = this;
			if (binop === undefined) {
				throw new Error("Token " + this.label + " doesn't have a binop");
			}
			return binop;
		}
	}

	const ___R$project$rome$$internal$js$parser$tokenizer$types_ts$keywords = new Map();

	class ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType
		extends ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType {
		constructor(name, options = {}) {
			options.keyword = name;

			super(name, options);

			___R$project$rome$$internal$js$parser$tokenizer$types_ts$keywords.set(
				name,
				this,
			);
		}
	}

	class ___R$project$rome$$internal$js$parser$tokenizer$types_ts$BinopTokenType
		extends ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType {
		constructor(name, prec) {
			super(
				name,
				{
					beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
					binop: prec,
				},
			);
		}
	}

	const ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types = {
		num: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"num",
			{
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		bigint: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"bigint",
			{
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		regexp: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"regexp",
			{
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		string: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"string",
			{
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		name: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"name",
			{
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		eof: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"eof",
		),
		invalid: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"invalid",
		),
		comment: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"comment",
		),
		// Punctuation token types.
		bracketL: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"[",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		bracketR: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"]",
		),
		braceL: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"{",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		braceBarL: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"{|",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		braceR: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"}",
		),
		braceBarR: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"|}",
		),
		parenL: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"(",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		parenR: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			")",
		),
		comma: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			",",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
			},
		),
		semi: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			";",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
			},
		),
		colon: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			":",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
			},
		),
		doubleColon: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"::",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
			},
		),
		dot: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			".",
		),
		question: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"?",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
			},
		),
		questionDot: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"?.",
		),
		arrow: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"=>",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
			},
		),
		template: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"template",
		),
		ellipsis: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"...",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
			},
		),
		backQuote: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"`",
			{
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		dollarBraceL: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"${",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		at: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"@",
		),
		hash: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"#",
		),
		// Operators. These carry several kinds of properties to help the
		// parser use them properly (the presence of these properties is
		// what categorizes them as operators).
		//
		// `binop`, when present, specifies that this operator is a binary
		// operator, and will refer to its precedence.
		//
		// `prefix` and `postfix` mark the operator as a prefix or postfix
		// unary operator.
		//
		// `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
		// binary operators with a very low precedence, that should result
		// in JSAssignmentExpression nodes.
		eq: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"=",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
				isAssign: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$isAssign,
			},
		),
		assign: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"_=",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
				isAssign: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$isAssign,
			},
		),
		incDec: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"++/--",
			{
				prefix: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$prefix,
				postfix: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$postfix,
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		bang: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"!",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
				prefix: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$prefix,
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		tilde: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"~",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
				prefix: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$prefix,
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		nullishCoalescing: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$BinopTokenType(
			"??",
			1,
		),
		logicalOR: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$BinopTokenType(
			"||",
			1,
		),
		logicalAND: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$BinopTokenType(
			"&&",
			2,
		),
		bitwiseOR: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$BinopTokenType(
			"|",
			3,
		),
		bitwiseXOR: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$BinopTokenType(
			"^",
			4,
		),
		bitwiseAND: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$BinopTokenType(
			"&",
			5,
		),
		equality: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$BinopTokenType(
			"==/!=",
			6,
		),
		relational: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$BinopTokenType(
			"</>",
			7,
		),
		bitShift: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$BinopTokenType(
			"<</>>",
			8,
		),
		plusMin: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"+/-",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
				binop: 9,
				prefix: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$prefix,
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		modulo: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$BinopTokenType(
			"%",
			10,
		),
		star: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$BinopTokenType(
			"*",
			10,
		),
		slash: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$BinopTokenType(
			"/",
			10,
		),
		exponent: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"**",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
				binop: 11,
				rightAssociative: true,
			},
		),
		jsxName: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"jsxName",
		),
		jsxText: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"jsxText",
			{beforeExpr: true},
		),
		jsxTagStart: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"jsxTagStart",
			{startsExpr: true},
		),
		jsxTagEnd: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$TokenType(
			"jsxTagEnd",
		),
		_break: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"break",
		),
		_case: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"case",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
			},
		),
		_catch: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"catch",
		),
		_continue: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"continue",
		),
		_debugger: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"debugger",
		),
		_default: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"default",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
			},
		),
		_do: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"do",
			{
				isLoop: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$isLoop,
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
			},
		),
		_else: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"else",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
			},
		),
		_finally: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"finally",
		),
		_for: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"for",
			{
				isLoop: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$isLoop,
			},
		),
		_function: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"function",
			{
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		_if: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"if",
		),
		_return: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"return",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
			},
		),
		_switch: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"switch",
		),
		_throw: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"throw",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
				prefix: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$prefix,
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		_try: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"try",
		),
		_var: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"var",
		),
		_const: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"const",
		),
		_while: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"while",
			{
				isLoop: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$isLoop,
			},
		),
		_with: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"with",
		),
		_new: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"new",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		_this: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"this",
			{
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		_super: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"super",
			{
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		_class: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"class",
			{
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		_extends: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"extends",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
			},
		),
		_export: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"export",
		),
		_import: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"import",
			{
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		_null: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"null",
			{
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		_true: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"true",
			{
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		_false: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"false",
			{
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		_in: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"in",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
				binop: 7,
			},
		),
		_instanceof: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"instanceof",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
				binop: 7,
			},
		),
		_typeof: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"typeof",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
				prefix: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$prefix,
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		_void: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"void",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
				prefix: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$prefix,
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		_delete: new ___R$project$rome$$internal$js$parser$tokenizer$types_ts$KeywordTokenType(
			"delete",
			{
				beforeExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$beforeExpr,
				prefix: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$prefix,
				startsExpr: ___R$$priv$project$rome$$internal$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
	};



  // project-rome/@internal/js-parser/tokenizer/context.ts
class ___R$project$rome$$internal$js$parser$tokenizer$context_ts$TokContext {
		constructor(token, isExpr, preserveSpace, override) {
			this.token = token;
			this.isExpr = !!isExpr;
			this.preserveSpace = !!preserveSpace;
			this.override = override;
		}
	}

	const ___R$project$rome$$internal$js$parser$tokenizer$context_ts$types = {
		braceStatement: new ___R$project$rome$$internal$js$parser$tokenizer$context_ts$TokContext(
			"{",
			false,
		),
		braceExpression: new ___R$project$rome$$internal$js$parser$tokenizer$context_ts$TokContext(
			"{",
			true,
		),
		templateQuasi: new ___R$project$rome$$internal$js$parser$tokenizer$context_ts$TokContext(
			"${",
			false,
		),
		parenStatement: new ___R$project$rome$$internal$js$parser$tokenizer$context_ts$TokContext(
			"(",
			false,
		),
		parenExpression: new ___R$project$rome$$internal$js$parser$tokenizer$context_ts$TokContext(
			"(",
			true,
		),
		template: new ___R$project$rome$$internal$js$parser$tokenizer$context_ts$TokContext(
			"`",
			true,
			true,
			(p) =>
				___R$project$rome$$internal$js$parser$tokenizer$index_ts$readTemplateToken(
					p,
				)
			,
		),
		functionExpression: new ___R$project$rome$$internal$js$parser$tokenizer$context_ts$TokContext(
			"function",
			true,
		),
		functionStatement: new ___R$project$rome$$internal$js$parser$tokenizer$context_ts$TokContext(
			"function",
			false,
		),
		// JSX
		jsxOpenTag: new ___R$project$rome$$internal$js$parser$tokenizer$context_ts$TokContext(
			"<tag",
			false,
		),
		jsxCloseTag: new ___R$project$rome$$internal$js$parser$tokenizer$context_ts$TokContext(
			"</tag",
			false,
		),
		jsxInner: new ___R$project$rome$$internal$js$parser$tokenizer$context_ts$TokContext(
			"<tag>...</tag>",
			true,
			true,
		),
	};

	// Token-specific context update code
	___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR.updateContext = ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR.updateContext = function(
		parser,
	) {
		if (parser.state.context.length === 1) {
			parser.state.exprAllowed = true;
			return;
		}

		let out = parser.state.context.pop();
		if (
			out ===
			___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.braceStatement
		) {
			const context = ___R$project$rome$$internal$js$parser$tokenizer$index_ts$getCurContext(
				parser,
			);
			if (context !== undefined && context.token === "function") {
				out = parser.state.context.pop();
			}
		}

		if (out === undefined) {
			throw new Error("No context found");
		}

		parser.state.exprAllowed = !out.isExpr;
	};

	___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name.updateContext = function(
		parser,
		prevType,
	) {
		let allowed = false;
		if (
			prevType !==
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.dot
		) {
			if (
				(parser.state.tokenValue === "of" && !parser.state.exprAllowed) ||
				(parser.state.tokenValue === "yield" &&
				___R$project$rome$$internal$js$parser$parser_ts$inScope(
					parser,
					"GENERATOR",
				))
			) {
				allowed = true;
			}
		}

		parser.state.exprAllowed = allowed;

		if (parser.state.isIterator) {
			parser.state.isIterator = false;
		}
	};

	___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL.updateContext = function(
		parser,
		prevType,
	) {
		parser.state.context.push(
			___R$project$rome$$internal$js$parser$tokenizer$index_ts$isBraceBlock(
				parser,
				prevType,
			)
				? ___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.braceStatement
				: ___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.braceExpression,
		);
		parser.state.exprAllowed = true;
	};

	___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.dollarBraceL.updateContext = function(
		parser,
	) {
		parser.state.context.push(
			___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.templateQuasi,
		);
		parser.state.exprAllowed = true;
	};

	___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL.updateContext = function(
		parser,
		prevType,
	) {
		const statementParens =
			prevType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._if ||
			prevType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._for ||
			prevType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._with ||
			prevType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._while;
		parser.state.context.push(
			statementParens
				? ___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.parenStatement
				: ___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.parenExpression,
		);
		parser.state.exprAllowed = true;
	};

	___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.incDec.updateContext = function() {
		// tokExprAllowed stays unchanged
	};

	___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._function.updateContext = function(
		parser,
		prevType,
	) {
		if (
			prevType.beforeExpr &&
			prevType !==
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.semi &&
			prevType !==
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._else &&
			!(prevType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._return &&
			___R$project$rome$$internal$js$parser$utils$whitespace_ts$lineBreak.test(
				parser.getRawInput(parser.state.lastEndIndex, parser.state.startIndex),
			)) &&
			!((prevType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon ||
			prevType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL) &&
			___R$project$rome$$internal$js$parser$tokenizer$index_ts$getCurContext(
				parser,
			) ===
			___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.bStat)
		) {
			parser.state.context.push(
				___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.functionExpression,
			);
		} else {
			parser.state.context.push(
				___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.functionStatement,
			);
		}

		parser.state.exprAllowed = false;
	};

	___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._class.updateContext = ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._function.updateContext;

	___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.backQuote.updateContext = function(
		parser,
	) {
		if (
			___R$project$rome$$internal$js$parser$tokenizer$index_ts$getCurContext(
				parser,
			) ===
			___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.template
		) {
			parser.state.context.pop();
		} else {
			parser.state.context.push(
				___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.template,
			);
		}
		parser.state.exprAllowed = false;
	};

	___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.jsxTagStart.updateContext = function(
		parser,
	) {
		parser.state.context.push(
			___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.jsxInner,
		); // treat as beginning of JSX expression
		parser.state.context.push(
			___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.jsxOpenTag,
		); // start opening tag context
		parser.state.exprAllowed = false;
	};

	___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.jsxTagEnd.updateContext = function(
		parser,
		prevType,
	) {
		const out = parser.state.context.pop();
		if (
			(out ===
			___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.jsxOpenTag &&
			prevType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.slash) ||
			out ===
			___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.jsxCloseTag
		) {
			parser.state.context.pop();
			parser.state.exprAllowed =
				___R$project$rome$$internal$js$parser$tokenizer$index_ts$getCurContext(
					parser,
				) ===
				___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.jsxInner;
		} else {
			parser.state.exprAllowed = true;
		}
	};


  // project-rome/@internal/js-parser/parser/statement.ts
const ___R$project$rome$$internal$js$parser$parser$statement_ts = {
		parseTopLevel: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseTopLevel,
		parsePossibleInterpreterDirective: ___R$project$rome$$internal$js$parser$parser$statement_ts$parsePossibleInterpreterDirective,
		expressionStatementToDirective: ___R$project$rome$$internal$js$parser$parser$statement_ts$expressionStatementToDirective,
		isLetStart: ___R$project$rome$$internal$js$parser$parser$statement_ts$isLetStart,
		parseStatement: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseStatement,
		isAsyncFunctionDeclarationStart: ___R$project$rome$$internal$js$parser$parser$statement_ts$isAsyncFunctionDeclarationStart,
		assertModuleNodeAllowed: ___R$project$rome$$internal$js$parser$parser$statement_ts$assertModuleNodeAllowed,
		parseBreakContinueStatement: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseBreakContinueStatement,
		parseDebuggerStatement: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseDebuggerStatement,
		parseDoStatement: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseDoStatement,
		parseForStatement: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseForStatement,
		assertVarKind: ___R$project$rome$$internal$js$parser$parser$statement_ts$assertVarKind,
		parseIfStatement: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseIfStatement,
		parseReturnStatement: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseReturnStatement,
		parseSwitchStatement: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseSwitchStatement,
		parseThrowStatement: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseThrowStatement,
		parseTryStatement: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseTryStatement,
		parseVarStatement: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseVarStatement,
		parseWhileStatement: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseWhileStatement,
		parseWithStatement: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseWithStatement,
		parseEmptyStatement: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseEmptyStatement,
		parseLabeledStatement: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseLabeledStatement,
		parseExpressionStatement: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseExpressionStatement,
		parseBlock: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseBlock,
		isValidDirective: ___R$project$rome$$internal$js$parser$parser$statement_ts$isValidDirective,
		parseBlockBody: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseBlockBody,
		parseBlockOrModuleBlockBody: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseBlockOrModuleBlockBody,
		parseFor: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseFor,
		parseForIn: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseForIn,
		parseVar: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseVar,
		parseVarHead: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseVarHead,
		parseFunctionDeclaration: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseFunctionDeclaration,
		parseExportDefaultFunctionDeclaration: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseExportDefaultFunctionDeclaration,
		parseFunctionExpression: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseFunctionExpression,
		parseFunction: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseFunction,
		splitFunctionParams: ___R$project$rome$$internal$js$parser$parser$statement_ts$splitFunctionParams,
		parseFunctionParams: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseFunctionParams,
	};
	const ___R$$priv$project$rome$$internal$js$parser$parser$statement_ts$loopLabel = {
		kind: "loop",
	};
	const ___R$$priv$project$rome$$internal$js$parser$parser$statement_ts$switchLabel = {
		kind: "switch",
	};

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseTopLevel(
		parser,
	) {
		const start = parser.getPosition();
		const openContext = {
			name: "top-level",
			start,
			indent: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
			open: ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eof,
			close: ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eof,
		};

		// Parse the body, and catch fatal syntax errors

		// Get the first token
		___R$project$rome$$internal$js$parser$tokenizer$index_ts$nextToken(parser);

		const interpreter = ___R$project$rome$$internal$js$parser$parser$statement_ts$parsePossibleInterpreterDirective(
			parser,
		);
		const {body, directives} = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseBlockBody(
			parser,
			true,
			true,
			openContext,
		);

		return parser.finishNode(
			start,
			parser.finishRoot({
				type: "JSRoot",
				corrupt: parser.state.corrupt,
				body,
				directives,
				sourceType: parser.options.sourceType,
				interpreter,
				syntax: Array.from(parser.meta.syntax),
				hasHoistedVars: parser.state.hasHoistedVars,
			}),
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parsePossibleInterpreterDirective(
		parser,
	) {
		// Check for #!
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.hash,
			) &&
			parser.input[___R$project$rome$$internal$ob1$index_ts$ob1Get0(
				parser.state.endIndex,
			)] === "!"
		) {
			const directive = ___R$project$rome$$internal$js$parser$tokenizer$index_ts$skipInterpreterDirective(
				parser,
				1,
			);

			// Advance to next token
			___R$project$rome$$internal$js$parser$parser_ts$next(parser);

			return directive;
		} else {
			return undefined;
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$expressionStatementToDirective(
		parser,
		stmt,
	) {
		const expr = stmt.expression;

		const start = parser.getLoc(stmt).start;

		const raw = parser.getRawInput(
			parser.getInputStartIndex(expr),
			parser.getInputEndIndex(expr),
		);
		const val = raw.slice(1, -1); // remove quotes
		const end = parser.getLoc(stmt).end;

		return parser.finishNodeAt(
			start,
			end,
			{
				type: "JSDirective",
				value: val,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$isLetStart(
		parser,
		context,
	) {
		if (
			!___R$project$rome$$internal$js$parser$parser_ts$isContextual(
				parser,
				"let",
			)
		) {
			return false;
		}

		___R$project$rome$$internal$js$parser$utils$whitespace_ts$skipWhiteSpace.lastIndex = ___R$project$rome$$internal$ob1$index_ts$ob1Get0(
			parser.state.index,
		);
		const skip = ___R$project$rome$$internal$js$parser$utils$whitespace_ts$skipWhiteSpace.exec(
			parser.input,
		);
		if (skip == null) {
			throw new Error("Should never be true");
		}

		const next = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
			parser.state.index,
			skip[0].length,
		);
		const nextCh = parser.input.charCodeAt(
			___R$project$rome$$internal$ob1$index_ts$ob1Get0(next),
		);

		// For ambiguous cases, determine if a LexicalDeclaration (or only a
		// Statement) is allowed here. If context is not empty then only a Statement
		// is allowed. However, `let [` is an explicit negative lookahead for
		// JSExpressionStatement, so special-case it first.
		if (
			nextCh ===
			___R$project$rome$$internal$string$charcodes$index_ts.leftSquareBracket
		) {
			return true;
		}

		if (context !== undefined) {
			return false;
		}

		if (
			nextCh ===
			___R$project$rome$$internal$string$charcodes$index_ts.leftCurlyBrace
		) {
			return true;
		}

		if (
			___R$project$rome$$internal$js$parser$utils$identifier_ts$isIdentifierStart(
				nextCh,
			)
		) {
			let pos = ___R$project$rome$$internal$ob1$index_ts$ob1Add(next, 1);
			while (
				___R$project$rome$$internal$js$parser$utils$identifier_ts$isIdentifierChar(
					parser.input.charCodeAt(
						___R$project$rome$$internal$ob1$index_ts$ob1Get0(pos),
					),
				)
			) {
				pos = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(pos);
			}

			const ident = parser.getRawInput(next, pos);
			if (
				!___R$project$rome$$internal$js$parser$utils$identifier_ts$keywordRelationalOperator.test(
					ident,
				)
			) {
				return true;
			}
		}
		return false;
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseStatement(
		parser,
		context = undefined,
		topLevel = false,
	) {
		let startType = parser.state.tokenType;
		const start = parser.getPosition();

		if (
			startType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._const &&
			___R$project$rome$$internal$js$parser$parser_ts$isSyntaxEnabled(
				parser,
				"ts",
			)
		) {
			const ahead = ___R$project$rome$$internal$js$parser$parser_ts$lookaheadState(
				parser,
			);
			if (
				ahead.tokenType ===
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name &&
				ahead.tokenValue === "enum"
			) {
				___R$project$rome$$internal$js$parser$parser_ts$expect(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._const,
				);
				___R$project$rome$$internal$js$parser$parser_ts$expectContextual(
					parser,
					"enum",
				);
				return ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSEnumDeclaration(
					parser,
					start,
					/* isConst */ true,
				);
			}
		}

		let kind;
		if (
			___R$project$rome$$internal$js$parser$parser$statement_ts$isLetStart(
				parser,
				context,
			)
		) {
			startType = ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._var;
			kind = "let";
		}

		// Most types of statements are recognized by the keyword they

		// start with. Many are trivial to parse, some require a bit of

		// complexity.
		switch (startType) {
			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._break:
				return ___R$project$rome$$internal$js$parser$parser$statement_ts$parseBreakContinueStatement(
					parser,
					start,
					true,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._continue:
				return ___R$project$rome$$internal$js$parser$parser$statement_ts$parseBreakContinueStatement(
					parser,
					start,
					false,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._debugger:
				return ___R$project$rome$$internal$js$parser$parser$statement_ts$parseDebuggerStatement(
					parser,
					start,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._do:
				return ___R$project$rome$$internal$js$parser$parser$statement_ts$parseDoStatement(
					parser,
					start,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._for:
				return ___R$project$rome$$internal$js$parser$parser$statement_ts$parseForStatement(
					parser,
					start,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._function: {
				if (
					___R$project$rome$$internal$js$parser$parser_ts$lookaheadState(parser).tokenType ===
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.dot
				) {
					// JSMetaProperty: eg. function.sent
					break;
				}

				if (context !== undefined) {
					if (
						___R$project$rome$$internal$js$parser$parser_ts$inScope(
							parser,
							"STRICT",
						)
					) {
						___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
							parser,
							{
								description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.ILLEGAL_FUNCTION_IN_STRICT,
							},
						);
					} else if (context !== "if" && context !== "label") {
						___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
							parser,
							{
								description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.ILLEGAL_FUNCTION_IN_NON_STRICT,
							},
						);
					}
				}

				___R$project$rome$$internal$js$parser$parser_ts$expect(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._function,
				);

				const result = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseFunctionDeclaration(
					parser,
					start,
					false,
				);

				if (context !== undefined && result.head.generator === true) {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.ILLEGAL_GENERATOR_DEFINITION,
							loc: result.loc,
						},
					);
				}

				return result;
			}

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._class: {
				if (context !== undefined) {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedToken(
						parser,
					);
				}
				return ___R$project$rome$$internal$js$parser$parser$classes_ts$parseClassDeclaration(
					parser,
					start,
				);
			}

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._if:
				return ___R$project$rome$$internal$js$parser$parser$statement_ts$parseIfStatement(
					parser,
					start,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._return:
				return ___R$project$rome$$internal$js$parser$parser$statement_ts$parseReturnStatement(
					parser,
					start,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._switch:
				return ___R$project$rome$$internal$js$parser$parser$statement_ts$parseSwitchStatement(
					parser,
					start,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._throw:
				return ___R$project$rome$$internal$js$parser$parser$statement_ts$parseThrowStatement(
					parser,
					start,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._try:
				return ___R$project$rome$$internal$js$parser$parser$statement_ts$parseTryStatement(
					parser,
					start,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._const:
			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._var: {
				kind =
					kind === undefined
						? ___R$project$rome$$internal$js$parser$parser$statement_ts$assertVarKind(
								String(parser.state.tokenValue),
							)
						: kind;
				if (context !== undefined && kind !== "var") {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.LEXICAL_DECLARATION_IN_SINGLE_STATEMENT_CONTEXT,
						},
					);
				}
				return ___R$project$rome$$internal$js$parser$parser$statement_ts$parseVarStatement(
					parser,
					start,
					kind,
				);
			}

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._while:
				return ___R$project$rome$$internal$js$parser$parser$statement_ts$parseWhileStatement(
					parser,
					start,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._with:
				return ___R$project$rome$$internal$js$parser$parser$statement_ts$parseWithStatement(
					parser,
					start,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL:
				return ___R$project$rome$$internal$js$parser$parser$statement_ts$parseBlock(
					parser,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.semi:
				return ___R$project$rome$$internal$js$parser$parser$statement_ts$parseEmptyStatement(
					parser,
					start,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._export:
			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._import: {
				const nextToken = ___R$project$rome$$internal$js$parser$parser_ts$lookaheadState(
					parser,
				);
				if (
					nextToken.tokenType ===
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL ||
					nextToken.tokenType ===
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.dot
				) {
					break;
				}

				___R$project$rome$$internal$js$parser$parser_ts$next(parser);

				let result;
				if (
					startType ===
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._import
				) {
					result = ___R$project$rome$$internal$js$parser$parser$modules_ts$parseImport(
						parser,
						start,
					);
				} else {
					result = ___R$project$rome$$internal$js$parser$parser$modules_ts$parseExport(
						parser,
						start,
					);
				}

				if (!topLevel) {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.IMPORT_EXPORT_MUST_TOP_LEVEL,
						},
					);
				}

				___R$project$rome$$internal$js$parser$parser$statement_ts$assertModuleNodeAllowed(
					parser,
					result,
				);

				return result;
			}

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name:
				if (
					___R$project$rome$$internal$js$parser$parser$statement_ts$isAsyncFunctionDeclarationStart(
						parser,
					)
				) {
					if (context !== undefined) {
						___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
							parser,
							{
								description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.ILLEGAL_ASYNC_DEFINITION,
							},
						);
					}

					// async identifier
					___R$project$rome$$internal$js$parser$parser_ts$expect(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name,
					);

					// function keyword
					___R$project$rome$$internal$js$parser$parser_ts$expect(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._function,
					);

					return ___R$project$rome$$internal$js$parser$parser$statement_ts$parseFunctionDeclaration(
						parser,
						start,
						true,
					);
				}
		}

		// If the statement does not start with a statement keyword or a

		// brace, it's an JSExpressionStatement or JSLabeledStatement. We

		// simply start parsing an expression, and afterwards, if the

		// next token is a colon and the expression was a simple

		// JSIdentifier node, we switch to interpreting it as a label.
		const maybeName = String(parser.state.tokenValue);
		const expr = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpression(
			parser,
			"statement expression",
		);

		if (
			startType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name &&
			expr.type === "JSReferenceIdentifier" &&
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			return ___R$project$rome$$internal$js$parser$parser$statement_ts$parseLabeledStatement(
				parser,
				start,
				maybeName,
				expr,
				context,
			);
		} else {
			return ___R$project$rome$$internal$js$parser$parser$statement_ts$parseExpressionStatement(
				parser,
				start,
				expr,
			);
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$isAsyncFunctionDeclarationStart(
		parser,
	) {
		if (
			!___R$project$rome$$internal$js$parser$parser_ts$isContextual(
				parser,
				"async",
			)
		) {
			return false;
		}

		const {input} = parser;
		const {index} = parser.state;

		___R$project$rome$$internal$js$parser$utils$whitespace_ts$skipWhiteSpace.lastIndex = ___R$project$rome$$internal$ob1$index_ts$ob1Get0(
			index,
		);
		const skip = ___R$project$rome$$internal$js$parser$utils$whitespace_ts$skipWhiteSpace.exec(
			input,
		);

		if (!skip || skip.length === 0) {
			return false;
		}

		const next = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
			index,
			skip[0].length,
		);

		return (
			!___R$project$rome$$internal$js$parser$utils$whitespace_ts$lineBreak.test(
				parser.getRawInput(index, next),
			) &&
			parser.getRawInput(
				next,
				___R$project$rome$$internal$ob1$index_ts$ob1Add(next, 8),
			) === "function" &&
			(___R$project$rome$$internal$ob1$index_ts$ob1Get0(next) + 8 ===
			input.length ||
			!___R$project$rome$$internal$js$parser$utils$identifier_ts$isIdentifierChar(
				input.charCodeAt(
					___R$project$rome$$internal$ob1$index_ts$ob1Get0(next) + 8,
				),
			))
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$assertModuleNodeAllowed(
		parser,
		node,
	) {
		if (
			(node.type === "JSImportDeclaration" &&
			(node.importKind === "type" || node.importKind === "typeof")) ||
			(node.type === "JSExportLocalDeclaration" && node.exportKind === "type") ||
			(node.type === "JSExportAllDeclaration" && node.exportKind === "type")
		) {
			// Allow Flow type imports and exports in all conditions because
			// Flow itself does not care about 'sourceType'.
			return;
		}

		if (!parser.meta.inModule) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					loc: node.loc,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.IMPORT_EXPORT_IN_SCRIPT(
						parser.options.manifestPath,
					),
				},
			);
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseBreakContinueStatement(
		parser,
		start,
		isBreak,
	) {
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);

		let label;
		if (___R$project$rome$$internal$js$parser$parser_ts$isLineTerminator(parser)) {
			label = undefined;
		} else if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name,
			)
		) {
			label = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier(
				parser,
			);
			___R$project$rome$$internal$js$parser$parser_ts$semicolon(parser);
		} else {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedToken(parser);
		}

		// Verify that there is an actual destination to break or

		// continue to.
		let i;
		for (i = 0; i < parser.state.labels.length; ++i) {
			const lab = parser.state.labels[i];
			if (label === undefined || lab.name === label.name) {
				if (lab.kind !== undefined && (isBreak || lab.kind === "loop")) {
					break;
				}

				if (label && isBreak) {
					break;
				}
			}
		}
		if (i === parser.state.labels.length) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					start,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.UNKNOWN_LABEL(
						label && label.name,
					),
				},
			);
		}

		if (isBreak) {
			return parser.finishNode(
				start,
				{
					type: "JSBreakStatement",
					label,
				},
			);
		} else {
			return parser.finishNode(
				start,
				{
					type: "JSContinueStatement",
					label,
				},
			);
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseDebuggerStatement(
		parser,
		start,
	) {
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		___R$project$rome$$internal$js$parser$parser_ts$semicolon(parser);
		return parser.finishNode(start, {type: "JSDebuggerStatement"});
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseDoStatement(
		parser,
		start,
	) {
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		parser.state.labels.push(
			___R$$priv$project$rome$$internal$js$parser$parser$statement_ts$loopLabel,
		);
		const body = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseStatement(
			parser,
			"do",
		);
		parser.state.labels.pop();
		___R$project$rome$$internal$js$parser$parser_ts$expect(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._while,
		);
		const test = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseParenExpression(
			parser,
			"do test",
		);
		___R$project$rome$$internal$js$parser$parser_ts$eat(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.semi,
		);
		return parser.finishNode(
			start,
			{
				type: "JSDoWhileStatement",
				body,
				test,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseForStatement(
		parser,
		start,
	) {
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		parser.state.labels.push(
			___R$$priv$project$rome$$internal$js$parser$parser$statement_ts$loopLabel,
		);

		let awaitAt;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$inScope(parser, "ASYNC") &&
			___R$project$rome$$internal$js$parser$parser_ts$eatContextual(
				parser,
				"await",
			)
		) {
			awaitAt = parser.getLastEndPosition();
		}

		const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR,
			"for head",
		);

		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.semi,
			)
		) {
			if (awaitAt) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedToken(parser);
			}
			return ___R$project$rome$$internal$js$parser$parser$statement_ts$parseFor(
				parser,
				start,
				openContext,
				undefined,
			);
		}

		const _isLet = ___R$project$rome$$internal$js$parser$parser$statement_ts$isLetStart(
			parser,
		);
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._var,
			) ||
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._const,
			) ||
			_isLet
		) {
			const initStart = parser.getPosition();

			const kind = ___R$project$rome$$internal$js$parser$parser$statement_ts$assertVarKind(
				_isLet ? "let" : String(parser.state.tokenValue),
			);
			___R$project$rome$$internal$js$parser$parser_ts$next(parser);

			const declarations = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseVar(
				parser,
				initStart,
				kind,
				true,
			);

			const init = parser.finishNode(
				initStart,
				{
					type: "JSVariableDeclaration",
					kind,
					declarations,
				},
			);

			if (
				(___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._in,
				) ||
				___R$project$rome$$internal$js$parser$parser_ts$isContextual(
					parser,
					"of",
				)) &&
				init.declarations.length === 1
			) {
				return ___R$project$rome$$internal$js$parser$parser$statement_ts$parseForIn(
					parser,
					start,
					openContext,
					init,
					awaitAt,
				);
			}

			if (awaitAt !== undefined) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						start: awaitAt,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.REGULAR_FOR_AWAIT,
					},
				);
			}

			return ___R$project$rome$$internal$js$parser$parser$statement_ts$parseFor(
				parser,
				start,
				openContext,
				init,
			);
		}

		const refShorthandDefaultPos = {
			index: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
		};
		let init = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpression(
			parser,
			"for init",
			true,
			refShorthandDefaultPos,
		);

		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._in,
			) ||
			___R$project$rome$$internal$js$parser$parser_ts$isContextual(parser, "of")
		) {
			const description = ___R$project$rome$$internal$js$parser$parser_ts$isContextual(
				parser,
				"of",
			)
				? "for-of statement"
				: "for-in statement";
			const initPattern = ___R$project$rome$$internal$js$parser$parser$lval_ts$toTargetAssignmentPattern(
				parser,
				init,
				description,
			);
			___R$project$rome$$internal$js$parser$parser$lval_ts$checkLVal(
				parser,
				init,
				undefined,
				undefined,
				description,
			);
			return ___R$project$rome$$internal$js$parser$parser$statement_ts$parseForIn(
				parser,
				start,
				openContext,
				initPattern,
				awaitAt,
			);
		}

		if (
			___R$project$rome$$internal$ob1$index_ts$ob1Get0(
				refShorthandDefaultPos.index,
			) >
			0
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedToken(
				parser,
				parser.getPositionFromIndex(refShorthandDefaultPos.index),
			);
		}

		if (awaitAt !== undefined) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					start: awaitAt,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.REGULAR_FOR_AWAIT,
				},
			);
		}

		return ___R$project$rome$$internal$js$parser$parser$statement_ts$parseFor(
			parser,
			start,
			openContext,
			init,
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$assertVarKind(
		kind,
	) {
		if (kind === "let" || kind === "var" || kind === "const") {
			return kind;
		} else {
			throw new Error("Expected valid variable kind but got " + kind);
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseIfStatement(
		parser,
		start,
	) {
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		const test = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseParenExpression(
			parser,
			"if test",
		);
		const consequent = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseStatement(
			parser,
			"if",
		);
		const alternate = ___R$project$rome$$internal$js$parser$parser_ts$eat(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._else,
		)
			? ___R$project$rome$$internal$js$parser$parser$statement_ts$parseStatement(
					parser,
					"if",
				)
			: undefined;
		return parser.finishNode(
			start,
			{
				type: "JSIfStatement",
				test,
				consequent,
				alternate,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseReturnStatement(
		parser,
		start,
	) {
		if (
			!___R$project$rome$$internal$js$parser$parser_ts$inScope(
				parser,
				"FUNCTION",
			) &&
			parser.options.sourceType !== "template" &&
			!parser.options.allowReturnOutsideFunction
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.RETURN_OUTSIDE_FUNCTION,
				},
			);
		}

		___R$project$rome$$internal$js$parser$parser_ts$next(parser);

		// In `return` (and `break`/`continue`), the keywords with
		// optional arguments, we eagerly look for a semicolon or the
		// possibility to insert one.
		let argument;
		if (
			!___R$project$rome$$internal$js$parser$parser_ts$isLineTerminator(parser)
		) {
			argument = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpression(
				parser,
				"return argument",
			);
			___R$project$rome$$internal$js$parser$parser_ts$semicolon(parser);
		}

		return parser.finishNode(
			start,
			{
				type: "JSReturnStatement",
				argument,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseSwitchStatement(
		parser,
		start,
	) {
		___R$project$rome$$internal$js$parser$parser_ts$expect(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._switch,
		);
		const discriminant = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseParenExpression(
			parser,
			"switch discriminant",
		);
		const cases = [];
		const hasBrace = ___R$project$rome$$internal$js$parser$parser_ts$match(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL,
		);
		const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
			"switch body",
		);
		parser.state.labels.push(
			___R$$priv$project$rome$$internal$js$parser$parser$statement_ts$switchLabel,
		);

		if (hasBrace) {
			// Statements under must be grouped (by label) in JSSwitchCase
			// nodes. `cur` is used to keep the node that we are currently
			// adding statements to.
			let cur;

			function pushCase() {
				if (cur === undefined) {
					return;
				}

				cases.push(
					parser.finishNode(
						cur.start,
						{
							type: "JSSwitchCase",
							test: cur.test,
							consequent: cur.consequent,
						},
					),
				);

				cur = undefined;
			}

			let sawDefault;

			while (true) {
				if (
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
					) ||
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eof,
					)
				) {
					break;
				}

				if (
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._case,
					) ||
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._default,
					)
				) {
					pushCase();

					const start = parser.getPosition();
					const isCase = ___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._case,
					);

					___R$project$rome$$internal$js$parser$parser_ts$next(parser);

					let test;
					if (isCase) {
						test = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpression(
							parser,
							"case test",
						);
					} else {
						if (sawDefault) {
							// TODO point to other default
							___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
								parser,
								{
									start: parser.state.lastStartPos,
									description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.MULTIPLE_DEFAULT_CASE,
								},
							);
						}
						sawDefault = true;
					}

					cur = {
						start,
						consequent: [],
						test,
					};

					___R$project$rome$$internal$js$parser$parser_ts$expect(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
					);
				} else {
					const stmt = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseStatement(
						parser,
						undefined,
					);
					if (cur === undefined) {
						___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
							parser,
							{
								loc: stmt.loc,
								description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.SWITCH_STATEMENT_OUTSIDE_CASE,
							},
						);
					} else {
						cur.consequent.push(stmt);
					}
				}
			}

			pushCase();
		}

		___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
			parser,
			openContext,
		);
		parser.state.labels.pop();

		return parser.finishNode(
			start,
			{
				type: "JSSwitchStatement",
				discriminant,
				cases,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseThrowStatement(
		parser,
		start,
	) {
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		if (
			___R$project$rome$$internal$js$parser$utils$whitespace_ts$lineBreak.test(
				parser.getRawInput(parser.state.lastEndIndex, parser.state.startIndex),
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					start: parser.state.lastEndPos,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.NEWLINE_AFTER_THROW,
				},
			);
		}

		const argument = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpression(
			parser,
			"throw argument",
		);
		___R$project$rome$$internal$js$parser$parser_ts$semicolon(parser);
		return parser.finishNode(
			start,
			{
				type: "JSThrowStatement",
				argument,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseTryStatement(
		parser,
		start,
	) {
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);

		const block = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseBlock(
			parser,
		);
		let handler = undefined;

		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._catch,
			)
		) {
			const clauseStart = parser.getPosition();
			___R$project$rome$$internal$js$parser$parser_ts$next(parser);

			let param;
			if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
				)
			) {
				const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR,
					"catch clause param",
				);
				param = ___R$project$rome$$internal$js$parser$parser$lval_ts$parseTargetBindingPattern(
					parser,
				);
				const clashes = new Map();
				___R$project$rome$$internal$js$parser$parser$lval_ts$checkLVal(
					parser,
					param,
					true,
					clashes,
					"catch clause",
				);
				___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
					parser,
					openContext,
				);
			}

			const body = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseBlock(
				parser,
			);
			handler = parser.finishNode(
				clauseStart,
				{
					type: "JSCatchClause",
					body,
					param,
				},
			);
		}

		const finalizer = ___R$project$rome$$internal$js$parser$parser_ts$eat(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._finally,
		)
			? ___R$project$rome$$internal$js$parser$parser$statement_ts$parseBlock(
					parser,
				)
			: undefined;

		if (!handler && !finalizer) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					start,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TRY_MISSING_FINALLY_OR_CATCH,
				},
			);
		}

		return parser.finishNode(
			start,
			{
				type: "JSTryStatement",
				block,
				finalizer,
				handler,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseVarStatement(
		parser,
		start,
		kind,
	) {
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		const declarations = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseVar(
			parser,
			start,
			kind,
			false,
		);
		___R$project$rome$$internal$js$parser$parser_ts$semicolon(parser);
		return parser.finishNode(
			start,
			{
				type: "JSVariableDeclarationStatement",
				declaration: parser.finishNode(
					start,
					{
						type: "JSVariableDeclaration",
						kind,
						declarations,
					},
				),
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseWhileStatement(
		parser,
		start,
	) {
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		const test = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseParenExpression(
			parser,
			"while test",
		);
		parser.state.labels.push(
			___R$$priv$project$rome$$internal$js$parser$parser$statement_ts$loopLabel,
		);
		const body = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseStatement(
			parser,
			"while",
		);
		parser.state.labels.pop();
		return parser.finishNode(start, {type: "JSWhileStatement", test, body});
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseWithStatement(
		parser,
		start,
	) {
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		const object = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseParenExpression(
			parser,
			"with object",
		);
		const body = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseStatement(
			parser,
			"with",
		);

		if (
			___R$project$rome$$internal$js$parser$parser_ts$inScope(parser, "STRICT")
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					loc: parser.finishLoc(start),
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.WITH_IN_STRICT,
				},
			);
		}

		return parser.finishNode(
			start,
			{
				type: "JSWithStatement",
				object,
				body,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseEmptyStatement(
		parser,
		start,
	) {
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		return parser.finishNode(start, {type: "JSEmptyStatement"});
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseLabeledStatement(
		parser,
		start,
		maybeName,
		expr,
		context,
	) {
		for (const label of parser.state.labels) {
			if (label.name === maybeName) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						loc: expr.loc,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.DUPLICATE_LABEL(
							maybeName,
							label.loc,
						),
					},
				);
			}
		}

		let kind = undefined;
		if (parser.state.tokenType.isLoop) {
			kind = "loop";
		} else if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._switch,
			)
		) {
			kind = "switch";
		}

		const startIndex = parser.getIndexFromPosition(start, parser.filename);
		for (let i = parser.state.labels.length - 1; i >= 0; i--) {
			const label = parser.state.labels[i];
			if (label.statementStart === startIndex) {
				label.statementStart = parser.getIndex();
				label.kind = kind;
			} else {
				break;
			}
		}

		parser.state.labels.push({
			name: maybeName,
			kind,
			loc: parser.getLoc(expr),
			statementStart: parser.getIndex(),
		});

		let statementContext = "label";
		if (context !== undefined) {
			if (context.includes("label")) {
				statementContext = context;
			} else {
				// @ts-ignore
				statementContext = context + "label";
			}
		}
		const body = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseStatement(
			parser,
			statementContext,
		);

		if (
			body.type === "JSClassDeclaration" ||
			(body.type === "JSVariableDeclarationStatement" &&
			body.declaration.kind !== "var") ||
			(body.type === "JSFunctionDeclaration" &&
			(___R$project$rome$$internal$js$parser$parser_ts$inScope(parser, "STRICT") ||
			body.head.generator === true ||
			body.head.async === true))
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					loc: body.loc,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.INVALID_LABEL_DECLARATION,
				},
			);
		}

		parser.state.labels.pop();
		return parser.finishNode(
			start,
			{
				type: "JSLabeledStatement",
				label: Object.assign({}, expr, {type: "JSIdentifier"}),
				body,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseExpressionStatement(
		parser,
		start,
		expr,
	) {
		const node = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeExpressionStatement(
			parser,
			start,
			expr,
		);
		if (node !== undefined) {
			return node;
		}

		___R$project$rome$$internal$js$parser$parser_ts$semicolon(parser);
		return parser.finishNode(
			start,
			{
				type: "JSExpressionStatement",
				expression: expr,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseBlock(
		parser,
		allowDirectives,
	) {
		const start = parser.getPosition();
		const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
			"block",
		);
		const {body, directives} = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseBlockBody(
			parser,
			allowDirectives,
			false,
			openContext,
		);
		return parser.finishNode(
			start,
			{
				type: "JSBlockStatement",
				directives,
				body,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$isValidDirective(
		parser,
		stmt,
	) {
		return (
			stmt.type === "JSExpressionStatement" &&
			stmt.expression.type === "JSStringLiteral" &&
			!___R$project$rome$$internal$js$parser$parser_ts$isParenthesized(
				parser,
				stmt.expression,
			)
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseBlockBody(
		parser,
		allowDirectives = false,
		topLevel,
		openContext,
	) {
		return ___R$project$rome$$internal$js$parser$parser$statement_ts$parseBlockOrModuleBlockBody(
			parser,
			allowDirectives,
			topLevel,
			openContext,
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseBlockOrModuleBlockBody(
		parser,
		allowDirectives,
		topLevel,
		openContext,
	) {
		const body = [];
		const directives = [];

		let parsedNonDirective = false;
		let didSetStrict = undefined;
		let octalPosition;

		while (true) {
			if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					openContext.close,
				) ||
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eof,
				)
			) {
				___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
					parser,
					openContext,
				);
				break;
			}

			if (!parsedNonDirective && parser.state.containsOctal && !octalPosition) {
				octalPosition = parser.state.octalPosition;
			}

			const stmt = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseStatement(
				parser,
				undefined,
				topLevel,
			);

			if (
				allowDirectives &&
				!parsedNonDirective &&
				stmt.type === "JSExpressionStatement" &&
				___R$project$rome$$internal$js$parser$parser$statement_ts$isValidDirective(
					parser,
					stmt,
				)
			) {
				const directive = ___R$project$rome$$internal$js$parser$parser$statement_ts$expressionStatementToDirective(
					parser,
					stmt,
				);
				directives.push(directive);

				if (didSetStrict === undefined && directive.value === "use strict") {
					___R$project$rome$$internal$js$parser$tokenizer$index_ts$setStrict(
						parser,
						true,
					);
					didSetStrict = true;

					if (octalPosition !== undefined) {
						___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
							parser,
							{
								index: octalPosition,
								description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.OCTAL_IN_STRICT,
							},
						);
					}
				}

				continue;
			}

			parsedNonDirective = true;
			body.push(stmt);
		}

		if (didSetStrict) {
			___R$project$rome$$internal$js$parser$parser_ts$popScope(parser, "STRICT");
		}

		return {body, directives};
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseFor(
		parser,
		start,
		openContext,
		init,
	) {
		___R$project$rome$$internal$js$parser$parser_ts$expect(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.semi,
		);

		const test = ___R$project$rome$$internal$js$parser$parser_ts$match(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.semi,
		)
			? undefined
			: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpression(
					parser,
					"for test",
				);
		___R$project$rome$$internal$js$parser$parser_ts$expect(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.semi,
		);

		const update = ___R$project$rome$$internal$js$parser$parser_ts$match(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR,
		)
			? undefined
			: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpression(
					parser,
					"for update",
				);
		___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
			parser,
			openContext,
		);

		const body = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseStatement(
			parser,
			"for",
		);
		parser.state.labels.pop();

		return parser.finishNode(
			start,
			{
				type: "JSForStatement",
				init,
				test,
				update,
				body,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseForIn(
		parser,
		start,
		openContext,
		init,
		awaitAt,
	) {
		const isForIn = ___R$project$rome$$internal$js$parser$parser_ts$match(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._in,
		);
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);

		const isAwait = awaitAt !== undefined;
		if (isForIn && isAwait) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					start: awaitAt,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.REGULAR_FOR_AWAIT,
				},
			);
		}

		if (
			init.type === "JSVariableDeclaration" &&
			init.declarations[0].init !== undefined &&
			(!isForIn ||
			___R$project$rome$$internal$js$parser$parser_ts$inScope(parser, "STRICT") ||
			init.kind !== "var" ||
			init.declarations[0].id.type !== "JSBindingIdentifier")
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					loc: init.loc,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.FOR_IN_OF_WITH_INITIALIZER,
				},
			);
		}

		const left = init;
		const right = isForIn
			? ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpression(
					parser,
					"for right",
				)
			: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeAssign(
					parser,
					"for right",
				);
		___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
			parser,
			openContext,
		);

		const body = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseStatement(
			parser,
			"for",
		);
		parser.state.labels.pop();

		if (isForIn) {
			const node = parser.finishNode(
				start,
				{
					type: "JSForInStatement",
					left,
					right,
					body,
				},
			);
			return node;
		} else {
			const node = parser.finishNode(
				start,
				{
					type: "JSForOfStatement",
					await: isAwait,
					left,
					right,
					body,
				},
			);
			return node;
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseVar(
		parser,
		start,
		kind,
		isFor,
	) {
		const declarations = [];

		while (true) {
			const start = parser.getPosition();
			const id = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseVarHead(
				parser,
				start,
			);

			if (kind === "var") {
				parser.state.hasHoistedVars = true;
			}

			let init;
			if (
				___R$project$rome$$internal$js$parser$parser_ts$eat(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eq,
				)
			) {
				init = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeAssign(
					parser,
					"var init",
					isFor,
				);
			} else {
				if (
					kind === "const" &&
					!(___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._in,
					) ||
					___R$project$rome$$internal$js$parser$parser_ts$isContextual(
						parser,
						"of",
					))
				) {
					// `const` with no initializer is allowed in TypeScript.
					// It could be a declaration like `const x: number;`.
					if (
						!___R$project$rome$$internal$js$parser$parser_ts$isSyntaxEnabled(
							parser,
							"ts",
						)
					) {
						___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
							parser,
							{
								description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.CONST_WITHOUT_INITIALIZER,
								loc: id.loc,
							},
						);
					}
				}

				// We exclude `const` because we already validated it above
				if (
					kind !== "const" &&
					id.type !== "JSBindingIdentifier" &&
					!(isFor &&
					(___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._in,
					) ||
					___R$project$rome$$internal$js$parser$parser_ts$isContextual(
						parser,
						"of",
					)))
				) {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							start: parser.state.lastEndPos,
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.COMPLEX_BINDING_WITHOUT_INITIALIZER,
						},
					);
				}
			}

			declarations.push(
				parser.finishNode(
					start,
					{
						type: "JSVariableDeclarator",
						id,
						init,
					},
				),
			);

			if (
				!___R$project$rome$$internal$js$parser$parser_ts$eat(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
				)
			) {
				break;
			}
		}

		return declarations;
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseVarHead(
		parser,
		start,
	) {
		const id = ___R$project$rome$$internal$js$parser$parser$lval_ts$parseTargetBindingPattern(
			parser,
		);

		___R$project$rome$$internal$js$parser$parser$lval_ts$checkLVal(
			parser,
			id,
			true,
			undefined,
			"variable declaration",
		);

		let definite;
		if (
			id.type === "JSBindingIdentifier" &&
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bang,
			)
		) {
			definite = true;
			___R$project$rome$$internal$js$parser$parser_ts$expectSyntaxEnabled(
				parser,
				"ts",
			);
			___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			const typeAnnotation = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
				parser,
				true,
			);

			return parser.finishNode(
				start,
				Object.assign(
					{},
					id,
					{
						meta: parser.finishNode(
							start,
							{
								type: "JSPatternMeta",
								typeAnnotation,
								definite,
							},
						),
					},
				),
			);
		} else if (definite) {
			return Object.assign(
				{},
				id,
				{meta: parser.finishNode(start, {type: "JSPatternMeta", definite})},
			);
		} else {
			return id;
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$statement_ts$parseFunctionId(
		parser,
		requiredStatementId,
	) {
		if (
			requiredStatementId ||
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name,
			)
		) {
			return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseBindingIdentifier(
				parser,
			);
		} else {
			return undefined;
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseFunctionDeclaration(
		parser,
		start,
		isAsync,
	) {
		const ___R$ = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseFunction(
			parser,
			{
				start,
				requiredStatementId: true,
				isStatement: true,
				isAsync,
			},
		);
		const shape = Object.assign({}, ___R$);
		delete shape.id;
		delete shape.body;
		const {id, body} = ___R$;
		if (id === undefined) {
			throw new Error("Required function name");
		}

		if (body === undefined) {
			return parser.finalizeNode(
				Object.assign({type: "TSDeclareFunction"}, shape, {id}),
			);
		}

		return parser.finalizeNode(
			Object.assign({type: "JSFunctionDeclaration"}, shape, {id, body}),
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseExportDefaultFunctionDeclaration(
		parser,
		start,
		isAsync,
	) {
		let ___R$1 = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseFunction(
			parser,
			{
				start,
				requiredStatementId: false,
				isStatement: true,
				isAsync,
			},
		);
		let shape = Object.assign({}, ___R$1);
		delete shape.id;
		delete shape.body;
		let {id, body} = ___R$1;
		if (id === undefined) {
			id = {
				type: "JSBindingIdentifier",
				name: "*default*",
				// Does this `loc` make sense?
				loc: shape.loc,
			};
		}

		if (body === undefined) {
			return parser.finalizeNode(
				Object.assign({type: "TSDeclareFunction"}, shape, {id}),
			);
		}

		return parser.finalizeNode(
			Object.assign({type: "JSFunctionDeclaration"}, shape, {id, body}),
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseFunctionExpression(
		parser,
		start,
		isAsync,
	) {
		const ___R$2 = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseFunction(
			parser,
			{
				start,
				requiredStatementId: false,
				isStatement: false,
				isAsync,
			},
		);
		const shape = Object.assign({}, ___R$2);
		delete shape.body;
		const {body} = ___R$2;
		if (body === undefined) {
			throw new Error("Expected body");
		}

		return Object.assign({}, shape, {body, type: "JSFunctionExpression"});
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseFunction(
		parser,
		opts,
	) {
		const {start, isStatement, requiredStatementId, isAsync} = opts;

		const isGenerator = ___R$project$rome$$internal$js$parser$parser_ts$eat(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.star,
		);

		let id;
		if (isStatement) {
			id = ___R$$priv$project$rome$$internal$js$parser$parser$statement_ts$parseFunctionId(
				parser,
				requiredStatementId,
			);
		}

		const oldYieldPos = parser.state.yieldPos;
		const oldAwaitPos = parser.state.awaitPos;
		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"FUNCTION_LOC",
			start,
		);
		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"FUNCTION",
			true,
		);
		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"METHOD",
			false,
		);
		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"GENERATOR",
			isGenerator,
		);
		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"ASYNC",
			isAsync,
		);
		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"CLASS_PROPERTY",
			false,
		);
		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"NON_ARROW_FUNCTION",
		);
		parser.state.yieldPos = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;
		parser.state.awaitPos = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;

		if (!isStatement) {
			id = ___R$$priv$project$rome$$internal$js$parser$parser$statement_ts$parseFunctionId(
				parser,
				false,
			);
		}

		const headStart = parser.getPosition();
		const {params, rest, typeParameters} = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseFunctionParams(
			parser,
		);
		const {head, body} = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseFunctionBodyAndFinish(
			parser,
			{
				allowBodiless: isStatement,
				id,
				params,
				rest,
				isArrowFunction: false,
				isMethod: false,
				isAsync,
				isGenerator,
				headStart,
				start,
			},
		);

		parser.state.yieldPos = oldYieldPos;
		parser.state.awaitPos = oldAwaitPos;

		___R$project$rome$$internal$js$parser$parser_ts$popScope(
			parser,
			"NON_ARROW_FUNCTION",
		);
		___R$project$rome$$internal$js$parser$parser_ts$popScope(parser, "FUNCTION");
		___R$project$rome$$internal$js$parser$parser_ts$popScope(
			parser,
			"FUNCTION_LOC",
		);
		___R$project$rome$$internal$js$parser$parser_ts$popScope(
			parser,
			"CLASS_PROPERTY",
		);
		___R$project$rome$$internal$js$parser$parser_ts$popScope(parser, "METHOD");
		___R$project$rome$$internal$js$parser$parser_ts$popScope(
			parser,
			"GENERATOR",
		);
		___R$project$rome$$internal$js$parser$parser_ts$popScope(parser, "ASYNC");

		if (body !== undefined && body.type !== "JSBlockStatement") {
			throw new Error("Expected block statement for functions");
		}

		return {
			head: Object.assign({}, head, {typeParameters}),
			body,
			id,
			loc: parser.finishLoc(start),
		};
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$splitFunctionParams(
		params,
	) {
		const firstParam = params[0];
		if (
			firstParam !== undefined &&
			firstParam.type === "JSBindingIdentifier" &&
			firstParam.name === "this"
		) {
			return {
				thisType: firstParam,
				params: params.slice(1),
			};
		} else {
			return {
				thisType: undefined,
				params,
			};
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$statement_ts$parseFunctionParams(
		parser,
		kind,
		allowTSModifiers,
	) {
		let typeParameters = undefined;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$isRelational(parser, "<")
		) {
			typeParameters = ___R$project$rome$$internal$js$parser$parser$typescript_ts$maybeParseTSTypeParameters(
				parser,
			);

			if (typeParameters !== undefined && (kind === "get" || kind === "set")) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						loc: typeParameters.loc,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.ACCESSOR_WITH_TYPE_PARAMS,
					},
				);
			}
		}

		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"PARAMETERS",
			true,
		);

		const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR,
			"function params",
		);
		const {list: params, rest} = ___R$project$rome$$internal$js$parser$parser$lval_ts$parseBindingListNonEmpty(
			parser,
			openContext,
			allowTSModifiers,
		);

		___R$project$rome$$internal$js$parser$parser_ts$popScope(
			parser,
			"PARAMETERS",
		);
		___R$project$rome$$internal$js$parser$parser$expression_ts$checkYieldAwaitInDefaultParams(
			parser,
		);
		return {params, rest, typeParameters};
	}


  // project-rome/@internal/codec-js-regexp/index.ts
function ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$isHex(str) {
		return !/[^0-9a-fA-F]/.test(str);
	}

	function ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$isOct(str) {
		const OCT_REGEX = /^[0-7]+$/;
		return OCT_REGEX.test(str);
	}

	function ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$getCodePoint(
		char,
	) {
		if (char.length === 1) {
			const point = char.codePointAt(0);
			if (point !== undefined) {
				return point;
			}
		}

		throw new Error("Input was not 1 character long");
	}

	function ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$readOctalCode(
		input,
		index,
		nextChar,
	) {
		let char = nextChar;
		let octal = "";
		let nextIndex = ___R$project$rome$$internal$ob1$index_ts$ob1Add(index, 1);
		while (___R$project$rome$$internal$parser$core$utils_ts$isDigit(char)) {
			octal += char;
			// stop at max octal ascii in case of octal escape
			if (parseInt(octal) > 377) {
				octal = octal.slice(0, octal.length - 1);
				break;
			}
			nextIndex = ___R$project$rome$$internal$ob1$index_ts$ob1Add(nextIndex, 1);
			char = input[___R$project$rome$$internal$ob1$index_ts$ob1Get0(nextIndex)];
		}
		if (octal === "") {
			return {octalValue: undefined, end: nextIndex};
		}
		const octalValue = parseInt(octal, 10);
		return {octalValue, end: nextIndex};
	}

	const ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$createRegExpParser = ___R$project$rome$$internal$parser$core$utils_ts$createParser({
		diagnosticCategory: "parse/regex",

		tokenize(parser, index) {
			const char = parser.getInputCharOnly(index);

			if (char === "\\") {
				let end = ___R$project$rome$$internal$ob1$index_ts$ob1Add(index, 2);

				const nextChar = parser.getInputCharOnly(index, 1);
				switch (nextChar) {
					case "t":
						return parser.finishComplexToken(
							"Character",
							{
								escaped: false,
								value: "\t",
							},
							end,
						);

					case "n":
						return parser.finishComplexToken(
							"Character",
							{
								escaped: false,
								value: "\n",
							},
							end,
						);

					case "r":
						return parser.finishComplexToken(
							"Character",
							{
								escaped: false,
								value: "\r",
							},
							end,
						);

					case "v":
						return parser.finishComplexToken(
							"Character",
							{
								escaped: false,
								value: "\x0b",
							},
							end,
						);

					case "f":
						return parser.finishComplexToken(
							"Character",
							{
								escaped: false,
								value: "\f",
							},
							end,
						);

					case "d":
					case "D":
					case "b":
					case "B":
					case "s":
					case "S":
					case "w":
					case "W":
						return parser.finishValueToken("EscapedCharacter", nextChar, end);

					case "k": {
						if (parser.options.unicode) {
							// named group back reference https://github.com/tc39/proposal-regexp-named-groups#backreferences
							let value = "";
							let [char, next] = parser.getInputChar(index, 2);

							if (char === "<") {
								while (!parser.isEOF(next)) {
									value += char;
									[char, next] = parser.getInputChar(index, 1);

									if (char === ">") {
										break;
									}
								}

								return parser.finishComplexToken(
									"NamedBackReferenceCharacter",
									{
										value,
										escaped: true,
									},
									index,
								);
							}
						}

						return parser.finishComplexToken(
							"Character",
							{
								value: "k",
								escaped: true,
							},
							end,
						);
					}

					case "p": {
						if (parser.options.unicode) {
							// TODO unicode property escapes https://github.com/tc39/proposal-regexp-unicode-property-escapes
						}

						return parser.finishComplexToken(
							"Character",
							{
								value: "p",
								escaped: true,
							},
							end,
						);
					}

					case "P": {
						if (parser.options.unicode) {
							// TODO unicode property escapes https://github.com/tc39/proposal-regexp-unicode-property-escapes
						}

						return parser.finishComplexToken(
							"Character",
							{
								value: "P",
								escaped: true,
							},
							end,
						);
					}

					case "c":
						// TODO???
						return parser.finishComplexToken(
							"Character",
							{
								value: "c",
								escaped: true,
							},
							end,
						);

					case "0": {
						const {octalValue, end: octalEnd} = ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$readOctalCode(
							parser.input,
							index,
							nextChar,
						);
						if (
							octalValue !== undefined &&
							___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$isOct(
								octalValue.toString(),
							)
						) {
							const octal = parseInt(octalValue.toString(), 8);
							return parser.finishComplexToken(
								"Character",
								{
									value: String.fromCharCode(octal),
									escaped: true,
								},
								octalEnd,
							);
						}
						return parser.finishComplexToken(
							"Character",
							{
								value: String.fromCharCode(0),
								escaped: true,
							},
							end,
						);
					}

					case "x": {
						const [possibleHex] = parser.getInputRange(index, 3, 1);

						// \xhh
						if (
							possibleHex.length === 2 &&
							___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$isHex(
								possibleHex,
							)
						) {
							end = ___R$project$rome$$internal$ob1$index_ts$ob1Add(end, 2);

							return parser.finishComplexToken(
								"Character",
								{
									value: String.fromCharCode(parseInt(possibleHex, 16)),
									escaped: true,
								},
								end,
							);
						}

						return parser.finishComplexToken(
							"Character",
							{
								value: "x",
								escaped: true,
							},
							end,
						);
					}

					case "u": {
						// Get the next 4 characters after \u
						const [possibleHex] = parser.getInputRange(index, 4, 2);

						// \uhhhh
						if (
							possibleHex.length === 4 &&
							___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$isHex(
								possibleHex,
							)
						) {
							end = ___R$project$rome$$internal$ob1$index_ts$ob1Add(end, 4);

							return parser.finishComplexToken(
								"Character",
								{
									value: String.fromCharCode(parseInt(possibleHex, 16)),
									escaped: true,
								},
								end,
							);
						}

						if (parser.options.unicode) {
							// TODO \u{hhhh} or \u{hhhhh}
						}

						return parser.finishComplexToken(
							"Character",
							{
								value: "u",
								escaped: true,
							},
							end,
						);
					}

					// Redundant escaping
					default: {
						let {
							octalValue: referenceValue,
							end: referenceEnd,
						} = ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$readOctalCode(
							parser.input,
							index,
							nextChar,
						);
						if (referenceValue !== undefined) {
							let backReference = referenceValue.toString();
							// \8 \9 are treated as escape char
							if (referenceValue === 8 || referenceValue === 9) {
								return parser.finishComplexToken(
									"Character",
									{
										value: backReference,
										escaped: true,
									},
									referenceEnd,
								);
							}

							if (
								___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$isOct(
									backReference,
								)
							) {
								const octal = parseInt(backReference, 8);
								return parser.finishComplexToken(
									"Character",
									{
										value: String.fromCharCode(octal),
										escaped: true,
									},
									referenceEnd,
								);
							}

							// back reference allowed are 1 - 99
							if (referenceValue >= 1 && referenceValue <= 99) {
								return parser.finishComplexToken(
									"NumericBackReferenceCharacter",
									{
										value: parseInt(backReference, 10),
										escaped: true,
									},
									referenceEnd,
								);
							} else {
								backReference = backReference.slice(0, backReference.length - 1);
								referenceEnd = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
									referenceEnd,
									-1,
								);
								if (
									___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$isOct(
										backReference,
									)
								) {
									return parser.finishComplexToken(
										"Character",
										{
											value: String.fromCharCode(parseInt(backReference, 8)),
											escaped: true,
										},
										referenceEnd,
									);
								} else {
									return parser.finishComplexToken(
										"NumericBackReferenceCharacter",
										{
											value: parseInt(backReference, 10),
											escaped: true,
										},
										referenceEnd,
									);
								}
							}
						}

						return parser.finishComplexToken(
							"Character",
							{
								value: nextChar,
								escaped: true,
							},
							end,
						);
					}
				}
			}

			switch (char) {
				case "$":
				case "^":
				case ".":
				case "?":
				case "{":
				case "}":
				case "+":
				case "|":
				case "*":
				case "[":
				case "]":
				case "(":
				case ")":
					return parser.finishValueToken("Operator", char);
			}

			return parser.finishComplexToken(
				"Character",
				{
					value: char,
					escaped: false,
				},
			);
		},
	});

	function ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$getGroupModifiers(
		parser,
	) {
		const token = parser.getToken();

		if (token.type === "Character") {
			switch (token.value) {
				case ":": {
					parser.nextToken();
					return {
						type: "NON_CAPTURE",
						kind: undefined,
					};
				}

				case "=": {
					parser.nextToken();
					return {
						type: "NON_CAPTURE",
						kind: "positive-lookahead",
					};
				}

				case "!": {
					parser.nextToken();
					return {
						type: "NON_CAPTURE",
						kind: "negative-lookahead",
					};
				}

				case "<": {
					const nextToken = parser.lookaheadToken();

					if (nextToken.type === "Character") {
						switch (nextToken.value) {
							case "!": {
								parser.nextToken();
								parser.nextToken();
								return {
									type: "NON_CAPTURE",
									kind: "negative-lookbehind",
								};
							}

							case "=": {
								parser.nextToken();
								parser.nextToken();
								return {
									type: "NON_CAPTURE",
									kind: "positive-lookbehind",
								};
							}
						}

						if (
							___R$project$rome$$internal$parser$core$utils_ts$isESIdentifierStart(
								nextToken.value,
							)
						) {
							let name = "";

							// 1 is for the <
							let skipCount = 1;
							let targetToken = nextToken;
							while (
								targetToken.type === "Character" &&
								___R$project$rome$$internal$parser$core$utils_ts$isESIdentifierChar(
									targetToken.value,
								)
							) {
								name += targetToken.value;
								targetToken = parser.lookaheadToken(targetToken.end);
								skipCount++;
							}

							if (targetToken.type === "Character" && targetToken.value === ">") {
								// Skip through all the name tokens including >
								skipCount++;

								// This is kinda a hacky solution, and slower than it could be
								for (let i = 0; i < skipCount; i++) {
									parser.nextToken();
								}

								return {
									type: "NAMED_CAPTURE",
									name,
								};
							}
						}
					}
				}
			}
		}

		parser.unexpectedDiagnostic({
			description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.REGEX_PARSER.INVALID_CAPTURE_GROUP_MODIFIER,
			token,
		});

		return undefined;
	}

	function ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$matchOperator(
		parser,
		op,
	) {
		const token = parser.getToken();
		return token.type === "Operator" && token.value === op;
	}

	function ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$eatOperator(
		parser,
		op,
	) {
		if (
			___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$matchOperator(
				parser,
				op,
			)
		) {
			parser.nextToken();
			return true;
		} else {
			return false;
		}
	}

	function ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseGroupCapture(
		parser,
	) {
		const start = parser.getPosition();
		parser.nextToken();

		let modifiers;
		if (
			___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$eatOperator(
				parser,
				"?",
			)
		) {
			modifiers = ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$getGroupModifiers(
				parser,
			);
		}

		const expression = ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseExpression(
			parser,
			() =>
				!___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$matchOperator(
					parser,
					")",
				)
			,
		);

		if (
			!___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$eatOperator(
				parser,
				")",
			)
		) {
			parser.unexpectedDiagnostic({
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.REGEX_PARSER.UNCLOSED_GROUP,
				start,
			});
		}

		if (modifiers !== undefined && modifiers.type === "NON_CAPTURE") {
			return {
				type: "JSRegExpGroupNonCapture",
				expression,
				kind: modifiers.kind,
				loc: parser.finishLoc(start),
			};
		} else {
			let name = modifiers !== undefined ? modifiers.name : undefined;
			return {
				type: "JSRegExpGroupCapture",
				expression,
				name,
				loc: parser.finishLoc(start),
			};
		}
	}

	function ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseCharSet(
		parser,
	) {
		const start = parser.getPosition();
		parser.nextToken();

		const body = [];
		const invert = ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$eatOperator(
			parser,
			"^",
		);

		while (
			!parser.matchToken("EOF") &&
			!___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$matchOperator(
				parser,
				"]",
			)
		) {
			const part = ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseCharacterOrRange(
				parser,
			);
			body.push(part);
		}

		if (
			!___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$eatOperator(
				parser,
				"]",
			)
		) {
			parser.unexpectedDiagnostic({
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.REGEX_PARSER.UNCLOSED_CHAR_SET,
				start,
			});
		}

		return {
			type: "JSRegExpCharSet",
			invert,
			body,
			loc: parser.finishLoc(start),
		};
	}

	function ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$getCharacterFromToken(
		parser,
		token,
	) {
		switch (token.type) {
			case "Character":
			case "Operator":
				return token.value;

			case "SOF":
			case "EOF":
			case "Invalid":
				throw new Error("Unnecessary");

			default:
				throw new Error("Never");
		}
	}

	function ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseCharacter(
		parser,
	) {
		const token = parser.getToken();

		if (token.type === "Character") {
			parser.nextToken();
			return {
				type: "JSRegExpCharacter",
				value: token.value,
				loc: parser.finishLocFromToken(token),
			};
		}

		if (token.type === "NumericBackReferenceCharacter") {
			parser.nextToken();

			return {
				type: "JSRegExpNumericBackReference",
				value: token.value,
				loc: parser.finishLocFromToken(token),
			};
		}

		if (token.type === "NamedBackReferenceCharacter") {
			const start = parser.input.slice(
				0,
				___R$project$rome$$internal$ob1$index_ts$ob1Get0(token.start),
			);
			parser.nextToken();

			if (token.value[token.value.length - 1] !== ">") {
				parser.unexpectedDiagnostic({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.REGEX_PARSER.UNCLOSED_NAMED_CAPTURE,
					loc: parser.finishLocFromToken(token),
				});
			}

			if (!start.includes(token.value)) {
				parser.unexpectedDiagnostic({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.REGEX_PARSER.INVALID_NAMED_CAPTURE,
					loc: parser.finishLocFromToken(token),
				});
			}

			const name = token.value.slice(1, token.value.length - 1);
			return {
				type: "JSRegExpNamedBackReference",
				name,
				loc: parser.finishLocFromToken(token),
			};
		}

		if (token.type === "EscapedCharacter") {
			parser.nextToken();

			const loc = parser.finishLocFromToken(token);
			switch (token.value) {
				case "d":
					return {
						type: "JSRegExpDigitCharacter",
						loc,
					};

				case "D":
					return {
						type: "JSRegExpNonDigitCharacter",
						loc,
					};

				case "b":
					return {
						type: "JSRegExpWordBoundaryCharacter",
						loc,
					};

				case "B":
					return {
						type: "JSRegExpNonWordBoundaryCharacter",
						loc,
					};

				case "s":
					return {
						type: "JSRegExpWhiteSpaceCharacter",
						loc,
					};

				case "S":
					return {
						type: "JSRegExpNonWhiteSpaceCharacter",
						loc,
					};

				case "w":
					return {
						type: "JSRegExpWordCharacter",
						loc,
					};

				case "W":
					return {
						type: "JSRegExpNonWordCharacter",
						loc,
					};
			}
		}

		parser.nextToken();
		return {
			type: "JSRegExpCharacter",
			value: ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$getCharacterFromToken(
				parser,
				token,
			),
			loc: parser.finishLocFromToken(token),
		};
	}

	function ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseCharacterOrRange(
		parser,
	) {
		const startPos = parser.getPosition();
		let start = ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseCharacter(
			parser,
		);

		// Range
		const nextToken = parser.getToken();
		if (
			start.type === "JSRegExpCharacter" &&
			nextToken.type === "Character" &&
			nextToken.value === "-" &&
			!nextToken.escaped
		) {
			const lookaheadToken = parser.lookaheadToken();
			if (lookaheadToken.type === "Character") {
				// Skip dash
				parser.nextToken();

				let end = ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseCharacter(
					parser,
				);

				const loc = parser.finishLoc(startPos);

				if (
					start.type === "JSRegExpCharacter" &&
					end.type === "JSRegExpCharacter" &&
					___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$getCodePoint(
						end.value,
					) <
					___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$getCodePoint(
						start.value,
					)
				) {
					parser.unexpectedDiagnostic({
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.REGEX_PARSER.REVERSED_CHAR_SET_RANGE,
						loc,
					});
					const _end = end;
					end = start;
					start = _end;
				}

				return {
					type: "JSRegExpCharSetRange",
					loc,
					start,
					end,
				};
			}
		}

		return start;
	}

	function ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseDigits(
		parser,
	) {
		let digits = "";
		let token = parser.getToken();
		while (
			token.type === "Character" &&
			___R$project$rome$$internal$parser$core$utils_ts$isDigit(token.value)
		) {
			digits += token.value;
			token = parser.nextToken();
		}

		if (digits.length === 0) {
			return undefined;
		} else {
			return Number(digits);
		}
	}

	function ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseQuantifier(
		parser,
	) {
		if (
			___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$eatOperator(
				parser,
				"?",
			)
		) {
			return {
				min: 0,
				max: 1,
			};
		}

		if (
			___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$eatOperator(
				parser,
				"*",
			)
		) {
			return {
				min: 0,
				max: undefined,
			};
		}

		if (
			___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$eatOperator(
				parser,
				"+",
			)
		) {
			return {
				min: 1,
				max: undefined,
			};
		}

		if (
			___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$matchOperator(
				parser,
				"{",
			)
		) {
			const snapshot = parser.save();

			parser.nextToken();

			const start = parser.getPosition();
			const min = ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseDigits(
				parser,
			);

			if (min !== undefined) {
				const nextToken = parser.getToken();
				if (nextToken.type === "Character" && nextToken.value === ",") {
					parser.nextToken();

					const max = ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseDigits(
						parser,
					);
					const end = parser.getPosition();

					const endToken = parser.getToken();
					if (endToken.type === "Operator" && endToken.value === "}") {
						parser.nextToken();

						if (max !== undefined && min > max) {
							parser.unexpectedDiagnostic({
								description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.REGEX_PARSER.REVERSED_QUANTIFIER_RANGE,
								start,
								end,
							});
							return {
								max: min,
								min: max,
							};
						}

						return {
							min,
							max,
						};
					}
				} else if (nextToken.type === "Operator" && nextToken.value === "}") {
					parser.nextToken();
					return {
						min,
						max: min,
					};
				}
			}

			parser.restore(snapshot);
		}

		return undefined;
	}

	function ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseBodyItem(
		parser,
	) {
		const start = parser.getPosition();

		const prefix = ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseBodyItemPrefix(
			parser,
		);
		if (prefix === undefined) {
			return undefined;
		}

		let target = prefix;

		while (true) {
			const quantifier = ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseQuantifier(
				parser,
			);
			if (quantifier === undefined) {
				break;
			}

			const lazy = ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$eatOperator(
				parser,
				"?",
			);

			const quantified = Object.assign(
				{type: "JSRegExpQuantified", loc: parser.finishLoc(start), target, lazy},
				quantifier,
			);

			target = quantified;
		}

		return target;
	}

	function ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseOperator(
		parser,
		token,
	) {
		switch (token.value) {
			case "$": {
				parser.nextToken();
				return {
					type: "JSRegExpEndCharacter",
					loc: parser.finishLocFromToken(token),
				};
			}

			case "^": {
				parser.nextToken();
				return {
					type: "JSRegExpStartCharacter",
					loc: parser.finishLocFromToken(token),
				};
			}

			case ".": {
				parser.nextToken();
				return {
					type: "JSRegExpAnyCharacter",
					loc: parser.finishLocFromToken(token),
				};
			}

			case "[":
				return ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseCharSet(
					parser,
				);

			case "(":
				return ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseGroupCapture(
					parser,
				);

			case ")": {
				parser.nextToken();
				parser.unexpectedDiagnostic({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.REGEX_PARSER.UNOPENED_GROUP,
					token,
				});
				return;
			}

			case "{": {
				const start = parser.getPosition();
				const unmatchedQuantifier = ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseQuantifier(
					parser,
				);
				if (unmatchedQuantifier === undefined) {
					// Quantifier is undefined and eaten tokens were restored
					// Return a '{' token as a RegexpCharacter, parseBodyItem() will handle parsing of subsequent quantifiers
					return ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseCharacter(
						parser,
					);
				} else {
					// If quantifier is defined, then syntax error: Nothing to repeat
					const end = parser.getPosition();
					parser.unexpectedDiagnostic({
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.REGEX_PARSER.NO_TARGET_QUANTIFIER,
						start,
						end,
					});
					return;
				}
			}

			case "?":
			case "*":
			case "+": {
				parser.nextToken();
				parser.unexpectedDiagnostic({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.REGEX_PARSER.INVALID_QUANTIFIER_TARGET,
					token,
				});
				return;
			}

			case "]":
			case "}":
				return ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseCharacter(
					parser,
				);

			default:
				return undefined;
		}
	}

	function ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseBodyItemPrefix(
		parser,
	) {
		const token = parser.getToken();

		switch (token.type) {
			case "Operator":
				return ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseOperator(
					parser,
					token,
				);

			case "EscapedCharacter":
			case "Character":
			case "NumericBackReferenceCharacter":
			case "NamedBackReferenceCharacter":
				return ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseCharacter(
					parser,
				);
		}

		parser.unexpectedDiagnostic({
			description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.REGEX_PARSER.UNKNOWN_REGEX_PART,
			token,
		});

		return undefined;
	}

	function ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseExpression(
		parser,
		whileCallback,
	) {
		const alternations = [];
		let body = [];

		const start = parser.getPosition();
		let alternateStart = start;

		while (
			!parser.matchToken("EOF") &&
			(whileCallback === undefined || whileCallback())
		) {
			if (
				___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$eatOperator(
					parser,
					"|",
				)
			) {
				alternations.push({
					start: alternateStart,
					end: parser.getPosition(),
					body,
				});
				alternateStart = parser.getPosition();
				body = [];
				continue;
			}

			const part = ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseBodyItem(
				parser,
			);
			if (part !== undefined) {
				body.push(part);
			}
		}

		alternations.push({
			body,
			start: alternateStart,
			end: parser.getPosition(),
		});

		let expression;

		while (alternations.length > 0) {
			const alternation = alternations.shift();

			const sub = {
				type: "JSRegExpSubExpression",
				body: alternation.body,
				loc: parser.finishLocAt(alternation.start, alternation.end),
			};

			if (expression === undefined) {
				expression = sub;
			} else {
				const alternationNode = {
					type: "JSRegExpAlternation",
					left: expression,
					right: sub,
					loc: parser.finishLocAt(
						parser.getLoc(expression).start,
						alternation.end,
					),
				};

				expression = alternationNode;
			}
		}

		if (expression === undefined) {
			throw new Error(
				"Impossible. We should always have at least one alternation that will set parser.",
			);
		}

		return expression;
	}

	function ___R$project$rome$$internal$codec$js$regexp$index_ts$parseRegExp(
		opts,
	) {
		const parser = ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$createRegExpParser(
			opts,
		);
		return {
			expression: ___R$$priv$project$rome$$internal$codec$js$regexp$index_ts$parseExpression(
				parser,
			),
			diagnostics: parser.getDiagnostics(),
		};
	}


  // project-rome/@internal/js-parser/parser/expression.ts
const ___R$project$rome$$internal$js$parser$parser$expression_ts = {
		checkPropClash: ___R$project$rome$$internal$js$parser$parser$expression_ts$checkPropClash,
		parseExpression: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpression,
		parseMaybeAssign: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeAssign,
		parseMaybeConditional: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeConditional,
		tryParseConditionalConsequent: ___R$project$rome$$internal$js$parser$parser$expression_ts$tryParseConditionalConsequent,
		parseConditional: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseConditional,
		forwardNoArrowParamsConversionAt: ___R$project$rome$$internal$js$parser$parser$expression_ts$forwardNoArrowParamsConversionAt,
		parseExpressionOps: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionOps,
		parseExpressionOp: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionOp,
		parseMaybeUnary: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeUnary,
		parseExpressionWithPossibleSubscripts: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionWithPossibleSubscripts,
		parseSubscripts: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseSubscripts,
		parseAsyncArrowWithTypeParameters: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseAsyncArrowWithTypeParameters,
		parseExpressionSubscript: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionSubscript,
		parseTaggedTemplateExpression: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseTaggedTemplateExpression,
		checkYieldAwaitInDefaultParams: ___R$project$rome$$internal$js$parser$parser$expression_ts$checkYieldAwaitInDefaultParams,
		atPossibleAsync: ___R$project$rome$$internal$js$parser$parser$expression_ts$atPossibleAsync,
		parseCallExpressionArguments: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseCallExpressionArguments,
		shouldParseAsyncArrow: ___R$project$rome$$internal$js$parser$parser$expression_ts$shouldParseAsyncArrow,
		parseAsyncArrowFromCallExpression: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseAsyncArrowFromCallExpression,
		parseNoCallExpr: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseNoCallExpr,
		parseExpressionAtom: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionAtom,
		parseBooleanLiteral: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseBooleanLiteral,
		parseMaybePrivateName: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybePrivateName,
		parseFunctionExpressionOrMetaProperty: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseFunctionExpressionOrMetaProperty,
		parseMetaProperty: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMetaProperty,
		parseImportMetaProperty: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseImportMetaProperty,
		parseParenExpression: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseParenExpression,
		parseParenAndDistinguishExpression: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseParenAndDistinguishExpression,
		shouldParseArrow: ___R$project$rome$$internal$js$parser$parser$expression_ts$shouldParseArrow,
		parseArrowHead: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseArrowHead,
		parseParenItem: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseParenItem,
		parseNew: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseNew,
		parseTemplateElement: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseTemplateElement,
		parseTemplate: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseTemplate,
		parseObjectExpression: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseObjectExpression,
		parseObjectPattern: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseObjectPattern,
		isGetterOrSetterMethod: ___R$project$rome$$internal$js$parser$parser$expression_ts$isGetterOrSetterMethod,
		checkGetterSetterParamCount: ___R$project$rome$$internal$js$parser$parser$expression_ts$checkGetterSetterParamCount,
		parseObjectMethod: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseObjectMethod,
		parseObjectProperty: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseObjectProperty,
		parseObjectPropertyValue: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseObjectPropertyValue,
		parseObjectPropertyKey: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseObjectPropertyKey,
		parseMethod: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMethod,
		parseArrowExpression: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseArrowExpression,
		isStrictBody: ___R$project$rome$$internal$js$parser$parser$expression_ts$isStrictBody,
		parseFunctionBodyAndFinish: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseFunctionBodyAndFinish,
		parseFunctionBody: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseFunctionBody,
		checkFunctionNameAndParams: ___R$project$rome$$internal$js$parser$parser$expression_ts$checkFunctionNameAndParams,
		parseExpressionList: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionList,
		parseExpressionListNonEmpty: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionListNonEmpty,
		parseCallArgument: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseCallArgument,
		parseIdentifier: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier,
		parseBindingIdentifier: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseBindingIdentifier,
		parseReferenceIdentifier: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseReferenceIdentifier,
		parseTSConstKeyword: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseTSConstKeyword,
		toTSConstKeyword: ___R$project$rome$$internal$js$parser$parser$expression_ts$toTSConstKeyword,
		toBindingIdentifier: ___R$project$rome$$internal$js$parser$parser$expression_ts$toBindingIdentifier,
		toAssignmentIdentifier: ___R$project$rome$$internal$js$parser$parser$expression_ts$toAssignmentIdentifier,
		toReferenceIdentifier: ___R$project$rome$$internal$js$parser$parser$expression_ts$toReferenceIdentifier,
		toIdentifier: ___R$project$rome$$internal$js$parser$parser$expression_ts$toIdentifier,
		createIdentifier: ___R$project$rome$$internal$js$parser$parser$expression_ts$createIdentifier,
		parseIdentifierName: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifierName,
		checkReservedWord: ___R$project$rome$$internal$js$parser$parser$expression_ts$checkReservedWord,
		parseAwait: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseAwait,
		parseYield: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseYield,
		parseStringLiteral: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseStringLiteral,
		parseNumericLiteral: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseNumericLiteral,
		parseArrayHole: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseArrayHole,
	};
	function ___R$project$rome$$internal$js$parser$parser$expression_ts$checkPropClash(
		parser,
		prop,
		props,
	) {
		if (
			prop.key.type === "JSComputedPropertyKey" ||
			prop.type === "JSObjectMethod"
		) {
			return undefined;
		}

		const key = prop.key.value;

		// We can only check these for collisions since they're statically known
		if (
			key.type !== "JSIdentifier" &&
			key.type !== "JSStringLiteral" &&
			key.type !== "JSNumericLiteral"
		) {
			return;
		}

		// It is either an JSIdentifier or a String/NumericLiteral
		const name = key.type === "JSIdentifier" ? key.name : String(key.value);

		if (name === "__proto__") {
			if (props.has("proto")) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.PROTO_PROP_REDEFINITION,
						loc: key.loc,
					},
				);
			} else {
				props.add("proto");
			}
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpression(
		parser,
		context,
		noIn,
		refShorthandDefaultPos,
	) {
		const startPos = parser.state.startPos;
		const expr = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeAssign(
			parser,
			context,
			noIn,
			refShorthandDefaultPos,
		);
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
			)
		) {
			let expressions = [expr];
			while (
				___R$project$rome$$internal$js$parser$parser_ts$eat(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
				)
			) {
				expressions.push(
					___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeAssign(
						parser,
						context,
						noIn,
						refShorthandDefaultPos,
					),
				);
			}

			expressions = ___R$project$rome$$internal$js$parser$parser$lval_ts$filterSpread(
				parser,
				___R$project$rome$$internal$js$parser$parser$lval_ts$toReferencedList(
					parser,
					expressions,
				),
			);

			return parser.finishNode(
				startPos,
				{
					type: "JSSequenceExpression",
					expressions,
				},
			);
		}
		return expr;
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeAssign(
		parser,
		context,
		noIn,
		refShorthandDefaultPos,
		afterLeftParse,
		refNeedsArrowPos,
	) {
		const branches = ___R$project$rome$$internal$js$parser$parser_ts$createBranch(
			parser,
		);

		// Try parsing as JSX
		if (
			(___R$project$rome$$internal$js$parser$parser_ts$isRelational(parser, "<") ||
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.jsxTagStart,
			)) &&
			___R$project$rome$$internal$js$parser$parser_ts$shouldTokenizeJSX(parser)
		) {
			branches.add(
				() => {
					return ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$_parseMaybeAssign(
						parser,
						context,
						noIn,
						refShorthandDefaultPos,
						afterLeftParse,
						refNeedsArrowPos,
					);
				},
				{diagnosticsPriority: 1},
			);

			// Remove `tc.j_expr` and `tc.j_oTag` from 'context added
			// by parsing `jsxTagStart` to stop the JSX plugin from
			// messing with the tokens
			const cLength = parser.state.context.length;
			if (
				parser.state.context[cLength - 1] ===
				___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.jsxOpenTag
			) {
				parser.state.context.length -= 2;
			}
			___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.relational,
				"<",
			);
		}

		// Try parsing as an arrow function with type parameters
		if (
			___R$project$rome$$internal$js$parser$parser_ts$isRelational(parser, "<")
		) {
			branches.add(() => {
				const start = parser.getPosition();
				const typeParameters = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeParameters(
					parser,
				);
				const possibleArrow = ___R$project$rome$$internal$js$parser$parser$expression_ts$forwardNoArrowParamsConversionAt(
					parser,
					start,
					() =>
						___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$_parseMaybeAssign(
							parser,
							context,
							noIn,
							refShorthandDefaultPos,
							afterLeftParse,
							refNeedsArrowPos,
						)
					,
				);
				___R$project$rome$$internal$js$parser$parser_ts$resetStartLocationFromNode(
					parser,
					possibleArrow,
					typeParameters,
				);

				if (possibleArrow.type === "JSArrowFunctionExpression") {
					// `as` cast for reasons... `possibleArrow` is `T | JSArrowFunctionExpression`
					const arrow = (possibleArrow);
					return Object.assign(
						{},
						arrow,
						{head: Object.assign({}, arrow.head, {typeParameters})},
					);
				} else {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							loc: typeParameters.loc,
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.EXPECTED_ARROW_AFTER_TYPE_PARAMS,
						},
					);
					return ___R$project$rome$$internal$js$parser$parser$expression_ts$toReferenceIdentifier(
						parser,
						___R$project$rome$$internal$js$parser$parser_ts$createUnknownIdentifier(
							parser,
							"type params without arrow function",
						),
					);
				}
			});
		}

		if (branches.hasOptimalBranch()) {
			return branches.pick();
		}

		return ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$_parseMaybeAssign(
			parser,
			context,
			noIn,
			refShorthandDefaultPos,
			afterLeftParse,
			refNeedsArrowPos,
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$_parseMaybeAssign(
		parser,
		context,
		noIn,
		refShorthandDefaultPos,
		afterLeftParse,
		refNeedsArrowPos,
	) {
		const startPos = parser.state.startPos;

		if (
			___R$project$rome$$internal$js$parser$parser_ts$isContextual(
				parser,
				"yield",
			)
		) {
			if (
				___R$project$rome$$internal$js$parser$parser_ts$inScope(
					parser,
					"GENERATOR",
				)
			) {
				let left = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseYield(
					parser,
					noIn,
				);
				if (afterLeftParse) {
					left = afterLeftParse(parser, left, startPos);
				}
				return left;
			} else {
				// The tokenizer will assume an expression is allowed after
				// `yield`, but this isn't that kind of yield
				parser.state.exprAllowed = false;
			}
		}

		const oldCommaAfterSpreadAt = parser.state.commaAfterSpreadAt;
		parser.state.commaAfterSpreadAt = ___R$project$rome$$internal$ob1$index_ts$ob1Number0Neg1;

		let failOnShorthandAssign;
		if (refShorthandDefaultPos) {
			failOnShorthandAssign = false;
		} else {
			refShorthandDefaultPos = ___R$project$rome$$internal$js$parser$utils$location_ts$createIndexTracker();
			failOnShorthandAssign = true;
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
			) ||
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name,
			)
		) {
			parser.state.potentialArrowAt = parser.getIndex();
		}

		let left = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeConditional(
			parser,
			context,
			noIn,
			refShorthandDefaultPos,
			refNeedsArrowPos,
		);
		if (afterLeftParse) {
			left = afterLeftParse(parser, left, startPos);
		}

		if (parser.state.tokenType.isAssign) {
			const operator = (String(parser.state.tokenValue));
			const leftPatt = ___R$project$rome$$internal$js$parser$parser$lval_ts$toAssignmentPattern(
				parser,
				left,
				"assignment expression",
			);

			// reset because shorthand default was used correctly
			refShorthandDefaultPos.index = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;

			___R$project$rome$$internal$js$parser$parser$lval_ts$checkLVal(
				parser,
				leftPatt,
				undefined,
				undefined,
				"assignment expression",
			);

			// We should never get patterns here...?

			//if (left.type === 'BindingArrayPattern' || left.type === 'BindingObjectPattern') {
			//  checkCommaAfterRestFromSpread(parser);

			//}
			parser.state.commaAfterSpreadAt = oldCommaAfterSpreadAt;

			___R$project$rome$$internal$js$parser$parser_ts$next(parser);
			const right = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeAssign(
				parser,
				"assignment right",
				noIn,
			);
			return parser.finishNode(
				startPos,
				{
					type: "JSAssignmentExpression",
					operator,
					left: leftPatt,
					right,
				},
			);
		} else if (
			failOnShorthandAssign &&
			___R$project$rome$$internal$ob1$index_ts$ob1Get0(
				refShorthandDefaultPos.index,
			) > 0
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedToken(
				parser,
				parser.getPositionFromIndex(refShorthandDefaultPos.index),
			);
		}

		parser.state.commaAfterSpreadAt = oldCommaAfterSpreadAt;

		return left;
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeConditional(
		parser,
		context,
		noIn,
		refShorthandDefaultPos,
		refNeedsArrowPos,
	) {
		const startPos = parser.state.startPos;
		const potentialArrowAt = parser.state.potentialArrowAt;
		const expr = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionOps(
			parser,
			context,
			noIn,
			refShorthandDefaultPos,
		);

		if (
			expr.type === "JSArrowFunctionExpression" &&
			parser.getInputStartIndex(expr) === potentialArrowAt
		) {
			return expr;
		}

		if (
			refShorthandDefaultPos &&
			___R$project$rome$$internal$ob1$index_ts$ob1Get0(
				refShorthandDefaultPos.index,
			) > 0
		) {
			return expr;
		}

		return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseConditional(
			parser,
			expr,
			noIn,
			startPos,
			refNeedsArrowPos,
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$tryParseConditionalConsequent(
		parser,
	) {
		const brancher = ___R$project$rome$$internal$js$parser$parser_ts$createBranch(
			parser,
		);

		brancher.add(() => {
			parser.state.noArrowParamsConversionAt.push(parser.getIndex());
			const consequent = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeAssign(
				parser,
				"conditional consequent",
			);
			parser.state.noArrowParamsConversionAt.pop();
			return {
				consequent,
				failed: !___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
				),
			};
		});

		return brancher.pick();
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseConditional(
		parser,
		expr,
		noIn,
		startPos,
		refNeedsArrowPos,
	) {
		if (
			!___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.question,
			)
		) {
			return expr;
		}

		// This is to handle a case like this: const foo = (foo?: bar) => {};
		// We'll be called due to the `?`, and we should mark ourselves as an
		// expected arrow function if parsing as a regular conditional fails
		if (refNeedsArrowPos) {
			const branch = ___R$project$rome$$internal$js$parser$parser_ts$createBranch(
				parser,
			);

			branch.add(
				() =>
					___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$_parseConditional(
						parser,
						expr,
						noIn,
						startPos,
					)
				,
				{
					maxNewDiagnostics: 0,
				},
			);

			if (branch.hasBranch()) {
				return branch.pick();
			} else {
				refNeedsArrowPos.index = parser.getIndex();
				return expr;
			}
		}

		___R$project$rome$$internal$js$parser$parser_ts$expect(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.question,
		);
		const originalNoArrowAt = parser.state.noArrowAt;
		let {consequent} = ___R$project$rome$$internal$js$parser$parser$expression_ts$tryParseConditionalConsequent(
			parser,
		);
		parser.state.noArrowAt = originalNoArrowAt;

		if (
			!___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.MISSING_CONDITIONAL_SEPARATOR,
				},
			);
		}

		const alternate = ___R$project$rome$$internal$js$parser$parser$expression_ts$forwardNoArrowParamsConversionAt(
			parser,
			startPos,
			() =>
				___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeAssign(
					parser,
					"conditional alternate",
					noIn,
					undefined,
					undefined,
					undefined,
				)
			,
		);

		return parser.finishNode(
			startPos,
			{
				type: "JSConditionalExpression",
				test: expr,
				consequent,
				alternate,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$forwardNoArrowParamsConversionAt(
		parser,
		start,
		parse,
	) {
		if (
			parser.state.noArrowParamsConversionAt.includes(
				parser.getIndexFromPosition(start, parser.filename),
			)
		) {
			let result;
			parser.state.noArrowParamsConversionAt.push(parser.getIndex());
			result = parse();
			parser.state.noArrowParamsConversionAt.pop();
			return result;
		} else {
			return parse();
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$_parseConditional(
		parser,
		expr,
		noIn,
		startPos,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.question,
			)
		) {
			const test = expr;
			const consequent = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeAssign(
				parser,
				"conditional consequent",
			);
			___R$project$rome$$internal$js$parser$parser_ts$expect(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
			);
			const alternate = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeAssign(
				parser,
				"conditional alternate",
				noIn,
			);
			return parser.finishNode(
				startPos,
				{
					type: "JSConditionalExpression",
					test,
					consequent,
					alternate,
				},
			);
		}
		return expr;
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionOps(
		parser,
		context,
		noIn,
		refShorthandDefaultPos,
	) {
		const startPos = parser.state.startPos;
		const potentialArrowAt = parser.state.potentialArrowAt;
		const expr = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeUnary(
			parser,
			context,
			refShorthandDefaultPos,
		);

		if (
			expr.type === "JSArrowFunctionExpression" &&
			parser.getInputStartIndex(expr) === potentialArrowAt
		) {
			return expr;
		}
		if (
			refShorthandDefaultPos &&
			___R$project$rome$$internal$ob1$index_ts$ob1Get0(
				refShorthandDefaultPos.index,
			) > 0
		) {
			return expr;
		}

		return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionOp(
			parser,
			context,
			expr,
			startPos,
			-1,
			noIn,
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionOp(
		parser,
		context,
		left,
		leftStartPos,
		minPrec,
		noIn = false,
	) {
		if (
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._in.getBinop() >
			minPrec &&
			!___R$project$rome$$internal$js$parser$parser_ts$hasPrecedingLineBreak(
				parser,
			) &&
			___R$project$rome$$internal$js$parser$parser_ts$isContextual(parser, "as")
		) {
			const _const = ___R$project$rome$$internal$js$parser$parser$typescript_ts$tryTSNextParseConstantContext(
				parser,
			);

			let typeAnnotation;
			if (_const) {
				___R$project$rome$$internal$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext(
					parser,
					left,
				);
				typeAnnotation = _const;
			} else {
				typeAnnotation = ___R$project$rome$$internal$js$parser$parser$typescript_ts$tsNextThenParseType(
					parser,
				);
			}

			const node = parser.finishNode(
				leftStartPos,
				{
					type: "TSAsExpression",
					typeAnnotation,
					expression: left,
				},
			);

			return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionOp(
				parser,
				context,
				node,
				leftStartPos,
				minPrec,
				noIn,
			);
		}

		const prec = parser.state.tokenType.binop;
		if (
			prec !== undefined &&
			(!noIn ||
			!___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._in,
			))
		) {
			if (prec > minPrec) {
				const operator = (String(parser.state.tokenValue));

				if (
					operator === "**" &&
					left.type === "JSUnaryExpression" &&
					!___R$project$rome$$internal$js$parser$parser_ts$isParenthesized(
						parser,
						left,
					)
				) {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							loc: left.argument.loc,
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.WRAP_EXPONENTIATION,
						},
					);
				}

				const op = parser.state.tokenType;
				___R$project$rome$$internal$js$parser$parser_ts$next(parser);

				const startPos = parser.state.startPos;

				const right = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionOp(
					parser,
					context,
					___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeUnary(
						parser,
						context,
					),
					startPos,
					op.rightAssociative ? prec - 1 : prec,
					noIn,
				);

				let node;
				if (operator === "||" || operator === "&&" || operator === "??") {
					node = parser.finishNode(
						leftStartPos,
						{
							type: "JSLogicalExpression",
							left,
							right,
							operator,
						},
					);
				} else {
					node = parser.finishNode(
						leftStartPos,
						{
							type: "JSBinaryExpression",
							left,
							right,
							operator,
						},
					);
				}

				return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionOp(
					parser,
					context,
					node,
					leftStartPos,
					minPrec,
					noIn,
				);
			}
		}

		return left;
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeUnary(
		parser,
		context,
		refShorthandDefaultPos,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$isSyntaxEnabled(
				parser,
				"ts",
			) &&
			!___R$project$rome$$internal$js$parser$parser_ts$isSyntaxEnabled(
				parser,
				"jsx",
			) &&
			___R$project$rome$$internal$js$parser$parser_ts$isRelational(parser, "<")
		) {
			return ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeAssertion(
				parser,
			);
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$isContextual(
				parser,
				"await",
			) &&
			___R$project$rome$$internal$js$parser$parser_ts$inScope(parser, "ASYNC")
		) {
			return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseAwait(
				parser,
			);
		}

		if (parser.state.tokenType.prefix) {
			const start = parser.getPosition();
			const update = ___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.incDec,
			);
			const operator = (String(parser.state.tokenValue));
			const prefix = true;

			___R$project$rome$$internal$js$parser$parser_ts$next(parser);

			const argument = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeUnary(
				parser,
				context,
			);

			if (
				refShorthandDefaultPos &&
				___R$project$rome$$internal$ob1$index_ts$ob1Get0(
					refShorthandDefaultPos.index,
				) > 0
			) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedToken(
					parser,
					parser.getPositionFromIndex(refShorthandDefaultPos.index),
				);
			}

			if (update) {
				___R$project$rome$$internal$js$parser$parser$lval_ts$checkLVal(
					parser,
					argument,
					undefined,
					undefined,
					"prefix operation",
				);
			} else if (
				___R$project$rome$$internal$js$parser$parser_ts$inScope(
					parser,
					"STRICT",
				) &&
				operator === "delete"
			) {
				if (argument.type === "JSReferenceIdentifier") {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							loc: argument.loc,
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.DELETE_LOCAL_VARIABLE_IN_STRICT,
						},
					);
				} else if (
					argument.type === "JSMemberExpression" &&
					argument.property.value.type === "JSPrivateName"
				) {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							loc: argument.property.loc,
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.DELETE_PRIVATE_FIELD,
						},
					);
				}
			}

			let node;
			if (update) {
				if (operator !== "++" && operator !== "--") {
					throw new Error("Expected ++/-- operator only for JSUpdateExpression");
				}

				node = parser.finishNode(
					start,
					{
						type: "JSUpdateExpression",
						argument,
						operator,
						prefix,
					},
				);
			} else {
				if (operator === "++" || operator === "--") {
					throw new Error("BinaryExpression cannot have ++/-- operator");
				}

				node = parser.finishNode(
					start,
					{
						type: "JSUnaryExpression",
						argument,
						operator,
						prefix,
					},
				);
			}

			return node;
		}

		const startPos = parser.state.startPos;

		let expr = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionWithPossibleSubscripts(
			parser,
			context,
			refShorthandDefaultPos,
		);
		if (
			refShorthandDefaultPos &&
			___R$project$rome$$internal$ob1$index_ts$ob1Get0(
				refShorthandDefaultPos.index,
			) > 0
		) {
			return expr;
		}

		while (
			parser.state.tokenType.postfix &&
			!___R$project$rome$$internal$js$parser$parser_ts$canInsertSemicolon(
				parser,
			)
		) {
			const operator = (String(parser.state.tokenValue));
			___R$project$rome$$internal$js$parser$parser$lval_ts$checkLVal(
				parser,
				expr,
				undefined,
				undefined,
				"postfix operation",
			);
			___R$project$rome$$internal$js$parser$parser_ts$next(parser);

			const updateNode = parser.finishNode(
				startPos,
				{
					type: "JSUpdateExpression",
					operator,
					prefix: false,
					argument: expr,
				},
			);
			expr = updateNode;
		}

		return expr;
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionWithPossibleSubscripts(
		parser,
		context,
		refShorthandDefaultPos,
	) {
		const startPos = parser.state.startPos;
		const potentialArrowAt = parser.state.potentialArrowAt;
		const expr = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionAtom(
			parser,
			context,
			refShorthandDefaultPos,
		);

		if (
			expr.type === "JSArrowFunctionExpression" &&
			parser.getInputStartIndex(expr) === potentialArrowAt
		) {
			return expr;
		}

		if (
			refShorthandDefaultPos &&
			___R$project$rome$$internal$ob1$index_ts$ob1Get0(
				refShorthandDefaultPos.index,
			) > 0
		) {
			return expr;
		}

		return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseSubscripts(
			parser,
			expr,
			startPos,
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseSubscripts(
		parser,
		base,
		startPos,
		noCalls,
	) {
		const maybeAsyncArrow = ___R$project$rome$$internal$js$parser$parser$expression_ts$atPossibleAsync(
			parser,
			base,
		);

		if (
			base.type === "JSReferenceIdentifier" &&
			base.name === "async" &&
			parser.state.noArrowAt.includes(
				parser.getIndexFromPosition(startPos, parser.filename),
			)
		) {
			const argsStart = parser.getPosition();
			const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR,
				"call arguments",
			);
			const callee = base;
			const {args} = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseCallExpressionArguments(
				parser,
				openContext,
				false,
			);
			base = parser.finishNodeWithStarts(
				[argsStart, startPos],
				{
					type: "JSCallExpression",
					callee,
					arguments: args,
				},
			);
		} else if (
			base.type === "JSReferenceIdentifier" &&
			base.name === "async" &&
			___R$project$rome$$internal$js$parser$parser_ts$isRelational(parser, "<")
		) {
			const branch = ___R$project$rome$$internal$js$parser$parser_ts$createBranch(
				parser,
			);
			branch.add(() =>
				___R$project$rome$$internal$js$parser$parser$expression_ts$parseAsyncArrowWithTypeParameters(
					parser,
					startPos,
				)
			);
			branch.add(() =>
				___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionSubscriptsRecursively(
					parser,
					base,
					startPos,
					noCalls,
					maybeAsyncArrow,
				)
			);
			return branch.pick();
		}

		return ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionSubscriptsRecursively(
			parser,
			base,
			startPos,
			noCalls,
			maybeAsyncArrow,
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseAsyncArrowWithTypeParameters(
		parser,
		startPos,
	) {
		const {params, rest, typeParameters} = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseFunctionParams(
			parser,
		);

		const {returnType, valid} = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseArrowHead(
			parser,
		);
		if (!valid) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.INVALID_ASYNC_ARROW_WITH_TYPE_PARAMS,
				},
			);
			return undefined;
		}

		const func = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseArrowExpression(
			parser,
			startPos,
			{
				bindingList: params,
				rest,
			},
			/* isAsync */ true,
		);

		return Object.assign(
			{},
			func,
			{head: Object.assign({}, func.head, {returnType, typeParameters})},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionSubscriptsRecursively(
		parser,
		base,
		startPos,
		noCalls,
		maybeAsyncArrow,
	) {
		const state = {
			optionalChainMember: false,
			stop: false,
		};
		do {
			base = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionSubscript(
				parser,
				base,
				startPos,
				noCalls,
				state,
				maybeAsyncArrow,
			);
		} while (!state.stop);
		return base;
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionSubscript(
		parser,
		base,
		startPos,
		noCalls = false,
		state,
		maybeAsyncArrow,
	) {
		if (
			!___R$project$rome$$internal$js$parser$parser_ts$hasPrecedingLineBreak(
				parser,
			) &&
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bang,
			)
		) {
			parser.state.exprAllowed = false;
			___R$project$rome$$internal$js$parser$parser_ts$next(parser);

			return parser.finishNode(
				startPos,
				{
					type: "TSNonNullExpression",
					expression: base,
				},
			);
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.questionDot,
			)
		) {
			state.optionalChainMember = true;

			if (
				noCalls &&
				___R$project$rome$$internal$js$parser$parser_ts$lookaheadState(parser).tokenType ===
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL
			) {
				state.stop = true;
				return base;
			}

			___R$project$rome$$internal$js$parser$parser_ts$next(parser);

			// eg: o.m?.<T>(e);
			if (
				___R$project$rome$$internal$js$parser$parser_ts$isRelational(
					parser,
					"<",
				)
			) {
				if (noCalls) {
					state.stop = true;
					return base;
				}

				const callee = base;
				const typeArguments = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeArguments(
					parser,
				);
				const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR,
					"call arguments",
				);
				const {args} = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseCallExpressionArguments(
					parser,
					openContext,
					false,
				);
				return parser.finishNode(
					startPos,
					{
						type: "JSOptionalCallExpression",
						arguments: args,
						callee,
						typeArguments,
					},
				);
			}

			if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketL,
				)
			) {
				const propStart = parser.getPosition();
				const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketL,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketR,
					"computed property",
				);
				const object = base;
				const property = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpression(
					parser,
					"optional member expression property",
				);
				___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
					parser,
					openContext,
				);
				return parser.finishNode(
					startPos,
					{
						type: "JSMemberExpression",
						object,
						property: parser.finishNode(
							propStart,
							{
								type: "JSComputedMemberProperty",
								optional: true,
								value: property,
							},
						),
					},
				);
			}

			if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
				)
			) {
				const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR,
					"call arguments",
				);
				const callee = base;
				const {args} = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseCallExpressionArguments(
					parser,
					openContext,
					false,
				);

				return parser.finishNode(
					startPos,
					{
						type: "JSOptionalCallExpression",
						callee,
						arguments: args,
					},
				);
			}

			const object = base;
			const property = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier(
				parser,
				true,
			);

			return parser.finishNode(
				startPos,
				{
					type: "JSMemberExpression",
					object,
					property: {
						type: "JSStaticMemberProperty",
						loc: property.loc,
						optional: true,
						value: property,
					},
				},
			);
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.dot,
			)
		) {
			const object = base;
			const property = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybePrivateName(
				parser,
			);

			return parser.finishNode(
				startPos,
				{
					type: "JSMemberExpression",
					object,
					property: {
						type: "JSStaticMemberProperty",
						loc: property.loc,
						value: property,
					},
				},
			);
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketL,
			)
		) {
			const propStart = parser.getPosition();
			const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketL,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketR,
				"computed property",
			);
			const object = base;
			const property = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpression(
				parser,
				"member expression computed property",
			);
			___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
				parser,
				openContext,
			);

			return parser.finishNode(
				startPos,
				{
					type: "JSMemberExpression",
					object,
					property: parser.finishNode(
						propStart,
						{
							type: "JSComputedMemberProperty",
							value: property,
						},
					),
				},
			);
		}

		// Supports: foo<Foo>(); and foo<Foo>``;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$isRelational(parser, "<") &&
			___R$project$rome$$internal$js$parser$parser_ts$isSyntaxEnabled(
				parser,
				"ts",
			)
		) {
			const possibleCallExpression = ___R$project$rome$$internal$js$parser$parser_ts$tryBranch(
				parser,
				() => {
					const typeArguments = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeArguments(
						parser,
					);

					if (
						!noCalls &&
						___R$project$rome$$internal$js$parser$parser_ts$match(
							parser,
							___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
						)
					) {
						const argsStart = parser.getPosition();
						const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
							parser,
							___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
							___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR,
							"call arguments",
						);
						const {args} = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseCallExpressionArguments(
							parser,
							openContext,
							false,
						);
						const node = parser.finishNodeWithStarts(
							[argsStart, startPos],
							{
								type: "JSCallExpression",
								arguments: args,
								callee: base,
								typeArguments,
							},
						);
						return node;
					}

					if (
						___R$project$rome$$internal$js$parser$parser_ts$match(
							parser,
							___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.backQuote,
						)
					) {
						return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseTaggedTemplateExpression(
							parser,
							startPos,
							base,
							state,
							typeArguments,
						);
					}

					return undefined;
				},
			);

			if (possibleCallExpression !== undefined) {
				return possibleCallExpression;
			}
		}

		if (
			!noCalls &&
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
			)
		) {
			const oldMaybeInArrowParameters = parser.state.maybeInArrowParameters;
			const oldYieldPos = parser.state.yieldPos;
			const oldAwaitPos = parser.state.awaitPos;
			parser.state.maybeInArrowParameters = true;
			parser.state.yieldPos = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;
			parser.state.awaitPos = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;

			const argsStart = parser.getPosition();
			const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR,
				"call arguments",
			);
			const callee = base;

			const oldCommaAfterSpreadAt = parser.state.commaAfterSpreadAt;
			parser.state.commaAfterSpreadAt = ___R$project$rome$$internal$ob1$index_ts$ob1Number0Neg1;

			let {args, params} = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseCallExpressionArguments(
				parser,
				openContext,
				maybeAsyncArrow,
			);

			if (
				maybeAsyncArrow &&
				___R$project$rome$$internal$js$parser$parser$expression_ts$shouldParseAsyncArrow(
					parser,
				)
			) {
				state.stop = true;

				___R$project$rome$$internal$js$parser$parser$lval_ts$checkCommaAfterRestFromSpread(
					parser,
				);

				const node = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseAsyncArrowFromCallExpression(
					parser,
					startPos,
					params === undefined ? args : params,
				);
				___R$project$rome$$internal$js$parser$parser$expression_ts$checkYieldAwaitInDefaultParams(
					parser,
				);
				parser.state.yieldPos = oldYieldPos;
				parser.state.awaitPos = oldAwaitPos;
				return node;
			} else {
				args = ___R$project$rome$$internal$js$parser$parser$lval_ts$toReferencedListDeep(
					parser,
					args,
				);

				// We keep the old value if it isn't null, for cases like

				//   (x = async(yield)) => {}
				parser.state.yieldPos = oldYieldPos || parser.state.yieldPos;
				parser.state.awaitPos = oldAwaitPos || parser.state.awaitPos;
			}

			parser.state.maybeInArrowParameters = oldMaybeInArrowParameters;
			parser.state.commaAfterSpreadAt = oldCommaAfterSpreadAt;

			return parser.finishNodeWithStarts(
				[argsStart, startPos],
				{
					type: state.optionalChainMember
						? "JSOptionalCallExpression"
						: "JSCallExpression",
					callee,
					arguments: args,
				},
			);
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.backQuote,
			)
		) {
			return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseTaggedTemplateExpression(
				parser,
				startPos,
				base,
				state,
			);
		}

		state.stop = true;
		return base;
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseTaggedTemplateExpression(
		parser,
		startPos,
		tag,
		state,
		typeArguments,
	) {
		if (state.optionalChainMember) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TAGGED_TEMPLATE_IN_OPTIONAL_CHAIN,
				},
			);
		}

		const quasi = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseTemplate(
			parser,
			true,
		);
		return parser.finishNode(
			startPos,
			{
				type: "JSTaggedTemplateExpression",
				tag,
				quasi,
				typeArguments,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$checkYieldAwaitInDefaultParams(
		parser,
	) {
		if (
			___R$project$rome$$internal$ob1$index_ts$ob1Get0(parser.state.yieldPos) >
			0 &&
			(parser.state.awaitPos ===
			___R$project$rome$$internal$ob1$index_ts$ob1Number0 ||
			parser.state.yieldPos < parser.state.awaitPos)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					index: parser.state.yieldPos,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.YIELD_IN_GENERATOR_PARAMS,
				},
			);
		}

		if (
			___R$project$rome$$internal$ob1$index_ts$ob1Get0(parser.state.awaitPos) >
			0
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					index: parser.state.awaitPos,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.AWAIT_IN_ASYNC_PARAMS,
				},
			);
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$atPossibleAsync(
		parser,
		base,
	) {
		const start = parser.getInputStartIndex(base);
		const end = parser.getInputEndIndex(base);
		return (
			base.type === "JSReferenceIdentifier" &&
			base.name === "async" &&
			parser.state.lastEndIndex === end &&
			!___R$project$rome$$internal$js$parser$parser_ts$canInsertSemicolon(
				parser,
			) &&
			parser.getRawInput(start, end) === "async"
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseCallExpressionArguments(
		parser,
		openContext,
		possibleAsyncArrow,
		refTrailingCommaPos,
	) {
		let callArgs = [];
		let funcParams = [];

		let innerParenStart;
		let first = true;

		let forceAsyncArrow = false;

		while (true) {
			if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					openContext.close,
				) ||
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eof,
				)
			) {
				___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
					parser,
					openContext,
				);
				break;
			}

			if (first) {
				first = false;
			} else {
				if (
					!___R$project$rome$$internal$js$parser$parser_ts$expect(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
					)
				) {
					break;
				}

				if (
					___R$project$rome$$internal$js$parser$parser_ts$eat(
						parser,
						openContext.close,
					)
				) {
					break;
				}
			}

			// we need to make sure that if this is an async arrow functions, that we don't allow inner parens inside the params
			if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
				) &&
				!innerParenStart
			) {
				innerParenStart = parser.state.startPos;
			}

			const elt = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseCallArgument(
				parser,
				"call expression argument",
				false,
				possibleAsyncArrow
					? ___R$project$rome$$internal$js$parser$utils$location_ts$createIndexTracker()
					: undefined,
				possibleAsyncArrow
					? ___R$project$rome$$internal$js$parser$utils$location_ts$createIndexTracker()
					: undefined,
				possibleAsyncArrow ? refTrailingCommaPos : undefined,
			);
			if (elt.type === "JSArrayHole") {
				throw new Error("Expected element");
			}

			if (elt.type === "JSAmbiguousFlowTypeCastExpression") {
				if (possibleAsyncArrow) {
					// Definitely needs to be an arrow
					forceAsyncArrow = true;

					if (callArgs.length > 0) {
						funcParams = callArgs.slice();
						callArgs = [];
					}

					funcParams.push(elt);
				} else {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.CONFUSING_CALL_ARGUMENT,
							loc: elt.loc,
						},
					);
				}
				continue;
			}

			if (funcParams.length > 0) {
				funcParams.push(elt);
			} else {
				callArgs.push(elt);
			}
		}

		if (
			forceAsyncArrow &&
			!___R$project$rome$$internal$js$parser$parser$expression_ts$shouldParseAsyncArrow(
				parser,
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.EXPECTED_ARROW_AFTER_ASYNC_TYPE_PARAMS,
				},
			);
		}

		// we found an async arrow function so let's not allow any inner parens
		if (
			possibleAsyncArrow &&
			innerParenStart !== undefined &&
			___R$project$rome$$internal$js$parser$parser$expression_ts$shouldParseAsyncArrow(
				parser,
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					start: innerParenStart,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.PARENTHESIZED_FUNCTION_PARAMS,
				},
			);
		}

		return {
			args: callArgs,
			params: funcParams.length === 0 ? undefined : funcParams,
		};
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$shouldParseAsyncArrow(
		parser,
	) {
		return (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
			) ||
			(___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.arrow,
			) &&
			!___R$project$rome$$internal$js$parser$parser_ts$canInsertSemicolon(
				parser,
			))
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseAsyncArrowFromCallExpression(
		parser,
		start,
		args,
	) {
		let returnType;

		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			const oldNoAnonFunctionType = parser.state.noAnonFunctionType;
			parser.state.noAnonFunctionType = true;
			returnType = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
				parser,
				true,
			);
			parser.state.noAnonFunctionType = oldNoAnonFunctionType;
		}

		const oldYield = parser.state.yieldInPossibleArrowParameters;
		parser.state.yieldInPossibleArrowParameters = undefined;
		___R$project$rome$$internal$js$parser$parser_ts$expect(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.arrow,
		);
		const node = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseArrowExpression(
			parser,
			start,
			{
				assignmentList: args,
			},
			true,
		);
		parser.state.yieldInPossibleArrowParameters = oldYield;
		return Object.assign(
			{},
			node,
			{head: Object.assign({}, node.head, {returnType})},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseNoCallExpr(
		parser,
		context,
	) {
		const startPos = parser.state.startPos;
		return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseSubscripts(
			parser,
			___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionAtom(
				parser,
				context,
			),
			startPos,
			true,
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionAtom(
		parser,
		context,
		refShorthandDefaultPos,
	) {
		// If a division operator appears in an expression position, the
		// tokenizer got confused, and we force it to read a regexp instead.
		if (
			parser.state.tokenType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.slash
		) {
			___R$project$rome$$internal$js$parser$tokenizer$index_ts$readRegexp(
				parser,
			);
		}

		const canBeArrow = parser.state.potentialArrowAt === parser.getIndex();

		// We don't want to match <! as it's the start of a HTML comment
		if (
			___R$project$rome$$internal$js$parser$parser_ts$isRelational(parser, "<") &&
			parser.input.charCodeAt(
				___R$project$rome$$internal$ob1$index_ts$ob1Get0(parser.state.index),
			) !==
			___R$project$rome$$internal$string$charcodes$index_ts.exclamationMark
		) {
			// In case we encounter an lt token here it will always be the start of
			// jsx as the lt sign is not allowed in places that expect an expression
			___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.jsxTagStart,
			);
			return ___R$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXElement(
				parser,
			);
		}

		switch (parser.state.tokenType) {
			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.jsxTagStart:
				return ___R$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXElement(
					parser,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._super:
				return ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$parseSuper(
					parser,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._import:
				return ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$parseImportOrMetaProperty(
					parser,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._this: {
				const start = parser.getPosition();
				___R$project$rome$$internal$js$parser$parser_ts$next(parser);
				return parser.finishNode(start, {type: "JSThisExpression"});
			}

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name: {
				const start = parser.getPosition();
				const containsEsc = parser.state.escapePosition !== undefined;
				const id = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier(
					parser,
				);

				if (
					!containsEsc &&
					id.name === "async" &&
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._function,
					) &&
					!___R$project$rome$$internal$js$parser$parser_ts$canInsertSemicolon(
						parser,
					)
				) {
					___R$project$rome$$internal$js$parser$parser_ts$next(parser);
					return ___R$project$rome$$internal$js$parser$parser$statement_ts$parseFunctionExpression(
						parser,
						start,
						true,
					);
				}

				if (
					canBeArrow &&
					!containsEsc &&
					id.name === "async" &&
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name,
					)
				) {
					const oldYield = parser.state.yieldInPossibleArrowParameters;
					parser.state.yieldInPossibleArrowParameters = undefined;
					const params = [
						___R$project$rome$$internal$js$parser$parser$expression_ts$parseReferenceIdentifier(
							parser,
						),
					];
					___R$project$rome$$internal$js$parser$parser_ts$expect(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.arrow,
					);
					// let foo = bar => {};
					const node = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseArrowExpression(
						parser,
						start,
						{
							assignmentList: params,
						},
						true,
					);
					parser.state.yieldInPossibleArrowParameters = oldYield;
					return node;
				}

				if (
					canBeArrow &&
					!___R$project$rome$$internal$js$parser$parser_ts$canInsertSemicolon(
						parser,
					) &&
					___R$project$rome$$internal$js$parser$parser_ts$eat(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.arrow,
					)
				) {
					const oldYield = parser.state.yieldInPossibleArrowParameters;
					parser.state.yieldInPossibleArrowParameters = undefined;
					const node = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseArrowExpression(
						parser,
						start,
						{
							assignmentList: [
								___R$project$rome$$internal$js$parser$parser$expression_ts$toReferenceIdentifier(
									parser,
									id,
								),
							],
						},
					);
					parser.state.yieldInPossibleArrowParameters = oldYield;
					return node;
				}

				return ___R$project$rome$$internal$js$parser$parser$expression_ts$toReferenceIdentifier(
					parser,
					id,
				);
			}

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._do:
				return ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$parseDoExpression(
					parser,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.regexp:
				return ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$parseRegExpLiteral(
					parser,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.num:
				return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseNumericLiteral(
					parser,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bigint:
				return ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$parseBigIntLiteral(
					parser,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.string:
				return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseStringLiteral(
					parser,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._null:
				return ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$parseNullLiteral(
					parser,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._true:
			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._false:
				return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseBooleanLiteral(
					parser,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL:
				return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseParenAndDistinguishExpression(
					parser,
					context,
					canBeArrow,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketL:
				return ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$parseArrayExpression(
					parser,
					refShorthandDefaultPos,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL:
				return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseObjectExpression(
					parser,
					refShorthandDefaultPos,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._function:
				return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseFunctionExpressionOrMetaProperty(
					parser,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._class: {
				const start = parser.getPosition();
				return ___R$project$rome$$internal$js$parser$parser$classes_ts$parseClassExpression(
					parser,
					start,
				);
			}

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._new:
				return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseNew(
					parser,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.backQuote:
				return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseTemplate(
					parser,
					false,
				);

			default: {
				const start = parser.getPosition();
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.UNKNOWN_EXPRESSION_ATOM_START(
							context,
						),
					},
				);
				___R$project$rome$$internal$js$parser$parser_ts$next(parser);
				return ___R$project$rome$$internal$js$parser$parser$expression_ts$toReferenceIdentifier(
					parser,
					___R$project$rome$$internal$js$parser$parser_ts$createUnknownIdentifier(
						parser,
						context,
						start,
					),
				);
			}
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseBooleanLiteral(
		parser,
	) {
		const start = parser.getPosition();
		const value = ___R$project$rome$$internal$js$parser$parser_ts$match(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._true,
		);
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		return parser.finishNode(
			start,
			{
				type: "JSBooleanLiteral",
				value,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybePrivateName(
		parser,
	) {
		const isPrivate = ___R$project$rome$$internal$js$parser$parser_ts$match(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.hash,
		);

		if (isPrivate) {
			const start = parser.getPosition();
			___R$project$rome$$internal$js$parser$parser_ts$next(parser);
			___R$project$rome$$internal$js$parser$parser_ts$assertNoSpace(
				parser,
				___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.SPACE_BETWEEN_PRIVATE_HASH,
			);
			const id = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier(
				parser,
				true,
			);
			return parser.finishNode(
				start,
				{
					type: "JSPrivateName",
					id,
				},
			);
		} else {
			return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier(
				parser,
				true,
			);
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseFunctionExpressionOrMetaProperty(
		parser,
	) {
		const start = parser.getPosition();
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);

		// We do not do parseIdentifier here because when parseFunctionExpressionOrMetaProperty

		// is called we already know that the current token is a "name" with the value "function"

		// This will improve perf a tiny little bit as we do not do validation but more importantly

		// here is that parseIdentifier will remove an item from the expression stack

		// if "function" or "class" is parsed as identifier (in objects e.g.), which should not happen here.
		const meta = ___R$project$rome$$internal$js$parser$parser$expression_ts$createIdentifier(
			parser,
			start,
			"function",
		);

		if (
			___R$project$rome$$internal$js$parser$parser_ts$inScope(
				parser,
				"GENERATOR",
			) &&
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.dot,
			)
		) {
			return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMetaProperty(
				parser,
				start,
				meta,
				"sent",
			);
		}

		const node = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseFunctionExpression(
			parser,
			start,
			false,
		);

		if (node.type !== "JSFunctionExpression") {
			throw new Error("Expected parseFunction to return a JSFunctionExpression");
		}

		return node;
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMetaProperty(
		parser,
		start,
		meta,
		propertyName,
	) {
		if (
			meta.name === "function" &&
			propertyName === "sent" &&
			!___R$project$rome$$internal$js$parser$parser_ts$isContextual(
				parser,
				propertyName,
			)
		) {
			// They didn't actually say `function.sent`, just `function.`, so a simple error would be less confusing.
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedToken(parser);
		}

		const escapePosition = parser.state.escapePosition;
		const property = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier(
			parser,
			true,
		);

		if (property.name === propertyName) {
			___R$project$rome$$internal$js$parser$parser_ts$banUnicodeEscape(
				parser,
				escapePosition,
				propertyName,
			);
		} else {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					loc: property.loc,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.INVALID_META_PROPERTY(
						meta.name,
						propertyName,
					),
				},
			);
		}

		return parser.finishNode(
			start,
			{
				type: "JSMetaProperty",
				meta,
				property,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseImportMetaProperty(
		parser,
	) {
		const start = parser.getPosition();
		const id = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier(
			parser,
			true,
		);
		___R$project$rome$$internal$js$parser$parser_ts$expect(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.dot,
		);
		const node = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMetaProperty(
			parser,
			start,
			id,
			"meta",
		);

		if (!parser.meta.inModule) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					loc: node.loc,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.IMPORT_META_OUTSIDE_MODULE,
				},
			);
		}

		return node;
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseParenExpression(
		parser,
		context,
	) {
		const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR,
			context,
		);
		const val = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpression(
			parser,
			context,
		);
		___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
			parser,
			openContext,
		);
		return val;
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseParenAndDistinguishExpression(
		parser,
		context,
		canBeArrow,
	) {
		const startPos = parser.getPosition();
		const startIndex = parser.getIndex();

		if (parser.state.noArrowAt.includes(startIndex)) {
			canBeArrow = false;
		}

		const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR,
			"paren expression",
		);

		const oldMaybeInArrowParameters = parser.state.maybeInArrowParameters;
		const oldYieldPos = parser.state.yieldPos;
		const oldAwaitPos = parser.state.awaitPos;
		const oldYield = parser.state.yieldInPossibleArrowParameters;
		parser.state.maybeInArrowParameters = true;
		parser.state.yieldInPossibleArrowParameters = undefined;
		parser.state.yieldPos = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;
		parser.state.awaitPos = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;

		const innerStart = parser.getPosition();
		const exprList = [];
		const refShorthandDefaultPos = ___R$project$rome$$internal$js$parser$utils$location_ts$createIndexTracker();
		const refNeedsArrowPos = ___R$project$rome$$internal$js$parser$utils$location_ts$createIndexTracker();
		let first = true;
		let spreadStart;
		let optionalCommaStart;

		while (
			!___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR,
			)
		) {
			if (first) {
				first = false;
			} else {
				if (
					!___R$project$rome$$internal$js$parser$parser_ts$expect(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
						refNeedsArrowPos.index ===
						___R$project$rome$$internal$ob1$index_ts$ob1Number0
							? undefined
							: parser.getPositionFromIndex(refNeedsArrowPos.index),
					)
				) {
					break;
				}

				if (
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR,
					)
				) {
					optionalCommaStart = parser.state.startPos;
					break;
				}
			}

			if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.ellipsis,
				)
			) {
				const spreadNodeStartPos = parser.state.startPos;
				spreadStart = parser.state.startPos;
				exprList.push(
					___R$project$rome$$internal$js$parser$parser$expression_ts$parseParenItem(
						parser,
						___R$project$rome$$internal$js$parser$parser$lval_ts$parseSpread(
							parser,
						),
						spreadNodeStartPos,
					),
				);

				if (
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
					) &&
					___R$project$rome$$internal$js$parser$parser_ts$lookaheadState(parser).tokenType ===
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR
				) {
					___R$project$rome$$internal$js$parser$parser$lval_ts$raiseRestNotLast(
						parser,
					);
					___R$project$rome$$internal$js$parser$parser_ts$eat(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
					);
				}
			} else {
				exprList.push(
					___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeAssign(
						parser,
						context,
						false,
						refShorthandDefaultPos,
						___R$project$rome$$internal$js$parser$parser$expression_ts$parseParenItem,
						refNeedsArrowPos,
					),
				);
			}
		}

		const innerEnd = parser.getPosition();
		___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
			parser,
			openContext,
		);

		parser.state.maybeInArrowParameters = oldMaybeInArrowParameters;

		if (
			canBeArrow &&
			___R$project$rome$$internal$js$parser$parser$expression_ts$shouldParseArrow(
				parser,
			)
		) {
			const {valid, returnType} = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseArrowHead(
				parser,
			);

			if (valid) {
				___R$project$rome$$internal$js$parser$parser$expression_ts$checkYieldAwaitInDefaultParams(
					parser,
				);
				parser.state.yieldPos = oldYieldPos;
				parser.state.awaitPos = oldAwaitPos;

				for (const param of exprList) {
					if (
						___R$project$rome$$internal$js$parser$parser_ts$isParenthesized(
							parser,
							param,
						)
					) {
						___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
							parser,
							{
								loc: param.loc,
								description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.PARENTHESIZED_FUNCTION_PARAMS,
							},
						);
					}
				}

				const arrow = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseArrowExpression(
					parser,
					startPos,
					{
						assignmentList: exprList,
					},
				);
				parser.state.yieldInPossibleArrowParameters = oldYield;
				return Object.assign(
					{},
					arrow,
					{head: Object.assign({}, arrow.head, {returnType})},
				);
			}
		}

		parser.state.yieldInPossibleArrowParameters = oldYield;

		// We keep the old value if it isn't null, for cases like

		//   (x = (yield)) => {}
		parser.state.yieldPos = oldYieldPos || parser.state.yieldPos;
		parser.state.awaitPos = oldAwaitPos || parser.state.awaitPos;

		if (exprList.length === 0) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					start: innerStart,
					end: innerEnd,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.EMPTY_PARENTHESIZED_EXPRESSION,
				},
			);

			exprList.push(
				___R$project$rome$$internal$js$parser$parser$expression_ts$toReferenceIdentifier(
					parser,
					___R$project$rome$$internal$js$parser$parser_ts$createUnknownIdentifier(
						parser,
						"empty parenthesized expression",
						innerStart,
						innerEnd,
					),
				),
			);
		}

		if (optionalCommaStart !== undefined) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedToken(
				parser,
				optionalCommaStart,
			);
		}

		if (spreadStart !== undefined) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedToken(
				parser,
				spreadStart,
			);
		}

		if (
			___R$project$rome$$internal$ob1$index_ts$ob1Get0(
				refShorthandDefaultPos.index,
			) >
			0
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedToken(
				parser,
				parser.getPositionFromIndex(refShorthandDefaultPos.index),
			);
		}

		if (
			___R$project$rome$$internal$ob1$index_ts$ob1Get0(refNeedsArrowPos.index) >
			0
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedToken(
				parser,
				parser.getPositionFromIndex(refNeedsArrowPos.index),
			);
		}

		const filterList = ___R$project$rome$$internal$js$parser$parser$lval_ts$filterSpread(
			parser,
			___R$project$rome$$internal$js$parser$parser$lval_ts$toReferencedListDeep(
				parser,
				exprList,
				/* isParenthesizedExpr */ true,
			),
		);

		let val = filterList[0];
		if (filterList.length > 1) {
			val = parser.finishNodeAt(
				innerStart,
				innerEnd,
				{
					type: "JSSequenceExpression",
					expressions: filterList,
				},
			);
		}

		___R$project$rome$$internal$js$parser$parser_ts$addParenthesized(
			parser,
			val,
		);

		return val;
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$shouldParseArrow(
		parser,
	) {
		return (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
			) ||
			!___R$project$rome$$internal$js$parser$parser_ts$canInsertSemicolon(
				parser,
			)
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseArrowHead(
		parser,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			const oldNoAnonFunctionType = parser.state.noAnonFunctionType;
			parser.state.noAnonFunctionType = true;

			const branch = ___R$project$rome$$internal$js$parser$parser_ts$createBranch(
				parser,
			);

			branch.add(() => {
				const res = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
				);

				if (
					___R$project$rome$$internal$js$parser$parser_ts$canInsertSemicolon(
						parser,
					)
				) {
					// No semicolon insertion expected
					return undefined;
				}

				if (
					___R$project$rome$$internal$js$parser$parser_ts$eat(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.arrow,
					)
				) {
					return res;
				}

				return undefined;
			});

			if (branch.hasBranch()) {
				const returnType = branch.pick();
				parser.state.noAnonFunctionType = oldNoAnonFunctionType;

				if (returnType === undefined) {
					throw new Error(
						"hasBranchResult call above should have refined this condition",
					);
				}

				return {
					valid: true,
					returnType,
				};
			} else {
				parser.state.noAnonFunctionType = oldNoAnonFunctionType;
				return {
					valid: false,
					returnType: undefined,
				};
			}
		} else {
			return {
				valid: ___R$project$rome$$internal$js$parser$parser_ts$eat(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.arrow,
				),
				returnType: undefined,
			};
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseParenItem(
		parser,
		node,
		startPos,
	) {
		let optional = undefined;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.question,
			)
		) {
			optional = true;
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			const typeAnnotation = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
				parser,
				true,
			);
			return parser.finishNode(
				startPos,
				{
					type: "JSAmbiguousFlowTypeCastExpression",
					expression: node,
					typeAnnotation,
					optional,
				},
			);
		}

		if (optional) {
			return parser.finishNode(
				startPos,
				{
					type: "JSAmbiguousFlowTypeCastExpression",
					expression: node,
					typeAnnotation: undefined,
					optional,
				},
			);
		}

		return node;
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseNew(
		parser,
	) {
		const start = parser.getPosition();
		const meta = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier(
			parser,
			true,
		);

		if (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.dot,
			)
		) {
			const metaProp = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMetaProperty(
				parser,
				start,
				meta,
				"target",
			);

			if (
				!___R$project$rome$$internal$js$parser$parser_ts$inScope(
					parser,
					"NON_ARROW_FUNCTION",
				) &&
				!___R$project$rome$$internal$js$parser$parser_ts$inScope(
					parser,
					"CLASS_PROPERTY",
				)
			) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						loc: metaProp.loc,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.NEW_TARGET_OUTSIDE_CLASS,
					},
				);
			}

			return metaProp;
		}

		const callee = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseNoCallExpr(
			parser,
			"new callee",
		);

		if (callee.type === "JSImportCall") {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					loc: callee.loc,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.SUPER_OUTSIDE_METHOD,
				},
			);
		}

		const optionalMember = ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$getFirstOptionalChainMember(
			callee,
		);
		if (optionalMember !== undefined) {
			const memberLoc = parser.getLoc(optionalMember);

			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.NEW_IN_OPTIONAL_CHAIN(
						memberLoc,
					),
				},
			);
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.questionDot,
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.NEW_IN_OPTIONAL_CHAIN(),
				},
			);
		}

		let optional = undefined;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.questionDot,
			)
		) {
			optional = true;
		}

		let typeArguments = undefined;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$isSyntaxEnabled(
				parser,
				"ts",
			) &&
			___R$project$rome$$internal$js$parser$parser_ts$isRelational(parser, "<")
		) {
			typeArguments = ___R$project$rome$$internal$js$parser$parser_ts$tryBranch(
				parser,
				___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeArguments,
			);
		}

		let args = [];
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
			)
		) {
			const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR,
				"new argument",
			);
			args = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionListNonEmpty(
				parser,
				"new expression argument",
				openContext,
			);
			args = ___R$project$rome$$internal$js$parser$parser$lval_ts$toReferencedList(
				parser,
				args,
			);
		} else if (
			___R$project$rome$$internal$js$parser$parser_ts$isSyntaxEnabled(
				parser,
				"ts",
			) &&
			typeArguments !== undefined
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.NEW_WITH_TYPESCRIPT_TYPE_ARGUMENTS_NO_PARENS,
				},
			);
		}

		return parser.finishNode(
			start,
			{
				type: "JSNewExpression",
				callee,
				typeArguments,
				arguments: args,
				optional,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$getFirstOptionalChainMember(
		node,
	) {
		if (node.type === "JSOptionalCallExpression") {
			return node;
		}

		if (node.type === "JSMemberExpression") {
			if (node.property.optional) {
				return node;
			}

			if (node.property.type === "JSStaticMemberProperty") {
				return ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$getFirstOptionalChainMember(
					node.object,
				);
			}
		}

		return undefined;
	}

	// Parse template expression.
	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseTemplateElement(
		parser,
		isTagged,
	) {
		const start = parser.getPosition();
		const tokenValue = parser.state.tokenValue;

		if (tokenValue === undefined) {
			if (isTagged) {
				parser.state.invalidTemplateEscapePosition = undefined;
			} else {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						index: parser.state.invalidTemplateEscapePosition,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.INVALID_TEMPLATE_ESCAPE,
					},
				);
			}
		}

		const raw = parser.getRawInput(
			parser.state.startIndex,
			parser.state.endIndex,
		).replace(/\r\n?/g, "\n");
		const cooked = tokenValue === undefined ? raw : String(tokenValue);

		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		const tail = ___R$project$rome$$internal$js$parser$parser_ts$match(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.backQuote,
		);
		return parser.finishNode(
			start,
			{
				type: "JSTemplateElement",
				raw,
				cooked,
				tail,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseTemplate(
		parser,
		isTagged,
	) {
		const start = parser.getPosition();
		const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.backQuote,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.backQuote,
			"template literal",
		);
		const expressions = [];
		let curElt = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseTemplateElement(
			parser,
			isTagged,
		);
		const quasis = [curElt];

		while (true) {
			if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eof,
				) ||
				curElt.tail === true
			) {
				break;
			}

			const exprPpenContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.dollarBraceL,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
				"template expression value",
			);
			expressions.push(
				___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpression(
					parser,
					"template expression value",
				),
			);
			___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
				parser,
				exprPpenContext,
			);

			curElt = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseTemplateElement(
				parser,
				isTagged,
			);
			quasis.push(curElt);
		}

		___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
			parser,
			openContext,
		);

		return parser.finishNode(
			start,
			{
				type: "JSTemplateLiteral",
				expressions,
				quasis,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseObjectExpression(
		parser,
		refShorthandDefaultPos,
	) {
		const propHash = new Set();
		let first = true;

		const start = parser.getPosition();
		const properties = [];

		const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
			"object",
		);

		while (true) {
			if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
				) ||
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eof,
				)
			) {
				___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
					parser,
					openContext,
				);
				break;
			}

			if (first) {
				first = false;
			} else {
				if (
					!___R$project$rome$$internal$js$parser$parser_ts$expect(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
					)
				) {
					break;
				}

				if (
					___R$project$rome$$internal$js$parser$parser_ts$eat(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
					)
				) {
					break;
				}
			}

			if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.ellipsis,
				)
			) {
				const prop = Object.assign(
					{},
					___R$project$rome$$internal$js$parser$parser$lval_ts$parseSpread(
						parser,
					),
					{type: "JSSpreadProperty"},
				);
				properties.push(prop);
				continue;
			}

			const start = parser.getPosition();
			let isGenerator = ___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.star,
			);
			let isAsync = false;

			let key;
			let escapePosition;

			if (
				___R$project$rome$$internal$js$parser$parser_ts$isContextual(
					parser,
					"async",
				)
			) {
				if (isGenerator) {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedToken(
						parser,
					);
				}

				const asyncId = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier(
					parser,
				);
				if (
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
					) ||
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
					) ||
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
					) ||
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eq,
					) ||
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
					)
				) {
					key = {
						type: "JSStaticPropertyKey",
						loc: asyncId.loc,
						value: asyncId,
					};
				} else {
					if (
						___R$project$rome$$internal$js$parser$parser_ts$hasPrecedingLineBreak(
							parser,
						)
					) {
						___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
							parser,
							{
								description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.ASYNC_OBJECT_METHOD_LINE_BREAK,
							},
						);
					}

					isAsync = true;
					if (
						___R$project$rome$$internal$js$parser$parser_ts$match(
							parser,
							___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.star,
						)
					) {
						___R$project$rome$$internal$js$parser$parser_ts$next(parser);
						isGenerator = true;
					}
					escapePosition = parser.state.escapePosition;
					key = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseObjectPropertyKey(
						parser,
					);
				}
			} else {
				escapePosition = parser.state.escapePosition;
				key = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseObjectPropertyKey(
					parser,
				);
			}

			const prop = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseObjectPropertyValue(
				parser,
				{
					key,
					start,
					isGenerator,
					isAsync,
					isPattern: false,
					refShorthandDefaultPos,
					escapePosition,
				},
			);
			if (prop === undefined) {
				continue;
			}
			if (prop.type === "JSBindingObjectPatternProperty") {
				throw new Error("Impossible");
			}

			___R$project$rome$$internal$js$parser$parser$expression_ts$checkPropClash(
				parser,
				prop,
				propHash,
			);
			properties.push(prop);
		}

		return parser.finishNode(
			start,
			{
				type: "JSObjectExpression",
				properties,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseObjectPattern(
		parser,
		refShorthandDefaultPos,
	) {
		const propHash = new Set();
		let first = true;

		const start = parser.getPosition();
		const properties = [];
		let rest;

		const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
			"object pattern",
		);

		let firstRestLocation = undefined;

		while (true) {
			if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eof,
				) ||
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
				)
			) {
				break;
			}

			if (first) {
				first = false;
			} else {
				___R$project$rome$$internal$js$parser$parser_ts$expect(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
				);

				if (
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eof,
					) ||
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
					)
				) {
					break;
				}
			}

			let isGenerator = false;
			let isAsync = false;
			let start = parser.getPosition();

			if (
				___R$project$rome$$internal$js$parser$parser_ts$eat(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.ellipsis,
				)
			) {
				const argument = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseBindingIdentifier(
					parser,
				);
				rest = argument;

				if (firstRestLocation !== undefined) {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							loc: argument.loc,
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.MULTIPLE_DESTRUCTURING_RESTS,
						},
					);
				}

				if (
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
					) ||
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eof,
					)
				) {
					break;
				}

				if (
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
					) &&
					___R$project$rome$$internal$js$parser$parser_ts$lookaheadState(parser).tokenType ===
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR
				) {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TRAILING_COMMA_AFTER_REST,
						},
					);
					___R$project$rome$$internal$js$parser$parser_ts$eat(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
					);
					break;
				} else {
					firstRestLocation = argument.loc;
					continue;
				}
			}

			start = parser.getPosition();

			const key = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseObjectPropertyKey(
				parser,
			);
			const prop = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseObjectPropertyValue(
				parser,
				{
					key,
					start,
					isGenerator,
					isAsync,
					isPattern: true,
					refShorthandDefaultPos,
					escapePosition: undefined,
				},
			);

			if (prop === undefined) {
				continue;
			}

			___R$project$rome$$internal$js$parser$parser$expression_ts$checkPropClash(
				parser,
				prop,
				propHash,
			);

			if (prop.type !== "JSBindingObjectPatternProperty") {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.INVALID_OBJECT_PATTERN_PROP,
						loc: prop.loc,
					},
				);
				continue;
			}

			properties.push(prop);
		}

		___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
			parser,
			openContext,
		);

		if (firstRestLocation !== undefined) {
			___R$project$rome$$internal$js$parser$parser$lval_ts$raiseRestNotLast(
				parser,
				firstRestLocation,
			);
		}

		return parser.finishNode(
			start,
			{
				type: "JSBindingObjectPattern",
				properties,
				rest,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$isGetterOrSetterMethod(
		parser,
		key,
		// `key` is always from `name.key`, we just need it here to refine
		keyVal,
		isPattern,
	) {
		return (
			!isPattern &&
			key.type === "JSStaticPropertyKey" &&
			keyVal.type === "JSIdentifier" &&
			(keyVal.name === "get" || keyVal.name === "set") &&
			(___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.string,
			) ||
			// get "string"() {}
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.num,
			) ||
			// get 1() {}
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketL,
			) ||
			// get ["string"]() {}
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name,
			) ||
			// get foo() {}
			!!parser.state.tokenType.keyword) // get debugger() {}
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$checkGetterSetterParamCount(
		parser,
		method,
		kind,
	) {
		const head = method.head;

		if (kind === "get") {
			if (head.rest !== undefined || head.params.length !== 0) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						loc: method.loc,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.GETTER_WITH_PARAMS,
					},
				);
			}
		} else if (kind === "set") {
			if (head.rest !== undefined) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						loc: head.rest.loc,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.SETTER_WITH_REST,
					},
				);
			} else if (head.params.length !== 1) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						loc: method.loc,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.SETTER_NOT_ONE_PARAM,
					},
				);
			}
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseObjectMethod(
		parser,
		{
			key,
			start,
			isGenerator,
			isAsync,
			isPattern,
			escapePosition,
		},
	) {
		if (
			isAsync ||
			isGenerator ||
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
			)
		) {
			if (isPattern) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.OBJECT_METHOD_IN_PATTERN,
					},
				);
			}

			const partial = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMethod(
				parser,
				{
					kind: "method",
					isClass: false,
					isGenerator,
					isAsync,
					isConstructor: false,
				},
			);

			const {body} = partial;
			if (body === undefined || body.type !== "JSBlockStatement") {
				throw new Error("Expected body");
			}

			return parser.finishNode(
				start,
				Object.assign(
					{},
					partial,
					{body, key, type: "JSObjectMethod", kind: "method"},
				),
			);
		}

		if (
			___R$project$rome$$internal$js$parser$parser$expression_ts$isGetterOrSetterMethod(
				parser,
				key,
				key.value,
				isPattern,
			)
		) {
			if (isAsync) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.ASYNC_GETTER_SETTER,
					},
				);
			}

			if (isGenerator) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.GENERATOR_GETTER_SETTER,
					},
				);
			}

			const kind = key.value.name;
			if (kind !== "get" && kind !== "set") {
				throw new Error(
					"Name should be get or set as we already validated it as such",
				);
			}
			___R$project$rome$$internal$js$parser$parser_ts$banUnicodeEscape(
				parser,
				escapePosition,
				kind,
			);

			const newKey = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseObjectPropertyKey(
				parser,
			);

			const partial = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMethod(
				parser,
				{
					kind,
					isClass: false,
					isGenerator: false,
					isAsync: false,
					isConstructor: false,
				},
			);

			const {body, head} = partial;
			if (body === undefined || body.type !== "JSBlockStatement") {
				throw new Error("Expected body");
			}

			const method = parser.finishNode(
				start,
				{
					head,
					body,
					key: newKey,
					type: "JSObjectMethod",
					kind,
				},
			);
			___R$project$rome$$internal$js$parser$parser$expression_ts$checkGetterSetterParamCount(
				parser,
				method,
				method.kind,
			);
			return method;
		}

		return undefined;
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseObjectProperty(
		parser,
		key,
		start,
		isPattern,
		refShorthandDefaultPos,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			if (isPattern) {
				const value = ___R$project$rome$$internal$js$parser$parser$lval_ts$parseMaybeDefault(
					parser,
				);
				return parser.finishNode(
					start,
					{
						key,
						type: "JSBindingObjectPatternProperty",
						value,
					},
				);
			} else {
				const value = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeAssign(
					parser,
					"object property value",
					false,
					refShorthandDefaultPos,
				);
				return parser.finishNode(
					start,
					{
						key,
						type: "JSObjectProperty",
						value,
					},
				);
			}
		}

		if (key.type === "JSStaticPropertyKey" && key.value.type === "JSIdentifier") {
			___R$project$rome$$internal$js$parser$parser$expression_ts$checkReservedWord(
				parser,
				key.value.name,
				parser.getLoc(key.value),
				true,
				true,
			);

			if (isPattern) {
				let value = ___R$project$rome$$internal$js$parser$parser$expression_ts$toBindingIdentifier(
					parser,
					___R$project$rome$$internal$js$parser$parser_ts$cloneNode(
						parser,
						key.value,
					),
				);

				if (
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eq,
					) &&
					refShorthandDefaultPos
				) {
					if (
						refShorthandDefaultPos.index ===
						___R$project$rome$$internal$ob1$index_ts$ob1Number0
					) {
						refShorthandDefaultPos.index = parser.getIndex();
					}

					value = ___R$project$rome$$internal$js$parser$parser$lval_ts$parseMaybeDefault(
						parser,
						start,
						value,
					);
				}

				return parser.finishNode(
					start,
					{
						type: "JSBindingObjectPatternProperty",
						key,
						value,
					},
				);
			}

			return parser.finishNode(
				start,
				{
					type: "JSObjectProperty",
					key,
					value: ___R$project$rome$$internal$js$parser$parser$expression_ts$toReferenceIdentifier(
						parser,
						___R$project$rome$$internal$js$parser$parser_ts$cloneNode(
							parser,
							key.value,
						),
					),
				},
			);
		}

		return undefined;
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseObjectPropertyValue(
		parser,
		{
			key,
			start,
			isGenerator,
			isAsync,
			isPattern,
			refShorthandDefaultPos,
			escapePosition,
		},
	) {
		// parse type parameters for object method shorthand
		let typeParameters = ___R$project$rome$$internal$js$parser$parser$typescript_ts$maybeParseTSTypeParameters(
			parser,
		);
		if (
			typeParameters !== undefined &&
			!___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedToken(parser);
		}

		let node =
			___R$project$rome$$internal$js$parser$parser$expression_ts$parseObjectMethod(
				parser,
				{
					key,
					start,
					isGenerator,
					isAsync,
					isPattern,
					escapePosition,
				},
			) ||
			___R$project$rome$$internal$js$parser$parser$expression_ts$parseObjectProperty(
				parser,
				key,
				start,
				isPattern,
				refShorthandDefaultPos,
			);

		if (node === undefined) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedToken(parser);
			return undefined;
		}

		if (typeParameters === undefined) {
			return node;
		} else {
			if (
				node.type === "JSObjectProperty" ||
				node.type === "JSBindingObjectPatternProperty"
			) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						loc: typeParameters.loc,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.OBJECT_PROPERTY_WITH_TYPE_PARAMETERS,
					},
				);
				return node;
			}

			return Object.assign(
				{},
				node,
				{head: Object.assign({}, node.head, {typeParameters})},
			);
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseObjectPropertyKey(
		parser,
	) {
		const start = parser.getPosition();

		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketL,
			)
		) {
			const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketL,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketR,
				"property name",
			);

			const value = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeAssign(
				parser,
				"property name",
			);
			___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
				parser,
				openContext,
			);
			return parser.finishNode(
				start,
				{
					type: "JSComputedPropertyKey",
					value,
				},
			);
		} else {
			___R$project$rome$$internal$js$parser$parser_ts$pushScope(
				parser,
				"PROPERTY_NAME",
				true,
			);

			// We check if it's valid for it to be a private name when we push it.
			let value;
			if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.num,
				)
			) {
				value = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseNumericLiteral(
					parser,
				);
			} else if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.string,
				)
			) {
				value = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseStringLiteral(
					parser,
				);
			} else {
				value = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybePrivateName(
					parser,
				);
			}

			___R$project$rome$$internal$js$parser$parser_ts$popScope(
				parser,
				"PROPERTY_NAME",
			);

			return parser.finishNode(
				start,
				{
					type: "JSStaticPropertyKey",
					value,
				},
			);
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMethod(
		parser,
		opts,
	) {
		const {kind, isClass, isGenerator, isAsync, isConstructor} = opts;

		const oldYieldPos = parser.state.yieldPos;
		const oldAwaitPos = parser.state.awaitPos;
		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"FUNCTION",
			true,
		);
		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"NON_ARROW_FUNCTION",
		);
		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"METHOD",
			kind,
		);
		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"GENERATOR",
			isGenerator,
		);
		parser.state.yieldPos = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;
		parser.state.awaitPos = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;

		const allowTSModifiers = isConstructor;
		const headStart = parser.getPosition();
		const {typeParameters, rest, params} = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseFunctionParams(
			parser,
			kind,
			allowTSModifiers,
		);
		const start = parser.getPosition();
		const {body, head} = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseFunctionBodyAndFinish(
			parser,
			{
				headStart,
				rest,
				params,
				id: undefined,
				allowBodiless: isClass,
				isArrowFunction: false,
				isAsync,
				isGenerator,
				isMethod: true,
				start,
			},
		);

		___R$project$rome$$internal$js$parser$parser_ts$popScope(parser, "METHOD");
		___R$project$rome$$internal$js$parser$parser_ts$popScope(
			parser,
			"GENERATOR",
		);
		___R$project$rome$$internal$js$parser$parser_ts$popScope(parser, "FUNCTION");
		___R$project$rome$$internal$js$parser$parser_ts$popScope(
			parser,
			"NON_ARROW_FUNCTION",
		);
		parser.state.yieldPos = oldYieldPos;
		parser.state.awaitPos = oldAwaitPos;

		return {
			head: Object.assign({}, head, {typeParameters}),
			body,
		};
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$createFunctionHead(
		parser,
		params,
		rest,
		opts,
	) {
		const nonRestParams = [];

		for (const param of params) {
			switch (param.type) {
				case "JSBindingIdentifier":
				case "JSBindingAssignmentPattern":
				case "JSBindingObjectPattern":
				case "JSBindingArrayPattern": {
					nonRestParams.push(param);
					break;
				}

				default:
					throw new Error("TODO");
			}
		}

		return Object.assign(
			{type: "JSFunctionHead", rest},
			___R$project$rome$$internal$js$parser$parser$statement_ts$splitFunctionParams(
				nonRestParams,
			),
			opts,
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseArrowExpression(
		parser,
		start,
		opts,
		isAsync = false,
	) {
		// if we got there, it's no more "yield in possible arrow parameters";
		// it's just "yield in arrow parameters"
		if (parser.state.yieldInPossibleArrowParameters) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					start: parser.state.yieldInPossibleArrowParameters,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.YIELD_NAME_IN_GENERATOR,
				},
			);
		}

		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"FUNCTION",
			true,
		);

		const oldYieldPos = parser.state.yieldPos;
		const oldAwaitPos = parser.state.awaitPos;
		const oldMaybeInArrowParameters = parser.state.maybeInArrowParameters;
		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"GENERATOR",
			false,
		);
		parser.state.maybeInArrowParameters = false;
		parser.state.yieldPos = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;
		parser.state.awaitPos = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;

		const headEnd = parser.getLastEndPosition();

		let params = [];
		let rest = opts.rest;

		if (opts.bindingList !== undefined) {
			params = opts.bindingList;
		}

		if (opts.assignmentList !== undefined) {
			({params, rest} = ___R$project$rome$$internal$js$parser$parser$lval_ts$toFunctionParamsBindingList(
				parser,
				opts.assignmentList,
				"arrow function parameters",
			));
		}

		let head = parser.finishNodeAt(
			start,
			headEnd,
			___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$createFunctionHead(
				parser,
				params,
				rest,
				{
					hasHoistedVars: false,
					async: isAsync,
				},
			),
		);

		const {body, hasHoistedVars} = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseFunctionBody(
			parser,
			{
				id: undefined,
				allowBodiless: false,
				isArrowFunction: true,
				isMethod: false,
				isAsync,
				isGenerator: false,
				start,
			},
		);

		head = Object.assign({}, head, {hasHoistedVars});

		___R$project$rome$$internal$js$parser$parser$expression_ts$checkFunctionNameAndParams(
			parser,
			{
				isArrowFunction: true,
				isMethod: false,
				id: undefined,
				params,
				rest,
				start,
			},
			body,
		);

		___R$project$rome$$internal$js$parser$parser_ts$popScope(
			parser,
			"GENERATOR",
		);
		___R$project$rome$$internal$js$parser$parser_ts$popScope(parser, "FUNCTION");
		parser.state.maybeInArrowParameters = oldMaybeInArrowParameters;
		parser.state.yieldPos = oldYieldPos;
		parser.state.awaitPos = oldAwaitPos;

		// Finish the head again so it's added to the comment stack again so that the arrow
		// finishNode can take comments if necessary
		head = parser.finishNodeAt(start, headEnd, head);

		return parser.finishNode(
			start,
			{
				type: "JSArrowFunctionExpression",
				body,
				head,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$isStrictBody(
		parser,
		body,
	) {
		if (body.type === "JSBlockStatement" && body.directives !== undefined) {
			for (const directive of body.directives) {
				if (directive.value === "use strict") {
					return true;
				}
			}
		}

		return false;
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseFunctionBodyAndFinish(
		parser,
		opts,
	) {
		let returnType = undefined;

		// For arrow functions, `parseArrow` handles the return type itself.
		if (
			!opts.isArrowFunction &&
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			returnType = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
			);
		}

		const headEnd = parser.getLastEndPosition();
		let head = parser.finishNodeAt(
			opts.headStart,
			headEnd,
			___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$createFunctionHead(
				parser,
				opts.params,
				opts.rest,
				{
					generator: opts.isGenerator,
					async: opts.isAsync,
					hasHoistedVars: false,
					returnType,
				},
			),
		);

		if (
			opts.allowBodiless &&
			!___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL,
			) &&
			___R$project$rome$$internal$js$parser$parser_ts$isLineTerminator(parser)
		) {
			return {
				head,
				body: undefined,
			};
		}

		const {body, hasHoistedVars} = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseFunctionBody(
			parser,
			opts,
		);

		___R$project$rome$$internal$js$parser$parser$expression_ts$checkFunctionNameAndParams(
			parser,
			{
				isArrowFunction: opts.isArrowFunction,
				isMethod: opts.isMethod,
				id: opts.id,
				start: opts.start,
				params: opts.params,
				rest: opts.rest,
			},
			body,
		);

		head = Object.assign({}, head, {hasHoistedVars});

		return {
			head,
			body,
		};
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseFunctionBody(
		parser,
		opts,
	) {
		if (opts.isArrowFunction) {
			return ___R$project$rome$$internal$js$parser$parser$expression_ts$forwardNoArrowParamsConversionAt(
				parser,
				opts.start,
				() =>
					___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$_parseFunctionBody(
						parser,
						opts,
					)
				,
			);
		} else {
			return ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$_parseFunctionBody(
				parser,
				opts,
			);
		}
	}

	// Parse function body and check parameters.
	function ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$_parseFunctionBody(
		parser,
		opts,
	) {
		const {isArrowFunction, isAsync, isGenerator} = opts;

		const isExpression =
			isArrowFunction &&
			!___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL,
			);

		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"PARAMETERS",
			false,
		);
		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"ASYNC",
			isAsync,
		);

		let hasHoistedVars = false;
		let body;
		if (isExpression) {
			body = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeAssign(
				parser,
				"function body",
			);
		} else {
			// Start a new scope with regard to labels and the `inGenerator`
			// flag (restore them to their old value afterwards).
			const oldLabels = parser.state.labels;
			___R$project$rome$$internal$js$parser$parser_ts$pushScope(
				parser,
				"GENERATOR",
				isGenerator,
			);
			parser.state.labels = [];

			const oldhasHoistedVars = parser.state.hasHoistedVars;
			parser.state.hasHoistedVars = false;

			body = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseBlock(
				parser,
				true,
			);
			hasHoistedVars = parser.state.hasHoistedVars;

			___R$project$rome$$internal$js$parser$parser_ts$popScope(
				parser,
				"GENERATOR",
			);

			parser.state.hasHoistedVars = oldhasHoistedVars;
			parser.state.labels = oldLabels;
		}

		___R$project$rome$$internal$js$parser$parser_ts$popScope(parser, "ASYNC");
		___R$project$rome$$internal$js$parser$parser_ts$popScope(
			parser,
			"PARAMETERS",
		);

		return {body, hasHoistedVars};
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$checkFunctionNameAndParams(
		parser,
		opts,
		body,
		force,
	) {
		const {isArrowFunction, isMethod, id, rest, start, params} = opts;

		if (
			!___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$isSimpleParamList(
				params,
				rest,
			) &&
			body.type === "JSBlockStatement" &&
			body.directives !== undefined
		) {
			const firstDirective = body.directives[0];
			if (firstDirective !== undefined && firstDirective.value === "use strict") {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						loc: firstDirective.loc,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.STRICT_DIRECTIVE_IN_NON_SIMPLE_PARAMS,
					},
				);
			}
		}

		const startIndex = parser.getIndexFromPosition(start, parser.filename);
		if (
			isArrowFunction &&
			force !== true &&
			parser.state.noArrowParamsConversionAt.includes(startIndex)
		) {
			return undefined;
		}

		// If this is a strict mode function, verify that argument names
		// are not repeated, and it does not try to bind the words `eval`
		const _isStrictBody = ___R$project$rome$$internal$js$parser$parser$expression_ts$isStrictBody(
			parser,
			body,
		);
		const isStrict =
			___R$project$rome$$internal$js$parser$parser_ts$inScope(parser, "STRICT") ||
			_isStrictBody;

		const isSimpleParams = ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$isSimpleParamList(
			params,
			rest,
		);
		const shouldCheckLVal =
			isStrict || isArrowFunction || isMethod || !isSimpleParams;

		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"STRICT",
			isStrict,
		);

		if (shouldCheckLVal) {
			const clashes = new Map();

			if (id !== undefined) {
				___R$project$rome$$internal$js$parser$parser$lval_ts$checkLVal(
					parser,
					id,
					true,
					undefined,
					"function name",
				);
			}

			for (const param of params) {
				if (_isStrictBody && param.type !== "JSBindingIdentifier") {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							loc: param.loc,
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.NON_SIMPLE_PARAM_IN_EXPLICIT_STRICT_FUNCTION,
						},
					);
				}
				___R$project$rome$$internal$js$parser$parser$lval_ts$checkLVal(
					parser,
					param,
					true,
					clashes,
					"function parameter list",
				);
			}
		}

		___R$project$rome$$internal$js$parser$parser_ts$popScope(parser, "STRICT");
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$isSimpleParamList(
		params,
		rest,
	) {
		if (rest !== undefined) {
			return false;
		}

		for (const param of params) {
			if (param.type !== "JSBindingIdentifier") {
				return false;
			}
		}

		return true;
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionList(
		parser,
		context,
		openContext,
		allowEmpty,
		refShorthandDefaultPos,
	) {
		const elts = [];
		let first = true;

		while (true) {
			if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					openContext.close,
				) ||
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eof,
				)
			) {
				break;
			}

			if (first) {
				first = false;
			} else {
				___R$project$rome$$internal$js$parser$parser_ts$expect(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
				);

				if (
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						openContext.close,
					)
				) {
					break;
				}
			}

			elts.push(
				___R$project$rome$$internal$js$parser$parser$expression_ts$parseCallArgument(
					parser,
					context,
					allowEmpty,
					refShorthandDefaultPos,
				),
			);
		}

		___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
			parser,
			openContext,
		);

		return elts;
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionListNonEmpty(
		parser,
		context,
		openContext,
		refShorthandDefaultPos,
	) {
		const val = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionList(
			parser,
			context,
			openContext,
			false,
			refShorthandDefaultPos,
		);
		// @ts-ignore: Passed allowEmpty: false above
		return val;
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseCallArgument(
		parser,
		context,
		allowHoles = false,
		refShorthandDefaultPos,
		refNeedsArrowPos,
		refTrailingCommaPos,
	) {
		if (
			allowHoles &&
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
			)
		) {
			return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseArrayHole(
				parser,
			);
		} else if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.ellipsis,
			)
		) {
			const spreadNodeStart = parser.state.startPos;

			const elt = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseParenItem(
				parser,
				___R$project$rome$$internal$js$parser$parser$lval_ts$parseSpread(
					parser,
					refShorthandDefaultPos,
					refNeedsArrowPos,
				),
				spreadNodeStart,
			);

			if (
				refTrailingCommaPos &&
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
				)
			) {
				refTrailingCommaPos.index = parser.getIndex();
			}

			return elt;
		} else {
			return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeAssign(
				parser,
				context,
				false,
				refShorthandDefaultPos,
				___R$project$rome$$internal$js$parser$parser$expression_ts$parseParenItem,
				refNeedsArrowPos,
			);
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier(
		parser,
		liberal,
	) {
		const start = parser.getPosition();
		const name = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifierName(
			parser,
			liberal,
		);
		return ___R$project$rome$$internal$js$parser$parser$expression_ts$createIdentifier(
			parser,
			start,
			name,
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseBindingIdentifier(
		parser,
		liberal,
	) {
		return ___R$project$rome$$internal$js$parser$parser$expression_ts$toBindingIdentifier(
			parser,
			___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier(
				parser,
				liberal,
			),
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseReferenceIdentifier(
		parser,
		liberal,
	) {
		return ___R$project$rome$$internal$js$parser$parser$expression_ts$toReferenceIdentifier(
			parser,
			___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier(
				parser,
				liberal,
			),
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseTSConstKeyword(
		parser,
	) {
		return ___R$project$rome$$internal$js$parser$parser$expression_ts$toTSConstKeyword(
			parser,
			___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier(
				parser,
			),
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$toTSConstKeyword(
		parser,
		node,
	) {
		return parser.finalizeNode(
			Object.assign({}, node, {type: "TSConstKeyword"}),
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$toBindingIdentifier(
		parser,
		node,
	) {
		return parser.finalizeNode(
			Object.assign({}, node, {type: "JSBindingIdentifier"}),
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$toAssignmentIdentifier(
		parser,
		node,
	) {
		return parser.finalizeNode(
			Object.assign({}, node, {type: "JSAssignmentIdentifier"}),
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$toReferenceIdentifier(
		parser,
		node,
	) {
		return parser.finalizeNode(
			Object.assign({}, node, {type: "JSReferenceIdentifier"}),
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$toIdentifier(
		parser,
		node,
	) {
		return Object.assign({}, node, {type: "JSIdentifier"});
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$createIdentifier(
		parser,
		start,
		name,
	) {
		const node = parser.finishNode(
			start,
			{
				type: "JSIdentifier",
				name,
			},
		);
		parser.getLoc(node).identifierName = name;
		return node;
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifierName(
		parser,
		liberal = false,
	) {
		const loc = parser.finishLocAt(parser.state.startPos, parser.state.endPos);

		if (!liberal) {
			___R$project$rome$$internal$js$parser$parser$expression_ts$checkReservedWord(
				parser,
				String(parser.state.tokenValue),
				loc,
				!!parser.state.tokenType.keyword,
				false,
			);
		}

		let name;

		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name,
			)
		) {
			name = String(parser.state.tokenValue);
		} else if (parser.state.tokenType.keyword !== undefined) {
			name = parser.state.tokenType.keyword;

			// `class` and `function` keywords push new context into this.context.
			// But there is no chance to pop the context if the keyword is consumed
			// as an identifier such as a property name.
			// If the previous token is a dot, this does not apply because the
			// context-managing code already ignored the keyword
			if (
				(name === "class" || name === "function") &&
				(parser.state.lastEndIndex !==
				___R$project$rome$$internal$ob1$index_ts$ob1Inc(
					parser.state.lastStartIndex,
				) ||
				parser.input.charCodeAt(
					___R$project$rome$$internal$ob1$index_ts$ob1Get0(
						parser.state.lastStartIndex,
					),
				) !== ___R$project$rome$$internal$string$charcodes$index_ts.dot)
			) {
				parser.state.context.pop();
			}
		} else {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.EXPECTED_IDENTIFIER,
				},
			);
			name = "";
		}

		if (!liberal) {
			___R$project$rome$$internal$js$parser$parser$expression_ts$checkReservedWord(
				parser,
				name,
				loc,
				parser.state.tokenType.keyword !== undefined,
				false,
			);
		}

		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		return name;
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$checkReservedWord(
		parser,
		word,
		loc,
		checkKeywords,
		isBinding,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$isSyntaxEnabled(
				parser,
				"ts",
			)
		) {
			// TypeScript support in Babel disables reserved word checking...
			// This is mostly because TS allows reserved words in certain scenarios
			// TODO we should just allow those rather than relying on this hack
			return undefined;
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$inScope(
				parser,
				"GENERATOR",
			) &&
			word === "yield"
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					loc,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.YIELD_NAME_IN_GENERATOR,
				},
			);
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$inScope(parser, "ASYNC") &&
			word === "await"
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					loc,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.AWAIT_NAME_IN_ASYNC,
				},
			);
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$inScope(
				parser,
				"CLASS_PROPERTY",
			) &&
			word === "arguments"
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					loc,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.ARGUMENTS_IN_CLASS_FIELD,
				},
			);
		}

		if (
			checkKeywords &&
			___R$project$rome$$internal$js$parser$utils$identifier_ts$isKeyword(word)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					loc,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.UNEXPECTED_KEYWORD(
						word,
					),
				},
			);
		}

		let isReserved;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$inScope(parser, "STRICT")
		) {
			if (isBinding) {
				isReserved = ___R$project$rome$$internal$js$parser$utils$identifier_ts$isStrictBindReservedWord(
					word,
					parser.meta.inModule,
				);
			} else {
				isReserved = ___R$project$rome$$internal$js$parser$utils$identifier_ts$isStrictReservedWord(
					word,
					parser.meta.inModule,
				);
			}
		} else {
			isReserved = ___R$project$rome$$internal$js$parser$utils$identifier_ts$isReservedWord(
				word,
				parser.meta.inModule,
			);
		}

		if (isReserved) {
			if (
				!___R$project$rome$$internal$js$parser$parser_ts$inScope(
					parser,
					"ASYNC",
				) &&
				word === "await"
			) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						loc,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.AWAIT_OUTSIDE_ASYNC,
					},
				);
			} else {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						loc,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.RESERVED_WORD(
							word,
						),
					},
				);
			}
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseAwait(
		parser,
	) {
		if (!parser.state.awaitPos) {
			parser.state.awaitPos = parser.state.index;
		}

		if (
			!___R$project$rome$$internal$js$parser$parser_ts$inScope(parser, "ASYNC")
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.AWAIT_OUTSIDE_ASYNC,
				},
			);
		}

		const start = parser.getPosition();
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);

		if (
			___R$project$rome$$internal$js$parser$parser_ts$inScope(
				parser,
				"PARAMETERS",
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.AWAIT_IN_ASYNC_PARAMS,
				},
			);
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.star,
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					start,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.AWAIT_STAR,
				},
			);
		}

		const argument = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeUnary(
			parser,
			"await argument",
		);
		return parser.finishNode(start, {type: "JSAwaitExpression", argument});
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseYield(
		parser,
		noIn,
	) {
		if (!parser.state.yieldPos) {
			parser.state.yieldPos = parser.state.index;
		}

		const start = parser.getPosition();

		if (
			___R$project$rome$$internal$js$parser$parser_ts$inScope(
				parser,
				"PARAMETERS",
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					start,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.YIELD_IN_GENERATOR_PARAMS,
				},
			);
		}

		if (
			parser.state.maybeInArrowParameters &&
			// We only set yieldInPossibleArrowParameters if we haven't already
			// found a possible invalid JSYieldExpression.
			parser.state.yieldInPossibleArrowParameters === undefined
		) {
			parser.state.yieldInPossibleArrowParameters = start;
		}

		___R$project$rome$$internal$js$parser$parser_ts$next(parser);

		let delegate;
		let argument;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.semi,
			) ||
			(!___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.star,
			) &&
			!parser.state.tokenType.startsExpr) ||
			___R$project$rome$$internal$js$parser$parser_ts$canInsertSemicolon(parser)
		) {
			delegate = false;
		} else {
			delegate = ___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.star,
			);
			argument = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeAssign(
				parser,
				"yield argument",
				noIn,
			);
		}

		return parser.finishNode(
			start,
			{
				type: "JSYieldExpression",
				delegate,
				argument,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$parseNullLiteral(
		parser,
	) {
		const start = parser.getPosition();
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		return parser.finishNode(start, {type: "JSNullLiteral"});
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseStringLiteral(
		parser,
	) {
		const start = parser.getPosition();
		const value = String(parser.state.tokenValue);
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		return parser.finishNode(
			start,
			{
				type: "JSStringLiteral",
				value,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$parseBigIntLiteral(
		parser,
	) {
		const start = parser.getPosition();
		const value = String(parser.state.tokenValue);
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		return parser.finishNode(
			start,
			{
				type: "JSBigIntLiteral",
				value,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseNumericLiteral(
		parser,
	) {
		const start = parser.getPosition();
		const {tokenValue} = parser.state;
		if (
			!(tokenValue instanceof
			___R$project$rome$$internal$js$parser$tokenizer$index_ts$NumberTokenValue)
		) {
			throw new Error("Expected NumberTokenValue");
		}

		const {value, format} = tokenValue;
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		return parser.finishNode(
			start,
			{
				type: "JSNumericLiteral",
				format,
				value,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$parseRegExpLiteral(
		parser,
	) {
		const start = parser.getPosition();
		const value = parser.state.tokenValue;
		if (
			!(value instanceof
			___R$project$rome$$internal$js$parser$tokenizer$index_ts$RegExpTokenValue)
		) {
			throw new Error("Expected regex token value");
		}
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);

		const {flags, pattern} = value;

		const {diagnostics, expression} = ___R$project$rome$$internal$codec$js$regexp$index_ts$parseRegExp({
			// Advance past first slash
			offsetPosition: {
				line: start.line,
				column: ___R$project$rome$$internal$ob1$index_ts$ob1Inc(start.column),
			},
			path: parser.filename,
			input: pattern,
			unicode: flags.has("u"),
		});

		for (const diagnostic of diagnostics) {
			parser.addDiagnostic(diagnostic);
		}

		return parser.finishNode(
			start,
			{
				type: "JSRegExpLiteral",
				expression,
				global: flags.has("g"),
				multiline: flags.has("m"),
				sticky: flags.has("y"),
				insensitive: flags.has("i"),
				noDotNewline: flags.has("s"),
				unicode: flags.has("u"),
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$parseImportOrMetaProperty(
		parser,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$lookaheadState(parser).tokenType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.dot
		) {
			return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseImportMetaProperty(
				parser,
			);
		} else {
			return ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$parseImportCall(
				parser,
			);
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$parseImportCall(
		parser,
	) {
		___R$project$rome$$internal$js$parser$parser_ts$expect(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._import,
		);

		const start = parser.getPosition();
		const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR,
			"array",
		);

		let argument;

		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR,
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.IMPORT_EXACT_ARGUMENTS,
				},
			);

			argument = ___R$project$rome$$internal$js$parser$parser$expression_ts$toReferenceIdentifier(
				parser,
				___R$project$rome$$internal$js$parser$parser_ts$createUnknownIdentifier(
					parser,
					"import call argument",
				),
			);
		} else {
			const callArg = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseCallArgument(
				parser,
				"call expression argument",
				false,
			);
			if (callArg.type === "JSArrayHole") {
				throw new Error(
					"Expected argument, parseExpressionListItem was passed maybeAllowEmpty: false",
				);
			} else {
				argument = callArg;
			}
		}

		// TODO warn on multiple arguments
		if (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					start: parser.state.lastStartPos,
					end: parser.state.lastEndPos,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.IMPORT_TRAILING_COMMA,
				},
			);
		}

		if (argument.type === "JSSpreadElement") {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					loc: argument.loc,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.IMPORT_SPREAD,
				},
			);
		}

		___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
			parser,
			openContext,
		);

		const spreadOrExpression =
			argument.type === "JSAmbiguousFlowTypeCastExpression"
				? argument.expression
				: argument;

		const expression =
			spreadOrExpression.type === "JSSpreadElement"
				? spreadOrExpression.argument
				: spreadOrExpression;

		return parser.finishNode(
			start,
			{type: "JSImportCall", argument: expression},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$parseSuper(
		parser,
	) {
		if (
			!___R$project$rome$$internal$js$parser$parser_ts$inScope(parser, "METHOD") &&
			!___R$project$rome$$internal$js$parser$parser_ts$inScope(
				parser,
				"CLASS_PROPERTY",
			) &&
			parser.options.sourceType !== "template"
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.SUPER_OUTSIDE_METHOD,
				},
			);
		}

		const start = parser.getPosition();
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);

		if (
			!___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
			) &&
			!___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketL,
			) &&
			!___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.dot,
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.INVALID_SUPER_SUFFIX,
				},
			);
		}

		const loc = parser.finishLoc(start);

		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
			) &&
			(___R$project$rome$$internal$js$parser$parser_ts$getLastScope(
				parser,
				"METHOD",
			) !== "constructor" ||
			___R$project$rome$$internal$js$parser$parser_ts$getLastScope(
				parser,
				"CLASS",
			) !== "derived") &&
			parser.options.sourceType !== "template"
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					loc,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.SUPER_CALL_OUTSIDE_CONSTRUCTOR,
				},
			);
		}

		return parser.finalizeNode({
			type: "JSSuper",
			loc,
		});
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$parseDoExpression(
		parser,
	) {
		const start = parser.getPosition();
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		const oldLabels = parser.state.labels;
		parser.state.labels = [];
		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"FUNCTION",
			false,
		);
		const body = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseBlock(
			parser,
			false,
		);
		___R$project$rome$$internal$js$parser$parser_ts$popScope(parser, "FUNCTION");
		parser.state.labels = oldLabels;
		return parser.finishNode(
			start,
			{
				type: "JSDoExpression",
				body,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$expression_ts$parseArrayHole(
		parser,
	) {
		return parser.finishNode(
			parser.getPosition(),
			{
				type: "JSArrayHole",
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$expression_ts$parseArrayExpression(
		parser,
		refShorthandDefaultPos,
	) {
		const start = parser.getPosition();
		const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketL,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketR,
			"array",
		);

		const elements = ___R$project$rome$$internal$js$parser$parser$lval_ts$toReferencedListOptional(
			parser,
			___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionList(
				parser,
				"array element",
				openContext,
				true,
				refShorthandDefaultPos,
			),
		);

		return parser.finishNode(
			start,
			{
				type: "JSArrayExpression",
				elements,
			},
		);
	}


  // project-rome/@internal/js-parser/parser/lval.ts
const ___R$project$rome$$internal$js$parser$parser$lval_ts = {
		toAssignmentPattern: ___R$project$rome$$internal$js$parser$parser$lval_ts$toAssignmentPattern,
		toTargetAssignmentPattern: ___R$project$rome$$internal$js$parser$parser$lval_ts$toTargetAssignmentPattern,
		toTargetBindingPattern: ___R$project$rome$$internal$js$parser$parser$lval_ts$toTargetBindingPattern,
		toParamBindingPattern: ___R$project$rome$$internal$js$parser$parser$lval_ts$toParamBindingPattern,
		toBindingPattern: ___R$project$rome$$internal$js$parser$parser$lval_ts$toBindingPattern,
		toAssignmentObjectProperty: ___R$project$rome$$internal$js$parser$parser$lval_ts$toAssignmentObjectProperty,
		toAssignableList: ___R$project$rome$$internal$js$parser$parser$lval_ts$toAssignableList,
		toFunctionParamsBindingList: ___R$project$rome$$internal$js$parser$parser$lval_ts$toFunctionParamsBindingList,
		toReferencedList: ___R$project$rome$$internal$js$parser$parser$lval_ts$toReferencedList,
		toReferencedListOptional: ___R$project$rome$$internal$js$parser$parser$lval_ts$toReferencedListOptional,
		normalizeReferencedItem: ___R$project$rome$$internal$js$parser$parser$lval_ts$normalizeReferencedItem,
		filterSpread: ___R$project$rome$$internal$js$parser$parser$lval_ts$filterSpread,
		toReferencedListDeep: ___R$project$rome$$internal$js$parser$parser$lval_ts$toReferencedListDeep,
		toReferencedListDeepOptional: ___R$project$rome$$internal$js$parser$parser$lval_ts$toReferencedListDeepOptional,
		parseSpread: ___R$project$rome$$internal$js$parser$parser$lval_ts$parseSpread,
		parseTargetBindingPattern: ___R$project$rome$$internal$js$parser$parser$lval_ts$parseTargetBindingPattern,
		parseBindingList: ___R$project$rome$$internal$js$parser$parser$lval_ts$parseBindingList,
		parseBindingListNonEmpty: ___R$project$rome$$internal$js$parser$parser$lval_ts$parseBindingListNonEmpty,
		parseBindingListItem: ___R$project$rome$$internal$js$parser$parser$lval_ts$parseBindingListItem,
		parseBindingListItemTypes: ___R$project$rome$$internal$js$parser$parser$lval_ts$parseBindingListItemTypes,
		parseMaybeDefault: ___R$project$rome$$internal$js$parser$parser$lval_ts$parseMaybeDefault,
		checkLVal: ___R$project$rome$$internal$js$parser$parser$lval_ts$checkLVal,
		checkToRestConversion: ___R$project$rome$$internal$js$parser$parser$lval_ts$checkToRestConversion,
		hasCommaAfterRest: ___R$project$rome$$internal$js$parser$parser$lval_ts$hasCommaAfterRest,
		raiseRestNotLast: ___R$project$rome$$internal$js$parser$parser$lval_ts$raiseRestNotLast,
		checkCommaAfterRestFromSpread: ___R$project$rome$$internal$js$parser$parser$lval_ts$checkCommaAfterRestFromSpread,
	};
	const ___R$$priv$project$rome$$internal$js$parser$parser$lval_ts$VALID_REST_ARGUMENT_TYPES = [
		"JSIdentifier",
		"JSMemberExpression",
	];

	function ___R$project$rome$$internal$js$parser$parser$lval_ts$toAssignmentPattern(
		parser,
		node,
		contextDescription,
	) {
		switch (node.type) {
			case "JSAssignmentObjectPattern":
			case "JSAssignmentArrayPattern":
			case "JSAssignmentAssignmentPattern":
			case "JSAssignmentObjectPatternProperty":
			case "JSAssignmentIdentifier":
			case "JSMemberExpression":
				return node;

			case "JSAmbiguousFlowTypeCastExpression":
				return ___R$project$rome$$internal$js$parser$parser$lval_ts$toAssignmentPattern(
					parser,
					___R$project$rome$$internal$js$parser$parser$typescript_ts$ambiguousTypeCastToParameter(
						parser,
						node,
					),
					contextDescription,
				);

			case "JSBindingIdentifier":
			case "JSReferenceIdentifier":
				return ___R$project$rome$$internal$js$parser$parser$expression_ts$toAssignmentIdentifier(
					parser,
					node,
				);

			case "TSAsExpression":
				return Object.assign(
					{},
					node,
					{
						type: "TSAssignmentAsExpression",
						expression: ___R$project$rome$$internal$js$parser$parser$lval_ts$toTargetAssignmentPattern(
							parser,
							node.expression,
							contextDescription,
						),
					},
				);

			case "TSNonNullExpression":
				return Object.assign(
					{},
					node,
					{
						type: "TSAssignmentNonNullExpression",
						expression: ___R$project$rome$$internal$js$parser$parser$lval_ts$toTargetAssignmentPattern(
							parser,
							node.expression,
							contextDescription,
						),
					},
				);

			case "TSTypeAssertion":
				return Object.assign(
					{},
					node,
					{
						type: "TSAssignmentTypeAssertion",
						expression: ___R$project$rome$$internal$js$parser$parser$lval_ts$toTargetAssignmentPattern(
							parser,
							node.expression,
							contextDescription,
						),
					},
				);

			case "JSObjectExpression": {
				const props = [];
				let rest;
				for (let index = 0; index < node.properties.length; index++) {
					const prop = node.properties[index];
					if (prop.type === "JSSpreadProperty") {
						const arg = ___R$project$rome$$internal$js$parser$parser$lval_ts$toTargetAssignmentPattern(
							parser,
							prop.argument,
							contextDescription,
						);
						if (arg.type === "JSAssignmentIdentifier") {
							rest = arg;
						} else {
							___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
								parser,
								{
									loc: arg.loc,
									description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.INVALID_OBJECT_REST_ARGUMENT,
								},
							);
						}
						continue;
					}

					props.push(
						___R$project$rome$$internal$js$parser$parser$lval_ts$toAssignmentObjectProperty(
							parser,
							prop,
						),
					);
				}
				return {
					type: "JSAssignmentObjectPattern",
					loc: node.loc,
					properties: props,
					rest,
				};
			}

			case "JSArrayExpression": {
				const {list: elements, rest} = ___R$project$rome$$internal$js$parser$parser$lval_ts$toAssignableList(
					parser,
					node.elements,
					contextDescription,
				);
				return {
					type: "JSAssignmentArrayPattern",
					loc: node.loc,
					elements,
					rest,
				};
			}

			case "JSAssignmentExpression": {
				if (node.operator !== "=") {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							loc: parser.getLoc(node.left),
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.INVALID_ASSIGNMENT_PATTERN_OPERATOR,
						},
					);
				}

				return Object.assign(
					{},
					node,
					{
						type: "JSAssignmentAssignmentPattern",
						left: ___R$project$rome$$internal$js$parser$parser$lval_ts$toTargetAssignmentPattern(
							parser,
							node.left,
							contextDescription,
						),
						right: node.right,
						loc: node.loc,
					},
				);
			}

			default: {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						loc: node.loc,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.INVALID_LEFT_HAND_SIDE(
							contextDescription,
						),
					},
				);
				return ___R$project$rome$$internal$js$parser$parser$expression_ts$toAssignmentIdentifier(
					parser,
					___R$project$rome$$internal$js$parser$parser_ts$createUnknownIdentifier(
						parser,
						contextDescription,
					),
				);
			}
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$lval_ts$toTargetAssignmentPattern(
		parser,
		node,
		contextDescription,
	) {
		const binding = ___R$project$rome$$internal$js$parser$parser$lval_ts$toAssignmentPattern(
			parser,
			node,
			contextDescription,
		);

		switch (binding.type) {
			case "JSAssignmentIdentifier":
			case "JSAssignmentArrayPattern":
			case "JSAssignmentObjectPattern":
			case "JSMemberExpression":
			case "TSAssignmentAsExpression":
			case "TSAssignmentNonNullExpression":
			case "TSAssignmentTypeAssertion":
				return binding;

			default: {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						loc: node.loc,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.INVALID_ASSIGNMENT_TARGET,
					},
				);
				return {
					type: "JSAssignmentIdentifier",
					loc: node.loc,
					name: "X",
				};
			}
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$lval_ts$toTargetBindingPattern(
		parser,
		node,
		contextDescription,
	) {
		const binding = ___R$project$rome$$internal$js$parser$parser$lval_ts$toBindingPattern(
			parser,
			node,
			contextDescription,
		);

		switch (binding.type) {
			case "JSBindingIdentifier":
			case "JSBindingArrayPattern":
			case "JSBindingObjectPattern":
				return binding;

			default:
				// TODO return Unknown
				throw new Error("TODO " + binding.type);
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$lval_ts$toParamBindingPattern(
		parser,
		node,
		contextDescription,
	) {
		const binding = ___R$project$rome$$internal$js$parser$parser$lval_ts$toBindingPattern(
			parser,
			node,
			contextDescription,
		);

		switch (binding.type) {
			case "JSBindingIdentifier":
			case "JSBindingArrayPattern":
			case "JSBindingObjectPattern":
			case "JSBindingAssignmentPattern":
				return binding;

			default:
				// TODO return Unknown
				throw new Error("TODO " + binding.type);
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$lval_ts$toBindingPattern(
		parser,
		node,
		contextDescription,
	) {
		const binding = ___R$project$rome$$internal$js$parser$parser$lval_ts$toAssignmentPattern(
			parser,
			node,
			contextDescription,
		);

		if (binding.type === "JSMemberExpression") {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					loc: node.loc,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.BINDING_MEMBER_EXPRESSION,
				},
			);

			return {
				type: "JSBindingIdentifier",
				name: "X",
				loc: node.loc,
			};
		}

		switch (binding.type) {
			case "JSAssignmentObjectPattern": {
				const newNode = Object.assign(
					{},
					binding,
					{
						type: "JSBindingObjectPattern",
						rest: binding.rest === undefined
							? undefined
							: ___R$project$rome$$internal$js$parser$parser$expression_ts$toBindingIdentifier(
									parser,
									binding.rest,
								),
						properties: binding.properties.map((prop) => {
							const bindingProp = ___R$project$rome$$internal$js$parser$parser$lval_ts$toBindingPattern(
								parser,
								prop,
								contextDescription,
							);

							if (bindingProp.type !== "JSBindingObjectPatternProperty") {
								throw new Error("impossible condition");
							}

							return bindingProp;
						}),
					},
				);
				return newNode;
			}

			case "JSAssignmentAssignmentPattern": {
				const newNode = Object.assign(
					{},
					binding,
					{
						type: "JSBindingAssignmentPattern",
						left: ___R$project$rome$$internal$js$parser$parser$lval_ts$toTargetBindingPattern(
							parser,
							binding.left,
							contextDescription,
						),
					},
				);
				return newNode;
			}

			case "JSAssignmentArrayPattern": {
				const newNode = Object.assign(
					{},
					binding,
					{
						type: "JSBindingArrayPattern",
						elements: binding.elements.map((elem) =>
							elem.type === "JSArrayHole"
								? elem
								: ___R$project$rome$$internal$js$parser$parser$lval_ts$toParamBindingPattern(
										parser,
										elem,
										contextDescription,
									)
						),
						rest: binding.rest === undefined
							? undefined
							: ___R$project$rome$$internal$js$parser$parser$lval_ts$toTargetBindingPattern(
									parser,
									binding.rest,
									contextDescription,
								),
					},
				);
				return newNode;
			}

			case "JSAssignmentIdentifier": {
				const newNode = Object.assign(
					{},
					binding,
					{type: "JSBindingIdentifier"},
				);
				return newNode;
			}

			case "JSAssignmentObjectPatternProperty": {
				const newNode = Object.assign(
					{},
					binding,
					{
						type: "JSBindingObjectPatternProperty",
						value: ___R$project$rome$$internal$js$parser$parser$lval_ts$toBindingPattern(
							parser,
							binding.value,
							contextDescription,
						),
					},
				);
				return newNode;
			}

			default:
				throw new Error("Unknown node " + node.type);
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$lval_ts$toAssignmentObjectProperty(
		parser,
		prop,
	) {
		switch (prop.type) {
			case "JSObjectMethod": {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						loc: prop.key.loc,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.OBJECT_PATTERN_CANNOT_CONTAIN_METHODS,
					},
				);

				const fakeProp = {
					type: "JSAssignmentObjectPatternProperty",
					loc: prop.loc,
					key: {
						type: "JSStaticPropertyKey",
						value: {
							type: "JSIdentifier",
							name: "X",
							loc: prop.loc,
						},
						loc: prop.loc,
					},
					value: {
						type: "JSAssignmentIdentifier",
						name: "X",
						loc: prop.loc,
					},
				};

				return fakeProp;
			}

			case "JSObjectProperty":
				return Object.assign(
					{},
					prop,
					{
						type: "JSAssignmentObjectPatternProperty",
						value: ___R$project$rome$$internal$js$parser$parser$lval_ts$toAssignmentPattern(
							parser,
							prop.value,
							"assignment object property value",
						),
					},
				);

			default: {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						loc: prop.loc,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.INVALID_OBJECT_PATTERN_PROPERTY,
					},
				);
				return {
					type: "JSAssignmentObjectPatternProperty",
					loc: prop.loc,
					key: {
						type: "JSStaticPropertyKey",
						loc: prop.loc,
						value: {
							type: "JSIdentifier",
							loc: prop.loc,
							name: "X",
						},
					},
					value: {
						type: "JSAssignmentIdentifier",
						loc: prop.loc,
						name: "X",
					},
				};
			}
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$lval_ts$toAssignableList(
		parser,
		exprList,
		contextDescription,
	) {
		const newList = [];
		let rest;

		let end = exprList.length;

		// Validate last element
		if (end > 0) {
			let last = exprList[end - 1];

			if (last !== undefined && last.type === "JSSpreadElement") {
				const arg = ___R$project$rome$$internal$js$parser$parser$lval_ts$toTargetAssignmentPattern(
					parser,
					last.argument,
					contextDescription,
				);
				rest = arg;
				end--;
			}

			if (
				last !== undefined &&
				last.type === "JSAmbiguousFlowTypeCastExpression" &&
				last.expression.type === "JSSpreadElement"
			) {
				rest = ___R$project$rome$$internal$js$parser$parser$typescript_ts$ambiguousTypeCastToParameter(
					parser,
					Object.assign({}, last, {expression: last.expression.argument}),
				);
				end--;
			}
		}

		// Turn type casts that we found in function parameter head into type annotated params
		for (let i = 0; i < end; i++) {
			const expr = exprList[i];

			if (expr.type === "JSAmbiguousFlowTypeCastExpression") {
				exprList[i] = ___R$project$rome$$internal$js$parser$parser$typescript_ts$ambiguousTypeCastToParameter(
					parser,
					expr,
				);
			}

			if (expr.type === "TSAsExpression" || expr.type === "TSTypeAssertion") {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						loc: expr.loc,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TS_UNEXPECTED_CAST_IN_PARAMETER_POSITION,
					},
				);
			}
		}

		for (let i = 0; i < end; i++) {
			const elt = exprList[i];

			if (elt.type === "JSSpreadElement") {
				___R$project$rome$$internal$js$parser$parser$lval_ts$raiseRestNotLast(
					parser,
					parser.getLoc(elt),
				);
			}

			if (elt.type === "JSArrayHole") {
				newList.push(elt);
				continue;
			}

			const assign = ___R$project$rome$$internal$js$parser$parser$lval_ts$toAssignmentPattern(
				parser,
				elt,
				contextDescription,
			);
			newList.push(assign);
		}

		return {list: newList, rest};
	}

	function ___R$project$rome$$internal$js$parser$parser$lval_ts$toFunctionParamsBindingList(
		parser,
		exprList,
		contextDescription,
	) {
		const bindingList = [];

		const {list: assignmentList, rest: assignmentRest} = ___R$project$rome$$internal$js$parser$parser$lval_ts$toAssignableList(
			parser,
			exprList,
			contextDescription,
		);

		const bindingRest =
			assignmentRest === undefined
				? assignmentRest
				: ___R$project$rome$$internal$js$parser$parser$lval_ts$toTargetBindingPattern(
						parser,
						assignmentRest,
						contextDescription,
					);

		for (const item of assignmentList) {
			if (item === undefined) {
				// TODO should never happen?
				continue;
			}

			if (item.type === "JSAssignmentAssignmentPattern") {
				const binding = ___R$project$rome$$internal$js$parser$parser$lval_ts$toBindingPattern(
					parser,
					item,
					contextDescription,
				);
				if (binding.type !== "JSBindingAssignmentPattern") {
					throw new Error("TODO");
				}

				bindingList.push(binding);
				continue;
			}

			const binding = ___R$project$rome$$internal$js$parser$parser$lval_ts$toTargetBindingPattern(
				parser,
				item,
				contextDescription,
			);
			bindingList.push(binding);
		}

		return {params: bindingList, rest: bindingRest};
	}

	function ___R$project$rome$$internal$js$parser$parser$lval_ts$toReferencedList(
		parser,
		exprList,
		isParenthesizedExpr,
	) {
		for (let i = 0; i < exprList.length; i++) {
			const expr = exprList[i];
			exprList[i] = ___R$project$rome$$internal$js$parser$parser$lval_ts$normalizeReferencedItem(
				parser,
				expr,
				exprList.length > 1,
				isParenthesizedExpr,
			);
		}

		// @ts-ignore: We actually filtered them out
		return exprList;
	}

	function ___R$project$rome$$internal$js$parser$parser$lval_ts$toReferencedListOptional(
		parser,
		exprList,
		isParenthesizedExpr,
	) {
		for (let i = 0; i < exprList.length; i++) {
			const expr = exprList[i];
			if (expr.type !== "JSArrayHole") {
				exprList[i] = ___R$project$rome$$internal$js$parser$parser$lval_ts$normalizeReferencedItem(
					parser,
					expr,
					exprList.length > 1,
					isParenthesizedExpr,
				);
			}
		}

		// @ts-ignore: We actually filtered them out
		return exprList;
	}

	function ___R$project$rome$$internal$js$parser$parser$lval_ts$normalizeReferencedItem(
		parser,
		expr,
		multiple,
		isParenthesizedExpr,
	) {
		if (expr.type !== "JSAmbiguousFlowTypeCastExpression") {
			return expr;
		}

		___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
			parser,
			{
				loc: expr.loc,
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.FLOW_TYPE_CAST_IN_TS,
			},
		);

		if (
			!___R$project$rome$$internal$js$parser$parser_ts$isParenthesized(
				parser,
				expr,
			) &&
			(multiple || !isParenthesizedExpr)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					loc: expr.loc,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TYPE_CAST_EXPECTED_PARENS,
				},
			);
		}

		if (expr.optional) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					loc: expr.loc,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TYPE_CAST_CANNOT_BE_OPTIONAL,
				},
			);
		}

		const {typeAnnotation, expression} = expr;

		if (typeAnnotation === undefined) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					loc: expr.loc,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TYPE_CAST_WITHOUT_ANNOTATION,
				},
			);
			return expression;
		}

		return expression;
	}

	function ___R$project$rome$$internal$js$parser$parser$lval_ts$filterSpread(
		parser,
		elems,
	) {
		for (let i = 0; i < elems.length; i++) {
			const elem = elems[i];
			if (elem.type === "JSSpreadElement") {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.UNEXPECTED_SPREAD,
					},
				);

				elems[i] = ___R$project$rome$$internal$js$parser$parser$expression_ts$toReferenceIdentifier(
					parser,
					___R$project$rome$$internal$js$parser$parser_ts$createUnknownIdentifier(
						parser,
						"spread substitute",
					),
				);
			}
		}
		// @ts-ignore Technically wrong but we removed all JSSpreadElement
		return elems;
	}

	function ___R$project$rome$$internal$js$parser$parser$lval_ts$toReferencedListDeep(
		parser,
		exprList,
		isParenthesizedExpr,
	) {
		const refList = ___R$project$rome$$internal$js$parser$parser$lval_ts$toReferencedList(
			parser,
			exprList,
			isParenthesizedExpr,
		);
		___R$$priv$project$rome$$internal$js$parser$parser$lval_ts$toReferencedListDeepItems(
			parser,
			refList,
		);
		return refList;
	}

	function ___R$project$rome$$internal$js$parser$parser$lval_ts$toReferencedListDeepOptional(
		parser,
		exprList,
		isParenthesizedExpr,
	) {
		const refList = ___R$project$rome$$internal$js$parser$parser$lval_ts$toReferencedListOptional(
			parser,
			exprList,
			isParenthesizedExpr,
		);
		___R$$priv$project$rome$$internal$js$parser$parser$lval_ts$toReferencedListDeepItems(
			parser,
			refList,
		);
		return refList;
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$lval_ts$toReferencedListDeepItems(
		parser,
		exprList,
	) {
		for (let i = 0; i < exprList.length; i++) {
			const expr = exprList[i];
			if (expr.type === "JSArrayExpression") {
				___R$project$rome$$internal$js$parser$parser$lval_ts$toReferencedListDeepOptional(
					parser,
					expr.elements,
				);
			}
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$lval_ts$parseSpread(
		parser,
		refShorthandDefaultPos,
		refNeedsArrowPos,
	) {
		const start = parser.getPosition();
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);

		const argument = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeAssign(
			parser,
			"spread argument",
			false,
			refShorthandDefaultPos,
			undefined,
			refNeedsArrowPos,
		);

		if (
			___R$project$rome$$internal$ob1$index_ts$ob1Get0(
				parser.state.commaAfterSpreadAt,
			) === -1 &&
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
			)
		) {
			parser.state.commaAfterSpreadAt = parser.state.index;
		}

		return parser.finishNode(
			start,
			{
				type: "JSSpreadElement",
				argument,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$lval_ts$parseTargetBindingPattern(
		parser,
	) {
		switch (parser.state.tokenType) {
			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketL:
				return ___R$$priv$project$rome$$internal$js$parser$parser$lval_ts$parseArrayPattern(
					parser,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL:
				return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseObjectPattern(
					parser,
					___R$project$rome$$internal$js$parser$utils$location_ts$createIndexTracker(),
				);
		}

		return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseBindingIdentifier(
			parser,
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$lval_ts$parseArrayPattern(
		parser,
	) {
		const start = parser.getPosition();
		const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketL,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketR,
			"array pattern",
		);
		const {list: elements, rest} = ___R$project$rome$$internal$js$parser$parser$lval_ts$parseBindingList(
			parser,
			openContext,
			true,
		);
		return parser.finishNode(
			start,
			{
				type: "JSBindingArrayPattern",
				elements,
				rest,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$lval_ts$parseBindingList(
		parser,
		openContext,
		allowHoles = false,
		allowTSModifiers = false,
	) {
		const elts = [];
		let rest;

		let first = true;
		while (true) {
			if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					openContext.close,
				) ||
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eof,
				)
			) {
				___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
					parser,
					openContext,
				);
				break;
			}

			if (first) {
				first = false;
			} else {
				if (
					!___R$project$rome$$internal$js$parser$parser_ts$eat(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
					)
				) {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.EXPECTED_COMMA_SEPARATOR(
								openContext.name,
							),
						},
					);
					break;
				}
			}

			if (
				allowHoles &&
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
				)
			) {
				elts.push(
					___R$project$rome$$internal$js$parser$parser$expression_ts$parseArrayHole(
						parser,
					),
				);
			} else if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					openContext.close,
				)
			) {
				___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
					parser,
					openContext,
				);
				break;
			} else if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.ellipsis,
				)
			) {
				___R$project$rome$$internal$js$parser$parser_ts$next(parser);

				rest = ___R$project$rome$$internal$js$parser$parser$lval_ts$parseBindingListItemTypes(
					parser,
					parser.getPosition(),
					___R$project$rome$$internal$js$parser$parser$lval_ts$parseTargetBindingPattern(
						parser,
					),
				);

				if (
					!___R$project$rome$$internal$js$parser$parser$lval_ts$hasCommaAfterRest(
						parser,
					)
				) {
					___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
						parser,
						openContext,
					);
					break;
				}
			} else {
				elts.push(
					___R$project$rome$$internal$js$parser$parser$lval_ts$parseBindingListItem(
						parser,
						allowTSModifiers,
					),
				);
			}
		}
		return {list: elts, rest};
	}

	function ___R$project$rome$$internal$js$parser$parser$lval_ts$parseBindingListNonEmpty(
		parser,
		openContext,
		allowTSModifiers,
	) {
		const list = ___R$project$rome$$internal$js$parser$parser$lval_ts$parseBindingList(
			parser,
			openContext,
			false,
			allowTSModifiers,
		);
		// @ts-ignore: Need to make this more explicit we set `allowEmpty: false` above
		return list;
	}

	function ___R$project$rome$$internal$js$parser$parser$lval_ts$parseBindingListItem(
		parser,
		allowTSModifiers,
	) {
		const start = parser.getPosition();

		let accessibility;
		let readonly = false;
		if (allowTSModifiers) {
			accessibility = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSAccessModifier(
				parser,
			);
			readonly = ___R$project$rome$$internal$js$parser$parser$typescript_ts$hasTSModifier(
				parser,
				["readonly"],
			);
		}

		const left = ___R$project$rome$$internal$js$parser$parser$lval_ts$parseBindingListItemTypes(
			parser,
			start,
			___R$project$rome$$internal$js$parser$parser$lval_ts$parseTargetBindingPattern(
				parser,
			),
		);
		const elt = ___R$project$rome$$internal$js$parser$parser$lval_ts$parseMaybeDefault(
			parser,
			start,
			left,
		);

		if (accessibility !== undefined || readonly) {
			if (
				!___R$project$rome$$internal$js$parser$parser_ts$isSyntaxEnabled(
					parser,
					"ts",
				)
			) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TS_DISABLED_BUT_ACCESSIBILITY_OR_READONLY,
					},
				);
			}

			if (
				elt.type !== "JSBindingIdentifier" &&
				elt.type !== "JSBindingAssignmentPattern"
			) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						start,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TS_PARAMETER_PROPERTY_BINDING_PATTERN,
					},
				);
			}

			return parser.finishNode(
				start,
				Object.assign(
					{},
					elt,
					{
						meta: parser.finishNode(
							start,
							{
								type: "JSPatternMeta",
								accessibility,
								readonly,
							},
						),
					},
				),
			);
		}

		return elt;
	}

	function ___R$project$rome$$internal$js$parser$parser$lval_ts$parseBindingListItemTypes(
		parser,
		start,
		param,
	) {
		let typeAnnotation;
		let optional;

		if (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.question,
			)
		) {
			if (param.type !== "JSBindingIdentifier") {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						loc: param.loc,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TYPE_BINDING_PARAMETER_OPTIONAL,
					},
				);
			}

			optional = true;
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			typeAnnotation = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
				parser,
				true,
			);
		}

		return parser.finalizeNode(
			Object.assign(
				{},
				param,
				{
					meta: parser.finishNode(
						start,
						{
							type: "JSPatternMeta",
							optional,
							typeAnnotation,
						},
					),
				},
			),
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$lval_ts$parseMaybeDefault(
		parser,
		start = parser.getPosition(),
		left = ___R$project$rome$$internal$js$parser$parser$lval_ts$parseTargetBindingPattern(
			parser,
		),
	) {
		let target;

		if (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eq,
			)
		) {
			const right = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeAssign(
				parser,
				"assignment pattern right",
			);
			const assign = parser.finishNode(
				start,
				{
					type: "JSBindingAssignmentPattern",
					left,
					right,
				},
			);
			target = assign;
		} else {
			target = left;
		}

		if (
			target.type === "JSBindingAssignmentPattern" &&
			target.meta !== undefined &&
			target.meta.typeAnnotation !== undefined &&
			___R$project$rome$$internal$parser$core$utils_ts$comparePositions(
				parser.getLoc(target.right).start,
				parser.getLoc(target.meta.typeAnnotation).start,
			) === -1
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					loc: target.meta.typeAnnotation.loc,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TYPE_ANNOTATION_AFTER_ASSIGNMENT,
				},
			);
		}

		return target;
	}

	const ___R$$priv$project$rome$$internal$js$parser$parser$lval_ts$ALLOWED_PARENTHESIZED_LVAL_TYPES = [
		"JSIdentifier",
		"JSMemberExpression",
		"TSAsExpression",
		"TSTypeAssertion",
		"TSAssignmentTypeAssertion",
		"TSAssignmentAsExpression",
		"TSAssignmentNonNullExpression",
	];

	// Verify that a node is an lval — something that can be assigned
	// to.
	function ___R$project$rome$$internal$js$parser$parser$lval_ts$checkLVal(
		parser,
		expr,
		maybeIsBinding,
		checkClashes,
		contextDescription,
	) {
		const isBinding = maybeIsBinding === undefined ? false : maybeIsBinding;

		// Verify that nodes aren't parenthesized
		if (
			___R$project$rome$$internal$js$parser$parser_ts$isParenthesized(
				parser,
				expr,
			) &&
			!___R$$priv$project$rome$$internal$js$parser$parser$lval_ts$ALLOWED_PARENTHESIZED_LVAL_TYPES.includes(
				expr.type,
			)
		) {
			let patternType;
			if (expr.type === "JSBindingObjectPattern") {
				patternType = "object";
			}
			if (expr.type === "JSBindingArrayPattern") {
				patternType = "array";
			}
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.INVALID_PARENTEHSIZED_LVAL(
						patternType,
					),
					loc: expr.loc,
				},
			);
		}

		switch (expr.type) {
			case "TSAsExpression":
			case "TSNonNullExpression":
			case "TSTypeAssertion": {
				___R$project$rome$$internal$js$parser$parser$lval_ts$checkLVal(
					parser,
					expr.expression,
					isBinding,
					checkClashes,
					contextDescription,
				);
				return undefined;
			}

			case "JSBindingIdentifier":
			case "JSReferenceIdentifier":
			case "JSAssignmentIdentifier": {
				if (
					___R$project$rome$$internal$js$parser$parser_ts$inScope(
						parser,
						"STRICT",
					) &&
					___R$project$rome$$internal$js$parser$utils$identifier_ts$isStrictBindReservedWord(
						expr.name,
						parser.meta.inModule,
					)
				) {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							loc: expr.loc,
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.RESERVED_WORD(
								expr.name,
							),
						},
					);
				}

				if (checkClashes !== undefined) {
					const clash = checkClashes.get(expr.name);

					if (clash === undefined) {
						checkClashes.set(expr.name, expr);
					} else {
						___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
							parser,
							{
								description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.ARGUMENT_CLASH_IN_STRICT(
									expr.name,
									expr.loc,
								),
								loc: expr.loc,
							},
						);
					}
				}
				break;
			}

			case "JSAssignmentObjectPattern":
			case "JSBindingObjectPattern": {
				if (expr.rest !== undefined) {
					___R$project$rome$$internal$js$parser$parser$lval_ts$checkLVal(
						parser,
						expr.rest,
						isBinding,
						checkClashes,
						"rest property",
					);
				}

				for (let prop of expr.properties) {
					if (prop.type === "JSBindingObjectPatternProperty") {
						___R$project$rome$$internal$js$parser$parser$lval_ts$checkLVal(
							parser,
							prop.value,
							isBinding,
							checkClashes,
							"object destructuring pattern",
						);
					} else {
						___R$project$rome$$internal$js$parser$parser$lval_ts$checkLVal(
							parser,
							prop,
							isBinding,
							checkClashes,
							"object destructuring pattern",
						);
					}
				}
				break;
			}

			case "JSAssignmentObjectPatternProperty":
			case "JSBindingObjectPatternProperty":
				break;

			case "JSAssignmentArrayPattern":
			case "JSBindingArrayPattern": {
				if (expr.rest !== undefined) {
					___R$project$rome$$internal$js$parser$parser$lval_ts$checkLVal(
						parser,
						expr.rest,
						isBinding,
						checkClashes,
						"rest element",
					);
				}

				for (const elem of expr.elements) {
					___R$project$rome$$internal$js$parser$parser$lval_ts$checkLVal(
						parser,
						elem,
						isBinding,
						checkClashes,
						"array destructuring pattern",
					);
				}
				break;
			}

			case "JSBindingAssignmentPattern": {
				___R$project$rome$$internal$js$parser$parser$lval_ts$checkLVal(
					parser,
					expr.left,
					isBinding,
					checkClashes,
					"assignment pattern",
				);
				break;
			}
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$lval_ts$checkToRestConversion(
		parser,
		node,
	) {
		if (
			___R$$priv$project$rome$$internal$js$parser$parser$lval_ts$VALID_REST_ARGUMENT_TYPES.includes(
				node.argument.type,
			) ===
			false
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					loc: node.argument.loc,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.REST_INVALID_ARGUMENT,
				},
			);
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$lval_ts$hasCommaAfterRest(
		parser,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
			)
		) {
			___R$project$rome$$internal$js$parser$parser$lval_ts$raiseRestNotLast(
				parser,
			);
			return true;
		}

		return false;
	}

	function ___R$project$rome$$internal$js$parser$parser$lval_ts$raiseRestNotLast(
		parser,
		loc,
		start,
	) {
		___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
			parser,
			{
				start,
				loc,
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.DESTRUCTURING_REST_ELEMENT_NOT_LAST,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$lval_ts$checkCommaAfterRestFromSpread(
		parser,
	) {
		if (
			___R$project$rome$$internal$ob1$index_ts$ob1Get0(
				parser.state.commaAfterSpreadAt,
			) >
			-1
		) {
			___R$project$rome$$internal$js$parser$parser$lval_ts$raiseRestNotLast(
				parser,
				undefined,
				parser.getPositionFromIndex(parser.state.commaAfterSpreadAt),
			);
		}
	}


  // project-rome/@internal/js-parser/parser/jsx.ts
const ___R$project$rome$$internal$js$parser$parser$jsx_ts = {
		parseJSXText: ___R$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXText,
		parseJSXElement: ___R$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXElement,
	};
	// Indicates whether we should create a JSXIdentifier or a JSXReferenceIdentifier
	function ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$isHTMLElementName(
		tagName,
	) {
		return (
			/^[a-z]|-/.test(tagName) &&
			___R$project$rome$$internal$js$ast$utils$isValidIdentifierName_ts$isValidIdentifierName(
				tagName,
			)
		);
	}

	// Transforms JSX element name to string.
	function ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$getQualifiedJSXName(
		node,
	) {
		if (node === undefined) {
			return "";
		}

		switch (node.type) {
			case "JSXIdentifier":
			case "JSXReferenceIdentifier":
				return node.name;

			case "JSXNamespacedName":
				return node.namespace.name + ":" + node.name.name;

			case "JSXMemberExpression":
				return (
					___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$getQualifiedJSXName(
						node.object,
					) +
					"." +
					___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$getQualifiedJSXName(
						node.property,
					)
				);
		}
	}

	// Parse next token as JSX identifier
	function ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXIdentifier(
		parser,
	) {
		const start = parser.getPosition();
		let name;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.jsxName,
			)
		) {
			name = String(parser.state.tokenValue);
		} else if (parser.state.tokenType.keyword !== undefined) {
			name = parser.state.tokenType.keyword;
		} else {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.JSX_UNKNOWN_IDENTIFIER_TOKEN,
				},
			);
			name = "";
		}

		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		return parser.finishNode(
			start,
			{
				type: "JSXIdentifier",
				name,
			},
		);
	}

	// Parse namespaced identifier.
	function ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXNamespacedName(
		parser,
	) {
		const start = parser.getPosition();

		const namespace = ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXIdentifier(
			parser,
		);
		if (
			!___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			return namespace;
		}

		const name = ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXIdentifier(
			parser,
		);
		return parser.finishNode(
			start,
			{
				type: "JSXNamespacedName",
				name,
				namespace,
			},
		);
	}

	// Parses element name in any form - namespaced, member
	// or single identifier.
	function ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXElementName(
		parser,
	) {
		const start = parser.getPosition();

		const namespacedName = ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXNamespacedName(
			parser,
		);

		let node;
		if (
			namespacedName.type === "JSXIdentifier" &&
			!___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$isHTMLElementName(
				namespacedName.name,
			)
		) {
			node = Object.assign({}, namespacedName, {type: "JSXReferenceIdentifier"});
		} else {
			node = namespacedName;
		}

		while (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.dot,
			)
		) {
			const property = ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXIdentifier(
				parser,
			);
			node = parser.finishNode(
				start,
				{
					type: "JSXMemberExpression",
					object: node,
					property,
				},
			);
		}

		return node;
	}

	// Parses any type of JSX attribute value.
	function ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXAttributeValue(
		parser,
	) {
		let node;
		switch (parser.state.tokenType) {
			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL: {
				node = ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXExpressionContainer(
					parser,
				);
				if (node.expression.type === "JSXEmptyExpression") {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							loc: node.loc,
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.JSX_EMPTY_ATTRIBUTE_VALUE,
						},
					);
				}
				return node;
			}

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.jsxTagStart:
				return ___R$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXElement(
					parser,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.string:
				return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseStringLiteral(
					parser,
				);

			default: {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.JSX_INVALID_ATTRIBUTE_VALUE,
					},
				);
				return parser.finishNode(
					parser.getPosition(),
					{
						type: "JSStringLiteral",
						value: "?",
					},
				);
			}
		}
	}

	// JSXEmptyExpression is unique type since it doesn't actually parse anything,
	// and so it should start at the end of last read token (left brace) and finish
	// at the beginning of the next one (right brace).
	function ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXEmptyExpression(
		parser,
	) {
		return parser.finishNode(
			parser.state.lastEndPos,
			{
				type: "JSXEmptyExpression",
			},
		);
	}

	// Parse JSX spread child
	function ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXSpreadChild(
		parser,
	) {
		const start = parser.getPosition();
		const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
			"jsx spread child",
		);
		___R$project$rome$$internal$js$parser$parser_ts$expect(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.ellipsis,
		);
		const expression = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpression(
			parser,
			"jsx spread child expression",
		);
		___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
			parser,
			openContext,
		);

		return parser.finishNode(
			start,
			{
				type: "JSXSpreadChild",
				expression,
			},
		);
	}

	// Parses JSX expression enclosed into curly brackets.
	function ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXExpressionContainer(
		parser,
	) {
		const start = parser.getPosition();
		const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
			"jsx expression container",
		);
		let expression;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
			)
		) {
			expression = ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXEmptyExpression(
				parser,
			);
		} else {
			expression = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpression(
				parser,
				"jsx inner expression container",
			);
		}
		___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
			parser,
			openContext,
		);
		return parser.finishNode(
			start,
			{
				type: "JSXExpressionContainer",
				expression,
			},
		);
	}

	// Parses following JSX attribute name-value pair.
	function ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXAttribute(
		parser,
	) {
		const start = parser.getPosition();

		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL,
			)
		) {
			const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
				"jsx attribute spread",
			);
			___R$project$rome$$internal$js$parser$parser_ts$expect(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.ellipsis,
			);
			const argument = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeAssign(
				parser,
				"jsx attribute spread",
			);
			___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
				parser,
				openContext,
			);
			return parser.finishNode(
				start,
				{
					type: "JSXSpreadAttribute",
					argument,
				},
			);
		}

		const name = ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXNamespacedName(
			parser,
		);
		const value = ___R$project$rome$$internal$js$parser$parser_ts$eat(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eq,
		)
			? ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXAttributeValue(
					parser,
				)
			: undefined;
		return parser.finishNode(
			start,
			{
				type: "JSXAttribute",
				name,
				value,
			},
		);
	}

	// Parses JSX opening tag starting after "<".
	function ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXOpeningElementAt(
		parser,
		start,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.jsxTagEnd,
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$expect(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.jsxTagEnd,
			);
			return {
				typeArguments: undefined,
				name: undefined,
				loc: {
					filename: parser.filename,
					start,
					end: parser.getPosition(),
				},
				attributes: [],
				selfClosing: false,
			};
		}

		const attributes = [];
		const name = ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXElementName(
			parser,
		);

		let typeArguments;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$isRelational(parser, "<")
		) {
			if (
				!___R$project$rome$$internal$js$parser$parser_ts$isSyntaxEnabled(
					parser,
					"ts",
				)
			) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.JSX_ELEM_TYPE_ARGUMENTS_OUTSIDE_TS,
					},
				);
			}

			typeArguments = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeArguments(
				parser,
			);
		}

		// We need to check for isRelational('>') here as the above type arguments parsing can put the tokenizer

		// into an unusual state for: <foo<bar>></foo>
		while (
			!___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.slash,
			) &&
			!___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.jsxTagEnd,
			) &&
			!___R$project$rome$$internal$js$parser$parser_ts$atEOF(parser)
		) {
			attributes.push(
				___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXAttribute(
					parser,
				),
			);
		}
		const selfClosing = ___R$project$rome$$internal$js$parser$parser_ts$eat(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.slash,
		);
		if (
			!___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.jsxTagEnd,
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.JSX_UNCLOSED_SELF_CLOSING_TAG,
				},
			);
		}
		return {
			typeArguments,
			name,
			attributes,
			selfClosing,
			loc: parser.getLoc(name),
		};
	}

	// Parses JSX closing tag starting after "</".
	function ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXClosingElementAt(
		parser,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.jsxTagEnd,
			)
		) {
			return undefined;
		}

		const name = ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXElementName(
			parser,
		);

		if (
			!___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.jsxTagEnd,
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.JSX_UNCLOSED_CLOSING_TAG,
				},
			);
		}

		return name;
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$recoverFromUnclosedJSX(
		parser,
	) {
		// jsxOpenTag
		parser.state.context.pop();
		parser.state.exprAllowed = false;
	}

	// Parses entire JSX element, including it"s opening tag
	// (starting after "<"), attributes, contents and closing tag.
	function ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXElementAt(
		parser,
		start,
	) {
		const children = [];
		const openingDef = ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXOpeningElementAt(
			parser,
			start,
		);

		let closingNameLoc;
		let closingName;

		// Parse children for unclosed elements
		if (!openingDef.selfClosing) {
			contents: while (true) {
				switch (parser.state.tokenType) {
					case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.jsxTagStart: {
						const start = parser.getPosition();
						___R$project$rome$$internal$js$parser$parser_ts$next(parser);
						if (
							___R$project$rome$$internal$js$parser$parser_ts$eat(
								parser,
								___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.slash,
							)
						) {
							closingName = ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXClosingElementAt(
								parser,
							);
							closingNameLoc = {
								filename: parser.filename,
								start,
								end: parser.getPosition(),
							};
							break contents;
						}
						children.push(
							___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXElementAt(
								parser,
								start,
							),
						);
						break;
					}

					case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.jsxText: {
						children.push(
							___R$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXText(
								parser,
							),
						);
						break;
					}

					case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL: {
						if (
							___R$project$rome$$internal$js$parser$parser_ts$lookaheadState(
								parser,
							).tokenType ===
							___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.ellipsis
						) {
							children.push(
								___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXSpreadChild(
									parser,
								),
							);
						} else {
							children.push(
								___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXExpressionContainer(
									parser,
								),
							);
						}
						break;
					}

					case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eof: {
						___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
							parser,
							{
								description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.JSX_UNCLOSED_ELEMENT(
									___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$getQualifiedJSXName(
										openingDef.name,
									),
									openingDef.loc,
								),
							},
						);
						break contents;
					}

					default: {
						___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
							parser,
							{
								description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.JSX_UNKNOWN_CHILD_START(
									___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$getQualifiedJSXName(
										openingDef.name,
									),
									openingDef.loc,
								),
							},
						);

						// We don't need to do it for the tt.eof case above because nothing will ever be parsed after
						___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$recoverFromUnclosedJSX(
							parser,
						);

						break contents;
					}
				}
			}

			// Unclosed element, would have produced an error above but we still want to produce a valid AST and avoid the below error conditions
			if (closingNameLoc === undefined) {
				closingName = openingDef.name;
				closingNameLoc = openingDef.loc;
			}

			// Fragment open, element close
			if (openingDef.name === undefined && closingName !== undefined) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						loc: openingDef.loc,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.JSX_EXPECTED_CLOSING_FRAGMENT_TAG(
							___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$getQualifiedJSXName(
								openingDef.name,
							),
							openingDef.loc,
						),
					},
				);
			}

			// Element open, fragment close
			if (openingDef.name !== undefined && closingName === undefined) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						loc: openingDef.loc,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.JSX_EXPECTED_CLOSING_TAG(
							___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$getQualifiedJSXName(
								openingDef.name,
							),
							openingDef.loc,
						),
					},
				);
			}

			// Validate element names: Element open, element close
			if (openingDef.name !== undefined && closingName !== undefined) {
				if (
					___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$getQualifiedJSXName(
						closingName,
					) !==
					___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$getQualifiedJSXName(
						openingDef.name,
					)
				) {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							loc: openingDef.loc,
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.JSX_EXPECTED_CLOSING_TAG(
								___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$getQualifiedJSXName(
									openingDef.name,
								),
								openingDef.loc,
							),
						},
					);
				}
			}
		}

		___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$checkAccidentalFragment(
			parser,
		);

		const openingName = openingDef.name;
		if (openingName === undefined) {
			return parser.finishNode(
				start,
				{
					type: "JSXFragment",
					children,
				},
			);
		} else {
			return parser.finishNode(
				start,
				{
					type: "JSXElement",
					name: openingName,
					typeArguments: openingDef.typeArguments,
					attributes: openingDef.attributes,
					selfClosing: openingDef.selfClosing,
					children,
				},
			);
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$checkAccidentalFragment(
		parser,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.relational,
			) &&
			parser.state.tokenValue === "<"
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.UNWRAPPED_ADJACENT_JHX,
				},
			);
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXText(
		parser,
	) {
		// No need to assert syntax here because we wont get that far as parseJSXElement would have already been called
		const start = parser.getPosition();
		const value = String(parser.state.tokenValue);
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		return parser.finishNode(
			start,
			{
				type: "JSXText",
				value,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXElement(
		parser,
	) {
		// Only necessary here as this is the only JSX entry point
		if (
			!___R$project$rome$$internal$js$parser$parser_ts$isSyntaxEnabled(
				parser,
				"jsx",
			)
		) {
			if (
				___R$project$rome$$internal$js$parser$parser_ts$isSyntaxEnabled(
					parser,
					"ts",
				)
			) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.JSX_IN_TS_EXTENSION,
					},
				);
			} else {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.JSX_DISABLED,
					},
				);
			}
		}

		const start = parser.getPosition();
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		return ___R$$priv$project$rome$$internal$js$parser$parser$jsx_ts$parseJSXElementAt(
			parser,
			start,
		);
	}


  // project-rome/@internal/js-parser/parser/typescript.ts
const ___R$project$rome$$internal$js$parser$parser$typescript_ts = {
		parseTSModifier: ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSModifier,
		hasTSModifier: ___R$project$rome$$internal$js$parser$parser$typescript_ts$hasTSModifier,
		ambiguousTypeCastToParameter: ___R$project$rome$$internal$js$parser$parser$typescript_ts$ambiguousTypeCastToParameter,
		maybeParseTSTypeParameters: ___R$project$rome$$internal$js$parser$parser$typescript_ts$maybeParseTSTypeParameters,
		maybeParseTSTypeArguments: ___R$project$rome$$internal$js$parser$parser$typescript_ts$maybeParseTSTypeArguments,
		parseTSTypeParameters: ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeParameters,
		tryTSNextParseConstantContext: ___R$project$rome$$internal$js$parser$parser$typescript_ts$tryTSNextParseConstantContext,
		tsCheckLiteralForConstantContext: ___R$project$rome$$internal$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext,
		tryTSParseIndexSignature: ___R$project$rome$$internal$js$parser$parser$typescript_ts$tryTSParseIndexSignature,
		parseTSTypeOrTypePredicateAnnotation: ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation,
		parseTSTypeAnnotation: ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeAnnotation,
		parseTSTypeAssertion: ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeAssertion,
		parseTSHeritageClause: ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSHeritageClause,
		parseTSInterfaceDeclaration: ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSInterfaceDeclaration,
		parseTSTypeAlias: ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeAlias,
		tsNextThenParseType: ___R$project$rome$$internal$js$parser$parser$typescript_ts$tsNextThenParseType,
		parseTSEnumDeclaration: ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSEnumDeclaration,
		parseTSModuleBlock: ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSModuleBlock,
		parseTSModuleOrNamespaceDeclaration: ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSModuleOrNamespaceDeclaration,
		parseTSAmbientExternalModuleDeclaration: ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSAmbientExternalModuleDeclaration,
		parseTSImportEqualsDeclaration: ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSImportEqualsDeclaration,
		parseTSDeclare: ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSDeclare,
		parseTSTypeExpressionStatement: ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeExpressionStatement,
		parseTSAbstractClass: ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSAbstractClass,
		parseTSExportDefaultAbstractClass: ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSExportDefaultAbstractClass,
		parseTSTypeArguments: ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeArguments,
		isTSDeclarationStart: ___R$project$rome$$internal$js$parser$parser$typescript_ts$isTSDeclarationStart,
		parseTSAccessModifier: ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSAccessModifier,
		isTSAbstractClass: ___R$project$rome$$internal$js$parser$parser$typescript_ts$isTSAbstractClass,
		parseTSExport: ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSExport,
	};
	// Doesn't handle 'void' or 'null' because those are keywords, not identifiers.
	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$keywordTypeFromName(
		value,
	) {
		switch (value) {
			case "any":
				return "TSAnyKeywordTypeAnnotation";

			case "boolean":
				return "TSBooleanKeywordTypeAnnotation";

			case "bigint":
				return "TSBigIntKeywordTypeAnnotation";

			case "never":
				return "TSNeverKeywordTypeAnnotation";

			case "number":
				return "TSNumberKeywordTypeAnnotation";

			case "object":
				return "TSObjectKeywordTypeAnnotation";

			case "string":
				return "TSStringKeywordTypeAnnotation";

			case "symbol":
				return "TSSymbolKeywordTypeAnnotation";

			case "undefined":
				return "TSUndefinedKeywordTypeAnnotation";

			case "unknown":
				return "TSUnknownKeywordTypeAnnotation";

			default:
				return undefined;
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsIsIdentifier(
		parser,
	) {
		// TODO: actually a bit more complex in TypeScript, but shouldn't matter.
		// See https://github.com/Microsoft/TypeScript/issues/15008
		return ___R$project$rome$$internal$js$parser$parser_ts$match(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name,
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsNextTokenCanFollowModifier(
		parser,
	) {
		// Note: TypeScript's implementation is much more complicated because
		// more things are considered modifiers there.
		// This implementation only handles modifiers not handled by @babel/parser itself. And 'static'.
		// TODO: Would be nice to avoid lookahead. Want a hasLineBreakUpNext() method...
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		return (
			!___R$project$rome$$internal$js$parser$parser_ts$hasPrecedingLineBreak(
				parser,
			) &&
			!___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
			) &&
			!___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR,
			) &&
			!___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
			) &&
			!___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eq,
			) &&
			!___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.question,
			) &&
			!___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bang,
			)
		);
	}

	/** Parses a modifier matching one the given modifier names.*/
	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSModifier(
		parser,
		allowedModifiers,
	) {
		if (
			!___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name,
			)
		) {
			return undefined;
		}

		const start = parser.getPosition();

		// @ts-ignore: We are lying here but we validate it in all the correct places
		const modifier = String(parser.state.tokenValue);
		if (
			allowedModifiers.includes(modifier) &&
			___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tryTSParse(
				parser,
				___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsNextTokenCanFollowModifier,
			)
		) {
			___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$expectTSEnabled(
				parser,
				"access modifier",
				start,
			);
			return modifier;
		} else {
			return undefined;
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$hasTSModifier(
		parser,
		allowedModifiers,
	) {
		return (
			___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSModifier(
				parser,
				allowedModifiers,
			) !== undefined
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsIsListTerminator(
		parser,
		kind,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eof,
			)
		) {
			return true;
		}

		switch (kind) {
			case "EnumMembers":
			case "TypeMembers":
				return ___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
				);

			case "HeritageClauseElement":
				return ___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL,
				);

			case "TupleElementTypes":
				return ___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketR,
				);

			case "TypeParametersOrArguments":
				return ___R$project$rome$$internal$js$parser$parser_ts$isRelational(
					parser,
					">",
				);
		}

		throw new Error("Unreachable");
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$expectTSEnabled(
		parser,
		label,
		start = parser.getPosition(),
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$isSyntaxEnabled(
				parser,
				"ts",
			)
		) {
			return;
		}

		___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
			parser,
			{
				start,
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TS_REQUIRED(
					label,
				),
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSList(
		parser,
		kind,
		parseElement,
	) {
		const result = [];
		while (
			!___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsIsListTerminator(
				parser,
				kind,
			)
		) {
			// Skipping 'parseListElement' from the TS source since that's just for error handling.
			result.push(parseElement(parser));
		}
		return result;
	}

	/**
 * If !expectSuccess, returns undefined instead of failing to parse.
 * If expectSuccess, parseElement should always return a defined value.
 */
	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSDelimitedList(
		parser,
		kind,
		parseElement,
	) {
		const result = [];

		while (true) {
			if (
				___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsIsListTerminator(
					parser,
					kind,
				)
			) {
				break;
			}

			const element = parseElement(parser);
			if (element === undefined) {
				break;
			}

			result.push(element);

			if (
				___R$project$rome$$internal$js$parser$parser_ts$eat(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
				)
			) {
				continue;
			}

			if (
				___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsIsListTerminator(
					parser,
					kind,
				)
			) {
				break;
			}

			// This will fail with an error about a missing comma
			if (
				___R$project$rome$$internal$js$parser$parser_ts$expect(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
				)
			) {
				break;
			}
		}

		return result;
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSBracketedList(
		parser,
		kind,
		parseElement,
		bracket,
		skipFirstToken,
	) {
		if (!skipFirstToken) {
			if (bracket) {
				___R$project$rome$$internal$js$parser$parser_ts$expect(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketL,
				);
			} else {
				___R$project$rome$$internal$js$parser$parser_ts$expectRelational(
					parser,
					"<",
				);
			}
		}

		const result = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSDelimitedList(
			parser,
			kind,
			parseElement,
		);

		if (bracket) {
			___R$project$rome$$internal$js$parser$parser_ts$expect(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketR,
			);
		} else {
			___R$project$rome$$internal$js$parser$parser_ts$expectRelational(
				parser,
				">",
			);
		}

		return result;
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSImportType(
		parser,
	) {
		const start = parser.getPosition();
		___R$project$rome$$internal$js$parser$parser_ts$expect(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._import,
		);
		const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR,
			"ts import type",
		);

		if (
			!___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.string,
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TS_IMPORT_ARG_NOT_STRING,
				},
			);
		}

		const argument = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionAtom(
			parser,
			"ts import argument",
		);
		___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
			parser,
			openContext,
		);

		let qualifier;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.dot,
			)
		) {
			qualifier = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSEntityName(
				parser,
				/* allowReservedWords */ true,
			);
		}

		let typeParameters;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$isRelational(parser, "<")
		) {
			typeParameters = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeArguments(
				parser,
			);
		}

		return parser.finishNode(
			start,
			{
				type: "TSImportType",
				argument,
				qualifier,
				typeParameters,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSEntityName(
		parser,
		allowReservedWords,
	) {
		let entity = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseReferenceIdentifier(
			parser,
		);
		while (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.dot,
			)
		) {
			const start = parser.getLoc(entity).start;
			const right = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier(
				parser,
				allowReservedWords,
			);
			entity = parser.finishNode(
				start,
				{
					type: "TSQualifiedName",
					left: entity,
					right,
				},
			);
		}
		return entity;
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeReference(
		parser,
	) {
		const start = parser.getPosition();
		const typeName = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSEntityName(
			parser,
			/* allowReservedWords */ false,
		);
		let typeParameters;
		if (
			!___R$project$rome$$internal$js$parser$parser_ts$hasPrecedingLineBreak(
				parser,
			) &&
			___R$project$rome$$internal$js$parser$parser_ts$isRelational(parser, "<")
		) {
			typeParameters = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeArguments(
				parser,
			);
		}
		return parser.finishNode(
			start,
			{
				type: "TSTypeReference",
				typeName,
				typeParameters,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSThisTypePredicate(
		parser,
		lhs,
	) {
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		const start = parser.getLoc(lhs).start;
		const parameterName = lhs;
		const typeAnnotation = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
			parser,
			/* eatColon */ false,
		);

		return parser.finishNode(
			start,
			{
				type: "TSTypePredicate",
				asserts: false,
				parameterName,
				typeAnnotation,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSThisTypeNode(
		parser,
	) {
		const start = parser.getPosition();
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		return parser.finishNode(
			start,
			{
				type: "TSThisType",
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeQuery(
		parser,
	) {
		const start = parser.getPosition();
		___R$project$rome$$internal$js$parser$parser_ts$expect(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._typeof,
		);
		let exprName;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._import,
			)
		) {
			exprName = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSImportType(
				parser,
			);
		} else {
			exprName = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSEntityName(
				parser,
				/* allowReservedWords */ true,
			);
		}
		return parser.finishNode(
			start,
			{
				type: "TSTypeQuery",
				exprName,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$ambiguousTypeCastToParameter(
		parser,
		node,
	) {
		const start = parser.getPosition();
		const expr = ___R$project$rome$$internal$js$parser$parser$lval_ts$toTargetAssignmentPattern(
			parser,
			node.expression,
			"parameter",
		);

		const meta = parser.finishNode(
			start,
			{
				type: "JSPatternMeta",
				optional: node.optional,
				typeAnnotation: node.typeAnnotation,
			},
		);

		return parser.finishNode(
			start,
			Object.assign(
				{},
				expr,
				{
					// @ts-ignore
					meta,
				},
			),
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$maybeParseTSTypeParameters(
		parser,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$isRelational(parser, "<")
		) {
			return ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeParameters(
				parser,
			);
		} else {
			return undefined;
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$maybeParseTSTypeArguments(
		parser,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$isRelational(parser, "<")
		) {
			return ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeArguments(
				parser,
			);
		} else {
			return undefined;
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeParameter(
		parser,
	) {
		const start = parser.getPosition();
		___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$expectTSEnabled(
			parser,
			"type parameters",
			start,
		);

		const name = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifierName(
			parser,
		);
		const constraint = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsEatThenParseType(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._extends,
		);
		const _default = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsEatThenParseType(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eq,
		);
		return parser.finishNode(
			start,
			{
				type: "TSTypeParameter",
				name,
				constraint,
				default: _default,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tryParseTSTypeParameters(
		parser,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$isRelational(parser, "<")
		) {
			return ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeParameters(
				parser,
			);
		} else {
			return undefined;
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeParameters(
		parser,
	) {
		const start = parser.getPosition();

		___R$project$rome$$internal$js$parser$parser_ts$expectRelational(
			parser,
			"<",
		);

		const params = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSBracketedList(
			parser,
			"TypeParametersOrArguments",
			___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeParameter,
			/* bracket */ false,
			/* skipFirstToken */ true,
		);

		return parser.finishNode(
			start,
			{
				type: "TSTypeParameterDeclaration",
				params,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$tryTSNextParseConstantContext(
		parser,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$lookaheadState(parser).tokenType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._const
		) {
			___R$project$rome$$internal$js$parser$parser_ts$next(parser);
			return ___R$project$rome$$internal$js$parser$parser$expression_ts$parseTSConstKeyword(
				parser,
			);
		} else {
			return undefined;
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext(
		parser,
		node,
	) {
		switch (node.type) {
			case "JSStringLiteral":
			case "JSTemplateLiteral":
			case "JSNumericLiteral":
			case "JSBooleanLiteral":
			case "JSSpreadElement":
			case "JSObjectMethod":
			case "JSObjectExpression":
				break;

			case "JSArrayExpression": {
				for (const elem of node.elements) {
					if (elem) {
						___R$project$rome$$internal$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext(
							parser,
							elem,
						);
					}
				}
				break;
			}

			case "JSObjectProperty": {
				___R$project$rome$$internal$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext(
					parser,
					node.value,
				);
				break;
			}

			case "JSUnaryExpression": {
				___R$project$rome$$internal$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext(
					parser,
					node.argument,
				);
				break;
			}

			default:
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						loc: node.loc,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TS_CONSTANT_NOT_LITERAL,
					},
				);
		}
	}

	// Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,
	// but here it's always false, because parser.is only used for types.
	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSSignatureDeclarationMeta(
		parser,
		returnToken,
	) {
		const start = parser.getPosition();

		// Arrow fns *must* have return token (`=>`). Normal functions can omit it.
		const returnTokenRequired =
			returnToken ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.arrow;
		const typeParameters = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tryParseTSTypeParameters(
			parser,
		);
		const {list: parameters, rest} = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSBindingListForSignature(
			parser,
		);

		let typeAnnotation;
		if (returnTokenRequired) {
			typeAnnotation = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation(
				parser,
				returnToken,
			);
		} else if (
			___R$project$rome$$internal$js$parser$parser_ts$match(parser, returnToken)
		) {
			typeAnnotation = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation(
				parser,
				returnToken,
			);
		}

		return {
			typeAnnotation,
			meta: parser.finishNode(
				start,
				{
					type: "TSSignatureDeclarationMeta",
					typeParameters,
					parameters,
					rest,
				},
			),
		};
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSBindingListForSignature(
		parser,
	) {
		const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR,
			"ts signature parameters",
		);
		const {list: patterns, rest} = ___R$project$rome$$internal$js$parser$parser$lval_ts$parseBindingListNonEmpty(
			parser,
			openContext,
		);
		const validPatterns = [];

		for (const pattern of patterns) {
			if (
				pattern.type === "JSBindingIdentifier" ||
				pattern.type === "JSBindingObjectPattern" ||
				pattern.type === "JSBindingArrayPattern"
			) {
				validPatterns.push(pattern);
			} else {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						loc: pattern.loc,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TS_INVALID_SIGNATURE_BINDING_NODE,
					},
				);
			}
		}

		return {list: validPatterns, rest};
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeMemberSemicolon(
		parser,
	) {
		if (
			!___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$semicolon(parser);
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSConstructSignatureDeclaration(
		parser,
	) {
		const start = parser.getPosition();
		___R$project$rome$$internal$js$parser$parser_ts$expect(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._new,
		);
		const {meta, typeAnnotation} = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSSignatureDeclarationMeta(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
		);
		___R$project$rome$$internal$js$parser$parser_ts$semicolon(parser);
		return parser.finishNode(
			start,
			{
				type: "TSConstructSignatureDeclaration",
				meta,
				typeAnnotation,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSCallSignatureDeclaration(
		parser,
	) {
		const start = parser.getPosition();
		const {meta, typeAnnotation} = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSSignatureDeclarationMeta(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
		);
		___R$project$rome$$internal$js$parser$parser_ts$semicolon(parser);
		return parser.finishNode(
			start,
			{
				type: "TSCallSignatureDeclaration",
				meta,
				typeAnnotation,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsIsUnambiguouslyIndexSignature(
		parser,
	) {
		___R$project$rome$$internal$js$parser$parser_ts$next(parser); // Skip '{'
		return (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name,
			) &&
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
			)
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$tryTSParseIndexSignature(
		parser,
		start,
	) {
		if (
			!(___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketL,
			) &&
			___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$lookaheadTS(
				parser,
				___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsIsUnambiguouslyIndexSignature,
			))
		) {
			return undefined;
		}

		___R$project$rome$$internal$js$parser$parser_ts$expect(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketL,
		);

		const idStart = parser.getPosition();
		const id = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseBindingIdentifier(
			parser,
		);

		const keyTypeAnnotation = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
			parser,
		);
		const key = parser.finishNode(
			idStart,
			Object.assign(
				{},
				id,
				{
					meta: parser.finishNode(
						idStart,
						Object.assign(
							{},
							id.meta,
							{type: "JSPatternMeta", typeAnnotation: keyTypeAnnotation},
						),
					),
				},
			),
		);

		___R$project$rome$$internal$js$parser$parser_ts$expect(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketR,
		);

		const typeAnnotation = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tryTSParseTypeAnnotation(
			parser,
		);

		___R$project$rome$$internal$js$parser$parser_ts$semicolon(parser);
		return parser.finishNode(
			start,
			{
				type: "TSIndexSignature",
				typeAnnotation,
				key,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSPropertyOrMethodSignature(
		parser,
		start,
		readonly,
	) {
		const key = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseObjectPropertyKey(
			parser,
		);
		const optional = ___R$project$rome$$internal$js$parser$parser_ts$eat(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.question,
		);

		if (
			!readonly &&
			(___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
			) ||
			___R$project$rome$$internal$js$parser$parser_ts$isRelational(parser, "<"))
		) {
			const {meta, typeAnnotation} = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSSignatureDeclarationMeta(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
			);
			___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeMemberSemicolon(
				parser,
			);
			return parser.finishNode(
				start,
				{
					type: "TSMethodSignature",
					optional,
					meta,
					key,
					returnType: typeAnnotation,
				},
			);
		} else {
			const typeAnnotation = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tryTSParseTypeAnnotation(
				parser,
			);
			___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeMemberSemicolon(
				parser,
			);
			return parser.finishNode(
				start,
				{
					type: "TSPropertySignature",
					optional,
					readonly,
					typeAnnotation,
					key,
				},
			);
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeMember(
		parser,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
			) ||
			___R$project$rome$$internal$js$parser$parser_ts$isRelational(parser, "<")
		) {
			return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSCallSignatureDeclaration(
				parser,
			);
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._new,
			) &&
			___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$lookaheadTS(
				parser,
				___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsIsStartOfConstructSignature,
			)
		) {
			return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSConstructSignatureDeclaration(
				parser,
			);
		}

		const start = parser.getPosition();
		const readonly = ___R$project$rome$$internal$js$parser$parser$typescript_ts$hasTSModifier(
			parser,
			["readonly"],
		);

		const idx = ___R$project$rome$$internal$js$parser$parser$typescript_ts$tryTSParseIndexSignature(
			parser,
			start,
		);
		if (idx) {
			return Object.assign({}, idx, {readonly});
		}

		return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSPropertyOrMethodSignature(
			parser,
			start,
			readonly,
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsIsStartOfConstructSignature(
		parser,
	) {
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		return (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
			) ||
			___R$project$rome$$internal$js$parser$parser_ts$isRelational(parser, "<")
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSObjectTypeAnnotation(
		parser,
	) {
		const start = parser.getPosition();
		const members = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSObjectTypeMembers(
			parser,
		);
		return parser.finishNode(
			start,
			{
				type: "TSObjectTypeAnnotation",
				members,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSObjectTypeMembers(
		parser,
	) {
		const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
			"ts object type members",
		);
		const members = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSList(
			parser,
			"TypeMembers",
			___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeMember,
		);
		___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
			parser,
			openContext,
		);
		return members;
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsIsStartOfMappedType(
		parser,
	) {
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);

		if (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.plusMin,
			)
		) {
			return ___R$project$rome$$internal$js$parser$parser_ts$isContextual(
				parser,
				"readonly",
			);
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$isContextual(
				parser,
				"readonly",
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		}

		if (
			!___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketL,
			)
		) {
			return false;
		}

		___R$project$rome$$internal$js$parser$parser_ts$next(parser);

		if (
			!___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsIsIdentifier(
				parser,
			)
		) {
			return false;
		}

		___R$project$rome$$internal$js$parser$parser_ts$next(parser);

		return ___R$project$rome$$internal$js$parser$parser_ts$match(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._in,
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSMappedTypeParameter(
		parser,
	) {
		const start = parser.getPosition();
		const name = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifierName(
			parser,
		);
		const constraint = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsExpectThenParseType(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._in,
		);
		return parser.finishNode(
			start,
			{
				type: "TSTypeParameter",
				name,
				constraint,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$toPlusMin(
		val,
	) {
		const str = String(val);
		if (str === "+" || str === "-") {
			return str;
		} else {
			throw new Error("Expected +/-");
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSMappedType(
		parser,
	) {
		const start = parser.getPosition();

		const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
			"ts mapped type",
		);

		let readonly;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.plusMin,
			)
		) {
			readonly = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$toPlusMin(
				parser.state.tokenValue,
			);
			___R$project$rome$$internal$js$parser$parser_ts$next(parser);
			___R$project$rome$$internal$js$parser$parser_ts$expectContextual(
				parser,
				"readonly",
			);
		} else if (
			___R$project$rome$$internal$js$parser$parser_ts$eatContextual(
				parser,
				"readonly",
			)
		) {
			readonly = true;
		}

		const paramOpenContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketL,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketR,
			"ts mapped type parameter",
		);
		const typeParameter = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSMappedTypeParameter(
			parser,
		);
		___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
			parser,
			paramOpenContext,
		);

		let optional;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.plusMin,
			)
		) {
			optional = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$toPlusMin(
				parser.state.tokenValue,
			);
			___R$project$rome$$internal$js$parser$parser_ts$next(parser);
			___R$project$rome$$internal$js$parser$parser_ts$expect(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.question,
			);
		} else if (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.question,
			)
		) {
			optional = true;
		}

		const typeAnnotation = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tryTSParseType(
			parser,
		);
		___R$project$rome$$internal$js$parser$parser_ts$semicolon(parser);
		___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
			parser,
			openContext,
		);

		return parser.finishNode(
			start,
			{
				type: "TSMappedType",
				typeParameter,
				typeAnnotation,
				optional,
				readonly,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTupleType(
		parser,
	) {
		const start = parser.getPosition();
		const elementDefs = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSBracketedList(
			parser,
			"TupleElementTypes",
			___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTupleElementType,
			/* bracket */ true,
			/* skipFirstToken */ false,
		);

		// Validate the elementTypes to ensure:
		//   No mandatory elements may follow optional elements

		//   If there's a rest element, it must be at the end of the tuple
		let seenOptionalElement = false;
		const elementTypes = [];
		let rest;
		for (const {type, isRest} of elementDefs) {
			if (rest !== undefined) {
				// No elements should come after a rest, we should have already produced an error
				continue;
			}

			if (type.optional) {
				seenOptionalElement = true;
			} else if (seenOptionalElement && !isRest) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						loc: type.loc,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TS_REQUIRED_FOLLOWS_OPTIONAL,
					},
				);
			}

			if (isRest) {
				rest = type;
			} else {
				elementTypes.push(type);
			}
		}

		return parser.finishNode(
			start,
			{
				type: "TSTupleType",
				elementTypes,
				rest,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTupleElementTypeInner(
		parser,
	) {
		let typeAnnotation = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSType(
			parser,
		);
		let optional = ___R$project$rome$$internal$js$parser$parser_ts$eat(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.question,
		);
		let name;

		if (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			if (
				typeAnnotation.type === "TSTypeReference" &&
				typeAnnotation.typeName.type === "JSReferenceIdentifier"
			) {
				name = ___R$project$rome$$internal$js$parser$parser$expression_ts$toBindingIdentifier(
					parser,
					typeAnnotation.typeName,
				);
				typeAnnotation = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSType(
					parser,
				);
			} else {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						loc: typeAnnotation.loc,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TS_TUPLE_ELEMENT_LABEL_INCORRECT,
					},
				);
			}

			if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.question,
				)
			) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TS_TUPLE_ELEMENT_OPTIONAL_TRAILING,
					},
				);
				___R$project$rome$$internal$js$parser$parser_ts$next(parser);
				optional = true;
			}
		}

		return {
			typeAnnotation,
			optional,
			name,
		};
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTupleElementType(
		parser,
	) {
		const start = parser.getPosition();
		let isRest = false;
		let typeAnnotation;
		let optional;
		let name;

		// parses `...TsType[]`
		if (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.ellipsis,
			)
		) {
			isRest = true;
			({typeAnnotation, optional, name} = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTupleElementTypeInner(
				parser,
			));
			___R$project$rome$$internal$js$parser$parser$lval_ts$hasCommaAfterRest(
				parser,
			);
		} else {
			({typeAnnotation, optional, name} = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTupleElementTypeInner(
				parser,
			));
		}

		const elem = parser.finishNode(
			start,
			{
				type: "TSTupleElement",
				name,
				optional,
				typeAnnotation,
			},
		);

		if (optional && isRest) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					loc: elem.loc,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TS_TUPLE_ELEMENT_OPTIONAL_REST,
				},
			);
		}

		return {
			isRest,
			type: elem,
		};
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSParenthesizedType(
		parser,
	) {
		const start = parser.getPosition();
		const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR,
			"ts parenthesized type",
		);
		const typeAnnotation = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSType(
			parser,
		);
		___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
			parser,
			openContext,
		);
		return parser.finishNode(
			start,
			{
				type: "TSParenthesizedType",
				typeAnnotation,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSFunctionType(
		parser,
	) {
		const start = parser.getPosition();
		const {meta, typeAnnotation} = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSSignatureDeclarationMeta(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.arrow,
		);

		if (typeAnnotation === undefined) {
			throw new Error(
				"Type annotation return type required as we passed tt.arrow above",
			);
		}

		return parser.finishNode(
			start,
			{
				type: "TSFunctionType",
				meta,
				typeAnnotation,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSConstructorType(
		parser,
	) {
		const start = parser.getPosition();
		___R$project$rome$$internal$js$parser$parser_ts$expect(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._new,
		);

		const {meta, typeAnnotation} = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSSignatureDeclarationMeta(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.arrow,
		);

		if (typeAnnotation === undefined) {
			throw new Error(
				"Type annotation return type required as we passed tt.arrow above",
			);
		}

		return parser.finishNode(
			start,
			{
				type: "TSConstructorType",
				meta,
				typeAnnotation,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTemplateLiteralType(
		parser,
	) {
		const templateNode = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseTemplate(
			parser,
			false,
		);

		if (templateNode.expressions.length > 0) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					loc: parser.getLoc(templateNode.expressions[0]),
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TS_TEMPLATE_LITERAL_WITH_SUBSTITUION,
				},
			);
		}

		return {
			type: "TSTemplateLiteralTypeAnnotation",
			value: templateNode.quasis[0].raw,
			loc: templateNode.loc,
		};
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSNonArrayType(
		parser,
	) {
		switch (parser.state.tokenType) {
			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name:
			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._void:
			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._null: {
				let type;
				if (
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._void,
					)
				) {
					type = "TSVoidKeywordTypeAnnotation";
				} else if (
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._null,
					)
				) {
					type = "TSNullKeywordTypeAnnotation";
				} else {
					type = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$keywordTypeFromName(
						String(parser.state.tokenValue),
					);
				}

				if (
					type !== undefined &&
					___R$project$rome$$internal$js$parser$parser_ts$lookaheadState(parser).tokenType !==
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.dot
				) {
					const start = parser.getPosition();
					___R$project$rome$$internal$js$parser$parser_ts$next(parser);
					return parser.finishNode(
						start,
						({
							type,
						}),
					);
				}
				return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeReference(
					parser,
				);
			}

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.string:
			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.num:
			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._true:
			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._false:
			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.plusMin:
				return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSObjectTypeAnnotationAnnotation(
					parser,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._this: {
				const thisKeyword = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSThisTypeNode(
					parser,
				);
				if (
					___R$project$rome$$internal$js$parser$parser_ts$isContextual(
						parser,
						"is",
					) &&
					!___R$project$rome$$internal$js$parser$parser_ts$hasPrecedingLineBreak(
						parser,
					)
				) {
					return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSThisTypePredicate(
						parser,
						thisKeyword,
					);
				} else {
					return thisKeyword;
				}
			}

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._typeof:
				return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeQuery(
					parser,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._import:
				return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSImportType(
					parser,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL:
				if (
					___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$lookaheadTS(
						parser,
						___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsIsStartOfMappedType,
					)
				) {
					return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSMappedType(
						parser,
					);
				} else {
					return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSObjectTypeAnnotation(
						parser,
					);
				}

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketL:
				return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTupleType(
					parser,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL:
				return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSParenthesizedType(
					parser,
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.backQuote:
				return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTemplateLiteralType(
					parser,
				);
		}

		___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
			parser,
			{
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TS_UNKNOWN_NON_ARRAY_START,
			},
		);
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		return parser.finishNode(
			parser.getPosition(),
			{
				type: "TSTypeReference",
				typeName: ___R$project$rome$$internal$js$parser$parser$expression_ts$toReferenceIdentifier(
					parser,
					___R$project$rome$$internal$js$parser$parser_ts$createUnknownIdentifier(
						parser,
						"ts non array type start",
					),
				),
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSObjectTypeAnnotationAnnotation(
		parser,
	) {
		const start = parser.getPosition();

		switch (parser.state.tokenType) {
			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.string: {
				const value = String(parser.state.tokenValue);
				___R$project$rome$$internal$js$parser$parser_ts$next(parser);
				return parser.finishNode(
					start,
					{
						type: "TSStringLiteralTypeAnnotation",
						value,
					},
				);
			}

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.num: {
				const {tokenValue} = parser.state;
				if (
					!(tokenValue instanceof
					___R$project$rome$$internal$js$parser$tokenizer$index_ts$NumberTokenValue)
				) {
					throw new Error("Expected NumberTokenValue");
				}

				const {value, format} = tokenValue;
				___R$project$rome$$internal$js$parser$parser_ts$next(parser);
				return parser.finishNode(
					start,
					{
						type: "TSNumericLiteralTypeAnnotation",
						value,
						format,
					},
				);
			}

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._true:
			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._false: {
				const value = ___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._true,
				);
				___R$project$rome$$internal$js$parser$parser_ts$next(parser);
				return parser.finishNode(
					start,
					{
						type: "TSBooleanLiteralTypeAnnotation",
						value,
					},
				);
			}

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.plusMin: {
				const {tokenValue} = parser.state;
				if (tokenValue === "-") {
					___R$project$rome$$internal$js$parser$parser_ts$next(parser);

					if (
						!___R$project$rome$$internal$js$parser$parser_ts$match(
							parser,
							___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.num,
						)
					) {
						___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
							parser,
							{
								description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TYPE_NUMERIC_LITERAL_EXPECTED,
							},
						);
						___R$project$rome$$internal$js$parser$parser_ts$next(parser);
						return parser.finishNode(
							start,
							{
								type: "TSNumericLiteralTypeAnnotation",
								value: 0,
							},
						);
					}

					const {tokenValue} = parser.state;
					if (
						!(tokenValue instanceof
						___R$project$rome$$internal$js$parser$tokenizer$index_ts$NumberTokenValue)
					) {
						throw new Error("Expected NumberTokenValue");
					}

					const {value, format} = tokenValue;
					___R$project$rome$$internal$js$parser$parser_ts$next(parser);
					return parser.finishNode(
						start,
						{
							type: "TSNumericLiteralTypeAnnotation",
							value: -value,
							format,
						},
					);
				} else {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TYPE_NUMERIC_LITERAL_PLUS,
						},
					);
					___R$project$rome$$internal$js$parser$parser_ts$next(parser);

					if (
						!___R$project$rome$$internal$js$parser$parser_ts$match(
							parser,
							___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.num,
						)
					) {
						___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
							parser,
							{
								description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TYPE_NUMERIC_LITERAL_EXPECTED,
							},
						);
						___R$project$rome$$internal$js$parser$parser_ts$next(parser);
						return parser.finishNode(
							start,
							{
								type: "TSNumericLiteralTypeAnnotation",
								value: 0,
							},
						);
					}

					return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSObjectTypeAnnotationAnnotation(
						parser,
					);
				}
			}

			default:
				throw new Error(
					"Caller should have already validated the range of token types",
				);
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSArrayTypeOrHigher(
		parser,
	) {
		let type = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSNonArrayType(
			parser,
		);

		while (
			!___R$project$rome$$internal$js$parser$parser_ts$hasPrecedingLineBreak(
				parser,
			) &&
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketL,
			)
		) {
			if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketR,
				)
			) {
				const start = parser.getLoc(type).start;
				const elementType = type;
				___R$project$rome$$internal$js$parser$parser_ts$expect(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketR,
				);
				type = parser.finishNode(
					start,
					{
						type: "TSArrayType",
						elementType,
					},
				);
			} else {
				const start = parser.getLoc(type).start;
				const objectType = type;
				const indexType = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSType(
					parser,
				);
				___R$project$rome$$internal$js$parser$parser_ts$expect(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketR,
				);
				type = parser.finishNode(
					start,
					{
						type: "TSIndexedAccessType",
						objectType,
						indexType,
					},
				);
			}
		}
		return type;
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeOperator(
		parser,
		operator,
	) {
		const start = parser.getPosition();
		___R$project$rome$$internal$js$parser$parser_ts$expectContextual(
			parser,
			operator,
		);

		const typeAnnotation = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeOperatorOrHigher(
			parser,
		);

		const node = parser.finishNode(
			start,
			{
				type: "TSTypeOperator",
				typeAnnotation,
				operator,
			},
		);

		if (operator === "readonly") {
			___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsCheckTypeAnnotationForReadOnly(
				parser,
				typeAnnotation,
			);
		}

		return node;
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsCheckTypeAnnotationForReadOnly(
		parser,
		node,
	) {
		switch (node.type) {
			case "TSTupleType":
			case "TSArrayType":
				return;

			default: {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						loc: node.loc,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TS_INVALID_READONLY_MODIFIER,
					},
				);
				break;
			}
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSInferType(
		parser,
	) {
		const inferStart = parser.getPosition();
		___R$project$rome$$internal$js$parser$parser_ts$expectContextual(
			parser,
			"infer",
		);

		const start = parser.getPosition();
		const name = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifierName(
			parser,
		);
		const typeParameter = parser.finishNode(
			start,
			{
				type: "TSTypeParameter",
				name,
			},
		);

		return parser.finishNode(
			inferStart,
			{
				type: "TSInferType",
				typeParameter,
			},
		);
	}

	const ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$TS_TYPE_OPERATORS = [
		"keyof",
		"unique",
		"readonly",
	];

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeOperatorOrHigher(
		parser,
	) {
		let operator;

		for (const op of ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$TS_TYPE_OPERATORS) {
			if (
				___R$project$rome$$internal$js$parser$parser_ts$isContextual(parser, op)
			) {
				operator = op;
				break;
			}
		}

		if (operator !== undefined) {
			return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeOperator(
				parser,
				operator,
			);
		} else if (
			___R$project$rome$$internal$js$parser$parser_ts$isContextual(
				parser,
				"infer",
			)
		) {
			return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSInferType(
				parser,
			);
		} else {
			return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSArrayTypeOrHigher(
				parser,
			);
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSUnionOrIntersectionType(
		parser,
		kind,
		parseConstituentType,
		operator,
	) {
		___R$project$rome$$internal$js$parser$parser_ts$eat(parser, operator);
		let type = parseConstituentType(parser);

		if (___R$project$rome$$internal$js$parser$parser_ts$match(parser, operator)) {
			const types = [type];
			while (
				___R$project$rome$$internal$js$parser$parser_ts$eat(parser, operator)
			) {
				types.push(parseConstituentType(parser));
			}

			const start = parser.getLoc(type).start;
			if (kind === "JSUnionTypeAnnotation") {
				type = parser.finishNode(
					start,
					{
						type: "TSUnionTypeAnnotation",
						types,
					},
				);
			} else if (kind === "TSIntersectionTypeAnnotation") {
				type = parser.finishNode(
					start,
					{
						type: "TSIntersectionTypeAnnotation",
						types,
					},
				);
			}
		}

		return type;
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSIntersectionTypeAnnotationOrHigher(
		parser,
	) {
		return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSUnionOrIntersectionType(
			parser,
			"TSIntersectionTypeAnnotation",
			___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeOperatorOrHigher,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bitwiseAND,
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseUnionTypeAnnotationOrHigher(
		parser,
	) {
		return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSUnionOrIntersectionType(
			parser,
			"JSUnionTypeAnnotation",
			___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSIntersectionTypeAnnotationOrHigher,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bitwiseOR,
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsIsStartOfFunctionType(
		parser,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$isRelational(parser, "<")
		) {
			return true;
		}
		return (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
			) &&
			___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$lookaheadTS(
				parser,
				___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsIsUnambiguouslyStartOfFunctionType,
			)
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsSkipParameterStart(
		parser,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name,
			) ||
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._this,
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$next(parser);
			return true;
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL,
			)
		) {
			let braceStackCounter = 1;
			___R$project$rome$$internal$js$parser$parser_ts$next(parser);

			while (braceStackCounter > 0) {
				if (
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL,
					)
				) {
					braceStackCounter++;
				} else if (
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
					)
				) {
					braceStackCounter--;
				}

				___R$project$rome$$internal$js$parser$parser_ts$next(parser);
			}
			return true;
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketL,
			)
		) {
			let braceStackCounter = 1;
			___R$project$rome$$internal$js$parser$parser_ts$next(parser);

			while (braceStackCounter > 0) {
				if (
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketL,
					)
				) {
					braceStackCounter++;
				} else if (
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketR,
					)
				) {
					braceStackCounter--;
				}

				___R$project$rome$$internal$js$parser$parser_ts$next(parser);
			}
			return true;
		}

		return false;
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsIsUnambiguouslyStartOfFunctionType(
		parser,
	) {
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR,
			) ||
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.ellipsis,
			)
		) {
			// ()
			// (...
			return true;
		}
		if (
			___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsSkipParameterStart(
				parser,
			)
		) {
			if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
				) ||
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
				) ||
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.question,
				) ||
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eq,
				)
			) {
				// (xxx :
				// (xxx ,
				// (xxx ?
				// (xxx =
				return true;
			}
			if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR,
				)
			) {
				___R$project$rome$$internal$js$parser$parser_ts$next(parser);
				if (
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.arrow,
					)
				) {
					// (xxx ) =>
					return true;
				}
			}
		}
		return false;
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation(
		parser,
		returnToken,
	) {
		let start = parser.getPosition();
		___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$expectTSEnabled(
			parser,
			"type annotation",
			start,
		);

		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"TYPE",
			true,
		);
		___R$project$rome$$internal$js$parser$parser_ts$expect(parser, returnToken);

		let hasAsserts = ___R$project$rome$$internal$js$parser$parser_ts$eatContextual(
			parser,
			"asserts",
		);
		let parameterName;
		let typePredicateVariable;
		if (
			___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsIsIdentifier(
				parser,
			)
		) {
			typePredicateVariable = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tryTSParse(
				parser,
				___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypePredicatePrefix,
			);
		}
		if (typePredicateVariable === undefined) {
			if (hasAsserts) {
				parameterName = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier(
					parser,
				);
				if (parameterName === undefined) {
					throw Error("Should have an identifier after asserts");
				}
			} else {
				___R$project$rome$$internal$js$parser$parser_ts$popScope(parser, "TYPE");
				return ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
					parser,
					/* eatColon */ false,
					start,
				);
			}
		} else {
			parameterName = typePredicateVariable;
		}

		let type;
		if (typePredicateVariable) {
			type = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
				parser,
				/* eatColon */ false,
			);
			start = parser.getLoc(typePredicateVariable).start;
		}

		___R$project$rome$$internal$js$parser$parser_ts$popScope(parser, "TYPE");

		return parser.finishNode(
			start,
			{
				type: "TSTypePredicate",
				asserts: hasAsserts,
				parameterName,
				typeAnnotation: type,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tryTSParseTypeAnnotation(
		parser,
	) {
		return ___R$project$rome$$internal$js$parser$parser_ts$match(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
		)
			? ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
					parser,
				)
			: undefined;
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tryTSParseType(
		parser,
	) {
		return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsEatThenParseType(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypePredicatePrefix(
		parser,
	) {
		const id = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier(
			parser,
		);
		if (
			___R$project$rome$$internal$js$parser$parser_ts$isContextual(parser, "is") &&
			!___R$project$rome$$internal$js$parser$parser_ts$hasPrecedingLineBreak(
				parser,
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$next(parser);
			return id;
		} else {
			return undefined;
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
		parser,
		eatColon = true,
		start = parser.getPosition(),
	) {
		___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$expectTSEnabled(
			parser,
			"type annotation",
			start,
		);

		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"TYPE",
			true,
		);

		if (eatColon) {
			___R$project$rome$$internal$js$parser$parser_ts$expect(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
			);
		}

		const typeAnnotation = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSType(
			parser,
			start,
		);
		___R$project$rome$$internal$js$parser$parser_ts$popScope(parser, "TYPE");
		return typeAnnotation;
	}

	/** Be sure to be in a type context before calling parser. using `tsInType`.*/
	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSType(
		parser,
		start = parser.getPosition(),
	) {
		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"TYPE",
			true,
		);

		const type = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSNonConditionalType(
			parser,
		);
		if (
			___R$project$rome$$internal$js$parser$parser_ts$hasPrecedingLineBreak(
				parser,
			) ||
			!___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._extends,
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$popScope(parser, "TYPE");
			return type;
		}

		const checkType = type;

		const extendsType = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSNonConditionalType(
			parser,
		);
		___R$project$rome$$internal$js$parser$parser_ts$expect(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.question,
		);

		const trueType = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSType(
			parser,
		);
		___R$project$rome$$internal$js$parser$parser_ts$expect(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
		);

		const falseType = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSType(
			parser,
		);
		___R$project$rome$$internal$js$parser$parser_ts$popScope(parser, "TYPE");

		return parser.finishNode(
			start,
			{
				type: "TSConditionalType",
				checkType,
				extendsType,
				trueType,
				falseType,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSNonConditionalType(
		parser,
	) {
		if (
			___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsIsStartOfFunctionType(
				parser,
			)
		) {
			return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSFunctionType(
				parser,
			);
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._new,
			)
		) {
			// As in `new () => Date`
			return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSConstructorType(
				parser,
			);
		}

		return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseUnionTypeAnnotationOrHigher(
			parser,
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeAssertion(
		parser,
	) {
		const start = parser.getPosition();
		___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$expectTSEnabled(
			parser,
			"type assertion",
			start,
		);

		const _const = ___R$project$rome$$internal$js$parser$parser$typescript_ts$tryTSNextParseConstantContext(
			parser,
		);
		const typeAnnotation =
			_const ||
			___R$project$rome$$internal$js$parser$parser$typescript_ts$tsNextThenParseType(
				parser,
			);
		___R$project$rome$$internal$js$parser$parser_ts$expectRelational(
			parser,
			">",
		);

		const expression = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeUnary(
			parser,
			"ts type assertion",
		);
		if (_const) {
			___R$project$rome$$internal$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext(
				parser,
				expression,
			);
		}

		return parser.finishNode(
			start,
			{
				type: "TSTypeAssertion",
				expression,
				typeAnnotation,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSHeritageClause(
		parser,
		descriptor,
	) {
		___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$expectTSEnabled(
			parser,
			"heritage clause",
		);

		const originalStart = parser.state.startPos;
		const delimitedList = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSDelimitedList(
			parser,
			"HeritageClauseElement",
			___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSExpressionWithTypeArguments,
		);

		if (delimitedList.length === 0) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					start: originalStart,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TS_EMPTY_LIST(
						descriptor,
					),
				},
			);
		}

		return delimitedList;
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSExpressionWithTypeArguments(
		parser,
	) {
		const start = parser.getPosition();

		// Note: TS uses parseLeftHandSideExpressionOrHigher,

		// then has grammar errors later if it's not an EntityName.
		const expression = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSEntityName(
			parser,
			/* allowReservedWords */ false,
		);

		let typeParameters;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$isRelational(parser, "<")
		) {
			typeParameters = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeArguments(
				parser,
			);
		}

		return parser.finishNode(
			start,
			{
				type: "TSExpressionWithTypeArguments",
				expression,
				typeParameters,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSInterfaceDeclaration(
		parser,
		start,
	) {
		___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$expectTSEnabled(
			parser,
			"interface declaration",
			start,
		);

		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"TYPE",
			true,
		);
		const id = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseBindingIdentifier(
			parser,
		);
		const typeParameters = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tryParseTSTypeParameters(
			parser,
		);

		let _extends;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._extends,
			)
		) {
			_extends = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSHeritageClause(
				parser,
				"extends",
			);
		}

		const bodyStart = parser.getPosition();
		const bodyItems = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSObjectTypeMembers(
			parser,
		);
		const body = parser.finishNode(
			bodyStart,
			{
				type: "TSInterfaceBody",
				body: bodyItems,
			},
		);

		___R$project$rome$$internal$js$parser$parser_ts$popScope(parser, "TYPE");
		return parser.finishNode(
			start,
			{
				type: "TSInterfaceDeclaration",
				id,
				body,
				typeParameters,
				extends: _extends,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeAlias(
		parser,
		start,
	) {
		const id = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseBindingIdentifier(
			parser,
		);
		const typeParameters = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tryParseTSTypeParameters(
			parser,
		);
		const typeAnnotation = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsExpectThenParseType(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eq,
		);
		___R$project$rome$$internal$js$parser$parser_ts$semicolon(parser);
		return parser.finishNode(
			start,
			{
				type: "TSTypeAlias",
				id,
				typeParameters,
				right: typeAnnotation,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsInNoContext(
		parser,
		cb,
	) {
		const oldContext = parser.state.context;
		parser.state.context = [oldContext[0]];
		const res = cb(parser);
		parser.state.context = oldContext;
		return res;
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsEatThenParseType(
		parser,
		token,
	) {
		if (___R$project$rome$$internal$js$parser$parser_ts$match(parser, token)) {
			return ___R$project$rome$$internal$js$parser$parser$typescript_ts$tsNextThenParseType(
				parser,
			);
		} else {
			return undefined;
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsExpectThenParseType(
		parser,
		token,
	) {
		return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsDoThenParseType(
			parser,
			() => {
				___R$project$rome$$internal$js$parser$parser_ts$expect(parser, token);
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$tsNextThenParseType(
		parser,
	) {
		return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsDoThenParseType(
			parser,
			() => ___R$project$rome$$internal$js$parser$parser_ts$next(parser),
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsDoThenParseType(
		parser,
		cb,
	) {
		cb();
		return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSType(
			parser,
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSEnumMember(
		parser,
	) {
		const start = parser.getPosition();
		// Computed property names are grammar errors in an enum, so accept just string literal or identifier.
		const id = ___R$project$rome$$internal$js$parser$parser_ts$match(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.string,
		)
			? ___R$project$rome$$internal$js$parser$parser$expression_ts$parseStringLiteral(
					parser,
				)
			: ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier(
					parser,
					/* liberal */ true,
				);

		let initializer;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eq,
			)
		) {
			initializer = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeAssign(
				parser,
				"ts enum member initializer",
			);
		}

		return parser.finishNode(
			start,
			{
				type: "TSEnumMember",
				initializer,
				id,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSEnumDeclaration(
		parser,
		start,
		isConst,
	) {
		parser.addDiagnosticFilter({
			message: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.RESERVED_WORD(
				"enum",
			).message,
			start,
		});

		const id = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseBindingIdentifier(
			parser,
		);

		const braceOpenStart = parser.getPosition();
		const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
			"ts enum declaration",
		);

		const members = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSDelimitedList(
			parser,
			"EnumMembers",
			___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSEnumMember,
		);
		___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
			parser,
			openContext,
		);

		return parser.finishNodeWithStarts(
			[braceOpenStart, start],
			{
				type: "TSEnumDeclaration",
				members,
				id,
				const: isConst,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSModuleBlock(
		parser,
	) {
		const start = parser.getPosition();

		const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
			"ts module block",
		);

		// Inside of a module block is considered 'top-level', meaning it can have imports and exports.
		const {body} = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseBlockOrModuleBlockBody(
			parser,
			/* allowDirectives */ false,
			/* topLevel */ true,
			openContext,
		);
		return parser.finishNode(
			start,
			{
				type: "TSModuleBlock",
				body,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSModuleOrNamespaceDeclaration(
		parser,
		start,
	) {
		const id = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseBindingIdentifier(
			parser,
		);

		let body;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.dot,
			)
		) {
			body = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSModuleOrNamespaceDeclaration(
				parser,
				parser.getPosition(),
			);
		} else {
			body = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSModuleBlock(
				parser,
			);
		}

		return parser.finishNode(
			start,
			{
				type: "TSModuleDeclaration",
				id,
				body,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSAmbientExternalModuleDeclaration(
		parser,
		start,
	) {
		let global;
		let id;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$isContextual(
				parser,
				"global",
			)
		) {
			global = true;
			id = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseBindingIdentifier(
				parser,
			);
		} else if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.string,
			)
		) {
			id = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseStringLiteral(
				parser,
			);
		} else {
			throw parser.unexpected();
		}

		let body;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL,
			)
		) {
			body = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSModuleBlock(
				parser,
			);
		} else {
			___R$project$rome$$internal$js$parser$parser_ts$semicolon(parser);
		}

		return parser.finishNode(
			start,
			{
				type: "TSModuleDeclaration",
				id,
				global,
				body,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSImportEqualsDeclaration(
		parser,
		start,
		isExport = false,
	) {
		___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$expectTSEnabled(
			parser,
			"import equals declaration",
			start,
		);

		const id = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseBindingIdentifier(
			parser,
		);
		___R$project$rome$$internal$js$parser$parser_ts$expect(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eq,
		);

		const moduleReference = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSModuleReference(
			parser,
		);
		___R$project$rome$$internal$js$parser$parser_ts$semicolon(parser);

		return parser.finishNode(
			start,
			{
				type: "TSImportEqualsDeclaration",
				id,
				moduleReference,
				isExport,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsIsExternalModuleReference(
		parser,
	) {
		return (
			___R$project$rome$$internal$js$parser$parser_ts$isContextual(
				parser,
				"require",
			) &&
			___R$project$rome$$internal$js$parser$parser_ts$lookaheadState(parser).tokenType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSModuleReference(
		parser,
	) {
		return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsIsExternalModuleReference(
			parser,
		)
			? ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSExternalModuleReference(
					parser,
				)
			: ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSEntityName(
					parser,
					/* allowReservedWords */ false,
				);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSExternalModuleReference(
		parser,
	) {
		const start = parser.getPosition();
		___R$project$rome$$internal$js$parser$parser_ts$expectContextual(
			parser,
			"require",
		);
		const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR,
			"ts external module reference",
		);

		let expression;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.string,
			)
		) {
			expression = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseStringLiteral(
				parser,
			);
		} else {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TS_EXTERNAL_MODULE_REFERENCE_ARG_NOT_STRING,
				},
			);

			// Skip as much of the next expression as we can
			___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionAtom(
				parser,
				"ts external module reference expression",
			);

			// Create a fake string literal
			expression = parser.finishNode(
				start,
				{
					type: "JSStringLiteral",
					value: "",
				},
			);
		}

		___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
			parser,
			openContext,
		);

		return parser.finishNode(
			start,
			{
				type: "TSExternalModuleReference",
				expression,
			},
		);
	}

	// Utilities
	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$lookaheadTS(
		parser,
		f,
	) {
		const state = ___R$project$rome$$internal$js$parser$parser_ts$cloneState(
			parser,
		);
		const res = f(parser);
		parser.state = state;
		return res;
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tryTSParse(
		parser,
		f,
	) {
		const state = ___R$project$rome$$internal$js$parser$parser_ts$cloneState(
			parser,
		);
		const result = f(parser);
		if (result === undefined || result === false) {
			parser.state = state;
			return undefined;
		} else {
			return result;
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSDeclare(
		parser,
		start,
	) {
		let starttype = parser.state.tokenType;
		let kind;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$isContextual(
				parser,
				"let",
			)
		) {
			starttype = ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._var;
			kind = "let";
		}

		if (
			starttype ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._const &&
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._const,
			) &&
			___R$project$rome$$internal$js$parser$parser_ts$isLookaheadContextual(
				parser,
				"enum",
			)
		) {
			// `const enum = 0;` not allowed because 'enum' is a strict mode reserved word.
			___R$project$rome$$internal$js$parser$parser_ts$expect(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._const,
			);
			___R$project$rome$$internal$js$parser$parser_ts$expectContextual(
				parser,
				"enum",
			);
			return Object.assign(
				{declare: true},
				___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSEnumDeclaration(
					parser,
					start,
					/* isConst */ true,
				),
			);
		}

		switch (starttype) {
			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._function:
				return Object.assign(
					{},
					___R$project$rome$$internal$js$parser$parser$statement_ts$parseFunctionDeclaration(
						parser,
						start,
						false,
					),
					{declare: true},
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._class:
				return Object.assign(
					{},
					___R$project$rome$$internal$js$parser$parser$classes_ts$parseClassDeclaration(
						parser,
						start,
					),
					{declare: true},
				);

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._const:
			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._var: {
				kind =
					kind === undefined
						? ___R$project$rome$$internal$js$parser$parser$statement_ts$assertVarKind(
								String(parser.state.tokenValue),
							)
						: kind;
				return Object.assign(
					{declare: true},
					___R$project$rome$$internal$js$parser$parser$statement_ts$parseVarStatement(
						parser,
						start,
						kind,
					),
				);
			}

			case ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name: {
				const value = String(parser.state.tokenValue);

				if (value === "global") {
					return Object.assign(
						{declare: true},
						___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSAmbientExternalModuleDeclaration(
							parser,
							start,
						),
					);
				} else if (
					___R$project$rome$$internal$js$parser$parser$typescript_ts$isTSDeclarationStart(
						parser,
					)
				) {
					const id = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseReferenceIdentifier(
						parser,
					);
					const decl = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeExpressionStatement(
						parser,
						start,
						id,
					);

					if (decl === undefined) {
						throw new Error("Should have returned a node");
					}

					if (
						decl.type !== "TSInterfaceDeclaration" &&
						decl.type !== "TSTypeAlias" &&
						decl.type !== "TSEnumDeclaration" &&
						decl.type !== "JSFunctionDeclaration" &&
						decl.type !== "JSClassDeclaration" &&
						decl.type !== "JSVariableDeclarationStatement" &&
						decl.type !== "TSDeclareFunction" &&
						decl.type !== "TSModuleDeclaration"
					) {
						throw new Error(
							"Encountered a non-TS declare node when calling parseTSTypeExpressionStatement",
						);
					}

					return Object.assign({}, decl, {declare: true});
				}
			}
		}

		___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
			parser,
			{
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.TS_UNKNOWN_DECLARE_START,
			},
		);

		// Fake node
		const loc = parser.finishLoc(start);
		return {
			type: "JSVariableDeclarationStatement",
			loc,
			declaration: {
				type: "JSVariableDeclaration",
				loc,
				kind: "var",
				declarations: [
					{
						type: "JSVariableDeclarator",
						loc,
						id: ___R$project$rome$$internal$js$parser$parser$expression_ts$toBindingIdentifier(
							parser,
							___R$project$rome$$internal$js$parser$parser_ts$createUnknownIdentifier(
								parser,
								"typescript declare start",
								start,
							),
						),
						init: undefined,
					},
				],
			},
		};
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeExpressionStatement(
		parser,
		start,
		expr,
	) {
		// TODO TypeScript does not like isLineTerminator(parser, )
		if (expr.type !== "JSReferenceIdentifier") {
			return undefined;
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$hasPrecedingLineBreak(
				parser,
			)
		) {
			return undefined;
		}

		switch (expr.name) {
			case "declare":
				if (
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._class,
					) ||
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name,
					) ||
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._function,
					) ||
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._const,
					) ||
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._var,
					) ||
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._export,
					)
				) {
					return ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSDeclare(
						parser,
						start,
					);
				} else {
					break;
				}

			case "interface": {
				parser.addDiagnosticFilter({
					message: ___R$project$rome$$internal$markup$escape_ts$markup`interface is a reserved word`,
					start,
				});

				return ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSInterfaceDeclaration(
					parser,
					start,
				);
			}

			case "type": {
				___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$expectTSEnabled(
					parser,
					"type alias",
					start,
				);
				// TODO perform some lookahead to make sure we want to do this
				return ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeAlias(
					parser,
					start,
				);
			}

			case "abstract":
				if (
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._class,
					)
				) {
					___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$expectTSEnabled(
						parser,
						"abstract class",
						start,
					);
					return ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSAbstractClass(
						parser,
						start,
					);
				} else {
					break;
				}

			case "enum": {
				if (
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name,
					)
				) {
					___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$expectTSEnabled(
						parser,
						"enum declaration",
						start,
					);
					return ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSEnumDeclaration(
						parser,
						start,
						/* isConst */ false,
					);
				} else {
					break;
				}
			}

			case "module":
				if (
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.string,
					)
				) {
					___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$expectTSEnabled(
						parser,
						"ambient external module declaration",
						start,
					);
					return ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSAmbientExternalModuleDeclaration(
						parser,
						start,
					);
				} else if (
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name,
					) &&
					!___R$project$rome$$internal$js$parser$parser_ts$isLineTerminator(
						parser,
					)
				) {
					___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$expectTSEnabled(
						parser,
						"module or namespace declaration",
						start,
					);
					return ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSModuleOrNamespaceDeclaration(
						parser,
						start,
					);
				} else {
					break;
				}

			case "namespace": {
				if (
					!___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name,
					)
				) {
					return undefined;
				}

				___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$expectTSEnabled(
					parser,
					"module or namespace declaration",
					start,
				);
				return ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSModuleOrNamespaceDeclaration(
					parser,
					start,
				);
			}

			// TODO abstract this into typescript.js
			case "global":
				// `global { }` (with no `declare`) may appear inside an ambient module declaration.
				// Would like to use parseTSAmbientExternalModuleDeclaration here, but already ran past 'global'.
				if (
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL,
					)
				) {
					___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$expectTSEnabled(
						parser,
						"module declaration",
						start,
					);
					const global = true;
					const id = ___R$project$rome$$internal$js$parser$parser$expression_ts$toBindingIdentifier(
						parser,
						expr,
					);
					const body = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSModuleBlock(
						parser,
					);
					return parser.finishNode(
						start,
						{
							type: "TSModuleDeclaration",
							global,
							id,
							body,
						},
					);
				}
		}

		return undefined;
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSAbstractClass(
		parser,
		start,
	) {
		return Object.assign(
			{},
			___R$project$rome$$internal$js$parser$parser$classes_ts$parseClassDeclaration(
				parser,
				start,
			),
			{abstract: true},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSExportDefaultAbstractClass(
		parser,
		start,
	) {
		return Object.assign(
			{},
			___R$project$rome$$internal$js$parser$parser$classes_ts$parseExportDefaultClassDeclaration(
				parser,
				start,
			),
			{abstract: true},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeArguments(
		parser,
	) {
		const start = parser.getPosition();
		___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$expectTSEnabled(
			parser,
			"type arguments",
			start,
		);

		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"TYPE",
			true,
		);

		const params = ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$tsInNoContext(
			parser,
			() => {
				___R$project$rome$$internal$js$parser$parser_ts$expectRelational(
					parser,
					"<",
				);
				return ___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSDelimitedList(
					parser,
					"TypeParametersOrArguments",
					___R$$priv$project$rome$$internal$js$parser$parser$typescript_ts$parseTSType,
				);
			},
		);

		// This reads the next token after the `>` too, so do parser.in the enclosing context.

		// But be sure not to parse a regex in the jsx expression `<C<number> />`, so set exprAllowed = false
		parser.state.exprAllowed = false;
		___R$project$rome$$internal$js$parser$parser_ts$popScope(parser, "TYPE");
		___R$project$rome$$internal$js$parser$parser_ts$expectRelational(
			parser,
			">",
		);

		return parser.finishNode(
			start,
			{
				type: "TSTypeParameterInstantiation",
				params,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$isTSDeclarationStart(
		parser,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name,
			)
		) {
			switch (parser.state.tokenValue) {
				case "abstract":
				case "declare":
				case "enum":
				case "interface":
				case "module":
				case "namespace":
				case "type":
					return true;
			}
		}

		return false;
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSAccessModifier(
		parser,
	) {
		return ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSModifier(
			parser,
			["public", "protected", "private"],
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$isTSAbstractClass(
		parser,
	) {
		return (
			___R$project$rome$$internal$js$parser$parser_ts$isContextual(
				parser,
				"abstract",
			) &&
			___R$project$rome$$internal$js$parser$parser_ts$lookaheadState(parser).tokenType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._class
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSExport(
		parser,
		start,
	) {
		if (
			!___R$project$rome$$internal$js$parser$parser_ts$isSyntaxEnabled(
				parser,
				"ts",
			)
		) {
			return undefined;
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._import,
			)
		) {
			// `export const A =B;`
			___R$project$rome$$internal$js$parser$parser_ts$expect(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._import,
			);
			return ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSImportEqualsDeclaration(
				parser,
				start,
				/* isExport */ true,
			);
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eq,
			)
		) {
			// `export = x;`
			const expression = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpression(
				parser,
				"ts export assignment",
			);
			___R$project$rome$$internal$js$parser$parser_ts$semicolon(parser);
			return parser.finishNode(
				start,
				{
					type: "TSExportAssignment",
					expression,
				},
			);
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$eatContextual(
				parser,
				"as",
			)
		) {
			// `export as namespace A;`
			// See `parseNamespaceExportDeclaration` in TypeScript's own parser
			___R$project$rome$$internal$js$parser$parser_ts$expectContextual(
				parser,
				"namespace",
			);
			const id = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier(
				parser,
			);
			___R$project$rome$$internal$js$parser$parser_ts$semicolon(parser);
			return parser.finishNode(
				start,
				{
					type: "TSNamespaceExportDeclaration",
					id,
				},
			);
		}

		return undefined;
	}


  // project-rome/@internal/js-parser/parser/classes.ts
const ___R$project$rome$$internal$js$parser$parser$classes_ts = {
		parseClassExpression: ___R$project$rome$$internal$js$parser$parser$classes_ts$parseClassExpression,
		parseExportDefaultClassDeclaration: ___R$project$rome$$internal$js$parser$parser$classes_ts$parseExportDefaultClassDeclaration,
		parseClassDeclaration: ___R$project$rome$$internal$js$parser$parser$classes_ts$parseClassDeclaration,
		parseClass: ___R$project$rome$$internal$js$parser$parser$classes_ts$parseClass,
	};
	function ___R$project$rome$$internal$js$parser$parser$classes_ts$parseClassExpression(
		parser,
		start,
	) {
		return parser.finalizeNode(
			Object.assign(
				{},
				___R$project$rome$$internal$js$parser$parser$classes_ts$parseClass(
					parser,
					start,
					true,
				),
				{type: "JSClassExpression"},
			),
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$classes_ts$parseExportDefaultClassDeclaration(
		parser,
		start,
	) {
		let ___R$ = ___R$project$rome$$internal$js$parser$parser$classes_ts$parseClass(
			parser,
			start,
			true,
		);
		let shape = Object.assign({}, ___R$);
		delete shape.id;
		let {id} = ___R$;
		if (id === undefined) {
			id = {
				type: "JSBindingIdentifier",
				name: "*default*",
				// Does this `loc` make sense?
				loc: shape.loc,
			};
		}

		return parser.finalizeNode(
			Object.assign({}, shape, {type: "JSClassDeclaration", id}),
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$classes_ts$parseClassDeclaration(
		parser,
		start,
	) {
		const ___R$1 = ___R$project$rome$$internal$js$parser$parser$classes_ts$parseClass(
			parser,
			start,
			false,
		);
		const shape = Object.assign({}, ___R$1);
		delete shape.id;
		const {id} = ___R$1;
		if (id === undefined) {
			throw new Error("Expected id");
		}

		return parser.finalizeNode(
			Object.assign({}, shape, {type: "JSClassDeclaration", id}),
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$classes_ts$parseClass(
		parser,
		start,
		optionalId,
	) {
		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"METHOD",
			false,
		);
		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"STRICT",
			true,
		);

		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		const {id, typeParameters} = ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassId(
			parser,
			optionalId,
		);
		const {superClass, superTypeParameters, implemented} = ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassSuper(
			parser,
		);

		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"CLASS",
			superClass === undefined ? "normal" : "derived",
		);

		const bodyStart = parser.getPosition();
		const body = ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassBody(
			parser,
		);

		___R$project$rome$$internal$js$parser$parser_ts$popScope(parser, "CLASS");
		___R$project$rome$$internal$js$parser$parser_ts$popScope(parser, "STRICT");
		___R$project$rome$$internal$js$parser$parser_ts$popScope(parser, "METHOD");

		// We have two finishNodes here to consume the innerComments inside of the body
		// This is since in the Rome AST, we don't have a ClassBody node, so the comment
		// algorithm thinks that the JSClassHead location is too broad, and thinks a different
		// node should consume them.
		const meta = parser.finishNode(
			start,
			parser.finishNode(
				bodyStart,
				{
					type: "JSClassHead",
					body,
					typeParameters,
					superClass,
					superTypeParameters,
					implements: implemented,
				},
			),
		);

		return {
			loc: parser.finishLoc(start),
			id,
			meta,
		};
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$isClassProperty(
		parser,
	) {
		return (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bang,
			) ||
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
			) ||
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eq,
			) ||
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.semi,
			) ||
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
			)
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$isClassMethod(
		parser,
	) {
		return (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
			) ||
			___R$project$rome$$internal$js$parser$parser_ts$isRelational(parser, "<")
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$isNonstaticConstructor(
		parser,
		key,
		meta,
	) {
		// Class property
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			return false;
		}

		// Static
		if (meta.static) {
			return false;
		}

		if (
			key.type === "JSStaticPropertyKey" &&
			key.value.type === "JSIdentifier" &&
			key.value.name === "constructor"
		) {
			return true;
		}

		if (
			key.value.type === "JSStringLiteral" &&
			key.value.value === "constructor"
		) {
			return true;
		}

		return false;
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassBody(
		parser,
	) {
		// class bodies are implicitly strict
		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"STRICT",
			true,
		);
		parser.state.classLevel = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(
			parser.state.classLevel,
		);

		const state = {hadConstructor: false};

		const body = [];

		const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
			"class body",
		);

		while (true) {
			if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
				) ||
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eof,
				)
			) {
				break;
			}

			if (
				___R$project$rome$$internal$js$parser$parser_ts$eat(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.semi,
				)
			) {
				continue;
			}

			const member = ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassMember(
				parser,
				state,
			);
			if (member !== undefined) {
				body.push(member);
			}
		}

		___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
			parser,
			openContext,
		);

		parser.state.classLevel = ___R$project$rome$$internal$ob1$index_ts$ob1Dec(
			parser.state.classLevel,
		);
		___R$project$rome$$internal$js$parser$parser_ts$popScope(parser, "STRICT");

		return body;
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassMember(
		parser,
		state,
	) {
		const start = parser.getPosition();
		const escapePosition = parser.state.escapePosition;

		let accessibility;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$isSyntaxEnabled(
				parser,
				"ts",
			)
		) {
			accessibility = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSAccessModifier(
				parser,
			);
		}

		let isStatic = false;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name,
			) &&
			parser.state.tokenValue === "static"
		) {
			const keyId = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier(
				parser,
				true,
			); // eats 'static'
			const key = {
				type: "JSStaticPropertyKey",
				value: keyId,
				loc: keyId.loc,
			};

			const meta = parser.finishNode(
				start,
				{
					type: "JSClassPropertyMeta",
					static: false,
					typeAnnotation: undefined,
					accessibility,
					optional: false,
					abstract: false,
					readonly: false,
				},
			);

			if (
				___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$isClassMethod(
					parser,
				)
			) {
				// A method named 'static'
				return ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassMethod(
					parser,
					{
						start,
						meta,
						key,
						kind: "method",
						isStatic: false,
						isAsync: false,
						isGenerator: false,
						isConstructor: false,
					},
				);
			}

			if (
				___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$isClassProperty(
					parser,
				)
			) {
				// A property named 'static'
				return ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassProperty(
					parser,
					start,
					key,
					meta,
				);
			}

			if (escapePosition !== undefined) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						index: escapePosition,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.ESCAPE_SEQUENCE_IN_WORD(
							"static",
						),
					},
				);
			}

			// Otherwise something static
			isStatic = true;
		}

		return ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassMemberWithIsStatic(
			parser,
			start,
			state,
			isStatic,
			accessibility,
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassMemberWithIsStatic(
		parser,
		start,
		state,
		isStatic,
		accessibility,
	) {
		let abstract = false;
		let readonly = false;

		const mod = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSModifier(
			parser,
			["abstract", "readonly"],
		);
		switch (mod) {
			case "readonly": {
				readonly = true;
				abstract = ___R$project$rome$$internal$js$parser$parser$typescript_ts$hasTSModifier(
					parser,
					["abstract"],
				);
				break;
			}

			case "abstract": {
				abstract = true;
				readonly = ___R$project$rome$$internal$js$parser$parser$typescript_ts$hasTSModifier(
					parser,
					["readonly"],
				);
				break;
			}
		}

		const nameOpts = {
			start,
			static: isStatic,
			accessibility,
			readonly,
			abstract,
		};

		if (!abstract && !isStatic && accessibility === undefined) {
			const indexSignature = ___R$project$rome$$internal$js$parser$parser$typescript_ts$tryTSParseIndexSignature(
				parser,
				start,
			);
			if (indexSignature) {
				return Object.assign({}, indexSignature, {readonly});
			}
		}

		// Must be a property (if not an index signature).
		if (readonly) {
			const {key, meta} = ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassPropertyMeta(
				parser,
				nameOpts,
			);
			if (key.value.type === "JSPrivateName") {
				return ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassPrivateProperty(
					parser,
					start,
					key.value,
					meta,
				);
			} else {
				return ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$pushClassProperty(
					parser,
					start,
					key,
					meta,
				);
			}
		}

		// Generator methods
		if (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.star,
			)
		) {
			const {meta, key} = ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassPropertyMeta(
				parser,
				nameOpts,
			);

			if (key.value.type === "JSPrivateName") {
				// Private generator method
				return ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassPrivateMethod(
					parser,
					{
						start,
						key: key.value,
						meta,
						isGenerator: true,
						isAsync: false,
						kind: "method",
					},
				);
			}

			if (
				___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$isNonstaticConstructor(
					parser,
					key,
					meta,
				)
			) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						loc: key.loc,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.GENERATOR_CLASS_CONSTRUCTOR,
					},
				);
			}

			return ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassMethod(
				parser,
				{
					start,
					key,
					meta,
					kind: "method",
					isStatic: false,
					isGenerator: true,
					isAsync: false,
					isConstructor: false,
				},
			);
		}

		const escapePosition = parser.state.escapePosition;
		const {meta, key} = ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassPropertyMeta(
			parser,
			nameOpts,
		);

		// Regular method
		if (
			___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$isClassMethod(
				parser,
			)
		) {
			// Private method
			if (key.value.type === "JSPrivateName") {
				return ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassPrivateMethod(
					parser,
					{
						start,
						key: key.value,
						meta,
						isGenerator: false,
						isAsync: false,
						kind: "method",
					},
				);
			}

			const isConstructor = ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$isNonstaticConstructor(
				parser,
				key,
				meta,
			);

			let kind = "method";
			if (isConstructor) {
				kind = "constructor";

				// TypeScript allows multiple overloaded constructor declarations
				if (
					state.hadConstructor &&
					!___R$project$rome$$internal$js$parser$parser_ts$isSyntaxEnabled(
						parser,
						"ts",
					)
				) {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							loc: key.loc,
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.DUPLICATE_CLASS_CONSTRUCTOR,
						},
					);
				}
				state.hadConstructor = true;
			}

			return ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassMethod(
				parser,
				{
					start,
					key,
					meta,
					kind,
					isStatic,
					isGenerator: false,
					isAsync: false,
					isConstructor,
				},
			);
		}

		// Class property
		if (
			___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$isClassProperty(
				parser,
			)
		) {
			if (key.value.type === "JSPrivateName") {
				return ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassPrivateProperty(
					parser,
					start,
					key.value,
					meta,
				);
			} else {
				return ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$pushClassProperty(
					parser,
					start,
					key,
					meta,
				);
			}
		}

		// Async method
		if (
			key.value.type === "JSIdentifier" &&
			key.value.name === "async" &&
			!___R$project$rome$$internal$js$parser$parser_ts$isLineTerminator(parser)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$banUnicodeEscape(
				parser,
				escapePosition,
				"async",
			);

			// an async method
			const isGenerator = ___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.star,
			);

			// The so-called parsed name would have been "async": get the real name.
			const {meta, key} = ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassPropertyMeta(
				parser,
				nameOpts,
			);

			if (key.value.type === "JSPrivateName") {
				// private async method
				return ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassPrivateMethod(
					parser,
					{
						start,
						key: key.value,
						meta,
						isGenerator,
						isAsync: true,
						kind: "method",
					},
				);
			} else {
				const method = ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassMethod(
					parser,
					{
						start,
						key,
						meta,
						kind: "method",
						isStatic,
						isGenerator,
						isAsync: true,
						isConstructor: false,
					},
				);

				if (
					___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$isNonstaticConstructor(
						parser,
						key,
						meta,
					)
				) {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							loc: key.loc,
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.ASYNC_CLASS_CONSTRUCTOR,
						},
					);
				}

				return method;
			}
		}

		// Getter/setter method
		if (
			key.value.type === "JSIdentifier" &&
			(key.value.name === "get" || key.value.name === "set") &&
			!(___R$project$rome$$internal$js$parser$parser_ts$isLineTerminator(parser) &&
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.star,
			))
		) {
			// `get\n*` is an uninitialized property named 'get' followed by a generator.
			// a getter or setter
			const kind = key.value.name;
			___R$project$rome$$internal$js$parser$parser_ts$banUnicodeEscape(
				parser,
				escapePosition,
				kind,
			);

			// The so-called parsed name would have been "get/set": get the real name.
			const {meta, key: methodKey} = ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassPropertyMeta(
				parser,
				nameOpts,
			);

			if (methodKey.value.type === "JSPrivateName") {
				// private getter/setter
				const method = ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassPrivateMethod(
					parser,
					{
						start,
						key: methodKey.value,
						meta,
						isGenerator: false,
						isAsync: false,
						kind,
					},
				);
				___R$project$rome$$internal$js$parser$parser$expression_ts$checkGetterSetterParamCount(
					parser,
					method,
					method.kind,
				);
				return method;
			} else {
				const method = ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassMethod(
					parser,
					{
						start,
						key: methodKey,
						meta,
						kind,
						isStatic: false,
						isGenerator: false,
						isAsync: false,
						isConstructor: false,
					},
				);

				if (
					___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$isNonstaticConstructor(
						parser,
						key,
						meta,
					)
				) {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							loc: methodKey.loc,
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.GET_SET_CLASS_CONSTRUCTOR,
						},
					);
				}

				___R$project$rome$$internal$js$parser$parser$expression_ts$checkGetterSetterParamCount(
					parser,
					method,
					method.kind,
				);
				return method;
			}
		}

		if (___R$project$rome$$internal$js$parser$parser_ts$isLineTerminator(parser)) {
			// an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)
			if (key.value.type === "JSPrivateName") {
				return ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassPrivateProperty(
					parser,
					start,
					key.value,
					meta,
				);
			} else {
				return ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$pushClassProperty(
					parser,
					start,
					key,
					meta,
				);
			}
		}

		___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
			parser,
			{
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.UNKNOWN_CLASS_PROPERTY_START,
			},
		);
		return undefined;
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassPropertyMeta(
		parser,
		opts,
	) {
		let typeAnnotation;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			typeAnnotation = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
				parser,
				true,
			);
		}

		const key = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseObjectPropertyKey(
			parser,
		);

		if (
			key.type === "JSStaticPropertyKey" &&
			opts.static &&
			key.value.type === "JSIdentifier" &&
			key.value.name === "prototype"
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					loc: key.loc,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.CLASS_STATIC_PROTOTYPE_PROPERTY,
				},
			);
		}

		if (
			key.value.type === "JSPrivateName" &&
			key.value.id.name === "constructor"
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					loc: key.loc,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.CLASS_PRIVATE_FIELD_NAMED_CONSTRUCTOR,
				},
			);
		}

		let optional = false;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.question,
			)
		) {
			optional = true;
			___R$project$rome$$internal$js$parser$parser_ts$expectSyntaxEnabled(
				parser,
				"ts",
			);
			___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		}

		return {
			key,
			meta: parser.finishNode(
				opts.start,
				Object.assign(
					{type: "JSClassPropertyMeta", typeAnnotation, optional},
					opts,
				),
			),
		};
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$pushClassProperty(
		parser,
		start,
		key,
		meta,
	) {
		// This only affects properties, not methods.
		if (
			___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$isNonstaticConstructor(
				parser,
				key,
				meta,
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					loc: key.loc,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.CLASS_PROPERTY_NAME_CONSTRUCTOR,
				},
			);
		}

		return ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassProperty(
			parser,
			start,
			key,
			meta,
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassMethod(
		parser,
		opts,
	) {
		const {start, key, meta, kind, isGenerator, isAsync, isConstructor} = opts;

		const typeParameters = ___R$project$rome$$internal$js$parser$parser$typescript_ts$maybeParseTSTypeParameters(
			parser,
		);

		const {head, body} = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMethod(
			parser,
			{
				kind,
				isClass: true,
				isGenerator,
				isAsync,
				isConstructor,
			},
		);

		const method = {
			head: Object.assign({}, head, {typeParameters}),
			loc: parser.finishLoc(start),
			kind,
			key,
			meta,
		};

		if (body === undefined) {
			return parser.finalizeNode(
				Object.assign({}, method, {type: "TSDeclareMethod", body: undefined}),
			);
		} else {
			if (body.type !== "JSBlockStatement") {
				throw new Error("Expected JSBlockStatement body");
			}

			if (key.value.type === "JSPrivateName") {
				throw new Error("Expected to hit other private methods instead");
			}

			return parser.finalizeNode(
				Object.assign({}, method, {body, type: "JSClassMethod"}),
			);
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassPrivateMethod(
		parser,
		opts,
	) {
		const {start, key, meta, isGenerator, isAsync, kind} = opts;

		const typeParameters = ___R$project$rome$$internal$js$parser$parser$typescript_ts$maybeParseTSTypeParameters(
			parser,
		);
		const method = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMethod(
			parser,
			{
				kind,
				isClass: true,
				isGenerator,
				isAsync,
				isConstructor: false,
			},
		);

		const {body} = method;
		if (body === undefined || body.type !== "JSBlockStatement") {
			throw new Error("Expected body");
		}

		return parser.finishNode(
			start,
			Object.assign(
				{},
				method,
				{
					body,
					meta,
					key,
					kind,
					type: "JSClassPrivateMethod",
					head: Object.assign({}, method.head, {typeParameters}),
				},
			),
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassPrivateProperty(
		parser,
		start,
		key,
		meta,
	) {
		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"CLASS_PROPERTY",
			true,
		);

		let typeAnnotation;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			typeAnnotation = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
				parser,
				true,
			);
		}

		const value = ___R$project$rome$$internal$js$parser$parser_ts$eat(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eq,
		)
			? ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeAssign(
					parser,
					"class private property value",
				)
			: undefined;
		___R$project$rome$$internal$js$parser$parser_ts$semicolon(parser);
		___R$project$rome$$internal$js$parser$parser_ts$popScope(
			parser,
			"CLASS_PROPERTY",
		);

		return parser.finishNode(
			start,
			{
				meta,
				key,
				type: "JSClassPrivateProperty",
				value,
				typeAnnotation,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassProperty(
		parser,
		start,
		key,
		meta,
	) {
		// TODO maybe parsing should be abstracted for private class properties too?
		let definite;
		if (
			!meta.optional &&
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bang,
			)
		) {
			definite = true;
			___R$project$rome$$internal$js$parser$parser_ts$expectSyntaxEnabled(
				parser,
				"ts",
			);
		}

		let typeAnnotation;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			typeAnnotation = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
				parser,
				true,
			);
		}

		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"CLASS_PROPERTY",
			true,
		);

		let value;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eq,
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$next(parser);
			value = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeAssign(
				parser,
				"class property value",
			);
		}
		___R$project$rome$$internal$js$parser$parser_ts$semicolon(parser);

		___R$project$rome$$internal$js$parser$parser_ts$popScope(
			parser,
			"CLASS_PROPERTY",
		);

		if (key.value.type === "JSPrivateName") {
			throw new Error(
				"PrivateName encountered in regular parseClassProperty, expects method is parsePrivateClassProperty",
			);
		}

		return parser.finishNode(
			start,
			{
				meta,
				key,
				type: "JSClassProperty",
				definite,
				typeAnnotation,
				value,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassId(
		parser,
		optionalId,
	) {
		let idAllowed = true;

		// Allow `class implements Foo {}` in class expressions
		if (
			optionalId &&
			___R$project$rome$$internal$js$parser$parser_ts$isContextual(
				parser,
				"implements",
			)
		) {
			idAllowed = false;
		}

		let id;
		if (idAllowed) {
			if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name,
				)
			) {
				id = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseBindingIdentifier(
					parser,
				);
			} else if (!optionalId) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.REQUIRED_CLASS_NAME,
					},
				);
				id = ___R$project$rome$$internal$js$parser$parser$expression_ts$toBindingIdentifier(
					parser,
					___R$project$rome$$internal$js$parser$parser_ts$createUnknownIdentifier(
						parser,
						"required class name",
					),
				);
			}
		}

		const typeParameters = ___R$project$rome$$internal$js$parser$parser$typescript_ts$maybeParseTSTypeParameters(
			parser,
		);
		return {id, typeParameters};
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$classes_ts$parseClassSuper(
		parser,
	) {
		let superClass = ___R$project$rome$$internal$js$parser$parser_ts$eat(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._extends,
		)
			? ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionWithPossibleSubscripts(
					parser,
					"class heritage",
				)
			: undefined;
		let superTypeParameters;

		if (superClass !== undefined) {
			superTypeParameters = ___R$project$rome$$internal$js$parser$parser$typescript_ts$maybeParseTSTypeArguments(
				parser,
			);
		}

		let implemented;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$isContextual(
				parser,
				"implements",
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$next(parser);
			implemented = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSHeritageClause(
				parser,
				"implements",
			);
		}

		return {superClass, superTypeParameters, implemented};
	}


  // project-rome/@internal/js-parser/parser/modules.ts
const ___R$project$rome$$internal$js$parser$parser$modules_ts = {
		parseExport: ___R$project$rome$$internal$js$parser$parser$modules_ts$parseExport,
		parseImport: ___R$project$rome$$internal$js$parser$parser$modules_ts$parseImport,
		isMaybeDefaultImport: ___R$project$rome$$internal$js$parser$parser$modules_ts$isMaybeDefaultImport,
		hasTypeImportKind: ___R$project$rome$$internal$js$parser$parser$modules_ts$hasTypeImportKind,
	};
	function ___R$project$rome$$internal$js$parser$parser$modules_ts$parseExport(
		parser,
		start,
	) {
		const tsNode = ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSExport(
			parser,
			start,
		);
		if (tsNode !== undefined) {
			return tsNode;
		}

		let exportKind = "value";
		let declaration;
		let localSpecifiers;

		// export * from '...'';
		if (
			___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$shouldParseExportStar(
				parser,
			)
		) {
			return ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseExportStar(
				parser,
				start,
			);
		} else if (
			___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$isExportDefaultSpecifier(
				parser,
			)
		) {
			const defStart = parser.getPosition();
			const defExported = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier(
				parser,
				true,
			);

			let namedSpecifiers = [];
			let defaultSpecifier = parser.finishNode(
				defStart,
				{
					type: "JSExportDefaultSpecifier",
					exported: defExported,
				},
			);
			let namespaceSpecifier;

			if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
				) &&
				___R$project$rome$$internal$js$parser$parser_ts$lookaheadState(parser).tokenType ===
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.star
			) {
				___R$project$rome$$internal$js$parser$parser_ts$expect(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
				);
				const specifierStart = parser.getPosition();
				___R$project$rome$$internal$js$parser$parser_ts$expect(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.star,
				);
				___R$project$rome$$internal$js$parser$parser_ts$expectContextual(
					parser,
					"as",
				);
				const exported = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier(
					parser,
				);
				namespaceSpecifier = parser.finishNode(
					specifierStart,
					{
						type: "JSExportNamespaceSpecifier",
						exported,
					},
				);
			} else {
				namedSpecifiers = ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseExportLocalSpecifiersMaybe(
					parser,
				);
			}

			const source = ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseExportFromExpect(
				parser,
			);
			return ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$createExportExternalDeclaration(
				parser,
				start,
				defaultSpecifier,
				namespaceSpecifier,
				namedSpecifiers,
				source,
			);
		} else if (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._default,
			)
		) {
			// export default ...
			const declaration = ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseExportDefaultExpression(
				parser,
			);
			___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$checkExport(
				parser,
				{
					specifiers: localSpecifiers,
					declaration,
					isDefault: true,
				},
			);

			const node = parser.finishNode(
				start,
				{
					type: "JSExportDefaultDeclaration",
					declaration,
				},
			);
			return node;
		} else if (
			___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$shouldParseExportDeclaration(
				parser,
			)
		) {
			let source;
			({
				declaration,
				source,
				localSpecifiers,
				exportKind,
			} = ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseExportDeclaration(
				parser,
			));

			if (source !== undefined) {
				if (declaration !== undefined) {
					throw new Error(
						"When there's a source we don't also expect a declaration",
					);
				}

				return ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$createExportExternalDeclaration(
					parser,
					start,
					undefined,
					undefined,
					localSpecifiers === undefined ? [] : localSpecifiers,
					source,
					exportKind,
				);
			}
		} else if (
			___R$project$rome$$internal$js$parser$parser_ts$isContextual(
				parser,
				"async",
			) &&
			!___R$project$rome$$internal$js$parser$parser$statement_ts$isAsyncFunctionDeclarationStart(
				parser,
			)
		) {
			const next = ___R$project$rome$$internal$js$parser$parser_ts$lookaheadState(
				parser,
			);

			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					start: next.startPos,
					end: next.endPos,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.EXPORT_ASYNC_NO_FUNCTION_KEYWORD,
				},
			);
			declaration = undefined;
			localSpecifiers = [];
		} else {
			// export { x, y as z } [from '...']';
			localSpecifiers = ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseExportSpecifiers(
				parser,
			);

			const source = ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseExportFrom(
				parser,
				false,
			);
			if (source !== undefined) {
				return ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$createExportExternalDeclaration(
					parser,
					start,
					undefined,
					undefined,
					localSpecifiers,
					source,
				);
			}
		}

		___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$checkExport(
			parser,
			{
				specifiers: localSpecifiers,
				declaration,
				isDefault: false,
			},
		);

		if (declaration !== undefined) {
			if (
				declaration.type !== "JSVariableDeclarationStatement" &&
				declaration.type !== "JSClassDeclaration" &&
				declaration.type !== "JSFunctionDeclaration" &&
				declaration.type !== "TSModuleDeclaration" &&
				declaration.type !== "TSEnumDeclaration" &&
				declaration.type !== "TSTypeAlias" &&
				declaration.type !== "TSInterfaceDeclaration" &&
				declaration.type !== "TSDeclareFunction"
			) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						loc: declaration.loc,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.INVALID_EXPORT_DECLARATION,
					},
				);
				return declaration;
			}
		}

		const node = parser.finishNode(
			start,
			{
				type: "JSExportLocalDeclaration",
				exportKind,
				specifiers: localSpecifiers,
				declaration,
			},
		);
		return node;
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$createExportExternalDeclaration(
		parser,
		start,
		defaultSpecifier,
		namespaceSpecifier,
		namedSpecifiers,
		source,
		exportKind,
	) {
		___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$checkExport(
			parser,
			{
				specifiers: [defaultSpecifier, namespaceSpecifier, ...namedSpecifiers],
				declaration: undefined,
				isDefault: false,
				localIsExternal: true,
			},
		);

		const node = parser.finishNode(
			start,
			{
				type: "JSExportExternalDeclaration",
				exportKind,
				source,
				namedSpecifiers: [],
				defaultSpecifier,
				namespaceSpecifier,
			},
		);

		// We convert the specifiers after we've finished the JSExportExternalDeclaration node
		// as the comment attachment logic may mess with the specifiers and so we need to
		// clone them after
		return Object.assign(
			{},
			node,
			{
				namedSpecifiers: ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$convertLocalToExternalSpecifiers(
					parser,
					namedSpecifiers,
				),
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$convertLocalToExternalSpecifiers(
		parser,
		specifiers = [],
	) {
		return specifiers.map((specifier) => {
			return Object.assign(
				{},
				specifier,
				{
					type: "JSExportExternalSpecifier",
					local: ___R$project$rome$$internal$js$parser$parser$expression_ts$toIdentifier(
						parser,
						specifier.local,
					),
				},
			);
		});
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseExportDefaultExpression(
		parser,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$isSyntaxEnabled(
				parser,
				"ts",
			)
		) {
			if (
				___R$project$rome$$internal$js$parser$parser$typescript_ts$isTSAbstractClass(
					parser,
				)
			) {
				const start = parser.getPosition();
				___R$project$rome$$internal$js$parser$parser_ts$next(parser); // Skip 'abstract'
				return ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSExportDefaultAbstractClass(
					parser,
					start,
				);
			}

			if (
				parser.state.tokenValue === "interface" &&
				!___R$project$rome$$internal$js$parser$parser_ts$isLineTerminator(
					parser,
				)
			) {
				const start = parser.getPosition();
				___R$project$rome$$internal$js$parser$parser_ts$next(parser);
				return ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSInterfaceDeclaration(
					parser,
					start,
				);
			}
		}

		const start = parser.getPosition();
		const isAsync = ___R$project$rome$$internal$js$parser$parser$statement_ts$isAsyncFunctionDeclarationStart(
			parser,
		);
		if (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._function,
			) ||
			isAsync
		) {
			if (isAsync) {
				___R$project$rome$$internal$js$parser$parser_ts$eatContextual(
					parser,
					"async",
				);
				___R$project$rome$$internal$js$parser$parser_ts$expect(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._function,
				);
			}

			return ___R$project$rome$$internal$js$parser$parser$statement_ts$parseExportDefaultFunctionDeclaration(
				parser,
				start,
				isAsync,
			);
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._class,
			)
		) {
			return ___R$project$rome$$internal$js$parser$parser$classes_ts$parseExportDefaultClassDeclaration(
				parser,
				start,
			);
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._const,
			) ||
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._var,
			) ||
			___R$project$rome$$internal$js$parser$parser$statement_ts$isLetStart(
				parser,
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.INVALID_EXPORT_DEFAULT,
				},
			);
		}

		const res = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseMaybeAssign(
			parser,
			"export default declaration",
		);
		___R$project$rome$$internal$js$parser$parser_ts$semicolon(parser);
		return res;
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseExportDeclaration(
		parser,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$isContextual(
				parser,
				"type",
			)
		) {
			const start = parser.getPosition();
			___R$project$rome$$internal$js$parser$parser_ts$next(parser);

			if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL,
				)
			) {
				// export { foo, bar };
				const specifiers = ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseExportSpecifiers(
					parser,
				);
				const source = ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseExportFrom(
					parser,
					false,
				);
				return {
					exportKind: "type",
					localSpecifiers: specifiers,
					source,
				};
			} else {
				// export type Foo = Bar;
				return {
					exportKind: "type",
					declaration: ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSTypeAlias(
						parser,
						start,
					),
				};
			}
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$isContextual(
				parser,
				"interface",
			)
		) {
			const declarationNode = parser.getPosition();
			___R$project$rome$$internal$js$parser$parser_ts$next(parser);
			return {
				exportKind: "type",
				declaration: ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSInterfaceDeclaration(
					parser,
					declarationNode,
				),
			};
		}

		return {
			exportKind: "value",
			declaration: ___R$project$rome$$internal$js$parser$parser$statement_ts$parseStatement(
				parser,
			),
		};
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$isExportDefaultSpecifier(
		parser,
	) {
		// export Foo from "mod"
		// export Foo, {Bar} from "mod"
		const lookahead = ___R$project$rome$$internal$js$parser$parser_ts$lookaheadState(
			parser,
		);
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name,
			) &&
			(lookahead.tokenType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma ||
			(lookahead.tokenType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name &&
			lookahead.tokenValue === "from"))
		) {
			return true;
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$isSyntaxEnabled(
				parser,
				"ts",
			) &&
			___R$project$rome$$internal$js$parser$parser$typescript_ts$isTSDeclarationStart(
				parser,
			)
		) {
			return false;
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name,
			) &&
			(parser.state.tokenValue === "type" ||
			parser.state.tokenValue === "interface" ||
			parser.state.tokenValue === "opaque")
		) {
			return false;
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name,
			)
		) {
			return (
				parser.state.tokenValue !== "async" && parser.state.tokenValue !== "let"
			);
		}

		if (
			!___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._default,
			)
		) {
			return false;
		}

		return false;
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseExportLocalSpecifiersMaybe(
		parser,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
			)
		) {
			return ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseExportSpecifiers(
				parser,
			);
		} else {
			return [];
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseExportFromExpect(
		parser,
	) {
		// @ts-ignore: `expect` parameter will always return a JSStringLiteral
		return ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseExportFrom(
			parser,
			true,
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseExportFrom(
		parser,
		expect,
	) {
		let source;

		if (
			___R$project$rome$$internal$js$parser$parser_ts$eatContextual(
				parser,
				"from",
			)
		) {
			if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.string,
				)
			) {
				source = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseStringLiteral(
					parser,
				);
			} else {
				const expr = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseExpressionAtom(
					parser,
					"export from",
				);

				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						loc: expr.loc,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.EXPORT_FROM_NOT_STRING,
					},
				);

				source = {
					type: "JSStringLiteral",
					value: "",
					loc: expr.loc,
				};
			}
		} else if (expect) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.EXPORT_MISSING_FROM,
				},
			);

			source = {
				type: "JSStringLiteral",
				value: "",
				loc: parser.finishLoc(parser.getPosition()),
			};
		}

		___R$project$rome$$internal$js$parser$parser_ts$semicolon(parser);

		return source;
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$shouldParseExportStar(
		parser,
	) {
		return (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.star,
			) ||
			(___R$project$rome$$internal$js$parser$parser_ts$isContextual(
				parser,
				"type",
			) &&
			___R$project$rome$$internal$js$parser$parser_ts$lookaheadState(parser).tokenType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.star)
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseExportStar(
		parser,
		start,
	) {
		let exportKind;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$eatContextual(
				parser,
				"type",
			)
		) {
			exportKind = "type";
		}

		___R$project$rome$$internal$js$parser$parser_ts$expect(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.star,
		);

		if (
			___R$project$rome$$internal$js$parser$parser_ts$isContextual(parser, "as")
		) {
			const {source, namespaceSpecifier, namedSpecifiers} = ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseExportNamespace(
				parser,
				exportKind,
			);
			return parser.finishNode(
				start,
				{
					type: "JSExportExternalDeclaration",
					namespaceSpecifier,
					exportKind,
					namedSpecifiers,
					source,
				},
			);
		} else {
			const source = ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseExportFrom(
				parser,
				true,
			);
			if (source === undefined) {
				throw new Error(
					"Passed `true` above which expects there to be a string",
				);
			}
			return parser.finishNode(
				start,
				{
					type: "JSExportAllDeclaration",
					exportKind,
					source,
				},
			);
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseExportNamespace(
		parser,
		exportKind,
	) {
		if (exportKind === "type") {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.EXPORT_TYPE_NAMESPACE,
				},
			);
		}

		const specifierStart = parser.state.lastStartPos;
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		const exported = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier(
			parser,
			true,
		);

		const namespaceSpecifier = parser.finishNode(
			specifierStart,
			{
				type: "JSExportNamespaceSpecifier",
				exported,
			},
		);

		const namedSpecifiers = ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$convertLocalToExternalSpecifiers(
			parser,
			___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseExportLocalSpecifiersMaybe(
				parser,
			),
		);

		const source = ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseExportFromExpect(
			parser,
		);
		return {source, namespaceSpecifier, namedSpecifiers};
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$shouldParseExportDeclaration(
		parser,
	) {
		return (
			___R$project$rome$$internal$js$parser$parser$typescript_ts$isTSDeclarationStart(
				parser,
			) ||
			___R$project$rome$$internal$js$parser$parser_ts$isContextual(
				parser,
				"type",
			) ||
			___R$project$rome$$internal$js$parser$parser_ts$isContextual(
				parser,
				"interface",
			) ||
			___R$project$rome$$internal$js$parser$parser_ts$isContextual(
				parser,
				"opaque",
			) ||
			parser.state.tokenType.keyword === "var" ||
			parser.state.tokenType.keyword === "const" ||
			parser.state.tokenType.keyword === "function" ||
			parser.state.tokenType.keyword === "class" ||
			___R$project$rome$$internal$js$parser$parser$statement_ts$isLetStart(
				parser,
			) ||
			___R$project$rome$$internal$js$parser$parser$statement_ts$isAsyncFunctionDeclarationStart(
				parser,
			) ||
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.at,
			)
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$checkExport(
		parser,
		{
			specifiers,
			declaration,
			localIsExternal = false,
			isDefault = false,
		},
	) {
		// Check for duplicate exports
		if (isDefault) {
			// Default exports
			if (declaration !== undefined) {
				___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$checkDuplicateExports(
					parser,
					declaration,
					"default",
				);
			}
			return undefined;
		}

		if (declaration !== undefined) {
			// Exported declarations
			if (declaration.type === "JSFunctionDeclaration") {
				if (declaration.id === undefined) {
					throw new Error("Expected declaration.id");
				}

				___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$checkDuplicateExports(
					parser,
					declaration,
					declaration.id.name,
				);
			}

			if (declaration.type === "JSClassDeclaration") {
				if (declaration.id === undefined) {
					throw new Error("Expected declaration.id");
				}

				___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$checkDuplicateExports(
					parser,
					declaration,
					declaration.id.name,
				);
			}

			if (declaration.type === "JSVariableDeclaration") {
				for (const node of ___R$project$rome$$internal$js$ast$utils$getBindingIdentifiers_ts$getBindingIdentifiers(
					declaration,
				)) {
					___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$checkDuplicateExports(
						parser,
						node,
						node.name,
					);
				}
			}
		}

		if (specifiers !== undefined) {
			// Named exports
			for (const specifier of specifiers) {
				if (specifier === undefined) {
					continue;
				}

				___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$checkDuplicateExports(
					parser,
					specifier,
					specifier.exported.name,
				);

				if (specifier.type === "JSExportLocalSpecifier" && !localIsExternal) {
					const {local} = specifier;
					if (local !== undefined) {
						// check for keywords used as local names
						___R$project$rome$$internal$js$parser$parser$expression_ts$checkReservedWord(
							parser,
							local.name,
							parser.getLoc(local),
							true,
							false,
						);
					}
				}
			}
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$checkDuplicateExports(
		parser,
		node,
		name,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$isSyntaxEnabled(
				parser,
				"ts",
			)
		) {
			// Refer to checkReservedWord for an explanation
			return undefined;
		}

		const existing = parser.state.exportedIdentifiers.get(name);
		if (existing !== undefined) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					loc: node.loc,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.DUPLICATE_EXPORT(
						name,
						existing,
					),
				},
			);
		}

		parser.state.exportedIdentifiers.set(name, parser.getLoc(node));
	}

	// Parses a comma-separated list of module exports.
	function ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseExportSpecifiers(
		parser,
	) {
		const specifiers = [];
		let first = true;

		// export { x, y as z } [from '...']';
		const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
			"export specifiers",
		);

		while (true) {
			if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
				) ||
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eof,
				)
			) {
				___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
					parser,
					openContext,
				);
				break;
			}

			if (first) {
				first = false;
			} else {
				___R$project$rome$$internal$js$parser$parser_ts$expect(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
				);
				if (
					___R$project$rome$$internal$js$parser$parser_ts$eat(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
					)
				) {
					break;
				}
			}

			const start = parser.getPosition();
			const local = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseReferenceIdentifier(
				parser,
				true,
			);
			const exported = ___R$project$rome$$internal$js$parser$parser_ts$eatContextual(
				parser,
				"as",
			)
				? ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier(
						parser,
						true,
					)
				: ___R$project$rome$$internal$js$parser$parser$expression_ts$toIdentifier(
						parser,
						___R$project$rome$$internal$js$parser$parser_ts$cloneNode(
							parser,
							local,
						),
					);
			specifiers.push(
				parser.finishNode(
					start,
					{
						type: "JSExportLocalSpecifier",
						local,
						exported,
						// TODO exportKind?
					},
				),
			);
		}

		return specifiers;
	}

	function ___R$project$rome$$internal$js$parser$parser$modules_ts$parseImport(
		parser,
		start,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name,
			) &&
			___R$project$rome$$internal$js$parser$parser_ts$lookaheadState(parser).tokenType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eq
		) {
			return ___R$project$rome$$internal$js$parser$parser$typescript_ts$parseTSImportEqualsDeclaration(
				parser,
				start,
			);
		}

		let namedSpecifiers = [];
		let namespaceSpecifier;
		let defaultSpecifier;
		let source;
		let importKind;

		// import '...'
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.string,
			)
		) {
			source = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseStringLiteral(
				parser,
			);
		} else {
			({
				namedSpecifiers,
				namespaceSpecifier,
				defaultSpecifier,
				importKind,
			} = ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseImportSpecifiers(
				parser,
				start,
			));

			if (
				___R$project$rome$$internal$js$parser$parser_ts$expectContextual(
					parser,
					"from",
				) &&
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.string,
				)
			) {
				source = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseStringLiteral(
					parser,
				);
			} else {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.IMPORT_MISSING_SOURCE,
					},
				);

				source = parser.finishNode(
					start,
					{
						type: "JSStringLiteral",
						value: "",
					},
				);
			}
		}

		___R$project$rome$$internal$js$parser$parser_ts$semicolon(parser);
		return parser.finishNode(
			start,
			{
				type: "JSImportDeclaration",
				namedSpecifiers,
				namespaceSpecifier,
				defaultSpecifier,
				source,
				importKind,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$shouldParseDefaultImport(
		parser,
		kind,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser$modules_ts$hasTypeImportKind(
				kind,
			)
		) {
			return ___R$project$rome$$internal$js$parser$parser$modules_ts$isMaybeDefaultImport(
				parser.state,
			);
		} else {
			return ___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name,
			);
		}
	}

	function ___R$project$rome$$internal$js$parser$parser$modules_ts$isMaybeDefaultImport(
		state,
	) {
		return (
			(state.tokenType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name ||
			!!state.tokenType.keyword) &&
			state.tokenValue !== "from"
		);
	}

	function ___R$project$rome$$internal$js$parser$parser$modules_ts$hasTypeImportKind(
		kind,
	) {
		return kind === "type" || kind === "typeof";
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseImportSpecifierLocal(
		parser,
		importKind,
		contextDescription,
	) {
		const start = parser.getPosition();

		const local = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseBindingIdentifier(
			parser,
		);

		___R$project$rome$$internal$js$parser$parser$lval_ts$checkLVal(
			parser,
			local,
			true,
			undefined,
			contextDescription,
		);

		return parser.finishNode(
			start,
			{
				type: "JSImportSpecifierLocal",
				name: local,
				importKind,
			},
		);
	}

	// Parses a comma-separated list of module imports.
	function ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseImportSpecifiers(
		parser,
		start,
	) {
		let importKind = undefined;

		// Ensure that when parsing `import from './type.js` we don't mistakenly think it's an import type';

		// TODO probably need to check for a comma and `as`
		const lh = ___R$project$rome$$internal$js$parser$parser_ts$lookaheadState(
			parser,
		);
		if (
			lh.tokenType !==
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name ||
			(lh.tokenType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name &&
			lh.tokenValue !== "from")
		) {
			if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._typeof,
				)
			) {
				importKind = "typeof";
			} else if (
				___R$project$rome$$internal$js$parser$parser_ts$isContextual(
					parser,
					"type",
				)
			) {
				importKind = "type";
			}
		}

		if (importKind) {
			if (
				___R$project$rome$$internal$js$parser$parser$modules_ts$isMaybeDefaultImport(
					lh,
				) ||
				lh.tokenType ===
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL ||
				lh.tokenType ===
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.star
			) {
				___R$project$rome$$internal$js$parser$parser_ts$next(parser);
			}
		}

		let namedSpecifiers = [];
		let namespaceSpecifier;
		let defaultSpecifier;

		let first = true;

		// import defaultObj, { x, y as z } from '...'';
		if (
			___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$shouldParseDefaultImport(
				parser,
				importKind,
			)
		) {
			const meta = ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseImportSpecifierLocal(
				parser,
				importKind,
				"default import specifier",
			);

			defaultSpecifier = parser.finishNode(
				start,
				{
					type: "JSImportDefaultSpecifier",
					local: meta,
				},
			);

			if (
				!___R$project$rome$$internal$js$parser$parser_ts$eat(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
				)
			) {
				return {
					namedSpecifiers,
					namespaceSpecifier,
					defaultSpecifier,
					importKind,
				};
			}
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.star,
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$next(parser);
			___R$project$rome$$internal$js$parser$parser_ts$expectContextual(
				parser,
				"as",
			);

			const meta = ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseImportSpecifierLocal(
				parser,
				importKind,
				"import namespace specifier",
			);

			namespaceSpecifier = parser.finishNode(
				start,
				{
					type: "JSImportNamespaceSpecifier",
					local: meta,
				},
			);

			return {namedSpecifiers, namespaceSpecifier, defaultSpecifier, importKind};
		}

		const openContext = ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
			"import specifiers",
		);

		while (true) {
			if (
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
				) ||
				___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eof,
				)
			) {
				___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
					parser,
					openContext,
				);
				break;
			}

			if (first) {
				first = false;
			} else {
				// Detect an attempt to deep destructure
				if (
					___R$project$rome$$internal$js$parser$parser_ts$eat(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
					)
				) {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.DESTRUCTURING_IN_IMPORT,
						},
					);
				}

				___R$project$rome$$internal$js$parser$parser_ts$expect(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
				);

				if (
					___R$project$rome$$internal$js$parser$parser_ts$eat(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
					)
				) {
					break;
				}
			}

			namedSpecifiers.push(
				___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseImportSpecifier(
					parser,
					importKind,
				),
			);
		}

		return {namedSpecifiers, namespaceSpecifier, defaultSpecifier, importKind};
	}

	function ___R$$priv$project$rome$$internal$js$parser$parser$modules_ts$parseImportSpecifier(
		parser,
		nodeKind,
	) {
		const start = parser.getPosition();
		const firstIdentPos = parser.state.startPos;
		const firstIdent = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier(
			parser,
			true,
		);

		let imported;
		let local;
		let importKind = undefined;
		if (firstIdent.name === "type") {
			importKind = "type";
		} else if (firstIdent.name === "typeof") {
			importKind = "typeof";
		}

		let isBinding = false;
		if (
			___R$project$rome$$internal$js$parser$parser_ts$isContextual(parser, "as") &&
			!___R$project$rome$$internal$js$parser$parser_ts$isLookaheadContextual(
				parser,
				"as",
			)
		) {
			const asIdent = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier(
				parser,
				true,
			);
			if (
				importKind !== undefined &&
				!___R$project$rome$$internal$js$parser$parser_ts$match(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name,
				) &&
				parser.state.tokenType.keyword === undefined
			) {
				// `import {type as ,` or `import {type as }`
				imported = asIdent;
				local = ___R$project$rome$$internal$js$parser$parser$expression_ts$toBindingIdentifier(
					parser,
					___R$project$rome$$internal$js$parser$parser_ts$cloneNode(
						parser,
						asIdent,
					),
				);
			} else {
				// `import {type as foo`
				imported = firstIdent;
				importKind = undefined;
				local = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseBindingIdentifier(
					parser,
				);
			}
		} else if (
			importKind !== undefined &&
			(___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name,
			) ||
			parser.state.tokenType.keyword)
		) {
			// `import {type foo`
			imported = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseIdentifier(
				parser,
				true,
			);
			if (
				___R$project$rome$$internal$js$parser$parser_ts$eatContextual(
					parser,
					"as",
				)
			) {
				local = ___R$project$rome$$internal$js$parser$parser$expression_ts$parseBindingIdentifier(
					parser,
				);
			} else {
				isBinding = true;
				local = ___R$project$rome$$internal$js$parser$parser$expression_ts$toBindingIdentifier(
					parser,
					___R$project$rome$$internal$js$parser$parser_ts$cloneNode(
						parser,
						imported,
					),
				);
			}
		} else {
			isBinding = true;
			imported = firstIdent;
			importKind = undefined;
			local = ___R$project$rome$$internal$js$parser$parser$expression_ts$toBindingIdentifier(
				parser,
				___R$project$rome$$internal$js$parser$parser_ts$cloneNode(
					parser,
					imported,
				),
			);
		}

		const nodeIsTypeImport = ___R$project$rome$$internal$js$parser$parser$modules_ts$hasTypeImportKind(
			nodeKind,
		);
		const specifierIsTypeImport = ___R$project$rome$$internal$js$parser$parser$modules_ts$hasTypeImportKind(
			importKind,
		);

		if (nodeIsTypeImport && specifierIsTypeImport) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					start: firstIdentPos,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.IMPORT_KIND_SPECIFIER_ON_IMPORT_DECLARATION_WITH_KIND,
				},
			);
		}

		const loc = parser.finishLoc(start);

		if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {
			___R$project$rome$$internal$js$parser$parser$expression_ts$checkReservedWord(
				parser,
				local.name,
				loc,
				true,
				true,
			);
		}

		___R$project$rome$$internal$js$parser$parser$lval_ts$checkLVal(
			parser,
			local,
			true,
			undefined,
			"import specifier",
		);

		return parser.finishNode(
			start,
			{
				type: "JSImportSpecifier",
				imported,
				local: parser.finishNode(
					start,
					{
						type: "JSImportSpecifierLocal",
						name: local,
						importKind,
					},
				),
			},
		);
	}


  // project-rome/@internal/js-parser/parser/index.ts



  // project-rome/@internal/js-parser/parser.ts
const ___R$$priv$project$rome$$internal$js$parser$parser_ts$TOKEN_MISTAKES = {
		";": ":",
		",": ".",
	};

	class ___R$project$rome$$internal$js$parser$parser_ts$DiagnosticsFatalError
		extends Error {
		constructor() {
			super(
				"Diagnostics exceeded maxDiagnostics state cap, this error is expected to be handled by a try-catch in the call stack",
			);
		}
	}

	const ___R$$priv$project$rome$$internal$js$parser$parser_ts$SCOPE_TYPES = [
		"FUNCTION_LOC",
		"NON_ARROW_FUNCTION",
		"FUNCTION",
		"GENERATOR",
		"ASYNC",
		"PROPERTY_NAME",
		"CLASS_PROPERTY",
		"PARAMETERS",
		"METHOD",
		"CLASS",
		"TYPE",
		"MAX_NEW_DIAGNOSTICS",
		"STRICT",
		"FLOW_COMMENT",
	];

	const ___R$$priv$project$rome$$internal$js$parser$parser_ts$EMPTY_POS = {
		line: ___R$project$rome$$internal$ob1$index_ts$ob1Number1,
		column: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
	};

	const ___R$project$rome$$internal$js$parser$parser_ts$createJSParser = ___R$project$rome$$internal$parser$core$utils_ts$createParser({
		diagnosticCategory: "parse/js",
		getInitialState() {
			return {
				scopes: {},
				hasHoistedVars: false,
				tokens: [],
				potentialArrowAt: ___R$project$rome$$internal$ob1$index_ts$ob1Number0Neg1,
				commaAfterSpreadAt: ___R$project$rome$$internal$ob1$index_ts$ob1Number0Neg1,
				yieldPos: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
				awaitPos: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
				noArrowAt: [],
				noArrowParamsConversionAt: [],
				maybeInArrowParameters: false,
				isIterator: false,
				noAnonFunctionType: false,
				classLevel: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
				labels: [],
				yieldInPossibleArrowParameters: undefined,
				index: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
				lineStartIndex: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
				curLine: ___R$project$rome$$internal$ob1$index_ts$ob1Number1,
				tokenType: ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eof,
				tokenValue: undefined,
				startPos: ___R$$priv$project$rome$$internal$js$parser$parser_ts$EMPTY_POS,
				endPos: ___R$$priv$project$rome$$internal$js$parser$parser_ts$EMPTY_POS,
				lastStartPos: ___R$$priv$project$rome$$internal$js$parser$parser_ts$EMPTY_POS,
				lastEndPos: ___R$$priv$project$rome$$internal$js$parser$parser_ts$EMPTY_POS,
				startIndex: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
				endIndex: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
				lastEndIndex: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
				lastStartIndex: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
				context: [
					___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.braceStatement,
				],
				exprAllowed: true,
				containsOctal: false,
				escapePosition: undefined,
				octalPosition: undefined,
				invalidTemplateEscapePosition: undefined,
				exportedIdentifiers: new Map(),
				lineStart: true,
				indentLevel: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
			};
		},

		overrides: {
			getPosition(parser) {
				return parser.state.startPos;
			},

			getIndex(parser) {
				return parser.state.startIndex;
			},

			getLastEndPosition(parser) {
				return parser.state.lastEndPos;
			},
		},
	});

	function ___R$project$rome$$internal$js$parser$parser_ts$resetTokenizerLine(
		parser,
	) {
		const {state} = parser;
		state.lineStartIndex = state.index;
		state.lineStart = true;
		state.indentLevel = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$getScope(
		parser,
		type,
	) {
		let scope = parser.state.scopes[type];
		if (scope === undefined) {
			scope = [];
			parser.state.scopes[type] = scope;
		}
		return scope;
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$getLastScope(
		parser,
		type,
	) {
		const scope = ___R$project$rome$$internal$js$parser$parser_ts$getScope(
			parser,
			type,
		);
		return scope[scope.length - 1];
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$pushScope(
		parser,
		type,
		value,
	) {
		___R$project$rome$$internal$js$parser$parser_ts$getScope(parser, type).push(
			value,
		);
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$popScope(
		parser,
		type,
	) {
		___R$project$rome$$internal$js$parser$parser_ts$getScope(parser, type).pop();
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$inScope(parser, type) {
		return (
			___R$project$rome$$internal$js$parser$parser_ts$hasScope(parser, type) &&
			___R$project$rome$$internal$js$parser$parser_ts$getLastScope(parser, type) !==
			false
		);
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$hasScope(
		parser,
		type,
	) {
		const scope = parser.state.scopes[type];
		return scope !== undefined && scope.length > 0;
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$addParenthesized(
		parser,
		node,
	) {
		parser.meta.parenthesized.add(
			___R$project$rome$$internal$parser$core$utils_ts$derivePositionKey(
				parser.getLoc(node).start,
			),
		);
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$isParenthesized(
		parser,
		node,
	) {
		return parser.meta.parenthesized.has(
			___R$project$rome$$internal$parser$core$utils_ts$derivePositionKey(
				parser.getLoc(node).start,
			),
		);
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$setState(
		parser,
		newState,
	) {
		// Verify that this new state doesn't exceed any previous maxDiagnostic cap
		// maxDiagnostics will be at -1 when it's own limit has been exceeded, in
		// this case, we are likely replacing the State with another that's valid
		// and doesn't exceed
		const maxDiagnostics = ___R$project$rome$$internal$js$parser$parser_ts$getLastScope(
			parser,
			"MAX_NEW_DIAGNOSTICS",
		);
		if (typeof maxDiagnostics === "number" && maxDiagnostics !== -1) {
			const diff = newState.diagnostics.length - parser.state.diagnostics.length;
			if (diff > maxDiagnostics) {
				throw new ___R$project$rome$$internal$js$parser$parser_ts$DiagnosticsFatalError();
			}
		}

		parser.state = newState;
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$atEOF(parser) {
		return ___R$project$rome$$internal$js$parser$parser_ts$match(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eof,
		);
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$createBranch(parser) {
		return new ___R$project$rome$$internal$js$parser$ParserBranchFinder_ts$default(
			parser,
		);
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$tryBranch(parser, fn) {
		const branch = new ___R$project$rome$$internal$js$parser$ParserBranchFinder_ts$default(
			parser,
		);
		branch.add(fn, {maxNewDiagnostics: 0});
		if (branch.hasBranch()) {
			return branch.pickOptional();
		} else {
			return undefined;
		}
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$createUnknownIdentifier(
		parser,
		reason,
		start = parser.getPosition(),
		end = parser.getLastEndPosition(),
	) {
		parser.state.corrupt = true;
		return {
			type: "JSIdentifier",
			name: "INVALID_PLACEHOLDER",
			loc: parser.finishLocAt(start, end),
		};
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$assertNoSpace(
		parser,
		_metadata = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.UNEXPECTED_SPACE,
	) {
		const {state} = parser;
		if (
			___R$project$rome$$internal$parser$core$utils_ts$comparePositions(
				state.startPos,
				state.lastEndPos,
			) ===
			1
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					start: state.lastEndPos,
					end: state.lastEndPos,
					description: _metadata,
				},
			);
		}
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$shouldCreateToken(
		parser,
	) {
		return parser.options.tokens && !parser.meta.isLookahead;
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$createToken(
		parser,
		state,
	) {
		const token = {
			type: state.tokenType,
			loc: {
				filename: parser.filename,
				start: state.startPos,
				end: state.endPos,
			},
		};
		___R$project$rome$$internal$js$parser$parser_ts$pushToken(parser, token);
		return token;
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$pushToken(
		parser,
		token,
	) {
		const lastToken = parser.state.tokens[parser.state.tokens.length - 1];
		if (lastToken !== undefined) {
			if (
				___R$project$rome$$internal$parser$core$utils_ts$comparePositions(
					token.loc.start,
					lastToken.loc.end,
				) ===
				-1
			) {
				throw new Error(
					"Trying to push a token that appears before the last pushed token",
				);
			}
		}

		parser.state.tokens.push(token);
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
		parser,
		opts,
	) {
		if (parser.meta.isLookahead) {
			return;
		}

		let maxDiagnostics = ___R$project$rome$$internal$js$parser$parser_ts$getLastScope(
			parser,
			"MAX_NEW_DIAGNOSTICS",
		);
		if (typeof maxDiagnostics === "number") {
			maxDiagnostics--;
			___R$project$rome$$internal$js$parser$parser_ts$popScope(
				parser,
				"MAX_NEW_DIAGNOSTICS",
			);
			___R$project$rome$$internal$js$parser$parser_ts$pushScope(
				parser,
				"MAX_NEW_DIAGNOSTICS",
				maxDiagnostics,
			);
			if (maxDiagnostics < 0) {
				throw new ___R$project$rome$$internal$js$parser$parser_ts$DiagnosticsFatalError();
			}
		}

		parser.unexpectedDiagnostic(opts);
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$shouldTokenizeJSX(
		parser,
	) {
		return (
			!___R$project$rome$$internal$js$parser$parser_ts$isSyntaxEnabled(
				parser,
				"ts",
			) ||
			___R$project$rome$$internal$js$parser$parser_ts$isSyntaxEnabled(
				parser,
				"jsx",
			)
		);
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$isSyntaxEnabled(
		parser,
		syntax,
	) {
		return parser.meta.syntax.has(syntax);
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$expectSyntaxEnabled(
		parser,
		syntax,
	) {
		if (
			!___R$project$rome$$internal$js$parser$parser_ts$isSyntaxEnabled(
				parser,
				syntax,
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.EXPECTED_ENABLE_SYNTAX(
						syntax,
					),
				},
			);
		}
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$isRelational(
		parser,
		op,
	) {
		return (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.relational,
			) && parser.state.tokenValue === op
		);
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$expectRelational(
		parser,
		op,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$eatRelational(parser, op)
		) {
			return true;
		} else {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.EXPECTED_RELATIONAL_OPERATOR,
				},
			);
			return false;
		}
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$banUnicodeEscape(
		parser,
		index,
		name,
	) {
		if (index !== undefined) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					index,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.ESCAPE_SEQUENCE_IN_WORD(
						name,
					),
				},
			);
		}
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$eatRelational(
		parser,
		op,
	) {
		if (___R$project$rome$$internal$js$parser$parser_ts$isRelational(parser, op)) {
			___R$project$rome$$internal$js$parser$parser_ts$next(parser);
			return true;
		} else {
			return false;
		}
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$isContextual(
		parser,
		name,
	) {
		return (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name,
			) &&
			parser.state.tokenValue === name &&
			parser.state.escapePosition === undefined
		);
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$isLookaheadContextual(
		parser,
		name,
	) {
		const l = ___R$project$rome$$internal$js$parser$parser_ts$lookaheadState(
			parser,
		);
		return (
			l.tokenType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name &&
			l.tokenValue === name &&
			l.escapePosition === undefined
		);
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$eatContextual(
		parser,
		name,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$isContextual(parser, name)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$next(parser);
			return true;
		} else {
			return false;
		}
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$expectContextual(
		parser,
		name,
		_metadata = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.EXPECTED_KEYWORD(
			name,
		),
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$eatContextual(
				parser,
				name,
			)
		) {
			return true;
		} else {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: _metadata,
				},
			);
			return false;
		}
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$canInsertSemicolon(
		parser,
	) {
		return (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eof,
			) ||
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
			) ||
			___R$project$rome$$internal$js$parser$parser_ts$hasPrecedingLineBreak(
				parser,
			)
		);
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$hasPrecedingLineBreak(
		parser,
	) {
		return ___R$project$rome$$internal$js$parser$utils$whitespace_ts$lineBreak.test(
			parser.getRawInput(
				parser.getIndexFromPosition(parser.state.lastEndPos, parser.filename),
				parser.getIndexFromPosition(parser.state.startPos, parser.filename),
			),
		);
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$isLineTerminator(
		parser,
	) {
		return (
			___R$project$rome$$internal$js$parser$parser_ts$eat(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.semi,
			) ||
			___R$project$rome$$internal$js$parser$parser_ts$canInsertSemicolon(parser)
		);
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$semicolon(parser) {
		if (
			!___R$project$rome$$internal$js$parser$parser_ts$isLineTerminator(parser)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.EXPECTED_SEMI_OR_LINE_TERMINATOR,
				},
			);
		}
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$expect(
		parser,
		type,
		pos,
	) {
		if (___R$project$rome$$internal$js$parser$parser_ts$eat(parser, type)) {
			return true;
		} else {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedToken(
				parser,
				pos,
				type,
			);
			return false;
		}
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$expectOpening(
		parser,
		open,
		close,
		name,
	) {
		const pos = parser.getPosition();
		const indent = parser.state.indentLevel;
		___R$project$rome$$internal$js$parser$parser_ts$expect(parser, open);
		return {
			indent,
			start: pos,
			name,
			open,
			close,
		};
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$expectClosing(
		parser,
		context,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				context.close,
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$next(parser);
			return true;
		} else {
			const currPos = parser.getPosition();

			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.EXPECTED_CLOSING(
						context.name,
						context.close.label,
						{
							filename: parser.filename,
							start: currPos,
							end: currPos,
						},
					),
					start: context.start,
					end: context.start,
				},
			);

			return false;
		}
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$unexpectedToken(
		parser,
		pos,
		tokenType,
	) {
		let expectedToken;
		let possibleShiftMistake = false;

		if (tokenType !== undefined) {
			expectedToken = tokenType.label;

			const possibleMistake = ___R$$priv$project$rome$$internal$js$parser$parser_ts$TOKEN_MISTAKES[tokenType.label];
			possibleShiftMistake =
				possibleMistake !== undefined &&
				possibleMistake === parser.state.tokenType.label;
		}

		___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
			parser,
			{
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.UNEXPECTED_TOKEN(
					expectedToken,
					possibleShiftMistake,
				),
				start: pos == null ? parser.state.startPos : pos,
				end: pos == null ? parser.state.endPos : pos,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$cloneNode(
		parser,
		node,
	) {
		if (
			node.leadingComments === undefined &&
			node.trailingComments === undefined &&
			node.innerComments === undefined
		) {
			return Object.assign({}, node);
		} else {
			return Object.assign(
				{},
				node,
				{
					leadingComments: undefined,
					trailingComments: undefined,
					innerComments: undefined,
				},
			);
		}
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$resetStartLocationFromNode(
		parser,
		node,
		locationNode,
	) {
		node.loc = Object.assign(
			{},
			parser.getLoc(node),
			{start: parser.getLoc(locationNode).start},
		);
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$next(parser) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$shouldCreateToken(parser)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$createToken(
				parser,
				parser.state,
			);
		}

		parser.state.lastEndPos = parser.state.endPos;
		parser.state.lastStartPos = parser.state.startPos;
		parser.state.lastEndIndex = parser.state.endIndex;
		parser.state.lastStartIndex = parser.state.startIndex;
		___R$project$rome$$internal$js$parser$tokenizer$index_ts$nextToken(parser);
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$eat(parser, type) {
		if (___R$project$rome$$internal$js$parser$parser_ts$match(parser, type)) {
			___R$project$rome$$internal$js$parser$parser_ts$next(parser);
			return true;
		}

		return false;
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$match(parser, type) {
		return parser.state.tokenType === type;
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$lookaheadState(
		parser,
	) {
		const old = parser.state;
		parser.state = ___R$project$rome$$internal$js$parser$parser_ts$cloneState(
			parser,
			true,
		);

		parser.meta.isLookahead = true;
		___R$project$rome$$internal$js$parser$parser_ts$next(parser);
		parser.meta.isLookahead = false;

		const curr = parser.state;
		parser.state = old;
		return curr;
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$cloneState(
		parser,
		skipArrays = false,
	) {
		const state = Object.assign({}, parser.state);

		for (const key in state) {
			// @ts-ignore
			let val = state[key];

			const shouldSlice = !skipArrays || key === "context";
			if (shouldSlice && Array.isArray(val)) {
				// @ts-ignore
				state[key] = val.slice();
			}
		}

		const scopes = Object.assign({}, state.scopes);
		state.scopes = scopes;
		for (const type of ___R$$priv$project$rome$$internal$js$parser$parser_ts$SCOPE_TYPES) {
			const scope = scopes[type];
			if (scope !== undefined) {
				scopes[type] = scope.slice();
			}
		}

		return state;
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$getPositionFromState(
		parser,
	) {
		const {state} = parser;
		const pos = {
			line: state.curLine,
			column: ___R$project$rome$$internal$ob1$index_ts$ob1Sub(
				state.index,
				state.lineStartIndex,
			),
		};
		parser.indexTracker.setPositionIndex(pos, state.index);
		return pos;
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$createMeta(opts) {
		return {
			isLookahead: false,
			inModule: opts.sourceType === "template" || opts.sourceType === "module",
			parenthesized: new Set(),
			syntax: new Set(opts.syntax),
		};
	}

	function ___R$project$rome$$internal$js$parser$parser_ts$parseRoot(parser) {
		if (parser.meta.inModule) {
			___R$project$rome$$internal$js$parser$parser_ts$pushScope(
				parser,
				"ASYNC",
				true,
			);
			___R$project$rome$$internal$js$parser$parser_ts$pushScope(
				parser,
				"STRICT",
				true,
			);
		}

		const program = ___R$project$rome$$internal$js$parser$parser$statement_ts$parseTopLevel(
			parser,
		);

		if (parser.meta.inModule) {
			___R$project$rome$$internal$js$parser$parser_ts$popScope(parser, "ASYNC");
			___R$project$rome$$internal$js$parser$parser_ts$popScope(parser, "STRICT");
		}

		// Smoke test for unpopped scopes
		for (const type of ___R$$priv$project$rome$$internal$js$parser$parser_ts$SCOPE_TYPES) {
			if (___R$project$rome$$internal$js$parser$parser_ts$hasScope(parser, type)) {
				throw new Error(
					"Finished parsing but there was still a " + type + " scope stack",
				);
			}
		}

		// Smoke test for token exhaustion
		if (
			!___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eof,
			)
		) {
			throw new Error("Finish parsing but we arent at the end of the file");
		}

		return program;
	}


  // project-rome/@internal/js-parser/tokenizer/unicodeMistakes.ts
const ___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES = new Map();

	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u07fa",
		["Nko Lajanyalan", "_"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufe4d",
		["Dashed Low Line", "_"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufe4e",
		["Centreline Low Line", "_"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufe4f",
		["Wavy Low Line", "_"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff3f",
		["Fullwidth Low Line", "_"],
	);

	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2010",
		["Hyphen", "-"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2011",
		["Non-Breaking Hyphen", "-"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2012",
		["Figure Dash", "-"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2013",
		["En Dash", "-"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2014",
		["Em Dash", "-"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufe58",
		["Small Em Dash", "-"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u06d4",
		["Arabic Full Stop", "-"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2043",
		["Hyphen Bullet", "-"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02d7",
		["Modifier Letter Minus Sign", "-"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2212",
		["Minus Sign", "-"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2796",
		["Heavy Minus Sign", "-"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2cba",
		["Coptic Letter Dialect-P Ni", "-"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u30fc",
		["Katakana-Hiragana Prolonged Sound Mark", "-"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff0d",
		["Fullwidth Hyphen-Minus", "-"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2015",
		["Horizontal Bar", "-"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2500",
		["Box Drawings Light Horizontal", "-"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2501",
		["Box Drawings Heavy Horizontal", "-"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u31d0",
		["CJK Stroke H", "-"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ua7f7",
		["Latin Epigraphic Letter Dideways", "-"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1173",
		["Hangul Jungseong Eu", "-"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3161",
		["Hangul Letter Eu", "-"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u4e00",
		["CJK Unified Ideograph-4E00", "-"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2f00",
		["Kangxi Radical One", "-"],
	);

	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u060d",
		["Arabic Date Separator", ","],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u066b",
		["Arabic Decimal Separator", ","],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u201a",
		["Single Low-9 Quotation Mark", ","],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\xb8",
		["Cedilla", ","],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ua4f9",
		["Lisu Letter Tone Na Po", ","],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff0c",
		["Fullwidth Comma", ","],
	);

	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u037e",
		["Greek Question Mark", ";"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff1b",
		["Fullwidth Semicolon", ";"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufe14",
		["Presentation Form For Vertical Semicolon", ";"],
	);

	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u0903",
		["Devanagari Sign Visarga", ":"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u0a83",
		["Gujarati Sign Visarga", ":"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff1a",
		["Fullwidth Colon", ":"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u0589",
		["Armenian Full Stop", ":"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u0703",
		["Syriac Supralinear Colon", ":"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u0704",
		["Syriac Sublinear Colon", ":"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u16ec",
		["Runic Multiple Punctuation", ":"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufe30",
		["Presentation Form For Vertical Two Dot Leader", ":"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1803",
		["Mongolian Full Stop", ":"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1809",
		["Mongolian Manchu Full Stop", ":"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u205a",
		["Two Dot Punctuation", ":"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u05c3",
		["Hebrew Punctuation Sof Pasuq", ":"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02f8",
		["Modifier Letter Raised Colon", ":"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ua789",
		["Modifier Letter Colon", ":"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2236",
		["Ratio", ":"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02d0",
		["Modifier Letter Triangular Colon", ":"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ua4fd",
		["Lisu Letter Tone Mya Jeu", ":"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufe13",
		["Presentation Form For Vertical Colon", ":"],
	);

	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff01",
		["Fullwidth Exclamation Mark", "!"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u01c3",
		["Latin Letter Retroflex Click", "!"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2d51",
		["Tifinagh Letter Tuareg Yang", "!"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufe15",
		["Presentation Form For Vertical Exclamation Mark", "!"],
	);

	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u0294",
		["Latin Letter Glottal Stop", "?"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u0241",
		["Latin Capital Letter Glottal Stop", "?"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u097d",
		["Devanagari Letter Glottal Stop", "?"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u13ae",
		["Cherokee Letter He", "?"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ua6eb",
		["Bamum Letter Ntuu", "?"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff1f",
		["Fullwidth Question Mark", "?"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufe16",
		["Presentation Form For Vertical Question Mark", "?"],
	);

	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u{1d16d}",
		["Musical Symbol Combining Augmentation Dot", "."],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2024",
		["One Dot Leader", "."],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u0701",
		["Syriac Supralinear Full Stop", "."],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u0702",
		["Syriac Sublinear Full Stop", "."],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ua60e",
		["Vai Full Stop", "."],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u{10a50}",
		["Kharoshthi Punctuation Dot", "."],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u0660",
		["Arabic-Indic Digit Zero", "."],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u06f0",
		["Extended Arabic-Indic Digit Zero", "."],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ua4f8",
		["Lisu Letter Tone Mya Ti", "."],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\xb7",
		["Middle Dot", "."],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u30fb",
		["Katakana Middle Dot", "."],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff65",
		["Halfwidth Katakana Middle Dot", "."],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u16eb",
		["Runic Single Punctuation", "."],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u0387",
		["Greek Ano Teleia", "."],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2e31",
		["Word Separator Middle Dot", "."],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u{10101}",
		["Aegean Word Separator Dot", "."],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2022",
		["Bullet", "."],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2027",
		["Hyphenation Point", "."],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2219",
		["Bullet Operator", "."],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u22c5",
		["Dot Operator", "."],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ua78f",
		["Latin Letter Sinological Dot", "."],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1427",
		["Canadian Syllabics Final Middle Dot", "."],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1427",
		["Canadian Syllabics Final Middle Dot", "."],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff0e",
		["Fullwidth Full Stop", "."],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3002",
		["Ideographic Full Stop", "."],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufe12",
		["Presentation Form For Vertical Ideographic Full Stop", "."],
	);

	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u055d",
		["Armenian Comma", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff07",
		["Fullwidth Apostrophe", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2018",
		["Left Single Quotation Mark", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2019",
		["Right Single Quotation Mark", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u201b",
		["Single High-Reversed-9 Quotation Mark", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2032",
		["Prime", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2035",
		["Reversed Prime", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u055a",
		["Armenian Apostrophe", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u05f3",
		["Hebrew Punctuation Geresh", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"`",
		["Grave Accent", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1fef",
		["Greek Varia", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff40",
		["Fullwidth Grave Accent", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\xb4",
		["Acute Accent", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u0384",
		["Greek Tonos", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1ffd",
		["Greek Oxia", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1fbd",
		["Greek Koronis", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1fbf",
		["Greek Psili", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1ffe",
		["Greek Dasia", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02b9",
		["Modifier Letter Prime", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u0374",
		["Greek Numeral Sign", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02c8",
		["Modifier Letter Vertical Line", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02ca",
		["Modifier Letter Acute Accent", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02cb",
		["Modifier Letter Grave Accent", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02f4",
		["Modifier Letter Middle Grave Accent", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02bb",
		["Modifier Letter Turned Comma", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02bd",
		["Modifier Letter Reversed Comma", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02bc",
		["Modifier Letter Apostrophe", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02be",
		["Modifier Letter Right Half Ring", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ua78c",
		["Latin Small Letter Saltillo", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u05d9",
		["Hebrew Letter Yod", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u07f4",
		["Nko High Tone Apostrophe", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u07f5",
		["Nko Low Tone Apostrophe", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u144a",
		["Canadian Syllabics West-Cree P", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u16cc",
		["Runic Letter Short-Twig-Sol S", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u{16f51}",
		["Miao Sign Aspiration", "'"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u{16f52}",
		["Miao Sign Reformed Voicing", "'"],
	);

	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1cd3",
		["Vedic Sign Nihshvasa", '"'],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff02",
		["Fullwidth Quotation Mark", '"'],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u201c",
		["Left Double Quotation Mark", '"'],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u201d",
		["Right Double Quotation Mark", '"'],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u201f",
		["Double High-Reversed-9 Quotation Mark", '"'],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2033",
		["Double Prime", '"'],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2036",
		["Reversed Double Prime", '"'],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3003",
		["Ditto Mark", '"'],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u05f4",
		["Hebrew Punctuation Gershayim", '"'],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02dd",
		["Double Acute Accent", '"'],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02ba",
		["Modifier Letter Double Prime", '"'],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02f6",
		["Modifier Letter Middle Double Acute Accent", '"'],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02f5",
		["Modifier Letter Middle Double Grave Accent", '"'],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02ee",
		["Modifier Letter Double Apostrophe", '"'],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u05f2",
		["Hebrew Ligature Yiddish Double Yod", '"'],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u275e",
		["Heavy Double Comma Quotation Mark Ornament", '"'],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u275d",
		["Heavy Double Turned Comma Quotation Mark Ornament", '"'],
	);

	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff08",
		["Fullwidth Left Parenthesis", "("],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2768",
		["Medium Left Parenthesis Ornament", "("],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufd3e",
		["Ornate Left Parenthesis", "("],
	);

	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff09",
		["Fullwidth Right Parenthesis", ")"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2769",
		["Medium Right Parenthesis Ornament", ")"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufd3f",
		["Ornate Right Parenthesis", ")"],
	);

	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff3b",
		["Fullwidth Left Square Bracket", "["],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2772",
		["Light Left Tortoise Shell Bracket Ornament", "["],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u300c",
		["Left Corner Bracket", "["],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u300e",
		["Left White Corner Bracket", "["],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3010",
		["Left Black Lenticular Bracket", "["],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3014",
		["Left Tortoise Shell Bracket", "["],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3016",
		["Left White Lenticular Bracket", "["],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3018",
		["Left White Tortoise Shell Bracket", "["],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u301a",
		["Left White Square Bracket", "["],
	);

	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff3d",
		["Fullwidth Right Square Bracket", "]"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2773",
		["Light Right Tortoise Shell Bracket Ornament", "]"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u300d",
		["Right Corner Bracket", "]"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u300f",
		["Right White Corner Bracket", "]"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3011",
		["Right Black Lenticular Bracket", "]"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3015",
		["Right Tortoise Shell Bracket", "]"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3017",
		["Right White Lenticular Bracket", "]"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3019",
		["Right White Tortoise Shell Bracket", "]"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u301b",
		["Right White Square Bracket", "]"],
	);

	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2774",
		["Medium Left Curly Bracket Ornament", "{"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u{1d114}",
		["Musical Symbol Brace", "{"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff5b",
		["Fullwidth Left Curly Bracket", "{"],
	);

	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2775",
		["Medium Right Curly Bracket Ornament", "}"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff5d",
		["Fullwidth Right Curly Bracket", "}"],
	);

	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u204e",
		["Low Asterisk", "*"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u066d",
		["Arabic Five Pointed Star", "*"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2217",
		["Asterisk Operator", "*"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u{1031f}",
		["Old Italic Letter Ess", "*"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff0a",
		["Fullwidth Asterisk", "*"],
	);

	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1735",
		["Philippine Single Punctuation", "/"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2041",
		["Caret Insertion Point", "/"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2215",
		["Division Slash", "/"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2044",
		["Fraction Slash", "/"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2571",
		["Box Drawings Light Diagonal Upper Right To Lower Left", "/"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u27cb",
		["Mathematical Rising Diagonal", "/"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u29f8",
		["Big Solidus", "/"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u{1d23a}",
		["Greek Instrumental Notation Symbol-47", "/"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u31d3",
		["CJK Stroke Sp", "/"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3033",
		["Vertical Kana Repeat Mark Upper Half", "/"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2cc6",
		["Coptic Capital Letter Old Coptic Esh", "/"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u30ce",
		["Katakana Letter No", "/"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u4e3f",
		["CJK Unified Ideograph-4E3F", "/"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2f03",
		["Kangxi Radical Slash", "/"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff0f",
		["Fullwidth Solidus", "/"],
	);

	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff3c",
		["Fullwidth Reverse Solidus", "\\"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufe68",
		["Small Reverse Solidus", "\\"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2216",
		["Set Minus", "\\"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u27cd",
		["Mathematical Falling Diagonal", "\\"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u29f5",
		["Reverse Solidus Operator", "\\"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u29f9",
		["Big Reverse Solidus", "\\"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u29f9",
		["Greek Vocal Notation Symbol-16", "\\"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u29f9",
		["Greek Instrumental Symbol-48", "\\"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u31d4",
		["CJK Stroke D", "\\"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u4e36",
		["CJK Unified Ideograph-4E36", "\\"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2f02",
		["Kangxi Radical Dot", "\\"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3001",
		["Ideographic Comma", "\\"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u30fd",
		["Katakana Iteration Mark", "\\"],
	);

	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ua778",
		["Latin Small Letter Um", "&"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff06",
		["Fullwidth Ampersand", "&"],
	);

	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u16ed",
		["Runic Cross Punctuation", "+"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2795",
		["Heavy Plus Sign", "+"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u{1029b}",
		["Lycian Letter H", "+"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufb29",
		["Hebrew Letter Alternative Plus Sign", "+"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff0b",
		["Fullwidth Plus Sign", "+"],
	);

	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2039",
		["Single Left-Pointing Angle Quotation Mark", "<"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u276e",
		["Heavy Left-Pointing Angle Quotation Mark Ornament", "<"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02c2",
		["Modifier Letter Left Arrowhead", "<"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u{1d236}",
		["Greek Instrumental Symbol-40", "<"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1438",
		["Canadian Syllabics Pa", "<"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u16b2",
		["Runic Letter Kauna", "<"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u276c",
		["Medium Left-Pointing Angle Bracket Ornament", "<"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u27e8",
		["Mathematical Left Angle Bracket", "<"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2329",
		["Left-Pointing Angle Bracket", "<"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3008",
		["Left Angle Bracket", "<"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u31db",
		["CJK Stroke Pd", "<"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u304f",
		["Hiragana Letter Ku", "<"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u{21fe8}",
		["CJK Unified Ideograph-21FE8", "<"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u300a",
		["Left Double Angle Bracket", "<"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff1c",
		["Fullwidth Less-Than Sign", "<"],
	);

	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1400",
		["Canadian Syllabics Hyphen", "="],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2e40",
		["Double Hyphen", "="],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u30a0",
		["Katakana-Hiragana Double Hyphen", "="],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ua4ff",
		["Lisu Punctuation Full Stop", "="],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff1d",
		["Fullwidth Equals Sign", "="],
	);

	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u203a",
		["Single Right-Pointing Angle Quotation Mark", ">"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u276f",
		["Heavy Right-Pointing Angle Quotation Mark Ornament", ">"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02c3",
		["Modifier Letter Right Arrowhead", ">"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u{1d237}",
		["Greek Instrumental Symbol-42", ">"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1433",
		["Canadian Syllabics Po", ">"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u{16f3f}",
		["Miao Letter Archaic Zza", ">"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u276d",
		["Medium Right-Pointing Angle Bracket Ornament", ">"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u27e9",
		["Mathematical Right Angle Bracket", ">"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u232a",
		["Right-Pointing Angle Bracket", ">"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3009",
		["Right Angle Bracket", ">"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u300b",
		["Right Double Angle Bracket", ">"],
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff1e",
		["Fullwidth Greater-Than Sign", ">"],
	);

	const ___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES = new Map();
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		" ",
		"Space",
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"_",
		"Underscore",
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"-",
		"Minus/Hyphen",
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		",",
		"Comma",
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		";",
		"Semicolon",
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		":",
		"Colon",
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"!",
		"Exclamation Mark",
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"?",
		"Question Mark",
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		".",
		"Period",
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"'",
		"Single Quote",
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		'"',
		"Quotation Mark",
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"(",
		"Left Parenthesis",
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		")",
		"Right Parenthesis",
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"[",
		"Left Square Bracket",
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"]",
		"Right Square Bracket",
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"{",
		"Left Curly Brace",
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"}",
		"Right Curly Brace",
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"*",
		"Asterisk",
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"/",
		"Slash",
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"\\",
		"Backslash",
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"&",
		"Ampersand",
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"+",
		"Plus Sign",
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"<",
		"Less-Than Sign",
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"=",
		"Equals Sign",
	);
	___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		">",
		"Greater-Than Sign",
	);


  // project-rome/@internal/js-parser/tokenizer/index.ts
const ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$HEX_NUMBER = /^[\da-fA-F]+$/;
	const ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$DECIMAL_NUMBER = /^\d+$/;

	// The following character codes are forbidden from 'being
	// an immediate sibling of JSNumericLiteralSeparator _
	const ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$forbiddenNumericSeparatorSiblings = {
		decBinOct: [
			___R$project$rome$$internal$string$charcodes$index_ts.dot,
			___R$project$rome$$internal$string$charcodes$index_ts.uppercaseB,
			___R$project$rome$$internal$string$charcodes$index_ts.uppercaseE,
			___R$project$rome$$internal$string$charcodes$index_ts.uppercaseO,
			___R$project$rome$$internal$string$charcodes$index_ts.underscore,
			// multiple separators are not allowed
			___R$project$rome$$internal$string$charcodes$index_ts.lowercaseB,
			___R$project$rome$$internal$string$charcodes$index_ts.lowercaseE,
			___R$project$rome$$internal$string$charcodes$index_ts.lowercaseO,
		],
		hex: [
			___R$project$rome$$internal$string$charcodes$index_ts.dot,
			___R$project$rome$$internal$string$charcodes$index_ts.uppercaseX,
			___R$project$rome$$internal$string$charcodes$index_ts.underscore,
			// multiple separators are not allowed
			___R$project$rome$$internal$string$charcodes$index_ts.lowercaseX,
		],
	};

	const ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsBin = [
		// 0 - 1
		___R$project$rome$$internal$string$charcodes$index_ts.digit0,
		___R$project$rome$$internal$string$charcodes$index_ts.digit1,
	];
	const ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsOct = [
		// 0 - 7
		...___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsBin,
		___R$project$rome$$internal$string$charcodes$index_ts.digit2,
		___R$project$rome$$internal$string$charcodes$index_ts.digit3,
		___R$project$rome$$internal$string$charcodes$index_ts.digit4,
		___R$project$rome$$internal$string$charcodes$index_ts.digit5,
		___R$project$rome$$internal$string$charcodes$index_ts.digit6,
		___R$project$rome$$internal$string$charcodes$index_ts.digit7,
	];
	const ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsDec = [
		// 0 - 9
		...___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsOct,
		___R$project$rome$$internal$string$charcodes$index_ts.digit8,
		___R$project$rome$$internal$string$charcodes$index_ts.digit9,
	];

	const ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsHex = [
		// 0 - 9, A - F, a - f,
		...___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsDec,
		___R$project$rome$$internal$string$charcodes$index_ts.uppercaseA,
		___R$project$rome$$internal$string$charcodes$index_ts.uppercaseB,
		___R$project$rome$$internal$string$charcodes$index_ts.uppercaseC,
		___R$project$rome$$internal$string$charcodes$index_ts.uppercaseD,
		___R$project$rome$$internal$string$charcodes$index_ts.uppercaseE,
		___R$project$rome$$internal$string$charcodes$index_ts.uppercaseF,
		___R$project$rome$$internal$string$charcodes$index_ts.lowercaseA,
		___R$project$rome$$internal$string$charcodes$index_ts.lowercaseB,
		___R$project$rome$$internal$string$charcodes$index_ts.lowercaseC,
		___R$project$rome$$internal$string$charcodes$index_ts.lowercaseD,
		___R$project$rome$$internal$string$charcodes$index_ts.lowercaseE,
		___R$project$rome$$internal$string$charcodes$index_ts.lowercaseF,
	];
	const ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblings = {
		bin: ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsBin,
		oct: ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsOct,
		dec: ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsDec,
		hex: ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsHex,
	};

	// Object type used to represent tokens. Note that normally, tokens
	// simply exist as properties on the parser object. This is only
	// used for the onToken callback and the external tokenizer.
	class ___R$project$rome$$internal$js$parser$tokenizer$index_ts$RegExpTokenValue {
		constructor(pattern, flags) {
			this.pattern = pattern;
			this.flags = flags;
		}
	}

	class ___R$project$rome$$internal$js$parser$tokenizer$index_ts$NumberTokenValue {
		constructor(value, format) {
			this.value = value;
			this.format = format;
		}
	}

	// ## Tokenizer
	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
		parser,
	) {
		const index = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(
			parser.state.index,
		);
		parser.state.index = index;
		return index;
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
		parser,
	) {
		return ___R$project$rome$$internal$ob1$index_ts$ob1Get0(parser.state.index);
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$codePointToString(
		code,
	) {
		// UTF-16 Decoding
		if (code <= 65_535) {
			return String.fromCharCode(code);
		} else {
			return String.fromCharCode(
				(code - 65_536 >> 10) + 55_296,
				(code - 65_536 & 1_023) + 56_320,
			);
		}
	}

	// Toggle strict mode. Re-reads the next number or string to please
	// pedantic tests (`"use strict"; 010;` should fail).
	function ___R$project$rome$$internal$js$parser$tokenizer$index_ts$setStrict(
		parser,
		isStrict,
	) {
		___R$project$rome$$internal$js$parser$parser_ts$pushScope(
			parser,
			"STRICT",
			isStrict,
		);

		if (
			!___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.num,
			) &&
			!___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.string,
			)
		) {
			return undefined;
		}

		parser.state.index = parser.state.startIndex;
		while (parser.state.index < parser.state.lineStartIndex) {
			parser.state.lineStartIndex = ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(
				parser.input.lastIndexOf(
					"\n",
					___R$project$rome$$internal$ob1$index_ts$ob1Get0(
						parser.state.lineStartIndex,
					) - 2,
				) + 1,
			);
			parser.state.curLine = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(
				parser.state.curLine,
			);
		}
		___R$project$rome$$internal$js$parser$tokenizer$index_ts$nextToken(parser);
	}

	function ___R$project$rome$$internal$js$parser$tokenizer$index_ts$getCurContext(
		parser,
	) {
		return parser.state.context[parser.state.context.length - 1];
	}

	function ___R$project$rome$$internal$js$parser$tokenizer$index_ts$nextToken(
		parser,
	) {
		const curContext = ___R$project$rome$$internal$js$parser$tokenizer$index_ts$getCurContext(
			parser,
		);

		if (!curContext || !curContext.preserveSpace) {
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$skipSpace(
				parser,
			);
		}

		parser.state.containsOctal = false;
		parser.state.octalPosition = undefined;
		parser.state.startPos = ___R$project$rome$$internal$js$parser$parser_ts$getPositionFromState(
			parser,
		);
		parser.state.startIndex = parser.state.index;

		if (parser.state.index >= parser.length) {
			___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eof,
			);
			return undefined;
		}

		if (curContext !== undefined && curContext.override) {
			curContext.override(parser);
		} else {
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readToken(
				parser,
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$fullCharCodeAtPos(
					parser,
				),
			);
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readToken(
		parser,
		code,
	) {
		const matchedJSX = ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readJSXToken(
			parser,
			code,
		);
		if (matchedJSX) {
			return undefined;
		} else {
			return ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readNormalToken(
				parser,
				code,
			);
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readJSXToken(
		parser,
		code,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$inScope(
				parser,
				"PROPERTY_NAME",
			)
		) {
			return false;
		}

		if (___R$project$rome$$internal$js$parser$parser_ts$inScope(parser, "TYPE")) {
			return false;
		}

		if (
			!___R$project$rome$$internal$js$parser$parser_ts$shouldTokenizeJSX(parser)
		) {
			return false;
		}

		const context = ___R$project$rome$$internal$js$parser$tokenizer$index_ts$getCurContext(
			parser,
		);

		if (
			context ===
			___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.jsxInner
		) {
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenJsx(
				parser,
			);
			return true;
		}

		if (
			context ===
			___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.jsxOpenTag ||
			context ===
			___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.jsxCloseTag
		) {
			if (
				___R$project$rome$$internal$js$parser$utils$identifier_ts$isIdentifierStart(
					code,
				)
			) {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenJsxWord(
					parser,
				);
				return true;
			}

			if (
				code ===
				___R$project$rome$$internal$string$charcodes$index_ts.greaterThan
			) {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
				___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.jsxTagEnd,
				);
				return true;
			}

			if (
				(code ===
				___R$project$rome$$internal$string$charcodes$index_ts.quotationMark ||
				code ===
				___R$project$rome$$internal$string$charcodes$index_ts.apostrophe) &&
				context ===
				___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.jsxOpenTag
			) {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenJsxString(
					parser,
					code,
				);
				return true;
			}
		}

		if (
			code === ___R$project$rome$$internal$string$charcodes$index_ts.lessThan &&
			parser.state.exprAllowed &&
			parser.input.charCodeAt(
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
					parser,
				) + 1,
			) !==
			___R$project$rome$$internal$string$charcodes$index_ts.exclamationMark
		) {
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
			___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.jsxTagStart,
			);
			return true;
		}

		return false;
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readNormalToken(
		parser,
		code,
	) {
		// JSIdentifier or keyword. '\uXXXX' sequences are allowed in
		// identifiers, so '\' also dispatches to that.
		if (
			___R$project$rome$$internal$js$parser$utils$identifier_ts$isIdentifierStart(
				code,
			) ||
			code === ___R$project$rome$$internal$string$charcodes$index_ts.backslash
		) {
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readWord(
				parser,
			);
		} else {
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getTokenFromCode(
				parser,
				code,
			);
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$fullCharCodeAtPos(
		parser,
	) {
		return ___R$project$rome$$internal$js$parser$utils$identifier_ts$getFullCharCodeAt(
			parser.input,
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
				parser,
			),
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$pushComment(
		parser,
		opts,
	) {
		const loc = parser.finishLocAt(opts.startPos, opts.endPos);
		let comment;
		if (opts.block) {
			comment = parser.comments.createComment({
				type: "CommentBlock",
				value: ___R$project$rome$$internal$string$utils$removeCarriageReturn_ts$removeCarriageReturn(
					opts.text,
				),
				loc,
			});
		} else {
			comment = parser.comments.createComment({
				type: "CommentLine",
				value: opts.text,
				loc,
			});
		}

		// We should enable jsx syntax when there's a comment with @\jsx
		if (opts.text.includes("@jsx")) {
			parser.meta.syntax.add("jsx");
		}

		if (!parser.meta.isLookahead) {
			parser.registerComment(comment);
		}

		if (
			___R$project$rome$$internal$js$parser$parser_ts$shouldCreateToken(parser)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$pushToken(
				parser,
				{
					type: ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comment,
					loc,
				},
			);
		}

		return comment;
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$skipBlockComment(
		parser,
	) {
		const startPos = ___R$project$rome$$internal$js$parser$parser_ts$getPositionFromState(
			parser,
		);
		const startIndex = parser.state.index;
		parser.state.index = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
			parser.state.index,
			2,
		);

		const endIndex = ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(
			parser.input.indexOf(
				"*/",
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
			),
		);

		if (endIndex === ___R$project$rome$$internal$ob1$index_ts$ob1Number0Neg1) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					end: parser.getPositionFromIndex(
						___R$project$rome$$internal$ob1$index_ts$ob1Sub(
							parser.state.index,
							2,
						),
					),
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.UNTERMINATED_BLOCK_COMMENT,
				},
			);
			return undefined;
		}

		// Skip */
		parser.state.index = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
			endIndex,
			2,
		);

		___R$project$rome$$internal$js$parser$utils$whitespace_ts$lineBreakG.lastIndex = ___R$project$rome$$internal$ob1$index_ts$ob1Get0(
			startIndex,
		);

		let match;
		while (
			(match = ___R$project$rome$$internal$js$parser$utils$whitespace_ts$lineBreakG.exec(
				parser.input,
			)) &&
			match.index <
			___R$project$rome$$internal$ob1$index_ts$ob1Get0(parser.state.index)
		) {
			parser.state.curLine = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(
				parser.state.curLine,
			);
			___R$project$rome$$internal$js$parser$parser_ts$resetTokenizerLine(parser);
			parser.state.lineStartIndex = ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(
				match.index + match[0].length,
			);
		}

		___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$pushComment(
			parser,
			{
				block: true,
				text: parser.getRawInput(
					___R$project$rome$$internal$ob1$index_ts$ob1Add(startIndex, 2),
					endIndex,
				),
				startPos,
				endPos: ___R$project$rome$$internal$js$parser$parser_ts$getPositionFromState(
					parser,
				),
			},
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$parseLineComment(
		parser,
		startSkip,
	) {
		const startIndex = parser.state.index;
		const startPos = ___R$project$rome$$internal$js$parser$parser_ts$getPositionFromState(
			parser,
		);
		parser.state.index = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
			parser.state.index,
			startSkip,
		);
		let ch = parser.input.charCodeAt(
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
				parser,
			),
		);
		if (parser.state.index < parser.length) {
			while (
				ch !== ___R$project$rome$$internal$string$charcodes$index_ts.lineFeed &&
				ch !==
				___R$project$rome$$internal$string$charcodes$index_ts.carriageReturn &&
				ch !==
				___R$project$rome$$internal$string$charcodes$index_ts.lineSeparator &&
				ch !==
				___R$project$rome$$internal$string$charcodes$index_ts.paragraphSeparator &&
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				) < parser.length
			) {
				ch = parser.input.charCodeAt(
					___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
						parser,
					),
				);
			}
		}
		const endPos = ___R$project$rome$$internal$js$parser$parser_ts$getPositionFromState(
			parser,
		);
		const text = parser.getRawInput(
			___R$project$rome$$internal$ob1$index_ts$ob1Add(startIndex, startSkip),
			parser.state.index,
		);

		return {
			startPos,
			endPos,
			text,
		};
	}

	function ___R$project$rome$$internal$js$parser$tokenizer$index_ts$skipLineComment(
		parser,
		startSkip,
	) {
		const lineComment = ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$parseLineComment(
			parser,
			startSkip,
		);
		return ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$pushComment(
			parser,
			{
				block: false,
				text: lineComment.text,
				startPos: lineComment.startPos,
				endPos: lineComment.endPos,
			},
		);
	}

	function ___R$project$rome$$internal$js$parser$tokenizer$index_ts$skipInterpreterDirective(
		parser,
		startSkip,
	) {
		const lineComment = ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$parseLineComment(
			parser,
			startSkip,
		);
		const loc = parser.finishLocAt(lineComment.startPos, lineComment.endPos);
		return {
			type: "JSInterpreterDirective",
			value: lineComment.text,
			loc,
		};
	}

	// Called at the start of the parse and after every token. Skips
	// whitespace and comments, and.
	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$skipSpace(
		parser,
	) {
		loop: while (parser.state.index < parser.length) {
			const ch = parser.input.charCodeAt(
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
			);

			if (parser.state.lineStart) {
				if (
					ch === ___R$project$rome$$internal$string$charcodes$index_ts.space ||
					ch === ___R$project$rome$$internal$string$charcodes$index_ts.tab
				) {
					parser.state.indentLevel = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(
						parser.state.indentLevel,
					);
				} else {
					parser.state.lineStart = false;
				}
			}

			if (
				ch ===
				___R$project$rome$$internal$string$charcodes$index_ts.carriageReturn &&
				parser.input.charCodeAt(
					___R$project$rome$$internal$ob1$index_ts$ob1Get0(parser.state.index) +
					1,
				) === ___R$project$rome$$internal$string$charcodes$index_ts.lineFeed
			) {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
			}

			switch (ch) {
				case ___R$project$rome$$internal$string$charcodes$index_ts.space:
				case ___R$project$rome$$internal$string$charcodes$index_ts.nonBreakingSpace: {
					___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
						parser,
					);
					break;
				}

				case ___R$project$rome$$internal$string$charcodes$index_ts.carriageReturn:
				case ___R$project$rome$$internal$string$charcodes$index_ts.lineFeed:
				case ___R$project$rome$$internal$string$charcodes$index_ts.lineSeparator:
				case ___R$project$rome$$internal$string$charcodes$index_ts.paragraphSeparator: {
					___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
						parser,
					);
					parser.state.curLine = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(
						parser.state.curLine,
					);
					___R$project$rome$$internal$js$parser$parser_ts$resetTokenizerLine(
						parser,
					);
					break;
				}

				case ___R$project$rome$$internal$string$charcodes$index_ts.slash: {
					switch (
						parser.input.charCodeAt(
							___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
								parser,
							) + 1,
						)
					) {
						case ___R$project$rome$$internal$string$charcodes$index_ts.asterisk: {
							// Break the loop and don't consume Flow comment code
							if (
								parser.input.charCodeAt(
									___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
										parser,
									) + 2,
								) ===
								___R$project$rome$$internal$string$charcodes$index_ts.colon &&
								parser.input.charCodeAt(
									___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
										parser,
									) + 3,
								) ===
								___R$project$rome$$internal$string$charcodes$index_ts.colon
							) {
								break loop;
							}

							___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$skipBlockComment(
								parser,
							);
							break;
						}

						case ___R$project$rome$$internal$string$charcodes$index_ts.slash: {
							___R$project$rome$$internal$js$parser$tokenizer$index_ts$skipLineComment(
								parser,
								2,
							);
							break;
						}

						default:
							break loop;
					}
					break;
				}

				default:
					if (
						(ch >
						___R$project$rome$$internal$string$charcodes$index_ts.backSpace &&
						ch < ___R$project$rome$$internal$string$charcodes$index_ts.shiftOut) ||
						(ch >=
						___R$project$rome$$internal$string$charcodes$index_ts.oghamSpaceMark &&
						___R$project$rome$$internal$js$parser$utils$whitespace_ts$nonASCIIwhitespace.test(
							String.fromCharCode(ch),
						))
					) {
						___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
							parser,
						);
					} else {
						break loop;
					}
			}
		}
	}

	// Called at the end of every token. Sets `end`, `val`, and
	// maintains `context` and `exprAllowed`, and skips the space after
	// the token, so that the next one's `start` will point at the
	// right position.
	function ___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
		parser,
		type,
		val,
	) {
		parser.state.endPos = ___R$project$rome$$internal$js$parser$parser_ts$getPositionFromState(
			parser,
		);
		parser.state.endIndex = parser.state.index;

		const prevType = parser.state.tokenType;
		parser.state.tokenType = type;
		parser.state.tokenValue = val;

		___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$updateContext(
			parser,
			prevType,
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenDot(
		parser,
	) {
		const next = parser.input.charCodeAt(
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
				parser,
			) + 1,
		);
		if (
			next >= ___R$project$rome$$internal$string$charcodes$index_ts.digit0 &&
			next <= ___R$project$rome$$internal$string$charcodes$index_ts.digit9
		) {
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readNumber(
				parser,
				true,
			);
			return undefined;
		}

		const next2 = parser.input.charCodeAt(
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
				parser,
			) + 2,
		);
		if (
			next === ___R$project$rome$$internal$string$charcodes$index_ts.dot &&
			next2 === ___R$project$rome$$internal$string$charcodes$index_ts.dot
		) {
			parser.state.index = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
				parser.state.index,
				3,
			);
			___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.ellipsis,
			);
		} else {
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
			___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.dot,
			);
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenSlash(
		parser,
	) {
		const next = parser.input.charCodeAt(
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
				parser,
			) + 1,
		);

		// If this starts with /*:: then it's a Flow comment

		// TODO Flow also allows "flow-include" in place of "::"
		if (
			next === ___R$project$rome$$internal$string$charcodes$index_ts.asterisk &&
			parser.input.charCodeAt(
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
					parser,
				) + 2,
			) === ___R$project$rome$$internal$string$charcodes$index_ts.colon &&
			parser.input.charCodeAt(
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
					parser,
				) + 3,
			) === ___R$project$rome$$internal$string$charcodes$index_ts.colon
		) {
			parser.state.index = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
				parser.state.index,
				4,
			);
			___R$project$rome$$internal$js$parser$parser_ts$pushScope(
				parser,
				"FLOW_COMMENT",
			);
			___R$project$rome$$internal$js$parser$tokenizer$index_ts$nextToken(parser);
			return;
		}

		// '/'
		if (parser.state.exprAllowed) {
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
			___R$project$rome$$internal$js$parser$tokenizer$index_ts$readRegexp(
				parser,
			);
			return;
		}

		if (next === ___R$project$rome$$internal$string$charcodes$index_ts.equalsTo) {
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$finishOp(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.assign,
				2,
			);
		} else {
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$finishOp(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.slash,
				1,
			);
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenMultModulo(
		parser,
		code,
	) {
		let next = parser.input.charCodeAt(
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
				parser,
			) + 1,
		);

		// */ Is the end of a Flow comment
		if (
			code === ___R$project$rome$$internal$string$charcodes$index_ts.asterisk &&
			___R$project$rome$$internal$js$parser$parser_ts$inScope(
				parser,
				"FLOW_COMMENT",
			) &&
			next === ___R$project$rome$$internal$string$charcodes$index_ts.slash
		) {
			___R$project$rome$$internal$js$parser$parser_ts$popScope(
				parser,
				"FLOW_COMMENT",
			);
			parser.state.index = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
				parser.state.index,
				2,
			);
			___R$project$rome$$internal$js$parser$tokenizer$index_ts$nextToken(parser);
			return;
		}

		// '%*'
		let type =
			code === ___R$project$rome$$internal$string$charcodes$index_ts.asterisk
				? ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.star
				: ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.modulo;
		let width = 1;
		const exprAllowed = parser.state.exprAllowed;

		// Exponentiation operator **
		if (
			code === ___R$project$rome$$internal$string$charcodes$index_ts.asterisk &&
			next === ___R$project$rome$$internal$string$charcodes$index_ts.asterisk
		) {
			width++;
			next = parser.input.charCodeAt(
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
					parser,
				) + 2,
			);
			type = ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.exponent;
		}

		if (
			next === ___R$project$rome$$internal$string$charcodes$index_ts.equalsTo &&
			!exprAllowed
		) {
			width++;
			type = ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.assign;
		}

		___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$finishOp(
			parser,
			type,
			width,
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenPipeAmp(
		parser,
		code,
	) {
		// '|&'
		const next = parser.input.charCodeAt(
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
				parser,
			) + 1,
		);

		if (next === code) {
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$finishOp(
				parser,
				code ===
				___R$project$rome$$internal$string$charcodes$index_ts.verticalBar
					? ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.logicalOR
					: ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.logicalAND,
				2,
			);
			return undefined;
		}

		// '|}'
		if (
			code === ___R$project$rome$$internal$string$charcodes$index_ts.verticalBar &&
			next ===
			___R$project$rome$$internal$string$charcodes$index_ts.rightCurlyBrace
		) {
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$finishOp(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceBarR,
				2,
			);
			return undefined;
		}

		if (next === ___R$project$rome$$internal$string$charcodes$index_ts.equalsTo) {
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$finishOp(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.assign,
				2,
			);
			return undefined;
		}

		___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$finishOp(
			parser,
			code === ___R$project$rome$$internal$string$charcodes$index_ts.verticalBar
				? ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bitwiseOR
				: ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bitwiseAND,
			1,
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenCaret(
		parser,
	) {
		// '^'
		const next = parser.input.charCodeAt(
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
				parser,
			) + 1,
		);
		if (next === ___R$project$rome$$internal$string$charcodes$index_ts.equalsTo) {
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$finishOp(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.assign,
				2,
			);
		} else {
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$finishOp(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bitwiseXOR,
				1,
			);
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenPlusMin(
		parser,
		code,
	) {
		// '+-'
		const next = parser.input.charCodeAt(
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
				parser,
			) + 1,
		);

		if (next === code) {
			if (
				next === ___R$project$rome$$internal$string$charcodes$index_ts.dash &&
				!parser.meta.inModule &&
				parser.input.charCodeAt(
					___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
						parser,
					) + 2,
				) === ___R$project$rome$$internal$string$charcodes$index_ts.greaterThan &&
				(parser.state.lastEndIndex ===
				___R$project$rome$$internal$ob1$index_ts$ob1Number0 ||
				___R$project$rome$$internal$js$parser$utils$whitespace_ts$lineBreak.test(
					parser.getRawInput(parser.state.lastEndIndex, parser.state.index),
				))
			) {
				// A `-->` line comment
				___R$project$rome$$internal$js$parser$tokenizer$index_ts$skipLineComment(
					parser,
					3,
				);
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$skipSpace(
					parser,
				);
				___R$project$rome$$internal$js$parser$tokenizer$index_ts$nextToken(
					parser,
				);
				return undefined;
			}
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$finishOp(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.incDec,
				2,
			);
			return undefined;
		}

		if (next === ___R$project$rome$$internal$string$charcodes$index_ts.equalsTo) {
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$finishOp(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.assign,
				2,
			);
		} else {
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$finishOp(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.plusMin,
				1,
			);
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenLtGt(
		parser,
		code,
	) {
		// '<>'
		const next = parser.input.charCodeAt(
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
				parser,
			) + 1,
		);
		let size = 1;

		// we need to check if we're in a type to avoid interpreting the >> in Array<Array<string>> as a bitshift
		if (
			next === code &&
			!___R$project$rome$$internal$js$parser$parser_ts$inScope(parser, "TYPE")
		) {
			size =
				code ===
				___R$project$rome$$internal$string$charcodes$index_ts.greaterThan &&
				parser.input.charCodeAt(
					___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
						parser,
					) + 2,
				) === ___R$project$rome$$internal$string$charcodes$index_ts.greaterThan
					? 3
					: 2;
			if (
				parser.input.charCodeAt(
					___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
						parser,
					) + size,
				) ===
				___R$project$rome$$internal$string$charcodes$index_ts.equalsTo
			) {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$finishOp(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.assign,
					size + 1,
				);
				return undefined;
			}
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$finishOp(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bitShift,
				size,
			);
			return undefined;
		}

		if (
			code === ___R$project$rome$$internal$string$charcodes$index_ts.lessThan &&
			next ===
			___R$project$rome$$internal$string$charcodes$index_ts.exclamationMark &&
			!parser.meta.inModule &&
			parser.input.charCodeAt(
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
					parser,
				) + 2,
			) === ___R$project$rome$$internal$string$charcodes$index_ts.dash &&
			parser.input.charCodeAt(
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
					parser,
				) + 3,
			) === ___R$project$rome$$internal$string$charcodes$index_ts.dash
		) {
			// `<!--`, an XML-style comment that should be interpreted as a line comment
			___R$project$rome$$internal$js$parser$tokenizer$index_ts$skipLineComment(
				parser,
				4,
			);
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$skipSpace(
				parser,
			);
			___R$project$rome$$internal$js$parser$tokenizer$index_ts$nextToken(parser);
			return undefined;
		}

		if (next === ___R$project$rome$$internal$string$charcodes$index_ts.equalsTo) {
			// <= | >=
			size = 2;
		}

		___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$finishOp(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.relational,
			size,
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenEqExcl(
		parser,
		code,
	) {
		// '=!'
		const next = parser.input.charCodeAt(
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
				parser,
			) + 1,
		);
		if (next === ___R$project$rome$$internal$string$charcodes$index_ts.equalsTo) {
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$finishOp(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.equality,
				parser.input.charCodeAt(
					___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
						parser,
					) + 2,
				) === ___R$project$rome$$internal$string$charcodes$index_ts.equalsTo
					? 3
					: 2,
			);
			return undefined;
		}
		if (
			code === ___R$project$rome$$internal$string$charcodes$index_ts.equalsTo &&
			next === ___R$project$rome$$internal$string$charcodes$index_ts.greaterThan
		) {
			// '=>'
			parser.state.index = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
				parser.state.index,
				2,
			);
			___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.arrow,
			);
			return undefined;
		}
		___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$finishOp(
			parser,
			code === ___R$project$rome$$internal$string$charcodes$index_ts.equalsTo
				? ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eq
				: ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bang,
			1,
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenQuestion(
		parser,
	) {
		const next = parser.input.charCodeAt(
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
				parser,
			) + 1,
		);
		const next2 = parser.input.charCodeAt(
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
				parser,
			) + 2,
		);
		if (
			next ===
			___R$project$rome$$internal$string$charcodes$index_ts.questionMark &&
			!___R$project$rome$$internal$js$parser$parser_ts$inScope(parser, "TYPE")
		) {
			if (
				next2 ===
				___R$project$rome$$internal$string$charcodes$index_ts.equalsTo
			) {
				// '??='
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$finishOp(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.assign,
					3,
				);
			} else {
				// '??'
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$finishOp(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.nullishCoalescing,
					2,
				);
			}
		} else if (
			next === ___R$project$rome$$internal$string$charcodes$index_ts.dot &&
			!(next2 >= ___R$project$rome$$internal$string$charcodes$index_ts.digit0 &&
			next2 <= ___R$project$rome$$internal$string$charcodes$index_ts.digit9)
		) {
			// '.' not followed by a number
			parser.state.index = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
				parser.state.index,
				2,
			);
			___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.questionDot,
			);
		} else {
			// '?'
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
			___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.question,
			);
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenNumberSign(
		parser,
	) {
		// Only tokenize a hash if we're inside of a class, or if we're the first character in the file (hashbang indicator)
		if (
			___R$project$rome$$internal$ob1$index_ts$ob1Get0(parser.state.classLevel) >
			0 ||
			parser.state.index === ___R$project$rome$$internal$ob1$index_ts$ob1Number0
		) {
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
			___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.hash,
			);
			return undefined;
		}

		// TODO make this a diagnostic, and advance to the next line if suspected hashbang
		___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
			parser,
			{
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.UNEXPECTED_HASH(
					parser.input[___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
						parser,
					) + 1] === "!",
				),
			},
		);
		___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
			parser,
		);
		___R$project$rome$$internal$js$parser$tokenizer$index_ts$nextToken(parser);
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getTokenFromCode(
		parser,
		code,
	) {
		if (code === ___R$project$rome$$internal$string$charcodes$index_ts.digit0) {
			const next = parser.input.charCodeAt(
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
					parser,
				) + 1,
			);

			// '0x', '0X' - hex number
			if (
				next ===
				___R$project$rome$$internal$string$charcodes$index_ts.lowercaseX ||
				next ===
				___R$project$rome$$internal$string$charcodes$index_ts.uppercaseX
			) {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readRadixNumber(
					parser,
					16,
					"hex",
				);
				return undefined;
			}

			// '0o', '0O' - octal number
			if (
				next ===
				___R$project$rome$$internal$string$charcodes$index_ts.lowercaseO ||
				next ===
				___R$project$rome$$internal$string$charcodes$index_ts.uppercaseO
			) {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readRadixNumber(
					parser,
					8,
					"octal",
				);
				return undefined;
			}

			// '0b', '0B' - binary number
			if (
				next ===
				___R$project$rome$$internal$string$charcodes$index_ts.lowercaseB ||
				next ===
				___R$project$rome$$internal$string$charcodes$index_ts.uppercaseB
			) {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readRadixNumber(
					parser,
					2,
					"binary",
				);
				return undefined;
			}
		}

		switch (code) {
			case ___R$project$rome$$internal$string$charcodes$index_ts.numberSign:
				return ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenNumberSign(
					parser,
				);

			// The interpretation of a dot depends on whether it is followed

			// by a digit or another two dots.
			case ___R$project$rome$$internal$string$charcodes$index_ts.dot: {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenDot(
					parser,
				);
				return undefined;
			}

			// Punctuation tokens.
			case ___R$project$rome$$internal$string$charcodes$index_ts.leftParenthesis: {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
				___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenL,
				);
				return undefined;
			}

			case ___R$project$rome$$internal$string$charcodes$index_ts.rightParenthesis: {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
				___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR,
				);
				return undefined;
			}

			case ___R$project$rome$$internal$string$charcodes$index_ts.semicolon: {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
				___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.semi,
				);
				return undefined;
			}

			case ___R$project$rome$$internal$string$charcodes$index_ts.comma: {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
				___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.comma,
				);
				return undefined;
			}

			case ___R$project$rome$$internal$string$charcodes$index_ts.leftSquareBracket: {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
				___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketL,
				);
				return undefined;
			}

			case ___R$project$rome$$internal$string$charcodes$index_ts.rightSquareBracket: {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
				___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bracketR,
				);
				return undefined;
			}

			case ___R$project$rome$$internal$string$charcodes$index_ts.leftCurlyBrace: {
				if (
					parser.input.charCodeAt(
						___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
							parser,
						) + 1,
					) ===
					___R$project$rome$$internal$string$charcodes$index_ts.verticalBar
				) {
					___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$finishOp(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceBarL,
						2,
					);
				} else {
					___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
						parser,
					);
					___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL,
					);
				}
				return undefined;
			}

			case ___R$project$rome$$internal$string$charcodes$index_ts.rightCurlyBrace: {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
				___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceR,
				);
				return undefined;
			}

			case ___R$project$rome$$internal$string$charcodes$index_ts.colon: {
				if (
					parser.input.charCodeAt(
						___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
							parser,
						) + 1,
					) ===
					___R$project$rome$$internal$string$charcodes$index_ts.colon
				) {
					___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$finishOp(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.doubleColon,
						2,
					);
				} else {
					___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
						parser,
					);
					___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon,
					);
				}
				return undefined;
			}

			case ___R$project$rome$$internal$string$charcodes$index_ts.questionMark: {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenQuestion(
					parser,
				);
				return undefined;
			}

			case ___R$project$rome$$internal$string$charcodes$index_ts.atSign: {
				// The token @@ is the start of a Flow iterator name
				const next = parser.input.charCodeAt(
					___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
						parser,
					) + 1,
				);
				if (
					next ===
					___R$project$rome$$internal$string$charcodes$index_ts.atSign
				) {
					parser.state.isIterator = true;
					___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readWord(
						parser,
					);
				} else {
					___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
						parser,
					);
					___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.at,
					);
				}
				return undefined;
			}

			case ___R$project$rome$$internal$string$charcodes$index_ts.graveAccent: {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
				___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.backQuote,
				);
				return undefined;
			}

			// Anything else beginning with a digit is an integer, octal

			// number, or float.
			case ___R$project$rome$$internal$string$charcodes$index_ts.digit0:
			case ___R$project$rome$$internal$string$charcodes$index_ts.digit1:
			case ___R$project$rome$$internal$string$charcodes$index_ts.digit2:
			case ___R$project$rome$$internal$string$charcodes$index_ts.digit3:
			case ___R$project$rome$$internal$string$charcodes$index_ts.digit4:
			case ___R$project$rome$$internal$string$charcodes$index_ts.digit5:
			case ___R$project$rome$$internal$string$charcodes$index_ts.digit6:
			case ___R$project$rome$$internal$string$charcodes$index_ts.digit7:
			case ___R$project$rome$$internal$string$charcodes$index_ts.digit8:
			case ___R$project$rome$$internal$string$charcodes$index_ts.digit9: {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readNumber(
					parser,
					false,
				);
				return undefined;
			}

			// Quotes produce strings.
			case ___R$project$rome$$internal$string$charcodes$index_ts.quotationMark:
			case ___R$project$rome$$internal$string$charcodes$index_ts.apostrophe: {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readString(
					parser,
					code,
				);
				return undefined;
			}

			// Operators are parsed inline in tiny state machines. '=' (charCodes.equalsTo) is

			// often referred to. `finishOp` simply skips the amount of

			// characters it is given as second argument, and returns a token

			// of the type given by its first argument.
			case ___R$project$rome$$internal$string$charcodes$index_ts.slash: {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenSlash(
					parser,
				);
				return undefined;
			}

			case ___R$project$rome$$internal$string$charcodes$index_ts.percentSign:
			case ___R$project$rome$$internal$string$charcodes$index_ts.asterisk: {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenMultModulo(
					parser,
					code,
				);
				return undefined;
			}

			case ___R$project$rome$$internal$string$charcodes$index_ts.verticalBar:
			case ___R$project$rome$$internal$string$charcodes$index_ts.ampersand: {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenPipeAmp(
					parser,
					code,
				);
				return undefined;
			}

			case ___R$project$rome$$internal$string$charcodes$index_ts.caret: {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenCaret(
					parser,
				);
				return undefined;
			}

			case ___R$project$rome$$internal$string$charcodes$index_ts.plusSign:
			case ___R$project$rome$$internal$string$charcodes$index_ts.dash: {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenPlusMin(
					parser,
					code,
				);
				return undefined;
			}

			case ___R$project$rome$$internal$string$charcodes$index_ts.lessThan:
			case ___R$project$rome$$internal$string$charcodes$index_ts.greaterThan: {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenLtGt(
					parser,
					code,
				);
				return undefined;
			}

			case ___R$project$rome$$internal$string$charcodes$index_ts.equalsTo:
			case ___R$project$rome$$internal$string$charcodes$index_ts.exclamationMark: {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenEqExcl(
					parser,
					code,
				);
				return undefined;
			}

			case ___R$project$rome$$internal$string$charcodes$index_ts.tilde: {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$finishOp(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.tilde,
					1,
				);
				return undefined;
			}
		}

		const char = parser.input[___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
			parser,
		)];
		const unicodeMistake = ___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.get(
			char,
		);
		if (unicodeMistake !== undefined) {
			const [unicodeName, equivalentChar] = unicodeMistake;
			const equivalentName = ___R$project$rome$$internal$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.get(
				equivalentChar,
			);
			if (equivalentName === undefined) {
				throw new Error("Expected ASCII name for " + equivalentChar);
			}

			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.UNEXPECTED_UNICODE_CHARACTER(
						char,
						unicodeName,
						equivalentChar,
						equivalentName,
					),
				},
			);

			// Read the token as the equivalent character
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getTokenFromCode(
				parser,
				equivalentChar.charCodeAt(0),
			);
			return;
		}

		___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
			parser,
			{
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.PARSER_CORE.UNEXPECTED_CHARACTER(
					___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$codePointToString(
						code,
					),
				),
			},
		);

		// Skip unknown characters
		___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
			parser,
		);
		___R$project$rome$$internal$js$parser$tokenizer$index_ts$nextToken(parser);
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$finishOp(
		parser,
		type,
		size,
	) {
		const str = parser.getRawInput(
			parser.state.index,
			___R$project$rome$$internal$ob1$index_ts$ob1Add(parser.state.index, size),
		);
		parser.state.index = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
			parser.state.index,
			size,
		);
		___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
			parser,
			type,
			str,
		);
	}

	function ___R$project$rome$$internal$js$parser$tokenizer$index_ts$readRegexp(
		parser,
	) {
		const start = parser.state.index;
		let escaped;
		let inClass;
		while (true) {
			if (parser.state.index >= parser.length) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						end: parser.getPositionFromIndex(parser.state.index),
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.UNTERMINATED_REGEX,
					},
				);
				break;
			}

			const ch = parser.input.charAt(
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
			);
			if (
				___R$project$rome$$internal$js$parser$utils$whitespace_ts$lineBreak.test(
					ch,
				)
			) {
				if (
					parser.input.charAt(
						___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
							parser,
						) - 2,
					) ===
					String.fromCharCode(
						___R$project$rome$$internal$string$charcodes$index_ts.backslash,
					) ||
					parser.input.charAt(
						___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
							parser,
						) - 3,
					) ===
					String.fromCharCode(
						___R$project$rome$$internal$string$charcodes$index_ts.backslash,
					)
				) {
					const line = parser.input.slice(
						0,
						___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
							parser,
						),
					);
					const backslashIndex = line.lastIndexOf(
						String.fromCharCode(
							___R$project$rome$$internal$string$charcodes$index_ts.backslash,
						),
					);
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							end: parser.getPositionFromIndex(
								___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(
									backslashIndex,
								),
							),
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.DANGLING_BACKSLASH_IN_REGEX,
						},
					);
					break;
				}
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						end: parser.getPositionFromIndex(parser.state.index),
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.UNTERMINATED_REGEX,
					},
				);
				break;
			}

			if (escaped) {
				escaped = false;
			} else {
				if (ch === "[") {
					inClass = true;
				} else if (ch === "]" && inClass) {
					inClass = false;
				} else if (ch === "/" && !inClass) {
					break;
				}

				escaped = ch === "\\";
			}

			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
		}

		const content = parser.getRawInput(start, parser.state.index);
		___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
			parser,
		);

		const rawMods = ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readWord1(
			parser,
		);
		if (parser.state.escapePosition !== undefined) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					index: parser.state.escapePosition,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.UNICODE_ESCAPE_IN_REGEX_FLAGS,
				},
			);
		}
		const mods = ___R$project$rome$$internal$js$parser$utils$regex_ts$validateRegexFlags(
			rawMods,
			(metadata, flagPosition) => {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						index: ___R$project$rome$$internal$ob1$index_ts$ob1Add(
							___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(
								___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
									parser,
								) - rawMods.length,
							),
							flagPosition,
						),
						description: metadata,
					},
				);
			},
		);

		___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.regexp,
			new ___R$project$rome$$internal$js$parser$tokenizer$index_ts$RegExpTokenValue(
				content,
				mods,
			),
		);
	}

	// Read an integer in the given radix. Return null if zero digits
	// were read, the integer value otherwise. When `len` is given, this
	// will return `null` unless the integer has exactly `len` digits.
	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readInt(
		parser,
		radix,
		len,
	) {
		const start = parser.state.index;
		const forbiddenSiblings =
			radix === 16
				? ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$forbiddenNumericSeparatorSiblings.hex
				: ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$forbiddenNumericSeparatorSiblings.decBinOct;

		let allowedSiblings;
		if (radix === 16) {
			allowedSiblings = ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblings.hex;
		} else if (radix === 10) {
			allowedSiblings = ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblings.dec;
		} else if (radix === 8) {
			allowedSiblings = ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblings.oct;
		} else {
			allowedSiblings = ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblings.bin;
		}

		let total = 0;

		for (let i = 0, e = len === undefined ? Infinity : len; i < e; ++i) {
			const code = parser.input.charCodeAt(
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
			);
			let val;

			const prev = parser.input.charCodeAt(
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
					parser,
				) - 1,
			);
			const next = parser.input.charCodeAt(
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
					parser,
				) + 1,
			);
			if (
				code ===
				___R$project$rome$$internal$string$charcodes$index_ts.underscore
			) {
				if (allowedSiblings.indexOf(next) === -1) {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.INVALID_INT_TOKEN,
						},
					);
				}

				if (
					forbiddenSiblings.indexOf(prev) > -1 ||
					forbiddenSiblings.indexOf(next) > -1 ||
					Number.isNaN(next)
				) {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.INVALID_INT_TOKEN,
						},
					);
				}

				// Ignore this _ character
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
				continue;
			}

			if (
				code >=
				___R$project$rome$$internal$string$charcodes$index_ts.lowercaseA
			) {
				val =
					code -
					___R$project$rome$$internal$string$charcodes$index_ts.lowercaseA +
					___R$project$rome$$internal$string$charcodes$index_ts.lineFeed;
			} else if (
				code >=
				___R$project$rome$$internal$string$charcodes$index_ts.uppercaseA
			) {
				val =
					code -
					___R$project$rome$$internal$string$charcodes$index_ts.uppercaseA +
					___R$project$rome$$internal$string$charcodes$index_ts.lineFeed;
			} else if (
				___R$project$rome$$internal$string$charcodes$index_ts.isDigit(code)
			) {
				val =
					code - ___R$project$rome$$internal$string$charcodes$index_ts.digit0; // 0-9
			} else {
				val = Infinity;
			}

			if (val >= radix) {
				break;
			}

			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
			total = total * radix + val;
		}

		if (
			parser.state.index === start ||
			(len !== undefined &&
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
				parser,
			) -
			___R$project$rome$$internal$ob1$index_ts$ob1Get0(start) !==
			len)
		) {
			return undefined;
		}

		return total;
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readRadixNumber(
		parser,
		radix,
		format,
	) {
		const start = parser.state.index;
		let isBigInt = false;

		parser.state.index = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
			parser.state.index,
			2,
		); // 0x
		let val = ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readInt(
			parser,
			radix,
		);
		if (val === undefined) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					index: ___R$project$rome$$internal$ob1$index_ts$ob1Add(start, 2),
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.EXPECTED_NUMBER_IN_RADIX(
						radix,
					),
				},
			);
			val = 0;
		}

		if (
			parser.input.charCodeAt(
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
			) ===
			___R$project$rome$$internal$string$charcodes$index_ts.lowercaseN
		) {
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
			isBigInt = true;
		}

		if (
			___R$project$rome$$internal$js$parser$utils$identifier_ts$isIdentifierStart(
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$fullCharCodeAtPos(
					parser,
				),
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					index: parser.state.index,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.IDENTIFIER_AFTER_NUMBER,
				},
			);
		}

		if (isBigInt) {
			const str = parser.getRawInput(start, parser.state.index).replace(
				/[_n]/g,
				"",
			);
			___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bigint,
				str,
			);
			return undefined;
		}

		___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.num,
			new ___R$project$rome$$internal$js$parser$tokenizer$index_ts$NumberTokenValue(
				val,
				format,
			),
		);
	}

	// Read an integer, octal integer, or floating-point number.
	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readNumber(
		parser,
		startsWithDot,
	) {
		const start = parser.state.startIndex;
		let isFloat = false;
		let isBigInt = false;

		if (
			!startsWithDot &&
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readInt(
				parser,
				10,
			) === undefined
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					index: parser.state.index,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.INVALID_NUMBER,
				},
			);
		}

		let isOctal =
			___R$project$rome$$internal$ob1$index_ts$ob1Get0(parser.state.index) -
			___R$project$rome$$internal$ob1$index_ts$ob1Get0(start) >=
			2 &&
			parser.input.charCodeAt(
				___R$project$rome$$internal$ob1$index_ts$ob1Get0(start),
			) === ___R$project$rome$$internal$string$charcodes$index_ts.digit0;
		if (isOctal) {
			if (
				___R$project$rome$$internal$js$parser$parser_ts$inScope(
					parser,
					"STRICT",
				)
			) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						index: parser.state.index,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.LEGACY_OCTAL_IN_STRICT_MODE,
					},
				);
			}

			if (/[89]/.test(parser.getRawInput(start, parser.state.index))) {
				isOctal = false;
			}
		}

		let next = parser.input.charCodeAt(
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
				parser,
			),
		);
		if (
			next === ___R$project$rome$$internal$string$charcodes$index_ts.dot &&
			!isOctal
		) {
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readInt(
				parser,
				10,
			);
			isFloat = true;
			next = parser.input.charCodeAt(
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
			);
		}

		if (
			(next === ___R$project$rome$$internal$string$charcodes$index_ts.uppercaseE ||
			next === ___R$project$rome$$internal$string$charcodes$index_ts.lowercaseE) &&
			!isOctal
		) {
			next = parser.input.charCodeAt(
				___R$project$rome$$internal$ob1$index_ts$ob1Get0(
					___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
						parser,
					),
				),
			);

			if (
				next === ___R$project$rome$$internal$string$charcodes$index_ts.plusSign ||
				next === ___R$project$rome$$internal$string$charcodes$index_ts.dash
			) {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
			}

			if (
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readInt(
					parser,
					10,
				) ===
				undefined
			) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						index: parser.state.index,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.INVALID_NUMBER,
					},
				);
			}

			isFloat = true;
			next = parser.input.charCodeAt(
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
			);
		}

		if (
			next ===
			___R$project$rome$$internal$string$charcodes$index_ts.lowercaseN
		) {
			// Disallow floats and legacy octal syntax, new style octal ("0o") is handled in readRadixNumber
			if (isFloat) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						index: parser.state.index,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.DECIMAL_BIGINT,
					},
				);
			}

			if (isOctal) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						index: parser.state.index,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.OCTAL_BIGINT,
					},
				);
			}

			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
			isBigInt = true;
		}

		if (
			___R$project$rome$$internal$js$parser$utils$identifier_ts$isIdentifierStart(
				parser.input.codePointAt(
					___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
						parser,
					),
				),
			)
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					index: parser.state.index,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.IDENTIFIER_AFTER_NUMBER,
				},
			);
		}

		// Remove "_" for numeric literal separator, and "n" for BigInts
		const str = parser.getRawInput(start, parser.state.index).replace(
			/[_n]/g,
			"",
		);

		if (isBigInt) {
			___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.bigint,
				str,
			);
			return undefined;
		}

		const num = isOctal ? parseInt(str, 8) : parseFloat(str);
		___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.num,
			new ___R$project$rome$$internal$js$parser$tokenizer$index_ts$NumberTokenValue(
				num,
				isOctal ? "octal" : undefined,
			),
		);
	}

	// Read a string value, interpreting backslash-escapes.
	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readCodePoint(
		parser,
		throwOnInvalid,
	) {
		const ch = parser.input.charCodeAt(
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
				parser,
			),
		);
		let code;

		if (
			ch ===
			___R$project$rome$$internal$string$charcodes$index_ts.leftCurlyBrace
		) {
			const codePos = parser.state.index;
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
			code = ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readHexChar(
				parser,
				parser.input.indexOf(
					"}",
					___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
						parser,
					),
				) -
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
				throwOnInvalid,
			);
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
			if (code === undefined) {
				// @ts-ignore
				parser.state.invalidTemplateEscapePosition--; // to point to the '\'' instead of the 'u'
			} else if (code > 1_114_111) {
				if (throwOnInvalid) {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							index: codePos,
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.OUT_OF_BOUND_CODE_POINT,
						},
					);
				} else {
					parser.state.invalidTemplateEscapePosition = ___R$project$rome$$internal$ob1$index_ts$ob1Sub(
						codePos,
						2,
					);
					return undefined;
				}
			}
		} else {
			code = ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readHexChar(
				parser,
				4,
				throwOnInvalid,
			);
		}
		return code;
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readString(
		parser,
		quote,
	) {
		let out = "";
		let chunkStart = ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
			parser,
		);

		while (true) {
			if (parser.state.index >= parser.length) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						end: parser.getPositionFromIndex(parser.state.index),
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.UNTERMINATED_STRING,
					},
				);
				break;
			}

			const ch = parser.input.charCodeAt(
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
			);
			if (ch === quote) {
				break;
			}

			if (ch === ___R$project$rome$$internal$string$charcodes$index_ts.backslash) {
				out += parser.getRawInput(chunkStart, parser.state.index);
				out += ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readEscapedChar(
					parser,
					false,
				);
				chunkStart = parser.state.index;
			} else if (
				ch ===
				___R$project$rome$$internal$string$charcodes$index_ts.lineSeparator ||
				ch ===
				___R$project$rome$$internal$string$charcodes$index_ts.paragraphSeparator
			) {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
				parser.state.curLine = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(
					parser.state.curLine,
				);
			} else {
				if (
					___R$project$rome$$internal$js$parser$utils$whitespace_ts$isNewLine(
						ch,
					)
				) {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							end: parser.getPositionFromIndex(parser.state.index),
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.UNTERMINATED_STRING,
						},
					);
				}
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
			}
		}

		out += parser.getRawInput(chunkStart, parser.state.index);
		___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
			parser,
		);
		___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.string,
			out,
		);
	}

	// Reads template string tokens.
	function ___R$project$rome$$internal$js$parser$tokenizer$index_ts$readTemplateToken(
		parser,
	) {
		let out = "";
		let chunkStart = parser.state.index;
		let containsInvalid = false;

		while (true) {
			if (parser.state.index >= parser.length) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						end: parser.getPositionFromIndex(parser.state.index),
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.UNTERMINATED_TEMPLATE,
					},
				);
				break;
			}

			const ch = parser.input.charCodeAt(
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
			);
			if (
				ch === ___R$project$rome$$internal$string$charcodes$index_ts.graveAccent ||
				(ch === ___R$project$rome$$internal$string$charcodes$index_ts.dollarSign &&
				parser.input.charCodeAt(
					___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
						parser,
					) + 1,
				) ===
				___R$project$rome$$internal$string$charcodes$index_ts.leftCurlyBrace)
			) {
				if (
					parser.state.index === parser.state.startIndex &&
					___R$project$rome$$internal$js$parser$parser_ts$match(
						parser,
						___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.template,
					)
				) {
					if (
						ch ===
						___R$project$rome$$internal$string$charcodes$index_ts.dollarSign
					) {
						parser.state.index = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
							parser.state.index,
							2,
						);
						___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
							parser,
							___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.dollarBraceL,
						);
						return undefined;
					} else {
						___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
							parser,
						);
						___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
							parser,
							___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.backQuote,
						);
						return undefined;
					}
				}
				out += parser.getRawInput(chunkStart, parser.state.index);
				___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.template,
					containsInvalid ? undefined : out,
				);
				return undefined;
			}

			if (ch === ___R$project$rome$$internal$string$charcodes$index_ts.backslash) {
				out += parser.getRawInput(chunkStart, parser.state.index);
				const escaped = ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readEscapedChar(
					parser,
					true,
				);
				if (escaped === undefined) {
					containsInvalid = true;
				} else {
					out += escaped;
				}
				chunkStart = parser.state.index;
			} else if (
				___R$project$rome$$internal$js$parser$utils$whitespace_ts$isNewLine(ch)
			) {
				out += parser.getRawInput(chunkStart, parser.state.index);
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);

				if (
					ch ===
					___R$project$rome$$internal$string$charcodes$index_ts.carriageReturn &&
					parser.input.charCodeAt(
						___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
							parser,
						),
					) === ___R$project$rome$$internal$string$charcodes$index_ts.lineFeed
				) {
					___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
						parser,
					);
				}

				switch (ch) {
					case ___R$project$rome$$internal$string$charcodes$index_ts.carriageReturn:
					case ___R$project$rome$$internal$string$charcodes$index_ts.lineFeed: {
						out += "\n";
						break;
					}

					default: {
						out += String.fromCharCode(ch);
						break;
					}
				}

				parser.state.curLine = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(
					parser.state.curLine,
				);
				___R$project$rome$$internal$js$parser$parser_ts$resetTokenizerLine(
					parser,
				);
				chunkStart = parser.state.index;
			} else {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
			}
		}
	}

	// Used to read escaped characters
	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readEscapedChar(
		parser,
		inTemplate,
	) {
		const throwOnInvalid = !inTemplate;
		const ch = parser.input.charCodeAt(
			___R$project$rome$$internal$ob1$index_ts$ob1Get0(
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				),
			),
		);
		___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
			parser,
		);

		if (
			ch ===
			___R$project$rome$$internal$string$charcodes$index_ts.carriageReturn &&
			parser.input.charCodeAt(
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
			) === ___R$project$rome$$internal$string$charcodes$index_ts.lineFeed
		) {
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
		}

		switch (ch) {
			case ___R$project$rome$$internal$string$charcodes$index_ts.lowercaseN:
				return "\n";

			case ___R$project$rome$$internal$string$charcodes$index_ts.lowercaseR:
				return "\r";

			case ___R$project$rome$$internal$string$charcodes$index_ts.lowercaseX: {
				const code = ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readHexChar(
					parser,
					2,
					throwOnInvalid,
				);
				return code === undefined ? undefined : String.fromCharCode(code);
			}

			case ___R$project$rome$$internal$string$charcodes$index_ts.lowercaseU: {
				const code = ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readCodePoint(
					parser,
					throwOnInvalid,
				);
				return code === undefined
					? undefined
					: ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$codePointToString(
							code,
						);
			}

			case ___R$project$rome$$internal$string$charcodes$index_ts.lowercaseT:
				return "\t";

			case ___R$project$rome$$internal$string$charcodes$index_ts.lowercaseB:
				return "\b";

			case ___R$project$rome$$internal$string$charcodes$index_ts.lowercaseV:
				return "\x0b";

			case ___R$project$rome$$internal$string$charcodes$index_ts.lowercaseF:
				return "\f";

			case ___R$project$rome$$internal$string$charcodes$index_ts.carriageReturn:
			case ___R$project$rome$$internal$string$charcodes$index_ts.lineFeed: {
				parser.state.curLine = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(
					parser.state.curLine,
				);
				___R$project$rome$$internal$js$parser$parser_ts$resetTokenizerLine(
					parser,
				);
				return "";
			}

			default: {
				if (
					ch >= ___R$project$rome$$internal$string$charcodes$index_ts.digit0 &&
					ch <= ___R$project$rome$$internal$string$charcodes$index_ts.digit7
				) {
					const codePos = ___R$project$rome$$internal$ob1$index_ts$ob1Dec(
						parser.state.index,
					);
					const octalMatches = parser.input.substr(
						___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
							parser,
						) - 1,
						3,
					).match(/^[0-7]+/);

					let octalStr = octalMatches[0];
					let octal = parseInt(octalStr, 8);
					if (octal > 255) {
						octalStr = octalStr.slice(0, -1);
						octal = parseInt(octalStr, 8);
					}

					if (octal > 0) {
						if (inTemplate) {
							parser.state.invalidTemplateEscapePosition = codePos;
							return undefined;
						} else if (
							___R$project$rome$$internal$js$parser$parser_ts$inScope(
								parser,
								"STRICT",
							)
						) {
							___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
								parser,
								{
									index: codePos,
									description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.OCTAL_IN_STRICT_MODE,
								},
							);
						} else if (!parser.state.containsOctal) {
							// These properties are only used to throw an error for an octal which occurs
							// in a directive which occurs prior to a "use strict" directive.
							parser.state.containsOctal = true;
							parser.state.octalPosition = codePos;
						}
					}

					parser.state.index = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
						parser.state.index,
						octalStr.length - 1,
					);
					return String.fromCharCode(octal);
				}

				return String.fromCharCode(ch);
			}
		}
	}

	// Used to read character escape sequences ('\x', '\u').
	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readHexChar(
		parser,
		len,
		throwOnInvalid,
	) {
		const start = parser.state.index;
		const n = ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readInt(
			parser,
			16,
			len,
		);

		if (n === undefined) {
			if (throwOnInvalid) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						index: start,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.BAD_HEX_ESCAPE,
					},
				);
				return 0;
			}

			const codePos = parser.state.index;
			parser.state.index = ___R$project$rome$$internal$ob1$index_ts$ob1Dec(
				codePos,
			);
			parser.state.invalidTemplateEscapePosition = ___R$project$rome$$internal$ob1$index_ts$ob1Dec(
				codePos,
			);
		}

		return n;
	}

	// Read an identifier, and return it as a string. Sets `parser.state.escapePosition`
	// to an index if the word contained a '\u' escape.
	//
	// Incrementally adds only escaped chars, adding other chunks as-is
	// as a micro-optimization.
	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readWord1(
		parser,
	) {
		parser.state.escapePosition = undefined;
		let word = "";
		let first = true;
		let chunkStart = parser.state.index;

		while (parser.state.index < parser.length) {
			const ch = ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$fullCharCodeAtPos(
				parser,
			);

			if (
				___R$project$rome$$internal$js$parser$utils$identifier_ts$isIdentifierChar(
					ch,
				)
			) {
				parser.state.index = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
					parser.state.index,
					ch <= 65_535 ? 1 : 2,
				);
			} else if (
				parser.state.isIterator &&
				ch === ___R$project$rome$$internal$string$charcodes$index_ts.atSign
			) {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
			} else if (
				ch ===
				___R$project$rome$$internal$string$charcodes$index_ts.backslash
			) {
				parser.state.escapePosition = parser.state.index;

				word += parser.getRawInput(chunkStart, parser.state.index);

				if (
					parser.input.charCodeAt(
						___R$project$rome$$internal$ob1$index_ts$ob1Get0(
							___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
								parser,
							),
						),
					) !==
					___R$project$rome$$internal$string$charcodes$index_ts.lowercaseU
				) {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							index: parser.state.index,
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.EXPECTED_UNICODE_ESCAPE,
						},
					);
				}

				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);

				const esc = ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readCodePoint(
					parser,
					true,
				);
				if (esc === undefined) {
					throw new Error("readCodePoint() should have thrown an error");
				}

				const isValid = first
					? ___R$project$rome$$internal$js$parser$utils$identifier_ts$isIdentifierStart
					: ___R$project$rome$$internal$js$parser$utils$identifier_ts$isIdentifierChar;
				if (!isValid(esc)) {
					___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
						parser,
						{
							index: parser.state.index,
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.INVALID_UNICODE_ESCAPE,
						},
					);
				}

				word += ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$codePointToString(
					esc,
				);
				chunkStart = parser.state.index;
			} else {
				break;
			}

			first = false;
		}

		return word + parser.getRawInput(chunkStart, parser.state.index);
	}

	// Read an identifier or keyword token. Will check for reserved
	// words when necessary.
	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readWord(
		parser,
	) {
		const word = ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readWord1(
			parser,
		);

		// @ts-ignore: The value of keywordTypes has a generic parameter of `string` instead of the labels that we would actually find in keywordTypes
		let type =
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$keywords.get(
				word,
			) || ___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name;

		if (type.keyword !== undefined && parser.state.escapePosition !== undefined) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					index: parser.state.escapePosition,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.ESCAPE_SEQUENCE_IN_KEYWORD(
						word,
					),
				},
			);
		}

		if (
			parser.state.isIterator &&
			(!___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$isIterator(
				word,
			) ||
			!___R$project$rome$$internal$js$parser$parser_ts$inScope(parser, "TYPE"))
		) {
			___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
				parser,
				{
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.INVALID_IDENTIFIER_NAME(
						word,
					),
				},
			);
		}

		___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
			parser,
			type,
			word,
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$isIterator(
		word,
	) {
		return word === "@@iterator" || word === "@@asyncIterator";
	}

	function ___R$project$rome$$internal$js$parser$tokenizer$index_ts$isBraceBlock(
		parser,
		prevType,
	) {
		const parent = ___R$project$rome$$internal$js$parser$tokenizer$index_ts$getCurContext(
			parser,
		);
		if (
			parent ===
			___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.functionExpression ||
			parent ===
			___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.functionStatement
		) {
			return true;
		}
		if (
			prevType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.colon &&
			(parent ===
			___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.braceStatement ||
			parent ===
			___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.braceExpression)
		) {
			return !parent.isExpr;
		}

		// The check for `tt.name && exprAllowed` detects whether we are

		// after a `yield` or `of` construct. See the `updateContext` for

		// `tt.name`.
		if (
			prevType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._return ||
			(prevType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name &&
			parser.state.exprAllowed)
		) {
			return ___R$project$rome$$internal$js$parser$utils$whitespace_ts$lineBreak.test(
				parser.getRawInput(parser.state.lastEndIndex, parser.state.startIndex),
			);
		}

		if (
			prevType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._else ||
			prevType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.semi ||
			prevType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eof ||
			prevType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.parenR ||
			prevType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.arrow
		) {
			return true;
		}

		if (
			prevType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL
		) {
			return (
				parent ===
				___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.braceStatement
			);
		}

		if (
			prevType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._var ||
			prevType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.name ||
			prevType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types._const
		) {
			return false;
		}

		if (
			prevType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.relational
		) {
			// `class C<T> { ... }`
			return true;
		}

		return !parser.state.exprAllowed;
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$updateContext(
		parser,
		prevType,
	) {
		if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.braceL,
			)
		) {
			const curContext = ___R$project$rome$$internal$js$parser$tokenizer$index_ts$getCurContext(
				parser,
			);
			if (
				curContext ===
				___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.jsxOpenTag
			) {
				parser.state.context.push(
					___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.braceExpression,
				);
			} else if (
				curContext ===
				___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.jsxInner
			) {
				parser.state.context.push(
					___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.templateQuasi,
				);
			} else {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$_updateContext(
					parser,
					prevType,
				);
			}

			parser.state.exprAllowed = true;
		} else if (
			___R$project$rome$$internal$js$parser$parser_ts$match(
				parser,
				___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.slash,
			) &&
			prevType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.jsxTagStart
		) {
			parser.state.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore
			parser.state.context.push(
				___R$project$rome$$internal$js$parser$tokenizer$context_ts$types.jsxCloseTag,
			); // reconsider as closing tag context
			parser.state.exprAllowed = false;
		} else {
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$_updateContext(
				parser,
				prevType,
			);
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$_updateContext(
		parser,
		prevType,
	) {
		const type = parser.state.tokenType;

		if (
			type.keyword !== undefined &&
			(prevType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.dot ||
			prevType ===
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.questionDot)
		) {
			parser.state.exprAllowed = false;
		} else if (type.updateContext !== undefined) {
			type.updateContext(parser, prevType);
		} else {
			parser.state.exprAllowed = type.beforeExpr;
		}
	}

	// Reads inline JSX contents token.
	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenJsx(
		parser,
	) {
		let out = "";
		let chunkStart = parser.state.index;
		while (true) {
			if (parser.state.index >= parser.length) {
				___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.eof,
				);
				break;
			}

			const code = parser.input.charCodeAt(
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
			);

			if (
				code === ___R$project$rome$$internal$string$charcodes$index_ts.lessThan ||
				code ===
				___R$project$rome$$internal$string$charcodes$index_ts.leftCurlyBrace
			) {
				if (parser.state.index === parser.state.startIndex) {
					if (
						code ===
						___R$project$rome$$internal$string$charcodes$index_ts.lessThan &&
						parser.state.exprAllowed
					) {
						___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
							parser,
						);
						return ___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
							parser,
							___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.jsxTagStart,
						);
					}

					return ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getTokenFromCode(
						parser,
						code,
					);
				}

				out += parser.getRawInput(chunkStart, parser.state.index);
				return ___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
					parser,
					___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.jsxText,
					out,
				);
			}

			if (
				code ===
				___R$project$rome$$internal$string$charcodes$index_ts.ampersand
			) {
				out += parser.getRawInput(chunkStart, parser.state.index);
				out += ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenJsxEntity(
					parser,
				);
				chunkStart = parser.state.index;
				continue;
			}

			if (
				___R$project$rome$$internal$js$parser$utils$whitespace_ts$isNewLine(
					code,
				)
			) {
				out += parser.getRawInput(chunkStart, parser.state.index);
				out += ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenJsxNewLine(
					parser,
					true,
				);
				chunkStart = parser.state.index;
			} else {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
			}
		}
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenJsxNewLine(
		parser,
		normalizeCRLF,
	) {
		const ch = parser.input.charCodeAt(
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
				parser,
			),
		);
		let out;
		___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
			parser,
		);

		if (
			ch ===
			___R$project$rome$$internal$string$charcodes$index_ts.carriageReturn &&
			parser.input.charCodeAt(
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
			) === ___R$project$rome$$internal$string$charcodes$index_ts.lineFeed
		) {
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
			out = normalizeCRLF ? "\n" : "\r\n";
		} else {
			out = String.fromCharCode(ch);
		}

		parser.state.curLine = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(
			parser.state.curLine,
		);
		___R$project$rome$$internal$js$parser$parser_ts$resetTokenizerLine(parser);
		return out;
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenJsxString(
		parser,
		quote,
	) {
		let out = "";
		let chunkStart = ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
			parser,
		);
		while (true) {
			if (parser.state.index >= parser.length) {
				___R$project$rome$$internal$js$parser$parser_ts$unexpectedDiagnostic(
					parser,
					{
						end: parser.getPositionFromIndex(parser.state.index),
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JS_PARSER.UNTERMINATED_JSX_STRING,
					},
				);
				break;
			}

			const ch = parser.input.charCodeAt(
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
			);
			if (ch === quote) {
				break;
			}

			if (ch === ___R$project$rome$$internal$string$charcodes$index_ts.ampersand) {
				out += parser.getRawInput(chunkStart, parser.state.index);
				out += ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenJsxEntity(
					parser,
				);
				chunkStart = parser.state.index;
			} else if (
				___R$project$rome$$internal$js$parser$utils$whitespace_ts$isNewLine(ch)
			) {
				out += parser.getRawInput(chunkStart, parser.state.index);
				out += ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenJsxNewLine(
					parser,
					false,
				);
				chunkStart = parser.state.index;
			} else {
				___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
			}
		}

		out += parser.getRawInput(chunkStart, parser.state.index);
		___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
			parser,
		);
		return ___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.string,
			out,
		);
	}

	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenJsxEntity(
		parser,
	) {
		let str = "";
		let count = 0;
		let entity;
		let ch = parser.input[___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
			parser,
		)];

		const startIndex = ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
			parser,
		);

		while (parser.state.index < parser.length && count++ < 10) {
			ch = parser.input[___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$getIndex(
				parser,
			)];
			___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
			if (ch === ";") {
				if (str[0] === "#") {
					if (str[1] === "x") {
						str = str.substr(2);
						if (
							___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$HEX_NUMBER.test(
								str,
							)
						) {
							entity = String.fromCodePoint(parseInt(str, 16));
						}
					} else {
						str = str.substr(1);
						if (
							___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$DECIMAL_NUMBER.test(
								str,
							)
						) {
							entity = String.fromCodePoint(parseInt(str, 10));
						}
					}
				} else {
					entity = ___R$project$rome$$internal$html$parser$xhtmlEntities_ts$xhtmlEntityNameToChar[str];
				}
				break;
			}
			str += ch;
		}

		if (entity === undefined) {
			parser.state.index = startIndex;
			return "&";
		} else {
			return entity;
		}
	}

	// Read a JSX identifier (valid tag or attribute name).
	//
	// Optimized version since JSX identifiers can't contain
	// escape characters and so can be read as single slice.
	// Also assumes that first character was already checked
	// by isIdentifierStart in readToken.
	function ___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$readTokenJsxWord(
		parser,
	) {
		let ch;
		const start = parser.state.index;
		do {
			ch = parser.input.charCodeAt(
				___R$project$rome$$internal$ob1$index_ts$ob1Get0(
					___R$$priv$project$rome$$internal$js$parser$tokenizer$index_ts$bumpIndex(
						parser,
					),
				),
			);
		} while (
			___R$project$rome$$internal$js$parser$utils$identifier_ts$isIdentifierChar(
				ch,
			) ||
			ch === ___R$project$rome$$internal$string$charcodes$index_ts.dash
		);
		return ___R$project$rome$$internal$js$parser$tokenizer$index_ts$finishToken(
			parser,
			___R$project$rome$$internal$js$parser$tokenizer$types_ts$types.jsxName,
			parser.getRawInput(start, parser.state.index),
		);
	}


  // project-rome/@internal/js-parser/CommentsConsumer.ts
class ___R$project$rome$$internal$js$parser$CommentsConsumer_ts$default {
		constructor(seedComments = []) {
			this.idToComment = new Map();
			this.counter = seedComments.length;
			this.setComments(seedComments);
		}

		setComments(comments) {
			this.idToComment.clear();

			for (const comment of comments) {
				this.idToComment.set(comment.id, comment);
			}
		}

		getCommentsFromIds(ids) {
			if (ids === undefined) {
				return [];
			}

			const comments = [];

			for (const id of ids) {
				const comment = this.getCommentFromId(id);
				if (comment !== undefined) {
					comments.push(comment);
				}
			}

			return comments;
		}

		getCommentFromId(id) {
			return this.idToComment.get(id);
		}

		assertGetCommentFromId(id) {
			const comment = this.getCommentFromId(id);
			if (comment === undefined) {
				throw new Error("No comment found for id " + id);
			}
			return comment;
		}

		getNextId() {
			return String(this.counter++);
		}

		updateComment(comment) {
			this.idToComment.set(comment.id, comment);
		}

		createComment(withoutId) {
			const withId = Object.assign({}, withoutId, {id: this.getNextId()});
			this.idToComment.set(withId.id, withId);
			return withId;
		}
	}


  // project-rome/@internal/js-parser/index.ts
function ___R$project$rome$$internal$js$parser$index_ts$parseJS(userOptions) {
		const options = ___R$project$rome$$internal$js$parser$options_ts$normalizeOptions(
			userOptions,
		);
		const meta = ___R$project$rome$$internal$js$parser$parser_ts$createMeta(
			options,
		);
		const parser = ___R$project$rome$$internal$js$parser$parser_ts$createJSParser(
			options,
			meta,
		);
		return ___R$project$rome$$internal$js$parser$parser_ts$parseRoot(parser);
	}

	function ___R$project$rome$$internal$js$parser$index_ts$tokenizeJS(
		userOptions,
	) {
		const options = Object.assign(
			{},
			___R$project$rome$$internal$js$parser$options_ts$normalizeOptions(
				userOptions,
			),
			{tokens: true},
		);
		const meta = ___R$project$rome$$internal$js$parser$parser_ts$createMeta(
			options,
		);
		const parser = ___R$project$rome$$internal$js$parser$parser_ts$createJSParser(
			options,
			meta,
		);
		___R$project$rome$$internal$js$parser$parser_ts$parseRoot(parser);

		let tokens = [];

		for (const token of parser.state.tokens) {
			tokens.push({
				type: token.type.label,
				start: parser.getIndexFromPosition(token.loc.start, token.loc.filename),
				end: parser.getIndexFromPosition(token.loc.end, token.loc.filename),
			});
		}

		return tokens;
	}


  // project-rome/@internal/compiler/transforms/compile/transpile/classProperties.ts
function ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$classProperties_ts$hasClassProps(
		node,
	) {
		for (const bodyNode of node.meta.body) {
			if (bodyNode.type === "JSClassProperty") {
				return true;
			}
		}

		return false;
	}

	function ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$classProperties_ts$createConstructor(
		rest,
		body,
	) {
		return ___R$project$rome$$internal$ast$js$classes$JSClassMethod_ts$jsClassMethod.create({
			kind: "constructor",
			key: ___R$project$rome$$internal$ast$js$objects$JSStaticPropertyKey_ts$jsStaticPropertyKey.quick(
				___R$project$rome$$internal$ast$js$auxiliary$JSIdentifier_ts$jsIdentifier.quick(
					"constructor",
				),
			),
			meta: ___R$project$rome$$internal$ast$js$classes$JSClassPropertyMeta_ts$jsClassPropertyMeta.create({

			}),
			head: ___R$project$rome$$internal$ast$js$auxiliary$JSFunctionHead_ts$jsFunctionHead.create({
				params: [],
				rest,
			}),
			body: ___R$project$rome$$internal$ast$js$statements$JSBlockStatement_ts$jsBlockStatement.create({
				body,
			}),
		});
	}

	function ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$classProperties_ts$toExpressionStatements(
		expressions,
	) {
		return expressions.map((expr) => {
			return ___R$project$rome$$internal$ast$js$statements$JSExpressionStatement_ts$jsExpressionStatement.create({
				expression: expr,
			});
		});
	}

	function ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$classProperties_ts$isSuperCall(
		node,
	) {
		return node.type === "JSCallExpression" && node.callee.type === "JSSuper";
	}

	function ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$classProperties_ts$transformClass(
		node,
		scope,
		context,
	) {
		const bodyReplacements = [];
		const constructorAssignments = [];
		const className =
			node.id === undefined ? scope.generateUid("class") : node.id.name;

		let _constructor = undefined;
		const filteredClassBody = [];
		for (const bodyNode of node.meta.body) {
			if (bodyNode.type === "JSClassMethod" && bodyNode.kind === "constructor") {
				_constructor = bodyNode;
				continue;
			}

			if (bodyNode.type === "JSClassProperty") {
				if (bodyNode.value === undefined) {
					continue;
				}

				if (bodyNode.key.type === "JSComputedPropertyKey") {
					if (bodyNode.meta.static === true) {
						bodyReplacements.push(
							___R$project$rome$$internal$js$ast$utils$template_ts$template.statement`${className}[${bodyNode.key.value}] = ${bodyNode.value};`,
						);
					} else {
						constructorAssignments.push(
							___R$project$rome$$internal$js$ast$utils$template_ts$template.expression`this[${bodyNode.key.value}] = ${bodyNode.value};`,
						);
					}
				} else {
					if (bodyNode.meta.static === true) {
						bodyReplacements.push(
							___R$project$rome$$internal$js$ast$utils$template_ts$template.statement`${className}.${bodyNode.key.value} = ${bodyNode.value};`,
						);
					} else {
						constructorAssignments.push(
							___R$project$rome$$internal$js$ast$utils$template_ts$template.expression`this.${bodyNode.key.value} = ${bodyNode.value};`,
						);
					}
				}
			} else {
				filteredClassBody.push(bodyNode);
			}
		}

		if (constructorAssignments.length) {
			if (node.meta.superClass !== undefined) {
				if (_constructor) {
					const visited = new Set();

					// find super() and insert assignments
					const reducedConstructor = context.reduce(
						_constructor,
						[
							{
								name: "classPropertiesInjector",
								enter(path) {
									const {node} = path;

									if (visited.has(node)) {
										return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
									}

									if (
										___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$classProperties_ts$isSuperCall(
											node,
										) &&
										path.parent.type !== "JSExpressionStatement"
									) {
										visited.add(node);

										// TODO retain proper value of super()
										return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
											___R$project$rome$$internal$ast$js$expressions$JSSequenceExpression_ts$jsSequenceExpression.create({
												expressions: [node, ...constructorAssignments],
											}),
										);
									}

									if (
										node.type === "JSExpressionStatement" &&
										___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$classProperties_ts$isSuperCall(
											node.expression,
										)
									) {
										visited.add(node);

										return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
											([
												node,
												...___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$classProperties_ts$toExpressionStatements(
													constructorAssignments,
												),
											]),
										);
									}

									return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
								},
							},
						],
					);
					_constructor = ___R$project$rome$$internal$ast$js$classes$JSClassMethod_ts$jsClassMethod.assert(
						reducedConstructor,
					);
				} else {
					// create new constructor with a super() call and assignments
					_constructor = ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$classProperties_ts$createConstructor(
						___R$project$rome$$internal$ast$js$patterns$JSBindingIdentifier_ts$jsBindingIdentifier.quick(
							"args",
						),
						[
							___R$project$rome$$internal$js$ast$utils$template_ts$template.statement`super(...args);`,
							...___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$classProperties_ts$toExpressionStatements(
								constructorAssignments,
							),
						],
					);
				}
			} else {
				if (_constructor) {
					// add assignments to end of constructor
					_constructor = Object.assign(
						{},
						_constructor,
						{
							body: Object.assign(
								{},
								_constructor.body,
								{
									body: [
										...___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$classProperties_ts$toExpressionStatements(
											constructorAssignments,
										),
										..._constructor.body.body,
									],
								},
							),
						},
					);
				} else {
					// create new constructor with just the assignments
					_constructor = ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$classProperties_ts$createConstructor(
						undefined,
						___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$classProperties_ts$toExpressionStatements(
							constructorAssignments,
						),
					);
				}
			}
		}

		if (_constructor !== undefined) {
			filteredClassBody.unshift(_constructor);
		}

		const newClass = Object.assign(
			{},
			node,
			{
				id: node.id !== undefined && node.id.name === className
					? node.id
					: ___R$project$rome$$internal$ast$js$patterns$JSBindingIdentifier_ts$jsBindingIdentifier.create({
							name: className,
						}),
				meta: Object.assign({}, node.meta, {body: filteredClassBody}),
			},
		);

		return {
			newClass,
			className,
			declarations: bodyReplacements,
		};
	}
	const ___R$project$rome$$internal$compiler$transforms$compile$transpile$classProperties_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "classProperties",
		enter(path) {
			const {node, scope, context} = path;

			// correctly replace an export class with the class node then append the declarations
			if (
				(node.type === "JSExportLocalDeclaration" ||
				node.type === "JSExportDefaultDeclaration") &&
				node.declaration !== undefined &&
				node.declaration.type === "JSClassDeclaration" &&
				___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$classProperties_ts$hasClassProps(
					node.declaration,
				)
			) {
				const {newClass, declarations} = ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$classProperties_ts$transformClass(
					node.declaration,
					scope,
					context,
				);
				return ___R$project$rome$$internal$compiler$index_ts$signals.replace([
					Object.assign({}, node, {declaration: newClass}),
					...declarations,
				]);
			}

			// turn a class expression into an IIFE that returns a class declaration
			if (
				node.type === "JSClassExpression" &&
				___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$classProperties_ts$hasClassProps(
					node,
				)
			) {
				const className =
					node.id === undefined ? scope.generateUid("class") : node.id.name;

				return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
					___R$project$rome$$internal$ast$js$expressions$JSCallExpression_ts$jsCallExpression.create({
						callee: ___R$project$rome$$internal$ast$js$expressions$JSArrowFunctionExpression_ts$jsArrowFunctionExpression.create({
							head: ___R$project$rome$$internal$ast$js$auxiliary$JSFunctionHead_ts$jsFunctionHead.quick([]),
							body: ___R$project$rome$$internal$ast$js$statements$JSBlockStatement_ts$jsBlockStatement.create({
								body: [
									Object.assign(
										{},
										node,
										{
											type: "JSClassDeclaration",
											id: ___R$project$rome$$internal$ast$js$patterns$JSBindingIdentifier_ts$jsBindingIdentifier.quick(
												className,
											),
										},
									),
									___R$project$rome$$internal$ast$js$statements$JSReturnStatement_ts$jsReturnStatement.create({
										argument: ___R$project$rome$$internal$ast$js$expressions$JSReferenceIdentifier_ts$jsReferenceIdentifier.quick(
											className,
										),
									}),
								],
							}),
						}),
						arguments: [],
					}),
				);
			}

			if (
				node.type === "JSClassDeclaration" &&
				___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$classProperties_ts$hasClassProps(
					node,
				)
			) {
				const {newClass, declarations} = ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$classProperties_ts$transformClass(
					node,
					scope,
					context,
				);
				return ___R$project$rome$$internal$compiler$index_ts$signals.replace([
					newClass,
					...declarations,
				]);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/transforms/compile/transpile/paramlessCatch.ts
const ___R$project$rome$$internal$compiler$transforms$compile$transpile$paramlessCatch_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "paramlessCatch",
		enter(path) {
			const {node} = path;

			if (node.type === "JSCatchClause" && node.param === undefined) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
					Object.assign(
						{},
						node,
						{
							param: ___R$project$rome$$internal$ast$js$patterns$JSBindingIdentifier_ts$jsBindingIdentifier.create({
								name: path.scope.generateUid(),
							}),
						},
					),
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/transforms/compile/transpile/optionalChaining.ts
const ___R$project$rome$$internal$compiler$transforms$compile$transpile$optionalChaining_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "optionalChaining",
		enter(path) {
			const {node} = path;

			if (node.type === "JSMemberExpression" && node.property.optional) {
				// TODO assign `node.object` to a variable and use it as a reference
				if (node.property.type === "JSComputedMemberProperty") {
					return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
						___R$project$rome$$internal$js$ast$utils$template_ts$template.expression`${node.object} == null ? undefined : ${node.object}[${node.property.value}]`,
					);
				} else {
					return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
						___R$project$rome$$internal$js$ast$utils$template_ts$template.expression`${node.object} == null ? undefined : ${node.object}.${node.property.value}`,
					);
				}
			}

			if (node.type === "JSOptionalCallExpression") {
				// TODO assign `node.callee` to a variable and use it as a reference
				return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
					___R$project$rome$$internal$js$ast$utils$template_ts$template.expression`${node.callee} == null ? undefined : ${___R$project$rome$$internal$ast$js$expressions$JSCallExpression_ts$jsCallExpression.create({
						callee: node.callee,
						arguments: node.arguments,
					})}`,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/transforms/compile/transpile/nullishCoalescing.ts
const ___R$project$rome$$internal$compiler$transforms$compile$transpile$nullishCoalescing_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "nullishCoalescing",
		enter(path) {
			const {node} = path;

			if (node.type === "JSLogicalExpression" && node.operator === "??") {
				// TODO assign `node.left` to a variable and use it as a reference
				return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
					___R$project$rome$$internal$js$ast$utils$template_ts$template.expression`${node.left} == null ? ${node.right} : ${node.left}`,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/ast-utils/isRoot.ts
function ___R$project$rome$$internal$ast$utils$isRoot_ts$isRoot(node) {
		return (
			node.type === "JSRoot" ||
			node.type === "CSSRoot" ||
			node.type === "CommitRoot" ||
			node.type === "MarkdownRoot" ||
			node.type === "HTMLRoot"
		);
	}


  // project-rome/@internal/ast-utils/assertRoot.ts
function ___R$project$rome$$internal$ast$utils$assertRoot_ts$assertRoot(node) {
		if (___R$project$rome$$internal$ast$utils$isRoot_ts$isRoot(node)) {
			return node;
		} else {
			throw new Error("Expected root node but got " + node.type);
		}
	}


  // project-rome/@internal/project/types.ts
const ___R$project$rome$$internal$project$types_ts = {
		createDefaultProjectConfigMeta: ___R$project$rome$$internal$project$types_ts$createDefaultProjectConfigMeta,
		createDefaultProjectConfig: ___R$project$rome$$internal$project$types_ts$createDefaultProjectConfig,
	};
	function ___R$project$rome$$internal$project$types_ts$createDefaultProjectConfigMeta() {
		return {
			projectDirectory: undefined,
			configPath: undefined,
			configHashes: [],
			configDependencies: new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet(),
			consumer: undefined,
			configSourceSubKey: undefined,
			consumersChain: [],
		};
	}

	function ___R$project$rome$$internal$project$types_ts$createDefaultProjectConfig() {
		return {
			name: "unknown",
			root: false,
			version: undefined,
			cache: {},
			develop: {
				serveStatic: true,
			},
			bundler: {
				externals: [],
			},
			compiler: {},
			resolver: {},
			typeCheck: {
				enabled: false,
				// Maybe this needs to be cloned...?
				libs: new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet(),
			},
			dependencies: {
				enabled: false,
			},
			lint: {
				ignore: [],
				globals: [],
			},
			tests: {
				ignore: [],
			},
			vcs: {
				root: ___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
					"/",
				),
			},
			files: {
				vendorPath: ___R$project$rome$$internal$path$index_ts$TEMP_PATH.append(
					"rome-remote",
				),
				assetExtensions: [],
				maxSize: 40_000_000, // 40 megabytes
			},
			targets: new Map(),
		};
	}


  // project-rome/@internal/path-match/types.ts



  // project-rome/@internal/path-match/parse.ts
function ___R$$priv$project$rome$$internal$path$match$parse_ts$isntNewline(char) {
		return char !== "\n";
	}

	const ___R$$priv$project$rome$$internal$path$match$parse_ts$createPathMatchParser = ___R$project$rome$$internal$parser$core$utils_ts$createParser({
		diagnosticCategory: "parse/patchMatch",
		tokenize(parser, index) {
			const char = parser.getInputCharOnly(index);
			const nextChar = parser.getInputCharOnly(index, 1);

			if (char === "*") {
				if (nextChar === "*") {
					return parser.finishToken(
						"DoubleStar",
						___R$project$rome$$internal$ob1$index_ts$ob1Add(index, 2),
					);
				} else {
					return parser.finishToken("Star");
				}
			} else if (
				index === ___R$project$rome$$internal$ob1$index_ts$ob1Number0 &&
				char === "!"
			) {
				return parser.finishToken("Exclamation");
			} else if (
				char === "#" &&
				parser.getPositionFromIndex(index).column ===
				___R$project$rome$$internal$ob1$index_ts$ob1Number0
			) {
				const [value, end] = parser.readInputFrom(
					index,
					___R$$priv$project$rome$$internal$path$match$parse_ts$isntNewline,
				);
				return parser.finishValueToken("Comment", value, end);
			}

			if (char === "\n") {
				return parser.finishToken("EOL");
			}

			if (char === "/") {
				return parser.finishToken("Separator");
			} else if (char === "\\" && nextChar === "\\") {
				return parser.finishToken(
					"Separator",
					___R$project$rome$$internal$ob1$index_ts$ob1Add(index, 2),
				);
			}

			const [value, end] = parser.readInputFrom(
				index,
				___R$$priv$project$rome$$internal$path$match$parse_ts$isWordCharacter.bind(
					undefined,
					parser,
				),
			);
			return parser.finishValueToken("Word", value, end);
		},
	});

	function ___R$$priv$project$rome$$internal$path$match$parse_ts$isWordCharacter(
		parser,
		char,
		index,
		input,
	) {
		const prevChar = input[___R$project$rome$$internal$ob1$index_ts$ob1Get0(
			index,
		) - 1];
		const nextChar = input[___R$project$rome$$internal$ob1$index_ts$ob1Get0(
			index,
		) + 1];

		if (char === "\n") {
			return false;
		}

		// Windows separator
		if (char === "\\" && nextChar === "\\") {
			return false;
		}

		// Any escaped character is a word character
		if (prevChar === "\\") {
			return true;
		}

		// Unix separator and wildcard
		if (char === "/") {
			return false;
		}

		// Wildcard
		if (char === "*") {
			return false;
		}

		return true;
	}

	function ___R$$priv$project$rome$$internal$path$match$parse_ts$eatSeparators(
		parser,
	) {
		let ate = false;
		while (parser.eatToken("Separator") !== undefined) {
			ate = true;
		}
		return ate;
	}

	//# Pattern parsing
	function ___R$$priv$project$rome$$internal$path$match$parse_ts$parsePatternSegmentPart(
		parser,
	) {
		const startPos = parser.getPosition();
		const token = parser.getToken();
		parser.nextToken();

		switch (token.type) {
			case "Star":
				return {
					type: "Wildcard",
					loc: parser.finishLoc(startPos),
				};

			case "Word":
				return {
					type: "Word",
					loc: parser.finishLoc(startPos),
					value: token.value,
				};

			default:
				throw parser.unexpected({
					start: startPos,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.PATH_MATCH.INVALID_PATTERN_SEGMENT_PART,
				});
		}
	}

	function ___R$$priv$project$rome$$internal$path$match$parse_ts$parseSegment(
		parser,
	) {
		const startPos = parser.getPosition();
		const parts = [];

		// A ** token is only allowed as the only part of a segment
		if (parser.matchToken("DoubleStar")) {
			const lookahead = parser.lookaheadToken();
			if (
				lookahead.type === "Separator" ||
				lookahead.type === "EOF" ||
				lookahead.type === "EOL"
			) {
				parser.eatToken("DoubleStar");
				___R$$priv$project$rome$$internal$path$match$parse_ts$eatSeparators(
					parser,
				);
				return {
					type: "WildcardSegment",
					loc: parser.finishLoc(startPos),
				};
			}
		}

		// Keep consuming tokens until we hit a separator or a comment
		while (
			!parser.matchToken("Comment") &&
			!parser.matchToken("EOF") &&
			!___R$$priv$project$rome$$internal$path$match$parse_ts$eatSeparators(
				parser,
			) &&
			!parser.matchToken("EOL")
		) {
			parts.push(
				___R$$priv$project$rome$$internal$path$match$parse_ts$parsePatternSegmentPart(
					parser,
				),
			);
		}

		return {
			loc: parser.finishLoc(startPos),
			type: "Segment",
			parts,
		};
	}

	function ___R$$priv$project$rome$$internal$path$match$parse_ts$isWildcardOnlySegment(
		parser,
		segment,
	) {
		if (segment === undefined) {
			return false;
		}

		if (segment.type === "WildcardSegment") {
			return true;
		}

		if (segment.parts.length === 1 && segment.parts[0].type === "Wildcard") {
			return true;
		}

		return false;
	}

	// Normalize all path segments, removing empty segments and wildcards from the start and end
	// These could also be parse errors but let's allow them
	function ___R$$priv$project$rome$$internal$path$match$parse_ts$normalizePatternSegments(
		parser,
		segments,
	) {
		const normalized = [];

		// Never normalize it if there's a single segment. This is to support writing a pattern that's just "*"
		if (segments.length === 1) {
			return segments;
		}

		for (const seg of segments) {
			// Remove all wildcard-only segments from 'beginning
			if (
				normalized.length === 0 &&
				___R$$priv$project$rome$$internal$path$match$parse_ts$isWildcardOnlySegment(
					parser,
					seg,
				)
			) {
				continue;
			}

			// Remove all empty segments
			if (seg.type === "Segment" && seg.parts.length === 0) {
				continue;
			}

			normalized.push(seg);
		}

		// TODO Remove duplicate wildcard segments
		// - Multiple WildcardSegment
		// - Wildcard next to a WildcardSegment
		// Remove all wildcard-only segments from end
		while (
			___R$$priv$project$rome$$internal$path$match$parse_ts$isWildcardOnlySegment(
				parser,
				normalized[normalized.length - 1],
			)
		) {
			normalized.pop();
		}

		return normalized;
	}

	function ___R$$priv$project$rome$$internal$path$match$parse_ts$eatEOL(parser) {
		while (parser.eatToken("EOL")) {
			// empty
		}
	}

	function ___R$$priv$project$rome$$internal$path$match$parse_ts$parsePatternNode(
		parser,
	) {
		const startPos = parser.getPosition();
		const segments = [];
		const negate = parser.eatToken("Exclamation") !== undefined;

		// Keep parsing segments until we hit the end of the input or a comment
		while (
			!parser.matchToken("Comment") &&
			!parser.matchToken("EOF") &&
			!parser.matchToken("EOL")
		) {
			segments.push(
				___R$$priv$project$rome$$internal$path$match$parse_ts$parseSegment(
					parser,
				),
			);
		}

		// Get a trailing comment
		if (parser.matchToken("Comment")) {
			const {value} = parser.expectToken("Comment");
			return {
				type: "Comment",
				loc: parser.finishLoc(startPos),
				value,
			};
		}

		let root = false;
		if (segments.length > 0) {
			const firstSeg = segments[0];
			root = firstSeg.type === "Segment" && firstSeg.parts.length === 0;
		}

		return {
			type: "PathPattern",
			loc: parser.finishLoc(startPos),
			root,
			negate,
			segments: ___R$$priv$project$rome$$internal$path$match$parse_ts$normalizePatternSegments(
				parser,
				segments,
			),
		};
	}

	function ___R$project$rome$$internal$path$match$parse_ts$parsePattern(opts) {
		const parser = ___R$$priv$project$rome$$internal$path$match$parse_ts$createPathMatchParser(
			opts,
		);
		const pattern = ___R$$priv$project$rome$$internal$path$match$parse_ts$parsePatternNode(
			parser,
		);
		___R$$priv$project$rome$$internal$path$match$parse_ts$eatEOL(parser);
		parser.finalize();
		return pattern;
	}

	function ___R$project$rome$$internal$path$match$parse_ts$parsePatternsFile(
		opts,
	) {
		const parser = ___R$$priv$project$rome$$internal$path$match$parse_ts$createPathMatchParser(
			opts,
		);
		const patterns = [];

		while (true) {
			___R$$priv$project$rome$$internal$path$match$parse_ts$eatEOL(parser);
			if (parser.matchToken("EOF")) {
				break;
			}

			patterns.push(
				___R$$priv$project$rome$$internal$path$match$parse_ts$parsePatternNode(
					parser,
				),
			);
		}

		parser.finalize();
		return patterns;
	}


  // project-rome/@internal/path-match/match.ts
function ___R$$priv$project$rome$$internal$path$match$match_ts$matchSegment(
		path,
		patternSeg,
	) {
		if (patternSeg.type !== "Segment") {
			throw new Error("Expected only plain segment");
		}

		const parts = [...patternSeg.parts];
		let buffer = path;

		function matchPart(part) {
			// If the buffer is empty then it's impossible for anything to match
			if (buffer.length === 0) {
				return false;
			}

			if (part.type === "Word") {
				if (buffer.startsWith(part.value)) {
					buffer = buffer.slice(part.value.length);
				} else {
					return false;
				}
			} else if (part.type === "Wildcard") {
				const nextPart = parts.shift();

				// If there's no other parts then a wildcard matches any buffer
				if (nextPart === undefined) {
					return buffer.length >= 0;
				}

				// Keep removing characters until we match the next part
				while (buffer.length > 0) {
					if (matchPart(nextPart)) {
						return true;
					}

					buffer = buffer.slice(1);
				}

				// We consumed the whole buffer and nothing matched
				return false;
			}

			return true;
		}

		while (parts.length > 0) {
			const part = parts.shift();
			if (part === undefined) {
				throw new Error("parts.length checked above");
			}

			if (!matchPart(part)) {
				return false;
			}
		}

		return true;
	}

	function ___R$project$rome$$internal$path$match$match_ts$default(
		pathSegs,
		pattern,
		cwdSegs,
	) {
		// Clone so we can freely mutate
		const patternSegs = [...pattern.segments];
		pathSegs = [...pathSegs];

		// Check if the pattern is empty
		if (patternSegs.length === 0 || pathSegs.length === 0) {
			return false;
		}

		// Quick optimization, check if the path contains all of the absolute names in the pattern
		for (const seg of patternSegs) {
			if (seg.type !== "Segment" || seg.parts.length !== 1) {
				continue;
			}

			const part = seg.parts[0];
			if (part.type === "Word" && !pathSegs.includes(part.value)) {
				return false;
			}
		}

		if (pattern.root && cwdSegs !== undefined) {
			cwdSegs = [...cwdSegs];

			// If this is a root pattern, then remove all the starting path segments that match the cwd
			for (const cwdSeg of cwdSegs) {
				const pathSeg = pathSegs.shift();
				if (cwdSeg !== pathSeg) {
					return false;
				}
			}
		} else {
			// Start removing all the path segments until we find one that matches the first pattern segment
			const firstPatternSeg = patternSegs.shift();
			if (firstPatternSeg === undefined) {
				throw new Error("patternSegs.length already validated above");
			}

			while (pathSegs.length > 0) {
				const pathSeg = pathSegs.shift();
				if (pathSeg === undefined) {
					throw new Error("pathSegs.length already validated above");
				}

				if (
					___R$$priv$project$rome$$internal$path$match$match_ts$matchSegment(
						pathSeg,
						firstPatternSeg,
					)
				) {
					if (pathSegs.length === 0 && patternSegs.length === 0) {
						// If there's no more path or pattern segments then this was a successfully match!
						return true;
					} else {
						// Make sure the rest match
						break;
					}
				}
			}
		}

		// If we consumed all the path segments then we didn't match anything
		if (pathSegs.length === 0) {
			return false;
		}

		// Match the rest of the path segments
		for (let i = 0; i < patternSegs.length; i++) {
			const patternSeg = patternSegs[i];

			// If we have no more path segments then it's impossible for this to match
			if (pathSegs.length === 0) {
				return false;
			}

			// When given a wildcard segment, keep popping off all the path segments until we find one that matches the next pattern segment
			if (patternSeg.type === "WildcardSegment") {
				const nextPattern = patternSegs[i + 1];
				while (
					pathSegs.length > 0 &&
					!___R$$priv$project$rome$$internal$path$match$match_ts$matchSegment(
						pathSegs[0],
						nextPattern,
					)
				) {
					pathSegs.shift();
				}
				continue;
			}

			// Basic match
			const pathSeg = pathSegs.shift();
			if (pathSeg === undefined) {
				throw new Error("pathSegs.length already validated above");
			}
			if (
				___R$$priv$project$rome$$internal$path$match$match_ts$matchSegment(
					pathSeg,
					patternSeg,
				)
			) {
				continue;
			} else {
				return false;
			}
		}

		return true;
	}


  // project-rome/@internal/path-match/stringify.ts
function ___R$project$rome$$internal$path$match$stringify_ts$stringifyPathPattern(
		node,
	) {
		switch (node.type) {
			case "Comment":
				return "#" + node.value;

			case "PathPattern":
				return node.segments.map((segment) =>
					___R$project$rome$$internal$path$match$stringify_ts$stringifyPathPattern(
						segment,
					)
				).join("/");

			case "Segment":
				return node.parts.map((part) =>
					___R$project$rome$$internal$path$match$stringify_ts$stringifyPathPattern(
						part,
					)
				).join("");

			case "WildcardSegment":
				return "**";

			case "Wildcard":
				return "*";

			case "Word":
				return node.value;
		}
	}


  // project-rome/@internal/path-match/index.ts
function ___R$project$rome$$internal$path$match$index_ts$flipPathPatterns(
		patterns,
	) {
		return patterns.map((pattern) => {
			if (pattern.type === "Comment") {
				return pattern;
			} else {
				return Object.assign({}, pattern, {negate: !pattern.negate});
			}
		});
	}

	function ___R$project$rome$$internal$path$match$index_ts$matchPath(
		path,
		patternNode,
		cwdSegs,
	) {
		if (patternNode.type === "Comment") {
			return false;
		}

		const matches = ___R$project$rome$$internal$path$match$match_ts$default(
			path.getSegments(),
			patternNode,
			cwdSegs,
		);

		if (patternNode.negate) {
			return !matches;
		} else {
			return matches;
		}
	}

	function ___R$$priv$project$rome$$internal$path$match$index_ts$getGreater(
		pattern,
		num,
	) {
		if (pattern.type === "PathPattern" && pattern.segments.length > num) {
			return pattern.segments.length;
		} else {
			return num;
		}
	}

	function ___R$project$rome$$internal$path$match$index_ts$matchPathPatterns(
		path,
		patterns,
		cwd,
	) {
		// Bail out if there are no patterns
		if (patterns.length === 0) {
			return "NO_MATCH";
		}

		let matches = 0;
		let notMatches = 0;

		let hasNegate = false;

		const pathSegments = path.getSegments();
		const cwdSegs = cwd === undefined ? undefined : cwd.getSegments();

		for (const pattern of patterns) {
			// No point in matching an empty pattern, could just contain a comment
			if (pattern.type === "Comment" || pattern.segments.length === 0) {
				continue;
			}

			if (pattern.negate) {
				hasNegate = true;
				if (
					___R$project$rome$$internal$path$match$match_ts$default(
						pathSegments,
						Object.assign({}, pattern, {negate: false}),
						cwdSegs,
					)
				) {
					notMatches = ___R$$priv$project$rome$$internal$path$match$index_ts$getGreater(
						pattern,
						notMatches,
					);
				}
			} else {
				if (
					___R$project$rome$$internal$path$match$match_ts$default(
						pathSegments,
						pattern,
						cwdSegs,
					)
				) {
					matches = ___R$$priv$project$rome$$internal$path$match$index_ts$getGreater(
						pattern,
						matches,
					);
				}
			}
		}

		// If we have a negate pattern, then we need to match more segments than it in order to qualify as a match
		if (hasNegate) {
			if (notMatches > matches) {
				return "NO_MATCH";
			} else if (matches > notMatches) {
				return "EXPLICIT_MATCH";
			} else {
				return "IMPLICIT_MATCH";
			}
		}

		if (matches > 0) {
			return "EXPLICIT_MATCH";
		}

		return "NO_MATCH";
	}


  // project-rome/@internal/project/constants.ts
const ___R$project$rome$$internal$project$constants_ts = {
		get PROJECT_CONFIG_PACKAGE_JSON_FIELD() {
			return ___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_PACKAGE_JSON_FIELD;
		},
		get PROJECT_CONFIG_DIRECTORY() {
			return ___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_DIRECTORY;
		},
		get PROJECT_CONFIG_FILENAMES() {
			return ___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_FILENAMES;
		},
		get PROJECT_CONFIG_WARN_FILENAMES() {
			return ___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_WARN_FILENAMES;
		},
		get PROJECT_CONFIG_SENSITIVE_DIRECTORIES() {
			return ___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_SENSITIVE_DIRECTORIES;
		},
	};
	const ___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_PACKAGE_JSON_FIELD = "rome";
	const ___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_DIRECTORY = ".config";
	const ___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_FILENAMES = [
		"rome.json",
		"rome.rjson",
	];
	const ___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_WARN_FILENAMES = [
		"romeconfig",
		"romerc",
		"rome.son",
		"rome.config.ts",
		"rome.config.js",
		"rome.config.json",
		"rome.config.rjson",
		"rome.config.son",
	];

	const ___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_SENSITIVE_DIRECTORIES = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet([
		___R$project$rome$$internal$path$index_ts$HOME_PATH,
		___R$project$rome$$internal$path$index_ts$HOME_PATH.append("Downloads"),
		___R$project$rome$$internal$path$index_ts$HOME_PATH.append("Documents"),
		___R$project$rome$$internal$path$index_ts$HOME_PATH.append("Desktop"),
		___R$project$rome$$internal$path$index_ts$HOME_PATH.append("Library"),
		___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath("/root"),
		___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
			"C:/Windows",
		),
		___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
			"C:/Windows/system32",
		),
	]);

	// Add dot versions
	for (const basename of ___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_WARN_FILENAMES) {
		if (basename[0] !== ".") {
			___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_WARN_FILENAMES.push(
				"." + basename,
			);
		}
	}
	for (const filename of ___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_FILENAMES.slice()) {
		___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_FILENAMES.push(
			"." + filename,
		);
	}


  // project-rome/@internal/project/utils.ts
const ___R$project$rome$$internal$project$utils_ts = {
		assertHardMeta: ___R$project$rome$$internal$project$utils_ts$assertHardMeta,
		arrayOfStrings: ___R$project$rome$$internal$project$utils_ts$arrayOfStrings,
		arrayOfPatterns: ___R$project$rome$$internal$project$utils_ts$arrayOfPatterns,
		mergeArrays: ___R$project$rome$$internal$project$utils_ts$mergeArrays,
		mergeAbsoluteFilePathSets: ___R$project$rome$$internal$project$utils_ts$mergeAbsoluteFilePathSets,
		getParentConfigDependencies: ___R$project$rome$$internal$project$utils_ts$getParentConfigDependencies,
	};
	function ___R$project$rome$$internal$project$utils_ts$assertHardMeta(meta) {
		const {configPath, projectDirectory: directory, consumer} = meta;
		if (
			configPath === undefined ||
			directory === undefined ||
			consumer === undefined
		) {
			throw new Error("This is not a disk project");
		}

		return Object.assign(
			{},
			meta,
			{configPath, consumer, projectDirectory: directory},
		);
	}

	function ___R$project$rome$$internal$project$utils_ts$arrayOfStrings(consumer) {
		if (consumer.exists()) {
			return consumer.asMappedArray((item) => item.asString());
		} else {
			return [];
		}
	}

	function ___R$project$rome$$internal$project$utils_ts$arrayOfPatterns(
		consumer,
	) {
		// TODO consumer.handleThrownDiagnostics
		return consumer.asMappedArray((item) => {
			return ___R$project$rome$$internal$path$match$parse_ts$parsePattern({
				path: consumer.filename,
				input: item.asString(),
				offsetPosition: item.getLocation("inner-value").start,
			});
		});
	}

	function ___R$project$rome$$internal$project$utils_ts$mergeArrays(a, b) {
		if (a === undefined) {
			return a;
		}

		if (b === undefined) {
			return a;
		}

		return [...a, ...b];
	}

	function ___R$project$rome$$internal$project$utils_ts$mergeAbsoluteFilePathSets(
		a,
		b,
	) {
		if (a === undefined) {
			return a;
		}

		if (b === undefined) {
			return a;
		}

		return new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet([
			...a,
			...b,
		]);
	}

	function ___R$project$rome$$internal$project$utils_ts$getParentConfigDependencies(
		path,
	) {
		const deps = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet();

		for (const directory of path.getChain()) {
			deps.add(directory.append("package.json"));

			for (const configFilename of ___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_FILENAMES) {
				deps.add(directory.append(".config", configFilename));
				deps.add(directory.append(configFilename));
			}
		}

		return deps;
	}


  // project-rome/@internal/codec-config/types.ts



  // project-rome/@internal/codec-config/parse.ts
// Words can't start with a digit
	function ___R$$priv$project$rome$$internal$codec$json$parse_ts$isWordStartChar(
		char,
	) {
		return (
			___R$project$rome$$internal$parser$core$utils_ts$isAlpha(char) ||
			char === "_" ||
			char === "$"
		);
	}

	// But a digit can appear inside of a word
	function ___R$$priv$project$rome$$internal$codec$json$parse_ts$isWordChar(
		char,
	) {
		return (
			___R$$priv$project$rome$$internal$codec$json$parse_ts$isWordStartChar(
				char,
			) || ___R$project$rome$$internal$parser$core$utils_ts$isDigit(char)
		);
	}

	// Check if an input string is a valid word, this is used by the stringifier to
	// determine if a property key should be quoted
	function ___R$project$rome$$internal$codec$json$parse_ts$isValidWord(word) {
		if (
			word.length === 0 ||
			!___R$$priv$project$rome$$internal$codec$json$parse_ts$isWordStartChar(
				word[0],
			)
		) {
			return false;
		}

		for (const char of word) {
			if (
				!___R$$priv$project$rome$$internal$codec$json$parse_ts$isWordChar(char)
			) {
				return false;
			}
		}

		return true;
	}

	// Check if a character is a part of a string, returning false for a newline or unescaped quote char
	function ___R$$priv$project$rome$$internal$codec$json$parse_ts$isJSONStringValueChar(
		char,
		index,
		input,
	) {
		if (char === "\n") {
			return false;
		}

		return ___R$$priv$project$rome$$internal$codec$json$parse_ts$isRJSONStringValueChar(
			char,
			index,
			input,
		);
	}

	// NOTE: Different methods as we allow newlines in RJSON strings
	function ___R$$priv$project$rome$$internal$codec$json$parse_ts$isRJSONStringValueChar(
		char,
		index,
		input,
	) {
		return !(char === '"' &&
		!___R$project$rome$$internal$string$utils$isEscaped_ts$isEscaped(
			index,
			input,
		));
	}

	// Turn a path into a string key we can use
	function ___R$project$rome$$internal$codec$json$parse_ts$toPathKey(parts) {
		// Right now this could conflict weirdly with properties with dots in them if they cause collisions
		// We have this method abstracted so we can make changes later if it's necessary (probably not worth it)
		return parts.join(".");
	}

	function ___R$$priv$project$rome$$internal$codec$json$parse_ts$isntNewline(
		char,
	) {
		return char !== "\n";
	}

	function ___R$$priv$project$rome$$internal$codec$json$parse_ts$isntBlockCommentEnd(
		char,
		index,
		input,
	) {
		const nextChar = input[___R$project$rome$$internal$ob1$index_ts$ob1Get0(
			index,
		) + 1];
		return char !== "*" && nextChar !== "/";
	}

	// Used for Number token validation, allow underscore as a separatore
	function ___R$$priv$project$rome$$internal$codec$json$parse_ts$isNumberChar(
		char,
	) {
		return (
			___R$project$rome$$internal$parser$core$utils_ts$isDigit(char) ||
			char === "_"
		);
	}

	const ___R$project$rome$$internal$codec$json$parse_ts$createJSONParser = ___R$project$rome$$internal$parser$core$utils_ts$createParser({
		diagnosticCategory: "parse/json",
		ignoreWhitespaceTokens: true,
		retainCarriageReturn: true,
		getInitialState(parser) {
			return {
				hasExtensions: parser.path !== undefined &&
				parser.path.getBasename().endsWith(".rjson"),
				pathKeys: [],
				paths: new Map(),
				pathToComments: new Map(),
			};
		},
		tokenize(parser, index) {
			const char = parser.getInputCharOnly(index);
			const nextChar = parser.getInputCharOnly(index, 1);

			// Line comment
			if (char === "/" && nextChar === "/") {
				const commentValueIndex = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
					index,
					2,
				);
				const [value] = parser.readInputFrom(
					commentValueIndex,
					___R$$priv$project$rome$$internal$codec$json$parse_ts$isntNewline,
				);
				// (comment content start + comment content length)
				return parser.finishValueToken(
					"LineComment",
					value,
					___R$project$rome$$internal$ob1$index_ts$ob1Add(
						commentValueIndex,
						value.length,
					),
				);
			}

			// BlockComment
			if (char === "/" && nextChar === "*") {
				const commentValueIndex = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
					index,
					2,
				);
				const [value] = parser.readInputFrom(
					commentValueIndex,
					___R$$priv$project$rome$$internal$codec$json$parse_ts$isntBlockCommentEnd,
				);

				// (comment content start + comment content length + 2 characters for comment end)
				const endIndex = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
					___R$project$rome$$internal$ob1$index_ts$ob1Add(
						commentValueIndex,
						value.length,
					),
					2,
				);

				// Ensure the comment is closed
				if (
					parser.input[___R$project$rome$$internal$ob1$index_ts$ob1Get0(
						endIndex,
					) - 2] !== "*" ||
					parser.input[___R$project$rome$$internal$ob1$index_ts$ob1Get0(
						endIndex,
					) - 1] !== "/"
				) {
					throw parser.unexpected({
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JSON.UNCLOSED_BLOCK_COMMENT,
						start: parser.getPositionFromIndex(endIndex),
					});
				}

				return parser.finishValueToken("BlockComment", value, endIndex);
			}

			// Single character token starters
			switch (char) {
				case '"': {
					const [value, end, overflow] = parser.readInputFrom(
						___R$project$rome$$internal$ob1$index_ts$ob1Inc(index),
						parser.state.hasExtensions
							? ___R$$priv$project$rome$$internal$codec$json$parse_ts$isRJSONStringValueChar
							: ___R$$priv$project$rome$$internal$codec$json$parse_ts$isJSONStringValueChar,
					);

					if (overflow) {
						throw parser.unexpected({
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JSON.UNCLOSED_STRING,
							start: parser.getPositionFromIndex(end),
						});
					}

					// Don't allow newlines in JSON
					if (!parser.state.hasExtensions) {
						for (let strIndex = 0; strIndex < value.length; strIndex++) {
							const char = value[strIndex];

							if (char === "\n") {
								throw parser.unexpected({
									description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JSON.STRING_NEWLINES_IN_JSON,
									start: parser.getPositionFromIndex(
										___R$project$rome$$internal$ob1$index_ts$ob1Add(
											index,
											strIndex,
										),
									),
								});
							}
						}
					}

					// Unescape the string
					const unescaped = ___R$project$rome$$internal$string$escape$unescapeJSONString_ts$default(
						value,
						(metadata, strIndex) => {
							throw parser.unexpected({
								description: metadata,
								start: parser.getPositionFromIndex(
									___R$project$rome$$internal$ob1$index_ts$ob1Add(
										index,
										strIndex,
									),
								),
							});
						},
						parser.state.hasExtensions,
					);

					// increment to take the trailing quote
					return parser.finishValueToken(
						"String",
						unescaped,
						___R$project$rome$$internal$ob1$index_ts$ob1Inc(end),
					);
				}

				case "'":
					throw parser.unexpected({
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JSON.SINGLE_QUOTE_USAGE,
						start: parser.getPositionFromIndex(index),
					});

				case "/":
					throw parser.unexpected({
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JSON.REGEX_IN_JSON,
						start: parser.getPositionFromIndex(index),
					});

				case ",":
					return parser.finishToken("Comma");

				case ".":
					return parser.finishToken("Dot");

				case "-":
					return parser.finishToken("Minus");

				case "+":
					return parser.finishToken("Plus");

				case ":":
					return parser.finishToken("Colon");

				case "{":
					return parser.finishToken("BraceOpen");

				case "}":
					return parser.finishToken("BraceClose");

				case "[":
					return parser.finishToken("BracketOpen");

				case "]":
					return parser.finishToken("BracketClose");
			}

			// Numbers
			if (___R$project$rome$$internal$parser$core$utils_ts$isDigit(char)) {
				const value = ___R$$priv$project$rome$$internal$codec$json$parse_ts$removeUnderscores(
					parser,
					index,
					parser.readInputFrom(
						index,
						___R$$priv$project$rome$$internal$codec$json$parse_ts$isNumberChar,
					)[0],
				);
				const num = Number(value);
				return parser.finishValueToken(
					"Number",
					num,
					___R$project$rome$$internal$ob1$index_ts$ob1Add(index, value.length),
				);
			}

			// Word - boolean, undefined etc
			if (
				___R$$priv$project$rome$$internal$codec$json$parse_ts$isWordStartChar(
					char,
				)
			) {
				const [value] = parser.readInputFrom(
					index,
					___R$$priv$project$rome$$internal$codec$json$parse_ts$isWordChar,
				);
				return parser.finishValueToken(
					"Word",
					value,
					___R$project$rome$$internal$ob1$index_ts$ob1Add(index, value.length),
				);
			}

			// Unknown character
			return undefined;
		},
	});

	function ___R$$priv$project$rome$$internal$codec$json$parse_ts$getPathInfo(
		parser,
		path,
	) {
		return parser.state.paths.get(path.join("."));
	}

	function ___R$$priv$project$rome$$internal$codec$json$parse_ts$setComments(
		parser,
		pathComments,
	) {
		const key = parser.state.pathKeys.join(".");

		const existing = parser.state.pathToComments.get(key);
		if (existing === undefined) {
			parser.state.pathToComments.set(key, pathComments);
		} else {
			parser.state.pathToComments.set(
				key,
				{
					inner: [...existing.inner, ...pathComments.inner],
					outer: [...existing.outer, ...pathComments.outer],
				},
			);
		}
	}

	function ___R$$priv$project$rome$$internal$codec$json$parse_ts$setPath(
		{state},
		info,
	) {
		state.paths.set(state.pathKeys.join("."), info);
		state.pathKeys.pop();
	}

	function ___R$$priv$project$rome$$internal$codec$json$parse_ts$parseObject(
		parser,
		firstKeyStart,
		firstKey,
	) {
		const obj = {};

		let innerComments = [];
		let isFirstProp = true;

		// These are comments that the next property should take in case the previous accidently took them
		let nextLeadingComments;

		do {
			if (parser.matchToken("BraceClose")) {
				break;
			}

			// Eat all the comments that appeared before this property, it's the most common and natural place to put them,
			// and is where we'll print all comments for a property.
			let leadingComments = ___R$$priv$project$rome$$internal$codec$json$parse_ts$eatComments(
				parser,
			);

			// Take any leading comments that were left by the previous property
			if (nextLeadingComments !== undefined) {
				leadingComments = [...nextLeadingComments, ...leadingComments];
				nextLeadingComments = undefined;
			}

			// Throw a meaningful error for redundant commas
			if (parser.matchToken("Comma")) {
				throw parser.unexpected({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JSON.REDUNDANT_COMMA,
				});
			}

			// If there's no property key indicator then delegate any comments we have to object
			const hasKey = isFirstProp && firstKey !== undefined;
			if (!hasKey && !parser.matchToken("String") && !parser.matchToken("Word")) {
				innerComments = [...innerComments, ...leadingComments];
				break;
			}

			const keyStart =
				isFirstProp && firstKeyStart !== undefined
					? firstKeyStart
					: parser.getPosition();

			// Parse the property key
			let key;
			if (isFirstProp && firstKey !== undefined) {
				// If this is the first property and we've been given a property key then use it instead
				key = firstKey;
			} else {
				key = ___R$$priv$project$rome$$internal$codec$json$parse_ts$parsePropertyKey(
					parser,
				);
			}
			isFirstProp = false;

			const keyEnd = parser.getPosition();
			parser.expectToken("Colon");

			// Having comments before the value is a really weird place to put them, but we'll handle it
			// anyway to avoid throwing a parser error. When stringified, the comments will all be before
			// the property.
			const leadingValueComments = ___R$$priv$project$rome$$internal$codec$json$parse_ts$eatComments(
				parser,
			);

			parser.state.pathKeys.push(key);

			// Parse the value.
			const valueStart = parser.getPosition();
			const value = ___R$$priv$project$rome$$internal$codec$json$parse_ts$parseExpression(
				parser,
			);
			const valueEnd = parser.getLastEndPosition();

			// Eat the comments after the expression and associate the comments with them
			let trailingValueComments = ___R$$priv$project$rome$$internal$codec$json$parse_ts$eatComments(
				parser,
			);

			// If the next token isn't a comma or closing brace then we've just stolen
			// the leading comments of the next property
			if (!parser.matchToken("Comma") && !parser.matchToken("BraceClose")) {
				nextLeadingComments = trailingValueComments;
				trailingValueComments = [];
			}

			___R$$priv$project$rome$$internal$codec$json$parse_ts$setComments(
				parser,
				{
					inner: [],
					outer: [
						...leadingComments,
						...leadingValueComments,
						...trailingValueComments,
					],
				},
			);

			___R$$priv$project$rome$$internal$codec$json$parse_ts$setPath(
				parser,
				{
					keyStart,
					keyEnd,
					valueStart,
					valueEnd,
					originalValue: value,
				},
			);

			// Set the object correctly, accounting for JS weirdness
			if (key === "__proto__") {
				// Need to use defineProperty to avoid triggering the Object.prototype.__proto__ setter
				Object.defineProperty(
					obj,
					"__proto__",
					{
						value,
						configurable: true,
						writable: true,
						enumerable: true,
					},
				);
			} else {
				obj[key] = value;
			}
		} while (
			___R$$priv$project$rome$$internal$codec$json$parse_ts$eatPropertySeparator(
				parser,
			)
		);

		// Take any loose leading comments
		if (nextLeadingComments !== undefined) {
			innerComments = [...innerComments, ...nextLeadingComments];
		}

		// If we were passed a first key then this was an implicit object so there's no end token
		if (firstKey === undefined) {
			parser.expectToken("BraceClose");
		}

		___R$$priv$project$rome$$internal$codec$json$parse_ts$setComments(
			parser,
			{
				inner: innerComments,
				outer: [],
			},
		);

		return obj;
	}

	// Remove underscores from 'a string, this is used for numeric separators eg. 100_000
	function ___R$$priv$project$rome$$internal$codec$json$parse_ts$removeUnderscores(
		parser,
		index,
		raw,
	) {
		let str = "";

		for (let i = 0; i < raw.length; i++) {
			const char = raw[i];

			if (char === "_") {
				// Don't allow separators in JSON
				if (!parser.state.hasExtensions) {
					throw parser.unexpected({
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JSON.NUMERIC_SEPARATORS_IN_JSON,
						start: parser.getPositionFromIndex(
							___R$project$rome$$internal$ob1$index_ts$ob1Inc(index),
						),
					});
				}
			} else {
				str += char;
			}
		}

		return str;
	}

	function ___R$$priv$project$rome$$internal$codec$json$parse_ts$eatComments(
		parser,
	) {
		const comments = [];

		while (true) {
			const token = parser.getToken();

			if (token.type === "LineComment") {
				comments.push({
					type: "LineComment",
					value: token.value,
				});
			} else if (token.type === "BlockComment") {
				comments.push({
					type: "BlockComment",
					value: token.value,
				});
			} else {
				break;
			}

			// Comments aren't allowed in regular JSON
			if (!parser.state.hasExtensions) {
				throw parser.unexpected({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JSON.COMMENTS_IN_JSON,
				});
			}

			parser.nextToken();
		}

		return comments;
	}

	function ___R$$priv$project$rome$$internal$codec$json$parse_ts$parseArray(
		parser,
	) {
		parser.expectToken("BracketOpen");

		const arr = [];
		let innerComments = [];
		let i = 0;

		do {
			if (parser.matchToken("BracketClose")) {
				break;
			}

			// Eat all the comments before an element
			const leadingComments = ___R$$priv$project$rome$$internal$codec$json$parse_ts$eatComments(
				parser,
			);

			if (parser.matchToken("Comma")) {
				throw parser.unexpected({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JSON.REDUNDANT_COMMA,
				});
			}

			// If we're at the end of the array then associate these comments with the array
			if (parser.matchToken("BracketClose")) {
				innerComments = [...innerComments, ...leadingComments];
				break;
			}

			const start = parser.getPosition();
			parser.state.pathKeys.push(i);
			i++;

			// Parse the value
			const item = ___R$$priv$project$rome$$internal$codec$json$parse_ts$parseExpression(
				parser,
			);
			arr.push(item);
			const end = parser.getLastEndPosition();

			// Trailing comments are really weird, but let's handle them just like object properties
			const trailingComments = ___R$$priv$project$rome$$internal$codec$json$parse_ts$eatComments(
				parser,
			);

			___R$$priv$project$rome$$internal$codec$json$parse_ts$setComments(
				parser,
				{
					outer: [...leadingComments, ...trailingComments],
					inner: [],
				},
			);

			___R$$priv$project$rome$$internal$codec$json$parse_ts$setPath(
				parser,
				{
					originalValue: item,
					keyStart: start,
					keyEnd: end,
					valueStart: start,
					valueEnd: end,
				},
			);

			// Have a meaningful error message when an object is incorrectly using brackets: ["foo": "bar"]
			if (parser.matchToken("Colon")) {
				throw parser.unexpected({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JSON.MISTAKEN_ARRAY_IDENTITY,
				});
			}
		} while (
			___R$$priv$project$rome$$internal$codec$json$parse_ts$eatPropertySeparator(
				parser,
			)
		);

		parser.expectToken("BracketClose");

		___R$$priv$project$rome$$internal$codec$json$parse_ts$setComments(
			parser,
			{
				inner: innerComments,
				outer: [],
			},
		);

		return arr;
	}

	// Check if the current token is a property separator and eat it if necessary
	function ___R$$priv$project$rome$$internal$codec$json$parse_ts$eatPropertySeparator(
		parser,
	) {
		const token = parser.getToken();

		// Implicit commas are only allowed in rjson
		if (parser.state.hasExtensions) {
			// Eat the token, don't care if we're in RJSON
			if (token.type === "Comma") {
				parser.nextToken();
			}

			// An object or array close is an instant failure
			// Doesn't matter what we're parsing since the subsequent tokens will be validated
			if (token.type === "BraceClose" || token.type === "BracketClose") {
				return false;
			}

			return true;
		} else {
			if (token.type !== "Comma") {
				return false;
			}

			// Make sure this isn't a trailing comma
			const lookahead = parser.lookaheadToken();
			if (lookahead.type === "BraceClose" || lookahead.type === "BracketClose") {
				throw parser.unexpected({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JSON.TRAILING_COMMA_IN_JSON,
				});
			}

			parser.nextToken();
			return true;
		}
	}

	function ___R$$priv$project$rome$$internal$codec$json$parse_ts$parseWord(
		parser,
		isStart,
	) {
		const start = parser.getPosition();
		const token = parser.expectToken("Word");

		switch (token.value) {
			case "true":
				return true;

			case "false":
				return false;

			case "null":
				return null;

			case "undefined":
				throw parser.unexpected({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JSON.UNDEFINED_IN_JSON,
				});
		}

		if (isStart && parser.matchToken("Colon")) {
			if (parser.state.hasExtensions) {
				return ___R$$priv$project$rome$$internal$codec$json$parse_ts$parseObject(
					parser,
					start,
					token.value,
				);
			} else {
				throw parser.unexpected({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JSON.IMPLICIT_OBJECT_IN_JSON,
				});
			}
		}

		throw parser.unexpected({
			description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JSON.UNKNOWN_WORD_IN_JSON(
				token.value,
			),
		});
	}

	function ___R$$priv$project$rome$$internal$codec$json$parse_ts$parseNumber(
		parser,
	) {
		const isNegative = parser.eatToken("Minus") !== undefined;

		// Get a string of the current number that we'll parse later
		const token = parser.expectToken("Number");
		let value = String(token.value);

		// Decimals
		if (parser.eatToken("Dot")) {
			value += ".";

			const decimal = parser.expectToken("Number");
			value += String(decimal.value);
		}

		// Scientific notation
		const nextToken = parser.getToken();
		if (
			nextToken.type === "Word" &&
			(nextToken.value === "e" || nextToken.value === "E")
		) {
			value += "e";

			// Operator
			const operator = parser.nextToken();
			if (operator.type === "Minus") {
				value += "-";
			} else if (operator.type === "Plus") {
				value += "+";
			} else {
				throw parser.unexpected();
			}

			// Factor
			parser.nextToken();
			const factor = parser.expectToken("Number");
			value += String(factor.value);
		}

		// BigInt
		const nextToken2 = parser.getToken();
		if (nextToken2.type === "Word" && nextToken2.value === "n") {
			throw parser.unexpected({
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JSON.BIGINT_IN_JSON,
			});
		}

		// Turn the string into an actual number
		let num = Number(value);
		if (isNegative) {
			num = -num;
		}
		return num;
	}

	function ___R$$priv$project$rome$$internal$codec$json$parse_ts$parsePropertyKey(
		parser,
	) {
		const token = parser.getToken();

		switch (token.type) {
			case "String": {
				parser.nextToken();
				return token.value;
			}

			case "Word":
				if (parser.state.hasExtensions) {
					parser.nextToken();
					return token.value;
				} else {
					throw parser.unexpected({
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JSON.PROPERTY_KEY_UNQUOTED_IN_JSON,
					});
				}

			default:
				throw parser.unexpected();
		}
	}

	function ___R$$priv$project$rome$$internal$codec$json$parse_ts$parseString(
		parser,
		isStart,
	) {
		const start = parser.getPosition();
		const token = parser.expectToken("String");

		if (isStart && parser.nextToken().type === "Colon") {
			if (parser.state.hasExtensions) {
				return ___R$$priv$project$rome$$internal$codec$json$parse_ts$parseObject(
					parser,
					start,
					token.value,
				);
			} else {
				throw parser.unexpected({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JSON.IMPLICIT_OBJECT_IN_JSON,
				});
			}
		} else {
			return token.value;
		}
	}

	function ___R$$priv$project$rome$$internal$codec$json$parse_ts$parseExpression(
		parser,
		isStart = false,
	) {
		const token = parser.getToken();

		switch (token.type) {
			case "String":
				return ___R$$priv$project$rome$$internal$codec$json$parse_ts$parseString(
					parser,
					isStart,
				);

			case "Minus":
			case "Number":
				return ___R$$priv$project$rome$$internal$codec$json$parse_ts$parseNumber(
					parser,
				);

			case "Word":
				return ___R$$priv$project$rome$$internal$codec$json$parse_ts$parseWord(
					parser,
					isStart,
				);

			case "BracketOpen":
				return ___R$$priv$project$rome$$internal$codec$json$parse_ts$parseArray(
					parser,
				);

			case "BraceOpen": {
				parser.nextToken();
				return ___R$$priv$project$rome$$internal$codec$json$parse_ts$parseObject(
					parser,
				);
			}

			default:
				throw parser.unexpected();
		}
	}

	function ___R$$priv$project$rome$$internal$codec$json$parse_ts$parseEntry(
		parser,
	) {
		if (parser.matchToken("EOF")) {
			if (parser.state.hasExtensions) {
				// If we're in RJSON mode then an empty input is an implicit object
				return {};
			} else {
				throw parser.unexpected({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.JSON.EMPTY_INPUT_IN_JSON,
				});
			}
		} else {
			return ___R$$priv$project$rome$$internal$codec$json$parse_ts$parseExpression(
				parser,
				true,
			);
		}
	}

	function ___R$project$rome$$internal$codec$json$parse_ts$parseJSONExtra(opts) {
		const parser = ___R$project$rome$$internal$codec$json$parse_ts$createJSONParser(
			opts,
		);
		const consumeDiagnosticCategory =
			parser.options.consumeDiagnosticCategory == null
				? "parse/json"
				: parser.options.consumeDiagnosticCategory;

		let expectSyntaxError = false;

		if (!parser.state.hasExtensions) {
			// If we're in regular JSON, try the native JSON.parse
			try {
				const value = JSON.parse(parser.input);

				// Lazy parse when we need location information
				let context;
				function getContext() {
					if (context === undefined) {
						const res = ___R$$priv$project$rome$$internal$codec$json$parse_ts$_parse(
							parser,
							consumeDiagnosticCategory,
						);
						context = res.context;
						return res.context;
					} else {
						return context;
					}
				}

				return {
					hasExtensions: false,
					path: parser.path,
					comments: new Map(),
					context: {
						category: consumeDiagnosticCategory,
						normalizeKey(path) {
							return getContext().normalizeKey(path);
						},
						getOriginalValue(path) {
							return getContext().getOriginalValue(path);
						},
						getDiagnosticLocation(keys, target) {
							return getContext().getDiagnosticLocation(keys, target);
						},
					},
					value,
				};
			} catch (err) {
				// On syntax errors we'll fall back to our parser which is slower, but produces more meaningful errors
				if (err instanceof SyntaxError) {
					expectSyntaxError = true;
				} else {
					throw err;
				}
			}
		}

		const res = ___R$$priv$project$rome$$internal$codec$json$parse_ts$_parse(
			parser,
			consumeDiagnosticCategory,
		);

		if (expectSyntaxError) {
			throw new Error(
				"JSON.parse failed but our custom JSON parser was successful... That doesn't smell right",
			);
		}

		return res;
	}

	function ___R$$priv$project$rome$$internal$codec$json$parse_ts$_parse(
		parser,
		category,
	) {
		const leadingComments = ___R$$priv$project$rome$$internal$codec$json$parse_ts$eatComments(
			parser,
		);

		const expr = ___R$$priv$project$rome$$internal$codec$json$parse_ts$parseEntry(
			parser,
		);

		const trailingComments = ___R$$priv$project$rome$$internal$codec$json$parse_ts$eatComments(
			parser,
		);
		___R$$priv$project$rome$$internal$codec$json$parse_ts$setComments(
			parser,
			{
				inner: [],
				outer: [...leadingComments, ...trailingComments],
			},
		);

		parser.finalize();

		const context = {
			category,
			normalizeKey: (key) => key,
			getDiagnosticLocation: (keys, target) => {
				const info = ___R$$priv$project$rome$$internal$codec$json$parse_ts$getPathInfo(
					parser,
					keys,
				);
				if (info === undefined) {
					return {
						language: "json",
						filename: parser.filename,
					};
				}

				let start = info.keyStart;
				let end = info.valueEnd;

				if (target === "key") {
					end = info.keyEnd;
				}

				if (target === "value" || target === "inner-value") {
					start = info.valueStart;
				}

				let loc = {
					filename: parser.filename,
					start,
					end,
				};

				if (target === "inner-value") {
					const originalValue = context.getOriginalValue(keys);

					// Remove quote marks for strings
					if (typeof originalValue === "string") {
						loc = Object.assign(
							{},
							loc,
							{
								start: Object.assign(
									{},
									loc.start,
									{
										column: ___R$project$rome$$internal$ob1$index_ts$ob1Add(
											loc.start.column,
											1,
										),
									},
								),
								end: Object.assign(
									{},
									loc.end,
									{
										column: ___R$project$rome$$internal$ob1$index_ts$ob1Sub(
											loc.end.column,
											1,
										),
									},
								),
							},
						);
					}
				}

				return Object.assign(
					{language: "json"},
					loc,
					{mtime: parser.mtime, sourceText: undefined},
				);
			},
			getOriginalValue: (keys) => {
				const info = ___R$$priv$project$rome$$internal$codec$json$parse_ts$getPathInfo(
					parser,
					keys,
				);
				if (info !== undefined) {
					return info.originalValue;
				}
			},
		};

		return {
			path: parser.path,
			hasExtensions: parser.state.hasExtensions,
			comments: parser.state.pathToComments,
			value: expr,
			context,
		};
	}


  // project-rome/@internal/codec-config/stringify.ts
function ___R$$priv$project$rome$$internal$codec$json$stringify_ts$joinList(
		open,
		close,
		indent,
		items,
	) {
		if (items.length === 0) {
			return open + close;
		} else {
			return [open, ...items, indent + close].join("\n");
		}
	}

	function ___R$$priv$project$rome$$internal$codec$json$stringify_ts$stringifyKey(
		key,
	) {
		if (___R$project$rome$$internal$codec$json$parse_ts$isValidWord(key)) {
			// A property key doesn't need quotes if it's a valid word
			return key;
		} else {
			return ___R$project$rome$$internal$string$escape$escapeJSString_ts$default(
				key,
				{
					quote: '"',
					ignoreWhitespaceEscapes: true,
					json: true,
				},
			);
		}
	}

	function ___R$project$rome$$internal$codec$json$stringify_ts$stringifyComments(
		indent,
		comments,
	) {
		return comments.map((node) => {
			if (node.type === "BlockComment") {
				return indent + "/*" + node.value + "*/";
			} else {
				// node.type === 'LineComment'
				return indent + "//" + node.value;
			}
		});
	}

	function ___R$$priv$project$rome$$internal$codec$json$stringify_ts$stringifyPrimitives(
		value,
	) {
		if (value === null) {
			return "null";
		}

		// Coerce primitive objects to their primitive form, as specified in ECMA262 24.5.2.1
		if (
			value instanceof Number ||
			value instanceof String ||
			value instanceof Boolean
		) {
			value = value.valueOf();
		}

		// Basic primitive types
		switch (typeof value) {
			case "symbol":
			case "function":
			case "undefined":
				return "null";

			case "boolean":
				return value ? "true" : "false";

			case "string":
				return ___R$project$rome$$internal$string$escape$escapeJSString_ts$default(
					value,
					{
						quote: '"',
						json: true,
						ignoreWhitespaceEscapes: true,
					},
				);

			case "bigint":
				// This is the actual V8 message lol
				throw new Error("Do not know how to serialize a BigInt");

			case "number":
				return ___R$project$rome$$internal$cli$layout$format_ts$markupToJoinedPlainText(
					___R$project$rome$$internal$pretty$format$index_ts$formatNumber(value),
				);
		}

		return undefined;
	}

	function ___R$$priv$project$rome$$internal$codec$json$stringify_ts$sortMapKeys(
		map,
	) {
		return new Set(
			Array.from(map.keys()).sort(
				___R$project$rome$$internal$string$utils$naturalCompare_ts$naturalCompare,
			),
		);
	}

	function ___R$$priv$project$rome$$internal$codec$json$stringify_ts$sortMap(
		map,
	) {
		const sortedMap = new Map();
		const sortedKeys = ___R$$priv$project$rome$$internal$codec$json$stringify_ts$sortMapKeys(
			map,
		);

		// Add any prioritized keys so they're before anything alphabetized
		for (const key of ___R$project$rome$$internal$pretty$format$index_ts$PRIORITIZE_KEYS) {
			if (sortedKeys.has(key)) {
				sortedKeys.delete(key);

				const val = map.get(key);
				if (val === undefined) {
					throw new Error("Expected value");
				}

				sortedMap.set(key, val);
			}
		}

		// Now add the rest
		for (const key of sortedKeys) {
			const val = map.get(key);
			if (val === undefined) {
				throw new Error("Expected value");
			}

			sortedMap.set(key, val);
		}

		return sortedMap;
	}

	function ___R$$priv$project$rome$$internal$codec$json$stringify_ts$getComments(
		consumer,
		opts,
	) {
		const comments = opts.comments.get(consumer.keyPath.join("."));
		if (comments === undefined) {
			return {
				inner: [],
				outer: [],
			};
		} else {
			return comments;
		}
	}

	function ___R$$priv$project$rome$$internal$codec$json$stringify_ts$stringifyArray(
		consumer,
		info,
	) {
		const {level, prevIndent, nextIndent, stack} = info;

		let buff = [];

		const arr = consumer.asIterable();
		for (const consumer of arr) {
			// Add element comments
			const comments = ___R$$priv$project$rome$$internal$codec$json$stringify_ts$getComments(
				consumer,
				info,
			).outer;
			buff = buff.concat(
				___R$project$rome$$internal$codec$json$stringify_ts$stringifyComments(
					nextIndent,
					comments,
				),
			);

			// Add the actual element line
			const element = ___R$$priv$project$rome$$internal$codec$json$stringify_ts$stringifyConsumer(
				consumer,
				{
					comments: info.comments,
					isTopLevel: false,
					level: level + 1,
					stack,
				},
			);
			buff.push("" + nextIndent + element);
		}

		// Add inner comments
		const innerComments = ___R$$priv$project$rome$$internal$codec$json$stringify_ts$getComments(
			consumer,
			info,
		).inner;
		buff = buff.concat(
			___R$project$rome$$internal$codec$json$stringify_ts$stringifyComments(
				nextIndent,
				innerComments,
			),
		);

		return ___R$$priv$project$rome$$internal$codec$json$stringify_ts$joinList(
			"[",
			"]",
			prevIndent,
			buff,
		);
	}

	function ___R$$priv$project$rome$$internal$codec$json$stringify_ts$stringifyPlainObject(
		consumer,
		info,
	) {
		const {level, prevIndent, stack, isTopLevel} = info;
		let {nextIndent} = info;

		// Must be an object if we failed all the other conditions
		let buff = [];
		const map = consumer.asMap();

		// Remove function, symbol, and undefined properties
		for (const [key, consumer] of map) {
			const value = consumer.asUnknown();

			if (
				typeof value === "function" ||
				typeof value === "undefined" ||
				typeof value === "symbol"
			) {
				map.delete(key);
			}
		}

		let propLevel = level + 1;

		// We only want to increase the level for properties when we aren't at the top
		if (isTopLevel && level === 0) {
			propLevel = 0;
			nextIndent = "";
		}

		// Build properties
		for (const [key, consumer] of ___R$$priv$project$rome$$internal$codec$json$stringify_ts$sortMap(
			map,
		)) {
			// Add property comments
			const comments = ___R$$priv$project$rome$$internal$codec$json$stringify_ts$getComments(
				consumer,
				info,
			).outer;
			buff = buff.concat(
				___R$project$rome$$internal$codec$json$stringify_ts$stringifyComments(
					nextIndent,
					comments,
				),
			);

			// Add the actual property line
			const propKey = ___R$$priv$project$rome$$internal$codec$json$stringify_ts$stringifyKey(
				key,
			);
			const propValue = ___R$$priv$project$rome$$internal$codec$json$stringify_ts$stringifyConsumer(
				consumer,
				{
					comments: info.comments,
					isTopLevel: false,
					level: propLevel,
					stack,
				},
			);
			buff.push("" + nextIndent + propKey + ": " + propValue);
		}

		// We track this so we know whether we can safely put everything at the top level

		// If we only have comments then there's no way the parser could infer it was originally an object
		const hasProps = buff.length > 0;

		// Add inner comments
		const innerComments = ___R$$priv$project$rome$$internal$codec$json$stringify_ts$getComments(
			consumer,
			info,
		).inner;
		buff = buff.concat(
			___R$project$rome$$internal$codec$json$stringify_ts$stringifyComments(
				nextIndent,
				innerComments,
			),
		);

		if (level === 0 && isTopLevel) {
			if (hasProps) {
				return buff.join("\n");
			} else if (buff.length > 0) {
				// Otherwise we just have a bunch of comments
				// Indent them correctly and just output it as a normal object
				buff = buff.map((str) => {
					return "  " + str;
				});
			}
		}

		return ___R$$priv$project$rome$$internal$codec$json$stringify_ts$joinList(
			"{",
			"}",
			prevIndent,
			buff,
		);
	}

	function ___R$$priv$project$rome$$internal$codec$json$stringify_ts$stringifyObject(
		consumer,
		value,
		opts,
	) {
		const {isTopLevel, level, stack} = opts;

		const info = {
			comments: opts.comments,
			isTopLevel,
			nextIndent: "\t".repeat(level + 1),
			prevIndent: level === 0 ? "" : "\t".repeat(level - 1),
			level,
			stack,
		};

		try {
			stack.add(value);

			if (Array.isArray(value) || value instanceof Set) {
				return ___R$$priv$project$rome$$internal$codec$json$stringify_ts$stringifyArray(
					consumer,
					info,
				);
			}

			return ___R$$priv$project$rome$$internal$codec$json$stringify_ts$stringifyPlainObject(
				consumer,
				info,
			);
		} finally {
			stack.delete(value);
		}
	}

	function ___R$project$rome$$internal$codec$json$stringify_ts$stringifyRootConsumer(
		consumer,
		pathToComments,
	) {
		const opts = {
			comments: pathToComments,
			isTopLevel: true,
			level: 0,
			stack: new Set(),
		};

		// Nothing else handles comments at the top level
		const inner = ___R$$priv$project$rome$$internal$codec$json$stringify_ts$stringifyConsumer(
			consumer,
			opts,
		);
		const comments = ___R$$priv$project$rome$$internal$codec$json$stringify_ts$getComments(
			consumer,
			opts,
		);
		const outer = ___R$project$rome$$internal$codec$json$stringify_ts$stringifyComments(
			"",
			comments.outer,
		);

		return [...outer, inner].join("\n");
	}

	function ___R$$priv$project$rome$$internal$codec$json$stringify_ts$stringifyConsumer(
		consumer,
		opts,
	) {
		const value = consumer.asUnknown();

		// Stringify primitives
		const asPrim = ___R$$priv$project$rome$$internal$codec$json$stringify_ts$stringifyPrimitives(
			value,
		);
		if (asPrim !== undefined) {
			return asPrim;
		}

		// Check if we're already stringfying this value to prevent recursion
		if (opts.stack.has(value)) {
			throw new TypeError("Recursive");
		}

		return ___R$$priv$project$rome$$internal$codec$json$stringify_ts$stringifyObject(
			consumer,
			value,
			opts,
		);
	}


  // project-rome/@internal/codec-config/index.ts
function ___R$project$rome$$internal$codec$json$index_ts$consumeJSON(opts) {
		return ___R$project$rome$$internal$codec$json$index_ts$consumeJSONExtra(
			opts,
		).consumer;
	}

	function ___R$project$rome$$internal$codec$json$index_ts$consumeJSONExtra(
		opts,
	) {
		const {value, context, hasExtensions, comments, path} = ___R$project$rome$$internal$codec$json$parse_ts$parseJSONExtra(
			opts,
		);

		return {
			hasExtensions,
			consumer: ___R$project$rome$$internal$consume$index_ts$consume({
				filePath: path,
				context,
				objectPath: [],
				value,
				parent: undefined,
			}),
			comments,
		};
	}

	function ___R$project$rome$$internal$codec$json$index_ts$parseJSON(opts) {
		return ___R$project$rome$$internal$codec$json$parse_ts$parseJSONExtra(opts).value;
	}

	function ___R$project$rome$$internal$codec$json$index_ts$tokenizeJSON(opts) {
		return ___R$project$rome$$internal$codec$json$parse_ts$createJSONParser(
			opts,
		).tokenizeAll();
	}

	function ___R$project$rome$$internal$codec$json$index_ts$stringifyRJSONFromConsumer(
		opts,
	) {
		return ___R$project$rome$$internal$codec$json$stringify_ts$stringifyRootConsumer(
			opts.consumer,
			opts.comments,
		);
	}

	function ___R$project$rome$$internal$codec$json$index_ts$stringifyJSONExtra(
		res,
	) {
		if (res.hasExtensions) {
			return ___R$project$rome$$internal$codec$json$index_ts$stringifyRJSONFromConsumer(
				res,
			);
		} else {
			return ___R$project$rome$$internal$codec$json$index_ts$stringifyJSON(
				res.consumer.asUnknown(),
			);
		}
	}

	function ___R$project$rome$$internal$codec$json$index_ts$stringifyRJSON(
		value,
		comments = new Map(),
	) {
		return ___R$project$rome$$internal$codec$json$stringify_ts$stringifyRootConsumer(
			___R$project$rome$$internal$consume$index_ts$consumeUnknown(
				value,
				"parse/json",
			),
			comments,
		);
	}

	function ___R$project$rome$$internal$codec$json$index_ts$stringifyJSON(
		value,
		spaces = false,
	) {
		return JSON.stringify(value, null, spaces ? "  " : "\t");
	}


  // project-rome/@internal/events/Event.ts
class ___R$project$rome$$internal$events$Event_ts$default {
		constructor(opts) {
			this.subscriptions = new Set();
			this.rootSubscription = undefined;
			this.name = opts.name;
			this.options = opts;
		}

		onSubscriptionChange() {
			// Hook for BridgeEvent
		}

		clear() {
			this.subscriptions.clear();
			this.rootSubscription = undefined;
		}

		hasSubscribers() {
			return this.hasSubscriptions();
		}

		hasSubscriptions() {
			return this.rootSubscription !== undefined;
		}

		// Dispatch the event without caring about the return values
		send(param, required = false) {
			const {rootSubscription} = this;
			if (rootSubscription === undefined) {
				if (required) {
					throw new Error("No subscription for event " + this.name);
				}
				return;
			}

			rootSubscription(param);

			for (const callback of this.subscriptions) {
				callback(param);
			}
		}

		async call(param) {
			const {rootSubscription, subscriptions} = this;
			if (rootSubscription === undefined) {
				throw new Error("No subscription for event " + this.name);
			}

			if (this.options.serial === true) {
				const ret = await rootSubscription(param);
				for (const callback of subscriptions) {
					await callback(param);
				}
				return ret;
			} else {
				const res = await Promise.all([
					rootSubscription(param),
					...Array.from(subscriptions, (callback) => callback(param)),
				]);

				// Return the root subscription value
				return res[0];
			}
		}

		wait(val, timeout) {
			return new Promise((resolve, reject) => {
				let timeoutId;
				let timedOut = false;

				if (timeout !== undefined) {
					timeoutId = setTimeout(
						() => {
							timedOut = true;
							listener.unsubscribe().then(() => {
								reject(
									new Error(
										"Timed out after waiting " + timeout + "ms for " + this.name,
									),
								);
							}).catch((err) => {
								reject(err);
							});
						},
						timeout,
					);
				}

				const listener = this.subscribe(async (param) => {
					if (timedOut) {
						return val;
					}

					if (timeoutId !== undefined) {
						clearTimeout(timeoutId);
					}

					await listener.unsubscribe();
					resolve(param);
					return val;
				});
			});
		}

		async callOptional(param) {
			if (this.rootSubscription === undefined) {
				return undefined;
			} else {
				return this.call(param);
			}
		}

		subscribe(callback, makeRoot) {
			if (this.options.unique === true && this.subscriptions.size !== 0) {
				throw new Error(
					"Event " + this.name + " only allows a single subscription",
				);
			}

			if (this.rootSubscription === callback || this.subscriptions.has(callback)) {
				throw new Error("Cannot double subscribe a callback");
			}

			if (this.rootSubscription === undefined) {
				this.rootSubscription = callback;
			} else if (makeRoot === true) {
				this.subscriptions.add(this.rootSubscription);
				this.rootSubscription = callback;
			} else {
				this.subscriptions.add(callback);
			}

			this.onSubscriptionChange();

			return {
				unsubscribe: async () => {
					this.unsubscribe(callback);
				},
			};
		}

		unsubscribe(callback) {
			if (this.subscriptions.has(callback)) {
				this.subscriptions.delete(callback);
				this.onSubscriptionChange();
				return;
			}

			// If this callback was the root subscription, then set it to the next one
			if (callback === this.rootSubscription) {
				this.rootSubscription = Array.from(this.subscriptions)[0];
				this.subscriptions.delete(this.rootSubscription);
				this.onSubscriptionChange();
				return;
			}
		}
	}


  // project-rome/@internal/async/createDeferredPromise.ts
function ___R$project$rome$$internal$async$createDeferredPromise_ts$default() {
		let resolve;
		let reject;
		const promise = new Promise((_resolve, _reject) => {
			resolve = _resolve;
			reject = _reject;
		});

		if (resolve === undefined || reject === undefined) {
			throw new Error("Promise factory should have been executed...");
		}

		return {resolve, reject, promise};
	}


  // project-rome/@internal/async/lockers.ts
const ___R$project$rome$$internal$async$lockers_ts = {
		get Locker() {
			return ___R$project$rome$$internal$async$lockers_ts$Locker;
		},
		get FilePathLocker() {
			return ___R$project$rome$$internal$async$lockers_ts$FilePathLocker;
		},
		get GlobalLock() {
			return ___R$project$rome$$internal$async$lockers_ts$GlobalLock;
		},
	};
	class ___R$$priv$project$rome$$internal$async$lockers_ts$Lock {
		constructor(locker, mapKey) {
			this.locker = locker;
			this.resolves = [];
			this.mapKey = mapKey;
		}

		addResolve(resolve) {
			this.resolves.push(resolve);
		}

		release() {
			const {resolves} = this;

			if (resolves.length === 0) {
				this.locker.locks.delete(this.mapKey);
			} else {
				const resolve = resolves.shift();
				if (resolve === undefined) {
					throw new Error("Already validated resolved.length aboved");
				}
				resolve(this);
			}
		}
	}

	class ___R$$priv$project$rome$$internal$async$lockers_ts$LockerNormalized {
		constructor() {
			this.locks = new Map();
		}

		hasLock(key) {
			return this.locks.has(this.normalizeKey(key));
		}

		getNewLock(rawKey) {
			const mapKey = this.normalizeKey(rawKey);
			if (this.locks.has(mapKey)) {
				throw new Error("Expected no lock to exist");
			}

			const lock = new ___R$$priv$project$rome$$internal$async$lockers_ts$Lock(
				this,
				mapKey,
			);
			this.locks.set(mapKey, lock);
			return lock;
		}

		async getLock(rawKey) {
			const key = this.normalizeKey(rawKey);
			const existingLock = this.locks.get(key);

			if (existingLock === undefined) {
				return this.getNewLock(rawKey);
			} else {
				return new Promise((resolve) => {
					existingLock.addResolve(resolve);
				});
			}
		}

		async waitLockDrained(key) {
			while (this.hasLock(key)) {
				const lock = await this.getLock(key);
				lock.release();
			}
		}

		async waitLock(key) {
			if (this.hasLock(key)) {
				const lock = await this.getLock(key);
				lock.release();
			}
		}

		async wrapLock(key, callback) {
			const lock = await this.getLock(key);
			try {
				return await callback();
			} finally {
				lock.release();
			}
		}
	}

	class ___R$project$rome$$internal$async$lockers_ts$Locker
		extends ___R$$priv$project$rome$$internal$async$lockers_ts$LockerNormalized {
		normalizeKey(key) {
			return key;
		}
	}

	class ___R$project$rome$$internal$async$lockers_ts$FilePathLocker
		extends ___R$$priv$project$rome$$internal$async$lockers_ts$LockerNormalized {
		normalizeKey(path) {
			return path.join();
		}
	}

	class ___R$project$rome$$internal$async$lockers_ts$GlobalLock {
		constructor() {
			this.resolves = [];
			this.dependencies = 0;

			this.incrementEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "incrementEvent",
			});

			this.decrementEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "decrementEvent",
			});
		}

		attachLock(lock) {
			lock.incrementEvent.subscribe(() => {
				this.dependencies++;
			});

			lock.decrementEvent.subscribe(() => {
				this.dependencies--;

				if (this.dependencies === 0) {
					this.unlock();
				}
			});
		}

		unlock() {
			for (const resolve of this.resolves) {
				resolve();
			}
			this.resolves = [];
		}

		async wrap(fn) {
			try {
				this.dependencies++;
				return await fn();
			} finally {
				this.dependencies--;

				if (this.dependencies === 0) {
					this.unlock();
				}
			}
		}

		async wait() {
			if (this.dependencies > 0) {
				const {resolve, promise} = ___R$project$rome$$internal$async$createDeferredPromise_ts$default();
				this.resolves.push(resolve);
				await promise;
			}
		}
	}


  // project-rome/@internal/async/Queue.ts
class ___R$project$rome$$internal$async$Queue_ts$default {
		constructor({maxThreads = Infinity, maxPerThread = 2, callback}) {
			this.runningThreads = [];
			this.waitingThreads = [];

			this.threads = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
				"threads",
				() => ({
					running: false,
					items: [],
				}),
			);

			this.locked = false;
			this.paused = false;

			this.callback = callback;
			this.maxThreads = maxThreads;
			this.maxPerThread = maxPerThread;
		}

		async pushQueue(thread, metadata, wait = false) {
			if (this.locked) {
				throw new Error("Queue is locked and no longer accepts items");
			}

			const {resolve, promise} = ___R$project$rome$$internal$async$createDeferredPromise_ts$default();

			// Populate the worker queue for this item
			const queue = this.threads.assert(thread);
			queue.items.push([metadata, resolve]);

			if (!queue.running && !this.paused) {
				this.startThread(thread, queue);
			}

			// If requested, wait on this queue item to finish
			if (wait) {
				await promise;
			}
		}

		startThread(thread, queue) {
			// Start this thread if it isn't already
			if (this.runningThreads.length < this.maxThreads) {
				const promise = this.processThread(thread, queue);
				this.runningThreads.push(promise);

				// Add a `catch` so that we aren't considered an unhandled promise if it rejects before a handler is attached
				promise.catch(() => {});
			} else {
				// Otherwise when another thread has finished, we'll start
				this.waitingThreads.push(thread);
			}
		}

		async processThread(thread, queue) {
			queue.running = true;

			const {items} = queue;

			const next = async () => {
				if (this.paused) {
					return;
				}

				const item = items.shift();
				if (item === undefined) {
					// Exhausted queue
					return;
				}

				const [metadata, resolve] = item;
				await this.callback(metadata, thread);
				resolve();
				await next();
			};

			const threads = [];
			for (let i = 0; i < this.maxPerThread; i++) {
				threads.push(next());
			}
			await Promise.all(threads);

			queue.running = false;

			if (this.waitingThreads.length > 0 && !this.paused) {
				const nextThread = this.waitingThreads.shift();
				const nextQueue = this.threads.get(nextThread);
				await this.processThread(nextThread, nextQueue);
			}
		}

		async pause() {
			// Build promises of work that went complete, will indicate a completely paused queue
			const promises = [];
			for (const queue of this.threads.values()) {
				for (const item of queue.items) {
					promises.push(item[1]);
				}
			}
			this.paused = true;
			this.waitingThreads = [];
			await Promise.all(promises);
		}

		resume() {
			this.paused = false;

			// Restart all threads
			for (const [thread, queue] of this.threads) {
				if (queue.items.length > 0) {
					this.startThread(thread, queue);
				}
			}
		}

		lock() {
			this.locked = true;
		}

		async spin() {
			while (
				// Keep consuming all the promises until we're exhausted
				this.runningThreads.length >
				0
			) {
				const {runningThreads} = this;
				this.runningThreads = [];
				await Promise.all(runningThreads);
			}
		}
	}


  // project-rome/@internal/async/index.ts



  // project-rome/@internal/events/EventQueue.ts
class ___R$project$rome$$internal$events$EventQueue_ts$default {
		constructor(debounce = 100) {
			this.subscriptions = new Set();
			this.queue = [];
			this.queueKeys = new Set();
			this.timeout = undefined;
			this.debounce = debounce;
			this.lock = new ___R$project$rome$$internal$async$lockers_ts$GlobalLock();
		}

		hasDebounce() {
			return this.timeout !== undefined;
		}

		async flush() {
			const queue = this.queue;
			this.queue = [];
			this.queueKeys = new Set();

			const queueValues = queue.map((item) => item.value);

			await this.lock.wrap(async () => {
				if (this.timeout !== undefined) {
					const [callback, timeout] = this.timeout;
					clearTimeout(timeout);
					callback();
					this.timeout = undefined;
				}

				for (const callback of this.subscriptions) {
					await callback(queueValues);
				}

				for (const {resolve} of queue) {
					resolve();
				}
			});
		}

		async push(value, key) {
			if (key !== undefined && this.queueKeys.has(key)) {
				return;
			}

			const {resolve, promise} = ___R$project$rome$$internal$async$createDeferredPromise_ts$default();

			this.queue.push({resolve, value});
			if (key !== undefined) {
				this.queueKeys.add(key);
			}

			if (this.timeout === undefined) {
				const timeout = setTimeout(() => this.flush(), this.debounce);
				this.lock.wrap(async () => {
					const {promise, resolve} = ___R$project$rome$$internal$async$createDeferredPromise_ts$default();
					this.timeout = [resolve, timeout];
					await promise;
				});
			}

			await promise;
		}

		subscribe(callback) {
			this.subscriptions.add(callback);

			return {
				unsubscribe: async () => {
					await this.flush();
					this.subscriptions.delete(callback);
				},
			};
		}
	}


  // project-rome/@internal/events/BridgeError.ts
class ___R$project$rome$$internal$events$BridgeError_ts$default extends Error {
		constructor(message, bridge) {
			super(message);
			this.bridge = bridge;
		}
	}


  // project-rome/@internal/events/BridgeEvent.ts
function ___R$$priv$project$rome$$internal$events$BridgeEvent_ts$validateDirection(
		// rome-ignore lint/ts/noExplicitAny: future cleanup
		event,
		invalidDirections,
		verb,
	) {
		invalidDirections.push(["server<->client", "server&client"]);

		for (const [eventDirection, bridgeType] of invalidDirections) {
			if (event.direction === eventDirection && event.bridge.type === bridgeType) {
				throw new Error(
					"The " +
					eventDirection +
					' event "' +
					event.name +
					'" cannot be ' +
					verb +
					" by a " +
					bridgeType +
					" bridge",
				);
			}
		}
	}

	class ___R$project$rome$$internal$events$BridgeEvent_ts$default
		extends ___R$project$rome$$internal$events$Event_ts$default {
		constructor(opts, bridge) {
			super(opts);

			this.bridge = bridge;
			this.requestCallbacks = new Map();
			this.direction = opts.direction;
		}

		clear() {
			super.clear();
			this.requestCallbacks.clear();
		}

		end(err) {
			for (const {reject} of this.requestCallbacks.values()) {
				reject(err);
			}
		}

		onSubscriptionChange() {
			___R$$priv$project$rome$$internal$events$BridgeEvent_ts$validateDirection(
				this,
				[["server->client", "client"], ["server<-client", "server"]],
				"subscribed",
			);
			this.bridge.sendSubscriptions();
		}

		dispatchRequest(param) {
			return super.call(param);
		}

		dispatchResponse(id, data) {
			const callbacks = this.requestCallbacks.get(id);
			if (!callbacks) {
				// ???
				return;
			}

			this.requestCallbacks.delete(id);

			if (data.responseStatus === "success") {
				// @ts-ignore
				callbacks.resolve(data.value);
			} else if (data.responseStatus === "error") {
				try {
					callbacks.reject(this.bridge.hydrateError(data));
				} catch (err) {
					callbacks.reject(err);
				}
			} else {
				// ???
			}

			if (callbacks.completed !== undefined) {
				callbacks.completed();
			}
		}

		hasSubscribers() {
			return this.bridge.listeners.has(this.name);
		}

		validateCanSend() {
			___R$$priv$project$rome$$internal$events$BridgeEvent_ts$validateDirection(
				this,
				[["server<-client", "client"], ["server->client", "server"]],
				"called",
			);
		}

		send(param) {
			if (!this.hasSubscribers()) {
				// No point in sending over a subscription that doesn't have a listener
				return;
			}

			this.validateCanSend();
			this.bridge.assertAlive();
			this.bridge.sendMessage({
				type: "request",
				event: this.name,
				param,
				priority: false,
			});
		}

		async call(param, opts = {}) {
			const {priority = false, timeout} = opts;
			this.validateCanSend();

			return new Promise((resolve, reject) => {
				this.bridge.assertAlive();

				const id = this.bridge.getNextMessageId();

				let completed;
				if (timeout !== undefined) {
					const timeoutId = setTimeout(
						() => {
							// Remove the request callback
							this.requestCallbacks.delete(id);

							// Reject the promise
							reject(
								new ___R$project$rome$$internal$events$BridgeError_ts$default(
									"Timeout of " +
									String(timeout) +
									"ms for " +
									this.name +
									"(" +
									String(JSON.stringify(param)) +
									") event exceeded",
									this.bridge,
								),
							);
						},
						timeout,
					);

					// Cancel the timeout if the response returns before the timer
					completed = () => {
						clearTimeout(timeoutId);
					};
				}

				this.requestCallbacks.set(
					id,
					{
						param,
						completed,
						reject,
						resolve,
					},
				);

				this.bridge.sendMessage({
					id,
					event: this.name,
					param,
					type: "request",
					priority,
				});
			});
		}

		callOptional() {
			throw new Error("callOptional not allowed on BridgeEvent " + this.name);
		}
	}


  // project-rome/@internal/codec-binary-serial/types.ts



  // project-rome/@internal/codec-binary-serial/codes.ts
function ___R$project$rome$$internal$codec$binary$serial$codes_ts$formatCode(
		code,
	) {
		if (
			___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES[code] ===
			undefined
		) {
			return "?(" + code + ")";
		} else {
			return (
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES[code] +
				"(" +
				code +
				")"
			);
		}
	}
	const ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES = function() {
		const VALUE_CODES = {};
		VALUE_CODES[VALUE_CODES["STRING"] = 0] = "STRING";
		VALUE_CODES[VALUE_CODES["ARRAY"] = 1] = "ARRAY";
		VALUE_CODES[VALUE_CODES["SET"] = 2] = "SET";
		VALUE_CODES[VALUE_CODES["MAP"] = 3] = "MAP";
		VALUE_CODES[VALUE_CODES["OBJECT"] = 4] = "OBJECT";
		VALUE_CODES[VALUE_CODES["SYMBOL"] = 5] = "SYMBOL";
		VALUE_CODES[VALUE_CODES["DATE"] = 6] = "DATE";
		VALUE_CODES[VALUE_CODES["TRUE"] = 7] = "TRUE";
		VALUE_CODES[VALUE_CODES["FALSE"] = 8] = "FALSE";
		VALUE_CODES[VALUE_CODES["NULL"] = 9] = "NULL";
		VALUE_CODES[VALUE_CODES["UNDEFINED"] = 10] = "UNDEFINED";
		VALUE_CODES[VALUE_CODES["INT8"] = 11] = "INT8";
		VALUE_CODES[VALUE_CODES["INT16"] = 12] = "INT16";
		VALUE_CODES[VALUE_CODES["INT32"] = 13] = "INT32";
		VALUE_CODES[VALUE_CODES["INT64"] = 14] = "INT64";
		VALUE_CODES[VALUE_CODES["FLOAT"] = 15] = "FLOAT";
		VALUE_CODES[VALUE_CODES["NAN"] = 16] = "NAN";
		VALUE_CODES[VALUE_CODES["POSITIVE_INFINITY"] = 17] = "POSITIVE_INFINITY";
		VALUE_CODES[VALUE_CODES["NEGATIVE_INFINITY"] = 18] = "NEGATIVE_INFINITY";
		VALUE_CODES[VALUE_CODES["NEGATIVE_ZERO"] = 19] = "NEGATIVE_ZERO";
		VALUE_CODES[VALUE_CODES["FILE_PATH"] = 20] = "FILE_PATH";
		VALUE_CODES[VALUE_CODES["FILE_PATH_SET"] = 21] = "FILE_PATH_SET";
		VALUE_CODES[VALUE_CODES["FILE_PATH_MAP"] = 22] = "FILE_PATH_MAP";
		VALUE_CODES[VALUE_CODES["ERROR"] = 23] = "ERROR";
		VALUE_CODES[VALUE_CODES["REGEXP"] = 24] = "REGEXP";
		VALUE_CODES[VALUE_CODES["TEMPLATED_OBJECT_ARRAY"] = 25] = "TEMPLATED_OBJECT_ARRAY";
		VALUE_CODES[VALUE_CODES["REFERENCE"] = 26] = "REFERENCE";
		VALUE_CODES[VALUE_CODES["DECLARE_REFERENCE"] = 27] = "DECLARE_REFERENCE";
		VALUE_CODES[VALUE_CODES["ARRAY_BUFFER"] = 28] = "ARRAY_BUFFER";
		VALUE_CODES[VALUE_CODES["ARRAY_BUFFER_VIEW"] = 29] = "ARRAY_BUFFER_VIEW";
		return VALUE_CODES;
	}()
	function ___R$project$rome$$internal$codec$binary$serial$codes_ts$validateValueCode(
		code,
	) {
		switch (code) {
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.STRING:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.ARRAY:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.SET:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.MAP:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.OBJECT:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.SYMBOL:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.DATE:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.TRUE:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.FALSE:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.NULL:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.UNDEFINED:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.INT8:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.INT16:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.INT32:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.INT64:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.FLOAT:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.NAN:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.POSITIVE_INFINITY:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.NEGATIVE_INFINITY:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.NEGATIVE_ZERO:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.FILE_PATH:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.FILE_PATH_SET:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.FILE_PATH_MAP:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.ERROR:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.REGEXP:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.TEMPLATED_OBJECT_ARRAY:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.DECLARE_REFERENCE:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.REFERENCE:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.ARRAY_BUFFER_VIEW:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.ARRAY_BUFFER:
				return code;

			default:
				throw new Error("Invalid value code " + code);
		}
	}
	const ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES = function() {
		const ARRAY_BUFFER_VIEW_CODES = {};
		ARRAY_BUFFER_VIEW_CODES[ARRAY_BUFFER_VIEW_CODES["DATA_VIEW"] = 0] = "DATA_VIEW";
		ARRAY_BUFFER_VIEW_CODES[ARRAY_BUFFER_VIEW_CODES["INT_8"] = 1] = "INT_8";
		ARRAY_BUFFER_VIEW_CODES[ARRAY_BUFFER_VIEW_CODES["UINT_8"] = 2] = "UINT_8";
		ARRAY_BUFFER_VIEW_CODES[ARRAY_BUFFER_VIEW_CODES["UINT_8_CLAMPED"] = 3] = "UINT_8_CLAMPED";
		ARRAY_BUFFER_VIEW_CODES[ARRAY_BUFFER_VIEW_CODES["INT_16"] = 4] = "INT_16";
		ARRAY_BUFFER_VIEW_CODES[ARRAY_BUFFER_VIEW_CODES["UINT_16"] = 5] = "UINT_16";
		ARRAY_BUFFER_VIEW_CODES[ARRAY_BUFFER_VIEW_CODES["INT_32"] = 6] = "INT_32";
		ARRAY_BUFFER_VIEW_CODES[ARRAY_BUFFER_VIEW_CODES["UINT_32"] = 7] = "UINT_32";
		ARRAY_BUFFER_VIEW_CODES[ARRAY_BUFFER_VIEW_CODES["FLOAT_32"] = 8] = "FLOAT_32";
		ARRAY_BUFFER_VIEW_CODES[ARRAY_BUFFER_VIEW_CODES["FLOAT_64"] = 9] = "FLOAT_64";
		ARRAY_BUFFER_VIEW_CODES[ARRAY_BUFFER_VIEW_CODES["BIG_INT_64"] = 10] = "BIG_INT_64";
		ARRAY_BUFFER_VIEW_CODES[ARRAY_BUFFER_VIEW_CODES["BIG_UINT_64"] = 11] = "BIG_UINT_64";
		return ARRAY_BUFFER_VIEW_CODES;
	}()
	function ___R$project$rome$$internal$codec$binary$serial$codes_ts$validateArrayBufferViewCode(
		code,
	) {
		switch (code) {
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.DATA_VIEW:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.INT_8:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.UINT_8:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.UINT_8_CLAMPED:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.INT_16:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.UINT_16:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.INT_32:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.UINT_32:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.FLOAT_32:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.FLOAT_64:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.BIG_INT_64:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.BIG_UINT_64:
				return code;

			default:
				throw new Error("Invalid typed array code " + code);
		}
	}

	function ___R$project$rome$$internal$codec$binary$serial$codes_ts$instanceToArrayBufferViewCode(
		val,
	) {
		if (val instanceof Int8Array) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.INT_8;
		} else if (val instanceof Uint8Array) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.UINT_8;
		} else if (val instanceof Uint8ClampedArray) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.UINT_8_CLAMPED;
		} else if (val instanceof Int16Array) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.INT_16;
		} else if (val instanceof Uint16Array) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.UINT_16;
		} else if (val instanceof Int32Array) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.INT_32;
		} else if (val instanceof Uint32Array) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.UINT_32;
		} else if (val instanceof Float32Array) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.FLOAT_32;
		} else if (val instanceof Float64Array) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.FLOAT_64;
		} else if (val instanceof BigInt64Array) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.BIG_INT_64;
		} else if (val instanceof BigUint64Array) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.BIG_UINT_64;
		} else if (val instanceof DataView) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.DATA_VIEW;
		} else {
			throw new Error("Unknown typed array instance");
		}
	}
	function ___R$project$rome$$internal$codec$binary$serial$codes_ts$arrayBufferViewCodeToInstance(
		code,
		buffer,
		offset,
		length,
	) {
		switch (code) {
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.INT_8:
				return new Int8Array(buffer, offset, length);

			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.UINT_8:
				return new Uint8Array(buffer, offset, length);

			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.UINT_8_CLAMPED:
				return new Uint8ClampedArray(buffer, offset, length);

			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.INT_16:
				return new Int16Array(buffer, offset, length);

			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.UINT_16:
				return new Uint16Array(buffer, offset, length);

			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.INT_32:
				return new Int32Array(buffer, offset, length);

			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.UINT_32:
				return new Uint32Array(buffer, offset, length);

			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.FLOAT_32:
				return new Float32Array(buffer, offset, length);

			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.FLOAT_64:
				return new Float64Array(buffer, offset, length);

			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.BIG_INT_64:
				return new BigInt64Array(buffer, offset, length);

			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.BIG_UINT_64:
				return new BigUint64Array(buffer, offset, length);

			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ARRAY_BUFFER_VIEW_CODES.DATA_VIEW:
				return new DataView(buffer, offset, length);
		}
	}
	const ___R$project$rome$$internal$codec$binary$serial$codes_ts$ERROR_CODES = function() {
		const ERROR_CODES = {};
		ERROR_CODES[ERROR_CODES["REGULAR"] = 0] = "REGULAR";
		ERROR_CODES[ERROR_CODES["EVAL"] = 1] = "EVAL";
		ERROR_CODES[ERROR_CODES["RANGE"] = 2] = "RANGE";
		ERROR_CODES[ERROR_CODES["REFERENCE"] = 3] = "REFERENCE";
		ERROR_CODES[ERROR_CODES["SYNTAX"] = 4] = "SYNTAX";
		ERROR_CODES[ERROR_CODES["TYPE"] = 5] = "TYPE";
		ERROR_CODES[ERROR_CODES["URI"] = 6] = "URI";
		return ERROR_CODES;
	}()
	function ___R$project$rome$$internal$codec$binary$serial$codes_ts$validateErrorCode(
		code,
	) {
		switch (code) {
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ERROR_CODES.REGULAR:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ERROR_CODES.EVAL:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ERROR_CODES.RANGE:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ERROR_CODES.REFERENCE:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ERROR_CODES.SYNTAX:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ERROR_CODES.TYPE:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ERROR_CODES.URI:
				return code;

			default:
				throw new Error("Invalid error code " + code);
		}
	}

	function ___R$project$rome$$internal$codec$binary$serial$codes_ts$instanceToErrorCode(
		err,
	) {
		if (err instanceof EvalError) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$ERROR_CODES.EVAL;
		} else if (err instanceof ReferenceError) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$ERROR_CODES.REFERENCE;
		} else if (err instanceof SyntaxError) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$ERROR_CODES.SYNTAX;
		} else if (err instanceof TypeError) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$ERROR_CODES.TYPE;
		} else if (err instanceof URIError) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$ERROR_CODES.URI;
		} else if (err instanceof RangeError) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$ERROR_CODES.RANGE;
		} else {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$ERROR_CODES.REGULAR;
		}
	}

	function ___R$project$rome$$internal$codec$binary$serial$codes_ts$errorCodeToInstance(
		code,
	) {
		switch (code) {
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ERROR_CODES.EVAL:
				return new EvalError();

			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ERROR_CODES.RANGE:
				return new RangeError();

			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ERROR_CODES.REFERENCE:
				return new ReferenceError();

			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ERROR_CODES.SYNTAX:
				return new SyntaxError();

			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ERROR_CODES.TYPE:
				return new TypeError();

			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ERROR_CODES.URI:
				return new URIError();

			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$ERROR_CODES.REGULAR:
				return new Error();

			default:
				throw new Error("Invalid error code " + code);
		}
	}
	const ___R$project$rome$$internal$codec$binary$serial$codes_ts$FILE_CODES = function() {
		const FILE_CODES = {};
		FILE_CODES[FILE_CODES["UNKNOWN"] = 0] = "UNKNOWN";
		FILE_CODES[FILE_CODES["ABSOLUTE"] = 1] = "ABSOLUTE";
		FILE_CODES[FILE_CODES["RELATIVE"] = 2] = "RELATIVE";
		FILE_CODES[FILE_CODES["URL"] = 3] = "URL";
		return FILE_CODES;
	}()
	function ___R$project$rome$$internal$codec$binary$serial$codes_ts$validateFileCode(
		code,
	) {
		switch (code) {
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$FILE_CODES.UNKNOWN:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$FILE_CODES.ABSOLUTE:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$FILE_CODES.RELATIVE:
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$FILE_CODES.URL:
				return code;

			default:
				throw new Error("Unknown file code " + code);
		}
	}

	function ___R$project$rome$$internal$codec$binary$serial$codes_ts$filePathMapToCode(
		map,
	) {
		if (
			map instanceof
			___R$project$rome$$internal$path$collections_ts$RelativeFilePathMap
		) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$FILE_CODES.RELATIVE;
		} else if (
			map instanceof
			___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap
		) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$FILE_CODES.ABSOLUTE;
		} else if (
			map instanceof
			___R$project$rome$$internal$path$collections_ts$UnknownPathMap
		) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$FILE_CODES.UNKNOWN;
		} else {
			throw new Error("Unknown FilePath type");
		}
	}

	function ___R$project$rome$$internal$codec$binary$serial$codes_ts$filePathSetToCode(
		set,
	) {
		if (
			set instanceof
			___R$project$rome$$internal$path$collections_ts$RelativeFilePathSet
		) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$FILE_CODES.RELATIVE;
		} else if (
			set instanceof
			___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet
		) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$FILE_CODES.ABSOLUTE;
		} else if (
			set instanceof
			___R$project$rome$$internal$path$collections_ts$UnknownPathSet
		) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$FILE_CODES.UNKNOWN;
		} else {
			throw new Error("Unknown FilePath type");
		}
	}

	function ___R$project$rome$$internal$codec$binary$serial$codes_ts$filePathToCode(
		path,
	) {
		if (
			path instanceof
			___R$project$rome$$internal$path$index_ts$RelativeFilePath
		) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$FILE_CODES.RELATIVE;
		} else if (
			path instanceof
			___R$project$rome$$internal$path$index_ts$AbsoluteFilePath
		) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$FILE_CODES.ABSOLUTE;
		} else if (
			path instanceof
			___R$project$rome$$internal$path$index_ts$UnknownPath
		) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$FILE_CODES.UNKNOWN;
		} else if (path instanceof ___R$project$rome$$internal$path$index_ts$URLPath) {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$FILE_CODES.URL;
		} else {
			throw new Error("Unknown FilePath type");
		}
	}

	function ___R$project$rome$$internal$codec$binary$serial$codes_ts$filePathFromCode(
		code,
		filename,
	) {
		switch (code) {
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$FILE_CODES.RELATIVE:
				return ___R$project$rome$$internal$path$index_ts$createRelativeFilePath(
					filename,
				);

			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$FILE_CODES.ABSOLUTE:
				return ___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
					filename,
				);

			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$FILE_CODES.URL:
				return ___R$project$rome$$internal$path$index_ts$createURLPath(filename);

			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$FILE_CODES.UNKNOWN:
				return ___R$project$rome$$internal$path$index_ts$createUnknownPath(
					filename,
				);
		}
	}

	function ___R$project$rome$$internal$codec$binary$serial$codes_ts$filePathMapFromCode(
		code,
	) {
		switch (code) {
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$FILE_CODES.UNKNOWN:
				return new ___R$project$rome$$internal$path$collections_ts$UnknownPathMap();

			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$FILE_CODES.RELATIVE:
				return new ___R$project$rome$$internal$path$collections_ts$RelativeFilePathMap();

			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$FILE_CODES.ABSOLUTE:
				return new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();

			default:
				throw new Error("File path code " + code + " cannot be a map");
		}
	}

	function ___R$project$rome$$internal$codec$binary$serial$codes_ts$filePathSetFromCode(
		code,
	) {
		switch (code) {
			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$FILE_CODES.UNKNOWN:
				return new ___R$project$rome$$internal$path$collections_ts$UnknownPathSet();

			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$FILE_CODES.RELATIVE:
				return new ___R$project$rome$$internal$path$collections_ts$RelativeFilePathSet();

			case ___R$project$rome$$internal$codec$binary$serial$codes_ts$FILE_CODES.ABSOLUTE:
				return new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet();

			default:
				throw new Error("File path code " + code + " cannot be a map");
		}
	}


  // project-rome/@internal/codec-binary-serial/utf8.ts
/**
 * Code in this file taken from https://github.com/msgpack/msgpack-javascript and licensed under:
 *
 * Copyright 2019 The MessagePack Community.
 *
 * Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby
 * granted, provided that the above copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

	const ___R$$priv$project$rome$$internal$codec$binary$serial$utf8_ts$sharedTextEncoder = new TextEncoder();
	const ___R$$priv$project$rome$$internal$codec$binary$serial$utf8_ts$sharedTextDecoder = new TextDecoder();

	const ___R$project$rome$$internal$codec$binary$serial$utf8_ts$TEXT_ENCODER_THRESHOLD = 200;
	const ___R$project$rome$$internal$codec$binary$serial$utf8_ts$TEXT_DECODER_THRESHOLD = 200;

	const ___R$$priv$project$rome$$internal$codec$binary$serial$utf8_ts$CHUNK_SIZE = 0x1000;

	function ___R$project$rome$$internal$codec$binary$serial$utf8_ts$utf8Count(
		str,
	) {
		const strLength = str.length;

		let byteLength = 0;
		let pos = 0;
		while (pos < strLength) {
			let value = str.charCodeAt(pos++);

			if ((value & 0xffffff80) === 0) {
				// 1-byte
				byteLength++;
				continue;
			} else if ((value & 0xfffff800) === 0) {
				// 2-bytes
				byteLength += 2;
			} else {
				// handle surrogate pair
				if (value >= 0xd800 && value <= 0xdbff) {
					// high surrogate
					if (pos < strLength) {
						const extra = str.charCodeAt(pos);
						if ((extra & 0xfc00) === 0xdc00) {
							++pos;
							value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;
						}
					}
				}

				if ((value & 0xffff0000) === 0) {
					// 3-byte
					byteLength += 3;
				} else {
					// 4-byte
					byteLength += 4;
				}
			}
		}
		return byteLength;
	}

	function ___R$project$rome$$internal$codec$binary$serial$utf8_ts$utf8Encode(
		str,
		output,
		outputOffset,
		byteLength,
	) {
		if (
			byteLength >
			___R$project$rome$$internal$codec$binary$serial$utf8_ts$TEXT_ENCODER_THRESHOLD
		) {
			if (
				___R$$priv$project$rome$$internal$codec$binary$serial$utf8_ts$sharedTextEncoder.encodeInto ===
				undefined
			) {
				output.set(
					___R$$priv$project$rome$$internal$codec$binary$serial$utf8_ts$sharedTextEncoder.encode(
						str,
					),
					outputOffset,
				);
			} else {
				___R$$priv$project$rome$$internal$codec$binary$serial$utf8_ts$sharedTextEncoder.encodeInto(
					str,
					output.subarray(outputOffset),
				);
			}
			return;
		}

		const strLength = str.length;
		let offset = outputOffset;
		let pos = 0;
		while (pos < strLength) {
			let value = str.charCodeAt(pos++);

			if ((value & 0xffffff80) === 0) {
				// 1-byte
				output[offset++] = value;
				continue;
			} else if ((value & 0xfffff800) === 0) {
				// 2-bytes
				output[offset++] = value >> 6 & 0x1f | 0xc0;
			} else {
				// handle surrogate pair
				if (value >= 0xd800 && value <= 0xdbff) {
					// high surrogate
					if (pos < strLength) {
						const extra = str.charCodeAt(pos);
						if ((extra & 0xfc00) === 0xdc00) {
							++pos;
							value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;
						}
					}
				}

				if ((value & 0xffff0000) === 0) {
					// 3-byte
					output[offset++] = value >> 12 & 0xf | 0xe0;
					output[offset++] = value >> 6 & 0x3f | 0x80;
				} else {
					// 4-byte
					output[offset++] = value >> 18 & 0x7 | 0xf0;
					output[offset++] = value >> 12 & 0x3f | 0x80;
					output[offset++] = value >> 6 & 0x3f | 0x80;
				}
			}

			output[offset++] = value & 0x3f | 0x80;
		}
	}

	function ___R$project$rome$$internal$codec$binary$serial$utf8_ts$utf8Decode(
		bytes,
		inputOffset,
		byteLength,
	) {
		if (
			byteLength >
			___R$project$rome$$internal$codec$binary$serial$utf8_ts$TEXT_DECODER_THRESHOLD
		) {
			const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);
			return ___R$$priv$project$rome$$internal$codec$binary$serial$utf8_ts$sharedTextDecoder.decode(
				stringBytes,
			);
		}

		let offset = inputOffset;
		const end = offset + byteLength;

		const units = [];
		let result = "";
		while (offset < end) {
			const byte1 = bytes[offset++];
			if ((byte1 & 0x80) === 0) {
				// 1 byte
				units.push(byte1);
			} else if ((byte1 & 0xe0) === 0xc0) {
				// 2 bytes
				const byte2 = bytes[offset++] & 0x3f;
				units.push((byte1 & 0x1f) << 6 | byte2);
			} else if ((byte1 & 0xf0) === 0xe0) {
				// 3 bytes
				const byte2 = bytes[offset++] & 0x3f;
				const byte3 = bytes[offset++] & 0x3f;
				units.push((byte1 & 0x1f) << 12 | byte2 << 6 | byte3);
			} else if ((byte1 & 0xf8) === 0xf0) {
				// 4 bytes
				const byte2 = bytes[offset++] & 0x3f;
				const byte3 = bytes[offset++] & 0x3f;
				const byte4 = bytes[offset++] & 0x3f;
				let unit = (byte1 & 0x7) << 0x12 | byte2 << 0xc | byte3 << 0x6 | byte4;
				if (unit > 0xffff) {
					unit -= 0x10000;
					units.push(unit >>> 10 & 0x3ff | 0xd800);
					unit = 0xdc00 | unit & 0x3ff;
				}
				units.push(unit);
			} else {
				units.push(byte1);
			}

			if (
				units.length >=
				___R$$priv$project$rome$$internal$codec$binary$serial$utf8_ts$CHUNK_SIZE
			) {
				var ___R$;
				result += (___R$ = String, ___R$.fromCharCode.apply(___R$, [...units]));
				units.length = 0;
			}
		}

		if (units.length > 0) {
			var ___R$1;
			result += (___R$1 = String, ___R$1.fromCharCode.apply(___R$1, [...units]));
		}

		return result;
	}


  // project-rome/@internal/codec-binary-serial/RSERBufferAssembler.ts
const ___R$$priv$project$rome$$internal$codec$binary$serial$RSERBufferAssembler_ts$MAX_INT8 = 127;
	const ___R$$priv$project$rome$$internal$codec$binary$serial$RSERBufferAssembler_ts$MAX_INT16 = 32_767;
	const ___R$$priv$project$rome$$internal$codec$binary$serial$RSERBufferAssembler_ts$MAX_INT32 = 2_147_483_647;

	class ___R$project$rome$$internal$codec$binary$serial$RSERBufferAssembler_ts$default {
		constructor() {
			this.totalSize = 0;
			this.seenObjects = new Set();
			this.references = new Map();
		}

		writeCode(code) {
			this.totalSize += 1;
			code;
		}

		writeByte(value) {
			this.totalSize += 1;
			value;
		}

		writeInt(value, size) {
			this.totalSize += size;
		}

		// When we are writing the buffer, we will insert a header before all values that will be referenced
		// We need to account for that here since we do it after the fact
		onReferenceCreate(id) {
			this.encodeDeclareReferenceHead(id);
		}

		writeFloat(value) {
			value;
			this.totalSize += 8;
		}

		appendString(buf, size) {
			this.totalSize += size;
		}

		appendBytes(buf) {
			this.totalSize += buf.byteLength;
		}

		encodeHeader(size) {
			this.writeByte(0);
			this.writeByte(1);
			this.encodeInt(size);
		}

		encodeBigInt(val) {
			this.writeCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.INT64,
			);
			this.writeInt(val, 8);
		}

		encodeInt(val) {
			if (typeof val === "bigint") {
				return this.encodeBigInt(val);
			}

			const abs = Math.abs(val);
			if (
				abs <=
				___R$$priv$project$rome$$internal$codec$binary$serial$RSERBufferAssembler_ts$MAX_INT8
			) {
				this.writeCode(
					___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.INT8,
				);
				this.writeInt(val, 1);
			} else if (
				abs <=
				___R$$priv$project$rome$$internal$codec$binary$serial$RSERBufferAssembler_ts$MAX_INT16
			) {
				this.writeCode(
					___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.INT16,
				);
				this.writeInt(val, 2);
			} else if (
				abs <=
				___R$$priv$project$rome$$internal$codec$binary$serial$RSERBufferAssembler_ts$MAX_INT32
			) {
				this.writeCode(
					___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.INT32,
				);
				this.writeInt(val, 4);
			} else {
				this.encodeFloat(val);
			}
		}

		encodeTemplatedObjectArray(arr) {
			// More compact form
			if (arr.length === 0) {
				this.writeCode(
					___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.ARRAY,
				);
				this.encodeInt(0);
				return;
			}

			this.writeCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.TEMPLATED_OBJECT_ARRAY,
			);
			this.encodeInt(arr.length);

			// Encode keys
			const keys = Object.keys(arr[0]);
			this.encodeInt(keys.length);
			for (const key of keys) {
				this.encodeStringValue(key);
			}

			// Encode entries
			for (const obj of arr) {
				for (const key of keys) {
					const val = obj[key];
					this.encodeValue(val);
				}
			}
		}

		encodeArray(val) {
			this.writeCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.ARRAY,
			);
			this.encodeInt(val.length);
			for (let i = 0; i < val.length; ++i) {
				this.encodeValue(val[i]);
			}
		}

		encodeSet(set) {
			this.writeCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.SET,
			);
			this.encodeInt(set.size);
			for (const elem of set) {
				this.encodeValue(elem);
			}
		}

		encodeMap(map) {
			this.writeCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.MAP,
			);
			this.encodeInt(map.size);
			for (const [key, value] of map) {
				this.encodeValue(key);
				this.encodeValue(value);
			}
		}

		encodeFilePathMap(map) {
			this.writeCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.FILE_PATH_MAP,
			);
			this.writeByte(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$filePathMapToCode(
					map,
				),
			);
			this.encodeInt(map.size);
			for (const [path, value] of map) {
				this.encodeStringValue(path.join());
				this.encodeValue(value);
			}
		}

		encodeFilePathSet(set) {
			this.writeCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.FILE_PATH_SET,
			);
			this.writeByte(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$filePathSetToCode(
					set,
				),
			);
			this.encodeInt(set.size);
			for (const path of set) {
				this.encodeStringValue(path.join());
			}
		}

		encodeFilePath(path) {
			this.writeCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.FILE_PATH,
			);
			this.writeByte(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$filePathToCode(
					path,
				),
			);
			this.encodeStringValue(path.join());
		}

		encodeDate(val) {
			this.writeCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.DATE,
			);
			this.encodeInt(val.valueOf());
		}

		encodeError(val) {
			this.writeCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.ERROR,
			);
			this.writeCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$instanceToErrorCode(
					val,
				),
			);

			const struct = ___R$project$rome$$internal$v8$errors_ts$getErrorStructure(
				val,
				0,
				false,
			);
			this.encodeStringValue(struct.message == null ? "" : struct.message);
			this.encodeValue(struct.stack);
			this.encodePlainObject(struct.node);
			this.encodeTemplatedObjectArray(struct.frames);
		}

		encodeNull() {
			this.writeCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.NULL,
			);
		}

		encodeRegExp(regex) {
			this.writeCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.REGEXP,
			);
			this.encodeStringValue(regex.source);
			this.encodeStringValue(regex.flags);
		}

		encodeReference(id) {
			this.writeCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.REFERENCE,
			);
			this.encodeInt(id);
		}

		encodeDeclareReferenceHead(id) {
			this.writeCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.DECLARE_REFERENCE,
			);
			this.encodeInt(id);
		}

		encodeArrayBuffer(val) {
			this.writeCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.ARRAY_BUFFER,
			);
			this.encodeInt(val.byteLength);
			this.appendBytes(new Uint8Array(val));
		}

		encodeArrayBufferView(val) {
			this.writeCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.ARRAY_BUFFER_VIEW,
			);
			this.writeByte(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$instanceToArrayBufferViewCode(
					val,
				),
			);
			this.encodeInt(val.byteLength);
			this.encodeInt(val.byteOffset);
			this.encodeArrayBuffer(val.buffer);
		}

		encodeObject(val) {
			// Already a declared reference
			const refId = this.references.get(val);
			if (refId !== undefined) {
				if (this.seenObjects.has(val)) {
					this.encodeReference(refId);
					return;
				} else {
					this.encodeDeclareReferenceHead(refId);
				}
			}

			// Is this the second time we've seen this object?
			if (this.seenObjects.has(val)) {
				const id = this.references.size;
				this.references.set(val, id);
				this.onReferenceCreate(id);
				this.encodeReference(id);
				return;
			}

			this.seenObjects.add(val);

			if (val instanceof ArrayBuffer) {
				return this.encodeArrayBuffer(val);
			}

			if (ArrayBuffer.isView(val)) {
				return this.encodeArrayBufferView(val);
			}

			if (
				val instanceof ___R$project$rome$$internal$path$index_ts$UnknownPath ||
				val instanceof
				___R$project$rome$$internal$path$index_ts$RelativeFilePath ||
				val instanceof
				___R$project$rome$$internal$path$index_ts$AbsoluteFilePath ||
				val instanceof ___R$project$rome$$internal$path$index_ts$URLPath
			) {
				return this.encodeFilePath(val);
			}

			if (val instanceof Set) {
				return this.encodeSet(val);
			}

			if (val instanceof Map) {
				return this.encodeMap(val);
			}

			if (val instanceof Error) {
				return this.encodeError(val);
			}

			if (val instanceof RegExp) {
				return this.encodeRegExp(val);
			}

			if (
				val instanceof
				___R$project$rome$$internal$path$collections_ts$RelativeFilePathMap ||
				val instanceof
				___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap ||
				val instanceof
				___R$project$rome$$internal$path$collections_ts$UnknownPathMap
			) {
				return this.encodeFilePathMap(val);
			}

			if (
				val instanceof
				___R$project$rome$$internal$path$collections_ts$RelativeFilePathSet ||
				val instanceof
				___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet ||
				val instanceof
				___R$project$rome$$internal$path$collections_ts$UnknownPathSet
			) {
				return this.encodeFilePathSet(val);
			}

			if (Array.isArray(val)) {
				return this.encodeArray(val);
			}

			if (val instanceof Date) {
				return this.encodeDate(val);
			}

			if (
				___R$project$rome$$internal$typescript$helpers$index_ts$isPlainObject(
					val,
				)
			) {
				this.encodePlainObject(val);
			} else {
				throw new Error(
					___R$project$rome$$internal$pretty$format$index_ts$pretty`Don't know how to serialize the object ${val} to RSER`,
				);
			}
		}

		encodePlainObject(val) {
			this.writeCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.OBJECT,
			);

			const keys = Object.keys(val);

			// First pass to compute number of defined keys
			let numKeys = keys.length;
			for (let i = 0; i < keys.length; ++i) {
				const key = keys[i];
				const v = val[key];
				if (typeof v === "undefined") {
					numKeys--;
				}
			}

			this.encodeInt(numKeys);

			for (let i = 0; i < keys.length; ++i) {
				const key = keys[i];
				const v = val[key];
				if (typeof v === "undefined") {
					// Don't include it
					continue;
				}

				this.encodeStringValue(key);
				this.encodeValue(v);
			}
		}

		encodeUndefined() {
			this.writeCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.UNDEFINED,
			);
		}

		encodeStringValue(val) {
			const byteLength = ___R$project$rome$$internal$codec$binary$serial$utf8_ts$utf8Count(
				val,
			);
			this.encodeInt(byteLength);
			this.appendString(val, byteLength);
		}

		encodeNumber(val) {
			if (typeof val === "bigint" || Number.isSafeInteger(val)) {
				this.encodeInt(val);
			} else {
				this.encodeFloat(val);
			}
		}

		encodeFloat(val) {
			this.writeCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.FLOAT,
			);
			this.writeFloat(val);
		}

		encodeValue(val) {
			switch (typeof val) {
				case "bigint":
				case "number": {
					// NaN
					if (typeof val === "number" && isNaN(val)) {
						this.writeCode(
							___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.NAN,
						);
						return;
					}

					// -0
					if (Object.is(val, -0)) {
						this.writeCode(
							___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.NEGATIVE_ZERO,
						);
						return;
					}

					// +Infinity
					if (val === Number.POSITIVE_INFINITY) {
						this.writeCode(
							___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.POSITIVE_INFINITY,
						);
						return;
					}

					// -Infinity
					if (val === Number.NEGATIVE_INFINITY) {
						this.writeCode(
							___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.NEGATIVE_INFINITY,
						);
						return;
					}

					this.encodeNumber(val);
					return;
				}

				case "undefined": {
					return this.encodeUndefined();
				}

				case "string": {
					this.writeCode(
						___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.STRING,
					);
					this.encodeStringValue(val);
					return;
				}

				case "boolean": {
					this.writeByte(
						val
							? ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.TRUE
							: ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.FALSE,
					);
					return;
				}

				case "symbol": {
					this.writeCode(
						___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.SYMBOL,
					);
					const key = Symbol.keyFor(val);
					if (key === undefined) {
						throw new Error("Not a global symbol");
					}
					this.encodeStringValue(key);
					return;
				}

				case "object": {
					if (val === null) {
						return this.encodeNull();
					}

					return this.encodeObject(val);
				}
			}

			throw new Error(
				___R$project$rome$$internal$pretty$format$index_ts$pretty`Don't know how to serialize the value ${val} to RSER`,
			);
		}
	}


  // project-rome/@internal/codec-binary-serial/RSERBufferWriter.ts
class ___R$project$rome$$internal$codec$binary$serial$RSERBufferWriter_ts$default
		extends ___R$project$rome$$internal$codec$binary$serial$RSERBufferAssembler_ts$default {
		constructor(buffer, assembler) {
			super();
			this.references = assembler.references;
			this.totalSize = buffer.byteLength;
			this.writeOffset = 0;
			this.buffer = buffer;
			this.bytes = new Uint8Array(buffer);
			this.view = new DataView(buffer);
		}

		static allocate(size) {
			return new ___R$project$rome$$internal$codec$binary$serial$RSERBufferWriter_ts$default(
				new ArrayBuffer(size),
				new ___R$project$rome$$internal$codec$binary$serial$RSERBufferAssembler_ts$default(),
			);
		}

		onReferenceCreate() {}

		getWritableSize() {
			return this.buffer.byteLength - this.writeOffset;
		}

		assertWritableSize(size) {
			const remaining = this.getWritableSize();

			if (remaining < size) {
				throw new Error(
					"Wanted to write " +
					size +
					" bytes but only have " +
					remaining +
					" remaining",
				);
			}
		}

		appendBytes(buf) {
			const size = buf.byteLength;
			this.assertWritableSize(size);
			this.bytes.set(buf, this.writeOffset);
			this.writeOffset += size;
		}

		appendString(text, size) {
			___R$project$rome$$internal$codec$binary$serial$utf8_ts$utf8Encode(
				text,
				this.bytes,
				this.writeOffset,
				size,
			);
			this.writeOffset += size;
		}

		writeCode(code) {
			this.writeByte(code);
		}

		writeByte(value) {
			this.assertWritableSize(1);
			this.view.setInt8(this.writeOffset, value);
			this.writeOffset++;
		}

		writeInt(value, size) {
			this.assertWritableSize(size);

			if (typeof value === "bigint") {
				if (size === 8) {
					this.view.setBigInt64(this.writeOffset, value);
					this.writeOffset += size;
					return;
				} else {
					throw new Error("Expected size 8 for bigint but got " + size);
				}
			}

			switch (size) {
				case 1: {
					this.view.setInt8(this.writeOffset, value);
					break;
				}

				case 2: {
					this.view.setInt16(this.writeOffset, value);
					break;
				}

				case 4: {
					this.view.setInt32(this.writeOffset, value);
					break;
				}

				default:
					throw new Error("Unsupported integer size " + size);
			}

			this.writeOffset += size;
		}

		writeFloat(value) {
			this.assertWritableSize(8);
			this.view.setFloat64(this.writeOffset, value);
			this.writeOffset += 8;
		}
	}


  // project-rome/@internal/codec-binary-serial/CachedKeyDecoder.ts
const ___R$$priv$project$rome$$internal$codec$binary$serial$CachedKeyDecoder_ts$MAX_KEY_LENGTH = 16;
	const ___R$$priv$project$rome$$internal$codec$binary$serial$CachedKeyDecoder_ts$MAX_LENGTH_PER_KEY = 16;

	class ___R$project$rome$$internal$codec$binary$serial$CachedKeyDecoder_ts$CachedKeyDecoder {
		constructor() {
			// Avoid `new Array(N)` to create a non-sparse array for performance.
			this.caches = [];
			for (
				let i = 0;
				i <
				___R$$priv$project$rome$$internal$codec$binary$serial$CachedKeyDecoder_ts$MAX_KEY_LENGTH;
				i++
			) {
				this.caches.push([]);
			}
		}

		canBeCached(byteLength) {
			return (
				byteLength > 0 &&
				byteLength <=
				___R$$priv$project$rome$$internal$codec$binary$serial$CachedKeyDecoder_ts$MAX_KEY_LENGTH
			);
		}

		get(bytes, inputOffset, byteLength) {
			const records = this.caches[byteLength - 1];
			const recordsLength = records.length;

			FIND_CHUNK: for (let i = 0; i < recordsLength; i++) {
				const record = records[i];
				const recordBytes = record.bytes;

				for (let j = 0; j < byteLength; j++) {
					if (recordBytes[j] !== bytes[inputOffset + j]) {
						continue FIND_CHUNK;
					}
				}
				return record.value;
			}

			return undefined;
		}

		store(bytes, value) {
			const records = this.caches[bytes.length - 1];
			const record = {bytes, value};

			if (
				records.length >=
				___R$$priv$project$rome$$internal$codec$binary$serial$CachedKeyDecoder_ts$MAX_LENGTH_PER_KEY
			) {
				// `records` are full!
				// Set `record` to a randomized position.
				records[Math.random() * records.length | 0] = record;
			} else {
				records.push(record);
			}
		}

		decode(bytes, inputOffset, byteLength) {
			const cachedValue = this.get(bytes, inputOffset, byteLength);
			if (cachedValue !== undefined) {
				return cachedValue;
			}

			const value = ___R$project$rome$$internal$codec$binary$serial$utf8_ts$utf8Decode(
				bytes,
				inputOffset,
				byteLength,
			);
			const slicedCopyOfBytes = bytes.slice(
				inputOffset,
				inputOffset + byteLength,
			);
			this.store(slicedCopyOfBytes, value);
			return value;
		}
	}


  // project-rome/@internal/codec-binary-serial/RSERBufferParser.ts
const ___R$$priv$project$rome$$internal$codec$binary$serial$RSERBufferParser_ts$sharedCachedKeyDecoder = new ___R$project$rome$$internal$codec$binary$serial$CachedKeyDecoder_ts$CachedKeyDecoder();

	class ___R$project$rome$$internal$codec$binary$serial$RSERBufferParser_ts$default {
		constructor(view) {
			this.view = view;
			this.bytes = new Uint8Array(view.buffer, view.byteOffset, view.byteLength);
			this.readOffset = 0;
			this.references = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
				"references",
			);
		}

		getReadableSize() {
			return this.view.byteLength - this.readOffset;
		}

		canRead(size) {
			return this.getReadableSize() >= size;
		}

		assertReadableSize(size) {
			let remaining = this.getReadableSize();
			if (remaining < size) {
				throw new Error(
					"Expected at least " +
					size +
					" bytes to read but only have " +
					remaining,
				);
			}
		}

		peekString(size) {
			this.assertReadableSize(size);
			return ___R$project$rome$$internal$codec$binary$serial$utf8_ts$utf8Decode(
				this.bytes,
				this.readOffset,
				size,
			);
		}

		readStringSize(size) {
			const str = this.peekString(size);
			this.readOffset += size;
			return str;
		}

		readString() {
			const size = this.decodeNumber();
			return this.readStringSize(size);
		}

		peekInt(size, offset = 0) {
			this.assertReadableSize(size);

			switch (size) {
				case 1:
					return this.view.getInt8(this.readOffset + offset);

				case 2:
					return this.view.getInt16(this.readOffset + offset);

				case 4:
					return this.view.getInt32(this.readOffset + offset);

				case 8:
					return this.view.getBigInt64(this.readOffset + offset);

				default:
					throw new Error("Invalid integer size " + size);
			}
		}

		peekCode() {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$validateValueCode(
				this.peekInt(1),
			);
		}

		readInt(bytes) {
			const ival = this.peekInt(bytes);
			this.readOffset += bytes;
			return ival;
		}

		expectCode(expected) {
			const got = this.peekCode();
			if (got === expected) {
				this.readOffset++;
			} else {
				throw new Error(
					"Expected code " +
					___R$project$rome$$internal$codec$binary$serial$codes_ts$formatCode(
						expected,
					) +
					" but got " +
					___R$project$rome$$internal$codec$binary$serial$codes_ts$formatCode(
						got,
					),
				);
			}
		}

		decodeHeader() {
			this.expectCode(0);
			this.expectCode(1);

			if (this.canRead(1)) {
				const size = this.getDecodeIntSize();
				if (this.canRead(1 + size)) {
					return this.decodeNumber();
				}
			}

			return false;
		}

		decodeDeclareReference() {
			this.expectCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.DECLARE_REFERENCE,
			);
			const id = this.decodeNumber();
			const code = this.peekCode();

			switch (code) {
				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.FILE_PATH_MAP: {
					this.readOffset++;
					const code = this.decodeFilePathCode();
					const map = ___R$project$rome$$internal$codec$binary$serial$codes_ts$filePathMapFromCode(
						code,
					);
					this.references.set(id, map);
					return this.decodeFilePathMapValue(map);
				}

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.SET: {
					this.readOffset++;
					const set = new Set();
					this.references.set(id, set);
					return this.decodeSetValue(set);
				}

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.MAP: {
					this.readOffset++;
					const map = new Map();
					this.references.set(id, map);
					return this.decodeMapValue(map);
				}

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.ARRAY: {
					const arr = this.decodeArrayHead();
					this.references.set(id, arr);
					return this.decodeArrayElements(arr);
				}

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.TEMPLATED_OBJECT_ARRAY: {
					const arr = this.decodeTemplatedObjectArrayHead();
					this.references.set(id, arr);
					return this.decodeTemplateObjectArrayValues(arr);
				}

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.OBJECT: {
					this.readOffset++;
					const obj = {};
					this.references.set(id, obj);
					return this.decodeObjectValue(obj);
				}
			}

			// These can never refer to itself
			let val;
			if (
				code ===
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.REGEXP
			) {
				val = this.decodeRegExp();
			} else if (
				code ===
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.FILE_PATH
			) {
				val = this.decodeFilePath();
			} else if (
				code ===
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.DATE
			) {
				val = this.decodeDate();
			} else if (
				code ===
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.FILE_PATH_SET
			) {
				val = this.decodeFilePathSet();
			} else if (
				code ===
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.ERROR
			) {
				val = this.decodeError();
			} else if (
				code ===
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.ARRAY_BUFFER_VIEW
			) {
				val = this.decodeArrayBufferView();
			} else if (
				code ===
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.ARRAY_BUFFER
			) {
				val = this.decodeArrayBuffer();
			} else {
				throw new Error(
					"Don't know how to decode reference " +
					___R$project$rome$$internal$codec$binary$serial$codes_ts$formatCode(
						code,
					),
				);
			}
			this.references.set(id, val);
			return val;
		}

		decodeReference() {
			this.expectCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.REFERENCE,
			);
			const id = this.decodeNumber();
			return this.references.assert(id);
		}

		decodeValue() {
			const code = this.peekCode();

			switch (code) {
				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.INT8:
				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.INT16:
				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.INT32:
				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.INT64:
					return this.decodeInt();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.REFERENCE:
					return this.decodeReference();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.DECLARE_REFERENCE:
					return this.decodeDeclareReference();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.FLOAT:
					return this.decodeFloat();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.SYMBOL:
					return this.decodeSymbol();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.TRUE:
					return this.decodeTrue();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.FALSE:
					return this.decodeFalse();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.NULL:
					return this.decodeNull();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.UNDEFINED:
					return this.decodeUndefined();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.NAN:
					return this.decodeNaN();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.POSITIVE_INFINITY:
					return this.decodePositiveInfinity();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.NEGATIVE_INFINITY:
					return this.decodeNegativeInfinity();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.NEGATIVE_ZERO:
					return this.decodeNegativeZero();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.FILE_PATH:
					return this.decodeFilePath();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.FILE_PATH_MAP:
					return this.decodeFilePathMap();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.FILE_PATH_SET:
					return this.decodeFilePathSet();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.SET:
					return this.decodeSet();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.MAP:
					return this.decodeMap();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.ERROR:
					return this.decodeError();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.STRING:
					return this.decodeString();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.ARRAY:
					return this.decodeArray();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.OBJECT:
					return this.decodeObject();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.REGEXP:
					return this.decodeRegExp();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.TEMPLATED_OBJECT_ARRAY:
					return this.decodeTemplatedObjectArray();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.DATE:
					return this.decodeDate();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.ARRAY_BUFFER_VIEW:
					return this.decodeArrayBufferView();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.ARRAY_BUFFER:
					return this.decodeArrayBuffer();

				default:
					throw new Error(
						"Unhandled " +
						___R$project$rome$$internal$codec$binary$serial$codes_ts$formatCode(
							code,
						) +
						" code",
					);
			}
		}

		decodeArrayBufferView() {
			this.readOffset++;

			const code = ___R$project$rome$$internal$codec$binary$serial$codes_ts$validateArrayBufferViewCode(
				this.readInt(1),
			);
			const length = this.decodeNumber();
			const offset = this.decodeNumber();
			const view = this.decodeArrayBuffer();
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$arrayBufferViewCodeToInstance(
				code,
				view,
				offset,
				length,
			);
		}

		decodeArrayBuffer() {
			this.readOffset++;
			const offset = this.readOffset;
			const length = this.decodeNumber();
			const buffer = this.bytes.subarray(offset, offset + length);
			this.readOffset += length;
			return buffer;
		}

		decodeSymbol() {
			this.readOffset++;
			const key = this.readString();
			return Symbol.for(key);
		}

		decodeTrue() {
			this.readOffset++;
			return true;
		}

		decodeFalse() {
			this.readOffset++;
			return false;
		}

		decodeNull() {
			this.readOffset++;
			return null;
		}

		decodeNaN() {
			this.readOffset++;
			return NaN;
		}

		decodePositiveInfinity() {
			this.readOffset++;
			return Number.POSITIVE_INFINITY;
		}

		decodeNegativeInfinity() {
			this.readOffset++;
			return Number.NEGATIVE_INFINITY;
		}

		decodeNegativeZero() {
			this.readOffset++;
			return -0;
		}

		decodeUndefined() {
			this.readOffset++;
			return undefined;
		}

		decodeFloat() {
			this.readOffset++;
			this.assertReadableSize(8);
			const num = this.view.getFloat64(this.readOffset);
			this.readOffset += 8;
			return num;
		}

		decodeRegExp() {
			this.expectCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.REGEXP,
			);
			const pattern = this.readString();
			const flags = this.readString();
			return new RegExp(pattern, flags);
		}

		decodeArray() {
			const arr = this.decodeArrayHead();
			return this.decodeArrayElements(arr);
		}

		decodeArrayHead() {
			this.expectCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.ARRAY,
			);
			const length = this.decodeNumber();
			return new Array(length);
		}

		decodeArrayElements(arr) {
			for (let i = 0; i < arr.length; ++i) {
				arr[i] = this.decodeValue();
			}
			return arr;
		}

		decodeObject() {
			this.expectCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.OBJECT,
			);
			return this.decodeObjectValue({});
		}

		decodeObjectValue(obj) {
			const length = this.decodeInt();
			for (let i = 0; i < length; ++i) {
				const key = this.decodeKey();
				const val = this.decodeValue();
				obj[key] = val;
			}
			return obj;
		}

		decodeTemplatedObjectArray() {
			// Sometimes we may encode a templated object array to a regular array (like when there's no elements)
			const code = this.peekCode();
			if (
				code ===
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.ARRAY
			) {
				return this.decodeArray();
			} else {
				const arr = this.decodeTemplatedObjectArrayHead();
				return this.decodeTemplateObjectArrayValues(arr);
			}
		}

		decodeTemplatedObjectArrayHead() {
			this.expectCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.TEMPLATED_OBJECT_ARRAY,
			);
			const length = this.decodeInt();
			return new Array(length);
		}

		decodeTemplateObjectArrayValues(arr) {
			// Decode keys
			const keyCount = this.decodeInt();
			const keys = [];
			for (let i = 0; i < keyCount; ++i) {
				keys.push(this.readString());
			}

			// Decode array and objects
			for (let i = 0; i < length; ++i) {
				const obj = {};
				for (let keyidx = 0; keyidx < keys.length; ++keyidx) {
					const val = this.decodeValue();
					const key = keys[keyidx];
					obj[key] = val;
				}
				arr[i] = obj;
			}
			return arr;
		}

		decodeDate() {
			this.expectCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.DATE,
			);
			const time = this.decodeNumber();
			return new Date(time);
		}

		decodeFilePathCode() {
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$validateFileCode(
				this.readInt(1),
			);
		}

		decodeFilePath() {
			this.expectCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.FILE_PATH,
			);
			const code = this.decodeFilePathCode();
			const str = this.readString();
			return ___R$project$rome$$internal$codec$binary$serial$codes_ts$filePathFromCode(
				code,
				str,
			);
		}

		decodeFilePathMap() {
			this.expectCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.FILE_PATH_MAP,
			);
			const code = this.decodeFilePathCode();
			const map = ___R$project$rome$$internal$codec$binary$serial$codes_ts$filePathMapFromCode(
				code,
			);
			return this.decodeFilePathMapValue(map);
		}

		decodeFilePathMapValue(map) {
			const size = this.decodeInt();
			for (let i = 0; i < size; ++i) {
				const str = this.readString();
				const value = this.decodeValue();
				map.setString(str, value);
			}
			return map;
		}

		decodeFilePathSet() {
			this.expectCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.FILE_PATH_SET,
			);

			const code = this.decodeFilePathCode();
			const set = ___R$project$rome$$internal$codec$binary$serial$codes_ts$filePathSetFromCode(
				code,
			);

			const size = this.decodeInt();
			for (let i = 0; i < size; ++i) {
				set.addString(this.readString());
			}
			return set;
		}

		decodeSet() {
			this.expectCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.SET,
			);
			return this.decodeSetValue(new Set());
		}

		decodeSetValue(set) {
			const size = this.decodeInt();
			for (let i = 0; i < size; ++i) {
				set.add(this.decodeValue());
			}
			return set;
		}

		decodeMap() {
			this.expectCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.MAP,
			);
			return this.decodeMapValue(new Map());
		}

		decodeMapValue(map) {
			const nitems = this.decodeInt();
			for (let i = 0; i < nitems; ++i) {
				const key = this.decodeValue();
				const value = this.decodeValue();
				map.set(key, value);
			}
			return map;
		}

		decodeError() {
			this.readOffset++;

			const errorCode = ___R$project$rome$$internal$codec$binary$serial$codes_ts$validateErrorCode(
				this.readInt(1),
			);
			const message = this.readString();
			const stack = this.decodeStringOrVoid();

			const err = ___R$project$rome$$internal$codec$binary$serial$codes_ts$errorCodeToInstance(
				errorCode,
			);
			err.message = message;
			err.stack = stack;

			// @ts-ignore: Validating these is expensive but we can be confident on the validity
			const nodeProps = this.decodeObject();
			___R$project$rome$$internal$v8$errors_ts$setNodeErrorProps(err, nodeProps);

			// @ts-ignore: ^^
			const frames = this.decodeTemplatedObjectArray();
			___R$project$rome$$internal$v8$errors_ts$setErrorFrames(err, frames);

			return err;
		}

		decodeStringOrVoid() {
			const code = this.peekCode();
			if (
				code ===
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.UNDEFINED
			) {
				return this.decodeUndefined();
			} else if (
				code ===
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.STRING
			) {
				return this.decodeString();
			} else {
				throw new Error(
					"Expected string or undefined but got " +
					___R$project$rome$$internal$codec$binary$serial$codes_ts$formatCode(
						code,
					),
				);
			}
		}

		decodeKey() {
			const size = this.decodeNumber();
			if (
				___R$$priv$project$rome$$internal$codec$binary$serial$RSERBufferParser_ts$sharedCachedKeyDecoder.canBeCached(
					size,
				)
			) {
				const str = ___R$$priv$project$rome$$internal$codec$binary$serial$RSERBufferParser_ts$sharedCachedKeyDecoder.decode(
					this.bytes,
					this.readOffset,
					size,
				);
				this.readOffset += size;
				return str;
			} else {
				return this.readStringSize(size);
			}
		}

		decodeString() {
			this.expectCode(
				___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.STRING,
			);
			return this.readString();
		}

		decodeInt() {
			this.assertReadableSize(1);
			const size = this.getDecodeIntSize();
			this.readOffset += 1;
			return this.readInt(size);
		}

		decodeNumber() {
			const code = this.peekCode();

			switch (code) {
				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.INT8:
				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.INT16:
				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.INT32: {
					const num = this.decodeInt();
					if (typeof num === "bigint") {
						throw new Error("Did not expect a bigint");
					} else {
						return num;
					}
				}

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.FLOAT:
					return this.decodeFloat();

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.INT64:
					throw new Error("Unexpected bigint, only regular numbers accepted");

				default:
					throw new Error(
						___R$project$rome$$internal$codec$binary$serial$codes_ts$formatCode(
							code,
						) + " is not a valid number code",
					);
			}
		}

		getDecodeIntSize() {
			const code = this.peekInt(1);
			switch (code) {
				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.INT8:
					return 1;

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.INT16:
					return 2;

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.INT32:
					return 4;

				case ___R$project$rome$$internal$codec$binary$serial$codes_ts$VALUE_CODES.INT64:
					return 8;

				default:
					throw new Error(
						"No int encoding for " +
						___R$project$rome$$internal$codec$binary$serial$codes_ts$formatCode(
							code,
						),
					);
			}
		}
	}


  // project-rome/@internal/codec-binary-serial/RSERStream.ts
class ___R$project$rome$$internal$codec$binary$serial$RSERStream_ts$default {
		constructor() {
			this.state = this.createWaitingState();
			this.overflow = [];

			this.errorEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "RSERStream.error",
			});

			this.valueEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "RSERStream.value",
			});

			this.sendEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "RSERStream.sendEvent",
			});
		}

		createWaitingState() {
			return {
				type: "WAITING",
				// Max size of the message header
				writer: ___R$project$rome$$internal$codec$binary$serial$RSERBufferWriter_ts$default.allocate(
					7,
				),
			};
		}

		send(val) {
			try {
				this.sendEvent.send(
					___R$project$rome$$internal$codec$binary$serial$index_ts$encodeRSERBuffer(
						val,
					),
				);
			} catch (err) {
				this.errorEvent.send(err);
			}
		}

		append(buf) {
			const {writer, type} = this.state;

			try {
				// Fast path for appending a full message
				if (type === "WAITING" && writer.writeOffset === 0 && buf.byteLength > 7) {
					const reader = new ___R$project$rome$$internal$codec$binary$serial$RSERBufferParser_ts$default(
						new DataView(buf),
					);
					const payloadLength = reader.decodeHeader();
					if (
						payloadLength !== false &&
						payloadLength === reader.getReadableSize()
					) {
						const val = reader.decodeValue();
						this.valueEvent.send(val);
						return;
					}
				}

				// Push to overflow queue if necessary
				let arr = new Uint8Array(buf);

				const remaining = writer.getWritableSize();
				if (remaining < arr.byteLength) {
					// Slicing Node buffers is cheap since it just creates a view
					this.overflow.push(arr.slice(remaining));
					arr = arr.slice(0, remaining);
				}

				writer.appendBytes(arr);
				this.process();
			} catch (err) {
				this.errorEvent.send(err);
			}
		}

		setState(state) {
			try {
				this.state = state;
				const {writer} = this.state;

				while (this.overflow.length > 0 && writer.getWritableSize() > 0) {
					let entry = this.overflow[0];
					const writableSize = writer.getWritableSize();

					const bufferSize = Buffer.byteLength(entry);
					if (bufferSize > writableSize) {
						this.overflow[0] = entry.slice(writableSize);
						entry = entry.slice(0, writableSize);
					} else {
						this.overflow.shift();
					}

					writer.appendBytes(entry);

					this.process();
				}
			} catch (err) {
				this.errorEvent.send(err);
			}
		}

		process() {
			const {type, writer} = this.state;

			if (type === "WAITING") {
				if (writer.writeOffset < 2) {
					return;
				}

				const reader = new ___R$project$rome$$internal$codec$binary$serial$RSERBufferParser_ts$default(
					writer.view,
				);
				const payloadLength = reader.decodeHeader();
				if (payloadLength === false) {
					return;
				}

				// The header buffer is set to the maximum size it could be, but there could still be data left so push it on.
				const leftover = reader.getReadableSize();
				const payloadWriter = ___R$project$rome$$internal$codec$binary$serial$RSERBufferWriter_ts$default.allocate(
					payloadLength + leftover,
				);
				if (leftover > 0) {
					payloadWriter.appendBytes(writer.bytes.slice(reader.readOffset));
				}

				this.setState({
					type: "READING",
					writer: payloadWriter,
				});
			}

			if (type === "READING") {
				if (writer.getWritableSize() > 0) {
					// Need more data
					return;
				}

				// We have enough to decode it
				const reader = new ___R$project$rome$$internal$codec$binary$serial$RSERBufferParser_ts$default(
					writer.view,
				);
				const val = reader.decodeValue();
				this.valueEvent.send(val);
				this.setState(this.createWaitingState());
			}
		}
	}


  // project-rome/@internal/codec-binary-serial/index.ts
function ___R$project$rome$$internal$codec$binary$serial$index_ts$encodeRSERBuffer(
		val,
	) {
		const assembler = new ___R$project$rome$$internal$codec$binary$serial$RSERBufferAssembler_ts$default();
		assembler.encodeValue(val);
		const payloadLength = assembler.totalSize;
		assembler.encodeHeader(payloadLength);
		const messageLength = assembler.totalSize;

		const buf = new ___R$project$rome$$internal$codec$binary$serial$RSERBufferWriter_ts$default(
			new ArrayBuffer(messageLength),
			assembler,
		);
		buf.encodeHeader(payloadLength);
		buf.encodeValue(val);
		return buf.buffer;
	}


  // project-rome/@internal/events/Bridge.ts
class ___R$project$rome$$internal$events$Bridge_ts$default {
		constructor(opts) {
			this.errorTransports = new Map();

			this.alive = true;
			this.hasHandshook = false;
			this.endError = undefined;
			this.type = opts.type;
			this.opts = opts;

			this.messageIdCounter = 0;
			this.events = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
				"events",
			);

			this.handshakeEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "Bridge.handshake",
			});
			this.endEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "Bridge.end",
				serial: true,
			});
			this.updatedListenersEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "Bridge.updatedListenersEvent",
			});

			// A Set of event names that are being listened to on the other end
			// We track this to avoid sending over subscriptions that aren't needed
			this.listeners = new Set();

			this.prioritizedResponses = new Set();
			this.deprioritizedResponseQueue = [];

			this.postHandshakeQueue = [];

			this.heartbeatEvent = this.createEvent({
				name: "Bridge.heartbeat",
				direction: "server<->client",
			});

			if (this.type !== "server&client") {
				this.heartbeatEvent.subscribe(() => {
					return undefined;
				});
			}

			this.init();
		}

		attachEndSubscriptionRemoval(subscription) {
			this.endEvent.subscribe(async () => {
				await subscription.unsubscribe();
			});
		}

		getPendingRequestsSummary() {
			const summaries = [];

			for (const event of this.events.values()) {
				const requestCount = event.requestCallbacks.size;
				if (requestCount > 0) {
					let list = Array.from(
						event.requestCallbacks.values(),
						({param}) => {
							return ___R$project$rome$$internal$markup$escape_ts$markup`<li>${___R$project$rome$$internal$pretty$format$index_ts$default(
								param,
							)}</li>`;
						},
					);

					summaries.push(
						___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${event.name}</emphasis> x ${requestCount}\n<ul>${___R$project$rome$$internal$markup$escape_ts$concatMarkup(
							list,
						)}</ul>`,
					);
				}
			}

			return summaries;
		}

		monitorHeartbeat(
			timeout,
			onExceeded,
			{
				iterations,
				initialTime,
			} = {iterations: 0, initialTime: 0},
		) {
			if (this.type === "server&client") {
				// No point in monitoring this since we're the same process
				return;
			}

			const start = Date.now();

			this.heartbeatTimeout = setTimeout(
				async () => {
					try {
						await this.heartbeatEvent.call(undefined, {timeout});
					} catch (err) {
						if (
							err instanceof
							___R$project$rome$$internal$events$BridgeError_ts$default
						) {
							if (this.alive) {
								const took = Date.now() - start;
								onExceeded({
									summary: this.getPendingRequestsSummary(),
									iterations,
									totalTime: initialTime + took,
								});
							}
						} else {
							throw err;
						}
					} finally {
						const took = Date.now() - start;
						this.monitorHeartbeat(
							timeout,
							onExceeded,
							{
								initialTime: initialTime + took,
								iterations: iterations + 1,
							},
						);
					}
				},
				1_000,
			);
		}

		clearPrioritization(id) {
			this.prioritizedResponses.delete(id);

			if (this.prioritizedResponses.size === 0) {
				for (const msg of this.deprioritizedResponseQueue) {
					this.sendMessage(msg);
				}
				this.deprioritizedResponseQueue = [];
			}
		}

		async handshake(opts = {}) {
			if (this.hasHandshook) {
				throw new Error("Already performed handshake");
			}

			const {timeout, second = false} = opts;

			// Send a handshake in case we were the first
			if (!second) {
				this.sendMessage({
					type: "handshake",
					first: true,
					subscriptions: this.getSubscriptions(),
				});
			}

			// Wait for a handshake from the other end
			const res = await this.handshakeEvent.wait(undefined, timeout);

			if (res.first) {
				// Send the handshake again, as it wouldn't have received the first
				this.sendMessage({
					type: "handshake",
					first: false,
					subscriptions: this.getSubscriptions(),
				});
			}

			this.receivedSubscriptions(res.subscriptions);

			this.hasHandshook = true;

			for (const msg of this.postHandshakeQueue) {
				this.sendMessage(msg);
			}
			this.postHandshakeQueue = [];
		}

		getSubscriptions() {
			const names = [];
			for (const event of this.events.values()) {
				if (event.hasSubscriptions()) {
					names.push(event.name);
				}
			}
			return names;
		}

		sendSubscriptions() {
			if (!this.hasHandshook) {
				// If we haven't had the handshake then no point sending them. They'll be sent all at once after
				return;
			}

			// Nobody to send an update to
			if (!this.alive) {
				return;
			}

			// Notify the other side of what we're currently subscribed to
			// We send over a list of all of our subscriptions every time
			// This is fine since we don't change subscriptions often and they aren't very large
			// If we have a lot of subscriptions, or are changing them a lot in the future then this could be optimized
			this.sendMessage({
				type: "subscriptions",
				names: this.getSubscriptions(),
			});
		}

		receivedSubscriptions(names) {
			this.listeners = new Set(names);
			this.updatedListenersEvent.send(this.listeners);
		}

		attachRSER() {
			const buf = new ___R$project$rome$$internal$codec$binary$serial$RSERStream_ts$default();

			buf.errorEvent.subscribe((err) => {
				this.endWithError(err);
			});

			buf.valueEvent.subscribe((value) => {
				process.nextTick(() => {
					this.handleMessage((value));
				});
			});

			return buf;
		}

		init() {
			// This method can be overridden by subclasses, it allows you to add logic such as error serializers
		}

		clear() {
			for (const [, event] of this.events) {
				event.clear();
			}
		}

		getNextMessageId() {
			return ++this.messageIdCounter;
		}

		createEvent(opts) {
			if (this.events.has(opts.name)) {
				throw new Error("Duplicate event");
			}

			const event = new ___R$project$rome$$internal$events$BridgeEvent_ts$default(
				opts,
				this,
			);
			this.events.set(opts.name, event);
			return event;
		}

		//# Connection death
		assertAlive() {
			if (this.endError !== undefined) {
				throw this.endError;
			}
		}

		endWithError(err) {
			if (!this.alive) {
				return;
			}

			this.alive = false;
			this.endError = err;

			// Reject any pending requests
			for (const [, event] of this.events) {
				event.end(err);
			}
			this.clear();

			// Clear any currently processing heartbeat
			if (this.heartbeatTimeout !== undefined) {
				clearTimeout(this.heartbeatTimeout);
			}

			// Notify listeners
			this.endEvent.send(err, true);
		}

		end(message = "Connection died") {
			this.endWithError(
				new ___R$project$rome$$internal$events$BridgeError_ts$default(
					message,
					this,
				),
			);
		}

		//# Error serialization

		hydrateError({value: struct, metadata}) {
			const transport = this.errorTransports.get(struct.name);
			if (transport === undefined) {
				const err = new Error(struct.message);
				err.name = struct.name || "Error";
				err.stack = struct.stack;
				___R$project$rome$$internal$v8$errors_ts$setErrorFrames(
					err,
					struct.frames,
				);
				return err;
			} else {
				return transport.hydrate(struct, metadata);
			}
		}

		serializeError(errRaw) {
			// Just in case something that wasn't an Error was thrown
			const err = errRaw instanceof Error ? errRaw : new Error(String(errRaw));

			// Fetch some metadata for hydration
			const tranport = this.errorTransports.get(err.name);
			const metadata = tranport === undefined ? {} : tranport.serialize(err);

			return {
				value: ___R$project$rome$$internal$v8$errors_ts$getErrorStructure(err),
				metadata,
			};
		}

		buildErrorResponse(id, event, errRaw) {
			return Object.assign(
				{id, event, type: "response", responseStatus: "error"},
				this.serializeError(errRaw),
			);
		}

		// rome-ignore lint/ts/noExplicitAny: future cleanup
		addErrorTransport(name, transport) {
			this.errorTransports.set(name, transport);
		}

		//# Message transmission

		sendMessage(msg) {
			// There's no try-catch gated around sendMessage because the call stack here will include some other error handler
			// We need to be specific for handleMessage because it could come from anywhere
			if (msg.type !== "handshake" && !this.hasHandshook) {
				this.postHandshakeQueue.push(msg);
				return;
			}

			this.assertAlive();

			if (msg.type === "response") {
				if (
					this.prioritizedResponses.size > 0 &&
					!this.prioritizedResponses.has(msg.id)
				) {
					this.deprioritizedResponseQueue.push(msg);
					return;
				}

				if (this.prioritizedResponses.has(msg.id)) {
					this.clearPrioritization(msg.id);
				}
			}

			const {opts} = this;
			opts.sendMessage(msg);
			if (opts.onSendMessage !== undefined) {
				opts.onSendMessage(msg);
			}
		}

		handleMessage(msg) {
			try {
				this.assertAlive();

				if (msg.type === "handshake") {
					this.handshakeEvent.send({
						subscriptions: msg.subscriptions,
						first: msg.first,
					});
				}

				if (msg.type === "subscriptions") {
					this.receivedSubscriptions(msg.names);
				}

				if (msg.type === "request") {
					this.handleMessageRequest(msg);
				}

				if (msg.type === "response") {
					this.handleMessageResponse(msg);
				}
			} catch (err) {
				this.endWithError(err);
			}
		}

		handleMessageResponse(data) {
			const {id, event} = data;
			if (id === undefined) {
				throw new Error("Expected id");
			}
			if (event === undefined) {
				throw new Error("Expected event");
			}

			const eventHandler = this.events.assert(event);
			eventHandler.dispatchResponse(id, data);
		}

		handleMessageRequest(data) {
			const {id, event, param, priority} = data;
			if (event === undefined) {
				throw new Error("Expected event in message request but received none");
			}

			const eventHandler = this.events.assert(event);

			if (id === undefined) {
				eventHandler.dispatchRequest(param).catch((err) => {
					this.endWithError(err);
				});
			} else {
				if (priority) {
					this.prioritizedResponses.add(id);
				}

				eventHandler.dispatchRequest(param).then(
					(value) => {
						this.sendMessage({
							event,
							id,
							type: "response",
							responseStatus: "success",
							value,
						});
					},
					(err) => {
						this.sendMessage(this.buildErrorResponse(id, event, err));
					},
				).catch((err) => this.endWithError(err));
			}
		}
	}


  // project-rome/@internal/events/bridgeCreators.ts
const ___R$project$rome$$internal$events$bridgeCreators_ts = {
		createBridgeFromWebSocketInterface: ___R$project$rome$$internal$events$bridgeCreators_ts$createBridgeFromWebSocketInterface,
		createBridgeFromBrowserWebSocket: ___R$project$rome$$internal$events$bridgeCreators_ts$createBridgeFromBrowserWebSocket,
		createBridgeFromSocket: ___R$project$rome$$internal$events$bridgeCreators_ts$createBridgeFromSocket,
		createBridgeFromLocal: ___R$project$rome$$internal$events$bridgeCreators_ts$createBridgeFromLocal,
		createBridgeFromWorkerThread: ___R$project$rome$$internal$events$bridgeCreators_ts$createBridgeFromWorkerThread,
		createBridgeFromWorkerThreadParentPort: ___R$project$rome$$internal$events$bridgeCreators_ts$createBridgeFromWorkerThreadParentPort,
	};
	const ___R$$priv$project$rome$$internal$events$bridgeCreators_ts$workerThreads = require(
		"worker_threads",
	);
	function ___R$project$rome$$internal$events$bridgeCreators_ts$createBridgeFromWebSocketInterface(
		CustomBridge,
		inf,
		opts,
	) {
		const bridge = new CustomBridge(
			Object.assign(
				{},
				opts,
				{
					sendMessage: (data) => {
						rser.send(data);
					},
				},
			),
		);

		const {socket} = inf;
		const rser = bridge.attachRSER();

		rser.sendEvent.subscribe((buf) => {
			inf.send(Buffer.from(buf));
		});

		bridge.endEvent.subscribe(() => {
			socket.end();
		});

		inf.completeFrameEvent.subscribe((frame) => {
			rser.append(frame.payload.buffer);
		});

		socket.on(
			"error",
			(err) => {
				bridge.endWithError(err);
			},
		);

		socket.on(
			"end",
			() => {
				bridge.end("RPC WebSocket died");
			},
		);

		return bridge;
	}

	function ___R$project$rome$$internal$events$bridgeCreators_ts$createBridgeFromBrowserWebSocket(
		CustomBridge,
		socket,
		opts,
	) {
		const bridge = new CustomBridge(
			Object.assign(
				{},
				opts,
				{
					sendMessage: (data) => {
						rser.send(data);
					},
				},
			),
		);

		const rser = bridge.attachRSER();

		rser.sendEvent.subscribe((buf) => {
			socket.send(buf);
		});

		bridge.endEvent.subscribe(() => {
			socket.close();
		});

		socket.binaryType = "arraybuffer";

		socket.onmessage = function(event) {
			const {data} = event;
			if (!(data instanceof ArrayBuffer)) {
				throw new Error("Expected ArrayBuffer");
			}
			rser.append(data);
		};

		socket.onclose = () => {
			bridge.end("RPC WebSocket disconnected");
		};

		return bridge;
	}

	function ___R$project$rome$$internal$events$bridgeCreators_ts$createBridgeFromSocket(
		CustomBridge,
		socket,
		opts,
	) {
		const bridge = new CustomBridge(
			Object.assign(
				{},
				opts,
				{
					sendMessage: (data) => {
						rser.send(data);
					},
				},
			),
		);

		const rser = bridge.attachRSER();

		rser.sendEvent.subscribe((buf) => {
			socket.write(new Uint8Array(buf));
		});

		bridge.endEvent.subscribe(() => {
			socket.end();
		});

		socket.on(
			"data",
			(chunk) => {
				rser.append(chunk.buffer);
			},
		);

		socket.on(
			"error",
			(err) => {
				bridge.endWithError(err);
			},
		);

		socket.on(
			"end",
			() => {
				bridge.end("Socket disconnected");
			},
		);

		return bridge;
	}

	function ___R$project$rome$$internal$events$bridgeCreators_ts$createBridgeFromLocal(
		CustomBridge,
		opts,
	) {
		const bridge = new CustomBridge(
			Object.assign(
				{},
				opts,
				{
					type: "server&client",
					sendMessage: (msg) => {
						bridge.handleMessage(msg);
					},
				},
			),
		);

		return bridge;
	}

	function ___R$project$rome$$internal$events$bridgeCreators_ts$createBridgeFromWorkerThread(
		CustomBridge,
		worker,
		opts,
	) {
		const bridge = new CustomBridge(
			Object.assign(
				{},
				opts,
				{
					sendMessage: (data) => {
						rser.send(data);
					},
				},
			),
		);

		const rser = bridge.attachRSER();

		rser.sendEvent.subscribe((msg) => {
			worker.postMessage(msg, [msg]);
		});

		bridge.endEvent.subscribe(() => {
			worker.terminate();
		});

		worker.on(
			"message",
			(msg) => {
				rser.append(msg);
			},
		);

		worker.on(
			"messageerror",
			(err) => {
				bridge.endWithError(err);
			},
		);

		worker.on(
			"error",
			(err) => {
				bridge.endWithError(err);
			},
		);

		worker.on(
			"exit",
			(code) => {
				bridge.end("Worker thread died with exit code " + code);
			},
		);

		return bridge;
	}

	function ___R$project$rome$$internal$events$bridgeCreators_ts$createBridgeFromWorkerThreadParentPort(
		CustomBridge,
		opts,
	) {
		const {parentPort} = ___R$$priv$project$rome$$internal$events$bridgeCreators_ts$workerThreads;
		if (parentPort == null) {
			throw new Error("No worker_threads parentPort found");
		}

		const bridge = new CustomBridge(
			Object.assign(
				{},
				opts,
				{
					sendMessage: (data) => {
						rser.send(data);
					},
				},
			),
		);

		const rser = bridge.attachRSER();

		rser.sendEvent.subscribe((msg) => {
			parentPort.postMessage(msg, [msg]);
		});

		bridge.endEvent.subscribe(() => {
			parentPort.close();
			process.exit();
		});

		parentPort.on(
			"message",
			(msg) => {
				rser.append(msg);
			},
		);

		parentPort.on(
			"close",
			() => {
				bridge.end("Worker thread parent port closed");
			},
		);

		return bridge;
	}


  // project-rome/@internal/events/types.ts
const ___R$project$rome$$internal$events$types_ts = {};


  // project-rome/@internal/events/utils.ts
const ___R$project$rome$$internal$events$utils_ts = {
		mergeEventSubscriptions: ___R$project$rome$$internal$events$utils_ts$mergeEventSubscriptions,
		createEmptySubscription: ___R$project$rome$$internal$events$utils_ts$createEmptySubscription,
		createSubscriptionHelper: ___R$project$rome$$internal$events$utils_ts$createSubscriptionHelper,
		wrapSubscriptionConsumer: ___R$project$rome$$internal$events$utils_ts$wrapSubscriptionConsumer,
	};
	function ___R$project$rome$$internal$events$utils_ts$mergeEventSubscriptions(
		subs,
	) {
		return {
			async unsubscribe() {
				for (const sub of subs) {
					await sub.unsubscribe();
				}
			},
		};
	}

	function ___R$project$rome$$internal$events$utils_ts$createEmptySubscription() {
		return {
			async unsubscribe() {},
		};
	}

	function ___R$project$rome$$internal$events$utils_ts$createSubscriptionHelper() {
		const subscriptions = [];

		return {
			add(sub) {
				subscriptions.push(sub);
			},
			async unsubscribe() {
				await ___R$project$rome$$internal$events$utils_ts$mergeEventSubscriptions(
					subscriptions,
				).unsubscribe();
			},
		};
	}

	function ___R$project$rome$$internal$events$utils_ts$wrapSubscriptionConsumer(
		callback,
	) {
		return async function(...args) {
			const helper = ___R$project$rome$$internal$events$utils_ts$createSubscriptionHelper();

			try {
				return await callback.apply(null, [helper, ...args]);
			} finally {
				await helper.unsubscribe();
			}
		};
	}


  // project-rome/@internal/events/index.ts



  // project-rome/@internal/cli-environment/index.ts
const ___R$$priv$project$rome$$internal$cli$environment$index_ts$stream = require(
		"stream",
	);
	const ___R$$priv$project$rome$$internal$cli$environment$index_ts$tty = require(
		"tty",
	);
	const ___R$project$rome$$internal$cli$environment$index_ts$DEFAULT_TERMINAL_FEATURES = {
		background: "unknown",
		isTTY: false,
		columns: ___R$project$rome$$internal$ob1$index_ts$ob1Coerce1(100),
		progress: false,
		cursor: false,
		unicode: true,
		hyperlinks: false,
		colorDepth: 4,
	};

	function ___R$project$rome$$internal$cli$environment$index_ts$getEnvVar(key) {
		const value = process.env[key];
		if (value === undefined) {
			return {type: "UNDEFINED", value: undefined};
		}
		if (value === "0" || value === "false") {
			return {type: "DISABLED", value: false};
		}
		if (value === "1" || value === "true") {
			return {type: "ENABLED", value: true};
		}
		return {type: "ENABLED", value};
	}

	function ___R$project$rome$$internal$cli$environment$index_ts$inferTerminalFeatures(
		stdout,
		force = {},
	) {
		let columns = ___R$project$rome$$internal$ob1$index_ts$ob1Coerce1(100);
		let colorDepth = 1;
		let isTTY = force.isTTY === true;
		let unicode = false;
		let isCI = ___R$project$rome$$internal$cli$environment$index_ts$isCIEnv();
		let background = "unknown";

		// Increase column size for CI
		if (isCI) {
			columns = ___R$project$rome$$internal$ob1$index_ts$ob1Coerce1(200);
			colorDepth = 4;
		}

		// Only apply this environment sniffing when we've been given a process stdout stream
		// Otherwise it'll be some custom stream and if they really want to infer from the environment
		// Then they will do it on process.stdout and pass the features as the force param
		if (
			stdout instanceof
			___R$$priv$project$rome$$internal$cli$environment$index_ts$tty.WriteStream
		) {
			isTTY = true;
			unicode = process.platform !== "win32";
			colorDepth = (stdout.getColorDepth());
			columns = ___R$project$rome$$internal$ob1$index_ts$ob1Coerce1(
				stdout.columns,
			);

			// Sniff for the background
			// https://github.com/vim/vim/blob/e3f915d12c8fe0466918a29ab4eaef153f71a2cd/src/term.c#L2943-L2952
			const COLORFGBG = ___R$project$rome$$internal$cli$environment$index_ts$getEnvVar(
				"COLORFGBG",
			);
			if (COLORFGBG.type === "ENABLED") {
				const color = parseInt(String(COLORFGBG.value).split(";").pop());
				if (!isNaN(color)) {
					if ((color >= 0 && color <= 6) || color === 8) {
						background = "dark";
					} else {
						background = "light";
					}
				}
			}
		}

		const fancyAnsi = isTTY && !isCI;

		const progress =
			fancyAnsi &&
			___R$project$rome$$internal$cli$environment$index_ts$getEnvVar(
				"ROME_PROGRESS",
			).type !== "DISABLED";

		let features = ___R$project$rome$$internal$typescript$helpers$index_ts$mergeObjects(
			{
				progress,
				isTTY,
				background,
				columns,
				cursor: fancyAnsi,
				hyperlinks: fancyAnsi,
				colorDepth,
				unicode,
			},
			force,
		);

		const updateEvent = new ___R$project$rome$$internal$events$Event_ts$default({
			name: "update",
		});

		let closeUpdateEvent = () => {};
		let setupUpdateEvent = () => {};

		// Watch for resizing, unless force.columns has been set and we'll consider it to be fixed
		if (
			stdout instanceof
			___R$$priv$project$rome$$internal$cli$environment$index_ts$tty.WriteStream &&
			force.columns === undefined
		) {
			function onStdoutResize() {
				if (
					stdout instanceof
					___R$$priv$project$rome$$internal$cli$environment$index_ts$tty.WriteStream
				) {
					features = Object.assign(
						{},
						features,
						{
							columns: ___R$project$rome$$internal$ob1$index_ts$ob1Coerce1(
								stdout.columns,
							),
						},
					);
					updateEvent.send(features);
				}
			}

			setupUpdateEvent = () => {
				stdout.on("resize", onStdoutResize);
			};

			closeUpdateEvent = () => {
				stdout.off("resize", onStdoutResize);
			};
		}

		return {
			updateEvent,
			features,
			setupUpdateEvent,
			closeUpdateEvent,
		};
	}

	const ___R$$priv$project$rome$$internal$cli$environment$index_ts$CI_ENV_NAMES = [
		"CI",
		"TRAVIS",
		"CIRCLECI",
		"APPVEYOR",
		"GITLAB_CI",
		"GITHUB_ACTIONS",
	];

	function ___R$project$rome$$internal$cli$environment$index_ts$isCIEnv() {
		for (const key of ___R$$priv$project$rome$$internal$cli$environment$index_ts$CI_ENV_NAMES) {
			if (
				___R$project$rome$$internal$cli$environment$index_ts$getEnvVar(key).type ===
				"ENABLED"
			) {
				return true;
			}
		}
		return false;
	}


  // project-rome/@internal/fs/FileNotFound.ts
class ___R$project$rome$$internal$fs$FileNotFound_ts$FileNotFound extends Error {
		constructor(path, suffixMessage) {
			super(
				suffixMessage === undefined
					? path.join() + " not found"
					: path.join() + ": " + suffixMessage,
			);
			this.suffixMessage = suffixMessage;
			this.name = "FileNotFound";
			this._path = path;
		}

		static async maybeAllowMissing(allow, path, factory) {
			if (allow) {
				return ___R$project$rome$$internal$fs$FileNotFound_ts$FileNotFound.allowMissing(
					path,
					factory,
				);
			} else {
				return {
					value: await factory(),
					missing: false,
				};
			}
		}

		static async allowMissing(path, factory) {
			try {
				return {
					value: await factory(),
					missing: false,
				};
			} catch (err) {
				if (
					err instanceof
					___R$project$rome$$internal$fs$FileNotFound_ts$FileNotFound &&
					err._path.equal(path)
				) {
					return {missing: true, value: undefined};
				} else {
					throw err;
				}
			}
		}
	}


  // project-rome/@internal/fs/index.ts
const ___R$$priv$project$rome$$internal$fs$index_ts$fs = require("fs");
	// Most fs errors don't have a stack trace. This is due to the way that node queues file operations.
	// Capturing a stacktrace would be very expensive.
	// So here we just alternatively do it ourselves if we were passed the ROME_FS_ERRORS=1 env var
	// https://github.com/nodejs/node/issues/30944
	const ___R$$priv$project$rome$$internal$fs$index_ts$debugErrors =
		___R$project$rome$$internal$cli$environment$index_ts$getEnvVar(
			"ROME_FS_ERRORS",
		).type === "ENABLED";
	function ___R$$priv$project$rome$$internal$fs$index_ts$wrapReject(
		promise,
		addFrames,
	) {
		const callError = ___R$$priv$project$rome$$internal$fs$index_ts$debugErrors
			? new Error()
			: undefined;

		return promise.catch((err) => {
			if (callError !== undefined) {
				// Remove wrapReject frame and custom addFrames to get to the real callsite
				___R$project$rome$$internal$v8$errors_ts$setErrorFrames(
					err,
					___R$project$rome$$internal$v8$errors_ts$getErrorStructure(callError).frames.slice(
						1 + addFrames,
					),
				);
			}

			// Convert ENOENT to FileNotFound errors, if we want this to be a pretty node error then it can be converted later
			if (err.code === "ENOENT" && err.path !== undefined) {
				const err2 = new ___R$project$rome$$internal$fs$FileNotFound_ts$FileNotFound(
					___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
						err.path,
					),
				);
				___R$project$rome$$internal$v8$errors_ts$setNodeErrorProps(err2, err);
				___R$project$rome$$internal$v8$errors_ts$setErrorFrames(
					err2,
					___R$project$rome$$internal$v8$errors_ts$getErrorStructure(err).frames,
				);
				return Promise.reject(err2);
			}

			// If the error has no stacktrace then we'll recommend adding the envvar
			return Promise.reject(
				___R$project$rome$$internal$node$errors_ts$convertPossibleNodeErrorToDiagnostic(
					err,
				),
			);
		});
	}

	function ___R$$priv$project$rome$$internal$fs$index_ts$promisifyData(
		path,
		factory,
	) {
		return ___R$$priv$project$rome$$internal$fs$index_ts$wrapReject(
			new Promise((resolve, reject) => {
				factory(
					path.join(),
					(err, data) => {
						if (err === null) {
							resolve(data);
						} else {
							reject(err);
						}
					},
				);
			}),
			2,
		);
	}

	function ___R$$priv$project$rome$$internal$fs$index_ts$promisifyVoid(
		path,
		factory,
	) {
		return ___R$$priv$project$rome$$internal$fs$index_ts$wrapReject(
			new Promise((resolve, reject) => {
				factory(
					path.join(),
					(err) => {
						if (err === null) {
							resolve();
						} else {
							reject(err);
						}
					},
				);
			}),
			2,
		);
	}

	// watch
	function ___R$project$rome$$internal$fs$index_ts$watch(
		path,
		options,
		listener,
	) {
		return ___R$$priv$project$rome$$internal$fs$index_ts$fs.watch(
			path.join(),
			options,
			listener,
		);
	}

	function ___R$project$rome$$internal$fs$index_ts$readFile(path) {
		return ___R$$priv$project$rome$$internal$fs$index_ts$promisifyData(
			path,
			(filename, callback) =>
				___R$$priv$project$rome$$internal$fs$index_ts$fs.readFile(
					filename,
					callback,
				)
			,
		);
	}

	async function ___R$project$rome$$internal$fs$index_ts$readFileText(path) {
		return (await ___R$project$rome$$internal$fs$index_ts$readFile(path)).toString();
	}

	async function ___R$project$rome$$internal$fs$index_ts$readFileTextMeta(path) {
		return {
			input: (await ___R$project$rome$$internal$fs$index_ts$readFile(path)).toString(),
			path,
		};
	}

	function ___R$project$rome$$internal$fs$index_ts$writeFile(path, content) {
		return ___R$$priv$project$rome$$internal$fs$index_ts$promisifyVoid(
			path,
			(filename, callback) =>
				___R$$priv$project$rome$$internal$fs$index_ts$fs.writeFile(
					filename,
					content,
					callback,
				)
			,
		);
	}

	function ___R$project$rome$$internal$fs$index_ts$copyFile(src, dest) {
		return ___R$$priv$project$rome$$internal$fs$index_ts$promisifyVoid(
			src,
			(src, callback) =>
				___R$$priv$project$rome$$internal$fs$index_ts$fs.copyFile(
					src,
					dest.join(),
					callback,
				)
			,
		);
	}

	// readdir
	function ___R$$priv$project$rome$$internal$fs$index_ts$createReaddirReturn(
		directory,
		files,
	) {
		return new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet(
			files.sort().map((basename) => {
				return directory.append(basename);
			}),
		);
	}

	function ___R$project$rome$$internal$fs$index_ts$readDirectory(path) {
		return ___R$$priv$project$rome$$internal$fs$index_ts$wrapReject(
			new Promise((resolve, reject) => {
				___R$$priv$project$rome$$internal$fs$index_ts$fs.readdir(
					path.join(),
					(err, files) => {
						if (err === null) {
							resolve(
								___R$$priv$project$rome$$internal$fs$index_ts$createReaddirReturn(
									path,
									files,
								),
							);
						} else {
							reject(err);
						}
					},
				);
			}),
			1,
		);
	}

	function ___R$project$rome$$internal$fs$index_ts$lstat(path) {
		return ___R$$priv$project$rome$$internal$fs$index_ts$promisifyData(
			path,
			(filename, callback) =>
				___R$$priv$project$rome$$internal$fs$index_ts$fs.lstat(
					filename,
					callback,
				)
			,
		);
	}

	function ___R$project$rome$$internal$fs$index_ts$exists(path) {
		return new Promise((resolve) => {
			___R$$priv$project$rome$$internal$fs$index_ts$fs.exists(
				path.join(),
				(exists) => {
					resolve(exists);
				},
			);
		});
	}

	function ___R$project$rome$$internal$fs$index_ts$removeFile(path) {
		return ___R$$priv$project$rome$$internal$fs$index_ts$promisifyVoid(
			path,
			(filename, callback) =>
				___R$$priv$project$rome$$internal$fs$index_ts$fs.unlink(
					filename,
					(err) => {
						if (err != null && err.code !== "ENOENT") {
							callback(err);
						} else {
							callback(null);
						}
					},
				)
			,
		);
	}

	async function ___R$project$rome$$internal$fs$index_ts$removeDirectory(path) {
		// Delete all inner files
		for (const subpath of await ___R$project$rome$$internal$fs$index_ts$readDirectory(
			path,
		)) {
			const stats = await ___R$project$rome$$internal$fs$index_ts$lstat(subpath);
			if (stats.isDirectory()) {
				await ___R$project$rome$$internal$fs$index_ts$removeDirectory(subpath);
			} else {
				await ___R$project$rome$$internal$fs$index_ts$removeFile(subpath);
			}
		}

		// Remove directory with all files deleted
		return ___R$$priv$project$rome$$internal$fs$index_ts$promisifyVoid(
			path,
			(filename, callback) =>
				___R$$priv$project$rome$$internal$fs$index_ts$fs.rmdir(
					filename,
					callback,
				)
			,
		);
	}

	function ___R$project$rome$$internal$fs$index_ts$createDirectory(path) {
		return ___R$$priv$project$rome$$internal$fs$index_ts$promisifyVoid(
			path,
			(filename, callback) =>
				___R$$priv$project$rome$$internal$fs$index_ts$fs.mkdir(
					filename,
					{
						recursive: true,
					},
					callback,
				)
			,
		);
	}

	function ___R$project$rome$$internal$fs$index_ts$openFile(
		path,
		flags = "r",
		mode,
	) {
		return ___R$$priv$project$rome$$internal$fs$index_ts$fs.promises.open(
			path.join(),
			flags,
			mode,
		);
	}

	function ___R$project$rome$$internal$fs$index_ts$openDirectory(
		path,
		opts = {},
	) {
		return ___R$$priv$project$rome$$internal$fs$index_ts$promisifyData(
			path,
			(filename, callback) =>
				___R$$priv$project$rome$$internal$fs$index_ts$fs.opendir(
					filename,
					opts,
					callback,
				)
			,
		);
	}

	function ___R$project$rome$$internal$fs$index_ts$createWriteStream(path, opts) {
		return ___R$$priv$project$rome$$internal$fs$index_ts$fs.createWriteStream(
			path.join(),
			opts,
		);
	}

	function ___R$project$rome$$internal$fs$index_ts$createReadStream(path, opts) {
		return ___R$$priv$project$rome$$internal$fs$index_ts$fs.createReadStream(
			path.join(),
			opts,
		);
	}

	function ___R$project$rome$$internal$fs$index_ts$readFileTextSync(path) {
		return ___R$$priv$project$rome$$internal$fs$index_ts$fs.readFileSync(
			path.join(),
			"utf8",
		);
	}

	function ___R$project$rome$$internal$fs$index_ts$lstatSync(path) {
		return ___R$$priv$project$rome$$internal$fs$index_ts$fs.lstatSync(
			path.join(),
		);
	}


  // project-rome/@internal/codec-semver/compare.ts
function ___R$$priv$project$rome$$internal$codec$semver$compare_ts$compareIdentifiers(
		a,
		b,
	) {
		// Equal
		if (b === undefined) {
			return 0;
		}

		if (typeof a === "string" || typeof b === "string") {
			// @ts-ignore: built-in def is not restrictive enough
			return String(a).localeCompare(String(b));
		}

		// Less than
		if (a < b) {
			return -1;
		}

		// Greater than
		if (a > b) {
			return 1;
		}

		// Equal
		return 0;
	}

	function ___R$$priv$project$rome$$internal$codec$semver$compare_ts$compareMain(
		version,
		range,
	) {
		return (
			___R$$priv$project$rome$$internal$codec$semver$compare_ts$compareIdentifiers(
				version.major,
				range.major,
			) ||
			___R$$priv$project$rome$$internal$codec$semver$compare_ts$compareIdentifiers(
				version.minor,
				range.minor,
			) ||
			___R$$priv$project$rome$$internal$codec$semver$compare_ts$compareIdentifiers(
				version.patch,
				range.patch,
			)
		);
	}

	function ___R$$priv$project$rome$$internal$codec$semver$compare_ts$comparePre(
		version,
		range,
	) {
		// NOT having a prerelease is > having one
		if (version.prerelease.length > 0 && range.prerelease.length === 0) {
			return -1;
		} else if (version.prerelease.length === 0 && range.prerelease.length > 0) {
			return 1;
		} else if (version.prerelease.length === 0 && range.prerelease.length === 0) {
			return 0;
		}

		let i = 0;
		do {
			const a = version.prerelease[i];
			const b = range.prerelease[i];

			if (a === undefined && b === undefined) {
				return 0;
			} else if (b === undefined) {
				return 1;
			} else if (a === undefined) {
				return -1;
			} else if (a === b) {
				continue;
			} else {
				return ___R$$priv$project$rome$$internal$codec$semver$compare_ts$compareIdentifiers(
					a,
					b,
				);
			}
		} while (++i);

		throw new Error("Unreachable");
	}

	function ___R$project$rome$$internal$codec$semver$compare_ts$compareFromAst(
		version,
		range,
	) {
		return (
			___R$$priv$project$rome$$internal$codec$semver$compare_ts$compareMain(
				version,
				range,
			) ||
			___R$$priv$project$rome$$internal$codec$semver$compare_ts$comparePre(
				version,
				range,
			)
		);
	}


  // project-rome/@internal/codec-semver/satisfies.ts
function ___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$buildVersion(
		major,
		minor,
		patch,
	) {
		return {
			type: "WildcardVersion",
			major,
			minor,
			patch,
			prerelease: [],
			build: [],
		};
	}

	function ___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$compareOp(
		op,
		version,
		range,
	) {
		if (range.type === "Wildcard") {
			return true;
		}

		switch (op) {
			case "=":
				return (
					___R$project$rome$$internal$codec$semver$compare_ts$compareFromAst(
						version,
						range,
					) === 0
				);

			case "<":
				return (
					___R$project$rome$$internal$codec$semver$compare_ts$compareFromAst(
						version,
						range,
					) < 0
				);

			case ">":
				return (
					___R$project$rome$$internal$codec$semver$compare_ts$compareFromAst(
						version,
						range,
					) > 0
				);

			case ">=":
				return (
					___R$project$rome$$internal$codec$semver$compare_ts$compareFromAst(
						version,
						range,
					) >= 0
				);

			case "<=":
				return (
					___R$project$rome$$internal$codec$semver$compare_ts$compareFromAst(
						version,
						range,
					) <= 0
				);

			case "^": {
				// Make sure that the version isn't less than the range
				if (
					!___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$compareOp(
						">=",
						version,
						range,
					)
				) {
					return false;
				}

				// Deconstruct the range
				const {major, minor, patch} = range;

				if (major === 0) {
					if (minor === 0) {
						// ^0.0.3 := >=0.0.3 <0.0.4
						// @ts-ignore
						return ___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$compareOp(
							"<",
							version,
							___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$buildVersion(
								0,
								0,
								patch + 1,
							),
						);
					} else {
						// ^0.2.3 := >=0.2.3 <0.3.0
						// @ts-ignore
						return ___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$compareOp(
							"<",
							version,
							___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$buildVersion(
								0,
								minor + 1,
								0,
							),
						);
					}
				}

				// ^1.2.3 := >=1.2.3 <2.0.0

				// @ts-ignore
				return ___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$compareOp(
					"<",
					version,
					___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$buildVersion(
						major + 1,
						0,
						0,
					),
				);
			}

			case "~>":
			case "~": {
				// Make sure that the version isn't less than the range
				if (
					!___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$compareOp(
						">=",
						version,
						range,
					)
				) {
					return false;
				}

				// Deconstruct the range
				const {major, minor} = range;

				if (minor === undefined) {
					// ~1 := >=1.0.0 <(1+1).0.0 := >=1.0.0 <2.0.0 (Same as 1.x)
					// @ts-ignore
					return ___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$compareOp(
						"<",
						version,
						___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$buildVersion(
							major + 1,
							minor,
							0,
						),
					);
				}

				// ~1.2.3 := >=1.2.3 <1.(2+1).0 := >=1.2.3 <1.3.0
				return ___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$compareOp(
					"<",
					version,
					___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$buildVersion(
						major,
						minor + 1,
						0,
					),
				);
			}

			default:
				throw new Error("Unknown operator " + op);
		}
	}

	function ___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$inRange(
		version,
		left,
		right,
	) {
		if (left.type === "Wildcard" || right.type === "Wildcard") {
			return true;
		}

		return (
			___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$compareOp(
				">=",
				version,
				left,
			) &&
			___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$compareOp(
				"<=",
				version,
				right,
			)
		);
	}

	function ___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$collectVersions(
		range,
	) {
		switch (range.type) {
			case "AbsoluteVersion":
			case "WildcardVersion":
				return [range];

			case "Wildcard":
				return [];

			case "Comparator":
				return ___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$collectVersions(
					range.version,
				);

			case "LogicalAnd":
			case "LogicalOr":
			case "VersionRange":
				return [
					...___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$collectVersions(
						range.left,
					),
					...___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$collectVersions(
						range.right,
					),
				];

			default:
				throw new Error("Unknown range type");
		}
	}

	function ___R$project$rome$$internal$codec$semver$satisfies_ts$satisfiesFromAst(
		version,
		range,
	) {
		const res = ___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$satisfiesSub(
			version,
			range,
		);
		if (!res) {
			return false;
		}

		if (version.prerelease.length > 0) {
			// Find the set of versions that are allowed to have prereleases
			// For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
			// That should allow `1.2.3-pr.2` to pass.
			// However, `1.2.4-alpha.notready` should NOT be allowed,
			// even though it's within the range set by the comparators.
			const versions = ___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$collectVersions(
				range,
			);

			for (const comparator of versions) {
				if (comparator.prerelease.length > 0) {
					if (
						comparator.major === version.major &&
						comparator.minor === version.minor &&
						comparator.patch === version.patch
					) {
						return true;
					}
				}
			}

			// Version has a -pre, but it's not one of the ones we like.
			return false;
		}

		return true;
	}

	function ___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$satisfiesSub(
		version,
		range,
	) {
		switch (range.type) {
			case "AbsoluteVersion":
			case "WildcardVersion":
				return ___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$compareOp(
					"=",
					version,
					range,
				);

			case "Wildcard":
				return true;

			case "Comparator":
				return ___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$compareOp(
					range.operator,
					version,
					range.version,
				);

			case "LogicalAnd":
				return (
					___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$satisfiesSub(
						version,
						range.left,
					) &&
					___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$satisfiesSub(
						version,
						range.right,
					)
				);

			case "LogicalOr":
				return (
					___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$satisfiesSub(
						version,
						range.left,
					) ||
					___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$satisfiesSub(
						version,
						range.right,
					)
				);

			case "VersionRange":
				return (
					___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$inRange(
						version,
						range.left,
						range.right,
					) ||
					___R$$priv$project$rome$$internal$codec$semver$satisfies_ts$inRange(
						version,
						range.right,
						range.left,
					)
				);
		}
	}


  // project-rome/@internal/codec-semver/parse.ts
const ___R$$priv$project$rome$$internal$codec$semver$parse_ts$createSemverParser = ___R$project$rome$$internal$parser$core$utils_ts$createParser({
		diagnosticCategory: "parse/semver",
		normalizeInput: (input) => input.trimRight(),
		tokenize(parser, index) {
			const char = parser.getInputCharOnly(index);
			const nextChar = parser.getInputCharOnly(index, 1);

			if (
				(char === "<" && nextChar === "=") ||
				(char === ">" && nextChar === "=") ||
				(char === "~" && nextChar === ">")
			) {
				// @ts-ignore: TS doesn't infer the possible combinations
				const value = char + nextChar;
				return parser.finishValueToken(
					"Operator",
					value,
					___R$project$rome$$internal$ob1$index_ts$ob1Add(index, 2),
				);
			}

			if (
				char === "^" ||
				char === "<" ||
				char === ">" ||
				char === "~" ||
				char === "="
			) {
				const op = char;
				return parser.finishValueToken("Operator", op);
			}

			if (char === "|" && nextChar === "|") {
				return parser.finishToken(
					"Pipe",
					___R$project$rome$$internal$ob1$index_ts$ob1Add(index, 2),
				);
			}

			if (char === "*") {
				return parser.finishToken("Star");
			}

			if (
				parser.getInputCharOnly(index, -1) === " " &&
				char === "-" &&
				nextChar === " "
			) {
				return parser.finishToken("RangeDash");
			}

			if (char === "-") {
				return parser.finishToken("Dash");
			}

			if (char === "+") {
				return parser.finishToken("Plus");
			}

			if (char === ".") {
				return parser.finishToken("Dot");
			}

			if (___R$project$rome$$internal$parser$core$utils_ts$isDigit(char)) {
				const [value] = parser.readInputFrom(
					index,
					___R$project$rome$$internal$parser$core$utils_ts$isDigit,
				);
				return parser.finishValueToken(
					"Number",
					Number(value),
					___R$project$rome$$internal$ob1$index_ts$ob1Add(index, value.length),
				);
			}

			if (___R$project$rome$$internal$parser$core$utils_ts$isAlpha(char)) {
				const [value] = parser.readInputFrom(
					index,
					___R$project$rome$$internal$parser$core$utils_ts$isAlpha,
				);
				return parser.finishValueToken(
					"Word",
					value,
					___R$project$rome$$internal$ob1$index_ts$ob1Add(index, value.length),
				);
			}

			if (char === " " || char === "\t") {
				return parser.finishToken("Space");
			}

			// Unknown character
			return undefined;
		},
	});

	// Remove all subsequent space tokens
	function ___R$$priv$project$rome$$internal$codec$semver$parse_ts$eatSpaceToken(
		parser,
	) {
		while (parser.eatToken("Space") !== undefined) {
			// empty
		}
	}

	function ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseVersionOrWildcard(
		parser,
	) {
		const startPos = parser.getPosition();
		const startToken = parser.getToken();
		const version = ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseVersion(
			parser,
		);

		// We should return a bare wildcard when parsed in a version position if there was nothing else attached
		if (
			___R$$priv$project$rome$$internal$codec$semver$parse_ts$isWildcardToken(
				parser,
				startToken,
			) &&
			version.minor === undefined &&
			version.patch === undefined &&
			version.prerelease.length === 0 &&
			version.build.length === 0
		) {
			return {
				type: "Wildcard",
				loc: parser.finishLoc(startPos),
			};
		}

		return version;
	}

	function ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseVersion(
		parser,
	) {
		const startPos = parser.getPosition();
		const startToken = parser.getToken();

		if (
			___R$$priv$project$rome$$internal$codec$semver$parse_ts$isVersionCharacter(
				parser,
				startToken,
			)
		) {
			parser.nextToken();
		}

		const major = ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseVersionNumber(
			parser,
		);
		let minor = undefined;
		let patch = undefined;

		if (parser.eatToken("Dot")) {
			minor = ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseVersionNumber(
				parser,
			);
		} else if (parser.meta.mode === "version") {
			throw parser.unexpected({
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SEMVER.MISSING_MINOR_VERSION,
			});
		}

		if (parser.eatToken("Dot")) {
			patch = ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseVersionNumber(
				parser,
			);
		} else if (parser.meta.mode === "version") {
			throw parser.unexpected({
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SEMVER.MISSING_PATCH_VERSION,
			});
		}

		if (parser.matchToken("Dot")) {
			throw parser.unexpected({
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SEMVER.EXCESSIVE_VERSION_PARTS,
			});
		}

		// The dash is optional in loose mode. eg. 1.2.3pre
		let prerelease = [];
		if (
			parser.eatToken("Dash") ||
			(parser.options.loose && parser.matchToken("Word"))
		) {
			prerelease = ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseVersionQualifierParts(
				parser,
			);
		}

		let build = [];
		if (parser.eatToken("Plus")) {
			build = ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseVersionQualifierParts(
				parser,
			);
		}

		if (major !== undefined && minor !== undefined && patch !== undefined) {
			return {
				type: "AbsoluteVersion",
				loc: parser.finishLoc(startPos),
				major,
				minor,
				patch,
				prerelease,
				build,
			};
		} else {
			return {
				type: "WildcardVersion",
				loc: parser.finishLoc(startPos),
				major,
				minor,
				patch,
				prerelease,
				build,
			};
		}
	}

	function ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseVersionQualifierParts(
		parser,
	) {
		const parts = [];
		do {
			parts.push(
				___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseVersionQualifierPart(
					parser,
				),
			);
		} while (parser.eatToken("Dot") !== undefined);
		return parts;
	}

	function ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseVersionQualifierPart(
		parser,
	) {
		const parts = [];

		do {
			const token = parser.getToken();

			if (token.type === "Number" || token.type === "Word") {
				parser.nextToken();
				parts.push(token.value);
			} else if (token.type === "Dash") {
				parser.nextToken();
				parts.push("-");
			} else if (parser.options.loose && token.type === "Star") {
				// https://github.com/romefrontend/rome/issues/295
				parser.nextToken();
				parts.push("*");
			} else {
				throw parser.unexpected({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SEMVER.INVALID_QUANTIFIER_PART,
				});
			}
		} while (
			parser.matchToken("Number") ||
			parser.matchToken("Word") ||
			parser.matchToken("Dash")
		);

		if (parts.length === 1 && typeof parts[0] === "number") {
			return parts[0];
		} else {
			return parts.join("");
		}
	}

	function ___R$$priv$project$rome$$internal$codec$semver$parse_ts$isWildcardToken(
		parser,
		token,
	) {
		if (token.type === "Star") {
			return true;
		}

		if (token.type === "Word") {
			return token.value === "x" || token.value === "X";
		}

		return false;
	}

	function ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseVersionNumber(
		parser,
	) {
		const token = parser.getToken();

		if (token.type === "Number") {
			parser.nextToken();
			return token.value;
		}

		if (
			___R$$priv$project$rome$$internal$codec$semver$parse_ts$isWildcardToken(
				parser,
				token,
			)
		) {
			if (parser.meta.mode === "version") {
				throw parser.unexpected({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SEMVER.WILDCARD_IN_VERSION,
				});
			}

			parser.nextToken();
		} else {
			throw parser.unexpected({
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SEMVER.INVALID_VERSION_NUMBER,
			});
		}

		return undefined;
	}

	function ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseLogicalOr(
		parser,
		left,
	) {
		parser.nextToken();
		___R$$priv$project$rome$$internal$codec$semver$parse_ts$eatSpaceToken(
			parser,
		);

		const right = ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseExpression(
			parser,
		);
		return {
			loc: parser.finishLoc(parser.getLoc(left).start),
			type: "LogicalOr",
			left,
			right,
		};
	}

	function ___R$$priv$project$rome$$internal$codec$semver$parse_ts$validateRangeSide(
		parser,
		node,
	) {
		// In loose mode, we allow ranges to be a bare wildcard instead of a version
		// eg. * - 1.2.3
		if (node.type === "WildcardVersion" || node.type === "AbsoluteVersion") {
			return node;
		}

		if (node.type === "Wildcard" && parser.options.loose) {
			return node;
		}

		throw parser.unexpected(
			Object.assign(
				{},
				___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SEMVER.INVALID_RANGE,
				{start: parser.getLoc(node).start},
			),
		);
	}

	function ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseVersionRange(
		parser,
		left,
	) {
		parser.nextToken();
		___R$$priv$project$rome$$internal$codec$semver$parse_ts$eatSpaceToken(
			parser,
		);

		const right = ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseVersionOrWildcard(
			parser,
		);

		return {
			type: "VersionRange",
			loc: parser.finishLoc(parser.getLoc(left).start),
			left: ___R$$priv$project$rome$$internal$codec$semver$parse_ts$validateRangeSide(
				parser,
				left,
			),
			right: ___R$$priv$project$rome$$internal$codec$semver$parse_ts$validateRangeSide(
				parser,
				right,
			),
		};
	}

	function ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseWildcard(
		parser,
	) {
		const startPos = parser.getPosition();
		parser.nextToken();
		return {type: "Wildcard", loc: parser.finishLoc(startPos)};
	}

	function ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseAtomOperator(
		parser,
		token,
	) {
		const startPos = parser.getPosition();
		parser.nextToken();
		___R$$priv$project$rome$$internal$codec$semver$parse_ts$eatSpaceToken(
			parser,
		);

		const version = ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseVersionOrWildcard(
			parser,
		);

		return {
			type: "Comparator",
			loc: parser.finishLoc(startPos),
			operator: token.value,
			version,
		};
	}

	function ___R$$priv$project$rome$$internal$codec$semver$parse_ts$isVersionCharacter(
		parser,
		token,
	) {
		if (parser.options.loose && token.type === "Word") {
			return token.value === "v";
		}

		return false;
	}

	function ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseAtomStartPipe(
		parser,
	) {
		if (parser.options.loose) {
			// A bare pipe in an atom start position is treated the same as a wildcard...
			// Why...? Because node-semver allows it lol
			// > satisfies('1.2.3', '||') === true
			return ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseWildcard(
				parser,
			);
		} else {
			throw parser.unexpected({
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SEMVER.BARE_PIPE_WITHOUT_LOOSE,
			});
		}
	}

	function ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseAtomStartWord(
		parser,
		token,
	) {
		if (
			___R$$priv$project$rome$$internal$codec$semver$parse_ts$isWildcardToken(
				parser,
				token,
			)
		) {
			return ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseWildcard(
				parser,
			);
		} else if (
			___R$$priv$project$rome$$internal$codec$semver$parse_ts$isVersionCharacter(
				parser,
				token,
			)
		) {
			return ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseVersion(
				parser,
			);
		} else {
			throw parser.unexpected({
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SEMVER.UNEXPECTED_WORD(
					token.value,
				),
			});
		}
	}

	function ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseAtom(
		parser,
	) {
		const token = parser.getToken();

		switch (token.type) {
			case "Number":
				return ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseVersion(
					parser,
				);

			case "Operator":
				return ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseAtomOperator(
					parser,
					token,
				);

			case "Star":
				return ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseWildcard(
					parser,
				);

			case "Pipe":
				return ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseAtomStartPipe(
					parser,
				);

			case "Word":
				return ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseAtomStartWord(
					parser,
					token,
				);

			default:
				throw parser.unexpected({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SEMVER.UNKNOWN_START,
				});
		}
	}

	function ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseLogicalAnd(
		parser,
		left,
	) {
		const right = ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseExpression(
			parser,
		);

		return {
			type: "LogicalAnd",
			left,
			right,
			loc: {
				filename: parser.filename,
				start: parser.getLoc(left).start,
				end: parser.getLoc(right).end,
			},
		};
	}

	function ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseExpression(
		parser,
	) {
		const left = ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseAtom(
			parser,
		);
		___R$$priv$project$rome$$internal$codec$semver$parse_ts$eatSpaceToken(
			parser,
		);

		if (parser.matchToken("RangeDash")) {
			return ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseVersionRange(
				parser,
				left,
			);
		}

		if (parser.matchToken("Pipe")) {
			return ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseLogicalOr(
				parser,
				left,
			);
		}

		if (!parser.matchToken("EOF")) {
			return ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseLogicalAnd(
				parser,
				left,
			);
		}

		return left;
	}

	function ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseInitialRange(
		parser,
	) {
		// Allow spaces at the beginning, spaces at the end have been removed by the trimRight in the constructor
		___R$$priv$project$rome$$internal$codec$semver$parse_ts$eatSpaceToken(
			parser,
		);

		// Empty string is an implicit wildcard in loose mode
		if (parser.matchToken("EOF") && parser.options.loose) {
			return ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseWildcard(
				parser,
			);
		}

		const expr = ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseExpression(
			parser,
		);
		parser.finalize();

		return expr;
	}

	function ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseInitialVersion(
		parser,
	) {
		const node = ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseInitialRange(
			parser,
		);

		// Verify the return value in version mode
		if (node.type !== "AbsoluteVersion") {
			throw parser.unexpected(
				Object.assign(
					{},
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SEMVER.EXPECTED_VERSION,
					{start: parser.getLoc(node).start},
				),
			);
		}

		return node;
	}

	function ___R$project$rome$$internal$codec$semver$parse_ts$parseSemverRange(
		opts,
	) {
		return ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseInitialRange(
			___R$$priv$project$rome$$internal$codec$semver$parse_ts$createSemverParser(
				opts,
				{mode: "range"},
			),
		);
	}

	function ___R$project$rome$$internal$codec$semver$parse_ts$parseSemverVersion(
		opts,
	) {
		return ___R$$priv$project$rome$$internal$codec$semver$parse_ts$parseInitialVersion(
			___R$$priv$project$rome$$internal$codec$semver$parse_ts$createSemverParser(
				opts,
				{mode: "version"},
			),
		);
	}


  // project-rome/@internal/codec-semver/utils.ts
function ___R$project$rome$$internal$codec$semver$utils_ts$normalizeUserVersion(
		ver,
		opts,
	) {
		if (typeof ver === "string") {
			return ___R$project$rome$$internal$codec$semver$parse_ts$parseSemverVersion(
				Object.assign({}, opts, {input: ver}),
			);
		} else if (ver.type === "AbsoluteVersion") {
			return ver;
		} else {
			throw new Error("Not a valid version: " + ver.type);
		}
	}

	function ___R$project$rome$$internal$codec$semver$utils_ts$normalizeUserRange(
		range,
		opts,
	) {
		if (typeof range === "string") {
			return ___R$project$rome$$internal$codec$semver$parse_ts$parseSemverRange(
				Object.assign({}, opts, {input: range}),
			);
		} else {
			return range;
		}
	}


  // project-rome/@internal/codec-semver/stringify.ts
// Remove all
	function ___R$$priv$project$rome$$internal$codec$semver$stringify_ts$compactRight(
		parts,
	) {
		for (let i = parts.length - 1; i >= 0; i--) {
			const part = parts[i];
			if (part !== undefined) {
				return parts.slice(0, i + 1);
			}
		}

		return [];
	}

	const ___R$$priv$project$rome$$internal$codec$semver$stringify_ts$WILDCARD = "*";

	function ___R$project$rome$$internal$codec$semver$stringify_ts$default(node) {
		switch (node.type) {
			case "WildcardVersion":
			case "AbsoluteVersion": {
				// Build up x.x.x format
				let str = ___R$$priv$project$rome$$internal$codec$semver$stringify_ts$compactRight([
					node.major,
					node.minor,
					node.patch,
				]).map((part) =>
					part == null
						? ___R$$priv$project$rome$$internal$codec$semver$stringify_ts$WILDCARD
						: part
				).join(".");

				// add on qualifiers
				if (node.prerelease.length > 0) {
					str += "-" + node.prerelease.join(".");
				}
				if (node.build.length > 0) {
					str += "+" + node.build.join(".");
				}
				return str;
			}

			case "Wildcard":
				return ___R$$priv$project$rome$$internal$codec$semver$stringify_ts$WILDCARD;

			case "Comparator":
				return (
					"" +
					node.operator +
					___R$project$rome$$internal$codec$semver$stringify_ts$default(
						node.version,
					)
				);

			case "LogicalAnd":
				return (
					___R$project$rome$$internal$codec$semver$stringify_ts$default(
						node.left,
					) +
					" " +
					___R$project$rome$$internal$codec$semver$stringify_ts$default(
						node.right,
					)
				);

			case "LogicalOr":
				return (
					___R$project$rome$$internal$codec$semver$stringify_ts$default(
						node.left,
					) +
					" || " +
					___R$project$rome$$internal$codec$semver$stringify_ts$default(
						node.right,
					)
				);

			case "VersionRange":
				return (
					___R$project$rome$$internal$codec$semver$stringify_ts$default(
						node.left,
					) +
					" - " +
					___R$project$rome$$internal$codec$semver$stringify_ts$default(
						node.right,
					)
				);
		}
	}


  // project-rome/@internal/codec-semver/index.ts
function ___R$project$rome$$internal$codec$semver$index_ts$sortSemverVersions(
		rawVersions,
		opts,
	) {
		const versions = rawVersions.map((ver) =>
			___R$project$rome$$internal$codec$semver$utils_ts$normalizeUserVersion(
				ver,
				opts,
			)
		);
		return versions.sort((a, b) =>
			___R$project$rome$$internal$codec$semver$compare_ts$compareFromAst(a, b)
		);
	}

	function ___R$project$rome$$internal$codec$semver$index_ts$maxSatisfyingSemver(
		rawVersions,
		rawRange,
		opts,
	) {
		const versions = ___R$project$rome$$internal$codec$semver$index_ts$sortSemverVersions(
			rawVersions,
			opts,
		).reverse();
		const range = ___R$project$rome$$internal$codec$semver$utils_ts$normalizeUserRange(
			rawRange,
			opts,
		);

		for (const version of versions) {
			if (
				___R$project$rome$$internal$codec$semver$satisfies_ts$satisfiesFromAst(
					version,
					range,
				)
			) {
				return version;
			}
		}

		return undefined;
	}

	function ___R$project$rome$$internal$codec$semver$index_ts$minSatisfyingSemver(
		rawVersions,
		rawRange,
		opts,
	) {
		const versions = ___R$project$rome$$internal$codec$semver$index_ts$sortSemverVersions(
			rawVersions,
			opts,
		);
		const range = ___R$project$rome$$internal$codec$semver$utils_ts$normalizeUserRange(
			rawRange,
			opts,
		);

		for (const version of versions) {
			if (
				___R$project$rome$$internal$codec$semver$satisfies_ts$satisfiesFromAst(
					version,
					range,
				)
			) {
				return version;
			}
		}

		return undefined;
	}

	function ___R$project$rome$$internal$codec$semver$index_ts$satisfiesSemver(
		rawVersion,
		rawRange,
		opts,
	) {
		try {
			const version = ___R$project$rome$$internal$codec$semver$utils_ts$normalizeUserVersion(
				rawVersion,
				opts,
			);
			const range = ___R$project$rome$$internal$codec$semver$utils_ts$normalizeUserRange(
				rawRange,
				opts,
			);
			return ___R$project$rome$$internal$codec$semver$satisfies_ts$satisfiesFromAst(
				version,
				range,
			);
		} catch (err) {
			if (
				err instanceof
				___R$project$rome$$internal$diagnostics$errors_ts$DiagnosticsError
			) {
				return false;
			} else {
				throw err;
			}
		}
	}


  // project-rome/@internal/project/load.ts
const ___R$project$rome$$internal$project$load_ts = {
		loadCompleteProjectConfig: ___R$project$rome$$internal$project$load_ts$loadCompleteProjectConfig,
		normalizeProjectConfig: ___R$project$rome$$internal$project$load_ts$normalizeProjectConfig,
	};
	const ___R$$priv$project$rome$$internal$project$load_ts$crypto = require(
		"crypto",
	);
	const ___R$$priv$project$rome$$internal$project$load_ts$IGNORE_FILENAMES = [
		".gitignore",
		".hgignore",
	];

	function ___R$$priv$project$rome$$internal$project$load_ts$categoryExists(
		consumer,
	) {
		if (!consumer.exists()) {
			return false;
		}

		const value = consumer.asUnknown();
		if (typeof value === "boolean") {
			consumer.unexpected(
				___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.PROJECT_CONFIG.BOOLEAN_CATEGORY(
					value,
				),
			);
			return false;
		}

		return true;
	}

	async function ___R$project$rome$$internal$project$load_ts$loadCompleteProjectConfig(
		projectDirectory,
		configPath,
	) {
		// TODO use consumer.capture somehow here to aggregate errors
		const {partial, meta} = await ___R$$priv$project$rome$$internal$project$load_ts$loadPartialProjectConfig(
			projectDirectory,
			configPath,
		);
		const {consumer} = meta;

		// Produce a defaultConfig with some directory specific values
		const _defaultConfig = ___R$project$rome$$internal$project$types_ts$createDefaultProjectConfig();
		const defaultConfig = Object.assign(
			{},
			_defaultConfig,
			{vcs: Object.assign({}, _defaultConfig.vcs, {root: projectDirectory})},
		);

		const name = consumer.get("name").asString(
			"project-" + projectDirectory.getBasename(),
		);

		const config = Object.assign(
			{},
			defaultConfig,
			{
				name,
				root: partial.root === undefined ? defaultConfig.root : partial.root,
			},
			___R$$priv$project$rome$$internal$project$load_ts$mergePartialConfig(
				defaultConfig,
				partial,
			),
		);

		// Infer VCS ignore files as lint ignore rules
		for (const filename of ___R$$priv$project$rome$$internal$project$load_ts$IGNORE_FILENAMES) {
			const possiblePath = config.vcs.root.append(filename);
			meta.configDependencies.add(possiblePath);

			if (await ___R$project$rome$$internal$fs$index_ts$exists(possiblePath)) {
				const file = await ___R$project$rome$$internal$fs$index_ts$readFileText(
					possiblePath,
				);

				consumer.handleThrownDiagnostics(() => {
					const patterns = ___R$project$rome$$internal$path$match$parse_ts$parsePatternsFile({
						input: file,
						path: possiblePath,
					});

					// TODO: Maybe these are useful in other places?
					config.lint.ignore = [...config.lint.ignore, ...patterns];
				});
			}
		}

		return {
			config,
			meta,
		};
	}

	async function ___R$$priv$project$rome$$internal$project$load_ts$loadPartialProjectConfig(
		projectDirectory,
		configPath,
	) {
		const configFile = await ___R$project$rome$$internal$fs$index_ts$readFileText(
			configPath,
		);
		const res = ___R$project$rome$$internal$codec$json$index_ts$consumeJSONExtra({
			path: configPath,
			input: configFile,
		});

		return ___R$project$rome$$internal$project$load_ts$normalizeProjectConfig(
			res,
			configPath,
			configFile,
			projectDirectory,
		);
	}

	async function ___R$project$rome$$internal$project$load_ts$normalizeProjectConfig(
		res,
		configPath,
		configFile,
		projectDirectory,
	) {
		let {consumer} = res;

		let configSourceSubKey;
		let name;
		const isInPackageJson = configPath.getBasename() === "package.json";
		if (isInPackageJson) {
			// Infer name from package.json
			name = consumer.get("name").asStringOrVoid();

			consumer = consumer.get(
				___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_PACKAGE_JSON_FIELD,
			);
			configSourceSubKey = ___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_PACKAGE_JSON_FIELD;
		}

		const hash = ___R$$priv$project$rome$$internal$project$load_ts$crypto.createHash(
			"sha256",
		).update(configFile).digest("hex");

		const config = {
			compiler: {},
			bundler: {},
			cache: {},
			lint: {},
			resolver: {},
			develop: {},
			typeCheck: {},
			tests: {},
			files: {},
			vcs: {},
			dependencies: {},
			targets: new Map(),
		};

		if (name !== undefined) {
			config.name = name;
		}

		const meta = {
			projectDirectory,
			configPath,
			consumer,
			consumersChain: [consumer],
			configHashes: [hash],
			configSourceSubKey,
			configDependencies: ___R$project$rome$$internal$project$utils_ts$getParentConfigDependencies(
				projectDirectory,
			),
		};

		// We never use `name` here but it's used in `loadCompleteProjectConfig`
		consumer.markUsedProperty("name");

		if (consumer.has("version")) {
			const version = consumer.get("version");

			consumer.handleThrownDiagnostics(() => {
				config.version = ___R$project$rome$$internal$codec$semver$parse_ts$parseSemverRange({
					path: consumer.filename,
					input: version.asString(),
					offsetPosition: version.getLocation("inner-value").start,
				});

				// TODO verify that config.version range satisfies current version
			});
		}

		if (consumer.has("root")) {
			config.root = consumer.get("root").asBoolean();
		}

		const cache = consumer.get("cache");
		if (___R$$priv$project$rome$$internal$project$load_ts$categoryExists(cache)) {
			// TODO
		}

		const resolver = consumer.get("resolver");
		if (
			___R$$priv$project$rome$$internal$project$load_ts$categoryExists(resolver)
		) {
			// TODO
		}

		const bundler = consumer.get("bundler");
		if (
			___R$$priv$project$rome$$internal$project$load_ts$categoryExists(bundler)
		) {
			if (bundler.has("externals")) {
				config.bundler.externals = ___R$project$rome$$internal$project$utils_ts$arrayOfStrings(
					bundler.get("externals"),
				);
			}
		}

		const typeChecking = consumer.get("typeChecking");
		if (
			___R$$priv$project$rome$$internal$project$load_ts$categoryExists(
				typeChecking,
			)
		) {
			if (typeChecking.has("enabled")) {
				config.typeCheck.enabled = typeChecking.get("enabled").asBoolean();
			}

			if (typeChecking.has("libs")) {
				const libs = await ___R$$priv$project$rome$$internal$project$load_ts$normalizeTypeCheckingLibs(
					projectDirectory,
					typeChecking.get("libs"),
				);
				config.typeCheck.libs = libs.files;
				meta.configDependencies = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet([
					...meta.configDependencies,
					...libs.directories,
					...libs.files,
				]);
			}
		}

		const dependencies = consumer.get("dependencies");
		if (
			___R$$priv$project$rome$$internal$project$load_ts$categoryExists(
				dependencies,
			)
		) {
			if (dependencies.has("enabled")) {
				config.dependencies.enabled = dependencies.get("dependencies").asBoolean();
			}
		}

		const lint = consumer.get("lint");
		if (___R$$priv$project$rome$$internal$project$load_ts$categoryExists(lint)) {
			if (lint.has("ignore")) {
				config.lint.ignore = ___R$project$rome$$internal$project$utils_ts$arrayOfPatterns(
					lint.get("ignore"),
				);
			}

			if (lint.has("globals")) {
				config.lint.globals = ___R$project$rome$$internal$project$utils_ts$arrayOfStrings(
					lint.get("globals"),
				);
			}
		}

		const tests = consumer.get("tests");
		if (___R$$priv$project$rome$$internal$project$load_ts$categoryExists(tests)) {
			if (tests.has("ignore")) {
				config.tests.ignore = ___R$project$rome$$internal$project$utils_ts$arrayOfPatterns(
					tests.get("ignore"),
				);
			}
		}

		const develop = consumer.get("develop");
		if (
			___R$$priv$project$rome$$internal$project$load_ts$categoryExists(develop)
		) {
			if (develop.has("serveStatic")) {
				config.develop.serveStatic = develop.get("serveStatic").asBoolean();
			}
		}

		const files = consumer.get("files");
		if (___R$$priv$project$rome$$internal$project$load_ts$categoryExists(files)) {
			if (files.has("vendorPath")) {
				config.files.vendorPath = projectDirectory.resolve(
					files.get("vendorPath").asString(),
				);
			}

			if (files.has("maxSize")) {
				config.files.maxSize = files.get("maxSize").asNumber();
			}

			if (files.has("assetExtensions")) {
				config.files.assetExtensions = files.get("assetExtensions").asMappedArray((
					item,
				) => item.asString());
			}
		}

		const vcs = consumer.get("vcs");
		if (___R$$priv$project$rome$$internal$project$load_ts$categoryExists(vcs)) {
			if (vcs.has("root")) {
				config.vcs.root = projectDirectory.resolve(vcs.get("root").asString());
			}
		}

		const compiler = consumer.get("compiler");
		if (
			___R$$priv$project$rome$$internal$project$load_ts$categoryExists(compiler)
		) {
			// TODO
		}

		const targets = consumer.get("targets");
		if (
			___R$$priv$project$rome$$internal$project$load_ts$categoryExists(targets)
		) {
			for (const [name, object] of targets.asMap()) {
				const target = {
					constraints: object.get("constraints").asImplicitMappedArray((item) =>
						item.asString()
					),
				};
				object.enforceUsedProperties("config target property");
				config.targets.set(name, target);
			}
		}

		// Need to get this before enforceUsedProperties so it will be flagged
		const _extends = consumer.get("extends");

		// Flag unknown properties
		consumer.enforceUsedProperties("config property");

		if (_extends.exists()) {
			return await ___R$$priv$project$rome$$internal$project$load_ts$extendProjectConfig(
				projectDirectory,
				_extends,
				config,
				meta,
			);
		}

		return {
			partial: config,
			meta,
		};
	}

	async function ___R$$priv$project$rome$$internal$project$load_ts$normalizeTypeCheckingLibs(
		projectDirectory,
		consumer,
	) {
		const libFiles = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet();

		// Normalize library directories
		const directories = ___R$project$rome$$internal$project$utils_ts$arrayOfStrings(
			consumer,
		).map((libDirectory) => projectDirectory.resolve(libDirectory));

		// Crawl library directories and add their files
		for (const directory of directories) {
			const files = await ___R$project$rome$$internal$fs$index_ts$readDirectory(
				directory,
			);
			for (const file of files) {
				const stats = await ___R$project$rome$$internal$fs$index_ts$lstat(file);
				if (stats.isFile()) {
					libFiles.add(file);
				} else if (stats.isDirectory()) {
					directories.push(file);
				}
			}
		}

		return {
			files: libFiles,
			directories,
		};
	}

	async function ___R$$priv$project$rome$$internal$project$load_ts$extendProjectConfig(
		projectDirectory,
		extendsStrConsumer,
		config,
		meta,
	) {
		const extendsRelative = extendsStrConsumer.asString();

		if (extendsRelative === "parent") {
			// TODO maybe do some magic here?
		}

		const extendsPath = projectDirectory.resolve(extendsRelative);
		const {partial: extendsObj, meta: extendsMeta} = await ___R$$priv$project$rome$$internal$project$load_ts$loadPartialProjectConfig(
			extendsPath.getParent(),
			extendsPath,
		);

		// Check for recursive config
		if (extendsMeta.configDependencies.has(meta.configPath)) {
			throw extendsStrConsumer.unexpected(
				___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.PROJECT_CONFIG.RECURSIVE_CONFIG,
			);
		}

		const merged = ___R$$priv$project$rome$$internal$project$load_ts$mergePartialConfig(
			extendsObj,
			config,
		);

		const lintIgnore = ___R$project$rome$$internal$project$utils_ts$mergeArrays(
			extendsObj.lint.ignore,
			config.lint.ignore,
		);
		if (lintIgnore !== undefined) {
			merged.lint.ignore = lintIgnore;
		}

		const lintGlobals = ___R$project$rome$$internal$project$utils_ts$mergeArrays(
			extendsObj.lint.globals,
			config.lint.globals,
		);
		if (lintGlobals !== undefined) {
			merged.lint.globals = lintGlobals;
		}

		const testingIgnore = ___R$project$rome$$internal$project$utils_ts$mergeArrays(
			extendsObj.tests.ignore,
			config.tests.ignore,
		);
		if (testingIgnore !== undefined) {
			merged.tests.ignore = testingIgnore;
		}

		const typeCheckingLibs = ___R$project$rome$$internal$project$utils_ts$mergeAbsoluteFilePathSets(
			extendsObj.typeCheck.libs,
			config.typeCheck.libs,
		);
		if (typeCheckingLibs !== undefined) {
			merged.typeCheck.libs = typeCheckingLibs;
		}

		const bundlerExternals = ___R$project$rome$$internal$project$utils_ts$mergeArrays(
			extendsObj.bundler.externals,
			config.bundler.externals,
		);
		if (bundlerExternals !== undefined) {
			merged.bundler.externals = bundlerExternals;
		}

		return {
			partial: merged,
			meta: Object.assign(
				{},
				meta,
				{
					consumersChain: [
						...meta.consumersChain,
						...extendsMeta.consumersChain,
					],
					configDependencies: new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet([
						...meta.configDependencies,
						...extendsMeta.configDependencies,
						extendsPath,
					]),
					configHashes: [...meta.configHashes, ...extendsMeta.configHashes],
				},
			),
		};
	}

	function ___R$$priv$project$rome$$internal$project$load_ts$mergePartialConfig(
		a,
		b,
	) {
		return {
			cache: Object.assign({}, a.cache, b.cache),
			compiler: Object.assign({}, a.compiler, b.compiler),
			lint: Object.assign({}, a.lint, b.lint),
			develop: Object.assign({}, a.develop, b.develop),
			bundler: Object.assign({}, a.bundler, b.bundler),
			dependencies: Object.assign({}, a.dependencies, b.dependencies),
			resolver: Object.assign({}, a.resolver, b.resolver),
			typeCheck: Object.assign({}, a.typeCheck, b.typeCheck),
			tests: Object.assign({}, a.tests, b.tests),
			files: Object.assign({}, a.files, b.files),
			vcs: Object.assign({}, a.vcs, b.vcs),
			targets: new Map([...a.targets.entries(), ...b.targets.entries()]),
		};
	}


  // project-rome/@internal/project/index.ts



  // project-rome/@internal/ast-utils/removeLoc.ts
function ___R$$priv$project$rome$$internal$ast$utils$removeLoc_ts$removeProp(
		obj,
	) {
		const ___R$ = obj;
		const locless = Object.assign({}, ___R$);
		delete locless.loc;
		const {loc} = ___R$;
		loc;
		return locless;
	}

	const ___R$$priv$project$rome$$internal$ast$utils$removeLoc_ts$removeLocTransform = [
		{
			name: "removeLocTransform",
			enter(path) {
				const {node} = path;

				if (node.loc === undefined) {
					return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
				} else {
					const newNode = ___R$$priv$project$rome$$internal$ast$utils$removeLoc_ts$removeProp(
						node,
					);

					// Also remove any `undefined` properties
					// rome-ignore lint/ts/noExplicitAny: future cleanup
					const escaped = newNode;
					for (const key in newNode) {
						if (escaped[key] === undefined) {
							// rome-ignore lint/js/noDelete: future cleanup
							delete escaped[key];
						}
					}

					return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
						(newNode),
					);
				}
			},
		},
	];

	function ___R$project$rome$$internal$ast$utils$removeLoc_ts$removeLoc(ast) {
		const context = new ___R$project$rome$$internal$compiler$lib$CompilerContext_ts$default({
			ast: ___R$project$rome$$internal$ast$js$core$JSRoot_ts$MOCK_PROGRAM,
			project: {
				directory: undefined,
				config: ___R$project$rome$$internal$project$types_ts$createDefaultProjectConfig(),
			},
		});
		return context.reduce(
			ast,
			___R$$priv$project$rome$$internal$ast$utils$removeLoc_ts$removeLocTransform,
		);
	}


  // project-rome/@internal/ast-utils/index.ts



  // project-rome/@internal/compiler/transforms/helpers/index.ts
function ___R$project$rome$$internal$compiler$transforms$helpers$index_ts$injectBinding(
		path,
		name = path.scope.generateUid(),
		init,
	) {
		const ref = ___R$project$rome$$internal$ast$js$expressions$JSReferenceIdentifier_ts$jsReferenceIdentifier.quick(
			name,
		);

		// lol
		const ass = ___R$project$rome$$internal$ast$js$patterns$JSAssignmentIdentifier_ts$jsAssignmentIdentifier.quick(
			name,
		);

		path.context.getVisitorState(
			___R$project$rome$$internal$compiler$transforms$helpers$index_ts$variableInjectorVisitor,
		).set(
			(state) => {
				return {
					bindings: [...state.bindings, [name, init]],
				};
			},
			{
				required: true,
			},
		);

		return [ref, ass];
	}

	const ___R$project$rome$$internal$compiler$transforms$helpers$index_ts$variableInjectorVisitor = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "variableInjector",
		enter(path, state) {
			const {node} = path;

			if (node.type === "JSBlockStatement" || node.type === "JSRoot") {
				state.reset({bindings: []});
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},

		exit(path, state) {
			const {node} = path;

			if (node.type === "JSBlockStatement" || node.type === "JSRoot") {
				const {bindings} = state.get();
				if (bindings.length === 0) {
					return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
				}

				return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
					Object.assign(
						{},
						node,
						{
							body: [
								___R$project$rome$$internal$ast$js$statements$JSVariableDeclarationStatement_ts$jsVariableDeclarationStatement.quick(
									___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclaration_ts$jsVariableDeclaration.create({
										kind: "var",
										declarations: bindings.map(([name, init]) => {
											return ___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclarator_ts$jsVariableDeclarator.create({
												id: ___R$project$rome$$internal$ast$js$patterns$JSBindingIdentifier_ts$jsBindingIdentifier.quick(
													name,
												),
												init,
											});
										}),
									}),
								),
								...node.body,
							],
						},
					),
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});

	function ___R$project$rome$$internal$compiler$transforms$helpers$index_ts$injectComment(
		path,
		comment,
	) {
		let commentWithId;
		const {id} = comment;

		if (id === undefined) {
			commentWithId = path.context.comments.createComment(comment);
		} else {
			// This comment already has an id so update it
			commentWithId = Object.assign({}, comment, {id});
			path.context.comments.updateComment(commentWithId);
		}

		path.context.getVisitorState(
			___R$project$rome$$internal$compiler$transforms$helpers$index_ts$commentInjectorVisitor,
		).set(
			(state) => {
				let comments = state.comments;

				if (id !== undefined) {
					// Remove from existing comments
					comments = comments.filter((comment) => comment.id !== id);
				}

				return {
					comments: [...comments, commentWithId],
				};
			},
			{
				required: true,
			},
		);

		return commentWithId.id;
	}

	const ___R$project$rome$$internal$compiler$transforms$helpers$index_ts$commentInjectorVisitor = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "commentInjector",

		enter(path, state) {
			const {node, context} = path;

			if (node.type === "CommentBlock" || node.type === "CommentLine") {
				context.comments.updateComment(node);
			}

			if (___R$project$rome$$internal$ast$utils$isRoot_ts$isRoot(node)) {
				context.comments.setComments(node.comments);
				state.reset({comments: []});
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},

		exit(path, state) {
			const {node} = path;

			if (
				___R$project$rome$$internal$ast$utils$isRoot_ts$isRoot(node) &&
				state.owns()
			) {
				const {comments} = state.get();
				if (comments.length > 0) {
					return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
						Object.assign({}, node, {comments: [...node.comments, ...comments]}),
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/transforms/compile/transpile/callSpread.ts
const ___R$project$rome$$internal$compiler$transforms$compile$transpile$callSpread_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "callSpread",
		enter(path) {
			const {node} = path;

			if (node.type === "JSCallExpression") {
				let func = node.callee;

				// Impossible to transform a bare super call
				if (func.type === "JSSuper") {
					return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
				}

				let hasSpread = false;
				for (const arg of node.arguments) {
					if (arg.type === "JSSpreadElement") {
						hasSpread = true;
						break;
					}
				}
				if (hasSpread) {
					let prepend;

					let object;
					if (func.type === "JSMemberExpression") {
						const injection = ___R$project$rome$$internal$compiler$transforms$helpers$index_ts$injectBinding(
							path,
						);
						object = injection[0];

						prepend = ___R$project$rome$$internal$ast$js$expressions$JSAssignmentExpression_ts$jsAssignmentExpression.create({
							operator: "=",
							left: injection[1],
							right: func.object,
						});

						func = ___R$project$rome$$internal$ast$js$expressions$JSMemberExpression_ts$jsMemberExpression.create({
							object,
							property: func.property,
						});
					} else {
						object = ___R$project$rome$$internal$ast$js$literals$JSNullLiteral_ts$jsNullLiteral.create({

						});
					}

					let call = {
						type: "JSCallExpression",
						loc: node.loc,
						callee: ___R$project$rome$$internal$js$ast$utils$template_ts$template.expression`${func}.apply`,
						arguments: [
							object,
							___R$project$rome$$internal$ast$js$expressions$JSArrayExpression_ts$jsArrayExpression.create({
								elements: node.arguments,
							}),
						],
					};

					if (prepend === undefined) {
						return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
							call,
						);
					} else {
						return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
							___R$project$rome$$internal$ast$js$expressions$JSSequenceExpression_ts$jsSequenceExpression.create({
								expressions: [prepend, call],
							}),
						);
					}
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/transforms/compile/transpile/templateLiterals.ts
const ___R$project$rome$$internal$compiler$transforms$compile$transpile$templateLiterals_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsTemplateLiterals",
		enter(path) {
			const {node, parent} = path;

			if (node.type === "JSTaggedTemplateExpression") {
				// TODO
			}

			if (
				node.type === "JSTemplateLiteral" &&
				parent.type !== "JSTaggedTemplateExpression"
			) {
				const nodes = [];
				const {expressions, quasis} = node;

				let index = 0;
				for (const elem of quasis) {
					if (elem.cooked) {
						nodes.push(
							___R$project$rome$$internal$ast$js$literals$JSStringLiteral_ts$jsStringLiteral.create({
								value: elem.cooked,
							}),
						);
					}

					if (index < expressions.length) {
						const expr = expressions[index++];
						if (expr.type !== "JSStringLiteral" || expr.value !== "") {
							nodes.push(expr);
						}
					}
				}

				if (nodes.length === 0) {
					return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
						___R$project$rome$$internal$ast$js$literals$JSStringLiteral_ts$jsStringLiteral.quick(
							"",
						),
					);
				}

				if (nodes.length === 1) {
					return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
						nodes[0],
					);
				}

				// Since `+` is left-to-right associative, nsure the first node is a string if first/second isn't
				if (
					nodes[0].type !== "JSStringLiteral" &&
					nodes[1].type !== "JSStringLiteral"
				) {
					nodes.unshift(
						___R$project$rome$$internal$ast$js$literals$JSStringLiteral_ts$jsStringLiteral.quick(
							"",
						),
					);
				}

				// Build the final expression
				let root = nodes[0];
				for (let i = 1; i < nodes.length; i++) {
					root = ___R$project$rome$$internal$ast$js$expressions$JSBinaryExpression_ts$jsBinaryExpression.create({
						operator: "+",
						left: root,
						right: nodes[i],
					});
				}
				return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
					root,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/transforms/compile/transpile/objectSpread.ts
function ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$objectSpread_ts$hasSpreadProperty(
		props,
	) {
		for (const prop of props) {
			if (prop.type === "JSSpreadProperty") {
				return true;
			}
		}
		return false;
	}

	function ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$objectSpread_ts$getRestProperty(
		node,
	) {
		if (node === undefined) {
			return undefined;
		}

		switch (node.type) {
			case "JSVariableDeclarator":
				return ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$objectSpread_ts$getRestProperty(
					node.id,
				);

			case "JSVariableDeclarationStatement":
				return ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$objectSpread_ts$getRestProperty(
					node.declaration,
				);

			case "JSVariableDeclaration": {
				for (const declarator of node.declarations) {
					const rest = ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$objectSpread_ts$getRestProperty(
						declarator,
					);
					if (rest !== undefined) {
						return rest;
					}
				}
				return undefined;
			}

			case "JSBindingObjectPattern":
				return node.rest;
		}

		return undefined;
	}

	function ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$objectSpread_ts$transformSpreadProperty(
		path,
		node,
	) {
		let props = [];
		const assignArgs = [];

		function pushProps() {
			if (props.length === 0 && assignArgs.length > 0) {
				return;
			}

			assignArgs.push(
				___R$project$rome$$internal$ast$js$objects$JSObjectExpression_ts$jsObjectExpression.create({
					properties: props,
				}),
			);

			props = [];
		}

		for (const prop of node.properties) {
			if (prop.type === "JSSpreadProperty") {
				pushProps();
				assignArgs.push(prop.argument);
			} else {
				props.push(prop);
			}
		}

		pushProps();

		return ___R$project$rome$$internal$ast$js$expressions$JSCallExpression_ts$jsCallExpression.create({
			callee: ___R$project$rome$$internal$js$ast$utils$template_ts$template.expression`Object.assign`,
			arguments: assignArgs,
		});
	}

	function ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$objectSpread_ts$transformRestProperty(
		path,
		node,
	) {
		const nodes = [];

		for (const declarator of node.declarations) {
			const restElem = ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$objectSpread_ts$getRestProperty(
				declarator,
			);

			if (
				restElem === undefined ||
				declarator.id.type !== "JSBindingObjectPattern"
			) {
				nodes.push(
					___R$project$rome$$internal$ast$js$statements$JSVariableDeclarationStatement_ts$jsVariableDeclarationStatement.quick(
						___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclaration_ts$jsVariableDeclaration.create({
							kind: node.kind,
							declarations: [declarator],
						}),
					),
				);
				continue;
			}

			const uid = path.scope.generateUid();

			// push on the initial declaration so we can reference it later
			nodes.push(
				___R$project$rome$$internal$ast$js$statements$JSVariableDeclarationStatement_ts$jsVariableDeclarationStatement.quick(
					___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclaration_ts$jsVariableDeclaration.create({
						kind: node.kind,
						declarations: [
							___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclarator_ts$jsVariableDeclarator.create({
								id: ___R$project$rome$$internal$ast$js$patterns$JSBindingIdentifier_ts$jsBindingIdentifier.create({
									name: uid,
								}),
								init: declarator.init,
							}),
						],
					}),
				),
			);

			// fetch all the previous prop names
			const removeProps = [];
			for (const prop of declarator.id.properties) {
				if (prop.type === "JSBindingObjectPatternProperty") {
					if (
						prop.key.type === "JSComputedPropertyKey" ||
						prop.key.value.type !== "JSIdentifier"
					) {
						throw new Error("unimplemented");
					} else {
						removeProps.push(prop.key.value.name);
					}
				}
			}

			// clone the init to the rest element
			const restName = restElem.name;
			nodes.push(
				___R$project$rome$$internal$ast$js$statements$JSVariableDeclarationStatement_ts$jsVariableDeclarationStatement.quick(
					___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclaration_ts$jsVariableDeclaration.create({
						kind: node.kind,
						declarations: [
							___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclarator_ts$jsVariableDeclarator.create({
								id: ___R$project$rome$$internal$ast$js$patterns$JSBindingIdentifier_ts$jsBindingIdentifier.quick(
									restName,
								),
								init: ___R$project$rome$$internal$js$ast$utils$template_ts$template.expression`Object.assign({}, ${uid})`,
							}),
						],
					}),
				),
			);

			// `delete` the properties
			for (const name of removeProps) {
				nodes.push(
					___R$project$rome$$internal$js$ast$utils$template_ts$template.statement`delete ${restName}.${name};`,
				);
			}

			// push on the initial destructuring without the rest element
			nodes.push(
				___R$project$rome$$internal$ast$js$statements$JSVariableDeclarationStatement_ts$jsVariableDeclarationStatement.quick(
					___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclaration_ts$jsVariableDeclaration.create({
						kind: node.kind,
						declarations: [
							___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclarator_ts$jsVariableDeclarator.create({
								id: ___R$project$rome$$internal$ast$js$patterns$JSBindingObjectPattern_ts$jsBindingObjectPattern.create({
									properties: declarator.id.properties,
									rest: undefined,
								}),
								init: ___R$project$rome$$internal$ast$js$expressions$JSReferenceIdentifier_ts$jsReferenceIdentifier.quick(
									uid,
								),
							}),
						],
					}),
				),
			);
		}

		return nodes;
	}
	const ___R$project$rome$$internal$compiler$transforms$compile$transpile$objectSpread_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "objectSpread",
		enter(path) {
			const {node} = path;

			if (
				node.type === "JSVariableDeclarationStatement" &&
				___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$objectSpread_ts$getRestProperty(
					node,
				) !== undefined
			) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
					___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$objectSpread_ts$transformRestProperty(
						path,
						node.declaration,
					),
				);
			}

			if (
				node.type === "JSObjectExpression" &&
				___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$objectSpread_ts$hasSpreadProperty(
					node.properties,
				)
			) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
					___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$objectSpread_ts$transformSpreadProperty(
						path,
						node,
					),
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/transforms/compile/transpile/enums.ts
function ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$enums_ts$buildEnumWrapper(
		path,
		node,
		id,
		assignments,
	) {
		const call = ___R$project$rome$$internal$ast$js$expressions$JSCallExpression_ts$jsCallExpression.assert(
			___R$project$rome$$internal$js$ast$utils$template_ts$template.expression`(function () { const ${id} = {}; return ${id};})();`,
		);

		const statements = assignments.map((expression) => ({
			type: "JSExpressionStatement",
			expression,
		}));

		const func = ___R$project$rome$$internal$ast$js$expressions$JSFunctionExpression_ts$jsFunctionExpression.assert(
			call.callee,
		);
		const factoryCall = Object.assign(
			{},
			call,
			{
				callee: Object.assign(
					{},
					func,
					{
						body: Object.assign(
							{},
							func.body,
							{body: [func.body.body[0], ...statements, func.body.body[1]]},
						),
					},
				),
			},
		);

		return ___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclaration_ts$jsVariableDeclaration.create({
			kind: "const",
			declarations: [
				___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclarator_ts$jsVariableDeclarator.create({
					id: node.id,
					init: factoryCall,
				}),
			],
		});
	}

	function ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$enums_ts$buildEnumMember(
		isString,
		id,
		name,
		value,
	) {
		return isString
			? ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$enums_ts$buildStringAssignment(
					id,
					name,
					value,
				)
			: ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$enums_ts$buildNumericAssignment(
					id,
					name,
					value,
				);
	}

	function ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$enums_ts$buildNumericAssignment(
		id,
		name,
		value,
	) {
		const nameNode = ___R$project$rome$$internal$ast$js$literals$JSStringLiteral_ts$jsStringLiteral.create({
			value: name,
		});
		return ___R$project$rome$$internal$js$ast$utils$template_ts$template.expression`
		${id}[${id}[${nameNode}] = ${value}] = ${nameNode};
	`;
	}

	function ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$enums_ts$buildStringAssignment(
		id,
		name,
		value,
	) {
		const nameNode = ___R$project$rome$$internal$ast$js$literals$JSStringLiteral_ts$jsStringLiteral.create({
			value: name,
		});
		return ___R$project$rome$$internal$js$ast$utils$template_ts$template.expression`
		${id}[${nameNode}] = ${value};
	`;
	}

	function ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$enums_ts$enumFill(
		path,
		node,
		scope,
		context,
	) {
		const x = ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$enums_ts$translateEnumValues(
			node,
			scope,
			context,
		);
		const assignments = x.map(([memberName, memberValue]) =>
			___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$enums_ts$buildEnumMember(
				typeof memberValue !== "string" &&
				memberValue.type === "JSStringLiteral",
				Object.assign({}, node.id),
				memberName,
				memberValue,
			)
		);
		return ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$enums_ts$buildEnumWrapper(
			path,
			node,
			Object.assign({}, node.id),
			assignments,
		);
	}

	function ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$enums_ts$translateEnumValues(
		node,
		scope,
		context,
	) {
		const seen = new Map();
		let prev = -1;

		return node.members.map((member) => {
			let value;
			const initializer = member.initializer;
			const name =
				member.id.type === "JSIdentifier" ? member.id.name : member.id.value;

			if (initializer) {
				let {value: constValue, bailed} = ___R$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$tryStaticEvaluation(
					initializer,
					scope,
					{
						isNodeValid: (node, resolvedNode) => {
							if (
								node.type === "JSReferenceIdentifier" &&
								resolvedNode.type !== "JSNumericLiteral"
							) {
								context.addNodeDiagnostic(
									member,
									___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.COMPILER.ENUM_COMPUTED_VALUES_UNSUPPORTED,
								);
								return false;
							}
							return true;
						},
					},
				);

				if (bailed && initializer.type === "JSReferenceIdentifier") {
					constValue = seen.get(initializer.name);
				}
				if (constValue !== undefined) {
					seen.set(name, constValue);

					if (typeof constValue === "number") {
						value = ___R$project$rome$$internal$ast$js$literals$JSNumericLiteral_ts$jsNumericLiteral.create({
							value: constValue,
						});
						prev = constValue;
					} else {
						value = ___R$project$rome$$internal$ast$js$literals$JSStringLiteral_ts$jsStringLiteral.create({
							value: String(constValue),
						});
						prev = undefined;
					}
				} else {
					value = initializer;
					prev = undefined;
				}
			} else {
				if (prev !== undefined) {
					prev++;
					value = ___R$project$rome$$internal$ast$js$literals$JSNumericLiteral_ts$jsNumericLiteral.create({
						value: prev,
					});
					seen.set(name, prev);
				} else {
					throw new Error("Enum member must have initializer");
				}
			}

			return [name, value];
		});
	}
	const ___R$project$rome$$internal$compiler$transforms$compile$transpile$enums_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "enums",
		enter(path) {
			const {context, node, scope} = path;

			if (node.type !== "TSEnumDeclaration") {
				return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
			}

			if (node.const) {
				context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.COMPILER.CONST_ENUMS_UNSUPPORTED,
				);
				return ___R$project$rome$$internal$compiler$index_ts$signals.remove;
			}

			if (node.declare) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.remove;
			}

			const fill = ___R$$priv$project$rome$$internal$compiler$transforms$compile$transpile$enums_ts$enumFill(
				path,
				node,
				scope,
				context,
			);

			switch (path.parent.type) {
				case "JSExportLocalDeclaration":
					return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
						fill,
					);

				case "JSBlockStatement":
				case "JSRoot":
					return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
						___R$project$rome$$internal$ast$js$statements$JSVariableDeclarationStatement_ts$jsVariableDeclarationStatement.quick(
							fill,
						),
					);

				default:
					throw new Error("Unexpected enum parent '" + path.parent.type);
			}
		},
	});


  // project-rome/@internal/compiler/transforms/compile/validation/optimizeImports.ts
// TODO: Remove this. This contains React for the following reason:
	//   A user may write: import * as React from 'react';
	//   We will remove the namespace and have only the used specifiers
	//   But the JSX plugin inserts `React.createElement`. Oh no.
	const ___R$$priv$project$rome$$internal$compiler$transforms$compile$validation$optimizeImports_ts$IGNORED_NAMES = [
		"React",
		"react",
	];

	function ___R$$priv$project$rome$$internal$compiler$transforms$compile$validation$optimizeImports_ts$getName(
		node,
	) {
		if (
			node.type !== "JSMemberExpression" &&
			node.type !== "JSXMemberExpression"
		) {
			return undefined;
		}

		const {property} = node;

		if (property.type === "JSComputedMemberProperty") {
			if (property.value.type === "JSStringLiteral") {
				return property.value.value;
			}
		} else {
			if (
				___R$project$rome$$internal$js$ast$utils$isIdentifierish_ts$isIdentifierish(
					property,
				)
			) {
				return property.name;
			}
		}

		return undefined;
	}
	const ___R$project$rome$$internal$compiler$transforms$compile$validation$optimizeImports_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "optimizeImports",
		enter(path) {
			const {node} = path;

			if (node.type !== "JSRoot") {
				return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
			}

			// Check if we have any wildcard imports
			const wildcardImports = new Map();
			const wildcardImportNodeToLocal = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
				"wildcardImportNodeToLocal",
			);
			for (const child of node.body) {
				if (
					child.type === "JSImportDeclaration" &&
					!___R$$priv$project$rome$$internal$compiler$transforms$compile$validation$optimizeImports_ts$IGNORED_NAMES.includes(
						child.source.value,
					) &&
					child.namespaceSpecifier !== undefined
				) {
					const specifier = child.namespaceSpecifier;
					wildcardImports.set(
						specifier.local.name.name,
						{
							binding: path.scope.getBindingAssert(specifier.local.name.name),
							names: new Set(),
							mappings: new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
								"wildcard import mappings",
							),
							references: new Set(),
						},
					);
					wildcardImportNodeToLocal.set(child, specifier.local.name.name);
				}
			}
			if (wildcardImports.size === 0) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
			}

			// - Find all imported names from this namespace
			// - Remove the namespaces that have computed property access
			path.traverse(
				"optimizeImportsWildcardCollector",
				(path) => {
					const {node, parent} = path;
					if (node.type !== "JSReferenceIdentifier") {
						return;
					}

					// Ensure we're referencing a wildcard import
					const wildcardInfo = wildcardImports.get(node.name);
					if (wildcardInfo === undefined) {
						return;
					}

					// Ensure that the binding hasn't been shadowed
					if (path.scope.getBinding(node.name) !== wildcardInfo.binding) {
						return;
					}

					const isComputed =
						parent.type === "JSMemberExpression" &&
						parent.object === node &&
						___R$$priv$project$rome$$internal$compiler$transforms$compile$validation$optimizeImports_ts$getName(
							parent,
						) === undefined;
					const isUnboxed =
						parent.type !== "JSMemberExpression" &&
						parent.type !== "JSXMemberExpression";

					if (isComputed || isUnboxed) {
						// Deopt as we can't follow this
						wildcardImports.delete(node.name);
					} else {
						const name = ___R$$priv$project$rome$$internal$compiler$transforms$compile$validation$optimizeImports_ts$getName(
							parent,
						);
						if (name === undefined) {
							throw new Error("Expected name");
						}
						wildcardInfo.names.add(name);
						wildcardInfo.references.add(parent);
					}
				},
			);
			if (wildcardImports.size === 0) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
			}

			// Populate the `mappings` field with a uid
			for (const info of wildcardImports.values()) {
				for (const name of info.names) {
					info.mappings.set(name, path.scope.generateUid(name));
				}
			}

			return path.reduceSignal({
				name: "optimizeImportWilcards",
				enter(path) {
					const {node} = path;

					// Replace all member expressions with their uids
					if (
						(node.type === "JSMemberExpression" ||
						node.type === "JSXMemberExpression") &&
						___R$project$rome$$internal$js$ast$utils$isIdentifierish_ts$isIdentifierish(
							node.object,
						)
					) {
						const wildcardInfo = wildcardImports.get(node.object.name);
						if (wildcardInfo !== undefined && wildcardInfo.references.has(node)) {
							const name = ___R$$priv$project$rome$$internal$compiler$transforms$compile$validation$optimizeImports_ts$getName(
								node,
							);
							if (name === undefined) {
								throw new Error("Expected name");
							}

							const newName = wildcardInfo.mappings.assert(name);
							if (node.type === "JSXMemberExpression") {
								return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
									___R$project$rome$$internal$ast$js$jsx$JSXIdentifier_ts$jsxIdentifier.quick(
										newName,
									),
								);
							} else {
								return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
									___R$project$rome$$internal$ast$js$expressions$JSReferenceIdentifier_ts$jsReferenceIdentifier.quick(
										newName,
									),
								);
							}
						}
					}

					// Add new specifiers to wildcard import declarations
					if (
						node.type === "JSImportDeclaration" &&
						wildcardImportNodeToLocal.has(node)
					) {
						const local = wildcardImportNodeToLocal.assert(node);

						const wildcardInfo = wildcardImports.get(local);
						if (wildcardInfo === undefined) {
							// We would have deopted earlier
							return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
						}

						// Remove wildcard specifier
						let namedSpecifiers = [...(node.namedSpecifiers || [])];

						// Add on our new mappings
						for (const [imported, local] of wildcardInfo.mappings) {
							namedSpecifiers.push(
								___R$project$rome$$internal$ast$js$modules$JSImportSpecifier_ts$jsImportSpecifier.create({
									imported: ___R$project$rome$$internal$ast$js$auxiliary$JSIdentifier_ts$jsIdentifier.quick(
										imported,
									),
									local: ___R$project$rome$$internal$ast$js$modules$JSImportSpecifierLocal_ts$jsImportSpecifierLocal.quick(
										___R$project$rome$$internal$ast$js$patterns$JSBindingIdentifier_ts$jsBindingIdentifier.quick(
											local,
										),
									),
								}),
							);
						}

						return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
							___R$project$rome$$internal$ast$js$modules$JSImportDeclaration_ts$jsImportDeclaration.create(
								Object.assign(
									{},
									node,
									{namespaceSpecifier: undefined, namedSpecifiers},
								),
							),
						);
					}

					return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
				},
			});
		},
	});


  // project-rome/@internal/compiler/transforms/compile/validation/optimizeExports.ts
const ___R$project$rome$$internal$compiler$transforms$compile$validation$optimizeExports_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "optimizeExports",
		enter(path) {
			const {node} = path;

			// turn `import {a} from 'b'; export {a}`; to `export {a} from 'b';`';
			if (
				node.type === "JSExportLocalDeclaration" &&
				node.exportKind === "value" &&
				node.declaration === undefined &&
				node.specifiers !== undefined
			) {
				const nodes = [];
				const specifiers = [];

				for (const specifier of node.specifiers) {
					if (specifier.type === "JSExportLocalSpecifier") {
						const binding = path.scope.getBinding(specifier.local.name);
						if (
							binding !== undefined &&
							binding instanceof
							___R$project$rome$$internal$compiler$scope$bindings_ts$ImportBinding &&
							binding.meta.type === "name"
						) {
							nodes.push(
								___R$project$rome$$internal$ast$js$modules$JSExportExternalDeclaration_ts$jsExportExternalDeclaration.create({
									namedSpecifiers: [
										___R$project$rome$$internal$ast$js$modules$JSExportExternalSpecifier_ts$jsExportExternalSpecifier.create({
											local: ___R$project$rome$$internal$ast$js$auxiliary$JSIdentifier_ts$jsIdentifier.quick(
												binding.meta.imported,
											),
											exported: specifier.exported,
											loc: specifier.loc,
										}),
									],
									source: ___R$project$rome$$internal$ast$js$literals$JSStringLiteral_ts$jsStringLiteral.quick(
										binding.meta.source,
									),
								}),
							);
						} else {
							specifiers.push(specifier);
						}
					} else {
						// TODO ???
						specifiers.push(specifier);
					}
				}

				if (specifiers.length === node.specifiers.length && nodes.length === 0) {
					return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
				}

				if (specifiers.length !== 0) {
					nodes.push(
						___R$project$rome$$internal$ast$js$modules$JSExportLocalDeclaration_ts$jsExportLocalDeclaration.create({
							specifiers,
						}),
					);
				}

				return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
					nodes,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/transforms/compile/jsx.ts
function ___R$$priv$project$rome$$internal$compiler$transforms$compile$jsx_ts$convertJSXIdentifier(
		path,
	) {
		const {node} = path;

		if (node.type === "JSXReferenceIdentifier") {
			if (node.name === "this") {
				return ___R$project$rome$$internal$ast$js$expressions$JSThisExpression_ts$jsThisExpression.create({

				});
			} else {
				return ___R$project$rome$$internal$ast$js$expressions$JSReferenceIdentifier_ts$jsReferenceIdentifier.create(
					{
						name: node.name,
					},
					node,
				);
			}
		} else if (node.type === "JSXIdentifier") {
			return ___R$project$rome$$internal$ast$js$literals$JSStringLiteral_ts$jsStringLiteral.quick(
				node.name,
			);
		} else if (node.type === "JSXMemberExpression") {
			let prop = ___R$$priv$project$rome$$internal$compiler$transforms$compile$jsx_ts$convertJSXIdentifier(
				path.getChildPath("property"),
			);

			if (prop.type === "JSReferenceIdentifier") {
				return ___R$project$rome$$internal$ast$js$expressions$JSMemberExpression_ts$jsMemberExpression.create({
					object: ___R$$priv$project$rome$$internal$compiler$transforms$compile$jsx_ts$convertJSXIdentifier(
						path.getChildPath("object"),
					),
					property: ___R$project$rome$$internal$ast$js$auxiliary$JSStaticMemberProperty_ts$jsStaticMemberProperty.quick(
						___R$project$rome$$internal$ast$js$auxiliary$JSIdentifier_ts$jsIdentifier.quick(
							prop.name,
						),
					),
				});
			} else {
				return ___R$project$rome$$internal$ast$js$expressions$JSMemberExpression_ts$jsMemberExpression.create({
					object: ___R$$priv$project$rome$$internal$compiler$transforms$compile$jsx_ts$convertJSXIdentifier(
						path.getChildPath("object"),
					),
					property: ___R$project$rome$$internal$ast$js$auxiliary$JSComputedMemberProperty_ts$jsComputedMemberProperty.quick(
						prop,
					),
				});
			}
		} else {
			throw new Error(
				"Received a node of type " +
				node.type +
				", the only node types that should be in this position are JSXIdentifier and JSXMemberExpression",
			);
		}
	}

	function ___R$$priv$project$rome$$internal$compiler$transforms$compile$jsx_ts$convertAttributeValue(
		node,
	) {
		if (node.type === "JSXExpressionContainer") {
			return node.expression;
		} else {
			return node;
		}
	}

	function ___R$$priv$project$rome$$internal$compiler$transforms$compile$jsx_ts$extractName(
		node,
	) {
		if (node.type === "JSXNamespacedName") {
			throw new Error("JSX is not XML blah blah blah");
		} else {
			return ___R$project$rome$$internal$ast$js$jsx$JSXIdentifier_ts$jsxIdentifier.assert(
				node,
			).name;
		}
	}

	function ___R$$priv$project$rome$$internal$compiler$transforms$compile$jsx_ts$convertAttribute(
		node,
	) {
		let valueNode = ___R$$priv$project$rome$$internal$compiler$transforms$compile$jsx_ts$convertAttributeValue(
			node.value ||
			___R$project$rome$$internal$ast$js$literals$JSBooleanLiteral_ts$jsBooleanLiteral.create({
				value: true,
			}),
		);
		if (
			valueNode.type === "JSStringLiteral" &&
			(!node.value || node.value.type !== "JSXExpressionContainer")
		) {
			valueNode = ___R$project$rome$$internal$ast$js$literals$JSStringLiteral_ts$jsStringLiteral.create({
				value: valueNode.value.replace(/\n\s+/g, " "),
			});
		}

		const name = ___R$$priv$project$rome$$internal$compiler$transforms$compile$jsx_ts$extractName(
			node.name,
		);

		if (
			___R$project$rome$$internal$js$ast$utils$isValidIdentifierName_ts$isValidIdentifierName(
				name,
			)
		) {
			const nameNode = ___R$project$rome$$internal$ast$js$auxiliary$JSIdentifier_ts$jsIdentifier.create({
				name,
				loc: ___R$project$rome$$internal$js$ast$utils$inheritLoc_ts$inheritLoc(
					node,
				),
			});

			return ___R$project$rome$$internal$ast$js$objects$JSObjectProperty_ts$jsObjectProperty.create({
				key: ___R$project$rome$$internal$ast$js$objects$JSStaticPropertyKey_ts$jsStaticPropertyKey.quick(
					nameNode,
				),
				value: valueNode,
			});
		} else {
			return ___R$project$rome$$internal$ast$js$objects$JSObjectProperty_ts$jsObjectProperty.create({
				key: ___R$project$rome$$internal$ast$js$objects$JSComputedPropertyKey_ts$jsComputedPropertyKey.quick(
					___R$project$rome$$internal$ast$js$literals$JSStringLiteral_ts$jsStringLiteral.quick(
						name,
					),
				),
				value: valueNode,
			});
		}
	}

	function ___R$$priv$project$rome$$internal$compiler$transforms$compile$jsx_ts$pushProps(
		_props,
		objs,
	) {
		if (!_props.length) {
			return _props;
		}

		objs.push(
			___R$project$rome$$internal$ast$js$objects$JSObjectExpression_ts$jsObjectExpression.create({
				properties: _props,
			}),
		);
		return [];
	}

	function ___R$$priv$project$rome$$internal$compiler$transforms$compile$jsx_ts$buildOpeningElementAttributes(
		attribs,
	) {
		let _props = [];
		const objs = [];

		for (const prop of attribs) {
			if (prop.type === "JSXSpreadAttribute") {
				_props = ___R$$priv$project$rome$$internal$compiler$transforms$compile$jsx_ts$pushProps(
					_props,
					objs,
				);
				objs.push(prop.argument);
			} else {
				_props.push(
					___R$$priv$project$rome$$internal$compiler$transforms$compile$jsx_ts$convertAttribute(
						prop,
					),
				);
			}
		}

		___R$$priv$project$rome$$internal$compiler$transforms$compile$jsx_ts$pushProps(
			_props,
			objs,
		);

		let ret;
		if (objs.length === 1) {
			// only one object
			ret = objs[0];
		} else {
			// looks like we have multiple objects
			if (objs[0].type !== "JSObjectExpression") {
				objs.unshift(
					___R$project$rome$$internal$ast$js$objects$JSObjectExpression_ts$jsObjectExpression.create({
						properties: [],
					}),
				);
			}

			// spread it
			ret = ___R$project$rome$$internal$ast$js$expressions$JSCallExpression_ts$jsCallExpression.create({
				callee: ___R$project$rome$$internal$js$ast$utils$template_ts$template.expression`Object.assign`,
				arguments: objs,
			});
		}

		return ret;
	}

	function ___R$$priv$project$rome$$internal$compiler$transforms$compile$jsx_ts$cleanJSXElementLiteralChild(
		value,
	) {
		const str = ___R$project$rome$$internal$js$ast$utils$cleanJSXText_ts$cleanJSXText(
			value,
		);
		if (str !== "") {
			return ___R$project$rome$$internal$ast$js$literals$JSStringLiteral_ts$jsStringLiteral.quick(
				str,
			);
		} else {
			return undefined;
		}
	}

	function ___R$$priv$project$rome$$internal$compiler$transforms$compile$jsx_ts$buildChildren(
		children,
	) {
		const elems = [];

		for (let child of children) {
			if (child.type === "JSXText") {
				const node = ___R$$priv$project$rome$$internal$compiler$transforms$compile$jsx_ts$cleanJSXElementLiteralChild(
					child.value,
				);
				if (node !== undefined) {
					elems.push(node);
				}
				continue;
			}

			if (child.type === "JSXExpressionContainer") {
				const {expression} = child;
				if (expression.type !== "JSXEmptyExpression") {
					elems.push(child.expression);
				}
				continue;
			}

			if (child.type === "JSXSpreadChild") {
				elems.push(
					___R$project$rome$$internal$ast$js$auxiliary$JSSpreadElement_ts$jsSpreadElement.quick(
						child.expression,
					),
				);
				continue;
			}

			elems.push(child);
		}

		return elems;
	}
	const ___R$project$rome$$internal$compiler$transforms$compile$jsx_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx",
		enter(path) {
			const {node, context, parent} = path;

			if (node.type === "JSXElement") {
				let type = ___R$$priv$project$rome$$internal$compiler$transforms$compile$jsx_ts$convertJSXIdentifier(
					path.getChildPath("name"),
				);

				if (node.name.type === "JSXNamespacedName") {
					// TODO better handle this
					context.addNodeDiagnostic(
						type,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.COMPILER.JSX_NOT_XML,
					);
				}

				let attribs;
				if (node.attributes.length > 0) {
					attribs = ___R$$priv$project$rome$$internal$compiler$transforms$compile$jsx_ts$buildOpeningElementAttributes(
						node.attributes,
					);
				} else {
					attribs = ___R$project$rome$$internal$ast$js$literals$JSNullLiteral_ts$jsNullLiteral.create({

					});
				}

				const call = ___R$project$rome$$internal$ast$js$expressions$JSCallExpression_ts$jsCallExpression.create({
					callee: ___R$project$rome$$internal$js$ast$utils$template_ts$template.expression`React.createElement`,
					arguments: [
						type,
						attribs,
						...___R$$priv$project$rome$$internal$compiler$transforms$compile$jsx_ts$buildChildren(
							node.children,
						),
					],
				});

				// If we're a JSX element child then we need to be wrapped
				if (parent.type === "JSXElement") {
					return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
						___R$project$rome$$internal$ast$js$jsx$JSXExpressionContainer_ts$jsxExpressionContainer.create({
							expression: call,
						}),
					);
				} else {
					return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
						call,
					);
				}
			}

			if (node.type === "JSXFragment") {
				const type = ___R$project$rome$$internal$js$ast$utils$template_ts$template.expression`React.Fragment`;
				const attribs = ___R$project$rome$$internal$js$ast$utils$template_ts$template.expression`null`;
				return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
					___R$project$rome$$internal$ast$js$expressions$JSCallExpression_ts$jsCallExpression.create({
						callee: ___R$project$rome$$internal$js$ast$utils$template_ts$template.expression`React.createElement`,
						arguments: [
							type,
							attribs,
							...___R$$priv$project$rome$$internal$compiler$transforms$compile$jsx_ts$buildChildren(
								node.children,
							),
						],
					}),
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/transforms/compileForBundle/_utils.ts
function ___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getOptions(
		context,
	) {
		const opts = context.options.bundle;
		if (opts === undefined) {
			throw new Error("No bundle options found");
		}
		return opts;
	}

	function ___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrivateName(
		name,
		moduleId,
	) {
		return (
			___R$project$rome$$internal$compiler$constants_ts$SCOPE_PRIVATE_PREFIX +
			"$priv$" +
			___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$normalizeModuleId(
				moduleId,
			) +
			"$" +
			name
		);
	}

	function ___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$normalizeModuleId(
		id,
	) {
		// TODO probably need more stuff in this
		return id.replace(/[\\\/@\-]/g, "$").replace(/[\-.]/g, "_");
	}

	function ___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
		name,
		moduleId,
		opts,
	) {
		const forwarded = opts.resolvedImports[moduleId + ":" + name];
		if (forwarded !== undefined) {
			moduleId = forwarded.id;
			name = forwarded.name;
		}

		return (
			___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(
				___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$normalizeModuleId(
					moduleId,
				),
			) +
			"$" +
			name
		);
	}

	function ___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(
		moduleId,
	) {
		return (
			"" +
			___R$project$rome$$internal$compiler$constants_ts$SCOPE_PRIVATE_PREFIX +
			___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$normalizeModuleId(
				moduleId,
			)
		);
	}

	function ___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getModuleId(
		source,
		opts,
	) {
		return opts.relativeSourcesToModuleId[source];
	}


  // project-rome/@internal/core/common/file-handlers/javascript.ts
const ___R$project$rome$$internal$core$common$file$handlers$javascript_ts$IMPLICIT_JS_EXTENSIONS = [
		"js",
		"ts",
		"tsx",
		"json",
	];

	const ___R$project$rome$$internal$core$common$file$handlers$javascript_ts$JS_EXTENSIONS = [];

	function ___R$$priv$project$rome$$internal$core$common$file$handlers$javascript_ts$buildJSHandler(
		ext,
		syntax,
		sourceTypeJS,
	) {
		___R$project$rome$$internal$core$common$file$handlers$javascript_ts$JS_EXTENSIONS.push(
			ext,
		);

		return {
			ext,
			sourceTypeJS,
			language: "js",
			hasTabs: true,
			capabilities: {
				lint: true,
				format: true,
			},

			async parse({mtime, sourceTypeJS, manifestPath, path, file, worker}) {
				const sourceText = await worker.readFile(file.real);
				const ast = ___R$project$rome$$internal$js$parser$index_ts$parseJS({
					input: sourceText,
					mtime,
					manifestPath,
					path,
					sourceType: sourceTypeJS,
					syntax,
					allowReturnOutsideFunction: sourceTypeJS === "script",
				});
				return {
					sourceText,
					ast,
					astModifiedFromSource: false,
				};
			},
		};
	}

	const ___R$project$rome$$internal$core$common$file$handlers$javascript_ts$jsHandler = ___R$$priv$project$rome$$internal$core$common$file$handlers$javascript_ts$buildJSHandler(
		"js",
		[],
	);
	const ___R$project$rome$$internal$core$common$file$handlers$javascript_ts$jsxHandler = ___R$$priv$project$rome$$internal$core$common$file$handlers$javascript_ts$buildJSHandler(
		"jsx",
		["jsx"],
	);
	const ___R$project$rome$$internal$core$common$file$handlers$javascript_ts$cjsHandler = ___R$$priv$project$rome$$internal$core$common$file$handlers$javascript_ts$buildJSHandler(
		"cjs",
		[],
		"script",
	);
	const ___R$project$rome$$internal$core$common$file$handlers$javascript_ts$mjsHandler = ___R$$priv$project$rome$$internal$core$common$file$handlers$javascript_ts$buildJSHandler(
		"mjs",
		[],
		"module",
	);
	const ___R$project$rome$$internal$core$common$file$handlers$javascript_ts$tsHandler = ___R$$priv$project$rome$$internal$core$common$file$handlers$javascript_ts$buildJSHandler(
		"ts",
		["ts"],
		"module",
	);
	const ___R$project$rome$$internal$core$common$file$handlers$javascript_ts$tsxHandler = ___R$$priv$project$rome$$internal$core$common$file$handlers$javascript_ts$buildJSHandler(
		"tsx",
		["ts", "jsx"],
		"module",
	);


  // project-rome/@internal/core/common/file-handlers/text.ts
const ___R$project$rome$$internal$core$common$file$handlers$text_ts$textHandler = {
		sourceTypeJS: "module",
		language: "unknown",
		hasTabs: false,
		capabilities: {
			lint: false,
			format: false,
		},

		async parse({path, mtime, file, worker}) {
			const src = await worker.readFile(file.real);
			const serial = JSON.stringify(src);
			const sourceText = "export default " + serial + ";";

			return {
				// Shouldn't error
				ast: ___R$project$rome$$internal$js$parser$index_ts$parseJS({
					input: sourceText,
					mtime,
					sourceType: "module",
					path,
				}),
				sourceText,
				astModifiedFromSource: true,
			};
		},
	};


  // project-rome/@internal/core/common/file-handlers/json.ts
// Format these with spaces since npm uses them otherwise it's extremely annoying
	const ___R$$priv$project$rome$$internal$core$common$file$handlers$json_ts$SPACE_WHITELIST = [
		"package.json",
		"package-lock.json",
	];

	const ___R$project$rome$$internal$core$common$file$handlers$json_ts$jsonHandler = {
		ext: "json",
		language: "json",
		hasTabs: true,
		capabilities: {
			lint: false,
			format: true,
		},

		async customFormat(info) {
			const {file, mtime, worker} = info;
			const {uid} = file;

			const real = ___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
				file.real,
			);
			const sourceText = await worker.readFile(real);
			const path = ___R$project$rome$$internal$path$index_ts$createUnknownPath(
				uid,
			);

			let formatted = sourceText;

			if (sourceText.length > 50_000) {
				// Fast path for big JSON files
				___R$project$rome$$internal$codec$json$index_ts$parseJSON({
					path,
					input: sourceText,
					mtime,
				});
			} else {
				const {consumer, comments, hasExtensions} = ___R$project$rome$$internal$codec$json$index_ts$consumeJSONExtra({
					input: sourceText,
					path,
					mtime,
				});

				if (hasExtensions) {
					formatted =
						___R$project$rome$$internal$codec$json$index_ts$stringifyRJSONFromConsumer({
							consumer,
							comments,
						}) + "\n";
				} else {
					formatted =
						String(
							___R$project$rome$$internal$codec$json$index_ts$stringifyJSON(
								consumer.asUnknown(),
								___R$$priv$project$rome$$internal$core$common$file$handlers$json_ts$SPACE_WHITELIST.includes(
									real.getBasename(),
								),
							),
						) + "\n";
				}
			}

			return {
				mtime,
				sourceText,
				diagnostics: [],
				suppressions: [],
				formatted,
			};
		},

		async parse({mtime, path, file, worker}) {
			const src = await worker.readFile(file.real);

			// Parse the JSON to make sure it's valid
			const obj = ___R$project$rome$$internal$codec$json$index_ts$parseJSON({
				path: ___R$project$rome$$internal$path$index_ts$createUnknownPath(
					file.uid,
				),
				input: src,
			});

			const rawJson = JSON.stringify(obj);
			const json = rawJson === undefined ? "undefined" : rawJson;
			const sourceText = "export default " + json + ";";

			return {
				// Shouldn't error
				ast: ___R$project$rome$$internal$js$parser$index_ts$parseJS({
					input: sourceText,
					mtime,
					sourceType: "module",
					path,
				}),
				sourceText,
				astModifiedFromSource: true,
			};
		},
	};

	const ___R$project$rome$$internal$core$common$file$handlers$json_ts$rjsonHandler = Object.assign(
		{},
		___R$project$rome$$internal$core$common$file$handlers$json_ts$jsonHandler,
		{ext: "rjson"},
	);


  // project-rome/@internal/core/common/file-handlers/html.ts
const ___R$project$rome$$internal$core$common$file$handlers$html_ts$IMPLICIT_JS_EXTENSIONS = [
		"js",
		"ts",
		"tsx",
		"json",
	];

	const ___R$project$rome$$internal$core$common$file$handlers$html_ts$htmlHandler = {
		ext: "html",
		language: "html",
		hasTabs: true,
		capabilities: {
			lint: false,
			format: false,
		},

		async parse({mtime, path, file, worker}) {
			const sourceText = await worker.readFile(file.real);
			const ast = ___R$project$rome$$internal$html$parser$index_ts$parseHTML({
				input: sourceText,
				mtime,
				path,
			});
			return {
				sourceText,
				ast,
				astModifiedFromSource: false,
			};
		},
	};

	const ___R$project$rome$$internal$core$common$file$handlers$html_ts$htmHandler = Object.assign(
		{},
		___R$project$rome$$internal$core$common$file$handlers$html_ts$htmlHandler,
		{ext: "htm"},
	);


  // project-rome/@internal/core/common/file-handlers/index.ts
function ___R$project$rome$$internal$core$common$file$handlers$index_ts$inferDiagnosticLanguageFromFilename(
		filename,
		existing,
	) {
		if (existing !== undefined && existing !== "unknown") {
			return existing;
		}
		if (filename !== undefined) {
			const {handler} = ___R$project$rome$$internal$core$common$file$handlers$index_ts$getFileHandlerFromPath(
				___R$project$rome$$internal$path$index_ts$createUnknownPath(filename),
				undefined,
			);
			if (handler !== undefined) {
				return handler.language;
			}
		}

		return "unknown";
	}

	function ___R$project$rome$$internal$core$common$file$handlers$index_ts$getFileHandlerExtensions(
		projectConfig,
	) {
		if (projectConfig === undefined) {
			return [
				...___R$$priv$project$rome$$internal$core$common$file$handlers$index_ts$DEFAULT_HANDLERS.keys(),
			];
		} else {
			return [
				...___R$$priv$project$rome$$internal$core$common$file$handlers$index_ts$DEFAULT_HANDLERS.keys(),
				...projectConfig.files.assetExtensions,
			];
		}
	}

	function ___R$project$rome$$internal$core$common$file$handlers$index_ts$getFileHandlerFromPath(
		path,
		projectConfig,
	) {
		const basename = path.getBasename();

		const match = basename.match(/\.([a-zA-Z]+)$/);
		if (match == null) {
			return {ext: "", handler: undefined};
		}

		const ext = match[1];
		let handler = ___R$$priv$project$rome$$internal$core$common$file$handlers$index_ts$DEFAULT_HANDLERS.get(
			ext,
		);

		// Allow setting custom assert extensions in the project config
		if (
			handler === undefined &&
			projectConfig !== undefined &&
			projectConfig.files.assetExtensions.includes(ext)
		) {
			handler = ___R$$priv$project$rome$$internal$core$common$file$handlers$index_ts$assetHandler;
		}

		return {ext, handler};
	}

	function ___R$project$rome$$internal$core$common$file$handlers$index_ts$getFileHandlerFromPathAssert(
		path,
		projectConfig,
	) {
		const {handler, ext} = ___R$project$rome$$internal$core$common$file$handlers$index_ts$getFileHandlerFromPath(
			path,
			projectConfig,
		);

		if (handler === undefined) {
			throw new Error("No file handler found for '" + path.join() + "'");
		} else {
			return {handler, ext};
		}
	}

	const ___R$project$rome$$internal$core$common$file$handlers$index_ts$ASSET_EXPORT_TEMPORARY_VALUE = "VALUE_INJECTED_BY_BUNDLER";

	const ___R$$priv$project$rome$$internal$core$common$file$handlers$index_ts$assetHandler = Object.assign(
		{},
		___R$project$rome$$internal$core$common$file$handlers$text_ts$textHandler,
		{
			ext: "unknown",
			canHaveScale: true,
			isAsset: true,

			async parse({path}) {
				// This exists just so analyzeDependencies has something to look at
				// When bundling we'll have custom logic in the compiler to handle assets and inject the correct string
				const sourceText =
					"export default '" +
					___R$project$rome$$internal$core$common$file$handlers$index_ts$ASSET_EXPORT_TEMPORARY_VALUE +
					"';";

				return {
					// Shouldn't error
					ast: ___R$project$rome$$internal$js$parser$index_ts$parseJS({
						input: sourceText,
						sourceType: "module",
						path,
					}),
					astModifiedFromSource: true,
					sourceText,
				};
			},
		},
	);

	// Extensions that have a `lint` handler
	const ___R$project$rome$$internal$core$common$file$handlers$index_ts$LINTABLE_EXTENSIONS = [];

	const ___R$project$rome$$internal$core$common$file$handlers$index_ts$FORMATTABLE_EXTENSIONS = [];

	function ___R$$priv$project$rome$$internal$core$common$file$handlers$index_ts$setHandler(
		handler,
	) {
		const {ext} = handler;

		if (handler.capabilities.lint || handler.capabilities.format) {
			___R$project$rome$$internal$core$common$file$handlers$index_ts$LINTABLE_EXTENSIONS.push(
				ext,
			);
		}

		if (handler.capabilities.format) {
			___R$project$rome$$internal$core$common$file$handlers$index_ts$FORMATTABLE_EXTENSIONS.push(
				ext,
			);
		}

		___R$$priv$project$rome$$internal$core$common$file$handlers$index_ts$DEFAULT_HANDLERS.set(
			ext,
			handler,
		);
	}

	const ___R$$priv$project$rome$$internal$core$common$file$handlers$index_ts$DEFAULT_HANDLERS = new Map();

	const ___R$$priv$project$rome$$internal$core$common$file$handlers$index_ts$DEFAULT_ASSET_EXTENSIONS = [
		"css",
		// Images
		"png",
		"jpg",
		"jpeg",
		"gif",
		"svg",
		// Video
		"webm",
		"mp4",
		"m4v",
		"avi",
		"mkv",
		// Audio
		"mp3",
		// Fonts
		"woff",
		"woff2",
		"eot",
		"ttf",
		"otf",
		// YAML
		"yml",
		"yaml",
	];

	for (const ext of ___R$$priv$project$rome$$internal$core$common$file$handlers$index_ts$DEFAULT_ASSET_EXTENSIONS) {
		___R$$priv$project$rome$$internal$core$common$file$handlers$index_ts$setHandler(
			Object.assign(
				{},
				___R$$priv$project$rome$$internal$core$common$file$handlers$index_ts$assetHandler,
				{ext},
			),
		);
	}

	___R$$priv$project$rome$$internal$core$common$file$handlers$index_ts$setHandler(
		___R$project$rome$$internal$core$common$file$handlers$javascript_ts$jsHandler,
	);
	___R$$priv$project$rome$$internal$core$common$file$handlers$index_ts$setHandler(
		___R$project$rome$$internal$core$common$file$handlers$javascript_ts$jsxHandler,
	);
	___R$$priv$project$rome$$internal$core$common$file$handlers$index_ts$setHandler(
		___R$project$rome$$internal$core$common$file$handlers$javascript_ts$cjsHandler,
	);
	___R$$priv$project$rome$$internal$core$common$file$handlers$index_ts$setHandler(
		___R$project$rome$$internal$core$common$file$handlers$javascript_ts$mjsHandler,
	);
	___R$$priv$project$rome$$internal$core$common$file$handlers$index_ts$setHandler(
		___R$project$rome$$internal$core$common$file$handlers$javascript_ts$tsHandler,
	);
	___R$$priv$project$rome$$internal$core$common$file$handlers$index_ts$setHandler(
		___R$project$rome$$internal$core$common$file$handlers$javascript_ts$tsxHandler,
	);
	___R$$priv$project$rome$$internal$core$common$file$handlers$index_ts$setHandler(
		___R$project$rome$$internal$core$common$file$handlers$json_ts$jsonHandler,
	);
	___R$$priv$project$rome$$internal$core$common$file$handlers$index_ts$setHandler(
		___R$project$rome$$internal$core$common$file$handlers$json_ts$rjsonHandler,
	);
	___R$$priv$project$rome$$internal$core$common$file$handlers$index_ts$setHandler(
		___R$project$rome$$internal$core$common$file$handlers$html_ts$htmlHandler,
	);
	___R$$priv$project$rome$$internal$core$common$file$handlers$index_ts$setHandler(
		___R$project$rome$$internal$core$common$file$handlers$html_ts$htmHandler,
	);
	// setHandler(markdownHandler);


  // project-rome/@internal/compiler/transforms/compileForBundle/assetTransform.ts
const ___R$project$rome$$internal$compiler$transforms$compileForBundle$assetTransform_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "asset",
		enter(path) {
			const {node} = path;
			const options = ___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getOptions(
				path.context,
			);

			if (
				node.type === "JSExportDefaultDeclaration" &&
				node.declaration.type === "JSStringLiteral" &&
				node.declaration.value ===
				___R$project$rome$$internal$core$common$file$handlers$index_ts$ASSET_EXPORT_TEMPORARY_VALUE &&
				options.assetPath !== undefined
			) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
					Object.assign(
						{},
						node,
						{
							declaration: Object.assign(
								{},
								node.declaration,
								{value: options.moduleId},
							),
						},
					),
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/transforms/compileForBundle/modern/cjsRootTransform.ts
const ___R$project$rome$$internal$compiler$transforms$compileForBundle$modern$cjsRootTransform_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "cjsRootTransform",
		enter(path) {
			const {node, scope, context} = path;

			const {moduleId} = ___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getOptions(
				context,
			);

			if (node.type === "JSRoot") {
				const mappings = new Map();

				// make all variables private
				for (const [name] of path.scope.getOwnBindings()) {
					mappings.set(
						name,
						___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrivateName(
							name,
							moduleId,
						),
					);
				}

				if (!scope.hasBinding("exports")) {
					mappings.set(
						"exports",
						___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(
							moduleId,
						),
					);
				}

				const newProgram = ___R$project$rome$$internal$js$ast$utils$renameBindings_ts$renameBindings(
					path,
					mappings,
				);
				return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
					newProgram,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/transforms/compileForBundle/modern/esToRefTransform.ts
const ___R$project$rome$$internal$compiler$transforms$compileForBundle$modern$esToRefTransform_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "esToRefTransform",
		enter(path) {
			const {node, scope, context} = path;

			const opts = ___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getOptions(
				context,
			);

			if (node.type === "JSRoot") {
				const mappings = new Map();

				// make all variables private
				for (const [name] of path.scope.getOwnBindings()) {
					mappings.set(
						name,
						___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrivateName(
							name,
							opts.moduleId,
						),
					);
				}

				// map exports and imports and correctly
				for (const child of node.body) {
					if (
						child.type === "JSImportDeclaration" &&
						child.importKind !== "type" &&
						child.importKind !== "typeof"
					) {
						const moduleId = ___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getModuleId(
							child.source.value,
							opts,
						);
						if (moduleId === undefined) {
							continue;
						}

						for (const specifier of ___R$project$rome$$internal$js$ast$utils$getImportSpecifiers_ts$getImportSpecifiers(
							child,
						)) {
							if (specifier.type === "JSImportSpecifier") {
								mappings.set(
									specifier.local.name.name,
									___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
										specifier.imported.name,
										moduleId,
										opts,
									),
								);
							} else if (specifier.type === "JSImportNamespaceSpecifier") {
								mappings.set(
									specifier.local.name.name,
									___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(
										moduleId,
									),
								);
							} else if (specifier.type === "JSImportDefaultSpecifier") {
								mappings.set(
									specifier.local.name.name,
									___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
										"default",
										moduleId,
										opts,
									),
								);
							} else {
								throw new Error("unexpected");
							}
						}
					}

					if (child.type === "JSExportLocalDeclaration") {
						// export const foo = '';
						// export function foo() {}
						for (const {name} of ___R$project$rome$$internal$js$ast$utils$getBindingIdentifiers_ts$getBindingIdentifiers(
							child,
						)) {
							mappings.set(
								name,
								___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
									name,
									opts.moduleId,
									opts,
								),
							);
						}

						// export {foo};
						if (child.specifiers !== undefined) {
							for (const specifier of child.specifiers) {
								const local = specifier.local.name;
								const binding = scope.getBinding(local);
								if (
									binding === undefined ||
									binding instanceof
									___R$project$rome$$internal$compiler$scope$bindings_ts$ImportBinding
								) {
									continue;
								}

								mappings.set(
									local,
									___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
										specifier.exported.name,
										opts.moduleId,
										opts,
									),
								);
							}
						}
					}

					if (child.type === "JSExportDefaultDeclaration") {
						const {declaration: decl} = child;
						if (
							(decl.type === "JSFunctionDeclaration" ||
							decl.type === "JSClassDeclaration") &&
							decl.id !== undefined
						) {
							mappings.set(
								decl.id.name,
								___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
									"default",
									opts.moduleId,
									opts,
								),
							);
						}
					}
				}

				const newProgram = ___R$project$rome$$internal$ast$js$core$JSRoot_ts$jsRoot.assert(
					___R$project$rome$$internal$js$ast$utils$renameBindings_ts$renameBindings(
						path,
						mappings,
					),
				);

				// Get new scope with updated bindings. TODO Maybe `renameBindings` should return the path?
				const newScope = scope.getRootScope().enterEvaluate(newProgram);

				if (opts.moduleAll) {
					// Get all the export names
					const exportNames = new Map();
					for (const child of newProgram.body) {
						if (child.type === "JSExportDefaultDeclaration") {
							exportNames.set(
								"default",
								___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
									"default",
									opts.moduleId,
									opts,
								),
							);
						}

						if (child.type === "JSExportExternalDeclaration") {
							// TODO defaultSpecifier and namespaceSpecifier
							const {source} = child;

							for (const specifier of child.namedSpecifiers) {
								// If this is an external export then use the correct name
								const moduleId = ___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getModuleId(
									source.value,
									opts,
								);
								if (moduleId === undefined) {
									continue;
								}

								const local = ___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
									specifier.local.name,
									moduleId,
									opts,
								);

								exportNames.set(specifier.exported.name, local);
							}
						}

						if (child.type === "JSExportLocalDeclaration") {
							if (child.declaration !== undefined) {
								throw new Error(
									___R$project$rome$$internal$pretty$format$index_ts$pretty`No export declarations should be here as they have been removed by renameBindings. Node: ${child}`,
								);
							}

							const {specifiers} = child;
							if (specifiers !== undefined) {
								for (const specifier of specifiers) {
									// The local binding has already been rewritten by renameBindings if it existed
									exportNames.set(specifier.exported.name, specifier.local.name);
								}
							}
						}
					}

					const exportObjProps = [];

					for (const [exported, local] of exportNames) {
						const binding = newScope.getBinding(local);
						if (binding !== undefined) {
							if (
								binding instanceof
								___R$project$rome$$internal$compiler$scope$bindings_ts$TypeBinding
							) {
								continue;
							}

							if (
								binding instanceof
								___R$project$rome$$internal$compiler$scope$bindings_ts$FunctionBinding
							) {
								exportObjProps.push(
									___R$project$rome$$internal$ast$js$objects$JSObjectProperty_ts$jsObjectProperty.create({
										key: ___R$project$rome$$internal$ast$js$objects$JSStaticPropertyKey_ts$jsStaticPropertyKey.quick(
											___R$project$rome$$internal$ast$js$auxiliary$JSIdentifier_ts$jsIdentifier.quick(
												exported,
											),
										),
										value: ___R$project$rome$$internal$ast$js$expressions$JSReferenceIdentifier_ts$jsReferenceIdentifier.quick(
											local,
										),
									}),
								);
								continue;
							}
						}

						exportObjProps.push(
							___R$project$rome$$internal$ast$js$objects$JSObjectMethod_ts$jsObjectMethod.create({
								kind: "get",
								key: ___R$project$rome$$internal$ast$js$objects$JSStaticPropertyKey_ts$jsStaticPropertyKey.quick(
									___R$project$rome$$internal$ast$js$auxiliary$JSIdentifier_ts$jsIdentifier.quick(
										exported,
									),
								),
								head: ___R$project$rome$$internal$ast$js$auxiliary$JSFunctionHead_ts$jsFunctionHead.quick([]),
								body: ___R$project$rome$$internal$ast$js$statements$JSBlockStatement_ts$jsBlockStatement.create({
									body: [
										___R$project$rome$$internal$ast$js$statements$JSReturnStatement_ts$jsReturnStatement.create({
											argument: ___R$project$rome$$internal$ast$js$expressions$JSReferenceIdentifier_ts$jsReferenceIdentifier.create({
												name: local,
											}),
										}),
									],
								}),
							}),
						);
					}

					const exportObj = ___R$project$rome$$internal$ast$js$objects$JSObjectExpression_ts$jsObjectExpression.create({
						properties: exportObjProps,
					});

					return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
						Object.assign(
							{},
							newProgram,
							{
								type: "JSRoot",
								body: [
									___R$project$rome$$internal$ast$js$statements$JSVariableDeclarationStatement_ts$jsVariableDeclarationStatement.quick(
										___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclaration_ts$jsVariableDeclaration.create({
											kind: "const",
											declarations: [
												___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclarator_ts$jsVariableDeclarator.create({
													id: ___R$project$rome$$internal$ast$js$patterns$JSBindingIdentifier_ts$jsBindingIdentifier.create({
														name: ___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(
															opts.moduleId,
														),
													}),
													init: exportObj,
												}),
											],
										}),
									),
									...newProgram.body,
								],
							},
						),
					);
				} else {
					return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
						newProgram,
					);
				}
			}

			if (node.type === "JSImportDeclaration") {
				// should have already been handled with the JSRoot branch
				return ___R$project$rome$$internal$compiler$index_ts$signals.remove;
			}

			if (node.type === "JSExportDefaultDeclaration") {
				const {declaration} = node;
				if (
					declaration.type === "JSFunctionDeclaration" ||
					declaration.type === "JSClassDeclaration"
				) {
					if (declaration.id === undefined) {
						return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
							Object.assign(
								{},
								node,
								{
									declaration: Object.assign(
										{},
										declaration,
										{
											id: ___R$project$rome$$internal$ast$js$patterns$JSBindingIdentifier_ts$jsBindingIdentifier.create({
												name: ___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
													"default",
													opts.moduleId,
													opts,
												),
											}),
										},
									),
								},
							),
						);
					} else {
						// if the export was named then we'll have already given it the correct name
						return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
							declaration,
						);
					}
				} else {
					return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
						___R$project$rome$$internal$js$ast$utils$template_ts$template.statement`const ${___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
							"default",
							opts.moduleId,
							opts,
						)} = ${declaration};`,
					);
				}
			}

			if (node.type === "JSExportExternalDeclaration") {
				// Remove external exports with a source as they will be resolved correctly and never point here
				return ___R$project$rome$$internal$compiler$index_ts$signals.remove;
			}

			if (node.type === "JSExportLocalDeclaration") {
				const {declaration, specifiers} = node;

				if (specifiers === undefined) {
					if (declaration === undefined) {
						throw new Error(
							"No specifiers or declaration existed, if there's no specifiers then there should be a declaration",
						);
					}
					return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
						declaration,
					);
				} else {
					// Check if any of the specifiers reference a global or import
					// If so, we need to insert declarations for them
					const nodes = [];

					for (const specifier of specifiers) {
						if (specifier.type === "JSExportLocalSpecifier") {
							const binding = path.scope.getBinding(specifier.local.name);

							// TODO we only really need this declaration for global bindings, `analyze()` could detect the exported import and resolvedImports would just work
							if (
								binding === undefined ||
								binding instanceof
								___R$project$rome$$internal$compiler$scope$bindings_ts$ImportBinding
							) {
								nodes.push(
									___R$project$rome$$internal$ast$js$statements$JSVariableDeclarationStatement_ts$jsVariableDeclarationStatement.quick(
										___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclaration_ts$jsVariableDeclaration.create({
											kind: "const",
											declarations: [
												___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclarator_ts$jsVariableDeclarator.create({
													id: ___R$project$rome$$internal$ast$js$patterns$JSBindingIdentifier_ts$jsBindingIdentifier.create({
														name: ___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
															specifier.exported.name,
															opts.moduleId,
															opts,
														),
													}),
													init: ___R$project$rome$$internal$ast$js$expressions$JSReferenceIdentifier_ts$jsReferenceIdentifier.quick(
														specifier.local.name,
													),
												}),
											],
										}),
									),
								);
							}
						} else {
							// TODO ???
						}
					}

					if (nodes.length === 0) {
						return ___R$project$rome$$internal$compiler$index_ts$signals.remove;
					} else {
						return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
							nodes,
						);
					}
				}
			}

			if (node.type === "JSExportAllDeclaration" && opts.moduleAll) {
				const moduleId = ___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getModuleId(
					node.source.value,
					opts,
				);
				if (moduleId === undefined) {
					return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
				}

				const theirNamespace = ___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(
					moduleId,
				);
				const ourNamespace = ___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(
					opts.moduleId,
				);
				return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
					___R$project$rome$$internal$js$ast$utils$template_ts$template.statement`
        Object.keys(${theirNamespace}).forEach(function (key) {
          if (key === 'default') return undefined;
          Object.defineProperty(${ourNamespace}, key, {
            enumerable: true,
            configurable: true,
            get: function get() {
              return ${theirNamespace}[key];
            }
          });
        });
      `,
				);
			}

			if (node.type === "JSExportAllDeclaration" && !opts.moduleAll) {
				// We can remove these, this signature has already been flagged by analyze() and we'll automatically forward it
				return ___R$project$rome$$internal$compiler$index_ts$signals.remove;
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/transforms/compileForBundle/modern/requireRewriteTransform.ts
const ___R$project$rome$$internal$compiler$transforms$compileForBundle$modern$requireRewriteTransform_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "requireRewriteTransform",
		enter(path) {
			const {node, context} = path;

			const {relativeSourcesToModuleId, moduleId} = ___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getOptions(
				context,
			);

			// Replace all references to module.exports to the correct version
			if (
				node.type === "JSMemberExpression" &&
				___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
					node,
					"module.exports",
				)
			) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
					___R$project$rome$$internal$ast$js$auxiliary$JSIdentifier_ts$jsIdentifier.create({
						name: ___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(
							moduleId,
						),
						loc: ___R$project$rome$$internal$js$ast$utils$inheritLoc_ts$inheritLoc(
							node,
							"module.exports",
						),
					}),
				);
			}

			// Replace all assignments of module.exports to the correct version
			if (
				node.type === "JSAssignmentExpression" &&
				___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
					node.left,
					"module.exports",
				)
			) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
					___R$project$rome$$internal$ast$js$expressions$JSAssignmentExpression_ts$jsAssignmentExpression.create({
						operator: node.operator,
						left: ___R$project$rome$$internal$ast$js$patterns$JSAssignmentIdentifier_ts$jsAssignmentIdentifier.create({
							name: ___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(
								moduleId,
							),
							loc: ___R$project$rome$$internal$js$ast$utils$inheritLoc_ts$inheritLoc(
								node,
								"module.exports",
							),
						}),
						right: node.right,
					}),
				);
			}

			// Replace import foo = require('module');
			if (
				node.type === "TSImportEqualsDeclaration" &&
				node.moduleReference.type === "TSExternalModuleReference"
			) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
					___R$project$rome$$internal$js$ast$utils$template_ts$template.statement`const ${node.id} = require(${node.moduleReference.expression});`,
				);
			}

			// Now handle normal `require('module')`
			if (node.type !== "JSCallExpression") {
				return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
			}

			const {callee} = node;
			if (callee.type !== "JSReferenceIdentifier" || callee.name !== "require") {
				return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
			}

			const sourceArg = node.arguments[0];
			if (sourceArg.type !== "JSStringLiteral") {
				return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
			}

			if (path.scope.hasBinding("require")) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
			}

			const replacement = relativeSourcesToModuleId[sourceArg.value];
			if (typeof replacement === "string") {
				return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
					___R$project$rome$$internal$ast$js$auxiliary$JSIdentifier_ts$jsIdentifier.create({
						name: ___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(
							replacement,
						),
					}),
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/transforms/compileForBundle/metaPropertyTransform.ts
function ___R$$priv$project$rome$$internal$compiler$transforms$compileForBundle$metaPropertyTransform_ts$isImportMeta(
		node,
	) {
		return (
			node.type === "JSMetaProperty" &&
			node.meta.name === "import" &&
			node.property.name === "meta"
		);
	}

	function ___R$$priv$project$rome$$internal$compiler$transforms$compileForBundle$metaPropertyTransform_ts$createURLString(
		context,
	) {
		const str = ___R$project$rome$$internal$ast$js$literals$JSStringLiteral_ts$jsStringLiteral.create({
			value: "file://" +
			___R$$priv$project$rome$$internal$compiler$transforms$compileForBundle$metaPropertyTransform_ts$getFilename(
				context,
			),
		});
		return ___R$project$rome$$internal$js$ast$utils$template_ts$template.expression`typeof __filename === 'string' ? 'file://' + __filename : ${str}`;
	}

	function ___R$$priv$project$rome$$internal$compiler$transforms$compileForBundle$metaPropertyTransform_ts$getFilename(
		context,
	) {
		const {path} = context;
		if (path === undefined) {
			return "";
		} else {
			return path.join();
		}
	}
	const ___R$project$rome$$internal$compiler$transforms$compileForBundle$metaPropertyTransform_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsMetaPropertyTransform",
		enter(path) {
			const {node, context} = path;

			// Inline __filenamd and __dirname

			/*if (
      node.type === 'ReferenceIdentifier' &&
      (node.type === '__dirname' || node.name === '__filename')
    ) {
      if (node.type === '__dirname') {
        return jsStringLiteral.create({
          value: pathUtils.dirname(getFilename(context)),
        });
      }

      if (node.type === '__filename') {
        return jsStringLiteral.create({
          value: getFilename(context),
        });
      }
    }*/

			// Direct reference to import.meta.url
			if (
				node.type === "JSMemberExpression" &&
				node.property.type === "JSStaticMemberProperty" &&
				___R$$priv$project$rome$$internal$compiler$transforms$compileForBundle$metaPropertyTransform_ts$isImportMeta(
					node.object,
				) &&
				node.property.value.type === "JSIdentifier" &&
				node.property.value.name === "url"
			) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
					___R$$priv$project$rome$$internal$compiler$transforms$compileForBundle$metaPropertyTransform_ts$createURLString(
						context,
					),
				);
			}

			// This is an escaped import.meta or else our other transform would have changed it
			if (
				___R$$priv$project$rome$$internal$compiler$transforms$compileForBundle$metaPropertyTransform_ts$isImportMeta(
					node,
				)
			) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
					___R$project$rome$$internal$js$ast$utils$template_ts$template.expression`({url: ${___R$$priv$project$rome$$internal$compiler$transforms$compileForBundle$metaPropertyTransform_ts$createURLString(
						context,
					)}})`,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/transforms/compileForBundle/scopedRomeTransform.ts
const ___R$project$rome$$internal$compiler$transforms$compileForBundle$scopedRomeTransform_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "scopedRome",
		enter(path) {
			const {node, scope} = path;

			if (scope.node === node && scope.hasBinding("Rome")) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
					___R$project$rome$$internal$js$ast$utils$renameBindings_ts$renameBindings(
						path,
						new Map([["Rome", scope.generateUid("Rome")]]),
					),
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/transforms/compileForBundle/asyncImportTransform.ts
const ___R$project$rome$$internal$compiler$transforms$compileForBundle$asyncImportTransform_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "asyncImport",
		enter(path) {
			const {node} = path;

			if (
				node.type === "JSCallExpression" &&
				node.callee.type === "JSImportCall"
			) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
					Object.assign(
						{},
						node,
						{
							callee: ___R$project$rome$$internal$ast$js$expressions$JSReferenceIdentifier_ts$jsReferenceIdentifier.create({
								name: "require",
							}),
						},
					),
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/transforms/compileForBundle/inlineEnv.ts
const ___R$project$rome$$internal$compiler$transforms$compileForBundle$inlineEnv_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "inlineEnv",
		enter(path) {
			const {node} = path;

			if (
				node.type === "JSMemberExpression" &&
				node.property.value.type === "JSIdentifier" &&
				node.property.value.name === "NODE_ENV" &&
				!path.scope.hasBinding("process") &&
				___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
					node,
					"process.env.NODE_ENV",
				)
			) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
					___R$project$rome$$internal$ast$js$literals$JSStringLiteral_ts$jsStringLiteral.create({
						value: "development",
					}),
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/transforms/index.ts
const ___R$project$rome$$internal$compiler$transforms$index_ts$stageOrder = [
		"pre",
		"compile",
		"compileForBundle",
	];

	const ___R$project$rome$$internal$compiler$transforms$index_ts$helperVisitors = [
		___R$project$rome$$internal$compiler$transforms$helpers$index_ts$variableInjectorVisitor,
		___R$project$rome$$internal$compiler$transforms$helpers$index_ts$commentInjectorVisitor,
	];

	const ___R$project$rome$$internal$compiler$transforms$index_ts$stageTransforms = {
		// These may effect dependency analysis
		pre: () => [
			___R$project$rome$$internal$compiler$transforms$compile$validation$optimizeImports_ts$default,
			___R$project$rome$$internal$compiler$transforms$compile$validation$optimizeExports_ts$default,
			___R$project$rome$$internal$compiler$transforms$compile$jsx_ts$default,
		],
		compile: () => [
			___R$project$rome$$internal$compiler$transforms$compile$transpile$paramlessCatch_ts$default,
			___R$project$rome$$internal$compiler$transforms$compile$transpile$optionalChaining_ts$default,
			___R$project$rome$$internal$compiler$transforms$compile$transpile$nullishCoalescing_ts$default,
			___R$project$rome$$internal$compiler$transforms$compile$transpile$objectSpread_ts$default,
			___R$project$rome$$internal$compiler$transforms$compile$transpile$classProperties_ts$default,
			___R$project$rome$$internal$compiler$transforms$compile$transpile$templateLiterals_ts$default,
			___R$project$rome$$internal$compiler$transforms$compile$transpile$callSpread_ts$default,
			___R$project$rome$$internal$compiler$transforms$compile$transpile$enums_ts$default,
		],
		compileForBundle: (projectConfig, options) => {
			const opts = options.bundle;
			if (opts === undefined) {
				throw new Error("Expected bundle options for compileForBundle stage");
			}

			const transforms = [];

			if (opts.assetPath !== undefined) {
				transforms.push(
					___R$project$rome$$internal$compiler$transforms$compileForBundle$assetTransform_ts$default,
				);
			}
			transforms.push(
				___R$project$rome$$internal$compiler$transforms$compileForBundle$metaPropertyTransform_ts$default,
			);
			transforms.push(
				___R$project$rome$$internal$compiler$transforms$compileForBundle$asyncImportTransform_ts$default,
			);
			transforms.push(
				___R$project$rome$$internal$compiler$transforms$compileForBundle$scopedRomeTransform_ts$default,
			);
			transforms.push(
				___R$project$rome$$internal$compiler$transforms$compileForBundle$inlineEnv_ts$default,
			);

			//if (opts.mode === "modern") {
			transforms.push(
				___R$project$rome$$internal$compiler$transforms$compileForBundle$modern$requireRewriteTransform_ts$default,
			);
			transforms.push(
				opts.analyze.moduleType === "cjs"
					? ___R$project$rome$$internal$compiler$transforms$compileForBundle$modern$cjsRootTransform_ts$default
					: ___R$project$rome$$internal$compiler$transforms$compileForBundle$modern$esToRefTransform_ts$default,
			);
			//} else {
			//transforms.push(inlineRequiresTransform);
			//transforms.push(esToCJSTransform);
			//transforms.push(magicCJSTransform);
			//}

			return transforms;
		},
	};


  // project-rome/@internal/compiler/lint/decisions.ts
const ___R$project$rome$$internal$compiler$lint$decisions_ts = {
		deriveDecisionPositionKey: ___R$project$rome$$internal$compiler$lint$decisions_ts$deriveDecisionPositionKey,
		parseDecisionStrings: ___R$project$rome$$internal$compiler$lint$decisions_ts$parseDecisionStrings,
		buildLintDecisionGlobalString: ___R$project$rome$$internal$compiler$lint$decisions_ts$buildLintDecisionGlobalString,
		buildLintDecisionString: ___R$project$rome$$internal$compiler$lint$decisions_ts$buildLintDecisionString,
		buildLintDecisionAdviceAction: ___R$project$rome$$internal$compiler$lint$decisions_ts$buildLintDecisionAdviceAction,
	};
	function ___R$$priv$project$rome$$internal$compiler$lint$decisions_ts$validateAction(
		raw,
		unexpected,
	) {
		if (raw === "fix" || raw === "suppress" || raw === "ignore") {
			return raw;
		} else {
			unexpected(
				___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT_COMMAND.INVALID_DECISION_ACTION(
					raw,
				),
			);
			return undefined;
		}
	}

	function ___R$project$rome$$internal$compiler$lint$decisions_ts$deriveDecisionPositionKey(
		action,
		loc,
	) {
		if (loc === undefined) {
			return undefined;
		}

		const {start} = loc;
		if (start === undefined) {
			return undefined;
		}

		if (action === "suppress") {
			return ___R$project$rome$$internal$ob1$index_ts$ob1Get1(start.line);
		} else {
			return (
				___R$project$rome$$internal$ob1$index_ts$ob1Get1(start.line) +
				":" +
				___R$project$rome$$internal$ob1$index_ts$ob1Get0(start.column)
			);
		}
	}

	function ___R$project$rome$$internal$compiler$lint$decisions_ts$parseDecisionStrings(
		decisions,
		cwd,
		unexpected,
	) {
		const lintCompilerOptionsPerFile = {};
		const globalDecisions = [];

		function parseGlobalDecision(parts, i) {
			if (parts.length !== 2) {
				unexpected(
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT_COMMAND.INVALID_DECISION_PART_COUNT(
						i,
					),
				);
			}

			const [rawAction, rawCategory] = parts;

			const action = ___R$$priv$project$rome$$internal$compiler$lint$decisions_ts$validateAction(
				rawAction,
				unexpected,
			);
			if (action === undefined) {
				return;
			}

			const category = (rawCategory);
			globalDecisions.push({category, action});
		}

		function parseLineDecision(parts, i) {
			if (parts.length < 4 || parts.length > 5) {
				unexpected(
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT_COMMAND.INVALID_DECISION_PART_COUNT(
						i,
					),
				);
			}

			const [rawAction, rawCategory, rawFilename, pos, id] = parts;

			const action = ___R$$priv$project$rome$$internal$compiler$lint$decisions_ts$validateAction(
				rawAction,
				unexpected,
			);
			if (action === undefined) {
				return;
			}

			const category = (rawCategory);
			const resolvedFilename = cwd.resolve(rawFilename).join();

			let compilerOptions = lintCompilerOptionsPerFile[resolvedFilename];
			if (compilerOptions === undefined) {
				compilerOptions = {
					hasDecisions: true,
					globalDecisions: [],
					decisionsByPosition: {},
				};
				lintCompilerOptionsPerFile[resolvedFilename] = compilerOptions;
			}

			let decisionsForPosition = compilerOptions.decisionsByPosition[pos];
			if (decisionsForPosition === undefined) {
				decisionsForPosition = [];
				compilerOptions.decisionsByPosition[pos] = decisionsForPosition;
			}

			decisionsForPosition.push({
				action,
				category,
				id: id === undefined ? undefined : Number(id),
			});
		}

		for (let i = 0; i < decisions.length; i++) {
			const segment = decisions[i];
			const parts = ___R$project$rome$$internal$string$utils$escapeSplit_ts$escapeSplit(
				segment,
				"-",
			);

			if (parts[0] === "global") {
				parseGlobalDecision(parts.slice(1), i);
			} else {
				parseLineDecision(parts, i);
			}
		}

		return {lintCompilerOptionsPerFile, globalDecisions};
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$decisions_ts$escapeFilename(
		filename,
	) {
		return filename.replace(/-/, "\\-");
	}

	function ___R$project$rome$$internal$compiler$lint$decisions_ts$buildLintDecisionGlobalString(
		action,
		category,
	) {
		return "global-" + action + "-" + category;
	}

	function ___R$project$rome$$internal$compiler$lint$decisions_ts$buildLintDecisionString(
		{
			filename,
			action,
			category,
			start,
			id,
		},
	) {
		const escapedFilename = ___R$$priv$project$rome$$internal$compiler$lint$decisions_ts$escapeFilename(
			filename,
		);
		const pos = ___R$project$rome$$internal$compiler$lint$decisions_ts$deriveDecisionPositionKey(
			action,
			{start},
		);

		const parts = [action, category, escapedFilename, pos];

		if (id !== undefined) {
			parts.push(String(id));
		}

		return parts.join("-");
	}

	function ___R$project$rome$$internal$compiler$lint$decisions_ts$buildLintDecisionAdviceAction(
		{
			noun,
			instruction,
			filename,
			shortcut,
			decision,
			extra,
		},
	) {
		return {
			type: "action",
			extra,
			hidden: true,
			command: "check",
			shortcut,
			args: filename === undefined
				? []
				: [
						___R$$priv$project$rome$$internal$compiler$lint$decisions_ts$escapeFilename(
							filename,
						),
					],
			noun,
			instruction,
			commandFlags: {
				decisions: [decision],
			},
		};
	}


  // project-rome/@internal/markup-syntax-highlight/utils.ts
function ___R$project$rome$$internal$markup$syntax$highlight$utils_ts$reduce(
		input,
		tokens,
		callback,
	) {
		let prevEnd = 0;
		let parts = [];

		for (let i = 0; i < tokens.length; i++) {
			const token = tokens[i];
			const start = ___R$project$rome$$internal$ob1$index_ts$ob1Get0(
				token.start,
			);
			const end = ___R$project$rome$$internal$ob1$index_ts$ob1Get0(token.end);
			let value = input.slice(start, end);

			// Add on text between tokens
			parts.push(
				___R$project$rome$$internal$markup$escape_ts$markup`${input.slice(
					prevEnd,
					start,
				)}`,
			);
			prevEnd = end;

			// Print this token
			// We need to break up the token text into lines, so that we can easily split the highlighted newlines and have the ansi codes be unbroken
			const lines = ___R$project$rome$$internal$string$utils$splitLines_ts$splitLines(
				value,
			);
			for (let i = 0; i < lines.length; i++) {
				const line = lines[i];

				if (line !== "") {
					const prev = tokens[i - 1];
					const next = tokens[i + 1];
					const escapedLine = ___R$project$rome$$internal$markup$escape_ts$markup`${line}`;
					const res = callback(token, escapedLine, prev, next);
					if (res === undefined) {
						parts.push(escapedLine);
					} else {
						const {value = escapedLine, type} = res;
						if (type === undefined) {
							parts.push(value);
						} else {
							parts.push(
								___R$project$rome$$internal$markup$syntax$highlight$utils_ts$markupToken(
									type,
									value,
								),
							);
						}
					}
				}

				// Last element isn't a line break
				const isLast = i === lines.length - 1;
				if (!isLast) {
					parts.push(___R$project$rome$$internal$markup$escape_ts$markup`\n`);
				}
			}
		}

		return ___R$project$rome$$internal$markup$syntax$highlight$utils_ts$concatSplitLinesMarkup(
			parts,
		);
	}

	function ___R$project$rome$$internal$markup$syntax$highlight$utils_ts$markupToken(
		type,
		value,
	) {
		return ___R$project$rome$$internal$markup$escape_ts$markupTag(
			"token",
			___R$project$rome$$internal$markup$escape_ts$markup`${value}`,
			{type},
		);
	}

	function ___R$project$rome$$internal$markup$syntax$highlight$utils_ts$concatSplitLinesMarkup(
		parts,
	) {
		return ___R$project$rome$$internal$string$utils$splitLines_ts$splitLines(
			___R$project$rome$$internal$markup$escape_ts$readMarkup(
				___R$project$rome$$internal$markup$escape_ts$concatMarkup(parts),
			),
		).map((line) =>
			___R$project$rome$$internal$markup$escape_ts$convertToMarkupFromRandomString(
				line,
			)
		);
	}

	function ___R$project$rome$$internal$markup$syntax$highlight$utils_ts$invalidHighlight(
		line,
	) {
		return {
			value: ___R$project$rome$$internal$markup$escape_ts$markupTag(
				"emphasis",
				___R$project$rome$$internal$markup$escape_ts$markupTag(
					"color",
					line,
					{bg: "red"},
				),
			),
		};
	}

	function ___R$project$rome$$internal$markup$syntax$highlight$utils_ts$reduceParserCore(
		input,
		tokens,
		callback,
	) {
		return ___R$project$rome$$internal$markup$syntax$highlight$utils_ts$reduce(
			input,
			tokens,
			(token, value, prev, next) => {
				switch (token.type) {
					case "Invalid":
						return ___R$project$rome$$internal$markup$syntax$highlight$utils_ts$invalidHighlight(
							value,
						);

					// Will never be hit
					case "EOF":
					case "SOF":
						return {
							value: ___R$project$rome$$internal$markup$escape_ts$markup``,
						};

					default:
						// We should have refined `token` to not include any of the base tokens
						return callback(token, value, prev, next);
				}
			},
		);
	}


  // project-rome/@internal/markup/escape.ts
const ___R$project$rome$$internal$markup$escape_ts = {
		convertToMarkupFromRandomString: ___R$project$rome$$internal$markup$escape_ts$convertToMarkupFromRandomString,
		filePathToMarkup: ___R$project$rome$$internal$markup$escape_ts$filePathToMarkup,
		markup: ___R$project$rome$$internal$markup$escape_ts$markup,
		readMarkup: ___R$project$rome$$internal$markup$escape_ts$readMarkup,
		serializeLazyMarkup: ___R$project$rome$$internal$markup$escape_ts$serializeLazyMarkup,
		isEmptyMarkup: ___R$project$rome$$internal$markup$escape_ts$isEmptyMarkup,
		concatMarkup: ___R$project$rome$$internal$markup$escape_ts$concatMarkup,
		markupTag: ___R$project$rome$$internal$markup$escape_ts$markupTag,
		unescapeTextValue: ___R$project$rome$$internal$markup$escape_ts$unescapeTextValue,
	};
	function ___R$$priv$project$rome$$internal$markup$escape_ts$isMarkup(part) {
		return typeof part === "object" && part != null && part.type === "MARKUP";
	}

	function ___R$$priv$project$rome$$internal$markup$escape_ts$isRawMarkup(part) {
		return (
			typeof part === "object" && part != null && part.type === "RAW_MARKUP"
		);
	}

	function ___R$$priv$project$rome$$internal$markup$escape_ts$isLazyMarkup(part) {
		return (
			typeof part === "object" && part != null && part.type === "LAZY_MARKUP"
		);
	}

	// Awkward name since we should only be doing this very very sparingly
	function ___R$project$rome$$internal$markup$escape_ts$convertToMarkupFromRandomString(
		unsafe,
	) {
		return {
			type: "MARKUP",
			parts: [
				___R$$priv$project$rome$$internal$markup$escape_ts$toRawMarkup(unsafe),
			],
		};
	}

	function ___R$project$rome$$internal$markup$escape_ts$filePathToMarkup(
		path,
		explicit = false,
	) {
		let tagName = "filelink";
		if (path instanceof ___R$project$rome$$internal$path$index_ts$URLPath) {
			tagName = "hyperlink";
		}

		const target = path.join();
		const text = explicit
			? ___R$project$rome$$internal$markup$escape_ts$markup`${target}`
			: ___R$project$rome$$internal$markup$escape_ts$markup``;

		return ___R$project$rome$$internal$markup$escape_ts$markupTag(
			tagName,
			text,
			{
				target,
			},
		);
	}

	const ___R$$priv$project$rome$$internal$markup$escape_ts$markupTemplateCache = new WeakMap();

	// A tagged template literal helper that will escape all interpolated strings, ensuring only markup works
	function ___R$project$rome$$internal$markup$escape_ts$markup(strs, ...values) {
		if (values.length === 0) {
			const cached = ___R$$priv$project$rome$$internal$markup$escape_ts$markupTemplateCache.get(
				strs,
			);
			if (cached !== undefined) {
				return cached;
			}
		}

		const parts = [];
		let hasLazy = false;

		for (let i = 0; i < strs.length; i++) {
			const str = strs[i];
			if (str !== "") {
				parts.push({
					type: "RAW_MARKUP",
					value: str,
				});
			}

			// Last string is not followed by an interpolated value
			if (i === strs.length - 1) {
				continue;
			}

			const value = values[i];
			if (typeof value === "undefined") {
				parts.push(
					___R$$priv$project$rome$$internal$markup$escape_ts$toRawMarkup(
						"<dim>undefined</dim>",
					),
				);
			} else if (typeof value === "number") {
				parts.push(
					___R$$priv$project$rome$$internal$markup$escape_ts$toRawMarkup(
						"<number>" + String(value) + "</number>",
					),
				);
			} else if (
				value instanceof
				___R$project$rome$$internal$path$index_ts$RelativeFilePath ||
				value instanceof
				___R$project$rome$$internal$path$index_ts$AbsoluteFilePath ||
				value instanceof ___R$project$rome$$internal$path$index_ts$URLPath ||
				value instanceof ___R$project$rome$$internal$path$index_ts$UnknownPath
			) {
				parts.push(
					___R$project$rome$$internal$markup$escape_ts$filePathToMarkup(value),
				);
			} else {
				if (
					typeof value === "function" ||
					___R$$priv$project$rome$$internal$markup$escape_ts$isLazyMarkup(value)
				) {
					hasLazy = true;
				}
				parts.push(value);
			}
		}

		const obj = {
			// @ts-ignore
			type: hasLazy ? "LAZY_MARKUP" : "MARKUP",
			parts,
		};

		// No interpolated values so result is static
		if (values.length === 0) {
			___R$$priv$project$rome$$internal$markup$escape_ts$markupTemplateCache.set(
				strs,
				obj,
			);
		}

		return obj;
	}

	// Here we have a cache making serializing markup so we can call it performantly with only the object
	// We can also benefit from a small speed up by common interpolated markup
	const ___R$$priv$project$rome$$internal$markup$escape_ts$readCache = new WeakMap();

	function ___R$project$rome$$internal$markup$escape_ts$readMarkup(item) {
		if (typeof item === "function") {
			return ___R$project$rome$$internal$markup$escape_ts$readMarkup(
				___R$project$rome$$internal$markup$escape_ts$serializeLazyMarkup(item),
			);
		}

		const cached = ___R$$priv$project$rome$$internal$markup$escape_ts$readCache.get(
			item,
		);
		if (cached !== undefined) {
			return cached;
		}

		let out = "";
		for (const part of item.parts) {
			if (___R$$priv$project$rome$$internal$markup$escape_ts$isRawMarkup(part)) {
				out += part.value;
			} else if (
				___R$$priv$project$rome$$internal$markup$escape_ts$isMarkup(part) ||
				___R$$priv$project$rome$$internal$markup$escape_ts$isLazyMarkup(part) ||
				typeof part === "function"
			) {
				out += ___R$project$rome$$internal$markup$escape_ts$readMarkup(part);
			} else {
				out += ___R$$priv$project$rome$$internal$markup$escape_ts$escapeMarkup(
					String(part),
				);
			}
		}
		___R$$priv$project$rome$$internal$markup$escape_ts$readCache.set(item, out);
		return out;
	}

	const ___R$$priv$project$rome$$internal$markup$escape_ts$factoryCache = new WeakMap();

	function ___R$project$rome$$internal$markup$escape_ts$serializeLazyMarkup(
		markup,
	) {
		if (___R$$priv$project$rome$$internal$markup$escape_ts$isLazyMarkup(markup)) {
			return {
				type: "MARKUP",
				parts: [
					___R$$priv$project$rome$$internal$markup$escape_ts$toRawMarkup(
						___R$project$rome$$internal$markup$escape_ts$readMarkup(markup),
					),
				],
			};
		} else if (typeof markup === "function") {
			let res = ___R$$priv$project$rome$$internal$markup$escape_ts$factoryCache.get(
				markup,
			);
			if (res === undefined) {
				res = markup();
				___R$$priv$project$rome$$internal$markup$escape_ts$factoryCache.set(
					markup,
					res,
				);
			}
			return ___R$project$rome$$internal$markup$escape_ts$serializeLazyMarkup(
				res,
			);
		} else {
			return markup;
		}
	}

	function ___R$project$rome$$internal$markup$escape_ts$isEmptyMarkup(safe) {
		if (typeof safe === "function") {
			return ___R$project$rome$$internal$markup$escape_ts$isEmptyMarkup(
				___R$project$rome$$internal$markup$escape_ts$serializeLazyMarkup(safe),
			);
		}

		for (const part of safe.parts) {
			if (typeof part === "string") {
				if (part !== "") {
					return false;
				}
			} else if (
				___R$$priv$project$rome$$internal$markup$escape_ts$isMarkup(part)
			) {
				if (!___R$project$rome$$internal$markup$escape_ts$isEmptyMarkup(part)) {
					return false;
				}
			} else if (
				___R$$priv$project$rome$$internal$markup$escape_ts$isRawMarkup(part)
			) {
				if (part.value !== "") {
					return false;
				}
			} else if (
				___R$$priv$project$rome$$internal$markup$escape_ts$isLazyMarkup(part)
			) {
				if (!___R$project$rome$$internal$markup$escape_ts$isEmptyMarkup(part)) {
					return false;
				}
			} else {
				return false;
			}
		}

		return true;
	}

	function ___R$project$rome$$internal$markup$escape_ts$concatMarkup(
		items,
		separator = ___R$project$rome$$internal$markup$escape_ts$markup``,
	) {
		const parts = [];
		let hasLazy = ___R$$priv$project$rome$$internal$markup$escape_ts$isLazyMarkup(
			separator,
		);

		for (let i = 0; i < items.length; i++) {
			const item = items[i];
			parts.push(item);

			if (___R$$priv$project$rome$$internal$markup$escape_ts$isLazyMarkup(item)) {
				hasLazy = true;
			}

			if (i !== items.length - 1) {
				parts.push(separator);
			}
		}

		return {
			// @ts-ignore
			type: hasLazy ? "LAZY_MARKUP" : "MARKUP",
			parts,
		};
	}

	function ___R$$priv$project$rome$$internal$markup$escape_ts$toRawMarkup(value) {
		return {
			type: "RAW_MARKUP",
			value,
		};
	}

	// Escape all \ and >
	function ___R$$priv$project$rome$$internal$markup$escape_ts$escapeMarkup(
		input,
	) {
		let escaped = "";
		for (let i = 0; i < input.length; i++) {
			const char = input[i];

			if (char === "<") {
				escaped += "\\<";
			} else if (char === '"') {
				escaped += '\\"';
			} else if (char === "\\") {
				escaped += "\\\\";
			} else {
				escaped += char;
			}
		}
		return escaped;
	}

	function ___R$project$rome$$internal$markup$escape_ts$markupTag(
		tagName,
		text,
		attrs,
	) {
		let ret = "<" + tagName;

		if (attrs !== undefined) {
			for (const key in attrs) {
				const value = attrs[key];
				if (value !== undefined) {
					ret +=
						" " +
						___R$$priv$project$rome$$internal$markup$escape_ts$escapeMarkup(key) +
						'="' +
						___R$$priv$project$rome$$internal$markup$escape_ts$escapeMarkup(
							String(value),
						) +
						'"';
				}
			}
		}

		const open = ___R$$priv$project$rome$$internal$markup$escape_ts$toRawMarkup(
			ret + ">",
		);
		const close = ___R$$priv$project$rome$$internal$markup$escape_ts$toRawMarkup(
			"</" + tagName + ">",
		);

		if (typeof text === "function" || text.type === "LAZY_MARKUP") {
			return {
				type: "LAZY_MARKUP",
				parts: [open, text, close],
			};
		} else {
			return {
				type: "MARKUP",
				parts: [open, text, close],
			};
		}
	}

	function ___R$project$rome$$internal$markup$escape_ts$unescapeTextValue(str) {
		let unescaped = "";

		for (let i = 0; i < str.length; i++) {
			const char = str[i];

			// Unescape \\< to just <
			// Unescape \\\\ to just \\
			if (char === "\\") {
				const nextChar = str[i + 1];
				if (nextChar === "<" || nextChar === '"' || nextChar === "\\") {
					i++;
					unescaped += nextChar;
					continue;
				}
			}

			unescaped += char;
		}

		return unescaped;
	}


  // project-rome/@internal/markup-syntax-highlight/highlightShell.ts
function ___R$project$rome$$internal$markup$syntax$highlight$highlightShell_ts$default(
		opts,
	) {
		// TODO properly handle strings with spaces
		const segments = opts.input.split(" ");

		let segmentCount = 0;

		const parts = segments.map((segment, i) => {
			if (i === 0) {
				const lastChar = segment[segment.length - 1];
				if (lastChar === "#" || lastChar === "$") {
					// const punc = markupToken("punctuation", lastChar);
					const punc = ___R$project$rome$$internal$markup$escape_ts$markupTag(
						"emphasis",
						___R$project$rome$$internal$markup$escape_ts$markup`${lastChar}`,
					);
					if (segment.length === 1) {
						return punc;
					} else {
						return ___R$project$rome$$internal$markup$escape_ts$concatMarkup([
							___R$project$rome$$internal$markup$escape_ts$filePathToMarkup(
								___R$project$rome$$internal$path$index_ts$createUnknownPath(
									segment.slice(0, -1),
								),
								true,
							),
							punc,
						]);
					}
				}
			}

			if (segment[0] === '"' || segment[0] === "'") {
				return ___R$project$rome$$internal$markup$syntax$highlight$utils_ts$markupToken(
					"string",
					segment,
				);
			}

			if (segment[0] === "-") {
				//return markupToken("operator", segment);
			}

			segmentCount++;

			if (segmentCount === 1 || (opts.isShorthand && segmentCount === 2)) {
				return ___R$project$rome$$internal$markup$syntax$highlight$utils_ts$markupToken(
					"function",
					segment,
				);
			}

			return ___R$project$rome$$internal$markup$escape_ts$markup`<dim>${segment}</dim>`;
		});

		return ___R$project$rome$$internal$markup$syntax$highlight$utils_ts$concatSplitLinesMarkup([
			___R$project$rome$$internal$markup$escape_ts$concatMarkup(
				parts,
				___R$project$rome$$internal$markup$escape_ts$markup` `,
			),
		]);
	}


  // project-rome/@internal/markup-syntax-highlight/highlightJS.ts
function ___R$project$rome$$internal$markup$syntax$highlight$highlightJS_ts$default(
		{input, path},
		sourceType,
	) {
		const tokens = ___R$project$rome$$internal$js$parser$index_ts$tokenizeJS({
			input,
			sourceType,
			path,
		});

		return ___R$project$rome$$internal$markup$syntax$highlight$utils_ts$reduce(
			input,
			tokens,
			(token, value, prev, next) => {
				switch (token.type) {
					case "break":
					case "case":
					case "catch":
					case "continue":
					case "debugger":
					case "default":
					case "do":
					case "else":
					case "finally":
					case "for":
					case "function":
					case "if":
					case "return":
					case "switch":
					case "throw":
					case "try":
					case "var":
					case "const":
					case "while":
					case "with":
					case "new":
					case "this":
					case "super":
					case "class":
					case "extends":
					case "export":
					case "import":
					case "in":
					case "instanceof":
					case "typeof":
					case "void":
					case "delete":
						return {type: "keyword"};

					case "true":
					case "false":
					case "null":
						return {type: "boolean"};

					case "num":
					case "bigint":
						return {type: "number"};

					case "regexp":
						return {type: "regex"};

					case "string":
					case "template":
					case "`":
						return {type: "string"};

					case "invalid":
						return ___R$project$rome$$internal$markup$syntax$highlight$utils_ts$invalidHighlight(
							value,
						);

					case "comment":
						return {type: "comment"};

					case ",":
					case ";":
					case ":":
					case "::":
					case "${":
					case ".":
					case "?":
					case "?.":
					case "[":
					case "]":
					case "{":
					case "{|":
					case "}":
					case "|}":
					case "(":
					case ")":
						return {type: "punctuation"};

					case "name": {
						if (next !== undefined && next.type === "(") {
							return {type: "function"};
						}

						// These are contextual keywords
						const word = ___R$project$rome$$internal$markup$escape_ts$readMarkup(
							value,
						);
						if (
							word === "from" ||
							word === "let" ||
							word === "async" ||
							word === "await" ||
							word === "public" ||
							word === "private"
						) {
							return {type: "keyword"};
						}

						return {type: "variable"};
					}

					case "jsxName":
						return {
							type: prev !== undefined &&
							(prev.type === "jsxTagStart" || prev.type === "/")
								? "variable"
								: "attr-name",
						};

					case "=>":
					case "...":
					case "@":
					case "#":
					case "=":
					case "_=":
					case "++/--":
					case "!":
					case "~":
					case "??":
					case "||":
					case "&&":
					case "|":
					case "^":
					case "&":
					case "==/!=":
					case "</>":
					case "<</>>":
					case "+/-":
					case "%":
					case "*":
					case "/":
					case "**":
						return {type: "operator"};

					default:
						return undefined;
				}
			},
		);
	}


  // project-rome/@internal/markup-syntax-highlight/highlightHTML.ts
function ___R$project$rome$$internal$markup$syntax$highlight$highlightHTML_ts$default(
		{input, path},
	) {
		const tokens = ___R$project$rome$$internal$html$parser$index_ts$tokenizeHTML({
			input,
			path,
		});

		return ___R$project$rome$$internal$markup$syntax$highlight$utils_ts$reduceParserCore(
			input,
			tokens,
			(token, value, prev) => {
				// All these tokens appear only inside of tags
				switch (token.type) {
					case "Equals":
						return {type: "attr-equals"};

					case "Identifier":
						return {
							type: prev !== undefined && prev.type === "TagStartOpen"
								? "tag"
								: "attr-name",
						};

					case "String":
						return {type: "attr-value"};

					case "TagEndOpen":
					case "TagEnd":
					case "TagSelfClosing":
					case "TagStartOpen":
						return {type: "punctuation"};

					default:
						return undefined;
				}
			},
		);
	}


  // project-rome/@internal/markup-syntax-highlight/highlightJSON.ts
function ___R$project$rome$$internal$markup$syntax$highlight$highlightJSON_ts$default(
		{input, path},
	) {
		const tokens = ___R$project$rome$$internal$codec$json$index_ts$tokenizeJSON({
			input,
			// Wont be used anywhere but activates JSON extensions if necessary
			path,
		});

		return ___R$project$rome$$internal$markup$syntax$highlight$utils_ts$reduceParserCore(
			input,
			tokens,
			(token) => {
				// Try to keep the highlighting in line with JS where possible
				switch (token.type) {
					case "BlockComment":
					case "LineComment":
						return {type: "comment"};

					case "String":
						return {type: "string"};

					case "Number":
						return {type: "number"};

					case "Word":
						switch (token.value) {
							case "true":
							case "false":
							case "null":
								return {type: "boolean"};

							default:
								return undefined;
						}

					case "Comma":
					case "Colon":
					case "Dot":
						return {type: "operator"};

					case "BracketOpen":
					case "BracketClose":
					case "BraceOpen":
					case "BraceClose":
					case "Minus":
					case "Plus":
						return {type: "punctuation"};

					default:
						return undefined;
				}
			},
		);
	}


  // project-rome/@internal/markup-syntax-highlight/types.ts



  // project-rome/@internal/markup-syntax-highlight/index.ts
// Max file size to avoid doing expensive highlighting for massive files - 100KB
	// NB: This should probably be lower
	const ___R$$priv$project$rome$$internal$markup$syntax$highlight$index_ts$FILE_SIZE_MAX = 100_000;

	function ___R$project$rome$$internal$markup$syntax$highlight$index_ts$highlightCode(
		opts,
	) {
		if (
			opts.input.length <
			___R$$priv$project$rome$$internal$markup$syntax$highlight$index_ts$FILE_SIZE_MAX &&
			opts.highlight
		) {
			switch (opts.language) {
				case "js":
					return ___R$project$rome$$internal$markup$syntax$highlight$highlightJS_ts$default(
						opts,
						// js-parser does not accept an "unknown" sourceType
						opts.sourceTypeJS === undefined || opts.sourceTypeJS === "unknown"
							? "script"
							: opts.sourceTypeJS,
					);

				case "html":
					return ___R$project$rome$$internal$markup$syntax$highlight$highlightHTML_ts$default(
						opts,
					);

				case "json":
					return ___R$project$rome$$internal$markup$syntax$highlight$highlightJSON_ts$default(
						opts,
					);

				case "shell":
					return ___R$project$rome$$internal$markup$syntax$highlight$highlightShell_ts$default(
						opts,
					);
			}
		}

		return ___R$project$rome$$internal$string$utils$splitLines_ts$splitLines(
			opts.input,
		).map((line) => ___R$project$rome$$internal$markup$escape_ts$markup`${line}`);
	}


  // project-rome/@internal/cli-diagnostics/utils.ts
const ___R$project$rome$$internal$cli$diagnostics$utils_ts = {
		showInvisibles: ___R$project$rome$$internal$cli$diagnostics$utils_ts$showInvisibles,
		cleanEquivalentString: ___R$project$rome$$internal$cli$diagnostics$utils_ts$cleanEquivalentString,
		toLines: ___R$project$rome$$internal$cli$diagnostics$utils_ts$toLines,
		inferDiagnosticLanguageFromRootAST: ___R$project$rome$$internal$cli$diagnostics$utils_ts$inferDiagnosticLanguageFromRootAST,
	};
	const ___R$$priv$project$rome$$internal$cli$diagnostics$utils_ts$unicodeControls = /[\u0000-\u001f\u007f-\u00a0]/u;

	function ___R$$priv$project$rome$$internal$cli$diagnostics$utils_ts$isWhitespace(
		char,
	) {
		return char === " " || char === "\t" || char === "\r" || char === "\n";
	}

	function ___R$project$rome$$internal$cli$diagnostics$utils_ts$showInvisibles(
		str,
		{atLineStart, atLineEnd, ignoreLoneSpaces, ignoreLeadingTabs},
	) {
		let hadNonWhitespace = false;
		let ret = "";

		// Get the first trailing whitespace character in the string
		let trailingWhitespaceIndex = str.length;
		while (
			___R$$priv$project$rome$$internal$cli$diagnostics$utils_ts$isWhitespace(
				str[trailingWhitespaceIndex - 1],
			)
		) {
			trailingWhitespaceIndex--;
		}

		for (let i = 0; i < str.length; i++) {
			const char = str[i];
			let showInvisible = true;

			// Only highlight spaces when surrounded by other spaces
			if (char === " " && ignoreLoneSpaces) {
				showInvisible = false;

				if (
					___R$$priv$project$rome$$internal$cli$diagnostics$utils_ts$isWhitespace(
						str[i - 1],
					) ||
					___R$$priv$project$rome$$internal$cli$diagnostics$utils_ts$isWhitespace(
						str[i + 1],
					)
				) {
					showInvisible = false;
				}
			}

			// Don't show leading tabs
			if (atLineStart && !hadNonWhitespace && char === "\t" && ignoreLeadingTabs) {
				showInvisible = false;
			}

			// Always show if at the end of line
			if (atLineEnd && i >= trailingWhitespaceIndex) {
				showInvisible = true;
			}

			if (!showInvisible) {
				if (
					!___R$$priv$project$rome$$internal$cli$diagnostics$utils_ts$isWhitespace(
						char,
					)
				) {
					hadNonWhitespace = true;
				}
				ret += char;
				continue;
			}

			const visible = ___R$$priv$project$rome$$internal$cli$diagnostics$utils_ts$showInvisibleChar(
				char,
			);
			if (visible !== undefined) {
				ret += ___R$project$rome$$internal$markup$escape_ts$readMarkup(
					___R$project$rome$$internal$markup$escape_ts$markup`<dim>${visible}</dim>`,
				);
				continue;
			}

			if (
				___R$project$rome$$internal$js$parser$utils$whitespace_ts$nonASCIIwhitespace.test(
					char,
				) ||
				___R$$priv$project$rome$$internal$cli$diagnostics$utils_ts$unicodeControls.test(
					char,
				)
			) {
				ret += ___R$project$rome$$internal$markup$escape_ts$readMarkup(
					___R$$priv$project$rome$$internal$cli$diagnostics$utils_ts$showUnicodeChar(
						char,
					),
				);
				continue;
			}

			ret += char;
		}

		return {
			hadNonWhitespace,
			value: ___R$project$rome$$internal$markup$escape_ts$convertToMarkupFromRandomString(
				ret,
			),
		};
	}

	function ___R$$priv$project$rome$$internal$cli$diagnostics$utils_ts$showUnicodeChar(
		char,
	) {
		// We use inverse to make it clear that it's not in the source
		return ___R$project$rome$$internal$markup$escape_ts$markup`<inverse>U+${char.codePointAt(
			0,
		).toString(16)}</inverse>`;
	}

	function ___R$$priv$project$rome$$internal$cli$diagnostics$utils_ts$showInvisibleChar(
		char,
	) {
		switch (char) {
			case " ":
				return "\xb7"; // Middle Dot

			case "\r":
				return "\u240d"; // Carriage Return Symbol

			case "\n":
				return "\u23ce"; // Return Symbol

			case "\t":
				// TODO this should be repeated for tabWidth
				return "\u2192 "; // Rightwards Arrow

			case "\0":
				return "\u2400"; // Null Symbol

			case "\x0b":
				return "\u240b"; // Vertical Tabulation Symbol

			case "\b":
				return "\u232b"; // Backspace Symbol

			case "\f":
				return "\u21a1"; // Downards Two Headed Arrow

			default:
				return undefined;
		}
	}

	function ___R$project$rome$$internal$cli$diagnostics$utils_ts$cleanEquivalentString(
		safe,
	) {
		let str =
			typeof safe === "string"
				? safe
				: ___R$project$rome$$internal$cli$layout$format_ts$markupToJoinedPlainText(
						safe,
					);

		// Replace all whitespace with spaces
		str = str.replace(/[\s\n]+/g, " ");

		// Remove trailing dot
		str = str.replace(/\.+$/, "");

		// Remove surrounding quotes
		str = str.replace(/^"(.*?)"$/, "$1");

		return str;
	}

	function ___R$project$rome$$internal$cli$diagnostics$utils_ts$toLines(opts) {
		const input = ___R$project$rome$$internal$string$utils$removeCarriageReturn_ts$removeCarriageReturn(
			opts.input,
		);
		const raw = ___R$project$rome$$internal$string$utils$splitLines_ts$splitLines(
			input,
		);
		const highlighted = ___R$project$rome$$internal$markup$syntax$highlight$index_ts$highlightCode(
			Object.assign({}, opts, {input}),
		);

		if (raw.length !== highlighted.length) {
			throw new Error(
				opts.path.join() +
				": raw and highlighted line count mismatch " +
				raw.length +
				" !== " +
				highlighted.length,
			);
		}

		return raw.map((line, i) => [line, highlighted[i]]);
	}

	function ___R$project$rome$$internal$cli$diagnostics$utils_ts$inferDiagnosticLanguageFromRootAST(
		ast,
	) {
		switch (ast.type) {
			case "JSRoot":
				return "js";

			case "HTMLRoot":
				return "html";

			case "CSSRoot":
				return "css";

			case "MarkdownRoot":
				return "md";

			case "CommitRoot":
				return "commit";
		}
	}


  // project-rome/@internal/compiler/transforms/cleanTransform.ts
function ___R$$priv$project$rome$$internal$compiler$transforms$cleanTransform_ts$isEmpty(
		arr,
	) {
		return arr === undefined || arr.length === 0;
	}

	// Transformations can easily put the AST into an invalid state.
	//
	// This could be setting properties to `undefined` that shouldn't be removed,
	// or having an empty array where the AST would expect at least one element.
	//
	// In an ideal world we would generate runtime validation, however we are
	// far from being able to technically do that.
	//
	// Even if we could we would still need some special handling to decide what
	// to do with some of these invalid states to prevent them from needing to be
	// handled everywhere.
	const ___R$project$rome$$internal$compiler$transforms$cleanTransform_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "clean",
		enter(path) {
			const {node} = path;

			// Remove declarations with no declarators
			if (
				node.type === "JSVariableDeclaration" &&
				___R$$priv$project$rome$$internal$compiler$transforms$cleanTransform_ts$isEmpty(
					node.declarations,
				)
			) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.remove;
			}

			// Remove declaration statement with no declaration or declarators
			if (
				node.type === "JSVariableDeclarationStatement" &&
				(node.declaration === undefined ||
				___R$$priv$project$rome$$internal$compiler$transforms$cleanTransform_ts$isEmpty(
					node.declaration.declarations,
				))
			) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.remove;
			}

			// Remove local named exports with no values
			if (
				node.type === "JSExportLocalDeclaration" &&
				node.declaration === undefined &&
				___R$$priv$project$rome$$internal$compiler$transforms$cleanTransform_ts$isEmpty(
					node.specifiers,
				)
			) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.remove;
			}

			// Remove expressionless expression statements
			if (node.type === "JSExpressionStatement" && node.expression === undefined) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.remove;
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lib/VisitorState.ts
class ___R$project$rome$$internal$compiler$lib$VisitorState_ts$default {
		constructor() {
			this.stack = [];
			this.currentIndex = -1;
			this.pushQueue = undefined;
			this.currentPathToken = undefined;
		}

		setCurrentPath(path) {
			this.currentPathToken = path.token;
		}

		owns() {
			return (
				this.has() && this.stack[this.currentIndex][1] === this.currentPathToken
			);
		}

		has() {
			return this.currentIndex >= 0;
		}

		getIndex(find) {
			let index = this.currentIndex;

			if (find !== undefined) {
				for (; index >= 0; index--) {
					if (find(this.stack[index][0])) {
						break;
					}
				}
			}

			return index;
		}

		getOptional(find) {
			const index = this.getIndex(find);
			if (index === -1) {
				throw new Error("VisitorState: Could not find stack");
			} else {
				return this.stack[index][0];
			}
		}

		get(find) {
			if (!this.has()) {
				throw new Error(
					"VisitorState.get: Nothing on the stack. Did you mean to use getOptional?",
				);
			}

			const index = this.getIndex(find);
			if (index === -1) {
				throw new Error("VisitorState.get: Could not find item on the stack");
			}

			return this.stack[index][0];
		}

		reset(state) {
			this.pushQueue = state;
		}

		pop() {
			this.currentIndex--;
			this.stack.pop();
		}

		checkPushed() {
			const {pushQueue: queueState} = this;
			if (queueState === undefined) {
				return false;
			} else {
				const {currentPathToken} = this;
				if (currentPathToken === undefined) {
					throw new Error("VisitorState.checkPushed: No current path found");
				}
				this.stack.push([queueState, currentPathToken]);
				this.currentIndex++;
				this.pushQueue = undefined;
				return true;
			}
		}

		set(partial, opts = {}) {
			if (!this.has()) {
				if (opts.required) {
					throw new Error("VisitorState.set: Nothing on the stack");
				} else {
					return;
				}
			}

			// Find stack item
			const stackIndex = this.getIndex(opts.find);
			if (stackIndex === -1) {
				if (opts.required) {
					throw new Error("VisitorState.set: Could not find stack");
				} else {
					return;
				}
			}

			const [state, path] = this.stack[stackIndex];

			// Optionally
			if (typeof partial === "function") {
				partial = partial(state);
			}

			// Allow passing in the existing state as a noop
			if (partial === state) {
				return;
			}

			// Update the state
			// NB: Wonder if we'd get away with an `Object.assign`...?
			const newState = Object.assign({}, state, partial);
			this.stack[stackIndex] = [newState, path];
		}
	}


  // project-rome/@internal/compiler/lib/CompilerContext.ts
class ___R$project$rome$$internal$compiler$lib$CompilerContext_ts$default {
		constructor(arg) {
			const {
				ast,
				origin,
				ref,
				frozen = false,
				options = {},
				project = {
					directory: undefined,
					config: ___R$project$rome$$internal$project$types_ts$createDefaultProjectConfig(),
				},
				suppressions = [],
			} = arg;

			this.records = [];

			this.ast = ast;
			this.path = ___R$project$rome$$internal$path$index_ts$createUnknownPath(
				ast.filename,
			);
			this.filename = ast.filename;
			this.displayFilename =
				ref === undefined ? ast.filename : ref.relative.join();
			this.frozen = frozen;
			this.mtime = ast.mtime;
			this.project = project;
			this.options = options;
			this.origin = origin;
			this.cacheDependencies = new Set();
			this.language = ___R$project$rome$$internal$cli$diagnostics$utils_ts$inferDiagnosticLanguageFromRootAST(
				ast,
			);
			this.sourceTypeJS = ast.type === "JSRoot" ? ast.sourceType : undefined;
			this.rootScope = new ___R$project$rome$$internal$compiler$scope$Scope_ts$RootScope(
				this,
				ast,
			);

			this.comments = new ___R$project$rome$$internal$js$parser$CommentsConsumer_ts$default(
				ast.comments,
			);
			this.diagnostics = new ___R$project$rome$$internal$diagnostics$DiagnosticsProcessor_ts$default();

			this.reducedRoot = false;
			this.suppressions = suppressions;
			this.visitSuppressions = arg.suppressions === undefined;

			this.visitorStates = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
				"visitorStates",
				() =>
					new ___R$project$rome$$internal$compiler$lib$VisitorState_ts$default()
				,
			);
		}

		getVisitorState(visitor) {
			const state = this.visitorStates.assert(visitor);
			return (state);
		}

		async normalizeTransforms(transforms) {
			return Promise.all(
				transforms.map(async (visitor) => {
					if (typeof visitor === "function") {
						return await visitor(this);
					} else {
						return visitor;
					}
				}),
			);
		}

		checkOverlappingSuppressions() {
			// Check for overlapping suppressions
			const nonOverlapSuppressions = new Map();
			for (const suppression of this.suppressions) {
				if (nonOverlapSuppressions.has(suppression.category)) {
					const previousSuppression = nonOverlapSuppressions.get(
						suppression.category,
					);
					const currentSuppression = suppression;
					if (
						currentSuppression.startLine > previousSuppression.startLine &&
						currentSuppression.endLine <= previousSuppression.endLine
					) {
						this.diagnostics.addDiagnostic({
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SUPPRESSIONS.OVERLAP(
								suppression.category,
							),
							location: suppression.commentLocation,
						});
					} else {
						// Replace suppression to compare to later suppressions
						nonOverlapSuppressions.set(suppression.category, suppression);
					}
				} else {
					nonOverlapSuppressions.set(suppression.category, suppression);
				}
			}
		}

		hasLocSuppression(loc, category) {
			if (loc === undefined) {
				return false;
			}

			for (const suppression of this.suppressions) {
				if (
					___R$project$rome$$internal$compiler$suppressions_ts$matchesSuppression(
						category,
						loc,
						suppression,
					)
				) {
					return true;
				}
			}

			return false;
		}

		getCacheDependencies() {
			return Array.from(this.cacheDependencies);
		}

		addCacheDependency(filename) {
			this.cacheDependencies.add(filename);
		}

		reduceRoot(visitors, ast = this.ast) {
			if (this.reducedRoot) {
				throw new Error("reduceRoot has already been called");
			}

			const node = ___R$project$rome$$internal$js$ast$utils$assertSingleNode_ts$assertSingleNode(
				___R$project$rome$$internal$compiler$methods$reduce_ts$reduceNode(
					ast,
					[
						___R$project$rome$$internal$compiler$suppressions_ts$createSuppressionsVisitor(),
						...___R$project$rome$$internal$compiler$transforms$index_ts$helperVisitors,
						___R$project$rome$$internal$compiler$transforms$cleanTransform_ts$default,
						...(Array.isArray(visitors) ? visitors : [visitors]),
					],
					this,
				),
			);
			if (!___R$project$rome$$internal$ast$utils$isRoot_ts$isRoot(node)) {
				throw new Error("Expected root to be returned from reduce");
			}

			if (this.visitSuppressions) {
				this.checkOverlappingSuppressions();
			}

			return node;
		}

		reduce(ast, visitors, pathOpts) {
			return ___R$project$rome$$internal$compiler$methods$reduce_ts$reduceNode(
				ast,
				visitors,
				this,
				pathOpts,
			);
		}

		record(record) {
			this.records.push(record);
		}

		hasLintDecisions() {
			const {lint} = this.options;
			return lint !== undefined && lint.hasDecisions === true;
		}

		getLintDecisions(key) {
			const {lint} = this.options;
			if (lint === undefined) {
				return [];
			}

			const {globalDecisions = []} = lint;

			if (key === undefined) {
				return globalDecisions;
			}

			const {decisionsByPosition} = lint;
			if (decisionsByPosition === undefined) {
				return globalDecisions;
			}

			return [...globalDecisions, ...(decisionsByPosition[key] || [])];
		}

		addLocDiagnostic(loc, description, contextDiag = {}) {
			let origins = [];
			if (this.origin !== undefined) {
				origins.push(this.origin);
			}
			if (contextDiag.origins !== undefined) {
				origins = origins.concat(contextDiag.origins);
			}

			if (loc !== undefined && loc.filename !== this.filename) {
				throw new Error(
					"Trying to add a location from " +
					loc.filename +
					" on a Context from " +
					this.path,
				);
			}

			const {category} = description;
			const advice = [...description.advice];
			if (loc !== undefined && loc.start !== undefined) {
				advice.push(
					___R$project$rome$$internal$compiler$lint$decisions_ts$buildLintDecisionAdviceAction({
						noun: ___R$project$rome$$internal$markup$escape_ts$markup`Add suppression comment`,
						shortcut: "s",
						instruction: ___R$project$rome$$internal$markup$escape_ts$markup`To suppress this error run`,
						filename: this.displayFilename,
						decision: ___R$project$rome$$internal$compiler$lint$decisions_ts$buildLintDecisionString({
							filename: this.displayFilename,
							action: "suppress",
							category,
							start: loc.start,
						}),
					}),
				);

				advice.push(
					___R$project$rome$$internal$compiler$lint$decisions_ts$buildLintDecisionAdviceAction({
						extra: true,
						noun: ___R$project$rome$$internal$markup$escape_ts$markup`Add suppression comments for ALL files with this category`,
						instruction: ___R$project$rome$$internal$markup$escape_ts$markup`To add suppression comments for ALL files with this category run`,
						decision: ___R$project$rome$$internal$compiler$lint$decisions_ts$buildLintDecisionGlobalString(
							"suppress",
							category,
						),
					}),
				);
			}
			const ___R$ = contextDiag;
			const diag = Object.assign({}, ___R$);
			delete diag.marker;
			const {marker} = ___R$;
			const diagnostic = this.diagnostics.addDiagnostic(
				Object.assign(
					{},
					diag,
					{
						description: Object.assign({}, description, {advice}),
						location: {
							marker,
							mtime: this.mtime,
							filename: this.filename,
							start: loc === undefined ? undefined : loc.start,
							end: loc === undefined ? undefined : loc.end,
							sourceTypeJS: this.sourceTypeJS,
							language: this.language,
						},
						origins,
					},
				),
			);

			let suppressed = this.hasLocSuppression(loc, description.category);

			// If we've been passed lint decisions then consider it suppressed unless we have been specifically told to fix it
			const diagCategory = description.category;
			if (this.hasLintDecisions()) {
				suppressed = true;

				const decisions = this.getLintDecisions(
					___R$project$rome$$internal$compiler$lint$decisions_ts$deriveDecisionPositionKey(
						"fix",
						loc,
					),
				);
				for (const {category, action} of decisions) {
					if (category === diagCategory && action === "fix") {
						suppressed = false;
					}
				}
			}

			return {
				loc,
				diagnostic,
				suppressed,
			};
		}

		getLoc(node) {
			if (node === undefined) {
				return undefined;
			}

			if (Array.isArray(node)) {
				return ___R$project$rome$$internal$parser$core$utils_ts$extractSourceLocationRangeFromNodes(
					node,
				);
			} else {
				return node.loc;
			}
		}

		addNodeDiagnostic(node, description, diag = {}) {
			return this.addLocDiagnostic(this.getLoc(node), description, diag);
		}
	}


  // project-rome/@internal/string-diff/index.ts
/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
	const ___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_DELETE = -1;
	const ___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_INSERT = 1;
	const ___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_EQUAL = 0;
	const ___R$project$rome$$internal$string$diff$index_ts$diffConstants = {
		DELETE: ___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_DELETE,
		EQUAL: ___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_EQUAL,
		ADD: ___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_INSERT,
	};

	function ___R$$priv$project$rome$$internal$string$diff$index_ts$generateLineKey(
		beforeLine,
		afterLine,
	) {
		return (beforeLine || "") + ":" + (afterLine || "");
	}

	function ___R$project$rome$$internal$string$diff$index_ts$stringDiffUnified(
		rawDiffs,
	) {
		const modifiedLines = new Set();
		const insertedLines = new Map();
		const beforeLineToAfter = new Map();

		let beforeLine = 1;
		let afterLine = 1;

		function hasModifiedLine(beforeLine, afterLine) {
			return modifiedLines.has(
				___R$$priv$project$rome$$internal$string$diff$index_ts$generateLineKey(
					beforeLine,
					afterLine,
				),
			);
		}

		function maybeGetLine(beforeLine, afterLine) {
			return insertedLines.get(
				___R$$priv$project$rome$$internal$string$diff$index_ts$generateLineKey(
					beforeLine,
					afterLine,
				),
			);
		}

		function getLine(beforeLine, afterLine) {
			const key = ___R$$priv$project$rome$$internal$string$diff$index_ts$generateLineKey(
				beforeLine,
				afterLine,
			);

			const existing = insertedLines.get(key);
			if (existing !== undefined) {
				return existing;
			}

			const line = {
				beforeLine,
				afterLine,
				diffs: [],
			};
			insertedLines.set(key, line);
			return line;
		}

		function pushToLine(diff) {
			switch (diff[0]) {
				case ___R$project$rome$$internal$string$diff$index_ts$diffConstants.ADD: {
					getLine(undefined, afterLine).diffs.push(diff);
					modifiedLines.add(
						___R$$priv$project$rome$$internal$string$diff$index_ts$generateLineKey(
							undefined,
							afterLine,
						),
					);
					break;
				}

				case ___R$project$rome$$internal$string$diff$index_ts$diffConstants.DELETE: {
					getLine(beforeLine, undefined).diffs.push(diff);
					modifiedLines.add(
						___R$$priv$project$rome$$internal$string$diff$index_ts$generateLineKey(
							beforeLine,
						),
					);
					break;
				}

				case ___R$project$rome$$internal$string$diff$index_ts$diffConstants.EQUAL: {
					// We are still on the first line
					if (beforeLine === 1 && afterLine === 1) {
						beforeLineToAfter.set(1, 1);
					}

					getLine(undefined, afterLine).diffs.push(diff);
					getLine(beforeLine, undefined).diffs.push(diff);
					break;
				}
			}
		}

		for (const tuple of rawDiffs) {
			const [type, text] = tuple;

			// Get all the lines
			const parts = text.split("\n");

			// Doesn't contain a newline
			if (parts.length <= 1) {
				pushToLine(tuple);
				continue;
			}

			// Deconstruct each text chunk
			const [currentLine, ...futureLines] = parts;

			// The first chunk belongs to the current line
			if (currentLine !== "") {
				pushToLine([type, currentLine]);
			}

			// Create unique lines for each other chunk
			for (const newLine of futureLines) {
				switch (type) {
					case ___R$project$rome$$internal$string$diff$index_ts$diffConstants.EQUAL: {
						afterLine++;
						beforeLine++;
						break;
					}

					case ___R$project$rome$$internal$string$diff$index_ts$diffConstants.DELETE: {
						beforeLine++;
						break;
					}

					case ___R$project$rome$$internal$string$diff$index_ts$diffConstants.ADD: {
						afterLine++;
						break;
					}
				}

				beforeLineToAfter.set(beforeLine, afterLine);
				pushToLine([type, newLine]);
			}
		}

		const beforeLineCount = beforeLine;
		const afterLineCount = afterLine;

		// Merge identical lines
		for (let beforeLine = 1; beforeLine <= beforeLineCount; beforeLine++) {
			let afterLine = beforeLineToAfter.get(beforeLine);
			if (!hasModifiedLine(beforeLine) && !hasModifiedLine(undefined, afterLine)) {
				const line = getLine(beforeLine);
				insertedLines.delete(
					___R$$priv$project$rome$$internal$string$diff$index_ts$generateLineKey(
						beforeLine,
						undefined,
					),
				);
				insertedLines.delete(
					___R$$priv$project$rome$$internal$string$diff$index_ts$generateLineKey(
						undefined,
						afterLine,
					),
				);
				insertedLines.set(
					___R$$priv$project$rome$$internal$string$diff$index_ts$generateLineKey(
						beforeLine,
						afterLine,
					),
					{beforeLine, afterLine, diffs: line.diffs},
				);
			}
		}

		const diffsByLineWithBeforeAndShared = [];

		// Print before lines, including those that are shared
		for (let beforeLine = 1; beforeLine <= beforeLineCount; beforeLine++) {
			const line = maybeGetLine(beforeLine);
			if (line !== undefined) {
				diffsByLineWithBeforeAndShared.push(line);
			}

			// If we have a shared line then add it
			const afterLine = beforeLineToAfter.get(beforeLine);
			if (afterLine !== undefined) {
				const line = maybeGetLine(beforeLine, afterLine);
				if (line !== undefined) {
					diffsByLineWithBeforeAndShared.push(line);
				}
			}
		}

		let lastPrintedAfter = 0;
		let diffsByLine = [];

		function catchUpAfter(afterLine) {
			for (let i = lastPrintedAfter + 1; i <= afterLine; i++) {
				const line = maybeGetLine(undefined, i);
				if (line !== undefined) {
					diffsByLine.push(line);
				}
			}
			lastPrintedAfter = afterLine;
		}

		// Catch up after lines when we hit a shared line
		for (const line of diffsByLineWithBeforeAndShared) {
			const {afterLine} = line;
			if (afterLine !== undefined) {
				catchUpAfter(afterLine);
			}
			diffsByLine.push(line);
		}

		// Push on remaining lines at the end
		catchUpAfter(afterLineCount);

		return {
			diffsByLine,
			beforeLineCount,
			afterLineCount,
		};
	}

	function ___R$project$rome$$internal$string$diff$index_ts$default(
		text1,
		text2,
	) {
		// only pass fix_unicode=true at the top level, not when main is
		// recursively invoked
		return ___R$$priv$project$rome$$internal$string$diff$index_ts$main(
			text1,
			text2,
			true,
		);
	}

	/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {Int|Object} [cursor_pos] Edit position in text1 or object with more info
 * @return {Array} Array of diff tuples.
 */
	function ___R$$priv$project$rome$$internal$string$diff$index_ts$main(
		text1,
		text2,
		fixUnicode = false,
	) {
		// Check for equality
		if (text1 === text2) {
			if (text1) {
				return [
					[
						___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_EQUAL,
						text1,
					],
				];
			}
			return [];
		}

		// Trim off common prefix (speedup).
		let commonlength = ___R$$priv$project$rome$$internal$string$diff$index_ts$commonPrefix(
			text1,
			text2,
		);
		let commonprefix = text1.substring(0, commonlength);
		text1 = text1.substring(commonlength);
		text2 = text2.substring(commonlength);

		// Trim off common suffix (speedup).
		commonlength = ___R$$priv$project$rome$$internal$string$diff$index_ts$commonSuffix(
			text1,
			text2,
		);
		let commonsuffix = text1.substring(text1.length - commonlength);
		text1 = text1.substring(0, text1.length - commonlength);
		text2 = text2.substring(0, text2.length - commonlength);

		// Compute the diff on the middle block.
		let diffs = ___R$$priv$project$rome$$internal$string$diff$index_ts$compute(
			text1,
			text2,
		);

		// Restore the prefix and suffix.
		if (commonprefix) {
			diffs.unshift([
				___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_EQUAL,
				commonprefix,
			]);
		}
		if (commonsuffix) {
			diffs.push([
				___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_EQUAL,
				commonsuffix,
			]);
		}
		___R$$priv$project$rome$$internal$string$diff$index_ts$cleanupMerge(
			diffs,
			fixUnicode,
		);
		return diffs;
	}

	/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {Array} Array of diff tuples.
 */
	function ___R$$priv$project$rome$$internal$string$diff$index_ts$compute(
		text1,
		text2,
	) {
		let diffs = [];

		if (!text1) {
			// Just add some text (speedup).
			return [
				[
					___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_INSERT,
					text2,
				],
			];
		}

		if (!text2) {
			// Just delete some text (speedup).
			return [
				[
					___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_DELETE,
					text1,
				],
			];
		}

		let longtext = text1.length > text2.length ? text1 : text2;
		let shorttext = text1.length > text2.length ? text2 : text1;
		let i = longtext.indexOf(shorttext);
		if (i !== -1) {
			// Shorter text is inside the longer text (speedup).
			diffs = [
				[
					___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_INSERT,
					longtext.substring(0, i),
				],
				[
					___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_EQUAL,
					shorttext,
				],
				[
					___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_INSERT,
					longtext.substring(i + shorttext.length),
				],
			];
			// Swap insertions for deletions if diff is reversed.
			if (text1.length > text2.length) {
				diffs[0][0] = diffs[2][0] = ___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_DELETE;
			}
			return diffs;
		}

		if (shorttext.length === 1) {
			// Single character string.
			// After the previous speedup, the character can't be an equality.
			return [
				[
					___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_DELETE,
					text1,
				],
				[
					___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_INSERT,
					text2,
				],
			];
		}

		// Check to see if the problem can be split in two.
		let hm = ___R$$priv$project$rome$$internal$string$diff$index_ts$halfMatch(
			text1,
			text2,
		);
		if (hm) {
			// A half-match was found, sort out the return data.
			let text1A = hm[0];
			let text1B = hm[1];
			let text2A = hm[2];
			let text2B = hm[3];
			let midCommon = hm[4];
			// Send both pairs off for separate processing.
			let diffsA = ___R$$priv$project$rome$$internal$string$diff$index_ts$main(
				text1A,
				text2A,
			);
			let diffsB = ___R$$priv$project$rome$$internal$string$diff$index_ts$main(
				text1B,
				text2B,
			);
			// Merge the results.
			return diffsA.concat(
				[
					[
						___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_EQUAL,
						midCommon,
					],
				],
				diffsB,
			);
		}

		return ___R$$priv$project$rome$$internal$string$diff$index_ts$bisect(
			text1,
			text2,
		);
	}

	/**
 * Find the 'middle snake' of a diff, split the problem in two
 * and return the recursively constructed diff.
 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {Array} Array of diff tuples.
 * @private
 */
	function ___R$$priv$project$rome$$internal$string$diff$index_ts$bisect(
		text1,
		text2,
	) {
		// Cache the text lengths to prevent multiple calls.
		let text1Length = text1.length;
		let text2Length = text2.length;
		let maxD = Math.ceil((text1Length + text2Length) / 2);
		let vOffset = maxD;
		let vLength = 2 * maxD;
		let v1 = new Array(vLength);
		let v2 = new Array(vLength);

		// Setting all elements to -1 is faster in Chrome & Firefox than mixing
		// integers and undefined.
		for (let x = 0; x < vLength; x++) {
			v1[x] = -1;
			v2[x] = -1;
		}
		v1[vOffset + 1] = 0;
		v2[vOffset + 1] = 0;
		let delta = text1Length - text2Length;

		// If the total number of characters is odd, then the front path will collide
		// with the reverse path.
		let front = delta % 2 !== 0;

		// Offsets for start and end of k loop.
		// Prevents mapping of space beyond the grid.
		let k1Start = 0;
		let k1End = 0;
		let k2Start = 0;
		let k2End = 0;
		for (let d = 0; d < maxD; d++) {
			// Walk the front path one step.
			for (let k1 = -d + k1Start; k1 <= d - k1End; k1 += 2) {
				let k1Offset = vOffset + k1;
				let x1;
				if (k1 === -d || (k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1])) {
					x1 = v1[k1Offset + 1];
				} else {
					x1 = v1[k1Offset - 1] + 1;
				}
				let y1 = x1 - k1;
				while (
					x1 < text1Length &&
					y1 < text2Length &&
					text1.charAt(x1) === text2.charAt(y1)
				) {
					x1++;
					y1++;
				}
				v1[k1Offset] = x1;
				if (x1 > text1Length) {
					// Ran off the right of the graph.
					k1End += 2;
				} else if (y1 > text2Length) {
					// Ran off the bottom of the graph.
					k1Start += 2;
				} else if (front) {
					let k2Offset = vOffset + delta - k1;
					if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {
						// Mirror x2 onto top-left coordinate system.
						let x2 = text1Length - v2[k2Offset];
						if (x1 >= x2) {
							// Overlap detected.
							return ___R$$priv$project$rome$$internal$string$diff$index_ts$bisectSplit(
								text1,
								text2,
								x1,
								y1,
							);
						}
					}
				}
			}

			// Walk the reverse path one step.
			for (let k2 = -d + k2Start; k2 <= d - k2End; k2 += 2) {
				let k2Offset = vOffset + k2;
				let x2;
				if (k2 === -d || (k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1])) {
					x2 = v2[k2Offset + 1];
				} else {
					x2 = v2[k2Offset - 1] + 1;
				}
				let y2 = x2 - k2;
				while (
					x2 < text1Length &&
					y2 < text2Length &&
					text1.charAt(text1Length - x2 - 1) ===
					text2.charAt(text2Length - y2 - 1)
				) {
					x2++;
					y2++;
				}
				v2[k2Offset] = x2;
				if (x2 > text1Length) {
					// Ran off the left of the graph.
					k2End += 2;
				} else if (y2 > text2Length) {
					// Ran off the top of the graph.
					k2Start += 2;
				} else if (!front) {
					let k1Offset = vOffset + delta - k2;
					if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {
						let x1 = v1[k1Offset];
						let y1 = vOffset + x1 - k1Offset;
						// Mirror x2 onto top-left coordinate system.
						x2 = text1Length - x2;
						if (x1 >= x2) {
							// Overlap detected.
							return ___R$$priv$project$rome$$internal$string$diff$index_ts$bisectSplit(
								text1,
								text2,
								x1,
								y1,
							);
						}
					}
				}
			}
		}

		// Diff took too long and hit the deadline or
		// number of diffs equals number of characters, no commonality at all.
		return [
			[
				___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_DELETE,
				text1,
			],
			[
				___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_INSERT,
				text2,
			],
		];
	}

	/**
 * Given the location of the 'middle snake', split the diff in two parts
 * and recurse.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} x Index of split point in text1.
 * @param {number} y Index of split point in text2.
 * @return {Array} Array of diff tuples.
 */
	function ___R$$priv$project$rome$$internal$string$diff$index_ts$bisectSplit(
		text1,
		text2,
		x,
		y,
	) {
		let text1A = text1.substring(0, x);
		let text2A = text2.substring(0, y);
		let text1B = text1.substring(x);
		let text2B = text2.substring(y);

		// Compute both diffs serially.
		let diffs = ___R$$priv$project$rome$$internal$string$diff$index_ts$main(
			text1A,
			text2A,
		);
		let diffsb = ___R$$priv$project$rome$$internal$string$diff$index_ts$main(
			text1B,
			text2B,
		);

		return diffs.concat(diffsb);
	}

	/**
 * Determine the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
	function ___R$$priv$project$rome$$internal$string$diff$index_ts$commonPrefix(
		text1,
		text2,
	) {
		// Quick check for common null cases.
		if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
			return 0;
		}

		// Binary search.
		// Performance analysis: http://neil.fraser.name/news/2007/10/09/
		let pointermin = 0;
		let pointermax = Math.min(text1.length, text2.length);
		let pointermid = pointermax;
		let pointerstart = 0;
		while (pointermin < pointermid) {
			if (
				text1.substring(pointerstart, pointermid) ===
				text2.substring(pointerstart, pointermid)
			) {
				pointermin = pointermid;
				pointerstart = pointermin;
			} else {
				pointermax = pointermid;
			}
			pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
		}

		if (
			___R$$priv$project$rome$$internal$string$diff$index_ts$isSurrogatePairStart(
				text1.charCodeAt(pointermid - 1),
			)
		) {
			pointermid--;
		}

		return pointermid;
	}

	/**
 * Determine the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
	function ___R$$priv$project$rome$$internal$string$diff$index_ts$commonSuffix(
		text1,
		text2,
	) {
		// Quick check for common null cases.
		if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {
			return 0;
		}

		// Binary search.

		// Performance analysis: http://neil.fraser.name/news/2007/10/09/
		let pointermin = 0;
		let pointermax = Math.min(text1.length, text2.length);
		let pointermid = pointermax;
		let pointerend = 0;
		while (pointermin < pointermid) {
			if (
				text1.substring(text1.length - pointermid, text1.length - pointerend) ===
				text2.substring(text2.length - pointermid, text2.length - pointerend)
			) {
				pointermin = pointermid;
				pointerend = pointermin;
			} else {
				pointermax = pointermid;
			}
			pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
		}

		if (
			___R$$priv$project$rome$$internal$string$diff$index_ts$isSurrogatePairEnd(
				text1.charCodeAt(text1.length - pointermid),
			)
		) {
			pointermid--;
		}

		return pointermid;
	}

	/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 */
	function ___R$$priv$project$rome$$internal$string$diff$index_ts$halfMatch(
		text1,
		text2,
	) {
		let longtext = text1.length > text2.length ? text1 : text2;
		let shorttext = text1.length > text2.length ? text2 : text1;
		if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
			return undefined; // Pointless.
		}

		// First check if the second quarter is the seed for a half-match.
		let hm1 = ___R$$priv$project$rome$$internal$string$diff$index_ts$halfMatchI(
			longtext,
			shorttext,
			Math.ceil(longtext.length / 4),
		);

		// Check again based on the third quarter.
		let hm2 = ___R$$priv$project$rome$$internal$string$diff$index_ts$halfMatchI(
			longtext,
			shorttext,
			Math.ceil(longtext.length / 2),
		);

		let hm;
		if (!hm1 && !hm2) {
			return undefined;
		} else if (hm2) {
			if (hm1) {
				// Both matched.  Select the longest.
				hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
			} else {
				hm = hm2;
			}
		} else {
			hm = hm1;
		}

		if (hm === undefined) {
			throw new Error("Expected half match");
		}

		// A half-match was found, sort out the return data.
		let text1A;
		let text1B;
		let text2A;
		let text2B;
		if (text1.length > text2.length) {
			text1A = hm[0];
			text1B = hm[1];
			text2A = hm[2];
			text2B = hm[3];
		} else {
			text2A = hm[0];
			text2B = hm[1];
			text1A = hm[2];
			text1B = hm[3];
		}
		let midCommon = hm[4];
		return [text1A, text1B, text2A, text2B, midCommon];
	}

	/**
 * Does a substring of shorttext exist within longtext such that the substring
 * is at least half the length of longtext?
 * Closure, but does not reference any external variables.
 * @param {string} longtext Longer string.
 * @param {string} shorttext Shorter string.
 * @param {number} i Start index of quarter length substring within longtext.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
 *     of shorttext and the common middle.  Or null if there was no match.
 * @private
 */
	function ___R$$priv$project$rome$$internal$string$diff$index_ts$halfMatchI(
		longtext,
		shorttext,
		i,
	) {
		// Start with a 1/4 length substring at position i as a seed.
		let seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
		let j = -1;
		let bestCommon = "";
		let bestLongtextA = "";
		let bestLongtextB = "";
		let bestShorttextA = "";
		let bestShorttextB = "";
		while ((j = shorttext.indexOf(seed, j + 1)) !== -1) {
			let prefixLength = ___R$$priv$project$rome$$internal$string$diff$index_ts$commonPrefix(
				longtext.substring(i),
				shorttext.substring(j),
			);
			let suffixLength = ___R$$priv$project$rome$$internal$string$diff$index_ts$commonSuffix(
				longtext.substring(0, i),
				shorttext.substring(0, j),
			);
			if (bestCommon.length < suffixLength + prefixLength) {
				bestCommon =
					shorttext.substring(j - suffixLength, j) +
					shorttext.substring(j, j + prefixLength);
				bestLongtextA = longtext.substring(0, i - suffixLength);
				bestLongtextB = longtext.substring(i + prefixLength);
				bestShorttextA = shorttext.substring(0, j - suffixLength);
				bestShorttextB = shorttext.substring(j + prefixLength);
			}
		}

		if (bestCommon.length * 2 >= longtext.length) {
			return [
				bestLongtextA,
				bestLongtextB,
				bestShorttextA,
				bestShorttextB,
				bestCommon,
			];
		} else {
			return undefined;
		}
	}

	/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {Array} diffs Array of diff tuples.
 * @param {boolean} fix_unicode Whether to normalize to a unicode-correct diff
 */
	function ___R$$priv$project$rome$$internal$string$diff$index_ts$cleanupMerge(
		diffs,
		fixUnicode,
	) {
		diffs.push([
			___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_EQUAL,
			"",
		]); // Add a dummy entry at the end.
		let pointer = 0;
		let countDelete = 0;
		let countInsert = 0;
		let textDelete = "";
		let textInsert = "";
		let commonlength;
		while (pointer < diffs.length) {
			if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
				diffs.splice(pointer, 1);
				continue;
			}
			switch (diffs[pointer][0]) {
				case ___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_INSERT: {
					countInsert++;
					textInsert += diffs[pointer][1];
					pointer++;
					break;
				}
				case ___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_DELETE: {
					countDelete++;
					textDelete += diffs[pointer][1];
					pointer++;
					break;
				}
				case ___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_EQUAL: {
					let previousEquality = pointer - countInsert - countDelete - 1;
					if (fixUnicode) {
						// prevent splitting of unicode surrogate pairs.  when fix_unicode is true,
						// we assume that the old and new text in the diff are complete and correct
						// unicode-encoded JS strings, but the tuple boundaries may fall between
						// surrogate pairs.  we fix this by shaving off stray surrogates from the end
						// of the previous equality and the beginning of this equality.  this may create
						// empty equalities or a common prefix or suffix.  for example, if AB and AC are
						// emojis, `[[0, 'A'], [-1, 'BA'], [0, 'C']]` would turn into deleting 'ABAC' and
						// inserting 'AC', and then the common suffix 'AC' will be eliminated.  in this
						// particular case, both equalities go away, we absorb any previous inequalities,
						// and we keep scanning for the next equality before rewriting the tuples.
						if (
							previousEquality >= 0 &&
							___R$$priv$project$rome$$internal$string$diff$index_ts$endsWithPairStart(
								diffs[previousEquality][1],
							)
						) {
							let stray = diffs[previousEquality][1].slice(-1);
							diffs[previousEquality][1] = diffs[previousEquality][1].slice(
								0,
								-1,
							);
							textDelete = stray + textDelete;
							textInsert = stray + textInsert;
							if (!diffs[previousEquality][1]) {
								// emptied out previous equality, so delete it and include previous delete/insert
								diffs.splice(previousEquality, 1);
								pointer--;
								let k = previousEquality - 1;
								if (
									diffs[k] &&
									diffs[k][0] ===
									___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_INSERT
								) {
									countInsert++;
									textInsert = diffs[k][1] + textInsert;
									k--;
								}
								if (
									diffs[k] &&
									diffs[k][0] ===
									___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_DELETE
								) {
									countDelete++;
									textDelete = diffs[k][1] + textDelete;
									k--;
								}
								previousEquality = k;
							}
						}
						if (
							___R$$priv$project$rome$$internal$string$diff$index_ts$startsWithPairEnd(
								diffs[pointer][1],
							)
						) {
							let stray = diffs[pointer][1].charAt(0);
							diffs[pointer][1] = diffs[pointer][1].slice(1);
							textDelete += stray;
							textInsert += stray;
						}
					}
					if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
						// for empty equality not at end, wait for next equality
						diffs.splice(pointer, 1);
						break;
					}
					if (textDelete.length > 0 || textInsert.length > 0) {
						// note that commonPrefix and commonSuffix are unicode-aware
						if (textDelete.length > 0 && textInsert.length > 0) {
							// Factor out any common prefixes.
							commonlength = ___R$$priv$project$rome$$internal$string$diff$index_ts$commonPrefix(
								textInsert,
								textDelete,
							);
							if (commonlength !== 0) {
								if (previousEquality >= 0) {
									diffs[previousEquality][1] += textInsert.substring(
										0,
										commonlength,
									);
								} else {
									diffs.splice(
										0,
										0,
										[
											___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_EQUAL,
											textInsert.substring(0, commonlength),
										],
									);
									pointer++;
								}
								textInsert = textInsert.substring(commonlength);
								textDelete = textDelete.substring(commonlength);
							}

							// Factor out any common suffixes.
							commonlength = ___R$$priv$project$rome$$internal$string$diff$index_ts$commonSuffix(
								textInsert,
								textDelete,
							);
							if (commonlength !== 0) {
								diffs[pointer][1] =
									textInsert.substring(textInsert.length - commonlength) +
									diffs[pointer][1];
								textInsert = textInsert.substring(
									0,
									textInsert.length - commonlength,
								);
								textDelete = textDelete.substring(
									0,
									textDelete.length - commonlength,
								);
							}
						}

						// Delete the offending records and add the merged ones.
						let n = countInsert + countDelete;
						if (textDelete.length === 0 && textInsert.length === 0) {
							diffs.splice(pointer - n, n);
							pointer = pointer - n;
						} else if (textDelete.length === 0) {
							diffs.splice(
								pointer - n,
								n,
								[
									___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_INSERT,
									textInsert,
								],
							);
							pointer = pointer - n + 1;
						} else if (textInsert.length === 0) {
							diffs.splice(
								pointer - n,
								n,
								[
									___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_DELETE,
									textDelete,
								],
							);
							pointer = pointer - n + 1;
						} else {
							diffs.splice(
								pointer - n,
								n,
								[
									___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_DELETE,
									textDelete,
								],
								[
									___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_INSERT,
									textInsert,
								],
							);
							pointer = pointer - n + 2;
						}
					}
					if (
						pointer !== 0 &&
						diffs[pointer - 1][0] ===
						___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_EQUAL
					) {
						// Merge this equality with the previous one.
						diffs[pointer - 1][1] += diffs[pointer][1];
						diffs.splice(pointer, 1);
					} else {
						pointer++;
					}
					countInsert = 0;
					countDelete = 0;
					textDelete = "";
					textInsert = "";
					break;
				}
			}
		}
		if (diffs[diffs.length - 1][1] === "") {
			// Remove the dummy entry at the end.
			diffs.pop();
		}

		// Second pass: look for single edits surrounded on both sides by equalities
		// which can be shifted sideways to eliminate an equality.
		// e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
		let changes = false;
		pointer = 1;

		// Intentionally ignore the first and last element (don't need checking).
		while (pointer < diffs.length - 1) {
			if (
				diffs[pointer - 1][0] ===
				___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_EQUAL &&
				diffs[pointer + 1][0] ===
				___R$$priv$project$rome$$internal$string$diff$index_ts$DIFF_EQUAL
			) {
				// This is a single edit surrounded by equalities.
				if (
					diffs[pointer][1].substring(
						diffs[pointer][1].length - diffs[pointer - 1][1].length,
					) ===
					diffs[pointer - 1][1]
				) {
					// Shift the edit over the previous equality.
					diffs[pointer][1] =
						diffs[pointer - 1][1] +
						diffs[pointer][1].substring(
							0,
							diffs[pointer][1].length - diffs[pointer - 1][1].length,
						);
					diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
					diffs.splice(pointer - 1, 1);
					changes = true;
				} else if (
					diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ===
					diffs[pointer + 1][1]
				) {
					// Shift the edit over the next equality.
					diffs[pointer - 1][1] += diffs[pointer + 1][1];
					diffs[pointer][1] =
						diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
						diffs[pointer + 1][1];
					diffs.splice(pointer + 1, 1);
					changes = true;
				}
			}
			pointer++;
		}

		// If shifts were made, the diff needs reordering and another shift sweep.
		if (changes) {
			___R$$priv$project$rome$$internal$string$diff$index_ts$cleanupMerge(
				diffs,
				fixUnicode,
			);
		}
	}

	function ___R$$priv$project$rome$$internal$string$diff$index_ts$isSurrogatePairStart(
		charCode,
	) {
		return charCode >= 55_296 && charCode <= 56_319;
	}

	function ___R$$priv$project$rome$$internal$string$diff$index_ts$isSurrogatePairEnd(
		charCode,
	) {
		return charCode >= 56_320 && charCode <= 57_343;
	}

	function ___R$$priv$project$rome$$internal$string$diff$index_ts$startsWithPairEnd(
		str,
	) {
		return ___R$$priv$project$rome$$internal$string$diff$index_ts$isSurrogatePairEnd(
			str.charCodeAt(0),
		);
	}

	function ___R$$priv$project$rome$$internal$string$diff$index_ts$endsWithPairStart(
		str,
	) {
		return ___R$$priv$project$rome$$internal$string$diff$index_ts$isSurrogatePairStart(
			str.charCodeAt(str.length - 1),
		);
	}


  // project-rome/@internal/formatter/node/parentheses.ts
function ___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$isClassExtendsClause(
		node,
		parent,
	) {
		return (
			(parent.type === "JSClassDeclaration" ||
			parent.type === "JSClassExpression") &&
			parent.meta.superClass === node
		);
	}

	const ___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$parens = new Map();
	const ___R$project$rome$$internal$formatter$node$parentheses_ts$default = ___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$parens;
	___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$parens.set(
		"TSAsExpression",
		() => true,
	);

	___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$parens.set(
		"TSAssignmentAsExpression",
		() => true,
	);

	___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$parens.set(
		"TSTypeAssertion",
		() => true,
	);

	___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$parens.set(
		"JSMemberExpression",
		(node, parent) => {
			if (node.property.optional) {
				return (
					(parent.type === "JSCallExpression" && parent.callee === node) ||
					(parent.type === "JSMemberExpression" && parent.object === node)
				);
			} else {
				return false;
			}
		},
	);

	___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$parens.set(
		"JSUpdateExpression",
		(node, parent) => {
			return (
				// (foo++).test(), (foo++)[0]
				(parent.type === "JSMemberExpression" && parent.object === node) ||
				// (foo++)()
				(parent.type === "JSCallExpression" && parent.callee === node) ||
				// new (foo++)()
				(parent.type === "JSNewExpression" && parent.callee === node) ||
				___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$isClassExtendsClause(
					node,
					parent,
				)
			);
		},
	);

	___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$parens.set(
		"JSObjectExpression",
		(node, parent, printStack) => {
			return ___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$isFirstInStatement(
				printStack,
				{considerArrow: true},
			);
		},
	);

	___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$parens.set(
		"JSDoExpression",
		(node, parent, printStack) => {
			return ___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$isFirstInStatement(
				printStack,
			);
		},
	);

	function ___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$needsParenLogicalExpression(
		node,
		parent,
	) {
		if (
			node.operator === "**" &&
			parent.type === "JSBinaryExpression" &&
			parent.operator === "**"
		) {
			return parent.left === node;
		}

		// class A extends (B ?? C) {
		if (
			___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$isClassExtendsClause(
				node,
				parent,
			)
		) {
			return true;
		}

		// (f ?? g)()
		// (f ?? g)?.()
		// new (A ?? B)()
		if (
			parent.type === "JSCallExpression" ||
			parent.type === "JSOptionalCallExpression" ||
			parent.type === "JSNewExpression"
		) {
			return parent.callee === node;
		}

		// ...(a ?? b)
		// await (a ?? b)
		if (
			___R$project$rome$$internal$js$ast$utils$isUnaryLike_ts$isUnaryLike(
				parent,
			) ||
			parent.type === "JSAwaitExpression"
		) {
			return true;
		}

		// (a ?? b).x
		// (a ?? b)?.x
		if (parent.type === "JSMemberExpression" && parent.object === node) {
			return true;
		}

		// (a ?? b) ?? c
		// a ?? (b ?? c)
		if (parent.type === "JSLogicalExpression") {
			if (node.type === "JSLogicalExpression") {
				return node.operator !== parent.operator;
			}
		}

		if (___R$project$rome$$internal$js$ast$utils$isBinary_ts$isBinary(parent)) {
			const parentOp = parent.operator;
			const parentPos = ___R$project$rome$$internal$js$ast$utils$getPrecedence_ts$getPrecedence(
				parentOp,
			);

			const nodeOp = node.operator;
			const nodePos = ___R$project$rome$$internal$js$ast$utils$getPrecedence_ts$getPrecedence(
				nodeOp,
			);

			if (
				// Logical expressions with the same precedence don't need parens.
				(parentPos === nodePos &&
				parent.right === node &&
				parent.type !== "JSLogicalExpression") ||
				parentPos > nodePos
			) {
				return true;
			}
		}

		return false;
	}

	___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$parens.set(
		"JSLogicalExpression",
		___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$needsParenLogicalExpression,
	);

	___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$parens.set(
		"JSBinaryExpression",
		(node, parent) => {
			// let i = (1 in []);
			// for ((1 in []);;);
			if (
				node.operator === "in" &&
				(parent.type === "JSVariableDeclarator" ||
				___R$project$rome$$internal$js$ast$utils$isFor_ts$isFor(parent))
			) {
				return true;
			}

			return ___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$needsParenLogicalExpression(
				node,
				parent,
			);
		},
	);

	___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$parens.set(
		"JSSequenceExpression",
		(node, parent) => {
			if (
				// Although parentheses wouldn't hurt around sequence
				// expressions in the head of for loops, traditional style
				// dictates that e.g. i++, j++ should not be wrapped with
				// parentheses.
				parent.type === "JSForStatement" ||
				parent.type === "JSThrowStatement" ||
				parent.type === "JSReturnStatement" ||
				(parent.type === "JSIfStatement" && parent.test === node) ||
				(parent.type === "JSWhileStatement" && parent.test === node) ||
				(parent.type === "JSForInStatement" && parent.right === node) ||
				(parent.type === "JSSwitchStatement" && parent.discriminant === node) ||
				(parent.type === "JSExpressionStatement" && parent.expression === node)
			) {
				return false;
			}

			// Arrow function builder handles the parens printing.
			if (parent.type === "JSArrowFunctionExpression") {
				return false;
			}

			// Otherwise err on the side of overparenthesization, adding
			// explicit exceptions above if this proves overzealous.
			return true;
		},
	);

	function ___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$needsParenYieldExpression(
		node,
		parent,
	) {
		return (
			___R$project$rome$$internal$js$ast$utils$isBinary_ts$isBinary(parent) ||
			___R$project$rome$$internal$js$ast$utils$isUnaryLike_ts$isUnaryLike(
				parent,
			) ||
			parent.type === "JSMemberExpression" ||
			(parent.type === "JSCallExpression" && parent.callee === node) ||
			(parent.type === "JSNewExpression" && parent.callee === node) ||
			(parent.type === "JSAwaitExpression" && node.type === "JSYieldExpression") ||
			(parent.type === "JSConditionalExpression" && node === parent.test) ||
			___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$isClassExtendsClause(
				node,
				parent,
			)
		);
	}

	___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$parens.set(
		"JSYieldExpression",
		___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$needsParenYieldExpression,
	);
	___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$parens.set(
		"JSAwaitExpression",
		___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$needsParenYieldExpression,
	);

	___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$parens.set(
		"JSOptionalCallExpression",
		(node, parent) => {
			return (
				(parent.type === "JSCallExpression" && parent.callee === node) ||
				(parent.type === "JSMemberExpression" && parent.object === node)
			);
		},
	);

	___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$parens.set(
		"JSClassExpression",
		(node, parent, printStack) => {
			return ___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$isFirstInStatement(
				printStack,
				{considerDefaultExports: true},
			);
		},
	);

	function ___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$needsParenUnaryExpression(
		node,
		parent,
	) {
		return (
			(parent.type === "JSMemberExpression" && parent.object === node) ||
			(parent.type === "JSCallExpression" && parent.callee === node) ||
			(parent.type === "JSNewExpression" && parent.callee === node) ||
			(parent.type === "JSBinaryExpression" &&
			parent.operator === "**" &&
			parent.left === node) ||
			___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$isClassExtendsClause(
				node,
				parent,
			)
		);
	}

	___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$parens.set(
		"JSUnaryExpression",
		___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$needsParenUnaryExpression,
	);
	___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$parens.set(
		"JSSpreadElement",
		___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$needsParenUnaryExpression,
	);
	___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$parens.set(
		"JSSpreadProperty",
		___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$needsParenUnaryExpression,
	);

	___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$parens.set(
		"JSFunctionExpression",
		(node, parent, printStack) => {
			return ___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$isFirstInStatement(
				printStack,
				{considerDefaultExports: true},
			);
		},
	);

	___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$parens.set(
		"JSArrowFunctionExpression",
		(node, parent) => {
			return (
				parent.type === "JSExportLocalDeclaration" ||
				___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$needsParenConditionalExpression(
					node,
					parent,
				)
			);
		},
	);

	function ___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$needsParenConditionalExpression(
		node,
		parent,
	) {
		if (
			___R$project$rome$$internal$js$ast$utils$isUnaryLike_ts$isUnaryLike(
				parent,
			) ||
			___R$project$rome$$internal$js$ast$utils$isBinary_ts$isBinary(parent) ||
			(parent.type === "JSConditionalExpression" && parent.test === node) ||
			parent.type === "JSAwaitExpression" ||
			(parent.type === "JSMemberExpression" &&
			parent.object === node &&
			parent.property.optional) ||
			(parent.type === "JSOptionalCallExpression" && parent.callee === node) ||
			parent.type === "JSTaggedTemplateExpression" ||
			parent.type === "TSTypeAssertion" ||
			parent.type === "TSAsExpression"
		) {
			return true;
		}

		return ___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$needsParenUnaryExpression(
			node,
			parent,
		);
	}

	___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$parens.set(
		"JSConditionalExpression",
		___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$needsParenConditionalExpression,
	);

	___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$parens.set(
		"JSAssignmentExpression",
		(node, parent) => {
			if (node.left.type === "JSAssignmentObjectPattern") {
				return true;
			} else {
				return ___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$needsParenConditionalExpression(
					node,
					parent,
				);
			}
		},
	);

	function ___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$needsParenUnionTypeAnnotation(
		node,
		parent,
	) {
		return (
			parent.type === "TSIntersectionTypeAnnotation" ||
			parent.type === "TSUnionTypeAnnotation" ||
			parent.type === "TSArrayType" ||
			(parent.type === "TSTupleElement" && parent.optional === true)
		);
	}

	___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$parens.set(
		"TSUnionTypeAnnotation",
		___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$needsParenUnionTypeAnnotation,
	);
	___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$parens.set(
		"TSIntersectionTypeAnnotation",
		___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$needsParenUnionTypeAnnotation,
	);

	___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$parens.set(
		"TSInferType",
		(node, parent) => {
			return (
				parent.type === "TSArrayType" ||
				(parent.type === "TSTupleElement" && parent.optional === true)
			);
		},
	);

	// Walk up the print stack to deterimine if our node can come first
	// in statement.
	function ___R$$priv$project$rome$$internal$formatter$node$parentheses_ts$isFirstInStatement(
		printStack,
		{considerArrow = false, considerDefaultExports = false} = {},
	) {
		let i = printStack.length - 1;
		let node = printStack[i];
		i--;
		let parent = printStack[i];
		while (i > 0) {
			if (
				(parent.type === "JSExpressionStatement" && parent.expression === node) ||
				parent.type === "JSTaggedTemplateExpression" ||
				(considerDefaultExports &&
				parent.type === "JSExportDefaultDeclaration" &&
				parent.declaration === node) ||
				(considerArrow &&
				parent.type === "JSArrowFunctionExpression" &&
				parent.body === node)
			) {
				return true;
			}

			if (
				(parent.type === "JSCallExpression" && parent.callee === node) ||
				(parent.type === "JSSequenceExpression" &&
				parent.expressions[0] === node) ||
				(parent.type === "JSMemberExpression" && parent.object === node) ||
				(___R$project$rome$$internal$js$ast$utils$isConditional_ts$isConditional(
					parent,
				) &&
				parent.test === node) ||
				(___R$project$rome$$internal$js$ast$utils$isBinary_ts$isBinary(parent) &&
				parent.left === node) ||
				(parent.type === "JSAssignmentExpression" && parent.left === node)
			) {
				node = parent;
				i--;
				parent = printStack[i];
			} else {
				return false;
			}
		}

		return false;
	}


  // project-rome/@internal/formatter/node/index.ts
const ___R$project$rome$$internal$formatter$node$index_ts = {
		getLinesBetween: ___R$project$rome$$internal$formatter$node$index_ts$getLinesBetween,
		needsParens: ___R$project$rome$$internal$formatter$node$index_ts$needsParens,
		isOnSameLine: ___R$project$rome$$internal$formatter$node$index_ts$isOnSameLine,
	};
	function ___R$$priv$project$rome$$internal$formatter$node$index_ts$isOrHasCallExpression(
		node,
	) {
		if (node.type === "JSCallExpression") {
			return true;
		}

		if (node.type === "JSComputedMemberProperty") {
			return ___R$$priv$project$rome$$internal$formatter$node$index_ts$isOrHasCallExpression(
				node.value,
			);
		}

		if (node.type === "JSMemberExpression") {
			return (
				___R$$priv$project$rome$$internal$formatter$node$index_ts$isOrHasCallExpression(
					node.object,
				) ||
				___R$$priv$project$rome$$internal$formatter$node$index_ts$isOrHasCallExpression(
					node.property,
				)
			);
		}

		return false;
	}

	function ___R$$priv$project$rome$$internal$formatter$node$index_ts$orderLoc(
		a,
		b,
	) {
		if (
			___R$project$rome$$internal$parser$core$utils_ts$comparePositions(
				a.end,
				b.start,
			) ===
			-1
		) {
			return [a, b];
		} else {
			return [b, a];
		}
	}

	function ___R$project$rome$$internal$formatter$node$index_ts$getLinesBetween(
		aNode,
		bNode,
	) {
		if (aNode.loc && bNode.loc) {
			const [a, b] = ___R$$priv$project$rome$$internal$formatter$node$index_ts$orderLoc(
				aNode.loc,
				bNode.loc,
			);
			return (
				___R$project$rome$$internal$ob1$index_ts$ob1Get1(b.start.line) -
				___R$project$rome$$internal$ob1$index_ts$ob1Get1(a.end.line)
			);
		} else {
			return 0;
		}
	}

	function ___R$project$rome$$internal$formatter$node$index_ts$needsParens(
		node,
		parent,
		printStack,
	) {
		if (!parent) {
			return false;
		}

		if (parent.type === "JSNewExpression" && parent.callee === node) {
			if (
				___R$$priv$project$rome$$internal$formatter$node$index_ts$isOrHasCallExpression(
					node,
				)
			) {
				return true;
			}
		}

		const fn = ___R$project$rome$$internal$formatter$node$parentheses_ts$default.get(
			node.type,
		);
		return fn ? fn(node, parent, printStack) : false;
	}

	function ___R$project$rome$$internal$formatter$node$index_ts$isOnSameLine(
		aNode,
		bNode,
	) {
		if (aNode.loc && bNode.loc) {
			return aNode.loc.end.line === bNode.loc.start.line;
		} else {
			return false;
		}
	}


  // project-rome/@internal/formatter/builders/comments.ts
function ___R$project$rome$$internal$formatter$builders$comments_ts$hasInnerComments(
		node,
	) {
		return node.innerComments !== undefined && node.innerComments.length > 0;
	}

	const ___R$$priv$project$rome$$internal$formatter$builders$comments_ts$CSS_COMMENT_WRAPPER = [
		"/*",
		"*/",
	];
	const ___R$$priv$project$rome$$internal$formatter$builders$comments_ts$HTML_COMMENT_WRAPPER = [
		"<!--",
		"-->",
	];

	const ___R$$priv$project$rome$$internal$formatter$builders$comments_ts$languageToBlockCommentWrapper = {
		html: ___R$$priv$project$rome$$internal$formatter$builders$comments_ts$HTML_COMMENT_WRAPPER,
		md: ___R$$priv$project$rome$$internal$formatter$builders$comments_ts$HTML_COMMENT_WRAPPER,
		css: ___R$$priv$project$rome$$internal$formatter$builders$comments_ts$CSS_COMMENT_WRAPPER,
		js: ___R$$priv$project$rome$$internal$formatter$builders$comments_ts$CSS_COMMENT_WRAPPER,
		json: ___R$$priv$project$rome$$internal$formatter$builders$comments_ts$CSS_COMMENT_WRAPPER,
	};

	function ___R$project$rome$$internal$formatter$builders$comments_ts$tokenizeComment(
		node,
		language,
	) {
		// Only JS can have line comments
		if (language === "js" && node.type === "CommentLine") {
			// NB: We assume that node.value doesn't have any newlines. Is that a safe assumption to make?
			return ___R$project$rome$$internal$formatter$tokens_ts$comment(
				"//" + node.value.trimEnd(),
			);
		}

		const wrapper = ___R$$priv$project$rome$$internal$formatter$builders$comments_ts$languageToBlockCommentWrapper[language];
		if (wrapper === undefined) {
			throw new Error("No block comment wrapper found for language " + language);
		}

		const [prefix, suffix] = wrapper;
		const lines = node.value.split("\n");

		if (
			wrapper ===
			___R$$priv$project$rome$$internal$formatter$builders$comments_ts$CSS_COMMENT_WRAPPER &&
			lines.every((line) => line.trimStart().charAt(0) === "*")
		) {
			return ___R$project$rome$$internal$formatter$tokens_ts$comment(
				___R$project$rome$$internal$formatter$tokens_ts$concat([
					prefix,
					___R$project$rome$$internal$formatter$tokens_ts$join(
						___R$project$rome$$internal$formatter$tokens_ts$hardline,
						lines.map((line, index) =>
							index === 0
								? line.trimEnd()
								: " " +
									(index < lines.length - 1 ? line.trim() : line.trimStart())
						),
					),
					suffix,
				]),
			);
		} else {
			return ___R$project$rome$$internal$formatter$tokens_ts$comment(
				"" + prefix + node.value + suffix,
			);
		}
	}

	function ___R$$priv$project$rome$$internal$formatter$builders$comments_ts$tokenizeCommentSeparator(
		left,
		right,
	) {
		const linesBetween = ___R$project$rome$$internal$formatter$node$index_ts$getLinesBetween(
			left,
			right,
		);
		if (linesBetween === 0) {
			return ___R$project$rome$$internal$formatter$tokens_ts$space;
		}
		if (linesBetween === 1) {
			return ___R$project$rome$$internal$formatter$tokens_ts$hardline;
		}
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			___R$project$rome$$internal$formatter$tokens_ts$hardline,
			___R$project$rome$$internal$formatter$tokens_ts$hardline,
		]);
	}

	function ___R$project$rome$$internal$formatter$builders$comments_ts$tokenizeLeadingComment(
		node,
		next,
		language,
	) {
		const comment = ___R$project$rome$$internal$formatter$builders$comments_ts$tokenizeComment(
			node,
			language,
		);
		if (node.type === "CommentLine") {
			return ___R$project$rome$$internal$formatter$tokens_ts$concat([
				comment,
				___R$project$rome$$internal$formatter$tokens_ts$hardline,
			]);
		} else {
			return ___R$project$rome$$internal$formatter$tokens_ts$concat([
				comment,
				___R$$priv$project$rome$$internal$formatter$builders$comments_ts$tokenizeCommentSeparator(
					node,
					next,
				),
			]);
		}
	}

	function ___R$project$rome$$internal$formatter$builders$comments_ts$tokenizeTrailingComment(
		node,
		previous,
		language,
	) {
		const comment = ___R$project$rome$$internal$formatter$builders$comments_ts$tokenizeComment(
			node,
			language,
		);
		const linesBetween = ___R$project$rome$$internal$formatter$node$index_ts$getLinesBetween(
			previous,
			node,
		);

		if (linesBetween >= 1) {
			return ___R$project$rome$$internal$formatter$tokens_ts$lineSuffix(
				___R$project$rome$$internal$formatter$tokens_ts$concat([
					linesBetween > 1
						? ___R$project$rome$$internal$formatter$tokens_ts$hardline
						: "",
					___R$project$rome$$internal$formatter$tokens_ts$hardline,
					comment,
				]),
			);
		} else {
			if (node.type === "CommentBlock") {
				return ___R$project$rome$$internal$formatter$tokens_ts$ifBreak(
					___R$project$rome$$internal$formatter$tokens_ts$lineSuffix(
						___R$project$rome$$internal$formatter$tokens_ts$concat([
							___R$project$rome$$internal$formatter$tokens_ts$space,
							comment,
						]),
					),
					___R$project$rome$$internal$formatter$tokens_ts$concat([
						___R$project$rome$$internal$formatter$tokens_ts$space,
						comment,
					]),
				);
			} else {
				return ___R$project$rome$$internal$formatter$tokens_ts$lineSuffix(
					___R$project$rome$$internal$formatter$tokens_ts$concat([
						___R$project$rome$$internal$formatter$tokens_ts$space,
						comment,
					]),
				);
			}
		}
	}


  // project-rome/@internal/formatter/builders/common/comments/CommentBlock.ts
function ___R$project$rome$$internal$formatter$builders$common$comments$CommentBlock_ts$default() {
		throw new Error("Unexpected comment printing");
	}


  // project-rome/@internal/formatter/builders/common/comments/CommentLine.ts
function ___R$project$rome$$internal$formatter$builders$common$comments$CommentLine_ts$default() {
		throw new Error("Unexpected comment printing");
	}


  // project-rome/@internal/formatter/builders/common/commit/CommitRoot.ts
function ___R$project$rome$$internal$formatter$builders$common$commit$CommitRoot_ts$default() {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/css/core/CSSAtRule.ts
function ___R$project$rome$$internal$formatter$builders$css$core$CSSAtRule_ts$default(
		builder,
		node,
	) {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/css/core/CSSBlock.ts
function ___R$project$rome$$internal$formatter$builders$css$core$CSSBlock_ts$default(
		builder,
		node,
	) {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/css/core/CSSDeclaration.ts
function ___R$project$rome$$internal$formatter$builders$css$core$CSSDeclaration_ts$default(
		builder,
		node,
	) {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/css/core/CSSDimension.ts
function ___R$project$rome$$internal$formatter$builders$css$core$CSSDimension_ts$default(
		builder,
		node,
	) {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/css/core/CSSFunction.ts
function ___R$project$rome$$internal$formatter$builders$css$core$CSSFunction_ts$default(
		builder,
		node,
	) {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/css/core/CSSIdentifier.ts
function ___R$project$rome$$internal$formatter$builders$css$core$CSSIdentifier_ts$default(
		builder,
		node,
	) {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/css/core/CSSNumber.ts
function ___R$project$rome$$internal$formatter$builders$css$core$CSSNumber_ts$default(
		builder,
		node,
	) {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/css/core/CSSPercentage.ts
function ___R$project$rome$$internal$formatter$builders$css$core$CSSPercentage_ts$default(
		builder,
		node,
	) {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/css/core/CSSRaw.ts
function ___R$project$rome$$internal$formatter$builders$css$core$CSSRaw_ts$default(
		builder,
		node,
	) {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/css/core/CSSRoot.ts
function ___R$project$rome$$internal$formatter$builders$css$core$CSSRoot_ts$default(
		builder,
		node,
	) {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/css/core/CSSRule.ts
function ___R$project$rome$$internal$formatter$builders$css$core$CSSRule_ts$default(
		builder,
		node,
	) {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/html/attributes/HTMLAttribute.ts
function ___R$project$rome$$internal$formatter$builders$html$attributes$HTMLAttribute_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			builder.tokenize(node.name, node),
			"=",
			builder.tokenize(node.value, node),
		]);
	}


  // project-rome/@internal/formatter/builders/html/tags/HTMLDoctypeTag.ts
function ___R$project$rome$$internal$formatter$builders$html$tags$HTMLDoctypeTag_ts$default(
		builder,
		node,
	) {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/html/tags/HTMLElement.ts
function ___R$project$rome$$internal$formatter$builders$html$tags$HTMLElement_ts$default(
		builder,
		node,
	) {
		const name = builder.tokenize(node.name, node);
		const tokens = ["<", name];

		for (const attr of node.attributes) {
			tokens.push(___R$project$rome$$internal$formatter$tokens_ts$space);
			tokens.push(builder.tokenize(attr.name, attr));
			tokens.push("=");
			tokens.push(builder.tokenize(attr.value, attr));
		}

		if (
			node.children.length === 0 &&
			node.selfClosing !== false &&
			!___R$project$rome$$internal$formatter$builders$comments_ts$hasInnerComments(
				node,
			)
		) {
			tokens.push(___R$project$rome$$internal$formatter$tokens_ts$space, "/>");
		} else {
			tokens.push(">");

			const children = [];

			children.push(builder.tokenizeInnerComments(node, true));

			for (let i = 0; i < node.children.length; i++) {
				const child = node.children[i];
				const printed = builder.tokenize(child, node);

				if (i > 0 && builder.getLinesBetween(node.children[i - 1], child) > 1) {
					children.push(
						___R$project$rome$$internal$formatter$tokens_ts$concat([
							___R$project$rome$$internal$formatter$tokens_ts$softline,
							printed,
						]),
					);
				} else {
					children.push(printed);
				}
			}

			tokens.push(
				___R$project$rome$$internal$formatter$tokens_ts$concat([
					___R$project$rome$$internal$formatter$tokens_ts$indent(
						___R$project$rome$$internal$formatter$tokens_ts$join(
							___R$project$rome$$internal$formatter$tokens_ts$softline,
							children,
						),
					),
					___R$project$rome$$internal$formatter$tokens_ts$softline,
				]),
			);

			tokens.push("</");
			tokens.push(name);
			tokens.push(">");
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/html/core/HTMLIdentifier.ts
function ___R$project$rome$$internal$formatter$builders$html$core$HTMLIdentifier_ts$default(
		builder,
		node,
	) {
		return node.name;
	}


  // project-rome/@internal/formatter/builders/html/core/HTMLRoot.ts
function ___R$project$rome$$internal$formatter$builders$html$core$HTMLRoot_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			builder.tokenizeStatementList(node.body, node),
			___R$project$rome$$internal$formatter$tokens_ts$hardline,
		]);
	}


  // project-rome/@internal/formatter/builders/html/core/HTMLString.ts
function ___R$project$rome$$internal$formatter$builders$html$core$HTMLString_ts$default(
		builder,
		node,
	) {
		return JSON.stringify(node.value);
	}


  // project-rome/@internal/formatter/builders/html/core/HTMLText.ts
function ___R$project$rome$$internal$formatter$builders$html$core$HTMLText_ts$default(
		builder,
		node,
	) {
		// TODO Escape <
		return node.value;
	}


  // project-rome/@internal/formatter/builders/js/temp/JSAmbiguousFlowTypeCastExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$temp$JSAmbiguousFlowTypeCastExpression_ts$default() {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/js/expressions/JSArrayExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$expressions$JSArrayExpression_ts$default(
		builder,
		node,
	) {
		const hasContents = node.elements.length > 0;
		const hasRest =
			(node.type === "JSBindingArrayPattern" ||
			node.type === "JSAssignmentArrayPattern") &&
			node.rest !== undefined;

		if (!hasContents && !hasRest) {
			if (
				___R$project$rome$$internal$formatter$builders$comments_ts$hasInnerComments(
					node,
				)
			) {
				return ___R$project$rome$$internal$formatter$tokens_ts$group(
					___R$project$rome$$internal$formatter$tokens_ts$concat([
						"[",
						builder.tokenizeInnerComments(node, true),
						___R$project$rome$$internal$formatter$tokens_ts$softline,
						"]",
					]),
				);
			} else {
				return "[]";
			}
		}

		const tokens = [];

		if (hasContents) {
			const elements = [];

			for (let i = 0; i < node.elements.length; i++) {
				const element = node.elements[i];
				const printed = builder.tokenize(element, node);

				if (i > 0 && builder.getLinesBetween(node.elements[i - 1], element) > 1) {
					elements.push(
						___R$project$rome$$internal$formatter$tokens_ts$concat([
							___R$project$rome$$internal$formatter$tokens_ts$softline,
							printed,
						]),
					);
				} else {
					elements.push(printed);
				}
			}

			tokens.push(
				___R$project$rome$$internal$formatter$tokens_ts$join(
					___R$project$rome$$internal$formatter$tokens_ts$concat([
						",",
						___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace,
					]),
					elements,
				),
			);

			if (hasRest) {
				tokens.push(
					",",
					___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace,
				);
			} else {
				// Add trailing comma
				tokens.push(
					___R$project$rome$$internal$formatter$tokens_ts$ifBreak(","),
				);
			}
		}

		if (hasRest) {
			tokens.push("...", builder.tokenize((node).rest, node));
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$group(
			___R$project$rome$$internal$formatter$tokens_ts$concat([
				"[",
				___R$project$rome$$internal$formatter$tokens_ts$indent(
					___R$project$rome$$internal$formatter$tokens_ts$concat([
						___R$project$rome$$internal$formatter$tokens_ts$softline,
						___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
					]),
				),
				___R$project$rome$$internal$formatter$tokens_ts$softline,
				"]",
			]),
		);
	}


  // project-rome/@internal/formatter/builders/js/auxiliary/JSArrayHole.ts
function ___R$project$rome$$internal$formatter$builders$js$auxiliary$JSArrayHole_ts$default(
		builder,
		node,
	) {
		return builder.tokenizeInnerComments(node, false);
	}


  // project-rome/@internal/formatter/builders/js/expressions/JSArrowFunctionExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$expressions$JSArrowFunctionExpression_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (node.head.async === true) {
			tokens.push("async");
			tokens.push(___R$project$rome$$internal$formatter$tokens_ts$space);
		}

		tokens.push(builder.tokenize(node.head, node));
		tokens.push(___R$project$rome$$internal$formatter$tokens_ts$space, "=>");

		const body = builder.tokenize(node.body, node);

		// Keep these types of node on the line as the arrow
		if (
			node.body.type === "JSArrayExpression" ||
			node.body.type === "JSObjectExpression" ||
			node.body.type === "JSBlockStatement" ||
			node.body.type === "JSArrowFunctionExpression"
		) {
			return ___R$project$rome$$internal$formatter$tokens_ts$group(
				___R$project$rome$$internal$formatter$tokens_ts$concat([
					___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
					___R$project$rome$$internal$formatter$tokens_ts$space,
					body,
				]),
			);
		}

		if (node.body.type === "JSSequenceExpression") {
			return ___R$project$rome$$internal$formatter$tokens_ts$concat([
				___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
				___R$project$rome$$internal$formatter$tokens_ts$group(
					___R$project$rome$$internal$formatter$tokens_ts$concat([
						___R$project$rome$$internal$formatter$tokens_ts$space,
						"(",
						___R$project$rome$$internal$formatter$tokens_ts$indent(
							___R$project$rome$$internal$formatter$tokens_ts$concat([
								___R$project$rome$$internal$formatter$tokens_ts$softline,
								body,
							]),
						),
						___R$project$rome$$internal$formatter$tokens_ts$softline,
						")",
					]),
				),
			]);
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$group(
			___R$project$rome$$internal$formatter$tokens_ts$concat([
				___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
				___R$project$rome$$internal$formatter$tokens_ts$group(
					___R$project$rome$$internal$formatter$tokens_ts$concat([
						___R$project$rome$$internal$formatter$tokens_ts$indent(
							___R$project$rome$$internal$formatter$tokens_ts$concat([
								___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace,
								body,
							]),
						),
						___R$project$rome$$internal$formatter$tokens_ts$softline,
					]),
				),
			]),
		);
	}


  // project-rome/@internal/formatter/builders/js/patterns/JSAssignmentArrayPattern.ts
function ___R$project$rome$$internal$formatter$builders$js$patterns$JSAssignmentArrayPattern_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$builders$js$expressions$JSArrayExpression_ts$default(
			builder,
			node,
		);
	}


  // project-rome/@internal/formatter/builders/js/patterns/JSBindingAssignmentPattern.ts
function ___R$project$rome$$internal$formatter$builders$js$patterns$JSBindingAssignmentPattern_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			builder.tokenize(node.left, node),
			___R$project$rome$$internal$formatter$tokens_ts$space,
			"=",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(node.right, node),
		]);
	}


  // project-rome/@internal/formatter/builders/js/patterns/JSAssignmentAssignmentPattern.ts
function ___R$project$rome$$internal$formatter$builders$js$patterns$JSAssignmentAssignmentPattern_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$builders$js$patterns$JSBindingAssignmentPattern_ts$default(
			builder,
			node,
		);
	}


  // project-rome/@internal/formatter/builders/js/utils.ts
function ___R$project$rome$$internal$formatter$builders$js$utils_ts$buildLabelStatementBuilder(
		prefix,
	) {
		return (builder, node) => {
			const tokens = [prefix];

			if (node.label) {
				tokens.push(
					___R$project$rome$$internal$formatter$tokens_ts$space,
					builder.tokenize(node.label, node),
				);
			}

			tokens.push(";");

			return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
		};
	}

	function ___R$project$rome$$internal$formatter$builders$js$utils_ts$buildThrowAndReturnStatementBuilder(
		prefix,
	) {
		return (builder, node) => {
			const tokens = [prefix];

			if (node.argument) {
				tokens.push(___R$project$rome$$internal$formatter$tokens_ts$space);

				if (
					node.argument.type === "JSBinaryExpression" ||
					node.argument.type === "JSLogicalExpression" ||
					node.argument.type === "JSSequenceExpression"
				) {
					tokens.push(
						___R$project$rome$$internal$formatter$tokens_ts$group(
							___R$project$rome$$internal$formatter$tokens_ts$concat([
								___R$project$rome$$internal$formatter$tokens_ts$ifBreak("("),
								___R$project$rome$$internal$formatter$tokens_ts$indent(
									___R$project$rome$$internal$formatter$tokens_ts$concat([
										___R$project$rome$$internal$formatter$tokens_ts$softline,
										builder.tokenize(node.argument, node),
									]),
								),
								___R$project$rome$$internal$formatter$tokens_ts$softline,
								___R$project$rome$$internal$formatter$tokens_ts$ifBreak(")"),
							]),
						),
					);
				} else {
					tokens.push(builder.tokenize(node.argument, node));
				}
			}

			tokens.push(";");

			return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
		};
	}

	function ___R$project$rome$$internal$formatter$builders$js$utils_ts$printMethod(
		builder,
		node,
	) {
		const kind = node.kind;

		const tokens = [];

		if (kind === "method" && node.head.generator === true) {
			tokens.push("*");
		}

		if (kind === "get" || kind === "set") {
			tokens.push(kind);
			tokens.push(___R$project$rome$$internal$formatter$tokens_ts$space);
		}

		if (node.head.async === true) {
			tokens.push("async");
			tokens.push(___R$project$rome$$internal$formatter$tokens_ts$space);
		}

		if (node.type === "TSDeclareMethod") {
			return ___R$project$rome$$internal$formatter$tokens_ts$concat([
				___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
				builder.tokenize(node.head, node),
			]);
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
			builder.tokenize(node.key, node),
			builder.tokenize(node.head, node),
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(node.body, node),
		]);
	}

	function ___R$project$rome$$internal$formatter$builders$js$utils_ts$printBindingPatternParams(
		builder,
		node,
		params,
		rest,
	) {
		if (params.length === 0 && rest === undefined) {
			if (
				___R$project$rome$$internal$formatter$builders$comments_ts$hasInnerComments(
					node,
				)
			) {
				return ___R$project$rome$$internal$formatter$tokens_ts$concat([
					"(",
					builder.tokenizeInnerComments(node, true),
					___R$project$rome$$internal$formatter$tokens_ts$hardline,
					")",
				]);
			} else {
				return "()";
			}
		}

		const tokens = [
			___R$project$rome$$internal$formatter$tokens_ts$softline,
			___R$project$rome$$internal$formatter$tokens_ts$join(
				___R$project$rome$$internal$formatter$tokens_ts$concat([
					",",
					___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace,
				]),
				params.map((param) => builder.tokenize(param, node)),
			),
		];

		if (rest) {
			if (params.length > 0) {
				tokens.push(
					",",
					___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace,
				);
			}
			tokens.push("...", builder.tokenize(rest, node));
		}

		if (params.length > 0 && !rest) {
			tokens.push(___R$project$rome$$internal$formatter$tokens_ts$ifBreak(","));
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"(",
			___R$project$rome$$internal$formatter$tokens_ts$indent(
				___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
			),
			___R$project$rome$$internal$formatter$tokens_ts$softline,
			")",
		]);
	}

	function ___R$project$rome$$internal$formatter$builders$js$utils_ts$printTSBraced(
		builder,
		node,
		members,
	) {
		if (members.length === 0) {
			return ___R$project$rome$$internal$formatter$tokens_ts$group(
				___R$project$rome$$internal$formatter$tokens_ts$concat([
					"{",
					builder.tokenizeInnerComments(node, true),
					___R$project$rome$$internal$formatter$tokens_ts$softline,
					"}",
				]),
			);
		}

		// TODO inner comments wont be included if there's a member. Members could have been inserted after parsing the source.
		return ___R$project$rome$$internal$formatter$tokens_ts$group(
			___R$project$rome$$internal$formatter$tokens_ts$concat([
				"{",
				___R$project$rome$$internal$formatter$tokens_ts$indent(
					___R$project$rome$$internal$formatter$tokens_ts$concat([
						___R$project$rome$$internal$formatter$tokens_ts$hardline,
						___R$project$rome$$internal$formatter$tokens_ts$join(
							___R$project$rome$$internal$formatter$tokens_ts$hardline,
							members.map((member, index) => {
								const printed = builder.tokenize(member, node);
								if (
									index > 0 &&
									builder.getLinesBetween(members[index - 1], member) > 1
								) {
									return ___R$project$rome$$internal$formatter$tokens_ts$concat([
										___R$project$rome$$internal$formatter$tokens_ts$hardline,
										printed,
									]);
								} else {
									return printed;
								}
							}),
						),
					]),
				),
				___R$project$rome$$internal$formatter$tokens_ts$hardline,
				"}",
			]),
			true,
		);
	}

	function ___R$project$rome$$internal$formatter$builders$js$utils_ts$printPatternMeta(
		builder,
		node,
		meta,
	) {
		if (builder.options.typeAnnotations && meta !== undefined) {
			const tokens = [];

			if (meta.optional) {
				tokens.push("?");
			}

			if (meta.typeAnnotation) {
				tokens.push(
					":",
					___R$project$rome$$internal$formatter$tokens_ts$space,
					builder.tokenize(meta.typeAnnotation, node),
				);
			}

			return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
		} else {
			return "";
		}
	}

	function ___R$project$rome$$internal$formatter$builders$js$utils_ts$printClause(
		builder,
		clause,
		parent,
	) {
		if (clause.type === "JSEmptyStatement") {
			return ";";
		}

		if (clause.type === "JSBlockStatement") {
			return ___R$project$rome$$internal$formatter$tokens_ts$concat([
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(clause, parent),
			]);
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$indent(
			___R$project$rome$$internal$formatter$tokens_ts$concat([
				___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace,
				builder.tokenize(clause, parent),
			]),
		);
	}

	function ___R$project$rome$$internal$formatter$builders$js$utils_ts$printCommaList(
		builder,
		nodes,
		parent,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$join(
			___R$project$rome$$internal$formatter$tokens_ts$concat([
				",",
				___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace,
			]),
			nodes.map((node) => builder.tokenize(node, parent)),
		);
	}

	function ___R$project$rome$$internal$formatter$builders$js$utils_ts$printAssignment(
		builder,
		node,
		left,
		operator,
		right,
	) {
		const canBreak =
			right.type === "JSBinaryExpression" ||
			right.type === "JSLogicalExpression" ||
			right.type === "JSSequenceExpression" ||
			(right.type === "JSConditionalExpression" &&
			___R$project$rome$$internal$js$ast$utils$isBinary_ts$isBinary(right.test));

		return ___R$project$rome$$internal$formatter$tokens_ts$group(
			___R$project$rome$$internal$formatter$tokens_ts$concat([
				builder.tokenize(left, node),
				operator,
				canBreak
					? ___R$project$rome$$internal$formatter$tokens_ts$group(
							___R$project$rome$$internal$formatter$tokens_ts$indent(
								___R$project$rome$$internal$formatter$tokens_ts$concat([
									___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace,
									builder.tokenize(right, node),
								]),
							),
						)
					: ___R$project$rome$$internal$formatter$tokens_ts$concat([
							___R$project$rome$$internal$formatter$tokens_ts$space,
							builder.tokenize(right, node),
						]),
			]),
		);
	}


  // project-rome/@internal/formatter/builders/js/expressions/JSAssignmentExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$expressions$JSAssignmentExpression_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$builders$js$utils_ts$printAssignment(
			builder,
			node,
			node.left,
			___R$project$rome$$internal$formatter$tokens_ts$concat([
				___R$project$rome$$internal$formatter$tokens_ts$space,
				node.operator,
			]),
			node.right,
		);
	}


  // project-rome/@internal/formatter/builders/js/auxiliary/JSIdentifier.ts
function ___R$project$rome$$internal$formatter$builders$js$auxiliary$JSIdentifier_ts$default(
		builder,
		node,
	) {
		return node.name;
	}


  // project-rome/@internal/formatter/builders/js/patterns/JSAssignmentIdentifier.ts
function ___R$project$rome$$internal$formatter$builders$js$patterns$JSAssignmentIdentifier_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$builders$js$auxiliary$JSIdentifier_ts$default(
			builder,
			node,
		);
	}


  // project-rome/@internal/formatter/builders/js/objects/JSObjectExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$objects$JSObjectExpression_ts$default(
		builder,
		node,
	) {
		if (
			___R$project$rome$$internal$formatter$builders$comments_ts$hasInnerComments(
				node,
			)
		) {
			return ___R$project$rome$$internal$formatter$tokens_ts$group(
				___R$project$rome$$internal$formatter$tokens_ts$concat([
					"{",
					builder.tokenizeInnerComments(node, true),
					___R$project$rome$$internal$formatter$tokens_ts$softline,
					"}",
				]),
			);
		}

		const tokens = [];
		const props = node.properties;

		tokens.push(
			___R$project$rome$$internal$formatter$tokens_ts$join(
				___R$project$rome$$internal$formatter$tokens_ts$concat([
					",",
					___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace,
				]),
				props.map((prop, index) => {
					const printed = builder.tokenize(prop, node);
					if (index > 0 && builder.getLinesBetween(props[index - 1], prop) > 1) {
						return ___R$project$rome$$internal$formatter$tokens_ts$concat([
							___R$project$rome$$internal$formatter$tokens_ts$softline,
							printed,
						]);
					} else {
						return printed;
					}
				}),
			),
		);

		if (
			(node.type === "JSBindingObjectPattern" ||
			node.type === "JSAssignmentObjectPattern") &&
			node.rest !== undefined
		) {
			if (props.length > 0) {
				tokens.push(
					",",
					___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace,
				);
				if (builder.getLinesBetween(props[props.length - 1], node.rest) > 1) {
					tokens.push(___R$project$rome$$internal$formatter$tokens_ts$softline);
				}
			}

			tokens.push("...", builder.tokenize(node.rest, node));
		} else if (props.length > 0) {
			// Add trailing comma
			tokens.push(___R$project$rome$$internal$formatter$tokens_ts$ifBreak(","));
		}

		// If the first property is not one the same line as the opening brace,
		// the object is printed on multiple lines.
		const shouldBreak =
			node.loc !== undefined &&
			props.length > 0 &&
			props[0].loc !== undefined &&
			props[0].loc.start.line !== node.loc.start.line;

		return ___R$project$rome$$internal$formatter$tokens_ts$group(
			___R$project$rome$$internal$formatter$tokens_ts$concat([
				"{",
				___R$project$rome$$internal$formatter$tokens_ts$indent(
					___R$project$rome$$internal$formatter$tokens_ts$concat([
						___R$project$rome$$internal$formatter$tokens_ts$softline,
						___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
					]),
				),
				___R$project$rome$$internal$formatter$tokens_ts$softline,
				"}",
			]),
			shouldBreak,
		);
	}


  // project-rome/@internal/formatter/builders/js/patterns/JSAssignmentObjectPattern.ts
function ___R$project$rome$$internal$formatter$builders$js$patterns$JSAssignmentObjectPattern_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$builders$js$objects$JSObjectExpression_ts$default(
			builder,
			node,
		);
	}


  // project-rome/@internal/formatter/builders/js/objects/JSObjectProperty.ts
function ___R$$priv$project$rome$$internal$formatter$builders$js$objects$JSObjectProperty_ts$isShorthand(
		key,
		value,
	) {
		return (
			key.type === "JSStaticPropertyKey" &&
			key.value.type === "JSIdentifier" &&
			(value.type === "JSReferenceIdentifier" ||
			value.type === "JSBindingIdentifier" ||
			value.type === "JSAssignmentIdentifier") &&
			value.name === key.value.name
		);
	}

	function ___R$project$rome$$internal$formatter$builders$js$objects$JSObjectProperty_ts$default(
		builder,
		node,
	) {
		const tokens = [builder.tokenize(node.key, node)];

		if (
			(node.value.type === "JSBindingAssignmentPattern" ||
			node.value.type === "JSAssignmentAssignmentPattern") &&
			___R$$priv$project$rome$$internal$formatter$builders$js$objects$JSObjectProperty_ts$isShorthand(
				node.key,
				node.value.left,
			)
		) {
			return ___R$project$rome$$internal$formatter$tokens_ts$concat([
				___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
				___R$project$rome$$internal$formatter$tokens_ts$space,
				"=",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.value.right, node.value),
			]);
		} else if (
			___R$$priv$project$rome$$internal$formatter$builders$js$objects$JSObjectProperty_ts$isShorthand(
				node.key,
				node.value,
			)
		) {
			return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
		} else {
			return ___R$project$rome$$internal$formatter$tokens_ts$concat([
				___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
				":",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.value, node),
			]);
		}
	}


  // project-rome/@internal/formatter/builders/js/patterns/JSAssignmentObjectPatternProperty.ts
function ___R$project$rome$$internal$formatter$builders$js$patterns$JSAssignmentObjectPatternProperty_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$builders$js$objects$JSObjectProperty_ts$default(
			builder,
			node,
		);
	}


  // project-rome/@internal/formatter/builders/js/expressions/JSAwaitExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$expressions$JSAwaitExpression_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"await",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(node.argument, node),
		]);
	}


  // project-rome/@internal/formatter/builders/js/literals/JSBigIntLiteral.ts
function ___R$project$rome$$internal$formatter$builders$js$literals$JSBigIntLiteral_ts$default(
		builder,
		node,
	) {
		return node.value + "n";
	}


  // project-rome/@internal/formatter/builders/js/expressions/JSBinaryExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$expressions$JSBinaryExpression_ts$default(
		builder,
		node,
		parent,
	) {
		const shouldNotGroup =
			(parent.type === "JSIfStatement" && parent.test === node) ||
			(parent.type === "JSDoWhileStatement" && parent.test === node) ||
			(parent.type === "JSWhileStatement" && parent.test === node) ||
			(parent.type === "JSSwitchStatement" && parent.discriminant === node);

		const parts = ___R$$priv$project$rome$$internal$formatter$builders$js$expressions$JSBinaryExpression_ts$printBinaryExpression(
			builder,
			node,
			parent,
			shouldNotGroup,
		);

		if (shouldNotGroup) {
			return ___R$project$rome$$internal$formatter$tokens_ts$concat(parts);
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$group(
			___R$project$rome$$internal$formatter$tokens_ts$concat(parts),
		);
	}

	function ___R$$priv$project$rome$$internal$formatter$builders$js$expressions$JSBinaryExpression_ts$printBinaryExpression(
		builder,
		node,
		parent,
		shouldNotGroup,
	) {
		const parts = [];

		if (
			___R$project$rome$$internal$js$ast$utils$isBinary_ts$isBinary(node.left) &&
			___R$project$rome$$internal$js$ast$utils$getPrecedence_ts$getPrecedence(
				node.operator,
			) ===
			___R$project$rome$$internal$js$ast$utils$getPrecedence_ts$getPrecedence(
				node.left.operator,
			)
		) {
			var ___R$;
			___R$ = parts,
				___R$.push.apply(
					___R$,
					[
						...___R$$priv$project$rome$$internal$formatter$builders$js$expressions$JSBinaryExpression_ts$printBinaryExpression(
							builder,
							node.left,
							node,
							shouldNotGroup,
						),
					],
				);
		} else {
			parts.push(builder.tokenize(node.left, node));
		}

		// Inline object and array expressions:
		//   obj && {
		//   arr ?? [
		const shouldInline =
			node.type === "JSLogicalExpression" &&
			(node.right.type === "JSArrayExpression" ||
			node.right.type === "JSObjectExpression");

		const right = ___R$project$rome$$internal$formatter$tokens_ts$concat([
			node.operator,
			shouldInline
				? ___R$project$rome$$internal$formatter$tokens_ts$space
				: ___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace,
			builder.tokenize(node.right, node),
		]);

		const shouldGroup =
			!shouldNotGroup &&
			node.type !== parent.type &&
			node.type !== node.left.type &&
			node.type !== node.right.type;

		parts.push(
			___R$project$rome$$internal$formatter$tokens_ts$concat([
				___R$project$rome$$internal$formatter$tokens_ts$space,
				shouldGroup
					? ___R$project$rome$$internal$formatter$tokens_ts$group(right)
					: right,
			]),
		);

		return parts;
	}


  // project-rome/@internal/formatter/builders/js/patterns/JSBindingArrayPattern.ts
function ___R$project$rome$$internal$formatter$builders$js$patterns$JSBindingArrayPattern_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			___R$project$rome$$internal$formatter$builders$js$expressions$JSArrayExpression_ts$default(
				builder,
				node,
			),
			___R$project$rome$$internal$formatter$builders$js$utils_ts$printPatternMeta(
				builder,
				node,
				node.meta,
			),
		]);
	}


  // project-rome/@internal/formatter/builders/js/patterns/JSBindingIdentifier.ts
function ___R$project$rome$$internal$formatter$builders$js$patterns$JSBindingIdentifier_ts$default(
		builder,
		node,
	) {
		if (node.name[0] === "*") {
			// Internal name
			return "";
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			___R$project$rome$$internal$formatter$builders$js$auxiliary$JSIdentifier_ts$default(
				builder,
				node,
			),
			___R$project$rome$$internal$formatter$builders$js$utils_ts$printPatternMeta(
				builder,
				node,
				node.meta,
			),
		]);
	}


  // project-rome/@internal/formatter/builders/js/patterns/JSBindingObjectPattern.ts
function ___R$project$rome$$internal$formatter$builders$js$patterns$JSBindingObjectPattern_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			___R$project$rome$$internal$formatter$builders$js$objects$JSObjectExpression_ts$default(
				builder,
				node,
			),
			___R$project$rome$$internal$formatter$builders$js$utils_ts$printPatternMeta(
				builder,
				node,
				node.meta,
			),
		]);
	}


  // project-rome/@internal/formatter/builders/js/patterns/JSBindingObjectPatternProperty.ts
function ___R$project$rome$$internal$formatter$builders$js$patterns$JSBindingObjectPatternProperty_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$builders$js$objects$JSObjectProperty_ts$default(
			builder,
			node,
		);
	}


  // project-rome/@internal/formatter/builders/js/statements/JSBlockStatement.ts
function ___R$project$rome$$internal$formatter$builders$js$statements$JSBlockStatement_ts$default(
		builder,
		node,
		parent,
	) {
		const hasComments =
			node.innerComments !== undefined && node.innerComments.length > 0;
		const hasContents = node.body !== undefined && node.body.length > 0;
		const hasDirectives =
			node.directives !== undefined && node.directives.length > 0;

		if (
			!hasComments &&
			!hasContents &&
			!hasDirectives &&
			(parent.type === "JSArrowFunctionExpression" ||
			parent.type === "JSClassMethod" ||
			parent.type === "JSClassPrivateMethod" ||
			parent.type === "JSDoWhileStatement" ||
			parent.type === "JSForInStatement" ||
			parent.type === "JSForOfStatement" ||
			parent.type === "JSForStatement" ||
			parent.type === "JSFunctionDeclaration" ||
			parent.type === "JSFunctionExpression" ||
			parent.type === "JSObjectMethod" ||
			parent.type === "JSSwitchStatement" ||
			parent.type === "JSWhileStatement")
		) {
			return "{}";
		}

		const tokens = ["{"];

		if (hasDirectives) {
			for (const directive of node.directives) {
				tokens.push(
					___R$project$rome$$internal$formatter$tokens_ts$indent(
						builder.tokenize(directive, node),
						true,
					),
				);
			}
		}

		if (hasContents) {
			tokens.push(
				___R$project$rome$$internal$formatter$tokens_ts$indent(
					builder.tokenizeStatementList(node.body, node),
					true,
				),
			);
		}

		if (hasComments) {
			tokens.push(builder.tokenizeInnerComments(node, true));
		}

		tokens.push(___R$project$rome$$internal$formatter$tokens_ts$hardline, "}");

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/js/literals/JSBooleanLiteral.ts
function ___R$project$rome$$internal$formatter$builders$js$literals$JSBooleanLiteral_ts$default(
		builder,
		node,
	) {
		return node.value ? "true" : "false";
	}


  // project-rome/@internal/formatter/builders/js/statements/JSBreakStatement.ts
const ___R$project$rome$$internal$formatter$builders$js$statements$JSBreakStatement_ts$default = ___R$project$rome$$internal$formatter$builders$js$utils_ts$buildLabelStatementBuilder(
		"break",
	);


  // project-rome/@internal/formatter/builders/js/expressions/JSCallExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$expressions$JSCallExpression_ts$default(
		builder,
		node,
	) {
		const tokens = [builder.tokenize(node.callee, node)];

		if (node.type === "JSOptionalCallExpression") {
			tokens.push("?.");
		}

		if (node.typeArguments) {
			tokens.push(builder.tokenize(node.typeArguments, node));
		}

		tokens.push(
			___R$$priv$project$rome$$internal$formatter$builders$js$expressions$JSCallExpression_ts$printArguments(
				builder,
				node,
			),
		);

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}

	function ___R$$priv$project$rome$$internal$formatter$builders$js$expressions$JSCallExpression_ts$printArguments(
		builder,
		node,
	) {
		if (node.arguments.length === 0) {
			if (
				___R$project$rome$$internal$formatter$builders$comments_ts$hasInnerComments(
					node,
				)
			) {
				return ___R$project$rome$$internal$formatter$tokens_ts$concat([
					"(",
					builder.tokenizeInnerComments(node, true),
					___R$project$rome$$internal$formatter$tokens_ts$hardline,
					")",
				]);
			} else {
				return "()";
			}
		}

		if (node.arguments.length === 1) {
			const argument = node.arguments[0];
			if (
				argument.type === "JSArrayExpression" ||
				argument.type === "JSObjectExpression" ||
				___R$project$rome$$internal$js$ast$utils$isFunctionNode_ts$isFunctionNode(
					argument,
				)
			) {
				return ___R$project$rome$$internal$formatter$tokens_ts$concat([
					"(",
					builder.tokenize(argument, node),
					")",
				]);
			}
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$group(
			___R$project$rome$$internal$formatter$tokens_ts$concat([
				"(",
				___R$project$rome$$internal$formatter$tokens_ts$indent(
					___R$project$rome$$internal$formatter$tokens_ts$concat([
						___R$project$rome$$internal$formatter$tokens_ts$softline,
						___R$project$rome$$internal$formatter$builders$js$utils_ts$printCommaList(
							builder,
							node.arguments,
							node,
						),
					]),
				),
				___R$project$rome$$internal$formatter$tokens_ts$ifBreak(","),
				___R$project$rome$$internal$formatter$tokens_ts$softline,
				")",
			]),
		);
	}


  // project-rome/@internal/formatter/builders/js/auxiliary/JSCatchClause.ts
function ___R$project$rome$$internal$formatter$builders$js$auxiliary$JSCatchClause_ts$default(
		builder,
		node,
	) {
		if (node.param) {
			return ___R$project$rome$$internal$formatter$tokens_ts$concat([
				"catch",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				"(",
				builder.tokenize(node.param, node),
				") ",
				builder.tokenize(node.body, node),
			]);
		} else {
			return ___R$project$rome$$internal$formatter$tokens_ts$concat([
				"catch",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.body, node),
			]);
		}
	}


  // project-rome/@internal/formatter/builders/js/classes/JSClassDeclaration.ts
function ___R$project$rome$$internal$formatter$builders$js$classes$JSClassDeclaration_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (node.type === "JSClassDeclaration" && builder.options.typeAnnotations) {
			if (node.declare) {
				tokens.push(
					"declare",
					___R$project$rome$$internal$formatter$tokens_ts$space,
				);
			}

			if (node.abstract) {
				tokens.push(
					"abstract",
					___R$project$rome$$internal$formatter$tokens_ts$space,
				);
			}
		}

		tokens.push("class");

		if (node.id) {
			tokens.push(
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.id, node),
			);
		}

		tokens.push(
			builder.tokenize(node.meta, node),
			___R$project$rome$$internal$formatter$tokens_ts$space,
			"{",
		);

		if (
			___R$project$rome$$internal$formatter$builders$comments_ts$hasInnerComments(
				node.meta,
			)
		) {
			tokens.push(
				builder.tokenizeInnerComments(node.meta, true),
				___R$project$rome$$internal$formatter$tokens_ts$hardline,
			);
		}

		if (node.meta.body.length > 0) {
			tokens.push(
				___R$project$rome$$internal$formatter$tokens_ts$concat([
					___R$project$rome$$internal$formatter$tokens_ts$indent(
						___R$project$rome$$internal$formatter$tokens_ts$concat([
							___R$project$rome$$internal$formatter$tokens_ts$hardline,
							builder.tokenizeStatementList(node.meta.body, node.meta),
						]),
					),
					___R$project$rome$$internal$formatter$tokens_ts$hardline,
				]),
			);
		}

		tokens.push("}");

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/js/classes/JSClassExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$classes$JSClassExpression_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$builders$js$classes$JSClassDeclaration_ts$default(
			builder,
			node,
		);
	}


  // project-rome/@internal/formatter/builders/js/classes/JSClassHead.ts
function ___R$project$rome$$internal$formatter$builders$js$classes$JSClassHead_ts$default(
		builder,
		node,
	) {
		const tokens = [];
		const tokenGroups = [];

		tokens.push(builder.tokenize(node.typeParameters, node));

		if (node.superClass) {
			tokenGroups.push(
				___R$project$rome$$internal$formatter$tokens_ts$group(
					___R$project$rome$$internal$formatter$tokens_ts$concat([
						___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace,
						"extends",
						___R$project$rome$$internal$formatter$tokens_ts$space,
						builder.tokenize(node.superClass, node),
						builder.tokenize(node.superTypeParameters, node),
					]),
				),
			);
		}

		if (
			builder.options.typeAnnotations &&
			node.implements &&
			node.implements.length > 0
		) {
			tokenGroups.push(
				___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace,
				"implements",
				___R$project$rome$$internal$formatter$tokens_ts$group(
					___R$project$rome$$internal$formatter$tokens_ts$indent(
						___R$project$rome$$internal$formatter$tokens_ts$concat([
							___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace,
							___R$project$rome$$internal$formatter$builders$js$utils_ts$printCommaList(
								builder,
								node.implements,
								node,
							),
						]),
					),
				),
			);
		}

		if (tokenGroups.length > 0) {
			tokens.push(
				___R$project$rome$$internal$formatter$tokens_ts$group(
					___R$project$rome$$internal$formatter$tokens_ts$indent(
						___R$project$rome$$internal$formatter$tokens_ts$concat(tokenGroups),
					),
				),
			);
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/js/classes/JSClassMethod.ts
function ___R$project$rome$$internal$formatter$builders$js$classes$JSClassMethod_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			builder.tokenize(node.meta, node),
			___R$project$rome$$internal$formatter$builders$js$utils_ts$printMethod(
				builder,
				node,
			),
		]);
	}


  // project-rome/@internal/formatter/builders/js/classes/JSClassPrivateMethod.ts
function ___R$project$rome$$internal$formatter$builders$js$classes$JSClassPrivateMethod_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			builder.tokenize(node.meta, node),
			___R$project$rome$$internal$formatter$builders$js$utils_ts$printMethod(
				builder,
				node,
			),
		]);
	}


  // project-rome/@internal/formatter/builders/js/classes/JSClassPrivateProperty.ts
function ___R$project$rome$$internal$formatter$builders$js$classes$JSClassPrivateProperty_ts$default(
		builder,
		node,
	) {
		const tokens = [
			builder.tokenize(node.meta, node),
			builder.tokenize(node.key, node),
		];

		if (builder.options.typeAnnotations && node.typeAnnotation) {
			tokens.push(
				":",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.typeAnnotation, node),
			);
		}

		if (node.value) {
			tokens.push(___R$project$rome$$internal$formatter$tokens_ts$space);
			tokens.push("=");
			tokens.push(___R$project$rome$$internal$formatter$tokens_ts$space);
			tokens.push(builder.tokenize(node.value, node));
		}

		tokens.push(";");

		return ___R$project$rome$$internal$formatter$tokens_ts$group(
			___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
		);
	}


  // project-rome/@internal/formatter/builders/js/classes/JSClassProperty.ts
function ___R$project$rome$$internal$formatter$builders$js$classes$JSClassProperty_ts$default(
		builder,
		node,
	) {
		if (node.value === undefined && !builder.options.typeAnnotations) {
			// A JSClassProperty with no value is a type annotation
			return "";
		}

		const tokens = [
			builder.tokenize(node.meta, node),
			builder.tokenize(node.key, node),
		];

		if (builder.options.typeAnnotations && node.typeAnnotation) {
			tokens.push(
				":",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.typeAnnotation, node),
			);
		}

		if (node.value) {
			tokens.push(___R$project$rome$$internal$formatter$tokens_ts$space);
			tokens.push("=");
			tokens.push(___R$project$rome$$internal$formatter$tokens_ts$space);
			tokens.push(builder.tokenize(node.value, node));
		}

		tokens.push(";");

		return ___R$project$rome$$internal$formatter$tokens_ts$group(
			___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
		);
	}


  // project-rome/@internal/formatter/builders/js/classes/JSClassPropertyMeta.ts
function ___R$project$rome$$internal$formatter$builders$js$classes$JSClassPropertyMeta_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (builder.options.typeAnnotations) {
			if (node.accessibility) {
				tokens.push(
					node.accessibility,
					___R$project$rome$$internal$formatter$tokens_ts$space,
				);
			}

			if (node.readonly) {
				tokens.push(
					"readonly",
					___R$project$rome$$internal$formatter$tokens_ts$space,
				);
			}

			if (node.abstract) {
				tokens.push(
					"abstract",
					___R$project$rome$$internal$formatter$tokens_ts$space,
				);
			}
		}

		if (node.static) {
			tokens.push(
				"static",
				___R$project$rome$$internal$formatter$tokens_ts$space,
			);
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/js/auxiliary/JSComputedMemberProperty.ts
function ___R$project$rome$$internal$formatter$builders$js$auxiliary$JSComputedMemberProperty_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (node.optional) {
			tokens.push("?.");
		}

		tokens.push("[", builder.tokenize(node.value, node), "]");

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/js/objects/JSComputedPropertyKey.ts
function ___R$project$rome$$internal$formatter$builders$js$objects$JSComputedPropertyKey_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"[",
			builder.tokenize(node.value, node),
			"]",
		]);
	}


  // project-rome/@internal/formatter/builders/js/expressions/JSConditionalExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$expressions$JSConditionalExpression_ts$default(
		builder,
		node,
		parent,
	) {
		return ___R$project$rome$$internal$formatter$builders$js$expressions$JSConditionalExpression_ts$printConditionalExpression(
			builder.tokenize(node.test, node),
			builder.tokenize(node.consequent, node),
			builder.tokenize(node.alternate, node),
			parent,
			node.consequent,
			node.alternate,
		);
	}

	function ___R$$priv$project$rome$$internal$formatter$builders$js$expressions$JSConditionalExpression_ts$isConditionalExpression(
		node,
	) {
		return (
			node.type === "JSConditionalExpression" ||
			node.type === "TSConditionalType"
		);
	}

	function ___R$project$rome$$internal$formatter$builders$js$expressions$JSConditionalExpression_ts$printConditionalExpression(
		test,
		consequent,
		alternate,
		parentNode,
		consequentNode,
		alternateNode,
	) {
		const printed = ___R$project$rome$$internal$formatter$tokens_ts$concat([
			test,
			___R$project$rome$$internal$formatter$tokens_ts$indent(
				___R$project$rome$$internal$formatter$tokens_ts$concat([
					___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace,
					"?",
					___R$project$rome$$internal$formatter$tokens_ts$space,
					___R$$priv$project$rome$$internal$formatter$builders$js$expressions$JSConditionalExpression_ts$isConditionalExpression(
						consequentNode,
					)
						? consequent
						: ___R$project$rome$$internal$formatter$tokens_ts$indent(consequent),
				]),
			),
			___R$project$rome$$internal$formatter$tokens_ts$indent(
				___R$project$rome$$internal$formatter$tokens_ts$concat([
					___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace,
					":",
					___R$project$rome$$internal$formatter$tokens_ts$space,
					___R$$priv$project$rome$$internal$formatter$builders$js$expressions$JSConditionalExpression_ts$isConditionalExpression(
						alternateNode,
					)
						? alternate
						: ___R$project$rome$$internal$formatter$tokens_ts$indent(alternate),
				]),
			),
		]);

		// Do not group nested conditional expressions. By doing so, if a conditional
		// expression breaks, the hole chain breaks.
		return ___R$$priv$project$rome$$internal$formatter$builders$js$expressions$JSConditionalExpression_ts$isConditionalExpression(
			parentNode,
		)
			? printed
			: ___R$project$rome$$internal$formatter$tokens_ts$group(printed);
	}


  // project-rome/@internal/formatter/builders/js/statements/JSContinueStatement.ts
const ___R$project$rome$$internal$formatter$builders$js$statements$JSContinueStatement_ts$default = ___R$project$rome$$internal$formatter$builders$js$utils_ts$buildLabelStatementBuilder(
		"continue",
	);


  // project-rome/@internal/formatter/builders/js/statements/JSDebuggerStatement.ts
function ___R$project$rome$$internal$formatter$builders$js$statements$JSDebuggerStatement_ts$default() {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"debugger",
			";",
		]);
	}


  // project-rome/@internal/formatter/builders/js/literals/JSStringLiteral.ts
function ___R$project$rome$$internal$formatter$builders$js$literals$JSStringLiteral_ts$default(
		builder,
		node,
		parent,
	) {
		const quotes =
			parent.type === "JSXAttribute" || !node.value.includes('"') ? '"' : "'";

		const value =
			parent.type === "JSXAttribute"
				? ___R$project$rome$$internal$html$parser$xhtmlEntities_ts$escapeXHTMLEntities(
						node.value,
					)
				: node.value;

		return ___R$project$rome$$internal$string$escape$escapeJSString_ts$default(
			value,
			{quote: quotes},
		);
	}


  // project-rome/@internal/formatter/builders/js/core/JSDirective.ts
function ___R$project$rome$$internal$formatter$builders$js$core$JSDirective_ts$default(
		builder,
		node,
		parent,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			___R$project$rome$$internal$formatter$builders$js$literals$JSStringLiteral_ts$default(
				builder,
				node,
				parent,
			),
			";",
		]);
	}


  // project-rome/@internal/formatter/builders/js/expressions/JSDoExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$expressions$JSDoExpression_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"do",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(node.body, node),
		]);
	}


  // project-rome/@internal/formatter/builders/js/statements/JSDoWhileStatement.ts
function ___R$project$rome$$internal$formatter$builders$js$statements$JSDoWhileStatement_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			___R$project$rome$$internal$formatter$tokens_ts$group(
				___R$project$rome$$internal$formatter$tokens_ts$concat([
					"do",
					___R$project$rome$$internal$formatter$builders$js$utils_ts$printClause(
						builder,
						node.body,
						node,
					),
				]),
			),
			node.body.type === "JSBlockStatement"
				? ___R$project$rome$$internal$formatter$tokens_ts$space
				: ___R$project$rome$$internal$formatter$tokens_ts$hardline,
			"while",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			"(",
			___R$project$rome$$internal$formatter$tokens_ts$group(
				___R$project$rome$$internal$formatter$tokens_ts$concat([
					___R$project$rome$$internal$formatter$tokens_ts$indent(
						___R$project$rome$$internal$formatter$tokens_ts$concat([
							___R$project$rome$$internal$formatter$tokens_ts$softline,
							builder.tokenize(node.test, node),
						]),
					),
					___R$project$rome$$internal$formatter$tokens_ts$softline,
				]),
			),
			")",
			";",
		]);
	}


  // project-rome/@internal/formatter/builders/js/statements/JSEmptyStatement.ts
function ___R$project$rome$$internal$formatter$builders$js$statements$JSEmptyStatement_ts$default() {
		return ";";
	}


  // project-rome/@internal/formatter/builders/js/modules/JSExportAllDeclaration.ts
function ___R$project$rome$$internal$formatter$builders$js$modules$JSExportAllDeclaration_ts$default(
		builder,
		node,
	) {
		const tokens = [
			"export",
			___R$project$rome$$internal$formatter$tokens_ts$space,
		];

		if (node.exportKind === "type") {
			if (!builder.options.typeAnnotations) {
				return "";
			}

			tokens.push("type", ___R$project$rome$$internal$formatter$tokens_ts$space);
		}

		tokens.push(
			"*",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			"from",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(node.source, node),
			";",
		);

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/js/modules/JSExportLocalDeclaration.ts
function ___R$project$rome$$internal$formatter$builders$js$modules$JSExportLocalDeclaration_ts$default(
		builder,
		node,
	) {
		if (node.exportKind === "type" && !builder.options.typeAnnotations) {
			return "";
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"export",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			___R$project$rome$$internal$formatter$builders$js$modules$JSExportLocalDeclaration_ts$printExportDeclaration(
				builder,
				node,
			),
		]);
	}

	function ___R$project$rome$$internal$formatter$builders$js$modules$JSExportLocalDeclaration_ts$printExportDeclaration(
		builder,
		node,
	) {
		if (node.declaration) {
			const tokens = [builder.tokenize(node.declaration, node)];
			if (
				!___R$project$rome$$internal$js$ast$utils$isDeclaration_ts$isDeclaration(
					node.declaration,
				)
			) {
				tokens.push(";");
			}
			return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
		} else {
			if (node.type !== "JSExportLocalDeclaration") {
				throw new Error("Expected JSExportLocalDeclaration");
			}

			const {specifiers} = node;
			if (specifiers === undefined) {
				throw new Error("Expected specifiers since there was no declaration");
			}

			const tokens = [];

			if (node.exportKind === "type") {
				tokens.push(
					"type",
					___R$project$rome$$internal$formatter$tokens_ts$space,
				);
			}

			if (specifiers.length === 0) {
				if (
					___R$project$rome$$internal$formatter$builders$comments_ts$hasInnerComments(
						node,
					)
				) {
					tokens.push(
						___R$project$rome$$internal$formatter$tokens_ts$concat([
							"{",
							builder.tokenizeInnerComments(node, true),
							___R$project$rome$$internal$formatter$tokens_ts$hardline,
							"}",
						]),
					);
				} else {
					tokens.push("{}");
				}
			} else {
				tokens.push(
					___R$project$rome$$internal$formatter$tokens_ts$group(
						___R$project$rome$$internal$formatter$tokens_ts$concat([
							"{",
							___R$project$rome$$internal$formatter$tokens_ts$indent(
								___R$project$rome$$internal$formatter$tokens_ts$concat([
									___R$project$rome$$internal$formatter$tokens_ts$softline,
									___R$project$rome$$internal$formatter$builders$js$utils_ts$printCommaList(
										builder,
										specifiers,
										node,
									),
								]),
							),
							___R$project$rome$$internal$formatter$tokens_ts$ifBreak(","),
							___R$project$rome$$internal$formatter$tokens_ts$softline,
							"}",
						]),
					),
				);
			}

			tokens.push(";");

			return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
		}
	}


  // project-rome/@internal/formatter/builders/js/modules/JSExportDefaultDeclaration.ts
function ___R$project$rome$$internal$formatter$builders$js$modules$JSExportDefaultDeclaration_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"export",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			"default",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			___R$project$rome$$internal$formatter$builders$js$modules$JSExportLocalDeclaration_ts$printExportDeclaration(
				builder,
				node,
			),
		]);
	}


  // project-rome/@internal/formatter/builders/js/modules/JSExportDefaultSpecifier.ts
function ___R$project$rome$$internal$formatter$builders$js$modules$JSExportDefaultSpecifier_ts$default(
		builder,
		node,
	) {
		return builder.tokenize(node.exported, node);
	}


  // project-rome/@internal/formatter/builders/js/modules/JSImportDeclaration.ts
function ___R$project$rome$$internal$formatter$builders$js$modules$JSImportDeclaration_ts$default(
		builder,
		node,
	) {
		const tokens = [
			"import",
			___R$project$rome$$internal$formatter$tokens_ts$space,
		];

		if (node.importKind === "type" || node.importKind === "typeof") {
			tokens.push(node.importKind);
			tokens.push(___R$project$rome$$internal$formatter$tokens_ts$space);
		}

		const {namedSpecifiers, defaultSpecifier, namespaceSpecifier} = node;

		if (
			namedSpecifiers.length > 0 ||
			namespaceSpecifier !== undefined ||
			defaultSpecifier !== undefined
		) {
			tokens.push(
				___R$project$rome$$internal$formatter$builders$js$modules$JSImportDeclaration_ts$printModuleSpecifiers(
					builder,
					node,
				),
				___R$project$rome$$internal$formatter$tokens_ts$space,
				"from",
				___R$project$rome$$internal$formatter$tokens_ts$space,
			);
		}

		tokens.push(builder.tokenize(node.source, node), ";");

		return ___R$project$rome$$internal$formatter$tokens_ts$group(
			___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
		);
	}

	function ___R$project$rome$$internal$formatter$builders$js$modules$JSImportDeclaration_ts$printModuleSpecifiers(
		builder,
		node,
	) {
		const {namedSpecifiers, defaultSpecifier, namespaceSpecifier} = node;

		const groups = [];

		if (defaultSpecifier !== undefined) {
			groups.push(builder.tokenize(node.defaultSpecifier, node));
		}

		if (namespaceSpecifier !== undefined) {
			groups.push(builder.tokenize(node.namespaceSpecifier, node));
		}

		if (namedSpecifiers.length > 0) {
			const specifiers = [];

			for (const specifier of namedSpecifiers) {
				specifiers.push(builder.tokenize(specifier, node));
			}

			if (specifiers.length === 1) {
				// Do not create insert softline tokens when there is a single specifier
				// in order to keep the braces on the same line.
				groups.push(
					___R$project$rome$$internal$formatter$tokens_ts$concat([
						"{",
						specifiers[0],
						"}",
					]),
				);
			} else {
				groups.push(
					___R$project$rome$$internal$formatter$tokens_ts$concat([
						"{",
						___R$project$rome$$internal$formatter$tokens_ts$indent(
							___R$project$rome$$internal$formatter$tokens_ts$concat([
								___R$project$rome$$internal$formatter$tokens_ts$softline,
								___R$project$rome$$internal$formatter$tokens_ts$join(
									___R$project$rome$$internal$formatter$tokens_ts$concat([
										",",
										___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace,
									]),
									specifiers,
								),
							]),
						),
						___R$project$rome$$internal$formatter$tokens_ts$ifBreak(","),
						___R$project$rome$$internal$formatter$tokens_ts$softline,
						"}",
					]),
				);
			}
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$join(
			___R$project$rome$$internal$formatter$tokens_ts$concat([
				",",
				___R$project$rome$$internal$formatter$tokens_ts$space,
			]),
			groups,
		);
	}


  // project-rome/@internal/formatter/builders/js/modules/JSExportExternalDeclaration.ts
function ___R$project$rome$$internal$formatter$builders$js$modules$JSExportExternalDeclaration_ts$default(
		builder,
		node,
	) {
		const tokens = [
			"export",
			___R$project$rome$$internal$formatter$tokens_ts$space,
		];

		if (node.exportKind === "type") {
			if (!builder.options.typeAnnotations) {
				return "";
			}

			tokens.push("type", ___R$project$rome$$internal$formatter$tokens_ts$space);
		}

		tokens.push(
			___R$project$rome$$internal$formatter$builders$js$modules$JSImportDeclaration_ts$printModuleSpecifiers(
				builder,
				node,
			),
			___R$project$rome$$internal$formatter$tokens_ts$space,
			"from",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(node.source, node),
			";",
		);

		return ___R$project$rome$$internal$formatter$tokens_ts$group(
			___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
		);
	}


  // project-rome/@internal/formatter/builders/js/modules/JSExportLocalSpecifier.ts
function ___R$project$rome$$internal$formatter$builders$js$modules$JSExportLocalSpecifier_ts$default(
		builder,
		node,
	) {
		const tokens = [builder.tokenize(node.local, node)];

		if (node.local.name === node.exported.name) {
			return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
		} else {
			return ___R$project$rome$$internal$formatter$tokens_ts$concat([
				___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
				___R$project$rome$$internal$formatter$tokens_ts$space,
				"as",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.exported, node),
			]);
		}
	}


  // project-rome/@internal/formatter/builders/js/modules/JSExportExternalSpecifier.ts
function ___R$project$rome$$internal$formatter$builders$js$modules$JSExportExternalSpecifier_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$builders$js$modules$JSExportLocalSpecifier_ts$default(
			builder,
			node,
		);
	}


  // project-rome/@internal/formatter/builders/js/modules/JSExportNamespaceSpecifier.ts
function ___R$project$rome$$internal$formatter$builders$js$modules$JSExportNamespaceSpecifier_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"*",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			"as",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(node.exported, node),
		]);
	}


  // project-rome/@internal/formatter/builders/js/statements/JSExpressionStatement.ts
function ___R$project$rome$$internal$formatter$builders$js$statements$JSExpressionStatement_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			builder.tokenize(node.expression, node),
			";",
		]);
	}


  // project-rome/@internal/formatter/builders/js/statements/JSForInStatement.ts
function ___R$project$rome$$internal$formatter$builders$js$statements$JSForInStatement_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$group(
			___R$project$rome$$internal$formatter$tokens_ts$concat([
				"for",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				"(",
				builder.tokenize(node.left, node),
				___R$project$rome$$internal$formatter$tokens_ts$space,
				"in",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.right, node),
				")",
				___R$project$rome$$internal$formatter$builders$js$utils_ts$printClause(
					builder,
					node.body,
					node,
				),
			]),
		);
	}


  // project-rome/@internal/formatter/builders/js/statements/JSForOfStatement.ts
function ___R$project$rome$$internal$formatter$builders$js$statements$JSForOfStatement_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$group(
			___R$project$rome$$internal$formatter$tokens_ts$concat([
				"for",
				node.await
					? ___R$project$rome$$internal$formatter$tokens_ts$concat([
							___R$project$rome$$internal$formatter$tokens_ts$space,
							"await",
						])
					: "",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				"(",
				builder.tokenize(node.left, node),
				___R$project$rome$$internal$formatter$tokens_ts$space,
				"of",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.right, node),
				")",
				___R$project$rome$$internal$formatter$builders$js$utils_ts$printClause(
					builder,
					node.body,
					node,
				),
			]),
		);
	}


  // project-rome/@internal/formatter/builders/js/statements/JSForStatement.ts
function ___R$project$rome$$internal$formatter$builders$js$statements$JSForStatement_ts$default(
		builder,
		node,
	) {
		const body = ___R$project$rome$$internal$formatter$builders$js$utils_ts$printClause(
			builder,
			node.body,
			node,
		);

		if (!node.init && !node.test && !node.update) {
			return ___R$project$rome$$internal$formatter$tokens_ts$group(
				___R$project$rome$$internal$formatter$tokens_ts$concat([
					"for",
					___R$project$rome$$internal$formatter$tokens_ts$space,
					"(;;)",
					body,
				]),
			);
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$group(
			___R$project$rome$$internal$formatter$tokens_ts$concat([
				"for",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				"(",
				___R$project$rome$$internal$formatter$tokens_ts$group(
					___R$project$rome$$internal$formatter$tokens_ts$concat([
						___R$project$rome$$internal$formatter$tokens_ts$indent(
							___R$project$rome$$internal$formatter$tokens_ts$concat([
								___R$project$rome$$internal$formatter$tokens_ts$softline,
								builder.tokenize(node.init, node),
								";",
								___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace,
								builder.tokenize(node.test, node),
								";",
								___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace,
								builder.tokenize(node.update, node),
							]),
						),
						___R$project$rome$$internal$formatter$tokens_ts$softline,
					]),
				),
				")",
				body,
			]),
		);
	}


  // project-rome/@internal/formatter/builders/js/expressions/JSFunctionExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$expressions$JSFunctionExpression_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (node.head.async === true) {
			tokens.push("async");
			tokens.push(___R$project$rome$$internal$formatter$tokens_ts$space);
		}

		tokens.push("function");

		if (node.head.generator === true) {
			tokens.push("*");
		}

		if (node.id) {
			tokens.push(
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.id, node),
			);
		}

		tokens.push(
			builder.tokenize(node.head, node),
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(node.body, node),
		);

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/js/statements/JSFunctionDeclaration.ts
function ___R$project$rome$$internal$formatter$builders$js$statements$JSFunctionDeclaration_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$builders$js$expressions$JSFunctionExpression_ts$default(
			builder,
			node,
		);
	}


  // project-rome/@internal/formatter/builders/js/auxiliary/JSFunctionHead.ts
function ___R$project$rome$$internal$formatter$builders$js$auxiliary$JSFunctionHead_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (builder.options.typeAnnotations && node.typeParameters) {
			tokens.push(builder.tokenize(node.typeParameters, node));
		}

		const printedParameters = ___R$project$rome$$internal$formatter$builders$js$utils_ts$printBindingPatternParams(
			builder,
			node,
			node.thisType ? [node.thisType, ...node.params] : node.params,
			node.rest,
		);

		let printedReturnType = "";
		if (builder.options.typeAnnotations) {
			if (node.returnType) {
				const tokens = [":"];
				tokens.push(
					___R$project$rome$$internal$formatter$tokens_ts$space,
					builder.tokenize(node.returnType, node),
				);
				printedReturnType = ___R$project$rome$$internal$formatter$tokens_ts$concat(
					tokens,
				);
			}
		}

		tokens.push(
			___R$project$rome$$internal$formatter$tokens_ts$group(
				___R$project$rome$$internal$formatter$tokens_ts$concat([
					printedParameters,
					printedReturnType,
				]),
			),
		);

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/js/statements/JSIfStatement.ts
function ___R$project$rome$$internal$formatter$builders$js$statements$JSIfStatement_ts$default(
		builder,
		node,
	) {
		const tokens = [
			___R$project$rome$$internal$formatter$tokens_ts$group(
				___R$project$rome$$internal$formatter$tokens_ts$concat([
					"if",
					___R$project$rome$$internal$formatter$tokens_ts$space,
					"(",
					___R$project$rome$$internal$formatter$tokens_ts$group(
						___R$project$rome$$internal$formatter$tokens_ts$concat([
							___R$project$rome$$internal$formatter$tokens_ts$indent(
								___R$project$rome$$internal$formatter$tokens_ts$concat([
									___R$project$rome$$internal$formatter$tokens_ts$softline,
									builder.tokenize(node.test, node),
								]),
							),
							___R$project$rome$$internal$formatter$tokens_ts$softline,
						]),
					),
					")",
				]),
			),
			___R$project$rome$$internal$formatter$tokens_ts$space,
		];

		let needsBlock = false;
		if (node.alternate) {
			needsBlock =
				___R$$priv$project$rome$$internal$formatter$builders$js$statements$JSIfStatement_ts$getLastStatement(
					node.consequent,
				).type === "JSIfStatement";
		}

		if (needsBlock) {
			tokens.push(
				"{",
				___R$project$rome$$internal$formatter$tokens_ts$indent(
					builder.tokenize(node.consequent, node),
					true,
				),
				___R$project$rome$$internal$formatter$tokens_ts$hardline,
				"}",
			);
		} else {
			tokens.push(builder.tokenize(node.consequent, node));
		}

		if (node.alternate) {
			tokens.push(
				___R$project$rome$$internal$formatter$tokens_ts$space,
				"else",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.alternate, node),
			);
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}

	// Recursively get the last statement.
	function ___R$$priv$project$rome$$internal$formatter$builders$js$statements$JSIfStatement_ts$getLastStatement(
		statement,
	) {
		if (
			(statement.type === "JSWithStatement" ||
			statement.type === "JSWhileStatement" ||
			statement.type === "JSDoWhileStatement" ||
			statement.type === "JSForOfStatement" ||
			statement.type === "JSForInStatement" ||
			statement.type === "JSForStatement") &&
			___R$project$rome$$internal$js$ast$utils$isStatement_ts$isStatement(
				statement.body,
			)
		) {
			return ___R$$priv$project$rome$$internal$formatter$builders$js$statements$JSIfStatement_ts$getLastStatement(
				statement.body,
			);
		} else {
			return statement;
		}
	}


  // project-rome/@internal/formatter/builders/js/modules/JSImportCall.ts
function ___R$project$rome$$internal$formatter$builders$js$modules$JSImportCall_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"import(",
			builder.tokenize(node.argument, node),
			")",
		]);
	}


  // project-rome/@internal/formatter/builders/js/modules/JSImportDefaultSpecifier.ts
function ___R$project$rome$$internal$formatter$builders$js$modules$JSImportDefaultSpecifier_ts$default(
		builder,
		node,
	) {
		return builder.tokenize(node.local.name, node);
	}


  // project-rome/@internal/formatter/builders/js/modules/JSImportNamespaceSpecifier.ts
function ___R$project$rome$$internal$formatter$builders$js$modules$JSImportNamespaceSpecifier_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"*",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			"as",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(node.local.name, node),
		]);
	}


  // project-rome/@internal/formatter/builders/js/modules/JSImportSpecifier.ts
function ___R$project$rome$$internal$formatter$builders$js$modules$JSImportSpecifier_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		tokens.push(builder.tokenize(node.imported, node));

		if (node.local.name.name !== node.imported.name) {
			tokens.push(
				___R$project$rome$$internal$formatter$tokens_ts$space,
				"as",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.local.name, node),
			);
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/js/modules/JSImportSpecifierLocal.ts
function ___R$project$rome$$internal$formatter$builders$js$modules$JSImportSpecifierLocal_ts$default(
		builder,
		node,
	) {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/js/core/JSInterpreterDirective.ts
function ___R$project$rome$$internal$formatter$builders$js$core$JSInterpreterDirective_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"#!" + node.value,
			___R$project$rome$$internal$formatter$tokens_ts$hardline,
			___R$project$rome$$internal$formatter$tokens_ts$hardline,
		]);
	}


  // project-rome/@internal/formatter/builders/js/statements/JSLabeledStatement.ts
function ___R$project$rome$$internal$formatter$builders$js$statements$JSLabeledStatement_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			builder.tokenize(node.label, node),
			":",
			node.body.type === "JSEmptyStatement"
				? ";"
				: ___R$project$rome$$internal$formatter$tokens_ts$concat([
						___R$project$rome$$internal$formatter$tokens_ts$space,
						builder.tokenize(node.body, node),
					]),
		]);
	}


  // project-rome/@internal/formatter/builders/js/expressions/JSLogicalExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$expressions$JSLogicalExpression_ts$default(
		builder,
		node,
		parent,
	) {
		return ___R$project$rome$$internal$formatter$builders$js$expressions$JSBinaryExpression_ts$default(
			builder,
			node,
			parent,
		);
	}


  // project-rome/@internal/formatter/builders/js/expressions/JSMemberExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$expressions$JSMemberExpression_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			builder.tokenize(node.object, node),
			builder.tokenize(node.property, node),
		]);
	}


  // project-rome/@internal/formatter/builders/js/expressions/JSMetaProperty.ts
function ___R$project$rome$$internal$formatter$builders$js$expressions$JSMetaProperty_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			builder.tokenize(node.meta, node),
			".",
			builder.tokenize(node.property, node),
		]);
	}


  // project-rome/@internal/formatter/builders/js/expressions/JSNewExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$expressions$JSNewExpression_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"new",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			___R$project$rome$$internal$formatter$builders$js$expressions$JSCallExpression_ts$default(
				builder,
				node,
			),
		]);
	}


  // project-rome/@internal/formatter/builders/js/literals/JSNullLiteral.ts
function ___R$project$rome$$internal$formatter$builders$js$literals$JSNullLiteral_ts$default() {
		return "null";
	}


  // project-rome/@internal/formatter/builders/js/literals/JSNumericLiteral.ts
function ___R$project$rome$$internal$formatter$builders$js$literals$JSNumericLiteral_ts$default(
		builder,
		node,
	) {
		if (builder.options.format === "pretty") {
			if (node.format === undefined) {
				return ___R$project$rome$$internal$string$utils$humanizeNumber_ts$humanizeNumber(
					node.value,
				);
			} else {
				switch (node.format) {
					case "binary":
						return "0b" + node.value.toString(2);
					case "octal":
						return "0o" + node.value.toString(8);
					case "hex":
						return "0x" + node.value.toString(16);
				}
			}
		} else {
			return String(node.value);
		}
	}


  // project-rome/@internal/formatter/builders/js/objects/JSObjectMethod.ts
function ___R$project$rome$$internal$formatter$builders$js$objects$JSObjectMethod_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$builders$js$utils_ts$printMethod(
			builder,
			node,
		);
	}


  // project-rome/@internal/formatter/builders/js/expressions/JSOptionalCallExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$expressions$JSOptionalCallExpression_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$builders$js$expressions$JSCallExpression_ts$default(
			builder,
			node,
		);
	}


  // project-rome/@internal/formatter/builders/js/patterns/JSPatternMeta.ts
function ___R$project$rome$$internal$formatter$builders$js$patterns$JSPatternMeta_ts$default() {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/js/classes/JSPrivateName.ts
function ___R$project$rome$$internal$formatter$builders$js$classes$JSPrivateName_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"#",
			builder.tokenize(node.id, node),
		]);
	}


  // project-rome/@internal/formatter/builders/js/expressions/JSReferenceIdentifier.ts
function ___R$project$rome$$internal$formatter$builders$js$expressions$JSReferenceIdentifier_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$builders$js$auxiliary$JSIdentifier_ts$default(
			builder,
			node,
		);
	}


  // project-rome/@internal/formatter/builders/js/regex/JSRegExpAlternation.ts
function ___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpAlternation_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			builder.tokenize(node.left, node),
			"|",
			builder.tokenize(node.right, node),
		]);
	}


  // project-rome/@internal/formatter/builders/js/regex/JSRegExpAnyCharacter.ts
function ___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpAnyCharacter_ts$default() {
		return ".";
	}


  // project-rome/@internal/formatter/builders/js/regex/JSRegExpCharacter.ts
function ___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpCharacter_ts$default(
		builder,
		node,
		parent,
	) {
		const isInCharSet = parent.type === "JSRegExpCharSet";
		if (isInCharSet) {
			switch (node.value) {
				case "$":
				case "^":
				case ".":
				case "?":
				case "{":
				case "}":
				case "+":
				case "*":
				case "[":
				case "(":
				case ")":
				case "|":
					return node.value;

				case "-":
					return "\\-";
			}
		}

		switch (node.value) {
			case "\t":
				return "\\t";

			case "\n":
				return "\\n";

			case "\r":
				return "\\r";

			case "\x0b":
				return "\\v";

			case "\f":
				return "\\f";

			case "\b":
				return "\\b";

			case "/":
			case "\\":
			case "$":
			case "^":
			case ".":
			case "?":
			case "{":
			case "}":
			case "+":
			case "*":
			case "[":
			case "]":
			case "(":
			case ")":
			case "|":
				return "\\" + node.value;

			default:
				return ___R$project$rome$$internal$string$escape$escapeJSString_ts$default(
					node.value,
					{json: true, unicodeOnly: true},
				);
		}
	}


  // project-rome/@internal/formatter/builders/js/regex/JSRegExpCharSet.ts
function ___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpCharSet_ts$default(
		builder,
		node,
	) {
		const tokens = ["["];

		if (node.invert) {
			tokens.push("^");
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
			___R$project$rome$$internal$formatter$tokens_ts$concat(
				node.body.map((item) => builder.tokenize(item, node)),
			),
			"]",
		]);
	}


  // project-rome/@internal/formatter/builders/js/regex/JSRegExpCharSetRange.ts
function ___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpCharSetRange_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			builder.tokenize(node.start, node),
			"-",
			builder.tokenize(node.end, node),
		]);
	}


  // project-rome/@internal/formatter/builders/js/regex/JSRegExpControlCharacter.ts
function ___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpControlCharacter_ts$default() {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/js/regex/JSRegExpDigitCharacter.ts
function ___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpDigitCharacter_ts$default() {
		return "\\d";
	}


  // project-rome/@internal/formatter/builders/js/regex/JSRegExpEndCharacter.ts
function ___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpEndCharacter_ts$default() {
		return "$";
	}


  // project-rome/@internal/formatter/builders/js/regex/JSRegExpGroupCapture.ts
function ___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpGroupCapture_ts$default(
		builder,
		node,
	) {
		const tokens = ["("];

		if (node.name !== undefined) {
			tokens.push("?<");
			tokens.push(node.name);
			tokens.push(">");
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
			builder.tokenize(node.expression, node),
			")",
		]);
	}


  // project-rome/@internal/formatter/builders/js/regex/JSRegExpGroupNonCapture.ts
function ___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpGroupNonCapture_ts$default(
		builder,
		node,
	) {
		const tokens = ["(?"];

		switch (node.kind) {
			case "positive-lookahead": {
				tokens.push("=");
				break;
			}

			case "negative-lookahead": {
				tokens.push("!");
				break;
			}

			case "positive-lookbehind": {
				tokens.push("<!");
				break;
			}

			case "negative-lookbehind": {
				tokens.push("<=");
				break;
			}

			default: {
				tokens.push(":");
				break;
			}
		}

		tokens.push(builder.tokenize(node.expression, node));
		tokens.push(")");

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/js/literals/JSRegExpLiteral.ts
function ___R$project$rome$$internal$formatter$builders$js$literals$JSRegExpLiteral_ts$default(
		builder,
		node,
	) {
		const flags = [];

		if (node.global === true) {
			flags.push("g");
		}

		if (node.multiline === true) {
			flags.push("m");
		}

		if (node.sticky === true) {
			flags.push("y");
		}

		if (node.insensitive === true) {
			flags.push("i");
		}

		if (node.noDotNewline === true) {
			flags.push("s");
		}

		if (node.unicode === true) {
			flags.push("u");
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"/",
			builder.tokenize(node.expression, node),
			"/",
			flags.join(""),
		]);
	}


  // project-rome/@internal/formatter/builders/js/regex/JSRegExpNamedBackReference.ts
function ___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpNamedBackReference_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"\\k",
			"<",
			node.name,
			">",
		]);
	}


  // project-rome/@internal/formatter/builders/js/regex/JSRegExpNonDigitCharacter.ts
function ___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpNonDigitCharacter_ts$default() {
		return "\\D";
	}


  // project-rome/@internal/formatter/builders/js/regex/JSRegExpNonWhiteSpaceCharacter.ts
function ___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpNonWhiteSpaceCharacter_ts$default() {
		return "\\S";
	}


  // project-rome/@internal/formatter/builders/js/regex/JSRegExpNonWordBoundaryCharacter.ts
function ___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpNonWordBoundaryCharacter_ts$default() {
		return "\\B";
	}


  // project-rome/@internal/formatter/builders/js/regex/JSRegExpNonWordCharacter.ts
function ___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpNonWordCharacter_ts$default() {
		return "\\W";
	}


  // project-rome/@internal/formatter/builders/js/regex/JSRegExpNumericBackReference.ts
function ___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpNumericBackReference_ts$default(
		builder,
		node,
	) {
		return "\\" + node.value;
	}


  // project-rome/@internal/formatter/builders/js/regex/JSRegExpQuantified.ts
function ___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpQuantified_ts$default(
		builder,
		node,
	) {
		const tokens = [builder.tokenize(node.target, node)];

		if (node.min === 0 && node.max === 1) {
			tokens.push("?");
		} else if (node.min === 0 && node.max === undefined) {
			tokens.push("*");
		} else if (node.min === 1 && node.max === undefined) {
			tokens.push("+");
		} else {
			tokens.push("{");

			tokens.push(String(node.min));

			if (node.min !== node.max) {
				tokens.push(",");
				if (node.max !== undefined) {
					tokens.push(String(node.max));
				}
			}

			tokens.push("}");
		}

		if (node.lazy) {
			tokens.push("?");
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/js/regex/JSRegExpStartCharacter.ts
function ___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpStartCharacter_ts$default() {
		return "^";
	}


  // project-rome/@internal/formatter/builders/js/regex/JSRegExpSubExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpSubExpression_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat(
			node.body.map((item) => builder.tokenize(item, node)),
		);
	}


  // project-rome/@internal/formatter/builders/js/regex/JSRegExpWhiteSpaceCharacter.ts
function ___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpWhiteSpaceCharacter_ts$default() {
		return "\\s";
	}


  // project-rome/@internal/formatter/builders/js/regex/JSRegExpWordBoundaryCharacter.ts
function ___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpWordBoundaryCharacter_ts$default() {
		return "\\b";
	}


  // project-rome/@internal/formatter/builders/js/regex/JSRegExpWordCharacter.ts
function ___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpWordCharacter_ts$default() {
		return "\\w";
	}


  // project-rome/@internal/formatter/builders/js/statements/JSReturnStatement.ts
const ___R$project$rome$$internal$formatter$builders$js$statements$JSReturnStatement_ts$default = ___R$project$rome$$internal$formatter$builders$js$utils_ts$buildThrowAndReturnStatementBuilder(
		"return",
	);


  // project-rome/@internal/formatter/builders/js/core/JSRoot.ts
function ___R$project$rome$$internal$formatter$builders$js$core$JSRoot_ts$default(
		builder,
		node,
	) {
		const tokens = [builder.tokenizeStatementList(node.directives, node)];

		if (node.directives && node.directives.length) {
			tokens.push(___R$project$rome$$internal$formatter$tokens_ts$hardline);
		}

		if (node.interpreter && builder.options.allowInterpreterDirective) {
			tokens.push(builder.tokenize(node.interpreter, node));
		}

		tokens.push(
			builder.tokenizeInnerComments(node, false),
			builder.tokenizeStatementList(node.body, node),
		);

		tokens.push(___R$project$rome$$internal$formatter$tokens_ts$hardline);

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/js/expressions/JSSequenceExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$expressions$JSSequenceExpression_ts$default(
		builder,
		node,
		parent,
	) {
		if (
			parent.type === "JSExpressionStatement" ||
			parent.type === "JSForStatement" ||
			parent.type === "JSSequenceExpression"
		) {
			// Indent expressions after the first to improve the readability
			return ___R$project$rome$$internal$formatter$tokens_ts$group(
				___R$project$rome$$internal$formatter$tokens_ts$concat(
					node.expressions.map((expr, i) =>
						i === 0
							? builder.tokenize(expr, node)
							: ___R$project$rome$$internal$formatter$tokens_ts$concat([
									",",
									___R$project$rome$$internal$formatter$tokens_ts$indent(
										___R$project$rome$$internal$formatter$tokens_ts$concat([
											___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace,
											builder.tokenize(expr, node),
										]),
									),
								])
					),
				),
			);
		} else {
			return ___R$project$rome$$internal$formatter$tokens_ts$group(
				___R$project$rome$$internal$formatter$tokens_ts$join(
					___R$project$rome$$internal$formatter$tokens_ts$concat([
						",",
						___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace,
					]),
					node.expressions.map((expr) => builder.tokenize(expr, node)),
				),
			);
		}
	}


  // project-rome/@internal/formatter/builders/js/auxiliary/JSSpreadElement.ts
function ___R$project$rome$$internal$formatter$builders$js$auxiliary$JSSpreadElement_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"...",
			builder.tokenize(node.argument, node),
		]);
	}


  // project-rome/@internal/formatter/builders/js/objects/JSSpreadProperty.ts
function ___R$project$rome$$internal$formatter$builders$js$objects$JSSpreadProperty_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"...",
			builder.tokenize(node.argument, node),
		]);
	}


  // project-rome/@internal/formatter/builders/js/auxiliary/JSStaticMemberProperty.ts
function ___R$project$rome$$internal$formatter$builders$js$auxiliary$JSStaticMemberProperty_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (node.optional) {
			tokens.push("?");
		}

		tokens.push(".", builder.tokenize(node.value, node));

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/js/objects/JSStaticPropertyKey.ts
function ___R$project$rome$$internal$formatter$builders$js$objects$JSStaticPropertyKey_ts$default(
		builder,
		node,
	) {
		return builder.tokenize(node.value, node);
	}


  // project-rome/@internal/formatter/builders/js/expressions/JSSuper.ts
function ___R$project$rome$$internal$formatter$builders$js$expressions$JSSuper_ts$default() {
		return "super";
	}


  // project-rome/@internal/formatter/builders/js/auxiliary/JSSwitchCase.ts
function ___R$project$rome$$internal$formatter$builders$js$auxiliary$JSSwitchCase_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (node.test) {
			tokens.push(
				"case",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.test, node),
				":",
			);
		} else {
			tokens.push("default", ":");
		}

		const {consequent} = node;
		if (consequent.length === 1 && consequent[0].type === "JSBlockStatement") {
			tokens.push(___R$project$rome$$internal$formatter$tokens_ts$space);
			tokens.push(builder.tokenize(consequent[0], node));
		} else if (consequent.length > 0) {
			tokens.push(
				___R$project$rome$$internal$formatter$tokens_ts$indent(
					___R$project$rome$$internal$formatter$tokens_ts$concat([
						___R$project$rome$$internal$formatter$tokens_ts$hardline,
						builder.tokenizeStatementList(consequent, node),
					]),
				),
			);
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/js/statements/JSSwitchStatement.ts
function ___R$project$rome$$internal$formatter$builders$js$statements$JSSwitchStatement_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			___R$project$rome$$internal$formatter$tokens_ts$group(
				___R$project$rome$$internal$formatter$tokens_ts$concat([
					"switch",
					___R$project$rome$$internal$formatter$tokens_ts$space,
					"(",
					___R$project$rome$$internal$formatter$tokens_ts$group(
						___R$project$rome$$internal$formatter$tokens_ts$concat([
							___R$project$rome$$internal$formatter$tokens_ts$indent(
								___R$project$rome$$internal$formatter$tokens_ts$concat([
									___R$project$rome$$internal$formatter$tokens_ts$softline,
									builder.tokenize(node.discriminant, node),
								]),
							),
							___R$project$rome$$internal$formatter$tokens_ts$softline,
						]),
					),
					")",
				]),
			),
			___R$project$rome$$internal$formatter$tokens_ts$space,
			"{",
			node.cases.length > 0
				? ___R$project$rome$$internal$formatter$tokens_ts$indent(
						___R$project$rome$$internal$formatter$tokens_ts$concat([
							___R$project$rome$$internal$formatter$tokens_ts$hardline,
							builder.tokenizeStatementList(node.cases, node),
						]),
					)
				: "",
			___R$project$rome$$internal$formatter$tokens_ts$hardline,
			"}",
		]);
	}


  // project-rome/@internal/formatter/builders/js/expressions/JSTaggedTemplateExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$expressions$JSTaggedTemplateExpression_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			builder.tokenize(node.tag, node),
			builder.tokenize(node.quasi, node),
		]);
	}


  // project-rome/@internal/formatter/builders/js/auxiliary/JSTemplateElement.ts
function ___R$project$rome$$internal$formatter$builders$js$auxiliary$JSTemplateElement_ts$default(
		builder,
		node,
		parent,
	) {
		parent = ___R$project$rome$$internal$ast$js$literals$JSTemplateLiteral_ts$jsTemplateLiteral.assert(
			parent,
		);

		const isFirst = parent.quasis[0] === node;
		const isLast = parent.quasis[parent.quasis.length - 1] === node;

		const value = (isFirst ? "`" : "}") + node.raw + (isLast ? "`" : "${");
		return value;
	}


  // project-rome/@internal/formatter/builders/js/literals/JSTemplateLiteral.ts
function ___R$project$rome$$internal$formatter$builders$js$literals$JSTemplateLiteral_ts$default(
		builder,
		node,
	) {
		const tokens = [];
		const quasis = node.quasis;

		for (let i = 0; i < quasis.length; i++) {
			tokens.push(builder.tokenize(quasis[i], node));

			if (i + 1 < quasis.length) {
				tokens.push(builder.tokenize(node.expressions[i], node));
			}
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/js/expressions/JSThisExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$expressions$JSThisExpression_ts$default() {
		return "this";
	}


  // project-rome/@internal/formatter/builders/js/statements/JSThrowStatement.ts
const ___R$project$rome$$internal$formatter$builders$js$statements$JSThrowStatement_ts$default = ___R$project$rome$$internal$formatter$builders$js$utils_ts$buildThrowAndReturnStatementBuilder(
		"throw",
	);


  // project-rome/@internal/formatter/builders/js/statements/JSTryStatement.ts
function ___R$project$rome$$internal$formatter$builders$js$statements$JSTryStatement_ts$default(
		builder,
		node,
	) {
		const tokens = [
			"try",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(node.block, node),
		];

		if (node.handler) {
			tokens.push(
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.handler, node),
			);
		}

		if (node.finalizer) {
			tokens.push(
				___R$project$rome$$internal$formatter$tokens_ts$space,
				"finally",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.finalizer, node),
			);
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/js/expressions/JSUnaryExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$expressions$JSUnaryExpression_ts$default(
		builder,
		node,
	) {
		if (
			node.operator === "void" ||
			node.operator === "delete" ||
			node.operator === "typeof"
		) {
			return ___R$project$rome$$internal$formatter$tokens_ts$concat([
				node.operator,
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.argument, node),
			]);
		} else {
			return ___R$project$rome$$internal$formatter$tokens_ts$concat([
				node.operator,
				builder.tokenize(node.argument, node),
			]);
		}
	}


  // project-rome/@internal/formatter/builders/js/expressions/JSUpdateExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$expressions$JSUpdateExpression_ts$default(
		builder,
		node,
	) {
		if (node.prefix === true) {
			return ___R$project$rome$$internal$formatter$tokens_ts$concat([
				node.operator,
				builder.tokenize(node.argument, node),
			]);
		} else {
			return ___R$project$rome$$internal$formatter$tokens_ts$concat([
				builder.tokenize(node.argument, node),
				node.operator,
			]);
		}
	}


  // project-rome/@internal/formatter/builders/js/auxiliary/JSVariableDeclaration.ts
function ___R$project$rome$$internal$formatter$builders$js$auxiliary$JSVariableDeclaration_ts$default(
		builder,
		node,
	) {
		const declarations = node.declarations.map((declaration) =>
			builder.tokenize(declaration, node)
		);

		return ___R$project$rome$$internal$formatter$tokens_ts$group(
			___R$project$rome$$internal$formatter$tokens_ts$concat([
				node.kind,
				___R$project$rome$$internal$formatter$tokens_ts$space,
				declarations.shift(),
				___R$project$rome$$internal$formatter$tokens_ts$indent(
					___R$project$rome$$internal$formatter$tokens_ts$concat(
						declarations.map((declaration) =>
							___R$project$rome$$internal$formatter$tokens_ts$concat([
								",",
								___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace,
								declaration,
							])
						),
					),
				),
			]),
		);
	}


  // project-rome/@internal/formatter/builders/js/statements/JSVariableDeclarationStatement.ts
function ___R$project$rome$$internal$formatter$builders$js$statements$JSVariableDeclarationStatement_ts$default(
		builder,
		node,
	) {
		if (node.declare === true && !builder.options.typeAnnotations) {
			return "";
		}

		const tokens = [];

		if (node.declare) {
			tokens.push(
				"declare",
				___R$project$rome$$internal$formatter$tokens_ts$space,
			);
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
			builder.tokenize(node.declaration, node),
			";",
		]);
	}


  // project-rome/@internal/formatter/builders/js/auxiliary/JSVariableDeclarator.ts
function ___R$project$rome$$internal$formatter$builders$js$auxiliary$JSVariableDeclarator_ts$default(
		builder,
		node,
	) {
		if (node.init) {
			return ___R$project$rome$$internal$formatter$builders$js$utils_ts$printAssignment(
				builder,
				node,
				node.id,
				___R$project$rome$$internal$formatter$tokens_ts$concat([
					___R$project$rome$$internal$formatter$tokens_ts$space,
					"=",
				]),
				node.init,
			);
		} else {
			return builder.tokenize(node.id, node);
		}
	}


  // project-rome/@internal/formatter/builders/js/statements/JSWhileStatement.ts
function ___R$project$rome$$internal$formatter$builders$js$statements$JSWhileStatement_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$group(
			___R$project$rome$$internal$formatter$tokens_ts$concat([
				"while",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				"(",
				___R$project$rome$$internal$formatter$tokens_ts$group(
					___R$project$rome$$internal$formatter$tokens_ts$concat([
						___R$project$rome$$internal$formatter$tokens_ts$indent(
							___R$project$rome$$internal$formatter$tokens_ts$concat([
								___R$project$rome$$internal$formatter$tokens_ts$softline,
								builder.tokenize(node.test, node),
							]),
						),
						___R$project$rome$$internal$formatter$tokens_ts$softline,
					]),
				),
				")",
				___R$project$rome$$internal$formatter$builders$js$utils_ts$printClause(
					builder,
					node.body,
					node,
				),
			]),
		);
	}


  // project-rome/@internal/formatter/builders/js/statements/JSWithStatement.ts
function ___R$project$rome$$internal$formatter$builders$js$statements$JSWithStatement_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"with",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			"(",
			builder.tokenize(node.object, node),
			")",
			___R$project$rome$$internal$formatter$builders$js$utils_ts$printClause(
				builder,
				node.body,
				node,
			),
		]);
	}


  // project-rome/@internal/formatter/builders/js/jsx/JSXAttribute.ts
function ___R$project$rome$$internal$formatter$builders$js$jsx$JSXAttribute_ts$default(
		builder,
		node,
	) {
		const tokens = [builder.tokenize(node.name, node)];

		if (node.value) {
			return ___R$project$rome$$internal$formatter$tokens_ts$concat([
				___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
				"=",
				builder.tokenize(node.value, node),
			]);
		} else {
			return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
		}
	}


  // project-rome/@internal/formatter/builders/js/jsx/JSXElement.ts
function ___R$project$rome$$internal$formatter$builders$js$jsx$JSXElement_ts$default(
		builder,
		node,
	) {
		const tokens = [
			"<",
			builder.tokenize(node.name, node),
			builder.tokenize(node.typeArguments, node),
		];

		if (node.attributes.length > 0) {
			tokens.push(
				___R$project$rome$$internal$formatter$tokens_ts$space,
				___R$project$rome$$internal$formatter$tokens_ts$join(
					___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace,
					node.attributes.map((attr) => builder.tokenize(attr, node)),
				),
			);
		}

		if (node.selfClosing !== false && node.children.length === 0) {
			return ___R$project$rome$$internal$formatter$tokens_ts$group(
				___R$project$rome$$internal$formatter$tokens_ts$concat([
					___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
					___R$project$rome$$internal$formatter$tokens_ts$space,
					"/>",
				]),
			);
		} else {
			return ___R$project$rome$$internal$formatter$tokens_ts$concat([
				___R$project$rome$$internal$formatter$tokens_ts$group(
					___R$project$rome$$internal$formatter$tokens_ts$concat([
						___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
						">",
					]),
				),
				___R$project$rome$$internal$formatter$tokens_ts$concat([
					___R$project$rome$$internal$formatter$tokens_ts$indent(
						builder.tokenizeStatementList(node.children, node),
						true,
					),
					___R$project$rome$$internal$formatter$tokens_ts$hardline,
				]),
				"</",
				builder.tokenize(node.name, node),
				">",
			]);
		}
	}


  // project-rome/@internal/formatter/builders/js/jsx/JSXEmptyExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$jsx$JSXEmptyExpression_ts$default(
		builder,
		node,
	) {
		return builder.tokenizeInnerComments(node, false);
	}


  // project-rome/@internal/formatter/builders/js/jsx/JSXExpressionContainer.ts
function ___R$project$rome$$internal$formatter$builders$js$jsx$JSXExpressionContainer_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"{",
			builder.tokenize(node.expression, node),
			"}",
		]);
	}


  // project-rome/@internal/formatter/builders/js/jsx/JSXFragment.ts
function ___R$project$rome$$internal$formatter$builders$js$jsx$JSXFragment_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"<>",
			___R$project$rome$$internal$formatter$tokens_ts$concat([
				___R$project$rome$$internal$formatter$tokens_ts$indent(
					builder.tokenizeStatementList(node.children, node),
					true,
				),
				___R$project$rome$$internal$formatter$tokens_ts$hardline,
			]),
			"</>",
		]);
	}


  // project-rome/@internal/formatter/builders/js/jsx/JSXIdentifier.ts
function ___R$project$rome$$internal$formatter$builders$js$jsx$JSXIdentifier_ts$default(
		builder,
		node,
	) {
		return node.name;
	}


  // project-rome/@internal/formatter/builders/js/jsx/JSXMemberExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$jsx$JSXMemberExpression_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			builder.tokenize(node.object, node),
			".",
			builder.tokenize(node.property, node),
		]);
	}


  // project-rome/@internal/formatter/builders/js/jsx/JSXNamespacedName.ts
function ___R$project$rome$$internal$formatter$builders$js$jsx$JSXNamespacedName_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			builder.tokenize(node.namespace, node),
			":",
			builder.tokenize(node.name, node),
		]);
	}


  // project-rome/@internal/formatter/builders/js/jsx/JSXReferenceIdentifier.ts
function ___R$project$rome$$internal$formatter$builders$js$jsx$JSXReferenceIdentifier_ts$default(
		builder,
		node,
	) {
		return node.name;
	}


  // project-rome/@internal/formatter/builders/js/jsx/JSXSpreadAttribute.ts
function ___R$project$rome$$internal$formatter$builders$js$jsx$JSXSpreadAttribute_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"{",
			"...",
			builder.tokenize(node.argument, node),
			"}",
		]);
	}


  // project-rome/@internal/formatter/builders/js/jsx/JSXSpreadChild.ts
function ___R$project$rome$$internal$formatter$builders$js$jsx$JSXSpreadChild_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"{",
			"...",
			builder.tokenize(node.expression, node),
			"}",
		]);
	}


  // project-rome/@internal/formatter/builders/js/jsx/JSXText.ts
function ___R$project$rome$$internal$formatter$builders$js$jsx$JSXText_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$html$parser$xhtmlEntities_ts$escapeXHTMLEntities(
			___R$project$rome$$internal$js$ast$utils$cleanJSXText_ts$cleanJSXText(
				node.value,
			),
		);
	}


  // project-rome/@internal/formatter/builders/js/expressions/JSYieldExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$expressions$JSYieldExpression_ts$default(
		builder,
		node,
	) {
		const tokens = ["yield"];

		if (node.delegate === true) {
			tokens.push("*");
		}

		if (node.argument) {
			tokens.push(
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.argument, node),
			);
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/markdown/inline/MarkdownAutomaticLinkInline.ts
function ___R$project$rome$$internal$formatter$builders$markdown$inline$MarkdownAutomaticLinkInline_ts$default(
		builder,
		node,
	) {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/markdown/inline/MarkdownBoldInline.ts
function ___R$project$rome$$internal$formatter$builders$markdown$inline$MarkdownBoldInline_ts$default(
		builder,
		node,
	) {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/markdown/blocks/MarkdownCodeBlock.ts
function ___R$project$rome$$internal$formatter$builders$markdown$blocks$MarkdownCodeBlock_ts$default(
		builder,
		node,
	) {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/markdown/inline/MarkdownCodeInline.ts
function ___R$project$rome$$internal$formatter$builders$markdown$inline$MarkdownCodeInline_ts$default(
		builder,
		node,
	) {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/markdown/inline/MarkdownDefinitionInline.ts
function ___R$project$rome$$internal$formatter$builders$markdown$inline$MarkdownDefinitionInline_ts$default(
		builder,
		node,
	) {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/markdown/blocks/MarkdownDividerBlock.ts
function ___R$project$rome$$internal$formatter$builders$markdown$blocks$MarkdownDividerBlock_ts$default(
		builder,
		node,
	) {
		return node.value;
	}


  // project-rome/@internal/formatter/builders/markdown/inline/MarkdownEmphasisInline.ts
function ___R$project$rome$$internal$formatter$builders$markdown$inline$MarkdownEmphasisInline_ts$default(
		builder,
		node,
	) {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/markdown/blocks/MarkdownHeadingBlock.ts
function ___R$project$rome$$internal$formatter$builders$markdown$blocks$MarkdownHeadingBlock_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"#".repeat(node.level),
			___R$project$rome$$internal$formatter$tokens_ts$space,
			node.value,
			___R$project$rome$$internal$formatter$tokens_ts$hardline,
		]);
	}


  // project-rome/@internal/formatter/builders/markdown/inline/MarkdownImageInline.ts
function ___R$project$rome$$internal$formatter$builders$markdown$inline$MarkdownImageInline_ts$default(
		builder,
		node,
	) {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/markdown/inline/MarkdownLinkInline.ts
function ___R$project$rome$$internal$formatter$builders$markdown$inline$MarkdownLinkInline_ts$default(
		builder,
		node,
	) {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/markdown/blocks/MarkdownListBlock.ts
function ___R$project$rome$$internal$formatter$builders$markdown$blocks$MarkdownListBlock_ts$default(
		builder,
		node,
	) {
		const tokens = node.children.reduce(
			(tokens, child, index) => {
				if (node.ordered) {
					tokens.push(index + 1 + ".");
					tokens.push(___R$project$rome$$internal$formatter$tokens_ts$space);
				} else {
					if (child.value) {
						tokens.push(child.value);
						tokens.push(___R$project$rome$$internal$formatter$tokens_ts$space);
					}
				}
				tokens.push(builder.tokenize(child, node));
				if (index + 1 < node.children.length) {
					tokens.push(___R$project$rome$$internal$formatter$tokens_ts$hardline);
				}

				return tokens;
			},
			([]),
		);
		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/markdown/core/MarkdownListItem.ts
function ___R$project$rome$$internal$formatter$builders$markdown$core$MarkdownListItem_ts$default(
		builder,
		node,
	) {
		const tokens = [];
		if (node.checked !== undefined) {
			tokens.push("[" + (node.checked ? "x" : " ") + "]");
		}

		tokens.push(builder.tokenizeStatementList(node.children, node));

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/markdown/core/MarkdownParagraph.ts
function ___R$project$rome$$internal$formatter$builders$markdown$core$MarkdownParagraph_ts$default(
		builder,
		node,
	) {
		const tokens = node.children.map((child) => {
			return builder.tokenize(child, node);
		});
		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/markdown/blocks/MarkdownQuoteBlock.ts
function ___R$project$rome$$internal$formatter$builders$markdown$blocks$MarkdownQuoteBlock_ts$default(
		builder,
		node,
	) {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/markdown/core/MarkdownRoot.ts
function ___R$project$rome$$internal$formatter$builders$markdown$core$MarkdownRoot_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			builder.tokenizeStatementList(node.body, node),
			___R$project$rome$$internal$formatter$tokens_ts$hardline,
		]);
	}


  // project-rome/@internal/formatter/builders/markdown/core/MarkdownText.ts
function ___R$project$rome$$internal$formatter$builders$markdown$core$MarkdownText_ts$default(
		builder,
		node,
	) {
		return node.value;
	}


  // project-rome/@internal/formatter/builders/common/core/MockParent.ts
function ___R$project$rome$$internal$formatter$builders$common$core$MockParent_ts$default() {
		throw new Error("unimplemented");
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSAnyKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSAnyKeywordTypeAnnotation_ts$default() {
		return "any";
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSArrayType.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSArrayType_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			builder.tokenize(node.elementType, node),
			"[]",
		]);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSAsExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSAsExpression_ts$default(
		builder,
		node,
	) {
		if (builder.options.typeAnnotations) {
			return ___R$project$rome$$internal$formatter$tokens_ts$concat([
				builder.tokenize(node.expression, node),
				___R$project$rome$$internal$formatter$tokens_ts$space,
				"as",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.typeAnnotation, node),
			]);
		} else {
			return builder.tokenize(node.expression, node);
		}
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSAssignmentAsExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSAssignmentAsExpression_ts$default(
		builder,
		node,
	) {
		if (builder.options.typeAnnotations) {
			return ___R$project$rome$$internal$formatter$tokens_ts$concat([
				builder.tokenize(node.expression, node),
				___R$project$rome$$internal$formatter$tokens_ts$space,
				"as",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.typeAnnotation, node),
			]);
		} else {
			return builder.tokenize(node.expression, node);
		}
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSAssignmentNonNullExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSAssignmentNonNullExpression_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			builder.tokenize(node.expression, node),
			"!",
		]);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSAssignmentTypeAssertion.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSAssignmentTypeAssertion_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"<",
			builder.tokenize(node.typeAnnotation, node),
			">",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(node.expression, node),
		]);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSBigIntKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSBigIntKeywordTypeAnnotation_ts$default() {
		return "bigint";
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSBigIntLiteralTypeAnnotation.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSBigIntLiteralTypeAnnotation_ts$default(
		builder,
		node,
	) {
		return node.value + "n";
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSBooleanKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSBooleanKeywordTypeAnnotation_ts$default() {
		return "boolean";
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSBooleanLiteralTypeAnnotation.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSBooleanLiteralTypeAnnotation_ts$default(
		builder,
		node,
	) {
		return node.value ? "true" : "false";
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSCallSignatureDeclaration.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSCallSignatureDeclaration_ts$default(
		builder,
		node,
	) {
		const tokens = [builder.tokenize(node.meta, node)];

		if (node.typeAnnotation) {
			tokens.push(
				":",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.typeAnnotation, node),
			);
		}

		tokens.push(";");

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSConditionalType.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSConditionalType_ts$default(
		builder,
		node,
		parent,
	) {
		return ___R$project$rome$$internal$formatter$builders$js$expressions$JSConditionalExpression_ts$printConditionalExpression(
			___R$project$rome$$internal$formatter$tokens_ts$concat([
				builder.tokenize(node.checkType, node),
				___R$project$rome$$internal$formatter$tokens_ts$space,
				"extends",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.extendsType, node),
			]),
			builder.tokenize(node.trueType, node),
			builder.tokenize(node.falseType, node),
			parent,
			node.trueType,
			node.falseType,
		);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSConstKeyword.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSConstKeyword_ts$default() {
		return "const";
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSConstructorType.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSConstructorType_ts$default(
		builder,
		node,
	) {
		const tokens = [
			"new",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(node.meta, node),
		];

		if (node.typeAnnotation) {
			tokens.push(
				___R$project$rome$$internal$formatter$tokens_ts$space,
				"=>",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.typeAnnotation, node),
			);
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSConstructSignatureDeclaration.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSConstructSignatureDeclaration_ts$default(
		builder,
		node,
	) {
		const tokens = [
			"new",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(node.meta, node),
		];

		if (node.typeAnnotation) {
			tokens.push(
				":",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.typeAnnotation, node),
			);
		}

		tokens.push(";");

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSDeclareFunction.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSDeclareFunction_ts$default(
		builder,
		node,
	) {
		let tokens = [];

		if (node.declare) {
			tokens.push(
				"declare",
				___R$project$rome$$internal$formatter$tokens_ts$space,
			);
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
			"function",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(node.id, node),
			builder.tokenize(node.head, node),
			";",
		]);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSDeclareMethod.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSDeclareMethod_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			builder.tokenize(node.meta, node),
			builder.tokenize(node.key, node),
			___R$project$rome$$internal$formatter$builders$js$utils_ts$printMethod(
				builder,
				node,
			),
		]);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSEmptyKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSEmptyKeywordTypeAnnotation_ts$default() {
		return "empty";
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSEnumDeclaration.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSEnumDeclaration_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (node.declare) {
			tokens.push(
				"declare",
				___R$project$rome$$internal$formatter$tokens_ts$space,
			);
		}

		if (node.const) {
			tokens.push(
				"const",
				___R$project$rome$$internal$formatter$tokens_ts$space,
			);
		}

		tokens.push(
			"enum",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(node.id, node),
			___R$project$rome$$internal$formatter$tokens_ts$space,
			___R$project$rome$$internal$formatter$builders$js$utils_ts$printTSBraced(
				builder,
				node,
				node.members,
			),
		);

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSEnumMember.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSEnumMember_ts$default(
		builder,
		node,
	) {
		const tokens = [builder.tokenize(node.id, node)];

		if (node.initializer) {
			tokens.push(
				___R$project$rome$$internal$formatter$tokens_ts$space,
				"=",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.initializer, node),
			);
		}

		tokens.push(",");

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSExportAssignment.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSExportAssignment_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"export",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			"=",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(node.expression, node),
			";",
		]);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSExpressionWithTypeArguments.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSExpressionWithTypeArguments_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			builder.tokenize(node.expression, node),
			builder.tokenize(node.typeParameters, node),
		]);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSExternalModuleReference.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSExternalModuleReference_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"require(",
			builder.tokenize(node.expression, node),
			")",
		]);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSFunctionType.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSFunctionType_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$group(
			___R$project$rome$$internal$formatter$tokens_ts$concat([
				builder.tokenize(node.meta, node),
				___R$project$rome$$internal$formatter$tokens_ts$space,
				"=>",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.typeAnnotation, node),
			]),
		);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSImportEqualsDeclaration.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSImportEqualsDeclaration_ts$default(
		builder,
		node,
	) {
		const tokens = [];
		if (node.isExport) {
			tokens.push("export");
			tokens.push(___R$project$rome$$internal$formatter$tokens_ts$space);
		}

		tokens.push(
			"import",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(node.id, node),
			___R$project$rome$$internal$formatter$tokens_ts$space,
			"=",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(node.moduleReference, node),
			";",
		);

		return ___R$project$rome$$internal$formatter$tokens_ts$group(
			___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
		);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSImportType.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSImportType_ts$default(
		builder,
		node,
	) {
		const tokens = ["import(", builder.tokenize(node.argument, node), ")"];

		if (node.qualifier) {
			tokens.push(".", builder.tokenize(node.qualifier, node));
		}

		if (node.typeParameters) {
			tokens.push(builder.tokenize(node.typeParameters, node));
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSIndexedAccessType.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSIndexedAccessType_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			builder.tokenize(node.objectType, node),
			"[",
			builder.tokenize(node.indexType, node),
			"]",
		]);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSIndexSignature.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSIndexSignature_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (node.readonly) {
			tokens.push("readonly");
			tokens.push(___R$project$rome$$internal$formatter$tokens_ts$space);
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
			"[",
			builder.tokenize(node.key, node),
			"]",
			":",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(node.typeAnnotation, node),
			";",
		]);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSInferType.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSInferType_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"infer",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(node.typeParameter, node),
		]);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSInterfaceBody.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSInterfaceBody_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$builders$js$utils_ts$printTSBraced(
			builder,
			node,
			node.body,
		);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSInterfaceDeclaration.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSInterfaceDeclaration_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (node.declare) {
			tokens.push(
				"declare",
				___R$project$rome$$internal$formatter$tokens_ts$space,
			);
		}

		tokens.push(
			"interface",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(node.id, node),
			builder.tokenize(node.typeParameters, node),
		);

		if (node.extends !== undefined && node.extends.length > 0) {
			tokens.push(
				___R$project$rome$$internal$formatter$tokens_ts$space,
				"extends",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				___R$project$rome$$internal$formatter$builders$js$utils_ts$printCommaList(
					builder,
					node.extends,
					node,
				),
			);
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(node.body, node),
		]);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSIntersectionTypeAnnotation.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSIntersectionTypeAnnotation_ts$default(
		builder,
		node,
	) {
		const parts = [];
		let shouldIndent = false;
		let previous;

		for (let i = 0; i < node.types.length; i++) {
			const type = node.types[i];
			const printed = builder.tokenize(type, node);

			if (previous === undefined) {
				parts.push(printed);
			} else if (
				___R$$priv$project$rome$$internal$formatter$builders$js$typescript$TSIntersectionTypeAnnotation_ts$isObjectType(
					previous,
				) &&
				___R$$priv$project$rome$$internal$formatter$builders$js$typescript$TSIntersectionTypeAnnotation_ts$isObjectType(
					type,
				)
			) {
				//   let foo: {
				//     a: string;
				//     b: string;
				//   } & {
				//     c: string;
				//     d: string;
				//   };
				parts.push(
					___R$project$rome$$internal$formatter$tokens_ts$space,
					"&",
					___R$project$rome$$internal$formatter$tokens_ts$space,
					shouldIndent
						? ___R$project$rome$$internal$formatter$tokens_ts$indent(printed)
						: printed,
				);
			} else if (
				!___R$$priv$project$rome$$internal$formatter$builders$js$typescript$TSIntersectionTypeAnnotation_ts$isObjectType(
					previous,
				) &&
				!___R$$priv$project$rome$$internal$formatter$builders$js$typescript$TSIntersectionTypeAnnotation_ts$isObjectType(
					type,
				)
			) {
				//   let foo: XXXX &
				//     YYYY &&
				//     ZZZZ;
				parts.push(
					___R$project$rome$$internal$formatter$tokens_ts$indent(
						___R$project$rome$$internal$formatter$tokens_ts$concat([
							___R$project$rome$$internal$formatter$tokens_ts$space,
							"&",
							___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace,
							printed,
						]),
					),
				);
			} else {
				//   let z: AAA & {
				//     a: string;
				//     b: string;
				//   } & BBB &
				//     CCC & {
				//       c: string;
				//       d: string;
				//     };
				if (i > 1) {
					shouldIndent = true;
				}

				parts.push(
					___R$project$rome$$internal$formatter$tokens_ts$space,
					"&",
					___R$project$rome$$internal$formatter$tokens_ts$space,
					shouldIndent
						? ___R$project$rome$$internal$formatter$tokens_ts$indent(printed)
						: printed,
				);
			}

			previous = type;
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$group(
			___R$project$rome$$internal$formatter$tokens_ts$concat(parts),
		);
	}

	function ___R$$priv$project$rome$$internal$formatter$builders$js$typescript$TSIntersectionTypeAnnotation_ts$isObjectType(
		node,
	) {
		return (
			node.type === "TSMappedType" || node.type === "TSObjectTypeAnnotation"
		);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSMappedType.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSMappedType_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (node.readonly) {
			tokens.push(
				___R$$priv$project$rome$$internal$formatter$builders$js$typescript$TSMappedType_ts$tokenIfPlusMinus(
					builder,
					node.readonly,
				),
				"readonly",
				___R$project$rome$$internal$formatter$tokens_ts$space,
			);
		}

		const {typeParameter} = node;
		tokens.push(
			"[",
			typeParameter.name,
			___R$project$rome$$internal$formatter$tokens_ts$space,
			"in",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(typeParameter.constraint, typeParameter),
			"]",
		);

		if (node.optional) {
			tokens.push(
				___R$$priv$project$rome$$internal$formatter$builders$js$typescript$TSMappedType_ts$tokenIfPlusMinus(
					builder,
					node.optional,
				),
				"?",
			);
		}

		if (node.typeAnnotation) {
			tokens.push(
				":",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.typeAnnotation, node),
			);
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$group(
			___R$project$rome$$internal$formatter$tokens_ts$concat([
				"{",
				___R$project$rome$$internal$formatter$tokens_ts$indent(
					___R$project$rome$$internal$formatter$tokens_ts$concat([
						___R$project$rome$$internal$formatter$tokens_ts$softline,
						___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
					]),
				),
				___R$project$rome$$internal$formatter$tokens_ts$softline,
				"}",
			]),
		);
	}

	function ___R$$priv$project$rome$$internal$formatter$builders$js$typescript$TSMappedType_ts$tokenIfPlusMinus(
		builder,
		token,
	) {
		switch (token) {
			case "+":
			case "-":
				return token;

			default:
				return "";
		}
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSMethodSignature.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSMethodSignature_ts$default(
		builder,
		node,
	) {
		const tokens = [
			builder.tokenize(node.key, node),
			builder.tokenize(node.meta, node),
		];

		if (node.returnType) {
			tokens.push(":");
			tokens.push(___R$project$rome$$internal$formatter$tokens_ts$space);
			tokens.push(builder.tokenize(node.returnType, node));
		}

		tokens.push(";");

		return ___R$project$rome$$internal$formatter$tokens_ts$group(
			___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
		);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSMixedKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSMixedKeywordTypeAnnotation_ts$default() {
		return "mixed";
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSModuleBlock.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSModuleBlock_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"{",
			___R$project$rome$$internal$formatter$tokens_ts$indent(
				builder.tokenizeStatementList(node.body, node),
				true,
			),
			___R$project$rome$$internal$formatter$tokens_ts$hardline,
			"}",
		]);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSModuleDeclaration.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSModuleDeclaration_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (node.declare) {
			tokens.push("declare");
			tokens.push(___R$project$rome$$internal$formatter$tokens_ts$space);
		}

		if (!node.global) {
			tokens.push(
				node.id.type === "JSBindingIdentifier" ? "namespace" : "module",
			);
			tokens.push(___R$project$rome$$internal$formatter$tokens_ts$space);
		}

		tokens.push(builder.tokenize(node.id, node));

		if (!node.body) {
			tokens.push(";");
			return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
		}

		let body = node.body;
		while (body !== undefined && body.type === "TSModuleDeclaration") {
			tokens.push(".", builder.tokenize(body.id, body));
			body = body.body;
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(body, node),
		]);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSNamespaceExportDeclaration.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSNamespaceExportDeclaration_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"export",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			"as",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			"namespace",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(node.id, node),
			";",
		]);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSNeverKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSNeverKeywordTypeAnnotation_ts$default() {
		return "never";
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSNonNullExpression.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSNonNullExpression_ts$default(
		builder,
		node,
	) {
		const expr = builder.tokenize(node.expression, node);

		if (builder.options.typeAnnotations) {
			return ___R$project$rome$$internal$formatter$tokens_ts$concat([expr, "!"]);
		} else {
			return expr;
		}
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSNullKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSNullKeywordTypeAnnotation_ts$default() {
		return "null";
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSNumberKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSNumberKeywordTypeAnnotation_ts$default() {
		return "number";
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSNumericLiteralTypeAnnotation.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSNumericLiteralTypeAnnotation_ts$default(
		builder,
		node,
	) {
		return String(node.value);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSObjectKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSObjectKeywordTypeAnnotation_ts$default() {
		return "object";
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSObjectTypeAnnotation.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSObjectTypeAnnotation_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$builders$js$utils_ts$printTSBraced(
			builder,
			node,
			node.members,
		);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSParenthesizedType.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSParenthesizedType_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"(",
			builder.tokenize(node.typeAnnotation, node),
			")",
		]);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSPropertySignature.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSPropertySignature_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (node.readonly) {
			tokens.push(
				"readonly",
				___R$project$rome$$internal$formatter$tokens_ts$space,
			);
		}

		tokens.push(builder.tokenize(node.key, node));

		if (node.optional) {
			tokens.push("?");
		}

		if (node.typeAnnotation) {
			tokens.push(
				":",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.typeAnnotation, node),
			);
		}

		tokens.push(";");

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSQualifiedName.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSQualifiedName_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			builder.tokenize(node.left, node),
			".",
			builder.tokenize(node.right, node),
		]);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSSignatureDeclarationMeta.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSSignatureDeclarationMeta_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			builder.tokenize(node.typeParameters, node),
			___R$project$rome$$internal$formatter$builders$js$utils_ts$printBindingPatternParams(
				builder,
				node,
				node.parameters,
				node.rest,
			),
		]);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSStringKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSStringKeywordTypeAnnotation_ts$default() {
		return "string";
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSStringLiteralTypeAnnotation.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSStringLiteralTypeAnnotation_ts$default(
		builder,
		node,
		parent,
	) {
		return ___R$project$rome$$internal$formatter$builders$js$literals$JSStringLiteral_ts$default(
			builder,
			node,
			parent,
		);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSSymbolKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSSymbolKeywordTypeAnnotation_ts$default() {
		return "symbol";
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSTemplateLiteralTypeAnnotation.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSTemplateLiteralTypeAnnotation_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$string$escape$escapeJSString_ts$default(
			node.value,
			{quote: "`"},
		);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSThisType.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSThisType_ts$default() {
		return "this";
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSTupleElement.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSTupleElement_ts$default(
		builder,
		node,
	) {
		let tokens = [];

		if (node.name) {
			tokens.push(builder.tokenize(node.name, node));
		}

		if (node.optional) {
			tokens.push("?");
		}

		if (node.name) {
			tokens.push(":");
			tokens.push(___R$project$rome$$internal$formatter$tokens_ts$space);
		}

		tokens.push(builder.tokenize(node.typeAnnotation, node));

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSTupleType.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSTupleType_ts$default(
		builder,
		node,
	) {
		if (node.elementTypes.length === 0 && node.rest === undefined) {
			if (
				___R$project$rome$$internal$formatter$builders$comments_ts$hasInnerComments(
					node,
				)
			) {
				return ___R$project$rome$$internal$formatter$tokens_ts$concat([
					"[",
					builder.tokenizeInnerComments(node, true),
					___R$project$rome$$internal$formatter$tokens_ts$hardline,
					"]",
				]);
			} else {
				return "[]";
			}
		}

		const parts = [];

		for (const elementType of node.elementTypes) {
			parts.push(builder.tokenize(elementType, node));
		}

		if (node.rest !== undefined) {
			parts.push(
				___R$project$rome$$internal$formatter$tokens_ts$concat([
					"...",
					builder.tokenize(node.rest, node),
				]),
			);
		}

		const tokens = [
			"[",
			___R$project$rome$$internal$formatter$tokens_ts$indent(
				___R$project$rome$$internal$formatter$tokens_ts$concat([
					___R$project$rome$$internal$formatter$tokens_ts$softline,
					___R$project$rome$$internal$formatter$tokens_ts$join(
						___R$project$rome$$internal$formatter$tokens_ts$concat([
							",",
							___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace,
						]),
						parts,
					),
				]),
			),
		];

		if (node.rest === undefined) {
			tokens.push(___R$project$rome$$internal$formatter$tokens_ts$ifBreak(","));
		}

		tokens.push(___R$project$rome$$internal$formatter$tokens_ts$softline, "]");

		return ___R$project$rome$$internal$formatter$tokens_ts$group(
			___R$project$rome$$internal$formatter$tokens_ts$concat(tokens),
		);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSTypeAlias.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSTypeAlias_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$group(
			___R$project$rome$$internal$formatter$tokens_ts$concat([
				"type",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.id, node),
				builder.tokenize(node.typeParameters, node),
				___R$project$rome$$internal$formatter$tokens_ts$space,
				"=",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.right, node),
				";",
			]),
		);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSTypeAssertion.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSTypeAssertion_ts$default(
		builder,
		node,
	) {
		if (builder.options.typeAnnotations) {
			return ___R$project$rome$$internal$formatter$tokens_ts$group(
				___R$project$rome$$internal$formatter$tokens_ts$concat([
					___R$project$rome$$internal$formatter$tokens_ts$group(
						___R$project$rome$$internal$formatter$tokens_ts$concat([
							"<",
							___R$project$rome$$internal$formatter$tokens_ts$indent(
								___R$project$rome$$internal$formatter$tokens_ts$concat([
									___R$project$rome$$internal$formatter$tokens_ts$softline,
									builder.tokenize(node.typeAnnotation, node),
								]),
							),
							___R$project$rome$$internal$formatter$tokens_ts$softline,
							">",
						]),
					),
					builder.tokenize(node.expression, node),
				]),
			);
		} else {
			return builder.tokenize(node.expression, node);
		}
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSTypeOperator.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSTypeOperator_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			node.operator,
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(node.typeAnnotation, node),
		]);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSTypeParameter.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSTypeParameter_ts$default(
		builder,
		node,
	) {
		const tokens = [node.name];

		if (node.constraint) {
			tokens.push(
				___R$project$rome$$internal$formatter$tokens_ts$space,
				"extends",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.constraint, node),
			);
		}

		if (node.default) {
			tokens.push(
				___R$project$rome$$internal$formatter$tokens_ts$space,
				"=",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.default, node),
			);
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSTypeParameterDeclaration.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSTypeParameterDeclaration_ts$default(
		builder,
		node,
	) {
		const params = node.params;
		const shouldInline =
			params.length === 1 &&
			params[0].type !== "TSIntersectionTypeAnnotation" &&
			params[0].type !== "TSUnionTypeAnnotation" &&
			params[0].type !== "TSIndexedAccessType" &&
			params[0].type !== "TSMappedType";

		if (shouldInline) {
			return ___R$project$rome$$internal$formatter$tokens_ts$concat([
				"<",
				builder.tokenize(params[0], node),
				">",
			]);
		} else {
			return ___R$project$rome$$internal$formatter$tokens_ts$group(
				___R$project$rome$$internal$formatter$tokens_ts$concat([
					"<",
					___R$project$rome$$internal$formatter$tokens_ts$indent(
						___R$project$rome$$internal$formatter$tokens_ts$concat([
							___R$project$rome$$internal$formatter$tokens_ts$softline,
							___R$project$rome$$internal$formatter$builders$js$utils_ts$printCommaList(
								builder,
								params,
								node,
							),
						]),
					),
					___R$project$rome$$internal$formatter$tokens_ts$softline,
					">",
				]),
			);
		}
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSTypeParameterInstantiation.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSTypeParameterInstantiation_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$builders$js$typescript$TSTypeParameterDeclaration_ts$default(
			builder,
			node,
		);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSTypePredicate.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSTypePredicate_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (node.asserts) {
			tokens.push(
				"asserts",
				___R$project$rome$$internal$formatter$tokens_ts$space,
			);
		}

		tokens.push(builder.tokenize(node.parameterName, node));

		if (node.typeAnnotation) {
			tokens.push(
				___R$project$rome$$internal$formatter$tokens_ts$space,
				"is",
				___R$project$rome$$internal$formatter$tokens_ts$space,
				builder.tokenize(node.typeAnnotation, node),
			);
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSTypeQuery.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSTypeQuery_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			"typeof",
			___R$project$rome$$internal$formatter$tokens_ts$space,
			builder.tokenize(node.exprName, node),
		]);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSTypeReference.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSTypeReference_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$internal$formatter$tokens_ts$concat([
			builder.tokenize(node.typeName, node),
			builder.tokenize(node.typeParameters, node),
		]);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSUndefinedKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSUndefinedKeywordTypeAnnotation_ts$default() {
		return "undefined";
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSUnionTypeAnnotation.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSUnionTypeAnnotation_ts$default(
		builder,
		node,
		parent,
	) {
		// Indentation may be handled by the parent node
		const shouldIndent =
			parent.type !== "TSTypeAssertion" &&
			parent.type !== "TSTypeParameterDeclaration" &&
			parent.type !== "TSTypeParameterInstantiation";

		const printed = ___R$project$rome$$internal$formatter$tokens_ts$concat([
			___R$project$rome$$internal$formatter$tokens_ts$ifBreak(
				___R$project$rome$$internal$formatter$tokens_ts$concat([
					shouldIndent
						? ___R$project$rome$$internal$formatter$tokens_ts$hardline
						: "",
					"|",
					___R$project$rome$$internal$formatter$tokens_ts$space,
				]),
			),
			___R$project$rome$$internal$formatter$tokens_ts$join(
				___R$project$rome$$internal$formatter$tokens_ts$concat([
					___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace,
					"|",
					___R$project$rome$$internal$formatter$tokens_ts$space,
				]),
				node.types.map((type) =>
					___R$project$rome$$internal$formatter$tokens_ts$indent(
						builder.tokenize(type, node),
					)
				),
			),
		]);

		return ___R$project$rome$$internal$formatter$tokens_ts$group(
			shouldIndent
				? ___R$project$rome$$internal$formatter$tokens_ts$indent(printed)
				: printed,
		);
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSUnknownKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSUnknownKeywordTypeAnnotation_ts$default() {
		return "unknown";
	}


  // project-rome/@internal/formatter/builders/js/typescript/TSVoidKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$formatter$builders$js$typescript$TSVoidKeywordTypeAnnotation_ts$default() {
		return "void";
	}


  // project-rome/@internal/formatter/builders/index.ts
// rome-ignore lint/ts/noExplicitAny: future cleanup
	const ___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
		"builders",
	);
	const ___R$project$rome$$internal$formatter$builders$index_ts$default = ___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders;
	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"CommentBlock",
		___R$project$rome$$internal$formatter$builders$common$comments$CommentBlock_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"CommentLine",
		___R$project$rome$$internal$formatter$builders$common$comments$CommentLine_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"CommitRoot",
		___R$project$rome$$internal$formatter$builders$common$commit$CommitRoot_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"CSSAtRule",
		___R$project$rome$$internal$formatter$builders$css$core$CSSAtRule_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"CSSBlock",
		___R$project$rome$$internal$formatter$builders$css$core$CSSBlock_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"CSSDeclaration",
		___R$project$rome$$internal$formatter$builders$css$core$CSSDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"CSSDimension",
		___R$project$rome$$internal$formatter$builders$css$core$CSSDimension_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"CSSFunction",
		___R$project$rome$$internal$formatter$builders$css$core$CSSFunction_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"CSSIdentifier",
		___R$project$rome$$internal$formatter$builders$css$core$CSSIdentifier_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"CSSNumber",
		___R$project$rome$$internal$formatter$builders$css$core$CSSNumber_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"CSSPercentage",
		___R$project$rome$$internal$formatter$builders$css$core$CSSPercentage_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"CSSRaw",
		___R$project$rome$$internal$formatter$builders$css$core$CSSRaw_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"CSSRoot",
		___R$project$rome$$internal$formatter$builders$css$core$CSSRoot_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"CSSRule",
		___R$project$rome$$internal$formatter$builders$css$core$CSSRule_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"HTMLAttribute",
		___R$project$rome$$internal$formatter$builders$html$attributes$HTMLAttribute_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"HTMLDoctypeTag",
		___R$project$rome$$internal$formatter$builders$html$tags$HTMLDoctypeTag_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"HTMLElement",
		___R$project$rome$$internal$formatter$builders$html$tags$HTMLElement_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"HTMLIdentifier",
		___R$project$rome$$internal$formatter$builders$html$core$HTMLIdentifier_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"HTMLRoot",
		___R$project$rome$$internal$formatter$builders$html$core$HTMLRoot_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"HTMLString",
		___R$project$rome$$internal$formatter$builders$html$core$HTMLString_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"HTMLText",
		___R$project$rome$$internal$formatter$builders$html$core$HTMLText_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSAmbiguousFlowTypeCastExpression",
		___R$project$rome$$internal$formatter$builders$js$temp$JSAmbiguousFlowTypeCastExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSArrayExpression",
		___R$project$rome$$internal$formatter$builders$js$expressions$JSArrayExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSArrayHole",
		___R$project$rome$$internal$formatter$builders$js$auxiliary$JSArrayHole_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSArrowFunctionExpression",
		___R$project$rome$$internal$formatter$builders$js$expressions$JSArrowFunctionExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSAssignmentArrayPattern",
		___R$project$rome$$internal$formatter$builders$js$patterns$JSAssignmentArrayPattern_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSAssignmentAssignmentPattern",
		___R$project$rome$$internal$formatter$builders$js$patterns$JSAssignmentAssignmentPattern_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSAssignmentExpression",
		___R$project$rome$$internal$formatter$builders$js$expressions$JSAssignmentExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSAssignmentIdentifier",
		___R$project$rome$$internal$formatter$builders$js$patterns$JSAssignmentIdentifier_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSAssignmentObjectPattern",
		___R$project$rome$$internal$formatter$builders$js$patterns$JSAssignmentObjectPattern_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSAssignmentObjectPatternProperty",
		___R$project$rome$$internal$formatter$builders$js$patterns$JSAssignmentObjectPatternProperty_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSAwaitExpression",
		___R$project$rome$$internal$formatter$builders$js$expressions$JSAwaitExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSBigIntLiteral",
		___R$project$rome$$internal$formatter$builders$js$literals$JSBigIntLiteral_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSBinaryExpression",
		___R$project$rome$$internal$formatter$builders$js$expressions$JSBinaryExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSBindingArrayPattern",
		___R$project$rome$$internal$formatter$builders$js$patterns$JSBindingArrayPattern_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSBindingAssignmentPattern",
		___R$project$rome$$internal$formatter$builders$js$patterns$JSBindingAssignmentPattern_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSBindingIdentifier",
		___R$project$rome$$internal$formatter$builders$js$patterns$JSBindingIdentifier_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSBindingObjectPattern",
		___R$project$rome$$internal$formatter$builders$js$patterns$JSBindingObjectPattern_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSBindingObjectPatternProperty",
		___R$project$rome$$internal$formatter$builders$js$patterns$JSBindingObjectPatternProperty_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSBlockStatement",
		___R$project$rome$$internal$formatter$builders$js$statements$JSBlockStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSBooleanLiteral",
		___R$project$rome$$internal$formatter$builders$js$literals$JSBooleanLiteral_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSBreakStatement",
		___R$project$rome$$internal$formatter$builders$js$statements$JSBreakStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSCallExpression",
		___R$project$rome$$internal$formatter$builders$js$expressions$JSCallExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSCatchClause",
		___R$project$rome$$internal$formatter$builders$js$auxiliary$JSCatchClause_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSClassDeclaration",
		___R$project$rome$$internal$formatter$builders$js$classes$JSClassDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSClassExpression",
		___R$project$rome$$internal$formatter$builders$js$classes$JSClassExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSClassHead",
		___R$project$rome$$internal$formatter$builders$js$classes$JSClassHead_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSClassMethod",
		___R$project$rome$$internal$formatter$builders$js$classes$JSClassMethod_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSClassPrivateMethod",
		___R$project$rome$$internal$formatter$builders$js$classes$JSClassPrivateMethod_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSClassPrivateProperty",
		___R$project$rome$$internal$formatter$builders$js$classes$JSClassPrivateProperty_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSClassProperty",
		___R$project$rome$$internal$formatter$builders$js$classes$JSClassProperty_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSClassPropertyMeta",
		___R$project$rome$$internal$formatter$builders$js$classes$JSClassPropertyMeta_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSComputedMemberProperty",
		___R$project$rome$$internal$formatter$builders$js$auxiliary$JSComputedMemberProperty_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSComputedPropertyKey",
		___R$project$rome$$internal$formatter$builders$js$objects$JSComputedPropertyKey_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSConditionalExpression",
		___R$project$rome$$internal$formatter$builders$js$expressions$JSConditionalExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSContinueStatement",
		___R$project$rome$$internal$formatter$builders$js$statements$JSContinueStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSDebuggerStatement",
		___R$project$rome$$internal$formatter$builders$js$statements$JSDebuggerStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSDirective",
		___R$project$rome$$internal$formatter$builders$js$core$JSDirective_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSDoExpression",
		___R$project$rome$$internal$formatter$builders$js$expressions$JSDoExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSDoWhileStatement",
		___R$project$rome$$internal$formatter$builders$js$statements$JSDoWhileStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSEmptyStatement",
		___R$project$rome$$internal$formatter$builders$js$statements$JSEmptyStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSExportAllDeclaration",
		___R$project$rome$$internal$formatter$builders$js$modules$JSExportAllDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSExportDefaultDeclaration",
		___R$project$rome$$internal$formatter$builders$js$modules$JSExportDefaultDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSExportDefaultSpecifier",
		___R$project$rome$$internal$formatter$builders$js$modules$JSExportDefaultSpecifier_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSExportExternalDeclaration",
		___R$project$rome$$internal$formatter$builders$js$modules$JSExportExternalDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSExportExternalSpecifier",
		___R$project$rome$$internal$formatter$builders$js$modules$JSExportExternalSpecifier_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSExportLocalDeclaration",
		___R$project$rome$$internal$formatter$builders$js$modules$JSExportLocalDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSExportLocalSpecifier",
		___R$project$rome$$internal$formatter$builders$js$modules$JSExportLocalSpecifier_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSExportNamespaceSpecifier",
		___R$project$rome$$internal$formatter$builders$js$modules$JSExportNamespaceSpecifier_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSExpressionStatement",
		___R$project$rome$$internal$formatter$builders$js$statements$JSExpressionStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSForInStatement",
		___R$project$rome$$internal$formatter$builders$js$statements$JSForInStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSForOfStatement",
		___R$project$rome$$internal$formatter$builders$js$statements$JSForOfStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSForStatement",
		___R$project$rome$$internal$formatter$builders$js$statements$JSForStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSFunctionDeclaration",
		___R$project$rome$$internal$formatter$builders$js$statements$JSFunctionDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSFunctionExpression",
		___R$project$rome$$internal$formatter$builders$js$expressions$JSFunctionExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSFunctionHead",
		___R$project$rome$$internal$formatter$builders$js$auxiliary$JSFunctionHead_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSIdentifier",
		___R$project$rome$$internal$formatter$builders$js$auxiliary$JSIdentifier_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSIfStatement",
		___R$project$rome$$internal$formatter$builders$js$statements$JSIfStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSImportCall",
		___R$project$rome$$internal$formatter$builders$js$modules$JSImportCall_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSImportDeclaration",
		___R$project$rome$$internal$formatter$builders$js$modules$JSImportDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSImportDefaultSpecifier",
		___R$project$rome$$internal$formatter$builders$js$modules$JSImportDefaultSpecifier_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSImportNamespaceSpecifier",
		___R$project$rome$$internal$formatter$builders$js$modules$JSImportNamespaceSpecifier_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSImportSpecifier",
		___R$project$rome$$internal$formatter$builders$js$modules$JSImportSpecifier_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSImportSpecifierLocal",
		___R$project$rome$$internal$formatter$builders$js$modules$JSImportSpecifierLocal_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSInterpreterDirective",
		___R$project$rome$$internal$formatter$builders$js$core$JSInterpreterDirective_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSLabeledStatement",
		___R$project$rome$$internal$formatter$builders$js$statements$JSLabeledStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSLogicalExpression",
		___R$project$rome$$internal$formatter$builders$js$expressions$JSLogicalExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSMemberExpression",
		___R$project$rome$$internal$formatter$builders$js$expressions$JSMemberExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSMetaProperty",
		___R$project$rome$$internal$formatter$builders$js$expressions$JSMetaProperty_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSNewExpression",
		___R$project$rome$$internal$formatter$builders$js$expressions$JSNewExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSNullLiteral",
		___R$project$rome$$internal$formatter$builders$js$literals$JSNullLiteral_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSNumericLiteral",
		___R$project$rome$$internal$formatter$builders$js$literals$JSNumericLiteral_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSObjectExpression",
		___R$project$rome$$internal$formatter$builders$js$objects$JSObjectExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSObjectMethod",
		___R$project$rome$$internal$formatter$builders$js$objects$JSObjectMethod_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSObjectProperty",
		___R$project$rome$$internal$formatter$builders$js$objects$JSObjectProperty_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSOptionalCallExpression",
		___R$project$rome$$internal$formatter$builders$js$expressions$JSOptionalCallExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSPatternMeta",
		___R$project$rome$$internal$formatter$builders$js$patterns$JSPatternMeta_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSPrivateName",
		___R$project$rome$$internal$formatter$builders$js$classes$JSPrivateName_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSReferenceIdentifier",
		___R$project$rome$$internal$formatter$builders$js$expressions$JSReferenceIdentifier_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSRegExpAlternation",
		___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpAlternation_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSRegExpAnyCharacter",
		___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpAnyCharacter_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSRegExpCharacter",
		___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpCharacter_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSRegExpCharSet",
		___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpCharSet_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSRegExpCharSetRange",
		___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpCharSetRange_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSRegExpControlCharacter",
		___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpControlCharacter_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSRegExpDigitCharacter",
		___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpDigitCharacter_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSRegExpEndCharacter",
		___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpEndCharacter_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSRegExpGroupCapture",
		___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpGroupCapture_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSRegExpGroupNonCapture",
		___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpGroupNonCapture_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSRegExpLiteral",
		___R$project$rome$$internal$formatter$builders$js$literals$JSRegExpLiteral_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSRegExpNamedBackReference",
		___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpNamedBackReference_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSRegExpNonDigitCharacter",
		___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpNonDigitCharacter_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSRegExpNonWhiteSpaceCharacter",
		___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpNonWhiteSpaceCharacter_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSRegExpNonWordBoundaryCharacter",
		___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpNonWordBoundaryCharacter_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSRegExpNonWordCharacter",
		___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpNonWordCharacter_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSRegExpNumericBackReference",
		___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpNumericBackReference_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSRegExpQuantified",
		___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpQuantified_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSRegExpStartCharacter",
		___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpStartCharacter_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSRegExpSubExpression",
		___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpSubExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSRegExpWhiteSpaceCharacter",
		___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpWhiteSpaceCharacter_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSRegExpWordBoundaryCharacter",
		___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpWordBoundaryCharacter_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSRegExpWordCharacter",
		___R$project$rome$$internal$formatter$builders$js$regex$JSRegExpWordCharacter_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSReturnStatement",
		___R$project$rome$$internal$formatter$builders$js$statements$JSReturnStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSRoot",
		___R$project$rome$$internal$formatter$builders$js$core$JSRoot_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSSequenceExpression",
		___R$project$rome$$internal$formatter$builders$js$expressions$JSSequenceExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSSpreadElement",
		___R$project$rome$$internal$formatter$builders$js$auxiliary$JSSpreadElement_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSSpreadProperty",
		___R$project$rome$$internal$formatter$builders$js$objects$JSSpreadProperty_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSStaticMemberProperty",
		___R$project$rome$$internal$formatter$builders$js$auxiliary$JSStaticMemberProperty_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSStaticPropertyKey",
		___R$project$rome$$internal$formatter$builders$js$objects$JSStaticPropertyKey_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSStringLiteral",
		___R$project$rome$$internal$formatter$builders$js$literals$JSStringLiteral_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSSuper",
		___R$project$rome$$internal$formatter$builders$js$expressions$JSSuper_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSSwitchCase",
		___R$project$rome$$internal$formatter$builders$js$auxiliary$JSSwitchCase_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSSwitchStatement",
		___R$project$rome$$internal$formatter$builders$js$statements$JSSwitchStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSTaggedTemplateExpression",
		___R$project$rome$$internal$formatter$builders$js$expressions$JSTaggedTemplateExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSTemplateElement",
		___R$project$rome$$internal$formatter$builders$js$auxiliary$JSTemplateElement_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSTemplateLiteral",
		___R$project$rome$$internal$formatter$builders$js$literals$JSTemplateLiteral_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSThisExpression",
		___R$project$rome$$internal$formatter$builders$js$expressions$JSThisExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSThrowStatement",
		___R$project$rome$$internal$formatter$builders$js$statements$JSThrowStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSTryStatement",
		___R$project$rome$$internal$formatter$builders$js$statements$JSTryStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSUnaryExpression",
		___R$project$rome$$internal$formatter$builders$js$expressions$JSUnaryExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSUpdateExpression",
		___R$project$rome$$internal$formatter$builders$js$expressions$JSUpdateExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSVariableDeclaration",
		___R$project$rome$$internal$formatter$builders$js$auxiliary$JSVariableDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSVariableDeclarationStatement",
		___R$project$rome$$internal$formatter$builders$js$statements$JSVariableDeclarationStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSVariableDeclarator",
		___R$project$rome$$internal$formatter$builders$js$auxiliary$JSVariableDeclarator_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSWhileStatement",
		___R$project$rome$$internal$formatter$builders$js$statements$JSWhileStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSWithStatement",
		___R$project$rome$$internal$formatter$builders$js$statements$JSWithStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSXAttribute",
		___R$project$rome$$internal$formatter$builders$js$jsx$JSXAttribute_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSXElement",
		___R$project$rome$$internal$formatter$builders$js$jsx$JSXElement_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSXEmptyExpression",
		___R$project$rome$$internal$formatter$builders$js$jsx$JSXEmptyExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSXExpressionContainer",
		___R$project$rome$$internal$formatter$builders$js$jsx$JSXExpressionContainer_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSXFragment",
		___R$project$rome$$internal$formatter$builders$js$jsx$JSXFragment_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSXIdentifier",
		___R$project$rome$$internal$formatter$builders$js$jsx$JSXIdentifier_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSXMemberExpression",
		___R$project$rome$$internal$formatter$builders$js$jsx$JSXMemberExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSXNamespacedName",
		___R$project$rome$$internal$formatter$builders$js$jsx$JSXNamespacedName_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSXReferenceIdentifier",
		___R$project$rome$$internal$formatter$builders$js$jsx$JSXReferenceIdentifier_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSXSpreadAttribute",
		___R$project$rome$$internal$formatter$builders$js$jsx$JSXSpreadAttribute_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSXSpreadChild",
		___R$project$rome$$internal$formatter$builders$js$jsx$JSXSpreadChild_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSXText",
		___R$project$rome$$internal$formatter$builders$js$jsx$JSXText_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"JSYieldExpression",
		___R$project$rome$$internal$formatter$builders$js$expressions$JSYieldExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"MarkdownAutomaticLinkInline",
		___R$project$rome$$internal$formatter$builders$markdown$inline$MarkdownAutomaticLinkInline_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"MarkdownBoldInline",
		___R$project$rome$$internal$formatter$builders$markdown$inline$MarkdownBoldInline_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"MarkdownCodeBlock",
		___R$project$rome$$internal$formatter$builders$markdown$blocks$MarkdownCodeBlock_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"MarkdownCodeInline",
		___R$project$rome$$internal$formatter$builders$markdown$inline$MarkdownCodeInline_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"MarkdownDefinitionInline",
		___R$project$rome$$internal$formatter$builders$markdown$inline$MarkdownDefinitionInline_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"MarkdownDividerBlock",
		___R$project$rome$$internal$formatter$builders$markdown$blocks$MarkdownDividerBlock_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"MarkdownEmphasisInline",
		___R$project$rome$$internal$formatter$builders$markdown$inline$MarkdownEmphasisInline_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"MarkdownHeadingBlock",
		___R$project$rome$$internal$formatter$builders$markdown$blocks$MarkdownHeadingBlock_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"MarkdownImageInline",
		___R$project$rome$$internal$formatter$builders$markdown$inline$MarkdownImageInline_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"MarkdownLinkInline",
		___R$project$rome$$internal$formatter$builders$markdown$inline$MarkdownLinkInline_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"MarkdownListBlock",
		___R$project$rome$$internal$formatter$builders$markdown$blocks$MarkdownListBlock_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"MarkdownListItem",
		___R$project$rome$$internal$formatter$builders$markdown$core$MarkdownListItem_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"MarkdownParagraph",
		___R$project$rome$$internal$formatter$builders$markdown$core$MarkdownParagraph_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"MarkdownQuoteBlock",
		___R$project$rome$$internal$formatter$builders$markdown$blocks$MarkdownQuoteBlock_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"MarkdownRoot",
		___R$project$rome$$internal$formatter$builders$markdown$core$MarkdownRoot_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"MarkdownText",
		___R$project$rome$$internal$formatter$builders$markdown$core$MarkdownText_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"MockParent",
		___R$project$rome$$internal$formatter$builders$common$core$MockParent_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSAnyKeywordTypeAnnotation",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSAnyKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSArrayType",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSArrayType_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSAsExpression",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSAsExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSAssignmentAsExpression",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSAssignmentAsExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSAssignmentNonNullExpression",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSAssignmentNonNullExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSAssignmentTypeAssertion",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSAssignmentTypeAssertion_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSBigIntKeywordTypeAnnotation",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSBigIntKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSBigIntLiteralTypeAnnotation",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSBigIntLiteralTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSBooleanKeywordTypeAnnotation",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSBooleanKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSBooleanLiteralTypeAnnotation",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSBooleanLiteralTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSCallSignatureDeclaration",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSCallSignatureDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSConditionalType",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSConditionalType_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSConstKeyword",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSConstKeyword_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSConstructorType",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSConstructorType_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSConstructSignatureDeclaration",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSConstructSignatureDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSDeclareFunction",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSDeclareFunction_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSDeclareMethod",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSDeclareMethod_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSEmptyKeywordTypeAnnotation",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSEmptyKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSEnumDeclaration",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSEnumDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSEnumMember",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSEnumMember_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSExportAssignment",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSExportAssignment_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSExpressionWithTypeArguments",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSExpressionWithTypeArguments_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSExternalModuleReference",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSExternalModuleReference_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSFunctionType",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSFunctionType_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSImportEqualsDeclaration",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSImportEqualsDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSImportType",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSImportType_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSIndexedAccessType",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSIndexedAccessType_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSIndexSignature",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSIndexSignature_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSInferType",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSInferType_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSInterfaceBody",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSInterfaceBody_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSInterfaceDeclaration",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSInterfaceDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSIntersectionTypeAnnotation",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSIntersectionTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSMappedType",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSMappedType_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSMethodSignature",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSMethodSignature_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSMixedKeywordTypeAnnotation",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSMixedKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSModuleBlock",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSModuleBlock_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSModuleDeclaration",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSModuleDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSNamespaceExportDeclaration",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSNamespaceExportDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSNeverKeywordTypeAnnotation",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSNeverKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSNonNullExpression",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSNonNullExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSNullKeywordTypeAnnotation",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSNullKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSNumberKeywordTypeAnnotation",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSNumberKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSNumericLiteralTypeAnnotation",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSNumericLiteralTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSObjectKeywordTypeAnnotation",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSObjectKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSObjectTypeAnnotation",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSObjectTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSParenthesizedType",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSParenthesizedType_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSPropertySignature",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSPropertySignature_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSQualifiedName",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSQualifiedName_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSSignatureDeclarationMeta",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSSignatureDeclarationMeta_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSStringKeywordTypeAnnotation",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSStringKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSStringLiteralTypeAnnotation",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSStringLiteralTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSSymbolKeywordTypeAnnotation",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSSymbolKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSTemplateLiteralTypeAnnotation",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSTemplateLiteralTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSThisType",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSThisType_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSTupleElement",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSTupleElement_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSTupleType",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSTupleType_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSTypeAlias",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSTypeAlias_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSTypeAssertion",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSTypeAssertion_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSTypeOperator",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSTypeOperator_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSTypeParameter",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSTypeParameter_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSTypeParameterDeclaration",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSTypeParameterDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSTypeParameterInstantiation",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSTypeParameterInstantiation_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSTypePredicate",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSTypePredicate_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSTypeQuery",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSTypeQuery_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSTypeReference",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSTypeReference_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSUndefinedKeywordTypeAnnotation",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSUndefinedKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSUnionTypeAnnotation",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSUnionTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSUnknownKeywordTypeAnnotation",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSUnknownKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$formatter$builders$index_ts$builders.set(
		"TSVoidKeywordTypeAnnotation",
		___R$project$rome$$internal$formatter$builders$js$typescript$TSVoidKeywordTypeAnnotation_ts$default,
	);
	/* GENERATED:END(id:main) */


  // project-rome/@internal/formatter/tokens.ts
const ___R$project$rome$$internal$formatter$tokens_ts = {
		get lineOrSpace() {
			return ___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace;
		},
		get softline() {
			return ___R$project$rome$$internal$formatter$tokens_ts$softline;
		},
		get hardline() {
			return ___R$project$rome$$internal$formatter$tokens_ts$hardline;
		},
		get space() {
			return ___R$project$rome$$internal$formatter$tokens_ts$space;
		},
		group: ___R$project$rome$$internal$formatter$tokens_ts$group,
		comment: ___R$project$rome$$internal$formatter$tokens_ts$comment,
		indent: ___R$project$rome$$internal$formatter$tokens_ts$indent,
		mark: ___R$project$rome$$internal$formatter$tokens_ts$mark,
		concat: ___R$project$rome$$internal$formatter$tokens_ts$concat,
		ifBreak: ___R$project$rome$$internal$formatter$tokens_ts$ifBreak,
		join: ___R$project$rome$$internal$formatter$tokens_ts$join,
		lineSuffix: ___R$project$rome$$internal$formatter$tokens_ts$lineSuffix,
	};
	const ___R$project$rome$$internal$formatter$tokens_ts$lineOrSpace = {
		type: "Line",
		mode: "space",
	};

	const ___R$project$rome$$internal$formatter$tokens_ts$softline = {
		type: "Line",
		mode: "soft",
	};

	const ___R$project$rome$$internal$formatter$tokens_ts$hardline = {
		type: "Line",
		mode: "hard",
	};

	const ___R$project$rome$$internal$formatter$tokens_ts$space = {
		type: "Space",
	};

	function ___R$project$rome$$internal$formatter$tokens_ts$group(
		contents,
		shouldBreak = false,
	) {
		return {
			type: "Group",
			contents,
			shouldBreak,
		};
	}

	function ___R$project$rome$$internal$formatter$tokens_ts$comment(value) {
		return {
			type: "Comment",
			value,
		};
	}

	function ___R$project$rome$$internal$formatter$tokens_ts$indent(
		contents,
		force = false,
	) {
		if (contents === "") {
			return "";
		}
		if (force) {
			contents = ___R$project$rome$$internal$formatter$tokens_ts$concat([
				___R$project$rome$$internal$formatter$tokens_ts$hardline,
				contents,
			]);
		}
		return {
			type: "Indent",
			contents,
		};
	}

	function ___R$project$rome$$internal$formatter$tokens_ts$mark(loc, prop) {
		return {
			type: "PositionMarker",
			loc,
			prop,
		};
	}

	function ___R$project$rome$$internal$formatter$tokens_ts$concat(parts) {
		if (parts.length === 0) {
			return "";
		}

		if (parts.length === 1) {
			return parts[0];
		}

		return {
			type: "Concat",
			parts,
		};
	}

	function ___R$project$rome$$internal$formatter$tokens_ts$ifBreak(
		breakContents,
		flatContents,
	) {
		return {
			type: "IfBreak",
			breakContents,
			flatContents,
		};
	}

	function ___R$project$rome$$internal$formatter$tokens_ts$join(
		separator,
		tokens,
	) {
		if (tokens.length === 0) {
			return "";
		}

		if (tokens.length === 1) {
			return tokens[0];
		}

		const parts = [];

		for (let i = 0; i < tokens.length; i++) {
			if (i > 0) {
				parts.push(separator);
			}
			parts.push(tokens[i]);
		}

		return ___R$project$rome$$internal$formatter$tokens_ts$concat(parts);
	}

	function ___R$project$rome$$internal$formatter$tokens_ts$lineSuffix(contents) {
		return {
			type: "LineSuffix",
			contents,
		};
	}


  // project-rome/@internal/formatter/Builder.ts
class ___R$project$rome$$internal$formatter$Builder_ts$default {
		constructor(opts, comments = []) {
			this.options = opts;
			this.comments = new ___R$project$rome$$internal$js$parser$CommentsConsumer_ts$default(
				comments,
			);
			this.printedComments = new Set();
			this.printStack = [];
			this.language = undefined;
		}

		getLanguage() {
			const {language} = this;
			if (language === undefined) {
				throw new Error(
					"This operation needs to know the root language but none was found",
				);
			}
			return language;
		}

		tokenize(node, parent) {
			if (node === undefined) {
				return "";
			}

			if (
				!this.options.typeAnnotations &&
				___R$project$rome$$internal$js$ast$utils$isTypeNode_ts$isTypeNode(node) &&
				!___R$project$rome$$internal$js$ast$utils$isTypeExpressionWrapperNode_ts$isTypeExpressionWrapperNode(
					node,
				)
			) {
				return "";
			}

			const tokenizeNode = ___R$project$rome$$internal$formatter$builders$index_ts$default.assert(
				node.type,
			);
			if (tokenizeNode === undefined) {
				throw new Error(
					"No known builder for node " +
					node.type +
					" with parent " +
					parent.type,
				);
			}

			const oldRootType = this.language;
			let changedRootType = false;

			if (___R$project$rome$$internal$ast$utils$isRoot_ts$isRoot(node)) {
				changedRootType = true;
				this.language = ___R$project$rome$$internal$cli$diagnostics$utils_ts$inferDiagnosticLanguageFromRootAST(
					node,
				);
			}
			this.printStack.push(node);

			let tokens = [];

			// Print leading comments
			const leadingComments = this.getComments("leadingComments", node);
			if (leadingComments !== undefined) {
				let next = node;

				// Leading comments are traversed backward in order to get `next` right
				for (let i = leadingComments.length - 1; i >= 0; i--) {
					const comment = leadingComments[i];
					this.printedComments.add(comment.id);
					tokens.unshift(
						___R$project$rome$$internal$formatter$builders$comments_ts$tokenizeLeadingComment(
							comment,
							next,
							this.getLanguage(),
						),
					);
					next = comment;
				}
			}

			// Print node itself
			let printedNode = tokenizeNode(this, node, parent);

			const needsParens = ___R$project$rome$$internal$formatter$node$index_ts.needsParens(
				node,
				parent,
				this.printStack,
			);

			this.printStack.pop();

			if (printedNode !== "") {
				if (this.options.sourceMaps && node.loc !== undefined) {
					printedNode = ___R$project$rome$$internal$formatter$tokens_ts$concat([
						___R$project$rome$$internal$formatter$tokens_ts$mark(
							node.loc,
							"start",
						),
						printedNode,
						___R$project$rome$$internal$formatter$tokens_ts$mark(
							node.loc,
							"end",
						),
					]);
				}

				if (needsParens) {
					printedNode = ___R$project$rome$$internal$formatter$tokens_ts$concat([
						"(",
						printedNode,
						")",
					]);
				}
			}

			tokens.push(printedNode);

			// Print trailing comments
			const trailingComments = this.getComments("trailingComments", node);
			if (trailingComments !== undefined) {
				let previous = node;

				for (const comment of trailingComments) {
					this.printedComments.add(comment.id);
					tokens.push(
						___R$project$rome$$internal$formatter$builders$comments_ts$tokenizeTrailingComment(
							comment,
							previous,
							this.getLanguage(),
						),
					);
					previous = comment;
				}
			}

			if (changedRootType) {
				this.language = oldRootType;
			}

			return ___R$project$rome$$internal$formatter$tokens_ts$concat(tokens);
		}

		tokenizeStatementList(nodes, parent) {
			if (nodes.length === 0) {
				return "";
			}

			const tokens = [];

			for (let i = 0; i < nodes.length; i++) {
				const isLast = i === nodes.length - 1;
				const node = nodes[i];

				if (node.type === "JSEmptyStatement") {
					continue;
				}

				let printed = this.tokenize(node, parent);
				if (printed === "") {
					continue;
				}

				if (!isLast) {
					const nextNode = nodes[i + 1];

					if (this.getLinesBetween(node, nextNode) > 1) {
						printed = ___R$project$rome$$internal$formatter$tokens_ts$concat([
							printed,
							___R$project$rome$$internal$formatter$tokens_ts$hardline,
						]);
					}
				}

				tokens.push(printed);
			}

			return ___R$project$rome$$internal$formatter$tokens_ts$join(
				___R$project$rome$$internal$formatter$tokens_ts$hardline,
				tokens,
			);
		}

		tokenizeInnerComments(node, shouldIndent) {
			const innerComments = this.getComments("innerComments", node);
			if (innerComments === undefined) {
				return "";
			}

			const tokens = [];

			for (const comment of innerComments) {
				this.printedComments.add(comment.id);
				tokens.push(
					___R$project$rome$$internal$formatter$builders$comments_ts$tokenizeComment(
						comment,
						this.getLanguage(),
					),
				);
			}

			return shouldIndent
				? ___R$project$rome$$internal$formatter$tokens_ts$indent(
						___R$project$rome$$internal$formatter$tokens_ts$join(
							___R$project$rome$$internal$formatter$tokens_ts$hardline,
							tokens,
						),
						true,
					)
				: ___R$project$rome$$internal$formatter$tokens_ts$join(
						___R$project$rome$$internal$formatter$tokens_ts$hardline,
						tokens,
					);
		}

		getComments(kind, node, all = false) {
			if (!node) {
				return undefined;
			}

			const ids = node[kind];
			if (ids === undefined) {
				return undefined;
			}

			const comments = this.comments.getCommentsFromIds(ids);

			if (all) {
				return comments;
			} else {
				return comments.filter((comment) =>
					!this.printedComments.has(comment.id)
				);
			}
		}

		getLinesBetween(a, b) {
			if (a.loc === undefined || b.loc === undefined) {
				return 0;
			}

			let aEndLine = ___R$project$rome$$internal$ob1$index_ts$ob1Get1(
				a.loc.end.line,
			);
			let bStartLine = ___R$project$rome$$internal$ob1$index_ts$ob1Get1(
				b.loc.start.line,
			);

			// Simple cases:
			//  1. `a` and `b` are on the same line
			//  2. `a` and `b` are on their own line without empty lines between them
			if (bStartLine - aEndLine <= 1) {
				return bStartLine - aEndLine;
			}

			// If the are more than one line between `a` and `b`, the comment nodes must
			// be inspected to detect empty lines.
			//
			// In the following example, `getLinesBetween` should return `1`.
			//
			//     a;
			//     /* COMMENT */
			//     b;

			const aTrailingComments = this.getComments("trailingComments", a, true);
			const bLeadingComments = this.getComments("leadingComments", b, true);

			// Comments must be deduplicated because they are shared between nodes.
			// Walk them in order to calculate the nodes' boundaries.
			if (aTrailingComments !== undefined || bLeadingComments !== undefined) {
				const seenComments = new Set();

				// Expand `a` boundaries
				if (aTrailingComments !== undefined) {
					for (const comment of aTrailingComments) {
						seenComments.add(comment);

						if (comment.loc !== undefined) {
							aEndLine = Math.max(
								aEndLine,
								___R$project$rome$$internal$ob1$index_ts$ob1Get1(
									comment.loc.end.line,
								),
							);
						}
					}
				}

				// Expand `b` boundaries
				if (bLeadingComments !== undefined) {
					for (const comment of bLeadingComments) {
						if (seenComments.has(comment)) {
							continue;
						}

						if (comment.loc !== undefined) {
							bStartLine = Math.min(
								bStartLine,
								___R$project$rome$$internal$ob1$index_ts$ob1Get1(
									comment.loc.start.line,
								),
							);
						}
					}
				}
			}

			return bStartLine - aEndLine;
		}
	}


  // project-rome/@internal/formatter/Printer.ts
class ___R$$priv$project$rome$$internal$formatter$Printer_ts$BreakError
		extends Error {
		constructor() {
			super(
				"This error represents a point in the formatter where we should line break. If you're seeing this something went wrong.",
			);
		}
	}

	class ___R$$priv$project$rome$$internal$formatter$Printer_ts$Box {
		constructor(value) {
			this.value = value;
		}
	}

	function ___R$$priv$project$rome$$internal$formatter$Printer_ts$forkState(
		parent,
		callback,
	) {
		const bufferLength = parent.buffer.length;
		const mappingsLength = parent.mappings.length;

		const state = Object.assign(
			{},
			parent,
			{
				generatedIndex: new ___R$$priv$project$rome$$internal$formatter$Printer_ts$Box(
					parent.generatedIndex.value,
				),
				generatedLine: new ___R$$priv$project$rome$$internal$formatter$Printer_ts$Box(
					parent.generatedLine.value,
				),
				generatedColumn: new ___R$$priv$project$rome$$internal$formatter$Printer_ts$Box(
					parent.generatedColumn.value,
				),
				pendingSpaces: new ___R$$priv$project$rome$$internal$formatter$Printer_ts$Box(
					parent.pendingSpaces.value,
				),
				pendingTabs: new ___R$$priv$project$rome$$internal$formatter$Printer_ts$Box(
					parent.pendingTabs.value,
				),
				lineWidth: new ___R$$priv$project$rome$$internal$formatter$Printer_ts$Box(
					parent.lineWidth.value,
				),
			},
		);

		try {
			callback(state);
		} catch (err) {
			// Discard dirty outputs
			if (parent.buffer.length !== bufferLength) {
				parent.buffer.length = bufferLength;
			}

			// Discard dirty mappings
			if (parent.mappings.length !== mappingsLength) {
				parent.mappings.length = mappingsLength;
			}

			throw err;
		}

		// Merge the states together
		parent.generatedIndex.value = state.generatedIndex.value;
		parent.generatedLine.value = state.generatedLine.value;
		parent.generatedColumn.value = state.generatedColumn.value;
		parent.pendingSpaces.value = state.pendingSpaces.value;
		parent.pendingTabs.value = state.pendingTabs.value;
		parent.lineWidth.value = state.lineWidth.value;
	}

	function ___R$$priv$project$rome$$internal$formatter$Printer_ts$write(
		str,
		state,
		options,
	) {
		for (const ch of str) {
			state.generatedIndex.value = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(
				state.generatedIndex.value,
			);
			if (ch === "\n") {
				state.generatedLine.value = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(
					state.generatedLine.value,
				);
				state.generatedColumn.value = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;
				state.lineWidth.value = 0;
			} else {
				state.generatedColumn.value = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(
					state.generatedColumn.value,
				);
				if (ch === "\t") {
					state.lineWidth.value += options.tabWidth;
				} else {
					state.lineWidth.value++;
				}
			}
		}
		state.buffer.push(str);
	}

	function ___R$$priv$project$rome$$internal$formatter$Printer_ts$print(
		token,
		state,
		options,
	) {
		const stack = [[token, state]];

		while (stack.length > 0) {
			const [token, state] = stack.pop();

			if (typeof token === "string") {
				if (token !== "") {
					// Print pending tabs
					if (state.pendingTabs.value > 0) {
						___R$$priv$project$rome$$internal$formatter$Printer_ts$write(
							"\t".repeat(state.pendingTabs.value),
							state,
							options,
						);
						state.pendingTabs.value = 0;
					}

					// Print pending spaces
					if (state.pendingSpaces.value > 0) {
						___R$$priv$project$rome$$internal$formatter$Printer_ts$write(
							" ".repeat(state.pendingSpaces.value),
							state,
							options,
						);
						state.pendingSpaces.value = 0;
					}

					let currentLine = state.generatedLine.value;

					___R$$priv$project$rome$$internal$formatter$Printer_ts$write(
						token,
						state,
						options,
					);

					if (state.flat) {
						// If the line is too long, break the group
						if (state.lineWidth.value > options.printWidth) {
							throw new ___R$$priv$project$rome$$internal$formatter$Printer_ts$BreakError();
						}

						// If a new line was printed, break the group
						if (currentLine !== state.generatedLine.value) {
							throw new ___R$$priv$project$rome$$internal$formatter$Printer_ts$BreakError();
						}
					}
				}
			} else {
				switch (token.type) {
					case "Comment": {
						stack.push([token.value, state]);
						break;
					}

					case "Concat": {
						for (let i = token.parts.length - 1; i >= 0; i--) {
							stack.push([token.parts[i], state]);
						}
						break;
					}

					case "Group": {
						if (token.shouldBreak) {
							if (state.flat) {
								throw new ___R$$priv$project$rome$$internal$formatter$Printer_ts$BreakError();
							} else {
								stack.push([token.contents, state]);
								break;
							}
						}

						if (state.flat) {
							stack.push([token.contents, state]);
						} else {
							try {
								___R$$priv$project$rome$$internal$formatter$Printer_ts$forkState(
									state,
									(next) => {
										// Try to print the group contents on a single line.
										// If it fails, break the group.
										next.flat = true;
										___R$$priv$project$rome$$internal$formatter$Printer_ts$print(
											token.contents,
											next,
											options,
										);
									},
								);
							} catch (err) {
								if (
									err instanceof
									___R$$priv$project$rome$$internal$formatter$Printer_ts$BreakError
								) {
									stack.push([token.contents, state]);
								} else {
									// This should not happen!
									// Let the error propagate.
									throw err;
								}
							}
						}
						break;
					}

					case "IfBreak": {
						if (state.flat) {
							if (token.flatContents) {
								stack.push([token.flatContents, state]);
							}
						} else {
							stack.push([token.breakContents, state]);
						}
						break;
					}

					case "Indent": {
						stack.push([
							token.contents,
							Object.assign(
								{},
								state,
								{
									indent: new ___R$$priv$project$rome$$internal$formatter$Printer_ts$Box(
										state.indent.value + 1,
									),
								},
							),
						]);
						break;
					}

					case "Line": {
						if (state.flat) {
							switch (token.mode) {
								case "space": {
									state.pendingSpaces.value++;
									break;
								}

								case "soft":
									// Soft lines are not printed in flat mode.
									break;

								case "hard":
									// Hard lines are always printed.
									// In flat mode, the current group be broken.
									throw new ___R$$priv$project$rome$$internal$formatter$Printer_ts$BreakError();
							}
						} else {
							if (state.lineSuffixes.length > 0) {
								stack.push([token, state]);
								while (state.lineSuffixes.length > 0) {
									stack.push(state.lineSuffixes.pop());
								}
							} else {
								___R$$priv$project$rome$$internal$formatter$Printer_ts$write(
									"\n",
									state,
									options,
								);

								// Enqueue the indentation
								state.pendingSpaces.value = 0;
								state.pendingTabs.value = state.indent.value;
							}
						}
						break;
					}

					case "LineSuffix": {
						if (state.flat) {
							throw new ___R$$priv$project$rome$$internal$formatter$Printer_ts$BreakError();
						} else {
							state.lineSuffixes.push([token.contents, state]);
						}
						break;
					}

					case "PositionMarker": {
						if (
							state.mappings.length > 0 &&
							state.mappings[state.mappings.length - 1].generated.index ===
							state.generatedIndex.value
						) {
							break;
						}

						state.mappings.push({
							generated: {
								line: state.generatedLine.value,
								column: state.generatedColumn.value,
								index: state.generatedIndex.value,
							},
							original: {
								line: token.loc[token.prop].line,
								column: token.loc[token.prop].column,
							},
							name: token.loc.identifierName,
							source: token.loc.filename,
						});
						break;
					}

					case "Space": {
						state.pendingSpaces.value++;
						break;
					}
				}
			}
		}
	}

	function ___R$project$rome$$internal$formatter$Printer_ts$printTokenToString(
		token,
		options,
	) {
		const state = {
			flat: false,
			indent: new ___R$$priv$project$rome$$internal$formatter$Printer_ts$Box(
				options.rootIndent,
			),
			pendingSpaces: new ___R$$priv$project$rome$$internal$formatter$Printer_ts$Box(
				0,
			),
			pendingTabs: new ___R$$priv$project$rome$$internal$formatter$Printer_ts$Box(
				0,
			),
			generatedIndex: new ___R$$priv$project$rome$$internal$formatter$Printer_ts$Box(
				___R$project$rome$$internal$ob1$index_ts$ob1Number0,
			),
			generatedLine: new ___R$$priv$project$rome$$internal$formatter$Printer_ts$Box(
				___R$project$rome$$internal$ob1$index_ts$ob1Number1,
			),
			generatedColumn: new ___R$$priv$project$rome$$internal$formatter$Printer_ts$Box(
				___R$project$rome$$internal$ob1$index_ts$ob1Number0,
			),
			buffer: [],
			mappings: [],
			lineSuffixes: [],
			lineWidth: new ___R$$priv$project$rome$$internal$formatter$Printer_ts$Box(
				0,
			),
		};

		___R$$priv$project$rome$$internal$formatter$Printer_ts$print(
			token,
			state,
			options,
		);

		return {
			code: state.buffer.join(""),
			mappings: state.mappings,
		};
	}


  // project-rome/@internal/formatter/index.ts
function ___R$project$rome$$internal$formatter$index_ts$formatAST(
		ast,
		{
			format = "pretty",
			typeAnnotations = true,
			sourceMaps = false,
			indent = 0,
			allowInterpreterDirective = true,
		} = {},
	) {
		const builder = new ___R$project$rome$$internal$formatter$Builder_ts$default(
			{
				format,
				sourceMaps,
				typeAnnotations,
				allowInterpreterDirective,
			},
			___R$project$rome$$internal$ast$utils$isRoot_ts$isRoot(ast)
				? ast.comments
				: [],
		);
		const token = builder.tokenize(
			ast,
			___R$project$rome$$internal$ast$common$core$MockParent_ts$MOCK_PARENT,
		);
		const formatted = ___R$project$rome$$internal$formatter$Printer_ts$printTokenToString(
			token,
			{
				printWidth: format === "pretty" ? 80 : Infinity,
				rootIndent: indent,
				tabWidth: 2,
			},
		);

		return formatted;
	}


  // project-rome/@internal/compiler/lib/Path.ts
// Given a signal, calculate what the formatted code would be
	function ___R$$priv$project$rome$$internal$compiler$lib$Path_ts$getFormattedCodeFromSignal(
		signal,
		path,
	) {
		switch (signal.type) {
			case "REMOVE":
				return "";

			case "REPLACE": {
				const {value} = signal;
				if (Array.isArray(value)) {
					return value.map((node) => {
						return ___R$project$rome$$internal$formatter$index_ts$formatAST(
							node,
						).code;
					}).filter((str) => str !== "").join("\n");
				} else {
					return ___R$project$rome$$internal$formatter$index_ts$formatAST(value).code;
				}
			}

			case "PARENT": {
				for (const possiblePath of path.ancestryPaths) {
					if (possiblePath.node === signal.parent) {
						return ___R$$priv$project$rome$$internal$compiler$lib$Path_ts$getFormattedCodeFromSignal(
							signal.signal,
							path,
						);
					}
				}

				// Will later be an error in reduce since this parent was not found
				return "";
			}

			case "RETAIN":
				return ___R$$priv$project$rome$$internal$compiler$lib$Path_ts$getFormattedCodeFromSignal(
					___R$project$rome$$internal$compiler$index_ts$signals.replace(
						path.node,
					),
					path,
				);
		}
	}

	class ___R$project$rome$$internal$compiler$lib$Path_ts$default {
		constructor(node, context, opts, token) {
			const ancestryPaths = opts.ancestryPaths || [];
			this.ancestryPaths = ancestryPaths;

			if (
				node ===
				___R$project$rome$$internal$ast$common$core$MockParent_ts$MOCK_PARENT
			) {
				this.parentPath = this;
			} else if (ancestryPaths.length === 0) {
				this.parentPath = new ___R$project$rome$$internal$compiler$lib$Path_ts$default(
					___R$project$rome$$internal$ast$common$core$MockParent_ts$MOCK_PARENT,
					context,
					{
						isMock: true,
					},
				);
			} else {
				this.parentPath = ancestryPaths[0];
			}

			this.node = node;
			this.parent = this.parentPath.node;
			this.context = context;

			const parentScope =
				opts.parentScope === undefined ||
				___R$project$rome$$internal$ast$utils$isRoot_ts$isRoot(node)
					? context.rootScope
					: opts.parentScope;

			let scope = opts.scope;
			if (scope === undefined) {
				if (opts.noScopeCreation === true) {
					scope = parentScope;
				} else {
					scope = parentScope.enterEvaluate(node, this.parent);
				}
			}
			this.scope = scope;

			this.nodeKey = opts.nodeKey;
			this.listKey = opts.listKey;

			this.isMock = opts.isMock === true;
			this.opts = opts;
			this.token = token == null ? {type: "PATH_TOKEN"} : token;
		}

		findAncestry(callback) {
			for (const path of this.ancestryPaths) {
				if (callback(path)) {
					return path;
				}
			}
			return undefined;
		}

		getChildPath(key) {
			// rome-ignore lint/ts/noExplicitAny: future cleanup
			const node = (this.node)[key];
			if (node === undefined) {
				throw new Error(
					"Attempted to get child path for " + key + " but no such node existed",
				);
			}

			return new ___R$project$rome$$internal$compiler$lib$Path_ts$default(
				node,
				this.context,
				{
					parentScope: this.scope,
					ancestryPaths: this.ancestryPaths.concat([this]),
					nodeKey: key,
				},
			);
		}

		getChildPaths(key) {
			// rome-ignore lint/ts/noExplicitAny: future cleanup
			const nodes = (this.node)[key];

			if (nodes === undefined) {
				throw new Error(
					"Attempted to get child paths for " +
					key +
					" but no such node existed",
				);
			}

			if (!Array.isArray(nodes)) {
				throw new Error("Expected child nodes for " + key + " to be an array");
			}

			const ancestryPaths = this.ancestryPaths.concat([this]);

			return nodes.map((node, i) => {
				return new ___R$project$rome$$internal$compiler$lib$Path_ts$default(
					node,
					this.context,
					{
						parentScope: this.scope,
						ancestryPaths,
						listKey: i,
						nodeKey: key,
					},
				);
			});
		}

		getPathKeys() {
			const parts = [];

			let path = this;
			while (path !== undefined && !path.isMock) {
				if (path.listKey !== undefined) {
					parts.push(String(path.listKey));
				}
				if (path.nodeKey !== undefined) {
					parts.push(path.nodeKey);
				}
				path = path.parentPath;
			}

			return parts.reverse();
		}

		fork(newNode) {
			return new ___R$project$rome$$internal$compiler$lib$Path_ts$default(
				newNode,
				this.context,
				this.getPathOptions(),
				this.token,
			);
		}

		getPathOptions() {
			return Object.assign(
				{},
				this.opts,
				{
					parentScope: this.scope === undefined
						? undefined
						: this.scope.parentScope,
				},
			);
		}

		traverse(name, callback) {
			this.reduceNode({
				name,
				enter(path) {
					callback(path);
					return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
				},
			});
		}

		reduceNode(visitors, opts) {
			return ___R$project$rome$$internal$compiler$methods$reduce_ts$reduceNode(
				this.node,
				visitors,
				this.context,
				Object.assign({}, this.getPathOptions(), opts),
			);
		}

		reduceSignal(visitors, opts) {
			return ___R$project$rome$$internal$compiler$methods$reduce_ts$reduceSignal(
				this.node,
				visitors,
				this.context,
				Object.assign({}, this.getPathOptions(), opts),
			);
		}

		addFixableDiagnostic(nodes, description, diag = {}) {
			const old = this.node;
			const {context} = this;
			const {fixed: defaultFixed, suggestions} = nodes;
			const target = nodes.target == null ? old : nodes.target;

			const {category} = description;
			const advice = [...description.advice];
			const loc = context.getLoc(target);

			let fixed = defaultFixed;

			if (nodes.target !== undefined) {
				// NB: The diff is going to refer to the old but diagnostic will be pointing to a different
				// location. Probably ok since you can mentally infer from context but we could add a log if it's
				// confusing.
			}

			// Add recommended fix
			if (defaultFixed !== undefined) {
				advice.push({
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Safe fix`,
				});

				advice.push({
					type: "diff",
					language: context.language,
					diff: ___R$project$rome$$internal$string$diff$index_ts$default(
						___R$$priv$project$rome$$internal$compiler$lib$Path_ts$getFormattedCodeFromSignal(
							___R$project$rome$$internal$compiler$index_ts$signals.replace(old),
							this,
						),
						___R$$priv$project$rome$$internal$compiler$lib$Path_ts$getFormattedCodeFromSignal(
							defaultFixed,
							this,
						),
					),
				});

				if (loc === undefined) {
					advice.push({
						type: "log",
						category: "error",
						text: ___R$project$rome$$internal$markup$escape_ts$markup`Unable to find target location`,
					});
				} else {
					advice.push(
						___R$project$rome$$internal$compiler$lint$decisions_ts$buildLintDecisionAdviceAction({
							filename: context.displayFilename,
							decision: ___R$project$rome$$internal$compiler$lint$decisions_ts$buildLintDecisionString({
								action: "fix",
								filename: context.displayFilename,
								category,
								start: loc.start,
							}),
							shortcut: "f",
							noun: ___R$project$rome$$internal$markup$escape_ts$markup`Apply fix`,
							instruction: ___R$project$rome$$internal$markup$escape_ts$markup`To apply this fix run`,
						}),
					);

					advice.push(
						___R$project$rome$$internal$compiler$lint$decisions_ts$buildLintDecisionAdviceAction({
							extra: true,
							noun: ___R$project$rome$$internal$markup$escape_ts$markup`Apply fix for ALL files with this category`,
							instruction: ___R$project$rome$$internal$markup$escape_ts$markup`To apply fix for ALL files with this category run`,
							decision: ___R$project$rome$$internal$compiler$lint$decisions_ts$buildLintDecisionGlobalString(
								"fix",
								category,
							),
						}),
					);
				}
			}

			if (suggestions !== undefined) {
				// If we have lint decisions then find the fix that corresponds with this suggestion
				if (context.hasLintDecisions()) {
					const decisions = context.getLintDecisions(
						___R$project$rome$$internal$compiler$lint$decisions_ts$deriveDecisionPositionKey(
							"fix",
							loc,
						),
					);
					for (const decision of decisions) {
						if (
							decision.category === category &&
							decision.action === "fix" &&
							decision.id !== undefined
						) {
							const suggestion = suggestions[decision.id];
							if (suggestion !== undefined) {
								fixed = suggestion.fixed;
							}
						}
					}
				}

				// Add advice suggestions
				let index = 0;
				for (const suggestion of suggestions) {
					const num = index + 1;

					const titlePrefix =
						suggestions.length === 1 ? "Suggested fix" : "Suggested fix #" + num;
					advice.push({
						type: "log",
						category: "none",
						text: ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${titlePrefix}:</emphasis> ${suggestion.title}`,
					});

					advice.push({
						type: "diff",
						language: context.language,
						diff: ___R$project$rome$$internal$string$diff$index_ts$default(
							___R$$priv$project$rome$$internal$compiler$lib$Path_ts$getFormattedCodeFromSignal(
								___R$project$rome$$internal$compiler$index_ts$signals.replace(
									old,
								),
								this,
							),
							___R$$priv$project$rome$$internal$compiler$lib$Path_ts$getFormattedCodeFromSignal(
								suggestion.fixed,
								this,
							),
						),
					});

					advice.push({
						type: "log",
						category: "info",
						text: suggestion.description,
					});

					if (loc === undefined) {
						advice.push({
							type: "log",
							category: "error",
							text: ___R$project$rome$$internal$markup$escape_ts$markup`Unable to find target location`,
						});
					} else {
						advice.push(
							___R$project$rome$$internal$compiler$lint$decisions_ts$buildLintDecisionAdviceAction({
								noun: suggestions.length === 1
									? ___R$project$rome$$internal$markup$escape_ts$markup`Apply suggested fix`
									: ___R$project$rome$$internal$markup$escape_ts$markup`Apply suggested fix "${suggestion.title}"`,
								shortcut: String(num),
								instruction: ___R$project$rome$$internal$markup$escape_ts$markup`To apply this fix run`,
								filename: context.displayFilename,
								decision: ___R$project$rome$$internal$compiler$lint$decisions_ts$buildLintDecisionString({
									filename: context.displayFilename,
									action: "fix",
									category,
									start: loc.start,
									id: index,
								}),
							}),
						);
					}

					index++;
				}
			}

			const {suppressed} = context.addLocDiagnostic(
				loc,
				Object.assign({}, description, {advice}),
				Object.assign(
					{},
					diag,
					{tags: Object.assign({}, diag.tags, {fixable: true})},
				),
			);

			if (suppressed || fixed === undefined) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
					old,
				);
			}

			// Inherit old location if necessary
			if (fixed.type === "REPLACE") {
				let value = fixed.value;
				if (Array.isArray(value)) {
					// For arrays the first one gets the loc
					const [first, ...rest] = value;
					if (first.loc === undefined) {
						value = [
							Object.assign(
								{},
								first,
								{
									loc: ___R$project$rome$$internal$js$ast$utils$inheritLoc_ts$inheritLoc(
										old,
									),
								},
							),
							...rest,
						];
					}
				} else {
					value = Object.assign(
						{},
						value,
						{
							loc: ___R$project$rome$$internal$js$ast$utils$inheritLoc_ts$inheritLoc(
								old,
							),
						},
					);
				}
			}

			return fixed;
		}
	}


  // project-rome/@internal/compiler/lib/Record.ts
class ___R$project$rome$$internal$compiler$lib$Record_ts$default {}


  // project-rome/@internal/compiler/lib/Cache.ts
let ___R$$priv$project$rome$$internal$compiler$lib$Cache_ts$projectIdCounter = 0;
	const ___R$$priv$project$rome$$internal$compiler$lib$Cache_ts$projectToId = new WeakMap();

	class ___R$project$rome$$internal$compiler$lib$Cache_ts$default {
		constructor() {
			this.cache = new WeakMap();
		}

		static buildQuery(req, additionalOptions) {
			const {ast, project, options} = req;
			const keyParts = [];

			let projectId = ___R$$priv$project$rome$$internal$compiler$lib$Cache_ts$projectToId.get(
				project,
			);
			if (projectId === undefined) {
				projectId = ___R$$priv$project$rome$$internal$compiler$lib$Cache_ts$projectIdCounter++;
				___R$$priv$project$rome$$internal$compiler$lib$Cache_ts$projectToId.set(
					project,
					projectId,
				);
			}

			// Add project config cache counter
			keyParts.push(String(projectId));

			// Add options if they exist
			const extra = Object.assign({}, options, additionalOptions);
			if (Object.keys(extra).length > 0) {
				keyParts.push(JSON.stringify(extra));
			}

			return {
				ast,
				key: keyParts.join(";"),
			};
		}

		get(query) {
			const astCache = this.cache.get(query.ast);
			if (astCache) {
				return astCache.get(query.key);
			} else {
				return undefined;
			}
		}

		set(query, value) {
			let astCache = this.cache.get(query.ast);
			if (astCache === undefined) {
				astCache = new Map();
				this.cache.set(query.ast, astCache);
			}
			astCache.set(query.key, value);
		}
	}


  // project-rome/@internal/compiler/lint/suppressions.ts
function ___R$$priv$project$rome$$internal$compiler$lint$suppressions_ts$getStartLine(
		node,
	) {
		const {loc} = node;
		if (loc === undefined) {
			return undefined;
		} else {
			return loc.start.line;
		}
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$suppressions_ts$buildSuppressionCommentValue(
		categories,
		explanation = "suppressed via --review",
	) {
		return (
			___R$project$rome$$internal$compiler$suppressions_ts$SUPPRESSION_START +
			" " +
			Array.from(categories).join(" ") +
			": " +
			explanation
		);
	}

	function ___R$project$rome$$internal$compiler$lint$suppressions_ts$addSuppressions(
		context,
		ast,
		explanation,
	) {
		if (!context.hasLintDecisions()) {
			return ast;
		}

		const visitedLines = new Set();

		function addComment(path, node, decisions) {
			// Find all suppression decisions
			const suppressionCategories = new Set();
			for (const {category, action} of decisions) {
				if (action === "suppress") {
					suppressionCategories.add(category);
				}
			}
			if (suppressionCategories.size === 0) {
				return node;
			}

			// Find existing suppression comment
			let updateComment;
			const lastComment = context.comments.getCommentsFromIds(
				node.leadingComments,
			).pop();
			if (
				lastComment !== undefined &&
				lastComment.value.includes(
					___R$project$rome$$internal$compiler$suppressions_ts$SUPPRESSION_START,
				)
			) {
				updateComment = lastComment;
			}

			// Insert new comment if there's none to update
			if (updateComment === undefined) {
				const id = ___R$project$rome$$internal$compiler$transforms$helpers$index_ts$injectComment(
					path,
					{
						type: "CommentLine",
						value: " " +
						___R$$priv$project$rome$$internal$compiler$lint$suppressions_ts$buildSuppressionCommentValue(
							suppressionCategories,
							explanation,
						),
					},
				);

				return Object.assign(
					{},
					node,
					{leadingComments: [...(node.leadingComments || []), id]},
				);
			}

			// Remove all categories that are already included in the suppression
			for (const category of suppressionCategories) {
				if (updateComment.value.includes(category)) {
					suppressionCategories.delete(category);
				}
			}

			// We may have eliminated them all
			if (suppressionCategories.size > 0) {
				___R$project$rome$$internal$compiler$transforms$helpers$index_ts$injectComment(
					path,
					Object.assign(
						{},
						updateComment,
						{
							value: updateComment.value.replace(
								___R$project$rome$$internal$compiler$suppressions_ts$SUPPRESSION_START,
								___R$$priv$project$rome$$internal$compiler$lint$suppressions_ts$buildSuppressionCommentValue(
									suppressionCategories,
								),
							),
						},
					),
				);
			}

			return node;
		}

		// Find the best node to attach comments to. This is generally the node with the largest range per line.
		return context.reduceRoot(
			{
				name: "suppressionVisitor",
				enter(path) {
					const {node} = path;

					// Don't allow attaching suppression comments to a comment or program...
					if (
						node.type === "CommentBlock" ||
						node.type === "CommentLine" ||
						node.type === "JSRoot"
					) {
						return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
					}

					const line = ___R$$priv$project$rome$$internal$compiler$lint$suppressions_ts$getStartLine(
						node,
					);
					if (line === undefined || visitedLines.has(line)) {
						return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
					}

					const decisions = context.getLintDecisions(
						String(___R$project$rome$$internal$ob1$index_ts$ob1Get1(line)),
					);
					if (decisions.length === 0) {
						return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
					}

					visitedLines.add(line);
					return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
						addComment(path, node, decisions),
					);
				},
			},
			ast,
		);
	}


  // project-rome/@internal/compiler/lint/utils/constants.ts
const ___R$project$rome$$internal$compiler$lint$utils$constants_ts$VOID_DOM_ELEMENTS = new Set([
		"area",
		"base",
		"br",
		"col",
		"embed",
		"hr",
		"img",
		"input",
		"keygen",
		"link",
		"menuitem",
		"meta",
		"param",
		"source",
		"track",
		"wbr",
	]);


  // project-rome/@internal/compiler/lint/rules/html/useClosingNonVoid.ts
const ___R$project$rome$$internal$compiler$lint$rules$html$useClosingNonVoid_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "html/useClosingNonVoid",
		enter(path) {
			const {node} = path;

			if (
				node.type === "HTMLElement" &&
				node.selfClosing &&
				!___R$project$rome$$internal$compiler$lint$utils$constants_ts$VOID_DOM_ELEMENTS.has(
					node.name.name,
				)
			) {
				return path.addFixableDiagnostic(
					{
						fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
							Object.assign({}, node, {selfClosing: false}),
						),
					},
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.HTML_USE_CLOSING_NON_VOID,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noArguments.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$noArguments_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noArguments",
		enter(path) {
			const {node, scope} = path;

			if (node.type === "JSReferenceIdentifier" && node.name === "arguments") {
				const args = scope.getBinding("arguments");
				if (args && args.kind === "arguments") {
					path.context.addNodeDiagnostic(
						node,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_ARGUMENTS,
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noAsyncPromiseExecutor.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$noAsyncPromiseExecutor_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noAsyncPromiseExecutor",
		enter(path) {
			const {node, context} = path;

			if (
				node.type === "JSNewExpression" &&
				node.callee.type === "JSReferenceIdentifier" &&
				node.callee.name === "Promise" &&
				node.arguments.length > 0 &&
				(node.arguments[0].type === "JSArrowFunctionExpression" ||
				node.arguments[0].type === "JSFunctionExpression") &&
				node.arguments[0].head.async
			) {
				context.addNodeDiagnostic(
					node.arguments[0],
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_ASYNC_PROMISE_EXECUTOR,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noCatchAssign.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$noCatchAssign_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noCatchAssign",
		enter(path) {
			const {node, context, scope} = path;

			if (node.type === "JSAssignmentIdentifier") {
				const binding = scope.getBinding(node.name);

				if (binding !== undefined && binding.kind === "catch") {
					context.addNodeDiagnostic(
						node,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_CATCH_ASSIGN,
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noCommaOperator.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$noCommaOperator_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noCommaOperator",
		enter(path) {
			const {node} = path;

			if (node.type === "JSSequenceExpression") {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_COMMA_OPERATOR,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noCompareNegZero.ts
const ___R$$priv$project$rome$$internal$compiler$lint$rules$js$noCompareNegZero_ts$OPERATORS_TO_CHECK = [
		">",
		">=",
		"<",
		"<=",
		"==",
		"===",
		"!=",
		"!==",
	];

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$js$noCompareNegZero_ts$isNegZero(
		node,
	) {
		return (
			node.type === "JSUnaryExpression" &&
			node.operator === "-" &&
			node.argument.type === "JSNumericLiteral" &&
			node.argument.value === 0
		);
	}
	const ___R$project$rome$$internal$compiler$lint$rules$js$noCompareNegZero_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noCompareNegZero",
		enter(path) {
			const {node} = path;

			if (
				node.type === "JSBinaryExpression" &&
				___R$$priv$project$rome$$internal$compiler$lint$rules$js$noCompareNegZero_ts$OPERATORS_TO_CHECK.includes(
					node.operator,
				) &&
				(___R$$priv$project$rome$$internal$compiler$lint$rules$js$noCompareNegZero_ts$isNegZero(
					node.left,
				) ||
				___R$$priv$project$rome$$internal$compiler$lint$rules$js$noCompareNegZero_ts$isNegZero(
					node.right,
				))
			) {
				if (node.operator === "===") {
					return path.addFixableDiagnostic(
						{
							fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
								___R$project$rome$$internal$js$ast$utils$template_ts$template.expression`Object.is(${node.left}, ${node.right})`,
							),
						},
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_COMPARE_NEG_ZERO(
							node.operator,
						),
					);
				} else {
					path.context.addNodeDiagnostic(
						node,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_COMPARE_NEG_ZERO(
							node.operator,
						),
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noCondAssign.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$noCondAssign_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noCondAssign",
		enter(path) {
			const {node} = path;

			if (
				(node.type === "JSIfStatement" ||
				node.type === "JSForStatement" ||
				node.type === "JSWhileStatement" ||
				node.type === "JSDoWhileStatement" ||
				node.type === "JSConditionalExpression") &&
				node.test &&
				node.test.type === "JSAssignmentExpression"
			) {
				path.context.addNodeDiagnostic(
					node.test,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_COND_ASSIGN,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noDebugger.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$noDebugger_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noDebugger",
		enter(path) {
			const {node} = path;

			if (node.type === "JSDebuggerStatement") {
				return path.addFixableDiagnostic(
					{
						fixed: ___R$project$rome$$internal$compiler$index_ts$signals.remove,
					},
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_DEBUGGER,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noDelete.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$noDelete_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noDelete",
		enter(path) {
			const {node} = path;

			if (
				node.type === "JSUnaryExpression" &&
				node.operator === "delete" &&
				node.argument.type === "JSMemberExpression"
			) {
				const left = node.argument;
				return path.addFixableDiagnostic(
					{
						fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
							___R$project$rome$$internal$ast$js$expressions$JSAssignmentExpression_ts$jsAssignmentExpression.create(
								{
									operator: "=",
									left: ___R$project$rome$$internal$ast$js$expressions$JSMemberExpression_ts$jsMemberExpression.create({
										object: left.object,
										property: left.property,
									}),
									right: ___R$project$rome$$internal$ast$js$expressions$JSReferenceIdentifier_ts$jsReferenceIdentifier.create({
										name: "undefined",
									}),
								},
								node,
							),
						),
					},
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_DELETE,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noDeleteVars.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$noDeleteVars_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noDeleteVars",
		enter(path) {
			const {node} = path;

			if (
				node.type === "JSUnaryExpression" &&
				node.operator === "delete" &&
				node.argument.type === "JSReferenceIdentifier"
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_DELETE_VARS,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noDoubleEquals.ts
const ___R$$priv$project$rome$$internal$compiler$lint$rules$js$noDoubleEquals_ts$SUGGESTION_DESCRIPTION = ___R$project$rome$$internal$markup$escape_ts$markup`This may be unsafe if you are relying on type coercion`;
	const ___R$project$rome$$internal$compiler$lint$rules$js$noDoubleEquals_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noDoubleEquals",
		enter(path) {
			const {node} = path;

			if (
				node.type === "JSBinaryExpression" &&
				node.right.type !== "JSNullLiteral" &&
				node.left.type !== "JSNullLiteral"
			) {
				if (node.operator === "!=") {
					return path.addFixableDiagnostic(
						{
							suggestions: [
								{
									title: ___R$project$rome$$internal$markup$escape_ts$markup`Use !==`,
									description: ___R$$priv$project$rome$$internal$compiler$lint$rules$js$noDoubleEquals_ts$SUGGESTION_DESCRIPTION,
									fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
										Object.assign({}, node, {operator: "!=="}),
									),
								},
							],
						},
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NEGATE_DOUBLE_EQUALS,
					);
				}

				if (node.operator === "==") {
					return path.addFixableDiagnostic(
						{
							suggestions: [
								{
									title: ___R$project$rome$$internal$markup$escape_ts$markup`Use ===`,
									description: ___R$$priv$project$rome$$internal$compiler$lint$rules$js$noDoubleEquals_ts$SUGGESTION_DESCRIPTION,
									fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
										Object.assign({}, node, {operator: "==="}),
									),
								},
							],
						},
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_DOUBLE_EQUALS,
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noDupeArgs.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$noDupeArgs_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noDupeArgs",
		enter(path) {
			const {node, context} = path;

			if (node.type === "JSFunctionHead") {
				const uniqueIdentifiers = new Set();

				for (const param of node.params) {
					for (const {name} of ___R$project$rome$$internal$js$ast$utils$getBindingIdentifiers_ts$getBindingIdentifiers(
						param,
					)) {
						if (uniqueIdentifiers.has(name)) {
							context.addNodeDiagnostic(
								param,
								___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_DUPE_ARGS(
									name,
								),
							);
						}

						uniqueIdentifiers.add(name);
					}
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lib/DiagnosticsDuplicateHelper.ts
class ___R$project$rome$$internal$compiler$lib$DiagnosticsDuplicateHelper_ts$DiagnosticsDuplicateHelper {
		constructor(context, descriptionFactory) {
			this.context = context;
			this.category = descriptionFactory("").category;
			this.descriptionFactory = descriptionFactory;
			this.locations = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
				"locations",
				() => [],
			);
		}

		addLocation(key, location) {
			const isSuppressed = this.context.hasLocSuppression(
				location,
				this.category,
			);
			if (isSuppressed) {
				// If this location has had it's diagnostic suppressed then we don't want to return
				// that it was a duplicate even if there's multiple occurences
				return {duplicate: false};
			}

			let locations = this.locations.assert(key);
			locations.push(location);
			return {duplicate: locations.length > 1};
		}

		process() {
			for (const [key, locations] of this.locations) {
				if (locations.length <= 1) {
					continue;
				}

				const description = this.descriptionFactory(key);
				const firstLocation = locations[0];
				const restLocations = locations.slice(1);

				this.context.addLocDiagnostic(
					firstLocation,
					Object.assign(
						{},
						description,
						{
							advice: [
								...description.advice,
								...___R$project$rome$$internal$diagnostics$helpers_ts$buildDuplicateLocationAdvice(
									restLocations,
								),
							],
						},
					),
				);
			}
		}
	}


  // project-rome/@internal/compiler/lint/rules/js/noDuplicateCase.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$noDuplicateCase_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noDuplicateCase",
		enter(path) {
			const {node, context} = path;

			if (node.type === "JSSwitchStatement") {
				const duplicates = new ___R$project$rome$$internal$compiler$lib$DiagnosticsDuplicateHelper_ts$DiagnosticsDuplicateHelper(
					context,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_DUPLICATE_CASE,
				);

				for (const param of node.cases) {
					if (param.test === undefined) {
						continue;
					}

					const test = ___R$project$rome$$internal$js$ast$utils$resolveIndirection_ts$resolveIndirection(
						param.test,
						path.scope,
					);
					const res = ___R$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$tryStaticEvaluation(
						test.node,
						test.scope,
					);

					if (res.bailed && test.node.type === "JSReferenceIdentifier") {
						// We weren't able to resolve this variable further
						duplicates.addLocation(test.node.name, param.test.loc);
						continue;
					}

					// No idea what this could be
					if (res.bailed) {
						continue;
					}

					duplicates.addLocation(
						___R$project$rome$$internal$pretty$format$index_ts$prettyFormatToString(
							res.value,
						),
						param.test.loc,
					);
				}

				duplicates.process();
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noDuplicateImportSource.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$noDuplicateImportSource_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/duplicateImport",
		enter(path) {
			const {node} = path;

			if (node.type === "JSRoot") {
				const skipImports = new Set();
				const seenSources = new Map();
				let shouldFix = false;

				for (const bodyNode of node.body) {
					if (bodyNode.type === "JSImportDeclaration") {
						const source = bodyNode.source.value;

						// Allow duplicate sources if the `importKind` is different
						const sourceKey =
							bodyNode.importKind === undefined
								? source
								: bodyNode.importKind + ":" + source;

						const seenLoc = seenSources.get(sourceKey);
						if (seenLoc === undefined) {
							seenSources.set(sourceKey, bodyNode.loc);
						} else {
							const {suppressed} = path.context.addNodeDiagnostic(
								bodyNode,
								___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_DUPLICATE_IMPORT_SOURCE(
									seenLoc,
								),
								{tags: {fixable: true}},
							);

							if (suppressed) {
								skipImports.add(bodyNode);
							} else {
								shouldFix = true;
							}
						}
					}
				}

				// Defer fixing unless it's totally necessary since there's additional overhead
				if (shouldFix) {
					const newBody = [];

					for (let i = 0; i < node.body.length; i++) {
						const bodyNode = node.body[i];

						if (bodyNode.type === "JSImportDeclaration") {
							// Skip import if it's already been consumed
							if (skipImports.has(bodyNode)) {
								continue;
							}

							let {
								namedSpecifiers,
								defaultSpecifier,
								namespaceSpecifier,
							} = bodyNode;

							// Find and concat all duplicate imports
							for (let x = i + 1; x < node.body.length; x++) {
								const possibleDuplicateNode = node.body[x];

								if (
									possibleDuplicateNode.type === "JSImportDeclaration" &&
									bodyNode.source.value === possibleDuplicateNode.source.value &&
									bodyNode.importKind === possibleDuplicateNode.importKind &&
									!skipImports.has(possibleDuplicateNode)
								) {
									skipImports.add(possibleDuplicateNode);
									namedSpecifiers = [
										...namedSpecifiers,
										...possibleDuplicateNode.namedSpecifiers,
									];

									// We do not currently handle renaming duplicate namespace and default bindings
									if (defaultSpecifier === undefined) {
										defaultSpecifier = possibleDuplicateNode.defaultSpecifier;
									}
									if (namespaceSpecifier === undefined) {
										namespaceSpecifier = possibleDuplicateNode.namespaceSpecifier;
									}
								}
							}

							newBody.push(
								Object.assign(
									{},
									bodyNode,
									{defaultSpecifier, namespaceSpecifier, namedSpecifiers},
								),
							);
						} else {
							newBody.push(bodyNode);
						}
					}

					return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
						Object.assign({}, node, {body: newBody}),
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noDuplicateKeys.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$js$noDuplicateKeys_ts$extractPropertyKey(
		node,
	) {
		if (node.key.type === "JSStaticPropertyKey") {
			const {value} = node.key;

			if (value.type === "JSPrivateName") {
				return value.id.name;
			}

			if (value.type === "JSIdentifier") {
				return value.name;
			}

			return String(value.value);
		}

		return undefined;
	}
	const ___R$project$rome$$internal$compiler$lint$rules$js$noDuplicateKeys_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noDuplicateKeys",
		enter(path) {
			const {node, context} = path;

			if (node.type === "JSObjectExpression") {
				const duplicates = new ___R$project$rome$$internal$compiler$lib$DiagnosticsDuplicateHelper_ts$DiagnosticsDuplicateHelper(
					context,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_DUPLICATE_KEYS,
				);

				for (const prop of node.properties) {
					if (prop.type === "JSSpreadProperty") {
						continue;
					}

					const key = ___R$$priv$project$rome$$internal$compiler$lint$rules$js$noDuplicateKeys_ts$extractPropertyKey(
						prop,
					);
					if (key !== undefined) {
						duplicates.addLocation(key, prop.key.loc);
					}
				}

				duplicates.process();
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noEmptyBlocks.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$js$noEmptyBlocks_ts$isEmpty(
		node,
	) {
		if (node.innerComments !== undefined && node.innerComments.length > 0) {
			return false;
		}

		if (node.type === "JSEmptyStatement") {
			return true;
		}

		if (node.type === "JSBlockStatement" && node.body.length === 0) {
			return true;
		}

		return false;
	}
	const ___R$project$rome$$internal$compiler$lint$rules$js$noEmptyBlocks_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noEmptyBlocks",
		enter(path) {
			const {node, context} = path;

			if (node.type === "JSIfStatement") {
				if (
					___R$$priv$project$rome$$internal$compiler$lint$rules$js$noEmptyBlocks_ts$isEmpty(
						node.consequent,
					)
				) {
					context.addNodeDiagnostic(
						node.consequent,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_EMPTY_BLOCKS,
					);
				}

				if (
					node.alternate !== undefined &&
					___R$$priv$project$rome$$internal$compiler$lint$rules$js$noEmptyBlocks_ts$isEmpty(
						node.alternate,
					)
				) {
					context.addNodeDiagnostic(
						node.alternate,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_EMPTY_BLOCKS,
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noExtraBooleanCast.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$js$noExtraBooleanCast_ts$isBooleanConstructorCall(
		node,
	) {
		return (
			node.type === "JSNewExpression" &&
			node.callee.type === "JSReferenceIdentifier" &&
			node.callee.name === "Boolean"
		);
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$js$noExtraBooleanCast_ts$isConditionalStatement(
		node,
	) {
		return node.type === "JSConditionalExpression";
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$js$noExtraBooleanCast_ts$isInBooleanContext(
		node,
	) {
		return (
			node.type === "JSIfStatement" ||
			node.type === "JSDoWhileStatement" ||
			node.type === "JSWhileStatement" ||
			node.type === "JSForStatement"
		);
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$js$noExtraBooleanCast_ts$getNode(
		path,
	) {
		let {node} = path;

		if (
			___R$$priv$project$rome$$internal$compiler$lint$rules$js$noExtraBooleanCast_ts$isBooleanConstructorCall(
				node,
			)
		) {
			if (node.type === "JSNewExpression" && node.arguments.length > 0) {
				return node.arguments[0];
			}
		}

		if (
			___R$$priv$project$rome$$internal$compiler$lint$rules$js$noExtraBooleanCast_ts$isInBooleanContext(
				node,
			) ||
			___R$$priv$project$rome$$internal$compiler$lint$rules$js$noExtraBooleanCast_ts$isConditionalStatement(
				node,
			)
		) {
			return node.test;
		}

		return undefined;
	}
	const ___R$project$rome$$internal$compiler$lint$rules$js$noExtraBooleanCast_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noExtraBooleanCast",
		enter(path) {
			const {context} = path;

			let node = ___R$$priv$project$rome$$internal$compiler$lint$rules$js$noExtraBooleanCast_ts$getNode(
				path,
			);

			if (node !== undefined) {
				if (
					(node.type === "JSUnaryExpression" &&
					node.operator === "!" &&
					node.argument.type === "JSUnaryExpression" &&
					node.argument.operator === "!") ||
					(node.type === "JSCallExpression" &&
					node.callee.type === "JSReferenceIdentifier" &&
					node.callee.name === "Boolean")
				) {
					context.addNodeDiagnostic(
						node,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_EXTRA_BOOLEAN_CAST,
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noFunctionAssign.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$noFunctionAssign_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noFunctionAssign",
		enter(path) {
			const {node, scope} = path;

			if (
				node.type === "JSAssignmentIdentifier" &&
				scope.getBinding(node.name) instanceof
				___R$project$rome$$internal$compiler$scope$bindings_ts$FunctionBinding
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_FUNCTION_ASSIGN,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noGetterReturn.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$noGetterReturn_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noGetterReturn",
		enter(path) {
			const {node} = path;

			if (
				(node.type === "JSClassMethod" || node.type === "JSObjectMethod") &&
				node.kind === "get"
			) {
				for (const record of ___R$project$rome$$internal$js$ast$utils$getCompletionRecords_ts$getCompletionRecords(
					node.body,
				)) {
					if (record.type === "INVALID") {
						path.context.addNodeDiagnostic(
							record.node,
							___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_GETTER_RETURN(
								record.description,
							),
						);
					}
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noImportAssign.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$js$noImportAssign_ts$isAssignment(
		path,
	) {
		switch (path.parentPath.node.type) {
			case "JSAssignmentExpression":
			case "JSAssignmentArrayPattern":
			case "JSAssignmentObjectPatternProperty":
			case "JSUpdateExpression":
			case "JSAssignmentObjectPattern":
			case "JSForInStatement":
				return true;

			default:
				return false;
		}
	}
	const ___R$project$rome$$internal$compiler$lint$rules$js$noImportAssign_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noImportAssign",
		enter(path) {
			const {node, scope} = path;

			if (
				(node.type === "JSAssignmentIdentifier" &&
				___R$$priv$project$rome$$internal$compiler$lint$rules$js$noImportAssign_ts$isAssignment(
					path,
				)) ||
				(node.type === "JSReferenceIdentifier" &&
				path.parentPath.node.type === "JSUpdateExpression")
			) {
				const binding = scope.getBinding(node.name);
				if (binding !== undefined && binding.kind === "import") {
					path.context.addNodeDiagnostic(
						node,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_IMPORT_ASSIGN(
							node.name,
						),
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noLabelVar.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$noLabelVar_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noLabelVar",
		enter(path) {
			const {node, scope} = path;

			if (node.type === "JSLabeledStatement") {
				const name = node.label.name;
				const binding = scope.getBinding(name);
				const isDefined =
					binding !== undefined || scope.getRootScope().isGlobal(name);

				if (isDefined) {
					path.context.addNodeDiagnostic(
						node,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_LABEL_VAR(
							name,
						),
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noNegationElse.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$js$noNegationElse_ts$isNegation(
		node,
	) {
		return (
			node.type === "JSUnaryExpression" &&
			node.prefix === true &&
			node.operator === "!"
		);
	}
	const ___R$project$rome$$internal$compiler$lint$rules$js$noNegationElse_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noNegationElse",
		enter(path) {
			const {node} = path;

			if (
				node.type === "JSIfStatement" &&
				node.alternate !== undefined &&
				___R$$priv$project$rome$$internal$compiler$lint$rules$js$noNegationElse_ts$isNegation(
					node.test,
				)
			) {
				return path.addFixableDiagnostic(
					{
						fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
							Object.assign(
								{},
								node,
								{
									test: node.test.argument,
									consequent: node.alternate,
									alternate: node.consequent,
								},
							),
						),
					},
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_NEGATION_ELSE,
				);
			}

			if (
				node.type === "JSConditionalExpression" &&
				___R$$priv$project$rome$$internal$compiler$lint$rules$js$noNegationElse_ts$isNegation(
					node.test,
				)
			) {
				return path.addFixableDiagnostic(
					{
						fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
							Object.assign(
								{},
								node,
								{
									test: node.test.argument,
									consequent: node.alternate,
									alternate: node.consequent,
								},
							),
						),
					},
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_NEGATION_ELSE,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noNestedTernary.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$noNestedTernary_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/jsNoNestedTernary",
		enter(path) {
			const {node} = path;

			if (node.type === "JSConditionalExpression") {
				if (node.alternate.type === "JSConditionalExpression") {
					path.context.addNodeDiagnostic(
						node.alternate,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_NESTED_TERNARY,
					);
				}
				if (node.consequent.type === "JSConditionalExpression") {
					path.context.addNodeDiagnostic(
						node.consequent,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_NESTED_TERNARY,
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noRestrictedGlobals.ts
const ___R$$priv$project$rome$$internal$compiler$lint$rules$js$noRestrictedGlobals_ts$RESTRICTED_GLOBALS = [
		"event",
		"error",
	];
	const ___R$project$rome$$internal$compiler$lint$rules$js$noRestrictedGlobals_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/restrictedGlobal",
		enter(path) {
			const {node, scope} = path;

			if (
				(node.type === "JSReferenceIdentifier" ||
				node.type === "JSXReferenceIdentifier") &&
				!___R$project$rome$$internal$js$ast$utils$isInTypeAnnotation_ts$isInTypeAnnotation(
					path,
				)
			) {
				const {name} = node;
				const binding = scope.getBinding(name);

				const isDefined = binding !== undefined;
				const isAGlobal = scope.getRootScope().isGlobal(name);

				if (
					!isDefined &&
					isAGlobal &&
					___R$$priv$project$rome$$internal$compiler$lint$rules$js$noRestrictedGlobals_ts$RESTRICTED_GLOBALS.includes(
						name,
					)
				) {
					path.context.addNodeDiagnostic(
						node,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_RESTRICTED_GLOBALS(
							name,
						),
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noSetterReturn.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$noSetterReturn_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noSetterReturn",
		enter(path) {
			const {node} = path;

			if (
				(node.type === "JSClassMethod" || node.type === "JSObjectMethod") &&
				node.kind === "set"
			) {
				for (const record of ___R$project$rome$$internal$js$ast$utils$getCompletionRecords_ts$getCompletionRecords(
					node.body,
				)) {
					if (
						record.type === "COMPLETION" &&
						record.node.type === "JSReturnStatement" &&
						record.node.argument !== undefined
					) {
						path.context.addNodeDiagnostic(
							record.node,
							___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_SETTER_RETURN,
						);
					}
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noShadowRestrictedNames.ts
const ___R$$priv$project$rome$$internal$compiler$lint$rules$js$noShadowRestrictedNames_ts$restrictedNames = new Set([
		...___R$project$rome$$internal$compiler$scope$globals_ts$builtin,
		...___R$project$rome$$internal$compiler$scope$globals_ts$es5,
		...___R$project$rome$$internal$compiler$scope$globals_ts$es2015,
		...___R$project$rome$$internal$compiler$scope$globals_ts$es2017,
	]);
	const ___R$project$rome$$internal$compiler$lint$rules$js$noShadowRestrictedNames_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noShadowRestrictedNames",
		enter(path) {
			const {node, context, scope} = path;

			if (scope.node === node) {
				for (const [name, binding] of scope.getOwnBindings()) {
					if (
						___R$$priv$project$rome$$internal$compiler$lint$rules$js$noShadowRestrictedNames_ts$restrictedNames.has(
							name,
						)
					) {
						context.addNodeDiagnostic(
							binding.node,
							___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_SHADOW_RESTRICTED_NAMES(
								name,
							),
						);
					}
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noShorthandArrayType.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$noShorthandArrayType_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noShorthandArrayType",
		enter(path) {
			const {node} = path;

			if (node.type === "TSArrayType") {
				return path.addFixableDiagnostic(
					{
						fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
							___R$project$rome$$internal$ast$js$typescript$TSTypeReference_ts$tsTypeReference.create({
								typeName: ___R$project$rome$$internal$ast$js$expressions$JSReferenceIdentifier_ts$jsReferenceIdentifier.quick(
									"Array",
								),
								typeParameters: ___R$project$rome$$internal$ast$js$typescript$TSTypeParameterInstantiation_ts$tsTypeParameterInstantiation.create({
									params: [node.elementType],
								}),
							}),
						),
					},
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_SHORTHAND_ARRAY_TYPE,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noShoutyConstants.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$noShoutyConstants_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noShoutyConstants",
		enter(path) {
			const {node, scope} = path;

			if (node.type === "JSReferenceIdentifier") {
				const binding = scope.getBinding(node.name);
				if (
					binding instanceof
					___R$project$rome$$internal$compiler$scope$bindings_ts$ConstBinding &&
					binding.value !== undefined &&
					binding.value.type === "JSStringLiteral" &&
					binding.value.value === node.name &&
					!binding.isExported &&
					(binding.scope.kind === "block" || binding.scope.kind === "program")
				) {
					return path.addFixableDiagnostic(
						{
							fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
								binding.value,
							),
						},
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_SHOUTY_CONSTANTS(
							binding.node.loc,
						),
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noSparseArray.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$noSparseArray_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noSparseArray",
		enter(path) {
			const {node, parent} = path;

			if (node.type === "JSArrayHole" && parent.type === "JSArrayExpression") {
				return path.addFixableDiagnostic(
					{
						fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
							___R$project$rome$$internal$ast$js$expressions$JSReferenceIdentifier_ts$jsReferenceIdentifier.create({
								name: "undefined",
							}),
						),
					},
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_SPARSE_ARRAY,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noTemplateCurlyInString.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$noTemplateCurlyInString_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noTemplateCurlyInString",
		enter(path) {
			const {node, context} = path;

			if (node.type === "JSStringLiteral") {
				const regex = /\$\{[^}]+\}/u;

				if (regex.test(node.value)) {
					context.addNodeDiagnostic(
						node,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_TEMPLATE_CURLY_IN_STRING,
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noUndeclaredVariables.ts
const ___R$$priv$project$rome$$internal$compiler$lint$rules$js$noUndeclaredVariables_ts$NODE_VARIABLES = [
		"require",
		"__dirname",
		"__filename",
		"module",
		"exports",
	];

	const ___R$$priv$project$rome$$internal$compiler$lint$rules$js$noUndeclaredVariables_ts$BROWSER_VARIABLES = [
		"fetch",
		"document",
		"window",
		"Worker",
		"cancelAnimationFrame",
		"requestAnimationFrame",
		"WebSocket",
		"alert",
		"Blob",
		"navigator",
		"Element",
		"Text",
		"Document",
		"performance",
	];

	// This is gross...
	const ___R$$priv$project$rome$$internal$compiler$lint$rules$js$noUndeclaredVariables_ts$TS_VARIABLES = [
		"MethodDecorator",
		"ParameterDecorator",
		"PromiseConstructorLike",
		"PromiseLike",
		"Promise",
		"ArrayLike",
		"Partial",
		"Required",
		"Readonly",
		"Pick",
		"Record",
		"Exclude",
		"Extract",
		"Omit",
		"NonNullable",
		"Parameters",
		"ConstructorParameters",
		"ReturnType",
		"InstanceType",
		"ThisType",
		"NodeJS",
		"Iterable",
		"IterableIterator",
		"ArrayBufferView",
		"Iterator",
		"TemplateStringsArray",
		"BufferEncoding",
		"Console",
		"Thenable",
	];
	const ___R$project$rome$$internal$compiler$lint$rules$js$noUndeclaredVariables_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noUndeclaredVariables",
		enter(path) {
			const {node, scope} = path;

			if (
				node.type === "JSReferenceIdentifier" ||
				node.type === "JSXReferenceIdentifier"
			) {
				const {name} = node;
				const binding = scope.getBinding(name);

				const isDefined =
					binding !== undefined ||
					scope.isGlobal(name) ||
					___R$$priv$project$rome$$internal$compiler$lint$rules$js$noUndeclaredVariables_ts$BROWSER_VARIABLES.includes(
						name,
					) ||
					___R$$priv$project$rome$$internal$compiler$lint$rules$js$noUndeclaredVariables_ts$NODE_VARIABLES.includes(
						name,
					) ||
					___R$$priv$project$rome$$internal$compiler$lint$rules$js$noUndeclaredVariables_ts$TS_VARIABLES.includes(
						name,
					);

				if (!isDefined) {
					path.context.addNodeDiagnostic(
						node,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_UNDECLARED_VARIABLES(
							name,
							scope.getBindingNames(),
						),
						{
							meta: {
								identifierName: name,
							},
						},
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noUnsafeFinally.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$noUnsafeFinally_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noUnsafeFinally",
		enter(path) {
			const {node, context} = path;

			if (node.type === "JSTryStatement") {
				const {finalizer} = node;

				if (finalizer && finalizer.type === "JSBlockStatement") {
					for (const statement of finalizer.body) {
						if (
							statement.type === "JSThrowStatement" ||
							statement.type === "JSContinueStatement" ||
							statement.type === "JSBreakStatement" ||
							statement.type === "JSReturnStatement"
						) {
							context.addNodeDiagnostic(
								statement,
								___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_UNSAFE_FINALLY(
									statement.type,
								),
							);
						}
					}
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noUnsafeNegation.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$noUnsafeNegation_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noUnsafeNegation",
		enter(path) {
			const {node} = path;

			if (
				node.type === "JSBinaryExpression" &&
				(node.operator === "in" || node.operator === "instanceof") &&
				node.left.type === "JSUnaryExpression" &&
				node.left.operator === "!"
			) {
				return path.addFixableDiagnostic(
					{
						fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
							___R$project$rome$$internal$ast$js$expressions$JSUnaryExpression_ts$jsUnaryExpression.create({
								operator: node.left.operator,
								argument: Object.assign({}, node, {left: node.left.argument}),
							}),
						),
					},
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_UNSAFE_NEGATION,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noUnusedTemplateLiteral.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$js$noUnusedTemplateLiteral_ts$containsSpecialCharacters(
		node,
	) {
		return /['"\n]/.test(node.raw);
	}
	const ___R$project$rome$$internal$compiler$lint$rules$js$noUnusedTemplateLiteral_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/jsNoUnusedTemplateLiteral",
		enter(path) {
			const {node} = path;

			if (
				node.type === "JSTemplateLiteral" &&
				path.parent.type !== "JSTaggedTemplateExpression" &&
				node.expressions.length === 0 &&
				!node.quasis.some(
					___R$$priv$project$rome$$internal$compiler$lint$rules$js$noUnusedTemplateLiteral_ts$containsSpecialCharacters,
				)
			) {
				return path.addFixableDiagnostic(
					{
						fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
							___R$project$rome$$internal$ast$js$literals$JSStringLiteral_ts$jsStringLiteral.quick(
								node.quasis.map((node) => node.cooked).join(),
							),
						),
					},
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_UNUSED_TEMPLATE_LITERAL,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noUnusedVariables.ts
// Common variables that are sometimes impossible to avoid
	const ___R$$priv$project$rome$$internal$compiler$lint$rules$js$noUnusedVariables_ts$ignoreVariables = [
		"React",
	];
	const ___R$project$rome$$internal$compiler$lint$rules$js$noUnusedVariables_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/unusedVariables",
		enter(path, state) {
			const {node, scope} = path;

			if (scope.node === node) {
				let hasBindings = false;
				const usedBindings = {};

				// Get all the non-exported bindings in this file and mark them as unused
				for (const [name, binding] of scope.getOwnBindings()) {
					if (
						binding instanceof
						___R$project$rome$$internal$compiler$scope$bindings_ts$ArgumentsBinding
					) {
						continue;
					}

					if (binding.isExported) {
						continue;
					}

					// Type parameter of a mapped type is always used as it's a property key
					if (
						binding instanceof
						___R$project$rome$$internal$compiler$scope$bindings_ts$TypeBinding &&
						binding.typeKind === "mapped type"
					) {
						continue;
					}

					hasBindings = true;
					usedBindings[name] = false;
				}

				if (!hasBindings) {
					return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
				}

				// For functions, special case parameters
				if (
					node.type === "JSFunctionDeclaration" ||
					node.type === "JSFunctionExpression" ||
					node.type === "JSObjectMethod" ||
					node.type === "JSClassMethod" ||
					node.type === "TSDeclareMethod" ||
					node.type === "TSDeclareFunction" ||
					node.type === "JSArrowFunctionExpression"
				) {
					let ignoreLast = true;
					let includeRest = false;

					// If there's no rest then only consider the last parameter to be unused
					const {rest} = node.head;
					if (rest !== undefined) {
						ignoreLast = false;
					}

					if (
						node.type === "TSDeclareFunction" ||
						node.type === "TSDeclareMethod"
					) {
						// This is an interface and has no body
						ignoreLast = false;
						includeRest = true;
					} else {
						// For functions that have a single throw statement in the body, consider all their arguments
						// to be used as this is typically an interface definition
						const {body} = node;
						if (
							body.type === "JSBlockStatement" &&
							body.body.length === 1 &&
							body.body[0].type === "JSThrowStatement"
						) {
							ignoreLast = false;
							includeRest = true;
						}
					}

					// Mark parameters as used
					let params = [...node.head.params];
					if (ignoreLast) {
						params.pop();
					}
					if (includeRest && rest !== undefined) {
						params.push(rest);
					}
					for (const {name} of ___R$project$rome$$internal$js$ast$utils$getBindingIdentifiers_ts$getBindingIdentifiers(
						params,
					)) {
						usedBindings[name] = true;
					}
				}

				if (
					node.type === "JSCatchClause" &&
					node.param &&
					node.param.type === "JSBindingIdentifier"
				) {
					// Mark error param as used as they are required
					usedBindings[node.param.name] = true;
				}

				// For a named function expression, don't consider the id to be unused
				if (node.type === "JSFunctionExpression" && node.id !== undefined) {
					usedBindings[node.id.name] = true;
				}

				state.reset({
					usedBindings,
					scope,
				});
			}

			if (
				node.type === "JSXReferenceIdentifier" ||
				node.type === "JSReferenceIdentifier"
			) {
				const binding = path.scope.getBindingFromPath(path);

				if (binding !== undefined) {
					state.set(
						(state) => {
							return Object.assign(
								{},
								state,
								{
									// @ts-ignore
									usedBindings: Object.assign(
										{},
										state.usedBindings,
										{[node.name]: true},
									),
								},
							);
						},
						{
							find: (state) => {
								return binding.scope === state.scope;
							},
						},
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},

		exit(path, state) {
			if (state.owns()) {
				const {usedBindings} = state.get();
				for (const name in usedBindings) {
					const used = usedBindings[name];
					const binding = path.scope.getBinding(name);

					if (
						used === false &&
						binding !== undefined &&
						!___R$$priv$project$rome$$internal$compiler$lint$rules$js$noUnusedVariables_ts$ignoreVariables.includes(
							name,
						)
					) {
						path.context.addNodeDiagnostic(
							binding.node,
							___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_UNUSED_VARIABLES(
								binding.kind,
								name,
							),
						);
					}
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/noVar.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$noVar_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/noVar",
		enter(path) {
			const {context, node} = path;

			if (node.type === "JSVariableDeclaration" && node.kind === "var") {
				context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_NO_VAR,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/useBlockStatements.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$useBlockStatements_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/useBlockStatements",
		enter(path) {
			const {node} = path;

			if (node.type === "JSIfStatement") {
				let shouldFix = false;
				let consequent = node.consequent;
				let alternate = node.alternate;

				if (node.consequent.type !== "JSBlockStatement") {
					consequent = ___R$project$rome$$internal$ast$js$statements$JSBlockStatement_ts$jsBlockStatement.quick([
						node.consequent,
					]);
					shouldFix = true;
				}

				if (
					node.alternate !== undefined &&
					node.alternate.type !== "JSBlockStatement" &&
					node.alternate.type !== "JSIfStatement"
				) {
					alternate = ___R$project$rome$$internal$ast$js$statements$JSBlockStatement_ts$jsBlockStatement.quick([
						node.alternate,
					]);
					shouldFix = true;
				}

				if (shouldFix) {
					return path.addFixableDiagnostic(
						{
							fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
								Object.assign({}, node, {consequent, alternate}),
							),
						},
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_PREFER_BLOCK_STATEMENT,
					);
				}
			} else if (
				node.type === "JSForStatement" ||
				node.type === "JSForInStatement" ||
				node.type === "JSForOfStatement" ||
				node.type === "JSDoWhileStatement" ||
				node.type === "JSWhileStatement" ||
				node.type === "JSWithStatement"
			) {
				if (node.body.type === "JSEmptyStatement") {
					const id = ___R$project$rome$$internal$compiler$transforms$helpers$index_ts$injectComment(
						path,
						{
							type: "CommentLine",
							value: " empty",
						},
					);

					return path.addFixableDiagnostic(
						{
							fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
								Object.assign(
									{},
									node,
									{
										body: ___R$project$rome$$internal$ast$js$statements$JSBlockStatement_ts$jsBlockStatement.create({
											innerComments: [id],
											body: [],
										}),
									},
								),
							),
						},
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_PREFER_BLOCK_STATEMENT,
					);
				}

				if (node.body.type !== "JSBlockStatement") {
					return path.addFixableDiagnostic(
						{
							fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
								Object.assign(
									{},
									node,
									{
										body: ___R$project$rome$$internal$ast$js$statements$JSBlockStatement_ts$jsBlockStatement.quick([
											node.body,
										]),
									},
								),
							),
						},
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_PREFER_BLOCK_STATEMENT,
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/useCamelCase.ts
function ___R$project$rome$$internal$compiler$lint$rules$js$useCamelCase_ts$normalizeCamelCase(
		name,
	) {
		if (
			!___R$project$rome$$internal$js$ast$utils$isValidIdentifierName_ts$isValidIdentifierName(
				name,
			)
		) {
			return undefined;
		}

		if (name === "") {
			return undefined;
		}

		return name;
	}
	const ___R$project$rome$$internal$compiler$lint$rules$js$useCamelCase_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/useCamelCase",
		enter(path) {
			const {node, scope, context} = path;

			// Check variables
			if (node === scope.node) {
				const renames = new Map();

				for (const [name, binding] of scope.getOwnBindings()) {
					const camelName = ___R$project$rome$$internal$compiler$lint$rules$js$useCamelCase_ts$normalizeCamelCase(
						___R$project$rome$$internal$string$utils$toCamelCase_ts$toCamelCase(
							name,
							{
								allowShouty: true,
							},
						),
					);
					if (camelName !== undefined && camelName !== name) {
						const {suppressed} = context.addNodeDiagnostic(
							binding.node,
							___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_VARIABLE_CAMEL_CASE(
								name,
								camelName,
							),
							{tags: {fixable: true}},
						);
						if (!suppressed) {
							renames.set(binding, camelName);
						}
					}
				}

				if (renames.size > 0) {
					return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
						___R$project$rome$$internal$js$ast$utils$renameBindings_ts$renameBindings(
							path,
							renames,
						),
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/useDefaultExportBasename.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$js$useDefaultExportBasename_ts$isValidDeclaration(
		node,
	) {
		return (
			node.type === "JSFunctionDeclaration" ||
			node.type === "JSClassDeclaration"
		);
	}

	function ___R$project$rome$$internal$compiler$lint$rules$js$useDefaultExportBasename_ts$filenameToId(
		path,
		capitalize,
	) {
		let basename = path.getExtensionlessBasename();

		if (basename === "index") {
			if (!path.hasParent()) {
				return undefined;
			}

			// If the filename is `index` then use the parent directory name
			basename = path.getParent().getExtensionlessBasename();
		}

		return ___R$project$rome$$internal$compiler$lint$rules$js$useCamelCase_ts$normalizeCamelCase(
			___R$project$rome$$internal$string$utils$toCamelCase_ts$toCamelCase(
				basename,
				{
					forcePascal: capitalize,
					allowShouty: true,
				},
			),
		);
	}
	const ___R$project$rome$$internal$compiler$lint$rules$js$useDefaultExportBasename_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/useDefaultExportBasename",
		enter(path) {
			const {context, node} = path;

			if (node.type === "JSRoot") {
				let defaultExport;
				for (const bodyNode of node.body) {
					if (bodyNode.type === "JSExportDefaultDeclaration") {
						defaultExport = bodyNode;
						break;
					}
				}

				if (
					defaultExport !== undefined &&
					___R$$priv$project$rome$$internal$compiler$lint$rules$js$useDefaultExportBasename_ts$isValidDeclaration(
						defaultExport.declaration,
					)
				) {
					const {declaration} = defaultExport;

					// Get the export default id
					const id = declaration.id;
					if (id !== undefined && context.path !== undefined) {
						const type =
							declaration.type === "JSFunctionDeclaration"
								? "function"
								: "class";
						const basename = ___R$project$rome$$internal$compiler$lint$rules$js$useDefaultExportBasename_ts$filenameToId(
							context.path,
							type === "class",
						);

						if (basename !== undefined && basename !== id.name) {
							const correctFilename = id.name + context.path.getExtensions();

							return path.addFixableDiagnostic(
								{
									target: id,
									fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
										___R$project$rome$$internal$js$ast$utils$renameBindings_ts$renameBindings(
											path,
											new Map([[id.name, basename]]),
										),
									),
								},
								___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_USE_DEFAULT_EXPORT_BASENAME({
									defaultName: id.name,
									defaultType: type,
									actualFilename: basename,
									correctFilename,
								}),
							);
						}
					}
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/useDefaultImportBasename.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$useDefaultImportBasename_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/useDefaultImportBasename",
		enter(path) {
			const {node} = path;

			if (node.type === "JSImportDeclaration") {
				const {defaultSpecifier} = node;
				if (defaultSpecifier === undefined) {
					return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
				}

				const filePath = ___R$project$rome$$internal$path$index_ts$createUnknownPath(
					node.source.value,
				);
				const expectedName = ___R$project$rome$$internal$compiler$lint$rules$js$useDefaultExportBasename_ts$filenameToId(
					filePath,
					false,
				);
				const expectedNameCapital = ___R$project$rome$$internal$compiler$lint$rules$js$useDefaultExportBasename_ts$filenameToId(
					filePath,
					true,
				);
				if (expectedName === undefined || expectedNameCapital === undefined) {
					return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
				}

				const localName = defaultSpecifier.local.name.name;
				if (localName !== expectedName && localName !== expectedNameCapital) {
					path.context.addNodeDiagnostic(
						node,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_USE_DEFAULT_IMPORT_BASENAME(
							localName,
							[expectedName, expectedNameCapital],
						),
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/useFunctionDeclarations.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$useFunctionDeclarations_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/useFunctionDeclarations",
		enter(path, state) {
			const {node} = path;

			if (
				node.type === "JSVariableDeclarationStatement" &&
				node.declaration.kind === "const"
			) {
				// Get all declarators that are function expressions, have no type annotation, and have a binding jsIdentifier id
				const declarators = node.declaration.declarations.filter((decl) => {
					return (
						decl.id.type === "JSBindingIdentifier" &&
						(decl.id.meta === undefined ||
						decl.id.meta.typeAnnotation === undefined) &&
						decl.init !== undefined &&
						(decl.init.type === "JSFunctionExpression" ||
						decl.init.type === "JSArrowFunctionExpression")
					);
				});
				if (declarators.length > 0) {
					state.reset({declarators});
				}
			}

			// If we have a `this` inside of an arrow function attached as a variable declarator then we should consider
			// it valid
			if (node.type === "JSThisExpression") {
				// Try to find the arrow function owner, or stop if we get to another function
				const func = path.findAncestry((path) => {
					if (path.node.type === "JSArrowFunctionExpression") {
						return path.parent.type === "JSVariableDeclarator";
					}

					return ___R$project$rome$$internal$js$ast$utils$isFunctionNode_ts$isFunctionNode(
						path.node,
					);
				});

				// We'll only return an JSArrowFunctionExpression if it was inside of a JSVariableDeclarator
				if (func !== undefined && func.node.type === "JSArrowFunctionExpression") {
					const declarator = ___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclarator_ts$jsVariableDeclarator.assert(
						func.parent,
					);
					state.set(
						(state) => {
							return {
								declarators: state.declarators.filter((decl) =>
									decl !== declarator
								),
							};
						},
						{
							find: (state) => state.declarators.includes(declarator),
						},
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},

		exit(path, _state) {
			const {node} = path;

			if (node.type === "JSVariableDeclarationStatement" && _state.owns()) {
				const state = _state.get();

				// We may have invalidated all declarations
				if (state.declarators.length === 0) {
					return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
				}

				const nodes = [];
				const replaceDeclarators = new Set(state.declarators);

				// Convert functions
				for (const decl of replaceDeclarators) {
					// Could have been changed under us. Ignore it, we'll get it in another pass
					if (!node.declaration.declarations.includes(decl)) {
						continue;
					}

					const id = ___R$project$rome$$internal$ast$js$patterns$JSBindingIdentifier_ts$jsBindingIdentifier.assert(
						decl.id,
					);
					const {init} = decl;

					if (
						init === undefined ||
						(init.type !== "JSFunctionExpression" &&
						init.type !== "JSArrowFunctionExpression")
					) {
						throw new Error("Invalid declarator put into state");
					}

					const {suppressed} = path.context.addNodeDiagnostic(
						init,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_USE_FUNCTION_DECLARATIONS,
						{tags: {fixable: true}},
					);
					if (suppressed) {
						replaceDeclarators.delete(decl);
						continue;
					}

					// Convert arrow function body if necessary
					const body =
						init.body.type === "JSBlockStatement"
							? init.body
							: ___R$project$rome$$internal$ast$js$statements$JSBlockStatement_ts$jsBlockStatement.create({
									body: [
										___R$project$rome$$internal$ast$js$statements$JSReturnStatement_ts$jsReturnStatement.quick(
											init.body,
										),
									],
								});

					nodes.push(
						___R$project$rome$$internal$ast$js$statements$JSFunctionDeclaration_ts$jsFunctionDeclaration.create(
							{
								id,
								head: init.head,
								body,
							},
							init,
						),
					);
				}

				// We may have invalidated all declarations
				if (replaceDeclarators.size === 0) {
					return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
				}

				const newNode = Object.assign(
					{},
					node,
					{
						declaration: Object.assign(
							{},
							node.declaration,
							{
								declarations: node.declaration.declarations.filter((decl) =>
									!replaceDeclarators.has(decl)
								),
							},
						),
					},
				);

				// We may have removed all the declarators
				if (newNode.declaration.declarations.length > 0) {
					nodes.push(newNode);
				}

				if (nodes.length === 1) {
					return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
						nodes[0],
					);
				}

				return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
					nodes,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/useSingleCaseStatement.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$useSingleCaseStatement_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/useSingleCaseStatement",
		enter(path) {
			const {node} = path;

			if (node.type === "JSSwitchCase" && node.consequent.length > 1) {
				return path.addFixableDiagnostic(
					{
						fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
							Object.assign(
								{},
								node,
								{
									consequent: [
										___R$project$rome$$internal$ast$js$statements$JSBlockStatement_ts$jsBlockStatement.quick(
											node.consequent,
										),
									],
								},
							),
						),
					},
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_USE_SINGLE_CASE_STATEMENT,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/useSingleVarDeclarator.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$useSingleVarDeclarator_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/useSingleVarDeclarator",
		enter(path) {
			const {node} = path;

			if (
				node.type === "JSVariableDeclarationStatement" &&
				node.declaration.declarations.length > 1
			) {
				const fixed = [];
				const {kind} = node.declaration;

				for (const declarator of node.declaration.declarations) {
					fixed.push(
						___R$project$rome$$internal$ast$js$statements$JSVariableDeclarationStatement_ts$jsVariableDeclarationStatement.quick(
							___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclaration_ts$jsVariableDeclaration.create({
								kind,
								declarations: [declarator],
							}),
						),
					);
				}

				return path.addFixableDiagnostic(
					{
						fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
							fixed,
						),
					},
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_USE_SINGLE_VAR_DECLARATOR,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/useSortedSpecifiers.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$js$useSortedSpecifiers_ts$compareImportSpecifiers(
		a,
		b,
	) {
		const order = ___R$project$rome$$internal$string$utils$naturalCompare_ts$naturalCompare(
			a.local.name.name,
			b.local.name.name,
			false,
		);
		if (order === 0) {
			return ___R$project$rome$$internal$string$utils$naturalCompare_ts$naturalCompare(
				a.imported.name,
				b.imported.name,
				false,
			);
		} else {
			return order;
		}
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$js$useSortedSpecifiers_ts$compareExportSpecifiers(
		a,
		b,
	) {
		const order = ___R$project$rome$$internal$string$utils$naturalCompare_ts$naturalCompare(
			a.local.name,
			b.local.name,
			false,
		);
		if (order === 0) {
			return ___R$project$rome$$internal$string$utils$naturalCompare_ts$naturalCompare(
				a.exported.name,
				b.exported.name,
				false,
			);
		} else {
			return order;
		}
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$js$useSortedSpecifiers_ts$shouldReorder(
		a,
		b,
	) {
		for (let i = 0; i < a.length && i < b.length; i++) {
			if (a[i] !== b[i]) {
				return true;
			}
		}

		return false;
	}
	const ___R$project$rome$$internal$compiler$lint$rules$js$useSortedSpecifiers_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/useSortedSpecifiers",
		enter(path) {
			const {node} = path;

			if (node.type === "JSImportDeclaration") {
				if (node.namedSpecifiers.length > 1) {
					const specifiers = node.namedSpecifiers;
					const sortedSpecifiers = specifiers.slice().sort(
						___R$$priv$project$rome$$internal$compiler$lint$rules$js$useSortedSpecifiers_ts$compareImportSpecifiers,
					);
					if (
						___R$$priv$project$rome$$internal$compiler$lint$rules$js$useSortedSpecifiers_ts$shouldReorder(
							specifiers,
							sortedSpecifiers,
						)
					) {
						return path.addFixableDiagnostic(
							{
								fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
									Object.assign({}, node, {namedSpecifiers: sortedSpecifiers}),
								),
							},
							___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_SORT_IMPORT_SPECIFIERS,
						);
					}
				}
			} else if (node.type === "JSExportExternalDeclaration") {
				if (node.namedSpecifiers.length > 1) {
					const specifiers = node.namedSpecifiers;
					const sortedSpecifiers = specifiers.slice().sort(
						___R$$priv$project$rome$$internal$compiler$lint$rules$js$useSortedSpecifiers_ts$compareExportSpecifiers,
					);
					if (
						___R$$priv$project$rome$$internal$compiler$lint$rules$js$useSortedSpecifiers_ts$shouldReorder(
							specifiers,
							sortedSpecifiers,
						)
					) {
						return path.addFixableDiagnostic(
							{
								fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
									Object.assign({}, node, {namedSpecifiers: sortedSpecifiers}),
								),
							},
							___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_SORT_EXPORT_SPECIFIERS,
						);
					}
				}
			} else if (node.type === "JSExportLocalDeclaration") {
				if (node.specifiers !== undefined && node.specifiers.length > 1) {
					const specifiers = node.specifiers;
					const sortedSpecifiers = specifiers.slice().sort(
						___R$$priv$project$rome$$internal$compiler$lint$rules$js$useSortedSpecifiers_ts$compareExportSpecifiers,
					);
					if (
						___R$$priv$project$rome$$internal$compiler$lint$rules$js$useSortedSpecifiers_ts$shouldReorder(
							specifiers,
							sortedSpecifiers,
						)
					) {
						return path.addFixableDiagnostic(
							{
								fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
									Object.assign({}, node, {specifiers: sortedSpecifiers}),
								),
							},
							___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_SORT_EXPORT_SPECIFIERS,
						);
					}
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/useTemplate.ts
// expr + expr
	function ___R$$priv$project$rome$$internal$compiler$lint$rules$js$useTemplate_ts$isBinaryAddExpression(
		node,
	) {
		return node.type === "JSBinaryExpression" && node.operator === "+";
	}

	// 'str' + 'str'
	// 'str' + expr
	// expr + 'str'
	// expr + (expr + 'str')
	// (expr + 'str') + expr
	function ___R$$priv$project$rome$$internal$compiler$lint$rules$js$useTemplate_ts$isUnnecessaryStringConcatExpression(
		node,
	) {
		if (
			!___R$$priv$project$rome$$internal$compiler$lint$rules$js$useTemplate_ts$isBinaryAddExpression(
				node,
			)
		) {
			return false;
		}

		if (node.left.type === "JSBinaryExpression") {
			if (
				___R$$priv$project$rome$$internal$compiler$lint$rules$js$useTemplate_ts$isUnnecessaryStringConcatExpression(
					node.left,
				)
			) {
				return true;
			}
		}

		if (node.right.type === "JSBinaryExpression") {
			if (
				___R$$priv$project$rome$$internal$compiler$lint$rules$js$useTemplate_ts$isUnnecessaryStringConcatExpression(
					node.right,
				)
			) {
				return true;
			}
		}

		if (
			node.left.type === "JSStringLiteral" &&
			!node.left.value.includes("`") &&
			!node.left.value.includes("\n")
		) {
			return true;
		}

		if (
			node.right.type === "JSStringLiteral" &&
			!node.right.value.includes("`") &&
			!node.right.value.includes("\n")
		) {
			return true;
		}

		if (node.left.type === "JSTemplateLiteral") {
			return true;
		}

		if (node.right.type === "JSTemplateLiteral") {
			return true;
		}

		return false;
	}

	// expr + expr + expr + ...
	function ___R$$priv$project$rome$$internal$compiler$lint$rules$js$useTemplate_ts$collectBinaryAddExpressionExpressions(
		node,
	) {
		let expressions = [];

		if (
			___R$$priv$project$rome$$internal$compiler$lint$rules$js$useTemplate_ts$isBinaryAddExpression(
				node.left,
			)
		) {
			expressions = expressions.concat(
				___R$$priv$project$rome$$internal$compiler$lint$rules$js$useTemplate_ts$collectBinaryAddExpressionExpressions(
					node.left,
				),
			);
		} else {
			expressions.push(node.left);
		}

		if (
			___R$$priv$project$rome$$internal$compiler$lint$rules$js$useTemplate_ts$isBinaryAddExpression(
				node.right,
			)
		) {
			expressions = expressions.concat(
				___R$$priv$project$rome$$internal$compiler$lint$rules$js$useTemplate_ts$collectBinaryAddExpressionExpressions(
					node.right,
				),
			);
		} else {
			expressions.push(node.right);
		}

		return expressions;
	}

	// zips template.quasis and template.expressions into one array
	function ___R$$priv$project$rome$$internal$compiler$lint$rules$js$useTemplate_ts$zipTemplateLiteralParts(
		template,
	) {
		let templateParts = [];

		for (let i = 0; i < template.quasis.length; i++) {
			templateParts.push(template.quasis[i]);

			if (i + 1 < template.quasis.length) {
				templateParts.push(template.expressions[i]);
			}
		}

		return templateParts;
	}

	// flattens an array of expressions into TemplateLiteral parts
	function ___R$$priv$project$rome$$internal$compiler$lint$rules$js$useTemplate_ts$flattenExpressionsToTemplateParts(
		expressions,
	) {
		let parts = [];
		let queue = [...expressions];

		while (true) {
			let node = queue.shift();
			if (!node) {
				break;
			}

			if (node.type === "JSTemplateLiteral") {
				queue = [
					...___R$$priv$project$rome$$internal$compiler$lint$rules$js$useTemplate_ts$zipTemplateLiteralParts(
						node,
					),
					...queue,
				];
			} else {
				parts.push(node);
			}
		}

		return parts;
	}

	// 'str' + 'str' + expr -> 'strstr' + expr
	function ___R$$priv$project$rome$$internal$compiler$lint$rules$js$useTemplate_ts$combineTemplateParts(
		expressions,
	) {
		let reducedExpressions = [];
		let index = 0;

		while (index < expressions.length) {
			let current = expressions[index];

			if (
				current.type === "JSStringLiteral" ||
				current.type === "JSTemplateElement"
			) {
				let strings = [current];

				while (index + 1 < expressions.length) {
					let next = expressions[index + 1];
					if (
						next.type === "JSStringLiteral" ||
						next.type === "JSTemplateElement"
					) {
						strings.push(next);
						index++;
					} else {
						break;
					}
				}

				if (strings.length === 1 && current.type === "JSStringLiteral") {
					reducedExpressions.push(current);
				} else {
					reducedExpressions.push(
						___R$project$rome$$internal$ast$js$literals$JSStringLiteral_ts$jsStringLiteral.create({
							value: strings.map((string) => {
								if (string.type === "JSTemplateElement") {
									return string.raw;
								} else {
									return string.value;
								}
							}).join(""),
						}),
					);
				}
			} else {
				reducedExpressions.push(current);
			}

			index++;
		}

		return reducedExpressions;
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$js$useTemplate_ts$createEmptyQuasis(
		isTail = false,
	) {
		return ___R$project$rome$$internal$ast$js$auxiliary$JSTemplateElement_ts$jsTemplateElement.create({
			cooked: "",
			raw: "",
			tail: isTail,
		});
	}

	// 'str' + expr + 'str' -> `str${expr}str`
	function ___R$$priv$project$rome$$internal$compiler$lint$rules$js$useTemplate_ts$convertTemplatePartsToTemplateLiteral(
		nodes,
	) {
		let templateExpressions = [];
		let templateQuasis = [];

		for (let index = 0; index < nodes.length; index++) {
			let node = nodes[index];
			let isTail = index === nodes.length - 1;
			let isHead = index === 0;

			if (node.type === "JSTemplateElement") {
				templateQuasis.push(node);
			} else if (node.type === "JSStringLiteral") {
				templateQuasis.push(
					___R$project$rome$$internal$ast$js$auxiliary$JSTemplateElement_ts$jsTemplateElement.create({
						cooked: node.value,
						raw: node.value,
						tail: isTail,
					}),
				);
			} else {
				templateExpressions.push(node);

				let next = nodes[index + 1];
				let isNextQuasis =
					(next == null ? undefined : next.type) === "JSStringLiteral" ||
					(next == null ? undefined : next.type) === "JSTemplateElement";

				if (isTail || isHead || !isNextQuasis) {
					templateQuasis.push(
						___R$$priv$project$rome$$internal$compiler$lint$rules$js$useTemplate_ts$createEmptyQuasis(
							isTail,
						),
					);
				}
			}
		}

		return ___R$project$rome$$internal$ast$js$literals$JSTemplateLiteral_ts$jsTemplateLiteral.create({
			expressions: templateExpressions,
			quasis: templateQuasis,
		});
	}

	// Only convert to a template literal when at least one of the expressions isn't a string
	// Concatenating together only strings is allowed as it's sometimes used to break up long lines
	// Ignore:
	// str + str
	// str + str + str
	// Replace:
	// str + expr
	// str + expr + str
	function ___R$$priv$project$rome$$internal$compiler$lint$rules$js$useTemplate_ts$shouldReplace(
		expressions,
	) {
		for (let expression of expressions) {
			if (expression.type !== "JSStringLiteral") {
				return true;
			}
		}

		return false;
	}
	const ___R$project$rome$$internal$compiler$lint$rules$js$useTemplate_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/useTemplate",
		enter(path) {
			const {node} = path;

			if (
				___R$$priv$project$rome$$internal$compiler$lint$rules$js$useTemplate_ts$isUnnecessaryStringConcatExpression(
					node,
				)
			) {
				const expressions = ___R$$priv$project$rome$$internal$compiler$lint$rules$js$useTemplate_ts$collectBinaryAddExpressionExpressions(
					node,
				);

				if (
					___R$$priv$project$rome$$internal$compiler$lint$rules$js$useTemplate_ts$shouldReplace(
						expressions,
					)
				) {
					const templateParts = ___R$$priv$project$rome$$internal$compiler$lint$rules$js$useTemplate_ts$flattenExpressionsToTemplateParts(
						expressions,
					);
					const combinedParts = ___R$$priv$project$rome$$internal$compiler$lint$rules$js$useTemplate_ts$combineTemplateParts(
						templateParts,
					);
					const template = ___R$$priv$project$rome$$internal$compiler$lint$rules$js$useTemplate_ts$convertTemplatePartsToTemplateLiteral(
						combinedParts,
					);

					return path.addFixableDiagnostic(
						{
							fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
								template,
							),
						},
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_USE_TEMPLATE,
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/js/useWhile.ts
const ___R$project$rome$$internal$compiler$lint$rules$js$useWhile_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "js/useWhile",
		enter(path) {
			const {node} = path;

			if (
				node.type === "JSForStatement" &&
				node.init === undefined &&
				node.update === undefined
			) {
				return path.addFixableDiagnostic(
					{
						fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
							___R$project$rome$$internal$ast$js$statements$JSWhileStatement_ts$jsWhileStatement.create(
								{
									test: node.test !== undefined
										? node.test
										: ___R$project$rome$$internal$ast$js$literals$JSBooleanLiteral_ts$jsBooleanLiteral.quick(
												true,
											),
									body: node.body,
									leadingComments: node.leadingComments,
									trailingComments: node.trailingComments,
								},
								node,
							),
						),
					},
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JS_USE_WHILE,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx-a11y/noAccessKey.ts
const ___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$noAccessKey_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx-a11y/noAccessKey",

		enter(path) {
			const {node} = path;

			if (
				node.type === "JSXElement" &&
				___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
					node,
					"accessKey",
				)
			) {
				return path.addFixableDiagnostic(
					{
						target: ___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
							node,
							"accessKey",
						),
						fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
							Object.assign(
								{},
								node,
								{
									attributes: node.attributes.filter((attribute) =>
										attribute.type !== "JSXAttribute" ||
										attribute.name.name !== "accessKey"
									),
								},
							),
						),
					},
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_NO_ACCESS_KEY,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/utils/aria/isElementInteractive.ts
function ___R$project$rome$$internal$compiler$lint$utils$aria$isElementInteractive_ts$default(
		elementName,
	) {
		let role;
		for (const [, roleInfo] of ___R$project$rome$$internal$compiler$lint$utils$aria$ariaRolesMap_ts$default) {
			if (roleInfo.baseConcepts) {
				const elementMatched = roleInfo.baseConcepts.some(({concept}) =>
					concept.name === elementName
				);
				if (elementMatched) {
					role = roleInfo;
					break;
				}
			}
		}

		if (role) {
			return ___R$project$rome$$internal$compiler$lint$utils$aria$isRoleInteractive_ts$default(
				role,
			);
		}
		return false;
	}


  // project-rome/@internal/compiler/lint/utils/aria/isRoleInteractive.ts
function ___R$project$rome$$internal$compiler$lint$utils$aria$isRoleInteractive_ts$default(
		role,
	) {
		return role.superClassRole.includes("widget");
	}


  // project-rome/@internal/compiler/lint/utils/aria/ariaPropsMap.ts
const ___R$$priv$project$rome$$internal$compiler$lint$utils$aria$ariaPropsMap_ts$ariaPropsMap = new Map([
		[
			"aria-activedescendant",
			{
				type: "id",
			},
		],
		[
			"aria-atomic",
			{
				type: "boolean",
			},
		],
		[
			"aria-autocomplete",
			{
				type: "token",
				values: ["inline", "list", "both", "none"],
			},
		],
		[
			"aria-busy",
			{
				type: "boolean",
			},
		],
		[
			"aria-checked",
			{
				type: "tristate",
			},
		],
		[
			"aria-colcount",
			{
				type: "integer",
			},
		],
		[
			"aria-colindex",
			{
				type: "integer",
			},
		],
		[
			"aria-colspan",
			{
				type: "integer",
			},
		],
		[
			"aria-controls",
			{
				type: "idlist",
			},
		],
		[
			"aria-current",
			{
				type: "token",
				values: ["page", "step", "location", "date", "time", true, false],
			},
		],
		[
			"aria-describedby",
			{
				type: "idlist",
			},
		],
		[
			"aria-details",
			{
				type: "id",
			},
		],
		[
			"aria-disabled",
			{
				type: "boolean",
			},
		],
		[
			"aria-dropeffect",
			{
				type: "tokenlist",
				values: ["copy", "execute", "link", "move", "none", "popup"],
			},
		],
		[
			"aria-errormessage",
			{
				type: "id",
			},
		],
		[
			"aria-expanded",
			{
				type: "boolean",
				allowUndefined: true,
			},
		],
		[
			"aria-flowto",
			{
				type: "idlist",
			},
		],
		[
			"aria-grabbed",
			{
				type: "boolean",
				allowUndefined: true,
			},
		],
		[
			"aria-haspopup",
			{
				type: "token",
				values: [false, true, "menu", "listbox", "tree", "grid", "dialog"],
			},
		],
		[
			"aria-hidden",
			{
				type: "boolean",
				allowUndefined: true,
			},
		],
		[
			"aria-invalid",
			{
				type: "token",
				values: ["grammar", false, "spelling", true],
			},
		],
		[
			"aria-keyshortcuts",
			{
				type: "string",
			},
		],
		[
			"aria-label",
			{
				type: "string",
			},
		],
		[
			"aria-labelledby",
			{
				type: "idlist",
			},
		],
		[
			"aria-level",
			{
				type: "integer",
			},
		],
		[
			"aria-live",
			{
				type: "token",
				values: ["assertive", "off", "polite"],
			},
		],
		[
			"aria-modal",
			{
				type: "boolean",
			},
		],
		[
			"aria-multiline",
			{
				type: "boolean",
			},
		],
		[
			"aria-multiselectable",
			{
				type: "boolean",
			},
		],
		[
			"aria-orientation",
			{
				type: "token",
				values: ["vertical", "undefined", "horizontal"],
			},
		],
		[
			"aria-owns",
			{
				type: "idlist",
			},
		],
		[
			"aria-placeholder",
			{
				type: "string",
			},
		],
		[
			"aria-posinset",
			{
				type: "integer",
			},
		],
		[
			"aria-pressed",
			{
				type: "tristate",
			},
		],
		[
			"aria-readonly",
			{
				type: "boolean",
			},
		],
		[
			"aria-relevant",
			{
				type: "tokenlist",
				values: ["additions", "all", "removals", "text"],
			},
		],
		[
			"aria-required",
			{
				type: "boolean",
			},
		],
		[
			"aria-roledescription",
			{
				type: "string",
			},
		],
		[
			"aria-rowcount",
			{
				type: "integer",
			},
		],
		[
			"aria-rowindex",
			{
				type: "integer",
			},
		],
		[
			"aria-rowspan",
			{
				type: "integer",
			},
		],
		[
			"aria-selected",
			{
				type: "boolean",
				allowUndefined: true,
			},
		],
		[
			"aria-setsize",
			{
				type: "integer",
			},
		],
		[
			"aria-sort",
			{
				type: "token",
				values: ["ascending", "descending", "none", "other"],
			},
		],
		[
			"aria-valuemax",
			{
				type: "number",
			},
		],
		[
			"aria-valuemin",
			{
				type: "number",
			},
		],
		[
			"aria-valuenow",
			{
				type: "number",
			},
		],
		[
			"aria-valuetext",
			{
				type: "string",
			},
		],
	]);
	const ___R$project$rome$$internal$compiler$lint$utils$aria$ariaPropsMap_ts$default = ___R$$priv$project$rome$$internal$compiler$lint$utils$aria$ariaPropsMap_ts$ariaPropsMap;


  // project-rome/@internal/compiler/lint/utils/aria/ariaRolesMap.ts
const ___R$$priv$project$rome$$internal$compiler$lint$utils$aria$ariaRolesMap_ts$ariaRolesMap = new Map([
		[
			"checkbox",
			{
				props: ["aria-checked", "aria-readonly"],
				requiredProps: ["aria-checked"],
				superClassRole: ["switch", "menuitemcheckbox", "widget"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "input",
							attributes: [
								{
									name: "type",
									value: "checkbox",
								},
							],
						},
					},
				],
			},
		],
		[
			"radio",
			{
				props: ["aria-checked", "aria-readonly"],
				requiredProps: ["aria-checked"],
				superClassRole: ["menuitemradio", "widget"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "input",
							attributes: [
								{
									name: "type",
									value: "radio",
								},
							],
						},
					},
				],
			},
		],
		[
			"switch",
			{
				props: ["aria-checked"],
				requiredProps: ["aria-checked"],
				superClassRole: ["checkbox", "widget"],
			},
		],
		[
			"option",
			{
				props: ["aria-selected"],
				requiredProps: ["aria-selected"],
				superClassRole: ["treeitem", "widget"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "option",
						},
					},
				],
			},
		],
		[
			"combobox",
			{
				props: ["aria-controls", "aria-expanded"],
				requiredProps: ["aria-controls", "aria-expanded"],
				superClassRole: ["select", "widget"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "select",
						},
					},
				],
			},
		],
		[
			"heading",
			{
				props: ["aria-level"],
				requiredProps: ["aria-level"],
				superClassRole: ["sectionhead"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "h1",
						},
					},
					{
						module: "HTML",
						concept: {
							name: "h2",
						},
					},
					{
						module: "HTML",
						concept: {
							name: "h3",
						},
					},
					{
						module: "HTML",
						concept: {
							name: "h4",
						},
					},
					{
						module: "HTML",
						concept: {
							name: "h5",
						},
					},
					{
						module: "HTML",
						concept: {
							name: "h6",
						},
					},
				],
			},
		],
		[
			"spinbutton",
			{
				props: ["aria-valuemax", "aria-valuemin", "aria-valuenow"],
				requiredProps: ["aria-valuemax", "aria-valuemin", "aria-valuenow"],
				superClassRole: ["composite", "input", "range", "widget"],
			},
		],
		[
			"slider",
			{
				props: ["aria-valuemax", "aria-valuemin", "aria-valuenow"],
				requiredProps: ["aria-valuemax", "aria-valuemin", "aria-valuenow"],
				superClassRole: ["input", "range", "widget"],
			},
		],
		[
			"separator",
			{
				props: ["aria-valuemax", "aria-valuemin", "aria-valuenow"],
				requiredProps: ["aria-valuemax", "aria-valuemin", "aria-valuenow"],
				superClassRole: ["structure", "widget"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "hr",
						},
					},
				],
			},
		],

		[
			"scrollbar",
			{
				props: [
					"aria-valuemax",
					"aria-valuemin",
					"aria-valuenow",
					"aria-orientation",
					"aria-controls",
				],
				requiredProps: [
					"aria-valuemax",
					"aria-valuemin",
					"aria-valuenow",
					"aria-orientation",
					"aria-controls",
				],
				superClassRole: ["range", "widget"],
			},
		],

		[
			"button",
			{
				props: ["aria-expanded", "aria-pressed"],
				requiredProps: [],
				superClassRole: ["roletype", "widget", "command"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "button",
						},
					},
					{
						module: "HTML",
						concept: {
							name: "input",
							attributes: [
								{
									name: "type",
									value: "button",
								},
							],
						},
					},
				],
			},
		],
		[
			"article",
			{
				props: [],
				requiredProps: [],
				superClassRole: ["document"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "article",
						},
					},
				],
			},
		],
		[
			"dialog",
			{
				props: ["aria-label", "aria-labelledby"],
				requiredProps: [],
				superClassRole: ["window"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "dialog",
						},
					},
				],
			},
		],
		[
			"alert",
			{
				props: [],
				requiredProps: [],
				superClassRole: ["section"],
				baseConcepts: [
					{
						module: "XForms",
						concept: {
							name: "alert",
						},
					},
				],
			},
		],
		[
			"alertdialog",
			{
				props: [],
				requiredProps: [],
				superClassRole: ["alert", "dialog"],
				baseConcepts: [
					{
						module: "XForms",
						concept: {
							name: "alert",
						},
					},
				],
			},
		],
		[
			"application",
			{
				props: [],
				requiredProps: [],
				superClassRole: ["structure"],
			},
		],
		[
			"banner",
			{
				props: [],
				requiredProps: [],
				superClassRole: ["landmark"],
			},
		],
		[
			"cell",
			{
				props: [
					"aria-colindex",
					"aria-colspan",
					"aria-rowindex",
					"aria-rowspan",
				],
				requiredProps: [],
				superClassRole: ["section"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "td",
						},
					},
				],
			},
		],
		[
			"columnheader",
			{
				props: ["aria-sort"],
				requiredProps: [],
				superClassRole: ["cell", "gridcell", "sectionhead"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "th",
							attributes: [
								{
									name: "scope",
									value: "col",
								},
							],
						},
					},
				],
			},
		],
		[
			"definition",
			{
				props: ["aria-labelledby"],
				requiredProps: [],
				superClassRole: ["section"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "dd",
						},
					},
					{
						module: "HTML",
						concept: {
							name: "dfn",
						},
					},
				],
			},
		],
		[
			"feed",
			{
				props: ["aria-busy", "aria-setsize"],
				requiredProps: [],
				superClassRole: ["section"],
			},
		],
		[
			"figure",
			{
				props: ["aria-label", "aria-labelledby"],
				requiredProps: [],
				superClassRole: ["section"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "figure",
						},
					},
				],
			},
		],
		[
			"form",
			{
				props: ["aria-label", "aria-labelledby"],
				requiredProps: [],
				superClassRole: ["section"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "form",
						},
					},
				],
			},
		],
		[
			"grid",
			{
				props: ["aria-level", "aria-multiselectable", "aria-readonly"],
				requiredProps: [],
				superClassRole: ["composite", "table"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "table",
						},
					},
				],
			},
		],
		[
			"gridcell",
			{
				props: ["aria-readonly", "aria-required", "aria-selected"],
				requiredProps: [],
				superClassRole: ["cell", "widget"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "td",
						},
					},
				],
			},
		],
		[
			"group",
			{
				props: ["aria-activedescendant"],
				requiredProps: [],
				superClassRole: ["row", "select", "toolbar"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "fieldset",
						},
					},
				],
			},
		],
		[
			"img",
			{
				props: ["aria-activedescendant"],
				requiredProps: [],
				superClassRole: ["section"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "img",
						},
					},
				],
			},
		],
		[
			"link",
			{
				props: ["aria-expanded"],
				requiredProps: [],
				superClassRole: ["command"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "a",
						},
					},
					{
						module: "HTML",
						concept: {
							name: "link",
						},
					},
				],
			},
		],
		[
			"list",
			{
				props: [],
				requiredProps: [],
				superClassRole: ["section"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "ol",
						},
					},
					{
						module: "HTML",
						concept: {
							name: "ul",
						},
					},
				],
			},
		],
		[
			"listbox",
			{
				props: [],
				requiredProps: [],
				superClassRole: ["select"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "select",
						},
					},
				],
			},
		],
		[
			"listitem",
			{
				props: [],
				requiredProps: [],
				superClassRole: ["section"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "li",
						},
					},
				],
			},
		],
		[
			"log",
			{
				props: [],
				requiredProps: [],
				superClassRole: ["section"],
			},
		],
		[
			"main",
			{
				props: [],
				requiredProps: [],
				superClassRole: ["landmark"],
			},
		],
		[
			"menu",
			{
				props: [],
				requiredProps: [],
				superClassRole: ["select"],
			},
		],
		[
			"menubar",
			{
				props: [],
				requiredProps: [],
				superClassRole: ["toolbar"],
			},
		],
		[
			"menuitem",
			{
				props: ["aria-posinset", "aria-setsize"],
				requiredProps: [],
				superClassRole: ["command"],
			},
		],
		[
			"menuitemcheckbox",
			{
				props: [],
				requiredProps: ["aria-checked"],
				superClassRole: ["checkbox", "menuitem"],
			},
		],
		[
			"menuitemradio",
			{
				props: [],
				requiredProps: ["aria-checked"],
				superClassRole: ["menuitemcheckbox", "radio"],
			},
		],
		[
			"navigation",
			{
				props: [],
				requiredProps: [],
				superClassRole: ["landmark"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "nav",
						},
					},
				],
			},
		],
		[
			"progressbar",
			{
				props: [],
				requiredProps: ["aria-valuenow", "aria-valuemin", "aria-valuemax"],
				superClassRole: ["range"],
			},
		],
		[
			"radiogroup",
			{
				props: ["aria-readonly", "aria-required"],
				requiredProps: [],
				superClassRole: ["range"],
			},
		],
		[
			"row",
			{
				props: ["aria-colindex", "aria-level", "aria-rowindex", "aria-selected"],
				requiredProps: [],
				superClassRole: ["group", "widget"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "tr",
						},
					},
				],
			},
		],
		[
			"rowgroup",
			{
				props: [],
				requiredProps: [],
				superClassRole: ["structure"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "tbody",
						},
					},
					{
						module: "HTML",
						concept: {
							name: "tfoot",
						},
					},
					{
						module: "HTML",
						concept: {
							name: "thead",
						},
					},
				],
			},
		],
		[
			"rowheader",
			{
				props: ["aria-sort"],
				requiredProps: [],
				superClassRole: ["cell", "gridcell", "sectionhead"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "th",
							attributes: [
								{
									name: "scope",
									value: "row",
								},
							],
						},
					},
				],
			},
		],
		[
			"searchbox",
			{
				props: [
					"aria-activedescendant",
					"aria-autocomplete",
					"aria-multiline",
					"aria-placeholder",
					"aria-readonly",
					"aria-required",
				],
				requiredProps: [],
				superClassRole: ["textbox"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "input",
							attributes: [
								{
									name: "type",
									value: "search",
								},
							],
						},
					},
				],
			},
		],
		[
			"tab",
			{
				props: ["aria-posinset", "aria-selected", "aria-setsize"],
				requiredProps: [],
				superClassRole: ["sectionhead", "widget"],
			},
		],
		[
			"table",
			{
				props: ["aria-colcount", "aria-rowcount"],
				requiredProps: [],
				superClassRole: ["section"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "table",
						},
					},
				],
			},
		],
		[
			"tablist",
			{
				props: ["aria-level", "aria-multiselectable", "aria-orientation"],
				requiredProps: [],
				superClassRole: ["composite"],
			},
		],
		[
			"term",
			{
				props: [],
				requiredProps: [],
				superClassRole: ["section"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "dt",
						},
					},
				],
			},
		],
		[
			"textbox",
			{
				props: [
					"aria-activedescendant",
					"aria-autocomplete",
					"aria-multiline",
					"aria-placeholder",
					"aria-readonly",
					"aria-required",
				],
				requiredProps: [],
				superClassRole: ["input"],
				baseConcepts: [
					{
						module: "HTML",
						concept: {
							name: "textarea",
						},
					},
					{
						module: "HTML",
						concept: {
							name: "input",
							attributes: [
								{
									name: "type",
									value: "text",
								},
							],
						},
					},
				],
			},
		],
		[
			"toolbar",
			{
				props: ["aria-orientation"],
				requiredProps: [],
				superClassRole: ["group"],
			},
		],
		[
			"tree",
			{
				props: ["aria-multiselectable", "aria-required"],
				requiredProps: [],
				superClassRole: ["select"],
			},
		],
	]);
	const ___R$project$rome$$internal$compiler$lint$utils$aria$ariaRolesMap_ts$default = ___R$$priv$project$rome$$internal$compiler$lint$utils$aria$ariaRolesMap_ts$ariaRolesMap;


  // project-rome/@internal/compiler/lint/utils/aria/elementsToConceptsMap.ts
const ___R$$priv$project$rome$$internal$compiler$lint$utils$aria$elementsToConceptsMap_ts$elementsToConceptsMap = new Map();

	for (const [, attributes] of ___R$project$rome$$internal$compiler$lint$utils$aria$ariaRolesMap_ts$default) {
		if (attributes.baseConcepts) {
			attributes.baseConcepts.forEach(({module, concept}) => {
				if (module === "HTML") {
					if (
						!___R$$priv$project$rome$$internal$compiler$lint$utils$aria$elementsToConceptsMap_ts$elementsToConceptsMap.has(
							concept.name,
						)
					) {
						___R$$priv$project$rome$$internal$compiler$lint$utils$aria$elementsToConceptsMap_ts$elementsToConceptsMap.set(
							concept.name,
							new Set(attributes.superClassRole),
						);
					}
				}
			});
		}
	}
	for (const [, attributes] of ___R$project$rome$$internal$compiler$lint$utils$aria$ariaRolesMap_ts$default) {
		if (attributes.baseConcepts) {
			attributes.baseConcepts.forEach(({module, concept}) => {
				if (module === "HTML") {
					if (
						!___R$$priv$project$rome$$internal$compiler$lint$utils$aria$elementsToConceptsMap_ts$elementsToConceptsMap.has(
							concept.name,
						)
					) {
						___R$$priv$project$rome$$internal$compiler$lint$utils$aria$elementsToConceptsMap_ts$elementsToConceptsMap.set(
							concept.name,
							new Set(attributes.superClassRole),
						);
					}
				}
			});
		}
	}
	const ___R$project$rome$$internal$compiler$lint$utils$aria$elementsToConceptsMap_ts$default = ___R$$priv$project$rome$$internal$compiler$lint$utils$aria$elementsToConceptsMap_ts$elementsToConceptsMap;


  // project-rome/@internal/compiler/lint/utils/aria/types.ts
const ___R$project$rome$$internal$compiler$lint$utils$aria$types_ts = {};


  // project-rome/@internal/compiler/lint/utils/aria/index.ts



  // project-rome/@internal/compiler/lint/rules/jsx-a11y/noAriaUnsupportedElements.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$noAriaUnsupportedElements_ts$hasAriaAttributes(
		node,
	) {
		const hasRole = ___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
			node,
			"role",
		);

		return (
			hasRole ||
			node.attributes.some((attr) =>
				attr.type === "JSXAttribute" &&
				attr.name.type === "JSXIdentifier" &&
				___R$project$rome$$internal$compiler$lint$utils$aria$ariaPropsMap_ts$default.has(
					(attr.name.name),
				)
			)
		);
	}
	const ___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$noAriaUnsupportedElements_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx-a11y/noAriaUnsupportedElements",
		enter(path) {
			const {node} = path;

			if (
				!(___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
					node,
					"meta",
				) ||
				___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
					node,
					"html",
				) ||
				___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
					node,
					"script",
				) ||
				___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
					node,
					"style",
				))
			) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
			}

			if (
				___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$noAriaUnsupportedElements_ts$hasAriaAttributes(
					node,
				)
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_ARIA_UNSUPPORTED_ELEMENTS,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx-a11y/noAutofocus.ts
const ___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$noAutofocus_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx-a11y/noAutofocus",

		enter(path) {
			const {node} = path;

			if (
				node.type === "JSXElement" &&
				___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
					node,
					"autoFocus",
				)
			) {
				return path.addFixableDiagnostic(
					{
						target: ___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
							node,
							"autoFocus",
						),
						fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
							Object.assign(
								{},
								node,
								{
									attributes: node.attributes.filter((attribute) =>
										attribute.type !== "JSXAttribute" ||
										attribute.name.name !== "autoFocus"
									),
								},
							),
						),
					},
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_NO_AUTOFOCUS,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx-a11y/noDistractingElements.ts
const ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$noDistractingElements_ts$DISTRACTING_TYPES = [
		"blink",
		"marquee",
	];
	const ___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$noDistractingElements_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx-a11y/noDistractingElements",

		enter(path) {
			const {node} = path;

			const distractingType =
				node.type === "JSXElement" &&
				___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$noDistractingElements_ts$DISTRACTING_TYPES.find((
					name,
				) =>
					___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
						node.name,
						name,
					)
				);

			if (distractingType) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_NO_DISTRACTING_ELEMENTS(
						distractingType,
					),
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx-a11y/noHeaderScope.ts
const ___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$noHeaderScope_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx-a11y/noHeaderScope",

		enter(path) {
			const {node} = path;

			if (
				node.type === "JSXElement" &&
				___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
					node,
					"scope",
				) &&
				!___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
					node.name,
					"th",
				)
			) {
				return path.addFixableDiagnostic(
					{
						fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
							Object.assign(
								{},
								node,
								{
									attributes: node.attributes.filter((attribute) =>
										attribute.type !== "JSXAttribute" ||
										attribute.name.name !== "scope"
									),
								},
							),
						),
					},
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_NO_SCOPE,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx-a11y/noNoninteractiveElementToInteractiveRole.ts
const ___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$noNoninteractiveElementToInteractiveRole_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx-a11y/noNoninteractiveElementToInteractiveRole",
		enter(path) {
			const {node} = path;

			if (
				node.type === "JSXElement" &&
				___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
					node,
					"role",
				)
			) {
				const name = ___R$project$rome$$internal$js$ast$utils$getJSXElementName_ts$getJSXElementName(
					node,
				);
				const roleAttribute = ___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
					node,
					"role",
				);
				if (
					roleAttribute &&
					roleAttribute.value &&
					roleAttribute.value.type === "JSStringLiteral"
				) {
					const role = ___R$project$rome$$internal$compiler$lint$utils$aria$ariaRolesMap_ts$default.get(
						roleAttribute.value.value,
					);
					if (role) {
						if (
							!___R$project$rome$$internal$compiler$lint$utils$aria$isElementInteractive_ts$default(
								name,
							) &&
							___R$project$rome$$internal$compiler$lint$utils$aria$isRoleInteractive_ts$default(
								role,
							)
						) {
							path.context.addNodeDiagnostic(
								roleAttribute,
								___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_NO_NONINTERACTIVE_ELEMENT_TO_INTERACTIVE_ROLE(
									name,
								),
							);
						}
					}
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx-a11y/noNoninteractiveTabindex.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$noNoninteractiveTabindex_ts$hasValidTabIndexValue(
		node,
	) {
		if (node && node.value && node.value.type === "JSStringLiteral") {
			const value = Number(node.value.value);
			if (value < 1) {
				return value;
			}
		}
		if (node && node.value && node.value.type === "JSXExpressionContainer") {
			const expression = node.value.expression;

			if (
				expression.type === "JSNumericLiteral" ||
				expression.type === "JSStringLiteral"
			) {
				const tabIndexValue = expression.value;
				if (Number(tabIndexValue) < 1) {
					return Number(tabIndexValue);
				}
			}

			// for tabIndex={-1}
			if (expression.type === "JSUnaryExpression") {
				return -1;
			}
		}

		return undefined;
	}
	const ___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$noNoninteractiveTabindex_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx-a11y/noNoninteractiveTabindex",
		enter(path) {
			const {node} = path;

			if (node.type === "JSXElement") {
				// it's a component, we don't know how the tabIndex is handled
				if (node.name && node.name.type === "JSXReferenceIdentifier") {
					return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
				}

				// not tabIndex, no worth continuing
				if (
					!___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
						node,
						"tabIndex",
					)
				) {
					return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
				}

				const tabIndexAttribute = ___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
					node,
					"tabIndex",
				);
				const tabIndexValue = ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$noNoninteractiveTabindex_ts$hasValidTabIndexValue(
					tabIndexAttribute,
				);
				if (tabIndexValue !== undefined) {
					const elementName = ___R$project$rome$$internal$js$ast$utils$getJSXElementName_ts$getJSXElementName(
						node,
					);
					/**
				 * Check if:
				 * 1. element doesn't have the role attribute
				 * 2. element is not interactive
				 *
				 * e.g. <div tabIndex="0"></div>
				 */
					if (
						!___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
							node,
							"role",
						)
					) {
						const elementToRole = ___R$project$rome$$internal$compiler$lint$utils$aria$elementsToConceptsMap_ts$default.get(
							elementName,
						);
						// the element is not part of any role, so it's an error
						// e.g. div, span, etc.
						if (elementToRole) {
							// not having the "widget" role means that the role is not interactive
							if (!elementToRole.has("widget") && tabIndexValue > -1) {
								path.context.addNodeDiagnostic(
									tabIndexAttribute,
									___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_NO_NONINTERACTIVE_TABINDEX,
								);
							}
						} else {
							/**
						 * Here we need to check the value of the index because
						 * <div tabIndex="-1" ></div>
						 * is a valid statement
						 */
							if (tabIndexValue > -1) {
								path.context.addNodeDiagnostic(
									tabIndexAttribute,
									___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_NO_NONINTERACTIVE_TABINDEX,
								);
							}
						}
					}
					const attr = ___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
						node,
						"role",
					);
					if (attr && attr.value && attr.value.type === "JSStringLiteral") {
						const role = ___R$project$rome$$internal$compiler$lint$utils$aria$ariaRolesMap_ts$default.get(
							attr.value.value,
						);
						if (role) {
							/**
						 * Some roles are not interactive (e.g. article),
						 * which means that they can have a tabIndex=-1 which removes the focus behaviour
						 *
						 * e.g. <article tabIndex="-1" /> is a valid statement
						 */
							if (
								!___R$project$rome$$internal$compiler$lint$utils$aria$isRoleInteractive_ts$default(
									role,
								) &&
								tabIndexValue > -1
							) {
								path.context.addNodeDiagnostic(
									attr,
									___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_NO_NONINTERACTIVE_TABINDEX,
								);
							}
						}
					}
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx-a11y/noOnChange.ts
const ___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$noOnChange_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx-a11y/noOnChange",
		enter(path) {
			const {context, node} = path;

			if (
				!___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
					node,
					"select",
				) &&
				!___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
					node,
					"option",
				)
			) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
			}

			if (
				!___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
					node,
					"onChange",
				)
			) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
			}

			if (
				___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
					node,
					"onBlur",
				)
			) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
			}

			context.addNodeDiagnostic(
				___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
					node,
					"onChange",
				),
				___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_NO_ON_CHANGE,
			);

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx-a11y/noPositiveTabindex.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$noPositiveTabindex_ts$createDiagnostic(
		path,
		node,
		attribute,
	) {
		return path.addFixableDiagnostic(
			{
				target: attribute,
				fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
					Object.assign(
						{},
						node,
						{
							attributes: node.attributes.filter((attribute) =>
								attribute.type !== "JSXAttribute" ||
								attribute.name.name !== "tabIndex"
							),
						},
					),
				),
			},
			___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_TABINDEX_NO_POSITIVE,
		);
	}
	const ___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$noPositiveTabindex_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx-a11y/noPositiveTabindex",
		enter(path) {
			const {node} = path;

			if (
				node.type === "JSXElement" &&
				___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
					node,
					"tabIndex",
				)
			) {
				const attribute = ___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
					node,
					"tabIndex",
				);
				if (
					attribute &&
					attribute.value &&
					attribute.value.type === "JSStringLiteral"
				) {
					const tabIndexValue = attribute.value.value;
					if (Number(tabIndexValue) > 0) {
						___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$noPositiveTabindex_ts$createDiagnostic(
							path,
							node,
							attribute,
						);
					}
				}

				if (
					attribute &&
					attribute.value &&
					attribute.value.type === "JSXExpressionContainer"
				) {
					const expression = attribute.value.expression;
					if (
						expression.type === "JSNumericLiteral" ||
						expression.type === "JSStringLiteral"
					) {
						const tabIndexValue = expression.value;
						if (Number(tabIndexValue) > 0) {
							___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$noPositiveTabindex_ts$createDiagnostic(
								path,
								node,
								attribute,
							);
						}
					}
				}
			}
			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx-a11y/noRedundantAlt.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$noRedundantAlt_ts$jsxImgRedundantAlt(
		node,
	) {
		if (
			!___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
				node,
				"img",
			)
		) {
			return false;
		}

		const attr = ___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
			node,
			"alt",
		);
		return (
			attr !== undefined &&
			attr.value &&
			attr.value.type === "JSStringLiteral" &&
			/(image)|(picture)|(photo)/i.test(attr.value.value)
		);
	}
	const ___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$noRedundantAlt_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx-a11y/noRedundantAlt",

		enter(path) {
			const {node} = path;

			if (
				___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$noRedundantAlt_ts$jsxImgRedundantAlt(
					node,
				)
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_IMG_REDUNDANT_ALT,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx-a11y/noRedundantRoles.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$noRedundantRoles_ts$createFixableDiagnostic(
		{path, node, mappedRole, roleAttribute, elementName, roleName},
	) {
		let ariaAttributesToRemove = [];
		if (mappedRole) {
			// here we retrieve the aria-* attributes that are not needed
			// e.g. role="heading" aria-level="1"
			ariaAttributesToRemove = mappedRole.requiredProps.reduce(
				(nodes, prop) => {
					const attr = ___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
						node,
						(prop),
					);
					if (attr) {
						nodes.push(attr);
					}
					return nodes;
				},
				([]),
			);
		}
		const titleSuggestion =
			ariaAttributesToRemove.length > 0
				? ___R$project$rome$$internal$markup$escape_ts$markup`Remove the role attribute and ARIA attributes.`
				: ___R$project$rome$$internal$markup$escape_ts$markup`Remove the role attribute.`;

		const fixed = Object.assign(
			{},
			node,
			{
				attributes: node.attributes.filter((attr) => {
					return attr.type === "JSXAttribute" && attr.name.name !== "role";
				}).filter((attr) => {
					if (attr.type === "JSXAttribute") {
						if (mappedRole) {
							return (
								attr.type === "JSXAttribute" &&
								!mappedRole.requiredProps.includes((attr.name.name))
							);
						}
						return attr.name.name !== "role";
					}

					return true;
				}),
			},
		);

		return path.addFixableDiagnostic(
			{
				target: [roleAttribute, ...ariaAttributesToRemove],
				suggestions: [
					{
						title: titleSuggestion,
						description: ___R$project$rome$$internal$markup$escape_ts$markup``,
						fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
							fixed,
						),
					},
				],
			},
			___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_NO_REDUNDANT_ROLES(
				roleName,
				elementName,
			),
		);
	}
	const ___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$noRedundantRoles_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx-a11y/noRedundantRoles",
		enter(path) {
			const {node} = path;

			if (
				node.type === "JSXElement" &&
				___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
					node,
					"role",
				)
			) {
				const elementName = ___R$project$rome$$internal$js$ast$utils$getJSXElementName_ts$getJSXElementName(
					node,
				);

				const roleAttribute = ___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
					node,
					"role",
				);
				if (
					roleAttribute &&
					roleAttribute.value &&
					roleAttribute.value.type === "JSStringLiteral"
				) {
					let elementHasARole;

					const mappedRole = ___R$project$rome$$internal$compiler$lint$utils$aria$ariaRolesMap_ts$default.get(
						roleAttribute.value.value,
					);
					// here we cover cases where "role" attribute and the element name differs in naming
					// e.g. h1 and role="heading"
					if (mappedRole && mappedRole.baseConcepts) {
						elementHasARole = mappedRole.baseConcepts.some(({concept, module}) => {
							if (module === "HTML") {
								// here we should also match additional attributes
								// e.g. role="checkbox" <=> <input type="checkbox" />
								if (concept.attributes) {
									return concept.attributes.every(({name, value}) => {
										const attr = ___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
											node,
											name,
										);
										return (
											attr &&
											attr.value &&
											attr.value.type === "JSStringLiteral" &&
											attr.value.value === value
										);
									});
								} else {
									return concept.name === elementName;
								}
							}
							return true;
						});
					}

					if (elementName === roleAttribute.value.value || elementHasARole) {
						___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$noRedundantRoles_ts$createFixableDiagnostic({
							roleAttribute,
							node,
							path,
							mappedRole,
							elementName,
							roleName: roleAttribute.value.value,
						});
					}
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx-a11y/noTargetBlank.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$noTargetBlank_ts$jsxAnchorHasBlankTarget(
		node,
	) {
		return (
			___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
				node,
				"a",
			) &&
			node.attributes.some((attribute) =>
				attribute.type === "JSXAttribute" &&
				attribute.name.name === "target" &&
				attribute.value &&
				attribute.value.type === "JSStringLiteral" &&
				attribute.value.value === "_blank"
			)
		);
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$noTargetBlank_ts$jsxAnchorHasNoReferrer(
		node,
	) {
		return (
			___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
				node,
				"a",
			) &&
			node.attributes.some((attribute) =>
				attribute.type === "JSXAttribute" &&
				attribute.name.name === "rel" &&
				attribute.value &&
				attribute.value.type === "JSStringLiteral" &&
				attribute.value.value.includes("noreferrer")
			)
		);
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$noTargetBlank_ts$jsxAnchorHasExternalLink(
		node,
	) {
		return (
			___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
				node,
				"a",
			) &&
			node.attributes.some((attribute) =>
				attribute.type === "JSXAttribute" &&
				attribute.name.name === "href" &&
				attribute.value &&
				((attribute.value.type === "JSStringLiteral" &&
				/^(?:\w+:|\/\/)/.test(attribute.value.value)) ||
				attribute.value.type === "JSXExpressionContainer")
			)
		);
	}
	const ___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$noTargetBlank_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx-a11y/noTargetBlank",

		enter(path) {
			const {node} = path;

			if (
				node.type === "JSXElement" &&
				___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$noTargetBlank_ts$jsxAnchorHasBlankTarget(
					node,
				) &&
				!___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$noTargetBlank_ts$jsxAnchorHasNoReferrer(
					node,
				) &&
				___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$noTargetBlank_ts$jsxAnchorHasExternalLink(
					node,
				)
			) {
				return path.addFixableDiagnostic(
					{
						target: ___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
							node,
							"target",
						),
						fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
							Object.assign(
								{},
								node,
								{
									attributes: node.attributes.filter((attribute) =>
										attribute.type !== "JSXAttribute" ||
										attribute.name.name !== "target"
									),
								},
							),
						),
					},
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_NO_TARGET_BLANK,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx-a11y/useAltText.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useAltText_ts$hasImgAltText(
		node,
	) {
		const attr = ___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
			node,
			"alt",
			true,
		);
		if (attr === undefined) {
			return false;
		}
		return (
			(attr.value &&
			attr.value.type === "JSStringLiteral" &&
			attr.value.value === "") ||
			___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
				node,
				"alt",
			)
		);
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useAltText_ts$hasObjectAltText(
		node,
	) {
		return (
			___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
				node,
				"aria-label",
			) ||
			___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
				node,
				"aria-labelledby",
			) ||
			___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
				node,
				"title",
			) ||
			node.children.length > 0
		);
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useAltText_ts$hasAreaAltText(
		node,
	) {
		return (
			___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
				node,
				"aria-label",
			) ||
			___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
				node,
				"aria-labelledby",
			) ||
			___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
				node,
				"alt",
			) ||
			___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
				node,
				"title",
			)
		);
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useAltText_ts$hasInputAltText(
		node,
	) {
		return (
			___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
				node,
				"aria-label",
			) ||
			___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
				node,
				"aria-labelledby",
			) ||
			___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
				node,
				"alt",
			) ||
			___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
				node,
				"title",
			)
		);
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useAltText_ts$hasTypeImage(
		node,
	) {
		const attr = ___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
			node,
			"type",
		);
		if (attr === undefined) {
			return false;
		}
		return (
			attr.value !== undefined &&
			attr.value.type === "JSStringLiteral" &&
			attr.value.value === "image"
		);
	}
	const ___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$useAltText_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx-a11y/useAltText",
		enter(path) {
			const {node} = path;

			if (node.type === "JSXElement" && node.name.type === "JSXIdentifier") {
				if (!/(img)|(area)|(input)|(object)/.test(node.name.name)) {
					return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
				}

				if (
					(___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
						node,
						"img",
					) &&
					!___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useAltText_ts$hasImgAltText(
						node,
					)) ||
					(___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
						node,
						"object",
					) &&
					!___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useAltText_ts$hasObjectAltText(
						node,
					)) ||
					(___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
						node,
						"area",
					) &&
					!___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useAltText_ts$hasAreaAltText(
						node,
					)) ||
					(___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
						node,
						"input",
					) &&
					___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useAltText_ts$hasTypeImage(
						node,
					) &&
					!___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useAltText_ts$hasInputAltText(
						node,
					))
				) {
					path.context.addNodeDiagnostic(
						node,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_ALT_TEXT,
					);
				}
			}
			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx-a11y/useAnchorContent.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useAnchorContent_ts$hasAnchorContent(
		node,
	) {
		return (
			___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
				node,
				"dangerouslySetInnerHTML",
			) ||
			(node.children.length > 0 &&
			node.children.some((child) =>
				child.type !== "JSXElement" ||
				!___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
					child,
					"aria-hidden",
				)
			))
		);
	}
	const ___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$useAnchorContent_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx-a11y/useAnchorContent",
		enter(path) {
			const {node} = path;

			if (
				___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
					node,
					"a",
				) &&
				!___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useAnchorContent_ts$hasAnchorContent(
					node,
				)
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_ANCHOR_HAS_CONTENT,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx-a11y/useAriaProps.ts
const ___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$useAriaProps_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx-a11y/useAriaProps",
		enter(path) {
			const {node, context} = path;

			if (
				node.type === "JSXAttribute" &&
				node.name.type === "JSXIdentifier" &&
				node.name.name.indexOf("aria-") === 0
			) {
				const ariaPropsArray = Array.from(
					___R$project$rome$$internal$compiler$lint$utils$aria$ariaPropsMap_ts$default,
				).map((ariaProps) => ariaProps[0]);

				const closestMatch = ___R$project$rome$$internal$string$utils$findClosestStringMatch_ts$findClosestStringMatch(
					node.name.name,
					ariaPropsArray,
				);

				let fixed;
				if (closestMatch !== undefined) {
					fixed = Object.assign(
						{},
						node,
						{
							name: Object.assign(
								{},
								node.name,
								{
									// React Documentation states that ariaProps should be in kebab-case, not camelCase:
									// https://reactjs.org/docs/accessibility.html#wai-aria
									name: ___R$project$rome$$internal$string$utils$toKebabCase_ts$toKebabCase(
										closestMatch,
									),
								},
							),
						},
					);
				}

				const isInvalidAriaProperty = !ariaPropsArray.includes((node.name.name));
				if (fixed !== undefined && isInvalidAriaProperty) {
					return path.addFixableDiagnostic(
						{
							suggestions: [
								{
									title: ___R$project$rome$$internal$markup$escape_ts$markup`ARIA Spelling Mistake`,
									description: ___R$project$rome$$internal$markup$escape_ts$markup``,
									fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
										fixed,
									),
								},
							],
						},
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_ARIA_PROPS(
							node.name.name,
						),
					);
				} else if (isInvalidAriaProperty) {
					context.addNodeDiagnostic(
						node,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_ARIA_PROPS(
							node.name.name,
						),
					);
				}
			}
			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx-a11y/useAriaPropsForRole.ts
const ___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$useAriaPropsForRole_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx-a11y/useAriaPropsForRole",
		enter(path) {
			const {node} = path;

			if (
				node.type === "JSXElement" &&
				___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
					node,
					"role",
				)
			) {
				const attr = ___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
					node,
					"role",
				);
				if (attr && attr.value && attr.value.type === "JSStringLiteral") {
					const role = ___R$project$rome$$internal$compiler$lint$utils$aria$ariaRolesMap_ts$default.get(
						attr.value.value,
					);
					if (role) {
						const hasAllProps = role.requiredProps.every((prop) => {
							return ___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
								node,
								prop,
							);
						});

						if (!hasAllProps) {
							const missingProps = role.requiredProps.map((prop) => {
								const attr = ___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
									node,
									prop,
								);
								if (!attr) {
									return prop;
								}
								return "";
							}).filter(Boolean);
							path.context.addNodeDiagnostic(
								node,
								___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_ROLE_HAS_REQUIRED_ARIA_PROPS(
									attr.value.value,
									missingProps,
								),
							);
						}
					}
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx-a11y/useAriaProptypes.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useAriaProptypes_ts$isCorrectValue(
		attribute,
		value,
	) {
		switch (attribute.type) {
			case "boolean": {
				if (typeof value === "string") {
					return value === "false" || value === "true";
				}
				return typeof value === "boolean";
			}

			case "id":
			case "string":
				return typeof value === "string";

			case "tristate": {
				if (typeof value === "string") {
					return value === "false" || value === "true" || value === "mixed";
				}
				if (typeof value === "boolean") {
					return Boolean(value);
				}
				return false;
			}
			case "token": {
				if (attribute.values) {
					return attribute.values.some((token) => {
						if (typeof token === "boolean") {
							if (typeof value === "string") {
								return value === "true" || value === "false";
							}
							return Boolean(value) === token;
						}
						return typeof value === "string" ? value === token : value === token;
					});
				}
				return false;
			}

			case "idlist": {
				return (
					typeof value === "string" &&
					value.split(" ").every((token) => typeof token === "string")
				);
			}

			case "integer":
			case "number":
				return typeof value !== "boolean" && isNaN(Number(value)) === false;

			case "tokenlist": {
				if (attribute.values) {
					return (
						typeof value === "string" &&
						value.split(" ").every((token) => {
							return (
								attribute.values &&
								attribute.values.indexOf(token.toLowerCase()) > -1
							);
						})
					);
				}
				return false;
			}

			default:
				return false;
		}
	}
	const ___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$useAriaProptypes_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx-a11y/useAriaProptypes",
		enter(path) {
			const {node} = path;

			if (node.type === "JSXAttribute") {
				if (
					node.name.type === "JSXIdentifier" &&
					node.name.name.indexOf("aria-") === 0
				) {
					if (node.value) {
						const ariaAttribute = ___R$project$rome$$internal$compiler$lint$utils$aria$ariaPropsMap_ts$default.get(
							(node.name.name),
						);
						if (ariaAttribute) {
							if (node.value.type === "JSStringLiteral") {
								if (
									node.value.value === "" ||
									!___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useAriaProptypes_ts$isCorrectValue(
										ariaAttribute,
										node.value.value,
									)
								) {
									path.context.addNodeDiagnostic(
										node,
										___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_ARIA_PROPTYPES(
											node.name.name,
											ariaAttribute.values,
										),
									);
								}
							}

							if (node.value.type === "JSXExpressionContainer") {
								const expression = node.value.expression;

								if (
									expression.type === "JSBooleanLiteral" ||
									expression.type === "JSNumericLiteral"
								) {
									if (
										!___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useAriaProptypes_ts$isCorrectValue(
											ariaAttribute,
											expression.value,
										)
									) {
										path.context.addNodeDiagnostic(
											node,
											___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_ARIA_PROPTYPES(
												node.name.name,
												ariaAttribute.values,
											),
										);
									}
								} else if (expression.type === "JSTemplateLiteral") {
									if (
										___R$project$rome$$internal$js$ast$utils$isEmptyTemplateLiteral_ts$isEmptyTemplateLiteral(
											expression,
										)
									) {
										path.context.addNodeDiagnostic(
											node,
											___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_ARIA_PROPTYPES(
												node.name.name,
												ariaAttribute.values,
											),
										);
									}
								}
							}
						}
					}
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx-a11y/useHeadingContent.ts
const ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useHeadingContent_ts$HEADINGS = [
		"h1",
		"h2",
		"h3",
		"h4",
		"h5",
		"h6",
	];

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useHeadingContent_ts$hasHeadingContent(
		node,
	) {
		if (
			!___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useHeadingContent_ts$HEADINGS.some((
				heading,
			) =>
				___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
					node,
					heading,
				)
			)
		) {
			return false;
		}
		return (
			___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
				node,
				"dangerouslySetInnerHTML",
			) ||
			(node.children.length > 0 &&
			node.children.some((child) =>
				child.type !== "JSXElement" ||
				!___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
					child,
					"aria-hidden",
				)
			))
		);
	}
	const ___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$useHeadingContent_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx-a11y/useHeadingContent",
		enter(path) {
			const {node} = path;

			if (
				___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useHeadingContent_ts$HEADINGS.some((
					heading,
				) =>
					___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
						node,
						heading,
					)
				) &&
				!___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useHeadingContent_ts$hasHeadingContent(
					(node),
				)
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_HEADING_HAS_CONTENT,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx-a11y/useHtmlLang.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useHtmlLang_ts$validLang(
		node,
	) {
		if (
			___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
				node,
				"lang",
			)
		) {
			const attr = ___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
				node,
				"lang",
			);
			if (attr && attr.value) {
				if (attr.value.type === "JSXExpressionContainer") {
					const expression = attr.value.expression;
					if (expression.type === "JSTemplateLiteral") {
						return !___R$project$rome$$internal$js$ast$utils$isEmptyTemplateLiteral_ts$isEmptyTemplateLiteral(
							expression,
						);
					}
					return (
						expression.type !== "JSNumericLiteral" &&
						expression.type !== "JSBooleanLiteral"
					);
				} else if (attr.value.type === "JSStringLiteral") {
					return true;
				}
				return false;
			}
		}
		return false;
	}
	const ___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$useHtmlLang_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx-a11y/useHtmlLang",

		enter(path) {
			const {node} = path;
			if (
				___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
					node,
					"html",
				)
			) {
				if (
					!___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
						node,
						"lang",
					) ||
					!___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useHtmlLang_ts$validLang(
						node,
					)
				) {
					path.context.addNodeDiagnostic(
						node,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_HTML_HAS_LANG,
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx-a11y/useIframeTitle.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useIframeTitle_ts$validTitle(
		node,
	) {
		if (
			___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
				node,
				"title",
			)
		) {
			const attr = ___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
				node,
				"title",
			);
			if (attr && attr.value) {
				if (attr.value.type === "JSXExpressionContainer") {
					const expression = attr.value.expression;
					if (expression.type === "JSTemplateLiteral") {
						return !___R$project$rome$$internal$js$ast$utils$isEmptyTemplateLiteral_ts$isEmptyTemplateLiteral(
							expression,
						);
					}
					return (
						expression.type !== "JSNumericLiteral" &&
						expression.type !== "JSBooleanLiteral"
					);
				} else if (attr.value.type === "JSStringLiteral") {
					return attr.value.value !== "";
				}
				return false;
			}
		}
		return false;
	}
	const ___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$useIframeTitle_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx-a11y/useIframeTitle",

		enter(path) {
			const {node} = path;
			if (
				___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
					node,
					"iframe",
				)
			) {
				if (
					!___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
						node,
						"title",
					) ||
					!___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useIframeTitle_ts$validTitle(
						node,
					)
				) {
					path.context.addNodeDiagnostic(
						node,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_IFRAME_HAS_TITLE,
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx-a11y/useKeyWithClickEvents.ts
const ___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$useKeyWithClickEvents_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx-a11y/useKeyWithClickEvents",
		enter(path) {
			const {node} = path;

			if (
				node.type === "JSXElement" &&
				___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
					node,
					"onClick",
				) &&
				!(___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
					node,
					"onKeyUp",
				) ||
				___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
					node,
					"onKeyDown",
				) ||
				___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
					node,
					"onKeyPress",
				))
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_CLICK_EVENTS_HAVE_KEY_EVENTS,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx-a11y/useKeyWithMouseEvents.ts
const ___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$useKeyWithMouseEvents_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx-a11y/useKeyWithMouseEvents",
		enter(path) {
			const {node} = path;

			if (node.type === "JSXElement") {
				if (
					___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
						node,
						"onMouseOver",
					) &&
					!___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
						node,
						"onFocus",
					)
				) {
					path.context.addNodeDiagnostic(
						___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
							node,
							"onMouseOver",
						),
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_MOUSE_EVENTS_HAVE_KEY_EVENTS(
							"onMouseOver",
							"onFocus",
						),
					);
				}

				if (
					___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
						node,
						"onMouseOut",
					) &&
					!___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
						node,
						"onBlur",
					)
				) {
					path.context.addNodeDiagnostic(
						___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
							node,
							"onMouseOut",
						),
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_MOUSE_EVENTS_HAVE_KEY_EVENTS(
							"onMouseOut",
							"onBlur",
						),
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx-a11y/useMediaCaption.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useMediaCaption_ts$hasMuted(
		node,
	) {
		return ___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
			node,
			"muted",
		);
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useMediaCaption_ts$hasTrack(
		node,
	) {
		return node.children.some((child) =>
			___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
				child,
				"track",
			)
		);
	}
	const ___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$useMediaCaption_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx-a11y/useMediaCaption",
		enter(path) {
			const {node} = path;

			if (
				!(___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
					node,
					"video",
				) ||
				___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
					node,
					"audio",
				))
			) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
			}

			if (
				___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
					node,
					"video",
				) &&
				___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useMediaCaption_ts$hasMuted(
					node,
				)
			) {
				return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
			}

			if (
				!___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useMediaCaption_ts$hasTrack(
					node,
				)
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_MEDIA_HAS_CAPTION,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx-a11y/useValidAnchor.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidAnchor_ts$hrefValue(
		attr,
		value,
	) {
		if (attr === undefined) {
			return false;
		}
		return (
			(((attr == null ? undefined : attr.value) == null
				? undefined
				: (attr == null ? undefined : attr.value).type) === "JSStringLiteral" &&
			attr.value.value === value) ||
			(((attr == null ? undefined : attr.value) == null
				? undefined
				: (attr == null ? undefined : attr.value).type) ===
			"JSXExpressionContainer" &&
			attr.value.expression.type === "JSStringLiteral" &&
			attr.value.expression.value === value) ||
			(((attr == null ? undefined : attr.value) == null
				? undefined
				: (attr == null ? undefined : attr.value).type) ===
			"JSXExpressionContainer" &&
			attr.value.expression.type === "JSTemplateLiteral" &&
			attr.value.expression.quasis.some((element) => element.raw === value))
		);
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidAnchor_ts$falsyHref(
		attr,
	) {
		return (
			attr === undefined ||
			((attr.value == null ? undefined : attr.value.type) ===
			"JSXExpressionContainer" &&
			attr.value.expression.type === "JSNullLiteral")
		);
	}
	const ___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidAnchor_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx-a11y/useValidAnchor",
		enter(path) {
			const {node} = path;

			if (
				___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
					node,
					"a",
				)
			) {
				const attr = ___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
					node,
					"href",
				);

				if (
					___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidAnchor_ts$falsyHref(
						attr,
					) &&
					!___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
						node,
						"onClick",
					)
				) {
					path.context.addNodeDiagnostic(
						node,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_ANCHOR_IS_VALID(
							___R$project$rome$$internal$markup$escape_ts$markup`Provide a <emphasis>href</emphasis> attribute for the <emphasis>a</emphasis> element.`,
						),
					);
				}

				if (
					attr &&
					!___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
						node,
						"onClick",
					)
				) {
					if (
						___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidAnchor_ts$hrefValue(
							attr,
							"#",
						) ||
						___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidAnchor_ts$hrefValue(
							attr,
							"javascript:void(0)",
						)
					) {
						path.context.addNodeDiagnostic(
							node,
							___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_ANCHOR_IS_VALID(
								___R$project$rome$$internal$markup$escape_ts$markup`Provide a valid <emphasis>href</emphasis> attribute for the <emphasis>a</emphasis> element.`,
							),
						);
					}
				}

				if (
					(___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
						node,
						"onClick",
					) &&
					!___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
						node,
						"href",
					)) ||
					(___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
						node,
						"href",
					) &&
					___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidAnchor_ts$hrefValue(
						attr,
						"#",
					)) ||
					___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidAnchor_ts$hrefValue(
						attr,
						"javascript:void(0)",
					)
				) {
					path.context.addNodeDiagnostic(
						node,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_ANCHOR_IS_VALID(
							___R$project$rome$$internal$markup$escape_ts$markup`Use a <emphasis>button</emphasis> element instead of an <emphasis>a</emphasis> element.`,
						),
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx-a11y/useValidLang.ts
const ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidLang_ts$ISO = {
		countries: [
			"AF",
			"AL",
			"DZ",
			"AS",
			"AD",
			"AO",
			"AI",
			"AQ",
			"AG",
			"AR",
			"AM",
			"AW",
			"AU",
			"AT",
			"AZ",
			"BS",
			"BH",
			"BD",
			"BB",
			"BY",
			"BE",
			"BZ",
			"BJ",
			"BM",
			"BT",
			"BO",
			"BA",
			"BW",
			"BR",
			"IO",
			"VG",
			"BN",
			"BG",
			"BF",
			"MM",
			"BI",
			"KH",
			"CM",
			"CA",
			"CV",
			"KY",
			"CF",
			"TD",
			"CL",
			"CN",
			"CX",
			"CC",
			"CO",
			"KM",
			"CK",
			"CR",
			"HR",
			"CU",
			"CY",
			"CZ",
			"CD",
			"DK",
			"DJ",
			"DM",
			"DO",
			"EC",
			"EG",
			"SV",
			"GQ",
			"ER",
			"EE",
			"ET",
			"FK",
			"FO",
			"FJ",
			"FI",
			"FR",
			"PF",
			"GA",
			"GM",
			"GE",
			"DE",
			"GH",
			"GI",
			"GR",
			"GL",
			"GD",
			"GU",
			"GT",
			"GN",
			"GW",
			"GY",
			"HT",
			"VA",
			"HN",
			"HK",
			"HU",
			"IS",
			"IN",
			"ID",
			"IR",
			"IQ",
			"IE",
			"IM",
			"IL",
			"IT",
			"CI",
			"JM",
			"JP",
			"JE",
			"JO",
			"KZ",
			"KE",
			"KI",
			"KW",
			"KG",
			"LA",
			"LV",
			"LB",
			"LS",
			"LR",
			"LY",
			"LI",
			"LT",
			"LU",
			"MO",
			"MK",
			"MG",
			"MW",
			"MY",
			"MV",
			"ML",
			"MT",
			"MH",
			"MR",
			"MU",
			"YT",
			"MX",
			"FM",
			"MD",
			"MC",
			"MN",
			"ME",
			"MS",
			"MA",
			"MZ",
			"NA",
			"NR",
			"NP",
			"NL",
			"AN",
			"NC",
			"NZ",
			"NI",
			"NE",
			"NG",
			"NU",
			"KP",
			"MP",
			"NO",
			"OM",
			"PK",
			"PW",
			"PA",
			"PG",
			"PY",
			"PE",
			"PH",
			"PN",
			"PL",
			"PT",
			"PR",
			"QA",
			"CG",
			"RO",
			"RU",
			"RW",
			"BL",
			"SH",
			"KN",
			"LC",
			"MF",
			"PM",
			"VC",
			"WS",
			"SM",
			"ST",
			"SA",
			"SN",
			"RS",
			"SC",
			"SL",
			"SG",
			"SK",
			"SI",
			"SB",
			"SO",
			"ZA",
			"KR",
			"ES",
			"LK",
			"SD",
			"SR",
			"SJ",
			"SZ",
			"SE",
			"CH",
			"SY",
			"TW",
			"TJ",
			"TZ",
			"TH",
			"TL",
			"TG",
			"TK",
			"TO",
			"TT",
			"TN",
			"TR",
			"TM",
			"TC",
			"TV",
			"UG",
			"UA",
			"AE",
			"GB",
			"US",
			"UY",
			"VI",
			"UZ",
			"VU",
			"VE",
			"VN",
			"WF",
			"EH",
			"YE",
			"ZM",
			"ZW",
		],
		languages: [
			"ab",
			"aa",
			"af",
			"sq",
			"am",
			"ar",
			"an",
			"hy",
			"as",
			"ay",
			"az",
			"ba",
			"eu",
			"bn",
			"dz",
			"bh",
			"bi",
			"br",
			"bg",
			"my",
			"be",
			"km",
			"ca",
			"zh",
			"zh-Hans",
			"zh-Hant",
			"co",
			"hr",
			"cs",
			"da",
			"nl",
			"en",
			"eo",
			"et",
			"fo",
			"fa",
			"fj",
			"fi",
			"fr",
			"fy",
			"gl",
			"gd",
			"gv",
			"ka",
			"de",
			"el",
			"kl",
			"gn",
			"gu",
			"ht",
			"ha",
			"he",
			"iw",
			"hi",
			"hu",
			"is",
			"io",
			"id",
			"in",
			"ia",
			"ie",
			"iu",
			"ik",
			"ga",
			"it",
			"ja",
			"jv",
			"kn",
			"ks",
			"kk",
			"rw",
			"ky",
			"rn",
			"ko",
			"ku",
			"lo",
			"la",
			"lv",
			"li",
			"ln",
			"lt",
			"mk",
			"mg",
			"ms",
			"ml",
			"mt",
			"mi",
			"mr",
			"mo",
			"mn",
			"na",
			"ne",
			"no",
			"oc",
			"or",
			"om",
			"ps",
			"pl",
			"pt",
			"pa",
			"qu",
			"rm",
			"ro",
			"ru",
			"sm",
			"sg",
			"sa",
			"sr",
			"sh",
			"st",
			"tn",
			"sn",
			"ii",
			"sd",
			"si",
			"ss",
			"sk",
			"sl",
			"so",
			"es",
			"su",
			"sw",
			"sv",
			"tl",
			"tg",
			"ta",
			"tt",
			"te",
			"th",
			"bo",
			"ti",
			"to",
			"ts",
			"tr",
			"tk",
			"tw",
			"ug",
			"uk",
			"ur",
			"uz",
			"vi",
			"vo",
			"wa",
			"cy",
			"wo",
			"xh",
			"yi",
			"ji",
			"yo",
			"zu",
		],
	};

	// We lazily build this suggestions list as it is massive
	let ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidLang_ts$suggestions;
	function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidLang_ts$getSuggestions() {
		if (
			___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidLang_ts$suggestions !==
			undefined
		) {
			return ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidLang_ts$suggestions;
		}

		___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidLang_ts$suggestions = [
			...___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidLang_ts$ISO.countries,
		];

		for (const language of ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidLang_ts$ISO.languages) {
			for (const country of ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidLang_ts$ISO.countries) {
				___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidLang_ts$suggestions.push(
					language + "-" + country,
				);
			}
		}

		return ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidLang_ts$suggestions;
	}

	// Will return the attribute value if invalid
	function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidLang_ts$jsxSupportedLang(
		node,
	) {
		const attr = ___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
			node,
			"lang",
		);

		if (!attr || !attr.value) {
			return "undefined";
		}

		if (attr.value.type === "JSStringLiteral") {
			const {value} = attr.value;
			if (
				!___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidLang_ts$langSupported(
					value,
				)
			) {
				return value;
			}
		}

		return undefined;
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidLang_ts$langSupported(
		lang,
	) {
		const [language, country] = lang.split("-");

		if (language && country) {
			return (
				___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidLang_ts$ISO.languages.includes(
					language,
				) &&
				___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidLang_ts$ISO.countries.includes(
					country,
				)
			);
		}

		if (language) {
			return ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidLang_ts$ISO.languages.includes(
				language,
			);
		}

		return false;
	}
	const ___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidLang_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx-a11y/useValidLang",
		enter(path) {
			const {node} = path;

			if (
				___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
					node,
					"html",
				) &&
				___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
					node,
					"lang",
				)
			) {
				const invalidValue = ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidLang_ts$jsxSupportedLang(
					node,
				);
				if (invalidValue !== undefined) {
					// TODO add an autofix suggestion
					path.context.addNodeDiagnostic(
						___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
							node,
							"lang",
						),
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_A11Y_LANG(
							invalidValue,
							___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidLang_ts$getSuggestions(),
						),
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx/noCommentText.ts
const ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$noCommentText_ts$commentPattern = /(^(\/\*\*|\/\*|\/\/)|\*\/$)/gm;
	const ___R$project$rome$$internal$compiler$lint$rules$jsx$noCommentText_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx/noCommentText",
		enter(path) {
			const {node} = path;

			if (node.type === "JSXText") {
				if (
					___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$noCommentText_ts$commentPattern.test(
						node.value,
					)
				) {
					path.addFixableDiagnostic(
						{
							fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
								Object.assign(
									{},
									node,
									{
										// TODO: This is exploiting JSXText and should be using properly create an expression container
										// and inject the comment
										value: "{/**" +
										node.value.replace(
											___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$noCommentText_ts$commentPattern,
											"",
										) +
										"*/}",
									},
								),
							),
						},
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_NO_COMMENT_TEXT,
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx/noDuplicateProps.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$noDuplicateProps_ts$getAttributeKey(
		node,
	) {
		const name = node.name.name;
		return typeof name === "string" ? name : name.name;
	}
	const ___R$project$rome$$internal$compiler$lint$rules$jsx$noDuplicateProps_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx/noDuplicateProps",

		enter(path) {
			const {context, node} = path;

			if (node.type !== "JSXElement") {
				return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
			}

			const duplicates = new ___R$project$rome$$internal$compiler$lib$DiagnosticsDuplicateHelper_ts$DiagnosticsDuplicateHelper(
				context,
				___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_NO_DUPLICATE_PROPS,
			);

			for (const attr of node.attributes) {
				if (attr.type === "JSXAttribute") {
					duplicates.addLocation(
						___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$noDuplicateProps_ts$getAttributeKey(
							attr,
						),
						attr.loc,
					);
				}
			}

			duplicates.process();

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx/noImplicitBoolean.ts
const ___R$project$rome$$internal$compiler$lint$rules$jsx$noImplicitBoolean_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx/noImplicitBoolean",
		enter(path) {
			const {node} = path;

			if (node.type === "JSXAttribute" && !node.value) {
				return path.addFixableDiagnostic(
					{
						fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
							Object.assign(
								{},
								node,
								{
									value: ___R$project$rome$$internal$ast$js$jsx$JSXExpressionContainer_ts$jsxExpressionContainer.create({
										expression: ___R$project$rome$$internal$ast$js$literals$JSBooleanLiteral_ts$jsBooleanLiteral.quick(
											true,
										),
									}),
								},
							),
						),
					},
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_NO_IMPLICIT_BOOLEAN,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx/noPropSpreading.ts
const ___R$project$rome$$internal$compiler$lint$rules$jsx$noPropSpreading_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx/noPropSpreading",
		enter(path) {
			const {node} = path;

			if (node.type === "JSXSpreadAttribute") {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_NO_PROP_SPREADING,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx/useJSXFileExtension.ts
const ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$useJSXFileExtension_ts$JSX_FILE_EXTENSIONS = [
		"jsx",
		"tsx",
	];

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$useJSXFileExtension_ts$isJSXNode(
		node,
	) {
		return node.type === "JSXFragment" || node.type === "JSXElement";
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$useJSXFileExtension_ts$isJSXFile(
		context,
	) {
		for (const ext of ___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$useJSXFileExtension_ts$JSX_FILE_EXTENSIONS) {
			if (context.path.hasEndExtension(ext)) {
				return true;
			}
		}
		return false;
	}
	const ___R$project$rome$$internal$compiler$lint$rules$jsx$useJSXFileExtension_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx/useJSXFileExtension",
		enter(path) {
			const {node, context} = path;

			if (
				___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$useJSXFileExtension_ts$isJSXNode(
					node,
				) &&
				!___R$$priv$project$rome$$internal$compiler$lint$rules$jsx$useJSXFileExtension_ts$isJSXFile(
					context,
				)
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_USE_J_S_X_FILE_EXTENSION(
						context.path.getExtensions(),
						context.path.getExtensionlessBasename(),
					),
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx/usePascalCase.ts
const ___R$project$rome$$internal$compiler$lint$rules$jsx$usePascalCase_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx/usePascalCase",
		enter(path) {
			const {node} = path;

			if (
				node.type === "JSXElement" &&
				node.name.type === "JSXReferenceIdentifier"
			) {
				const pascalCaseName = ___R$project$rome$$internal$compiler$lint$rules$js$useCamelCase_ts$normalizeCamelCase(
					___R$project$rome$$internal$string$utils$toCamelCase_ts$toCamelCase(
						node.name.name,
						{
							allowShouty: false,
							forcePascal: true,
						},
					),
				);
				if (pascalCaseName !== undefined && node.name.name !== pascalCaseName) {
					path.context.addNodeDiagnostic(
						node,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_USE_PASCAL_CASE(
							node.name.name,
							pascalCaseName,
						),
					);
				}
			}
			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/jsx/useSelfClosingElements.ts
const ___R$project$rome$$internal$compiler$lint$rules$jsx$useSelfClosingElements_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "jsx/useSelfClosingElements",
		enter(path) {
			const {node} = path;

			if (
				node.type === "JSXElement" &&
				!node.selfClosing &&
				node.children.length === 0
			) {
				return path.addFixableDiagnostic(
					{
						fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
							Object.assign({}, node, {selfClosing: true}),
						),
					},
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.JSX_USE_SELF_CLOSING_ELEMENTS,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/utils/react/isCreateElement.ts
function ___R$project$rome$$internal$compiler$lint$utils$react$isCreateElement_ts$default(
		node,
		scope,
	) {
		let isCreateElement = false;

		if (node.type !== "JSCallExpression") {
			return isCreateElement;
		}

		if (
			___R$project$rome$$internal$js$ast$utils$isIdentifierish_ts$isIdentifierish(
				node.callee,
			)
		) {
			const {node: callee} = ___R$project$rome$$internal$js$ast$utils$resolveIndirection_ts$resolveIndirection(
				node.callee,
				scope,
			);
			if (
				!___R$project$rome$$internal$js$ast$utils$isIdentifierish_ts$isIdentifierish(
					callee,
				)
			) {
				return isCreateElement;
			}
			const reference = scope.getBinding(callee.name);
			isCreateElement =
				(!reference && callee.name === "createElement") ||
				(reference instanceof
				___R$project$rome$$internal$compiler$scope$bindings_ts$ImportBinding &&
				reference.meta.source === "react" &&
				reference.meta.type === "name" &&
				reference.meta.imported === "createElement");
		}

		if (node.callee.type === "JSMemberExpression") {
			if (
				!___R$project$rome$$internal$js$ast$utils$isIdentifierish_ts$isIdentifierish(
					node.callee.object,
				)
			) {
				return isCreateElement;
			}
			const {node: object} = ___R$project$rome$$internal$js$ast$utils$resolveIndirection_ts$resolveIndirection(
				node.callee.object,
				scope,
			);
			if (
				!___R$project$rome$$internal$js$ast$utils$isIdentifierish_ts$isIdentifierish(
					object,
				)
			) {
				return isCreateElement;
			}
			const reference = scope.getBinding(object.name);
			isCreateElement =
				node.callee.property.type === "JSStaticMemberProperty" &&
				node.callee.property.value.type === "JSIdentifier" &&
				node.callee.property.value.name === "createElement" &&
				((reference instanceof
				___R$project$rome$$internal$compiler$scope$bindings_ts$ImportBinding &&
				reference.meta.source === "react") ||
				(!reference && object.name === "React"));
		}

		return isCreateElement;
	}


  // project-rome/@internal/compiler/lint/utils/react/getCreateElementProp.ts
function ___R$project$rome$$internal$compiler$lint$utils$react$getCreateElementProp_ts$default(
		node,
		scope,
		propName,
	) {
		if (
			!___R$project$rome$$internal$compiler$lint$utils$react$isCreateElement_ts$default(
				node,
				scope,
			) ||
			!node.arguments[1] ||
			node.arguments[1].type !== "JSObjectExpression"
		) {
			return;
		}

		return (node.arguments[1].properties.find((prop) => {
			return (
				prop.type === "JSObjectProperty" &&
				prop.key.value.type === "JSIdentifier" &&
				prop.key.value.name === propName
			);
		}));
	}


  // project-rome/@internal/compiler/lint/utils/react/analyzeCreateElementProp.ts
function ___R$project$rome$$internal$compiler$lint$utils$react$analyzeCreateElementProp_ts$default(
		node,
		scope,
		propName,
	) {
		const prop = ___R$project$rome$$internal$compiler$lint$utils$react$getCreateElementProp_ts$default(
			node,
			scope,
			propName,
		);
		if (!prop) {
			return;
		}
		return ___R$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$tryStaticEvaluation(
			prop.value,
			scope,
		).value;
	}


  // project-rome/@internal/compiler/lint/utils/react/doesNodeMatchReactPattern.ts
function ___R$project$rome$$internal$compiler$lint$utils$react$doesNodeMatchReactPattern_ts$default(
		node,
		scope,
		pattern,
		config = {
			packageName: "react",
			importName: "React",
		},
	) {
		if (
			___R$project$rome$$internal$js$ast$utils$isIdentifierish_ts$isIdentifierish(
				node,
			)
		) {
			({node, scope} = ___R$project$rome$$internal$js$ast$utils$resolveIndirection_ts$resolveIndirection(
				node,
				scope,
			));
			if (
				!___R$project$rome$$internal$js$ast$utils$isIdentifierish_ts$isIdentifierish(
					node,
				)
			) {
				return false;
			}

			const reference = scope.getBinding(node.name);
			return (
				(!reference && node.name === pattern) ||
				(reference instanceof
				___R$project$rome$$internal$compiler$scope$bindings_ts$ImportBinding &&
				reference.meta.source === config.packageName &&
				reference.meta.type === "name" &&
				reference.meta.imported === pattern)
			);
		}

		if (
			node.type === "JSMemberExpression" ||
			node.type === "JSXMemberExpression"
		) {
			const member = pattern.replace(
				new RegExp("^" + config.importName + "."),
				"",
			);
			const {node: objectNode, scope: objectScope} = ___R$project$rome$$internal$js$ast$utils$resolveIndirection_ts$resolveIndirection(
				node.object,
				scope,
			);
			if (
				!___R$project$rome$$internal$js$ast$utils$isIdentifierish_ts$isIdentifierish(
					objectNode,
				)
			) {
				return false;
			}

			const reference = objectScope.getBinding(objectNode.name);
			let identifier;
			if (
				node.property.type === "JSStaticMemberProperty" &&
				node.property.value.type === "JSIdentifier"
			) {
				identifier = node.property.value;
			} else if (node.property.type === "JSXIdentifier") {
				identifier = node.property;
			}
			if (!identifier) {
				return false;
			}

			return (
				(!reference && objectNode.name + "." + identifier.name === pattern) ||
				(reference instanceof
				___R$project$rome$$internal$compiler$scope$bindings_ts$ImportBinding &&
				reference.meta.source === config.packageName &&
				identifier.name === member)
			);
		}
		return false;
	}


  // project-rome/@internal/compiler/lint/utils/react/getCreateElementChildren.ts
function ___R$project$rome$$internal$compiler$lint$utils$react$getCreateElementChildren_ts$default(
		node,
		scope,
	) {
		if (
			!___R$project$rome$$internal$compiler$lint$utils$react$isCreateElement_ts$default(
				node,
				scope,
			)
		) {
			return;
		}
		if (node.arguments.length > 2) {
			return node.arguments.slice(2);
		}
		return ___R$project$rome$$internal$compiler$lint$utils$react$getCreateElementProp_ts$default(
			node,
			scope,
			"children",
		);
	}


  // project-rome/@internal/compiler/lint/utils/react/getCreateElementType.ts
function ___R$project$rome$$internal$compiler$lint$utils$react$getCreateElementType_ts$default(
		node,
		scope,
	) {
		if (
			!___R$project$rome$$internal$compiler$lint$utils$react$isCreateElement_ts$default(
				node,
				scope,
			) ||
			!node.arguments[0]
		) {
			return;
		}
		const {bailed, value} = ___R$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$tryStaticEvaluation(
			node.arguments[0],
			scope,
		);
		return !bailed && typeof value === "string" ? value : undefined;
	}


  // project-rome/@internal/compiler/lint/utils/react/insideClassComponent.ts
function ___R$$priv$project$rome$$internal$compiler$lint$utils$react$insideClassComponent_ts$checkClassComponentAncestry(
		{node, scope},
	) {
		return (
			node.type === "JSClassHead" &&
			node.superClass !== undefined &&
			(___R$project$rome$$internal$compiler$lint$utils$react$doesNodeMatchReactPattern_ts$default(
				node.superClass,
				scope,
				"React.Component",
			) ||
			___R$project$rome$$internal$compiler$lint$utils$react$doesNodeMatchReactPattern_ts$default(
				node.superClass,
				scope,
				"Component",
			) ||
			___R$project$rome$$internal$compiler$lint$utils$react$doesNodeMatchReactPattern_ts$default(
				node.superClass,
				scope,
				"React.PureComponent",
			) ||
			___R$project$rome$$internal$compiler$lint$utils$react$doesNodeMatchReactPattern_ts$default(
				node.superClass,
				scope,
				"PureComponent",
			))
		);
	}

	function ___R$project$rome$$internal$compiler$lint$utils$react$insideClassComponent_ts$default(
		path,
	) {
		if (
			___R$$priv$project$rome$$internal$compiler$lint$utils$react$insideClassComponent_ts$checkClassComponentAncestry(
				path,
			)
		) {
			return true;
		}
		const ancestor = path.findAncestry(
			___R$$priv$project$rome$$internal$compiler$lint$utils$react$insideClassComponent_ts$checkClassComponentAncestry,
		);
		return !!ancestor;
	}


  // project-rome/@internal/compiler/lint/utils/react/index.ts



  // project-rome/@internal/compiler/lint/rules/react/noAccessStateInSetState.ts
const ___R$project$rome$$internal$compiler$lint$rules$react$noAccessStateInSetState_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "react/noAccessStateInSetState",
		enter(path) {
			const {node} = path;
			if (
				node.type === "JSCallExpression" &&
				___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
					node.callee,
					"this.setState",
				) &&
				node.arguments[0].type === "JSObjectExpression"
			) {
				const hasThisState = node.arguments[0].properties.some((arg) => {
					if (arg.type === "JSObjectProperty") {
						if (
							arg.value.type === "JSMemberExpression" &&
							___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
								arg.value.object,
								"this.state",
							)
						) {
							return true;
						}
						if (
							(arg.value.type === "JSUnaryExpression" &&
							arg.value.argument.type === "JSMemberExpression" &&
							___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
								arg.value.argument.object,
								"this.state",
							)) ||
							(arg.value.type === "JSUnaryExpression" &&
							arg.value.argument.type === "JSUnaryExpression" &&
							arg.value.argument.argument.type === "JSMemberExpression" &&
							___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
								arg.value.argument.argument.object,
								"this.state",
							))
						) {
							return true;
						}
						if (arg.value.type === "JSBinaryExpression") {
							if (
								arg.value.left.type === "JSMemberExpression" &&
								___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
									arg.value.left.object,
									"this.state",
								)
							) {
								return true;
							}
							if (
								arg.value.right.type === "JSMemberExpression" &&
								___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
									arg.value.right.object,
									"this.state",
								)
							) {
								return true;
							}
						}
					}
					return false;
				});
				if (
					hasThisState &&
					___R$project$rome$$internal$compiler$lint$utils$react$insideClassComponent_ts$default(
						path,
					)
				) {
					path.context.addNodeDiagnostic(
						node,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_NO_ACCESS_STATE_IN_SET_STATE,
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/react/noArrayIndexKey.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noArrayIndexKey_ts$getKeyValue(
		path,
	) {
		let keyValue = undefined;
		let callExpression = undefined;

		// handle React.cloneElement and cloneElement
		if (path.node.type === "JSCallExpression") {
			callExpression = path.node;
		} else if (path.parent.type === "JSCallExpression") {
			callExpression = path.parent;
		}
		if (
			callExpression &&
			callExpression.type === "JSCallExpression" &&
			callExpression.arguments.length > 1
		) {
			const obj = callExpression.arguments[1];
			if (obj.type === "JSObjectExpression") {
				for (const prop of obj.properties) {
					if (
						prop.type === "JSObjectProperty" &&
						prop.key.type === "JSStaticPropertyKey" &&
						prop.key.value.type === "JSIdentifier" &&
						prop.key.value.name === "key"
					) {
						if (prop.value.type === "JSReferenceIdentifier") {
							keyValue = prop.value.name;
						}
					}
				}
			}
		}
		return keyValue;
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noArrayIndexKey_ts$getReactChildrenArrayMethod(
		path,
		scope,
	) {
		return path.findAncestry(({node}) => {
			if (
				node.type === "JSExpressionStatement" &&
				node.expression.type === "JSCallExpression"
			) {
				const expr = node.expression;
				// Children
				if (
					expr.callee.type === "JSMemberExpression" &&
					expr.callee.object.type === "JSReferenceIdentifier" &&
					___R$project$rome$$internal$compiler$lint$utils$react$doesNodeMatchReactPattern_ts$default(
						expr.callee.object,
						scope,
						"Children",
					) &&
					expr.callee.property.value.type === "JSIdentifier" &&
					(expr.callee.property.value.name === "map" ||
					expr.callee.property.value.name === "forEach")
				) {
					return true;
				}

				// React.Children
				if (
					expr.callee.type === "JSMemberExpression" &&
					expr.callee.object.type === "JSMemberExpression" &&
					___R$project$rome$$internal$compiler$lint$utils$react$doesNodeMatchReactPattern_ts$default(
						expr.callee.object,
						scope,
						"React.Children",
					) &&
					expr.callee.object.property.type === "JSStaticMemberProperty" &&
					expr.callee.object.property.value.type === "JSIdentifier" &&
					expr.callee.object.property.value.name === "Children" &&
					expr.callee.property.value.type === "JSIdentifier" &&
					(expr.callee.property.value.name === "map" ||
					expr.callee.property.value.name === "forEach")
				) {
					return true;
				}
			}
			return false;
		});
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noArrayIndexKey_ts$hasArrayMethod(
		path,
	) {
		return path.findAncestry(({node}) => {
			if (
				node.type === "JSExpressionStatement" &&
				node.expression.type === "JSCallExpression" &&
				node.expression.callee.type === "JSMemberExpression" &&
				node.expression.callee.property.type === "JSStaticMemberProperty" &&
				node.expression.callee.property.value.type === "JSIdentifier"
			) {
				return /(map|forEach|filter|some|every|find|findIndex|reduce|reduceRight)/.test(
					node.expression.callee.property.value.name,
				);
			}
			return false;
		});
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noArrayIndexKey_ts$hasArrayIndexKey(
		keyValue,
		node,
	) {
		if (
			node.type === "JSExpressionStatement" &&
			node.expression.type === "JSCallExpression" &&
			node.expression.arguments.length > 0
		) {
			const lastArg = node.expression.arguments[node.expression.arguments.length -
			1];
			if (
				___R$project$rome$$internal$js$ast$utils$isFunctionNode_ts$isFunctionNode(
					lastArg,
				)
			) {
				node = lastArg;
			}
		}
		if (
			___R$project$rome$$internal$js$ast$utils$isFunctionNode_ts$isFunctionNode(
				node,
			) &&
			node.head.params.length > 0
		) {
			const lastParam = node.head.params[node.head.params.length - 1];
			if (lastParam.type === "JSBindingIdentifier") {
				return lastParam.name === keyValue;
			}
		}

		return false;
	}
	const ___R$project$rome$$internal$compiler$lint$rules$react$noArrayIndexKey_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "react/noArrayIndexKey",
		enter(path) {
			const {node, scope} = path;

			if (
				___R$project$rome$$internal$compiler$lint$utils$react$doesNodeMatchReactPattern_ts$default(
					node,
					scope,
					"cloneElement",
				)
			) {
				const memberExpressionPath = path.findAncestry((path) =>
					path.node.type === "JSCallExpression"
				);
				if (memberExpressionPath) {
					const keyValue = ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noArrayIndexKey_ts$getKeyValue(
						memberExpressionPath,
					);
					const reactChildrenArrayMethod = ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noArrayIndexKey_ts$getReactChildrenArrayMethod(
						memberExpressionPath,
						scope,
					);
					const arrayMethod = ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noArrayIndexKey_ts$hasArrayMethod(
						memberExpressionPath,
					);

					if (keyValue && (reactChildrenArrayMethod || arrayMethod)) {
						if (
							(reactChildrenArrayMethod &&
							___R$$priv$project$rome$$internal$compiler$lint$rules$react$noArrayIndexKey_ts$hasArrayIndexKey(
								keyValue,
								reactChildrenArrayMethod.node,
							)) ||
							(arrayMethod &&
							___R$$priv$project$rome$$internal$compiler$lint$rules$react$noArrayIndexKey_ts$hasArrayIndexKey(
								keyValue,
								arrayMethod.node,
							))
						) {
							path.context.addNodeDiagnostic(
								node,
								___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_NO_ARRAY_INDEX_KEY,
							);
						}
					}
				}
			}

			if (
				___R$project$rome$$internal$compiler$lint$utils$react$doesNodeMatchReactPattern_ts$default(
					node,
					scope,
					"React.cloneElement",
				)
			) {
				const keyValue = ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noArrayIndexKey_ts$getKeyValue(
					path,
				);
				const reactChildrenArrayMethod = ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noArrayIndexKey_ts$getReactChildrenArrayMethod(
					path,
					scope,
				);
				const arrayMethod = ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noArrayIndexKey_ts$hasArrayMethod(
					path,
				);

				if (keyValue && (reactChildrenArrayMethod || arrayMethod)) {
					if (
						(reactChildrenArrayMethod &&
						___R$$priv$project$rome$$internal$compiler$lint$rules$react$noArrayIndexKey_ts$hasArrayIndexKey(
							keyValue,
							reactChildrenArrayMethod.node,
						)) ||
						(arrayMethod &&
						___R$$priv$project$rome$$internal$compiler$lint$rules$react$noArrayIndexKey_ts$hasArrayIndexKey(
							keyValue,
							arrayMethod.node,
						))
					) {
						path.context.addNodeDiagnostic(
							node,
							___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_NO_ARRAY_INDEX_KEY,
						);
					}
				}
			}

			if (
				node.type === "JSXElement" &&
				___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
					node,
					"key",
				)
			) {
				let keyValue = undefined;
				const keyAttribute = ___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
					node,
					"key",
				);
				if (keyAttribute) {
					if (
						keyAttribute.value &&
						keyAttribute.value.type === "JSXExpressionContainer" &&
						keyAttribute.value.expression.type === "JSReferenceIdentifier" &&
						keyAttribute.value.expression.name
					) {
						keyValue = keyAttribute.value.expression.name;
					}
				}
				const functionExpression = path.findAncestry((path) => {
					return ___R$project$rome$$internal$js$ast$utils$isFunctionNode_ts$isFunctionNode(
						path.node,
					);
				});

				if (keyValue && functionExpression) {
					if (
						___R$$priv$project$rome$$internal$compiler$lint$rules$react$noArrayIndexKey_ts$hasArrayMethod(
							functionExpression,
						) &&
						___R$$priv$project$rome$$internal$compiler$lint$rules$react$noArrayIndexKey_ts$hasArrayIndexKey(
							keyValue,
							functionExpression.node,
						)
					) {
						path.context.addNodeDiagnostic(
							node,
							___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_NO_ARRAY_INDEX_KEY,
						);
					}
				}
			}
			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/react/noChildrenProp.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noChildrenProp_ts$getJSXChildrenProp(
		node,
	) {
		return (
			node.type === "JSXElement" &&
			___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
				node,
				"children",
			)
		);
	}
	const ___R$project$rome$$internal$compiler$lint$rules$react$noChildrenProp_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "react/noChildrenProp",
		enter(path) {
			const {node, scope} = path;
			const childrenProp =
				___R$$priv$project$rome$$internal$compiler$lint$rules$react$noChildrenProp_ts$getJSXChildrenProp(
					node,
				) ||
				___R$project$rome$$internal$compiler$lint$utils$react$getCreateElementProp_ts$default(
					node,
					scope,
					"children",
				);
			if (childrenProp) {
				path.context.addNodeDiagnostic(
					childrenProp,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_NO_CHILDREN_PROP,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/react/noDanger.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noDanger_ts$getJSXDangerProp(
		node,
	) {
		return (
			node.type === "JSXElement" &&
			___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
				node,
				"dangerouslySetInnerHTML",
			)
		);
	}
	const ___R$project$rome$$internal$compiler$lint$rules$react$noDanger_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "react/noDanger",
		enter(path) {
			const {node, scope} = path;
			const dangerProp =
				___R$$priv$project$rome$$internal$compiler$lint$rules$react$noDanger_ts$getJSXDangerProp(
					node,
				) ||
				___R$project$rome$$internal$compiler$lint$utils$react$getCreateElementProp_ts$default(
					node,
					scope,
					"dangerouslySetInnerHTML",
				);
			if (dangerProp) {
				path.context.addNodeDiagnostic(
					dangerProp,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_NO_DANGER,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/react/noDangerWithChildren.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noDangerWithChildren_ts$jsxDangerWithChildren(
		node,
	) {
		if (node.type !== "JSXElement") {
			return false;
		}

		const hasAttribute = !!node.attributes.find((attribute) =>
			attribute.type === "JSXAttribute" &&
			attribute.name.name === "dangerouslySetInnerHTML"
		);

		return hasAttribute && node.children && node.children.length > 0;
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noDangerWithChildren_ts$jsxDangerWithPropChildren(
		node,
	) {
		if (node.type !== "JSXElement") {
			return false;
		}

		const hasDangerAttribute = !!node.attributes.find((attribute) =>
			attribute.type === "JSXAttribute" &&
			attribute.name.name === "dangerouslySetInnerHTML"
		);

		const hasChildrenAttribute = !!node.attributes.find((attribute) =>
			attribute.type === "JSXAttribute" && attribute.name.name === "children"
		);

		return hasDangerAttribute && hasChildrenAttribute;
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noDangerWithChildren_ts$createElementDangerWithChildren(
		node,
		scope,
	) {
		return (
			!!___R$project$rome$$internal$compiler$lint$utils$react$getCreateElementChildren_ts$default(
				node,
				scope,
			) &&
			!!___R$project$rome$$internal$compiler$lint$utils$react$getCreateElementProp_ts$default(
				node,
				scope,
				"dangerouslySetInnerHTML",
			)
		);
	}
	const ___R$project$rome$$internal$compiler$lint$rules$react$noDangerWithChildren_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "react/noDangerWithChildren",

		enter(path) {
			const {node, scope} = path;

			if (
				___R$$priv$project$rome$$internal$compiler$lint$rules$react$noDangerWithChildren_ts$jsxDangerWithChildren(
					node,
				) ||
				___R$$priv$project$rome$$internal$compiler$lint$rules$react$noDangerWithChildren_ts$jsxDangerWithPropChildren(
					node,
				) ||
				___R$$priv$project$rome$$internal$compiler$lint$rules$react$noDangerWithChildren_ts$createElementDangerWithChildren(
					node,
					scope,
				)
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_NO_DANGER_WITH_CHILDREN,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/react/noDidMountSetState.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noDidMountSetState_ts$inComponentDidMount(
		path,
	) {
		const func =
			path.findAncestry(({node}) =>
				___R$project$rome$$internal$js$ast$utils$isConditional_ts$isConditional(
					node,
				)
			) !== undefined;
		return (
			!func &&
			!!path.findAncestry(({node}) =>
				node.type === "JSClassMethod" &&
				node.key.type === "JSStaticPropertyKey" &&
				node.key.value.type === "JSIdentifier" &&
				node.key.value.name === "componentDidMount"
			)
		);
	}
	const ___R$project$rome$$internal$compiler$lint$rules$react$noDidMountSetState_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "react/noDidMountSetState",
		enter(path) {
			const {node} = path;

			if (
				___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
					node,
					"this.setState",
				) &&
				___R$project$rome$$internal$compiler$lint$utils$react$insideClassComponent_ts$default(
					path,
				) &&
				___R$$priv$project$rome$$internal$compiler$lint$rules$react$noDidMountSetState_ts$inComponentDidMount(
					path,
				)
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_NO_DID_MOUNT_SET_STATE,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/react/noDidUpdateSetState.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noDidUpdateSetState_ts$inComponentDidUpdate(
		path,
	) {
		const func =
			path.findAncestry(({node}) =>
				___R$project$rome$$internal$js$ast$utils$isConditional_ts$isConditional(
					node,
				)
			) !== undefined;
		return (
			!func &&
			path.findAncestry(({node}) =>
				node.type === "JSClassMethod" &&
				node.key.type === "JSStaticPropertyKey" &&
				node.key.value.type === "JSIdentifier" &&
				node.key.value.name === "componentDidUpdate"
			) !== undefined
		);
	}
	const ___R$project$rome$$internal$compiler$lint$rules$react$noDidUpdateSetState_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "react/noDidUpdateSetState",
		enter(path) {
			const {node} = path;

			if (
				___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
					node,
					"this.setState",
				) &&
				___R$project$rome$$internal$compiler$lint$utils$react$insideClassComponent_ts$default(
					path,
				) &&
				___R$$priv$project$rome$$internal$compiler$lint$rules$react$noDidUpdateSetState_ts$inComponentDidUpdate(
					path,
				)
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_NO_DID_UPDATE_SET_STATE,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/react/noDirectMutationState.ts
// Check if this.state mutation was in the constructor
	function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noDirectMutationState_ts$isMutationInConstructor(
		path,
	) {
		// Find the first instance of a constructor or a call method
		const ancestor = path.findAncestry(({node}) =>
			(node.type === "JSClassMethod" &&
			node.key.type === "JSStaticPropertyKey" &&
			node.key.value.type === "JSIdentifier" &&
			node.key.value.name === "constructor") ||
			node.type === "JSCallExpression"
		);

		// If undefined, or a call expression, then its not in a constructor
		return ancestor !== undefined && ancestor.node.type !== "JSCallExpression";
	}

	// Checks if the node contains this.state that is mutated (binary and unary expr)
	function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noDirectMutationState_ts$isStateMutated(
		node,
	) {
		// Check if node is a binary expression where this.state is the left side
		if (
			node.type === "JSAssignmentExpression" &&
			(___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
				node.left,
				"this.state",
			) ||
			___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
				node.left,
				"this.state.**",
			))
		) {
			return true;
		}

		// Check if the node is an update expression (++ and --)
		if (
			node.type === "JSUpdateExpression" &&
			(___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
				node.argument,
				"this.state",
			) ||
			___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
				node.argument,
				"this.state.**",
			))
		) {
			return true;
		}

		// Check if the delete operator is used
		if (
			node.type === "JSUnaryExpression" &&
			node.operator === "delete" &&
			(___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
				node.argument,
				"this.state",
			) ||
			___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
				node.argument,
				"this.state.**",
			))
		) {
			return true;
		}

		return false;
	}
	const ___R$project$rome$$internal$compiler$lint$rules$react$noDirectMutationState_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "react/noDirectMutationState",
		enter(path) {
			const {node} = path;

			// If the state is mutated anywhere except in a constructor, show message
			if (
				___R$$priv$project$rome$$internal$compiler$lint$rules$react$noDirectMutationState_ts$isStateMutated(
					node,
				) &&
				___R$project$rome$$internal$compiler$lint$utils$react$insideClassComponent_ts$default(
					path,
				) &&
				!___R$$priv$project$rome$$internal$compiler$lint$rules$react$noDirectMutationState_ts$isMutationInConstructor(
					path,
				)
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_NO_DIRECT_MUTATION_STATE,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/react/noFindDOMNode.ts
const ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noFindDOMNode_ts$reactDOMConfig = {
		packageName: "react-dom",
		importName: "ReactDOM",
	};
	const ___R$project$rome$$internal$compiler$lint$rules$react$noFindDOMNode_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "react/noFindDOMNode",

		enter(path) {
			const {node, scope} = path;

			if (
				node.type === "JSCallExpression" &&
				(___R$project$rome$$internal$compiler$lint$utils$react$doesNodeMatchReactPattern_ts$default(
					node.callee,
					scope,
					"findDOMNode",
					___R$$priv$project$rome$$internal$compiler$lint$rules$react$noFindDOMNode_ts$reactDOMConfig,
				) ||
				___R$project$rome$$internal$compiler$lint$utils$react$doesNodeMatchReactPattern_ts$default(
					node.callee,
					scope,
					"ReactDOM.findDOMNode",
					___R$$priv$project$rome$$internal$compiler$lint$rules$react$noFindDOMNode_ts$reactDOMConfig,
				))
			) {
				path.context.addNodeDiagnostic(
					node.callee,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_NO_FIND_DOM_NODE,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/react/noRedundantShouldComponentUpdate.ts
const ___R$project$rome$$internal$compiler$lint$rules$react$noRedundantShouldComponentUpdate_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "react/noRedundantShouldComponentUpdate",
		enter(path) {
			const {node, scope} = path;

			if (
				node.type === "JSClassDeclaration" &&
				!!node.meta.body.find((member) =>
					member.type === "JSClassMethod" &&
					member.key.type === "JSStaticPropertyKey" &&
					member.key.value.type === "JSIdentifier" &&
					member.key.value.name === "shouldComponentUpdate"
				) &&
				node.meta.superClass &&
				(___R$project$rome$$internal$compiler$lint$utils$react$doesNodeMatchReactPattern_ts$default(
					node.meta.superClass,
					scope,
					"React.PureComponent",
				) ||
				___R$project$rome$$internal$compiler$lint$utils$react$doesNodeMatchReactPattern_ts$default(
					node.meta.superClass,
					scope,
					"PureComponent",
				))
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_NO_REDUNDANT_SHOULD_COMPONENT_UPDATE,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/react/noRenderReturnValue.ts
const ___R$project$rome$$internal$compiler$lint$rules$react$noRenderReturnValue_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "react/noRenderReturnValue",

		enter(path) {
			const {node, parent, scope} = path;

			if (
				node.type === "JSCallExpression" &&
				___R$project$rome$$internal$compiler$lint$utils$react$doesNodeMatchReactPattern_ts$default(
					node.callee,
					scope,
					"ReactDOM.render",
					{
						packageName: "react-dom",
						importName: "ReactDOM",
					},
				) &&
				parent.type !== "JSExpressionStatement"
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_NO_RENDER_RETURN_VALUE,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/react/noStringRefs.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noStringRefs_ts$containsStringLiteral(
		attribute,
	) {
		return (
			(attribute.value == null ? undefined : attribute.value.type) ===
			"JSStringLiteral"
		);
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noStringRefs_ts$containsStringContainer(
		attribute,
	) {
		if (
			(attribute.value == null ? undefined : attribute.value.type) !==
			"JSXExpressionContainer"
		) {
			return false;
		}

		return (
			(attribute.value == null ? undefined : attribute.value.expression).type ===
			"JSStringLiteral" ||
			(attribute.value == null ? undefined : attribute.value.expression).type ===
			"JSTemplateLiteral"
		);
	}
	const ___R$project$rome$$internal$compiler$lint$rules$react$noStringRefs_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "react/noStringRefs",
		enter(path) {
			const {context, node} = path;

			if (
				___R$project$rome$$internal$compiler$lint$utils$react$insideClassComponent_ts$default(
					path,
				) &&
				___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
					node,
					"this.refs",
				)
			) {
				context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_NO_STRING_REFS(
						___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>this.refs</emphasis>`,
					),
				);
			}

			if (
				node.type === "JSXElement" &&
				___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
					node,
					"ref",
				)
			) {
				const ref = ___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
					node,
					"ref",
				);

				if (ref === undefined) {
					return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
				}

				if (
					___R$$priv$project$rome$$internal$compiler$lint$rules$react$noStringRefs_ts$containsStringLiteral(
						ref,
					) ||
					___R$$priv$project$rome$$internal$compiler$lint$rules$react$noStringRefs_ts$containsStringContainer(
						ref,
					)
				) {
					context.addNodeDiagnostic(
						ref,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_NO_STRING_REFS(
							___R$project$rome$$internal$markup$escape_ts$markup`string literals in ref attributes`,
						),
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/react/noThisInSFC.ts
const ___R$project$rome$$internal$compiler$lint$rules$react$noThisInSFC_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "react/noThisInSFC",
		enter(path) {
			const {node} = path;

			if (node.type === "JSThisExpression") {
				const hasJSX = path.findAncestry((path) => {
					if (path.node.type === "JSXElement") {
						return true;
					}

					if (path.node.type === "JSBlockStatement") {
						if (
							path.node.body.some((statement) =>
								statement.type === "JSReturnStatement" &&
								statement.argument &&
								statement.argument.type === "JSXElement"
							)
						) {
							return true;
						}
					}

					const {node} = path;
					return (
						node.type === "JSVariableDeclarator" &&
						node.init !== undefined &&
						node.init.type === "JSArrowFunctionExpression" &&
						node.init.body.type === "JSXElement"
					);
				});

				if (hasJSX) {
					const isFunction = hasJSX.findAncestry((path) => {
						return ___R$project$rome$$internal$js$ast$utils$isFunctionNode_ts$isFunctionNode(
							path.node,
						);
					});

					const declaration = hasJSX.node.type === "JSVariableDeclarator";

					if (isFunction || declaration) {
						path.context.addNodeDiagnostic(
							node,
							___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_NO_THIS_IN_SFC,
						);
					}
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/react/noUnsafe.ts
const ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noUnsafe_ts$UNSAFE_METHODS = [
		{
			oldMethod: "UNSAFE_componentWillMount",
			newMethod: "componentDidMount",
		},
		{
			oldMethod: "UNSAFE_componentWillReceiveProps",
			newMethod: "getDerivedStateFromProps",
		},
		{
			oldMethod: "UNSAFE_componentWillUpdate",
			newMethod: "componentDidUpdate",
		},
	];

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noUnsafe_ts$getUnsafeDef(
		node,
	) {
		return (
			node.type === "JSClassMethod" &&
			node.key.type === "JSStaticPropertyKey" &&
			node.key.value.type === "JSIdentifier" &&
			___R$$priv$project$rome$$internal$compiler$lint$rules$react$noUnsafe_ts$UNSAFE_METHODS.find((
				def,
			) => def.oldMethod === (node.key.value).name)
		);
	}
	const ___R$project$rome$$internal$compiler$lint$rules$react$noUnsafe_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "react/noUnsafe",

		enter(path) {
			const {node} = path;

			const unsafeDef = ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noUnsafe_ts$getUnsafeDef(
				node,
			);

			if (unsafeDef) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_NO_UNSAFE(
						unsafeDef.oldMethod,
						unsafeDef.newMethod,
					),
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/react/noUselessFragment.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noUselessFragment_ts$isChildOfHtmlElement(
		path,
	) {
		const parentNode = path.parent;
		return (
			parentNode.type === "JSXElement" &&
			parentNode.name.type === "JSXIdentifier" &&
			/^[a-z]+$/.test(parentNode.name.name)
		);
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noUselessFragment_ts$isFragment(
		node,
		scope,
	) {
		return (
			node.type === "JSXFragment" ||
			(node.type === "JSXElement" &&
			(___R$project$rome$$internal$compiler$lint$utils$react$doesNodeMatchReactPattern_ts$default(
				node.name,
				scope,
				"Fragment",
			) ||
			___R$project$rome$$internal$compiler$lint$utils$react$doesNodeMatchReactPattern_ts$default(
				node.name,
				scope,
				"React.Fragment",
			)))
		);
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noUselessFragment_ts$hasLessThanTwoChildren(
		node,
	) {
		return node.children.length < 2;
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noUselessFragment_ts$getChildrenNode(
		node,
	) {
		if (node.children.length === 0) {
			return ___R$project$rome$$internal$compiler$index_ts$signals.remove;
		}

		if (node.children.length === 1) {
			return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
				node.children[0],
			);
		}

		return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
			node.children,
		);
	}
	const ___R$project$rome$$internal$compiler$lint$rules$react$noUselessFragment_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "noUselessFragment",
		enter(path) {
			const {node, scope} = path;

			if (node.type !== "JSXFragment" && node.type !== "JSXElement") {
				return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
			}

			if (
				path.parent.type !== "JSReturnStatement" &&
				path.parent.type !== "JSVariableDeclarator" &&
				!___R$project$rome$$internal$js$ast$utils$isFunctionNode_ts$isFunctionNode(
					path.parent,
				) &&
				___R$$priv$project$rome$$internal$compiler$lint$rules$react$noUselessFragment_ts$isFragment(
					node,
					scope,
				) &&
				!(node.type === "JSXElement" &&
				___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
					node,
					"key",
				)) &&
				(___R$$priv$project$rome$$internal$compiler$lint$rules$react$noUselessFragment_ts$hasLessThanTwoChildren(
					node,
				) ||
				___R$$priv$project$rome$$internal$compiler$lint$rules$react$noUselessFragment_ts$isChildOfHtmlElement(
					path,
				))
			) {
				return path.addFixableDiagnostic(
					{
						fixed: ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noUselessFragment_ts$getChildrenNode(
							node,
						),
					},
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_NO_USELESS_FRAGMENT,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/react/noVoidElementsWithChildren.ts
const ___R$project$rome$$internal$compiler$lint$rules$react$noVoidElementsWithChildren_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "react/noVoidElementsWithChildren",
		enter(path) {
			const {node, scope} = path;
			const elementType = ___R$project$rome$$internal$compiler$lint$utils$react$getCreateElementType_ts$default(
				node,
				scope,
			);

			if (
				___R$project$rome$$internal$compiler$lint$utils$react$isCreateElement_ts$default(
					node,
					scope,
				) &&
				elementType &&
				___R$project$rome$$internal$compiler$lint$utils$constants_ts$VOID_DOM_ELEMENTS.has(
					elementType,
				)
			) {
				const childrenNode = ___R$project$rome$$internal$compiler$lint$utils$react$getCreateElementChildren_ts$default(
					node,
					scope,
				);
				const dangerNode = ___R$project$rome$$internal$compiler$lint$utils$react$getCreateElementProp_ts$default(
					node,
					scope,
					"dangerouslySetInnerHTML",
				);

				if (Array.isArray(childrenNode)) {
					return path.addFixableDiagnostic(
						{
							target: node.arguments,
							fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
								Object.assign(
									{},
									node,
									{arguments: [node.arguments[0], node.arguments[1]]},
								),
							),
						},
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_NO_VOID_ELEMENTS_WITH_CHILDREN(
							(node.arguments[0]).value,
							["children"],
						),
					);
				}

				if (elementType && childrenNode) {
					return path.addFixableDiagnostic(
						{
							target: childrenNode,
							fixed: ___R$project$rome$$internal$compiler$index_ts$signals.remove,
						},
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_NO_VOID_ELEMENTS_WITH_CHILDREN(
							elementType,
							["children"],
						),
					);
				}

				if (elementType && dangerNode) {
					return path.addFixableDiagnostic(
						{
							target: dangerNode,
							fixed: ___R$project$rome$$internal$compiler$index_ts$signals.remove,
						},
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_NO_VOID_ELEMENTS_WITH_CHILDREN(
							elementType,
							["dangerouslySetInnerHTML"],
						),
					);
				}
			}

			if (
				node.type === "JSXElement" &&
				node.name.type === "JSXIdentifier" &&
				___R$project$rome$$internal$compiler$lint$utils$constants_ts$VOID_DOM_ELEMENTS.has(
					node.name.name,
				)
			) {
				const element = node.name.name;

				let properties = new Set();

				if (node.children.length !== 0) {
					properties.add("children");
				}

				const newAttributes = [];
				for (const attribute of node.attributes) {
					if (attribute.type === "JSXAttribute") {
						const property = attribute.name.name;
						if (property === "children") {
							properties.add("children");
							continue;
						} else if (property === "dangerouslySetInnerHTML") {
							properties.add("dangerouslySetInnerHTML");
							continue;
						}
					}
					newAttributes.push(attribute);
				}

				if (properties.size > 0) {
					return path.addFixableDiagnostic(
						{
							fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
								Object.assign(
									{},
									node,
									{attributes: newAttributes, children: [], selfClosing: true},
								),
							),
						},
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_NO_VOID_ELEMENTS_WITH_CHILDREN(
							element,
							Array.from(properties),
						),
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/react/noWillUpdateSetState.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$noWillUpdateSetState_ts$inComponentWillUpdate(
		path,
	) {
		const func =
			path.findAncestry(({node}) =>
				___R$project$rome$$internal$js$ast$utils$isConditional_ts$isConditional(
					node,
				)
			) !== undefined;
		return (
			!func &&
			path.findAncestry(({node}) =>
				node.type === "JSClassMethod" &&
				node.key.type === "JSStaticPropertyKey" &&
				node.key.value.type === "JSIdentifier" &&
				(node.key.value.name === "componentWillUpdate" ||
				node.key.value.name === "UNSAFE_componentWillUpdate")
			) !== undefined
		);
	}
	const ___R$project$rome$$internal$compiler$lint$rules$react$noWillUpdateSetState_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "react/noWillUpdateSetState",
		enter(path) {
			const {node} = path;

			if (
				___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
					node,
					"this.setState",
				) &&
				___R$project$rome$$internal$compiler$lint$utils$react$insideClassComponent_ts$default(
					path,
				) &&
				___R$$priv$project$rome$$internal$compiler$lint$rules$react$noWillUpdateSetState_ts$inComponentWillUpdate(
					path,
				)
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_NO_WILL_UPDATE_SET_STATE,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/react/useButtonType.ts
const ___R$$priv$project$rome$$internal$compiler$lint$rules$react$useButtonType_ts$BUTTON_TYPE_REGEX = /^(reset)|(submit)|(button)$/;

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$useButtonType_ts$createElementMissingType(
		node,
		scope,
	) {
		if (
			___R$project$rome$$internal$compiler$lint$utils$react$getCreateElementType_ts$default(
				node,
				scope,
			) !==
			"button"
		) {
			return;
		}
		const elementType = ___R$project$rome$$internal$compiler$lint$utils$react$analyzeCreateElementProp_ts$default(
			node,
			scope,
			"type",
		);
		return (
			typeof elementType !== "string" ||
			!___R$$priv$project$rome$$internal$compiler$lint$rules$react$useButtonType_ts$BUTTON_TYPE_REGEX.test(
				elementType,
			)
		);
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$useButtonType_ts$jsxMissingType(
		node,
		scope,
	) {
		if (
			!___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
				node,
				"button",
			)
		) {
			return false;
		}
		if (
			!___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
				node,
				"type",
			)
		) {
			return true;
		}
		const valueNode = ___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
			node,
			"type",
		);
		if (!valueNode || !valueNode.value) {
			return false;
		}

		let valueTarget =
			valueNode.value.type === "JSXExpressionContainer"
				? valueNode.value.expression
				: valueNode.value;

		const {value} = ___R$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$tryStaticEvaluation(
			valueTarget,
			scope,
		);
		return (
			typeof value !== "string" ||
			!___R$$priv$project$rome$$internal$compiler$lint$rules$react$useButtonType_ts$BUTTON_TYPE_REGEX.test(
				value,
			)
		);
	}
	const ___R$project$rome$$internal$compiler$lint$rules$react$useButtonType_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "react/useButtonType",
		enter(path) {
			const {node, scope} = path;

			if (
				___R$$priv$project$rome$$internal$compiler$lint$rules$react$useButtonType_ts$createElementMissingType(
					node,
					scope,
				) ||
				___R$$priv$project$rome$$internal$compiler$lint$rules$react$useButtonType_ts$jsxMissingType(
					node,
					scope,
				)
			) {
				path.context.addNodeDiagnostic(
					(___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
						node,
						"button",
					) &&
					___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
						node,
						"type",
					)) ||
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_USE_BUTTON_TYPE,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/react/useFragmentSyntax.ts
const ___R$project$rome$$internal$compiler$lint$rules$react$useFragmentSyntax_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "react/useFragmentSyntax",
		enter(path) {
			const {node, scope} = path;

			if (
				node.type === "JSXElement" &&
				(___R$project$rome$$internal$compiler$lint$utils$react$doesNodeMatchReactPattern_ts$default(
					node.name,
					scope,
					"Fragment",
				) ||
				___R$project$rome$$internal$compiler$lint$utils$react$doesNodeMatchReactPattern_ts$default(
					node.name,
					scope,
					"React.Fragment",
				)) &&
				!___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
					node,
					"key",
				)
			) {
				return path.addFixableDiagnostic(
					{
						fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
							___R$project$rome$$internal$ast$js$jsx$JSXFragment_ts$jsxFragment.create({
								children: node.children,
							}),
						),
					},
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_USE_FRAGMENT_SYNTAX,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/react/useKey.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$useKey_ts$containsKeyAttr(
		node,
	) {
		const ATTR_NAME = "key";
		return !!node.attributes.find((attr) =>
			attr.type === "JSXAttribute" && attr.name.name === ATTR_NAME
		);
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$useKey_ts$getMapCallback(
		node,
	) {
		if (
			___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
				node.callee,
				"React.Children.map",
			) ||
			___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
				node.callee,
				"Children.map",
			)
		) {
			return node.arguments[1];
		}

		if (
			node.callee.type === "JSMemberExpression" &&
			node.callee.property.value.type === "JSIdentifier" &&
			node.callee.property.value.name === "map"
		) {
			return node.arguments[0];
		}

		return undefined;
	}
	const ___R$project$rome$$internal$compiler$lint$rules$react$useKey_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "react/useKey",
		enter(path) {
			const {node, context} = path;

			// JSXElement in array literal
			if (
				node.type === "JSXElement" &&
				!___R$$priv$project$rome$$internal$compiler$lint$rules$react$useKey_ts$containsKeyAttr(
					node,
				) &&
				path.parentPath.node.type === "JSArrayExpression"
			) {
				context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_USE_KEY(
						"array",
					),
				);
			}

			const fn =
				node.type === "JSCallExpression" &&
				___R$$priv$project$rome$$internal$compiler$lint$rules$react$useKey_ts$getMapCallback(
					node,
				);

			// Array.prototype.map
			if (fn) {
				// Short hand arrow function
				if (
					fn.type === "JSArrowFunctionExpression" &&
					fn.body.type === "JSXElement" &&
					!___R$$priv$project$rome$$internal$compiler$lint$rules$react$useKey_ts$containsKeyAttr(
						fn.body,
					)
				) {
					context.addNodeDiagnostic(
						fn.body,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_USE_KEY(
							"iterator",
						),
					);
				}

				// Function or arrow function with block statement
				if (
					fn &&
					(fn.type === "JSFunctionExpression" ||
					fn.type === "JSArrowFunctionExpression") &&
					fn.body.type === "JSBlockStatement"
				) {
					for (const statement of fn.body.body) {
						if (
							statement.type === "JSReturnStatement" &&
							(statement.argument == null ? undefined : statement.argument.type) ===
							"JSXElement" &&
							!___R$$priv$project$rome$$internal$compiler$lint$rules$react$useKey_ts$containsKeyAttr(
								statement.argument,
							)
						) {
							context.addNodeDiagnostic(
								statement.argument,
								___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_USE_KEY(
									"iterator",
								),
							);
						}
					}
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/react/useRenderReturn.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$useRenderReturn_ts$isRenderProperty(
		node,
	) {
		return (
			node.type === "JSStaticPropertyKey" &&
			node.value.type === "JSIdentifier" &&
			node.value.name === "render"
		);
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$useRenderReturn_ts$getMethodBody(
		node,
	) {
		if (node.type === "JSClassMethod") {
			return node.body;
		}

		if (
			node.type === "JSClassProperty" &&
			(node.value == null ? undefined : node.value.type) ===
			"JSArrowFunctionExpression"
		) {
			return node.value.body;
		}
		return undefined;
	}
	const ___R$project$rome$$internal$compiler$lint$rules$react$useRenderReturn_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "requireRenderReturn",
		enter(path) {
			const {node} = path;
			if (
				node.type === "JSClassHead" &&
				___R$project$rome$$internal$compiler$lint$utils$react$insideClassComponent_ts$default(
					path,
				)
			) {
				const renderMember = node.body.find(({key}) =>
					___R$$priv$project$rome$$internal$compiler$lint$rules$react$useRenderReturn_ts$isRenderProperty(
						key,
					)
				);
				const renderBody =
					renderMember &&
					___R$$priv$project$rome$$internal$compiler$lint$rules$react$useRenderReturn_ts$getMethodBody(
						renderMember,
					);

				if (
					renderBody &&
					!___R$project$rome$$internal$js$ast$utils$getCompletionRecords_ts$getCompletionRecords(
						renderBody,
					).some(({type}) => type === "COMPLETION")
				) {
					path.context.addNodeDiagnostic(
						renderBody,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_USE_RENDER_RETURN,
					);
				}
			}
			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/react/useSortComp.ts
const ___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$SortGroups = {
		STATIC_METHODS: 0,
		LIFECYCLE: 1,
		EVERYTHING_ELSE: 2,
		RENDER: 3,
	};

	// The list of methods and variables that are part of the lifecycle group. Order matters
	const ___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$lifecycleTypes = {
		"displayName": {type: "property", order: 0},
		"propTypes": {type: "property", order: 1},
		"contextTypes": {type: "property", order: 2},
		"childContextTypes": {type: "property", order: 3},
		"mixins": {type: "property", order: 4},
		"statics": {type: "property", order: 5},
		"defaultProps": {type: "property", order: 6},
		"constructor": {type: "method", order: 7},
		"getDefaultProps": {type: "method", order: 8},
		"state": {type: "property", order: 9},
		"getInitialState": {type: "method", order: 10},
		"getChildContext": {type: "method", order: 11},
		"getDerivedStateFromProps": {type: "method", order: 12},
		"componentWillMount": {type: "method", order: 13},
		"UNSAFE_componentWillMount": {type: "method", order: 14},
		"componentDidMount": {type: "method", order: 15},
		"componentWillReceiveProps": {type: "method", order: 16},
		"UNSAFE_componentWillReceiveProps": {type: "method", order: 17},
		"shouldComponentUpdate": {type: "method", order: 18},
		"componentWillUpdate": {type: "method", order: 19},
		"UNSAFE_componentWillUpdate": {type: "method", order: 20},
		"getSnapshotBeforeUpdate": {type: "method", order: 21},
		"componentDidUpdate": {type: "method", order: 22},
		"componentDidCatch": {type: "method", order: 23},
		"componentWillUnmount": {type: "method", order: 24},
	};

	const ___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$numberLifecycle = 25;

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$isReactComponent(
		node,
	) {
		// Check if it extends React.Component or Component, and React.PureCompnent and PureComponent
		return (
			node !== undefined &&
			node.superClass !== undefined &&
			(___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
				node.superClass,
				"React.Component",
			) ||
			___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
				node.superClass,
				"Component",
			) ||
			___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
				node.superClass,
				"React.PureComponent",
			) ||
			___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
				node.superClass,
				"PureComponent",
			))
		);
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$isStaticMethod(
		node,
	) {
		if (node.type === "JSClassMethod") {
			return node.kind === "method" && node.meta.static === true;
		}

		return false;
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$isLifecycleComponent(
		node,
	) {
		if (node.type === "JSClassMethod") {
			if (node.key.value.type !== "JSIdentifier") {
				return false;
			}
			const lifecycleName = node.key.value.name;

			// Check that it is a lifecycle method, and that the
			// type is the same (property vs method)
			return (
				lifecycleName in
				___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$lifecycleTypes &&
				___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$lifecycleTypes[lifecycleName].type ===
				"method"
			);
		} else if (node.type === "JSClassProperty") {
			if (node.key.value.type !== "JSIdentifier") {
				return false;
			}
			const lifecycleName = node.key.value.name;

			// Check that it is a lifecycle method, and that the
			// type is the same (property vs method)
			return (
				lifecycleName in
				___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$lifecycleTypes &&
				___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$lifecycleTypes[lifecycleName].type ===
				"property"
			);
		}

		return false;
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$isRenderMethod(
		node,
	) {
		if (node.type === "JSClassMethod") {
			return (
				node.kind === "method" &&
				node.key.value.type === "JSIdentifier" &&
				node.key.value.name === "render"
			);
		}

		return false;
	}

	// Takes a node and converts it to a number which corresponds to the order where it should be
	function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$convertNodeToOrder(
		node,
	) {
		if (
			___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$isLifecycleComponent(
				node,
			)
		) {
			const lifecycleName = (node).key.value.name;

			return (
				___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$SortGroups.LIFECYCLE +
				___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$lifecycleTypes[lifecycleName].order
			);
		} else if (
			___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$isRenderMethod(
				node,
			)
		) {
			return (
				___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$SortGroups.RENDER +
				___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$numberLifecycle
			);
		} else if (
			___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$isStaticMethod(
				node,
			)
		) {
			return ___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$SortGroups.STATIC_METHODS;
		} else {
			return (
				___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$SortGroups.EVERYTHING_ELSE +
				___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$numberLifecycle
			);
		}
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$getNodeName(
		node,
	) {
		if (
			(node.type === "JSClassMethod" || node.type === "JSClassProperty") &&
			node.key.value !== undefined &&
			node.key.value.type === "JSIdentifier"
		) {
			return node.key.value.name;
		}

		return "";
	}

	// Solution comes from https://en.wikipedia.org/wiki/Longest_increasing_subsequence
	function ___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$findOutOfOrderNodes(
		seq,
	) {
		if (seq.length <= 1) {
			return {nodesToMove: [], nodesInOrder: []};
		}

		let longestSubsequencePredecessorIndex = new Array(seq.length);
		let smallestValueIndex = new Array(seq.length + 1);

		let L = 0;
		for (let i = 0; i < seq.length; i++) {
			// Binary search for the largest positive j ≤ L such that X[M[j]] <= X[i]
			let lo = 1;
			let hi = L;
			while (lo <= hi) {
				const mid = Math.ceil((lo + hi) / 2);
				if (seq[smallestValueIndex[mid]].order <= seq[i].order) {
					lo = mid + 1;
				} else {
					hi = mid - 1;
				}
			}
			// After searching, lo is 1 greater than the length of the longest prefix of X[i]
			let newL = lo;

			// The predecessor of X[i] is the last index of the subsequence of length newL-1
			longestSubsequencePredecessorIndex[i] = smallestValueIndex[newL - 1];
			smallestValueIndex[newL] = i;

			if (newL > L) {
				// If we found a subsequence longer than any we've found yet, update L
				L = newL;
			}
		}

		// Reconstruct the inverse of the longest increasing subsequence
		let nodesToMove = Array(Math.max(seq.length - L - 1, 0));
		let nodesInOrder = new Array(L);
		let longestSubsequenceIndex = smallestValueIndex[L];
		let inverseIndex = nodesToMove.length;
		let subsequenceIndex = L - 1;
		// This part was adapted to get the increasing subsequence, but also the rest
		// of the values in the list (i.e. the values the user will be warned of)
		for (let i = seq.length - 1; i > -1; i += -1) {
			if (i === longestSubsequenceIndex) {
				nodesInOrder[subsequenceIndex] = seq[i];
				subsequenceIndex--;
				longestSubsequenceIndex = longestSubsequencePredecessorIndex[longestSubsequenceIndex];
			} else {
				nodesToMove[inverseIndex] = seq[i];
				inverseIndex--;
			}
		}
		return {nodesToMove, nodesInOrder};
	}
	const ___R$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "react/useSortComp",
		enter(path) {
			const {node} = path;

			// Look for classes and Check if the classes are react components
			if (
				(node.type === "JSClassDeclaration" || node.type === "JSClassExpression") &&
				node.meta !== undefined &&
				___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$isReactComponent(
					node.meta,
				) &&
				node.meta.body
			) {
				// The list of nodes in the class
				const classNodes = node.meta.body;

				// This is the list of nodes, except it will be showing their expected order.
				// Any order values that are not in order will be the ones we need to warn the
				// user about. We just find the position where the order should be and we know
				// which 2 nodes to tell the user about
				const orderList = classNodes.map((classNode) => {
					return {
						node: classNode,
						order: ___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$convertNodeToOrder(
							classNode,
						),
						name: ___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$getNodeName(
							classNode,
						),
					};
				});

				// Find longest increasing subsequence to find the elements we don't want to move
				// as well as the elements we want to move
				const {nodesToMove, nodesInOrder} = ___R$$priv$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$findOutOfOrderNodes(
					orderList,
				);

				// sort the nodesToMove based on order so we can more easily find where to put them
				nodesToMove.sort((a, b) => {
					return a.order - b.order;
				});

				// For each element to move, figure out where to move it to
				let toMoveIndex = 0;
				let inOrderIndex = 0;
				for (let i = 0; toMoveIndex < nodesToMove.length; i++) {
					const toMove = nodesToMove[toMoveIndex];
					const inOrder = nodesInOrder[inOrderIndex];

					// If nodeToMove can be placed before nodeInOrder or nodeInOrder is at the end of the list
					if (
						toMove.order < inOrder.order ||
						inOrderIndex === nodesInOrder.length - 1
					) {
						let position = "before";
						// If its the last one in the in order list
						if (inOrderIndex === nodesInOrder.length - 1) {
							// Add after error
							position = "after";
						}

						let errorNode = toMove.node;

						// Make the warning message point to the function name
						if (
							toMove.node.type === "JSClassMethod" ||
							toMove.node.type === "JSClassProperty"
						) {
							errorNode = toMove.node.key;
						}

						// Add diagnostics to the node
						path.context.addNodeDiagnostic(
							errorNode,
							___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_USE_SORT_COMP(
								inOrder.name,
								toMove.name,
								position,
							),
						);

						toMoveIndex++;
					} else {
						inOrderIndex++;
					}
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/react/useStylePropObject.ts
const ___R$project$rome$$internal$compiler$lint$rules$react$useStylePropObject_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "react/useStylePropObject",
		enter(path) {
			const {node} = path;

			if (
				node.type === "JSXAttribute" &&
				node.name.name === "style" &&
				node.value !== undefined &&
				((node.value.type === "JSXExpressionContainer" &&
				node.value.expression.type !== "JSObjectExpression") ||
				node.value.type !== "JSXExpressionContainer")
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REACT_USE_STYLE_PROP_OBJECT,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/regex/noDuplicateGroupNamesInRegularExpressions.ts
const ___R$project$rome$$internal$compiler$lint$rules$regex$noDuplicateGroupNamesInRegularExpressions_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "regex/noDuplicateGroupNamesInRegularExpressions",
		enter(path) {
			const {context, node} = path;

			if (node.type === "JSRegExpSubExpression") {
				const duplicates = new ___R$project$rome$$internal$compiler$lib$DiagnosticsDuplicateHelper_ts$DiagnosticsDuplicateHelper(
					context,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REGEX_DUPLICATE_REGEX_GROUP_NAME,
				);

				for (const bodyItem of node.body) {
					if (bodyItem.type === "JSRegExpGroupCapture") {
						const groupName = bodyItem.name;

						if (groupName !== undefined) {
							duplicates.addLocation(groupName, bodyItem.loc);
						}
					}
				}

				duplicates.process();
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/regex/noEmptyCharacterClass.ts
const ___R$project$rome$$internal$compiler$lint$rules$regex$noEmptyCharacterClass_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "regex/noEmptyCharacterClass",
		enter(path) {
			const {context, node} = path;

			if (
				node.type === "JSRegExpCharSet" &&
				node.body.length === 0 &&
				!node.invert
			) {
				context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REGEX_NO_EMPTY_CHAR_SET,
				);
				return ___R$project$rome$$internal$compiler$index_ts$signals.remove;
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/regex/noEmptyMatches.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$regex$noEmptyMatches_ts$isQuantifiedMinZero(
		el,
	) {
		return el.type === "JSRegExpQuantified" && el.min === 0;
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$regex$noEmptyMatches_ts$lintEmptyMatches(
		expr,
	) {
		if (expr.type === "JSRegExpSubExpression") {
			for (const item of expr.body) {
				let matches = false;
				if (
					item.type === "JSRegExpGroupNonCapture" ||
					item.type === "JSRegExpGroupCapture"
				) {
					matches = ___R$$priv$project$rome$$internal$compiler$lint$rules$regex$noEmptyMatches_ts$lintEmptyMatches(
						item.expression,
					);
				} else {
					matches = ___R$$priv$project$rome$$internal$compiler$lint$rules$regex$noEmptyMatches_ts$isQuantifiedMinZero(
						item,
					);
				}
				if (!matches) {
					return false;
				}
			}
			return true;
		} else {
			return (
				___R$$priv$project$rome$$internal$compiler$lint$rules$regex$noEmptyMatches_ts$lintEmptyMatches(
					expr.left,
				) ||
				___R$$priv$project$rome$$internal$compiler$lint$rules$regex$noEmptyMatches_ts$lintEmptyMatches(
					expr.right,
				)
			);
		}
	}
	const ___R$project$rome$$internal$compiler$lint$rules$regex$noEmptyMatches_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "regex/noEmptyMatches",
		enter(path) {
			const {context, node} = path;
			if (
				node.type === "JSRegExpLiteral" &&
				___R$$priv$project$rome$$internal$compiler$lint$rules$regex$noEmptyMatches_ts$lintEmptyMatches(
					node.expression,
				)
			) {
				context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REGEX_NO_EMPTY_MATCHES,
				);
			}
			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/regex/noMultipleSpacesInRegularExpressionLiterals.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$regex$noMultipleSpacesInRegularExpressionLiterals_ts$isSpaceChar(
		node,
	) {
		return (
			node !== undefined &&
			node.type === "JSRegExpCharacter" &&
			node.value === " "
		);
	}

	function ___R$$priv$project$rome$$internal$compiler$lint$rules$regex$noMultipleSpacesInRegularExpressionLiterals_ts$checkRegex(
		path,
		node,
	) {
		const newBody = [];
		const diagnosticTargets = [];

		let index = 0;
		while (index < node.body.length) {
			const item = node.body[index];

			// Push the item unchanged if it's not the start of consecutive spaces
			if (
				!___R$$priv$project$rome$$internal$compiler$lint$rules$regex$noMultipleSpacesInRegularExpressionLiterals_ts$isSpaceChar(
					item,
				) ||
				!___R$$priv$project$rome$$internal$compiler$lint$rules$regex$noMultipleSpacesInRegularExpressionLiterals_ts$isSpaceChar(
					node.body[index + 1],
				)
			) {
				newBody.push(item);
				index++;
				continue;
			}

			// Count the number of consecutive space chars
			let spaceCount = 0;
			while (
				___R$$priv$project$rome$$internal$compiler$lint$rules$regex$noMultipleSpacesInRegularExpressionLiterals_ts$isSpaceChar(
					node.body[index],
				)
			) {
				diagnosticTargets.push(node.body[index]);
				spaceCount++;
				index++;
			}

			// Push a new body item that represents all the consecutive spaces
			const quantifiedSpace = ___R$project$rome$$internal$ast$js$regex$JSRegExpQuantified_ts$jsRegExpQuantified.create({
				min: spaceCount,
				max: spaceCount,
				target: item,
			});
			newBody.push(quantifiedSpace);
		}

		if (diagnosticTargets.length > 0) {
			const newRegex = Object.assign({}, node, {body: newBody});
			return path.addFixableDiagnostic(
				{
					target: diagnosticTargets,
					fixed: ___R$project$rome$$internal$compiler$index_ts$signals.replace(
						newRegex,
					),
				},
				___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REGEX_NO_MULTIPLE_SPACES_IN_REGEX_LITERAL(
					diagnosticTargets.length,
				),
			);
		} else {
			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		}
	}
	const ___R$project$rome$$internal$compiler$lint$rules$regex$noMultipleSpacesInRegularExpressionLiterals_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "regex/noMultipleSpacesInRegularExpressionLiterals",
		enter(path) {
			const {node} = path;

			if (node.type === "JSRegExpSubExpression") {
				return ___R$$priv$project$rome$$internal$compiler$lint$rules$regex$noMultipleSpacesInRegularExpressionLiterals_ts$checkRegex(
					path,
					node,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/regex/noPosixInRegularExpression.ts
const ___R$project$rome$$internal$compiler$lint$rules$regex$noPosixInRegularExpression_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "regex/noPosixInRegularExpression",
		enter(path) {
			const {context, node} = path;

			if (node.type === "JSRegExpCharSet" && node.body.length > 2) {
				for (let i = 0; i < node.body.length; i++) {
					const nextNode = node.body[i + 1];
					const currNode = node.body[i];
					const lastNode = node.body[node.body.length - 1];
					if (
						currNode.type === "JSRegExpCharacter" &&
						currNode.value === "[" &&
						nextNode &&
						nextNode.type === "JSRegExpCharacter" &&
						(nextNode.value === ":" || nextNode.value === ".") &&
						lastNode.type === "JSRegExpCharacter" &&
						lastNode.value === nextNode.value
					) {
						context.addNodeDiagnostic(
							currNode,
							___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REGEX_NO_POSIX_IN_REGULAR_EXPRESSION,
						);
					}
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/regex/noReferenceToNonExistingGroup.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$regex$noReferenceToNonExistingGroup_ts$findCaptureGroups(
		path,
	) {
		const regexLiteral = path.findAncestry((path) =>
			path.node.type === "JSRegExpLiteral"
		);
		if (regexLiteral === undefined) {
			return regexLiteral;
		}
		let captureGroups = [];
		regexLiteral.traverse(
			"JSRegExpLiteral",
			(path) => {
				if (path.node.type === "JSRegExpGroupCapture") {
					captureGroups.push(path.node);
				}
			},
		);
		return captureGroups;
	}
	const ___R$project$rome$$internal$compiler$lint$rules$regex$noReferenceToNonExistingGroup_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "regex/noReferenceToNonExistingGroup",
		enter(path) {
			const {node, context} = path;

			if (node.type === "JSRegExpNumericBackReference") {
				const allCaptureGroups = ___R$$priv$project$rome$$internal$compiler$lint$rules$regex$noReferenceToNonExistingGroup_ts$findCaptureGroups(
					path,
				);
				if (allCaptureGroups === undefined) {
					context.addNodeDiagnostic(
						node,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REGEX_NO_REFERENCE_TO_NON_EXISTING_GROUP(
							String(node.value),
						),
					);
				} else {
					if (node.value > allCaptureGroups.length) {
						context.addNodeDiagnostic(
							node,
							___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.REGEX_NO_REFERENCE_TO_NON_EXISTING_GROUP(
								String(node.value),
							),
						);
					}
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/ts/noExplicitAny.ts
const ___R$project$rome$$internal$compiler$lint$rules$ts$noExplicitAny_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "ts/noExplicitAny",
		enter(path) {
			const {context, node} = path;

			if (node.type === "TSAnyKeywordTypeAnnotation") {
				context.addNodeDiagnostic(
					node,
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.TS_NO_EXPLICIT_ANY,
				);
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/ts/useInterfaces.ts
function ___R$$priv$project$rome$$internal$compiler$lint$rules$ts$useInterfaces_ts$extractObjects(
		typeAlias,
		scope,
	) {
		const {right} = typeAlias;

		let types;
		if (right.type === "TSObjectTypeAnnotation") {
			types = [right];
		} else if (right.type === "TSIntersectionTypeAnnotation") {
			types = right.types;
		} else {
			return undefined;
		}

		const _extends = [];
		let members = [];

		for (const node of types) {
			if (node.type === "TSObjectTypeAnnotation") {
				members = members.concat(node.members);
			} else if (node.type === "TSTypeReference") {
				const base = ___R$project$rome$$internal$js$ast$utils$getTSQualifiedBaseFromEntityName_ts$getTSQualifiedBaseFromEntityName(
					node.typeName,
				);
				const binding = scope.getBinding(base.name);

				if (
					binding === undefined ||
					(binding instanceof
					___R$project$rome$$internal$compiler$scope$bindings_ts$TypeBinding &&
					binding.typeKind === "parameter")
				) {
					// `extends` can only access a static type
					return undefined;
				}

				_extends.push({
					type: "TSExpressionWithTypeArguments",
					expression: node.typeName,
					typeParameters: node.typeParameters,
				});
			} else {
				// No idea what this is or how to include it
				return undefined;
			}
		}

		return {extends: _extends, members};
	}
	const ___R$project$rome$$internal$compiler$lint$rules$ts$useInterfaces_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "ts/useInterfaces",
		enter(path) {
			const {node} = path;

			if (node.type === "TSTypeAlias") {
				const extracted = ___R$$priv$project$rome$$internal$compiler$lint$rules$ts$useInterfaces_ts$extractObjects(
					node,
					path.scope,
				);

				if (extracted !== undefined) {
					/*return path.context.addFixableDiagnostic(
					{
						old: node,
						suggestions: [{
							fixed: {
								type: "TSInterfaceDeclaration",
								loc: node.loc,
								id: node.id,
								typeParameters: node.typeParameters,
								declare: node.declare,
								extends: extracted.extends,
								body: {
									type: "TSInterfaceBody",
									body: extracted.members,
								},
							},
						}]
					},
					descriptions.LINT.TS_PREFER_INTERFACES,
				);*/
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/lint/rules/index.ts
const ___R$project$rome$$internal$compiler$lint$rules$index_ts$lintTransforms = [
		___R$project$rome$$internal$compiler$lint$rules$html$useClosingNonVoid_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noArguments_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noAsyncPromiseExecutor_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noCatchAssign_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noCommaOperator_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noCompareNegZero_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noCondAssign_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noDebugger_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noDelete_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noDeleteVars_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noDoubleEquals_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noDupeArgs_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noDuplicateCase_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noDuplicateImportSource_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noDuplicateKeys_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noEmptyBlocks_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noExtraBooleanCast_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noFunctionAssign_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noGetterReturn_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noImportAssign_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noLabelVar_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noNegationElse_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noNestedTernary_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noRestrictedGlobals_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noSetterReturn_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noShadowRestrictedNames_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noShorthandArrayType_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noShoutyConstants_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noSparseArray_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noTemplateCurlyInString_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noUndeclaredVariables_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noUnsafeFinally_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noUnsafeNegation_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noUnusedTemplateLiteral_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noUnusedVariables_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$noVar_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$useBlockStatements_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$useCamelCase_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$useDefaultExportBasename_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$useDefaultImportBasename_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$useFunctionDeclarations_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$useSingleCaseStatement_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$useSingleVarDeclarator_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$useSortedSpecifiers_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$useTemplate_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$js$useWhile_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$noAccessKey_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$noAriaUnsupportedElements_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$noAutofocus_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$noDistractingElements_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$noHeaderScope_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$noNoninteractiveElementToInteractiveRole_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$noNoninteractiveTabindex_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$noOnChange_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$noPositiveTabindex_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$noRedundantAlt_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$noRedundantRoles_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$noTargetBlank_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$useAltText_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$useAnchorContent_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$useAriaProps_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$useAriaPropsForRole_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$useAriaProptypes_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$useHeadingContent_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$useHtmlLang_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$useIframeTitle_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$useKeyWithClickEvents_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$useKeyWithMouseEvents_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$useMediaCaption_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidAnchor_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$a11y$useValidLang_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$noCommentText_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$noDuplicateProps_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$noImplicitBoolean_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$noPropSpreading_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$useJSXFileExtension_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$usePascalCase_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$jsx$useSelfClosingElements_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$react$noAccessStateInSetState_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$react$noArrayIndexKey_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$react$noChildrenProp_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$react$noDanger_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$react$noDangerWithChildren_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$react$noDidMountSetState_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$react$noDidUpdateSetState_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$react$noDirectMutationState_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$react$noFindDOMNode_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$react$noRedundantShouldComponentUpdate_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$react$noRenderReturnValue_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$react$noStringRefs_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$react$noThisInSFC_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$react$noUnsafe_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$react$noUselessFragment_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$react$noVoidElementsWithChildren_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$react$noWillUpdateSetState_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$react$useButtonType_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$react$useFragmentSyntax_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$react$useKey_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$react$useRenderReturn_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$react$useSortComp_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$react$useStylePropObject_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$regex$noDuplicateGroupNamesInRegularExpressions_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$regex$noEmptyCharacterClass_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$regex$noEmptyMatches_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$regex$noMultipleSpacesInRegularExpressionLiterals_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$regex$noPosixInRegularExpression_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$regex$noReferenceToNonExistingGroup_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$ts$noExplicitAny_ts$default,
		___R$project$rome$$internal$compiler$lint$rules$ts$useInterfaces_ts$default,
	];


  // project-rome/@internal/compiler/lint/index.ts
const ___R$$priv$project$rome$$internal$compiler$lint$index_ts$lintCache = new ___R$project$rome$$internal$compiler$lib$Cache_ts$default();

	async function ___R$project$rome$$internal$compiler$lint$index_ts$default(req) {
		const {ast, project, applySafeFixes, options, suppressionExplanation} = req;

		const query = ___R$project$rome$$internal$compiler$lib$Cache_ts$default.buildQuery(
			req,
			{applySafeFixes, suppressionExplanation},
		);
		const cached = ___R$$priv$project$rome$$internal$compiler$lint$index_ts$lintCache.get(
			query,
		);
		if (cached) {
			return cached;
		}

		// Perform fixes
		let formatAst = ast;
		if (applySafeFixes) {
			const formatContext = new ___R$project$rome$$internal$compiler$lib$CompilerContext_ts$default({
				ref: req.ref,
				options,
				ast,
				project,
				frozen: false,
				origin: {
					category: "check",
				},
			});

			formatAst = formatContext.reduceRoot(
				___R$project$rome$$internal$compiler$lint$rules$index_ts$lintTransforms,
			);
			formatAst = ___R$project$rome$$internal$compiler$lint$suppressions_ts$addSuppressions(
				formatContext,
				formatAst,
				suppressionExplanation,
			);
		}
		const formattedCode = ___R$project$rome$$internal$formatter$index_ts$formatAST(
			formatAst,
		).code;

		// Run lints (could be with the autofixed AST)
		const context = new ___R$project$rome$$internal$compiler$lib$CompilerContext_ts$default({
			ref: req.ref,
			ast,
			project,
			options,
			origin: {
				category: "check",
			},
			frozen: true,
		});
		const newAst = context.reduceRoot(
			___R$project$rome$$internal$compiler$lint$rules$index_ts$lintTransforms,
		);
		if (ast !== newAst) {
			throw new Error("Expected the same ast. `frozen: true` is broken");
		}

		const diagnostics = context.diagnostics.getDiagnostics();
		const result = {
			suppressions: context.suppressions,
			diagnostics: [...ast.diagnostics, ...diagnostics],
			src: formattedCode,
		};
		___R$$priv$project$rome$$internal$compiler$lint$index_ts$lintCache.set(
			query,
			result,
		);
		return result;
	}


  // project-rome/@internal/compiler/methods/transform.ts
const ___R$$priv$project$rome$$internal$compiler$methods$transform_ts$transformCaches = ___R$project$rome$$internal$compiler$transforms$index_ts$stageOrder.map(() =>
		new ___R$project$rome$$internal$compiler$lib$Cache_ts$default()
	);

	async function ___R$project$rome$$internal$compiler$methods$transform_ts$default(
		req,
	) {
		const stage = req.stage == null ? "compile" : req.stage;

		const {options, project} = req;
		let ast = req.ast;

		const cacheQuery = ___R$project$rome$$internal$compiler$lib$Cache_ts$default.buildQuery(
			req,
		);

		const stageNo = ___R$project$rome$$internal$compiler$transforms$index_ts$stageOrder.indexOf(
			stage,
		);

		// Check this exact stage cache
		const stageCache = ___R$$priv$project$rome$$internal$compiler$methods$transform_ts$transformCaches[stageNo];
		const cached = stageCache.get(cacheQuery);
		if (cached !== undefined) {
			return cached;
		}

		let prevStageDiagnostics = [];
		let prevStageCacheDeps = [];
		let suppressions;

		// Run the previous stage
		if (stageNo > 0) {
			const prevStage = await ___R$project$rome$$internal$compiler$methods$transform_ts$default(
				Object.assign(
					{},
					req,
					{
						stage: ___R$project$rome$$internal$compiler$transforms$index_ts$stageOrder[stageNo -
						1],
					},
				),
			);
			prevStageDiagnostics = prevStage.diagnostics;
			prevStageCacheDeps = prevStage.cacheDependencies;
			ast = prevStage.ast;
			suppressions = prevStage.suppressions;
		}

		const context = new ___R$project$rome$$internal$compiler$lib$CompilerContext_ts$default({
			suppressions,
			ref: req.ref,
			ast,
			project,
			options,
			origin: {
				category: "transform",
			},
		});

		const transformFactory = ___R$project$rome$$internal$compiler$transforms$index_ts$stageTransforms[stage];
		const transforms = transformFactory(project.config, options);

		let visitors = await context.normalizeTransforms(transforms);

		const compiledAst = context.reduceRoot(visitors);

		const res = {
			suppressions: context.suppressions,
			diagnostics: [
				...prevStageDiagnostics,
				...context.diagnostics.getDiagnostics(),
			],
			cacheDependencies: [
				...prevStageCacheDeps,
				...context.getCacheDependencies(),
			],
			ast: compiledAst,
		};
		stageCache.set(cacheQuery, res);
		return res;
	}


  // project-rome/@internal/compiler/api/compile.ts
const ___R$$priv$project$rome$$internal$compiler$api$compile_ts$compileCache = new ___R$project$rome$$internal$compiler$lib$Cache_ts$default();

	async function ___R$project$rome$$internal$compiler$api$compile_ts$default(
		req,
	) {
		const {sourceText, ast} = req;

		const query = ___R$project$rome$$internal$compiler$lib$Cache_ts$default.buildQuery(
			req,
		);
		const cached = ___R$$priv$project$rome$$internal$compiler$api$compile_ts$compileCache.get(
			query,
		);
		if (cached) {
			return cached;
		}

		const {
			ast: transformedAst,
			diagnostics,
			suppressions,
			cacheDependencies,
		} = await ___R$project$rome$$internal$compiler$methods$transform_ts$default(
			req,
		);

		const formatted = ___R$project$rome$$internal$formatter$index_ts$formatAST(
			transformedAst,
			{
				typeAnnotations: false,
				indent: req.stage === "compileForBundle" ? 1 : 0,
				sourceMaps: true,
				allowInterpreterDirective: false,
			},
		);

		if (req.inputSourceMap !== undefined) {
			const inputSourceMap = ___R$project$rome$$internal$codec$source$map$SourceMapConsumer_ts$default.fromJSON(
				req.inputSourceMap,
			);
			const mappings = [];

			for (const mapping of formatted.mappings) {
				const actual = inputSourceMap.exactOriginalPositionFor(
					mapping.original.line,
					mapping.original.column,
				);

				if (actual !== undefined) {
					if (
						mapping.original.line !== actual.line ||
						mapping.original.column !== actual.column
					) {
						mappings.push(
							Object.assign(
								{},
								mapping,
								{
									original: {
										line: actual.line,
										column: actual.column,
									},
								},
							),
						);
					} else {
						mappings.push(mapping);
					}
				}
			}

			formatted.mappings = mappings;
		}

		const res = {
			compiledCode: formatted.code,
			mappings: formatted.mappings,
			diagnostics: [...ast.diagnostics, ...diagnostics],
			cacheDependencies,
			suppressions,
			sourceText,
		};

		___R$$priv$project$rome$$internal$compiler$api$compile_ts$compileCache.set(
			query,
			res,
		);
		return res;
	}


  // project-rome/@internal/compiler/api/analyzeDependencies/records.ts
class ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ImportRecord
		extends ___R$project$rome$$internal$compiler$lib$Record_ts$default {
		constructor(data) {
			super();
			this.data = data;
		}
	}

	class ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ExportRecord
		extends ___R$project$rome$$internal$compiler$lib$Record_ts$default {
		constructor(data) {
			super();
			this.data = data;
		}
	}

	class ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$EscapedCJSRefRecord
		extends ___R$project$rome$$internal$compiler$lib$Record_ts$default {
		constructor(node) {
			super();
			this.node = node;
		}
	}

	class ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$CJSExportRecord
		extends ___R$project$rome$$internal$compiler$lib$Record_ts$default {
		constructor(node) {
			super();
			this.node = node;
		}
	}

	class ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$CJSVarRefRecord
		extends ___R$project$rome$$internal$compiler$lib$Record_ts$default {
		constructor(node) {
			super();
			this.node = node;
		}
	}

	class ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ESExportRecord
		extends ___R$project$rome$$internal$compiler$lib$Record_ts$default {
		constructor(kind, node) {
			super();
			this.node = node;
			this.kind = kind;
		}
	}

	class ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$TopLevelAwaitRecord
		extends ___R$project$rome$$internal$compiler$lib$Record_ts$default {
		constructor(loc) {
			super();
			this.loc = loc;
		}
	}

	class ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ImportUsageRecord
		extends ___R$project$rome$$internal$compiler$lib$Record_ts$default {
		constructor(isTop, data) {
			super();
			this.isTop = isTop;
			this.data = data;
		}
	}


  // project-rome/@internal/compiler/api/analyzeDependencies/utils.ts
function ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$isOptional(
		path,
	) {
		for (const {node} of path.ancestryPaths) {
			if (node.type === "JSTryStatement") {
				return true;
			}
		}

		return false;
	}

	function ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$isTypeKind(
		kind,
	) {
		return kind === "type" || kind === "typeof";
	}

	function ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getImportKind(
		kind,
	) {
		return kind == null ? "value" : kind;
	}

	function ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getExportKind(
		kind,
	) {
		return kind == null ? "value" : kind;
	}

	function ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$maybeTypeBinding(
		kind,
		scope,
		id,
	) {
		const binding = scope.getBinding(id.name);
		if (
			kind === "value" &&
			binding instanceof
			___R$project$rome$$internal$compiler$scope$bindings_ts$TypeBinding
		) {
			return "type";
		} else {
			return kind;
		}
	}

	function ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getKindWithSpecifiers(
		rawKind,
		specifierKinds,
	) {
		const kind = ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getImportKind(
			rawKind,
		);
		if (
			___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$isTypeKind(
				kind,
			) ||
			specifierKinds.length === 0
		) {
			return kind;
		}

		for (const specifierKind of specifierKinds) {
			if (specifierKind === "value") {
				return "value";
			}
		}
		return "type";
	}

	function ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(
		scope,
		node,
	) {
		if (node === undefined) {
			return "other";
		}

		if (node.type === "JSIdentifier") {
			const binding = scope.getBinding(node.name);

			if (
				binding instanceof
				___R$project$rome$$internal$compiler$scope$bindings_ts$FunctionBinding
			) {
				return "function";
			}

			if (
				binding instanceof
				___R$project$rome$$internal$compiler$scope$bindings_ts$ClassBinding
			) {
				return "class";
			}

			if (
				binding instanceof
				___R$project$rome$$internal$compiler$scope$bindings_ts$TypeBinding
			) {
				const {typeKind} = binding;
				switch (typeKind) {
					case "function":
					case "class":
						return typeKind;
				}
			}
		}

		if (node.type === "JSFunctionDeclaration") {
			return "function";
		}

		if (node.type === "JSClassDeclaration" || node.type === "JSClassExpression") {
			return "class";
		}

		return "other";
	}

	function ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(
		scope,
		node,
	) {
		if (node.type === "JSReferenceIdentifier") {
			const binding = scope.getBinding(node.name);
			if (binding !== undefined) {
				return binding.node.loc;
			}
		}

		return node.loc;
	}

	function ___R$$priv$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$arraySame(
		a,
		b,
		callback,
	) {
		if (a.length !== b.length) {
			return false;
		}

		for (let i = 0; i < a.length; i++) {
			if (!callback(a[i], b[i])) {
				return false;
			}
		}

		return true;
	}

	function ___R$$priv$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$exportsSame(
		a,
		b,
	) {
		if (a.type !== b.type) {
			return false;
		}

		if (a.kind !== b.kind) {
			return false;
		}

		switch (a.type) {
			case "local":
				return b.type === "local" && a.name === b.name;

			case "external":
				return (
					b.type === "external" &&
					a.imported === b.imported &&
					a.exported === b.exported &&
					a.source === b.source
				);

			case "externalAll":
				return b.type === "externalAll" && a.source === b.source;

			case "externalNamespace":
				return (
					b.type === "externalNamespace" &&
					a.source === b.source &&
					a.exported === b.exported
				);
		}
	}

	function ___R$$priv$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$dependencyNameSame(
		a,
		b,
	) {
		return a.kind === b.kind && a.name === b.name;
	}

	function ___R$$priv$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$dependenciesSame(
		a,
		b,
	) {
		return (
			a.all === b.all &&
			a.async === b.async &&
			a.optional === b.optional &&
			a.source === b.source &&
			a.type === b.type &&
			___R$$priv$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$arraySame(
				a.names,
				b.names,
				___R$$priv$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$dependencyNameSame,
			)
		);
	}

	// Check if the shape of two analyzeDependencyResults are equal. Ignoring location information
	function ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$areAnalyzeDependencyResultsEqual(
		a,
		b,
	) {
		if (
			(a.firstTopAwaitLocation === undefined &&
			b.firstTopAwaitLocation !== undefined) ||
			(b.firstTopAwaitLocation === undefined &&
			a.firstTopAwaitLocation !== undefined)
		) {
			return false;
		}

		if (a.moduleType !== b.moduleType) {
			return false;
		}

		if (
			!___R$$priv$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$arraySame(
				a.exports,
				b.exports,
				___R$$priv$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$exportsSame,
			)
		) {
			return false;
		}

		if (
			!___R$$priv$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$arraySame(
				a.dependencies,
				b.dependencies,
				___R$$priv$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$dependenciesSame,
			)
		) {
			return false;
		}

		return true;
	}


  // project-rome/@internal/compiler/api/analyzeDependencies/visitors/es.ts
const ___R$project$rome$$internal$compiler$api$analyzeDependencies$visitors$es_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "analyzeDependenciesES",
		enter(path) {
			const {node, scope, context} = path;

			// import('./bar');
			if (
				node.type === "JSImportCall" &&
				node.argument.type === "JSStringLiteral"
			) {
				context.record(
					new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ImportRecord({
						type: "es",
						async: true,
						kind: "value",
						names: [],
						loc: node.argument.loc,
						source: node.argument.value,
						optional: ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$isOptional(
							path,
						),
						all: true,
					}),
				);
			}

			// Local bindings exports:
			// export const foo
			// export function foo() {}
			// export {};
			if (node.type === "JSExportLocalDeclaration") {
				const valueType = ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(
					scope,
					node.declaration,
				);
				for (const id of ___R$project$rome$$internal$js$ast$utils$getBindingIdentifiers_ts$getBindingIdentifiers(
					node,
				)) {
					const kind = ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$maybeTypeBinding(
						___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getExportKind(
							node.exportKind,
						),
						scope,
						id,
					);
					context.record(
						new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ExportRecord({
							type: "local",
							valueType,
							kind,
							loc: ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(
								scope,
								id,
							),
							name: id.name,
						}),
					);
				}

				const {specifiers} = node;
				if (specifiers !== undefined) {
					for (const specifier of specifiers) {
						const kind = ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$maybeTypeBinding(
							___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getExportKind(
								specifier.exportKind || node.exportKind,
							),
							scope,
							specifier.local,
						);

						context.record(
							new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ExportRecord({
								type: "local",
								loc: ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(
									scope,
									specifier.local,
								),
								valueType: ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(
									scope,
									specifier.local,
								),
								kind,
								name: specifier.exported.name,
							}),
						);
					}
				}
			}

			// export default
			if (node.type === "JSExportDefaultDeclaration") {
				context.record(
					new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ExportRecord({
						type: "local",
						loc: ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(
							scope,
							node.declaration,
						),
						valueType: ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(
							scope,
							node.declaration,
						),
						kind: "value",
						name: "default",
					}),
				);
			}

			// External binding exports:
			// export {} from '';
			if (node.type === "JSExportExternalDeclaration") {
				const {source} = node;
				const specifiersKinds = [];
				const exportedNames = [];

				const {namedSpecifiers, defaultSpecifier, namespaceSpecifier} = node;

				if (defaultSpecifier !== undefined) {
					context.record(
						new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ExportRecord({
							type: "external",
							kind: "value",
							loc: defaultSpecifier.loc,
							imported: "default",
							exported: defaultSpecifier.exported.name,
							source: source.value,
						}),
					);
				}

				if (namespaceSpecifier !== undefined) {
					context.record(
						new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ExportRecord({
							type: "externalNamespace",
							kind: "value",
							loc: namespaceSpecifier.loc,
							exported: namespaceSpecifier.exported.name,
							source: source.value,
						}),
					);
				}

				for (const specifier of namedSpecifiers) {
					const kind = ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getImportKind(
						specifier.exportKind || node.exportKind,
					);
					specifiersKinds.push(kind);

					exportedNames.push({
						name: specifier.local.name,
						kind,
						loc: specifier.loc,
					});

					context.record(
						new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ExportRecord({
							type: "external",
							kind,
							loc: specifier.loc,
							imported: specifier.local.name,
							exported: specifier.exported.name,
							source: source.value,
						}),
					);
				}

				context.record(
					new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ImportRecord({
						type: "es",
						async: false,
						kind: ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getKindWithSpecifiers(
							node.exportKind,
							specifiersKinds,
						),
						names: exportedNames,
						loc: source.loc,
						source: source.value,
						optional: ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$isOptional(
							path,
						),
						all: false,
					}),
				);
			}

			// TS: import A = require('B');
			if (
				node.type === "TSImportEqualsDeclaration" &&
				node.moduleReference.type === "TSExternalModuleReference"
			) {
				context.record(
					new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ImportRecord({
						type: "cjs",
						kind: "value",
						optional: ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$isOptional(
							path,
						),
						loc: node.loc,
						source: node.moduleReference.expression.value,
						names: [],
						all: true,
						async: false,
					}),
				);
			}

			// export * from '';
			if (node.type === "JSExportAllDeclaration") {
				context.record(
					new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ImportRecord({
						type: "es",
						async: false,
						kind: ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getExportKind(
							node.exportKind,
						),
						optional: ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$isOptional(
							path,
						),
						loc: node.source.loc,
						names: [],
						source: node.source.value,
						all: true,
					}),
				);

				context.record(
					new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ExportRecord({
						type: "externalAll",
						loc: node.loc,
						kind: ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getExportKind(
							node.exportKind,
						),
						source: node.source.value,
					}),
				);
			}

			if (
				node.type === "JSExportAllDeclaration" ||
				node.type === "JSExportDefaultDeclaration" ||
				node.type === "JSExportLocalDeclaration"
			) {
				context.record(
					new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ESExportRecord(
						___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getExportKind(
							node.exportKind,
						),
						node,
					),
				);
			}

			// import {} from '';
			// import * as foo from '';
			if (node.type === "JSImportDeclaration") {
				let hasNamespaceSpecifier = false;
				const specifierKinds = [];
				const names = [];

				for (const specifier of ___R$project$rome$$internal$js$ast$utils$getImportSpecifiers_ts$getImportSpecifiers(
					node,
				)) {
					if (specifier.type === "JSImportNamespaceSpecifier") {
						hasNamespaceSpecifier = true;
						break;
					}

					const kind = ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getImportKind(
						node.importKind,
					);
					specifierKinds.push(kind);

					if (specifier.type === "JSImportDefaultSpecifier") {
						names.push({
							kind,
							loc: specifier.loc,
							name: "default",
						});
					}

					if (specifier.type === "JSImportSpecifier") {
						names.push({
							kind,
							loc: specifier.loc,
							name: specifier.imported.name,
						});
					}
				}

				context.record(
					new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ImportRecord({
						type: "es",
						async: false,
						kind: ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getKindWithSpecifiers(
							node.importKind,
							specifierKinds,
						),
						loc: node.source.loc,
						optional: ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$isOptional(
							path,
						),
						source: node.source.value,
						all: hasNamespaceSpecifier,
						names,
					}),
				);
			}

			// Detect top level await
			if (
				node.type === "JSAwaitExpression" &&
				path.findAncestry((path) =>
					___R$project$rome$$internal$js$ast$utils$isFunctionNode_ts$isFunctionNode(
						path.node,
					)
				) === undefined
			) {
				const {loc} = node;
				if (loc === undefined) {
					throw new Error(
						"loc is undefined on JSAwaitExpression we want to mark",
					);
				}
				context.record(
					new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$TopLevelAwaitRecord(
						loc,
					),
				);
			}

			if (node.type === "JSReferenceIdentifier") {
				const binding = path.scope.getBinding(node.name);

				// Mark references to imports outside of functions
				if (
					binding !== undefined &&
					binding instanceof
					___R$project$rome$$internal$compiler$scope$bindings_ts$ImportBinding
				) {
					const {meta} = binding;

					// We can skip this if it's referencing a namespace
					if (meta.type !== "name") {
						return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
					}

					// These are nodes that will defer the execution of code outside the init path
					// (They could still be triggered with an actual function call but this is just for some basic analysis)
					const deferredExecution = path.findAncestry((path) =>
						___R$project$rome$$internal$js$ast$utils$isFunctionNode_ts$isFunctionNode(
							path.node,
						) || path.node.type === "JSClassProperty"
					);
					const isTop = deferredExecution === undefined;

					let kind = ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getImportKind(
						meta.kind,
					);
					if (
						___R$project$rome$$internal$js$ast$utils$isInTypeAnnotation_ts$isInTypeAnnotation(
							path,
						)
					) {
						kind = "type";
					}

					context.record(
						new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ImportUsageRecord(
							isTop,
							{
								kind,
								loc: node.loc,
								local: node.name,
								imported: meta.imported,
								source: meta.source,
							},
						),
					);
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/api/analyzeDependencies/visitors/cjs.ts
const ___R$project$rome$$internal$compiler$api$analyzeDependencies$visitors$cjs_ts$default = ___R$project$rome$$internal$compiler$utils_ts$createVisitor({
		name: "analyzeDependenciesCJS",
		enter(path) {
			const {node, parent, scope, context} = path;

			// Handle require()
			if (node.type === "JSCallExpression") {
				const {callee, arguments: args} = node;

				const isRequire =
					callee.type === "JSReferenceIdentifier" &&
					callee.name === "require" &&
					!path.scope.hasBinding("require");
				const sourceArg = args[0];

				if (
					isRequire &&
					args.length === 1 &&
					sourceArg.type === "JSStringLiteral"
				) {
					context.record(
						new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ImportRecord({
							type: "cjs",
							kind: "value",
							optional: ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$isOptional(
								path,
							),
							loc: node.loc,
							source: sourceArg.value,
							names: [],
							all: true,
							async: false,
						}),
					);
				}
			}

			// Detect assignments to exports and module.exports as definitely being an CJS module
			if (node.type === "JSAssignmentExpression") {
				const isModuleExports =
					path.scope.getBinding("module") === undefined &&
					(___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
						node.left,
						"module.exports",
					) ||
					___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
						node.left,
						"module.exports.**",
					));
				const isExports =
					path.scope.getBinding("exports") === undefined &&
					(___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
						node.left,
						"exports",
					) ||
					___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
						node.left,
						"exports.**",
					));

				if (isModuleExports || isExports) {
					context.record(
						new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$CJSExportRecord(
							node,
						),
					);
				}

				if (isModuleExports) {
					const {right} = node;

					if (right.type === "JSObjectExpression") {
						context.record(
							new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ExportRecord({
								type: "local",
								loc: ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(
									scope,
									node.right,
								),
								valueType: ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(
									scope,
									node.right,
								),
								kind: "value",
								name: "default",
							}),
						);

						for (const prop of right.properties) {
							// Don't allow spread, unknown, or computed properties
							if (
								prop.type === "JSSpreadProperty" ||
								(prop.key.type === "JSComputedPropertyKey" &&
								prop.key.value.type !== "JSStringLiteral")
							) {
								context.record(
									new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$EscapedCJSRefRecord(
										prop,
									),
								);
								continue;
							}

							const key = prop.key.value;
							let name;
							if (key.type === "JSIdentifier") {
								name = key.name;
							} else if (key.type === "JSStringLiteral") {
								name = key.value;
							} else {
								// Unknown key literal
								context.record(
									new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$EscapedCJSRefRecord(
										key,
									),
								);
								continue;
							}

							let target = prop.type === "JSObjectMethod" ? prop : prop.value;

							context.record(
								new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ExportRecord({
									type: "local",
									loc: ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(
										scope,
										target,
									),
									valueType: ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(
										scope,
										target,
									),
									kind: "value",
									name,
								}),
							);
						}
					} else {
						const source = ___R$project$rome$$internal$js$ast$utils$getRequireSource_ts$getRequireSource(
							node.right,
							scope,
						);
						if (source === undefined) {
							context.record(
								new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ExportRecord({
									type: "local",
									loc: ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(
										scope,
										node.right,
									),
									valueType: ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(
										scope,
										node.right,
									),
									kind: "value",
									name: "default",
								}),
							);
						} else {
							context.record(
								new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ExportRecord({
									type: "externalAll",
									loc: ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(
										scope,
										node.right,
									),
									kind: "value",
									source,
								}),
							);

							context.record(
								new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ExportRecord({
									type: "external",
									kind: "value",
									loc: ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(
										scope,
										node.right,
									),
									imported: "default",
									exported: "default",
									source,
								}),
							);
						}
					}
				}

				if (isExports) {
					const {parts} = ___R$project$rome$$internal$js$ast$utils$getNodeReferenceParts_ts$getNodeReferenceParts(
						node.left,
					);

					if (parts.length >= 2) {
						// parts[0] is exports
						const name = parts[1].value;

						context.record(
							new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ExportRecord({
								type: "local",
								loc: ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(
									scope,
									node.right,
								),
								valueType: ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(
									scope,
									node.right,
								),
								kind: "value",
								name,
							}),
						);
					}
				}
			}

			if (node.type === "JSReferenceIdentifier") {
				const binding = path.scope.getBinding(node.name);

				// Detect references to exports and module
				if (binding === undefined) {
					if (
						node.name === "__filename" ||
						node.name === "__dirname" ||
						node.name === "require" ||
						node.name === "module" ||
						node.name === "exports"
					) {
						context.record(
							new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$CJSVarRefRecord(
								node,
							),
						);
					}

					if (node.name === "module" || node.name === "exports") {
						const inMemberExpression =
							parent.type === "JSMemberExpression" && parent.object === node;
						if (!inMemberExpression) {
							context.record(
								new ___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$EscapedCJSRefRecord(
									node,
								),
							);
						}
					}
				}
			}

			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		},
	});


  // project-rome/@internal/compiler/api/analyzeDependencies/visitors/index.ts
const ___R$project$rome$$internal$compiler$api$analyzeDependencies$visitors$index_ts$default = [
		___R$project$rome$$internal$compiler$api$analyzeDependencies$visitors$es_ts$default,
		___R$project$rome$$internal$compiler$api$analyzeDependencies$visitors$cjs_ts$default,
	];


  // project-rome/@internal/compiler/api/analyzeDependencies/index.ts
const ___R$$priv$project$rome$$internal$compiler$api$analyzeDependencies$index_ts$analyzeCache = new ___R$project$rome$$internal$compiler$lib$Cache_ts$default();

	async function ___R$project$rome$$internal$compiler$api$analyzeDependencies$index_ts$default(
		req,
	) {
		let {ast, project} = req;

		const query = ___R$project$rome$$internal$compiler$lib$Cache_ts$default.buildQuery(
			req,
		);
		const cached = ___R$$priv$project$rome$$internal$compiler$api$analyzeDependencies$index_ts$analyzeCache.get(
			query,
		);
		if (cached) {
			return cached;
		}

		const context = new ___R$project$rome$$internal$compiler$lib$CompilerContext_ts$default({
			ref: req.ref,
			ast,
			project,
			origin: {
				category: "analyzeDependencies",
			},
		});
		({ast} = await ___R$project$rome$$internal$compiler$methods$transform_ts$default(
			Object.assign({}, req, {stage: "pre"}),
		));
		context.reduce(
			ast,
			___R$project$rome$$internal$compiler$api$analyzeDependencies$visitors$index_ts$default,
		);

		//
		const importFirstUsage = [];
		const seenImportFirstUsage = new Set();

		// Extract records
		const exports = [];
		const dependenciesBySource = new Map();

		const esValueExports = [];
		const cjsExports = [];
		let firstTopAwaitLocation;

		// TODO description
		//let hasCJSRef = false;

		// Whether we have a default export, used to automatically add one for CJS
		let hasDefaultExport = false;

		// Find the import sources that are only used as a type
		const sourcesUsedAsType = new Set();
		const sourcesUsedAsValue = new Set();
		for (const record of context.records) {
			let data;

			if (
				record instanceof
				___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ImportUsageRecord
			) {
				data = record.data;
			}

			// This has to be a separate if or else TS wont refine it...
			if (
				record instanceof
				___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ExportRecord &&
				record.data.type !== "local"
			) {
				data = record.data;
			}

			if (data !== undefined) {
				const {kind, source} = data;
				if (kind === "type") {
					sourcesUsedAsType.add(source);
				} else {
					sourcesUsedAsValue.add(source);
				}
			}
		}
		for (const source of sourcesUsedAsValue) {
			sourcesUsedAsType.delete(source);
		}

		// Process rest of the records
		for (const record of context.records) {
			if (
				record instanceof
				___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$EscapedCJSRefRecord
			) {
				exports.push({
					type: "local",
					loc: record.node.loc,
					kind: "value",
					valueType: "other",
					name: "*",
				});
			}

			if (
				record instanceof
				___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ImportRecord
			) {
				let {data} = record;

				// If this source was only ever used as a type then convert us to a value
				if (
					data.type === "es" &&
					data.kind === "value" &&
					sourcesUsedAsType.has(data.source)
				) {
					const names = [];

					for (const name of data.names) {
						names.push(Object.assign({}, name, {kind: "type"}));
					}

					data = Object.assign({}, data, {kind: "type", names});
				}

				// If we have multiple import records for this file, then merge them together
				const existing = dependenciesBySource.get(data.source);
				if (existing === undefined) {
					dependenciesBySource.set(data.source, data);
				} else {
					let kind;
					if (data.kind === existing.kind) {
						kind = data.kind;
					} else {
						kind = "value";
					}

					const combinedRecord = {
						type: data.type === "es" && existing.type === "es" ? "es" : "cjs",
						kind,
						optional: existing.optional && data.optional,
						async: existing.async || data.async,
						source: data.source,
						all: existing.all || data.all,
						names: [...existing.names, ...data.names],
						loc: existing.loc || data.loc,
					};

					// Map ordering is by insertion time, so in the case where the previous import was a type import
					// then we don't want to place our combined record in that position, it should be at the end.
					// Inserting a type import statement at the top of the file shouldn't change the execution order
					// if it was imported later
					if (existing.kind === "type" && data.kind === "value") {
						dependenciesBySource.delete(data.source);
					}

					dependenciesBySource.set(data.source, combinedRecord);
				}
			} else if (
				record instanceof
				___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ExportRecord
			) {
				exports.push(record.data);
			} else if (
				record instanceof
				___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$CJSVarRefRecord
			) {
				//hasCJSRef = true;
			} else if (
				record instanceof
				___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$CJSExportRecord
			) {
				cjsExports.push(record.node);
			} else if (
				record instanceof
				___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ESExportRecord
			) {
				// No point checking for ES imported in CJS because it would have been a syntax error
				if (record.kind === "value") {
					esValueExports.push(record.node);
				}
			} else if (
				record instanceof
				___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$TopLevelAwaitRecord
			) {
				if (firstTopAwaitLocation === undefined) {
					firstTopAwaitLocation = record.loc;
				}
			} else if (
				record instanceof
				___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$ImportUsageRecord &&
				record.isTop &&
				record.data.kind === "value"
			) {
				// Track the first reference to a value import that's not in a function
				// This is used to detect module cycles
				const {data} = record;
				const key = data.source + ":" + data.imported;
				if (seenImportFirstUsage.has(key)) {
					continue;
				}

				seenImportFirstUsage.add(key);
				importFirstUsage.push(data);
			}
		}

		// Build dependencies
		const dependencies = Array.from(dependenciesBySource.values());

		// Infer the module type
		let moduleType = "unknown";

		if (ast.type === "JSRoot") {
			moduleType = ast.sourceType === "script" ? "cjs" : "es";
		}

		//
		for (const record of context.records) {
			if (
				record instanceof
				___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$CJSVarRefRecord
			) {
				if (moduleType === "es") {
					/*context.addNodeDiagnostic(record.node, {
          category: 'analyzeDependencies',
          message: `CommonJS variable <emphasis>${
            record.node.name
          }</emphasis> is not available in an ES module`,
        });*/
				}
			} else if (
				record instanceof
				___R$project$rome$$internal$compiler$api$analyzeDependencies$records_ts$CJSExportRecord
			) {
				if (moduleType === "es") {
					context.addNodeDiagnostic(
						record.node,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.ANALYZE_DEPENDENCIES.CJS_EXPORT_IN_ES,
					);
				}
			}
		}

		// Add an implicit default import for CJS if there is none
		if (moduleType === "cjs" && !hasDefaultExport) {
			exports.push({
				type: "local",
				loc: undefined,
				kind: "value",
				valueType: "other",
				name: "default",
			});
		}

		const topLevelLocalBindings = {};

		// Get all top level bindings
		for (const [name, binding] of context.rootScope.enterEvaluate(ast).getOwnBindings()) {
			topLevelLocalBindings[name] = binding.node.loc;
		}

		const res = {
			topLevelLocalBindings,
			moduleType,
			firstTopAwaitLocation,
			exports,
			dependencies,
			importFirstUsage,
			diagnostics: [...ast.diagnostics, ...context.diagnostics.getDiagnostics()],
		};
		___R$$priv$project$rome$$internal$compiler$api$analyzeDependencies$index_ts$analyzeCache.set(
			query,
			res,
		);
		return res;
	}

	function ___R$project$rome$$internal$compiler$api$analyzeDependencies$index_ts$mergeAnalyzeDependencies(
		main,
		second,
	) {
		const exports = [...main.exports];

		// Take only local type exports
		for (const exp of second.exports) {
			if (exp.type === "local" && exp.kind === "type") {
				exports.push(exp);
			}

			// Ensure that all external exports are only reachable with `type`
			if (exp.type === "external" || exp.type === "externalAll") {
				exports.push(Object.assign({}, exp, {kind: "type"}));
			}
		}

		return Object.assign(
			{},
			main,
			{exports, diagnostics: [...main.diagnostics, ...second.diagnostics]},
		);
	}


  // project-rome/@internal/compiler/types.ts
const ___R$project$rome$$internal$compiler$types_ts = {};


  // project-rome/@internal/compiler/index.ts
const ___R$project$rome$$internal$compiler$index_ts = {
		get CompilerContext() {
			return ___R$project$rome$$internal$compiler$lib$CompilerContext_ts$default;
		},
		get PathOptions() {
			return ___R$project$rome$$internal$compiler$lib$Path_ts$PathOptions;
		},
		get Path() {
			return ___R$project$rome$$internal$compiler$lib$Path_ts$default;
		},
		get Record() {
			return ___R$project$rome$$internal$compiler$lib$Record_ts$default;
		},
		get Cache() {
			return ___R$project$rome$$internal$compiler$lib$Cache_ts$default;
		},
		get lint() {
			return ___R$project$rome$$internal$compiler$lint$index_ts$default;
		},
		get compile() {
			return ___R$project$rome$$internal$compiler$api$compile_ts$default;
		},
		get analyzeDependencies() {
			return ___R$project$rome$$internal$compiler$api$analyzeDependencies$index_ts$default;
		},
		get mergeAnalyzeDependencies() {
			return ___R$project$rome$$internal$compiler$api$analyzeDependencies$index_ts$mergeAnalyzeDependencies;
		},
		get Scope() {
			return ___R$project$rome$$internal$compiler$scope$Scope_ts$default;
		},
		get signals() {
			return ___R$project$rome$$internal$compiler$signals_ts;
		},
		get EnterSignal() {
			return ___R$project$rome$$internal$compiler$signals_ts$EnterSignal;
		},
		get ExitSignal() {
			return ___R$project$rome$$internal$compiler$signals_ts$ExitSignal;
		},
		get ParentSignal() {
			return ___R$project$rome$$internal$compiler$signals_ts$ParentSignal;
		},
		get RemoveSignal() {
			return ___R$project$rome$$internal$compiler$signals_ts$RemoveSignal;
		},
		get ReplaceSignal() {
			return ___R$project$rome$$internal$compiler$signals_ts$ReplaceSignal;
		},
		get SkipSignal() {
			return ___R$project$rome$$internal$compiler$signals_ts$SkipSignal;
		},
		get areAnalyzeDependencyResultsEqual() {
			return ___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$areAnalyzeDependencyResultsEqual;
		},
		get getPrefixedBundleNamespace() {
			return ___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace;
		},
		get matchesSuppression() {
			return ___R$project$rome$$internal$compiler$suppressions_ts$matchesSuppression;
		},
		get LintResult() {
			return ___R$project$rome$$internal$compiler$lint$index_ts$LintResult;
		},
		get CompileResult() {
			return ___R$project$rome$$internal$compiler$api$compile_ts$CompileResult;
		},
	};
	Object.keys(___R$project$rome$$internal$compiler$lint$decisions_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$compiler$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$compiler$lint$decisions_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$compiler$scope$bindings_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$compiler$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$compiler$scope$bindings_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$compiler$utils_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$compiler$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$compiler$utils_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$compiler$constants_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$compiler$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$compiler$constants_ts[key];
				},
			},
		);
	});
	const ___R$project$rome$$internal$compiler$index_ts$signals = ___R$project$rome$$internal$compiler$signals_ts;
	Object.keys(___R$project$rome$$internal$compiler$types_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$compiler$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$compiler$types_ts[key];
				},
			},
		);
	});


  // project-rome/@internal/js-ast-utils/renameBindings.ts
function ___R$project$rome$$internal$js$ast$utils$renameBindings_ts$renameBindings(
		path,
		oldToNewMapping,
	) {
		if (oldToNewMapping.size === 0) {
			return path.node;
		}

		const oldBindingToNewName = new Map();

		// get a list of the current bindings for this scope
		const oldNameToBinding = new Map();
		for (const [oldName, newName] of oldToNewMapping) {
			if (typeof oldName === "string") {
				const binding = path.scope.getBinding(oldName);
				oldNameToBinding.set(oldName, binding);
			} else {
				oldBindingToNewName.set(oldName, newName);
			}
		}

		// discover nodes to replace first without manipulating the AST as that will change the scope and binding objects
		const replaceNodesWithName = new Map();
		path.traverse(
			"renameBindingsCollector",
			(path) => {
				const {node, scope} = path;
				if (
					!___R$project$rome$$internal$js$ast$utils$isVariableIdentifier_ts$isVariableIdentifier(
						node,
					)
				) {
					return;
				}

				const binding = scope.getBinding(node.name);

				// oldName -> newName
				if (
					oldToNewMapping.has(node.name) &&
					binding === oldNameToBinding.get(node.name)
				) {
					const newName = oldToNewMapping.get(node.name);
					if (newName === undefined) {
						throw new Error("Should exist");
					}
					replaceNodesWithName.set(node, newName);
				}

				// Binding -> newName
				if (binding !== undefined && oldBindingToNewName.has(binding)) {
					const newName = oldBindingToNewName.get(binding);
					if (newName === undefined) {
						throw new Error("Should exist");
					}
					replaceNodesWithName.set(node, newName);
				}
			},
		);
		if (replaceNodesWithName.size === 0) {
			return path.node;
		}

		//
		const replaced = new Set();

		// replace the nodes
		const renamedNode = path.reduceNode(
			{
				name: "renameBindings",
				enter(path) {
					const {node} = path;

					// Retain the correct exported name for `export function` and `export class`
					if (
						node.type === "JSExportLocalDeclaration" &&
						node.declaration !== undefined &&
						(node.declaration.type === "JSFunctionDeclaration" ||
						node.declaration.type === "JSClassDeclaration")
					) {
						const id = node.declaration.id;
						const oldName = id.name;
						const newName = replaceNodesWithName.get(id);

						if (newName !== undefined) {
							replaced.add(id);

							return ___R$project$rome$$internal$compiler$index_ts$signals.replace([
								node.declaration,
								___R$project$rome$$internal$ast$js$modules$JSExportLocalDeclaration_ts$jsExportLocalDeclaration.create({
									specifiers: [
										___R$project$rome$$internal$ast$js$modules$JSExportLocalSpecifier_ts$jsExportLocalSpecifier.create({
											loc: id.loc,
											local: ___R$project$rome$$internal$ast$js$expressions$JSReferenceIdentifier_ts$jsReferenceIdentifier.quick(
												newName,
											),
											exported: ___R$project$rome$$internal$ast$js$auxiliary$JSIdentifier_ts$jsIdentifier.quick(
												oldName,
											),
										}),
									],
								}),
							]);
						}
					}

					// Retain the correct exported names for `export const`
					if (
						node.type === "JSExportLocalDeclaration" &&
						node.declaration !== undefined
					) {
						const bindings = ___R$project$rome$$internal$js$ast$utils$getBindingIdentifiers_ts$getBindingIdentifiers(
							node.declaration,
						);
						let includesAny = false;
						for (const node of bindings) {
							if (replaceNodesWithName.has(node)) {
								includesAny = true;
								break;
							}
						}

						if (includesAny) {
							return ___R$project$rome$$internal$compiler$index_ts$signals.replace([
								node.declaration,
								___R$project$rome$$internal$ast$js$modules$JSExportLocalDeclaration_ts$jsExportLocalDeclaration.create({
									specifiers: bindings.map((node) => {
										let local = node.name;

										const newName = replaceNodesWithName.get(node);
										if (newName !== undefined) {
											local = newName;
											replaced.add(node);
										}

										return ___R$project$rome$$internal$ast$js$modules$JSExportLocalSpecifier_ts$jsExportLocalSpecifier.create({
											loc: node.loc,
											local: ___R$project$rome$$internal$ast$js$expressions$JSReferenceIdentifier_ts$jsReferenceIdentifier.quick(
												local,
											),
											exported: ___R$project$rome$$internal$ast$js$auxiliary$JSIdentifier_ts$jsIdentifier.quick(
												node.name,
											),
										});
									}),
								}),
							]);
						}
					}

					if (
						___R$project$rome$$internal$js$ast$utils$isVariableIdentifier_ts$isVariableIdentifier(
							node,
						)
					) {
						const newName = replaceNodesWithName.get(node);
						if (newName !== undefined) {
							replaced.add(node);
							return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
								Object.assign(
									{},
									node,
									{
										name: newName,
										loc: ___R$project$rome$$internal$js$ast$utils$inheritLoc_ts$inheritLoc(
											node,
											node.name,
										),
									},
								),
							);
						}
					}

					return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
				},
			},
			{
				noScopeCreation: true,
			},
		);

		//
		if (replaced.size !== replaceNodesWithName.size) {
			throw new Error("Missed some bindings");
		}

		return ___R$project$rome$$internal$js$ast$utils$assertSingleOrMultipleNodes_ts$assertSingleOrMultipleNodes(
			renamedNode,
		);
	}


  // project-rome/@internal/js-ast-utils/template.ts
const ___R$$priv$project$rome$$internal$js$ast$utils$template_ts$templateCache = new Map();

	function ___R$$priv$project$rome$$internal$js$ast$utils$template_ts$getTemplate(
		strs,
	) {
		const cached = ___R$$priv$project$rome$$internal$js$ast$utils$template_ts$templateCache.get(
			strs,
		);
		if (cached) {
			return cached;
		}

		// calculate amount of placeholders to insert
		const pathCount = strs.length - 1;

		// create path ids
		let placeholders = {};
		const placeholderIds = [];
		for (let i = 0; i < pathCount; i++) {
			const id = "__" + String(i) + "__";
			placeholderIds.push(id);
			placeholders[id] = undefined;
		}

		// interpolate placeholders and original code
		let code = "";
		for (let i = 0; i < strs.length; i++) {
			// add original part of code
			code += strs[i];

			// add in placeholder
			const placeholder = placeholderIds[i];
			if (placeholder) {
				code += placeholder;
			}
		}

		// parse the interpolated code
		let ast = ___R$project$rome$$internal$js$parser$index_ts$parseJS({
			input: code,
			sourceType: "template",
			path: ___R$project$rome$$internal$path$index_ts$createUnknownPath(
				"template",
			),
		});

		// remove `loc` properties
		ast = ___R$project$rome$$internal$ast$js$core$JSRoot_ts$jsRoot.assert(
			___R$project$rome$$internal$ast$utils$removeLoc_ts$removeLoc(ast),
		);

		// traverse and find placeholders paths
		function collectPlaceholderPaths(path) {
			const {node} = path;
			if (
				___R$project$rome$$internal$js$ast$utils$isIdentifierish_ts$isIdentifierish(
					node,
				) &&
				node.name in placeholders
			) {
				placeholders[node.name] = {
					type: node.type,
					path: path.getPathKeys(),
				};
			}
			return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
		}

		const context = new ___R$project$rome$$internal$compiler$lib$CompilerContext_ts$default({
			ast,
		});
		context.reduce(
			ast,
			[{name: "collectPlaceholderPaths", enter: collectPlaceholderPaths}],
		);

		const placeholderPaths = [];
		for (const id in placeholders) {
			const path = placeholders[id];
			if (path === undefined) {
				throw new Error("Failed to find placeholder path for " + id);
			} else {
				placeholderPaths.push(path);
			}
		}

		return {ast, placeholderPaths};
	}

	function ___R$$priv$project$rome$$internal$js$ast$utils$template_ts$createIdentifier(
		substitute,
		expectedIdType,
	) {
		if (typeof substitute === "string") {
			// @ts-ignore: No idea why this error exists
			return {
				type: expectedIdType,
				name: substitute,
			};
		} else {
			return substitute;
		}
	}

	function ___R$project$rome$$internal$js$ast$utils$template_ts$template(
		strs,
		...substitutions
	) {
		const {ast, placeholderPaths} = ___R$$priv$project$rome$$internal$js$ast$utils$template_ts$getTemplate(
			strs,
		);

		// no substitutions so we can just return the ast!
		if (!substitutions.length) {
			return ast;
		}

		// this case should never be hit
		if (placeholderPaths.length !== substitutions.length) {
			throw new Error("Expected subtituions to be the same length as paths");
		}

		const newAst = Object.assign({}, ast);

		for (let i = 0; i < placeholderPaths.length; i++) {
			const {type, path} = placeholderPaths[i];

			const substitute = ___R$$priv$project$rome$$internal$js$ast$utils$template_ts$createIdentifier(
				substitutions[i],
				type,
			);
			// rome-ignore lint/ts/noExplicitAny: future cleanup
			let target = newAst;

			for (let i = 0; i < path.length; i++) {
				const key = path[i];
				const isLast = i === path.length - 1;

				if (isLast) {
					target[key] = substitute;
				} else {
					let currTarget = target[key];
					if (Array.isArray(currTarget)) {
						currTarget = currTarget.slice();
					} else {
						currTarget = Object.assign({}, currTarget);
					}
					target[key] = currTarget;
					target = currTarget;
				}
			}
		}

		return newAst;
	}

	___R$project$rome$$internal$js$ast$utils$template_ts$template.expression = (
		strs,
		...substitutions
	) => {
		var ___R$;
		const first =
			(___R$ = ___R$project$rome$$internal$js$ast$utils$template_ts$template,
			___R$.statement.apply(___R$, [strs, ...substitutions]));

		// Ensure that the single statement is an JSExpressionStatement
		if (first.type !== "JSExpressionStatement") {
			throw new Error("Single statement should be an JSExpressionStatement");
		}

		return first.expression;
	};

	___R$project$rome$$internal$js$ast$utils$template_ts$template.statement = (
		strs,
		...substitutions
	) => {
		// Parse the template, with caching
		const ast = ___R$project$rome$$internal$ast$js$core$JSRoot_ts$jsRoot.assert(
			___R$project$rome$$internal$js$ast$utils$template_ts$template.apply(
				null,
				[strs, ...substitutions],
			),
		);

		// Ensure that there's only a single statement in the JSRoot body
		const body = ast.body;
		if (body.length !== 1) {
			throw new Error("More than one statement isn't allowed for a template.");
		}
		return body[0];
	};


  // project-rome/@internal/js-ast-utils/createPropertyKey.ts
function ___R$project$rome$$internal$js$ast$utils$createPropertyKey_ts$createPropertyKey(
		name,
	) {
		if (
			___R$project$rome$$internal$js$ast$utils$isValidIdentifierName_ts$isValidIdentifierName(
				name,
			)
		) {
			return ___R$project$rome$$internal$ast$js$auxiliary$JSIdentifier_ts$jsIdentifier.quick(
				name,
			);
		} else {
			return ___R$project$rome$$internal$ast$js$literals$JSStringLiteral_ts$jsStringLiteral.quick(
				name,
			);
		}
	}


  // project-rome/@internal/js-ast-utils/valueToNode.ts
function ___R$project$rome$$internal$js$ast$utils$valueToNode_ts$valueToNode(
		value,
		ancestry = [],
	) {
		if (ancestry.includes(value)) {
			throw new Error("Recursion detected");
		}

		switch (typeof value) {
			case "string":
				return ___R$project$rome$$internal$ast$js$literals$JSStringLiteral_ts$jsStringLiteral.quick(
					value,
				);

			case "boolean":
				return ___R$project$rome$$internal$ast$js$literals$JSBooleanLiteral_ts$jsBooleanLiteral.quick(
					value,
				);

			case "number":
				return ___R$project$rome$$internal$ast$js$literals$JSNumericLiteral_ts$jsNumericLiteral.quick(
					value,
				);

			case "undefined":
				return ___R$project$rome$$internal$ast$js$expressions$JSReferenceIdentifier_ts$jsReferenceIdentifier.quick(
					"undefined",
				);

			case "object": {
				if (value === null) {
					return ___R$project$rome$$internal$ast$js$literals$JSNullLiteral_ts$jsNullLiteral.create({

					});
				}

				const subAncestry = [...ancestry, value];

				if (Array.isArray(value)) {
					return ___R$project$rome$$internal$ast$js$expressions$JSArrayExpression_ts$jsArrayExpression.quick(
						value.map((elem) =>
							___R$project$rome$$internal$js$ast$utils$valueToNode_ts$valueToNode(
								elem,
								subAncestry,
							)
						),
					);
				}

				const obj = (value);
				const props = [];

				for (let key in obj) {
					props.push(
						___R$project$rome$$internal$ast$js$objects$JSObjectProperty_ts$jsObjectProperty.create({
							key: ___R$project$rome$$internal$ast$js$objects$JSStaticPropertyKey_ts$jsStaticPropertyKey.create({
								value: ___R$project$rome$$internal$js$ast$utils$createPropertyKey_ts$createPropertyKey(
									key,
								),
							}),
							value: ___R$project$rome$$internal$js$ast$utils$valueToNode_ts$valueToNode(
								obj[key],
								subAncestry,
							),
						}),
					);
				}

				return ___R$project$rome$$internal$ast$js$objects$JSObjectExpression_ts$jsObjectExpression.quick(
					props,
				);
			}

			default:
				throw new Error("Do not know how to turn this value into a literal");
		}
	}


  // project-rome/@internal/js-ast-utils/createMemberProperty.ts
function ___R$project$rome$$internal$js$ast$utils$createMemberProperty_ts$createMemberProperty(
		name,
	) {
		if (
			___R$project$rome$$internal$js$ast$utils$isValidIdentifierName_ts$isValidIdentifierName(
				name,
			)
		) {
			return ___R$project$rome$$internal$ast$js$auxiliary$JSStaticMemberProperty_ts$jsStaticMemberProperty.quick(
				___R$project$rome$$internal$ast$js$auxiliary$JSIdentifier_ts$jsIdentifier.quick(
					name,
				),
			);
		} else {
			return ___R$project$rome$$internal$ast$js$auxiliary$JSComputedMemberProperty_ts$jsComputedMemberProperty.quick(
				___R$project$rome$$internal$ast$js$literals$JSStringLiteral_ts$jsStringLiteral.quick(
					name,
				),
			);
		}
	}


  // project-rome/@internal/js-ast-utils/getJSXAttribute.ts
function ___R$$priv$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$isEmptyAttributeValue(
		node,
	) {
		switch (node.type) {
			case "JSStringLiteral":
				return node.value === "";

			case "JSXExpressionContainer":
				return ___R$$priv$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$isEmptyAttributeValue(
					node.expression,
				);

			case "JSReferenceIdentifier":
				return node.name === "undefined";

			case "JSXEmptyExpression":
				return true;

			default:
				return false;
		}
	}

	function ___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
		tag,
		name,
		allowEmpty = false,
	) {
		for (const attr of tag.attributes) {
			if (attr.type === "JSXAttribute" && attr.name.name === name) {
				const {value} = attr;

				if (
					value !== undefined &&
					!allowEmpty &&
					___R$$priv$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$isEmptyAttributeValue(
						value,
					)
				) {
					return undefined;
				}

				return attr;
			}
		}
		return undefined;
	}


  // project-rome/@internal/js-ast-utils/hasJSXAttribute.ts
function ___R$project$rome$$internal$js$ast$utils$hasJSXAttribute_ts$hasJSXAttribute(
		tag,
		name,
		allowEmpty = false,
	) {
		return (
			___R$project$rome$$internal$js$ast$utils$getJSXAttribute_ts$getJSXAttribute(
				tag,
				name,
				allowEmpty,
			) !== undefined
		);
	}


  // project-rome/@internal/js-ast-utils/getJSXElementName.ts
function ___R$project$rome$$internal$js$ast$utils$getJSXElementName_ts$getJSXElementName(
		node,
	) {
		if (node.name.type === "JSXIdentifier") {
			return node.name.name;
		}
		if (node.name.type === "JSXReferenceIdentifier") {
			return node.name.name;
		}
		if (node.name.type === "JSXNamespacedName") {
			return node.name.name.name;
		}

		return "";
	}


  // project-rome/@internal/js-ast-utils/isJSXElement.ts
function ___R$project$rome$$internal$js$ast$utils$isJSXElement_ts$isJSXElement(
		node,
		name,
	) {
		return (
			node.type === "JSXElement" &&
			___R$project$rome$$internal$js$ast$utils$doesNodeMatchPattern_ts$doesNodeMatchPattern(
				node.name,
				name,
			)
		);
	}


  // project-rome/@internal/js-ast-utils/resolveIndirection.ts
function ___R$project$rome$$internal$js$ast$utils$resolveIndirection_ts$resolveIndirection(
		node,
		scope,
	) {
		switch (node.type) {
			case "JSReferenceIdentifier": {
				const binding = scope.getBinding(node.name);
				if (
					binding instanceof
					___R$project$rome$$internal$compiler$scope$bindings_ts$ConstBinding &&
					binding.value !== undefined
				) {
					return ___R$project$rome$$internal$js$ast$utils$resolveIndirection_ts$resolveIndirection(
						binding.value,
						binding.scope,
					);
				}
				break;
			}

			case "JSSequenceExpression":
				return ___R$project$rome$$internal$js$ast$utils$resolveIndirection_ts$resolveIndirection(
					node.expressions[node.expressions.length - 1],
					scope,
				);

			case "TSAsExpression":
			case "TSTypeAssertion":
			case "TSNonNullExpression":
				return ___R$project$rome$$internal$js$ast$utils$resolveIndirection_ts$resolveIndirection(
					node.expression,
					scope,
				);
		}

		return {node, scope};
	}


  // project-rome/@internal/js-ast-utils/tryStaticEvaluation.ts
const ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$BAILED = {
		bailed: true,
		value: undefined,
	};

	function ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$createResult(
		value,
	) {
		return {
			bailed: false,
			value,
		};
	}

	function ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$evalUnaryExpression(
		expr,
		scope,
		opts,
	) {
		const res = ___R$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$tryStaticEvaluation(
			expr.argument,
			scope,
			opts,
		);

		if (!res.bailed) {
			// We do not care about TS protections
			// rome-ignore lint/ts/noExplicitAny: future cleanup
			const value = (res.value);

			switch (expr.operator) {
				case "+":
					return ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$createResult(
						+value,
					);

				case "-":
					return ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$createResult(
						-value,
					);

				case "~":
					return ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$createResult(
						~value,
					);

				case "!":
					return ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$createResult(
						!value,
					);
			}
		}

		return ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$BAILED;
	}

	function ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$evalBinaryExpression(
		expr,
		scope,
		opts,
	) {
		const left = ___R$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$tryStaticEvaluation(
			expr.left,
			scope,
			opts,
		);
		if (left.bailed) {
			return ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$BAILED;
		}

		const right = ___R$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$tryStaticEvaluation(
			expr.right,
			scope,
			opts,
		);
		if (right.bailed) {
			return ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$BAILED;
		}

		// We do not care about TS protections
		// rome-ignore lint/ts/noExplicitAny: future cleanup
		const l = (left.value);
		// rome-ignore lint/ts/noExplicitAny: future cleanup
		const r = (right.value);

		switch (expr.operator) {
			case "|":
				return ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$createResult(
					l | r,
				);

			case "&":
				return ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$createResult(
					l & r,
				);

			case ">>":
				return ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$createResult(
					l >> r,
				);

			case ">>>":
				return ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$createResult(
					l >>> r,
				);

			case "<<":
				return ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$createResult(
					l << r,
				);

			case "^":
				return ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$createResult(
					l ^ r,
				);

			case "*":
				return ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$createResult(
					l * r,
				);

			case "/":
				return ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$createResult(
					l / r,
				);

			case "+":
				return ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$createResult(
					l + r,
				);

			case "-":
				return ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$createResult(
					l - r,
				);

			case "%":
				return ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$createResult(
					l % r,
				);

			default:
				return ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$BAILED;
		}
	}

	function ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$evalTemplateLiteral(
		expr,
		scope,
		opts,
	) {
		const {expressions, quasis} = expr;

		let str = "";
		let bailed = false;
		let index = 0;

		for (const elem of quasis) {
			str += elem.cooked;

			if (index < expressions.length) {
				const res = ___R$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$tryStaticEvaluation(
					expressions[index++],
					scope,
					opts,
				);

				if (res.bailed) {
					bailed = true;
					break;
				}

				str += res.value;
			}
		}

		if (bailed) {
			return ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$BAILED;
		} else {
			return ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$createResult(
				str,
			);
		}
	}

	const ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$cache = new WeakMap();

	function ___R$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$tryStaticEvaluation(
		node,
		scope,
		opts = {},
	) {
		const cached = ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$cache.get(
			node,
		);
		if (cached !== undefined) {
			return cached;
		}

		let res = ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$BAILED;

		const {node: resolvedNode, scope: resolvedScope} = ___R$project$rome$$internal$js$ast$utils$resolveIndirection_ts$resolveIndirection(
			node,
			scope,
		);

		if (opts.isNodeValid && !opts.isNodeValid(node, resolvedNode)) {
			return res;
		}

		switch (resolvedNode.type) {
			case "JSUnaryExpression": {
				res = ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$evalUnaryExpression(
					resolvedNode,
					resolvedScope,
					opts,
				);
				break;
			}

			case "JSBinaryExpression": {
				res = ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$evalBinaryExpression(
					resolvedNode,
					resolvedScope,
					opts,
				);
				break;
			}

			case "JSNullLiteral": {
				res = ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$createResult(
					null,
				);
				break;
			}

			case "JSBigIntLiteral": {
				res = ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$createResult(
					BigInt(resolvedNode.value),
				);
				break;
			}

			case "JSStringLiteral":
			case "JSBooleanLiteral":
			case "JSNumericLiteral": {
				res = ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$createResult(
					resolvedNode.value,
				);
				break;
			}

			case "JSReferenceIdentifier": {
				const binding = resolvedScope.getBinding(resolvedNode.name);
				if (binding === undefined && resolvedNode.name === "undefined") {
					res = ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$createResult(
						undefined,
					);
				}
				break;
			}

			case "JSTemplateLiteral": {
				res = ___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$evalTemplateLiteral(
					resolvedNode,
					resolvedScope,
					opts,
				);
				break;
			}
		}

		___R$$priv$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$cache.set(
			node,
			res,
		);
		return res;
	}


  // project-rome/@internal/js-ast-utils/tryStaticEvaluationPath.ts
function ___R$project$rome$$internal$js$ast$utils$tryStaticEvaluationPath_ts$tryStaticEvaluationPath(
		path,
		opts,
	) {
		return ___R$project$rome$$internal$js$ast$utils$tryStaticEvaluation_ts$tryStaticEvaluation(
			path.node,
			path.scope,
			opts,
		);
	}


  // project-rome/@internal/js-ast-utils/getTSQualifiedBaseFromEntityName.ts
function ___R$project$rome$$internal$js$ast$utils$getTSQualifiedBaseFromEntityName_ts$getTSQualifiedBaseFromEntityName(
		entity,
	) {
		switch (entity.type) {
			case "TSQualifiedName":
				return ___R$project$rome$$internal$js$ast$utils$getTSQualifiedBaseFromEntityName_ts$getTSQualifiedBaseFromEntityName(
					entity.left,
				);

			case "JSReferenceIdentifier":
				return entity;
		}
	}


  // project-rome/@internal/js-ast-utils/isEmptyTemplateLiteral.ts
function ___R$project$rome$$internal$js$ast$utils$isEmptyTemplateLiteral_ts$isEmptyTemplateLiteral(
		node,
	) {
		if (!node.quasis || node.quasis.length === 0) {
			return false;
		}

		if (node.quasis.length === 1) {
			const quasi = node.quasis[0];
			return quasi.cooked === "";
		}
		return false;
	}


  // project-rome/@internal/js-ast-utils/cleanJSXText.ts
function ___R$project$rome$$internal$js$ast$utils$cleanJSXText_ts$cleanJSXText(
		value,
	) {
		const lines = value.split(/\r\n|\n|\r/);

		let lastNonEmptyLine = 0;

		for (let i = 0; i < lines.length; i++) {
			if (lines[i].match(/[^ \t]/)) {
				lastNonEmptyLine = i;
			}
		}

		let str = "";

		for (let i = 0; i < lines.length; i++) {
			const line = lines[i];

			const isFirstLine = i === 0;
			const isLastLine = i === lines.length - 1;
			const isLastNonEmptyLine = i === lastNonEmptyLine;

			// replace rendered whitespace tabs with spaces
			let trimmedLine = line.replace(/\t/g, " ");

			// trim whitespace touching a newline
			if (!isFirstLine) {
				trimmedLine = trimmedLine.replace(/^[ ]+/, "");
			}

			// trim whitespace touching an endline
			if (!isLastLine) {
				trimmedLine = trimmedLine.replace(/[ ]+$/, "");
			}

			if (trimmedLine) {
				if (!isLastNonEmptyLine) {
					trimmedLine += " ";
				}

				str += trimmedLine;
			}
		}

		return str;
	}


  // project-rome/@internal/js-ast-utils/index.ts



  // project-rome/@internal/consume/Consumer.ts
function ___R$$priv$project$rome$$internal$consume$Consumer_ts$isComputedPart(
		part,
	) {
		return (
			typeof part === "number" ||
			!___R$project$rome$$internal$js$ast$utils$isValidIdentifierName_ts$isValidIdentifierName(
				part,
			)
		);
	}

	class ___R$project$rome$$internal$consume$Consumer_ts$default {
		constructor(opts) {
			this.path = opts.filePath;
			this.filename = this.path === undefined ? undefined : this.path.join();

			this.value = opts.value;
			this.parent = opts.parent;
			this.keyPath = opts.objectPath;
			this.context = opts.context;
			this.onDefinition = opts.onDefinition;
			this.propertyMetadata = opts.propertyMetadata;
			this.usedNames = new Set(opts.usedNames);
			this.forkCache = new Map();
			this.forceDiagnosticTarget = opts.forceDiagnosticTarget;
			this.declared = opts.declared === true;

			// See shouldDispatchUnexpected for explanation
			this.hasHandledUnexpected = false;
			this.handleUnexpected = opts.handleUnexpectedDiagnostic;
		}

		capture() {
			let diagnostics = [];
			const definitions = [];

			const consumer = this.cloneConsumer({
				onDefinition: (def, consumer) => {
					if (this.onDefinition !== undefined) {
						this.onDefinition(def, consumer);
					}

					definitions.push(def);
				},
				handleUnexpectedDiagnostic(diag) {
					diagnostics.push(diag);
				},
			});
			return {consumer, definitions, diagnostics};
		}

		async bufferDiagnostics(callback) {
			const {diagnostics, consumer} = await this.capture();
			const result = await callback(consumer);
			if (result === undefined || diagnostics.length > 0) {
				throw new ___R$project$rome$$internal$diagnostics$errors_ts$DiagnosticsError(
					"Captured diagnostics",
					diagnostics,
				);
			}
			return result;
		}

		// Just for JSON.stringify debugging of Consumer instances
		toJSON() {
			return this.value;
		}

		handleThrownDiagnostics(callback) {
			if (this.handleUnexpected === undefined) {
				callback();
			} else {
				const {diagnostics} = ___R$project$rome$$internal$diagnostics$wrap_ts$catchDiagnosticsSync(
					callback,
				);

				if (diagnostics !== undefined) {
					for (const diag of diagnostics) {
						this.handleUnexpected(diag);
					}
				}
			}
		}

		declareDefinition(partialDef, inputName) {
			if (this.declared) {
				return;
			}

			if (this.onDefinition === undefined) {
				return;
			}

			const metadata = Object.assign({inputName}, this.propertyMetadata);

			const def = Object.assign(
				{},
				partialDef,
				{objectPath: this.keyPath, metadata},
			);

			this.declared = true;

			this.onDefinition(def, this);
		}

		getDiagnosticLocation(target = "all") {
			const {forceDiagnosticTarget} = this;
			if (forceDiagnosticTarget !== undefined) {
				target = forceDiagnosticTarget;
			}

			let getPropertyDiagnosticLocation =
				this.propertyMetadata == null
					? undefined
					: this.propertyMetadata.getDiagnosticLocation;
			if (getPropertyDiagnosticLocation !== undefined) {
				const loc = getPropertyDiagnosticLocation(target);
				if (loc !== undefined) {
					return loc;
				}
			}

			const getDiagnosticLocation = this.context.getDiagnosticLocation;
			if (getDiagnosticLocation === undefined) {
				return {};
			} else {
				return getDiagnosticLocation(this.keyPath, target);
			}
		}

		getLocation(target) {
			const location = this.getDiagnosticLocation(target);
			if (
				location === undefined ||
				location.start === undefined ||
				location.end === undefined
			) {
				return {
					filename: this.filename,
					start: ___R$project$rome$$internal$parser$core$types_ts$UNKNOWN_POSITION,
					end: ___R$project$rome$$internal$parser$core$types_ts$UNKNOWN_POSITION,
				};
			} else {
				return {
					filename: location.filename,
					start: location.start,
					end: location.end,
				};
			}
		}

		getLocationRange(startIndex, endIndex = startIndex, target) {
			const loc = this.getLocation(target);
			if (
				loc.start ===
				___R$project$rome$$internal$parser$core$types_ts$UNKNOWN_POSITION
			) {
				return loc;
			}

			const {start, end} = loc;

			// We don't support handling line differences here... yet?
			if (start.line !== end.line) {
				return loc;
			}

			return Object.assign(
				{},
				loc,
				{
					start: Object.assign(
						{},
						start,
						{
							column: ___R$project$rome$$internal$ob1$index_ts$ob1Add(
								start.column,
								startIndex,
							),
						},
					),
					end: Object.assign(
						{},
						start,
						{
							column: ___R$project$rome$$internal$ob1$index_ts$ob1Add(
								start.column,
								endIndex,
							),
						},
					),
				},
			);
		}

		getKey() {
			return this.cloneConsumer({
				forceDiagnosticTarget: "key",
				value: this.getParentKey(),
			});
		}

		getParentKey() {
			return this.keyPath[this.keyPath.length - 1];
		}

		hasChangedFromSource() {
			const {getOriginalValue} = this.context;
			if (getOriginalValue === undefined) {
				return false;
			}

			const originalValue = getOriginalValue(this.keyPath);
			return !this.wasInSource() || this.value !== originalValue;
		}

		wasInSource() {
			const loc = this.getDiagnosticLocation();
			return (
				loc.filename !== undefined &&
				(loc.start !== undefined || loc.end !== undefined)
			);
		}

		getKeyPathString(path = this.keyPath) {
			const {normalizeKey} = this.context;
			let str = "";

			for (let i = 0; i < path.length; i++) {
				const prevPart = path[i - 1];
				let part = path[i];
				const nextPart = path[i + 1];

				if (typeof part === "string" && normalizeKey !== undefined) {
					part = normalizeKey(part);
				}

				if (
					prevPart !== undefined &&
					___R$$priv$project$rome$$internal$consume$Consumer_ts$isComputedPart(
						prevPart,
					)
				) {
					str += ".";
				}

				// If we are a computed property then wrap in brackets, the previous part would not have inserted a dot
				// We allow a computed part at the beginning of a path
				if (
					___R$$priv$project$rome$$internal$consume$Consumer_ts$isComputedPart(
						part,
					) &&
					i > 0
				) {
					const inner =
						typeof part === "number"
							? String(part)
							: ___R$project$rome$$internal$string$escape$escapeJSString_ts$default(
									part,
									{
										quote: '"',
									},
								);

					str += "[" + inner + "]";
				} else {
					if (
						nextPart === undefined ||
						___R$$priv$project$rome$$internal$consume$Consumer_ts$isComputedPart(
							nextPart,
						)
					) {
						// Don't append a dot if there are no parts or the next is computed
						str += part;
					} else {
						str += part + ".";
					}
				}
			}

			return str;
		}

		generateUnexpectedMessage(msg, opts) {
			const {at = "suffix", atParent = false} = opts;
			const {parent} = this;

			let target = this;

			if (atParent) {
				if (parent === undefined) {
					// Cannot target the parent if it does not exist
					return msg;
				} else {
					target = parent;
				}
			}

			if (at === "suffix") {
				msg = ___R$project$rome$$internal$markup$escape_ts$markup`${msg} at <emphasis>${target.getKeyPathString()}</emphasis>`;
			} else {
				msg = ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${target.getKeyPathString()}</emphasis> ${msg}`;
			}

			return msg;
		}

		unexpected(
			description = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.CONSUME.INVALID,
			opts = {},
		) {
			const {target = "value"} = opts;

			const {filename} = this;
			let location = this.getDiagnosticLocation(target);
			const fromSource = this.wasInSource();

			const message = this.generateUnexpectedMessage(description.message, opts);
			description = Object.assign({}, description, {message});

			const advice = [...(description.advice || [])];

			// Make the errors more descriptive
			if (fromSource) {
				if (this.hasChangedFromSource()) {
					advice.push({
						type: "log",
						category: "warn",
						text: ___R$project$rome$$internal$markup$escape_ts$markup`Our internal value has been modified since we read the original source`,
					});
				}
			} else {
				// Go up the consumer tree and take the position from the first consumer found in the source
				let consumer = this;
				do {
					if (consumer.wasInSource()) {
						location = consumer.getDiagnosticLocation(target);
						break;
					}
					consumer = consumer.parent;
				} while (consumer !== undefined);

				// If consumer is undefined and we have no filename then we were not able to find a location,
				// in this case, just throw a normal error
				if (consumer === undefined && filename === undefined) {
					throw new Error(
						___R$project$rome$$internal$markup$escape_ts$readMarkup(message),
					);
				}

				// Warn that we didn't find this value in the source if it's parent wasn't either
				if (this.parent === undefined || !this.parent.wasInSource()) {
					advice.push({
						type: "log",
						category: "warn",
						text: ___R$project$rome$$internal$markup$escape_ts$markup`This value was expected to be found at <emphasis>${this.getKeyPathString()}</emphasis> but was not in the original source`,
					});
				}
			}

			if (opts.loc !== undefined) {
				location = opts.loc;
			}

			if (location === undefined) {
				throw new Error(
					___R$project$rome$$internal$markup$escape_ts$readMarkup(message),
				);
			}

			const diagnostic = {
				description: Object.assign(
					{category: this.context.category},
					description,
					{advice},
				),
				location: Object.assign({}, location, {filename: this.filename}),
			};

			const err = ___R$project$rome$$internal$diagnostics$errors_ts$createSingleDiagnosticError(
				diagnostic,
			);

			if (this.handleUnexpected === undefined) {
				throw err;
			} else {
				if (this.shouldDispatchUnexpected()) {
					this.handleUnexpected(diagnostic);
					this.hasHandledUnexpected = true;
				}

				// Still allow throwing the diagnostic
				return err;
			}
		}

		// Only dispatch a single error for the current consumer, and suppress any if we have a parent consumer with errors
		// We do this since we could be producing redundant stale errors based on
		// results we've normalized to allow us to continue
		shouldDispatchUnexpected() {
			if (this.hasHandledUnexpected) {
				return false;
			}

			const {parent} = this;
			if (parent !== undefined) {
				return parent.shouldDispatchUnexpected();
			}

			return true;
		}

		cloneConsumer(opts) {
			return new ___R$project$rome$$internal$consume$Consumer_ts$default(
				Object.assign(
					{
						declared: this.declared,
						usedNames: this.usedNames,
						onDefinition: this.onDefinition,
						handleUnexpectedDiagnostic: this.handleUnexpected,
						filePath: this.path,
						context: this.context,
						value: this.value,
						parent: this.parent,
						objectPath: this.keyPath,
						propertyMetadata: this.propertyMetadata,
					},
					opts,
				),
			);
		}

		copy(mix) {
			let value = this.value;

			if (
				___R$project$rome$$internal$typescript$helpers$index_ts$isPlainObject(
					value,
				)
			) {
				value = Object.assign({}, this.asOriginalUnknownObject());
			}

			if (Array.isArray(value)) {
				value = [...value];
			}

			if (mix !== undefined) {
				Object.assign(value, mix);
			}

			const consumer = this.cloneConsumer({
				value,
			});

			// Add on cached property metadata if necessary
			for (const [key, value] of this.forkCache) {
				if (value.propertyMetadata !== undefined) {
					consumer.get(key, value.propertyMetadata);
				}
			}

			return consumer;
		}

		fork(key, value, propertyMetadata) {
			// We require this cache as we sometimes want to store state about a forked property such as used items
			const cached = this.forkCache.get(String(key));
			if (
				cached !== undefined &&
				cached.value === value &&
				(cached.propertyMetadata === undefined ||
				cached.propertyMetadata === propertyMetadata)
			) {
				return cached;
			}

			const forked = this.cloneConsumer({
				propertyMetadata,
				value,
				parent: this,
				objectPath: [...this.keyPath, key],
			});
			this.forkCache.set(String(key), forked);
			return forked;
		}

		_normalizeValueForSet(value) {
			if (value instanceof Set) {
				return Array.from(value);
			}

			if (value instanceof Map) {
				const obj = {};
				for (const [key, val] of value) {
					obj[key] = val;
				}
				return obj;
			}

			return value;
		}

		getValue(def) {
			if (this.exists()) {
				return this.value;
			} else {
				return def;
			}
		}

		setValue(rawValue) {
			const value = this._normalizeValueForSet(rawValue);
			this.value = value;

			// If we're at the root (as indicated by the lack of these properties) then go no where else
			const {parent, keyPath} = this;
			if (parent === undefined || keyPath.length === 0) {
				return this;
			}

			// Validate the parent is an object
			const parentValue = parent.asUnknown();
			if (
				parentValue === undefined ||
				parentValue === null ||
				typeof parentValue !== "object"
			) {
				throw parent.unexpected(
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.CONSUME.SET_PROPERTY_NON_OBJECT,
				);
			}

			// Mutate the parent
			const parentObj = parent.asOriginalUnknownObject();
			const key = this.getParentKey();
			parentObj[String(key)] = value;
			parent.setValue(parentObj);

			return this;
		}

		has(key) {
			const value = this.asOriginalUnknownObject();
			return value[key] != null;
		}

		delete(key) {
			this.get(key).setValue(undefined);
		}

		set(key, value) {
			this.get(key).setValue(value);
		}

		get(key, metadata) {
			const value = this.asOriginalUnknownObject();
			const valueKey =
				(metadata == null ? undefined : metadata.alternateName) &&
				this.has(metadata.alternateName)
					? metadata.alternateName
					: key;
			this.markUsedProperty(valueKey);
			return this.fork(key, value[valueKey], metadata);
		}

		getIndex(index) {
			const arr = this.asPlainArray();
			return this.fork(index, arr[index]);
		}

		markUsedProperty(name) {
			this.usedNames.add(name);
		}

		enforceUsedProperties(type = "property", recursive = true) {
			if (!this.isObject()) {
				return;
			}

			let knownProperties = Array.from(this.usedNames.keys());

			const {normalizeKey} = this.context;
			if (normalizeKey !== undefined) {
				knownProperties = knownProperties.map((key) => normalizeKey(key));
			}

			for (const [key, value] of this.asMap(false, false)) {
				if (!this.usedNames.has(key)) {
					value.unexpected(
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.CONSUME.UNUSED_PROPERTY(
							this.getKeyPathString([key]),
							type,
							knownProperties,
						),
						{
							target: "key",
							at: "suffix",
							atParent: true,
						},
					);
				}

				if (recursive) {
					value.enforceUsedProperties(type, true);
				}
			}
		}

		asNumberString(def) {
			this.declareDefinition({
				type: "number",
				default: def,
				required: def === undefined,
			});

			const str = this.asString(def);
			const num = parseFloat(str);
			if (isNaN(num)) {
				this.unexpected(
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.CONSUME.EXPECTED_VALID_NUMBER,
				);
				return 0;
			} else {
				return num;
			}
		}

		asNumberStringOrVoid() {
			this.declareDefinition({
				type: "number",
				default: undefined,
				required: false,
			});

			if (this.exists()) {
				return this.asNumberString();
			} else {
				return undefined;
			}
		}

		// JSON
		asJSONValue() {
			const {value} = this;

			switch (typeof value) {
				case "number":
				case "string":
				case "boolean":
					return value;
			}

			if (value === null) {
				return null;
			}

			if (Array.isArray(value)) {
				return this.asJSONArray();
			}

			if (this.isObject()) {
				return this.asJSONObject();
			}

			this.unexpected(
				___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.CONSUME.EXPECTED_JSON_VALUE,
			);
			return "";
		}

		asJSONArray() {
			const arr = [];
			for (const value of this.asIterable()) {
				arr.push(value.asJSONValue());
			}
			return arr;
		}

		asJSONObject() {
			const obj = {};
			for (const [key, value] of this.asMap()) {
				obj[key] = value.asJSONPropertyValue();
			}
			return obj;
		}

		asJSONPropertyValue() {
			if (this.exists()) {
				return this.asJSONValue();
			} else {
				return undefined;
			}
		}

		exists() {
			return this.value != null;
		}

		isObject() {
			const {value} = this;
			return (
				typeof value === "object" &&
				value !== null &&
				value.constructor === Object
			);
		}

		asUnknownObject(optional = false) {
			this.declareDefinition({
				type: "object",
				default: undefined,
				required: !optional,
			});

			return Object.assign({}, this.asOriginalUnknownObject(optional));
		}

		isEmpty() {
			const value = this.asUnknown();

			if (value == null) {
				return true;
			}

			if (value === "") {
				return true;
			}

			if (
				___R$project$rome$$internal$typescript$helpers$index_ts$isPlainObject(
					value,
				)
			) {
				return Object.keys(value).length === 0;
			}

			return false;
		}

		asOriginalUnknownObject(optional = false) {
			if (optional && !this.exists()) {
				return {};
			}

			const {value} = this;
			if (
				!___R$project$rome$$internal$typescript$helpers$index_ts$isPlainObject(
					value,
				)
			) {
				this.unexpected(
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.CONSUME.EXPECTED_OBJECT,
				);
				return {};
			}

			return value;
		}

		asMap(optional, markUsed = true) {
			this.declareDefinition({
				type: "object",
				default: undefined,
				required: !optional,
			});

			const value = this.asOriginalUnknownObject(optional);
			const map = new Map();
			for (const key in value) {
				if (markUsed) {
					this.markUsedProperty(key);
				}
				map.set(key, this.fork(key, value[key]));
			}
			return map;
		}

		asPlainArray(optional = false) {
			this.declareDefinition({
				type: "array",
				default: undefined,
				required: !optional,
			});

			if (optional && !this.exists()) {
				return [];
			}

			const {value} = this;

			if (!Array.isArray(value)) {
				this.unexpected(
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.CONSUME.EXPECTED_ARRAY,
				);
				return [];
			}

			return [...value];
		}

		asIterable(optional) {
			const arr = this.asPlainArray(optional);

			return arr.map((val, index) => {
				return this.fork(index, val);
			});
		}

		asMappedArray(callback) {
			return Array.from(this.asIterable(), callback);
		}

		asImplicitMappedArray(callback) {
			if (Array.isArray(this.asUnknown())) {
				return this.asMappedArray(callback);
			} else if (this.exists()) {
				return [callback(this)];
			} else {
				return [];
			}
		}

		asDateOrVoid() {
			this.declareDefinition({
				type: "date",
				default: undefined,
				required: false,
			});
			if (this.exists()) {
				return this.asDate();
			} else {
				return undefined;
			}
		}

		asDate(def) {
			this.declareDefinition({
				type: "date",
				default: def,
				required: def === undefined,
			});
			const value = this.getValue(def);
			if (!(value instanceof Date)) {
				this.unexpected(
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.CONSUME.EXPECTED_DATE,
				);
				return new Date();
			}
			return value;
		}

		asBooleanOrVoid() {
			this.declareDefinition({
				type: "boolean",
				default: undefined,
				required: false,
			});
			if (this.exists()) {
				return this.asBoolean();
			} else {
				return undefined;
			}
		}

		asBoolean(def) {
			this.declareDefinition({
				type: "boolean",
				default: def,
				required: def === undefined,
			});
			const value = this.getValue(def);
			if (typeof value !== "boolean") {
				this.unexpected(
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.CONSUME.EXPECTED_BOOLEAN,
				);
				return false;
			}
			return value;
		}

		asStringOrVoid() {
			this.declareDefinition({
				type: "string",
				default: undefined,
				required: false,
			});

			if (this.exists()) {
				return this.asString();
			} else {
				return undefined;
			}
		}

		asString(def) {
			this.declareDefinition({
				type: "string",
				default: def,
				required: def === undefined,
			});

			const value = this.getValue(def);
			if (typeof value !== "string") {
				this.unexpected(
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.CONSUME.EXPECTED_STRING,
				);
				return "";
			}
			return value;
		}

		asStringSet(validValues, def) {
			this.declareDefinition({
				type: "string",
				default: def,
				required: def === undefined,
				allowedValues: validValues,
			});

			const value = this.asString(def);

			// @ts-ignore
			if (validValues.includes(value)) {
				// @ts-ignore
				return value;
			} else {
				this.unexpected(
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.CONSUME.INVALID_STRING_SET_VALUE(
						value,
						// rome-ignore lint/ts/noExplicitAny: future cleanup
						((validValues)),
					),
					{
						target: "value",
					},
				);
				return validValues[0];
			}
		}

		asStringSetOrVoid(validValues) {
			this.declareDefinition({
				type: "string",
				default: undefined,
				required: false,
				allowedValues: validValues,
			});

			if (this.exists()) {
				return this.asStringSet(validValues);
			} else {
				return undefined;
			}
		}

		asBigIntOrVoid() {
			this.declareDefinition({
				type: "bigint",
				default: undefined,
				required: false,
			});
			if (this.exists()) {
				return this.asBigInt();
			} else {
				return undefined;
			}
		}

		asBigInt(def) {
			this.declareDefinition({
				type: "bigint",
				default: def,
				required: def === undefined,
			});

			const value = this.getValue(def);

			if (typeof value === "number") {
				return BigInt(value);
			}

			if (typeof value === "bigint") {
				return value;
			}

			this.unexpected(
				___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.CONSUME.EXPECTED_BIGINT,
			);
			return BigInt("0");
		}

		_declareOptionalFilePath() {
			this.declareDefinition(
				{
					type: "string",
					default: undefined,
					required: false,
				},
				"path",
			);
		}

		asURLPath(def) {
			const path = this.asUnknownPath(def);
			if (path.isURL()) {
				return path.assertURL();
			} else {
				var ___R$;
				this.unexpected(
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.CONSUME.EXPECTED_URL,
				);
				return (
					___R$ = ___R$project$rome$$internal$path$index_ts$createURLPath(
						"unknown://",
					),
					___R$.append.apply(___R$, [...path.getSegments()])
				);
			}
		}

		asURLPathOrVoid() {
			if (this.exists()) {
				return this.asURLPath();
			} else {
				this._declareOptionalFilePath();
				return undefined;
			}
		}

		asUnknownPath(def) {
			this.declareDefinition(
				{
					type: "string",
					default: def,
					required: def === undefined,
				},
				"path",
			);

			return ___R$project$rome$$internal$path$index_ts$createUnknownPath(
				this.asString(def),
			);
		}

		asUnknownPathOrVoid() {
			if (this.exists()) {
				return this.asUnknownPath();
			} else {
				this._declareOptionalFilePath();
				return undefined;
			}
		}

		asAbsoluteFilePath(def, cwd) {
			const path = this.asUnknownPath(def);
			if (path.isAbsolute()) {
				return path.assertAbsolute();
			} else if (cwd !== undefined && path.isRelative()) {
				return cwd.resolve(path);
			} else {
				var ___R$1;
				this.unexpected(
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.CONSUME.EXPECTED_ABSOLUTE_PATH,
				);
				return (
					___R$1 = ___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
						"/",
					),
					___R$1.append.apply(___R$1, [...path.getSegments()])
				);
			}
		}

		asAbsoluteFilePathOrVoid(cwd) {
			if (this.exists()) {
				return this.asAbsoluteFilePath(undefined, cwd);
			} else {
				this._declareOptionalFilePath();
				return undefined;
			}
		}

		asRelativeFilePath(def) {
			const path = this.asUnknownPath(def);
			if (path.isRelative()) {
				return path.assertRelative();
			} else {
				this.unexpected(
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.CONSUME.EXPECTED_RELATIVE_PATH,
				);
				return path.toExplicitRelative();
			}
		}

		asRelativeFilePathOrVoid() {
			if (this.exists()) {
				return this.asRelativeFilePath();
			} else {
				this._declareOptionalFilePath();
				return undefined;
			}
		}

		asExplicitRelativeFilePath(def) {
			const path = this.asRelativeFilePath(def);

			if (path.isExplicitRelative()) {
				return path;
			} else {
				this.unexpected(
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.CONSUME.EXPECTED_EXPLICIT_RELATIVE_PATH,
				);
				return path.toExplicitRelative();
			}
		}

		asExplicitRelativeFilePathOrVoid() {
			if (this.exists()) {
				return this.asExplicitRelativeFilePath();
			} else {
				this._declareOptionalFilePath();
				return undefined;
			}
		}

		asNumberOrVoid() {
			this.declareDefinition({
				type: "number",
				default: undefined,
				required: false,
			});

			if (this.exists()) {
				return this.asNumber();
			} else {
				return undefined;
			}
		}

		asZeroIndexedNumber(def) {
			return ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(
				this.asNumber(def),
			);
		}

		asOneIndexedNumber(def) {
			return ___R$project$rome$$internal$ob1$index_ts$ob1Coerce1(
				this.asNumber(def),
			);
		}

		asZeroIndexedNumberOrVoid() {
			const num = this.asNumberOrVoid();
			return num === undefined
				? undefined
				: ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(num);
		}

		asOneIndexedNumberOrVoid() {
			const num = this.asNumberOrVoid();
			return num === undefined
				? undefined
				: ___R$project$rome$$internal$ob1$index_ts$ob1Coerce1(num);
		}

		asNumber(def) {
			this.declareDefinition({
				type: "number",
				default: def,
				required: def === undefined,
			});

			const value = this.getValue(def);
			if (typeof value !== "number") {
				this.unexpected(
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.CONSUME.EXPECTED_NUMBER,
				);
				return 0;
			}
			return value;
		}

		asNumberInRange(opts) {
			const min = ___R$project$rome$$internal$ob1$index_ts$ob1Get(opts.min);
			const max = ___R$project$rome$$internal$ob1$index_ts$ob1Get(opts.max);
			const def = ___R$project$rome$$internal$ob1$index_ts$ob1Get(opts.default);

			this.declareDefinition({
				type: "number",
				default: def,
				required: def !== undefined,
				min,
				max,
			});

			const num = this.asNumber(def);

			// Nice error message when both min and max are specified
			if (min !== undefined && max !== undefined && (num < min || num > max)) {
				this.unexpected(
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.CONSUME.EXPECTED_NUMBER_BETWEEN(
						min,
						max,
					),
				);
				return num;
			}

			if (min !== undefined && num < min) {
				this.unexpected(
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.CONSUME.EXPECTED_NUMBER_HIGHER(
						min,
					),
				);
			}

			if (max !== undefined && num > max) {
				this.unexpected(
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.CONSUME.EXPECTED_NUMBER_LOWER(
						max,
					),
				);
			}

			return num;
		}

		asNumberSet(validValues, def) {
			this.declareDefinition({
				type: "number",
				default: def,
				required: def === undefined,
				allowedValues: validValues,
			});

			const value = this.asNumber(def);

			// @ts-ignore
			if (validValues.includes(value)) {
				// @ts-ignore
				return value;
			} else {
				this.unexpected(
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.CONSUME.INVALID_NUMBER_SET_VALUE(
						value,
						// rome-ignore lint/ts/noExplicitAny: future cleanup
						((validValues)),
					),
					{
						target: "value",
					},
				);
				return validValues[0];
			}
		}

		asNumberSetOrVoid(validValues) {
			this.declareDefinition({
				type: "number",
				default: undefined,
				required: false,
				allowedValues: validValues,
			});

			if (this.exists()) {
				return this.asNumberSet(validValues);
			} else {
				return undefined;
			}
		}

		asUnknown() {
			return this.value;
		}

		// rome-ignore lint/ts/noExplicitAny: future cleanup
		asAny() {
			return this.value;
		}
	}


  // project-rome/@internal/consume/index.ts
const ___R$$priv$project$rome$$internal$consume$index_ts$EMPTY_CONSUME_OPTIONS = {
		propertyMetadata: undefined,
		value: undefined,
		handleUnexpectedDiagnostic: undefined,
		onDefinition: undefined,
		filePath: undefined,
		objectPath: [],
		parent: undefined,
	};

	function ___R$project$rome$$internal$consume$index_ts$consume(opts) {
		return new ___R$project$rome$$internal$consume$Consumer_ts$default(
			___R$project$rome$$internal$typescript$helpers$index_ts$mergeObjects(
				Object.assign(
					{},
					___R$$priv$project$rome$$internal$consume$index_ts$EMPTY_CONSUME_OPTIONS,
					{context: opts.context},
				),
				opts,
			),
		);
	}

	function ___R$project$rome$$internal$consume$index_ts$consumeUnknown(
		value,
		category,
	) {
		return new ___R$project$rome$$internal$consume$Consumer_ts$default(
			Object.assign(
				{},
				___R$$priv$project$rome$$internal$consume$index_ts$EMPTY_CONSUME_OPTIONS,
				{
					context: {
						category,
					},
					value,
				},
			),
		);
	}


  // project-rome/@internal/cli-layout/formatANSI.ts
function ___R$project$rome$$internal$cli$layout$formatANSI_ts$ansiFormatText(
		{name: tagName, attributes},
		value,
		grid,
	) {
		const {features} = grid;

		switch (tagName) {
			case "hyperlink": {
				if (features.hyperlinks) {
					return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.hyperlink(
						attributes.get("target").asString(value),
						value,
					);
				} else {
					return value;
				}
			}

			case "filelink": {
				if (features.hyperlinks) {
					const {filename} = ___R$project$rome$$internal$markup$util_ts$buildFileLink(
						attributes,
						grid.options,
					);
					return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.hyperlink(
						value,
						"file://" + filename,
					);
				} else {
					return value;
				}
			}
		}

		if (features.colorDepth === 1) {
			return value;
		}

		switch (tagName) {
			case "inverse":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.inverse(
					value,
				);

			case "emphasis":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.bold(
					value,
				);

			case "dim":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.dim(
					value,
				);

			case "italic":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.italic(
					value,
				);

			case "underline":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.underline(
					value,
				);

			case "strike":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.strikethrough(
					value,
				);

			case "error":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.red(
					value,
				);

			case "success":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.green(
					value,
				);

			case "warn":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.yellow(
					value,
				);

			case "info":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.blue(
					value,
				);

			case "code":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.italic(
					value,
				);

			case "highlight": {
				const index = Math.min(0, attributes.get("i").asNumber(0));
				const fn = ___R$$priv$project$rome$$internal$cli$layout$formatANSI_ts$ansiHighlightFactories[index %
				___R$$priv$project$rome$$internal$cli$layout$formatANSI_ts$ansiHighlightFactories.length];
				return fn(value);
			}

			case "color":
				return ___R$$priv$project$rome$$internal$cli$layout$formatANSI_ts$formatAnsiBackground(
					___R$project$rome$$internal$markup$tags_ts$validateColor(
						attributes.get("bg").asStringOrVoid(),
					),
					___R$$priv$project$rome$$internal$cli$layout$formatANSI_ts$formatAnsiForeground(
						___R$project$rome$$internal$markup$tags_ts$validateColor(
							attributes.get("fg").asStringOrVoid(),
						),
						value,
					),
				);

			case "token":
				return ___R$$priv$project$rome$$internal$cli$layout$formatANSI_ts$formatToken(
					___R$project$rome$$internal$markup$tags_ts$validateTokenType(
						attributes.get("type").asStringOrVoid(),
					),
					value,
					grid,
				);

			default:
				return value;
		}
	}

	const ___R$$priv$project$rome$$internal$cli$layout$formatANSI_ts$scopeToTokenTypes = {
		"constant": ["number", "boolean"],
		"constant.numeric": ["number"],
		"constant.language.boolean": ["boolean"],
		"variable.other.constant": ["boolean"],

		"string": ["string"],
		"string.regexp": ["regex"],

		"comment": ["comment"],
		"entity.name.function": ["function"],
		//"": "operator"],
		"punctuation": ["punctuation"],
		//"variable": ["variable"],
		"keyword": ["keyword"],

		"entity.name.tag.html": ["tag"],
		"punctuation.separator.key-value.html": ["attr-equals"],
		"string.quoted.double.html": ["attr-value"],
		"entity.other.attribute-name": ["attr-name"],
		"entity.other.attribute-name.js": ["attr-name"],
	};

	function ___R$$priv$project$rome$$internal$cli$layout$formatANSI_ts$normalizeFontStyle(
		style,
	) {
		switch (style) {
			case "italic":
				return style;

			default:
				return "normal";
		}
	}

	const ___R$$priv$project$rome$$internal$cli$layout$formatANSI_ts$tokenColorsCache = new Map();
	let ___R$$priv$project$rome$$internal$cli$layout$formatANSI_ts$defaultTokenColors;

	function ___R$$priv$project$rome$$internal$cli$layout$formatANSI_ts$getTokenColors(
		consumer,
	) {
		if (consumer === undefined) {
			if (
				___R$$priv$project$rome$$internal$cli$layout$formatANSI_ts$defaultTokenColors ===
				undefined
			) {
				___R$$priv$project$rome$$internal$cli$layout$formatANSI_ts$defaultTokenColors = Object.assign(
					{},
					___R$$priv$project$rome$$internal$cli$layout$formatANSI_ts$getTokenColors(
						___R$project$rome$$internal$consume$index_ts$consumeUnknown(
							___R$project$rome$$internal$cli$layout$syntax$theme$OneDarkPro_json$default,
							"parse/vscodeTheme",
						),
					),
					{kind: "default"},
				);
			}

			return ___R$$priv$project$rome$$internal$cli$layout$formatANSI_ts$defaultTokenColors;
		}

		const cached = ___R$$priv$project$rome$$internal$cli$layout$formatANSI_ts$tokenColorsCache.get(
			consumer,
		);
		if (cached !== undefined) {
			return cached;
		}

		const theme = {
			kind: "user",
			tokens: {},
		};
		___R$$priv$project$rome$$internal$cli$layout$formatANSI_ts$tokenColorsCache.set(
			consumer,
			theme,
		);

		for (const prop of consumer.get("tokenColors").asIterable()) {
			const settings = prop.get("settings");
			const scope = prop.get("scope");
			const scopes = Array.isArray(scope.asUnknown())
				? scope.asMappedArray((elem) => elem.asString())
				: scope.asString().split(",").map((scope) => scope.trim());

			for (const scope of scopes) {
				const tokenTypes = ___R$$priv$project$rome$$internal$cli$layout$formatANSI_ts$scopeToTokenTypes[scope];
				if (tokenTypes === undefined) {
					continue;
				}

				for (const tokenType of tokenTypes) {
					const existing = theme.tokens[tokenType];

					const newSettings = {};

					if (settings.has("foreground")) {
						newSettings.rgb = ___R$$priv$project$rome$$internal$cli$layout$formatANSI_ts$hexToRgb(
							settings.get("foreground").asString(),
						);
					}

					if (settings.has("fontStyle")) {
						newSettings.fontStyle = ___R$$priv$project$rome$$internal$cli$layout$formatANSI_ts$normalizeFontStyle(
							settings.get("fontStyle").asString(),
						);
					}

					theme.tokens[tokenType] = Object.assign({}, existing, newSettings);
				}
			}
		}

		return theme;
	}

	function ___R$$priv$project$rome$$internal$cli$layout$formatANSI_ts$formatToken(
		type,
		value,
		grid,
	) {
		if (type === undefined) {
			return value;
		}

		const theme = ___R$$priv$project$rome$$internal$cli$layout$formatANSI_ts$getTokenColors(
			(grid.options == null ? undefined : grid.options.userConfig) == null
				? undefined
				: (grid.options == null ? undefined : grid.options.userConfig).syntaxTheme,
		);

		// Only use our default syntax theme when we are confident the terminal has a dark background
		if (theme.kind === "default" && grid.features.background !== "dark") {
			return value;
		}

		const format = theme.tokens[type];
		if (format === undefined) {
			return value;
		}

		if (format.fontStyle === "italic") {
			value = ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.italic(
				value,
			);
		}

		if (format.rgb === undefined) {
			return value;
		}

		return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsiRGB({
			value,
			color: format.rgb,
			features: grid.features,
		});
	}

	function ___R$$priv$project$rome$$internal$cli$layout$formatANSI_ts$hexToRgb(
		hex,
	) {
		if (hex === undefined) {
			throw new Error("No color string passed");
		}

		const match = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
		if (match == null) {
			throw new Error(hex + " is not a valid hex color");
		}

		return [
			parseInt(match[1], 16),
			parseInt(match[2], 16),
			parseInt(match[3], 16),
		];
	}

	// TODO fill this
	const ___R$$priv$project$rome$$internal$cli$layout$formatANSI_ts$ansiHighlightFactories = [
		___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.magenta,
		___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.cyan,
	];

	function ___R$$priv$project$rome$$internal$cli$layout$formatANSI_ts$formatAnsiBackground(
		bg,
		text,
	) {
		if (bg === undefined) {
			return text;
		}

		switch (bg) {
			case "black":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.bgBlack(
					text,
				);

			case "brightBlack":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.bgBrightBlack(
					text,
				);

			case "red":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.bgRed(
					text,
				);

			case "brightRed":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.bgBrightRed(
					text,
				);

			case "green":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.bgGreen(
					text,
				);

			case "brightGreen":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.bgBrightGreen(
					text,
				);

			case "yellow":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.bgYellow(
					text,
				);

			case "brightYellow":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.bgBrightYellow(
					text,
				);

			case "blue":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.bgBlue(
					text,
				);

			case "brightBlue":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.bgBrightBlue(
					text,
				);

			case "magenta":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.bgMagenta(
					text,
				);

			case "brightMagenta":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.bgBrightMagenta(
					text,
				);

			case "cyan":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.bgCyan(
					text,
				);

			case "brightCyan":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.bgBrightCyan(
					text,
				);

			case "white":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.bgWhite(
					text,
				);

			case "brightWhite":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.bgBrightWhite(
					text,
				);

			default:
				return text;
		}
	}

	function ___R$$priv$project$rome$$internal$cli$layout$formatANSI_ts$formatAnsiForeground(
		fg,
		text,
	) {
		if (fg === undefined) {
			return text;
		}

		switch (fg) {
			case "black":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.black(
					text,
				);

			case "brightBlack":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.brightBlack(
					text,
				);

			case "red":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.red(
					text,
				);

			case "brightRed":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.brightRed(
					text,
				);

			case "green":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.green(
					text,
				);

			case "brightGreen":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.brightGreen(
					text,
				);

			case "yellow":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.yellow(
					text,
				);

			case "brightYellow":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.brightYellow(
					text,
				);

			case "blue":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.blue(
					text,
				);

			case "brightBlue":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.brightBlue(
					text,
				);

			case "magenta":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.magenta(
					text,
				);

			case "brightMagenta":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.brightMagenta(
					text,
				);

			case "cyan":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.cyan(
					text,
				);

			case "brightCyan":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.brightCyan(
					text,
				);

			case "white":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.white(
					text,
				);

			case "brightWhite":
				return ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.brightWhite(
					text,
				);

			default:
				return text;
		}
	}


  // project-rome/@internal/cli-layout/formatHTML.ts
function ___R$project$rome$$internal$cli$layout$formatHTML_ts$htmlFormatText(
		{name: tagName, attributes},
		value,
	) {
		switch (tagName) {
			case "hyperlink": {
				return (
					'<a href="' +
					___R$project$rome$$internal$html$parser$xhtmlEntities_ts$escapeXHTMLEntities(
						attributes.get("target").asString(value),
					) +
					'">' +
					value +
					"</a>"
				);
			}

			case "filelink": {
				// We probably don't need filelinks if it's just for presentation in the browser?
				//const filename = getFileLinkFilename(attributes, opts);
				//return `<a href="file://${escapeXHTMLEntities(filename)}">${value}</a>`;
				return (
					'<span style="text-decoration-style: dashed; text-decoration-line: underline;">' +
					value +
					"</span>"
				);
			}

			case "inverse":
				return (
					'<span style="color: #000; background-color: #ddd;">' +
					value +
					"</span>"
				);

			case "emphasis":
				return "<strong>" + value + "</strong>";

			case "dim":
				return '<span style="opacity: 0.8;">' + value + "</span>";

			case "italic":
				return "<i>" + value + "</i>";

			case "underline":
				return "<u>" + value + "</u>";

			case "strike":
				return "<strike>" + value + "</strike>";

			case "error":
				return '<span style="color: Tomato;">' + value + "</span>";

			case "success":
				return '<span style="color: MediumSeaGreen;">' + value + "</span>";

			case "warn":
				return '<span style="color: Orange;">' + value + "</span>";

			case "info":
				return '<span style="color: DodgerBlue;">' + value + "</span>";

			case "code":
				return "<i>" + value + "</i>";

			case "highlight": {
				const index = Math.min(0, attributes.get("i").asNumber(0));
				const color = ___R$$priv$project$rome$$internal$cli$layout$formatHTML_ts$highlightColors[index %
				___R$$priv$project$rome$$internal$cli$layout$formatHTML_ts$highlightColors.length];
				return '<span style="color: ' + color + ';">' + value + "</span>";
			}

			case "color": {
				const styles = [];

				const fg = ___R$project$rome$$internal$markup$tags_ts$validateColor(
					attributes.get("fg").asStringOrVoid(),
				);
				if (fg !== undefined) {
					styles.push("color: " + fg);
				}

				const bg = ___R$project$rome$$internal$markup$tags_ts$validateColor(
					attributes.get("bg").asStringOrVoid(),
				);
				if (bg !== undefined) {
					styles.push("background-color: " + bg);
				}

				return '<span style="' + styles.join("; ") + '">' + value + "</span>";
			}

			case "token":
				return (
					'<span class="token ' +
					attributes.get("type").asString("") +
					'">' +
					value +
					"</span>"
				);

			default:
				return value;
		}
	}

	// TODO fill this with more
	const ___R$$priv$project$rome$$internal$cli$layout$formatHTML_ts$highlightColors = [
		"magenta",
		"cyan",
	];


  // project-rome/@internal/cli-layout/Grid.ts
function ___R$$priv$project$rome$$internal$cli$layout$Grid_ts$createTag(
		name,
		attributes = ___R$project$rome$$internal$markup$util_ts$createEmptyAttributes(),
		children = [],
	) {
		return {
			type: "Tag",
			name,
			attributes,
			children,
		};
	}

	function ___R$$priv$project$rome$$internal$cli$layout$Grid_ts$joinColumns(
		columns,
	) {
		return columns.filter((column) => typeof column === "string").join("");
	}

	function ___R$$priv$project$rome$$internal$cli$layout$Grid_ts$sliceColumns(
		columns,
		start,
		end,
	) {
		return ___R$$priv$project$rome$$internal$cli$layout$Grid_ts$joinColumns(
			columns.slice(
				___R$project$rome$$internal$ob1$index_ts$ob1Get1(start) - 1,
				___R$project$rome$$internal$ob1$index_ts$ob1Get1(end) - 1,
			),
		);
	}

	function ___R$$priv$project$rome$$internal$cli$layout$Grid_ts$extractViewTags(
		tag,
	) {
		let pointer;
		let linePrefixes = [];
		let children = [];

		for (const child of tag.children) {
			if (child.type === "Tag") {
				if (child.name === "viewLinePrefix") {
					linePrefixes.push(child);
					continue;
				} else if (child.name === "viewPointer") {
					pointer = child;
					continue;
				}
			}

			children.push(child);
		}

		return {pointer, linePrefixes, children};
	}

	const ___R$$priv$project$rome$$internal$cli$layout$Grid_ts$TAB_PLACEHOLDER_COLUMN = Symbol(
		"TAB_LAYOUT_PLACEHOLDER",
	);

	function ___R$$priv$project$rome$$internal$cli$layout$Grid_ts$isWhitespace(
		char,
	) {
		return (
			char === " " ||
			char === "\t" ||
			char ===
			___R$$priv$project$rome$$internal$cli$layout$Grid_ts$TAB_PLACEHOLDER_COLUMN
		);
	}

	class ___R$project$rome$$internal$cli$layout$Grid_ts$default {
		constructor(opts) {
			this.viewportWidth = opts.columns === undefined ? undefined : opts.columns;
			this.options = opts;

			this.features =
				opts.features === undefined
					? ___R$project$rome$$internal$cli$environment$index_ts$DEFAULT_TERMINAL_FEATURES
					: opts.features;

			this.cursor = {
				line: ___R$project$rome$$internal$ob1$index_ts$ob1Number1,
				column: ___R$project$rome$$internal$ob1$index_ts$ob1Number1,
			};

			this.sourceCursor = {
				currentLineText: "",
				currentLine: ___R$project$rome$$internal$ob1$index_ts$ob1Number1,
				currentColumn: ___R$project$rome$$internal$ob1$index_ts$ob1Number1,
			};

			this.lineStartMeta = {
				softWrapped: false,
				indentationCount: 0,
				sourceColumn: ___R$project$rome$$internal$ob1$index_ts$ob1Number1,
			};

			const {lineWrapMode = "word-break"} = opts.view;
			this.lineWrapMode = lineWrapMode;
			this.width = ___R$project$rome$$internal$ob1$index_ts$ob1Number1;

			this.lines = [
				// First line that we're going to fill.
				// If it isn't here then any height measurements before anything has been written will be wrong
				{
					ranges: [],
					columns: [],
				},
			];

			// TODO make the tab width customizable in userConfig
			this.tabSize = 2;

			const indentColumns = [];
			for (let i = 0; i < this.tabSize; i++) {
				let char = " ";
				if (!this.options.convertTabs) {
					char =
						i === 0
							? "\t"
							: ___R$$priv$project$rome$$internal$cli$layout$Grid_ts$TAB_PLACEHOLDER_COLUMN;
				}
				indentColumns.push(char);
			}
			this.indentColumns = indentColumns;
		}

		debugState() {
			return {
				cursor: this.cursor,
				width: this.width,
				height: this.getHeight(),
				lines: this.lines.map(({columns, ranges}) => {
					return {
						line: ___R$$priv$project$rome$$internal$cli$layout$Grid_ts$joinColumns(
							columns,
						),
						ranges: ranges.map(({ancestry, start, end}) => ({
							start,
							end,
							ancestry: ancestry.map((tag) => tag.name).join("|"),
						})),
					};
				}),
			};
		}

		alignRight() {
			const viewportWidth = ___R$project$rome$$internal$ob1$index_ts$ob1Get(
				this.viewportWidth,
			);
			if (viewportWidth === undefined) {
				return;
			}

			this.lines = this.lines.map(({ranges, columns}) => {
				let newColumns = [];

				// Pad out line to viewport width
				const offset = Math.max(0, viewportWidth - columns.length);
				for (const char of this.getSpaces(offset)) {
					newColumns.push(char);
				}

				newColumns = newColumns.concat(columns);

				// Skip if all it contains is whitespace
				let onlyWhitespace = true;
				for (const char of newColumns) {
					if (
						!___R$$priv$project$rome$$internal$cli$layout$Grid_ts$isWhitespace(
							char,
						)
					) {
						onlyWhitespace = false;
					}
				}
				if (onlyWhitespace) {
					return {
						columns: newColumns,
						ranges,
					};
				}

				const newRanges = ranges.map((range) => {
					return {
						start: ___R$project$rome$$internal$ob1$index_ts$ob1Add(
							range.start,
							offset,
						),
						end: ___R$project$rome$$internal$ob1$index_ts$ob1Add(
							range.end,
							offset,
						),
						ancestry: range.ancestry,
					};
				});

				return {
					ranges: newRanges,
					columns: newColumns,
				};
			});
		}

		doesOverflowViewport(column) {
			return (
				this.lineWrapMode !== "none" &&
				this.viewportWidth !== undefined &&
				___R$project$rome$$internal$ob1$index_ts$ob1Get1(column) >
				___R$project$rome$$internal$ob1$index_ts$ob1Get1(this.viewportWidth)
			);
		}

		getHeight() {
			return ___R$project$rome$$internal$ob1$index_ts$ob1Coerce1(
				this.lines.length,
			);
		}

		getLine(line) {
			const lineIndex =
				___R$project$rome$$internal$ob1$index_ts$ob1Get1(line) - 1;
			for (let i = lineIndex; i >= 0 && this.lines[i] === undefined; i--) {
				this.clearLine(
					___R$project$rome$$internal$ob1$index_ts$ob1Coerce1(i + 1),
				);
			}
			return this.lines[lineIndex];
		}

		clearLine(line) {
			this.lines[___R$project$rome$$internal$ob1$index_ts$ob1Get1(line) - 1] = {
				ranges: [],
				columns: [],
			};
		}

		getLineWidth(line) {
			return ___R$project$rome$$internal$ob1$index_ts$ob1Coerce1(
				this.getLine(line).columns.length,
			);
		}

		getWidth() {
			return this.width;
		}

		getSize() {
			return {
				height: this.getHeight(),
				width: this.getWidth(),
			};
		}

		getCursor() {
			return Object.assign({}, this.cursor);
		}

		getLines(format) {
			switch (format) {
				case "ansi":
					return this.getFormattedAnsiLines();

				case "html":
					return this.getFormattedHtmlLines();

				case "none":
					return this.getUnformattedLines();
			}
		}

		getTrimmedLines() {
			const lines = [...this.lines];

			// Remove empty columns
			// Explicit newlines will have at least one column with an empty field
			while (lines.length > 0 && lines[lines.length - 1].columns.length === 0) {
				lines.pop();
			}

			return lines;
		}

		getUnformattedLines() {
			return this.lines.map(({columns}) => {
				return ___R$$priv$project$rome$$internal$cli$layout$Grid_ts$joinColumns(
					columns,
				).trimRight();
			});
		}

		getFormattedLines(opts) {
			const lines = [];

			for (const {ranges, columns} of this.getTrimmedLines()) {
				// Sort ranges from last to first
				const sortedRanges = ranges.sort((a, b) =>
					___R$project$rome$$internal$ob1$index_ts$ob1Get1(b.end) -
					___R$project$rome$$internal$ob1$index_ts$ob1Get1(a.end)
				);

				let line = "";

				let lastEnd = undefined;

				function catchUp(end) {
					const start = opts.normalizeText(
						___R$$priv$project$rome$$internal$cli$layout$Grid_ts$joinColumns(
							columns.slice(end, lastEnd),
						),
					);
					line = "" + start + line;
					lastEnd = end;
				}

				for (const {start, end, ancestry} of sortedRanges) {
					catchUp(___R$project$rome$$internal$ob1$index_ts$ob1Get1(end) - 1);

					let substr = opts.normalizeText(
						___R$$priv$project$rome$$internal$cli$layout$Grid_ts$sliceColumns(
							columns,
							start,
							end,
						),
					);

					// Format tags in reverse
					for (let i = ancestry.length - 1; i >= 0; i--) {
						const tag = ancestry[i];
						substr = opts.formatTag(tag, substr);
					}

					substr = opts.wrapRange(substr);

					line = "" + substr + line;
					lastEnd = ___R$project$rome$$internal$ob1$index_ts$ob1Get1(start) - 1;
				}

				catchUp(0);

				lines.push(line.trimRight());
			}

			return lines;
		}

		getFormattedHtmlLines() {
			return this.getFormattedLines({
				normalizeText: (text) =>
					___R$project$rome$$internal$html$parser$xhtmlEntities_ts$escapeXHTMLEntities(
						text,
					)
				,
				formatTag: (tag, inner) =>
					___R$project$rome$$internal$cli$layout$formatHTML_ts$htmlFormatText(
						tag,
						inner,
					)
				,
				wrapRange: (str) => str,
			});
		}

		getFormattedAnsiLines() {
			return this.getFormattedLines({
				normalizeText: (text) => text,
				formatTag: (tag, inner) => {
					return ___R$project$rome$$internal$cli$layout$formatANSI_ts$ansiFormatText(
						tag,
						inner,
						this,
					);
				},
				wrapRange: (str) =>
					___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.reset(str)
				,
			});
		}

		// Fill current cursor line with spaces until the column
		fillCursor(cursor) {
			const line = this.getLine(cursor.line);
			const colIndex =
				___R$project$rome$$internal$ob1$index_ts$ob1Get1(cursor.column) - 1;

			// Amount of spaces to insert
			let count = 0;

			// Calculate how many we need to insert
			let i = colIndex - 1;
			while (i >= 0 && (line.columns[i] === undefined || line.columns[i] === "")) {
				i--;
				count++;
			}

			// Insert spaces
			for (const char of this.getSpaces(count)) {
				i++;
				line.columns[i] = char;
			}
		}

		moveCursor(cursor) {
			if (cursor.line !== this.cursor.line) {
				this.lineStartMeta.softWrapped = false;
				this.lineStartMeta.indentationCount = 0;
				this.lineStartMeta.sourceColumn = this.sourceCursor.currentColumn;
			}

			this.cursor = cursor;
		}

		moveCursorRight(
			columns = ___R$project$rome$$internal$ob1$index_ts$ob1Number1,
		) {
			const newColumns = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
				this.cursor.column,
				columns,
			);

			// Perform character line wrap
			if (this.doesOverflowViewport(newColumns)) {
				const currentLine = this.getLine(this.cursor.line);
				const previousLineSoftWrapped = this.lineStartMeta.softWrapped;

				this.newline();

				// Soft wrap, inherit the previous lines indentation
				if (currentLine !== undefined) {
					let i = 0;
					while (
						i < currentLine.columns.length &&
						___R$$priv$project$rome$$internal$cli$layout$Grid_ts$isWhitespace(
							currentLine.columns[i],
						)
					) {
						this.moveCursorRight();
						this.lineStartMeta.indentationCount++;
						i++;
					}

					const {extraSoftWrapIndent} = this.options.view;
					if (previousLineSoftWrapped) {
						this.lineStartMeta.softWrapped = true;
					} else if (extraSoftWrapIndent !== undefined) {
						this.lineStartMeta.softWrapped = true;
						for (let i = 0; i < extraSoftWrapIndent; i++) {
							this.moveCursorRight();
						}
					}
				}
			} else {
				this.moveCursor({
					line: this.cursor.line,
					column: newColumns,
				});
			}
		}

		userNewline() {
			this.newline();
			this.writeToCursor(this.cursor, "");
		}

		newline() {
			this.moveCursor({
				line: ___R$project$rome$$internal$ob1$index_ts$ob1Inc(this.getHeight()),
				column: ___R$project$rome$$internal$ob1$index_ts$ob1Number1,
			});
		}

		writeToCursor(cursor, char) {
			this.fillCursor(cursor);

			const line = this.getLine(cursor.line);
			const colIndex =
				___R$project$rome$$internal$ob1$index_ts$ob1Get1(cursor.column) - 1;

			const existing = line.columns[colIndex];
			if (existing !== undefined && existing !== "") {
				//throw new Error(pretty`Trying to write ${char} but already populated with ${existing}. Debug state: ${this.debugState()}`);
			}

			line.columns[colIndex] = char;

			if (cursor.column > this.width) {
				this.width = cursor.column;
			}
		}

		// Build up columns with as many tabs as we can and then spaces
		getSpaces(count) {
			let columns = [];
			if (count === 0) {
				return columns;
			}

			while (count >= this.tabSize) {
				columns = columns.concat(this.indentColumns);
				count -= this.tabSize;
			}

			while (count > 0) {
				columns.push(" ");
				count--;
			}

			return columns;
		}

		drawSpaces(count) {
			for (const char of this.getSpaces(count)) {
				this.drawChar(char);
			}
		}

		drawIndent() {
			for (const char of this.indentColumns) {
				this.drawChar(char);
			}
		}

		userChar(char) {
			if (char === "\t") {
				this.drawIndent();
			} else if (char === "\n") {
				this.userNewline();
			} else {
				this.drawChar(char);
			}
		}

		drawChar(char) {
			this.writeToCursor(this.cursor, char);
			this.moveCursorRight();
		}

		drawText(tag, ancestry) {
			this.writeText(tag.value, ancestry, tag.source);

			if (!tag.source && tag.sourceValue !== undefined) {
				for (const char of tag.sourceValue) {
					this.moveSourceCursor(char);
				}
			}
		}

		moveSourceCursor(char) {
			if (char === "\n") {
				this.sourceCursor.currentLineText = "";
				this.sourceCursor.currentColumn = ___R$project$rome$$internal$ob1$index_ts$ob1Number1;
				this.sourceCursor.currentLine = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(
					this.sourceCursor.currentLine,
				);
			} else {
				this.sourceCursor.currentLineText += char;
				this.sourceCursor.currentColumn = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(
					this.sourceCursor.currentColumn,
				);
			}
		}

		writeText(text, ancestry, source) {
			if (text === "") {
				return;
			}

			const start = this.getCursor();

			const words = text.split(" ");

			let forceNextWordOverflow = false;

			for (let i = 0; i < words.length; i++) {
				const word = words[i];
				const isLastWord = i === words.length - 1;

				// Check if printing this word would overflow the viewport
				// If the whole word itself wouldn't fit on it's own line then we will
				// perform hard line wrapping in writeChar
				const willOverflow =
					this.lineWrapMode === "word-break" &&
					(forceNextWordOverflow ||
					(this.doesOverflowViewport(
						___R$project$rome$$internal$ob1$index_ts$ob1Add(
							this.cursor.column,
							word.length - 1,
						),
					) &&
					!this.doesOverflowViewport(
						___R$project$rome$$internal$ob1$index_ts$ob1Coerce1(word.length),
					)));
				if (willOverflow) {
					this.newline();
				}
				forceNextWordOverflow = false;

				for (const char of ___R$project$rome$$internal$string$utils$splitChars_ts$splitChars(
					word,
				)) {
					this.userChar(char);

					if (source) {
						this.moveSourceCursor(char);
					}
				}

				let ignoreTrailingSpace = false;

				// Start of a sentence that was caused by line wrapping
				if (
					!word.endsWith("\n") &&
					this.cursor.column ===
					___R$project$rome$$internal$ob1$index_ts$ob1Number1 &&
					word !== ""
				) {
					ignoreTrailingSpace = true;
				}

				// If the next word will cause an overflow then don't print a leading space as it will be pointless
				const nextWord = words[i + 1];
				if (
					this.lineWrapMode === "word-break" &&
					nextWord !== undefined &&
					this.doesOverflowViewport(
						___R$project$rome$$internal$ob1$index_ts$ob1Add(
							this.cursor.column,
							nextWord.length,
						),
					)
				) {
					ignoreTrailingSpace = true;
					forceNextWordOverflow = true;
				}

				if (isLastWord) {
					ignoreTrailingSpace = true;
				}

				if (!ignoreTrailingSpace) {
					this.drawChar(" ");
				}
			}

			const end = this.getCursor();
			this.addCursorRange(start, end, ancestry);
		}

		setRange(lineNo, start, end, ancestry) {
			if (start === end) {
				// Nothing to format. Empty tag.
				return;
			}

			const line = this.getLine(lineNo);

			if (end < start) {
				throw new Error(
					___R$project$rome$$internal$pretty$format$index_ts$pretty`Range end for line index ${lineNo} is before the start. end(${end}) < start(${start}). Debug state: ${this.debugState()}`,
				);
			}

			const {ranges} = line;

			for (const range of ranges) {
				if (
					(start >= range.start && end <= range.end) ||
					(range.start >= start && range.end <= end)
				) {
					throw new Error(
						___R$project$rome$$internal$pretty$format$index_ts$pretty`The line no #${lineNo} ranges ${range.start}-${range.end} (${___R$$priv$project$rome$$internal$cli$layout$Grid_ts$sliceColumns(
							line.columns,
							range.start,
							range.end,
						)}) and ${start}-${end} (${___R$$priv$project$rome$$internal$cli$layout$Grid_ts$sliceColumns(
							line.columns,
							start,
							end,
						)}) overlap. Debug state: ${this.debugState()}`,
					);
				}
			}

			ranges.push({
				start,
				end,
				ancestry,
			});
		}

		addCursorRange(start, end, ancestry) {
			if (ancestry.length === 0) {
				// No point storing a range without ancestry
				return;
			}

			if (start.line === end.line) {
				if (start.column === end.column) {
					// Empty range
					return;
				}

				this.setRange(start.line, start.column, end.column, ancestry);
			} else {
				// Add first line
				this.setRange(
					start.line,
					start.column,
					___R$project$rome$$internal$ob1$index_ts$ob1Inc(
						this.getLineWidth(start.line),
					),
					ancestry,
				);

				// Add middle lines
				for (
					let i =
						___R$project$rome$$internal$ob1$index_ts$ob1Get1(start.line) + 1;
					i < ___R$project$rome$$internal$ob1$index_ts$ob1Get1(end.line);
					i++
				) {
					const line = ___R$project$rome$$internal$ob1$index_ts$ob1Coerce1(i);
					this.setRange(
						line,
						___R$project$rome$$internal$ob1$index_ts$ob1Coerce1(1),
						this.getLineWidth(line),
						ancestry,
					);
				}

				// Add last line
				this.setRange(
					end.line,
					___R$project$rome$$internal$ob1$index_ts$ob1Coerce1(1),
					end.column,
					ancestry,
				);
			}
		}

		drawListTag(tag, ancestry) {
			let items = [];
			for (const child of tag.children) {
				if (child.type === "Tag" && child.name === "li") {
					items.push(child);
				}
			}
			if (items.length === 0) {
				return;
			}

			const ordered = tag.name === "ol";

			if (ordered) {
				const reversed = tag.attributes.get("reversed").asBoolean(false);
				const startOffset = tag.attributes.get("start").asNumber(0);

				const highestNumSize = ___R$project$rome$$internal$string$utils$humanizeNumber_ts$humanizeNumber(
					items.length + startOffset,
				).length;

				for (let i = 0; i < items.length; i++) {
					const item = items[i];

					let num = startOffset;
					if (reversed) {
						num += items.length - i;
					} else {
						num += i + 1;
					}

					const humanNum = ___R$project$rome$$internal$string$utils$humanizeNumber_ts$humanizeNumber(
						num,
					);
					this.drawSpaces(highestNumSize - humanNum.length);
					this.writeText(
						humanNum + ". ",
						[
							___R$$priv$project$rome$$internal$cli$layout$Grid_ts$createTag(
								"dim",
								___R$project$rome$$internal$markup$util_ts$createEmptyAttributes(),
							),
						],
						false,
					);
					this.drawViewTag(item, ancestry);
					this.newline();
				}
			} else {
				for (const item of items) {
					this.writeText(
						"- ",
						[
							___R$$priv$project$rome$$internal$cli$layout$Grid_ts$createTag(
								"dim",
								___R$project$rome$$internal$markup$util_ts$createEmptyAttributes(),
							),
						],
						false,
					);
					this.drawViewTag(item, ancestry);
					this.newline();
				}
			}
		}

		drawPointer() {
			const {pointer} = this.options.view;
			const {sourceCursor, lineStartMeta, cursor} = this;
			if (pointer === undefined) {
				return false;
			}

			if (sourceCursor.currentLine !== pointer.line) {
				// I'm not quite sure what we are meant to do here
				return false;
			}

			let start = ___R$project$rome$$internal$ob1$index_ts$ob1Get1(
				pointer.columnStart,
			);
			let end = ___R$project$rome$$internal$ob1$index_ts$ob1Get1(
				pointer.columnEnd,
			);

			if (cursor.line !== sourceCursor.currentLine) {
				start = 0;
				end =
					end -
					___R$project$rome$$internal$ob1$index_ts$ob1Get1(
						lineStartMeta.sourceColumn,
					);
			}

			let markerOffset = start;
			let markerSize = end - start;

			// Account for soft indentation
			markerOffset += lineStartMeta.indentationCount;

			// If the marker includes tabs then increase the size
			for (let i = start; i < end; i++) {
				if (sourceCursor.currentLineText[i] === "\t") {
					markerSize += this.tabSize - 1;
				}
			}

			markerSize = Math.max(1, markerSize);

			// If any previous text on this line contains tabs then increase the offset
			for (let i = 0; i < start; i++) {
				if (sourceCursor.currentLineText[i] === "\t") {
					markerOffset += this.tabSize - 1;
				}
			}

			this.newline();

			// Pointer offset
			//this.drawSpaces(markerOffset);
			this.writeText(" ".repeat(markerOffset), [], false);

			// Pointer character
			if (pointer.char.length === 0) {
				this.writeText("^".repeat(markerSize), [], false);
			} else {
				for (let i = 0; i < markerSize; i++) {
					this.drawChildren(pointer.char, []);
				}
			}

			// Pointer message
			if (pointer.message.length > 0) {
				this.writeText(" ", [], false);
				this.drawViewTag(
					___R$$priv$project$rome$$internal$cli$layout$Grid_ts$createTag(
						"view",
						undefined,
						pointer.message,
					),
					[],
				);
			}

			return true;
		}

		parse(sub, offsetPosition) {
			if (sub === undefined) {
				return [];
			}

			return this.normalizeChildren(
				___R$project$rome$$internal$markup$parse_ts$parseMarkup(
					sub,
					{offsetPosition, sourceText: this.options.sourceText},
				),
			);
		}

		getViewLinePrefixes(children, ancestry) {
			const prefixes = [];

			let linePrefixFirst;
			let linePrefixMiddle;
			let linePrefixLast;
			let linePrefixPointer;

			// Extract viewLinePrefix tags
			for (const child of children) {
				switch (child.attributes.get("type").asStringOrVoid()) {
					case "first": {
						linePrefixFirst = child;
						prefixes.push(linePrefixFirst);
						break;
					}

					case "middle": {
						linePrefixMiddle = child;
						if (linePrefixLast === undefined) {
							linePrefixLast = child;
						}
						prefixes.push(child);
						break;
					}

					case "end": {
						linePrefixLast = child;
						prefixes.push(child);
						break;
					}

					case "pointer": {
						linePrefixPointer = child;
						prefixes.push(child);
						break;
					}

					case undefined: {
						if (
							linePrefixPointer === undefined ||
							linePrefixFirst === undefined ||
							linePrefixMiddle === undefined ||
							linePrefixLast === undefined
						) {
							prefixes.push(child);
						}
						if (linePrefixFirst === undefined) {
							linePrefixFirst = child;
						}
						if (linePrefixMiddle === undefined) {
							linePrefixMiddle = child;
						}
						if (linePrefixLast === undefined) {
							linePrefixLast = child;
						}
						if (linePrefixPointer === undefined) {
							linePrefixPointer = child;
						}
						break;
					}
				}
			}

			const childrenToGrid = new Map();
			let maxWidth = ___R$project$rome$$internal$ob1$index_ts$ob1Coerce1(0);

			// Get the maxWidth
			for (const prefix of prefixes) {
				const grid = new ___R$project$rome$$internal$cli$layout$Grid_ts$default(
					Object.assign({}, this.options, {columns: undefined}),
				);
				grid.drawChildren(prefix.children, ancestry);
				const width = grid.getSize().width;
				if (width > maxWidth) {
					maxWidth = width;
				}
			}

			// Now actually render the grids
			for (const prefix of prefixes) {
				const grid = new ___R$project$rome$$internal$cli$layout$Grid_ts$default(
					Object.assign({}, this.options, {columns: maxWidth}),
				);
				grid.drawChildren(prefix.children, ancestry);
				grid.maybeAlign(prefix);
				childrenToGrid.set(prefix, grid);
			}

			return {
				width: maxWidth,
				pointer: childrenToGrid.get(linePrefixPointer),
				first: childrenToGrid.get(linePrefixFirst),
				middle: childrenToGrid.get(linePrefixMiddle),
				last: childrenToGrid.get(linePrefixLast),
			};
		}

		getViewPointer({attributes, children}) {
			return {
				char: this.parse(
					attributes.get("char").asString(""),
					attributes.get("char").getDiagnosticLocation("inner-value").start,
				),
				message: children,
				line: attributes.get("line").asOneIndexedNumber(0),
				columnStart: attributes.get("start").asOneIndexedNumber(0),
				columnEnd: attributes.get("end").asOneIndexedNumber(0),
			};
		}

		drawViewTag(tag, ancestry, shrinkViewport) {
			const tags = ___R$$priv$project$rome$$internal$cli$layout$Grid_ts$extractViewTags(
				tag,
			);
			const {children} = tags;
			const {attributes} = tag;

			const pointer =
				tags.pointer === undefined
					? undefined
					: this.getViewPointer(tags.pointer);
			const linePrefixes = this.getViewLinePrefixes(tags.linePrefixes, ancestry);
			const startCursor = this.getCursor();

			// Calculate size of view
			let subViewport = undefined;
			const {viewportWidth} = this;
			if (viewportWidth !== undefined) {
				subViewport = viewportWidth;
				subViewport = ___R$project$rome$$internal$ob1$index_ts$ob1Sub(
					subViewport,
					startCursor.column,
				);
				// We add on one because we can place a character on the cursor position
				subViewport = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
					subViewport,
					1,
				);
				subViewport = ___R$project$rome$$internal$ob1$index_ts$ob1Sub(
					subViewport,
					linePrefixes.width,
				);
				if (shrinkViewport !== undefined) {
					subViewport = ___R$project$rome$$internal$ob1$index_ts$ob1Sub(
						subViewport,
						shrinkViewport,
					);
				}
			}

			const lineWrapMode = ___R$project$rome$$internal$markup$tags_ts$lineWrapValidator(
				attributes.get("lineWrap").asStringOrVoid(),
			);

			// Bail and just render the children if this view is redundant
			// This can happen since we wrap some other elements in views
			// The following conditions need to be met:
			// - No custom line wrap mode
			// - No pointer
			// - View viewport is the same
			// - No line prefixes
			// - Cursor on the first column
			if (
				lineWrapMode === undefined &&
				pointer === undefined &&
				subViewport !== undefined &&
				subViewport === this.viewportWidth &&
				linePrefixes.width ===
				___R$project$rome$$internal$ob1$index_ts$ob1Coerce1(0) &&
				startCursor.column ===
				___R$project$rome$$internal$ob1$index_ts$ob1Number1
			) {
				this.drawChildren(children, ancestry);
				return;
			}

			// Render first prefix
			if (linePrefixes.first !== undefined) {
				this.drawGrid(linePrefixes.first);
			}

			const grid = new ___R$project$rome$$internal$cli$layout$Grid_ts$default(
				Object.assign(
					{},
					this.options,
					{
						view: {
							extraSoftWrapIndent: attributes.get("extraSoftWrapIndent").asNumberOrVoid(),
							pointer,
							lineWrapMode,
						},
						columns: subViewport,
					},
				),
			);
			for (const child of children) {
				grid.drawChild(child, ancestry);
			}
			const drewPointer = grid.drawPointer();
			grid.maybeAlign(tag);

			this.moveCursor(
				Object.assign(
					{},
					startCursor,
					{
						column: ___R$project$rome$$internal$ob1$index_ts$ob1Add(
							startCursor.column,
							linePrefixes.width,
						),
					},
				),
			);
			this.drawGrid(grid);

			// Add line prefixes if we wrapped
			const height = ___R$project$rome$$internal$ob1$index_ts$ob1Get1(
				grid.getHeight(),
			);
			for (let i = 1; i < height; i++) {
				let linePrefix = linePrefixes.middle;

				if (i === height - 1) {
					if (drewPointer) {
						// Don't prefix a pointer
						linePrefix = linePrefixes.pointer;
					} else {
						linePrefix = linePrefixes.last;
					}
				}

				// Correct last offset if we drew a pointer
				if (drewPointer && i === height - 2) {
					linePrefix = linePrefixes.last;
				}

				if (linePrefix !== undefined) {
					this.moveCursor({
						line: ___R$project$rome$$internal$ob1$index_ts$ob1Add(
							startCursor.line,
							i,
						),
						column: startCursor.column,
					});

					this.drawGrid(linePrefix);
				}
			}

			this.newline();
		}

		drawTableTag(tag, ancestry) {
			var ___R$;
			const rows = [];

			for (const child of tag.children) {
				if (child.type === "Tag" && child.name === "tr") {
					const row = [];

					for (const field of child.children) {
						if (field.type === "Tag" && field.name === "td") {
							row.push(field);
						} else {
							// Probably error?
						}
					}

					rows.push(row);
				} else {
					// Probably error?
				}
			}

			// Get the max number of columns for a row
			const columnCount =
				(___R$ = Math,
				___R$.max.apply(___R$, [...rows.map((columns) => columns.length)]));

			// Get column widths
			const columnWidths = [];
			for (let i = 0; i < columnCount; i++) {
				var ___R$1;
				const widths = rows.map((row) => {
					const field = row[i];
					if (field === undefined) {
						// Could be an excessive column
						return 0;
					} else {
						const grid = new ___R$project$rome$$internal$cli$layout$Grid_ts$default(
							Object.assign({}, this.options, {columns: undefined}),
						);
						grid.drawTag(field, ancestry);
						return ___R$project$rome$$internal$ob1$index_ts$ob1Get1(
							grid.getSize().width,
						);
					}
				});
				columnWidths[i] = (___R$1 = Math, ___R$1.max.apply(___R$1, [...widths]));
			}

			// If the column size exceed the stream columns then scale them all down
			const colsNeeded = columnWidths.reduce((a, b) => a + b, 0);
			const {viewportWidth} = this;
			let availableCols =
				viewportWidth === undefined
					? undefined
					: ___R$project$rome$$internal$ob1$index_ts$ob1Get(viewportWidth) -
						columnCount -
						1;
			if (availableCols !== undefined && colsNeeded > availableCols) {
				// Find the biggest column
				let biggestColIndex = 0;
				for (let i = 0; i < columnWidths.length; i++) {
					const ourSize = columnWidths[i];
					const biggestSize = columnWidths[biggestColIndex];

					if (ourSize > biggestSize) {
						biggestColIndex = i;
					}
				}

				// Remove all columns from availableCols
				for (let i = 0; i < columnWidths.length; i++) {
					if (i !== biggestColIndex) {
						availableCols -= columnWidths[i];
					}
				}

				// Set biggest column to the availableCols
				columnWidths[biggestColIndex] = availableCols;
			}

			for (const row of rows) {
				for (let colIndex = 0; colIndex < row.length; colIndex++) {
					const field = row[colIndex];
					const width = ___R$project$rome$$internal$ob1$index_ts$ob1Coerce1(
						columnWidths[colIndex],
					);

					const grid = new ___R$project$rome$$internal$cli$layout$Grid_ts$default(
						Object.assign({}, this.options, {columns: width}),
					);
					grid.drawTag(field, ancestry);
					grid.maybeAlign(field);

					this.drawGrid(grid);
					this.moveCursorRight(
						___R$project$rome$$internal$ob1$index_ts$ob1Inc(width),
					);
				}

				this.newline();
			}
		}

		drawIndentTag(tag, ancestry) {
			// Optimization for nested indents
			let levels = 1;
			let children = tag.children;
			while (
				children.length === 1 &&
				children[0].type === "Tag" &&
				children[0].name === "indent"
			) {
				children = children[0].children;
				levels++;
			}

			for (let i = 0; i < levels; i++) {
				this.drawIndent();
			}

			this.drawViewTag(
				___R$$priv$project$rome$$internal$cli$layout$Grid_ts$createTag(
					"view",
					___R$project$rome$$internal$markup$util_ts$createEmptyAttributes(),
					children,
				),
				ancestry,
				___R$project$rome$$internal$ob1$index_ts$ob1Coerce1(levels * 2),
			);
		}

		// Sometimes we derive a Grid from a tag that accepts an align attribute
		maybeAlign(tag) {
			if (tag.attributes.get("align").asStringOrVoid() === "right") {
				this.alignRight();
			}
		}

		drawGrid(grid) {
			const lines = grid.getTrimmedLines();
			const cursor = this.getCursor();

			for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
				const {columns, ranges} = lines[lineIndex];

				const correctLine = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
					cursor.line,
					lineIndex,
				);

				for (let colIndex = 0; colIndex < columns.length; colIndex++) {
					const char = columns[colIndex];

					this.writeToCursor(
						{
							line: correctLine,
							column: ___R$project$rome$$internal$ob1$index_ts$ob1Add(
								cursor.column,
								colIndex,
							),
						},
						char,
					);
				}

				for (const range of ranges) {
					this.setRange(
						correctLine,
						___R$project$rome$$internal$ob1$index_ts$ob1Dec(
							___R$project$rome$$internal$ob1$index_ts$ob1Add(
								cursor.column,
								range.start,
							),
						),
						___R$project$rome$$internal$ob1$index_ts$ob1Dec(
							___R$project$rome$$internal$ob1$index_ts$ob1Add(
								cursor.column,
								range.end,
							),
						),
						range.ancestry,
					);
				}
			}
		}

		drawTag(tag, ancestry) {
			const hook = ___R$$priv$project$rome$$internal$cli$layout$Grid_ts$hooks.get(
				tag.name,
			);

			const subAncestry = [...ancestry, tag];

			if (hook !== undefined && hook.before !== undefined) {
				hook.before(tag, this, ancestry);
			}

			switch (tag.name) {
				case "ol":
				case "ul": {
					this.drawListTag(tag, subAncestry);
					break;
				}

				case "table": {
					this.drawTableTag(tag, subAncestry);
					break;
				}

				case "view": {
					this.drawViewTag(tag, subAncestry);
					break;
				}

				case "indent": {
					this.drawIndentTag(tag, subAncestry);
					break;
				}

				default: {
					this.drawChildren(tag.children, subAncestry);
					break;
				}
			}

			if (hook !== undefined && hook.after !== undefined) {
				hook.after(tag, this, ancestry);
			}
		}

		drawChild(child, ancestry) {
			if (child.type === "Text") {
				this.drawText(child, ancestry);
			} else {
				this.drawTag(child, ancestry);
			}
		}

		drawChildren(children, ancestry) {
			for (const child of children) {
				this.drawChild(child, ancestry);
			}
		}

		normalizeChildren(children) {
			let newChildren = [];

			for (const child of children) {
				newChildren = newChildren.concat(this.normalizeChild(child));
			}

			return newChildren;
		}

		normalizeChild(child) {
			if (child.type === "Text") {
				let {value} = child;

				if (this.options.convertTabs && value.includes("\t")) {
					const splitTabs = value.split("\t");
					const children = [];

					for (let i = 0; i < splitTabs.length; i++) {
						if (i > 0) {
							children.push({
								type: "Text",
								source: false,
								sourceValue: "\t",
								value: " ".repeat(this.tabSize),
							});
						}

						const value = splitTabs[i];
						children.push({
							type: "Text",
							source: true,
							value,
						});
					}

					return children;
				}

				// Remove '\r' in case it snuck in as file contents
				value = value.replace(/\r/g, "");

				return [
					{
						type: "Text",
						source: true,
						value,
					},
				];
			}

			const tag = child;
			const children = this.normalizeChildren(tag.children);
			const textLength = ___R$$priv$project$rome$$internal$cli$layout$Grid_ts$getChildrenTextLength(
				children,
			);
			const hasText = textLength > 0;

			let attributesWithoutEmphasis = tag.attributes;
			if (attributesWithoutEmphasis.has("emphasis")) {
				const emphasis = attributesWithoutEmphasis.get("emphasis").asBoolean(
					false,
				);
				attributesWithoutEmphasis = attributesWithoutEmphasis.copy({
					emphasis: undefined,
				});
				if (emphasis) {
					return this.normalizeChild(
						___R$$priv$project$rome$$internal$cli$layout$Grid_ts$createTag(
							"emphasis",
							___R$project$rome$$internal$markup$util_ts$createEmptyAttributes(),
							[Object.assign({}, tag, {attributes: attributesWithoutEmphasis})],
						),
					);
				}
			}

			let attributes = attributesWithoutEmphasis;
			if (attributes.has("dim")) {
				const dim = attributes.get("dim").asBoolean(false);
				attributes = attributes.copy({dim: undefined});
				if (dim) {
					return this.normalizeChild(
						___R$$priv$project$rome$$internal$cli$layout$Grid_ts$createTag(
							"dim",
							___R$project$rome$$internal$markup$util_ts$createEmptyAttributes(),
							[Object.assign({}, tag, {attributes})],
						),
					);
				}
			}

			// Insert padding
			if (tag.name === "pad") {
				const width = attributes.get("width").asNumber(0);
				const paddingSize = width - textLength;
				if (paddingSize > 0) {
					const paddingTextNode = {
						type: "Text",
						source: false,
						value: ___R$$priv$project$rome$$internal$cli$layout$Grid_ts$joinColumns(
							this.getSpaces(paddingSize),
						),
					};
					if (tag.attributes.get("align").asStringOrVoid() === "right") {
						return [paddingTextNode, ...tag.children];
					} else {
						return [...tag.children, paddingTextNode];
					}
				} else {
					return tag.children;
				}
			}

			// Insert highlight legend
			if (tag.name === "highlight" && attributes.get("legend").asBoolean(false)) {
				const index = Math.min(0, attributes.get("i").asNumber(0));
				return [
					Object.assign(
						{},
						tag,
						{attributes: attributes.copy({legend: undefined})},
					),
					___R$$priv$project$rome$$internal$cli$layout$Grid_ts$createTag(
						"dim",
						___R$project$rome$$internal$markup$util_ts$createEmptyAttributes(),
						[
							{
								type: "Text",
								source: false,
								value: "[" + String(index + 1) + "]",
							},
						],
					),
				];
			}

			if (hasText) {
				if (tag.name === "hr") {
					return [
						Object.assign(
							{},
							tag,
							{
								children: [
									{
										type: "Text",
										source: false,
										value: " ",
									},
									...children,
									{
										type: "Text",
										source: false,
										value: " ",
									},
								],
							},
						),
					];
				}
			} else {
				if (tag.name === "filelink") {
					return [
						Object.assign(
							{},
							tag,
							{
								children: [
									{
										type: "Text",
										source: false,
										value: ___R$project$rome$$internal$markup$util_ts$buildFileLink(
											tag.attributes,
											this.options,
										).text,
									},
								],
							},
						),
					];
				} else if (tag.name === "hyperlink") {
					return [
						Object.assign(
							{},
							tag,
							{
								children: [
									{
										type: "Text",
										source: false,
										value: tag.attributes.get("target").asString(""),
									},
								],
							},
						),
					];
				}
			}

			// These tags only expect text inside off them
			const singleInnerText =
				children.length === 1 && children[0].type === "Text"
					? children[0].value
					: undefined;
			if (singleInnerText !== undefined) {
				switch (tag.name) {
					case "filesize":
						return [
							Object.assign(
								{},
								tag,
								{
									children: [
										{
											type: "Text",
											source: false,
											sourceValue: singleInnerText,
											value: ___R$project$rome$$internal$string$utils$humanizeFileSize_ts$humanizeFileSize(
												Number(singleInnerText),
											),
										},
									],
								},
							),
						];

					case "duration":
						return [
							Object.assign(
								{},
								tag,
								{
									children: [
										{
											type: "Text",
											source: false,
											sourceValue: singleInnerText,
											value: ___R$project$rome$$internal$markup$util_ts$formatApprox(
												attributes,
												___R$project$rome$$internal$string$utils$humanizeTime_ts$humanizeTime(
													Number(singleInnerText),
													true,
												),
											),
										},
									],
								},
							),
						];

					case "number":
						return [
							Object.assign(
								{},
								tag,
								{
									children: [
										{
											type: "Text",
											source: false,
											sourceValue: singleInnerText,
											value: ___R$project$rome$$internal$markup$util_ts$formatNumber(
												attributes,
												singleInnerText,
											),
										},
									],
								},
							),
						];

					case "grammarNumber":
						return [
							Object.assign(
								{},
								tag,
								{
									children: [
										{
											type: "Text",
											source: false,
											sourceValue: singleInnerText,
											value: ___R$project$rome$$internal$markup$util_ts$formatGrammarNumber(
												attributes,
												singleInnerText,
											),
										},
									],
								},
							),
						];
				}
			}

			return [Object.assign({}, tag, {children})];
		}
	}

	function ___R$$priv$project$rome$$internal$cli$layout$Grid_ts$getChildrenTextLength(
		children,
	) {
		let length = 0;

		for (const child of children) {
			if (child.type === "Text") {
				length += child.value.length;
			}

			if (child.type === "Tag") {
				length += ___R$$priv$project$rome$$internal$cli$layout$Grid_ts$getChildrenTextLength(
					child.children,
				);
			}
		}

		return length;
	}

	const ___R$$priv$project$rome$$internal$cli$layout$Grid_ts$hooks = new Map();

	___R$$priv$project$rome$$internal$cli$layout$Grid_ts$hooks.set(
		"hr",
		{
			after: (tag, grid, ancestry) => {
				let viewportWidth =
					grid.viewportWidth === undefined
						? 100
						: ___R$project$rome$$internal$ob1$index_ts$ob1Get1(
								grid.viewportWidth,
							);
				let size =
					viewportWidth -
					___R$project$rome$$internal$ob1$index_ts$ob1Get1(grid.cursor.column) +
					1;
				size = Math.max(size, 0);
				grid.writeText("\u2501".repeat(size), ancestry, false);
			},
		},
	);


  // project-rome/@internal/cli-layout/format.ts
function ___R$project$rome$$internal$cli$layout$format_ts$renderGrid(
		safeMaybeLazy,
		opts = {},
		format,
	) {
		const safe = ___R$project$rome$$internal$markup$escape_ts$serializeLazyMarkup(
			safeMaybeLazy,
		);

		// Optimization for rendering a single escaped string with no columns
		if (
			opts.columns === undefined &&
			___R$project$rome$$internal$markup$util_ts$isSingleEscaped(safe)
		) {
			var ___R$;
			let line = safe.parts[0];

			if (opts.convertTabs) {
				// TODO make the tab width customizable in userConfig
				line = line.replace(/\t/g, " ".repeat(2));
			}

			const lines = ___R$project$rome$$internal$string$utils$splitLines_ts$splitLines(
				line,
			);
			const width =
				(___R$ = Math,
				___R$.max.apply(
					___R$,
					[
						...lines.map((line) =>
							___R$project$rome$$internal$string$utils$splitChars_ts$splitChars(
								line,
							).length
						),
					],
				));

			return {
				width,
				lines,
			};
		}

		const input = ___R$project$rome$$internal$markup$escape_ts$readMarkup(safe);
		const grid = new ___R$project$rome$$internal$cli$layout$Grid_ts$default(
			Object.assign({}, opts, {sourceText: input, view: {}}),
		);
		grid.drawChildren(grid.parse(safe, undefined), []);
		return {
			width: ___R$project$rome$$internal$ob1$index_ts$ob1Get1(grid.getWidth()),
			lines: grid.getLines(format),
		};
	}

	function ___R$project$rome$$internal$cli$layout$format_ts$markupToJoinedPlainText(
		input,
		opts = {},
	) {
		return ___R$project$rome$$internal$markup$normalize_ts$joinMarkupLines(
			___R$project$rome$$internal$cli$layout$format_ts$markupToPlainText(
				input,
				opts,
			),
		);
	}

	function ___R$project$rome$$internal$cli$layout$format_ts$markupToPlainText(
		input,
		opts = {},
	) {
		return ___R$project$rome$$internal$cli$layout$format_ts$renderGrid(
			input,
			opts,
			"none",
		);
	}

	function ___R$project$rome$$internal$cli$layout$format_ts$markupToAnsi(
		input,
		opts = {},
	) {
		return ___R$project$rome$$internal$cli$layout$format_ts$renderGrid(
			input,
			opts,
			"ansi",
		);
	}

	function ___R$project$rome$$internal$cli$layout$format_ts$markupToHtml(
		input,
		opts = {},
	) {
		return ___R$project$rome$$internal$cli$layout$format_ts$renderGrid(
			input,
			opts,
			"html",
		);
	}


  // project-rome/@internal/cli-layout/types.ts
const ___R$project$rome$$internal$cli$layout$types_ts = {};


  // project-rome/@internal/cli-layout/index.ts



  // project-rome/@internal/cli-reporter/ProgressBase.ts
const ___R$$priv$project$rome$$internal$cli$reporter$ProgressBase_ts$DEFAULT_PROGRESS_OPTIONS = {
		name: undefined,
		title: undefined,
		initDelay: undefined,
		elapsed: true,
		eta: true,
		persistent: false,
	};

	class ___R$project$rome$$internal$cli$reporter$ProgressBase_ts$default {
		constructor(reporter, opts = {}) {
			this.total = undefined;
			this.reporter = reporter;
			this.current = 0;

			this.approximateTotal = false;
			this.approximateETA = undefined;

			this.textIdCounter = 0;
			this.textIdStack = [];
			this.textStack = [];
			this.textIds = new Set();

			this.text = undefined;
			this.title =
				opts.title === undefined ? undefined : reporter.stripMarkup(opts.title);

			this.paused = false;
			this.pausedStart = undefined;
			this.pausedElapsed = 0;

			this.opts = ___R$project$rome$$internal$typescript$helpers$index_ts$mergeObjects(
				___R$$priv$project$rome$$internal$cli$reporter$ProgressBase_ts$DEFAULT_PROGRESS_OPTIONS,
				opts,
			);
		}

		setCurrent(current) {
			this.current = current;
			this.queueRender();

			// Progress complete
			if (
				this.total !== undefined &&
				this.current >= this.total &&
				!this.opts.persistent
			) {
				this.end();
			}
		}

		getText() {
			const {text} = this;
			if (
				text === undefined ||
				___R$project$rome$$internal$markup$escape_ts$isEmptyMarkup(text)
			) {
				return undefined;
			} else {
				return this.reporter.stripMarkup(text);
			}
		}

		setText(text) {
			this.text = text;
			this.queueRender();
		}

		setApproximateETA(duration) {
			this.approximateETA = duration;
		}

		setTotal(total, approximate = false) {
			this.total = total;
			this.approximateTotal = approximate;
			this.queueRender();
		}

		pushText(text, id) {
			if (id === undefined) {
				id = String(this.textIdCounter++);
			}
			if (this.textIds.has(id)) {
				throw new Error("Progress bar text " + id + " already exists");
			}
			this.setText(text);
			this.textStack.push(text);
			this.textIdStack.push(id);
			this.textIds.add(id);
			return id;
		}

		popText(id) {
			// Find
			const {textStack, textIdStack, textIds} = this;
			const index = textIdStack.indexOf(id);
			if (index === -1) {
				throw new Error("No pushed text for id " + id);
			}

			// Remove
			textStack.splice(index, 1);
			textIdStack.splice(index, 1);
			textIds.delete(id);

			// Set last
			const last = textStack[textStack.length - 1];
			this.setText(
				last == null
					? ___R$project$rome$$internal$markup$escape_ts$markup``
					: last,
			);
		}

		tick() {
			this.setCurrent(this.current + 1);
		}

		resume() {
			if (!this.paused || this.pausedStart === undefined) {
				return;
			}

			this.pausedElapsed += Date.now() - this.pausedStart;
			this.pausedStart = undefined;
			this.paused = false;
			this.render();
		}

		pause() {
			if (this.paused) {
				return;
			}

			this.pausedStart = Date.now();
			this.paused = true;
			this.render();
		}

		queueRender() {
			this.render();
		}

		end() {}

		render() {}
	}


  // project-rome/@internal/cli-reporter/stream.ts
const ___R$project$rome$$internal$cli$reporter$stream_ts = {
		getLeadingNewlineCount: ___R$project$rome$$internal$cli$reporter$stream_ts$getLeadingNewlineCount,
		removeLine: ___R$project$rome$$internal$cli$reporter$stream_ts$removeLine,
		createStreamState: ___R$project$rome$$internal$cli$reporter$stream_ts$createStreamState,
		log: ___R$project$rome$$internal$cli$reporter$stream_ts$log,
		isANSICursorStream: ___R$project$rome$$internal$cli$reporter$stream_ts$isANSICursorStream,
		clearScreen: ___R$project$rome$$internal$cli$reporter$stream_ts$clearScreen,
	};
	function ___R$project$rome$$internal$cli$reporter$stream_ts$getLeadingNewlineCount(
		{state},
	) {
		if (!state.leadingNewline) {
			return 0;
		}

		let newlines = 1;
		for (let i = state.buffer.length - 1; i >= 0; i++) {
			const line = state.buffer[i];
			if (line === "") {
				newlines++;
			} else {
				break;
			}
		}
		return newlines;
	}

	function ___R$$priv$project$rome$$internal$cli$reporter$stream_ts$calculateBufferPosition(
		{state},
		targetLine,
	) {
		let lineDiff = ___R$project$rome$$internal$ob1$index_ts$ob1Get0(
			___R$project$rome$$internal$ob1$index_ts$ob1Sub(
				state.currentLine,
				targetLine,
			),
		);
		let bufferIndex = state.buffer.length - lineDiff;

		if (!state.leadingNewline) {
			bufferIndex--;
		}

		return {lineDiff, bufferIndex};
	}

	function ___R$project$rome$$internal$cli$reporter$stream_ts$removeLine(
		stream,
		snapshot,
		stderr = false,
	) {
		// See if this stream is included in the snapshot
		const targetLine = stream.state.lineSnapshots.get(snapshot);
		if (targetLine === undefined) {
			return;
		}

		// We only care about ansi streams with cursor support
		if (
			!___R$project$rome$$internal$cli$reporter$stream_ts$isANSICursorStream(
				stream,
			)
		) {
			return;
		}

		// Position from where we currently are to the target line
		const {lineDiff, bufferIndex} = ___R$$priv$project$rome$$internal$cli$reporter$stream_ts$calculateBufferPosition(
			stream,
			targetLine,
		);

		// If the line to delete is the one we're on then just erase it
		if (lineDiff === 0) {
			stream.state.buffer[bufferIndex] = "";
			___R$$priv$project$rome$$internal$cli$reporter$stream_ts$clearCurrentLine(
				stream,
			);
			return;
		}

		// Remove line from the buffer
		stream.state.buffer.splice(bufferIndex, 1);

		// Update snapshots
		for (const [snapshot, line] of stream.state.lineSnapshots) {
			stream.state.lineSnapshots.set(
				snapshot,
				___R$project$rome$$internal$ob1$index_ts$ob1Dec(line),
			);
		}

		// Update line since we've shifted at least one
		stream.state.currentLine = ___R$project$rome$$internal$ob1$index_ts$ob1Dec(
			stream.state.currentLine,
		);

		// Go to the line right above where we want to remove
		stream.write(
			___R$project$rome$$internal$cli$layout$ansi_ts$ansiEscapes.cursorUp(
				lineDiff + 1,
			),
			stderr,
		);
		stream.write(
			___R$project$rome$$internal$cli$layout$ansi_ts$ansiEscapes.cursorTo(0),
			stderr,
		);

		// Sweeping down, starting rendering the next line
		for (let i = 1; i <= lineDiff; i++) {
			const line = stream.state.buffer[stream.state.buffer.length - lineDiff + i];
			stream.write(
				___R$project$rome$$internal$cli$layout$ansi_ts$ansiEscapes.cursorDown(),
				stderr,
			);
			stream.write(
				___R$project$rome$$internal$cli$layout$ansi_ts$ansiEscapes.cursorTo(0),
				stderr,
			);
			stream.write(
				___R$project$rome$$internal$cli$layout$ansi_ts$ansiEscapes.eraseLine,
				stderr,
			);
			if (line !== undefined) {
				stream.write(line, stderr);
			}
		}
	}

	function ___R$project$rome$$internal$cli$reporter$stream_ts$createStreamState() {
		return {
			lineSnapshots: new Map(),
			currentLine: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
			leadingNewline: false,
			buffer: [],
			nextLineInsertLeadingNewline: false,
		};
	}

	function ___R$project$rome$$internal$cli$reporter$stream_ts$log(
		stream,
		msg,
		opts = {},
		lineOffset = 0,
	) {
		const stderr = opts.stderr === true;
		let pushBuffer = true; //stream.state.lineSnapshots.size >= 0;

		const {replaceLineSnapshot} = opts;
		if (replaceLineSnapshot !== undefined) {
			let replaceLine = stream.state.lineSnapshots.get(replaceLineSnapshot);
			if (replaceLine === undefined) {
				// If we were given a replace line snapshot that we weren't a part of then the next line is considered
				// the owner
				stream.state.lineSnapshots.set(
					replaceLineSnapshot,
					stream.state.currentLine,
				);
				pushBuffer = true;
			} else if (
				___R$project$rome$$internal$cli$reporter$stream_ts$isANSICursorStream(
					stream,
				)
			) {
				replaceLine = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
					replaceLine,
					lineOffset,
				);
				___R$$priv$project$rome$$internal$cli$reporter$stream_ts$logReplace(
					stream,
					msg,
					replaceLine,
					stderr,
				);
				return;
			}
		}

		// We only push to the buffer if we have active line snapshots
		if (!pushBuffer && stream.state.buffer.length > 0) {
			stream.state.buffer = [];
		}

		if (stream.state.nextLineInsertLeadingNewline) {
			stream.state.nextLineInsertLeadingNewline = false;
			___R$$priv$project$rome$$internal$cli$reporter$stream_ts$newline(
				stream,
				stderr,
			);
		}

		if (stream.state.leadingNewline) {
			if (pushBuffer) {
				stream.state.buffer.push(msg);
			}
		} else {
			// If we have no newline then we are a part of the previous line
			const prev = stream.state.buffer.pop() || "";
			const line = prev + msg;
			if (pushBuffer) {
				stream.state.buffer.push(line);
			}
		}

		stream.write(msg, stderr);

		if (opts.preferNoNewline) {
			stream.state.nextLineInsertLeadingNewline = true;
		}

		// If a newline was requested consider us moved
		if (!opts.noNewline && !opts.preferNoNewline) {
			___R$$priv$project$rome$$internal$cli$reporter$stream_ts$newline(
				stream,
				stderr,
			);
		}
	}

	function ___R$project$rome$$internal$cli$reporter$stream_ts$isANSICursorStream(
		stream,
	) {
		return stream.format === "ansi" && stream.features.cursor;
	}

	function ___R$project$rome$$internal$cli$reporter$stream_ts$clearScreen(
		stream,
	) {
		if (
			___R$project$rome$$internal$cli$reporter$stream_ts$isANSICursorStream(
				stream,
			)
		) {
			stream.write(
				___R$project$rome$$internal$cli$layout$ansi_ts$ansiEscapes.clearScreen,
				false,
			);
			stream.state = ___R$project$rome$$internal$cli$reporter$stream_ts$createStreamState();
		}
	}

	function ___R$$priv$project$rome$$internal$cli$reporter$stream_ts$clearCurrentLine(
		stream,
	) {
		stream.write(
			___R$project$rome$$internal$cli$layout$ansi_ts$ansiEscapes.cursorTo(0),
			false,
		);
		stream.write(
			___R$project$rome$$internal$cli$layout$ansi_ts$ansiEscapes.eraseLine,
			false,
		);
		stream.state.nextLineInsertLeadingNewline = false;
	}

	function ___R$$priv$project$rome$$internal$cli$reporter$stream_ts$newline(
		stream,
		stderr,
	) {
		stream.state.leadingNewline = true;
		stream.state.currentLine = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(
			stream.state.currentLine,
		);
		stream.write("\n", stderr);
	}

	function ___R$$priv$project$rome$$internal$cli$reporter$stream_ts$logReplace(
		stream,
		msg,
		targetLine,
		stderr,
	) {
		const {lineDiff, bufferIndex} = ___R$$priv$project$rome$$internal$cli$reporter$stream_ts$calculateBufferPosition(
			stream,
			targetLine,
		);

		// Easy modification when it's just the current line
		if (lineDiff === 0) {
			___R$$priv$project$rome$$internal$cli$reporter$stream_ts$clearCurrentLine(
				stream,
			);
			stream.state.buffer[bufferIndex] = msg;
			stream.write(msg, stderr);
			return;
		}

		// Advance to and replace the target line
		stream.state.buffer[bufferIndex] = msg;
		stream.write(
			___R$project$rome$$internal$cli$layout$ansi_ts$ansiEscapes.cursorUp(
				lineDiff,
			),
			false,
		);
		stream.write(
			___R$project$rome$$internal$cli$layout$ansi_ts$ansiEscapes.cursorTo(0),
			false,
		);
		stream.write(
			___R$project$rome$$internal$cli$layout$ansi_ts$ansiEscapes.eraseLine,
			false,
		);
		stream.write(msg, false);

		// Advance back to the bottom
		if (lineDiff > 0) {
			stream.write(
				___R$project$rome$$internal$cli$layout$ansi_ts$ansiEscapes.cursorDown(
					lineDiff,
				),
				false,
			);
			stream.write(
				___R$project$rome$$internal$cli$layout$ansi_ts$ansiEscapes.cursorTo(0),
				false,
			);
		}
	}


  // project-rome/@internal/cli-reporter/Progress.ts
// 30 columns a second
	const ___R$$priv$project$rome$$internal$cli$reporter$Progress_ts$BOUNCER_INTERVAL =
		1_000 / 30;
	const ___R$$priv$project$rome$$internal$cli$reporter$Progress_ts$BOUNCER_WIDTH = 20;

	class ___R$project$rome$$internal$cli$reporter$Progress_ts$default
		extends ___R$project$rome$$internal$cli$reporter$ProgressBase_ts$default {
		constructor(reporter, opts = {}, onEnd) {
			super(reporter, opts);

			this.firstRenderLineSnapshot = undefined;
			this.startTime = Date.now();
			this.lastRenderTime = undefined;
			this.lastNoCursorRenderTime = undefined;
			this.lastRenderCurrent = 0;

			this.closed = false;
			this.onEnd = onEnd;

			this.delay = 60;
			this.renderEvery = 0;

			this.streamToBouncerStart = new Map();
			this.startBouncer();

			this.queueRender(opts.initDelay);
			this.initName(opts.name);
		}

		initName(name) {
			if (name === undefined) {
				return;
			}

			// TODO fetch approximate total and eta based on `name`
		}

		getElapsedTime() {
			const elapsed = Date.now() - this.startTime - this.pausedElapsed;
			if (elapsed < 1_000) {
				// Sometimes there'll be a small delay between when the initial startTime was set and when the first elapsed is
				// displayed. If we're under a second then just pretend as if no time has elapsed to prevent displaying a janky time.
				return 0;
			} else {
				return elapsed;
			}
		}

		getBouncerPosition(stream) {
			const start = this.streamToBouncerStart.get(stream);
			if (start === undefined) {
				return 0;
			} else {
				return start;
			}
		}

		startBouncer() {
			const queueTick = () => {
				this.bouncerTimer = setTimeout(
					tick,
					___R$$priv$project$rome$$internal$cli$reporter$Progress_ts$BOUNCER_INTERVAL,
				);
			};

			const tick = this.reporter.wrapCallback(() => {
				if (this.paused) {
					queueTick();
					return;
				}

				const elapsedTime = this.getElapsedTime();
				const elapsedFrames = Math.round(
					elapsedTime /
					___R$$priv$project$rome$$internal$cli$reporter$Progress_ts$BOUNCER_INTERVAL,
				);

				for (const {stream} of this.reporter.getStreamHandles()) {
					if (
						!___R$project$rome$$internal$cli$reporter$stream_ts.isANSICursorStream(
							stream,
						) ||
						stream.features.columns === undefined
					) {
						continue;
					}

					// We remove the bouncer width from the total columns since we'll append it
					const width =
						___R$project$rome$$internal$ob1$index_ts$ob1Get1(
							stream.features.columns,
						) -
						___R$$priv$project$rome$$internal$cli$reporter$Progress_ts$BOUNCER_WIDTH;

					// Position to place the bouncer
					let position = elapsedFrames % width;

					// Every odd complete bounce should reverse direction
					const totalBounces = Math.floor(elapsedFrames / width);
					if (totalBounces % 2 === 1) {
						position = width - position;
					}

					this.streamToBouncerStart.set(stream, position);
				}

				queueTick();
				this.render();
			});

			queueTick();
		}

		setCurrent(current) {
			if (this.closed) {
				return;
			}

			super.setCurrent(current);

			if (this.isRenderDue()) {
				this.render();
			}
		}

		setTotal(total, approximate = false) {
			super.setTotal(total, approximate);
			this.renderEvery = Math.round(total / 100);
			this.endBouncer();
		}

		setText(text) {
			if (this.closed) {
				return;
			}

			super.setText(text);
		}

		queueRender(delay = this.delay) {
			if (this.closed) {
				// Progress bar has been removed
				return;
			}

			if (this.renderTimer !== undefined) {
				// Render already queued
				return;
			}

			this.renderTimer = setTimeout(
				this.reporter.wrapCallback(() => {
					this.render();
				}),
				delay,
			);
		}

		endBouncer() {
			if (this.bouncerTimer !== undefined) {
				clearTimeout(this.bouncerTimer);
			}
			this.bouncerTimer = undefined;
		}

		endRender() {
			if (this.renderTimer !== undefined) {
				clearTimeout(this.renderTimer);
			}
			this.renderTimer = undefined;
		}

		end() {
			this._render(true);
			this.closed = true;
			this.endBouncer();
			this.endRender();

			const {firstRenderLineSnapshot} = this;
			if (firstRenderLineSnapshot !== undefined) {
				this.reporter.removeLine(firstRenderLineSnapshot);
				firstRenderLineSnapshot.close();
			}

			if (this.onEnd !== undefined) {
				this.onEnd();
			}
		}

		// Ensure that we update the progress bar after a certain amount of ticks
		// This allows us to use the progress bar for sync work where the event loop is always blocked
		isRenderDue() {
			if (this.lastRenderTime === undefined) {
				return true;
			}

			const isDue = this.current > this.lastRenderCurrent + this.renderEvery;
			if (isDue) {
				// We also make sure that we never force update more often than once a second
				// This is to ensure that the progress bar isn't negatively effecting performance
				const timeSinceLastRender = Date.now() - this.lastRenderTime;
				return timeSinceLastRender > 1_000;
			} else {
				return false;
			}
		}

		isBoldCharacter(i, ranges) {
			for (const [start, end] of ranges) {
				if (start >= i && end <= i) {
					return true;
				}
			}

			return false;
		}

		splitCharacters(str, boldRanges) {
			return ___R$project$rome$$internal$string$utils$splitChars_ts$splitChars(
				str,
			).map((char, i) => {
				if (this.isBoldCharacter(i, boldRanges)) {
					return [
						i,
						___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.bold(char),
					];
				} else {
					return [i, char];
				}
			});
		}

		buildProgressBouncer(stream, bar) {
			let start = this.getBouncerPosition(stream);
			let fullBar = "";
			for (const [i, char] of bar) {
				const isBounce =
					i >= start &&
					i <
					start +
					___R$$priv$project$rome$$internal$cli$reporter$Progress_ts$BOUNCER_WIDTH;

				if (isBounce) {
					if (this.paused) {
						fullBar += ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.inverse(
							char,
						);
					} else {
						fullBar += ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.black(
							___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.bgYellow(
								char,
							),
						);
					}
				} else {
					fullBar += char;
				}
			}
			return fullBar;
		}

		buildProgressBar(stream, columns, bar, total) {
			const ratio = Math.min(Math.max(this.current / total, 0), 1);

			const completeLength = Math.round(
				___R$project$rome$$internal$ob1$index_ts$ob1Get1(columns) * ratio,
			);
			let fullBar = "";
			for (const [i, char] of bar) {
				if (i < completeLength) {
					if (this.paused) {
						fullBar += ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.inverse(
							char,
						);
					} else {
						fullBar += ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.black(
							___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsi.bgGreen(
								char,
							),
						);
					}
				} else {
					fullBar += char;
				}
			}
			return fullBar;
		}

		buildBarSuffix() {
			const {total, current} = this;

			// Text to put at the end of the bar
			let suffix = "";

			// Total time since the progress bar was created
			const elapsed = this.getElapsedTime();

			// Time elapsed eg: elapsed 1m5s
			if (this.opts.elapsed) {
				suffix +=
					"elapsed " +
					___R$project$rome$$internal$string$utils$humanizeTime_ts$humanizeTime(
						elapsed,
					) +
					" ";
			}

			// Don't bother with a suffix if we haven't completed a single item
			if (current > 0) {
				if (elapsed > 0) {
					// How many milliseconds spent per total items
					const averagePerItem = elapsed / current;

					// ETA eg: 1m5s
					if (this.opts.eta) {
						if (
							this.approximateETA !== undefined &&
							elapsed < this.approximateETA
						) {
							// Approximate ETA
							const left = elapsed - this.approximateETA;
							suffix +=
								"eta ~" +
								___R$project$rome$$internal$string$utils$humanizeTime_ts$humanizeTime(
									left,
								) +
								" ";
						} else if (total !== undefined) {
							// How many items we have left
							const itemsLeft = total - current;

							// Total estimated time left
							const eta = itemsLeft * averagePerItem;
							suffix +=
								"eta " +
								___R$project$rome$$internal$string$utils$humanizeTime_ts$humanizeTime(
									eta,
								) +
								" ";
						} else {
							const ops = Math.round(1_000 / averagePerItem);
							suffix +=
								___R$project$rome$$internal$string$utils$humanizeNumber_ts$humanizeNumber(
									ops,
								) + " op/s ";
						}
					}
				}

				// Counter eg: 5/100
				suffix += ___R$project$rome$$internal$string$utils$humanizeNumber_ts$humanizeNumber(
					current,
				);
				if (total !== undefined) {
					suffix += "/";
					if (this.approximateTotal) {
						suffix += "~";
					}
					suffix += ___R$project$rome$$internal$string$utils$humanizeNumber_ts$humanizeNumber(
						total,
					);
				}
			}

			return suffix;
		}

		buildBar(stream, suffix, columns) {
			const {total, title} = this;

			// Text ranges that we should make bold
			const boldRanges = [];

			// Text to prefix to the bar
			let prefix = "";
			if (title !== undefined) {
				prefix += title;

				// Only the title should be bold, not the subtext
				boldRanges.push([0, prefix.length - 1]);
			}

			const text = this.getText();
			if (text !== undefined) {
				// Separate a title and it's text with a colon
				if (title !== undefined) {
					prefix += ": ";
				}
				prefix += text;
			}

			// Get the full width of the bar. We take off 3 for padding.
			const width =
				___R$project$rome$$internal$ob1$index_ts$ob1Get1(columns) - 3;

			// The amount of spaces to put between the title and counter
			const spacerLength = Math.max(0, width - prefix.length - suffix.length);
			const spacer = " ".repeat(spacerLength);

			// Trim the prefix if it will overflow
			prefix = prefix.slice(0, width - spacerLength - suffix.length);

			// The full raw bar without any coloring
			const raw = " " + prefix + spacer + " " + suffix;

			// Make sure the counter is bold
			boldRanges.push([raw.length - suffix.length, raw.length - 1]);

			// Split the raw bar into an array of formatted characters
			const chars = this.splitCharacters(raw, boldRanges);

			if (total === undefined) {
				return this.buildProgressBouncer(stream, chars);
			} else {
				return this.buildProgressBar(stream, columns, chars, total);
			}
		}

		logNoCursor(handle, suffix) {
			let text = "";

			const {title} = this;
			if (title !== undefined) {
				text += title;
				text += ": ";
			}

			text += suffix;

			this.reporter.info(
				___R$project$rome$$internal$markup$escape_ts$markup`${text}`,
				{
					stderr: true,
					handles: [handle],
				},
			);
		}

		render() {
			this._render(false);
		}

		_render(force = false) {
			if (this.closed) {
				return;
			}

			this.endRender();

			const {lastNoCursorRenderTime} = this;
			const now = Date.now();

			// If the stream isn't an ansi cursor stream, then every 5 seconds we'll output a regular log with some progress
			// information
			const isNoCursorDue =
				force ||
				lastNoCursorRenderTime === undefined ||
				now - lastNoCursorRenderTime > 5_000;
			if (isNoCursorDue) {
				this.lastNoCursorRenderTime = now;
			}

			this.lastRenderCurrent = this.current;
			this.lastRenderTime = now;

			if (this.firstRenderLineSnapshot === undefined) {
				this.firstRenderLineSnapshot = this.reporter.getLineSnapshot(false);
			}

			if (!this.reporter.hasStreamHandles()) {
				return;
			}

			// We can build this up front for all streams since it doesn't rely on any stream information
			const suffix = this.buildBarSuffix();

			for (const handle of this.reporter.getStreamHandles()) {
				const {stream} = handle;
				if (!stream.features.progress) {
					continue;
				}

				if (
					___R$project$rome$$internal$cli$reporter$stream_ts.isANSICursorStream(
						stream,
					) &&
					stream.features.columns !== undefined
				) {
					___R$project$rome$$internal$cli$reporter$stream_ts.log(
						stream,
						this.buildBar(stream, suffix, stream.features.columns),
						{
							replaceLineSnapshot: this.firstRenderLineSnapshot,
							preferNoNewline: true,
							stderr: true,
						},
					);
				} else {
					if (isNoCursorDue) {
						this.logNoCursor(handle, suffix);
					}
				}
			}
		}
	}


  // project-rome/@internal/cli-reporter/util.ts
const ___R$$priv$project$rome$$internal$cli$reporter$util_ts$readline = require(
		"readline",
	);
	function ___R$project$rome$$internal$cli$reporter$util_ts$mergeProgresses(
		progresses,
	) {
		if (progresses.length === 1) {
			return progresses[0];
		}

		return {
			render: () => {
				for (const progress of progresses) {
					progress.render();
				}
			},
			setCurrent: (current) => {
				for (const progress of progresses) {
					progress.setCurrent(current);
				}
			},
			setTotal: (total, approximate) => {
				for (const progress of progresses) {
					progress.setTotal(total, approximate);
				}
			},
			setText: (text) => {
				for (const progress of progresses) {
					progress.setText(text);
				}
			},
			pushText: (text) => {
				let id = "";
				for (const progress of progresses) {
					progress.pushText(text, id);
				}
				return id;
			},
			popText: (id) => {
				for (const progress of progresses) {
					progress.popText(id);
				}
			},
			setApproximateETA: (duration) => {
				for (const progress of progresses) {
					progress.setApproximateETA(duration);
				}
			},
			tick: () => {
				for (const progress of progresses) {
					progress.tick();
				}
			},
			end: () => {
				for (const progress of progresses) {
					progress.end();
				}
			},
			pause: () => {
				for (const progress of progresses) {
					progress.pause();
				}
			},
			resume: () => {
				for (const progress of progresses) {
					progress.resume();
				}
			},
		};
	}

	function ___R$project$rome$$internal$cli$reporter$util_ts$onKeypress(
		reporter,
		callback,
	) {
		const stdin = reporter.getStdin();

		___R$project$rome$$internal$cli$reporter$util_ts$setRawMode(stdin, true);
		___R$$priv$project$rome$$internal$cli$reporter$util_ts$readline.emitKeypressEvents(
			stdin,
		);

		function onkeypress(chunk, key) {
			switch (key.name) {
				case "c": {
					if (key.ctrl) {
						reporter.br({force: true});
						reporter.warn(
							___R$project$rome$$internal$markup$escape_ts$markup`Cancelled by user`,
						);
						process.exit(1);
					}
					return;
				}

				case "escape": {
					reporter.br({force: true});
					reporter.warn(
						___R$project$rome$$internal$markup$escape_ts$markup`Cancelled by user`,
					);
					process.exit(1);
					return;
				}
			}

			callback(key);
		}

		stdin.addListener("keypress", onkeypress);

		return {
			finish() {
				stdin.removeListener("keypress", onkeypress);
				___R$project$rome$$internal$cli$reporter$util_ts$setRawMode(
					stdin,
					false,
				);
			},
		};
	}

	function ___R$project$rome$$internal$cli$reporter$util_ts$setRawMode(
		stdin,
		raw,
	) {
		if (stdin.isTTY && stdin.setRawMode !== undefined) {
			stdin.setRawMode(raw);
		}

		if (raw) {
			stdin.resume();
		} else {
			stdin.pause();
		}
	}


  // project-rome/@internal/cli-reporter/select.ts
function ___R$$priv$project$rome$$internal$cli$reporter$select_ts$formatShortcut(
		{shortcut},
	) {
		if (shortcut === undefined) {
			return ___R$project$rome$$internal$markup$escape_ts$markup``;
		} else {
			return ___R$project$rome$$internal$markup$escape_ts$markup` <dim>(shortcut ${shortcut})</dim>`;
		}
	}

	async function ___R$project$rome$$internal$cli$reporter$select_ts$default(
		reporter,
		message,
		{
			options,
			defaults = [],
			radio = false,
			yes = false,
		},
	) {
		const optionNames = [];
		const seenShortcuts = new Set();

		// Verify there's no shortcut collisions and remove empty options
		for (const key in options) {
			const option = options[key];

			if (option !== undefined) {
				optionNames.push(key);

				const {shortcut} = option;
				if (shortcut !== undefined) {
					if (seenShortcuts.has(shortcut)) {
						throw new Error("Multiple options have the shortcut " + shortcut);
					} else {
						seenShortcuts.add(shortcut);
					}
				}
			}
		}

		let optionCount = optionNames.length;
		if (optionCount === 0) {
			return new Set();
		}

		if (yes) {
			return new Set(defaults);
		}

		let prompt = ___R$project$rome$$internal$markup$escape_ts$markup`<dim>❯</dim> <emphasis>${message}</emphasis>`;
		reporter.log(prompt);

		if (radio) {
			reporter.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Use arrow keys and then <emphasis>enter</emphasis> to select an option`,
			);
		} else {
			reporter.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Use arrow keys and <emphasis>space</emphasis> to select or deselect options and then <emphasis>enter</emphasis> to confirm`,
			);
		}

		const selectedOptions = new Set(defaults);
		let activeOption = 0;

		// Set first option if this is a radio
		if (radio && !defaults.length) {
			selectedOptions.add(optionNames[0]);
		}

		function boundActive() {
			activeOption = Math.min(activeOption, optionCount - 1);
			activeOption = Math.max(activeOption, 0);

			if (radio) {
				selectedOptions.clear();
				selectedOptions.add(optionNames[activeOption]);
			}
		}

		// If we aren't a radio then set the active option to the bottom of any that are enabled
		if (!radio) {
			while (selectedOptions.has(optionNames[activeOption])) {
				activeOption++;
			}
		}

		function render() {
			const optionNames = (Object.keys(options));
			for (let i = 0; i < optionNames.length; i++) {
				const key = optionNames[i];
				const option = options[key];
				const {label} = option;
				const shortcut = ___R$$priv$project$rome$$internal$cli$reporter$select_ts$formatShortcut(
					option,
				);

				let formattedLabel =
					optionNames.indexOf(key) === activeOption
						? ___R$project$rome$$internal$markup$escape_ts$markup`<underline>${label}</underline>`
						: label;

				let symbol = "";
				if (radio) {
					symbol = selectedOptions.has(key) ? "\u25c9" : "\u25ef";
				} else {
					symbol = selectedOptions.has(key) ? "\u2611" : "\u2610";
				}

				reporter.log(
					___R$project$rome$$internal$markup$escape_ts$markup`  ${symbol} ${formattedLabel}${shortcut}`,
					{
						// Don't put a newline on the last option
						noNewline: i === optionNames.length - 1,
					},
				);
			}
		}
		function cleanup() {
			for (let i = 0; i < optionCount; i++) {
				reporter.write(
					___R$project$rome$$internal$cli$layout$ansi_ts$ansiEscapes.eraseLine,
				);

				// Don't move above the top line
				if (i !== optionCount - 1) {
					reporter.write(
						___R$project$rome$$internal$cli$layout$ansi_ts$ansiEscapes.cursorUp(),
					);
				}
			}
			reporter.write(
				___R$project$rome$$internal$cli$layout$ansi_ts$ansiEscapes.cursorTo(0),
			);
		}
		function toggleOption(optionName) {
			if (selectedOptions.has(optionName)) {
				selectedOptions.delete(optionName);
			} else {
				selectedOptions.add(optionName);
			}
		}

		const stdin = reporter.getStdin();

		render();

		___R$project$rome$$internal$cli$reporter$util_ts$setRawMode(stdin, true);

		await new Promise((resolve) => {
			const keypress = ___R$project$rome$$internal$cli$reporter$util_ts$onKeypress(
				reporter,
				(key) => {
					// Check if this is an option shortcut
					if (!key.ctrl) {
						for (const optionName in options) {
							const option = options[optionName];
							if (option === undefined) {
								continue;
							}

							const {shortcut} = option;
							if (shortcut === key.name) {
								if (radio) {
									selectedOptions.clear();
									selectedOptions.add(optionName);
									finish();
								} else {
									toggleOption(optionName);
								}
								return;
							}
						}
					}

					switch (key.name) {
						case "up": {
							activeOption--;
							break;
						}

						case "down": {
							activeOption++;
							break;
						}

						case "space": {
							if (!radio) {
								toggleOption(optionNames[activeOption]);
							}
							break;
						}

						case "return": {
							finish();
							return;
						}

						default:
							return;
					}

					boundActive();
					cleanup();
					render();
				},
			);

			function finish() {
				cleanup();

				// Remove initial help message
				reporter.write(
					___R$project$rome$$internal$cli$layout$ansi_ts$ansiEscapes.cursorUp(),
				);
				reporter.write(
					___R$project$rome$$internal$cli$layout$ansi_ts$ansiEscapes.eraseLine,
				);

				// Remove initial log message
				reporter.write(
					___R$project$rome$$internal$cli$layout$ansi_ts$ansiEscapes.cursorUp(),
				);
				reporter.write(
					___R$project$rome$$internal$cli$layout$ansi_ts$ansiEscapes.eraseLine,
				);

				prompt = ___R$project$rome$$internal$markup$escape_ts$markup`${prompt}: `;
				if (selectedOptions.size > 0) {
					prompt = ___R$project$rome$$internal$markup$escape_ts$markup`${prompt}${___R$project$rome$$internal$markup$escape_ts$concatMarkup(
						Array.from(selectedOptions, (key) => options[key].label),
						___R$project$rome$$internal$markup$escape_ts$markup`, `,
					)}`;
				} else {
					prompt = ___R$project$rome$$internal$markup$escape_ts$markup`${prompt}<dim>none</dim>`;
				}
				reporter.log(prompt);

				// Stop listening for keypress
				keypress.finish();
				resolve();
			}
		});

		return selectedOptions;
	}


  // project-rome/@internal/cli-reporter/Reporter.ts
const ___R$$priv$project$rome$$internal$cli$reporter$Reporter_ts$stream = require(
		"stream",
	);
	const ___R$$priv$project$rome$$internal$cli$reporter$Reporter_ts$readline = require(
		"readline",
	);
	class ___R$project$rome$$internal$cli$reporter$Reporter_ts$default {
		constructor(opts = {}) {
			this.wrapCallback = (callback) => {
				const {wrapperFactory} = this;
				if (wrapperFactory === undefined) {
					return callback;
				} else {
					return wrapperFactory(callback);
				}
			};
			this.activeElements = new Set();
			this.indentLevel = 0;
			this.markupOptions =
				opts.markupOptions === undefined ? {} : opts.markupOptions;
			this.shouldRedirectOutToErr = false;
			this.stdin = opts.stdin;
			this.wrapperFactory = opts.wrapperFactory;
			this.streamHandles = new Set();

			if (opts.streams !== undefined) {
				for (const stream of opts.streams) {
					this.addStream(stream);
				}
			}
		}

		static fromProcess(opts = {}) {
			const reporter = new ___R$project$rome$$internal$cli$reporter$Reporter_ts$default(
				Object.assign(
					{},
					opts,
					{
						markupOptions: Object.assign(
							{cwd: ___R$project$rome$$internal$path$index_ts$CWD_PATH},
							opts.markupOptions,
						),
					},
				),
			);

			reporter.attachStdoutStreams(process.stdout, process.stderr);

			return reporter;
		}

		// Produce a new Reporter with all the streams of the input reporters. Streams will NOT be in sync.
		static concat(reporters) {
			const reporter = new ___R$project$rome$$internal$cli$reporter$Reporter_ts$default();
			for (const otherReporter of reporters) {
				for (const {stream} of otherReporter.getStreamHandles()) {
					reporter.addAttachedStream(stream);
				}
			}
			return reporter;
		}

		getLineSnapshot(populate = true) {
			const snapshot = {
				close: () => {
					for (const {stream} of this.getStreamHandles()) {
						stream.state.lineSnapshots.delete(snapshot);
					}
				},
			};

			if (populate) {
				for (const {stream} of this.getStreamHandles()) {
					stream.state.lineSnapshots.set(snapshot, stream.state.currentLine);
				}
			}

			return snapshot;
		}

		attachStdoutStreams(stdout, stderr, force = {}) {
			const {features, updateEvent, setupUpdateEvent, closeUpdateEvent} = ___R$project$rome$$internal$cli$environment$index_ts$inferTerminalFeatures(
				stdout,
				force,
			);

			const {format = features.colorDepth > 1 ? "ansi" : "none"} = force;

			setupUpdateEvent();

			const handle = this.addStream({
				format,
				features,
				write: (chunk, error) => {
					if (error) {
						if (stderr !== undefined) {
							// @ts-ignore
							stderr.write(chunk);
						}
					} else {
						if (stdout !== undefined) {
							// @ts-ignore
							stdout.write(chunk);
						}
					}
				},
				init: setupUpdateEvent,
				teardown: closeUpdateEvent,
			});

			updateEvent.subscribe((features) => {
				handle.stream.updateFeatures(features);
			});

			return {
				format,
				features,
				featuresUpdated: updateEvent,
				handle,
			};
		}

		attachConditionalStream(stream, check) {
			let handle;

			const cond = {
				update: () => {
					if (check()) {
						if (handle === undefined) {
							handle = this.addStream(stream);
						}
						return true;
					} else {
						if (handle !== undefined) {
							handle.remove();
							handle = undefined;
						}
						return false;
					}
				},
			};

			cond.update();

			return cond;
		}

		attachCaptureStream(format = "none", features = {}) {
			let buff = "";

			const stream = this.addStream({
				format,
				features: Object.assign(
					{},
					___R$project$rome$$internal$cli$environment$index_ts$DEFAULT_TERMINAL_FEATURES,
					features,
				),
				write(chunk) {
					buff += chunk;
				},
			});

			return {
				read() {
					return buff;
				},
				readAsMarkup() {
					return format === "markup"
						? ___R$project$rome$$internal$markup$escape_ts$convertToMarkupFromRandomString(
								buff,
							)
						: ___R$project$rome$$internal$markup$escape_ts$markup`${buff}`;
				},
				remove: stream.remove,
			};
		}

		getMessagePrefix() {
			return ___R$project$rome$$internal$markup$escape_ts$markup``;
		}

		redirectOutToErr(should) {
			const old = this.shouldRedirectOutToErr;
			this.shouldRedirectOutToErr = should;
			return old;
		}

		refreshActiveElements() {
			for (const elem of this.activeElements) {
				elem.render();
			}
		}

		addAttachedStream(stream) {
			const handle = {
				stream,
				remove: () => {
					if (!this.streamHandles.has(handle)) {
						return;
					}

					this.streamHandles.delete(handle);
					stream.handles.delete(handle);

					// Only teardown when all handles have been removed
					if (stream.teardown !== undefined && stream.handles.size === 0) {
						stream.teardown();
					}
				},
			};
			stream.handles.add(handle);
			this.streamHandles.add(handle);
			return handle;
		}

		addStream(unattached, state) {
			if (unattached.init !== undefined) {
				unattached.init();
			}

			const stream = Object.assign(
				{},
				unattached,
				{
					handles: new Set(),
					state: ___R$project$rome$$internal$typescript$helpers$index_ts$mergeObjects(
						___R$project$rome$$internal$cli$reporter$stream_ts.createStreamState(),
						state,
					),
					updateFeatures: (newFeatures) => {
						stream.features = newFeatures;
						this.refreshActiveElements();
					},
				},
			);
			return this.addAttachedStream(stream);
		}

		getStdin() {
			const {stdin} = this;
			if (stdin === undefined) {
				throw new Error("This operation expected a stdin but we have none");
			}
			return stdin;
		}

		async question(message, {hint, default: def = "", yes = false} = {}) {
			if (yes) {
				return def;
			}

			const stdin = this.getStdin();

			const origPrompt = ___R$project$rome$$internal$markup$escape_ts$markup`<dim emphasis>?</dim> <emphasis>${message}</emphasis>`;
			let prompt = origPrompt;
			if (hint !== undefined) {
				prompt = ___R$project$rome$$internal$markup$escape_ts$markup`${prompt} <dim>${hint}</dim>`;
			}
			if (def !== "") {
				prompt = ___R$project$rome$$internal$markup$escape_ts$markup`${prompt} (${def})`;
			}
			prompt = ___R$project$rome$$internal$markup$escape_ts$markup`${prompt}: `;
			this.log(
				prompt,
				{
					noNewline: true,
				},
			);

			const rl = ___R$$priv$project$rome$$internal$cli$reporter$Reporter_ts$readline.createInterface({
				input: stdin,
				output: new ___R$$priv$project$rome$$internal$cli$reporter$Reporter_ts$stream.Writable({
					write: (chunk, encoding, callback) => {
						this.write(chunk);
						callback();
					},
				}),
				terminal: false,
			});

			return new Promise((resolve) => {
				rl.on(
					"line",
					(line) => {
						rl.close();

						const normalized = line === "" ? def : line;

						// Replace initial prompt
						this.write(
							___R$project$rome$$internal$cli$layout$ansi_ts$ansiEscapes.cursorUp(),
						);
						this.write(
							___R$project$rome$$internal$cli$layout$ansi_ts$ansiEscapes.eraseLine,
						);

						let prompt = origPrompt;
						prompt = ___R$project$rome$$internal$markup$escape_ts$markup`${prompt}: `;
						if (normalized === "") {
							prompt = ___R$project$rome$$internal$markup$escape_ts$markup`${prompt}<dim>empty</dim>`;
						} else {
							prompt = ___R$project$rome$$internal$markup$escape_ts$markup`${prompt}${normalized}`;
						}
						this.log(prompt);

						resolve(normalized);
					},
				);
			});
		}

		async questionValidate(message, validate, options = {}) {
			while (true) {
				let res;

				await this.question(
					message,
					Object.assign(
						{},
						options,
						{
							normalize: (value) => {
								res = validate(value);

								if (res[0] === true && typeof res[1] === "string") {
									return res[1];
								} else {
									return value;
								}
							},
						},
					),
				);

				if (res === undefined) {
					throw new Error("normalize should have been called");
				}

				if (res[0] === false) {
					this.error(res[1]);
				} else {
					return res[1];
				}
			}
		}

		async radioConfirm(message) {
			const answer = await this.radio(
				message,
				{
					options: {
						yes: {
							label: ___R$project$rome$$internal$markup$escape_ts$markup`Yes`,
							shortcut: "y",
						},
						no: {
							label: ___R$project$rome$$internal$markup$escape_ts$markup`No`,
							shortcut: "n",
						},
					},
				},
			);
			return answer === "yes";
		}

		async confirm(message = "Press any key to continue") {
			this.log(
				___R$project$rome$$internal$markup$escape_ts$markup`<dim>${message}</dim>`,
				{noNewline: true},
			);

			await new Promise((resolve) => {
				const keypress = ___R$project$rome$$internal$cli$reporter$util_ts$onKeypress(
					this,
					() => {
						keypress.finish();
						resolve();
					},
				);
			});

			// Newline
			this.log(___R$project$rome$$internal$markup$escape_ts$markup``);
		}

		async radio(message, arg) {
			const set = await this.select(
				message,
				Object.assign({}, arg, {radio: true}),
			);

			// Should always have at least one element
			return Array.from(set)[0];
		}

		async select(message, args) {
			return ___R$project$rome$$internal$cli$reporter$select_ts$default(
				this,
				message,
				args,
			);
		}

		hasStreamHandles(opts) {
			if (opts !== undefined && opts.handles !== undefined) {
				return opts.handles.length > 0;
			}

			return this.streamHandles.size > 0;
		}

		getStreamHandles(opts) {
			if (opts !== undefined && opts.handles !== undefined) {
				return opts.handles;
			}

			return this.streamHandles;
		}

		teardown() {
			for (const handle of this.streamHandles) {
				handle.remove();
			}

			for (const elem of this.activeElements) {
				elem.end();
			}
			this.activeElements.clear();
		}

		fork(opts = {}) {
			return new ___R$project$rome$$internal$cli$reporter$Reporter_ts$default(
				Object.assign(
					{
						streams: [
							...Array.from(this.streamHandles, (handle) => handle.stream),
						],
						markupOptions: this.markupOptions,
						wrapperFactory: this.wrapperFactory,
					},
					opts,
				),
			);
		}

		table(head, rawBody) {
			let body = [];

			if (head.length > 0) {
				body.push(___R$project$rome$$internal$markup$escape_ts$markup`<tr>`);
				for (const field of head) {
					body.push(
						___R$project$rome$$internal$markup$escape_ts$markup`<td><emphasis>${field}</emphasis></td>`,
					);
				}
				body.push(___R$project$rome$$internal$markup$escape_ts$markup`</tr>`);
			}

			for (const row of rawBody) {
				body.push(___R$project$rome$$internal$markup$escape_ts$markup`<tr>`);
				for (let field of row) {
					body.push(
						___R$project$rome$$internal$markup$escape_ts$markup`<td>${field}</td>`,
					);
				}
				body.push(___R$project$rome$$internal$markup$escape_ts$markup`</tr>`);
			}

			this.log(
				___R$project$rome$$internal$markup$escape_ts$markup`<table>${___R$project$rome$$internal$markup$escape_ts$concatMarkup(
					body,
				)}</table>`,
			);
		}

		inspect(value, opts) {
			if (!this.hasStreamHandles(opts)) {
				return;
			}

			let formatted;
			if (typeof value !== "number" && typeof value !== "string") {
				formatted = ___R$project$rome$$internal$markup$escape_ts$markup`${___R$project$rome$$internal$pretty$format$index_ts$default(
					value,
				)}`;
			} else {
				formatted = ___R$project$rome$$internal$markup$escape_ts$markup`${String(
					value,
				)}`;
			}

			for (const {stream} of this.getStreamHandles(opts)) {
				this._logMarkup(stream, formatted, opts);
			}
		}

		write(msg, stderr = false) {
			for (const {stream} of this.getStreamHandles()) {
				stream.write(msg, stderr || this.shouldRedirectOutToErr);
			}
		}

		clearScreen(opts) {
			for (const {stream} of this.getStreamHandles(opts)) {
				___R$project$rome$$internal$cli$reporter$stream_ts.clearScreen(stream);
			}
		}

		heading(text) {
			this.br();
			this.log(
				___R$project$rome$$internal$markup$escape_ts$markup`<inverse><emphasis> ${text} </emphasis></inverse>`,
			);
			this.br();
		}

		async indent(callback) {
			this.indentLevel++;

			try {
				await callback();
			} finally {
				this.indentLevel--;
			}
		}

		indentSync(callback) {
			this.indentLevel++;

			try {
				callback();
			} finally {
				this.indentLevel--;
			}
		}

		async section(title, callback, opts) {
			this.hr(
				title === undefined
					? undefined
					: ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${title}</emphasis>`,
				opts,
			);
			await this.indent(callback);
			this.br(opts);
		}

		hr(text = ___R$project$rome$$internal$markup$escape_ts$markup``, opts) {
			for (const {stream} of this.getStreamHandles(opts)) {
				this.br();
				this._logMarkup(
					stream,
					___R$project$rome$$internal$markup$escape_ts$markup`<hr>${text}</hr>`,
				);
				this._logMarkup(
					stream,
					___R$project$rome$$internal$markup$escape_ts$markup``,
				);
			}
		}

		removeLine(snapshot, opts) {
			for (const {stream} of this.getStreamHandles(opts)) {
				___R$project$rome$$internal$cli$reporter$stream_ts.removeLine(
					stream,
					snapshot,
					opts !== undefined && opts.stderr,
				);
			}
		}

		async steps(callbacks, clear = true) {
			let total = 0;
			let current = 1;

			const filteredCallbacks = [];
			for (const item of callbacks) {
				if (item.test === undefined || (await item.test())) {
					filteredCallbacks.push(item);
					total++;
				}
			}

			for (const {message, callback} of filteredCallbacks) {
				const lineSnapshot = this.getLineSnapshot();

				try {
					this.step(current, total, message);

					await callback();

					if (clear) {
						this.removeLine(lineSnapshot);
					}
				} finally {
					lineSnapshot.close();
				}
			}
		}

		step(current, total, msg, opts) {
			this.log(
				___R$project$rome$$internal$markup$escape_ts$markup`<dim>[${String(
					current,
				)}/${String(total)}]</dim> ${msg}`,
				opts,
			);
		}

		br(opts) {
			const force = opts !== undefined && opts.force;
			for (const {stream} of this.getStreamHandles(opts)) {
				if (
					___R$project$rome$$internal$cli$reporter$stream_ts.getLeadingNewlineCount(
						stream,
					) < 2 ||
					force
				) {
					this._logMarkup(
						stream,
						___R$project$rome$$internal$markup$escape_ts$markup``,
						opts,
					);
				}
			}
		}

		stripMarkup(str) {
			return ___R$project$rome$$internal$cli$layout$format_ts$markupToJoinedPlainText(
				str,
				this.markupOptions,
			);
		}

		format(stream, str) {
			if (___R$project$rome$$internal$markup$escape_ts$isEmptyMarkup(str)) {
				return [""];
			}

			const prefix = this.getMessagePrefix();
			let built = ___R$project$rome$$internal$markup$escape_ts$isEmptyMarkup(
				prefix,
			)
				? str
				: ___R$project$rome$$internal$markup$escape_ts$markup`${prefix}<view>${str}</view>`;

			const shouldIndent = this.indentLevel > 0;

			if (shouldIndent) {
				for (let i = 0; i < this.indentLevel; i++) {
					built = ___R$project$rome$$internal$markup$escape_ts$markup`<indent>${built}</indent>`;
				}
			}

			const gridMarkupOptions = Object.assign(
				{},
				this.markupOptions,
				{
					columns: stream.features.columns,
					features: stream.features,
					// Printing to a terminal or something so convert tabs to spaces
					convertTabs: true,
				},
			);

			switch (stream.format) {
				case "ansi":
					return ___R$project$rome$$internal$cli$layout$format_ts$markupToAnsi(
						built,
						gridMarkupOptions,
					).lines;

				case "html":
					return ___R$project$rome$$internal$cli$layout$format_ts$markupToHtml(
						built,
						gridMarkupOptions,
					).lines;

				case "none":
					return ___R$project$rome$$internal$cli$layout$format_ts$markupToPlainText(
						built,
						gridMarkupOptions,
					).lines;

				case "markup":
					return [
						___R$project$rome$$internal$markup$escape_ts$readMarkup(
							___R$project$rome$$internal$markup$normalize_ts$normalizeMarkup(
								built,
								this.markupOptions,
							).text,
						),
					];
			}
		}

		log(msg, opts = {}) {
			for (const {stream} of this.getStreamHandles(opts)) {
				this._logMarkup(stream, msg, opts);
			}
		}

		logRaw(msg, opts = {}) {
			opts = Object.assign(
				{},
				opts,
				{stderr: opts.stderr || this.shouldRedirectOutToErr},
			);

			for (const {stream} of this.getStreamHandles(opts)) {
				___R$project$rome$$internal$cli$reporter$stream_ts.log(
					stream,
					msg,
					opts,
				);
			}
		}

		_logMarkup(stream, msg, opts = {}) {
			const lines = this.format(stream, msg);
			for (let i = 0; i < lines.length; i++) {
				___R$project$rome$$internal$cli$reporter$stream_ts.log(
					stream,
					lines[i],
					Object.assign(
						{},
						opts,
						{
							stderr: opts.stderr || this.shouldRedirectOutToErr,
							noNewline: i === lines.length - 1 ? opts.noNewline : false,
						},
					),
					i,
				);
			}
		}

		logCategory(rawInner, opts) {
			if (!this.hasStreamHandles(opts)) {
				return;
			}

			let inner = ___R$project$rome$$internal$markup$escape_ts$markupTag(
				opts.markupTag,
				rawInner,
			);

			for (const {stream} of this.getStreamHandles(opts)) {
				const prefixInner = stream.features.unicode
					? ___R$project$rome$$internal$markup$escape_ts$markup`${opts.unicodePrefix}`
					: ___R$project$rome$$internal$markup$escape_ts$markup`${opts.rawPrefix}`;
				const prefix = ___R$project$rome$$internal$markup$escape_ts$markupTag(
					"emphasis",
					___R$project$rome$$internal$markup$escape_ts$markupTag(
						opts.markupTag,
						prefixInner,
					),
				);
				const prefixedInner = ___R$project$rome$$internal$markup$escape_ts$markup`${prefix}<view>${inner}</view>`;
				this._logMarkup(
					stream,
					prefixedInner,
					{
						stderr: opts.stderr,
					},
				);
			}
		}

		success(msg, opts) {
			this.logCategory(
				msg,
				___R$project$rome$$internal$typescript$helpers$index_ts$mergeObjects(
					{
						unicodePrefix: "\u2714 ",
						rawPrefix: "\u221a ",
						markupTag: "success",
					},
					opts,
				),
			);
		}

		error(msg, opts) {
			this.logCategory(
				msg,
				___R$project$rome$$internal$typescript$helpers$index_ts$mergeObjects(
					{
						markupTag: "error",
						unicodePrefix: "\u2716 ",
						rawPrefix: "\xd7 ",
						stderr: true,
					},
					opts,
				),
			);
		}

		info(msg, opts) {
			this.logCategory(
				msg,
				___R$project$rome$$internal$typescript$helpers$index_ts$mergeObjects(
					{
						unicodePrefix: "\u2139 ",
						rawPrefix: "i ",
						markupTag: "info",
					},
					opts,
				),
			);
		}

		warn(msg, opts) {
			this.logCategory(
				msg,
				___R$project$rome$$internal$typescript$helpers$index_ts$mergeObjects(
					{
						unicodePrefix: "\u26a0 ",
						rawPrefix: "! ",
						markupTag: "warn",
						stderr: true,
					},
					opts,
				),
			);
		}

		command(command, prefix = true) {
			let highlighted = ___R$project$rome$$internal$markup$escape_ts$concatMarkup(
				___R$project$rome$$internal$markup$syntax$highlight$highlightShell_ts$default({
					input: command,
				}),
				___R$project$rome$$internal$markup$escape_ts$markup`\n`,
			);

			if (prefix) {
				highlighted = ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>$</emphasis> <view>${highlighted}</view>`;
			}

			this.log(highlighted);
		}

		namespace(prefix) {
			return {
				success: (suffix) =>
					this.success(
						___R$project$rome$$internal$markup$escape_ts$markup`${prefix} ${suffix}`,
					)
				,
				info: (suffix) =>
					this.info(
						___R$project$rome$$internal$markup$escape_ts$markup`${prefix} ${suffix}`,
					)
				,
				error: (suffix) =>
					this.error(
						___R$project$rome$$internal$markup$escape_ts$markup`${prefix} ${suffix}`,
					)
				,
				warn: (suffix) =>
					this.warn(
						___R$project$rome$$internal$markup$escape_ts$markup`${prefix} ${suffix}`,
					)
				,
				log: (suffix) =>
					this.log(
						___R$project$rome$$internal$markup$escape_ts$markup`${prefix} ${suffix}`,
					)
				,
				list: (items, opts = {}) => {
					const suffix =
						opts.prefix == null
							? ___R$project$rome$$internal$markup$escape_ts$markup``
							: opts.prefix;
					this.list(
						items,
						Object.assign(
							{},
							opts,
							{
								prefix: ___R$project$rome$$internal$markup$escape_ts$markup`${prefix} ${suffix}`,
							},
						),
					);
				},
			};
		}

		processedList(items, callback, opts = {}) {
			if (items.length === 0) {
				// We make some assumptions that there's at least one item
				return {truncated: false};
			}

			let truncatedCount = 0;

			let start = opts.start || 0;
			if (opts.truncate !== undefined && items.length > opts.truncate) {
				truncatedCount = items.length - opts.truncate;
				items = items.slice(0, opts.truncate);
				start += truncatedCount;
			}

			let buff = ___R$project$rome$$internal$markup$escape_ts$markup``;

			for (let i = 0; i < items.length; i++) {
				const item = items[i];
				const reporter = this.fork({
					streams: [],
				});
				const stream = reporter.attachCaptureStream("markup");
				const str = callback(reporter, item);
				stream.remove();

				let inner =
					str === undefined
						? ___R$project$rome$$internal$markup$escape_ts$convertToMarkupFromRandomString(
								stream.read().trimRight(),
							)
						: str;
				if (opts.pad && i !== items.length - 1) {
					inner = ___R$project$rome$$internal$markup$escape_ts$markup`${inner}\n`;
				}
				buff = ___R$project$rome$$internal$markup$escape_ts$markup`${buff}<li>${inner}</li>`;
			}

			if (opts.ordered) {
				buff = ___R$project$rome$$internal$markup$escape_ts$markupTag(
					"ol",
					buff,
					{start, reversed: opts.reverse},
				);
			} else {
				buff = ___R$project$rome$$internal$markup$escape_ts$markup`<ul>${buff}</ul>`;
			}

			if (truncatedCount > 0) {
				buff = ___R$project$rome$$internal$markup$escape_ts$markup`${buff}<dim>and ${truncatedCount} others...</dim>`;
			}

			if (opts.prefix !== undefined) {
				buff = ___R$project$rome$$internal$markup$escape_ts$markup`${opts.prefix}${buff}`;
			}

			this.log(buff);

			return {truncated: truncatedCount > 0};
		}

		list(items, opts = {}) {
			return this.processedList(
				items,
				(reporter, str) => {
					return str;
				},
				opts,
			);
		}

		progress(opts, onEnd) {
			const bar = new ___R$project$rome$$internal$cli$reporter$Progress_ts$default(
				this,
				opts,
				() => {
					this.activeElements.delete(bar);
					if (onEnd !== undefined) {
						onEnd();
					}
				},
			);
			this.activeElements.add(bar);
			return bar;
		}
	}


  // project-rome/@internal/cli-reporter/types.ts
const ___R$project$rome$$internal$cli$reporter$types_ts = {};


  // project-rome/@internal/cli-reporter/index.ts



  // project-rome/@internal/cli-diagnostics/constants.ts
const ___R$project$rome$$internal$cli$diagnostics$constants_ts = {
		get GUTTER() {
			return ___R$project$rome$$internal$cli$diagnostics$constants_ts$GUTTER;
		},
		get CODE_FRAME_INDENT() {
			return ___R$project$rome$$internal$cli$diagnostics$constants_ts$CODE_FRAME_INDENT;
		},
		get CODE_FRAME_SELECTED_INDENT() {
			return ___R$project$rome$$internal$cli$diagnostics$constants_ts$CODE_FRAME_SELECTED_INDENT;
		},
		get MAX_CODE_FRAME_LINES() {
			return ___R$project$rome$$internal$cli$diagnostics$constants_ts$MAX_CODE_FRAME_LINES;
		},
		get HALF_MAX_CODE_FRAME_LINES() {
			return ___R$project$rome$$internal$cli$diagnostics$constants_ts$HALF_MAX_CODE_FRAME_LINES;
		},
		get CODE_FRAME_CONTEXT_LINES() {
			return ___R$project$rome$$internal$cli$diagnostics$constants_ts$CODE_FRAME_CONTEXT_LINES;
		},
		get MAX_CODE_LENGTH() {
			return ___R$project$rome$$internal$cli$diagnostics$constants_ts$MAX_CODE_LENGTH;
		},
		get MAX_CODE_LINES() {
			return ___R$project$rome$$internal$cli$diagnostics$constants_ts$MAX_CODE_LINES;
		},
		get MAX_PATCH_LINES() {
			return ___R$project$rome$$internal$cli$diagnostics$constants_ts$MAX_PATCH_LINES;
		},
		get MAX_LOG_LENGTH() {
			return ___R$project$rome$$internal$cli$diagnostics$constants_ts$MAX_LOG_LENGTH;
		},
	};
	const ___R$project$rome$$internal$cli$diagnostics$constants_ts$GUTTER = ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis> \u2502 </emphasis>`;

	const ___R$project$rome$$internal$cli$diagnostics$constants_ts$CODE_FRAME_INDENT = "  ";
	const ___R$project$rome$$internal$cli$diagnostics$constants_ts$CODE_FRAME_SELECTED_INDENT = ___R$project$rome$$internal$markup$escape_ts$markup`<error>></error> `;

	const ___R$project$rome$$internal$cli$diagnostics$constants_ts$MAX_CODE_FRAME_LINES = 8;
	const ___R$project$rome$$internal$cli$diagnostics$constants_ts$HALF_MAX_CODE_FRAME_LINES =
		___R$project$rome$$internal$cli$diagnostics$constants_ts$MAX_CODE_FRAME_LINES /
		2;
	const ___R$project$rome$$internal$cli$diagnostics$constants_ts$CODE_FRAME_CONTEXT_LINES = 2;

	const ___R$project$rome$$internal$cli$diagnostics$constants_ts$MAX_CODE_LENGTH = 5_000;
	const ___R$project$rome$$internal$cli$diagnostics$constants_ts$MAX_CODE_LINES = 150;
	const ___R$project$rome$$internal$cli$diagnostics$constants_ts$MAX_PATCH_LINES = 150;
	const ___R$project$rome$$internal$cli$diagnostics$constants_ts$MAX_LOG_LENGTH = 5_000;


  // project-rome/@internal/cli-diagnostics/buildPatchCodeFrame.ts
function ___R$$priv$project$rome$$internal$cli$diagnostics$buildPatchCodeFrame_ts$formatDiffLine(
		diffs,
	) {
		let atLineStart = true;

		return ___R$project$rome$$internal$markup$escape_ts$concatMarkup(
			diffs.map(([type, text], i) => {
				const escapedText = ___R$project$rome$$internal$markup$escape_ts$markup`${text}`;

				const {hadNonWhitespace, value} = ___R$project$rome$$internal$cli$diagnostics$utils_ts$showInvisibles(
					___R$project$rome$$internal$markup$escape_ts$readMarkup(escapedText),
					{
						ignoreLeadingTabs: false,
						ignoreLoneSpaces: false,
						atLineStart,
						atLineEnd: i === diffs.length - 1,
					},
				);
				if (hadNonWhitespace) {
					atLineStart = false;
				}

				if (
					type ===
					___R$project$rome$$internal$string$diff$index_ts$diffConstants.EQUAL
				) {
					return value;
				} else {
					return ___R$project$rome$$internal$markup$escape_ts$markupTag(
						"emphasis",
						value,
					);
				}
			}),
		);
	}

	const ___R$$priv$project$rome$$internal$cli$diagnostics$buildPatchCodeFrame_ts$DELETE_MARKER = ___R$project$rome$$internal$markup$escape_ts$markupTag(
		"error",
		___R$project$rome$$internal$markup$escape_ts$markup`-`,
	);
	const ___R$$priv$project$rome$$internal$cli$diagnostics$buildPatchCodeFrame_ts$ADD_MARKER = ___R$project$rome$$internal$markup$escape_ts$markupTag(
		"success",
		___R$project$rome$$internal$markup$escape_ts$markup`+`,
	);

	function ___R$$priv$project$rome$$internal$cli$diagnostics$buildPatchCodeFrame_ts$formatSingleLineMarker(
		text,
	) {
		return ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${text}</emphasis>: `;
	}

	function ___R$project$rome$$internal$cli$diagnostics$buildPatchCodeFrame_ts$default(
		item,
		truncate,
	) {
		const {diffsByLine, beforeLineCount, afterLineCount} = ___R$project$rome$$internal$string$diff$index_ts$stringDiffUnified(
			item.diff,
		);

		// Calculate the parts of the diff we should show
		const shownLineIndexes = new Set();
		for (let i = 0; i < diffsByLine.length; i++) {
			const {beforeLine, afterLine} = diffsByLine[i];

			if (beforeLine === undefined || afterLine === undefined) {
				for (
					let visible =
						i -
						___R$project$rome$$internal$cli$diagnostics$constants_ts$CODE_FRAME_CONTEXT_LINES;
					visible <
					i +
					___R$project$rome$$internal$cli$diagnostics$constants_ts$CODE_FRAME_CONTEXT_LINES;
					visible++
				) {
					shownLineIndexes.add(visible);
				}
			}
		}

		// Calculate width of line no column
		const beforeNoLength = String(beforeLineCount).length;
		const afterNoLength = String(afterLineCount).length;

		const singleLine = beforeLineCount === 1 && afterLineCount === 1;

		const {legend} = item;
		const frame = [];
		let displayedLines = 0;
		let truncated = false;
		let lastDisplayedLine = -1;

		const lineNoLength = beforeNoLength + afterNoLength + 1;
		const skippedLine = ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${___R$project$rome$$internal$cli$diagnostics$constants_ts$CODE_FRAME_INDENT}${"\xb7".repeat(
			lineNoLength,
		)}${___R$project$rome$$internal$cli$diagnostics$constants_ts$GUTTER}</emphasis>`;

		function createLineNos(beforeLine, afterLine) {
			let parts = [];
			parts.push(
				___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${___R$project$rome$$internal$cli$diagnostics$constants_ts$CODE_FRAME_INDENT}<pad align="right" width="${String(
					beforeNoLength,
				)}">`,
			);
			if (beforeLine !== undefined) {
				parts.push(
					___R$project$rome$$internal$markup$escape_ts$markup`${String(
						beforeLine,
					)}`,
				);
			}
			parts.push(
				___R$project$rome$$internal$markup$escape_ts$markup`</pad> <pad align="right" width="${String(
					afterNoLength,
				)}">`,
			);
			if (afterLine !== undefined) {
				parts.push(
					___R$project$rome$$internal$markup$escape_ts$markup`${String(
						afterLine,
					)}`,
				);
			}
			parts.push(
				___R$project$rome$$internal$markup$escape_ts$markup`</pad></emphasis>`,
			);
			return ___R$project$rome$$internal$markup$escape_ts$concatMarkup(parts);
		}

		// Build the actual frame
		for (let i = 0; i < diffsByLine.length; i++) {
			if (!shownLineIndexes.has(i)) {
				continue;
			}

			displayedLines++;

			if (
				!truncate &&
				displayedLines >
				___R$project$rome$$internal$cli$diagnostics$constants_ts$MAX_PATCH_LINES
			) {
				truncated = true;
				continue;
			}

			const {beforeLine, afterLine, diffs} = diffsByLine[i];

			let lineType = "EQUAL";
			let marker = ___R$project$rome$$internal$markup$escape_ts$markup` `;

			if (beforeLine === undefined) {
				marker = ___R$$priv$project$rome$$internal$cli$diagnostics$buildPatchCodeFrame_ts$ADD_MARKER;
				lineType = "ADD";
			}

			if (afterLine === undefined) {
				marker = ___R$$priv$project$rome$$internal$cli$diagnostics$buildPatchCodeFrame_ts$DELETE_MARKER;
				lineType = "DELETE";
			}

			if (lastDisplayedLine !== i - 1 && lastDisplayedLine !== -1) {
				frame.push(skippedLine);
			}

			const logType = lineType === "ADD" ? "success" : "error";

			if (singleLine) {
				let legendPrefix = ___R$project$rome$$internal$markup$escape_ts$markup``;

				if (legend !== undefined) {
					if (lineType === "DELETE") {
						legendPrefix = ___R$$priv$project$rome$$internal$cli$diagnostics$buildPatchCodeFrame_ts$formatSingleLineMarker(
							legend.delete,
						);
					} else if (lineType === "ADD") {
						legendPrefix = ___R$$priv$project$rome$$internal$cli$diagnostics$buildPatchCodeFrame_ts$formatSingleLineMarker(
							legend.add,
						);
					}
				}

				if (lineType === "DELETE" || lineType === "ADD") {
					frame.push(
						___R$project$rome$$internal$markup$escape_ts$markup`${legendPrefix}<view><viewLinePrefix>${marker} </viewLinePrefix><${logType}>${___R$$priv$project$rome$$internal$cli$diagnostics$buildPatchCodeFrame_ts$formatDiffLine(
							diffs,
						)}</${logType}></view>`,
					);
				} else {
					frame.push(
						___R$project$rome$$internal$markup$escape_ts$markup`${legendPrefix}<view extraSoftWrapIndent="2"><viewLinePrefix>  </viewLinePrefix>${___R$$priv$project$rome$$internal$cli$diagnostics$buildPatchCodeFrame_ts$formatDiffLine(
							diffs,
						)}</view>`,
					);
				}
			} else {
				let prefixes = ___R$project$rome$$internal$markup$escape_ts$concatMarkup([
					___R$project$rome$$internal$markup$escape_ts$markup`<viewLinePrefix type="first">${createLineNos(
						beforeLine,
						afterLine,
					)}${___R$project$rome$$internal$cli$diagnostics$constants_ts$GUTTER}${marker} </viewLinePrefix>`,
					___R$project$rome$$internal$markup$escape_ts$markup`<viewLinePrefix type="middle"><dim>${createLineNos(
						beforeLine === undefined ? undefined : "\u2192",
						afterLine === undefined ? undefined : "\u2192",
					)}</dim>${___R$project$rome$$internal$cli$diagnostics$constants_ts$GUTTER}${marker} </viewLinePrefix>`,
				]);
				let line = ___R$$priv$project$rome$$internal$cli$diagnostics$buildPatchCodeFrame_ts$formatDiffLine(
					diffs,
				);

				if (lineType === "DELETE" || lineType === "ADD") {
					line = ___R$project$rome$$internal$markup$escape_ts$markup`<${logType}>${line}</${logType}>`;
				}

				frame.push(
					___R$project$rome$$internal$markup$escape_ts$markup`<view extraSoftWrapIndent="2">${prefixes}${line}</view>`,
				);
			}

			lastDisplayedLine = i;
		}

		if (truncated) {
			frame.push(
				___R$project$rome$$internal$markup$escape_ts$markup`${skippedLine} <dim><number>${String(
					displayedLines -
					___R$project$rome$$internal$cli$diagnostics$constants_ts$MAX_PATCH_LINES,
				)}</number> more lines truncated</dim>`,
			);
		}

		if (legend !== undefined && !singleLine) {
			frame.push(___R$project$rome$$internal$markup$escape_ts$markup``);
			frame.push(
				___R$project$rome$$internal$markup$escape_ts$markup`<error>- ${legend.delete}</error>`,
			);
			frame.push(
				___R$project$rome$$internal$markup$escape_ts$markup`<success>+ ${legend.add}</success>`,
			);
			frame.push(___R$project$rome$$internal$markup$escape_ts$markup``);
		}

		return {
			truncated,
			frame: ___R$project$rome$$internal$markup$escape_ts$concatMarkup(
				frame,
				___R$project$rome$$internal$markup$escape_ts$markup`\n`,
			),
		};
	}


  // project-rome/@internal/cli-diagnostics/buildCodeFrame.ts
function ___R$$priv$project$rome$$internal$cli$diagnostics$buildCodeFrame_ts$formatLineView(
		{marker, line, gutter},
		gutterLength,
	) {
		const attributes = {
			extraSoftWrapIndent: 2,
			// NB: The `word-break` default is probably better? lineWrap: "char-break",
		};

		const parts = [line];

		if (gutterLength > 0) {
			parts.push(
				___R$project$rome$$internal$markup$escape_ts$markupTag(
					"viewLinePrefix",
					___R$project$rome$$internal$markup$escape_ts$markup`<pad align="right" width="${String(
						gutterLength,
					)}"><emphasis>${gutter}</emphasis></pad>${___R$project$rome$$internal$cli$diagnostics$constants_ts$GUTTER}`,
					{
						type: "first",
					},
				),
			);

			parts.push(
				___R$project$rome$$internal$markup$escape_ts$markupTag(
					"viewLinePrefix",
					___R$project$rome$$internal$markup$escape_ts$markup`<dim>→</dim>${___R$project$rome$$internal$cli$diagnostics$constants_ts$GUTTER}`,
					{
						align: "right",
						type: "middle",
					},
				),
			);

			parts.push(
				___R$project$rome$$internal$markup$escape_ts$markupTag(
					"viewLinePrefix",
					___R$project$rome$$internal$cli$diagnostics$constants_ts$GUTTER,
					{
						align: "right",
						type: "pointer",
					},
				),
			);
		}

		if (marker !== undefined) {
			parts.push(
				___R$project$rome$$internal$markup$escape_ts$markupTag(
					"viewPointer",
					marker.message,
					{
						char: "<error><emphasis>^</emphasis></error>",
						line: "1",
						start: String(marker.start),
						end: String(marker.end),
					},
				),
			);
		}

		return ___R$project$rome$$internal$markup$escape_ts$markupTag(
			"view",
			___R$project$rome$$internal$markup$escape_ts$concatMarkup(parts),
			attributes,
		);
	}

	function ___R$project$rome$$internal$cli$diagnostics$buildCodeFrame_ts$default(
		{
			lines: allLines,
			truncateLines,
			start,
			end,
			type,
			markerMessage = ___R$project$rome$$internal$markup$escape_ts$markup``,
		},
	) {
		// Bail if we have negative line references, we have no lines, or we expected positions and don't have one
		let shouldBail = allLines.length === 0;
		if (type === "pointer" && (start === undefined || end === undefined)) {
			shouldBail = true;
		}
		if (
			start !== undefined &&
			start.line === ___R$project$rome$$internal$ob1$index_ts$ob1Number1Neg1
		) {
			shouldBail = true;
		}
		if (
			end !== undefined &&
			end.line === ___R$project$rome$$internal$ob1$index_ts$ob1Number1Neg1
		) {
			shouldBail = true;
		}
		if (shouldBail) {
			return {
				frame: markerMessage,
				truncated: false,
			};
		}

		// Whether we truncated lines
		let truncated = false;

		const startLineIndex =
			start === undefined
				? ___R$project$rome$$internal$ob1$index_ts$ob1Number0
				: ___R$project$rome$$internal$ob1$index_ts$ob1Coerce1To0(start.line);
		let endLineIndex =
			end === undefined
				? ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(
						allLines.length - 1,
					)
				: ___R$project$rome$$internal$ob1$index_ts$ob1Coerce1To0(end.line);

		// Increase the amount of lines we should show for "context"
		let contextStartIndex =
			start === undefined
				? startLineIndex
				: ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(
						Math.max(
							0,
							___R$project$rome$$internal$ob1$index_ts$ob1Get0(startLineIndex) -
							___R$project$rome$$internal$cli$diagnostics$constants_ts$CODE_FRAME_CONTEXT_LINES,
						),
					);
		let contextEndIndex =
			end === undefined
				? endLineIndex
				: ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(
						Math.min(
							allLines.length - 1,
							___R$project$rome$$internal$ob1$index_ts$ob1Get0(endLineIndex) +
							___R$project$rome$$internal$cli$diagnostics$constants_ts$CODE_FRAME_CONTEXT_LINES,
						),
					);

		let maxVisibleLineNo = 0;

		let formattedLines = [];
		for (
			let i = contextStartIndex;
			i <= contextEndIndex;
			i = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(i)
		) {
			let line = allLines[___R$project$rome$$internal$ob1$index_ts$ob1Get0(i)];
			if (line === undefined) {
				continue;
			}

			let [rawLine, highlightLine] = line;

			// Ensure that the frame doesn't start with whitespace
			if (
				rawLine.trim() === "" &&
				formattedLines.length === 0 &&
				i !== startLineIndex
			) {
				continue;
			}

			// If this is within the highlighted line range
			const shouldHighlight =
				type === "pointer" && i >= startLineIndex && i <= endLineIndex;

			let marker;

			if (shouldHighlight && start !== undefined && end !== undefined) {
				if (i === startLineIndex && i === endLineIndex) {
					// Only line in the selection
					marker = {
						message: markerMessage,
						start: start.column,
						end: end.column,
					};
				} else if (i === startLineIndex) {
					// First line in selection
					marker = {
						message: ___R$project$rome$$internal$markup$escape_ts$markup``,
						start: start.column,
						// line could be highlighted
						end: ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(
							rawLine.length,
						),
					};
				} else if (i === endLineIndex) {
					// Last line in selection
					marker = {
						message: markerMessage,
						start: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
						end: end.column,
					};
				}
			}

			// Show invisible characters
			highlightLine = ___R$project$rome$$internal$cli$diagnostics$utils_ts$showInvisibles(
				___R$project$rome$$internal$markup$escape_ts$readMarkup(highlightLine),
				{
					ignoreLeadingTabs: true,
					ignoreLoneSpaces: true,
					atLineStart: true,
					atLineEnd: true,
				},
			).value;

			const lineNo = ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0To1(i);
			let gutter = ___R$project$rome$$internal$markup$escape_ts$markup`${String(
				lineNo,
			)}`;

			if (shouldHighlight) {
				gutter = ___R$project$rome$$internal$markup$escape_ts$markup`${___R$project$rome$$internal$cli$diagnostics$constants_ts$CODE_FRAME_SELECTED_INDENT}${gutter}`;
			} else {
				gutter = ___R$project$rome$$internal$markup$escape_ts$markup`${___R$project$rome$$internal$cli$diagnostics$constants_ts$CODE_FRAME_INDENT}${gutter}`;
			}

			formattedLines.push({
				marker,
				gutter,
				line: highlightLine,
			});

			maxVisibleLineNo = ___R$project$rome$$internal$ob1$index_ts$ob1Get0(i) + 1;

			if (truncateLines !== undefined && maxVisibleLineNo > truncateLines) {
				truncated = true;
				break;
			}
		}

		// If we have too many lines in our selection, then collapse them to an ellipsis
		const pruned =
			type === "pointer" &&
			formattedLines.length >
			___R$project$rome$$internal$cli$diagnostics$constants_ts$MAX_CODE_FRAME_LINES +
			2;
		if (pruned) {
			const start = formattedLines.slice(
				0,
				___R$project$rome$$internal$cli$diagnostics$constants_ts$HALF_MAX_CODE_FRAME_LINES,
			);
			const end = formattedLines.slice(
				-___R$project$rome$$internal$cli$diagnostics$constants_ts$HALF_MAX_CODE_FRAME_LINES,
			);
			formattedLines = start.concat([undefined], end);
		}

		// Remove trailing blank lines
		for (let i = formattedLines.length - 1; i >= 0; i--) {
			const info = formattedLines[i];
			if (
				info !== undefined &&
				___R$project$rome$$internal$markup$escape_ts$isEmptyMarkup(info.line)
			) {
				formattedLines.pop();
			} else {
				break;
			}
		}

		// If there's no lines to target then return the normal marker
		if (formattedLines.length === 0) {
			return {
				frame: markerMessage,
				truncated: false,
			};
		}

		// Calculate max size of gutter, this is the maximum visible line plus the futter length plus the frame indent
		const lastLine = formattedLines[formattedLines.length - 1];
		if (lastLine === undefined) {
			throw new Error("Expected there to be a last line");
		}

		const maxGutterLength =
			String(maxVisibleLineNo).length +
			___R$project$rome$$internal$cli$diagnostics$constants_ts$CODE_FRAME_INDENT.length;

		// If what the marker is highlighting equals the marker message then it's redundant so don't show the message
		if (
			!___R$project$rome$$internal$markup$escape_ts$isEmptyMarkup(markerMessage) &&
			start !== undefined &&
			end !== undefined
		) {
			const line = allLines[___R$project$rome$$internal$ob1$index_ts$ob1Get0(
				___R$project$rome$$internal$ob1$index_ts$ob1Coerce1To0(start.line),
			)];
			if (line !== undefined) {
				const text = line[0].slice(
					___R$project$rome$$internal$ob1$index_ts$ob1Get0(start.column),
					___R$project$rome$$internal$ob1$index_ts$ob1Get0(end.column),
				);
				if (
					___R$project$rome$$internal$cli$diagnostics$utils_ts$cleanEquivalentString(
						text,
					) ===
					___R$project$rome$$internal$cli$diagnostics$utils_ts$cleanEquivalentString(
						markerMessage,
					)
				) {
					for (const selection of formattedLines) {
						if (
							selection !== undefined &&
							selection.marker !== undefined &&
							selection.marker.message === markerMessage
						) {
							selection.marker.message = ___R$project$rome$$internal$markup$escape_ts$markup``;
						}
					}
				}
			}
		}

		// Output no gutter with a soft indent if this is true
		if (formattedLines.length === 1) {
			const selection = formattedLines[0];
			if (selection === undefined) {
				throw new Error(
					"Expected a selection? undefined is only valid here as an omitted line signifier",
				);
			}

			return {
				frame: ___R$project$rome$$internal$markup$escape_ts$markup`${___R$project$rome$$internal$cli$diagnostics$constants_ts$CODE_FRAME_INDENT}${___R$$priv$project$rome$$internal$cli$diagnostics$buildCodeFrame_ts$formatLineView(
					selection,
					0,
				)}`,
				truncated,
			};
		}

		// Build up the line we display when source lines are omitted
		const omittedLine = ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis><pad align="right" width="${String(
			maxGutterLength,
		)}">...</pad></emphasis>${___R$project$rome$$internal$cli$diagnostics$constants_ts$GUTTER}`;

		// Build the frame
		const result = [];
		for (const selection of formattedLines) {
			if (!selection) {
				result.push(omittedLine);
				continue;
			}

			result.push(
				___R$$priv$project$rome$$internal$cli$diagnostics$buildCodeFrame_ts$formatLineView(
					selection,
					maxGutterLength,
				),
			);
		}

		if (truncated) {
			result.push(
				___R$project$rome$$internal$markup$escape_ts$markup`${omittedLine} <dim><number>${String(
					maxVisibleLineNo - truncateLines,
				)}</number> more lines truncated</dim>`,
			);
		}

		return {
			truncated,
			frame: ___R$project$rome$$internal$markup$escape_ts$concatMarkup(
				result,
				___R$project$rome$$internal$markup$escape_ts$markup`\n`,
			),
		};
	}


  // project-rome/@internal/cli-flags/serializeCLIFlags.ts
const ___R$project$rome$$internal$cli$flags$serializeCLIFlags_ts = {
		serializeCLIFlags: ___R$project$rome$$internal$cli$flags$serializeCLIFlags_ts$serializeCLIFlags,
	};
	function ___R$$priv$project$rome$$internal$cli$flags$serializeCLIFlags_ts$isObjectTarget(
		target,
	) {
		return typeof target !== "string";
	}

	// Used to determine if we should output a -- to disambiguate raw CLI args
	function ___R$$priv$project$rome$$internal$cli$flags$serializeCLIFlags_ts$hasConfusingArgs(
		args,
	) {
		for (const arg of args) {
			if (arg[0] === "-") {
				return true;
			}
		}

		return false;
	}

	function ___R$project$rome$$internal$cli$flags$serializeCLIFlags_ts$serializeCLIFlags(
		{
			args,
			flags,
			cwd,
			programName,
			commandName,

			defaultFlags = {},
			shorthandFlags = new Set(),
			incorrectCaseFlags = new Set(),
		},
		target,
	) {
		let startColumn = ___R$project$rome$$internal$ob1$index_ts$ob1Number0Neg1;
		let endColumn = ___R$project$rome$$internal$ob1$index_ts$ob1Number0Neg1;
		let code = "";

		function setStartColumn() {
			startColumn = ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(
				code.length,
			);
		}

		function setEndColumn() {
			// Never point to a space
			if (code[code.length - 1] === " ") {
				endColumn = ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(
					code.length - 1,
				);
			} else {
				endColumn = ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(
					code.length,
				);
			}
		}

		function push(str, set) {
			if (set) {
				setStartColumn();
			}

			code += str;

			if (set) {
				setEndColumn();
			}
		}

		function printArgs() {
			for (let i = 0; i < args.length; i++) {
				const arg = args[i];

				let isTarget = false;
				if (
					___R$$priv$project$rome$$internal$cli$flags$serializeCLIFlags_ts$isObjectTarget(
						target,
					) &&
					target.type === "arg" &&
					i === target.key
				) {
					isTarget = true;
				}
				if (
					___R$$priv$project$rome$$internal$cli$flags$serializeCLIFlags_ts$isObjectTarget(
						target,
					) &&
					target.type === "arg-range" &&
					target.from === i
				) {
					isTarget = true;
				}

				if (isTarget) {
					setStartColumn();
				}

				code += arg + " ";

				let isEndTarget = isTarget;

				// We are the end target if we're within the from-to range or we're greater than from with no to
				if (
					___R$$priv$project$rome$$internal$cli$flags$serializeCLIFlags_ts$isObjectTarget(
						target,
					) &&
					target.type === "arg-range" &&
					i > target.from &&
					(target.to === undefined || target.to <= i)
				) {
					isEndTarget = true;
				}

				if (isEndTarget) {
					setEndColumn();
				}
			}
		}

		// Only output cwd if it's the target
		if (cwd !== undefined && target === "cwd") {
			push(cwd.join(), true);
			code += "$ ";
		}

		push(programName + " ", target === "program");

		if (commandName !== undefined) {
			push(commandName + " ", target === "command");
		}

		const confusingArgs = ___R$$priv$project$rome$$internal$cli$flags$serializeCLIFlags_ts$hasConfusingArgs(
			args,
		);

		if (!confusingArgs) {
			printArgs();
		}

		// Add flags
		for (const key in flags) {
			const val = flags[key];

			// Ignore pointless default values
			if (val === defaultFlags[key]) {
				continue;
			}

			const values = Array.isArray(val) ? val : [val];

			const isTarget =
				___R$$priv$project$rome$$internal$cli$flags$serializeCLIFlags_ts$isObjectTarget(
					target,
				) &&
				target.type === "flag" &&
				key === target.key;

			if (isTarget) {
				setStartColumn();
			}

			for (const val of values) {
				const flagPrefix = shorthandFlags.has(key) ? "-" : "--";
				const kebabKey = incorrectCaseFlags.has(key)
					? key
					: ___R$project$rome$$internal$string$utils$toKebabCase_ts$toKebabCase(
							key,
						);
				if (val === false) {
					code += flagPrefix + "no-" + kebabKey + " ";
				} else {
					code += "" + flagPrefix + kebabKey + " ";
				}

				// Booleans are always indicated with just their flag
				if (typeof val !== "boolean") {
					// Only point to the value for flags that specify it
					if (
						isTarget &&
						___R$$priv$project$rome$$internal$cli$flags$serializeCLIFlags_ts$isObjectTarget(
							target,
						) &&
						target.type === "flag" &&
						(target.target === "value" || target.target === "inner-value")
					) {
						startColumn = ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(
							code.length,
						);
					}

					// Number or string
					code += String(val) + " ";
				}
			}

			if (isTarget) {
				setEndColumn();
			}
		}

		// Disambiguate raw arguments that look like flags
		if (confusingArgs) {
			code += "-- ";
			printArgs();
		}

		if (
			startColumn === ___R$project$rome$$internal$ob1$index_ts$ob1Number0Neg1 ||
			endColumn === ___R$project$rome$$internal$ob1$index_ts$ob1Number0Neg1
		) {
			startColumn = ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(
				code.length - 1,
			);
			endColumn = startColumn;
		}

		let start = {
			line: ___R$project$rome$$internal$ob1$index_ts$ob1Number1,
			column: startColumn,
		};

		let end = {
			line: ___R$project$rome$$internal$ob1$index_ts$ob1Number1,
			column: endColumn,
		};

		if (target === "none") {
			start = undefined;
			end = undefined;
		}

		return {
			language: "shell",
			mtime: undefined,
			sourceText: code.trimRight(),
			filename: "argv",
			start,
			end,
		};
	}


  // project-rome/@internal/cli-flags/Parser.ts
function ___R$$priv$project$rome$$internal$cli$flags$Parser_ts$splitCommandName(
		cmd,
	) {
		return cmd.split(" ");
	}

	// Whether we can display this value in help
	function ___R$$priv$project$rome$$internal$cli$flags$Parser_ts$isDisplayableHelpValue(
		value,
	) {
		return typeof value === "string" || typeof value === "number";
	}

	class ___R$project$rome$$internal$cli$flags$Parser_ts$default {
		constructor(opts) {
			this.reporter = opts.reporter;
			this.opts = opts;

			this.shorthandFlags = new Set();
			this.incorrectCaseFlags = new Set();
			this.declaredFlags = new Map();
			this.defaultFlags = new Map();
			this.flags = new Map();
			this.args = [];

			// These are used to track where we should insert an argument for a boolean flag value
			this.flagToArgIndex = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
				"flagToArgIndex",
			);
			this.flagToArgOffset = 0;

			this.consumeRawArgs(opts.args);

			this.commands = new Map();
			this.ranCommand = undefined;
			this.currentCommand = undefined;
		}

		looksLikeFlag(flag) {
			return (flag == null ? undefined : flag[0]) === "-";
		}

		toCamelCase(name) {
			const camelName = ___R$project$rome$$internal$string$utils$toCamelCase_ts$toCamelCase(
				name,
			);

			// Don't allow passing in straight camelcased names
			if (
				___R$project$rome$$internal$string$utils$toKebabCase_ts$toKebabCase(
					name,
				) !==
				name
			) {
				this.incorrectCaseFlags.add(name);
			}

			return camelName;
		}

		setFlag(key, value) {
			let newValue = value;
			const existing = this.flags.get(key);
			if (existing !== undefined) {
				if (Array.isArray(existing)) {
					newValue = [...existing, value];
				} else {
					newValue = [existing, value];
				}
			}
			this.flags.set(key, newValue);
		}

		consumeRawArgs(rawArgs) {
			while (rawArgs.length > 0) {
				const arg = String(rawArgs.shift());

				if (arg === "--") {
					// We consider a -- by itself to halt parsing of args, the rest of the remaining args are added to _
					this.args = this.args.concat(rawArgs);
					break;
				} else if (arg[0] === "-") {
					// Clean the argument by stripping off the dashes
					const name = arg[1] === "-" ? arg.slice(2) : arg.slice(1);

					// Flags beginning with no- are always false
					if (name.startsWith("no-")) {
						const camelName = this.toCamelCase(name.slice(3));
						this.setFlag(camelName, false);
						continue;
					}

					// Allow for arguments to be passed as --foo=bar
					const equalsIndex = name.indexOf("=");
					if (equalsIndex !== -1) {
						const cleanName = this.toCamelCase(name.slice(0, equalsIndex));
						const value = name.slice(equalsIndex + 1);
						this.setFlag(cleanName, value);
						continue;
					}

					const camelName = this.toCamelCase(name);

					// If the next argument is a flag or we're at the end of the args then just set it to `true`
					if (rawArgs.length === 0 || this.looksLikeFlag(rawArgs[0])) {
						this.setFlag(camelName, true);
					} else {
						// Otherwise, take that value
						this.setFlag(camelName, String(rawArgs.shift()));
					}

					if (arg[0] === "-" && arg[1] !== "-") {
						this.shorthandFlags.add(camelName);
					}

					this.flagToArgIndex.set(camelName, this.args.length);
				} else {
					// Not a flag and hasn't been consumed already by a previous arg so it must be a file
					this.args.push(arg);
				}
			}
		}

		getFlagsConsumer() {
			const defaultFlags = {};

			const flags = {};
			for (const [key, value] of this.flags) {
				flags[___R$project$rome$$internal$string$utils$toCamelCase_ts$toCamelCase(
					key,
				)] = value;
			}

			const consumer = ___R$project$rome$$internal$consume$index_ts$consume({
				filePath: ___R$project$rome$$internal$path$index_ts$createUnknownPath(
					"argv",
				),
				value: flags,
				onDefinition: (def, valueConsumer) => {
					const key = def.objectPath.join(".");

					// Detect root object
					if (key === "") {
						return;
					}

					// These flags are ambiguous with how we handle `--no-` booleans
					if (
						___R$project$rome$$internal$string$utils$toKebabCase_ts$toKebabCase(
							key,
						).startsWith("no-")
					) {
						throw new Error("CLI flag " + key + ' cannot start with "no"');
					}

					const value = flags[key];

					// Allow omitting a string flag value
					if (def.type === "string" && value === true) {
						valueConsumer.setValue("");
					}

					this.declareArgument({
						name: key,
						command: this.currentCommand,
						definition: def,
					});
					defaultFlags[key] = (def.default);

					// Automatically convert number strings
					if (def.type === "number" && typeof value !== "number") {
						if (valueConsumer.exists() || def.required) {
							valueConsumer.setValue(valueConsumer.asNumberString());
						}
					}

					// We've parsed arguments like `--foo bar` as `{foo: 'bar}`
					// However, --foo may be a boolean flag, so `bar` needs to be correctly added to args
					if (
						def.type === "boolean" &&
						value !== true &&
						value !== false &&
						value !== undefined
					) {
						const argIndex = this.flagToArgIndex.assert(key);

						// Insert the argument at the correct place
						this.args.splice(argIndex + this.flagToArgOffset, 0, String(value));

						// Increase offset to correct subsequent insertions
						this.flagToArgOffset++;

						//
						valueConsumer.setValue(true);
					}
				},
				context: {
					category: "flags/invalid",
					normalizeKey: (key) => {
						return this.incorrectCaseFlags.has(key)
							? key
							: ___R$project$rome$$internal$string$utils$toKebabCase_ts$toKebabCase(
									key,
								);
					},
					getOriginalValue: (keys) => {
						return flags[keys[0]];
					},
					getDiagnosticLocation: (keys, target) => {
						return ___R$project$rome$$internal$cli$flags$serializeCLIFlags_ts$serializeCLIFlags(
							Object.assign(
								{},
								this.getSerializeOptions(),
								{defaultFlags, flags},
							),
							{
								type: "flag",
								key: String(keys[0]),
								target,
							},
						);
					},
				},
			});

			return {flags: consumer, defaultFlags, rawFlags: flags};
		}

		declareArgument(decl) {
			// Commands may have colliding flags, this is only a problem in help mode, so make it unique
			const key =
				decl.command === undefined ? decl.name : decl.command + "." + decl.name;

			// Ensure it hasn't been declared more than once
			if (this.declaredFlags.has(key)) {
				throw new Error("Already declared argument " + key);
			}

			// Declare argument
			this.declaredFlags.set(key, decl);
			this.defaultFlags.set(key, decl.definition.default);
		}

		getInterface() {
			return new ___R$project$rome$$internal$cli$flags$Parser_ts$ParserInterface(
				this,
			);
		}

		async maybeDefineCommandFlags(command, consumer) {
			// A command name could be made of multiple strings
			const commandParts = ___R$$priv$project$rome$$internal$cli$flags$Parser_ts$splitCommandName(
				command.name,
			);
			for (let i = 0; i < commandParts.length; i++) {
				if (commandParts[i] !== this.args[i]) {
					return;
				}
			}

			// Remove command name from arguments
			this.args = this.args.slice(commandParts.length);
			return await this.defineCommandFlags(command, consumer);
		}

		checkBadFlags(consumer, definedCommand) {
			// Ignore flags from command and root parser options
			const ignoreFlags = [
				...((definedCommand !== undefined && definedCommand.command.ignoreFlags) || []),
				...(this.opts.ignoreFlags || []),
			];
			for (const key of ignoreFlags) {
				this.shorthandFlags.delete(key);
				this.incorrectCaseFlags.delete(key);
				consumer.markUsedProperty(key);
			}

			for (const [key] of this.flags) {
				if (this.shorthandFlags.has(key)) {
					const def =
						this.declaredFlags.get(key) == null
							? undefined
							: this.declaredFlags.get(key).definition;
					if (
						def &&
						(def.metadata == null ? undefined : def.metadata.alternateName) !==
						key
					) {
						consumer.get(key).unexpected(
							___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.FLAGS.UNSUPPORTED_SHORTHAND(
								key,
							),
						);
					}
				}
			}

			for (const incorrectName of this.incorrectCaseFlags) {
				consumer.get(incorrectName).unexpected(
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.FLAGS.INCORRECT_CASED_FLAG(
						incorrectName,
					),
				);
			}

			consumer.enforceUsedProperties("flag", false);
		}

		async writeShellCompletions(
			shell,
			directory = ___R$project$rome$$internal$path$index_ts$HOME_PATH,
		) {
			const {programName} = this.opts;
			const {reporter} = this;
			let path;

			// Figure out profiles and basename to use for the completion script
			switch (shell) {
				case "bash": {
					path = directory.append("." + programName + "-completion.sh");
					break;
				}

				case "fish": {
					path = ___R$project$rome$$internal$path$index_ts$HOME_PATH.append(
						".config",
						"fish",
						"completions",
						programName + ".fish",
					);
					break;
				}
			}

			// Write completions
			const res = await this.generateShellCompletions(shell);
			await ___R$project$rome$$internal$fs$index_ts$writeFile(path, res);
			reporter.success(
				___R$project$rome$$internal$markup$escape_ts$markup`Wrote shell completions to <emphasis>${path}</emphasis>`,
			);

			// Tell the user the next step
			switch (shell) {
				case "bash": {
					const possibleProfiles = [];
					possibleProfiles.push(
						___R$project$rome$$internal$path$index_ts$HOME_PATH.append(
							".bashrc",
						),
					);
					possibleProfiles.push(
						___R$project$rome$$internal$path$index_ts$HOME_PATH.append(
							".bash_profile",
						),
					);

					// Find the profile
					let profilePath;
					for (const path of possibleProfiles) {
						if (await ___R$project$rome$$internal$fs$index_ts$exists(path)) {
							profilePath = path;
							break;
						}
					}
					if (profilePath === undefined) {
						reporter.error(
							___R$project$rome$$internal$markup$escape_ts$markup`Could not find your bash profile. Tried the following:`,
						);
						reporter.list(
							possibleProfiles.map((path) => {
								return ___R$project$rome$$internal$markup$escape_ts$markup`${path}`;
							}),
						);
					} else {
						let file = await ___R$project$rome$$internal$fs$index_ts$readFileText(
							profilePath,
						);
						if (file.includes(path.getBasename())) {
							reporter.warn(
								___R$project$rome$$internal$markup$escape_ts$markup`Skipped <emphasis>${profilePath}</emphasis> modifications as looks like it was already included`,
							);
						} else {
							file = file.trim();
							file += "\n";
							file +=
								"source " +
								path.relative(profilePath).preferExplicitRelative().join();
							file += "\n";
							await ___R$project$rome$$internal$fs$index_ts$writeFile(
								profilePath,
								file,
							);
							reporter.success(
								___R$project$rome$$internal$markup$escape_ts$markup`Added completions to <emphasis>${profilePath}</emphasis>`,
							);
						}
					}
					break;
				}
			}

			reporter.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Restart your shell to enable!`,
			);
			this.exit(0);
		}

		async logShellCompletions(shell) {
			const res = await this.generateShellCompletions(shell);
			this.reporter.logRaw(res);
			this.exit(0);
		}

		async init() {
			const flagsConsumer = this.getFlagsConsumer();
			const {flags} = flagsConsumer;

			// Show help for --version
			const version = this.opts.version;
			if (version !== undefined) {
				const shouldDisplayVersion = flags.get(
					"version",
					{
						description: ___R$project$rome$$internal$markup$escape_ts$markup`Show the version`,
					},
				).asBoolean(false);
				if (shouldDisplayVersion) {
					this.reporter.log(
						___R$project$rome$$internal$markup$escape_ts$markup`${version}`,
					);
					this.exit(0);
				}
			}

			const {shellCompletionDirectory} = this.opts;
			// `--write-shell-completions <SHELL>` writes the commands to a file
			const writeShellCompletions = flags.get(
				"writeShellCompletions",
				{
					description: ___R$project$rome$$internal$markup$escape_ts$markup`Write shell completion commands`,
					inputName: "shell",
				},
			).asStringSetOrVoid(["fish", "bash"]);
			if (writeShellCompletions !== undefined) {
				await this.writeShellCompletions(
					writeShellCompletions,
					shellCompletionDirectory,
				);
			}

			// `--generate-shell-completions <SHELL>` writes the commands to stdout
			const logShellCompletions = flags.get(
				"logShellCompletions",
				{
					description: ___R$project$rome$$internal$markup$escape_ts$markup`Generate shell completion commands`,
					inputName: "shell",
				},
			).asStringSetOrVoid(["fish", "bash"]);
			if (logShellCompletions !== undefined) {
				await this.logShellCompletions(logShellCompletions);
			}

			// Show help for --help
			const shouldShowHelp = flags.get(
				"help",
				{
					description: ___R$project$rome$$internal$markup$escape_ts$markup`Show this help screen`,
					alternateName: "h",
				},
			).asBoolean(false);

			let definedCommand;

			const rootFlags = await flags.bufferDiagnostics(async (consumer) => {
				const rootFlags = this.opts.defineFlags(consumer);

				for (const [key, command] of this.commands) {
					const definedFlags = await this.maybeDefineCommandFlags(
						command,
						consumer,
					);
					if (definedFlags !== undefined) {
						this.currentCommand = key;
						definedCommand = {flags: definedFlags, command};
						break;
					}
				}

				this.checkBadFlags(consumer, definedCommand);

				this.currentCommand = undefined;

				if (this.opts.commandRequired && !shouldShowHelp) {
					this.commandRequired(definedCommand !== undefined, flagsConsumer);
				}

				return rootFlags;
			});

			// Show help for --help
			if (shouldShowHelp) {
				await this.showHelp(
					definedCommand === undefined ? undefined : definedCommand.command,
				);
				this.exit(1);
			}

			if (definedCommand !== undefined) {
				this.ranCommand = definedCommand.command;
				if (definedCommand.command.hidden === true) {
					this.reporter.warn(
						___R$project$rome$$internal$markup$escape_ts$markup`This command has been hidden. Consider its usage to be experimental and do not expect support or backwards compatibility.`,
					);
				}
				await definedCommand.command.callback(definedCommand.flags);
			}

			return rootFlags;
		}

		buildOptionsHelp(keys) {
			const optionOutput = [];
			let argColumnLength = 0;

			// Build up options, we need to do this to line up the columns correctly
			for (const key of keys) {
				const decl = this.declaredFlags.get(key);

				const {definition: def} = decl;
				const {metadata} = def;
				let argName = decl.name;
				let argCol = ___R$project$rome$$internal$string$utils$toKebabCase_ts$toKebabCase(
					decl.name,
				);

				// For booleans that default to `true`, show the --no- version as that'll be what users should use
				if (def.type === "boolean" && def.default === true) {
					argCol = "--no-" + argCol;
					argName = "no-" + argName;
				} else {
					argCol = "--" + argCol;
				}

				// Add input specifier unless a boolean
				if (def.type !== "boolean") {
					let {inputName} = metadata;

					if (inputName === undefined) {
						if (def.type === "number") {
							inputName = "num";
						} else {
							inputName = "input";
						}
					}

					argCol += " <" + inputName + ">";
				}

				if (metadata.alternateName) {
					argCol += ", -" + metadata.alternateName;
				}

				// Set arg col length if we'll be longer
				if (argColumnLength < argCol.length) {
					argColumnLength = argCol.length;
				}

				let descCol =
					metadata.description === undefined
						? ___R$project$rome$$internal$markup$escape_ts$markup`no description found`
						: metadata.description;

				const {default: defaultValue} = def;
				if (
					defaultValue !== undefined &&
					___R$$priv$project$rome$$internal$cli$flags$Parser_ts$isDisplayableHelpValue(
						defaultValue,
					)
				) {
					descCol = ___R$project$rome$$internal$markup$escape_ts$markup`${descCol} - default ${___R$project$rome$$internal$pretty$format$index_ts$prettyFormatEager(
						defaultValue,
					)}`;
				}

				if (def.type === "string" && def.allowedValues !== undefined) {
					const displayAllowedValues = def.allowedValues.filter((item) =>
						___R$$priv$project$rome$$internal$cli$flags$Parser_ts$isDisplayableHelpValue(
							item,
						)
					);
					if (displayAllowedValues !== undefined) {
						const printedValues = ___R$project$rome$$internal$markup$escape_ts$concatMarkup(
							displayAllowedValues.map((value) =>
								___R$project$rome$$internal$pretty$format$index_ts$prettyFormatEager(
									value,
								)
							),
							___R$project$rome$$internal$markup$escape_ts$markup` `,
						);
						descCol = ___R$project$rome$$internal$markup$escape_ts$markup`${descCol} - values ${printedValues})`;
					}
				}

				optionOutput.push({
					argName,
					arg: ___R$project$rome$$internal$markup$escape_ts$concatMarkup(
						___R$project$rome$$internal$markup$syntax$highlight$highlightShell_ts$default({
							input: argCol,
							isShorthand: !!metadata.alternateName,
						}),
						___R$project$rome$$internal$markup$escape_ts$markup` `,
					),
					description: descCol,
				});
			}

			// Sort options by argument name
			optionOutput.sort((a, b) =>
				___R$project$rome$$internal$string$utils$naturalCompare_ts$naturalCompare(
					a.argName,
					b.argName,
				)
			);

			// Build table rows
			return optionOutput.map((opt) => [
				___R$project$rome$$internal$markup$escape_ts$markup`<view align="right">${opt.arg}</view>`,
				opt.description,
			]);
		}

		async showUsageHelp(description, usage = "[flags]", prefix) {
			const {reporter} = this;
			const {programName} = this.opts;

			await reporter.section(
				___R$project$rome$$internal$markup$escape_ts$markup`Usage`,
				() => {
					if (description !== undefined) {
						reporter.log(description);
						reporter.br({force: true});
					}

					const commandParts = [programName];
					if (prefix !== undefined) {
						commandParts.push(prefix);
					}
					commandParts.push(usage);

					const command = commandParts.join(" ");
					reporter.command(command, false);
				},
			);
		}

		async showFocusedCommandHelp(command) {
			const {reporter} = this;
			const {name, usage, description, examples} = command;

			reporter.br({force: true});
			await this.showUsageHelp(description, usage, name);
			await this.showHelpExamples(examples, name);

			// Find arguments that belong to this command
			const argKeys = [];
			for (const [key, decl] of this.declaredFlags) {
				if (decl.command === name) {
					argKeys.push(key);
				}
			}

			const optRows = this.buildOptionsHelp(argKeys);
			if (optRows.length > 0) {
				await reporter.section(
					___R$project$rome$$internal$markup$escape_ts$markup`Command Flags`,
					() => {
						reporter.table([], optRows);
					},
				);
			}

			await reporter.section(
				___R$project$rome$$internal$markup$escape_ts$markup`Global Flags`,
				() => {
					reporter.info(
						___R$project$rome$$internal$markup$escape_ts$markup`To view global flags run`,
					);
					reporter.command("rome --help");
				},
			);
		}

		async showGlobalFlags() {
			const {reporter} = this;
			await reporter.section(
				___R$project$rome$$internal$markup$escape_ts$markup`Global Flags`,
				() => {
					// Show options not attached to any commands
					const lonerArgKeys = [];
					for (const [key, decl] of this.declaredFlags) {
						if (decl.command === undefined) {
							lonerArgKeys.push(key);
						}
					}

					reporter.table([], this.buildOptionsHelp(lonerArgKeys));
				},
			);
		}

		async generateShellCompletions(shell) {
			// Execute all command defineFlags. Only one is usually ran when the arguments match the command name.
			// But to generate autocomplete we want all the flags to be declared for all commands.
			const {flags} = this.getFlagsConsumer();
			for (const command of this.commands.values()) {
				// capture() will cause diagnostics to be suppressed
				const {consumer} = flags.capture();
				await this.defineCommandFlags(command, consumer);
			}

			const {programName} = this.opts;

			switch (shell) {
				case "bash": {
					return this.genBashCompletions(programName);
				}
				case "fish": {
					return this.genFishCompletions(programName);
				}
			}
		}

		genFishCompletions(prg) {
			let script = "";
			const scriptPre = "complete -c " + prg;

			// add rome
			script += scriptPre + " -f\n";

			// add command completions
			for (let [subcmd, meta] of this.commands.entries()) {
				// add command description if exists
				let description = "";
				if (meta.description) {
					description +=
						" -d '" +
						___R$project$rome$$internal$markup$escape_ts$readMarkup(
							meta.description,
						) +
						"'";
				}

				script +=
					scriptPre +
					" -n '__fish_use_subcommand' -a '" +
					subcmd +
					"'" +
					description +
					"\n";
			}

			// add flag completions
			for (let meta of this.declaredFlags.values()) {
				const subcmdCond =
					meta.command === undefined
						? ""
						: "-n '__fish_seen_subcommand_from " + meta.command + "'";
				script += scriptPre + " " + subcmdCond + " -l '" + meta.name + "'\n";
			}

			return script;
		}

		genBashCompletions(prg) {
			let romeCmds = "";
			let commandFuncs = "";
			let globalFlags = "";
			let cmdFlagMap = new Map();

			for (let subcmd of this.commands.keys()) {
				romeCmds += subcmd + " ";
			}

			for (let meta of this.declaredFlags.values()) {
				if (meta.command === undefined) {
					globalFlags += "--" + meta.name + " ";
				} else {
					if (cmdFlagMap.has(meta.command)) {
						cmdFlagMap.set(
							meta.command,
							cmdFlagMap.get(meta.command) + " --" + meta.name,
						);
					} else {
						cmdFlagMap.set(meta.command, "--" + meta.name);
					}
				}
			}

			for (let [cmd, flags] of cmdFlagMap.entries()) {
				commandFuncs +=
					"\n      __" +
					prg +
					"_" +
					cmd +
					'()\n      {\n        cmds="";\n        local_flags="' +
					flags +
					'"\n      }\n      ';
			}

			let romeFunc =
				"\n      __" +
				prg +
				'()\n      {\n          cmds="' +
				romeCmds +
				'"\n          local_flags="";\n      }\n    ';

			let mainScript =
				'\n      #!/usr/bin/env bash\n      global_flags="' +
				globalFlags +
				'"\n\n      # initial state\n      cmds=""\n      local_flags=""\n\n      __is_flag()\n      {\n        case $1 in\n          -*) echo "true"\n        esac\n      }\n\n      __' +
				prg +
				'_gen_completions()\n      {\n        local suggestions func flags index\n\n        index="$((${#COMP_WORDS[@]} - 1))"\n\n        flags="$global_flags $local_flags"\n\n        func="_"\n\n        for ((i=0; i < index; i++))\n        do\n          leaf=$(echo ${COMP_WORDS[$i]} | grep -o \'[^/]*$\')\n          if [[ ! $(__is_flag $leaf) ]]; then\n            func="${func}_${leaf}"\n          fi\n        done\n\n        $func 2> /dev/null\n\n        if [[ $(__is_flag ${COMP_WORDS[$index]}) ]]; then\n          suggestions=$flags\n        else\n          suggestions=$cmds\n        fi\n\n        COMPREPLY=($(compgen -W "$suggestions" -- "${COMP_WORDS[$index]}"))\n      }\n    ';

			return ___R$project$rome$$internal$string$utils$dedent_ts$dedent`
      ${mainScript}
      ${commandFuncs}
      ${romeFunc}
      complete -F __${prg}_gen_completions ${prg}
    `;
		}

		async showHelp(command = this.ranCommand) {
			if (command !== undefined) {
				await this.showFocusedCommandHelp(command);
				return;
			}

			const {reporter} = this;
			const {description, usage, examples, programName} = this.opts;

			await this.showUsageHelp(description, usage);
			await this.showGlobalFlags();

			// Sort commands into their appropriate categories for output
			const commandsByCategory = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
				"commandsByCategory",
				() => [],
			);
			const categoryNames = new Set();
			for (const [name, command] of this.commands) {
				if (name[0] === "_") {
					continue;
				}

				const {category} = command;
				const commandsForCategory = commandsByCategory.assert(category);
				commandsForCategory.push(command);
				categoryNames.add(category);
			}

			await reporter.section(
				___R$project$rome$$internal$markup$escape_ts$markup`Commands`,
				() => {
					const sortedCategoryNames = Array.from(categoryNames).sort();

					// Always make sure categoryless commands are displayed first
					if (sortedCategoryNames.includes(undefined)) {
						sortedCategoryNames.splice(
							sortedCategoryNames.indexOf(undefined),
							1,
						);
						sortedCategoryNames.unshift(undefined);
					}

					for (const category of sortedCategoryNames) {
						const commands = commandsByCategory.get(category).filter((c) => {
							return !c.hidden;
						});

						if (commands.length === 0) {
							continue;
						}

						if (category !== undefined) {
							reporter.log(
								___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${category} Commands</emphasis>`,
							);
						}

						// Sort by name
						commands.sort((a, b) => a.name.localeCompare(b.name));

						reporter.list(
							commands.map((cmd) => {
								return ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${cmd.name}</emphasis> ${cmd.description ===
								undefined
									? ""
									: cmd.description}`;
							}),
						);
						reporter.br();
					}

					reporter.info(
						___R$project$rome$$internal$markup$escape_ts$markup`To view help for a specific command run`,
					);
					reporter.command(programName + " command_name --help");
				},
			);

			await this.showHelpExamples(examples);
		}

		async showHelpExamples(examples, prefix) {
			const {programName} = this.opts;
			const {reporter} = this;

			if (examples === undefined || examples.length === 0) {
				return;
			}

			await reporter.section(
				___R$project$rome$$internal$markup$escape_ts$markup`Examples`,
				() => {
					for (const {description, command} of examples) {
						const commandParts = [];
						if (programName !== undefined) {
							commandParts.push(programName);
						}
						if (prefix !== undefined) {
							commandParts.push(prefix);
						}
						commandParts.push(command);

						const builtCommand = commandParts.join(" ");

						reporter.br();
						if (description !== undefined) {
							reporter.log(description);
						}
						reporter.command(builtCommand);
					}
				},
			);
		}

		commandRequired(foundCommand, {defaultFlags, rawFlags}) {
			if (foundCommand) {
				return;
			}

			const {programName, commandSuggestions} = this.opts;
			let {args} = this;
			let commandName = args.join(" ");
			let displayArgs = [];

			const opts = {
				programName,
				commandName,
				suggestedName: undefined,
				suggestedDescription: undefined,
				suggestedCommand: undefined,
			};

			// If we were provided with a list of command suggestions, try and find one
			if (commandSuggestions !== undefined) {
				for (let i = 0; i < args.length; i++) {
					const possibleCommandName = args.slice(0, i + 1).join(" ");
					const suggestion = commandSuggestions[possibleCommandName];
					if (suggestion !== undefined) {
						commandName = possibleCommandName;
						displayArgs = args.slice(i + 1);

						opts.suggestedName = suggestion.commandName;
						opts.suggestedDescription = suggestion.description;
						break;
					}
				}
			}

			// If we don't have a suggestion then try to find another closest one
			if (opts.suggestedName === undefined) {
				opts.suggestedName = ___R$project$rome$$internal$string$utils$findClosestStringMatch_ts$findClosestStringMatch(
					commandName,
					Array.from(this.commands.keys()),
				);
			}

			// Set suggestedCommand
			if (opts.suggestedName !== undefined) {
				opts.suggestedCommand = ___R$project$rome$$internal$cli$flags$serializeCLIFlags_ts$serializeCLIFlags(
					Object.assign(
						{},
						this.getSerializeOptions(),
						{
							commandName: opts.suggestedName,
							args: displayArgs,
							defaultFlags,
							flags: rawFlags,
						},
					),
					"none",
				).sourceText;
			}

			const diag = {
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.FLAGS.UNKNOWN_COMMAND(
					opts,
				),
				location: ___R$project$rome$$internal$cli$flags$serializeCLIFlags_ts$serializeCLIFlags(
					Object.assign(
						{},
						this.getSerializeOptions(),
						{commandName, args: displayArgs, defaultFlags, flags: rawFlags},
					),
					"command",
				),
			};

			throw new ___R$project$rome$$internal$diagnostics$errors_ts$DiagnosticsError(
				"Unknown command",
				[diag],
			);
		}

		getSerializeOptions() {
			return {
				programName: this.opts.programName,
				commandName: this.currentCommand,
				args: this.args,
				incorrectCaseFlags: this.incorrectCaseFlags,
				shorthandFlags: this.shorthandFlags,
				cwd: this.opts.cwd,
			};
		}

		addCommand(opts) {
			if (this.currentCommand !== undefined) {
				throw new Error("Nested commands aren't allowed");
			}

			this.commands.set(opts.name, opts);
		}

		async defineCommandFlags(command, consumer) {
			this.currentCommand = command.name;

			let flags = {};
			if (command.defineFlags !== undefined) {
				flags = command.defineFlags(consumer);
			}

			this.currentCommand = undefined;

			return flags;
		}

		exit(code) {
			if (!this.opts.noProcessExit) {
				process.exit(code);
			}
		}
	}

	class ___R$project$rome$$internal$cli$flags$Parser_ts$ParserInterface {
		constructor(parser) {
			this.parser = parser;
		}

		init() {
			return this.parser.init();
		}

		showHelp() {
			return this.parser.showHelp();
		}

		getArgs() {
			return this.parser.args;
		}

		command(opts) {
			this.parser.addCommand(opts);
		}
	}


  // project-rome/@internal/cli-flags/index.ts
function ___R$project$rome$$internal$cli$flags$index_ts$parseCLIFlags(opts) {
		const parser = new ___R$project$rome$$internal$cli$flags$Parser_ts$default(
			opts,
		);
		return parser.getInterface();
	}

	function ___R$project$rome$$internal$cli$flags$index_ts$parseCLIFlagsFromProcess(
		opts,
	) {
		let programName;
		let args;

		if (opts.args === undefined) {
			programName = process.argv[1];
			args = process.argv.slice(2);
		} else {
			programName = process.argv.join(" ");
			args = opts.args;
		}

		return ___R$project$rome$$internal$cli$flags$index_ts$parseCLIFlags(
			Object.assign(
				{},
				opts,
				{
					reporter: opts.reporter == null
						? ___R$project$rome$$internal$cli$reporter$Reporter_ts$default.fromProcess()
						: opts.reporter,
					args,
					cwd: opts.cwd == null
						? ___R$project$rome$$internal$path$index_ts$CWD_PATH
						: opts.cwd,
					programName: opts.programName == null ? programName : opts.programName,
				},
			),
		);
	}


  // project-rome/@internal/cli-diagnostics/printAdvice.ts
const ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$DID_PRINT = {
		printed: true,
		truncated: false,
	};

	const ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$DID_NOT_PRINT = {
		printed: false,
		truncated: false,
	};

	function ___R$project$rome$$internal$cli$diagnostics$printAdvice_ts$printAdvice(
		advice,
		opts,
	) {
		let truncated = false;

		for (const item of advice) {
			const res = ___R$project$rome$$internal$cli$diagnostics$printAdvice_ts$printAdviceItem(
				item,
				opts,
			);
			if (res.printed) {
				opts.reporter.br();
			}
			if (res.truncated) {
				truncated = true;
			}
		}

		return {truncated};
	}

	function ___R$project$rome$$internal$cli$diagnostics$printAdvice_ts$printAdviceItem(
		item,
		opts,
	) {
		switch (item.type) {
			case "log":
				return ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$printLog(
					item,
					opts,
				);

			case "action":
				return ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$printAction(
					item,
					opts,
				);

			case "list":
				return ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$printList(
					item,
					opts,
				);

			case "diff":
				return ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$printDiff(
					item,
					opts,
				);

			case "code":
				return ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$printCode(
					item,
					opts,
				);

			case "command":
				return ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$printCommand(
					item,
					opts,
				);

			case "frame":
				return ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$printFrame(
					item,
					opts,
				);

			case "stacktrace":
				return ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$printStacktrace(
					item,
					opts,
				);

			case "inspect":
				return ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$printInspect(
					item,
					opts,
				);

			case "group":
				return ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$printGroup(
					item,
					opts,
				);
		}
	}

	function ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$printGroup(
		item,
		opts,
	) {
		const {reporter} = opts;

		let truncated = false;

		reporter.log(
			___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${item.title}</emphasis>`,
		);
		reporter.br();
		reporter.indentSync(() => {
			({truncated} = ___R$project$rome$$internal$cli$diagnostics$printAdvice_ts$printAdvice(
				item.advice,
				opts,
			));
		});

		return {
			printed: true,
			truncated,
		};
	}

	function ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$printAction(
		item,
		opts,
	) {
		if (item.hidden && !opts.printer.flags.verboseDiagnostics) {
			return ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$DID_NOT_PRINT;
		}

		opts.reporter.info(item.instruction);

		const command = ___R$project$rome$$internal$cli$flags$serializeCLIFlags_ts$serializeCLIFlags(
			{
				programName: "rome",
				commandName: item.command,
				args: item.args == null ? [] : item.args,
				flags: Object.assign({}, item.commandFlags, item.requestFlags),
			},
			"none",
		).sourceText;
		opts.reporter.command(command);
		return ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$DID_PRINT;
	}

	function ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$printCommand(
		item,
		opts,
	) {
		opts.reporter.command(item.command);
		return ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$DID_PRINT;
	}

	function ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$printInspect(
		item,
		opts,
	) {
		const {reporter} = opts;
		reporter.indentSync(() => {
			reporter.inspect(item.data);
		});
		return ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$DID_PRINT;
	}

	function ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$generateDiffHint(
		diffs,
	) {
		let expected = "";
		let received = "";

		for (const [type, text] of diffs) {
			switch (type) {
				case ___R$project$rome$$internal$string$diff$index_ts$diffConstants.ADD: {
					received += text;
					break;
				}

				case ___R$project$rome$$internal$string$diff$index_ts$diffConstants.DELETE: {
					expected += text;
					break;
				}

				case ___R$project$rome$$internal$string$diff$index_ts$diffConstants.EQUAL: {
					expected += text;
					received += text;
					break;
				}
			}
		}

		if (expected.trim() === received.trim()) {
			return {
				type: "log",
				category: "info",
				text: ___R$project$rome$$internal$markup$escape_ts$markup`Only difference is leading and trailing whitespace`,
			};
		}

		const receivedNoCRLF = ___R$project$rome$$internal$string$utils$removeCarriageReturn_ts$removeCarriageReturn(
			received,
		);
		if (expected === receivedNoCRLF) {
			return {
				type: "log",
				category: "info",
				text: ___R$project$rome$$internal$markup$escape_ts$markup`Identical except the received uses CRLF newlines, while the expected does not`,
			};
		}

		const expectedNoCRLF = ___R$project$rome$$internal$string$utils$removeCarriageReturn_ts$removeCarriageReturn(
			expected,
		);
		if (received === expectedNoCRLF) {
			return {
				type: "log",
				category: "info",
				text: ___R$project$rome$$internal$markup$escape_ts$markup`Identical except the expected uses CRLF newlines, while the received does not`,
			};
		}

		return undefined;
	}

	function ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$printDiff(
		item,
		opts,
	) {
		const {frame, truncated} = ___R$project$rome$$internal$cli$diagnostics$buildPatchCodeFrame_ts$default(
			item,
			opts.flags.verboseDiagnostics !== false,
		);
		if (___R$project$rome$$internal$markup$escape_ts$isEmptyMarkup(frame)) {
			return ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$DID_NOT_PRINT;
		}

		opts.reporter.log(frame);

		const hint = ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$generateDiffHint(
			item.diff,
		);
		if (hint !== undefined) {
			opts.reporter.br();
			___R$project$rome$$internal$cli$diagnostics$printAdvice_ts$printAdviceItem(
				hint,
				opts,
			);
			opts.reporter.br();
		}

		return {
			printed: true,
			truncated,
		};
	}

	function ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$printList(
		item,
		opts,
	) {
		if (item.list.length === 0) {
			return ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$DID_NOT_PRINT;
		} else {
			const {truncated} = opts.reporter.list(
				item.list,
				{
					truncate: opts.flags.verboseDiagnostics ? undefined : 10,
					reverse: item.reverse,
					ordered: item.ordered,
				},
			);
			return {
				printed: true,
				truncated,
			};
		}
	}

	function ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$printTruncated(
		reporter,
		chars,
	) {
		reporter.log(
			___R$project$rome$$internal$markup$escape_ts$markup`<dim>${chars} more characters truncated</dim>`,
		);
	}

	function ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$printCode(
		item,
		opts,
	) {
		const {reporter} = opts;

		const truncatedLength =
			!opts.flags.verboseDiagnostics &&
			item.sourceText.length >
			___R$project$rome$$internal$cli$diagnostics$constants_ts$MAX_CODE_LENGTH;
		let code = truncatedLength
			? item.sourceText.slice(
					0,
					___R$project$rome$$internal$cli$diagnostics$constants_ts$MAX_CODE_LENGTH,
				)
			: item.sourceText;

		const {frame, truncated: truncatedLines} = ___R$project$rome$$internal$cli$diagnostics$buildCodeFrame_ts$default({
			type: "all",
			truncateLines: ___R$project$rome$$internal$cli$diagnostics$constants_ts$MAX_CODE_LINES,
			lines: ___R$project$rome$$internal$cli$diagnostics$utils_ts$toLines({
				input: code,
				path: ___R$project$rome$$internal$path$index_ts$createUnknownPath(
					"inline",
				),
				sourceTypeJS: item.sourceTypeJS,
				language: item.language,
				highlight: opts.printer.shouldHighlight(),
			}),
		});
		if (___R$project$rome$$internal$markup$escape_ts$isEmptyMarkup(frame)) {
			return ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$DID_NOT_PRINT;
		}

		reporter.log(frame);

		if (truncatedLength) {
			___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$printTruncated(
				reporter,
				item.sourceText.length -
				___R$project$rome$$internal$cli$diagnostics$constants_ts$MAX_CODE_LENGTH,
			);
		}

		return {
			printed: true,
			truncated: truncatedLines || truncatedLength,
		};
	}

	function ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$printFrame(
		item,
		opts,
	) {
		const {reporter} = opts;
		const {marker, start, end, filename} = item.location;
		let {sourceText} = item.location;
		const path =
			filename === undefined
				? ___R$project$rome$$internal$path$index_ts$createUnknownPath("unknown")
				: opts.printer.createFilePath(filename);

		let lines = [];
		if (sourceText !== undefined) {
			lines = ___R$project$rome$$internal$cli$diagnostics$utils_ts$toLines({
				path,
				input: sourceText,
				sourceTypeJS: item.location.sourceTypeJS,
				language: ___R$project$rome$$internal$core$common$file$handlers$index_ts$inferDiagnosticLanguageFromFilename(
					path,
					item.location.language,
				),
				highlight: opts.printer.shouldHighlight(),
			});
		} else if (filename !== undefined) {
			const source = opts.fileSources.get(path);
			if (source !== undefined) {
				lines = source.lines;
				sourceText = source.sourceText;
			}
		} else if (
			path.isAbsolute() &&
			opts.missingFileSources.has(path.assertAbsolute())
		) {
			return ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$printLog(
				{
					type: "log",
					category: "warn",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`File ${path} does not exist`,
				},
				opts,
			);
		}

		if (sourceText === undefined) {
			sourceText = "";
		}

		const {frame, truncated} = ___R$project$rome$$internal$cli$diagnostics$buildCodeFrame_ts$default({
			type: "pointer",
			lines,
			start,
			end,
			markerMessage: marker,
		});
		if (___R$project$rome$$internal$markup$escape_ts$isEmptyMarkup(frame)) {
			return ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$DID_NOT_PRINT;
		}

		reporter.log(frame);
		return {
			printed: true,
			truncated,
		};
	}

	function ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$printStacktrace(
		item,
		opts,
	) {
		const {diagnostic} = opts;
		const {frames} = item;

		let shownCodeFrames = 0;

		const isFirstPart = diagnostic.description.advice[0] === item;
		if (!isFirstPart) {
			const {title} = item;
			if (title !== undefined) {
				opts.reporter.info(
					___R$project$rome$$internal$markup$escape_ts$markup`${title}`,
				);
				opts.reporter.br({force: true});
			}
		}

		opts.reporter.processedList(
			frames,
			(reporter, frame) => {
				const {
					filename,
					object,
					suffix,
					property,
					language,
					prefix,
					line,
					column,
					sourceText: code,
				} = frame;

				const logParts = [];

				// Add prefix
				if (prefix !== undefined) {
					logParts.push(
						___R$project$rome$$internal$markup$escape_ts$markupTag(
							"dim",
							___R$project$rome$$internal$markup$escape_ts$markup`${prefix}`,
						),
					);
				}

				// Build path
				const objParts = [];
				if (object !== undefined) {
					objParts.push(
						___R$project$rome$$internal$markup$escape_ts$markupTag(
							"highlight",
							___R$project$rome$$internal$markup$escape_ts$markup`${object}`,
							{i: 0},
						),
					);
				}
				if (property !== undefined) {
					objParts.push(
						___R$project$rome$$internal$markup$escape_ts$markupTag(
							"highlight",
							___R$project$rome$$internal$markup$escape_ts$markup`${property}`,
							{i: 1},
						),
					);
				}
				if (objParts.length > 0) {
					logParts.push(
						___R$project$rome$$internal$markup$escape_ts$concatMarkup(
							objParts,
							___R$project$rome$$internal$markup$escape_ts$markup`.`,
						),
					);
				}

				// Add suffix
				if (suffix !== undefined) {
					logParts.push(
						___R$project$rome$$internal$markup$escape_ts$markupTag(
							"success",
							___R$project$rome$$internal$markup$escape_ts$markup`${suffix}`,
						),
					);
				}

				// Add source
				if (filename !== undefined && line !== undefined && column !== undefined) {
					const header = ___R$project$rome$$internal$diagnostics$helpers_ts$diagnosticLocationToMarkupFilelink({
						filename,
						language,
						start: {
							line,
							column,
						},
					});

					if (logParts.length === 0) {
						logParts.push(header);
					} else {
						logParts.push(
							___R$project$rome$$internal$markup$escape_ts$markup`<dim>(${header})</dim>`,
						);
					}
				}

				reporter.log(
					___R$project$rome$$internal$markup$escape_ts$concatMarkup(
						logParts,
						___R$project$rome$$internal$markup$escape_ts$markup` `,
					),
				);

				// A code frame will always be displayed if it's been marked as important on the stackframe advice or if it
				// refers to the diagnostic
				const isImportantStackFrame =
					filename !== undefined &&
					(filename === diagnostic.location.filename ||
					(item.importantFilenames !== undefined &&
					item.importantFilenames.includes(filename)));
				const shouldShowCodeFrame = isImportantStackFrame || shownCodeFrames < 2;

				if (
					shouldShowCodeFrame &&
					filename !== undefined &&
					line !== undefined &&
					column !== undefined
				) {
					const pos = {
						line,
						column,
					};

					const frame = ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$printFrame(
						{
							type: "frame",
							location: {
								filename,
								language,
								sourceTypeJS: "module",
								start: pos,
								end: pos,
								sourceText: code,
							},
						},
						Object.assign({}, opts, {reporter}),
					);
					if (frame.printed && !isImportantStackFrame) {
						shownCodeFrames++;
					}
				}
			},
			{
				ordered: true,
				truncate: opts.flags.verboseDiagnostics ? undefined : 20,
			},
		);

		return ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$DID_PRINT;
	}

	function ___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$printLog(
		item,
		opts,
	) {
		const {reporter} = opts;
		const {category} = item;
		let {text} = item;

		let truncated = false;
		let truncatedLength = 0;
		if (
			___R$project$rome$$internal$markup$escape_ts$readMarkup(text).length >
			___R$project$rome$$internal$cli$diagnostics$constants_ts$MAX_LOG_LENGTH
		) {
			({truncated, text, truncatedLength} = ___R$project$rome$$internal$markup$normalize_ts$normalizeMarkup(
				text,
				{},
				___R$project$rome$$internal$cli$diagnostics$constants_ts$MAX_LOG_LENGTH,
			));
		}

		if (text !== undefined) {
			switch (category) {
				case "none": {
					reporter.log(text);
					break;
				}

				case "warn": {
					reporter.warn(text);
					break;
				}

				case "info": {
					reporter.info(text);
					break;
				}

				case "error": {
					reporter.error(text);
					break;
				}

				default:
					throw new Error("Unknown message item log category " + category);
			}
		}

		if (truncated) {
			___R$$priv$project$rome$$internal$cli$diagnostics$printAdvice_ts$printTruncated(
				reporter,
				truncatedLength,
			);
		}

		return {
			printed: !item.compact,
			truncated,
		};
	}


  // project-rome/@internal/cli-diagnostics/banners/success.json
const ___R$project$rome$$internal$cli$diagnostics$banners$success_json$default = {
		"palettes": [
			[240, 240, 240],
			[240, 240, 225],
			[225, 225, 210],
			[225, 210, 210],
			[240, 225, 225],
			[210, 210, 195],
			[210, 195, 180],
			[195, 195, 165],
			[195, 180, 165],
			[225, 210, 195],
			[195, 195, 180],
			[225, 225, 225],
			[180, 180, 150],
			[180, 165, 150],
			[195, 180, 150],
			[195, 165, 150],
			[180, 165, 135],
			[180, 150, 135],
			[195, 165, 135],
			[225, 225, 195],
			[210, 210, 180],
			[210, 180, 150],
			[210, 180, 165],
			[225, 180, 180],
			[240, 180, 165],
			[240, 195, 195],
			[225, 195, 180],
			[165, 135, 120],
			[165, 150, 120],
			[195, 135, 120],
			[225, 150, 135],
			[240, 165, 165],
			[225, 180, 165],
			[225, 195, 165],
			[150, 120, 105],
			[150, 135, 105],
			[180, 150, 120],
			[195, 120, 105],
			[210, 135, 105],
			[210, 150, 120],
			[195, 150, 135],
			[210, 195, 165],
			[180, 105, 75],
			[195, 105, 90],
			[180, 90, 75],
			[240, 180, 180],
			[240, 225, 210],
			[240, 240, 210],
			[150, 120, 90],
			[180, 135, 120],
			[210, 150, 135],
			[210, 165, 150],
			[195, 150, 120],
			[225, 180, 150],
			[195, 120, 90],
			[180, 105, 90],
			[225, 165, 135],
			[225, 210, 180],
			[240, 210, 195],
			[225, 195, 195],
			[180, 135, 105],
			[225, 180, 135],
			[210, 135, 120],
			[225, 165, 150],
			[240, 180, 150],
			[210, 180, 180],
			[165, 135, 90],
			[180, 120, 90],
			[195, 135, 105],
			[225, 150, 120],
			[180, 135, 135],
			[210, 150, 150],
			[210, 195, 195],
			[210, 195, 210],
			[150, 135, 135],
			[195, 195, 195],
			[225, 210, 225],
			[180, 180, 135],
			[165, 120, 90],
			[240, 150, 135],
			[240, 165, 135],
			[240, 165, 150],
			[180, 90, 60],
			[180, 165, 165],
			[165, 135, 135],
			[180, 180, 180],
			[165, 150, 135],
			[150, 90, 45],
			[150, 75, 45],
			[210, 165, 135],
			[165, 165, 165],
			[165, 120, 75],
			[180, 135, 90],
			[150, 60, 45],
			[165, 105, 60],
			[165, 90, 60],
			[150, 105, 105],
			[210, 210, 210],
			[165, 105, 75],
			[225, 165, 165],
			[180, 120, 75],
			[165, 90, 75],
			[135, 90, 75],
			[195, 180, 180],
			[240, 195, 180],
			[135, 120, 120],
			[165, 135, 105],
			[150, 105, 75],
			[225, 150, 150],
			[240, 210, 180],
			[165, 150, 150],
			[165, 150, 105],
			[225, 135, 120],
			[210, 120, 105],
			[150, 90, 75],
			[180, 120, 105],
			[180, 150, 105],
			[240, 195, 165],
			[180, 165, 120],
			[225, 135, 135],
			[180, 105, 105],
			[195, 120, 120],
			[150, 75, 60],
			[105, 15, 15],
			[105, 15, 0],
			[120, 30, 30],
			[120, 30, 15],
			[105, 45, 30],
			[150, 90, 60],
			[210, 120, 120],
			[165, 75, 75],
			[90, 30, 30],
			[90, 15, 15],
			[120, 15, 30],
			[120, 15, 15],
			[90, 0, 0],
			[135, 45, 45],
			[165, 105, 90],
			[210, 105, 90],
			[135, 75, 45],
			[240, 210, 210],
			[225, 240, 225],
			[60, 30, 15],
			[45, 0, 0],
			[60, 15, 15],
			[75, 30, 15],
			[120, 60, 60],
			[195, 90, 75],
			[150, 45, 45],
			[75, 0, 15],
			[60, 0, 0],
			[75, 0, 0],
			[150, 105, 60],
			[135, 90, 45],
			[60, 45, 30],
			[105, 30, 30],
			[120, 15, 0],
			[150, 75, 75],
			[120, 105, 90],
			[105, 60, 45],
			[120, 75, 45],
			[60, 15, 0],
			[75, 15, 15],
			[105, 30, 15],
			[195, 105, 105],
			[165, 60, 60],
			[135, 15, 15],
			[180, 180, 165],
			[105, 90, 90],
			[30, 15, 15],
			[60, 30, 30],
			[135, 60, 60],
			[150, 45, 30],
			[150, 75, 30],
			[240, 225, 195],
			[75, 15, 0],
			[90, 15, 0],
			[120, 45, 30],
			[240, 150, 150],
			[105, 90, 75],
			[105, 75, 60],
			[105, 105, 105],
			[45, 45, 45],
			[30, 30, 15],
			[180, 60, 45],
			[165, 60, 30],
			[180, 90, 45],
			[135, 75, 30],
			[195, 135, 90],
			[135, 60, 45],
			[135, 75, 60],
			[90, 60, 30],
			[90, 60, 45],
			[30, 15, 0],
			[15, 15, 15],
			[45, 30, 15],
			[195, 90, 60],
			[180, 105, 60],
			[120, 75, 30],
			[105, 60, 30],
			[120, 60, 30],
			[15, 0, 0],
			[75, 45, 45],
			[180, 75, 30],
			[180, 120, 60],
			[90, 45, 30],
			[60, 45, 45],
			[60, 45, 60],
			[45, 30, 30],
			[75, 45, 30],
			[75, 45, 15],
			[195, 105, 75],
			[165, 45, 30],
			[165, 45, 15],
			[30, 0, 15],
			[45, 15, 15],
			[135, 60, 30],
			[210, 105, 60],
			[195, 120, 75],
			[75, 60, 30],
			[120, 120, 105],
			[165, 75, 60],
			[135, 45, 15],
			[195, 60, 45],
			[90, 30, 45],
			[165, 75, 30],
			[135, 90, 60],
			[135, 105, 60],
			[165, 90, 90],
			[120, 45, 45],
			[165, 75, 45],
			[210, 135, 60],
			[135, 90, 30],
			[165, 60, 45],
			[105, 75, 45],
			[195, 135, 45],
			[135, 105, 75],
			[75, 30, 30],
			[135, 105, 90],
			[195, 120, 45],
			[180, 105, 30],
			[135, 120, 90],
			[150, 60, 60],
			[180, 75, 75],
			[150, 60, 15],
			[150, 75, 15],
			[165, 120, 105],
			[180, 90, 90],
			[195, 90, 105],
			[210, 105, 105],
			[0, 0, 0],
			[15, 0, 15],
			[180, 105, 45],
			[120, 60, 45],
			[120, 60, 15],
			[90, 30, 15],
			[30, 0, 0],
			[15, 15, 0],
			[165, 90, 45],
			[180, 90, 30],
			[105, 30, 0],
			[180, 75, 45],
			[135, 45, 0],
			[120, 45, 15],
			[105, 45, 15],
			[45, 15, 0],
			[195, 90, 90],
			[90, 60, 60],
			[120, 75, 60],
			[135, 45, 30],
			[90, 45, 15],
			[225, 240, 240],
			[105, 75, 75],
			[150, 60, 30],
			[165, 180, 180],
			[180, 45, 60],
			[150, 45, 15],
			[135, 135, 135],
			[180, 60, 30],
			[90, 105, 105],
			[150, 135, 120],
			[105, 60, 60],
			[105, 45, 45],
			[225, 150, 105],
			[120, 120, 120],
			[105, 30, 45],
			[210, 150, 105],
			[90, 90, 90],
			[15, 30, 15],
			[45, 0, 15],
			[135, 30, 30],
			[180, 45, 30],
			[135, 30, 15],
			[75, 75, 75],
			[15, 15, 30],
			[0, 0, 15],
			[195, 60, 30],
			[210, 60, 45],
			[195, 90, 45],
			[210, 105, 75],
			[120, 90, 90],
			[45, 30, 45],
			[90, 45, 45],
			[0, 15, 0],
			[195, 75, 45],
			[195, 75, 60],
			[30, 30, 0],
			[135, 120, 105],
			[225, 195, 210],
			[60, 60, 60],
			[0, 15, 15],
			[15, 30, 45],
			[45, 45, 60],
			[30, 15, 30],
			[150, 30, 15],
			[30, 30, 30],
			[90, 75, 90],
			[90, 15, 30],
			[165, 165, 150],
			[120, 105, 60],
			[120, 120, 60],
			[60, 60, 45],
			[30, 45, 30],
			[60, 15, 30],
			[120, 30, 45],
			[60, 30, 45],
			[90, 90, 75],
			[135, 150, 60],
			[90, 90, 30],
			[30, 45, 45],
			[90, 75, 75],
			[120, 105, 105],
			[75, 30, 45],
			[60, 75, 60],
			[75, 15, 30],
			[45, 15, 30],
			[45, 60, 45],
			[120, 120, 90],
			[90, 15, 45],
			[75, 75, 60],
			[150, 150, 135],
			[75, 75, 45],
			[225, 120, 120],
			[75, 60, 60],
			[105, 105, 75],
			[120, 135, 90],
			[90, 90, 60],
			[135, 45, 60],
			[135, 30, 45],
			[75, 90, 75],
			[60, 75, 45],
			[210, 90, 60],
			[120, 45, 60],
			[150, 150, 150],
			[105, 120, 60],
			[105, 105, 60],
			[30, 30, 45],
			[135, 75, 75],
			[150, 45, 60],
			[225, 135, 90],
			[195, 105, 60],
			[195, 210, 195],
			[120, 75, 75],
			[90, 60, 75],
			[195, 135, 75],
			[210, 120, 75],
			[210, 225, 225],
			[150, 75, 90],
			[225, 135, 75],
			[210, 90, 75],
			[165, 120, 120],
			[210, 135, 75],
			[225, 105, 75],
			[180, 75, 60],
			[105, 45, 60],
			[225, 120, 75],
			[150, 90, 30],
			[165, 60, 75],
			[75, 45, 60],
			[225, 105, 60],
			[225, 90, 45],
			[225, 60, 30],
			[150, 30, 30],
			[150, 90, 90],
			[210, 135, 90],
			[150, 135, 90],
			[240, 75, 45],
			[135, 60, 75],
			[150, 105, 90],
			[240, 90, 60],
			[240, 105, 75],
			[210, 105, 45],
			[195, 150, 105],
			[240, 90, 45],
			[210, 120, 90],
			[45, 45, 30],
			[240, 105, 45],
			[210, 120, 45],
			[240, 90, 30],
			[210, 90, 45],
			[225, 120, 90],
			[195, 240, 195],
			[135, 240, 135],
			[75, 255, 60],
			[45, 255, 30],
			[45, 240, 30],
			[90, 225, 60],
			[105, 210, 75],
			[120, 135, 75],
			[195, 165, 165],
			[120, 150, 60],
			[30, 255, 0],
			[180, 180, 105],
			[165, 105, 105],
			[45, 240, 0],
			[45, 210, 0],
			[75, 105, 30],
			[30, 195, 0],
			[30, 225, 0],
			[30, 240, 0],
			[60, 240, 15],
			[90, 225, 30],
			[60, 195, 15],
			[30, 120, 15],
			[45, 105, 30],
			[105, 195, 30],
			[90, 225, 15],
			[75, 240, 30],
			[120, 195, 45],
			[105, 135, 30],
			[150, 165, 75],
			[180, 195, 30],
			[240, 75, 30],
			[165, 165, 45],
			[90, 225, 45],
			[105, 210, 45],
			[195, 165, 90],
			[135, 255, 135],
			[75, 255, 75],
			[90, 255, 90],
			[135, 240, 120],
			[165, 240, 150],
			[225, 240, 210],
			[90, 180, 75],
			[30, 135, 0],
			[135, 165, 45],
			[75, 210, 60],
			[90, 180, 30],
			[45, 210, 15],
			[150, 150, 60],
			[165, 195, 30],
			[225, 135, 60],
			[150, 210, 15],
			[135, 180, 45],
			[135, 225, 60],
			[210, 240, 210],
			[210, 240, 195],
			[195, 225, 195],
			[45, 165, 30],
			[30, 210, 15],
			[30, 150, 15],
			[15, 135, 0],
			[120, 165, 45],
			[45, 195, 15],
			[105, 90, 30],
			[105, 135, 45],
			[120, 180, 45],
			[105, 210, 30],
			[105, 195, 60],
			[120, 210, 45],
			[90, 120, 30],
			[210, 180, 105],
			[180, 180, 90],
			[135, 195, 60],
			[120, 210, 60],
			[135, 165, 60],
			[240, 135, 45],
			[180, 165, 75],
			[120, 165, 75],
			[195, 150, 75],
			[165, 180, 45],
			[120, 225, 30],
			[105, 165, 15],
			[75, 255, 45],
			[165, 240, 165],
			[150, 240, 150],
			[45, 135, 45],
			[30, 210, 0],
			[45, 120, 15],
			[150, 165, 60],
			[135, 195, 30],
			[90, 210, 30],
			[210, 120, 60],
			[135, 225, 105],
			[90, 255, 75],
			[120, 150, 45],
			[150, 240, 135],
			[90, 210, 75],
			[105, 90, 45],
			[60, 210, 15],
			[195, 180, 105],
			[195, 165, 105],
			[150, 165, 45],
			[195, 75, 15],
			[195, 60, 0],
			[135, 210, 15],
			[60, 240, 0],
			[150, 120, 15],
			[60, 195, 0],
			[75, 240, 15],
			[180, 240, 180],
			[105, 255, 90],
			[105, 150, 45],
			[105, 150, 30],
			[60, 240, 30],
			[75, 240, 60],
			[45, 225, 0],
			[150, 120, 75],
			[195, 180, 120],
			[210, 165, 120],
			[180, 165, 105],
			[210, 180, 120],
			[240, 105, 15],
			[165, 180, 30],
			[105, 240, 0],
			[135, 210, 30],
			[150, 165, 15],
			[120, 180, 30],
			[105, 240, 90],
			[60, 255, 45],
			[45, 255, 15],
			[90, 150, 30],
			[90, 240, 75],
			[90, 210, 15],
			[120, 90, 45],
			[105, 225, 60],
			[225, 195, 135],
			[165, 150, 90],
			[150, 165, 90],
			[225, 105, 30],
			[225, 120, 15],
			[120, 210, 15],
			[195, 120, 30],
			[150, 255, 150],
			[75, 135, 15],
			[105, 165, 75],
			[105, 210, 15],
			[180, 150, 90],
			[225, 165, 120],
			[210, 195, 135],
			[165, 135, 75],
			[210, 165, 105],
			[195, 165, 30],
			[75, 240, 0],
			[135, 210, 0],
			[165, 165, 30],
			[120, 165, 105],
			[75, 225, 0],
			[150, 180, 90],
			[180, 195, 105],
			[165, 180, 75],
			[150, 210, 30],
			[90, 240, 0],
			[210, 90, 30],
			[165, 90, 30],
			[195, 150, 90],
			[75, 210, 30],
			[225, 180, 120],
			[180, 135, 75],
			[225, 165, 90],
			[150, 180, 75],
			[225, 90, 30],
			[195, 120, 60],
			[210, 120, 30],
			[210, 180, 30],
			[135, 225, 0],
			[195, 150, 15],
			[225, 75, 30],
			[210, 75, 30],
			[195, 195, 150],
			[60, 255, 30],
			[195, 240, 180],
			[195, 30, 0],
			[165, 30, 15],
			[120, 150, 75],
			[210, 165, 75],
			[225, 165, 60],
			[195, 195, 45],
			[150, 165, 30],
			[195, 135, 60],
			[210, 195, 120],
			[240, 75, 15],
			[225, 150, 15],
			[240, 180, 15],
			[210, 165, 15],
			[210, 165, 45],
			[225, 90, 15],
			[210, 90, 15],
			[240, 120, 30],
			[210, 225, 180],
			[150, 120, 30],
			[45, 75, 0],
			[75, 120, 15],
			[75, 180, 30],
			[75, 195, 15],
			[195, 150, 60],
			[90, 195, 15],
			[120, 210, 30],
			[180, 165, 60],
			[195, 195, 105],
			[150, 225, 90],
			[135, 225, 75],
			[210, 150, 90],
			[195, 180, 30],
			[180, 180, 45],
			[225, 120, 30],
			[165, 195, 0],
			[165, 180, 15],
			[195, 165, 15],
			[225, 180, 30],
			[240, 180, 30],
			[225, 195, 15],
			[150, 225, 15],
			[135, 75, 15],
			[180, 180, 15],
			[195, 135, 30],
			[135, 225, 90],
			[180, 240, 165],
			[105, 255, 105],
			[150, 225, 135],
			[75, 225, 15],
			[195, 150, 45],
			[210, 165, 60],
			[120, 195, 30],
			[120, 225, 60],
			[195, 195, 75],
			[225, 180, 105],
			[225, 180, 45],
			[180, 225, 15],
			[180, 195, 90],
			[195, 210, 180],
			[90, 195, 30],
			[60, 225, 0],
			[105, 195, 45],
			[135, 150, 75],
			[165, 105, 45],
			[150, 135, 30],
			[105, 240, 15],
			[90, 240, 45],
			[195, 210, 105],
			[195, 195, 90],
			[210, 180, 90],
			[210, 195, 45],
			[150, 240, 0],
			[210, 180, 45],
			[225, 150, 90],
			[225, 150, 75],
			[60, 180, 0],
			[75, 210, 15],
			[90, 240, 15],
			[90, 240, 60],
			[210, 135, 45],
			[210, 150, 15],
			[225, 165, 30],
			[120, 90, 75],
			[225, 195, 120],
			[225, 165, 105],
			[240, 195, 30],
			[240, 195, 15],
			[210, 135, 30],
			[240, 165, 60],
			[210, 150, 30],
			[240, 195, 45],
			[240, 210, 30],
			[240, 180, 45],
			[225, 165, 45],
			[225, 150, 45],
			[225, 90, 60],
			[240, 150, 45],
			[150, 105, 45],
			[165, 105, 30],
			[210, 180, 135],
			[225, 195, 45],
			[225, 120, 45],
			[225, 180, 75],
			[225, 135, 30],
			[210, 165, 90],
			[240, 165, 45],
			[210, 105, 30],
			[225, 105, 45],
			[225, 75, 45],
			[225, 135, 45],
			[240, 150, 30],
			[150, 120, 60],
			[165, 120, 60],
			[180, 135, 15],
			[210, 150, 45],
			[225, 165, 75],
			[225, 150, 30],
			[240, 210, 15],
			[195, 90, 30],
			[240, 210, 150],
		],
		"rows": [
			[[0, 95]],
			[[0, 95]],
			[[0, 95]],
			[[0, 25], 1, 1, 2, 1, 1, 3, 4, 1, 1, 5, 5, 2, 0, [1, 3], [0, 54]],
			[[0, 24], 2, 2, 5, 6, 7, 7, 8, 7, 9, 9, 7, 7, 10, 1, 5, 5, 1, [0, 54]],
			[
				[0, 22],
				11,
				1,
				2,
				12,
				6,
				13,
				14,
				15,
				14,
				14,
				13,
				[14, 3],
				8,
				10,
				7,
				10,
				11,
				[0, 54],
			],
			[
				[0, 21],
				11,
				3,
				6,
				7,
				12,
				15,
				[16, 3],
				14,
				14,
				16,
				16,
				[14, 4],
				8,
				8,
				2,
				1,
				1,
				[0, 52],
			],
			[
				[0, 20],
				11,
				2,
				8,
				[14, 3],
				15,
				15,
				16,
				16,
				17,
				18,
				15,
				17,
				[15, 4],
				14,
				8,
				19,
				20,
				20,
				1,
				[0, 18],
				1,
				3,
				3,
				1,
				[0, 29],
			],
			[
				[0, 19],
				11,
				5,
				8,
				14,
				14,
				21,
				22,
				16,
				21,
				14,
				15,
				15,
				17,
				17,
				15,
				17,
				15,
				18,
				15,
				16,
				14,
				8,
				12,
				5,
				1,
				[0, 18],
				23,
				24,
				25,
				26,
				1,
				[0, 28],
			],
			[
				[0, 17],
				1,
				1,
				10,
				12,
				13,
				15,
				14,
				[21, 4],
				18,
				15,
				17,
				15,
				27,
				17,
				28,
				16,
				16,
				15,
				28,
				13,
				16,
				13,
				6,
				5,
				11,
				[0, 16],
				4,
				29,
				30,
				31,
				32,
				4,
				[0, 28],
			],
			[
				[0, 17],
				2,
				10,
				8,
				14,
				16,
				15,
				15,
				21,
				22,
				18,
				22,
				33,
				21,
				14,
				17,
				17,
				34,
				35,
				16,
				15,
				17,
				36,
				17,
				16,
				16,
				13,
				8,
				5,
				[0, 16],
				6,
				37,
				38,
				39,
				30,
				2,
				[0, 28],
			],
			[
				[0, 17],
				11,
				6,
				14,
				16,
				16,
				18,
				40,
				17,
				41,
				17,
				17,
				[22, 3],
				17,
				22,
				21,
				15,
				21,
				15,
				17,
				16,
				36,
				17,
				27,
				16,
				14,
				9,
				1,
				[0, 15],
				6,
				42,
				43,
				37,
				39,
				2,
				[0, 4],
				1,
				1,
				[0, 22],
			],
			[
				[0, 17],
				1,
				10,
				16,
				18,
				15,
				22,
				27,
				27,
				18,
				17,
				17,
				15,
				22,
				22,
				16,
				21,
				15,
				22,
				22,
				21,
				18,
				36,
				36,
				27,
				27,
				16,
				13,
				8,
				5,
				[0, 15],
				8,
				42,
				44,
				43,
				39,
				9,
				0,
				0,
				1,
				26,
				45,
				26,
				46,
				[0, 21],
			],
			[
				[0, 17],
				2,
				47,
				41,
				18,
				15,
				21,
				15,
				48,
				49,
				50,
				51,
				40,
				51,
				40,
				40,
				52,
				40,
				51,
				53,
				51,
				27,
				18,
				18,
				17,
				28,
				16,
				13,
				16,
				10,
				[0, 15],
				15,
				54,
				42,
				55,
				56,
				57,
				1,
				0,
				6,
				56,
				24,
				58,
				59,
				4,
				[0, 20],
			],
			[
				[0, 17],
				11,
				8,
				14,
				[36, 3],
				52,
				60,
				29,
				[50, 5],
				[39, 4],
				52,
				18,
				15,
				21,
				21,
				27,
				27,
				28,
				15,
				16,
				8,
				1,
				[0, 14],
				17,
				54,
				54,
				38,
				61,
				33,
				0,
				1,
				29,
				62,
				63,
				64,
				24,
				65,
				3,
				2,
				1,
				[0, 17],
			],
			[
				[0, 17],
				11,
				8,
				18,
				66,
				67,
				67,
				68,
				39,
				[30, 7],
				62,
				[69, 3],
				40,
				15,
				22,
				18,
				36,
				18,
				15,
				14,
				14,
				8,
				1,
				[0, 14],
				70,
				67,
				67,
				37,
				56,
				53,
				1,
				9,
				55,
				37,
				38,
				38,
				71,
				72,
				73,
				74,
				75,
				3,
				76,
				[0, 15],
			],
			[
				[0, 15],
				1,
				5,
				7,
				77,
				18,
				78,
				54,
				37,
				38,
				69,
				30,
				79,
				80,
				80,
				30,
				80,
				81,
				30,
				69,
				38,
				38,
				52,
				15,
				22,
				22,
				21,
				16,
				16,
				15,
				14,
				14,
				2,
				[0, 14],
				15,
				54,
				42,
				55,
				38,
				30,
				26,
				40,
				42,
				82,
				82,
				54,
				22,
				0,
				83,
				84,
				3,
				76,
				85,
				85,
				2,
				[0, 13],
			],
			[
				[0, 15],
				1,
				19,
				86,
				16,
				18,
				78,
				54,
				38,
				62,
				30,
				81,
				64,
				[81, 3],
				24,
				24,
				63,
				30,
				69,
				38,
				52,
				15,
				14,
				22,
				21,
				14,
				15,
				14,
				15,
				8,
				2,
				[0, 14],
				65,
				38,
				68,
				68,
				39,
				54,
				42,
				67,
				42,
				87,
				88,
				42,
				89,
				26,
				27,
				8,
				4,
				72,
				72,
				90,
				90,
				[0, 13],
			],
			[
				[0, 16],
				1,
				5,
				14,
				36,
				91,
				67,
				38,
				39,
				81,
				[24, 6],
				45,
				24,
				63,
				69,
				38,
				52,
				51,
				21,
				21,
				14,
				[15, 3],
				16,
				14,
				32,
				26,
				46,
				1,
				[0, 11],
				22,
				67,
				67,
				92,
				92,
				42,
				93,
				42,
				94,
				95,
				95,
				54,
				69,
				39,
				39,
				40,
				18,
				96,
				15,
				11,
				97,
				[0, 13],
			],
			[
				[0, 17],
				2,
				7,
				36,
				98,
				54,
				68,
				69,
				81,
				[24, 8],
				81,
				30,
				62,
				29,
				18,
				21,
				51,
				[16, 4],
				18,
				52,
				63,
				31,
				99,
				22,
				46,
				[0, 9],
				9,
				60,
				42,
				98,
				42,
				100,
				42,
				101,
				67,
				98,
				88,
				88,
				67,
				63,
				64,
				81,
				56,
				39,
				67,
				102,
				103,
				11,
				11,
				[0, 12],
			],
			[
				[0, 17],
				2,
				13,
				36,
				98,
				54,
				38,
				39,
				81,
				31,
				31,
				[24, 6],
				64,
				79,
				62,
				62,
				40,
				40,
				51,
				18,
				40,
				36,
				18,
				36,
				52,
				30,
				81,
				31,
				31,
				99,
				23,
				58,
				46,
				4,
				1,
				0,
				1,
				2,
				15,
				60,
				68,
				68,
				42,
				98,
				67,
				37,
				39,
				68,
				98,
				98,
				42,
				39,
				33,
				104,
				64,
				56,
				56,
				39,
				50,
				27,
				105,
				103,
				[0, 12],
			],
			[
				[0, 17],
				2,
				8,
				106,
				107,
				54,
				38,
				39,
				63,
				[31, 3],
				[24, 5],
				81,
				30,
				[62, 3],
				40,
				40,
				18,
				[36, 4],
				60,
				39,
				30,
				81,
				31,
				31,
				24,
				81,
				108,
				50,
				51,
				22,
				51,
				50,
				68,
				68,
				29,
				68,
				37,
				68,
				68,
				29,
				39,
				50,
				78,
				95,
				82,
				39,
				[109, 2],
				63,
				39,
				69,
				56,
				56,
				39,
				96,
				110,
				[0, 12],
			],
			[
				[0, 17],
				1,
				12,
				111,
				98,
				54,
				68,
				39,
				81,
				63,
				[81, 4],
				31,
				24,
				63,
				56,
				112,
				113,
				37,
				37,
				67,
				114,
				78,
				52,
				29,
				[115, 2],
				116,
				52,
				62,
				81,
				81,
				31,
				24,
				64,
				56,
				50,
				39,
				39,
				30,
				56,
				50,
				50,
				29,
				115,
				[67, 4],
				37,
				68,
				68,
				67,
				100,
				89,
				109,
				117,
				39,
				39,
				56,
				63,
				64,
				56,
				49,
				83,
				[0, 12],
			],
			[
				[0, 17],
				1,
				2,
				118,
				98,
				37,
				38,
				62,
				69,
				56,
				81,
				63,
				30,
				119,
				62,
				50,
				120,
				121,
				122,
				123,
				124,
				[125, 2],
				126,
				127,
				78,
				52,
				37,
				44,
				49,
				47,
				22,
				39,
				30,
				81,
				63,
				56,
				50,
				50,
				62,
				68,
				39,
				89,
				56,
				56,
				39,
				67,
				98,
				95,
				[128, 2],
				95,
				94,
				42,
				67,
				68,
				39,
				53,
				64,
				56,
				81,
				[24, 4],
				51,
				5,
				[0, 12],
			],
			[
				[0, 18],
				5,
				118,
				128,
				98,
				101,
				37,
				37,
				62,
				30,
				30,
				129,
				130,
				[131, 2],
				132,
				133,
				134,
				[135, 2],
				123,
				[136, 2],
				137,
				52,
				52,
				38,
				138,
				37,
				3,
				1,
				72,
				49,
				39,
				38,
				39,
				62,
				38,
				38,
				68,
				89,
				89,
				50,
				69,
				62,
				54,
				98,
				94,
				[87, 3],
				[139, 3],
				128,
				92,
				68,
				56,
				30,
				63,
				64,
				24,
				63,
				24,
				24,
				140,
				[0, 12],
			],
			[
				[0, 18],
				141,
				12,
				142,
				143,
				144,
				145,
				146,
				122,
				147,
				44,
				148,
				123,
				149,
				[150, 3],
				[151, 2],
				124,
				136,
				43,
				38,
				37,
				67,
				68,
				37,
				138,
				68,
				13,
				97,
				0,
				4,
				6,
				18,
				60,
				[67, 4],
				68,
				52,
				68,
				68,
				54,
				98,
				128,
				[87, 3],
				128,
				152,
				[128, 2],
				139,
				153,
				98,
				68,
				39,
				30,
				81,
				64,
				64,
				24,
				24,
				32,
				4,
				[0, 11],
			],
			[
				[0, 19],
				5,
				154,
				[143, 4],
				155,
				44,
				112,
				130,
				156,
				124,
				[123, 3],
				[134, 2],
				157,
				62,
				69,
				38,
				54,
				54,
				[38, 3],
				37,
				36,
				5,
				[0, 4],
				1,
				9,
				158,
				159,
				160,
				114,
				[98, 5],
				94,
				[128, 2],
				87,
				[153, 2],
				87,
				139,
				87,
				128,
				139,
				101,
				68,
				62,
				39,
				81,
				64,
				81,
				69,
				98,
				18,
				1,
				[0, 10],
			],
			[
				[0, 19],
				1,
				105,
				[143, 2],
				161,
				162,
				163,
				164,
				81,
				30,
				165,
				156,
				166,
				156,
				166,
				148,
				164,
				30,
				69,
				62,
				37,
				54,
				54,
				62,
				69,
				113,
				68,
				16,
				167,
				2,
				1,
				0,
				0,
				11,
				168,
				169,
				170,
				171,
				172,
				173,
				88,
				128,
				95,
				94,
				98,
				[100, 3],
				[98, 3],
				128,
				[87, 4],
				128,
				68,
				38,
				80,
				63,
				80,
				62,
				78,
				21,
				174,
				[0, 10],
			],
			[
				[0, 19],
				1,
				167,
				161,
				151,
				175,
				176,
				177,
				62,
				178,
				81,
				30,
				[129, 2],
				113,
				62,
				[81, 3],
				30,
				62,
				38,
				37,
				37,
				54,
				62,
				38,
				67,
				48,
				179,
				180,
				16,
				10,
				181,
				182,
				183,
				170,
				136,
				184,
				185,
				186,
				42,
				42,
				[88, 3],
				128,
				95,
				94,
				94,
				[98, 3],
				128,
				[87, 3],
				187,
				128,
				188,
				62,
				81,
				24,
				50,
				107,
				36,
				57,
				1,
				[0, 9],
			],
			[
				[0, 20],
				2,
				114,
				189,
				190,
				101,
				55,
				30,
				81,
				81,
				63,
				30,
				81,
				31,
				24,
				24,
				81,
				81,
				30,
				62,
				38,
				38,
				113,
				54,
				38,
				37,
				43,
				191,
				160,
				145,
				192,
				193,
				194,
				169,
				195,
				145,
				184,
				185,
				196,
				54,
				54,
				42,
				95,
				197,
				94,
				94,
				87,
				87,
				153,
				187,
				198,
				199,
				198,
				160,
				187,
				87,
				187,
				200,
				101,
				37,
				63,
				25,
				104,
				64,
				68,
				16,
				5,
				[0, 9],
			],
			[
				[0, 20],
				1,
				67,
				113,
				30,
				119,
				55,
				112,
				[30, 3],
				62,
				29,
				63,
				24,
				24,
				63,
				30,
				69,
				[38, 3],
				37,
				54,
				37,
				43,
				67,
				127,
				185,
				144,
				194,
				201,
				[169, 2],
				202,
				95,
				203,
				82,
				54,
				68,
				68,
				67,
				94,
				[197, 2],
				204,
				[94, 3],
				128,
				205,
				[206, 2],
				207,
				208,
				154,
				209,
				210,
				205,
				60,
				62,
				63,
				32,
				117,
				89,
				8,
				11,
				[0, 9],
			],
			[
				[0, 20],
				1,
				60,
				211,
				62,
				113,
				44,
				112,
				79,
				30,
				119,
				62,
				62,
				68,
				30,
				80,
				30,
				69,
				69,
				[38, 3],
				37,
				54,
				42,
				82,
				94,
				212,
				213,
				214,
				201,
				[169, 2],
				215,
				131,
				216,
				217,
				218,
				68,
				62,
				68,
				42,
				197,
				42,
				[100, 3],
				98,
				98,
				94,
				128,
				200,
				205,
				[209, 2],
				[205, 2],
				219,
				220,
				1,
				51,
				62,
				32,
				109,
				22,
				1,
				[0, 10],
			],
			[
				[0, 21],
				18,
				100,
				38,
				42,
				122,
				37,
				62,
				37,
				164,
				62,
				30,
				37,
				38,
				69,
				39,
				39,
				38,
				38,
				37,
				37,
				54,
				54,
				42,
				221,
				222,
				223,
				126,
				169,
				194,
				[169, 2],
				224,
				155,
				225,
				186,
				54,
				68,
				29,
				68,
				[42, 3],
				[100, 4],
				98,
				98,
				152,
				87,
				87,
				139,
				187,
				153,
				226,
				227,
				167,
				0,
				3,
				53,
				104,
				58,
				32,
				1,
				[0, 10],
			],
			[
				[0, 21],
				14,
				197,
				54,
				95,
				88,
				[122, 2],
				228,
				55,
				55,
				37,
				37,
				54,
				[38, 4],
				37,
				[54, 4],
				55,
				229,
				212,
				230,
				143,
				[169, 3],
				215,
				180,
				189,
				230,
				231,
				60,
				[68, 3],
				42,
				94,
				42,
				[100, 4],
				91,
				98,
				94,
				87,
				[187, 2],
				232,
				153,
				227,
				48,
				46,
				1,
				4,
				63,
				117,
				104,
				23,
				1,
				[0, 10],
			],
			[
				[0, 21],
				9,
				98,
				42,
				94,
				216,
				95,
				101,
				115,
				55,
				37,
				55,
				55,
				95,
				[38, 3],
				37,
				37,
				54,
				55,
				67,
				54,
				55,
				177,
				233,
				144,
				[169, 2],
				194,
				169,
				215,
				234,
				199,
				216,
				235,
				67,
				[68, 3],
				100,
				94,
				98,
				100,
				67,
				100,
				91,
				91,
				98,
				128,
				87,
				187,
				198,
				232,
				226,
				236,
				5,
				0,
				0,
				1,
				51,
				117,
				104,
				24,
				1,
				[0, 10],
			],
			[
				[0, 21],
				1,
				106,
				98,
				218,
				139,
				95,
				54,
				68,
				37,
				54,
				55,
				55,
				101,
				54,
				38,
				37,
				54,
				54,
				55,
				42,
				42,
				100,
				101,
				127,
				131,
				214,
				169,
				[194, 2],
				169,
				237,
				221,
				82,
				173,
				235,
				128,
				[68, 3],
				100,
				94,
				94,
				98,
				[100, 2],
				91,
				98,
				152,
				87,
				87,
				139,
				232,
				153,
				238,
				20,
				1,
				[0, 3],
				22,
				24,
				24,
				53,
				46,
				[0, 10],
			],
			[
				[0, 22],
				6,
				98,
				218,
				87,
				216,
				177,
				101,
				55,
				228,
				177,
				189,
				190,
				98,
				38,
				54,
				54,
				42,
				98,
				98,
				42,
				42,
				160,
				193,
				201,
				[169, 2],
				[194, 3],
				144,
				95,
				225,
				239,
				240,
				187,
				67,
				68,
				68,
				67,
				[94, 5],
				[128, 2],
				87,
				[187, 3],
				198,
				241,
				2,
				[0, 5],
				72,
				24,
				117,
				32,
				2,
				[0, 10],
			],
			[
				[0, 23],
				17,
				42,
				67,
				128,
				189,
				125,
				242,
				[243, 2],
				130,
				189,
				101,
				54,
				54,
				42,
				98,
				101,
				98,
				42,
				114,
				144,
				[201, 2],
				[169, 2],
				[194, 3],
				170,
				101,
				244,
				245,
				94,
				232,
				160,
				100,
				92,
				67,
				42,
				95,
				87,
				88,
				[139, 2],
				187,
				216,
				[200, 3],
				160,
				9,
				[0, 6],
				2,
				63,
				45,
				58,
				46,
				[0, 10],
			],
			[
				[0, 23],
				4,
				246,
				54,
				67,
				29,
				101,
				247,
				248,
				249,
				130,
				37,
				98,
				188,
				100,
				42,
				95,
				98,
				42,
				98,
				237,
				169,
				250,
				251,
				169,
				[194, 3],
				201,
				193,
				170,
				127,
				252,
				173,
				199,
				253,
				226,
				78,
				137,
				98,
				94,
				128,
				187,
				200,
				254,
				200,
				[254, 2],
				199,
				160,
				255,
				140,
				[0, 7],
				22,
				32,
				26,
				4,
				[0, 10],
			],
			[
				[0, 24],
				2,
				48,
				98,
				37,
				62,
				130,
				129,
				71,
				115,
				62,
				54,
				95,
				42,
				94,
				95,
				42,
				42,
				159,
				256,
				194,
				250,
				194,
				169,
				194,
				[169, 2],
				194,
				257,
				102,
				258,
				203,
				259,
				258,
				216,
				127,
				159,
				128,
				94,
				94,
				[87, 3],
				187,
				216,
				[200, 2],
				159,
				145,
				124,
				6,
				[0, 7],
				1,
				3,
				2,
				1,
				[0, 10],
			],
			[
				[0, 25],
				6,
				226,
				67,
				37,
				37,
				129,
				71,
				121,
				37,
				54,
				101,
				122,
				95,
				95,
				42,
				128,
				215,
				169,
				251,
				256,
				169,
				[194, 6],
				142,
				144,
				260,
				261,
				262,
				263,
				[205, 2],
				264,
				200,
				139,
				187,
				216,
				[200, 2],
				[139, 2],
				199,
				265,
				144,
				124,
				17,
				[0, 21],
			],
			[
				[0, 25],
				1,
				17,
				98,
				42,
				43,
				266,
				[249, 2],
				42,
				54,
				55,
				127,
				122,
				95,
				94,
				205,
				169,
				257,
				251,
				237,
				170,
				[194, 6],
				257,
				267,
				268,
				177,
				93,
				189,
				131,
				162,
				127,
				264,
				260,
				264,
				[263, 2],
				216,
				88,
				253,
				265,
				201,
				144,
				163,
				114,
				1,
				[0, 20],
			],
			[
				[0, 25],
				1,
				2,
				102,
				98,
				101,
				247,
				44,
				221,
				44,
				55,
				98,
				205,
				253,
				122,
				253,
				215,
				194,
				257,
				215,
				268,
				237,
				[194, 6],
				[257, 2],
				209,
				145,
				139,
				264,
				269,
				255,
				162,
				127,
				270,
				264,
				163,
				260,
				263,
				93,
				155,
				215,
				201,
				143,
				134,
				189,
				5,
				[0, 20],
			],
			[
				[0, 26],
				271,
				272,
				98,
				98,
				87,
				226,
				98,
				42,
				42,
				137,
				[131, 2],
				205,
				195,
				169,
				194,
				169,
				202,
				148,
				144,
				194,
				[251, 2],
				[194, 4],
				251,
				201,
				159,
				263,
				177,
				222,
				172,
				124,
				175,
				145,
				163,
				216,
				273,
				230,
				216,
				145,
				195,
				193,
				201,
				123,
				93,
				274,
				[0, 20],
			],
			[
				[0, 26],
				1,
				267,
				190,
				68,
				100,
				67,
				67,
				54,
				67,
				190,
				144,
				142,
				265,
				[169, 2],
				201,
				215,
				267,
				275,
				144,
				[194, 8],
				193,
				144,
				255,
				264,
				263,
				276,
				185,
				172,
				263,
				126,
				173,
				258,
				88,
				255,
				145,
				142,
				215,
				257,
				161,
				269,
				277,
				[0, 20],
			],
			[
				[0, 25],
				1,
				15,
				125,
				142,
				246,
				98,
				42,
				95,
				55,
				98,
				205,
				215,
				237,
				142,
				169,
				194,
				169,
				170,
				272,
				134,
				215,
				[194, 8],
				214,
				237,
				256,
				131,
				126,
				269,
				273,
				278,
				217,
				258,
				216,
				200,
				163,
				264,
				270,
				145,
				144,
				257,
				256,
				216,
				279,
				[0, 20],
			],
			[
				[0, 24],
				1,
				280,
				148,
				162,
				169,
				237,
				190,
				94,
				88,
				139,
				205,
				144,
				237,
				255,
				161,
				[194, 2],
				215,
				237,
				281,
				127,
				215,
				[194, 2],
				251,
				[194, 5],
				256,
				282,
				170,
				[256, 2],
				265,
				175,
				230,
				203,
				283,
				101,
				270,
				177,
				[264, 2],
				255,
				142,
				194,
				145,
				233,
				182,
				11,
				[0, 19],
			],
			[
				[0, 23],
				11,
				284,
				282,
				132,
				169,
				194,
				169,
				205,
				87,
				139,
				199,
				255,
				177,
				155,
				145,
				193,
				194,
				[215, 2],
				155,
				285,
				237,
				169,
				[194, 6],
				251,
				194,
				214,
				282,
				205,
				[201, 2],
				256,
				215,
				155,
				185,
				211,
				286,
				98,
				127,
				[264, 2],
				270,
				142,
				251,
				177,
				222,
				169,
				97,
				[0, 19],
			],
			[
				[0, 22],
				11,
				287,
				144,
				215,
				257,
				[194, 2],
				169,
				145,
				198,
				187,
				200,
				216,
				222,
				163,
				162,
				169,
				250,
				288,
				145,
				229,
				155,
				170,
				[194, 9],
				251,
				255,
				253,
				144,
				[250, 2],
				251,
				289,
				290,
				291,
				196,
				69,
				226,
				[127, 2],
				270,
				142,
				256,
				292,
				216,
				183,
				75,
				[0, 19],
			],
			[
				[0, 21],
				97,
				293,
				[169, 2],
				201,
				194,
				257,
				194,
				294,
				169,
				205,
				200,
				216,
				95,
				216,
				163,
				205,
				214,
				250,
				215,
				134,
				292,
				255,
				215,
				[194, 5],
				251,
				[194, 4],
				265,
				253,
				127,
				193,
				250,
				295,
				201,
				143,
				233,
				296,
				69,
				37,
				255,
				205,
				270,
				142,
				162,
				172,
				264,
				257,
				75,
				[0, 19],
			],
			[
				[0, 20],
				11,
				293,
				194,
				169,
				250,
				[194, 4],
				294,
				194,
				193,
				215,
				131,
				221,
				93,
				190,
				192,
				201,
				250,
				289,
				123,
				273,
				255,
				208,
				169,
				[194, 5],
				251,
				[194, 3],
				193,
				127,
				177,
				145,
				201,
				[250, 2],
				201,
				131,
				297,
				298,
				299,
				253,
				142,
				205,
				215,
				126,
				225,
				199,
				288,
				85,
				[0, 19],
			],
			[
				[0, 20],
				284,
				[194, 2],
				169,
				201,
				[194, 2],
				251,
				[194, 2],
				[169, 2],
				194,
				144,
				177,
				101,
				22,
				300,
				[250, 2],
				251,
				301,
				302,
				145,
				169,
				[194, 6],
				[251, 2],
				[194, 2],
				257,
				144,
				189,
				253,
				215,
				201,
				303,
				250,
				251,
				290,
				304,
				305,
				255,
				265,
				151,
				163,
				263,
				255,
				306,
				257,
				75,
				[0, 19],
			],
			[
				[0, 19],
				85,
				169,
				[194, 5],
				251,
				201,
				251,
				[194, 2],
				[169, 3],
				307,
				59,
				308,
				309,
				[201, 2],
				310,
				311,
				312,
				313,
				[169, 3],
				[194, 3],
				257,
				[194, 5],
				214,
				302,
				253,
				155,
				256,
				201,
				250,
				295,
				214,
				82,
				223,
				[134, 2],
				314,
				123,
				169,
				194,
				169,
				315,
				85,
				[0, 19],
			],
			[
				[0, 18],
				97,
				315,
				[194, 3],
				182,
				181,
				168,
				206,
				[194, 7],
				316,
				73,
				103,
				194,
				[201, 2],
				[194, 2],
				294,
				194,
				[169, 4],
				215,
				162,
				317,
				162,
				215,
				256,
				[194, 3],
				215,
				[253, 2],
				145,
				256,
				169,
				265,
				256,
				145,
				296,
				213,
				184,
				177,
				169,
				313,
				315,
				313,
				301,
				318,
				[0, 19],
			],
			[
				[0, 17],
				97,
				287,
				[194, 2],
				169,
				315,
				287,
				319,
				320,
				321,
				322,
				[194, 3],
				251,
				[194, 3],
				83,
				110,
				257,
				201,
				250,
				194,
				[169, 7],
				323,
				155,
				324,
				136,
				253,
				285,
				289,
				256,
				[194, 2],
				209,
				253,
				229,
				144,
				194,
				215,
				162,
				144,
				273,
				298,
				263,
				[169, 2],
				[194, 2],
				315,
				325,
				277,
				[0, 19],
			],
			[
				[0, 16],
				2,
				309,
				[194, 3],
				313,
				309,
				326,
				327,
				328,
				321,
				329,
				[194, 7],
				330,
				331,
				201,
				[250, 2],
				[194, 2],
				[169, 10],
				215,
				302,
				229,
				162,
				169,
				194,
				214,
				229,
				160,
				159,
				289,
				251,
				143,
				155,
				317,
				142,
				169,
				208,
				332,
				[194, 2],
				215,
				170,
				277,
				[0, 19],
			],
			[
				[0, 15],
				141,
				287,
				[194, 2],
				294,
				194,
				315,
				[333, 3],
				309,
				333,
				182,
				315,
				194,
				169,
				[194, 4],
				251,
				169,
				295,
				250,
				[194, 2],
				[169, 8],
				[313, 3],
				[169, 2],
				145,
				229,
				255,
				214,
				194,
				144,
				160,
				139,
				200,
				144,
				313,
				334,
				189,
				162,
				215,
				335,
				146,
				215,
				194,
				224,
				317,
				287,
				[0, 19],
			],
			[
				[0, 15],
				85,
				169,
				170,
				[169, 3],
				315,
				207,
				309,
				336,
				326,
				337,
				326,
				182,
				[194, 6],
				201,
				144,
				256,
				303,
				194,
				[169, 10],
				[313, 3],
				183,
				313,
				144,
				253,
				131,
				214,
				194,
				205,
				[128, 2],
				253,
				335,
				313,
				159,
				242,
				144,
				294,
				302,
				170,
				169,
				282,
				338,
				309,
				141,
				[0, 18],
			],
			[
				[0, 15],
				168,
				96,
				121,
				180,
				[169, 2],
				315,
				309,
				339,
				337,
				340,
				220,
				341,
				182,
				[194, 7],
				144,
				237,
				144,
				193,
				194,
				[169, 10],
				[313, 2],
				169,
				[313, 2],
				144,
				253,
				127,
				169,
				144,
				190,
				[107, 2],
				136,
				334,
				170,
				242,
				177,
				[215, 2],
				267,
				215,
				229,
				131,
				206,
				3,
				[0, 18],
			],
			[
				[0, 14],
				11,
				208,
				120,
				342,
				228,
				215,
				169,
				194,
				343,
				344,
				345,
				346,
				287,
				293,
				321,
				[194, 5],
				251,
				194,
				257,
				162,
				347,
				237,
				[169, 9],
				[313, 6],
				315,
				313,
				237,
				189,
				255,
				215,
				237,
				98,
				91,
				196,
				348,
				335,
				302,
				122,
				132,
				183,
				302,
				237,
				347,
				317,
				170,
				103,
				[0, 18],
			],
			[
				[0, 14],
				97,
				251,
				120,
				112,
				55,
				142,
				294,
				194,
				315,
				309,
				333,
				349,
				[350, 2],
				182,
				315,
				[194, 6],
				257,
				256,
				127,
				282,
				169,
				313,
				[169, 2],
				313,
				[169, 2],
				[313, 3],
				[169, 2],
				[313, 5],
				315,
				127,
				171,
				144,
				208,
				159,
				196,
				351,
				101,
				282,
				144,
				171,
				136,
				169,
				131,
				224,
				352,
				237,
				208,
				105,
				[0, 18],
			],
			[
				[0, 14],
				353,
				169,
				115,
				62,
				43,
				145,
				294,
				169,
				315,
				301,
				329,
				350,
				354,
				355,
				287,
				356,
				201,
				[194, 7],
				215,
				229,
				[169, 2],
				215,
				237,
				335,
				169,
				183,
				315,
				313,
				[183, 2],
				315,
				[313, 2],
				169,
				313,
				335,
				313,
				208,
				357,
				146,
				183,
				144,
				351,
				196,
				78,
				101,
				317,
				170,
				358,
				144,
				237,
				334,
				144,
				224,
				208,
				343,
				2,
				[0, 17],
			],
			[
				[0, 13],
				11,
				182,
				209,
				62,
				62,
				44,
				142,
				294,
				[169, 2],
				183,
				315,
				309,
				326,
				168,
				287,
				194,
				201,
				[194, 5],
				169,
				194,
				169,
				282,
				142,
				169,
				215,
				224,
				335,
				208,
				323,
				335,
				215,
				313,
				[335, 2],
				313,
				169,
				[313, 2],
				[335, 2],
				315,
				170,
				228,
				131,
				170,
				359,
				360,
				78,
				91,
				122,
				162,
				131,
				237,
				335,
				208,
				170,
				157,
				209,
				170,
				10,
				[0, 17],
			],
			[
				[0, 13],
				361,
				194,
				362,
				62,
				38,
				114,
				193,
				[169, 2],
				[194, 3],
				182,
				363,
				330,
				315,
				194,
				251,
				[194, 6],
				[169, 2],
				282,
				177,
				169,
				215,
				282,
				323,
				332,
				352,
				171,
				229,
				131,
				215,
				[313, 5],
				[335, 2],
				313,
				315,
				302,
				228,
				145,
				364,
				365,
				101,
				78,
				91,
				165,
				162,
				142,
				[215, 2],
				170,
				165,
				282,
				208,
				74,
				[0, 17],
			],
			[
				[0, 13],
				366,
				154,
				37,
				62,
				37,
				146,
				194,
				[169, 3],
				[194, 2],
				201,
				[169, 4],
				[194, 4],
				[251, 2],
				[194, 3],
				237,
				122,
				145,
				215,
				352,
				131,
				215,
				313,
				144,
				282,
				189,
				282,
				145,
				169,
				[313, 2],
				335,
				313,
				[335, 2],
				208,
				195,
				[367, 2],
				94,
				368,
				172,
				55,
				211,
				351,
				369,
				299,
				94,
				195,
				215,
				242,
				131,
				208,
				168,
				1,
				[0, 16],
			],
			[
				[0, 12],
				1,
				2,
				49,
				30,
				39,
				78,
				237,
				251,
				[169, 3],
				194,
				257,
				250,
				289,
				[169, 2],
				194,
				169,
				251,
				[194, 3],
				251,
				194,
				169,
				313,
				215,
				[171, 2],
				142,
				334,
				171,
				144,
				313,
				315,
				215,
				335,
				237,
				[282, 2],
				144,
				313,
				335,
				315,
				215,
				323,
				[208, 2],
				202,
				370,
				102,
				371,
				196,
				148,
				196,
				360,
				196,
				299,
				364,
				101,
				215,
				282,
				352,
				169,
				206,
				2,
				[0, 16],
			],
			[
				[0, 11],
				1,
				20,
				246,
				98,
				54,
				68,
				114,
				215,
				251,
				[169, 3],
				194,
				[201, 2],
				323,
				169,
				313,
				[169, 2],
				251,
				169,
				[194, 3],
				[169, 2],
				313,
				169,
				237,
				157,
				171,
				144,
				347,
				171,
				[335, 2],
				[313, 2],
				169,
				215,
				282,
				189,
				237,
				313,
				169,
				334,
				224,
				[335, 2],
				195,
				96,
				78,
				82,
				372,
				172,
				102,
				106,
				55,
				157,
				145,
				190,
				281,
				215,
				146,
				323,
				315,
				5,
				[0, 16],
			],
			[
				[0, 11],
				72,
				107,
				42,
				95,
				128,
				55,
				190,
				256,
				310,
				251,
				169,
				194,
				251,
				201,
				256,
				317,
				[169, 4],
				[194, 2],
				[169, 2],
				[194, 2],
				313,
				169,
				313,
				335,
				159,
				130,
				229,
				237,
				101,
				131,
				313,
				315,
				169,
				335,
				195,
				215,
				[189, 2],
				162,
				169,
				282,
				131,
				215,
				323,
				162,
				122,
				42,
				101,
				[360, 2],
				163,
				246,
				67,
				228,
				324,
				335,
				170,
				208,
				237,
				224,
				335,
				340,
				[0, 16],
			],
			[
				[0, 10],
				46,
				137,
				82,
				211,
				43,
				122,
				128,
				226,
				193,
				310,
				201,
				257,
				[251, 3],
				144,
				285,
				256,
				169,
				313,
				169,
				313,
				194,
				313,
				169,
				[194, 2],
				315,
				183,
				315,
				335,
				302,
				247,
				171,
				162,
				44,
				347,
				[313, 3],
				[208, 3],
				282,
				44,
				189,
				215,
				155,
				131,
				237,
				229,
				44,
				147,
				[351, 2],
				261,
				365,
				373,
				253,
				78,
				137,
				130,
				323,
				313,
				285,
				144,
				374,
				206,
				321,
				11,
				[0, 15],
			],
			[
				[0, 9],
				1,
				28,
				258,
				95,
				95,
				112,
				42,
				128,
				268,
				[201, 4],
				[251, 2],
				194,
				334,
				324,
				256,
				194,
				[169, 2],
				313,
				194,
				[169, 3],
				214,
				[194, 3],
				214,
				302,
				171,
				145,
				144,
				242,
				136,
				215,
				315,
				[208, 4],
				237,
				228,
				221,
				317,
				155,
				189,
				[195, 2],
				215,
				144,
				157,
				43,
				211,
				138,
				375,
				273,
				228,
				48,
				44,
				285,
				208,
				229,
				282,
				352,
				282,
				136,
				103,
				[0, 15],
			],
			[
				[0, 9],
				14,
				376,
				42,
				67,
				95,
				43,
				42,
				101,
				237,
				257,
				201,
				142,
				169,
				201,
				251,
				194,
				237,
				324,
				193,
				[194, 2],
				[169, 2],
				313,
				[169, 2],
				335,
				323,
				[169, 2],
				335,
				237,
				137,
				228,
				170,
				208,
				114,
				101,
				155,
				301,
				335,
				[313, 2],
				169,
				144,
				190,
				221,
				324,
				302,
				130,
				334,
				[335, 3],
				202,
				115,
				67,
				43,
				365,
				217,
				93,
				107,
				98,
				347,
				215,
				242,
				155,
				377,
				157,
				184,
				370,
				[0, 15],
			],
			[
				[0, 8],
				9,
				88,
				261,
				43,
				54,
				68,
				37,
				54,
				98,
				268,
				209,
				265,
				205,
				170,
				201,
				[295, 2],
				237,
				324,
				193,
				251,
				194,
				[169, 2],
				313,
				[169, 2],
				215,
				237,
				313,
				315,
				215,
				142,
				98,
				101,
				142,
				208,
				146,
				55,
				242,
				[208, 2],
				335,
				315,
				183,
				215,
				242,
				95,
				136,
				205,
				130,
				155,
				208,
				315,
				335,
				195,
				102,
				106,
				78,
				95,
				299,
				351,
				197,
				98,
				130,
				162,
				130,
				131,
				253,
				44,
				82,
				127,
				4,
				[0, 14],
			],
			[
				[0, 7],
				2,
				236,
				230,
				95,
				43,
				54,
				67,
				54,
				38,
				38,
				68,
				68,
				67,
				114,
				159,
				142,
				201,
				250,
				265,
				155,
				215,
				251,
				[194, 2],
				[169, 2],
				315,
				169,
				144,
				131,
				294,
				313,
				378,
				363,
				98,
				211,
				229,
				145,
				323,
				101,
				44,
				125,
				208,
				301,
				170,
				[208, 2],
				157,
				55,
				221,
				145,
				228,
				148,
				144,
				[315, 2],
				335,
				170,
				48,
				78,
				78,
				82,
				379,
				304,
				373,
				130,
				131,
				130,
				125,
				317,
				373,
				304,
				165,
				5,
				[0, 14],
			],
			[
				[0, 7],
				6,
				87,
				173,
				95,
				54,
				37,
				55,
				54,
				38,
				38,
				62,
				39,
				30,
				69,
				38,
				29,
				246,
				281,
				201,
				237,
				144,
				[251, 2],
				194,
				[169, 2],
				208,
				315,
				131,
				253,
				214,
				313,
				325,
				343,
				128,
				95,
				130,
				228,
				282,
				229,
				101,
				122,
				131,
				325,
				285,
				[170, 2],
				101,
				67,
				247,
				131,
				357,
				266,
				131,
				170,
				[315, 2],
				335,
				159,
				66,
				246,
				98,
				217,
				379,
				297,
				373,
				125,
				101,
				290,
				317,
				290,
				304,
				351,
				103,
				[0, 14],
			],
			[
				[0, 6],
				4,
				280,
				88,
				173,
				95,
				113,
				38,
				38,
				42,
				101,
				42,
				54,
				68,
				62,
				62,
				38,
				39,
				108,
				30,
				202,
				256,
				170,
				169,
				[194, 3],
				294,
				313,
				315,
				229,
				130,
				289,
				[313, 2],
				208,
				102,
				101,
				155,
				268,
				55,
				253,
				190,
				137,
				157,
				133,
				229,
				323,
				155,
				44,
				67,
				247,
				131,
				237,
				[247, 2],
				131,
				208,
				[301, 2],
				170,
				236,
				106,
				66,
				211,
				379,
				380,
				381,
				382,
				101,
				136,
				[215, 2],
				216,
				304,
				83,
				[0, 14],
			],
			[
				[0, 6],
				3,
				236,
				173,
				87,
				94,
				54,
				37,
				38,
				38,
				62,
				38,
				55,
				122,
				189,
				122,
				114,
				55,
				50,
				62,
				202,
				201,
				[215, 2],
				257,
				[194, 2],
				[169, 3],
				282,
				130,
				215,
				313,
				315,
				335,
				357,
				247,
				285,
				144,
				226,
				42,
				177,
				383,
				98,
				305,
				136,
				323,
				155,
				147,
				188,
				384,
				93,
				237,
				282,
				43,
				157,
				170,
				[208, 3],
				209,
				106,
				385,
				211,
				380,
				372,
				386,
				223,
				130,
				387,
				215,
				313,
				215,
				185,
				89,
				[0, 14],
			],
			[
				[0, 6],
				5,
				36,
				88,
				87,
				98,
				54,
				42,
				42,
				54,
				38,
				39,
				30,
				56,
				39,
				115,
				388,
				268,
				159,
				237,
				215,
				[201, 2],
				215,
				169,
				201,
				194,
				[169, 3],
				282,
				242,
				323,
				[313, 2],
				215,
				281,
				44,
				189,
				215,
				142,
				98,
				221,
				177,
				98,
				188,
				95,
				170,
				215,
				157,
				94,
				54,
				54,
				101,
				155,
				268,
				55,
				189,
				142,
				[208, 2],
				237,
				102,
				60,
				211,
				389,
				390,
				379,
				391,
				197,
				221,
				162,
				335,
				313,
				162,
				373,
				9,
				[0, 13],
			],
			[
				[0, 6],
				83,
				48,
				88,
				88,
				95,
				54,
				54,
				42,
				44,
				54,
				54,
				68,
				[39, 4],
				50,
				63,
				246,
				265,
				169,
				201,
				169,
				215,
				144,
				193,
				[215, 2],
				169,
				237,
				228,
				237,
				313,
				169,
				215,
				237,
				114,
				122,
				170,
				313,
				253,
				211,
				155,
				190,
				392,
				42,
				136,
				334,
				190,
				91,
				101,
				122,
				42,
				44,
				125,
				107,
				91,
				200,
				334,
				155,
				224,
				255,
				44,
				82,
				[393, 2],
				365,
				394,
				371,
				373,
				127,
				[144, 2],
				170,
				131,
				37,
				47,
				[0, 12],
			],
			[
				[0, 6],
				72,
				281,
				[216, 2],
				88,
				98,
				113,
				68,
				78,
				42,
				221,
				128,
				98,
				67,
				43,
				37,
				62,
				63,
				115,
				161,
				145,
				331,
				395,
				143,
				145,
				162,
				237,
				282,
				334,
				215,
				[114, 2],
				323,
				313,
				335,
				215,
				190,
				101,
				131,
				335,
				237,
				82,
				93,
				237,
				38,
				100,
				373,
				131,
				159,
				66,
				137,
				165,
				190,
				78,
				101,
				229,
				137,
				42,
				253,
				242,
				334,
				173,
				196,
				211,
				396,
				393,
				217,
				37,
				371,
				211,
				233,
				101,
				233,
				125,
				144,
				136,
				89,
				[0, 12],
			],
			[
				[0, 6],
				11,
				202,
				253,
				88,
				139,
				216,
				114,
				33,
				51,
				30,
				108,
				39,
				54,
				137,
				146,
				132,
				127,
				146,
				255,
				175,
				161,
				5,
				181,
				289,
				[255, 2],
				215,
				323,
				282,
				237,
				159,
				247,
				136,
				208,
				335,
				208,
				205,
				98,
				189,
				215,
				208,
				95,
				221,
				144,
				98,
				188,
				95,
				357,
				131,
				246,
				78,
				101,
				317,
				101,
				91,
				189,
				146,
				67,
				365,
				221,
				132,
				397,
				244,
				373,
				393,
				398,
				399,
				115,
				188,
				359,
				261,
				189,
				298,
				400,
				139,
				162,
				230,
				59,
				[0, 11],
			],
			[
				0,
				0,
				401,
				402,
				403,
				404,
				403,
				405,
				406,
				407,
				408,
				357,
				409,
				13,
				410,
				[411, 3],
				412,
				30,
				30,
				413,
				151,
				414,
				[411, 2],
				415,
				11,
				284,
				256,
				255,
				127,
				416,
				417,
				418,
				414,
				419,
				420,
				421,
				422,
				423,
				335,
				208,
				137,
				101,
				334,
				424,
				425,
				426,
				[414, 2],
				427,
				426,
				428,
				429,
				98,
				78,
				430,
				[411, 9],
				431,
				259,
				292,
				380,
				432,
				433,
				434,
				420,
				414,
				[420, 2],
				426,
				435,
				436,
				177,
				282,
				42,
				174,
				401,
				437,
				438,
				404,
				403,
				439,
				440,
				441,
				442,
				0,
			],
			[
				0,
				441,
				[411, 8],
				443,
				272,
				300,
				202,
				444,
				[411, 3],
				445,
				101,
				62,
				120,
				151,
				414,
				[411, 2],
				446,
				0,
				90,
				201,
				205,
				447,
				419,
				[411, 7],
				448,
				323,
				208,
				357,
				37,
				447,
				419,
				[411, 7],
				421,
				122,
				78,
				449,
				[411, 9],
				450,
				451,
				126,
				217,
				452,
				[411, 8],
				453,
				360,
				162,
				173,
				454,
				[411, 8],
				401,
				0,
			],
			[
				455,
				[411, 2],
				403,
				456,
				1,
				1,
				457,
				458,
				459,
				460,
				208,
				[201, 2],
				461,
				[411, 3],
				462,
				200,
				255,
				162,
				175,
				414,
				[411, 2],
				440,
				0,
				75,
				201,
				463,
				[411, 3],
				459,
				423,
				191,
				464,
				465,
				466,
				467,
				334,
				208,
				237,
				468,
				[411, 3],
				469,
				470,
				199,
				471,
				472,
				473,
				474,
				136,
				60,
				475,
				[411, 3],
				475,
				221,
				190,
				115,
				128,
				114,
				100,
				476,
				203,
				477,
				[411, 2],
				420,
				478,
				78,
				226,
				479,
				480,
				481,
				482,
				211,
				200,
				429,
				[411, 2],
				483,
				455,
				1,
				1,
				442,
				401,
				402,
				401,
				0,
			],
			[
				484,
				[411, 2],
				485,
				[0, 3],
				1,
				340,
				193,
				[251, 2],
				295,
				310,
				461,
				[411, 3],
				462,
				253,
				145,
				144,
				161,
				414,
				[411, 2],
				402,
				0,
				0,
				486,
				[411, 3],
				487,
				313,
				169,
				162,
				136,
				162,
				190,
				55,
				229,
				144,
				488,
				[411, 3],
				454,
				100,
				253,
				130,
				68,
				61,
				188,
				92,
				221,
				98,
				430,
				[411, 3],
				489,
				44,
				163,
				388,
				137,
				132,
				128,
				391,
				399,
				490,
				[411, 2],
				491,
				128,
				114,
				139,
				365,
				492,
				[298, 2],
				189,
				42,
				422,
				[411, 2],
				493,
				[0, 8],
			],
			[
				441,
				[411, 2],
				494,
				442,
				[0, 3],
				11,
				179,
				195,
				[201, 3],
				444,
				[411, 3],
				495,
				253,
				142,
				215,
				161,
				419,
				[411, 2],
				496,
				0,
				0,
				497,
				[411, 2],
				419,
				498,
				[169, 2],
				317,
				377,
				131,
				268,
				107,
				98,
				177,
				499,
				[411, 2],
				414,
				500,
				392,
				101,
				[114, 2],
				152,
				91,
				501,
				286,
				101,
				327,
				[411, 3],
				502,
				373,
				172,
				189,
				197,
				131,
				127,
				503,
				504,
				505,
				[411, 2],
				506,
				507,
				185,
				82,
				492,
				196,
				503,
				298,
				189,
				211,
				508,
				[411, 2],
				509,
				456,
				[0, 7],
			],
			[
				510,
				[411, 4],
				511,
				441,
				401,
				141,
				10,
				234,
				191,
				[205, 2],
				512,
				[411, 3],
				513,
				199,
				142,
				161,
				144,
				514,
				[411, 2],
				496,
				0,
				0,
				515,
				[411, 2],
				516,
				228,
				202,
				169,
				285,
				243,
				282,
				302,
				517,
				92,
				216,
				420,
				[411, 2],
				421,
				518,
				519,
				[60, 3],
				106,
				66,
				520,
				521,
				92,
				327,
				[411, 3],
				489,
				373,
				189,
				42,
				239,
				273,
				127,
				298,
				522,
				523,
				[411, 4],
				524,
				525,
				526,
				376,
				391,
				186,
				122,
				365,
				527,
				[411, 4],
				528,
				441,
				401,
				141,
				[0, 3],
			],
			[
				141,
				529,
				[411, 6],
				530,
				485,
				12,
				199,
				127,
				177,
				429,
				[411, 3],
				531,
				179,
				340,
				83,
				103,
				532,
				[411, 2],
				496,
				0,
				0,
				[411, 3],
				533,
				216,
				268,
				170,
				229,
				130,
				282,
				237,
				78,
				116,
				534,
				[411, 3],
				535,
				521,
				536,
				392,
				60,
				60,
				78,
				78,
				66,
				521,
				537,
				538,
				[411, 9],
				163,
				221,
				539,
				540,
				506,
				[411, 6],
				419,
				541,
				542,
				186,
				211,
				239,
				506,
				[411, 6],
				530,
				543,
				0,
				0,
			],
			[
				0,
				455,
				494,
				[411, 7],
				402,
				6,
				180,
				270,
				544,
				[411, 3],
				545,
				3,
				[0, 3],
				494,
				[411, 2],
				496,
				0,
				0,
				[411, 3],
				546,
				273,
				192,
				323,
				131,
				242,
				155,
				208,
				92,
				547,
				227,
				[411, 3],
				491,
				548,
				549,
				392,
				92,
				[78, 3],
				550,
				551,
				537,
				538,
				[411, 9],
				225,
				122,
				298,
				398,
				552,
				553,
				[411, 7],
				554,
				380,
				351,
				196,
				555,
				553,
				[411, 7],
				496,
				0,
			],
			[
				[0, 3],
				401,
				485,
				494,
				[411, 5],
				141,
				3,
				220,
				556,
				[411, 3],
				401,
				[0, 4],
				494,
				[411, 2],
				496,
				0,
				0,
				532,
				[411, 2],
				557,
				82,
				127,
				317,
				215,
				189,
				155,
				335,
				67,
				392,
				78,
				414,
				[411, 2],
				421,
				68,
				549,
				519,
				91,
				66,
				78,
				66,
				66,
				501,
				66,
				558,
				[411, 3],
				559,
				269,
				142,
				209,
				139,
				451,
				298,
				304,
				360,
				365,
				364,
				92,
				560,
				561,
				562,
				[411, 5],
				540,
				380,
				[196, 2],
				563,
				480,
				525,
				427,
				[411, 5],
				141,
			],
			[
				[0, 6],
				141,
				402,
				[411, 3],
				455,
				0,
				0,
				442,
				[411, 3],
				401,
				[0, 4],
				403,
				[411, 2],
				441,
				0,
				0,
				485,
				[411, 2],
				414,
				564,
				291,
				172,
				155,
				93,
				269,
				162,
				107,
				565,
				66,
				566,
				[411, 2],
				414,
				94,
				567,
				364,
				286,
				66,
				91,
				568,
				479,
				569,
				568,
				570,
				[411, 3],
				560,
				231,
				519,
				518,
				501,
				568,
				399,
				432,
				571,
				360,
				66,
				[106, 2],
				572,
				573,
				574,
				575,
				[411, 3],
				576,
				577,
				571,
				563,
				578,
				[571, 2],
				380,
				579,
				402,
				[411, 3],
				455,
			],
			[
				[0, 7],
				442,
				[411, 3],
				442,
				[0, 3],
				580,
				[411, 2],
				484,
				[0, 3],
				141,
				[411, 3],
				581,
				0,
				0,
				455,
				[411, 3],
				541,
				582,
				583,
				290,
				101,
				190,
				132,
				242,
				572,
				568,
				584,
				[411, 3],
				467,
				360,
				371,
				567,
				392,
				188,
				568,
				565,
				585,
				586,
				587,
				[411, 3],
				588,
				589,
				519,
				[590, 2],
				436,
				360,
				577,
				591,
				577,
				197,
				218,
				100,
				572,
				592,
				593,
				594,
				[411, 3],
				595,
				596,
				577,
				571,
				597,
				598,
				[577, 2],
				360,
				599,
				[411, 3],
				442,
			],
			[
				510,
				496,
				401,
				442,
				1,
				0,
				141,
				485,
				[411, 2],
				494,
				[0, 4],
				485,
				[411, 2],
				403,
				456,
				0,
				141,
				440,
				[411, 2],
				529,
				141,
				[0, 3],
				484,
				[411, 3],
				541,
				600,
				199,
				601,
				602,
				603,
				604,
				94,
				589,
				605,
				606,
				[411, 3],
				607,
				608,
				521,
				471,
				609,
				610,
				611,
				521,
				612,
				613,
				[411, 3],
				614,
				564,
				67,
				501,
				590,
				521,
				548,
				492,
				615,
				616,
				554,
				617,
				618,
				619,
				620,
				621,
				622,
				[411, 2],
				414,
				623,
				397,
				450,
				505,
				624,
				619,
				573,
				571,
				625,
				626,
				[411, 2],
				494,
				0,
			],
			[
				627,
				[411, 8],
				530,
				456,
				[0, 4],
				1,
				628,
				[411, 7],
				404,
				401,
				[0, 5],
				629,
				419,
				[411, 7],
				630,
				258,
				173,
				631,
				632,
				633,
				419,
				[411, 7],
				634,
				521,
				590,
				635,
				[411, 9],
				611,
				636,
				637,
				638,
				[411, 8],
				414,
				639,
				197,
				187,
				447,
				[411, 8],
				530,
				456,
				0,
			],
			[
				141,
				510,
				496,
				628,
				494,
				404,
				529,
				511,
				441,
				442,
				[0, 7],
				581,
				440,
				403,
				404,
				529,
				628,
				441,
				141,
				[0, 6],
				271,
				640,
				641,
				630,
				506,
				[414, 2],
				642,
				643,
				644,
				60,
				189,
				175,
				645,
				239,
				646,
				633,
				647,
				506,
				414,
				420,
				648,
				610,
				649,
				536,
				590,
				650,
				[411, 9],
				474,
				636,
				651,
				652,
				638,
				653,
				524,
				562,
				414,
				506,
				562,
				622,
				654,
				655,
				656,
				631,
				470,
				657,
				658,
				659,
				553,
				[414, 2],
				660,
				441,
				442,
				0,
				0,
			],
			[
				[0, 29],
				4,
				9,
				33,
				53,
				365,
				351,
				54,
				98,
				252,
				269,
				122,
				94,
				551,
				364,
				226,
				128,
				661,
				595,
				589,
				662,
				663,
				254,
				302,
				664,
				[549, 2],
				536,
				665,
				666,
				667,
				668,
				589,
				67,
				669,
				670,
				185,
				88,
				67,
				92,
				60,
				519,
				548,
				671,
				672,
				673,
				668,
				[667, 3],
				663,
				674,
				586,
				359,
				231,
				586,
				589,
				258,
				397,
				661,
				675,
				676,
				53,
				[0, 4],
			],
			[
				[0, 27],
				1,
				57,
				364,
				[676, 2],
				391,
				677,
				360,
				128,
				244,
				678,
				[186, 2],
				669,
				542,
				98,
				153,
				679,
				235,
				631,
				204,
				680,
				671,
				637,
				680,
				190,
				392,
				519,
				681,
				590,
				636,
				682,
				667,
				671,
				92,
				93,
				564,
				397,
				683,
				231,
				371,
				218,
				384,
				[371, 2],
				612,
				684,
				637,
				[667, 2],
				620,
				586,
				675,
				620,
				675,
				669,
				397,
				676,
				[685, 2],
				573,
				542,
				573,
				53,
				[0, 4],
			],
			[
				[0, 27],
				1,
				686,
				670,
				687,
				688,
				689,
				690,
				223,
				244,
				691,
				692,
				88,
				211,
				615,
				685,
				94,
				693,
				694,
				572,
				645,
				534,
				160,
				679,
				695,
				672,
				696,
				204,
				218,
				188,
				392,
				521,
				697,
				672,
				619,
				605,
				67,
				268,
				255,
				263,
				254,
				564,
				674,
				235,
				263,
				127,
				177,
				492,
				698,
				682,
				699,
				673,
				632,
				569,
				673,
				699,
				687,
				700,
				259,
				685,
				[573, 3],
				698,
				701,
				[0, 4],
			],
		],
	};


  // project-rome/@internal/cli-diagnostics/banners/error.json
const ___R$project$rome$$internal$cli$diagnostics$banners$error_json$default = {
		"palettes": [
			[0, 0, 0],
			[15, 0, 0],
			[30, 15, 15],
			[30, 15, 30],
			[15, 15, 15],
			[75, 60, 60],
			[45, 30, 30],
			[30, 30, 30],
			[90, 75, 75],
			[120, 90, 90],
			[105, 75, 75],
			[60, 45, 45],
			[90, 75, 60],
			[90, 60, 60],
			[105, 90, 90],
			[180, 135, 135],
			[150, 120, 120],
			[165, 135, 120],
			[120, 105, 90],
			[150, 120, 105],
			[105, 75, 90],
			[45, 45, 45],
			[30, 30, 15],
			[195, 165, 165],
			[195, 165, 150],
			[165, 120, 120],
			[180, 150, 150],
			[165, 135, 135],
			[15, 0, 15],
			[75, 60, 45],
			[165, 150, 135],
			[210, 165, 165],
			[210, 180, 180],
			[225, 180, 180],
			[135, 105, 105],
			[60, 30, 30],
			[60, 60, 45],
			[210, 180, 165],
			[225, 195, 180],
			[225, 195, 195],
			[75, 45, 45],
			[45, 15, 15],
			[135, 120, 105],
			[180, 150, 135],
			[195, 150, 150],
			[135, 105, 90],
			[240, 210, 195],
			[240, 195, 195],
			[30, 15, 0],
			[150, 135, 120],
			[180, 165, 150],
			[240, 210, 210],
			[240, 195, 180],
			[105, 90, 75],
			[135, 120, 120],
			[225, 180, 165],
			[210, 165, 150],
			[240, 210, 180],
			[60, 45, 30],
			[120, 105, 105],
			[240, 225, 210],
			[225, 210, 195],
			[195, 150, 135],
			[75, 75, 60],
			[180, 165, 165],
			[240, 225, 225],
			[225, 195, 165],
			[195, 165, 135],
			[210, 150, 135],
			[210, 180, 150],
			[180, 135, 105],
			[195, 180, 165],
			[165, 120, 90],
			[165, 105, 75],
			[180, 120, 105],
			[210, 165, 135],
			[195, 135, 120],
			[225, 165, 150],
			[195, 150, 120],
			[210, 195, 180],
			[150, 90, 75],
			[225, 180, 150],
			[180, 120, 90],
			[195, 135, 105],
			[150, 75, 45],
			[180, 135, 120],
			[45, 15, 30],
			[210, 150, 120],
			[165, 105, 90],
			[165, 120, 105],
			[135, 90, 75],
			[135, 90, 90],
			[180, 120, 75],
			[165, 90, 60],
			[150, 90, 45],
			[135, 60, 30],
			[135, 75, 60],
			[150, 105, 75],
			[180, 150, 120],
			[15, 15, 0],
			[165, 135, 105],
			[240, 195, 165],
			[180, 105, 75],
			[165, 90, 45],
			[195, 135, 90],
			[150, 90, 60],
			[135, 90, 60],
			[150, 105, 90],
			[150, 135, 105],
			[45, 45, 30],
			[210, 135, 120],
			[195, 120, 90],
			[180, 105, 60],
			[165, 75, 45],
			[105, 75, 60],
			[210, 135, 105],
			[225, 150, 105],
			[225, 135, 105],
			[210, 120, 90],
			[195, 105, 75],
			[195, 120, 75],
			[195, 90, 60],
			[180, 90, 45],
			[150, 75, 30],
			[135, 75, 45],
			[240, 150, 105],
			[240, 135, 105],
			[210, 105, 75],
			[180, 90, 60],
			[195, 105, 60],
			[150, 75, 60],
			[135, 90, 45],
			[255, 150, 105],
			[240, 150, 120],
			[240, 165, 120],
			[240, 165, 135],
			[225, 120, 90],
			[180, 75, 45],
			[180, 75, 30],
			[165, 75, 30],
			[225, 150, 135],
			[255, 165, 120],
			[240, 180, 150],
			[255, 195, 165],
			[240, 150, 135],
			[210, 105, 60],
			[195, 90, 45],
			[150, 60, 15],
			[150, 60, 30],
			[45, 30, 45],
			[225, 165, 135],
			[255, 150, 120],
			[255, 210, 180],
			[225, 120, 75],
			[165, 90, 75],
			[195, 120, 105],
			[255, 210, 195],
			[255, 195, 180],
			[255, 180, 165],
			[240, 120, 90],
			[180, 105, 105],
			[120, 90, 75],
			[240, 135, 90],
			[255, 135, 105],
			[255, 180, 150],
			[195, 120, 120],
			[135, 120, 90],
			[255, 165, 135],
			[240, 180, 165],
			[165, 60, 30],
			[150, 60, 45],
			[180, 105, 90],
			[240, 165, 150],
			[255, 165, 150],
			[165, 75, 60],
			[165, 105, 60],
			[120, 105, 75],
			[240, 135, 120],
			[240, 120, 105],
			[195, 90, 75],
			[135, 45, 30],
			[255, 135, 90],
			[210, 120, 75],
			[225, 150, 120],
			[225, 135, 90],
			[240, 120, 75],
			[135, 45, 15],
			[75, 45, 30],
			[150, 120, 90],
			[240, 135, 75],
			[180, 75, 60],
			[150, 105, 105],
			[210, 105, 90],
			[135, 75, 30],
			[120, 90, 60],
			[255, 150, 135],
			[225, 120, 105],
			[120, 45, 15],
			[120, 60, 15],
			[210, 135, 90],
			[165, 60, 45],
			[105, 45, 0],
			[135, 105, 75],
			[180, 90, 75],
			[105, 60, 15],
			[225, 105, 75],
			[210, 90, 75],
			[210, 90, 60],
			[195, 75, 45],
			[105, 30, 0],
			[120, 75, 45],
			[120, 60, 30],
			[120, 30, 15],
			[120, 30, 0],
			[135, 30, 0],
			[150, 45, 15],
			[165, 45, 15],
			[165, 60, 15],
			[105, 30, 15],
			[105, 45, 15],
			[75, 60, 30],
			[105, 15, 0],
			[105, 0, 0],
			[120, 0, 0],
			[120, 15, 0],
			[135, 15, 0],
			[150, 30, 0],
			[90, 0, 0],
			[75, 0, 0],
			[75, 15, 0],
			[90, 15, 0],
			[90, 30, 0],
			[120, 60, 45],
			[45, 30, 15],
			[150, 45, 0],
			[165, 30, 0],
			[165, 45, 0],
			[180, 60, 30],
			[135, 45, 0],
			[120, 45, 0],
			[225, 165, 165],
			[105, 75, 45],
			[90, 30, 15],
			[120, 45, 30],
			[60, 30, 15],
			[180, 45, 0],
			[45, 0, 0],
			[90, 30, 30],
			[150, 45, 30],
			[120, 45, 45],
			[105, 60, 45],
			[30, 0, 0],
			[180, 60, 45],
			[195, 15, 0],
			[225, 135, 75],
			[105, 30, 30],
			[105, 15, 15],
			[60, 0, 0],
			[135, 30, 30],
			[180, 0, 0],
			[210, 0, 0],
			[195, 105, 90],
			[120, 30, 30],
			[165, 0, 0],
			[120, 75, 60],
			[210, 150, 105],
			[240, 150, 90],
			[135, 60, 45],
			[135, 60, 15],
			[165, 15, 0],
			[195, 0, 0],
			[195, 75, 30],
			[195, 60, 30],
			[180, 15, 0],
			[255, 150, 90],
			[165, 30, 15],
			[165, 45, 30],
			[105, 45, 30],
			[195, 75, 60],
			[90, 45, 15],
			[150, 30, 15],
			[180, 45, 30],
			[225, 105, 60],
			[225, 105, 90],
			[150, 15, 0],
			[210, 90, 45],
			[210, 120, 105],
			[90, 60, 45],
			[225, 135, 120],
			[225, 120, 60],
			[90, 45, 30],
			[135, 30, 15],
			[195, 105, 45],
			[75, 30, 15],
			[45, 15, 0],
			[180, 60, 15],
			[60, 15, 15],
			[195, 90, 30],
			[180, 75, 15],
			[165, 60, 0],
			[150, 75, 15],
			[105, 60, 60],
			[150, 60, 0],
			[180, 90, 30],
			[165, 75, 15],
			[180, 105, 45],
			[165, 90, 30],
			[180, 120, 60],
			[165, 105, 45],
			[150, 90, 30],
			[135, 60, 0],
			[120, 90, 105],
			[165, 150, 150],
			[75, 30, 0],
			[75, 30, 30],
			[135, 105, 120],
			[60, 15, 0],
			[135, 120, 135],
			[165, 135, 150],
			[90, 60, 75],
			[60, 60, 60],
			[75, 60, 75],
			[150, 135, 135],
			[255, 0, 0],
			[240, 0, 0],
			[225, 45, 15],
			[135, 75, 15],
			[105, 90, 105],
			[60, 45, 60],
			[195, 60, 15],
			[60, 30, 0],
			[75, 15, 15],
			[225, 30, 0],
			[120, 60, 0],
			[45, 30, 0],
			[225, 0, 0],
			[225, 15, 0],
			[195, 165, 180],
			[90, 75, 90],
			[150, 0, 0],
			[195, 30, 0],
			[210, 15, 15],
			[180, 150, 165],
			[150, 120, 135],
			[75, 75, 75],
			[75, 45, 15],
			[195, 45, 0],
			[210, 30, 30],
			[225, 60, 30],
			[210, 75, 30],
			[240, 45, 15],
			[210, 30, 15],
			[225, 75, 30],
			[180, 30, 0],
			[210, 15, 0],
			[105, 90, 60],
			[240, 210, 165],
			[225, 105, 45],
			[75, 45, 60],
			[60, 60, 30],
			[165, 120, 75],
			[60, 45, 15],
			[210, 105, 45],
			[225, 90, 45],
			[210, 30, 0],
			[240, 60, 30],
			[240, 45, 30],
			[210, 45, 15],
			[195, 150, 105],
			[105, 45, 45],
			[240, 15, 0],
			[240, 75, 45],
			[150, 45, 45],
			[150, 105, 60],
			[255, 75, 60],
			[45, 45, 15],
			[90, 90, 75],
			[180, 60, 0],
		],
		"rows": [
			[[0, 52], 1, [0, 47]],
			[[0, 51], 2, [0, 4], 1, [0, 43]],
			[[0, 46], 3, 0, 0, 4, 1, 5, 6, 6, 1, 7, 2, 2, 4, 4, [0, 40]],
			[[0, 46], 5, 1, 0, 4, 8, 9, 10, 10, 8, 11, 12, 13, 11, 5, [0, 40]],
			[
				[0, 42],
				4,
				[0, 3],
				14,
				6,
				2,
				5,
				9,
				15,
				16,
				17,
				16,
				18,
				16,
				19,
				14,
				20,
				0,
				1,
				1,
				[0, 37],
			],
			[
				[0, 40],
				11,
				6,
				21,
				2,
				3,
				22,
				16,
				9,
				8,
				16,
				17,
				23,
				23,
				24,
				25,
				26,
				23,
				27,
				27,
				9,
				0,
				28,
				14,
				[0, 37],
			],
			[
				[0, 37],
				7,
				0,
				0,
				6,
				19,
				5,
				11,
				29,
				9,
				30,
				27,
				15,
				24,
				23,
				31,
				23,
				24,
				32,
				31,
				32,
				33,
				24,
				27,
				11,
				5,
				34,
				9,
				35,
				6,
				[0, 4],
				11,
				28,
				[0, 28],
			],
			[
				[0, 31],
				4,
				[0, 3],
				2,
				36,
				12,
				6,
				13,
				18,
				18,
				27,
				13,
				19,
				16,
				24,
				31,
				33,
				32,
				32,
				37,
				31,
				24,
				32,
				38,
				38,
				39,
				32,
				26,
				34,
				10,
				34,
				23,
				13,
				40,
				28,
				41,
				2,
				10,
				42,
				2,
				[0, 28],
			],
			[
				[0, 31],
				7,
				0,
				0,
				1,
				12,
				9,
				19,
				19,
				10,
				24,
				17,
				43,
				24,
				31,
				44,
				31,
				38,
				[33, 4],
				37,
				37,
				33,
				[39, 4],
				33,
				44,
				19,
				16,
				31,
				23,
				27,
				45,
				17,
				16,
				14,
				9,
				6,
				[0, 28],
			],
			[
				[0, 27],
				4,
				0,
				7,
				0,
				11,
				21,
				11,
				11,
				14,
				43,
				26,
				17,
				43,
				38,
				31,
				31,
				33,
				46,
				[38, 7],
				33,
				38,
				[39, 3],
				38,
				39,
				38,
				47,
				37,
				17,
				23,
				31,
				44,
				27,
				27,
				9,
				16,
				15,
				48,
				0,
				1,
				1,
				[0, 25],
			],
			[
				[0, 27],
				4,
				11,
				13,
				8,
				16,
				9,
				16,
				18,
				49,
				26,
				39,
				16,
				50,
				46,
				39,
				38,
				39,
				51,
				46,
				52,
				38,
				52,
				38,
				38,
				52,
				38,
				38,
				39,
				39,
				46,
				38,
				47,
				46,
				47,
				47,
				33,
				32,
				37,
				31,
				17,
				27,
				23,
				31,
				31,
				16,
				53,
				8,
				1,
				[0, 25],
			],
			[
				[0, 25],
				21,
				11,
				5,
				8,
				54,
				27,
				37,
				27,
				26,
				31,
				33,
				49,
				32,
				55,
				24,
				38,
				46,
				47,
				47,
				51,
				46,
				38,
				[55, 3],
				52,
				52,
				33,
				56,
				47,
				39,
				[47, 3],
				46,
				47,
				46,
				47,
				38,
				33,
				37,
				31,
				31,
				32,
				31,
				26,
				16,
				16,
				10,
				[0, 26],
			],
			[
				[0, 26],
				14,
				18,
				14,
				16,
				37,
				33,
				38,
				38,
				24,
				38,
				24,
				37,
				38,
				56,
				52,
				46,
				57,
				38,
				46,
				47,
				31,
				56,
				37,
				37,
				55,
				52,
				55,
				37,
				52,
				[33, 3],
				38,
				39,
				39,
				46,
				47,
				46,
				38,
				55,
				33,
				32,
				33,
				24,
				16,
				32,
				27,
				34,
				12,
				5,
				6,
				[0, 23],
			],
			[
				[0, 25],
				28,
				58,
				26,
				59,
				43,
				38,
				33,
				39,
				60,
				61,
				38,
				57,
				24,
				38,
				55,
				46,
				55,
				56,
				37,
				46,
				33,
				24,
				56,
				24,
				38,
				31,
				37,
				62,
				55,
				33,
				55,
				37,
				31,
				33,
				47,
				39,
				33,
				52,
				46,
				38,
				55,
				38,
				33,
				33,
				31,
				17,
				23,
				27,
				27,
				63,
				14,
				1,
				0,
				7,
				[0, 21],
			],
			[
				[0, 25],
				1,
				0,
				64,
				5,
				49,
				39,
				38,
				47,
				65,
				60,
				38,
				46,
				66,
				57,
				52,
				52,
				67,
				68,
				69,
				46,
				55,
				38,
				56,
				70,
				62,
				55,
				56,
				56,
				31,
				31,
				37,
				55,
				55,
				37,
				39,
				38,
				38,
				33,
				52,
				47,
				38,
				38,
				[33, 3],
				44,
				31,
				26,
				27,
				8,
				6,
				13,
				20,
				13,
				[0, 21],
			],
			[
				[0, 23],
				4,
				6,
				8,
				1,
				71,
				34,
				34,
				[46, 3],
				60,
				51,
				46,
				57,
				66,
				66,
				55,
				52,
				62,
				72,
				66,
				55,
				55,
				31,
				55,
				73,
				74,
				68,
				68,
				62,
				62,
				56,
				37,
				56,
				33,
				55,
				37,
				33,
				52,
				38,
				33,
				46,
				38,
				33,
				37,
				33,
				33,
				37,
				37,
				23,
				44,
				17,
				27,
				42,
				34,
				13,
				1,
				[0, 20],
			],
			[
				[0, 24],
				14,
				5,
				59,
				23,
				44,
				19,
				38,
				[46, 4],
				52,
				55,
				55,
				75,
				55,
				69,
				76,
				73,
				56,
				62,
				77,
				55,
				55,
				68,
				74,
				62,
				76,
				78,
				74,
				62,
				[56, 3],
				55,
				37,
				31,
				33,
				55,
				33,
				47,
				33,
				33,
				37,
				39,
				38,
				37,
				37,
				32,
				26,
				34,
				53,
				27,
				9,
				7,
				[0, 21],
			],
			[
				[0, 21],
				1,
				2,
				2,
				8,
				16,
				42,
				79,
				37,
				19,
				17,
				46,
				57,
				52,
				52,
				55,
				56,
				55,
				75,
				69,
				75,
				70,
				76,
				76,
				62,
				56,
				38,
				56,
				56,
				55,
				56,
				74,
				80,
				76,
				70,
				75,
				[62, 4],
				24,
				55,
				56,
				37,
				31,
				33,
				55,
				33,
				33,
				38,
				[37, 3],
				19,
				53,
				43,
				27,
				63,
				0,
				4,
				[0, 20],
			],
			[
				[0, 22],
				2,
				13,
				45,
				43,
				43,
				37,
				52,
				31,
				67,
				81,
				[52, 3],
				69,
				69,
				55,
				81,
				56,
				56,
				76,
				68,
				82,
				83,
				75,
				55,
				62,
				56,
				56,
				75,
				80,
				84,
				72,
				83,
				85,
				78,
				78,
				72,
				78,
				24,
				69,
				78,
				56,
				62,
				31,
				24,
				[37, 5],
				31,
				17,
				30,
				62,
				34,
				0,
				11,
				4,
				2,
				[0, 19],
			],
			[
				[0, 22],
				86,
				11,
				42,
				17,
				37,
				62,
				55,
				38,
				56,
				75,
				[55, 4],
				67,
				75,
				81,
				56,
				75,
				75,
				87,
				73,
				73,
				88,
				69,
				78,
				70,
				70,
				62,
				72,
				84,
				80,
				75,
				74,
				85,
				89,
				90,
				72,
				85,
				75,
				85,
				[62, 3],
				56,
				37,
				56,
				37,
				55,
				37,
				31,
				17,
				24,
				44,
				35,
				5,
				5,
				36,
				11,
				[0, 19],
			],
			[
				[0, 21],
				4,
				4,
				91,
				53,
				17,
				37,
				55,
				69,
				52,
				66,
				75,
				62,
				81,
				56,
				81,
				75,
				68,
				81,
				69,
				70,
				78,
				87,
				92,
				93,
				94,
				78,
				83,
				82,
				82,
				88,
				82,
				95,
				96,
				78,
				82,
				74,
				97,
				72,
				97,
				74,
				89,
				85,
				85,
				98,
				62,
				56,
				62,
				56,
				56,
				62,
				56,
				31,
				44,
				43,
				44,
				9,
				16,
				12,
				8,
				11,
				21,
				99,
				[0, 17],
			],
			[
				[0, 20],
				7,
				2,
				40,
				19,
				37,
				43,
				100,
				38,
				66,
				66,
				101,
				75,
				78,
				62,
				68,
				68,
				87,
				75,
				78,
				77,
				74,
				83,
				76,
				83,
				102,
				103,
				102,
				104,
				102,
				105,
				95,
				82,
				95,
				105,
				100,
				76,
				106,
				107,
				96,
				72,
				80,
				90,
				72,
				89,
				85,
				56,
				43,
				43,
				62,
				67,
				62,
				24,
				37,
				56,
				24,
				43,
				108,
				43,
				26,
				34,
				8,
				109,
				1,
				[0, 17],
			],
			[
				[0, 20],
				11,
				11,
				9,
				45,
				17,
				69,
				55,
				85,
				55,
				55,
				66,
				75,
				70,
				83,
				83,
				110,
				87,
				87,
				111,
				87,
				83,
				82,
				82,
				111,
				112,
				113,
				103,
				[102, 2],
				84,
				84,
				73,
				95,
				88,
				97,
				88,
				106,
				96,
				106,
				88,
				97,
				97,
				72,
				72,
				85,
				62,
				85,
				85,
				98,
				98,
				62,
				[24, 3],
				56,
				62,
				62,
				17,
				18,
				63,
				4,
				21,
				6,
				[0, 17],
			],
			[
				[0, 21],
				12,
				53,
				114,
				107,
				43,
				66,
				66,
				52,
				55,
				81,
				87,
				83,
				115,
				116,
				[117, 3],
				[115, 2],
				118,
				119,
				102,
				120,
				119,
				121,
				122,
				113,
				93,
				123,
				93,
				84,
				105,
				73,
				[124, 4],
				97,
				106,
				[105, 2],
				97,
				80,
				70,
				76,
				85,
				85,
				98,
				17,
				62,
				62,
				56,
				44,
				24,
				56,
				43,
				19,
				12,
				22,
				29,
				8,
				1,
				[0, 17],
			],
			[
				[0, 20],
				58,
				58,
				34,
				43,
				56,
				24,
				56,
				55,
				81,
				81,
				75,
				68,
				110,
				117,
				[125, 2],
				[126, 2],
				117,
				[115, 2],
				118,
				115,
				117,
				118,
				127,
				121,
				128,
				[122, 2],
				129,
				128,
				94,
				94,
				105,
				130,
				84,
				[124, 3],
				[105, 2],
				131,
				73,
				83,
				72,
				74,
				70,
				[62, 3],
				98,
				24,
				43,
				43,
				56,
				62,
				45,
				19,
				18,
				5,
				99,
				[0, 18],
			],
			[
				[0, 20],
				8,
				114,
				40,
				34,
				[55, 3],
				66,
				66,
				56,
				78,
				76,
				110,
				126,
				125,
				[132, 2],
				133,
				134,
				[135, 5],
				133,
				136,
				127,
				121,
				137,
				122,
				138,
				122,
				103,
				139,
				[123, 3],
				95,
				95,
				84,
				84,
				124,
				105,
				[82, 4],
				72,
				89,
				62,
				67,
				[62, 3],
				43,
				24,
				62,
				17,
				19,
				13,
				1,
				[0, 19],
			],
			[
				[0, 20],
				5,
				50,
				19,
				43,
				56,
				55,
				[66, 3],
				81,
				75,
				140,
				133,
				[125, 2],
				[132, 2],
				141,
				142,
				143,
				[101, 3],
				142,
				144,
				126,
				136,
				145,
				121,
				146,
				122,
				138,
				[139, 3],
				147,
				[148, 2],
				123,
				84,
				84,
				105,
				88,
				[82, 3],
				73,
				88,
				89,
				85,
				67,
				56,
				[62, 3],
				24,
				24,
				43,
				17,
				44,
				40,
				[0, 19],
			],
			[
				[0, 20],
				149,
				42,
				37,
				[107, 2],
				85,
				69,
				66,
				55,
				56,
				77,
				150,
				133,
				125,
				126,
				132,
				151,
				135,
				143,
				152,
				[52, 3],
				101,
				144,
				126,
				136,
				153,
				127,
				145,
				121,
				122,
				137,
				138,
				[139, 2],
				[123, 2],
				84,
				84,
				130,
				154,
				74,
				74,
				155,
				82,
				73,
				154,
				89,
				76,
				[85, 3],
				62,
				43,
				24,
				37,
				56,
				43,
				45,
				1,
				[0, 19],
			],
			[
				[0, 21],
				109,
				18,
				69,
				55,
				[66, 3],
				69,
				56,
				81,
				135,
				125,
				[126, 3],
				151,
				142,
				143,
				156,
				152,
				101,
				157,
				158,
				133,
				126,
				159,
				[153, 3],
				145,
				121,
				146,
				122,
				[137, 2],
				113,
				139,
				113,
				130,
				154,
				160,
				74,
				76,
				83,
				82,
				73,
				154,
				82,
				68,
				56,
				85,
				43,
				62,
				44,
				44,
				56,
				62,
				114,
				161,
				2,
				5,
				6,
				[0, 17],
			],
			[
				[0, 20],
				4,
				29,
				45,
				90,
				98,
				69,
				66,
				55,
				75,
				56,
				55,
				135,
				126,
				[162, 2],
				163,
				151,
				164,
				157,
				152,
				52,
				[157, 2],
				164,
				133,
				126,
				136,
				[153, 3],
				127,
				[121, 2],
				122,
				137,
				113,
				139,
				[148, 2],
				84,
				154,
				160,
				165,
				83,
				[155, 2],
				73,
				73,
				72,
				62,
				33,
				55,
				31,
				56,
				37,
				55,
				55,
				56,
				43,
				25,
				27,
				19,
				11,
				[0, 17],
			],
			[
				[0, 19],
				6,
				58,
				10,
				166,
				75,
				81,
				69,
				69,
				75,
				77,
				75,
				142,
				144,
				[162, 3],
				163,
				132,
				167,
				164,
				158,
				168,
				143,
				142,
				144,
				126,
				[136, 2],
				[153, 2],
				[127, 2],
				[121, 2],
				128,
				137,
				113,
				169,
				[148, 2],
				170,
				130,
				154,
				171,
				82,
				76,
				155,
				73,
				73,
				74,
				85,
				31,
				33,
				52,
				38,
				38,
				46,
				38,
				38,
				33,
				24,
				15,
				10,
				5,
				6,
				[0, 16],
			],
			[
				[0, 19],
				6,
				10,
				5,
				42,
				98,
				81,
				55,
				55,
				81,
				75,
				150,
				172,
				133,
				[162, 4],
				163,
				133,
				135,
				167,
				164,
				173,
				144,
				133,
				126,
				[136, 2],
				153,
				[127, 3],
				121,
				[128, 3],
				113,
				[148, 4],
				170,
				174,
				154,
				155,
				76,
				155,
				93,
				175,
				74,
				62,
				62,
				24,
				55,
				[46, 3],
				47,
				39,
				38,
				37,
				24,
				27,
				9,
				6,
				1,
				[0, 15],
			],
			[
				[0, 19],
				6,
				176,
				17,
				43,
				67,
				75,
				75,
				55,
				81,
				75,
				77,
				150,
				125,
				[162, 4],
				126,
				125,
				133,
				[135, 3],
				133,
				177,
				178,
				[136, 2],
				153,
				[127, 2],
				119,
				179,
				[128, 2],
				93,
				174,
				84,
				[148, 2],
				180,
				95,
				84,
				93,
				171,
				155,
				171,
				[105, 2],
				88,
				76,
				62,
				62,
				24,
				37,
				55,
				38,
				33,
				47,
				33,
				23,
				17,
				27,
				34,
				9,
				6,
				[0, 15],
			],
			[
				[0, 19],
				4,
				6,
				161,
				43,
				24,
				75,
				81,
				52,
				81,
				77,
				81,
				150,
				117,
				[162, 2],
				181,
				162,
				126,
				163,
				151,
				133,
				[144, 2],
				133,
				126,
				[136, 2],
				118,
				182,
				127,
				[119, 3],
				128,
				93,
				93,
				174,
				170,
				148,
				95,
				180,
				95,
				95,
				130,
				154,
				[171, 2],
				94,
				105,
				88,
				76,
				[85, 3],
				[62, 3],
				56,
				31,
				24,
				37,
				24,
				62,
				34,
				6,
				[0, 16],
			],
			[
				[0, 18],
				4,
				6,
				29,
				40,
				161,
				98,
				56,
				66,
				55,
				55,
				77,
				150,
				183,
				184,
				185,
				162,
				181,
				[163, 2],
				126,
				133,
				[135, 2],
				144,
				133,
				177,
				117,
				[136, 2],
				118,
				182,
				[119, 3],
				128,
				93,
				174,
				113,
				170,
				95,
				180,
				[186, 2],
				95,
				84,
				154,
				73,
				93,
				93,
				154,
				74,
				85,
				[62, 4],
				98,
				62,
				24,
				56,
				56,
				31,
				43,
				17,
				9,
				6,
				[0, 16],
			],
			[
				[0, 18],
				99,
				187,
				114,
				188,
				45,
				89,
				69,
				66,
				55,
				81,
				87,
				87,
				183,
				184,
				159,
				162,
				163,
				[126, 2],
				151,
				[135, 4],
				133,
				177,
				[136, 3],
				[118, 2],
				127,
				[119, 2],
				[128, 2],
				174,
				113,
				148,
				95,
				95,
				[186, 2],
				95,
				95,
				130,
				171,
				103,
				[105, 2],
				74,
				56,
				62,
				17,
				85,
				85,
				43,
				62,
				62,
				24,
				56,
				37,
				37,
				43,
				34,
				161,
				11,
				[0, 15],
			],
			[
				[0, 18],
				1,
				22,
				35,
				107,
				43,
				56,
				37,
				69,
				69,
				75,
				87,
				150,
				183,
				153,
				189,
				[162, 2],
				163,
				132,
				151,
				[167, 2],
				[135, 2],
				[133, 2],
				117,
				[136, 2],
				[118, 2],
				[127, 2],
				119,
				179,
				190,
				113,
				[170, 2],
				148,
				[95, 4],
				84,
				95,
				95,
				123,
				84,
				80,
				89,
				191,
				43,
				85,
				89,
				[85, 3],
				62,
				24,
				56,
				37,
				55,
				24,
				16,
				59,
				5,
				2,
				[0, 14],
			],
			[
				[0, 20],
				6,
				161,
				17,
				43,
				24,
				56,
				75,
				87,
				[150, 2],
				117,
				184,
				189,
				[162, 2],
				[163, 2],
				151,
				[135, 3],
				[133, 2],
				126,
				117,
				136,
				[118, 2],
				136,
				192,
				127,
				119,
				179,
				128,
				113,
				170,
				[148, 3],
				[95, 6],
				193,
				84,
				80,
				88,
				89,
				107,
				89,
				85,
				17,
				85,
				[62, 3],
				55,
				55,
				56,
				19,
				9,
				10,
				11,
				[0, 15],
			],
			[
				[0, 21],
				29,
				194,
				45,
				67,
				67,
				68,
				87,
				83,
				115,
				184,
				[162, 4],
				[163, 2],
				151,
				195,
				[167, 2],
				133,
				126,
				196,
				136,
				118,
				127,
				[136, 2],
				118,
				127,
				119,
				179,
				128,
				113,
				169,
				[148, 4],
				[95, 5],
				197,
				198,
				124,
				97,
				[107, 4],
				19,
				89,
				85,
				62,
				56,
				[55, 3],
				24,
				42,
				29,
				4,
				[0, 15],
			],
			[
				[0, 20],
				6,
				40,
				45,
				[98, 3],
				78,
				78,
				83,
				199,
				153,
				[162, 3],
				181,
				[163, 4],
				151,
				133,
				[126, 2],
				117,
				136,
				[127, 2],
				118,
				136,
				118,
				127,
				119,
				179,
				128,
				174,
				200,
				[148, 5],
				[95, 4],
				[201, 2],
				198,
				106,
				107,
				188,
				107,
				202,
				89,
				85,
				98,
				56,
				55,
				52,
				38,
				24,
				19,
				29,
				2,
				1,
				[0, 15],
			],
			[
				[0, 21],
				4,
				29,
				187,
				58,
				70,
				70,
				73,
				92,
				182,
				[162, 4],
				181,
				[162, 4],
				[126, 2],
				196,
				[136, 2],
				[127, 4],
				136,
				127,
				119,
				[179, 2],
				203,
				174,
				170,
				148,
				[95, 7],
				198,
				[201, 3],
				204,
				106,
				107,
				[89, 3],
				85,
				85,
				56,
				37,
				55,
				55,
				44,
				45,
				5,
				6,
				[0, 16],
			],
			[
				[0, 23],
				29,
				161,
				70,
				70,
				72,
				102,
				153,
				[162, 5],
				126,
				162,
				[159, 3],
				[136, 2],
				205,
				[127, 2],
				121,
				[179, 2],
				127,
				206,
				179,
				121,
				[128, 2],
				84,
				84,
				170,
				[95, 4],
				84,
				84,
				95,
				197,
				[201, 5],
				96,
				97,
				107,
				19,
				85,
				85,
				62,
				56,
				56,
				24,
				62,
				16,
				10,
				6,
				[0, 16],
			],
			[
				[0, 23],
				36,
				42,
				100,
				78,
				82,
				118,
				162,
				189,
				162,
				153,
				159,
				162,
				[126, 2],
				159,
				[136, 2],
				127,
				[207, 2],
				121,
				208,
				121,
				[128, 2],
				127,
				207,
				128,
				190,
				[174, 2],
				130,
				174,
				84,
				170,
				[84, 4],
				130,
				84,
				197,
				201,
				[209, 2],
				[201, 3],
				210,
				72,
				107,
				89,
				85,
				98,
				56,
				56,
				24,
				62,
				19,
				53,
				11,
				2,
				[0, 15],
			],
			[
				[0, 22],
				1,
				187,
				12,
				85,
				78,
				83,
				184,
				189,
				[153, 3],
				146,
				122,
				119,
				179,
				[128, 2],
				[113, 3],
				[137, 2],
				138,
				[137, 3],
				121,
				208,
				139,
				[148, 2],
				170,
				84,
				84,
				[124, 2],
				84,
				84,
				93,
				93,
				73,
				93,
				211,
				201,
				[209, 3],
				[201, 2],
				204,
				106,
				188,
				107,
				89,
				98,
				62,
				24,
				56,
				24,
				43,
				9,
				5,
				7,
				[0, 15],
			],
			[
				[0, 22],
				1,
				161,
				100,
				78,
				78,
				82,
				184,
				136,
				[153, 2],
				121,
				137,
				148,
				186,
				180,
				197,
				212,
				[213, 2],
				214,
				[215, 2],
				216,
				[137, 2],
				113,
				137,
				138,
				217,
				[186, 2],
				212,
				[218, 2],
				219,
				197,
				211,
				[198, 2],
				124,
				105,
				93,
				124,
				201,
				[209, 3],
				[201, 2],
				204,
				106,
				89,
				202,
				107,
				89,
				43,
				62,
				89,
				161,
				13,
				11,
				2,
				2,
				[0, 15],
			],
			[
				[0, 22],
				99,
				220,
				89,
				75,
				83,
				111,
				184,
				[153, 2],
				145,
				146,
				139,
				148,
				186,
				213,
				221,
				222,
				223,
				224,
				225,
				[226, 2],
				216,
				138,
				137,
				113,
				137,
				169,
				215,
				214,
				213,
				221,
				227,
				[228, 2],
				[229, 2],
				230,
				[231, 2],
				219,
				84,
				130,
				197,
				[209, 4],
				201,
				198,
				232,
				188,
				90,
				89,
				43,
				56,
				56,
				15,
				45,
				19,
				18,
				53,
				5,
				2,
				[0, 14],
			],
			[
				[0, 23],
				233,
				90,
				150,
				83,
				118,
				162,
				189,
				153,
				129,
				[122, 2],
				113,
				[169, 3],
				216,
				[234, 2],
				235,
				[226, 2],
				236,
				237,
				[137, 2],
				139,
				215,
				238,
				213,
				209,
				[213, 2],
				[209, 2],
				212,
				[197, 2],
				219,
				[209, 2],
				219,
				95,
				198,
				[201, 2],
				239,
				[197, 3],
				106,
				89,
				89,
				85,
				85,
				77,
				240,
				55,
				62,
				45,
				29,
				109,
				11,
				[0, 15],
			],
			[
				[0, 23],
				109,
				241,
				83,
				111,
				199,
				[162, 2],
				153,
				145,
				146,
				208,
				237,
				215,
				186,
				218,
				230,
				228,
				221,
				214,
				234,
				[226, 2],
				138,
				129,
				121,
				113,
				186,
				239,
				213,
				[209, 2],
				221,
				227,
				229,
				[242, 2],
				219,
				243,
				218,
				[209, 2],
				197,
				201,
				209,
				201,
				197,
				198,
				95,
				95,
				105,
				70,
				62,
				85,
				62,
				155,
				179,
				78,
				62,
				17,
				6,
				0,
				4,
				[0, 15],
			],
			[
				[0, 23],
				4,
				244,
				83,
				111,
				184,
				[162, 2],
				153,
				145,
				146,
				245,
				225,
				223,
				218,
				246,
				2,
				40,
				247,
				180,
				215,
				248,
				234,
				146,
				184,
				127,
				113,
				238,
				239,
				[197, 2],
				213,
				224,
				249,
				250,
				35,
				21,
				251,
				246,
				229,
				[209, 3],
				[201, 2],
				239,
				198,
				95,
				[193, 2],
				105,
				72,
				98,
				62,
				74,
				252,
				253,
				111,
				85,
				27,
				49,
				13,
				28,
				[0, 15],
			],
			[
				[0, 24],
				58,
				87,
				111,
				254,
				[189, 2],
				162,
				185,
				145,
				208,
				121,
				252,
				170,
				255,
				227,
				256,
				180,
				248,
				169,
				200,
				217,
				136,
				133,
				118,
				137,
				238,
				239,
				[197, 3],
				248,
				170,
				96,
				228,
				[257, 2],
				247,
				230,
				227,
				230,
				209,
				[201, 2],
				239,
				198,
				95,
				193,
				84,
				175,
				72,
				70,
				85,
				258,
				259,
				260,
				102,
				17,
				16,
				34,
				12,
				[0, 16],
			],
			[
				[0, 22],
				1,
				6,
				90,
				87,
				119,
				153,
				[189, 2],
				162,
				126,
				162,
				125,
				133,
				117,
				261,
				203,
				[200, 4],
				113,
				200,
				121,
				125,
				133,
				118,
				137,
				186,
				[239, 2],
				197,
				95,
				[170, 2],
				248,
				180,
				[262, 2],
				197,
				212,
				[209, 2],
				201,
				[239, 3],
				95,
				124,
				95,
				193,
				73,
				82,
				70,
				171,
				223,
				263,
				260,
				190,
				58,
				2,
				2,
				5,
				11,
				[0, 15],
			],
			[
				[0, 22],
				2,
				1,
				264,
				265,
				112,
				153,
				[189, 2],
				266,
				151,
				134,
				162,
				[136, 2],
				127,
				121,
				252,
				[237, 2],
				169,
				137,
				121,
				126,
				167,
				133,
				127,
				169,
				215,
				[239, 2],
				197,
				186,
				[148, 3],
				[170, 2],
				[267, 2],
				95,
				197,
				209,
				201,
				[239, 2],
				197,
				[95, 3],
				268,
				105,
				82,
				72,
				130,
				223,
				269,
				270,
				171,
				13,
				6,
				[0, 18],
			],
			[
				[0, 24],
				244,
				92,
				122,
				153,
				185,
				162,
				132,
				[125, 2],
				126,
				205,
				271,
				272,
				[237, 3],
				137,
				121,
				127,
				162,
				133,
				135,
				117,
				121,
				169,
				215,
				238,
				[239, 2],
				186,
				[170, 2],
				148,
				215,
				180,
				148,
				95,
				186,
				[239, 2],
				197,
				95,
				95,
				148,
				170,
				95,
				95,
				268,
				84,
				175,
				82,
				148,
				214,
				235,
				273,
				155,
				19,
				11,
				[0, 18],
			],
			[
				[0, 23],
				1,
				251,
				124,
				122,
				153,
				185,
				162,
				274,
				132,
				125,
				126,
				159,
				205,
				127,
				[207, 2],
				127,
				118,
				136,
				[126, 2],
				151,
				135,
				136,
				121,
				148,
				215,
				186,
				[239, 2],
				238,
				[148, 2],
				170,
				[148, 3],
				[186, 3],
				95,
				84,
				93,
				[174, 2],
				84,
				95,
				[268, 2],
				95,
				84,
				93,
				214,
				226,
				275,
				276,
				85,
				12,
				48,
				[0, 18],
			],
			[
				[0, 25],
				277,
				145,
				153,
				185,
				162,
				181,
				132,
				133,
				167,
				151,
				[133, 4],
				[144, 2],
				133,
				[163, 2],
				195,
				135,
				136,
				121,
				215,
				[186, 2],
				239,
				213,
				238,
				215,
				[148, 3],
				169,
				[148, 2],
				169,
				[148, 4],
				113,
				93,
				93,
				84,
				268,
				239,
				268,
				130,
				174,
				[226, 2],
				216,
				154,
				19,
				114,
				6,
				[0, 18],
			],
			[
				[0, 25],
				277,
				205,
				153,
				185,
				189,
				181,
				163,
				132,
				[167, 6],
				173,
				167,
				151,
				[126, 2],
				167,
				173,
				196,
				278,
				215,
				213,
				186,
				[239, 2],
				238,
				148,
				[169, 7],
				148,
				[215, 2],
				[148, 2],
				113,
				93,
				84,
				268,
				197,
				84,
				[203, 2],
				226,
				235,
				216,
				171,
				34,
				19,
				233,
				[0, 18],
			],
			[
				[0, 25],
				279,
				[153, 2],
				[185, 2],
				[181, 2],
				132,
				167,
				[173, 3],
				[167, 3],
				151,
				126,
				[162, 2],
				151,
				144,
				136,
				278,
				186,
				213,
				[239, 2],
				238,
				186,
				[200, 2],
				[137, 2],
				[169, 5],
				148,
				147,
				268,
				95,
				84,
				93,
				93,
				123,
				84,
				93,
				111,
				261,
				280,
				275,
				281,
				78,
				62,
				89,
				11,
				1,
				[0, 17],
			],
			[
				[0, 25],
				277,
				205,
				153,
				[185, 2],
				181,
				[163, 2],
				133,
				167,
				164,
				173,
				195,
				177,
				126,
				205,
				282,
				162,
				125,
				167,
				144,
				283,
				137,
				186,
				209,
				201,
				[239, 2],
				148,
				113,
				[137, 4],
				138,
				237,
				137,
				[113, 2],
				148,
				[268, 2],
				148,
				113,
				93,
				84,
				84,
				128,
				102,
				179,
				284,
				216,
				237,
				70,
				45,
				233,
				11,
				22,
				[0, 17],
			],
			[
				[0, 25],
				211,
				127,
				153,
				[185, 2],
				181,
				[163, 2],
				126,
				144,
				135,
				[178, 2],
				159,
				205,
				285,
				153,
				[125, 2],
				173,
				133,
				127,
				252,
				186,
				213,
				[209, 2],
				239,
				95,
				113,
				137,
				[128, 2],
				[137, 4],
				113,
				93,
				174,
				148,
				268,
				84,
				113,
				93,
				84,
				84,
				93,
				102,
				119,
				286,
				128,
				190,
				89,
				45,
				287,
				2,
				[0, 18],
			],
			[
				[0, 25],
				211,
				127,
				153,
				[185, 2],
				[181, 3],
				126,
				151,
				126,
				283,
				205,
				127,
				207,
				271,
				[126, 3],
				177,
				118,
				179,
				113,
				186,
				213,
				209,
				239,
				201,
				197,
				169,
				137,
				[128, 3],
				[137, 2],
				[113, 2],
				[93, 3],
				84,
				123,
				93,
				128,
				84,
				84,
				103,
				128,
				261,
				288,
				118,
				286,
				75,
				98,
				13,
				[0, 19],
			],
			[
				[0, 25],
				124,
				127,
				289,
				[185, 2],
				[159, 3],
				[126, 3],
				136,
				207,
				146,
				271,
				208,
				[153, 3],
				145,
				208,
				137,
				148,
				186,
				[213, 5],
				215,
				[137, 2],
				[128, 3],
				137,
				169,
				148,
				113,
				[93, 3],
				84,
				103,
				93,
				103,
				123,
				84,
				93,
				203,
				261,
				[140, 2],
				89,
				6,
				11,
				2,
				[0, 18],
			],
			[
				[0, 25],
				211,
				145,
				289,
				[185, 5],
				[159, 2],
				136,
				127,
				207,
				[208, 3],
				272,
				216,
				146,
				138,
				217,
				234,
				238,
				213,
				[209, 2],
				[213, 3],
				214,
				113,
				137,
				[128, 3],
				113,
				148,
				215,
				148,
				84,
				84,
				[103, 3],
				93,
				103,
				[84, 3],
				102,
				288,
				286,
				155,
				264,
				22,
				[0, 20],
			],
			[
				[0, 25],
				290,
				145,
				289,
				[185, 6],
				[205, 2],
				127,
				121,
				137,
				127,
				177,
				283,
				275,
				[226, 2],
				214,
				213,
				209,
				221,
				218,
				[221, 3],
				213,
				186,
				148,
				[137, 3],
				190,
				113,
				148,
				248,
				186,
				268,
				[123, 2],
				84,
				113,
				93,
				103,
				123,
				84,
				84,
				93,
				192,
				133,
				111,
				287,
				[0, 21],
			],
			[
				[0, 25],
				241,
				[145, 2],
				[153, 4],
				[205, 3],
				145,
				121,
				137,
				127,
				177,
				133,
				144,
				127,
				137,
				291,
				224,
				[221, 2],
				[230, 2],
				[221, 3],
				212,
				180,
				148,
				113,
				[137, 2],
				113,
				200,
				[148, 2],
				186,
				197,
				95,
				95,
				148,
				123,
				93,
				103,
				[123, 2],
				84,
				103,
				252,
				208,
				119,
				175,
				48,
				[0, 20],
			],
			[
				[0, 25],
				73,
				[145, 2],
				[153, 2],
				[282, 4],
				207,
				121,
				208,
				121,
				136,
				[126, 2],
				177,
				127,
				128,
				148,
				213,
				212,
				221,
				230,
				[221, 4],
				212,
				243,
				170,
				113,
				[169, 3],
				148,
				147,
				268,
				[239, 3],
				197,
				186,
				148,
				113,
				103,
				123,
				148,
				123,
				113,
				248,
				280,
				80,
				[277, 2],
				[0, 20],
			],
			[
				[0, 25],
				219,
				292,
				[145, 2],
				[282, 3],
				207,
				285,
				[208, 2],
				137,
				[121, 2],
				[127, 3],
				128,
				169,
				215,
				213,
				243,
				212,
				209,
				221,
				209,
				230,
				[221, 2],
				243,
				180,
				[148, 2],
				169,
				[147, 2],
				186,
				238,
				239,
				213,
				[209, 2],
				239,
				[268, 2],
				103,
				123,
				84,
				148,
				139,
				102,
				130,
				293,
				294,
				279,
				[0, 20],
			],
			[
				[0, 25],
				209,
				93,
				[145, 3],
				[285, 3],
				271,
				[138, 3],
				137,
				139,
				[137, 2],
				139,
				[147, 2],
				238,
				213,
				197,
				239,
				209,
				221,
				[230, 4],
				221,
				209,
				213,
				238,
				[215, 2],
				[238, 3],
				239,
				213,
				[209, 2],
				239,
				[268, 2],
				84,
				123,
				[148, 2],
				123,
				261,
				210,
				294,
				187,
				244,
				[0, 20],
			],
			[
				[0, 25],
				246,
				139,
				[145, 2],
				[285, 2],
				146,
				271,
				295,
				236,
				[147, 3],
				238,
				[123, 2],
				139,
				147,
				238,
				186,
				[209, 2],
				239,
				213,
				209,
				[230, 2],
				[229, 3],
				[230, 2],
				209,
				213,
				[238, 3],
				[213, 3],
				[209, 3],
				186,
				268,
				123,
				268,
				[148, 2],
				123,
				119,
				105,
				210,
				296,
				[0, 21],
			],
			[
				[0, 26],
				277,
				129,
				121,
				146,
				297,
				271,
				298,
				299,
				234,
				[238, 2],
				[239, 2],
				268,
				147,
				300,
				147,
				[238, 2],
				[214, 2],
				186,
				[213, 2],
				221,
				[230, 2],
				257,
				228,
				257,
				228,
				230,
				221,
				213,
				[238, 2],
				[213, 2],
				[209, 4],
				239,
				[268, 5],
				148,
				113,
				123,
				277,
				1,
				[0, 21],
			],
			[
				[0, 26],
				294,
				122,
				[146, 2],
				[138, 2],
				295,
				299,
				217,
				147,
				239,
				230,
				221,
				213,
				224,
				214,
				[225, 2],
				284,
				[226, 3],
				225,
				224,
				222,
				[227, 2],
				228,
				229,
				[257, 3],
				229,
				213,
				238,
				239,
				213,
				[209, 4],
				231,
				209,
				[239, 4],
				186,
				148,
				107,
				301,
				[0, 23],
			],
			[
				[0, 27],
				84,
				[146, 2],
				138,
				[298, 2],
				[138, 2],
				302,
				239,
				230,
				224,
				214,
				226,
				169,
				137,
				200,
				169,
				248,
				215,
				[291, 2],
				186,
				291,
				212,
				213,
				221,
				230,
				228,
				[246, 2],
				228,
				213,
				238,
				239,
				[209, 3],
				[231, 3],
				209,
				201,
				239,
				[201, 2],
				239,
				95,
				25,
				8,
				3,
				[0, 22],
			],
			[
				[0, 27],
				277,
				146,
				208,
				138,
				298,
				[138, 3],
				234,
				209,
				221,
				215,
				137,
				[121, 2],
				129,
				138,
				139,
				[169, 2],
				[215, 2],
				248,
				95,
				186,
				213,
				209,
				213,
				209,
				229,
				246,
				257,
				209,
				213,
				209,
				[231, 3],
				[209, 2],
				231,
				[209, 5],
				239,
				267,
				16,
				13,
				11,
				[0, 22],
			],
			[
				[0, 27],
				294,
				137,
				[138, 5],
				217,
				238,
				221,
				214,
				137,
				145,
				[127, 2],
				122,
				303,
				139,
				103,
				147,
				[186, 2],
				268,
				[239, 2],
				[213, 4],
				209,
				228,
				257,
				221,
				[209, 2],
				[231, 2],
				[209, 4],
				230,
				[231, 3],
				209,
				239,
				107,
				59,
				11,
				59,
				11,
				[0, 21],
			],
			[
				[0, 28],
				95,
				[138, 4],
				304,
				302,
				213,
				230,
				239,
				139,
				121,
				127,
				145,
				292,
				[305, 2],
				306,
				268,
				193,
				[268, 2],
				239,
				268,
				238,
				[213, 2],
				209,
				230,
				228,
				257,
				230,
				209,
				221,
				[231, 2],
				[209, 4],
				[230, 4],
				209,
				201,
				27,
				35,
				21,
				14,
				20,
				[0, 21],
			],
			[
				[0, 28],
				244,
				139,
				138,
				[298, 2],
				217,
				234,
				213,
				219,
				239,
				147,
				121,
				127,
				145,
				119,
				182,
				307,
				308,
				103,
				308,
				309,
				123,
				[300, 2],
				310,
				238,
				213,
				209,
				229,
				257,
				246,
				229,
				230,
				221,
				[209, 6],
				[230, 2],
				229,
				[231, 2],
				250,
				14,
				2,
				8,
				311,
				14,
				[0, 21],
			],
			[
				[0, 29],
				95,
				217,
				295,
				[217, 2],
				234,
				238,
				209,
				239,
				148,
				121,
				127,
				118,
				[184, 2],
				199,
				[112, 2],
				120,
				112,
				103,
				139,
				300,
				268,
				239,
				209,
				230,
				257,
				[246, 2],
				229,
				230,
				[209, 2],
				201,
				[239, 2],
				[209, 2],
				230,
				[229, 2],
				230,
				231,
				9,
				6,
				6,
				8,
				312,
				6,
				[0, 21],
			],
			[
				[0, 29],
				293,
				[217, 3],
				299,
				[302, 2],
				[239, 2],
				148,
				121,
				127,
				126,
				117,
				118,
				119,
				129,
				122,
				129,
				92,
				175,
				148,
				147,
				268,
				197,
				209,
				228,
				246,
				[251, 2],
				229,
				231,
				[209, 2],
				[239, 3],
				209,
				[230, 2],
				229,
				230,
				229,
				13,
				5,
				2,
				11,
				312,
				8,
				8,
				1,
				[0, 20],
			],
			[
				[0, 30],
				186,
				[217, 4],
				302,
				209,
				239,
				123,
				129,
				127,
				136,
				118,
				127,
				[129, 2],
				112,
				[139, 2],
				103,
				148,
				[239, 3],
				231,
				257,
				246,
				251,
				246,
				313,
				[209, 3],
				[239, 2],
				[209, 2],
				230,
				[229, 3],
				314,
				8,
				2,
				7,
				54,
				54,
				8,
				315,
				11,
				2,
				22,
				[0, 18],
			],
			[
				[0, 30],
				293,
				[234, 2],
				[299, 2],
				302,
				209,
				239,
				123,
				122,
				207,
				127,
				128,
				112,
				137,
				[122, 2],
				139,
				234,
				186,
				95,
				239,
				197,
				230,
				229,
				257,
				[251, 2],
				294,
				[231, 2],
				209,
				201,
				239,
				[209, 2],
				230,
				[229, 3],
				316,
				13,
				86,
				4,
				14,
				311,
				5,
				317,
				318,
				319,
				1,
				6,
				5,
				6,
				[0, 16],
			],
			[
				[0, 30],
				1,
				95,
				[234, 2],
				302,
				234,
				230,
				231,
				239,
				139,
				146,
				121,
				139,
				122,
				103,
				175,
				123,
				139,
				147,
				238,
				197,
				213,
				209,
				229,
				316,
				246,
				[251, 2],
				246,
				231,
				[209, 5],
				[230, 2],
				229,
				313,
				229,
				5,
				11,
				1,
				320,
				14,
				5,
				8,
				23,
				16,
				5,
				1,
				1,
				6,
				5,
				5,
				4,
				[0, 14],
			],
			[
				[0, 30],
				11,
				290,
				234,
				238,
				234,
				238,
				213,
				228,
				231,
				197,
				148,
				139,
				147,
				103,
				[175, 2],
				123,
				103,
				268,
				[209, 2],
				230,
				229,
				257,
				[246, 2],
				[251, 2],
				246,
				231,
				[209, 4],
				[230, 3],
				229,
				316,
				6,
				11,
				1,
				6,
				321,
				5,
				320,
				322,
				54,
				311,
				319,
				6,
				2,
				6,
				11,
				5,
				8,
				21,
				[0, 13],
			],
			[
				[0, 22],
				260,
				[323, 11],
				324,
				213,
				209,
				[229, 2],
				230,
				275,
				[323, 5],
				325,
				123,
				326,
				209,
				229,
				257,
				[246, 2],
				251,
				260,
				[323, 4],
				[231, 4],
				260,
				[323, 4],
				8,
				1,
				4,
				[11, 3],
				14,
				311,
				8,
				5,
				8,
				11,
				4,
				0,
				1,
				6,
				8,
				327,
				8,
				6,
				[0, 11],
			],
			[
				[0, 22],
				260,
				[323, 11],
				324,
				[209, 2],
				231,
				[229, 2],
				260,
				[323, 5],
				324,
				268,
				198,
				231,
				257,
				246,
				[251, 3],
				260,
				[323, 4],
				[230, 4],
				260,
				[323, 4],
				2,
				1,
				21,
				109,
				7,
				321,
				8,
				328,
				14,
				10,
				2,
				22,
				1,
				0,
				2,
				14,
				5,
				5,
				8,
				327,
				8,
				2,
				[0, 9],
			],
			[
				[0, 22],
				260,
				[323, 11],
				324,
				201,
				230,
				229,
				230,
				221,
				324,
				[323, 6],
				329,
				198,
				231,
				246,
				251,
				1,
				[251, 2],
				260,
				[323, 4],
				[230, 4],
				260,
				[323, 4],
				0,
				7,
				2,
				2,
				11,
				5,
				11,
				11,
				54,
				8,
				2,
				29,
				6,
				1,
				6,
				5,
				59,
				322,
				315,
				8,
				322,
				54,
				8,
				4,
				[0, 7],
			],
			[
				[0, 22],
				260,
				[323, 4],
				220,
				330,
				[244, 2],
				294,
				331,
				123,
				231,
				[209, 2],
				230,
				228,
				259,
				[323, 7],
				332,
				333,
				231,
				[251, 5],
				260,
				[323, 4],
				229,
				[230, 2],
				229,
				260,
				[323, 4],
				4,
				2,
				28,
				6,
				11,
				11,
				7,
				322,
				9,
				5,
				2,
				14,
				40,
				1,
				22,
				8,
				64,
				26,
				16,
				315,
				14,
				26,
				318,
				322,
				59,
				11,
				[0, 5],
			],
			[
				[0, 22],
				260,
				[323, 4],
				244,
				334,
				244,
				294,
				246,
				229,
				122,
				239,
				[221, 2],
				[227, 2],
				335,
				[323, 3],
				336,
				[323, 4],
				302,
				230,
				246,
				251,
				[246, 3],
				260,
				[323, 4],
				228,
				229,
				257,
				246,
				260,
				[323, 4],
				0,
				1,
				7,
				6,
				6,
				2,
				8,
				27,
				10,
				35,
				5,
				59,
				40,
				1,
				6,
				322,
				337,
				26,
				59,
				20,
				14,
				338,
				14,
				311,
				59,
				59,
				14,
				6,
				[0, 3],
			],
			[
				[0, 22],
				260,
				[323, 4],
				334,
				187,
				41,
				316,
				246,
				257,
				122,
				137,
				213,
				[221, 2],
				339,
				[323, 4],
				236,
				336,
				[323, 3],
				340,
				229,
				[257, 2],
				[229, 2],
				257,
				260,
				[323, 4],
				246,
				[251, 2],
				6,
				341,
				[323, 4],
				0,
				4,
				7,
				[2, 3],
				54,
				9,
				14,
				58,
				14,
				9,
				35,
				1,
				8,
				312,
				342,
				343,
				13,
				58,
				5,
				8,
				[14, 3],
				8,
				321,
				5,
				344,
				5,
				2,
			],
			[
				[0, 22],
				260,
				[323, 4],
				[244, 2],
				316,
				257,
				246,
				345,
				[292, 2],
				146,
				238,
				224,
				260,
				[323, 3],
				335,
				238,
				346,
				[323, 3],
				324,
				230,
				228,
				[230, 3],
				229,
				260,
				[323, 4],
				1,
				1,
				11,
				11,
				347,
				[323, 4],
				1,
				4,
				4,
				[2, 3],
				317,
				311,
				8,
				13,
				59,
				10,
				41,
				2,
				59,
				322,
				16,
				10,
				58,
				58,
				35,
				35,
				8,
				[311, 3],
				59,
				311,
				14,
				8,
				14,
			],
			[
				[0, 22],
				260,
				[323, 11],
				348,
				292,
				146,
				234,
				324,
				[323, 3],
				253,
				238,
				122,
				324,
				[323, 3],
				263,
				[221, 2],
				230,
				231,
				230,
				260,
				[323, 4],
				1,
				6,
				8,
				14,
				260,
				[323, 4],
				1,
				1,
				2,
				6,
				1,
				6,
				54,
				54,
				13,
				10,
				311,
				13,
				251,
				6,
				343,
				59,
				13,
				11,
				58,
				58,
				[233, 2],
				5,
				54,
				322,
				16,
				311,
				14,
				315,
				54,
				59,
			],
			[
				[0, 22],
				260,
				[323, 11],
				348,
				146,
				292,
				349,
				[323, 3],
				324,
				284,
				225,
				147,
				350,
				[323, 3],
				260,
				[221, 2],
				[209, 3],
				260,
				[323, 4],
				109,
				8,
				34,
				5,
				260,
				[323, 4],
				1,
				1,
				6,
				2,
				0,
				320,
				54,
				54,
				5,
				319,
				8,
				11,
				1,
				5,
				315,
				13,
				11,
				40,
				6,
				[233, 2],
				6,
				14,
				343,
				311,
				20,
				20,
				54,
				[322, 2],
				318,
			],
			[
				[0, 20],
				1,
				2,
				351,
				[323, 11],
				352,
				297,
				146,
				325,
				[323, 3],
				335,
				[214, 3],
				353,
				[323, 3],
				324,
				214,
				[213, 2],
				221,
				230,
				260,
				[323, 4],
				8,
				5,
				5,
				1,
				260,
				[323, 4],
				1,
				7,
				22,
				1,
				1,
				8,
				[315, 2],
				20,
				319,
				29,
				6,
				2,
				8,
				10,
				35,
				5,
				40,
				6,
				[233, 2],
				29,
				[8, 3],
				311,
				343,
				318,
				322,
				16,
				343,
			],
			[
				[0, 15],
				99,
				2,
				2,
				22,
				233,
				109,
				58,
				341,
				[323, 4],
				330,
				313,
				294,
				175,
				306,
				122,
				[282, 2],
				285,
				271,
				324,
				[323, 3],
				340,
				[226, 4],
				324,
				[323, 3],
				273,
				224,
				221,
				227,
				228,
				260,
				[323, 4],
				14,
				0,
				1,
				0,
				260,
				[323, 4],
				2,
				7,
				4,
				0,
				4,
				14,
				54,
				54,
				14,
				13,
				35,
				251,
				2,
				11,
				58,
				11,
				5,
				40,
				[233, 2],
				58,
				29,
				5,
				5,
				14,
				315,
				54,
				59,
				59,
				34,
				315,
			],
			[
				[0, 12],
				99,
				22,
				22,
				6,
				[109, 3],
				[58, 3],
				354,
				[323, 4],
				293,
				294,
				355,
				356,
				210,
				128,
				357,
				[282, 2],
				352,
				[323, 13],
				335,
				[213, 3],
				221,
				260,
				[323, 4],
				6,
				[0, 3],
				260,
				[323, 4],
				22,
				2,
				1,
				0,
				4,
				327,
				54,
				54,
				14,
				358,
				6,
				1,
				233,
				58,
				58,
				5,
				5,
				58,
				[233, 2],
				58,
				58,
				29,
				8,
				14,
				14,
				8,
				20,
				59,
				311,
				322,
			],
			[
				[0, 9],
				99,
				7,
				11,
				5,
				11,
				[109, 3],
				[58, 3],
				359,
				233,
				260,
				[323, 4],
				316,
				294,
				287,
				360,
				112,
				145,
				[282, 3],
				350,
				[323, 14],
				236,
				234,
				214,
				224,
				260,
				[323, 4],
				[0, 4],
				260,
				[323, 4],
				22,
				1,
				0,
				0,
				7,
				14,
				59,
				9,
				8,
				11,
				2,
				48,
				6,
				11,
				11,
				40,
				13,
				6,
				233,
				361,
				58,
				58,
				5,
				13,
				8,
				13,
				13,
				5,
				5,
				8,
				322,
			],
			[
				[0, 7],
				4,
				6,
				36,
				5,
				5,
				11,
				58,
				[109, 2],
				58,
				11,
				11,
				29,
				58,
				251,
				260,
				[323, 4],
				251,
				233,
				114,
				89,
				112,
				153,
				289,
				362,
				363,
				[323, 15],
				364,
				234,
				214,
				224,
				260,
				[323, 4],
				[0, 4],
				260,
				[323, 4],
				2,
				[0, 3],
				21,
				338,
				8,
				319,
				5,
				35,
				48,
				22,
				11,
				5,
				11,
				40,
				40,
				[233, 2],
				361,
				58,
				40,
				[5, 3],
				29,
				6,
				6,
				11,
				14,
				59,
			],
			[
				[0, 6],
				21,
				[5, 4],
				36,
				11,
				58,
				58,
				11,
				29,
				[58, 3],
				48,
				2,
				260,
				[323, 4],
				1,
				279,
				193,
				105,
				113,
				162,
				153,
				145,
				365,
				[323, 3],
				366,
				185,
				153,
				205,
				145,
				[146, 2],
				138,
				367,
				[323, 3],
				324,
				234,
				214,
				221,
				260,
				[323, 4],
				[0, 4],
				260,
				[323, 4],
				1,
				0,
				0,
				1,
				5,
				8,
				8,
				5,
				358,
				6,
				99,
				6,
				5,
				319,
				8,
				5,
				[233, 2],
				361,
				58,
				58,
				29,
				29,
				11,
				6,
				233,
				6,
				11,
				5,
				20,
				14,
			],
			[
				[0, 4],
				4,
				11,
				5,
				8,
				8,
				5,
				36,
				5,
				36,
				11,
				36,
				29,
				58,
				58,
				109,
				48,
				41,
				41,
				260,
				[323, 4],
				233,
				219,
				368,
				369,
				137,
				[162, 2],
				282,
				370,
				[323, 3],
				371,
				[153, 3],
				145,
				285,
				146,
				138,
				329,
				[323, 4],
				353,
				213,
				229,
				354,
				[323, 4],
				[0, 4],
				260,
				[323, 12],
				372,
				2,
				48,
				58,
				13,
				13,
				319,
				5,
				[233, 2],
				58,
				58,
				29,
				29,
				11,
				58,
				22,
				22,
				11,
				36,
				5,
				20,
				14,
			],
			[
				[0, 3],
				2,
				5,
				63,
				344,
				5,
				5,
				36,
				29,
				63,
				63,
				29,
				29,
				[58, 3],
				233,
				2,
				48,
				251,
				260,
				[323, 4],
				244,
				290,
				373,
				124,
				121,
				162,
				181,
				185,
				[323, 4],
				363,
				[282, 2],
				145,
				285,
				146,
				297,
				271,
				138,
				370,
				[323, 3],
				336,
				230,
				40,
				351,
				[323, 4],
				[0, 4],
				260,
				[323, 12],
				258,
				2,
				233,
				36,
				8,
				5,
				5,
				40,
				233,
				361,
				58,
				29,
				29,
				58,
				11,
				109,
				22,
				6,
				36,
				29,
				8,
				14,
				8,
			],
			[
				0,
				0,
				2,
				29,
				63,
				344,
				5,
				5,
				36,
				36,
				[12, 3],
				5,
				[58, 3],
				6,
				[233, 2],
				48,
				251,
				260,
				[323, 4],
				187,
				244,
				72,
				93,
				207,
				[162, 2],
				374,
				[323, 3],
				370,
				[282, 2],
				[145, 3],
				[362, 2],
				146,
				271,
				325,
				[323, 3],
				324,
				232,
				58,
				260,
				[323, 4],
				[0, 4],
				260,
				[323, 12],
				291,
				1,
				109,
				5,
				8,
				13,
				29,
				58,
				375,
				[58, 3],
				[22, 3],
				2,
				22,
				11,
				11,
				36,
				8,
				8,
				319,
			],
			[
				0,
				4,
				[5, 5],
				29,
				29,
				12,
				376,
				12,
				12,
				11,
				359,
				36,
				6,
				109,
				22,
				233,
				48,
				[251, 2],
				233,
				48,
				1,
				48,
				293,
				290,
				106,
				113,
				153,
				132,
				[181, 2],
				163,
				126,
				153,
				362,
				[282, 6],
				145,
				285,
				146,
				271,
				377,
				235,
				284,
				242,
				58,
				1,
				[0, 10],
				[1, 3],
				[0, 3],
				22,
				5,
				5,
				58,
				5,
				11,
				2,
				2,
				58,
				8,
				8,
				13,
				29,
				58,
				58,
				220,
				35,
				99,
				4,
				109,
				6,
				4,
				6,
				29,
				29,
				11,
				[5, 3],
			],
		],
	};


  // project-rome/@internal/cli-diagnostics/DiagnosticsPrinter.ts
const ___R$$priv$project$rome$$internal$cli$diagnostics$DiagnosticsPrinter_ts$DEFAULT_FILE_READERS = {
		async read(path) {
			if (
				(await ___R$project$rome$$internal$fs$index_ts$exists(path)) &&
				(await ___R$project$rome$$internal$fs$index_ts$lstat(path)).isFile()
			) {
				return await ___R$project$rome$$internal$fs$index_ts$readFileText(path);
			} else {
				return undefined;
			}
		},

		async getMtime(path) {
			if (await ___R$project$rome$$internal$fs$index_ts$exists(path)) {
				const stats = await ___R$project$rome$$internal$fs$index_ts$lstat(path);
				return stats.mtimeMs;
			} else {
				return undefined;
			}
		},
	};

	function ___R$$priv$project$rome$$internal$cli$diagnostics$DiagnosticsPrinter_ts$equalPosition(
		a,
		b,
	) {
		if (a === undefined || b === undefined) {
			return false;
		}

		if (a.line !== b.line || a.column !== b.column) {
			return false;
		}

		return true;
	}

	const ___R$project$rome$$internal$cli$diagnostics$DiagnosticsPrinter_ts$DEFAULT_PRINTER_FLAGS = {
		auxiliaryDiagnosticFormat: undefined,
		grep: "",
		inverseGrep: false,
		showAllDiagnostics: true,
		fieri: false,
		verboseDiagnostics: false,
		maxDiagnostics: 20,
	};

	function ___R$$priv$project$rome$$internal$cli$diagnostics$DiagnosticsPrinter_ts$hasFrame(
		loc,
	) {
		return loc.start !== undefined && loc.end !== undefined;
	}

	class ___R$project$rome$$internal$cli$diagnostics$DiagnosticsPrinter_ts$default
		extends Error {
		constructor(opts) {
			super(
				"Diagnostics printer. If you're seeing this then it wasn't caught and printed correctly.",
			);
			const {
				cwd,
				reporter,
				flags = ___R$project$rome$$internal$cli$diagnostics$DiagnosticsPrinter_ts$DEFAULT_PRINTER_FLAGS,
			} = opts;

			this.options = opts;

			this.reporter = reporter;
			this.flags = flags;
			this.fileReaders =
				opts.fileReaders === undefined
					? [
							___R$$priv$project$rome$$internal$cli$diagnostics$DiagnosticsPrinter_ts$DEFAULT_FILE_READERS,
						]
					: [
							opts.fileReaders,
							___R$$priv$project$rome$$internal$cli$diagnostics$DiagnosticsPrinter_ts$DEFAULT_FILE_READERS,
						];
			this.cwd =
				cwd == null ? ___R$project$rome$$internal$path$index_ts$CWD_PATH : cwd;
			this.processor = opts.processor;

			this.displayedCount = 0;
			this.problemCount = 0;
			this.filteredCount = 0;
			this.truncatedCount = 0;

			this.defaultFooterEnabled = true;
			this.hasTruncatedDiagnostics = false;
			this.missingFileSources = new ___R$project$rome$$internal$path$collections_ts$UnknownPathSet();
			this.fileSources = new ___R$project$rome$$internal$path$collections_ts$UnknownPathMap();
			this.fileMtimes = new ___R$project$rome$$internal$path$collections_ts$UnknownPathMap();
			this.onFooterPrintCallbacks = [];
		}

		createFilePath(filename) {
			const {normalizePosition} = this.reporter.markupOptions;

			if (normalizePosition === undefined) {
				return ___R$project$rome$$internal$path$index_ts$createUnknownPath(
					filename,
				);
			} else {
				return ___R$project$rome$$internal$path$index_ts$createUnknownPath(
					normalizePosition(filename, undefined, undefined).filename,
				);
			}
		}

		getDisplayedProblemsCount() {
			return this.problemCount - this.filteredCount;
		}

		shouldTruncate() {
			return (
				!this.flags.showAllDiagnostics &&
				this.displayedCount > this.flags.maxDiagnostics
			);
		}

		shouldIgnore(diag) {
			const {grep, inverseGrep} = this.flags;

			// An empty grep pattern means show everything
			if (grep === undefined || grep === "") {
				return false;
			}

			// Match against the supplied grep pattern
			let ignored =
				___R$project$rome$$internal$cli$layout$format_ts$markupToJoinedPlainText(
					diag.description.message,
				).toLowerCase().includes(grep) === false;
			if (inverseGrep) {
				ignored = !ignored;
			}
			return ignored;
		}

		// Only highlight if we have a reporter stream enabled that isn't format: "none"
		shouldHighlight() {
			for (const {stream} of this.reporter.getStreamHandles()) {
				if (stream.format !== "none") {
					return true;
				}
			}
			return false;
		}

		async addFileSource(dep) {
			const path = dep.path.assertAbsolute();

			let mtime;
			for (const reader of this.fileReaders) {
				if (mtime !== undefined) {
					break;
				}
				mtime = await reader.getMtime(path);
			}
			if (mtime === undefined) {
				this.missingFileSources.add(path);
				return;
			}

			this.fileMtimes.set(dep.path, mtime);

			if (dep.type === "reference") {
				let sourceText = dep.sourceText;
				for (const reader of this.fileReaders) {
					if (sourceText !== undefined) {
						break;
					}
					sourceText = await reader.read(path);
				}
				if (sourceText === undefined) {
					this.missingFileSources.add(path);
					return;
				}

				this.fileSources.set(
					dep.path,
					{
						sourceText,
						lines: ___R$project$rome$$internal$cli$diagnostics$utils_ts$toLines({
							highlight: this.shouldHighlight(),
							path: dep.path,
							input: sourceText,
							sourceTypeJS: dep.sourceTypeJS,
							language: ___R$project$rome$$internal$core$common$file$handlers$index_ts$inferDiagnosticLanguageFromFilename(
								dep.path,
								dep.language,
							),
						}),
					},
				);
			}
		}

		getDependenciesFromDiagnostics(diagnostics) {
			const deps = [];

			for (const diag of diagnostics) {
				const {
					dependencies,
					description: {advice},
					location: {language, sourceTypeJS, sourceText, mtime, filename},
				} = diag;

				if (filename !== undefined) {
					const path = this.createFilePath(filename);
					if (
						___R$$priv$project$rome$$internal$cli$diagnostics$DiagnosticsPrinter_ts$hasFrame(
							diag.location,
						)
					) {
						deps.push({
							type: "reference",
							path,
							mtime,
							language,
							sourceTypeJS,
							sourceText,
						});
					} else {
						deps.push({
							type: "change",
							path,
							mtime,
						});
					}
				}

				if (dependencies !== undefined) {
					for (const {filename, mtime} of dependencies) {
						deps.push({
							type: "change",
							path: this.createFilePath(filename),
							mtime,
						});
					}
				}

				for (const item of advice) {
					if (item.type === "frame") {
						const {location} = item;
						if (location.filename !== undefined) {
							const path = this.createFilePath(location.filename);
							if (
								___R$$priv$project$rome$$internal$cli$diagnostics$DiagnosticsPrinter_ts$hasFrame(
									location,
								)
							) {
								deps.push({
									type: "reference",
									path,
									language: location.language,
									sourceTypeJS: location.sourceTypeJS,
									mtime: location.mtime,
									sourceText: location.sourceText,
								});
							} else {
								deps.push({
									type: "change",
									path,
									mtime,
								});
							}
						}
					}

					if (item.type === "stacktrace") {
						for (const {filename, line, column, sourceText} of item.frames) {
							if (filename !== undefined) {
								const path = this.createFilePath(filename);
								if (line !== undefined && column !== undefined) {
									deps.push({
										type: "reference",
										path,
										language: undefined,
										sourceTypeJS: undefined,
										mtime: undefined,
										sourceText,
									});
								} else {
									deps.push({
										type: "change",
										path,
										mtime: undefined,
									});
								}
							}
						}
					}
				}
			}

			const depsMap = new ___R$project$rome$$internal$path$collections_ts$UnknownPathMap();

			// Remove non-absolute filenames and normalize sourceType and language for conflicts
			for (const dep of deps) {
				const path = dep.path;
				if (!path.isAbsolute()) {
					continue;
				}

				const existing = depsMap.get(path);

				// "reference" dependency can override "change" since it has more metadata that needs conflict resolution
				if (existing === undefined || existing.type === "change") {
					depsMap.set(dep.path, dep);
					continue;
				}

				if (dep.type === "reference") {
					if (
						dep.sourceText !== undefined &&
						existing.sourceText !== undefined &&
						dep.sourceText !== existing.sourceText
					) {
						throw new Error(
							"Found multiple sourceText entires for " +
							dep.path.join() +
							" that didn't match",
						);
					}

					if (existing.sourceText === undefined) {
						existing.sourceText = dep.sourceText;
					}

					if (existing.sourceTypeJS !== dep.sourceTypeJS) {
						existing.sourceTypeJS = "unknown";
					}

					if (existing.language !== dep.language) {
						existing.language = "unknown";
					}
				}
			}

			return Array.from(depsMap.values());
		}

		async fetchFileSources(diagnostics) {
			for (const dep of this.getDependenciesFromDiagnostics(diagnostics)) {
				const {path} = dep;
				if (!path.isAbsolute()) {
					continue;
				}

				await this.wrapError(
					"addFileSource(" + dep.path.join() + ")",
					() => this.addFileSource(dep),
				);
			}
		}

		async print() {
			await this.wrapError(
				"root",
				async () => {
					const filteredDiagnostics = this.filterDiagnostics();
					await this.fetchFileSources(filteredDiagnostics);
					await this.printDiagnostics(filteredDiagnostics);
				},
			);
		}

		async wrapError(reason, callback) {
			const {reporter} = this;
			try {
				await callback();
			} catch (err) {
				if (!this.options.wrapErrors) {
					throw err;
				}

				// Sometimes we'll run into issues displaying diagnostics
				// We can safely catch them here since the presence of diagnostics is considered a critical failure anyway
				// Display diagnostics is idempotent meaning we can bail at any point
				// We don't use reporter.error here since the error could have been thrown by cli-layout
				reporter.logRaw(
					"Encountered an error during diagnostics printing in " + reason,
				);
				reporter.logRaw(err.stack);
			}
		}

		async printDiagnostics(diagnostics) {
			const {reporter} = this;
			const restoreRedirect = reporter.redirectOutToErr(true);

			for (const diag of diagnostics) {
				this.printAuxiliaryDiagnostic(diag);
			}

			for (const diag of diagnostics) {
				await this.wrapError(
					"printDiagnostic",
					async () => this.printDiagnostic(diag),
				);
			}

			reporter.redirectOutToErr(restoreRedirect);
		}

		getOutdatedFiles(diag) {
			let outdatedFiles = new ___R$project$rome$$internal$path$collections_ts$UnknownPathSet();
			for (const {
				path,
				mtime: expectedMtime,
			} of this.getDependenciesFromDiagnostics([diag])) {
				const mtime = this.fileMtimes.get(path);

				// Consider us outdated if the other file is newer than what we want or doesn't have an mtime
				const isOutdated =
					mtime === undefined ||
					(expectedMtime !== undefined && mtime > expectedMtime);
				if (isOutdated) {
					outdatedFiles.add(path);
				}
			}
			return outdatedFiles;
		}

		printAuxiliaryDiagnostic(diag) {
			const {description: {message}, location: {start, filename}} = diag;

			switch (this.flags.auxiliaryDiagnosticFormat) {
				// https://docs.github.com/en/actions/reference/workflow-commands-for-github-actions#setting-an-error-message
				// Format: \:\:error file=app.js,line=10,col=15::Something went wrong
				// TODO escaping
				case "github-actions": {
					const parts = [];

					if (filename !== undefined) {
						const path = ___R$project$rome$$internal$path$index_ts$createUnknownPath(
							filename,
						);

						if (path.isAbsolute() && path.isRelativeTo(this.cwd)) {
							parts.push("file=" + this.cwd.relative(path).join());
						} else {
							parts.push("file=" + filename);
						}
					}

					if (start !== undefined) {
						if (start.line !== undefined) {
							parts.push(
								"line=" +
								___R$project$rome$$internal$ob1$index_ts$ob1Get1(start.line),
							);
						}

						if (start.column !== undefined) {
							parts.push(
								"col=" +
								___R$project$rome$$internal$ob1$index_ts$ob1Get0(start.column),
							);
						}
					}

					let log =
						"::error " +
						parts.join(",") +
						"::" +
						___R$project$rome$$internal$markup$normalize_ts$joinMarkupLines(
							___R$project$rome$$internal$cli$layout$format_ts$markupToPlainText(
								message,
							),
						);
					this.reporter.logRaw(log);
					break;
				}
			}
		}

		printDiagnostic(diag) {
			const {reporter} = this;
			const {start, end, filename} = diag.location;
			let advice = [...diag.description.advice];

			// Remove stacktrace from beginning if it contains only one frame that matches the root diagnostic location
			const firstAdvice = advice[0];
			if (
				firstAdvice !== undefined &&
				firstAdvice.type === "stacktrace" &&
				firstAdvice.frames.length === 1
			) {
				const frame = firstAdvice.frames[0];
				if (
					frame.filename === filename &&
					___R$$priv$project$rome$$internal$cli$diagnostics$DiagnosticsPrinter_ts$equalPosition(
						frame,
						start,
					)
				) {
					advice.shift();
				}
			}

			// Determine if we should skip showing the frame at the top of the diagnostic output
			// We check if there are any frame advice entries that match us exactly, this is
			// useful for simplifying stacktraces
			let skipFrame = false;
			if (start !== undefined && end !== undefined) {
				adviceLoop: for (const item of advice) {
					if (
						item.type === "frame" &&
						item.location.filename === filename &&
						___R$$priv$project$rome$$internal$cli$diagnostics$DiagnosticsPrinter_ts$equalPosition(
							item.location.start,
							start,
						) &&
						___R$$priv$project$rome$$internal$cli$diagnostics$DiagnosticsPrinter_ts$equalPosition(
							item.location.end,
							end,
						)
					) {
						skipFrame = true;
						break;
					}

					if (item.type === "stacktrace") {
						for (const frame of item.frames) {
							if (
								frame.filename === filename &&
								___R$$priv$project$rome$$internal$cli$diagnostics$DiagnosticsPrinter_ts$equalPosition(
									frame,
									start,
								)
							) {
								skipFrame = true;
								break adviceLoop;
							}
						}
					}
				}
			}

			// Check for outdated files
			const outdatedAdvice = [];
			const outdatedFiles = this.getOutdatedFiles(diag);

			// Check if this file doesn't even exist
			if (filename !== undefined) {
				const path = this.createFilePath(filename);
				const isMissing = this.missingFileSources.has(path);
				if (isMissing) {
					outdatedAdvice.push({
						type: "log",
						category: "warn",
						text: ___R$project$rome$$internal$markup$escape_ts$markup`This diagnostic refers to a file that does not exist`,
					});
					// Don't need to duplicate this path
					outdatedFiles.delete(path);
					skipFrame = true;
				}
			}

			// List outdated
			const isOutdated = outdatedFiles.size > 0;
			if (isOutdated) {
				const outdatedFilesArr = Array.from(
					outdatedFiles,
					(path) => path.join(),
				);

				if (outdatedFilesArr.length === 1 && outdatedFilesArr[0] === filename) {
					outdatedAdvice.push({
						type: "log",
						category: "warn",
						text: ___R$project$rome$$internal$markup$escape_ts$markup`This file has been changed since the diagnostic was produced and may be out of date`,
					});
				} else {
					outdatedAdvice.push({
						type: "log",
						category: "warn",
						text: ___R$project$rome$$internal$markup$escape_ts$markup`This diagnostic may be out of date as it relies on the following files that have been changed since the diagnostic was generated`,
					});

					outdatedAdvice.push({
						type: "list",
						list: outdatedFilesArr.map((filename) =>
							___R$project$rome$$internal$markup$escape_ts$markup`<filelink target="${filename}" />`
						),
					});
				}
			}

			const derived = ___R$project$rome$$internal$diagnostics$derive_ts$deriveRootAdviceFromDiagnostic(
				diag,
				{
					skipFrame,
					includeHeaderInAdvice: false,
					outdated: isOutdated,
				},
			);

			reporter.hr(derived.header);

			reporter.indentSync(() => {
				// Concat all the advice together
				const allAdvice = [
					...derived.advice,
					...outdatedAdvice,
					...advice,
					...derived.lastAdvice,
				];

				const {truncated} = ___R$project$rome$$internal$cli$diagnostics$printAdvice_ts$printAdvice(
					allAdvice,
					{
						printer: this,
						flags: this.flags,
						missingFileSources: this.missingFileSources,
						fileSources: this.fileSources,
						diagnostic: diag,
						reporter,
					},
				);

				if (truncated) {
					this.hasTruncatedDiagnostics = true;
				}

				// Print verbose information
				if (this.flags.verboseDiagnostics === true) {
					const {origins} = diag;

					if (origins !== undefined && origins.length > 0) {
						reporter.br();
						reporter.info(
							___R$project$rome$$internal$markup$escape_ts$markup`Why are you seeing this diagnostic?`,
						);
						reporter.br();
						reporter.list(
							origins.map((origin) => {
								let res = ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${origin.category}</emphasis>`;
								if (origin.message !== undefined) {
									res = ___R$project$rome$$internal$markup$escape_ts$markup`${res}: ${origin.message}`;
								}
								return res;
							}),
							{ordered: true},
						);
					}
				}
			});
		}

		filterDiagnostics() {
			const diagnostics = this.processor.getDiagnostics();
			const filteredDiagnostics = [];

			for (const diag of diagnostics) {
				this.problemCount++;

				if (this.shouldIgnore(diag)) {
					this.filteredCount++;
				} else if (this.shouldTruncate()) {
					this.truncatedCount++;
				} else {
					this.displayedCount++;
					filteredDiagnostics.push(diag);
				}
			}

			return filteredDiagnostics;
		}

		inject(title, printer) {
			this.processor.addDiagnostics(printer.processor.getDiagnostics());

			const {onFooterPrintCallbacks} = printer;
			if (onFooterPrintCallbacks.length === 0) {
				return;
			}

			this.onFooterPrint(
				async (reporter) => {
					reporter.br();
					reporter.log(
						___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${title}</emphasis>`,
					);
					reporter.br();

					await reporter.indent(async () => {
						// Include a more specific "X problems found" for each command
						const hasProblems = printer.hasProblems();
						if (hasProblems) {
							printer.defaultFooter();
						}

						for (const {callback} of onFooterPrintCallbacks) {
							await callback(reporter, hasProblems);
						}
					});

					reporter.br();
				},
				true,
			);
		}

		onFooterPrint(callback, after = false) {
			this.onFooterPrintCallbacks.push({callback, after});
		}

		hasProblems() {
			return this.problemCount > 0;
		}

		disableDefaultFooter() {
			this.defaultFooterEnabled = false;
		}

		defaultFooter() {
			const {reporter} = this;
			if (!this.defaultFooterEnabled) {
				return;
			}

			if (this.hasProblems()) {
				const {reporter, filteredCount} = this;

				const displayableProblems = this.getDisplayedProblemsCount();
				let str = ___R$project$rome$$internal$markup$escape_ts$markup`Found <emphasis>${displayableProblems}</emphasis> <grammarNumber plural="problems" singular="problem">${String(
					displayableProblems,
				)}</grammarNumber>`;

				if (filteredCount > 0) {
					str = ___R$project$rome$$internal$markup$escape_ts$markup`${str} <dim>(${filteredCount} filtered)</dim>`;
				}

				reporter.error(str);
			} else {
				reporter.success(
					___R$project$rome$$internal$markup$escape_ts$markup`No known problems!`,
				);
			}
		}

		async footer() {
			await this.wrapError(
				"footer",
				async () => {
					const {reporter} = this;
					const isError = this.hasProblems();

					if (isError) {
						const restoreRedirect = reporter.redirectOutToErr(true);
						reporter.hr();
						reporter.redirectOutToErr(restoreRedirect);
					}

					const displayableProblems = this.getDisplayedProblemsCount();
					if (this.truncatedCount > 0) {
						const {maxDiagnostics} = this.flags;
						reporter.warn(
							___R$project$rome$$internal$markup$escape_ts$markup`Only <emphasis>${maxDiagnostics}</emphasis> errors shown. Add the <code>--show-all-diagnostics</code> flag or specify <code>--max-diagnostics ${"<num>"}</code> to view the remaining ${displayableProblems -
							maxDiagnostics} errors`,
						);
					}

					if (this.hasTruncatedDiagnostics) {
						reporter.warn(
							___R$project$rome$$internal$markup$escape_ts$markup`Some diagnostics have been truncated. Use the --verbose-diagnostics flag to disable truncation.`,
						);
					}

					if (this.hasTruncatedDiagnostics || this.truncatedCount > 0) {
						reporter.br();
					}

					if (isError) {
						if (this.flags.fieri) {
							this.showBanner(
								(___R$project$rome$$internal$cli$diagnostics$banners$error_json$default),
							);
						}
					} else {
						if (this.flags.fieri) {
							this.showBanner(
								(___R$project$rome$$internal$cli$diagnostics$banners$success_json$default),
							);
						}
					}

					for (const {callback, after} of this.onFooterPrintCallbacks) {
						if (!after) {
							await callback(reporter, isError);
						}
					}

					this.defaultFooter();

					for (const {callback, after} of this.onFooterPrintCallbacks) {
						if (after) {
							await callback(reporter, isError);
						}
					}
				},
			);
		}

		showBanner(banner) {
			for (const {stream} of this.reporter.getStreamHandles()) {
				if (stream.format !== "ansi") {
					continue;
				}

				const text = "FLAVORTOWN";
				let textIndex = 0;
				let height = 0;
				let width = 0;

				let image = [];

				// Decompress banner
				for (const row of banner.rows) {
					const unpackedRow = [];

					for (const field of row) {
						let palleteIndex;
						let times = 1;
						if (Array.isArray(field)) {
							[palleteIndex, times] = field;
						} else {
							palleteIndex = field;
						}

						const pallete = banner.palettes[palleteIndex];
						for (let i = 0; i < times; i++) {
							unpackedRow.push(pallete);
						}
					}

					image.push(unpackedRow);
					if (unpackedRow.length > width) {
						width = unpackedRow.length;
					}
					height++;
				}

				// Calculate scale
				let scale =
					stream.features.columns === undefined
						? 1
						: ___R$project$rome$$internal$ob1$index_ts$ob1Get1(
								stream.features.columns,
							) / height;
				if (scale > 1) {
					scale = 1;
				}

				function averageColors(colors) {
					let averageColor = [0, 0, 0];

					for (const color of colors) {
						averageColor[0] += color[0];
						averageColor[1] += color[1];
						averageColor[2] += color[2];
					}

					return [
						Math.round(averageColor[0] / colors.length),
						Math.round(averageColor[1] / colors.length),
						Math.round(averageColor[2] / colors.length),
					];
				}

				// Scale image if necessary
				if (scale < 1) {
					const scaledHeight = Math.floor(height * scale);
					const scaledWidth = Math.floor(width * scale);
					const scaledImage = [];

					const heightRatio = width / scaledHeight;
					const widthRatio = width / scaledWidth;

					for (let i = 1; i <= scaledHeight; i++) {
						const start = Math.floor(i * heightRatio);
						const end = Math.ceil(i * heightRatio);

						// Scale height
						const scaledHeightRow = [];
						for (let i = 0; i < width; i++) {
							const colors = [];

							for (let x = start; x <= end; x++) {
								const color = image[x - 1][i];
								if (color !== undefined) {
									colors.push(color);
								}
							}

							scaledHeightRow.push(averageColors(colors));
						}

						// Scale width
						const scaledRow = [];
						for (let i = 1; i <= scaledWidth; i++) {
							const start = Math.floor(i * widthRatio);
							const end = Math.ceil(i * widthRatio);

							const colors = [];
							for (let i = start; i <= end; i++) {
								colors.push(scaledHeightRow[i - 1]);
							}

							scaledRow.push(averageColors(colors));
						}

						scaledImage.push(scaledRow);
					}

					image = scaledImage;
				}

				// Print image
				for (const row of image) {
					let line = "";

					for (const color of row) {
						let char = text[textIndex];
						textIndex++;
						if (textIndex === text.length) {
							textIndex = 0;
						}

						char = ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsiRGB({
							background: false,
							features: stream.features,
							value: char,
							color,
						});

						line += ___R$project$rome$$internal$cli$layout$ansi_ts$formatAnsiRGB({
							background: true,
							features: stream.features,
							value: char,
							color,
						});
					}

					stream.write(line + "\n", false);
				}
			}
		}
	}


  // project-rome/@internal/cli-diagnostics/index.ts
async function ___R$project$rome$$internal$cli$diagnostics$index_ts$printDiagnostics(
		{
			diagnostics,
			suppressions,
			printerOptions,
			excludeFooter,
		},
	) {
		const printer = new ___R$project$rome$$internal$cli$diagnostics$DiagnosticsPrinter_ts$default(
			printerOptions,
		);
		printer.processor.addDiagnostics(diagnostics);
		printer.processor.addSuppressions(suppressions);
		await printer.print();
		if (!excludeFooter || !printer.hasProblems()) {
			await printer.footer();
		}
		return printer;
	}

	async function ___R$project$rome$$internal$cli$diagnostics$index_ts$printDiagnosticsToString(
		opts,
	) {
		const reporter = new ___R$project$rome$$internal$cli$reporter$Reporter_ts$default();
		const stream = reporter.attachCaptureStream(opts.format, opts.features);
		await ___R$project$rome$$internal$cli$diagnostics$index_ts$printDiagnostics(
			Object.assign(
				{},
				opts,
				{
					printerOptions: Object.assign(
						{
							reporter,
							processor: new ___R$project$rome$$internal$diagnostics$DiagnosticsProcessor_ts$default(),
						},
						opts.printerOptions,
					),
				},
			),
		);
		return stream.read();
	}


  // project-rome/@internal/diagnostics/DiagnosticsNormalizer.ts
class ___R$project$rome$$internal$diagnostics$DiagnosticsNormalizer_ts$default {
		constructor(normalizeOptions, markupOptions, sourceMaps) {
			this.sourceMaps = sourceMaps;
			this.inlineSourceText = new Map();
			this.hasMarkupOptions = markupOptions !== undefined;

			this.hasOptions = normalizeOptions !== undefined;
			this.options = normalizeOptions == null ? {} : normalizeOptions;

			this.inlinedSourceTextFilenames = new Set();

			this.markupOptions = this.createMarkupOptions(markupOptions);
		}

		createMarkupOptions(markupOptions = {}) {
			const {sourceMaps} = this;

			return Object.assign(
				{},
				markupOptions,
				{
					normalizePosition: (filename, line, column) => {
						if (
							markupOptions !== undefined &&
							markupOptions.normalizePosition !== undefined
						) {
							({filename, line, column} = markupOptions.normalizePosition(
								filename,
								line,
								column,
							));
						}

						if (sourceMaps !== undefined) {
							// line and column can be undefined so we do some weirdness to try and get only the filename if possible
							// using some default positions and then we'll toss whatever positions they return
							const resolved = sourceMaps.approxOriginalPositionFor(
								filename,
								line == null
									? ___R$project$rome$$internal$ob1$index_ts$ob1Number1
									: line,
								column == null
									? ___R$project$rome$$internal$ob1$index_ts$ob1Number0
									: column,
							);
							if (resolved !== undefined) {
								return {
									filename: resolved.source,
									line: line === undefined ? undefined : resolved.line,
									column: column === undefined ? undefined : resolved.column,
								};
							}
						}

						return {filename, line, column};
					},
				},
			);
		}

		setInlineSourceText(filename, sourceText) {
			this.inlineSourceText.set(filename, sourceText);
		}

		normalizeFilename(filename) {
			const {markupOptions} = this;
			if (markupOptions === undefined || filename === undefined) {
				return filename;
			}

			const {normalizePosition} = markupOptions;
			if (normalizePosition === undefined) {
				return filename;
			}

			return normalizePosition(filename, undefined, undefined).filename;
		}

		normalizePositionValue(value) {
			if (this.markupOptions !== undefined && this.markupOptions.stripPositions) {
				return undefined;
			} else {
				return value;
			}
		}

		normalizeLocation(location) {
			const {sourceMaps} = this;
			if (sourceMaps === undefined) {
				return location;
			}

			let {marker, filename, start, end} = location;
			let origFilename = filename;

			if (filename !== undefined && origFilename !== undefined) {
				if (start !== undefined) {
					const resolved = sourceMaps.approxOriginalPositionFor(
						origFilename,
						start.line,
						start.column,
					);
					if (resolved !== undefined) {
						filename = resolved.source;
						start = Object.assign(
							{},
							start,
							{line: resolved.line, column: resolved.column},
						);
					}
				}

				if (end !== undefined) {
					const resolved = sourceMaps.approxOriginalPositionFor(
						origFilename,
						end.line,
						end.column,
					);
					if (resolved !== undefined) {
						// TODO confirm this is the same as `start` if it resolved
						filename = resolved.source;
						end = Object.assign(
							{},
							end,
							{line: resolved.line, column: resolved.column},
						);
					}
				}
			}

			const normalizedFilename = this.normalizeFilename(filename);

			// Inline sourceText. We keep track of filenames we've already inlined to avoid duplicating sourceText
			// During printing we'll fill it back in
			let {sourceText} = location;
			if (
				filename !== undefined &&
				!this.inlinedSourceTextFilenames.has(filename)
			) {
				if (sourceText === undefined) {
					sourceText = this.inlineSourceText.get(filename);
				}
				if (sourceText === undefined && normalizedFilename !== undefined) {
					sourceText = this.inlineSourceText.get(normalizedFilename);
				}

				// Remove sourceText if it's not pointing anywhere
				if (start === undefined && end === undefined) {
					sourceText = undefined;
				}

				// Register filename as inlined if necessary
				if (sourceText !== undefined) {
					this.inlinedSourceTextFilenames.add(filename);

					if (normalizedFilename !== undefined) {
						this.inlinedSourceTextFilenames.add(normalizedFilename);
					}
				}
			}

			return Object.assign(
				{},
				location,
				{
					sourceText,
					filename: normalizedFilename,
					marker: this.maybeNormalizeMarkup(marker),
					start: this.normalizePositionValue(start),
					end: this.normalizePositionValue(end),
				},
			);
		}

		normalizeMarkup(markup) {
			return ___R$project$rome$$internal$markup$normalize_ts$normalizeMarkup(
				markup,
				this.markupOptions,
			).text;
		}

		maybeNormalizeMarkup(markup) {
			return markup === undefined ? undefined : this.normalizeMarkup(markup);
		}

		normalizeDiagnosticAdviceItem(item) {
			const {sourceMaps} = this;

			switch (item.type) {
				case "frame":
					return Object.assign(
						{},
						item,
						{location: this.normalizeLocation(item.location)},
					);

				case "list":
					return Object.assign(
						{},
						item,
						{list: item.list.map((markup) => this.normalizeMarkup(markup))},
					);

				case "log":
					return Object.assign(
						{},
						item,
						{text: this.normalizeMarkup(item.text)},
					);

				case "action":
					if (this.markupOptions.stripPositions) {
						return Object.assign(
							{},
							item,
							{
								// Command flags could have position information
								commandFlags: {},
							},
						);
					} else {
						return item;
					}

				case "stacktrace":
					return Object.assign(
						{},
						item,
						{
							importantFilenames: (item.importantFilenames == null
								? []
								: item.importantFilenames).map((filename) =>
								this.normalizeFilename(filename)
							),
							frames: item.frames.map((frame) => {
								const {filename, line, column} = frame;

								if (
									filename === undefined ||
									line === undefined ||
									column === undefined ||
									(sourceMaps !== undefined && !sourceMaps.has(filename))
								) {
									return Object.assign(
										{},
										frame,
										{
											start: this.normalizePositionValue(line),
											column: this.normalizePositionValue(column),
											filename: this.normalizeFilename(filename),
										},
									);
								}

								if (sourceMaps !== undefined) {
									const resolved = sourceMaps.approxOriginalPositionFor(
										filename,
										line,
										column,
									);
									if (resolved !== undefined) {
										return Object.assign(
											{},
											frame,
											{
												filename: this.normalizeFilename(resolved.source),
												line: this.normalizePositionValue(resolved.line),
												column: this.normalizePositionValue(resolved.column),
											},
										);
									}
								}

								return frame;
							}),
						},
					);
			}

			return item;
		}

		normalizeDiagnostic(diag) {
			const {sourceMaps} = this;

			// Fast path for a common case
			if (
				!this.hasMarkupOptions &&
				(sourceMaps === undefined || !sourceMaps.hasAny()) &&
				this.inlineSourceText.size === 0 &&
				!this.hasOptions
			) {
				return diag;
			}

			const {description} = diag;

			const advice = description.advice.map((item) => {
				return this.normalizeDiagnosticAdviceItem(item);
			});

			let merge = {
				label: this.maybeNormalizeMarkup(diag.label),
				location: this.normalizeLocation(diag.location),
				description: Object.assign(
					{},
					description,
					{message: this.normalizeMarkup(description.message), advice},
				),
			};

			// Add on any specified tags
			if (this.options.tags) {
				merge.tags = Object.assign({}, this.options.tags, diag.tags);
			}

			// Add on any specified tags
			const {label} = this.options;
			if (label) {
				merge.label = diag.label
					? ___R$project$rome$$internal$markup$escape_ts$markup`${label} (${diag.label})`
					: label;
			}

			diag = Object.assign({}, diag, merge);

			return diag;
		}
	}


  // project-rome/@internal/diagnostics/helpers.ts
const ___R$project$rome$$internal$diagnostics$helpers_ts = {
		buildSuggestionAdvice: ___R$project$rome$$internal$diagnostics$helpers_ts$buildSuggestionAdvice,
		truncateSourceText: ___R$project$rome$$internal$diagnostics$helpers_ts$truncateSourceText,
		buildDuplicateLocationAdvice: ___R$project$rome$$internal$diagnostics$helpers_ts$buildDuplicateLocationAdvice,
		diagnosticLocationToMarkupFilelink: ___R$project$rome$$internal$diagnostics$helpers_ts$diagnosticLocationToMarkupFilelink,
	};
	function ___R$project$rome$$internal$diagnostics$helpers_ts$buildSuggestionAdvice(
		value,
		items,
		{minRating = 0.5, ignoreCase, formatItem} = {},
	) {
		const advice = [];

		const ratings = ___R$project$rome$$internal$string$utils$orderBySimilarity_ts$orderBySimilarity(
			value,
			items,
			{
				minRating,
				ignoreCase,
			},
		);

		const strings = ratings.map((item) => {
			const {target} = item;
			if (formatItem === undefined) {
				return target;
			} else {
				return formatItem(target);
			}
		});

		const topRatingFormatted = strings.shift();
		if (topRatingFormatted === undefined) {
			return advice;
		}

		// Raw rating that hasn't been formatted
		const topRatingRaw = ratings[0].target;

		if (topRatingRaw === value) {
			// TODO produce a better example
		}

		// If there's only 2 suggestions then just say "Did you mean A or B?" rather than printing the list
		if (strings.length === 1) {
			advice.push({
				type: "log",
				category: "info",
				text: ___R$project$rome$$internal$markup$escape_ts$markup`Did you mean <emphasis>${topRatingFormatted}</emphasis> or <emphasis>${strings[0]}</emphasis>?`,
			});
		} else {
			advice.push({
				type: "log",
				category: "info",
				text: ___R$project$rome$$internal$markup$escape_ts$markup`Did you mean <emphasis>${topRatingFormatted}</emphasis>?`,
			});

			advice.push({
				type: "diff",
				language: "unknown",
				diff: ___R$project$rome$$internal$string$diff$index_ts$default(
					value,
					topRatingRaw,
				),
			});

			if (strings.length > 0) {
				advice.push({
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Or one of these?`,
				});

				advice.push({
					type: "list",
					list: strings.map((str) =>
						___R$project$rome$$internal$markup$escape_ts$markup`${str}`
					),
					truncate: true,
				});
			}
		}

		// TODO check if ANY of the suggestions match
		if (
			topRatingRaw !== value &&
			topRatingRaw.toLowerCase() === value.toLowerCase()
		) {
			advice.push({
				type: "log",
				category: "warn",
				text: ___R$project$rome$$internal$markup$escape_ts$markup`This operation is case sensitive`,
			});
		}

		return advice;
	}

	function ___R$project$rome$$internal$diagnostics$helpers_ts$truncateSourceText(
		code,
		start,
		end,
	) {
		const lines = ___R$project$rome$$internal$string$utils$splitLines_ts$splitLines(
			code,
		);

		// Pad the starting and ending lines by 10
		const fromLine = Math.max(
			___R$project$rome$$internal$ob1$index_ts$ob1Get1(start.line) - 10,
			0,
		);
		const toLine = Math.max(
			___R$project$rome$$internal$ob1$index_ts$ob1Get1(end.line) + 10,
			lines.length,
		);

		const capturedLines = lines.slice(fromLine, toLine);
		return "\n".repeat(fromLine) + capturedLines.join("\n");
	}

	function ___R$project$rome$$internal$diagnostics$helpers_ts$buildDuplicateLocationAdvice(
		locations,
	) {
		const locationAdvice = locations.map((location) => {
			if (location === undefined) {
				return {
					type: "log",
					category: "warn",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Unable to find location`,
				};
			} else {
				return {
					type: "frame",
					location,
				};
			}
		});

		return [
			{
				type: "log",
				category: "info",
				text: ___R$project$rome$$internal$markup$escape_ts$markup`Defined already here`,
			},
			...locationAdvice,
		];
	}

	function ___R$project$rome$$internal$diagnostics$helpers_ts$diagnosticLocationToMarkupFilelink(
		loc,
	) {
		const {start, filename} = loc;

		if (filename === undefined) {
			return ___R$project$rome$$internal$markup$escape_ts$markup`unknown`;
		}

		if (start === undefined) {
			return ___R$project$rome$$internal$markup$escape_ts$markup`<filelink target="${filename}" />`;
		}

		return ___R$project$rome$$internal$markup$escape_ts$markup`<filelink target="${filename}" line="${String(
			start.line,
		)}" column="${String(start.column)}" />`;
	}


  // project-rome/@internal/diagnostics/derive.ts
const ___R$project$rome$$internal$diagnostics$derive_ts = {
		mergeDiagnostics: ___R$project$rome$$internal$diagnostics$derive_ts$mergeDiagnostics,
		derivePositionlessKeyFromDiagnostic: ___R$project$rome$$internal$diagnostics$derive_ts$derivePositionlessKeyFromDiagnostic,
		deriveRootAdviceFromDiagnostic: ___R$project$rome$$internal$diagnostics$derive_ts$deriveRootAdviceFromDiagnostic,
		deriveDiagnosticFromErrorStructure: ___R$project$rome$$internal$diagnostics$derive_ts$deriveDiagnosticFromErrorStructure,
		deriveDiagnosticFromError: ___R$project$rome$$internal$diagnostics$derive_ts$deriveDiagnosticFromError,
		getErrorStackAdvice: ___R$project$rome$$internal$diagnostics$derive_ts$getErrorStackAdvice,
		addOriginsToDiagnostics: ___R$project$rome$$internal$diagnostics$derive_ts$addOriginsToDiagnostics,
		addOriginsToDiagnostic: ___R$project$rome$$internal$diagnostics$derive_ts$addOriginsToDiagnostic,
	};
	function ___R$$priv$project$rome$$internal$diagnostics$derive_ts$normalizeArray(
		val,
	) {
		if (Array.isArray(val)) {
			return val;
		} else {
			return [];
		}
	}

	function ___R$project$rome$$internal$diagnostics$derive_ts$mergeDiagnostics(
		rootDiag,
		...diags
	) {
		let mergedAdvice = [
			...___R$$priv$project$rome$$internal$diagnostics$derive_ts$normalizeArray(
				rootDiag.description.advice,
			),
		];

		for (const diag of diags) {
			const derived = ___R$project$rome$$internal$diagnostics$derive_ts$deriveRootAdviceFromDiagnostic(
				diag,
			);
			mergedAdvice = [
				...mergedAdvice,
				...derived.advice,
				...___R$$priv$project$rome$$internal$diagnostics$derive_ts$normalizeArray(
					diag.description.advice,
				),
				...derived.lastAdvice,
			];
		}

		return Object.assign(
			{},
			rootDiag,
			{
				description: Object.assign(
					{},
					rootDiag.description,
					{advice: mergedAdvice},
				),
			},
		);
	}

	function ___R$project$rome$$internal$diagnostics$derive_ts$derivePositionlessKeyFromDiagnostic(
		diag,
	) {
		const normalizer = new ___R$project$rome$$internal$diagnostics$DiagnosticsNormalizer_ts$default(
			{},
			{
				stripPositions: true,
			},
		);

		return JSON.stringify(normalizer.normalizeDiagnostic(diag));
	}

	function ___R$project$rome$$internal$diagnostics$derive_ts$deriveRootAdviceFromDiagnostic(
		diag,
		opts = {
			skipFrame: false,
			includeHeaderInAdvice: true,
			outdated: false,
		},
	) {
		const advice = [];
		const {description, tags = {}, location} = diag;

		let header = ___R$project$rome$$internal$diagnostics$helpers_ts$diagnosticLocationToMarkupFilelink(
			location,
		);

		if (diag.label !== undefined) {
			header = ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${diag.label}</emphasis> ${header}`;

			if (description.category !== undefined) {
				header = ___R$project$rome$$internal$markup$escape_ts$markup`${header} <dim>${description.category}</dim>`;
			}
		} else {
			if (description.category !== undefined) {
				header = ___R$project$rome$$internal$markup$escape_ts$markup`${header} <emphasis>${description.category}</emphasis>`;
			}
		}

		if (tags.internal) {
			header = ___R$project$rome$$internal$markup$escape_ts$markup`${header} <inverse><error> INTERNAL </error></inverse>`;
		}

		if (tags.fixable) {
			header = ___R$project$rome$$internal$markup$escape_ts$markup`${header} <inverse> FIXABLE </inverse>`;
		}

		if (opts.outdated) {
			header = ___R$project$rome$$internal$markup$escape_ts$markup`${header} <inverse><warn> OUTDATED </warn></inverse>`;
		}

		if (tags.fatal) {
			header = ___R$project$rome$$internal$markup$escape_ts$markup`${header} <inverse><error> FATAL </error></inverse>`;
		}

		if (opts.includeHeaderInAdvice) {
			advice.push({
				type: "log",
				category: "none",
				text: header,
			});
		}

		const message = description.message;

		if (___R$project$rome$$internal$markup$escape_ts$isEmptyMarkup(message)) {
			advice.push({
				type: "log",
				category: "none",
				text: ___R$project$rome$$internal$markup$escape_ts$markup`<dim>no diagnostic message specified</dim>`,
			});
		} else {
			advice.push({
				type: "log",
				category: "error",
				text: message,
			});
		}

		if (!opts.skipFrame) {
			if (location.start !== undefined && location.end !== undefined) {
				advice.push({
					type: "frame",
					location: diag.location,
				});
			} else if (location.marker !== undefined) {
				// If we have no start/end, but we do have a marker then output is a log error
				advice.push({
					type: "log",
					category: "error",
					text: location.marker,
				});
			}
		}

		const lastAdvice = [];

		if (tags.fatal) {
			lastAdvice.push({
				type: "log",
				category: "warn",
				text: ___R$project$rome$$internal$markup$escape_ts$markup`Rome exited as this error could not be handled and resulted in a fatal error. Please report if necessary.`,
			});
		} else if (tags.internal) {
			lastAdvice.push({
				type: "log",
				category: "warn",
				text: ___R$project$rome$$internal$markup$escape_ts$markup`This diagnostic was derived from an internal Rome error. Potential bug, please report if necessary.`,
			});
		}

		return {header, advice, lastAdvice};
	}

	function ___R$project$rome$$internal$diagnostics$derive_ts$deriveDiagnosticFromErrorStructure(
		struct,
		opts,
	) {
		const {filename} = opts;

		let targetFilename = filename;
		let targetCode = undefined;
		let targetLoc = undefined;

		let {frames = [], message = "Unknown error"} = struct;

		const {cleanFrames} = opts;
		if (cleanFrames !== undefined && frames) {
			frames = cleanFrames(frames);
		}

		// Point the target to the closest frame with a filename
		for (const frame of frames) {
			if (frame.filename === undefined) {
				continue;
			}

			targetFilename = frame.filename;
			targetLoc = ___R$project$rome$$internal$v8$errors_ts$getDiagnosticLocationFromErrorFrame(
				frame,
			);
			break;
		}

		const advice = ___R$project$rome$$internal$diagnostics$derive_ts$getErrorStackAdvice(
			Object.assign({}, struct, {frames}),
			opts.stackAdviceOptions,
		);

		return {
			description: Object.assign(
				{
					message: ___R$project$rome$$internal$markup$escape_ts$markup`${message}`,
				},
				opts.description,
				{
					advice: [
						...advice,
						...((opts.description == null ? undefined : opts.description.advice) || []),
					],
				},
			),
			location: {
				filename: targetFilename,
				start: targetLoc === undefined ? undefined : targetLoc.start,
				end: targetLoc === undefined ? undefined : targetLoc.end,
				sourceText: targetCode,
			},
			label: opts.label,
			tags: opts.tags,
		};
	}

	function ___R$project$rome$$internal$diagnostics$derive_ts$deriveDiagnosticFromError(
		error,
		opts,
	) {
		return ___R$project$rome$$internal$diagnostics$derive_ts$deriveDiagnosticFromErrorStructure(
			___R$project$rome$$internal$v8$errors_ts$getErrorStructure(error),
			opts,
		);
	}

	function ___R$project$rome$$internal$diagnostics$derive_ts$getErrorStackAdvice(
		error,
		{title, importantFilenames} = {},
	) {
		const advice = [];
		const {frames = [], stack} = error;

		if (frames.length === 0 && stack !== undefined) {
			// Just in case we didn't get the frames for some reason
			if (title !== undefined) {
				advice.push({
					type: "log",
					category: "info",
					text: title,
				});
			}

			// Remove the `message` from the `stack`
			let cleanStack = stack;
			let removeMessage = error.name + ": " + error.message;
			if (cleanStack.startsWith(removeMessage)) {
				cleanStack = cleanStack.slice(removeMessage.length);
			}
			cleanStack = cleanStack.trim();

			const cleanStackList = cleanStack.replace(/\n+/g, "\n").split("\n").map((
				line,
			) => ___R$project$rome$$internal$markup$escape_ts$markup`${line.trim()}`);

			if (
				cleanStackList.length === 1 &&
				___R$project$rome$$internal$markup$escape_ts$isEmptyMarkup(
					cleanStackList[0],
				)
			) {
				advice.push({
					type: "log",
					category: "warn",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`We did not receive any frames and no raw stack trace found`,
				});
			} else {
				advice.push({
					type: "log",
					category: "warn",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Raw stack trace is being displayed as we did not receive any frames`,
				});

				advice.push({
					type: "list",
					list: cleanStackList,
				});
			}
		} else {
			const adviceFrames = frames.map((frame) => {
				const {
					typeName,
					functionName,
					methodName,
					filename,
					lineNumber,
					columnNumber,
					isEval,
					isNative,
					isConstructor,
					isAsync,
				} = frame;

				const prefixes = [];
				if (isAsync) {
					prefixes.push("await");
				}
				if (isEval) {
					prefixes.push("eval");
				}
				if (isConstructor) {
					prefixes.push("new");
				}
				const prefix = prefixes.length === 0 ? undefined : prefixes.join(" ");

				let object = typeName;
				let property = "<anonymous>";
				if (functionName !== undefined) {
					property = functionName;
				}
				if (methodName !== undefined) {
					property = methodName;
				}

				let suffix;
				if (isNative) {
					suffix = "native";
				}

				return {
					language: "unknown",
					suffix,
					prefix,
					object,
					property,
					filename,
					line: lineNumber,
					column: columnNumber,
				};
			});

			advice.push({
				type: "stacktrace",
				title,
				frames: adviceFrames,
				importantFilenames,
			});
		}

		return advice;
	}

	function ___R$project$rome$$internal$diagnostics$derive_ts$addOriginsToDiagnostics(
		origins,
		diagnostics,
	) {
		return diagnostics.map((diag) => {
			return ___R$project$rome$$internal$diagnostics$derive_ts$addOriginsToDiagnostic(
				origins,
				diag,
			);
		});
	}

	function ___R$project$rome$$internal$diagnostics$derive_ts$addOriginsToDiagnostic(
		origins,
		diag,
	) {
		const newOrigins =
			diag.origins === undefined ? origins : [...origins, ...diag.origins];
		return Object.assign({}, diag, {origins: newOrigins});
	}


  // project-rome/@internal/diagnostics/errors.ts
const ___R$project$rome$$internal$diagnostics$errors_ts = {
		get DiagnosticsError() {
			return ___R$project$rome$$internal$diagnostics$errors_ts$DiagnosticsError;
		},
		createSingleDiagnosticError: ___R$project$rome$$internal$diagnostics$errors_ts$createSingleDiagnosticError,
		getDiagnosticsFromError: ___R$project$rome$$internal$diagnostics$errors_ts$getDiagnosticsFromError,
		getOrDeriveDiagnosticsFromError: ___R$project$rome$$internal$diagnostics$errors_ts$getOrDeriveDiagnosticsFromError,
	};
	// If printDiagnosticsToString throws a DiagnosticsError then we'll be trapped in a loop forever
	// since we'll continuously be trying to serialize diagnostics
	let ___R$$priv$project$rome$$internal$diagnostics$errors_ts$insideDiagnosticsErrorSerial = false;

	class ___R$project$rome$$internal$diagnostics$errors_ts$DiagnosticsError
		extends Error {
		constructor(message, diagnostics, suppressions = []) {
			if (diagnostics.length === 0) {
				throw new Error("No diagnostics");
			}

			super();
			this._memoMessage = undefined;
			this._message = message;
			this.diagnostics = diagnostics;
			this.suppressions = suppressions;
			this.name = "DiagnosticsError";
		}

		// Lazily instantiate this. If we ever catchDiagnostics we wont even care about the `message`
		// so this avoids having to print it to a string
		get message() {
			if (this._memoMessage !== undefined) {
				return this._memoMessage;
			}

			if (
				___R$$priv$project$rome$$internal$diagnostics$errors_ts$insideDiagnosticsErrorSerial
			) {
				return [
					"Possible DiagnosticsError message serialization infinite loop",
					"Diagnostic messages:",
					this.diagnostics.map((diag) =>
						"- " +
						___R$project$rome$$internal$markup$escape_ts$readMarkup(
							diag.description.message,
						)
					),
				].join("\n");
			}

			let message = this._message === undefined ? "" : this._message + "\n";
			___R$$priv$project$rome$$internal$diagnostics$errors_ts$insideDiagnosticsErrorSerial = true;

			const reporter = new ___R$project$rome$$internal$cli$reporter$Reporter_ts$default();
			const stream = reporter.attachCaptureStream("none", {columns: undefined});
			const printer = new ___R$project$rome$$internal$cli$diagnostics$DiagnosticsPrinter_ts$default({
				reporter,
				processor: new ___R$project$rome$$internal$diagnostics$DiagnosticsProcessor_ts$default(),
				wrapErrors: true,
			});
			for (const diag of this.diagnostics) {
				printer.printDiagnostic(diag);
			}
			message += stream.read();
			___R$$priv$project$rome$$internal$diagnostics$errors_ts$insideDiagnosticsErrorSerial = false;

			this._memoMessage = message;
			return message;
		}
	}

	function ___R$project$rome$$internal$diagnostics$errors_ts$createSingleDiagnosticError(
		diag,
		suppressions,
	) {
		return new ___R$project$rome$$internal$diagnostics$errors_ts$DiagnosticsError(
			___R$project$rome$$internal$markup$escape_ts$readMarkup(
				diag.description.message,
			),
			[diag],
			suppressions,
		);
	}

	function ___R$project$rome$$internal$diagnostics$errors_ts$getDiagnosticsFromError(
		err,
	) {
		if (
			err instanceof
			___R$project$rome$$internal$diagnostics$errors_ts$DiagnosticsError
		) {
			const processor = new ___R$project$rome$$internal$diagnostics$DiagnosticsProcessor_ts$default({

			});
			processor.addSuppressions(err.suppressions);
			processor.addDiagnostics(err.diagnostics);
			return processor.getDiagnostics();
		}

		return undefined;
	}

	function ___R$project$rome$$internal$diagnostics$errors_ts$getOrDeriveDiagnosticsFromError(
		err,
		opts,
	) {
		err = ___R$project$rome$$internal$node$errors_ts$convertPossibleNodeErrorToDiagnostic(
			err,
		);
		const diagnostics = ___R$project$rome$$internal$diagnostics$errors_ts$getDiagnosticsFromError(
			err,
		);
		if (diagnostics === undefined) {
			return [
				___R$project$rome$$internal$diagnostics$derive_ts$deriveDiagnosticFromError(
					err,
					opts,
				),
			];
		} else {
			return diagnostics;
		}
	}


  // project-rome/@internal/diagnostics/types.ts
const ___R$project$rome$$internal$diagnostics$types_ts = {};


  // project-rome/@internal/diagnostics/descriptions/flags.ts
const ___R$project$rome$$internal$diagnostics$descriptions$flags_ts$flags = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		UNSUPPORTED_SHORTHAND: (flag) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`The <emphasis>-${flag}</emphasis> flag is not a valid shorthand flag`,
		}),
		INCORRECT_CASED_FLAG: (flag) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Incorrect cased flag name`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Use <emphasis>${___R$project$rome$$internal$string$utils$toKebabCase_ts$toKebabCase(
						flag,
					)}</emphasis> instead`,
				},
			],
		}),
		INCORRECT_ARG_COUNT: (excessive, text) => ({
			message: excessive
				? ___R$project$rome$$internal$markup$escape_ts$markup`Too many arguments`
				: ___R$project$rome$$internal$markup$escape_ts$markup`Missing arguments`,
			advice: [
				{
					type: "log",
					category: "info",
					text,
				},
			],
		}),
		DISALLOWED_REVIEW_FLAG: (key) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Flag <emphasis>${key}</emphasis> is not allowed with <emphasis>review</emphasis>`,
		}),
		DISALLOWED_REQUEST_FLAG: (key) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`This command does not support the <emphasis>${key}</emphasis> flag`,
		}),
		UNKNOWN_SUBCOMMAND: (action) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unknown subcommand ${action}`,
		}),
		NO_FILES_FOUND: (noun) => ({
			message: noun === undefined
				? ___R$project$rome$$internal$markup$escape_ts$markup`No files found`
				: ___R$project$rome$$internal$markup$escape_ts$markup`No files to ${noun} found`,
		}),
		UNKNOWN_COMMAND: (
			{
				programName,
				commandName,
				suggestedName,
				suggestedDescription,
				suggestedCommand,
			},
		) => {
			const advice = [];

			if (suggestedName !== undefined) {
				const description =
					suggestedDescription === undefined
						? ""
						: ___R$project$rome$$internal$markup$escape_ts$markup` ${suggestedDescription}`;
				advice.push({
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Did you mean <emphasis>${suggestedName}</emphasis> instead?${description}`,
				});
			}

			if (suggestedCommand !== undefined) {
				advice.push({
					type: "code",
					language: "shell",
					sourceText: suggestedCommand,
				});
			}

			return {
				category: "flags/invalid",
				message: commandName === ""
					? ___R$project$rome$$internal$markup$escape_ts$markup`No command specified`
					: ___R$project$rome$$internal$markup$escape_ts$markup`Unknown command <emphasis>${commandName}</emphasis>`,
				advice: [
					...advice,
					{
						type: "log",
						category: "info",
						text: ___R$project$rome$$internal$markup$escape_ts$markup`To see all available commands run`,
					},
					{
						type: "code",
						language: "shell",
						sourceText: programName + " --help",
					},
				],
			};
		},
	});


  // project-rome/@internal/diagnostics/descriptions/parsers/parserCore.ts
const ___R$project$rome$$internal$diagnostics$descriptions$parsers$parserCore_ts$parserCore = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		EXPECTED_SPACE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected no space between`,
		},
		EXPECTED_EOF: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected end of file`,
		},
		UNEXPECTED_EOF: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unexpected end of file`,
		},
		UNEXPECTED: (type) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unexpected ${type}`,
		}),
		UNEXPECTED_CHARACTER: (char) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unexpected character <emphasis>${char}</emphasis>`,
		}),
		EXPECTED_TOKEN: (got, expected) => {
			return {
				message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected token ${expected} but got ${got}`,
			};
		},
	});


  // project-rome/@internal/diagnostics/descriptions/parsers/regexp.ts
const ___R$project$rome$$internal$diagnostics$descriptions$parsers$regexp_ts$regexp = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		INVALID_CAPTURE_GROUP_MODIFIER: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid capture group modifier`,
		},
		UNCLOSED_GROUP: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unclosed group`,
		},
		UNOPENED_GROUP: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unopened group`,
		},
		INVALID_QUANTIFIER_TARGET: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid target for quantifier`,
		},
		UNKNOWN_REGEX_PART: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unknown regex part`,
		},
		REVERSED_CHAR_SET_RANGE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Range values reversed. Start char code is greater than end char code`,
		},
		UNCLOSED_CHAR_SET: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unclosed character set`,
		},
		DUPLICATE_FLAG: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Duplicate regular expression flag`,
		},
		INVALID_FLAG: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid regular expression flag`,
		},
		REVERSED_QUANTIFIER_RANGE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Quantifier minimum is greater than maximum`,
		},
		NO_TARGET_QUANTIFIER: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Nothing to repeat`,
		},
		INVALID_NAMED_CAPTURE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid named capture referenced`,
		},
		UNCLOSED_NAMED_CAPTURE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unclosed named capture`,
		},
	});


  // project-rome/@internal/diagnostics/descriptions/json.ts
const ___R$project$rome$$internal$diagnostics$descriptions$json_ts$json = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		SINGLE_QUOTE_USAGE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`You can only use double quoted strings`,
		},
		TRAILING_COMMA_VALUE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Trailing comma is only allowed after a value`,
		},
		UNCLOSED_STRING: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unclosed string`,
		},
		UNCLOSED_BLOCK_COMMENT: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unclosed block comment`,
		},
		MISTAKEN_ARRAY_IDENTITY: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Trying to use an array element as an object property. Did you mean to make an object?`,
		},
		REDUNDANT_COMMA: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Redundant comma`,
		},
		EMPTY_INPUT_IN_JSON: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Empty input`,
		},
		PROPERTY_KEY_UNQUOTED_IN_JSON: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Property keys must be quoted in JSON`,
		},
		IMPLICIT_OBJECT_IN_JSON: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Objects must be wrapped in curly braces in JSON`,
		},
		COMMENTS_IN_JSON: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Comments aren't allowed in JSON`,
		},
		TRAILING_COMMA_IN_JSON: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Trailing commas aren't allowed in JSON`,
		},
		REGEX_IN_JSON: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Regular expressions aren't allowed in JSON`,
		},
		UNKNOWN_WORD_IN_JSON: (word) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`${word} isn't a valid JSON word`,
		}),
		STRING_NEWLINES_IN_JSON: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Newlines aren't allowed in JSON, you insert a newline by escaping it like this "\\n"`,
		},
		UNDEFINED_IN_JSON: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`undefined isn't allowed in JSON, you could use null instead`,
		},
		BIGINT_IN_JSON: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Bigints aren't allowed in JSON`,
		},
		NUMERIC_SEPARATORS_IN_JSON: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Numeric separators are not allowed in JSON`,
		},
	});


  // project-rome/@internal/diagnostics/descriptions/semver.ts
const ___R$project$rome$$internal$diagnostics$descriptions$semver_ts$semver = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		MISSING_MINOR_VERSION: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`A minor number is required for a version`,
		},
		MISSING_PATCH_VERSION: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`A patch number is required for a version`,
		},
		EXCESSIVE_VERSION_PARTS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Too many parts for version`,
		},
		INVALID_QUANTIFIER_PART: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid version qualifier part`,
		},
		WILDCARD_IN_VERSION: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Wildcard aren't allowed in a hard version`,
		},
		INVALID_VERSION_NUMBER: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`This isn't a valid version part, expected a number`,
		},
		INVALID_RANGE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`A semver range can only be defined with versions`,
		},
		BARE_PIPE_WITHOUT_LOOSE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Bare pipes are only allowed in loose mode`,
		},
		UNEXPECTED_WORD: (word) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unexpected word <emphasis>${word}</emphasis>`,
		}),
		UNKNOWN_START: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unknown start of atom`,
		},
		EXPECTED_VERSION: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unexpected value for version`,
		},
	});


  // project-rome/@internal/diagnostics/descriptions/v8.ts
const ___R$project$rome$$internal$diagnostics$descriptions$v8_ts$v8 = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		SYNTAX_ERROR: (message) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`${message}`,
			category: "v8/syntaxError",
		}),
	});


  // project-rome/@internal/diagnostics/descriptions/commands/lintCommand.ts
const ___R$project$rome$$internal$diagnostics$descriptions$commands$lintCommand_ts$lintCommand = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		INVALID_DECISION_ACTION: (action) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${action}</emphasis> is not a valid decision action`,
		}),
		INVALID_DECISION_PART_COUNT: (i) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Segment ${String(
				i,
			)} contains an invalid number of decision parts`,
		}),
	});


  // project-rome/@internal/diagnostics/descriptions/projectManager.ts
const ___R$project$rome$$internal$diagnostics$descriptions$projectManager_ts$projectManager = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		NO_VCS: (rootConfigLocation) => ({
			category: "projectManager/vscMissing",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Can't find any version control for this project`,
			advice: rootConfigLocation === undefined
				? [
						{
							type: "log",
							category: "info",
							text: ___R$project$rome$$internal$markup$escape_ts$markup`Version control root was set to the project root as it was not configured. To configure a different directory run`,
						},
						{
							type: "code",
							language: "shell",
							sourceText: "rome config set-directory vcs.root DIRECTORY_HERE",
						},
					]
				: [
						{
							type: "log",
							category: "info",
							text: ___R$project$rome$$internal$markup$escape_ts$markup`Version control root was set here`,
						},
						{
							type: "frame",
							location: rootConfigLocation,
						},
					],
		}),
		DUPLICATE_PACKAGE: (packageName, existing) => ({
			category: "projectManager/nameCollision",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Duplicate package name <emphasis>${packageName}</emphasis>`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Defined already by <filelink target="${existing}" />`,
				},
			],
		}),
		NOT_FOUND: {
			category: "projectManager/missing",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Couldn't find a project`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Run <code>rome init</code> in this directory to initialize a project`,
				},
			],
		},
		INITING_SENSITIVE: (directory) => ({
			category: "projectManager/sensitiveDirectory",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Cannot create a project config in sensitive directory <emphasis>${___R$project$rome$$internal$markup$escape_ts$filePathToMarkup(
				directory,
				true,
			)}</emphasis>`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`A project created here is always a mistake. Try another folder.`,
				},
			],
		}),
		LOADING_SENSITIVE: (directory) => ({
			category: "projectManager/sensitiveDirectory",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Cannot load a project config in sensitive directory <emphasis>${___R$project$rome$$internal$markup$escape_ts$filePathToMarkup(
				directory,
				true,
			)}</emphasis>`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`A project created here is always a mistake. Check why this config exists and if necessary delete and try again.`,
				},
			],
		}),
		TYPO_CONFIG_FILENAME: (invalidFilename, validFilenames) => ({
			category: "projectManager/typoConfigFilename",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid Rome config filename <emphasis>${invalidFilename}</emphasis>`,
			advice: ___R$project$rome$$internal$diagnostics$helpers_ts$buildSuggestionAdvice(
				invalidFilename,
				validFilenames,
			),
		}),
		MISPLACED_CONFIG: (misplacedName) => ({
			category: "projectManager/misplacedConfig",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Misplaced project config <emphasis>${misplacedName}</emphasis>`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`This should be inside of a <emphasis>.config</emphasis> folder`,
				},
			],
		}),
	});


  // project-rome/@internal/diagnostics/descriptions/compiler.ts
const ___R$project$rome$$internal$diagnostics$descriptions$compiler_ts$compiler = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		CLASSES_UNSUPPORTED: {
			category: "compile/classes",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`The classes transform doesn't know how to transform this`,
		},
		JSX_NOT_XML: {
			category: "compile/jsx",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`JSX is not XML`,
		},
		CONST_ENUMS_UNSUPPORTED: {
			category: "compile/const-enums",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Const enums are not supported`,
		},
		ENUM_COMPUTED_VALUES_UNSUPPORTED: {
			category: "compile/nonnumeric-enum-values",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Only numeric enums can have computed members`,
		},
	});


  // project-rome/@internal/diagnostics/descriptions/stringEscape.ts
const ___R$project$rome$$internal$diagnostics$descriptions$stringEscape_ts$stringEscape = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		NOT_ENOUGH_CODE_POINTS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Not enough code point digits`,
		},
		INVALID_STRING_CHARACTER: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid string character (U+0000 to U+001F)`,
		},
		INVALID_HEX_DIGIT_FOR_ESCAPE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid hex digit for unicode escape`,
		},
	});


  // project-rome/@internal/diagnostics/descriptions/analyzeDependencies.ts
const ___R$project$rome$$internal$diagnostics$descriptions$analyzeDependencies_ts$analyzeDependencies = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		CJS_EXPORT_IN_ES: {
			category: "analyzeDependencies/cjsExportInES",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`You cannot use CommonJS exports in an ES module`,
		},
	});


  // project-rome/@internal/diagnostics/descriptions/parsers/stringMarkup.ts
const ___R$project$rome$$internal$diagnostics$descriptions$parsers$stringMarkup_ts$stringMarkup = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		UNCLOSED_STRING: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unclosed string`,
		},
		EXPECTED_CLOSING_TAG_NAME: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected closing tag name`,
		},
		UNKNOWN_START: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unknown child start`,
		},
		EXPECTED_ATTRIBUTE_NAME: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected attribute name`,
		},
		INCORRECT_CLOSING_TAG_NAME: (expected, got) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected to close ${expected} but found ${got}`,
		}),
		UNCLOSED_TAG: (tagName, openLocation) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unclosed ${tagName} tag`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Tag started here`,
				},
				{
					type: "frame",
					location: openLocation,
				},
			],
		}),
		INVALID_ATTRIBUTE_VALUE: (tagName, attributeName, attributeValue) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${attributeValue}</emphasis> is not a valid attribute value for <emphasis>${attributeName}</emphasis> in a <emphasis>${tagName}</emphasis>`,
		}),
		INVALID_ATTRIBUTE_NAME_FOR_TAG: (tagName, attributeName, validAttributes) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${attributeName}</emphasis> is not a valid attribute name for <emphasis>${tagName}</emphasis>`,
			advice: ___R$project$rome$$internal$diagnostics$helpers_ts$buildSuggestionAdvice(
				attributeName,
				validAttributes,
			),
		}),
		UNKNOWN_TAG_NAME: (tagName) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unknown tag name <emphasis>${tagName}</emphasis>`,
		}),
		RESTRICTED_CHILD: (tagName, allowedParents, gotParentName = "none") => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`The tag <emphasis>${tagName}</emphasis> should only appear as a child of ${___R$project$rome$$internal$diagnostics$descriptions$index_ts$orJoin(
				___R$project$rome$$internal$diagnostics$descriptions$index_ts$addEmphasis(
					allowedParents.map((str) =>
						___R$project$rome$$internal$markup$escape_ts$markup`${str}`
					),
				),
			)} not <emphasis>${gotParentName}</emphasis>`,
		}),
		RESTRICTED_PARENT: (tagName, allowedChildren, gotChildName) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`The tag <emphasis>${tagName}</emphasis> should only contain the tags ${___R$project$rome$$internal$diagnostics$descriptions$index_ts$orJoin(
				___R$project$rome$$internal$diagnostics$descriptions$index_ts$addEmphasis(
					allowedChildren.map((str) =>
						___R$project$rome$$internal$markup$escape_ts$markup`${str}`
					),
				),
			)} not <emphasis>${gotChildName}</emphasis>`,
		}),
		RESTRICTED_PARENT_TEXT: (tagName) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`The tag <emphasis>${tagName}</emphasis> should not contain any text`,
		}),
	});


  // project-rome/@internal/diagnostics/descriptions/parsers/pathMatch.ts
const ___R$project$rome$$internal$diagnostics$descriptions$parsers$pathMatch_ts$pathMatch = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		INVALID_PATTERN_SEGMENT_PART: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid pattern segment part`,
		},
		INVALID_PATH_SEGMENT: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid path segment`,
		},
	});


  // project-rome/@internal/diagnostics/descriptions/tests.ts
const ___R$project$rome$$internal$diagnostics$descriptions$tests_ts$tests = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		CANCELLED: {
			category: "tests/cancelled",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Test was cancelled`,
		},
		UNDECLARED: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`No tests declared in this file`,
			category: "tests/noneDeclared",
		},
		LOGS: (advice) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Test file produced console logs`,
			category: "tests/logs",
			advice: [
				...advice,
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Only visible when this test file contains failures`,
				},
			],
		}),
	});


  // project-rome/@internal/diagnostics/descriptions/suppressions.ts
const ___R$project$rome$$internal$diagnostics$descriptions$suppressions_ts$suppressions = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		UNUSED: (suppression) => {
			let description = "";
			if (suppression.startLine === suppression.endLine) {
				description = "line " + suppression.startLine;
			} else {
				description +=
					"lines " + suppression.startLine + " to " + suppression.endLine;
			}

			return {
				message: ___R$project$rome$$internal$markup$escape_ts$markup`Unused suppression. Did not hide any errors.`,
				category: "suppressions/unused",
				advice: [
					{
						type: "log",
						category: "info",
						text: ___R$project$rome$$internal$markup$escape_ts$markup`This suppression should hide <emphasis>${description}</emphasis>`,
					},
				],
			};
		},
		MISSING_SPACE: {
			category: "suppressions/missingSpace",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Missing space between prefix and suppression categories`,
		},
		MISSING_TARGET: {
			category: "suppressions/missingTarget",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`We could not find a target for this suppression`,
		},
		MISSING_EXPLANATION: {
			category: "suppressions/missingExplanation",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Suppression comments must have an explanation`,
		},
		DUPLICATE: (category) => ({
			category: "suppressions/duplicate",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Duplicate suppression category <emphasis>${category}</emphasis>`,
		}),
		OVERLAP: (category) => ({
			category: "suppressions/overlap",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`overlap suppression category <emphasis>${category}</emphasis>`,
		}),
		INCORRECT_SUPPRESSION_START: {
			category: "suppressions/incorrectSuppressionStart",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`This looks like a suppression comment typo. Did you mean <emphasis>rome-ignore</emphasis> instead?`,
		},
	});


  // project-rome/@internal/diagnostics/descriptions/snapshots.ts
const ___R$project$rome$$internal$diagnostics$descriptions$snapshots_ts$snapshots = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		MISSING_NEWLINE_AFTER_CODE_BLOCK: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Newline required after code block`,
		},
		MISSING_NEWLINE_BEFORE_CODE_BLOCK: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Newline required before code block end`,
		},
		UNCLOSED_CODE_BLOCK: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unclosed code block`,
		},
		EXPECTED_CODE_BLOCK_AFTER_HEADING: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected a code block after this heading`,
		},
		REDUNDANT: {
			category: "tests/snapshots/redundant",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Snapshot should not exist`,
		},
		MISSING: {
			category: "tests/snapshots/missing",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Snapshot does not exist`,
		},
		INCORRECT: (expected, got) => ({
			category: "tests/snapshots/incorrect",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Snapshots do not match`,
			advice: [
				{
					type: "diff",
					language: "unknown",
					diff: ___R$project$rome$$internal$string$diff$index_ts$default(
						expected,
						got,
					),
				},
			],
		}),
		INLINE_COLLISION: {
			category: "tests/snapshots/inlineCollision",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Trying to update this inline snapshot multiple times`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>t.inlineSnapshot</emphasis> can only be called once. Did you call it in a loop?`,
				},
			],
		},
		INLINE_MISSING_RECEIVED: {
			category: "tests/snapshots/inlineMissingReceived",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`This inline snapshot call does not have a received argument`,
		},
		INLINE_FROZEN: {
			category: "tests/snapshots/frozen",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Inline snapshot cannot be updated as snapshots are frozen`,
		},
		FROZEN: {
			category: "tests/snapshots/frozen",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Snapshot cannot be updated as snapshots are frozen`,
		},
		INLINE_BAD_MATCH: {
			category: "tests/snapshots/incorrect",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Inline snapshots do not match`,
		},
	});


  // project-rome/@internal/diagnostics/descriptions/bundler.ts
const ___R$project$rome$$internal$diagnostics$descriptions$bundler_ts$bundler = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		DETECTED_CYCLE: (localName, target, culprit, path) => {
			function formatPart(part, index) {
				const tagged = ___R$project$rome$$internal$markup$escape_ts$markup`<filelink target="${part}" />`;
				if (part === culprit) {
					return ___R$project$rome$$internal$markup$escape_ts$markup`<highlight i="0" legend>${tagged}</highlight>`;
				} else if (part === target) {
					return ___R$project$rome$$internal$markup$escape_ts$markup`<highlight i="1" legend>${tagged}</highlight>`;
				} else if (index === 0) {
					return ___R$project$rome$$internal$markup$escape_ts$markup`${tagged} <inverse> ENTRY </inverse>`;
				} else {
					return tagged;
				}
			}

			return {
				category: "bundler/moduleCycle",
				message: ___R$project$rome$$internal$markup$escape_ts$markup`The variable <emphasis>${localName}</emphasis> won't be initialized yet`,
				advice: [
					{
						type: "log",
						category: "info",
						text: ___R$project$rome$$internal$markup$escape_ts$markup`This is because the module it belongs to wont be executed yet. This is due to a circular dependency creating a module cycle.`,
					},
					{
						type: "log",
						category: "info",
						text: ___R$project$rome$$internal$markup$escape_ts$markup`The likely cause is the file ${formatPart(
							culprit,
						)} that was required by ${formatPart(target)} which created a circular dependency:`,
					},
					{
						type: "list",
						reverse: true,
						ordered: true,
						list: path.map(formatPart),
					},
				],
			};
		},
	});


  // project-rome/@internal/diagnostics/descriptions/resolver.ts
const ___R$project$rome$$internal$diagnostics$descriptions$resolver_ts$resolver = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		NOT_FOUND: (responseType, source, location) => {
			let messagePrefix = "";
			let category = "resolver/notFound";

			switch (responseType) {
				case "UNSUPPORTED": {
					messagePrefix = "Unsupported";
					category = "resolver/unsupported";
					break;
				}
				case "MISSING": {
					messagePrefix = "Cannot find";
					break;
				}
				case "FETCH_ERROR": {
					messagePrefix = "Failed to fetch";
					category = "resolver/fetchFailed";
					break;
				}
			}

			return {
				message: ___R$project$rome$$internal$markup$escape_ts$markup`${messagePrefix} <emphasis>${source}</emphasis> from <filelink emphasis target="${location.filename}" />`,
				category,
			};
		},
		UNKNOWN_EXPORT: (name, source, exportedNames, formatExportedName) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Couldn't find export <emphasis>${name}</emphasis> in <filelink emphasis target="${source}" />`,
			category: "resolver/unknownExport",
			advice: exportedNames.length === 0
				? [
						{
							type: "log",
							category: "info",
							text: ___R$project$rome$$internal$markup$escape_ts$markup`This file doesn't have any exports`,
						},
					]
				: ___R$project$rome$$internal$diagnostics$helpers_ts$buildSuggestionAdvice(
						name,
						exportedNames,
						{
							formatItem: (name) => {
								const {location, source} = formatExportedName(name);
								let format = ___R$project$rome$$internal$markup$escape_ts$markup`${name}`;

								if (location !== undefined) {
									if (location.start === undefined) {
										format = ___R$project$rome$$internal$markup$escape_ts$markup`<filelink target="${location.filename}">${name}</filelink>`;
									} else {
										format = ___R$project$rome$$internal$markup$escape_ts$markup`<filelink target="${location.filename}" line="${String(
											location.start.line,
										)}" column="${String(location.start.column)}">${name}</filelink>`;
									}
								}

								if (source !== undefined) {
									format = ___R$project$rome$$internal$markup$escape_ts$markup`${format} <dim>(from <filelink target="${source}" />)</dim>`;
								}

								return format;
							},
						},
					),
		}),
		UNKNOWN_EXPORT_POSSIBLE_UNEXPORTED_LOCAL: (name, source, location) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Couldn't find export <emphasis>${name}</emphasis> in <filelink emphasis target="${source}" />`,
			category: "resolver/unknownExport",
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`However we found a matching local variable in <filelink emphasis target="${location.filename}" />. Did you forget to export it?`,
				},
				{
					type: "frame",
					location,
				},
			],
		}),
	});


  // project-rome/@internal/diagnostics/descriptions/commitParser.ts
const ___R$project$rome$$internal$diagnostics$descriptions$commitParser_ts$commitParser = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		UNEXPECTED_TOKEN: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unexpected commit token`,
		},
		EMPTY_SCOPE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Empty commit scope`,
		},
		MISSING_DESCRIPTION: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Missing commit description`,
		},
		MISSING_TYPE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Missing commit type`,
		},
	});


  // project-rome/@internal/diagnostics/descriptions/parsers/spdx.ts
const ___R$project$rome$$internal$diagnostics$descriptions$parsers$spdx_ts$spdx = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		UNKNOWN_LICENSE: (id, knownLicenses) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unknown license <emphasis>${id}</emphasis>`,
			advice: [
				...___R$project$rome$$internal$diagnostics$helpers_ts$buildSuggestionAdvice(
					id,
					knownLicenses,
					{ignoreCase: true},
				),
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`The <emphasis>SPDX</emphasis> registry is used to ensure valid and legal licenses. See <hyperlink target="https://spdx.org/licenses/" /> for more information.`,
				},
			],
		}),
		VALID_LICENSE_WITH_MISSING_DASH: (possibleCorrectLicense) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Missing dash between license name and version`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Did you mean <emphasis>${possibleCorrectLicense}</emphasis>?`,
				},
			],
		}),
		WITH_RIGHT_LICENSE_ONLY: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Only a license id can be on the right side of a WITH`,
		},
		OPERATOR_NOT_BETWEEN_EXPRESSION: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Can only use AND/OR in between an expression`,
		},
		PLUS_NOT_AFTER_LICENSE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`A plus can only come after a license id`,
		},
		UNOPENED_PAREN: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Nothing open to close`,
		},
	});


  // project-rome/@internal/diagnostics/descriptions/parsers/jsParser.ts
function ___R$$priv$project$rome$$internal$diagnostics$descriptions$parsers$jsParser_ts$buildJSXOpeningAdvice(
		name,
		openingLoc,
	) {
		return [
			{
				type: "log",
				category: "info",
				text: name === ""
					? ___R$project$rome$$internal$markup$escape_ts$markup`Originated from this opening tag`
					: ___R$project$rome$$internal$markup$escape_ts$markup`Originated from opening tag of <emphasis>${name}</emphasis>`,
			},
			{
				type: "frame",
				location: openingLoc,
			},
		];
	}

	// @internal/js-parser
	const ___R$project$rome$$internal$diagnostics$descriptions$parsers$jsParser_ts$jsParser = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		UNTERMINATED_BLOCK_COMMENT: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unterminated comment`,
		},
		UNTERMINATED_JSX_STRING: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unterminated string constant`,
		},
		INVALID_UNICODE_ESCAPE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid Unicode escape`,
		},
		EXPECTED_UNICODE_ESCAPE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expecting Unicode escape sequence \\uXXXX`,
		},
		BAD_HEX_ESCAPE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Bad character escape sequence`,
		},
		OCTAL_IN_STRICT_MODE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Octal literal in strict mode`,
		},
		UNTERMINATED_TEMPLATE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unterminated template`,
		},
		UNTERMINATED_STRING: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unterminated string constant`,
		},
		OUT_OF_BOUND_CODE_POINT: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Code point out of bounds`,
		},
		IDENTIFIER_AFTER_NUMBER: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Identifier directly after number`,
		},
		OCTAL_BIGINT: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`A bigint can't be an octal`,
		},
		DECIMAL_BIGINT: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`A bigint can't have a decimal`,
		},
		INVALID_NUMBER: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid number`,
		},
		LEGACY_OCTAL_IN_STRICT_MODE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Legacy octal literals are not allowed in strict mode`,
		},
		INVALID_INT_TOKEN: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid or unexpected int token`,
		},
		UNICODE_ESCAPE_IN_REGEX_FLAGS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Regular expression flags can't contain unicode escapes`,
		},
		UNTERMINATED_REGEX: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unterminated regular expression`,
		},
		DANGLING_BACKSLASH_IN_REGEX: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Dangling backslash in a regular expression`,
		},
		EXPECTED_RELATIONAL_OPERATOR: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected relational operator`,
		},
		UNEXPECTED_SPACE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unexpected space`,
		},
		EXPECTED_SEMI_OR_LINE_TERMINATOR: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected a semicolon or a line terminator`,
		},
		GET_SET_CLASS_CONSTRUCTOR: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Constructor can't have get/set modifier`,
		},
		ASYNC_CLASS_CONSTRUCTOR: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Constructor cannot be async`,
		},
		GENERATOR_CLASS_CONSTRUCTOR: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Constructor cannot be a generator`,
		},
		DUPLICATE_CLASS_CONSTRUCTOR: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Duplicate constructor in the same class`,
		},
		UNKNOWN_CLASS_PROPERTY_START: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unknown class property start`,
		},
		CLASS_STATIC_PROTOTYPE_PROPERTY: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Classes may not have static property named prototype`,
		},
		CLASS_PRIVATE_FIELD_NAMED_CONSTRUCTOR: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Classes may not have a private field named '#constructor'`,
		},
		CLASS_PROPERTY_NAME_CONSTRUCTOR: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Classes may not have a non-static field named 'constructor'`,
		},
		PROTO_PROP_REDEFINITION: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Redefinition of __proto__ property`,
		},
		MISSING_CONDITIONAL_SEPARATOR: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Missing conditional expression consequent separator`,
		},
		WRAP_EXPONENTIATION: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Illegal expression. Wrap left hand side or entire exponentiation in parentheses.`,
		},
		DELETE_LOCAL_VARIABLE_IN_STRICT: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Deleting local variable in strict mode`,
		},
		DELETE_PRIVATE_FIELD: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Deleting a private field is not allowed`,
		},
		TAGGED_TEMPLATE_IN_OPTIONAL_CHAIN: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Tagged Template Literals are not allowed in optionalChain`,
		},
		YIELD_NAME_IN_GENERATOR: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Can not use 'yield' as identifier inside a generator`,
		},
		AWAIT_NAME_IN_ASYNC: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Can not use 'await' as identifier inside an async function`,
		},
		EMPTY_PARENTHESIZED_EXPRESSION: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Parenthesized expression didnt contain anything`,
		},
		AWAIT_IN_ASYNC_PARAMS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`await is not allowed in async function parameters`,
		},
		YIELD_IN_GENERATOR_PARAMS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`yield is not allowed in generator parameters`,
		},
		FLOW_TYPE_CAST_IN_TS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Flow type cast expressions aren't allowed in TypeScript`,
		},
		PARENTHESIZED_FUNCTION_PARAMS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Function parameters can't be parenthesized`,
		},
		NEW_WITH_TYPESCRIPT_TYPE_ARGUMENTS_NO_PARENS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`In TypeScript, a new expression with type arguments must have parens`,
		},
		INVALID_TEMPLATE_ESCAPE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid escape sequence in template`,
		},
		EXPECTED_IDENTIFIER: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected an identifier`,
		},
		IMPORT_EXACT_ARGUMENTS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`import() requires exactly one argument`,
		},
		IMPORT_TRAILING_COMMA: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Trailing comma is disallowed inside import(...) arguments`,
		},
		IMPORT_SPREAD: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Spread is not allowed in import()`,
		},
		IMPORT_NEW_CALLEE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Cannot use new with import(...)`,
		},
		SUPER_OUTSIDE_METHOD: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`super is only allowed in object methods and classes`,
		},
		INVALID_SUPER_SUFFIX: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid super suffix operator`,
		},
		AWAIT_OUTSIDE_ASYNC: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Can't use await outside of an async function`,
		},
		AWAIT_STAR: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`await* has been removed from the async functions proposal. Use Promise.all() instead.`,
		},
		NEW_TARGET_OUTSIDE_CLASS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`new.target can only be used in functions or class properties`,
		},
		MULTIPLE_DESTRUCTURING_RESTS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Cannot have multiple rest elements when destructuring`,
		},
		TRAILING_COMMA_AFTER_REST: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`A trailing comma is not permitted after the rest element`,
		},
		GETTER_WITH_PARAMS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`getter should have no parameters`,
		},
		SETTER_WITH_REST: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`setter function argument must not be a rest parameter`,
		},
		SETTER_NOT_ONE_PARAM: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`setter should have exactly one param`,
		},
		ASYNC_GETTER_SETTER: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`An object setter/getter can't be async`,
		},
		GENERATOR_GETTER_SETTER: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`An object setter/getter can't be a generator`,
		},
		ARGUMENTS_IN_CLASS_FIELD: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`'arguments' is not allowed in class field initializer`,
		},
		NON_SIMPLE_PARAM_IN_EXPLICIT_STRICT_FUNCTION: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Non-simple parameter in strict mode`,
		},
		STRICT_DIRECTIVE_IN_NON_SIMPLE_PARAMS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Illegal 'use strict' directive in function with non-simple parameter list`,
		},
		OBJECT_PROPERTY_WITH_TYPE_PARAMETERS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Object property cannot have type parameters`,
		},
		ILLEGAL_VARIANCE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Variance is not allowed here`,
		},
		OBJECT_METHOD_IN_PATTERN: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Object methods aren't allowed in object patterns`,
		},
		IMPORT_META_OUTSIDE_MODULE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`import.meta may only appear in a module`,
		},
		EXPECTED_ARROW_AFTER_ASYNC_TYPE_PARAMS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected arrow because we are a possible async arrow and type annotated parameters were present`,
		},
		INVALID_OBJECT_PATTERN_PROP: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid property node for object pattern`,
		},
		ASYNC_OBJECT_METHOD_LINE_BREAK: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`There shouldn't be any newlines between async and the rest of the function`,
		},
		SPACE_BETWEEN_PRIVATE_HASH: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unexpected space between # and identifier`,
		},
		CONFUSING_CALL_ARGUMENT: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Function parameter type annotation? Possibly forgot curlies around an object. Possibly forgot async keyword.`,
		},
		EXPECTED_ARROW_AFTER_TYPE_PARAMS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected an arrow function after this type parameter declaration`,
		},
		REQUIRED_CLASS_NAME: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Class name is required`,
		},
		JSX_ELEM_TYPE_ARGUMENTS_OUTSIDE_TS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`JSX element type arguments are only allowed in TS`,
		},
		UNWRAPPED_ADJACENT_JHX: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment \\<>...\\</>?`,
		},
		CONFUSED_OR: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unexpected ||, did you mean just |?`,
		},
		INVALID_ASSIGNMENT_TARGET: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Not a valid assignment target`,
		},
		IMPORT_KIND_SPECIFIER_ON_IMPORT_DECLARATION_WITH_KIND: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`The \`type\` and \`typeof\` keywords on named imports can only be used on regular \`import\` statements. It cannot be used with \`import type\` or \`import typeof\` statements`,
		},
		DESTRUCTURING_IN_IMPORT: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`ES2015 named imports do not destructure. Use another statement for destructuring after the import.`,
		},
		IMPORT_MISSING_SOURCE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`import missing a source`,
		},
		EXPORT_TYPE_NAMESPACE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Can't have a type export namespacer specifier`,
		},
		EXPORT_MISSING_FROM: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected \`from\` for an export node`,
		},
		EXPORT_FROM_NOT_STRING: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Export from only allows strings`,
		},
		BINDING_MEMBER_EXPRESSION: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Binding member expression`,
		},
		INVALID_OBJECT_PATTERN_PROPERTY: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Not a valid assignment object pattern property`,
		},
		OBJECT_PATTERN_CANNOT_CONTAIN_METHODS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Object pattern cannot contains methods`,
		},
		INVALID_ASSIGNMENT_PATTERN_OPERATOR: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Only '=' operator can be used for specifying default value.`,
		},
		INVALID_OBJECT_REST_ARGUMENT: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid rest operator's argument`,
		},
		INVALID_EXPORT_DEFAULT: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Only expressions, functions or classes are allowed as the \`default\` export.`,
		},
		INVALID_EXPORT_DECLARATION: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid export declaration`,
		},
		DESTRUCTURING_REST_ELEMENT_NOT_LAST: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`The rest element has to be the last element when destructuring`,
		},
		REST_INVALID_ARGUMENT: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid rest operator's argument`,
		},
		EXPORT_ASYNC_NO_FUNCTION_KEYWORD: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Started with \`export async\` so we expected to receive an async function but no function keyword was found`,
		},
		TYPE_CAST_WITHOUT_ANNOTATION: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Type cast expression has no type annotation. Did you mean for this to be a function parameter?`,
		},
		TYPE_CAST_CANNOT_BE_OPTIONAL: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Type cast expressions cannot be optional. Did you mean for this to be a function parameter?`,
		},
		TYPE_CAST_EXPECTED_PARENS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`The type cast expression is expected to be wrapped with parentheses`,
		},
		INVALID_ASYNC_ARROW_WITH_TYPE_PARAMS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid async arrow with type parameters`,
		},
		TYPE_NUMERIC_LITERAL_PLUS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Numeric literal type annotations cannot stand with a +, omit it instead`,
		},
		TYPE_NUMERIC_LITERAL_EXPECTED: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unexpected token, expected "number"`,
		},
		JSX_INVALID_ATTRIBUTE_VALUE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`JSX attribute value should be either an expression or a quoted JSX text`,
		},
		JSX_UNCLOSED_SELF_CLOSING_TAG: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unclosed JSX element open`,
		},
		JSX_UNCLOSED_CLOSING_TAG: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unclosed JSX element close`,
		},
		JSX_EMPTY_ATTRIBUTE_VALUE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`JSX attribute cannot be an empty expression`,
		},
		JSX_UNKNOWN_IDENTIFIER_TOKEN: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unknown JSX identifier token`,
		},
		TS_IMPORT_ARG_NOT_STRING: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Argument in a type import must be a string literal`,
		},
		TS_CONSTANT_NOT_LITERAL: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Only literal values are allowed as a constant type`,
		},
		TS_INVALID_SIGNATURE_BINDING_NODE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid node in signature binding list`,
		},
		TS_REQUIRED_FOLLOWS_OPTIONAL: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`A required element cannot follow an optional element.`,
		},
		TS_TEMPLATE_LITERAL_WITH_SUBSTITUION: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Template literal types cannot have any substitution`,
		},
		TS_UNKNOWN_NON_ARRAY_START: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unknown TS non array type start`,
		},
		TS_INVALID_READONLY_MODIFIER: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`'readonly' type modifier is only permitted on array and tuple literal types.`,
		},
		TS_EXTERNAL_MODULE_REFERENCE_ARG_NOT_STRING: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`TypeScript require() must have a single string argument`,
		},
		TS_UNKNOWN_DECLARE_START: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unknown TypeScript declare start`,
		},
		TS_UNEXPECTED_CAST_IN_PARAMETER_POSITION: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unexpected type cast in parameter position`,
		},
		TS_DISABLED_BUT_ACCESSIBILITY_OR_READONLY: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Accessibility and readonly syntax found but TS is not enabled`,
		},
		TS_PARAMETER_PROPERTY_BINDING_PATTERN: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`A parameter property may not be declared using a binding pattern.`,
		},
		TS_TUPLE_ELEMENT_LABEL_INCORRECT: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Only an identifier can be a tuple element label but this is something more complex`,
		},
		TS_TUPLE_ELEMENT_OPTIONAL_REST: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`A tuple member cannot be both optional and rest.`,
		},
		TS_TUPLE_ELEMENT_OPTIONAL_TRAILING: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`A labeled tuple element is declared as optional with a question mark after the name and before the colon, rather than after the type.`,
		},
		TYPE_ANNOTATION_AFTER_ASSIGNMENT: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Type annotations must come before default assignments, e.g. instead of \`age = 25: number\` use \`age: number = 25\``,
		},
		TYPE_BINDING_PARAMETER_OPTIONAL: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`A binding pattern parameter cannot be optional in an implementation signature.`,
		},
		ILLEGAL_FUNCTION_IN_STRICT: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`In strict mode code, functions can only be declared at top level or inside a block`,
		},
		ILLEGAL_FUNCTION_IN_NON_STRICT: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement`,
		},
		ILLEGAL_GENERATOR_DEFINITION: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Generators can only be declared at the top level or inside a block`,
		},
		ILLEGAL_ASYNC_DEFINITION: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Async functions can only be declared at the top level or inside a block`,
		},
		LEXICAL_DECLARATION_IN_SINGLE_STATEMENT_CONTEXT: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Lexical declaration cannot appear in a single-statement context`,
		},
		IMPORT_EXPORT_MUST_TOP_LEVEL: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`'import' and 'export' may only appear at the top level`,
		},
		REGULAR_FOR_AWAIT: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Can't have an await on a regular for loop`,
		},
		RETURN_OUTSIDE_FUNCTION: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`'return' outside of function`,
		},
		MULTIPLE_DEFAULT_CASE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Multiple default clauses`,
		},
		SWITCH_STATEMENT_OUTSIDE_CASE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Statement outside of a case or default block`,
		},
		NEWLINE_AFTER_THROW: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Illegal newline after throw`,
		},
		TRY_MISSING_FINALLY_OR_CATCH: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Missing catch or finally clause`,
		},
		INVALID_LABEL_DECLARATION: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid labeled declaration`,
		},
		WITH_IN_STRICT: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`'with' in strict mode`,
		},
		OCTAL_IN_STRICT: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Octal literal in strict mode`,
		},
		FOR_IN_OF_WITH_INITIALIZER: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Loop variable declaration may not have an initializer`,
		},
		CONST_WITHOUT_INITIALIZER: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`A constant must have an initializer`,
		},
		COMPLEX_BINDING_WITHOUT_INITIALIZER: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Complex binding patterns require an initialization value`,
		},
		ACCESSOR_WITH_TYPE_PARAMS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`An accessor cannot have type parameters`,
		},
		UNEXPECTED_SPREAD: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unexpected spread`,
		},
		DUPLICATE_LABEL: (label, loc) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Label <emphasis>${label}</emphasis> is already declared`,
			advice: ___R$project$rome$$internal$diagnostics$helpers_ts$buildDuplicateLocationAdvice([
				loc,
			]),
		}),
		UNKNOWN_LABEL: (label) => ({
			message: label === undefined
				? ___R$project$rome$$internal$markup$escape_ts$markup`No loop label found`
				: ___R$project$rome$$internal$markup$escape_ts$markup`Unknown label <emphasis>${label}</emphasis>`,
		}),
		IMPORT_EXPORT_IN_SCRIPT: (manifestPath) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>import</emphasis> and <emphasis>export</emphasis> can only appear in a module`,
			advice: [
				// TODO this advice is pointless if you have syntax extensions enabled
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Change the extension to <emphasis>.mjs</emphasis> to turn this file into a module`,
				},
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Add <emphasis>"type": "module"</emphasis> to your <filelink emphasis target="${manifestPath}" />`,
				},
			],
		}),
		SUPER_CALL_OUTSIDE_CONSTRUCTOR: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`super() is only valid inside a class constructor of a subclass`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Maybe a typo in the method name ('constructor') or not extending another class?`,
				},
			],
		},
		JSX_DISABLED: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`JSX syntax isn't enabled`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Are you using <emphasis>TypeScript</emphasis>? Change the file extension to <emphasis>.tsx</emphasis>`,
				},
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Are you using <emphasis>Flow</emphasis>? Add a <emphasis>@flow</emphasis> comment annotation to the top of the file`,
				},
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Not using either? Change the file extension to <emphasis>.jsx</emphasis>`,
				},
				// TODO you can also add `@jsx whatever` at the top of a file
			],
		},
		JSX_IN_TS_EXTENSION: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`JSX isn't allowed in regular TypeScript files`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Change the file extension to <emphasis>.tsx</emphasis> to enable JSX support`,
				},
			],
		},
		INVALID_PARENTEHSIZED_LVAL: (patternType) => {
			const message = ___R$project$rome$$internal$markup$escape_ts$markup`Invalid parenthesized binding`;
			if (patternType === "object") {
				return {
					message,
					advice: [
						{
							type: "log",
							category: "info",
							text: ___R$project$rome$$internal$markup$escape_ts$markup`Did you use \`({a}) = 0\` instead of \`({a} = 0)\`?`,
						},
					],
				};
			} else if (patternType === "array") {
				return {
					message,
					advice: [
						{
							type: "log",
							category: "info",
							text: ___R$project$rome$$internal$markup$escape_ts$markup`Did you use \`([a]) = 0\` instead of \`([a] = 0)\`?`,
						},
					],
				};
			} else {
				return {
					message,
					advice: [],
				};
			}
		},
		EXPECTED_COMMA_SEPARATOR: (context) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected a comma to separate items in ${context}`,
		}),
		INVALID_LEFT_HAND_SIDE: (context) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid left-hand side in ${context}`,
		}),
		TS_EMPTY_LIST: (descriptor) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`${descriptor} list cannot be empty`,
		}),
		JSX_EXPECTED_CLOSING_TAG: (name, openingLoc) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected a corresponding JSX closing tag for <emphasis>${name}</emphasis>`,
			advice: ___R$$priv$project$rome$$internal$diagnostics$descriptions$parsers$jsParser_ts$buildJSXOpeningAdvice(
				name,
				openingLoc,
			),
		}),
		JSX_EXPECTED_CLOSING_FRAGMENT_TAG: (name, openingLoc) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected JSX closing fragment tag`,
			advice: ___R$$priv$project$rome$$internal$diagnostics$descriptions$parsers$jsParser_ts$buildJSXOpeningAdvice(
				name,
				openingLoc,
			),
		}),
		JSX_UNKNOWN_CHILD_START: (name, openingLoc) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unknown JSX children start`,
			advice: ___R$$priv$project$rome$$internal$diagnostics$descriptions$parsers$jsParser_ts$buildJSXOpeningAdvice(
				name,
				openingLoc,
			),
		}),
		JSX_UNCLOSED_ELEMENT: (name, openingLoc) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unclosed JSX element`,
			advice: ___R$$priv$project$rome$$internal$diagnostics$descriptions$parsers$jsParser_ts$buildJSXOpeningAdvice(
				name,
				openingLoc,
			),
		}),
		TS_REQUIRED: (label) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`A ${label} is only valid inside of a TypeScript file`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`To enable <emphasis>TypeScript</emphasis> support, the file extension should end in <emphasis>.ts</emphasis> or <emphasis>.tsx</emphasis>`,
				},
			],
		}),
		DUPLICATE_EXPORT: (name, existing) => ({
			message: name === "default"
				? ___R$project$rome$$internal$markup$escape_ts$markup`Only one default export allowed per module.`
				: ___R$project$rome$$internal$markup$escape_ts$markup`\`${name}\` has already been exported. Exported identifiers must be unique.`,
			advice: ___R$project$rome$$internal$diagnostics$helpers_ts$buildDuplicateLocationAdvice([
				existing,
			]),
		}),
		NEW_IN_OPTIONAL_CHAIN: (responsiblePointer) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`constructors in/after an Optional Chain are not allowed`,
			advice: responsiblePointer && [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Optional chain member responsible`,
				},
				{
					type: "frame",
					location: responsiblePointer,
				},
			],
		}),
		UNKNOWN_EXPRESSION_ATOM_START: (context) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unknown start to an ${context}`,
		}),
		INVALID_META_PROPERTY: (metaName, propertyName) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`The only valid meta property for ${metaName} is ${metaName}.${propertyName}`,
		}),
		ARGUMENT_CLASH_IN_STRICT: (name, loc) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Argument <emphasis>${name}</emphasis> name clash in strict mode`,
			advice: ___R$project$rome$$internal$diagnostics$helpers_ts$buildDuplicateLocationAdvice([
				loc,
			]),
		}),
		RESERVED_WORD: (word) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`${word} is a reserved word`,
		}),
		UNEXPECTED_KEYWORD: (keyword) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unexpected keyword ${keyword}`,
		}),
		UNEXPECTED_TOKEN: (expected, possibleShiftMistake) => ({
			message: expected === undefined
				? ___R$project$rome$$internal$markup$escape_ts$markup`Unexpected token`
				: ___R$project$rome$$internal$markup$escape_ts$markup`Unexpected token, expected ${expected}`,
			advice: possibleShiftMistake
				? [
						{
							type: "log",
							category: "info",
							text: ___R$project$rome$$internal$markup$escape_ts$markup`Did you accidently hold shift?`,
						},
					]
				: [],
		}),
		EXPECTED_CLOSING: (name, char, location) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unclosed ${name}`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`We expected to find the closing character <emphasis>${char}</emphasis> here`,
				},
				{
					type: "frame",
					location,
				},
			],
		}),
		EXPECTED_KEYWORD: (keyword) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected keyword ${keyword}`,
		}),
		ESCAPE_SEQUENCE_IN_WORD: (word) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`${word} can't contain a unicode escape`,
		}),
		EXPECTED_ENABLE_SYNTAX: (syntaxName) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected ${syntaxName} syntax to be enabled`,
		}),
		UNEXPECTED_HASH: (exclamationFollowed) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unexpected character #`,
			advice: exclamationFollowed
				? [
						{
							type: "log",
							category: "info",
							text: ___R$project$rome$$internal$markup$escape_ts$markup`Did you want to write a hashbang? A hashbang can only be the first thing in a file.`,
						},
					]
				: [],
		}),
		UNEXPECTED_UNICODE_CHARACTER: (
			char,
			unicodeName,
			equivalentChar,
			equivalentName,
		) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unexpected Unicode character '<emphasis>${char}</emphasis>' (<emphasis>${unicodeName}</emphasis>)`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Did you mean '<emphasis>${equivalentChar}</emphasis>' (<emphasis>${equivalentName}</emphasis>)? Both characters look the same, but are not.`,
				},
			],
		}),
		EXPECTED_NUMBER_IN_RADIX: (radix) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected number in radix ${String(
				radix,
			)}`,
		}),
		INVALID_IDENTIFIER_NAME: (name) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid identifier ${name}`,
		}),
		ESCAPE_SEQUENCE_IN_KEYWORD: (keyword) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Escape sequence in keyword ${keyword}`,
		}),
	});


  // project-rome/@internal/diagnostics/descriptions/parsers/cssParser.ts
const ___R$project$rome$$internal$diagnostics$descriptions$parsers$cssParser_ts$cssParser = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		INVALID_BLOCK_START: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid block start`,
		},
		INVALID_DECLARATION: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid declaration`,
		},
		INVALID_ESCAPE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid escape sequence`,
		},
		UNEXPECTED_TOKEN: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unexpected token`,
		},
		UNTERMINATED_AT_RULE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unterminated at-rule`,
		},
		UNTERMINATED_BLOCK: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unterminated block`,
		},
		UNTERMINATED_FUNCTION: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unterminated function`,
		},
		UNTERMINATED_STRING: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unterminated string`,
		},
		UNTERMINATED_URL: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unterminated URL`,
		},
	});


  // project-rome/@internal/diagnostics/descriptions/typeCheck.ts
const ___R$project$rome$$internal$diagnostics$descriptions$typeCheck_ts$typeCheck = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		NOT_CALLABLE: {
			category: "typeCheck/uncallable",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`This type isn't callable`,
		},
		INCOMPATIBILITY: (upper, originLoc) => ({
			category: "typeCheck/incompatible",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Type incompatibility found`,
			advice: [
				{
					type: "log",
					category: "error",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`This type is incompatible with expected type of`,
				},
				originLoc === undefined
					? {
							type: "log",
							category: "info",
							text: upper,
						}
					: {
							type: "frame",
							location: Object.assign({}, originLoc, {marker: upper}),
						},
			],
		}),
		UNKNOWN_IMPORT: (importedName, source, possibleNames) => ({
			category: "typeCheck/unknownImport",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unknown import '${importedName}' in '${source}'`,
			advice: ___R$project$rome$$internal$diagnostics$helpers_ts$buildSuggestionAdvice(
				importedName,
				possibleNames,
			),
		}),
		UNKNOWN_PROP: (key, possibleNames) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Property ${key} not found in`,
			category: "typeCheck/unknownProperty",
			advice: ___R$project$rome$$internal$diagnostics$helpers_ts$buildSuggestionAdvice(
				key,
				possibleNames,
			),
		}),
		UNDECLARED_VARIABLE: (name, possibleNames) => ({
			category: "typeCheck/undeclaredVariable",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Undeclared variable ${name}`,
			advice: ___R$project$rome$$internal$diagnostics$helpers_ts$buildSuggestionAdvice(
				name,
				possibleNames,
			),
		}),
		NOT_EXHAUSTIVE: (only, target) => ({
			category: "typeCheck/notExhaustive",
			//message += `but allows ${this.extraenous.map(type => this.utils.humanize(type)).join(' | ')}`;
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected only a ${only} but got ${target}`,
		}),
		MISSING_CONDITION: (missing) => ({
			category: "typeCheck/missingCondition",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Missing the conditions ${missing.join(
				", ",
			)}`,
		}),
	});


  // project-rome/@internal/diagnostics/descriptions/consume.ts
const ___R$project$rome$$internal$diagnostics$descriptions$consume_ts$consume = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		SET_PROPERTY_NON_OBJECT: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Attempted to set a property on a non-object`,
		},
		EXPECTED_JSON_VALUE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected a JSON value`,
		},
		EXPECTED_OBJECT: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected object`,
		},
		EXPECTED_ARRAY: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected array`,
		},
		EXPECTED_DATE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected a date`,
		},
		EXPECTED_BOOLEAN: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected a boolean`,
		},
		EXPECTED_STRING: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected a string`,
		},
		EXPECTED_BIGINT: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected a bigint`,
		},
		EXPECTED_NUMBER: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected a number`,
		},
		EXPECTED_URL: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected a URL`,
		},
		EXPECTED_VALID_NUMBER: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected valid number`,
		},
		EXPECTED_ABSOLUTE_PATH: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected an absolute file path`,
		},
		EXPECTED_RELATIVE_PATH: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected a relative file path`,
		},
		EXPECTED_EXPLICIT_RELATIVE_PATH: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected an explicit relative file path. This is one that starts with <emphasis>./</emphasis> or <emphasis>../</emphasis>`,
		},
		INVALID: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid value`,
		},
		EXPECTED_NUMBER_BETWEEN: (min, max) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected number between ${String(
				___R$project$rome$$internal$ob1$index_ts$ob1Get(min),
			)} and ${String(___R$project$rome$$internal$ob1$index_ts$ob1Get(max))}`,
		}),
		EXPECTED_NUMBER_HIGHER: (num) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected number higher than ${String(
				___R$project$rome$$internal$ob1$index_ts$ob1Get(num),
			)}`,
		}),
		EXPECTED_NUMBER_LOWER: (num) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected number lower than ${String(
				___R$project$rome$$internal$ob1$index_ts$ob1Get(num),
			)}`,
		}),
		INVALID_NUMBER_SET_VALUE: (value, validValues) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid number <emphasis>${value}</emphasis>`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Possible values are`,
				},
				{
					type: "list",
					list: validValues.map((num) =>
						___R$project$rome$$internal$markup$escape_ts$markup`${num}`
					),
				},
			],
		}),
		INVALID_STRING_SET_VALUE: (value, validValues) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid value <emphasis>${value}</emphasis>`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Possible values are`,
				},
				{
					type: "list",
					list: validValues.map((str) =>
						___R$project$rome$$internal$markup$escape_ts$markup`${str}`
					),
				},
			],
		}),
		UNUSED_PROPERTY: (key, type, knownProperties) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unknown <emphasis>${key}</emphasis> ${type}`,
			advice: ___R$project$rome$$internal$diagnostics$helpers_ts$buildSuggestionAdvice(
				key,
				knownProperties,
				{
					ignoreCase: true,
				},
			),
		}),
	});


  // project-rome/@internal/diagnostics/descriptions/manifest.ts
const ___R$project$rome$$internal$diagnostics$descriptions$manifest_ts$manifest = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		TOO_MANY_HASH_PARTS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Too many hashes`,
		},
		MISSING_HOSTED_GIT_USER: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Missing user`,
		},
		MISSING_HOSTED_GIT_REPO: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Missing repo`,
		},
		TOO_MANY_HOSTED_GIT_PARTS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected only 2 parts`,
		},
		EMPTY_NPM_PATTERN: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Missing rest of npm dependency pattern`,
		},
		TOO_MANY_NPM_PARTS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Too many @ signs`,
		},
		STRING_BIN_WITHOUT_NAME: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`A string bin is only allowed if the manifest has a name property`,
		},
		MISSING_REPO_URL: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Missing repo URL`,
		},
		MIXED_EXPORTS_PATHS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Cannot mix a root conditional export with relative paths`,
		},
		NAME_EXCEEDS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`cannot exceed 214 characters`,
		},
		INVALID_NAME_START: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`cannot start with a dot or underscore`,
		},
		ORG_WITH_NO_PACKAGE_NAME: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`contains an org but no package name`,
		},
		ORG_TOO_MANY_PARTS: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`contains too many name separators`,
		},
		REDUNDANT_ORG_NAME_START: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Redundant <emphasis>@</emphasis> in org name`,
		},
		INVALID_NAME_CHAR: (char) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`The character <emphasis>${char}</emphasis> isn't allowed`,
		}),
		INCORRECT_CASING: (typoKey, correctKey) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`${typoKey} has incorrect casing, should be ${correctKey}`,
		}),
		INCORRECT_CAMEL_CASING: (typoKey, correctKey) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`${typoKey} isn't correctly camel cased when it should be ${correctKey}`,
		}),
		TYPO: (typoKey, correctKey) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`${typoKey} is a typo of ${correctKey}`,
		}),
		UNSUPPORTED_DEPENDENCY_PATTERN_PREFIX: (prefix) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unsupported dependency pattern prefix <emphasis>${prefix}</emphasis>`,
		}),
	});


  // project-rome/@internal/diagnostics/descriptions/projectConfig.ts
const ___R$project$rome$$internal$diagnostics$descriptions$projectConfig_ts$projectConfig = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		BOOLEAN_CATEGORY: (enabled) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected an object here but got a boolean`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`You likely wanted \`{"enabled": ${String(
						enabled,
					)}}\` instead`,
				},
			],
		}),
		RECURSIVE_CONFIG: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Recursive config`,
		},
	});


  // project-rome/@internal/diagnostics/descriptions/lint.ts
const ___R$project$rome$$internal$diagnostics$descriptions$lint_ts$lint = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		HTML_USE_CLOSING_NON_VOID: {
			category: "lint/html/useClosingNonVoid",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Non-void HTML elements cannot be self-closing. This is valid when using JSX, but not when using HTML.`,
		},
		JSX_USE_SELF_CLOSING_ELEMENTS: {
			category: "lint/jsx/useSelfClosingElements",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`JSX elements without children should be marked as self-closing. In JSX, it is valid for any element to be self-closing.`,
		},
		JS_NO_SHOUTY_CONSTANTS: (constantLocation = {}) => ({
			category: "lint/js/noShoutyConstants",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Redundant constant reference`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`You should avoid declaring constants with a string that's the same value as the variable name. It introduces a level of unnecessary indirection when it's only two additional characters to inline.`,
				},
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`This constant is declared here`,
				},
				{
					type: "frame",
					location: constantLocation,
				},
			],
		}),
		JS_NO_UNUSED_TEMPLATE_LITERAL: {
			category: "lint/js/noUnusedTemplateLiteral",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Do not use template literals if interpolation and special-character handling are not needed.`,
		},
		JSX_NO_IMPLICIT_BOOLEAN: {
			category: "lint/jsx/noImplicitBoolean",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Use explicit boolean values for boolean JSX props.`,
		},
		JS_NO_NESTED_TERNARY: {
			category: "lint/js/noNestedTernary",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Nesting ternary expressions can make code more difficult to understand.`,
		},
		JSX_USE_J_S_X_FILE_EXTENSION: (ext, basename) => ({
			category: "lint/jsx/useJSXFileExtension",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Files with the <emphasis>${ext}</emphasis> extension cannot contain JSX elements.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Change the <emphasis>${basename}${ext}</emphasis> file extension to <emphasis>.jsx</emphasis> or <emphasis>.tsx</emphasis>.`,
				},
			],
		}),
		TS_PREFER_INTERFACES: {
			category: "lint/ts/useInterfaces",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Use an interface instead of an object type alias`,
		},
		JSX_NO_PROP_SPREADING: {
			category: "lint/jsx/noPropSpreading",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid using property spreading in JSX components.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Explicit JSX attributes enhance the readability of code by clearly indicating which props are accepted by a given element.`,
				},
			],
		},
		REACT_NO_ARRAY_INDEX_KEY: {
			category: "lint/react/noArrayIndexKey",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid using array index as key property in an element.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`See <hyperlink target="https://reactjs.org/docs/lists-and-keys.html#keys" /> for more information.`,
				},
			],
		},
		REACT_NO_THIS_IN_SFC: {
			category: "lint/react/noThisInSFC",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid using <emphasis>this</emphasis> in stateless functional components.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`The <emphasis>this</emphasis> keyword has no binding in functional components. Use hooks instead.`,
				},
			],
		},
		JSX_A11Y_ARIA_PROPTYPES: (attributeName, values) => {
			let advice = [];
			if (values) {
				advice.push({
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`The supported values for the <emphasis>${attributeName}</emphasis> attribute are: ${values.reduce(
						(str, value) => {
							str.push(
								typeof value === "boolean" ? String(value) : '"' + value + '"',
							);
							return str;
						},
						([]),
					).join(", ")}`,
				});
			}
			return {
				category: "lint/jsx-a11y/useAriaProptypes",
				message: ___R$project$rome$$internal$markup$escape_ts$markup`The value of the ARIA attribute <emphasis>${attributeName}</emphasis> is not correct.`,
				advice,
			};
		},

		JSX_A11Y_NO_NONINTERACTIVE_ELEMENT_TO_INTERACTIVE_ROLE: (element) => ({
			category: "lint/jsx-a11y/noNoninteractiveElementToInteractiveRole",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`The HTML element <emphasis>${element}</emphasis> is non-interactive and should not have an interactive role.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Replace <emphasis>${element}</emphasis> with a div or a span.`,
				},
			],
		}),
		JSX_USE_PASCAL_CASE: (oldName, newName) => ({
			category: "lint/jsx/usePascalCase",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Switch <emphasis>${oldName}</emphasis> to <emphasis>${newName}</emphasis>.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`User-defined JSX components should be defined and referenced in PascalCase.`,
				},
			],
		}),
		REACT_NO_USELESS_FRAGMENT: {
			category: "lint/react/noUselessFragment",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid using unnecessary <emphasis>Fragment</emphasis>.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`A <emphasis>Fragment</emphasis> is redundant if it contains only one child, or if it is the child of a html element, and is not a keyed fragment.`,
				},
			],
		},
		REACT_NO_ACCESS_STATE_IN_SET_STATE: {
			category: "lint/react/noAccessStateInSetState",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid using <emphasis>this.state</emphasis> within a <emphasis>this.setState</emphasis> call.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Batched state calls could result in unexpected errors due to stale state data.`,
				},
			],
		},
		JSX_A11Y_NO_REDUNDANT_ROLES: (role, element) => ({
			category: "lint/jsx-a11y/noRedundantRoles",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Using the role attribute <emphasis>${role}</emphasis> on the <emphasis>${element}</emphasis> element is redundant.`,
		}),
		JSX_A11Y_ANCHOR_IS_VALID: (message) => ({
			category: "lint/jsx-a11y/useValidAnchor",
			message,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Anchor elements should only be used for default section or page navigation.`,
				},
			],
		}),
		JSX_A11Y_NO_NONINTERACTIVE_TABINDEX: {
			category: "lint/jsx-a11y/noNoninteractiveTabindex",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Do not use <emphasis>tabIndex</emphasis> on an element that is not interactive.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Adding non-interactive elements to the keyboard navigation flow can confuse users.`,
				},
			],
		},
		JSX_A11Y_ARIA_PROPS: (attribute) => ({
			category: "lint/jsx-a11y/useAriaProps",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${attribute}</emphasis> is an invalid ARIA attribute.`,
		}),
		JSX_A11Y_CLICK_EVENTS_HAVE_KEY_EVENTS: {
			category: "lint/jsx-a11y/useKeyWithClickEvents",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Pair the <emphasis>onClick</emphasis> mouse event with the <emphasis>onKeyUp</emphasis>, the <emphasis>onKeyDown</emphasis>, or the <emphasis>onKeyPress</emphasis> keyboard event.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Actions triggered using mouse events should have corresponding keyboard events to account for keyboard-only navigation.`,
				},
			],
		},
		JSX_NO_DUPLICATE_PROPS: (key) => ({
			category: "lint/jsx/noDuplicateProps",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid duplicate component props. Check the <emphasis>${key}</emphasis> prop.`,
		}),
		REACT_NO_STRING_REFS: (details) => ({
			category: "lint/react/noStringRefs",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Using ${details} is a deprecated pattern.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`See <hyperlink target="https://reactjs.org/docs/refs-and-the-dom.html#legacy-api-string-refs" /> for more information.`,
				},
			],
		}),
		REACT_USE_FRAGMENT_SYNTAX: {
			category: "lint/react/useFragmentSyntax",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Use shorthand syntax for <emphasis>Fragment</emphasis> elements instead of standard syntax.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Shorthand fragment syntax saves keystrokes and is only unapplicable when keys are required.`,
				},
			],
		},
		REACT_NO_REDUNDANT_SHOULD_COMPONENT_UPDATE: {
			category: "lint/react/noRedundantShouldComponentUpdate",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Do not implement <emphasis>shouldComponentUpdate</emphasis> when extending <emphasis>React.PureComponent</emphasis>.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`When the shouldComponentUpdate method is implemented, extending React.PureComponent provides no benefit.`,
				},
			],
		},
		REACT_NO_UNSAFE: (oldMethod, newMethod) => ({
			category: "lint/react/noUnsafe",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`The <emphasis>${oldMethod}</emphasis> method is unsafe for use in async rendering. Use the <emphasis>${newMethod}</emphasis> method instead.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`See <hyperlink target="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html" /> for more information.`,
				},
			],
		}),
		REACT_NO_DID_MOUNT_SET_STATE: {
			category: "lint/react/noDidMountSetState",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid calling <emphasis>this.setState</emphasis> in the <emphasis>componentDidMount</emphasis> method.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Updating state after mounting causes a second render that can cause visual layout thrashing.`,
				},
			],
		},
		REACT_USE_BUTTON_TYPE: {
			category: "lint/react/useButtonType",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Provide an explicit <emphasis>type</emphasis> prop on <emphasis>button</emphasis> elements.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`The default button type of "submit" causes page reloads and is not typical behavior in a React application.`,
				},
			],
		},
		JSX_A11Y_TABINDEX_NO_POSITIVE: {
			category: "lint/jsx-a11y/noPositiveTabindex",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid positive integer values for the <emphasis>tabIndex</emphasis> attribute.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Elements with a positive tab index override natural page content order. This causes elements without a positive tab index to come last when navigating using a keyboard.`,
				},
			],
		},
		JSX_A11Y_MOUSE_EVENTS_HAVE_KEY_EVENTS: (mouseEvent, keyboardEvent) => ({
			category: "lint/jsx-a11y/useKeyWithMouseEvents",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Pair the <emphasis>${mouseEvent}</emphasis> mouse event with the <emphasis>${keyboardEvent}</emphasis> keyboard event.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Actions triggered using mouse events should have corresponding keyboard events to account for keyboard-only navigation.`,
				},
			],
		}),
		JSX_A11Y_MEDIA_HAS_CAPTION: {
			category: "lint/jsx-a11y/useMediaCaption",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Provide a <emphasis>track</emphasis> for captions when using <emphasis>audio</emphasis> or <emphasis>video</emphasis> elements.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Captions support users with hearing-impairments. They should be a transcription or translation of the dialogue, sound effects, musical cues, and other relevant audio information.`,
				},
			],
		},
		REACT_NO_WILL_UPDATE_SET_STATE: {
			category: "lint/react/noWillUpdateSetState",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid calling <emphasis>this.setState</emphasis> in the <emphasis>componentWillUpdate</emphasis> method.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Updating state immediately before a scheduled render causes a second render that can cause visual layout thrashing.`,
				},
			],
		},
		JSX_A11Y_ARIA_UNSUPPORTED_ELEMENTS: {
			category: "lint/jsx-a11y/noAriaUnsupportedElements",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid the <emphasis>role</emphasis> attribute and <emphasis>aria-*</emphasis> attributes when using <emphasis>meta</emphasis>, <emphasis>html</emphasis>, <emphasis>script</emphasis>, and <emphasis>style</emphasis> elements.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Using roles on elements that do not support them can cause issues with screen readers.`,
				},
			],
		},
		JSX_A11Y_ANCHOR_HAS_CONTENT: {
			category: "lint/jsx-a11y/useAnchorContent",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Provide screen reader accessible content when using <emphasis>anchor</emphasis> elements.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`All links on a page should have content that is accessible to screen readers.`,
				},
			],
		},
		JSX_A11Y_LANG: (value, suggestions) => ({
			category: "lint/jsx-a11y/useValidLang",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Provide a valid value for the <emphasis>lang</emphasis> attribute.`,
			advice: ___R$project$rome$$internal$diagnostics$helpers_ts$buildSuggestionAdvice(
				value,
				suggestions,
			),
		}),
		JSX_A11Y_ALT_TEXT: {
			category: "lint/jsx-a11y/useAltText",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Provide <emphasis>alt</emphasis> text when using <emphasis>img</emphasis>, <emphasis>area</emphasis>, <emphasis>input type='image'</emphasis>, and <emphasis>object</emphasis> elements.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Meaningful alternative text on elements helps users relying on screen readers to understand content's purpose within a page.`,
				},
			],
		},
		JSX_A11Y_HEADING_HAS_CONTENT: {
			category: "lint/jsx-a11y/useHeadingContent",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Provide screen reader accessible content when using <emphasis>heading</emphasis> elements.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`All headings on a page should have content that is accessible to screen readers.`,
				},
			],
		},
		JSX_A11Y_HTML_HAS_LANG: {
			category: "lint/jsx-a11y/useHtmlLang",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Provide a <emphasis>lang</emphasis> attribute when using the <emphasis>html</emphasis> element.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Setting a lang attribute on HTML elements configures the language used by screen readers when no user default is specified.`,
				},
			],
		},
		JSX_A11Y_IFRAME_HAS_TITLE: {
			category: "lint/jsx-a11y/useIframeTitle",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Provide a <emphasis>title</emphasis> attribute when using <emphasis>iframe</emphasis> elements.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Screen readers rely on the title set on an iframe to describe the content being displayed.`,
				},
			],
		},
		JSX_A11Y_IMG_REDUNDANT_ALT: {
			category: "lint/jsx-a11y/noRedundantAlt",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid the words "image", "picture", or "photo" in <emphasis>img</emphasis> element alt text.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Screen readers announce img elements as "images", so it is not necessary to redeclare this in alternative text.`,
				},
			],
		},
		JSX_A11Y_NO_ACCESS_KEY: {
			category: "lint/jsx-a11y/noAccessKey",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid the <emphasis>accessKey</emphasis> attribute to reduce inconsistencies between keyboard shortcuts and screen reader keyboard comments.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Assigning keyboard shortcuts using the accessKey attribute leads to inconsistent keyboard actions across applications.`,
				},
			],
		},
		JSX_A11Y_NO_AUTOFOCUS: {
			category: "lint/jsx-a11y/noAutofocus",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid the <emphasis>autoFocus</emphasis> attribute.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Automatically focusing elements overrides natural page content focus order, causing issues for keyboard-only navigation.`,
				},
			],
		},
		JSX_A11Y_NO_DISTRACTING_ELEMENTS: (element) => ({
			category: "lint/jsx-a11y/noDistractingElements",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid using deprecated ${element} elements.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Deprecated ${element} are difficult to read and distract attention away from page content, especially for users with visual impairments.`,
				},
			],
		}),
		JSX_A11Y_NO_ON_CHANGE: {
			category: "lint/jsx-a11y/noOnChange",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Provide an <emphasis>onBlur</emphasis> event instead of an <emphasis>onChange</emphasis> event unless absolutely necessary.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`The onBlur event is more declarative and reliable for indicating input changes when using keyboard navigation.`,
				},
			],
		},
		JSX_A11Y_NO_TARGET_BLANK: {
			category: "lint/jsx-a11y/noTargetBlank",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid using <emphasis>target="_blank"</emphasis> without <emphasis>rel="noreferrer"</emphasis>.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Opening external links in new tabs without rel="noreferrer" is a security risk. See <hyperlink target="https://html.spec.whatwg.org/multipage/links.html#link-type-noopener" /> for more details.`,
				},
			],
		},
		JSX_A11Y_NO_SCOPE: {
			category: "lint/jsx-a11y/noHeaderScope",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid using the <emphasis>scope</emphasis> attribute on elements other than <emphasis>th</emphasis> elements.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Using the scope attribute incorrectly on tables makes them difficult to navigate using the keyboard.`,
				},
			],
		},
		JSX_A11Y_ROLE_HAS_REQUIRED_ARIA_PROPS: (roleName, missingAttributes) => ({
			category: "lint/jsx-a11y/useAriaPropsForRole",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`The element with the <emphasis>${roleName}</emphasis> ARIA role does not have the required ARIA attributes.`,
			advice: missingAttributes.map((missingAttribute) => {
				return {
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Missing aria attribute: ${missingAttribute}`,
				};
			}),
		}),
		REACT_USE_KEY: (origin) => ({
			category: "lint/react/useKey",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Provide a <emphasis>key</emphasis> prop with a unique value for each element in <emphasis>${origin}</emphasis>.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Keys help React identify which items have changed, are added, or are removed.`,
				},
			],
		}),
		JSX_NO_COMMENT_TEXT: {
			category: "lint/jsx/noCommentText",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Wrap <emphasis>comments</emphasis> inside children within <emphasis>braces</emphasis>.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`JavaScript comment sequences are not supported by JSX and result in unwanted characters on-screen.`,
				},
			],
		},
		REACT_NO_CHILDREN_PROP: {
			category: "lint/react/noChildrenProp",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid passing <emphasis>children</emphasis> using a prop.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`The canonical way to pass children in React is to use JSX elements or additional arguments to React.createElement.`,
				},
			],
		},
		REACT_NO_DANGER: {
			category: "lint/react/noDanger",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid passing content using the <emphasis>dangerouslySetInnerHTML</emphasis> prop.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Setting content using code can expose users to cross-site scripting (XSS) attacks.`,
				},
			],
		},
		REACT_NO_DANGER_WITH_CHILDREN: {
			category: "lint/react/noDangerWithChildren",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid passing both <emphasis>children</emphasis> and the <emphasis>dangerouslySetInnerHTML</emphasis> prop.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Setting HTML content will inadvertently override any passed children in React.`,
				},
			],
		},
		REACT_NO_DID_UPDATE_SET_STATE: {
			category: "lint/react/noDidUpdateSetState",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid calling <emphasis>this.setState</emphasis> in the <emphasis>componentDidUpdate</emphasis> method.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Updating state immediately after a previous update causes a second render that can cause visual layout thrashing.`,
				},
			],
		},
		REACT_NO_DIRECT_MUTATION_STATE: {
			category: "lint/react/noDirectMutationState",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid mutating <emphasis>this.state</emphasis> directly.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Calling <emphasis>setState()</emphasis> after mutating <emphasis>this.state</emphasis> directly may replace the mutation you made. The only place you may set <emphasis>this.state</emphasis> directly is in a constructor of a react class component.`,
				},
			],
		},
		REACT_NO_FIND_DOM_NODE: {
			category: "lint/react/noFindDOMNode",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid using the <emphasis>findDOMNode</emphasis> function.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`React plans to deprecate the findDOMNode function entirely since it prevents internal optimizations. Use callback refs instead.`,
				},
			],
		},
		REACT_USE_SORT_COMP: (right, wrong, position) => ({
			category: "lint/react/useSortComp",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${wrong}</emphasis> should be placed ${position} <emphasis>${right}</emphasis>.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`When creating React components it is more convenient to always follow the same organisation for method order to help you easily find lifecycle methods, event handlers, etc.`,
				},
			],
		}),
		REACT_USE_STYLE_PROP_OBJECT: {
			category: "lint/react/useStylePropObject",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`The <emphasis>style</emphasis> prop value must be an object.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`React will ignore non-object style props, even valid JSON strings.`,
				},
			],
		},
		REACT_USE_RENDER_RETURN: {
			category: "lint/react/useRenderReturn",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`The <emphasis>render</emphasis> method on a component must return content.`,
		},
		REACT_NO_RENDER_RETURN_VALUE: {
			category: "lint/react/noRenderReturnValue",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Do not depend on the return value from <emphasis>ReactDOM.render()</emphasis>.`,
		},
		REACT_NO_VOID_ELEMENTS_WITH_CHILDREN: (element, properties) => ({
			category: "lint/react/noVoidElementsWithChildren",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${element}</emphasis> is a void element tag and must not have <emphasis>${___R$project$rome$$internal$diagnostics$descriptions$index_ts$orJoin(
				properties.map((name) =>
					___R$project$rome$$internal$markup$escape_ts$markup`${name}`
				),
			)}</emphasis>.`,
		}),
		JS_USE_DEFAULT_IMPORT_BASENAME: (prev, basenames) => ({
			category: "lint/js/useDefaultImportBasename",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Use the basename ${___R$project$rome$$internal$diagnostics$descriptions$index_ts$orJoin(
				___R$project$rome$$internal$diagnostics$descriptions$index_ts$addEmphasis(
					basenames.map((basename) =>
						___R$project$rome$$internal$markup$escape_ts$markup`${basename}`
					),
				),
			)} when importing the default.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`If you really meant to use a named import, use the following:`,
				},
				{
					type: "code",
					language: "js",
					sourceText: "import {default as " + prev + "}",
				},
			],
		}),
		JS_NO_COMMA_OPERATOR: {
			category: "lint/js/noCommaOperator",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>Avoid the comma operator</emphasis>. It can lead to easy mistakes and ambiguous code.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`If you want multiple expressions, then break it up.`,
				},
			],
		},
		JS_NO_NEGATION_ELSE: {
			category: "lint/js/noNegationElse",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>Invert blocks</emphasis> when performing a negation test.`,
		},
		JS_NO_DUPLICATE_IMPORT_SOURCE: (seenLocation) => ({
			category: "lint/js/noDuplicateImportSource",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`This module has <emphasis>already been imported</emphasis>.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Previously imported here`,
				},
				{
					type: "frame",
					location: seenLocation,
				},
			],
		}),
		JS_PREFER_BLOCK_STATEMENT: {
			category: "lint/js/useBlockStatements",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>Block statements</emphasis> are preferred in this position.`,
		},
		JS_USE_TEMPLATE: {
			category: "lint/js/useTemplate",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>Template literals</emphasis> are preferred over <emphasis>string concatenation</emphasis>.`,
		},
		JS_USE_WHILE: {
			category: "lint/js/useWhile",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Use <emphasis>while</emphasis> loops instead of <emphasis>for</emphasis> loops.`,
		},
		JS_UNSAFE_NEGATION: {
			category: "lint/js/noUnsafeNegation",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`The <emphasis>negation operator is used unsafely</emphasis> on the left side of this binary expression.`,
		},
		JS_NO_UNUSED_VARIABLES: (kind, name) => ({
			category: "lint/js/noUnusedVariables",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`The ${kind} variable <emphasis>${name}</emphasis> is unused.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Unused variables are dead code and usually the result of incomplete refactoring.`,
				},
			],
		}),
		JS_NO_UNDECLARED_VARIABLES: (name, bindingsInScope) => ({
			category: "lint/js/noUndeclaredVariables",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`The <emphasis>${name}</emphasis> variable is undeclared`,
			advice: ___R$project$rome$$internal$diagnostics$helpers_ts$buildSuggestionAdvice(
				name,
				bindingsInScope,
			),
		}),
		JS_VARIABLE_CAMEL_CASE: (name, camelCaseName) => ({
			category: "lint/js/useCamelCase",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`The <emphasis>${name}</emphasis> variable should be camel cased as <emphasis>${camelCaseName}</emphasis>.`,
		}),
		JS_USE_SINGLE_CASE_STATEMENT: {
			category: "lint/js/useSingleCaseStatement",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`A switch case should only have a single statement. If you want more, then wrap it in a block.`,
		},
		/*JS_NO_CONFUSING_LANGUAGE: (
		message: StaticMarkup,
		suggestion: string,
		advice: DiagnosticAdvice,
	) => ({
		category: "lint/js/noConfusingLanguage",
		message,
		advice: [
			...advice,
			{
				type: "log",
				category: "info",
				text: markup`Consider using <emphasis>${suggestion}</emphasis> instead`,
			},
		],
	}),*/
		JS_NO_DOUBLE_EQUALS: {
			category: "lint/js/noDoubleEquals",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Use <emphasis>===</emphasis> instead of <emphasis>==</emphasis>.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`== is only allowed when comparing against null.`,
				},
			],
		},
		REGEX_NO_EMPTY_MATCHES: {
			category: "lint/regex/noEmptyMatches",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`This expression can return <emphasis>empty matches</emphasis>, and may match infinitely in some use cases.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Strengthen the regular expression so that empty matches are not possible.`,
				},
			],
		},
		JS_NEGATE_DOUBLE_EQUALS: {
			category: "lint/js/noDoubleEquals",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Use <emphasis>!==</emphasis> instead of <emphasis>!=</emphasis>.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`!= is only allowed when comparing against null.`,
				},
			],
		},
		JS_NO_CATCH_ASSIGN: {
			category: "lint/js/noCatchAssign",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Do not <emphasis>reassign catch parameters</emphasis>.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Use a local variable instead.`,
				},
			],
		},
		JS_NO_SPARSE_ARRAY: {
			category: "lint/js/noSparseArray",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`This <emphasis>array</emphasis> contains an <emphasis>empty slot</emphasis>.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Sparse arrays without values for some items can lead to confusion.`,
				},
			],
		},
		JS_USE_SINGLE_VAR_DECLARATOR: {
			category: "lint/js/useSingleVarDeclarator",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Declare variables separately.`,
		},
		JS_USE_FUNCTION_DECLARATIONS: {
			category: "lint/js/useFunctionDeclarations",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Use a <emphasis>function declaration</emphasis> instead of a <emphasis>const function</emphasis>.`,
		},
		JS_NO_VAR: {
			category: "lint/js/noVar",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Variable declarations using <emphasis>var</emphasis> are disallowed.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Use let or const instead.`,
				},
			],
		},
		JS_NO_SHORTHAND_ARRAY_TYPE: {
			category: "lint/js/noShorthandArrayType",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Use <emphasis>Array${"<T>"} syntax</emphasis> instead of <emphasis>shorthand T[] syntax</emphasis>.`,
		},
		JS_NO_UNSAFE_FINALLY: (type) => ({
			category: "lint/js/noUnsafeFinally",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Using <emphasis>${type}</emphasis> inside a <emphasis>finally</emphasis> clause is unsafe.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Do not use control flow statements inside finally clauses.`,
				},
			],
		}),
		JS_NO_TEMPLATE_CURLY_IN_STRING: {
			category: "lint/js/noTemplateCurlyInString",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`This string contains an <emphasis>unexpected template string</emphasis> expression.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Using template string expressions in regular strings is usually a typo.`,
				},
			],
		},
		JS_NO_SHADOW_RESTRICTED_NAMES: (name) => ({
			category: "lint/js/noShadowRestrictedNames",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Do not shadow the global <emphasis>${name}</emphasis> property.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Consider renaming this variable. It's easy to confuse the origin of variables when they're named after a known global.`,
				},
			],
		}),
		REGEX_NO_MULTIPLE_SPACES_IN_REGEX_LITERAL: (count) => ({
			category: "lint/regex/noMultipleSpacesInRegularExpressionLiterals",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`This <emphasis>regular expression</emphasis> contains unclear uses of <emphasis>multiple spaces</emphasis>.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`It's hard to visually count the amount of spaces, it's clearer if you use a quantifier instead. eg / {${String(
						count,
					)}}/`,
				},
			],
		}),
		JS_NO_LABEL_VAR: (name) => ({
			category: "lint/js/noLabelVar",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Do not use the ${name} variable name as a label.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Creating a label with the same name as an in-scope variable leads to confusion.`,
				},
			],
		}),
		JS_NO_IMPORT_ASSIGN: (name) => ({
			category: "lint/js/noImportAssign",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`The imported variable <emphasis>${name}</emphasis> is read-only.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Use a local variable instead of reassigning an import.`,
				},
			],
		}),
		JS_NO_EXTRA_BOOLEAN_CAST: {
			category: "lint/js/noExtraBooleanCast",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid <emphasis>redundant double-negation</emphasis>.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`It is not necessary to use double-negation when a value will already be coerced to a boolean.`,
				},
			],
		},
		JS_NO_FUNCTION_ASSIGN: {
			category: "lint/js/noFunctionAssign",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Do not <emphasis>reassign a function declaration</emphasis>.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Use a local variable instead.`,
				},
			],
		},
		REGEX_NO_EMPTY_CHAR_SET: {
			category: "lint/regex/noEmptyCharacterClass",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Do not use <emphasis>empty character classes in regular expressions</emphasis>.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Empty character classes are usually typos.`,
				},
			],
		},
		JS_NO_DUPLICATE_KEYS: (key) => ({
			category: "lint/js/noDuplicateKeys",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid duplicate component key. Check the <emphasis>${key}</emphasis> key.`,
		}),
		REGEX_NO_POSIX_IN_REGULAR_EXPRESSION: {
			category: "lint/regex/noPosixInRegularExpression",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Do not use POSIX character classes and collating sequences.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`This functionality is not supported in JavaScript regular expressions.`,
				},
			],
		},
		JS_NO_DUPLICATE_CASE: (value) => ({
			category: "lint/js/noDuplicateCase",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Do not duplicate the <emphasis>${value}</emphasis> case.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Duplicated switch logic paths are hard to follow and usually typos.`,
				},
			],
		}),
		JS_NO_DUPE_ARGS: (name) => ({
			category: "lint/js/noDupeArgs",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid duplicate function arguments. Check the <emphasis>${name}</emphasis> argument.`,
		}),
		JS_NO_DELETE: {
			category: "lint/js/noDelete",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`This is an unexpected use of the <emphasis>delete</emphasis> operator.`,
		},
		JS_NO_DELETE_VARS: {
			category: "lint/js/noDeleteVars",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`This is an invalid use of the <emphasis>delete</emphasis> operator.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Only object properties can be deleted.`,
				},
			],
		},
		JS_NO_DEBUGGER: {
			category: "lint/js/noDebugger",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`This is an unexpected use of the <emphasis>debugger</emphasis> statement.`,
		},
		JS_NO_COND_ASSIGN: {
			category: "lint/js/noCondAssign",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Do not assign <emphasis>variables in loop conditions</emphasis>.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`It is a common typo to mistype an equality operator as an assignment operator.`,
				},
			],
		},
		JS_NO_COMPARE_NEG_ZERO: (op) => ({
			category: "lint/js/noCompareNegZero",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Do not use the <emphasis>${op}</emphasis> operator to compare against <emphasis>-0</emphasis>.`,
			fixable: op === "===",
		}),
		JS_NO_ASYNC_PROMISE_EXECUTOR: {
			category: "lint/js/noAsyncPromiseExecutor",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>Promise executor functions</emphasis> should not be <emphasis>async</emphasis>.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`This can lead to lost errors and unnecessary indirection.`,
				},
			],
		},
		JS_NO_GETTER_RETURN: (got) => ({
			category: "lint/js/noGetterReturn",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>Return a value at the end of a getter method</emphasis> instead of ${got}.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Getters that do not return values are either typos or should not be getters.`,
				},
			],
		}),
		JS_NO_SETTER_RETURN: {
			category: "lint/js/noSetterReturn",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Do not <emphasis>return a value</emphasis> at the end of a <emphasis>setter method</emphasis>.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Setters that return values are either typos or should not be setters.`,
				},
			],
		},
		JS_NO_EMPTY_BLOCKS: {
			category: "lint/js/noEmptyBlocks",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid <emphasis>empty logic blocks</emphasis>.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Empty logic blocks usually result from incomplete refactoring.`,
				},
			],
		},
		JS_NO_ARGUMENTS: {
			category: "lint/js/noArguments",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Use the <emphasis>rest parameters</emphasis> instead of <emphasis>arguments</emphasis>.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Arguments does not have Array.prototype methods and can be inconvenient to use.`,
				},
			],
		},
		REGEX_DUPLICATE_REGEX_GROUP_NAME: (name) => ({
			category: "lint/regex/noDuplicateGroupNamesInRegularExpressions",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid duplicate group names. Check the <emphasis>${name}</emphasis> group.`,
		}),
		REGEX_NO_REFERENCE_TO_NON_EXISTING_GROUP: (name) => ({
			category: "lint/regex/noReferenceToNonExistingGroup",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid nonexistent group names. Check the <emphasis>${name}</emphasis> group.`,
		}),
		JS_USE_DEFAULT_EXPORT_BASENAME: (
			{
				defaultName,
				defaultType,
				actualFilename,
				correctFilename,
			},
		) => {
			let adviceMessage;

			if (defaultName === "*default*") {
				adviceMessage = ___R$project$rome$$internal$markup$escape_ts$markup`The`;
			} else {
				adviceMessage = ___R$project$rome$$internal$markup$escape_ts$markup`The filename should be <emphasis>${correctFilename}</emphasis> or the`;
			}

			adviceMessage = ___R$project$rome$$internal$markup$escape_ts$markup`${adviceMessage} ${defaultType} name should be <emphasis>${actualFilename}</emphasis>.`;

			return {
				category: "lint/js/useDefaultExportBasename",
				message: ___R$project$rome$$internal$markup$escape_ts$markup`The filename and the name of a default ${defaultType} should match.`,
				advice: [
					{
						type: "log",
						category: "info",
						text: adviceMessage,
					},
				],
			};
		},
		JS_NO_RESTRICTED_GLOBALS: (globalName) => ({
			category: "lint/js/noRestrictedGlobals",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Do not use the global variable <emphasis>${globalName}</emphasis>.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Use a local variable instead.`,
				},
			],
		}),
		JS_SORT_EXPORT_SPECIFIERS: {
			category: "lint/js/useSortedSpecifiers",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`The specifiers of the export declaration should be sorted alphabetically.`,
		},
		JS_SORT_IMPORT_SPECIFIERS: {
			category: "lint/js/useSortedSpecifiers",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`The specifiers of the import declaration should be sorted alphabetically.`,
		},
		PENDING_FIXES: (relativeFilename, language, original, formatted) => ({
			category: "lint/pendingFixes",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Pending formatting and safe fixes`,
			advice: [
				{
					type: "diff",
					language,
					diff: ___R$project$rome$$internal$string$diff$index_ts$default(
						original,
						formatted,
					),
				},
				({
					type: "action",
					command: "check",
					shortcut: "f",
					instruction: ___R$project$rome$$internal$markup$escape_ts$markup`To apply fixes and formatting run`,
					noun: ___R$project$rome$$internal$markup$escape_ts$markup`Apply fixes and format`,
					args: [relativeFilename],
					commandFlags: {
						apply: true,
					},
				}),
				({
					type: "action",
					hidden: true,
					command: "check",
					shortcut: "o",
					instruction: ___R$project$rome$$internal$markup$escape_ts$markup`To format this file without any fixes run`,
					noun: ___R$project$rome$$internal$markup$escape_ts$markup`Only format`,
					args: [relativeFilename],
					commandFlags: {
						format: true,
					},
				}),
			],
		}),
		TS_NO_EXPLICIT_ANY: {
			category: "lint/ts/noExplicitAny",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Avoid using the <emphasis>any</emphasis> type.`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Using nonspecific types defeats the purpose of using TypeScript.`,
				},
			],
		},
	});


  // project-rome/@internal/diagnostics/descriptions/userConfig.ts
const ___R$project$rome$$internal$diagnostics$descriptions$userConfig_ts$userConfig = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		VSCODE_THEME_NOT_FOUND: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`VSCode theme not found`,
		},
	});


  // project-rome/@internal/diagnostics/descriptions/parsers/htmlParser.ts
const ___R$project$rome$$internal$diagnostics$descriptions$parsers$htmlParser_ts$htmlParser = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		UNCLOSED_STRING: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unclosed string`,
		},
		EXPECTED_CLOSING_TAG_NAME: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected closing tag name`,
		},
		UNKNOWN_START: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unknown child start`,
		},
		EXPECTED_ATTRIBUTE_NAME: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected attribute name`,
		},
		INCORRECT_CLOSING_TAG_NAME: (expected, got) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Expected to close ${expected} but found ${got}`,
		}),
		UNOPENED_TAG: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Ending tag with no opening tag`,
		},
		UNCLOSED_TAG: (tagName, openLocation) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Unclosed ${tagName} tag`,
			advice: [
				{
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Tag started here`,
				},
				{
					type: "frame",
					location: openLocation,
				},
			],
		}),
	});


  // project-rome/@internal/diagnostics/descriptions/commands/recoveryStore.ts
const ___R$project$rome$$internal$diagnostics$descriptions$commands$recoveryStore_ts$recoveryStore = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		NOT_FOUND: (storeId) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Could not find recovery store <emphasis>${storeId}</emphasis>`,
			category: "recoveryStore/notFound",
		}),
		DIFF: (original, artifact) => ({
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Differences between saved and current file`,
			category: "recoveryStore/diff",
			advice: [
				{
					type: "diff",
					language: "unknown",
					diff: ___R$project$rome$$internal$string$diff$index_ts$default(
						original,
						artifact,
					),
					legend: {
						add: "Saved file",
						delete: "Current file",
					},
				},
			],
		}),
	});


  // project-rome/@internal/diagnostics/descriptions/parsers/markdownParser.ts
const ___R$project$rome$$internal$diagnostics$descriptions$parsers$markdownParser_ts$markdownParser = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		INVALID_SEQUENCE: {
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Invalid sequence`,
		},
	});


  // project-rome/@internal/diagnostics/descriptions/commands/initCommand.ts
const ___R$$priv$project$rome$$internal$diagnostics$descriptions$commands$initCommand_ts$IGNORE_ADVICE = [
		{
			type: "log",
			category: "info",
			text: ___R$project$rome$$internal$markup$escape_ts$markup`If you still really want to do this, you can bypass the restriction and create a project in this directory with the flag <code>--allow-dirty</code>:`,
		},
		{
			type: "code",
			language: "shell",
			sourceText: "rome init --allow-dirty",
		},
	];

	// @internal/core/server/commands/init.ts
	const ___R$project$rome$$internal$diagnostics$descriptions$commands$initCommand_ts$initCommand = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory({
		UNCOMMITTED_CHANGES: {
			category: "commands/init/uncommittedChanges",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Uncommitted changes in repository`,
			advice: [
				{
					type: "log",
					category: "warn",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`This command is destructive and will format and autofix all files within. We recommend committing your changes so you can recover them if you don't like the changes.`,
				},
				{
					type: "code",
					language: "shell",
					sourceText: 'git add -A && git commit -m "Rome init backup"',
				},
				...___R$$priv$project$rome$$internal$diagnostics$descriptions$commands$initCommand_ts$IGNORE_ADVICE,
			],
		},
		EXPECTED_REPO: {
			category: "commands/init/expectedRepo",
			message: ___R$project$rome$$internal$markup$escape_ts$markup`Directory is not a repository. Are you sure this is where you wanted to create a project?`,
			advice: [
				{
					type: "log",
					category: "warn",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`This command is destructive and will format and autofix all files within.`,
				},

				...___R$$priv$project$rome$$internal$diagnostics$descriptions$commands$initCommand_ts$IGNORE_ADVICE,
			],
		},
	});


  // project-rome/@internal/diagnostics/descriptions/index.ts
const ___R$project$rome$$internal$diagnostics$descriptions$index_ts = {
		join: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$join,
		andJoin: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$andJoin,
		orJoin: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$orJoin,
		addEmphasis: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$addEmphasis,
		createDiagnosticsCategory: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory,
		get descriptions() {
			return ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions;
		},
	};
	function ___R$project$rome$$internal$diagnostics$descriptions$index_ts$join(
		conjunction,
		items,
	) {
		if (items.length === 0) {
			return ___R$project$rome$$internal$markup$escape_ts$markup``;
		} else if (items.length === 1) {
			return items[0];
		} else {
			const popped = items.pop();
			return ___R$project$rome$$internal$markup$escape_ts$concatMarkup(
				[
					...items,
					___R$project$rome$$internal$markup$escape_ts$markup`${conjunction} ${popped}`,
				],
				___R$project$rome$$internal$markup$escape_ts$markup`, `,
			);
		}
	}

	function ___R$project$rome$$internal$diagnostics$descriptions$index_ts$andJoin(
		items,
	) {
		return ___R$project$rome$$internal$diagnostics$descriptions$index_ts$join(
			"and",
			items,
		);
	}

	function ___R$project$rome$$internal$diagnostics$descriptions$index_ts$orJoin(
		items,
	) {
		return ___R$project$rome$$internal$diagnostics$descriptions$index_ts$join(
			"or",
			items,
		);
	}

	function ___R$project$rome$$internal$diagnostics$descriptions$index_ts$addEmphasis(
		items,
	) {
		return items.map((item) =>
			___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${item}</emphasis>`
		);
	}

	function ___R$project$rome$$internal$diagnostics$descriptions$index_ts$createDiagnosticsCategory(
		input,
	) {
		// rome-ignore lint/ts/noExplicitAny: future cleanup
		const category = {};

		for (const key in input) {
			const value = input[key];

			if (typeof value === "function") {
				// rome-ignore lint/ts/noExplicitAny: future cleanup
				const callback = (value);

				// @ts-ignore trust me lol
				category[key] = function(...params) {
					const ___R$ = callback.apply(null, [...params]);
					const ret = Object.assign({}, ___R$);
					delete ret.message;
					delete ret.advice;
					const {message, advice = []} = ___R$;
					return Object.assign({}, ret, {advice, message});
				};
			} else {
				const ___R$1 = (value);
				const obj = Object.assign({}, ___R$1);
				delete obj.message;
				delete obj.advice;
				const {message, advice = []} = ___R$1;
				category[key] = Object.assign({}, obj, {advice, message});
			}
		}

		return category;
	}

	const ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions = {
		COMMIT_PARSER: ___R$project$rome$$internal$diagnostics$descriptions$commitParser_ts$commitParser,
		FLAGS: ___R$project$rome$$internal$diagnostics$descriptions$flags_ts$flags,
		PARSER_CORE: ___R$project$rome$$internal$diagnostics$descriptions$parsers$parserCore_ts$parserCore,
		REGEX_PARSER: ___R$project$rome$$internal$diagnostics$descriptions$parsers$regexp_ts$regexp,
		JSON: ___R$project$rome$$internal$diagnostics$descriptions$json_ts$json,
		SEMVER: ___R$project$rome$$internal$diagnostics$descriptions$semver_ts$semver,
		V8: ___R$project$rome$$internal$diagnostics$descriptions$v8_ts$v8,
		LINT_COMMAND: ___R$project$rome$$internal$diagnostics$descriptions$commands$lintCommand_ts$lintCommand,
		LINT: ___R$project$rome$$internal$diagnostics$descriptions$lint_ts$lint,
		PROJECT_MANAGER: ___R$project$rome$$internal$diagnostics$descriptions$projectManager_ts$projectManager,
		COMPILER: ___R$project$rome$$internal$diagnostics$descriptions$compiler_ts$compiler,
		STRING_ESCAPE: ___R$project$rome$$internal$diagnostics$descriptions$stringEscape_ts$stringEscape,
		ANALYZE_DEPENDENCIES: ___R$project$rome$$internal$diagnostics$descriptions$analyzeDependencies_ts$analyzeDependencies,
		STRING_MARKUP: ___R$project$rome$$internal$diagnostics$descriptions$parsers$stringMarkup_ts$stringMarkup,
		PATH_MATCH: ___R$project$rome$$internal$diagnostics$descriptions$parsers$pathMatch_ts$pathMatch,
		TESTS: ___R$project$rome$$internal$diagnostics$descriptions$tests_ts$tests,
		SUPPRESSIONS: ___R$project$rome$$internal$diagnostics$descriptions$suppressions_ts$suppressions,
		SNAPSHOTS: ___R$project$rome$$internal$diagnostics$descriptions$snapshots_ts$snapshots,
		BUNDLER: ___R$project$rome$$internal$diagnostics$descriptions$bundler_ts$bundler,
		RESOLVER: ___R$project$rome$$internal$diagnostics$descriptions$resolver_ts$resolver,
		SPDX: ___R$project$rome$$internal$diagnostics$descriptions$parsers$spdx_ts$spdx,
		JS_PARSER: ___R$project$rome$$internal$diagnostics$descriptions$parsers$jsParser_ts$jsParser,
		CSS_PARSER: ___R$project$rome$$internal$diagnostics$descriptions$parsers$cssParser_ts$cssParser,
		TYPE_CHECK: ___R$project$rome$$internal$diagnostics$descriptions$typeCheck_ts$typeCheck,
		CONSUME: ___R$project$rome$$internal$diagnostics$descriptions$consume_ts$consume,
		MANIFEST: ___R$project$rome$$internal$diagnostics$descriptions$manifest_ts$manifest,
		PROJECT_CONFIG: ___R$project$rome$$internal$diagnostics$descriptions$projectConfig_ts$projectConfig,
		USER_CONFIG: ___R$project$rome$$internal$diagnostics$descriptions$userConfig_ts$userConfig,
		HTML_PARSER: ___R$project$rome$$internal$diagnostics$descriptions$parsers$htmlParser_ts$htmlParser,
		MARKDOWN_PARSER: ___R$project$rome$$internal$diagnostics$descriptions$parsers$markdownParser_ts$markdownParser,
		RECOVERY_STORE: ___R$project$rome$$internal$diagnostics$descriptions$commands$recoveryStore_ts$recoveryStore,
		INIT_COMMAND: ___R$project$rome$$internal$diagnostics$descriptions$commands$initCommand_ts$initCommand,
	};


  // project-rome/@internal/diagnostics/DiagnosticsProcessor.ts
const ___R$$priv$project$rome$$internal$diagnostics$DiagnosticsProcessor_ts$DEFAULT_UNIQUE = [
		["label", "category", "filename", "message", "start.line", "start.column"],
	];

	class ___R$project$rome$$internal$diagnostics$DiagnosticsProcessor_ts$default {
		constructor(options = {}) {
			this.filters = [];
			this.options = options;
			this.includedKeys = new Set();
			this.unique =
				options.unique === undefined
					? ___R$$priv$project$rome$$internal$diagnostics$DiagnosticsProcessor_ts$DEFAULT_UNIQUE
					: options.unique;
			this.throwAfter = undefined;
			this.origins = options.origins === undefined ? [] : [...options.origins];
			this.allowedUnusedSuppressionPrefixes = new Set();
			this.usedSuppressions = new Set();
			this.suppressions = new Set();
			this.sourceMaps =
				options.sourceMaps == null
					? new ___R$project$rome$$internal$codec$source$map$SourceMapConsumerCollection_ts$default()
					: options.sourceMaps;
			this.normalizer = new ___R$project$rome$$internal$diagnostics$DiagnosticsNormalizer_ts$default(
				options.normalizeOptions,
				options.markupOptions,
				this.sourceMaps,
			);

			this.diagnostics = new Set();
			this.cachedDiagnostics = undefined;
		}

		assertEmpty() {
			if (this.hasDiagnostics()) {
				throw new Error("Expected no diagnostics for this operation");
			}
		}

		static createImmediateThrower(origins) {
			const diagnostics = new ___R$project$rome$$internal$diagnostics$DiagnosticsProcessor_ts$default({
				origins,
				onDiagnostics() {
					diagnostics.maybeThrowDiagnosticsError();
				},
			});
			return diagnostics;
		}

		unshiftOrigin(origin) {
			this.origins.unshift(origin);
		}

		setThrowAfter(num) {
			this.throwAfter = num;
		}

		maybeThrowDiagnosticsError() {
			if (this.hasDiagnostics()) {
				throw new ___R$project$rome$$internal$diagnostics$errors_ts$DiagnosticsError(
					"Thrown by DiagnosticsProcessor",
					this.getDiagnostics(),
				);
			}
		}

		hasDiagnostics() {
			return this.getDiagnostics().length > 0;
		}

		addAllowedUnusedSuppressionPrefix(prefix) {
			this.assertEmpty();
			this.allowedUnusedSuppressionPrefixes.add(prefix);
		}

		addSuppressions(suppressions) {
			this.cachedDiagnostics = undefined;
			for (const suppression of suppressions) {
				this.suppressions.add(suppression);
			}
		}

		addFilters(filters) {
			this.cachedDiagnostics = undefined;
			this.filters = this.filters.concat(filters);
		}

		addFilter(filter) {
			this.cachedDiagnostics = undefined;
			this.filters.push(filter);
		}

		doesMatchFilter(diag) {
			for (const suppression of this.suppressions) {
				if (
					___R$project$rome$$internal$compiler$suppressions_ts$matchesSuppression(
						diag.description.category,
						diag.location,
						suppression,
					)
				) {
					this.usedSuppressions.add(suppression);
					return true;
				}
			}

			for (const filter of this.filters) {
				if (
					filter.message !== undefined &&
					___R$project$rome$$internal$markup$escape_ts$readMarkup(
						filter.message,
					) !==
					___R$project$rome$$internal$markup$escape_ts$readMarkup(
						diag.description.message,
					)
				) {
					continue;
				}

				if (
					filter.filename !== undefined &&
					filter.filename !== diag.location.filename
				) {
					continue;
				}

				if (
					filter.category !== undefined &&
					filter.category !== diag.description.category
				) {
					continue;
				}

				if (filter.start !== undefined && diag.location.start !== undefined) {
					if (
						filter.start.line !== diag.location.start.line ||
						filter.start.column !== diag.location.start.column
					) {
						continue;
					}
				}

				if (
					filter.line !== undefined &&
					diag.location.start !== undefined &&
					diag.location.start.line !== filter.line
				) {
					continue;
				}

				if (filter.test !== undefined && filter.test(diag)) {
					continue;
				}

				return true;
			}

			return false;
		}

		buildDedupeKeys(diag) {
			if (diag.tags && diag.tags.unique) {
				return [];
			}

			// We don't do anything with `end` in this method, it's fairly meaningless for deduping errors
			let {start} = diag.location;

			const keys = [];

			for (const rule of this.unique) {
				const parts = [];

				if (rule.includes("label")) {
					parts.push(
						"label:" +
						(diag.label === undefined
							? ""
							: ___R$project$rome$$internal$markup$escape_ts$readMarkup(
									diag.label,
								)),
					);
				}

				if (rule.includes("category")) {
					parts.push("category:" + diag.description.category);
				}

				if (rule.includes("filename")) {
					parts.push("filename:" + String(diag.location.filename));
				}

				if (rule.includes("message")) {
					parts.push(
						"message:" +
						___R$project$rome$$internal$markup$escape_ts$readMarkup(
							diag.description.message,
						),
					);
				}

				if (start !== undefined) {
					if (rule.includes("start.line")) {
						parts.push("start.line:" + start.line);
					}

					if (rule.includes("start.column")) {
						parts.push("start.column:" + start.column);
					}
				}

				const key = parts.join(",");
				keys.push(key);
			}

			return keys;
		}

		addDiagnosticAssert(diag, origin) {
			return this.addDiagnostics([diag], origin, true)[0];
		}

		addDiagnostic(diag, origin) {
			return this.addDiagnostics([diag], origin)[0];
		}

		deleteDiagnostic(diag) {
			this.diagnostics.delete(diag);
		}

		addDiagnostics(diags, origin, force) {
			if (diags.length === 0) {
				return diags;
			}

			this.cachedDiagnostics = undefined;

			const {max} = this.options;
			const added = [];

			// Add origins to diagnostics
			const origins = [...this.origins];
			if (origin !== undefined) {
				origins.push(origin);
			}
			diags = ___R$project$rome$$internal$diagnostics$derive_ts$addOriginsToDiagnostics(
				origins,
				diags,
			);

			// Filter diagnostics
			diagLoop: for (let diag of diags) {
				if (!force && max !== undefined && this.diagnostics.size > max) {
					break;
				}

				// Check before normalization
				if (!force && this.doesMatchFilter(diag)) {
					continue;
				}

				diag = this.normalizer.normalizeDiagnostic(diag);

				// Check after normalization
				if (!force && this.doesMatchFilter(diag)) {
					continue;
				}

				const keys = this.buildDedupeKeys(diag);

				if (!force) {
					for (const key of keys) {
						if (this.includedKeys.has(key)) {
							continue diagLoop;
						}
					}
				}

				this.diagnostics.add(diag);
				added.push(diag);

				for (const key of keys) {
					this.includedKeys.add(key);
				}
			}

			const {onDiagnostics} = this.options;
			if (onDiagnostics !== undefined && added.length > 0) {
				onDiagnostics(added);
			}

			const {throwAfter} = this;
			if (throwAfter !== undefined && this.diagnostics.size >= throwAfter) {
				this.maybeThrowDiagnosticsError();
			}

			return added;
		}

		getDiagnosticsByFilename() {
			const byFilename = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
				"diagnosticsByFilename",
				() => [],
			);

			for (const diag of this.getDiagnostics()) {
				const {filename} = diag.location;

				const filenameDiagnostics = byFilename.assert(filename);
				filenameDiagnostics.push(diag);
			}

			return byFilename;
		}

		getDiagnostics() {
			const {cachedDiagnostics} = this;
			if (cachedDiagnostics !== undefined) {
				return cachedDiagnostics;
			}

			const diagnostics = [...this.diagnostics];

			// Add errors for remaining suppressions
			for (const suppression of this.suppressions) {
				if (this.usedSuppressions.has(suppression)) {
					continue;
				}

				const [categoryPrefix] = suppression.category.split("/");
				if (this.allowedUnusedSuppressionPrefixes.has(categoryPrefix)) {
					continue;
				}

				diagnostics.push(
					this.normalizer.normalizeDiagnostic({
						location: suppression.commentLocation,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SUPPRESSIONS.UNUSED(
							suppression,
						),
					}),
				);
			}

			this.cachedDiagnostics = diagnostics;

			return diagnostics;
		}
	}


  // project-rome/@internal/diagnostics/wrap.ts
const ___R$project$rome$$internal$diagnostics$wrap_ts = {
		catchDiagnostics: ___R$project$rome$$internal$diagnostics$wrap_ts$catchDiagnostics,
		interceptDiagnostics: ___R$project$rome$$internal$diagnostics$wrap_ts$interceptDiagnostics,
		catchDiagnosticsSync: ___R$project$rome$$internal$diagnostics$wrap_ts$catchDiagnosticsSync,
	};
	async function ___R$project$rome$$internal$diagnostics$wrap_ts$catchDiagnostics(
		promise,
		origin,
	) {
		try {
			const value = await promise();

			return {value, diagnostics: undefined};
		} catch (err) {
			const diagnostics = ___R$project$rome$$internal$diagnostics$errors_ts$getDiagnosticsFromError(
				err,
			);

			if (diagnostics) {
				return {
					value: undefined,
					diagnostics: origin === undefined
						? diagnostics
						: ___R$project$rome$$internal$diagnostics$derive_ts$addOriginsToDiagnostics(
								[origin],
								diagnostics,
							),
				};
			} else {
				throw err;
			}
		}
	}

	async function ___R$project$rome$$internal$diagnostics$wrap_ts$interceptDiagnostics(
		promise,
		process,
		origin,
	) {
		const res = await ___R$project$rome$$internal$diagnostics$wrap_ts$catchDiagnostics(
			promise,
			origin,
		);

		if (res.diagnostics !== undefined) {
			const processor = new ___R$project$rome$$internal$diagnostics$DiagnosticsProcessor_ts$default();
			process(processor);
			processor.addDiagnostics(res.diagnostics);
			throw new ___R$project$rome$$internal$diagnostics$errors_ts$DiagnosticsError(
				"Intercepted diagnostics",
				processor.getDiagnostics(),
			);
		}

		return res.value;
	}

	function ___R$project$rome$$internal$diagnostics$wrap_ts$catchDiagnosticsSync(
		callback,
		origin,
	) {
		try {
			const value = callback();

			return {value, diagnostics: undefined};
		} catch (err) {
			const diagnostics = ___R$project$rome$$internal$diagnostics$errors_ts$getDiagnosticsFromError(
				err,
			);

			if (diagnostics) {
				return {
					value: undefined,
					diagnostics: origin === undefined
						? diagnostics
						: ___R$project$rome$$internal$diagnostics$derive_ts$addOriginsToDiagnostics(
								[origin],
								diagnostics,
							),
				};
			} else {
				throw err;
			}
		}
	}


  // project-rome/@internal/diagnostics/categories.ts
const ___R$project$rome$$internal$diagnostics$categories_ts = {};


  // project-rome/@internal/diagnostics/index.ts



  // project-rome/@internal/parser-core/utils.ts
const ___R$project$rome$$internal$parser$core$utils_ts = {
		isDigit: ___R$project$rome$$internal$parser$core$utils_ts$isDigit,
		isAlpha: ___R$project$rome$$internal$parser$core$utils_ts$isAlpha,
		isHexDigit: ___R$project$rome$$internal$parser$core$utils_ts$isHexDigit,
		isESIdentifierChar: ___R$project$rome$$internal$parser$core$utils_ts$isESIdentifierChar,
		isESIdentifierStart: ___R$project$rome$$internal$parser$core$utils_ts$isESIdentifierStart,
		readUntilLineBreak: ___R$project$rome$$internal$parser$core$utils_ts$readUntilLineBreak,
		createParser: ___R$project$rome$$internal$parser$core$utils_ts$createParser,
		tryParseWithOptionalOffsetPosition: ___R$project$rome$$internal$parser$core$utils_ts$tryParseWithOptionalOffsetPosition,
		comparePositions: ___R$project$rome$$internal$parser$core$utils_ts$comparePositions,
		derivePositionKey: ___R$project$rome$$internal$parser$core$utils_ts$derivePositionKey,
		extractSourceLocationRangeFromNodes: ___R$project$rome$$internal$parser$core$utils_ts$extractSourceLocationRangeFromNodes,
	};
	function ___R$project$rome$$internal$parser$core$utils_ts$isDigit(char) {
		return char !== undefined && /[0-9]/.test(char);
	}

	function ___R$project$rome$$internal$parser$core$utils_ts$isAlpha(char) {
		return char !== undefined && /[A-Za-z]/.test(char);
	}

	function ___R$project$rome$$internal$parser$core$utils_ts$isHexDigit(char) {
		return char !== undefined && /[0-9A-Fa-f]/.test(char);
	}

	function ___R$project$rome$$internal$parser$core$utils_ts$isESIdentifierChar(
		char,
	) {
		return char !== undefined && /[A-F0-9a-z_$]/.test(char);
	}

	function ___R$project$rome$$internal$parser$core$utils_ts$isESIdentifierStart(
		char,
	) {
		return char !== undefined && /[A-Fa-z_$]/.test(char);
	}

	function ___R$project$rome$$internal$parser$core$utils_ts$readUntilLineBreak(
		char,
	) {
		return char !== "\n";
	}

	function ___R$project$rome$$internal$parser$core$utils_ts$createParser(impl) {
		return (opts, meta) => {
			return new ___R$project$rome$$internal$parser$core$ParserCore_ts$default(
				impl,
				opts,
				meta,
			);
		};
	}

	function ___R$project$rome$$internal$parser$core$utils_ts$tryParseWithOptionalOffsetPosition(
		parserOpts,
		opts,
	) {
		const {value} = ___R$project$rome$$internal$diagnostics$wrap_ts$catchDiagnosticsSync(() => {
			return opts.parse(parserOpts);
		});

		if (value === undefined) {
			// Diagnostics must be present
			opts.parse(
				Object.assign(
					{},
					parserOpts,
					{offsetPosition: opts.getOffsetPosition()},
				),
			);
			throw new Error("Expected error");
		} else {
			return value;
		}
	}

	function ___R$project$rome$$internal$parser$core$utils_ts$comparePositions(
		left,
		right,
	) {
		if (left === undefined && right !== undefined) {
			return -1;
		}

		if (left !== undefined && right === undefined) {
			return 1;
		}

		if (left === undefined || right === undefined) {
			return 0;
		}

		if (left.line === right.line) {
			if (left.column < right.column) {
				return -1;
			}

			if (left.column > right.column) {
				return 1;
			}

			return 0;
		}

		if (left.line < right.line) {
			return -1;
		}

		if (left.line > right.line) {
			return 1;
		}

		throw new Error(
			"Not a possible condition...? All possible states of a.line and b.line should have been handled above",
		);
	}

	function ___R$project$rome$$internal$parser$core$utils_ts$derivePositionKey(
		pos,
	) {
		return String(pos.line) + ":" + String(pos.column);
	}

	function ___R$project$rome$$internal$parser$core$utils_ts$extractSourceLocationRangeFromNodes(
		nodes,
	) {
		if (nodes.length === 0) {
			return undefined;
		}

		let filename = undefined;
		let start = undefined;
		let end = undefined;

		for (const node of nodes) {
			const {loc} = node;
			if (loc === undefined) {
				continue;
			}

			if (
				start === undefined ||
				___R$project$rome$$internal$parser$core$utils_ts$comparePositions(
					loc.start,
					start,
				) === -1
			) {
				start = loc.start;
			}

			if (
				end === undefined ||
				___R$project$rome$$internal$parser$core$utils_ts$comparePositions(
					loc.end,
					end,
				) === 1
			) {
				end = loc.end;
			}

			if (filename === undefined) {
				filename = loc.filename;
			} else if (filename !== loc.filename) {
				throw new Error(
					"Mixed filenames in node, expected " +
					filename +
					" but got " +
					loc.filename,
				);
			}
		}

		if (start === undefined || end === undefined) {
			return undefined;
		}

		return {
			filename,
			start,
			end,
		};
	}


  // project-rome/@internal/parser-core/PositionTracker.ts
class ___R$project$rome$$internal$parser$core$PositionTracker_ts$default {
		constructor(
			{
				filename,
				input,
				offsetPosition = {
					line: ___R$project$rome$$internal$ob1$index_ts$ob1Number1,
					column: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
				},
				getPosition,
			},
		) {
			this.getPosition = getPosition;
			this.filename = filename;
			this.input = input;

			this.latestPosition = offsetPosition;

			this.positionsToIndex = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
				"positionsToIndex",
			);
			this.positionsToIndex.set(
				___R$project$rome$$internal$parser$core$utils_ts$derivePositionKey(
					offsetPosition,
				),
				___R$project$rome$$internal$ob1$index_ts$ob1Number0,
			);

			this.cachedPositions = new Map();
		}

		getIndexFromPosition(pos, filename) {
			if (filename !== this.filename) {
				throw new Error(
					___R$project$rome$$internal$pretty$format$index_ts$pretty`PositionTracker filename mismatch. DiagnosticLocation filename ${filename} is different than the filename we're tracking of ${this.filename}. Position: ${pos}`,
				);
			}

			const index = this.positionsToIndex.assert(
				___R$project$rome$$internal$parser$core$utils_ts$derivePositionKey(pos),
			);
			return index;
		}

		getPositionFromIndex(index) {
			const cached = this.cachedPositions.get(index);
			if (cached !== undefined) {
				return cached;
			}

			let line = ___R$project$rome$$internal$ob1$index_ts$ob1Number1;
			let column = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;
			let indexSearchStart = 0;

			// Reuse existing line information if possible
			const {latestPosition} = this;
			const latestPositionIndex = this.getIndexFromPosition(
				latestPosition,
				this.filename,
			);

			const currPosition =
				this.getPosition === undefined ? undefined : this.getPosition();
			const currPositionIndex =
				currPosition === undefined
					? undefined
					: this.getIndexFromPosition(latestPosition, this.filename);

			if (
				currPosition !== undefined &&
				currPositionIndex !== undefined &&
				currPositionIndex > latestPositionIndex &&
				currPositionIndex < index
			) {
				line = currPosition.line;
				column = currPosition.column;
				indexSearchStart = ___R$project$rome$$internal$ob1$index_ts$ob1Get0(
					currPositionIndex,
				);
			} else if (latestPositionIndex < index) {
				line = latestPosition.line;
				column = latestPosition.column;
				indexSearchStart = ___R$project$rome$$internal$ob1$index_ts$ob1Get0(
					latestPositionIndex,
				);
			}

			// Read the rest of the input until we hit the index
			for (
				let i = indexSearchStart;
				i < ___R$project$rome$$internal$ob1$index_ts$ob1Get0(index);
				i++
			) {
				const char = this.input[i];

				if (char === "\n") {
					line = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(line);
					column = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;
				} else {
					column = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(column);
				}
			}

			const pos = {
				line,
				column,
			};

			if (latestPosition === undefined || index > latestPositionIndex) {
				this.latestPosition = pos;
			}

			this.setPositionIndex(pos, index);
			return pos;
		}

		setPositionIndex(pos, index) {
			this.positionsToIndex.set(
				___R$project$rome$$internal$parser$core$utils_ts$derivePositionKey(pos),
				index,
			);
			this.cachedPositions.set(index, pos);
		}
	}


  // project-rome/@internal/parser-core/comments.ts
function ___R$$priv$project$rome$$internal$parser$core$comments_ts$last(stack) {
		return stack[stack.length - 1];
	}

	function ___R$$priv$project$rome$$internal$parser$core$comments_ts$getIds(
		comments,
	) {
		return comments.map((comment) => comment.id);
	}

	function ___R$$priv$project$rome$$internal$parser$core$comments_ts$hasComments(
		comments,
	) {
		return comments !== undefined && comments.length > 0;
	}

	function ___R$$priv$project$rome$$internal$parser$core$comments_ts$setComments(
		parser,
		node,
		key,
		comments,
	) {
		let innerEndIndex = -1;

		for (let i = 0; i < comments.length; i++) {
			const comment = comments[i];
			if (
				parser.getInputStartIndex(comment) >= parser.getInputStartIndex(node) &&
				parser.getInputEndIndex(comment) <= parser.getInputEndIndex(node)
			) {
				innerEndIndex++;
			} else {
				break;
			}
		}

		if (innerEndIndex === -1) {
			node[key] = ___R$$priv$project$rome$$internal$parser$core$comments_ts$getIds(
				comments,
			);
		} else {
			node.innerComments = ___R$$priv$project$rome$$internal$parser$core$comments_ts$getIds(
				comments.slice(0, innerEndIndex + 1),
			);
			node[key] = ___R$$priv$project$rome$$internal$parser$core$comments_ts$getIds(
				comments.slice(innerEndIndex + 1),
			);
		}
	}

	function ___R$$priv$project$rome$$internal$parser$core$comments_ts$adjustCommentsAfterTrailingComma(
		parser,
		node,
		elements,
		// When the current node is followed by a token which hasn't a respective AST node, we
		// need to take all the trailing comments to prevent them from being attached to an
		// unrelated node. e.g. in
		//     var { x } /* cmt */ = { y }
		// we don't want /* cmt */ to be attached to { y }.
		// On the other hand, in
		//     fn(x) [new line] /* cmt */ [new line] y
		// /* cmt */ is both a trailing comment of fn(x) and a leading comment of y
		takeAllComments,
	) {
		const {state} = parser;

		if (state.leadingComments.length === 0) {
			return;
		}

		let lastElement = undefined;
		let i = elements.length;
		while (lastElement === undefined && i > 0) {
			lastElement = elements[--i];
		}
		if (lastElement === undefined) {
			return;
		}

		const {commentPreviousNode} = state;
		if (commentPreviousNode === undefined) {
			throw new Error("No commentPreviousNode found");
		}

		for (let j = 0; j < state.leadingComments.length; j++) {
			if (
				parser.getInputEndIndex(parser.state.leadingComments[j]) <
				parser.getInputEndIndex(commentPreviousNode)
			) {
				parser.state.leadingComments.splice(j, 1);
				j--;
			}
		}

		const newTrailingComments = [];
		for (let i = 0; i < state.leadingComments.length; i++) {
			const leadingComment = state.leadingComments[i];
			if (
				parser.getInputEndIndex(leadingComment) <
				parser.getInputEndIndex(node)
			) {
				newTrailingComments.push(leadingComment);

				// Perf: we don't need to splice if we are going to reset the array anyway
				if (!takeAllComments) {
					state.leadingComments.splice(i, 1);
					i--;
				}
			} else {
				if (node.trailingComments === undefined) {
					node.trailingComments = [];
				}
				node.trailingComments.push(leadingComment.id);
			}
		}
		if (takeAllComments) {
			state.leadingComments = [];
		}

		if (newTrailingComments.length > 0) {
			lastElement.trailingComments = ___R$$priv$project$rome$$internal$parser$core$comments_ts$getIds(
				newTrailingComments,
			);
		} else if (lastElement.trailingComments !== undefined) {
			lastElement.trailingComments = [];
		}
	}

	function ___R$project$rome$$internal$parser$core$comments_ts$attachComments(
		parser,
		node,
	) {
		if (node.type === "JSRoot" && node.body.length > 0) {
			return;
		}

		const {state} = parser;
		const {commentStack, commentPreviousNode} = state;

		let trailingComments;

		if (state.trailingComments.length > 0) {
			// If the first comment in trailingComments comes after the
			// current node, then we're good - all comments in the array will
			// come after the node and so it's safe to add them as official
			// trailingComments.
			if (
				parser.getInputStartIndex(state.trailingComments[0]) >=
				parser.getInputEndIndex(node)
			) {
				trailingComments = state.trailingComments;
				state.trailingComments = [];
			} else {
				// Otherwise, if the first comment doesn't come after the
				// current node, that means we have a mix of leading and trailing
				// comments in the array and that leadingComments contains the
				// same items as trailingComments. Reset trailingComments to
				// zero items and we'll handle this by evaluating leadingComments
				// later.
				parser.state.trailingComments = [];
			}
		} else if (commentStack.length > 0) {
			const lastInStack = ___R$$priv$project$rome$$internal$parser$core$comments_ts$last(
				commentStack,
			);
			if (
				___R$$priv$project$rome$$internal$parser$core$comments_ts$hasComments(
					lastInStack.trailingComments,
				) &&
				parser.getInputStartIndex(
					parser.comments.assertGetCommentFromId(
						lastInStack.trailingComments[0],
					),
				) >= parser.getInputEndIndex(node)
			) {
				trailingComments = parser.comments.getCommentsFromIds(
					lastInStack.trailingComments,
				);
				lastInStack.trailingComments = undefined;
			}
		}

		// Eating the stack.
		let firstChild;
		if (
			commentStack.length > 0 &&
			parser.getInputStartIndex(
				___R$$priv$project$rome$$internal$parser$core$comments_ts$last(
					commentStack,
				),
			) >= parser.getInputStartIndex(node)
		) {
			firstChild = commentStack.pop();
		}

		let lastChild;
		while (
			commentStack.length > 0 &&
			parser.getInputStartIndex(
				___R$$priv$project$rome$$internal$parser$core$comments_ts$last(
					commentStack,
				),
			) >= parser.getInputStartIndex(node)
		) {
			lastChild = commentStack.pop();
		}

		if (!lastChild && firstChild) {
			lastChild = firstChild;
		}

		// Adjust comments that follow a trailing comma on the last element in a
		// comma separated list of nodes to be the trailing comments on the last
		// element
		if (firstChild) {
			switch (node.type) {
				case "JSObjectExpression": {
					___R$$priv$project$rome$$internal$parser$core$comments_ts$adjustCommentsAfterTrailingComma(
						parser,
						node,
						node.properties,
					);
					break;
				}

				case "JSBindingObjectPattern":
				case "JSAssignmentObjectPattern": {
					___R$$priv$project$rome$$internal$parser$core$comments_ts$adjustCommentsAfterTrailingComma(
						parser,
						node,
						node.properties,
						true,
					);
					break;
				}

				case "JSCallExpression": {
					___R$$priv$project$rome$$internal$parser$core$comments_ts$adjustCommentsAfterTrailingComma(
						parser,
						node,
						node.arguments,
					);
					break;
				}

				case "JSArrayExpression": {
					___R$$priv$project$rome$$internal$parser$core$comments_ts$adjustCommentsAfterTrailingComma(
						parser,
						node,
						node.elements,
					);
					break;
				}

				case "JSBindingArrayPattern":
				case "JSAssignmentArrayPattern": {
					___R$$priv$project$rome$$internal$parser$core$comments_ts$adjustCommentsAfterTrailingComma(
						parser,
						node,
						node.elements,
						true,
					);
					break;
				}
			}
		} else if (
			commentPreviousNode !== undefined &&
			((commentPreviousNode.type === "JSImportSpecifier" &&
			node.type !== "JSImportSpecifier") ||
			(commentPreviousNode.type === "JSExportLocalSpecifier" &&
			node.type !== "JSExportExternalSpecifier") ||
			(commentPreviousNode.type === "JSExportExternalSpecifier" &&
			node.type !== "JSExportExternalSpecifier"))
		) {
			___R$$priv$project$rome$$internal$parser$core$comments_ts$adjustCommentsAfterTrailingComma(
				parser,
				node,
				[parser.state.commentPreviousNode],
			);
		}

		if (lastChild !== undefined) {
			if (
				___R$$priv$project$rome$$internal$parser$core$comments_ts$hasComments(
					lastChild.leadingComments,
				)
			) {
				if (
					lastChild !== node &&
					parser.getInputEndIndex(
						parser.comments.assertGetCommentFromId(
							___R$$priv$project$rome$$internal$parser$core$comments_ts$last(
								lastChild.leadingComments,
							),
						),
					) <= parser.getInputStartIndex(node)
				) {
					___R$$priv$project$rome$$internal$parser$core$comments_ts$setComments(
						parser,
						node,
						"leadingComments",
						parser.comments.getCommentsFromIds(lastChild.leadingComments),
					);
					lastChild.leadingComments = undefined;
				} else {
					// A leading comment for an anonymous class had been stolen by its first JSClassMethod,
					// so this takes back the leading comment.
					// See also: https://github.com/eslint/espree/issues/158
					for (let i = lastChild.leadingComments.length - 2; i >= 0; --i) {
						if (
							parser.getInputEndIndex(
								parser.comments.assertGetCommentFromId(
									lastChild.leadingComments[i],
								),
							) <=
							parser.getInputStartIndex(node)
						) {
							___R$$priv$project$rome$$internal$parser$core$comments_ts$setComments(
								parser,
								node,
								"leadingComments",
								parser.comments.getCommentsFromIds(
									lastChild.leadingComments.splice(0, i + 1),
								),
							);
							break;
						}
					}
				}
			}
		} else if (parser.state.leadingComments.length > 0) {
			if (
				parser.getInputEndIndex(
					___R$$priv$project$rome$$internal$parser$core$comments_ts$last(
						parser.state.leadingComments,
					),
				) <=
				parser.getInputStartIndex(node)
			) {
				if (parser.state.commentPreviousNode) {
					for (let j = 0; j < parser.state.leadingComments.length; j++) {
						if (
							parser.getInputEndIndex(parser.state.leadingComments[j]) <
							parser.getInputEndIndex(parser.state.commentPreviousNode)
						) {
							parser.state.leadingComments.splice(j, 1);
							j--;
						}
					}
				}

				if (state.leadingComments.length > 0) {
					___R$$priv$project$rome$$internal$parser$core$comments_ts$setComments(
						parser,
						node,
						"leadingComments",
						parser.state.leadingComments,
					);
					state.leadingComments = [];
				}
			} else {
				// https://github.com/eslint/espree/issues/2
				//
				// In special cases, such as return (without a value) and
				// debugger, all comments will end up as leadingComments and
				// will otherwise be eliminated. This step runs when the
				// commentStack is empty and there are comments left
				// in leadingComments.
				//
				// This loop figures out the stopping point between the actual
				// leading and trailing comments by finding the location of the
				// first comment that comes after the given node.
				let i = 0;
				while (i < state.leadingComments.length) {
					if (
						parser.getInputEndIndex(state.leadingComments[i]) >
						parser.getInputStartIndex(node)
					) {
						break;
					} else {
						i++;
					}
				}

				// Split the array based on the location of the first comment
				// that comes after the node. Keep in mind that this could
				// result in an empty array, and if so, the array must be
				// deleted.

				const leadingComments = state.leadingComments.slice(0, i);

				if (leadingComments.length > 0) {
					___R$$priv$project$rome$$internal$parser$core$comments_ts$setComments(
						parser,
						node,
						"leadingComments",
						leadingComments,
					);
				}

				// Similarly, trailing comments are attached later. The variable
				// must be reset to null if there are no trailing comments.
				trailingComments = state.leadingComments.slice(i);
				if (trailingComments.length === 0) {
					trailingComments = undefined;
				}
			}
		}

		parser.state.commentPreviousNode = node;

		if (trailingComments) {
			___R$$priv$project$rome$$internal$parser$core$comments_ts$setComments(
				parser,
				node,
				"trailingComments",
				trailingComments,
			);
		}

		commentStack.push(node);
	}


  // project-rome/@internal/parser-core/ParserCore.ts
class ___R$project$rome$$internal$parser$core$ParserCore_ts$default {
		constructor(impl, opts, meta) {
			const {
				path,
				mtime,
				offsetPosition,
				sourceText,
			} = opts;

			let {input} = opts;
			if (input === undefined) {
				input = "";
			} else if (!impl.retainCarriageReturn) {
				input = ___R$project$rome$$internal$string$utils$removeCarriageReturn_ts$removeCarriageReturn(
					input,
				);
			}
			if (impl.normalizeInput !== undefined) {
				input = impl.normalizeInput(input);
			}

			this.options = opts;
			this.meta = meta;
			this.impl = impl;

			// Input information
			this.path =
				path === undefined
					? undefined
					: ___R$project$rome$$internal$path$index_ts$createUnknownPath(path);
			this.filename = this.path === undefined ? undefined : this.path.join();
			this.mtime = mtime;
			this.input = input;
			this.sourceText = sourceText == null ? this.input : sourceText;
			this.length = ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(
				this.input.length,
			);

			this.eofToken = {
				type: "EOF",
				start: ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(
					this.input.length,
				),
				end: ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(
					this.input.length,
				),
			};

			// Parser/tokenizer state
			this.tokenizing = false;
			this.currLine =
				offsetPosition === undefined
					? ___R$project$rome$$internal$ob1$index_ts$ob1Number1
					: offsetPosition.line;
			this.currColumn =
				offsetPosition === undefined
					? ___R$project$rome$$internal$ob1$index_ts$ob1Number0
					: offsetPosition.column;
			this.nextTokenIndex = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;
			this.currentToken = ___R$$priv$project$rome$$internal$parser$core$ParserCore_ts$SOF_TOKEN;
			this.prevToken = ___R$$priv$project$rome$$internal$parser$core$ParserCore_ts$SOF_TOKEN;
			this.comments = new ___R$project$rome$$internal$js$parser$CommentsConsumer_ts$default();

			this.indexTracker = new ___R$project$rome$$internal$parser$core$PositionTracker_ts$default({
				filename: this.filename,
				input: this.input,
				offsetPosition,
				getPosition: this.getPosition.bind(this),
			});

			let initialState;
			if (initialState === undefined && impl.getInitialState !== undefined) {
				initialState = impl.getInitialState(this);
			}

			// @ts-ignore
			this.state = Object.assign(
				{},
				initialState,
				___R$project$rome$$internal$parser$core$ParserCore_ts$default.createInitialState(),
			);
		}

		static createInitialState() {
			return {
				corrupt: false,
				trailingComments: [],
				leadingComments: [],
				commentStack: [],
				comments: [],
				commentPreviousNode: undefined,
				diagnostics: [],
				diagnosticFilters: [],
			};
		}

		getPathAssert() {
			const {path} = this;
			if (path === undefined) {
				throw new Error("Path expected but none was passed to this Parser");
			} else {
				return path;
			}
		}

		getFilenameAssert() {
			const {filename} = this;
			if (filename === undefined) {
				throw new Error("Filename expected but none was passed to this Parser");
			} else {
				return filename;
			}
		}

		// Run the tokenizer over all tokens
		tokenizeAll() {
			const tokens = [];

			const {diagnostics} = ___R$project$rome$$internal$diagnostics$wrap_ts$catchDiagnosticsSync(() => {
				while (true) {
					tokens.push(this.getToken());
					if (this.matchToken("EOF")) {
						break;
					}

					this.nextToken();
				}
			});

			if (diagnostics !== undefined) {
				tokens.push({
					type: "Invalid",
					start: this.nextTokenIndex,
					end: this.length,
				});
			}

			return tokens;
		}

		// Tokenize method that must be implemented by subclasses
		tokenize(index) {
			const {tokenize} = this.impl;
			if (tokenize === undefined) {
				throw new Error("No tokenize implementation defined");
			} else {
				return tokenize(this, index);
			}
		}

		// Alternate tokenize method to allow that allows the use of state
		tokenizeWithState(index, state) {
			const {tokenizeWithState} = this.impl;
			if (tokenizeWithState !== undefined) {
				return tokenizeWithState(this, index, state);
			}

			const token = this.tokenize(index);
			if (token !== undefined) {
				return {token, state};
			}

			return undefined;
		}

		_tokenizeWithState(index, state) {
			if (this.impl.ignoreWhitespaceTokens) {
				switch (this.getInputCharOnly(index)) {
					case " ":
					case "\t":
					case "\r":
					case "\n":
						return this.lookahead(
							___R$project$rome$$internal$ob1$index_ts$ob1Inc(index),
						);
				}
			}

			return this.tokenizeWithState(index, state);
		}

		// Get the current token
		getToken() {
			const {currentToken} = this;
			if (
				currentToken ===
				___R$$priv$project$rome$$internal$parser$core$ParserCore_ts$SOF_TOKEN
			) {
				return this.nextToken();
			} else {
				return currentToken;
			}
		}

		save() {
			return {
				nextTokenIndex: this.nextTokenIndex,
				currentToken: this.currentToken,
				prevToken: this.prevToken,
				state: this.state,
			};
		}

		restore(snapshot) {
			this.nextTokenIndex = snapshot.nextTokenIndex;
			this.currentToken = snapshot.currentToken;
			this.prevToken = snapshot.prevToken;
			this.state = snapshot.state;
		}

		// Advance to the next token, returning the new one
		nextToken() {
			if (this.isEOF(this.nextTokenIndex)) {
				this.currentToken = this.eofToken;
				return this.eofToken;
			}

			if (this.tokenizing) {
				throw new Error("Can't call nextToken while tokenizing");
			}

			const prevToken = this.currentToken;
			const {token: nextToken, state} = this.lookahead();

			if (nextToken.end === prevToken.end) {
				throw new Error(
					"tokenize() returned a token with the same position as the last - Previous token: " +
					JSON.stringify(prevToken) +
					"; Next token: " +
					JSON.stringify(nextToken) +
					"; Input: " +
					this.input.slice(0, 100),
				);
			}

			const {line, column} = this.getPositionFromIndex(nextToken.start);
			this.currLine = line;
			this.currColumn = column;

			this.nextTokenIndex = nextToken.end;
			this.prevToken = prevToken;
			this.currentToken = nextToken;
			this.state = state;
			return nextToken;
		}

		// Get the start index of the current token
		getIndex() {
			const {overrides} = this.impl;
			if (overrides !== undefined) {
				return overrides.getIndex(this);
			}

			return this.currentToken.start;
		}

		// Get the position of the current token
		getPosition() {
			const {overrides} = this.impl;
			if (overrides !== undefined) {
				return overrides.getPosition(this);
			}

			const index = this.getIndex();
			const cached = this.indexTracker.cachedPositions.get(index);
			if (cached !== undefined) {
				return cached;
			}

			const pos = {
				line: this.currLine,
				column: this.currColumn,
			};
			this.indexTracker.setPositionIndex(pos, index);
			return pos;
		}

		// Get the end position of the previous token
		getLastEndPosition() {
			const {overrides} = this.impl;
			if (overrides !== undefined) {
				return overrides.getLastEndPosition(this);
			}

			return this.getPositionFromIndex(this.prevToken.end);
		}

		// Return the token that's after this current token without advancing to it
		lookaheadToken(index) {
			return this.lookahead(index).token;
		}

		// Return the token and state that's after the current token without advancing to it
		lookahead(index = this.nextTokenIndex) {
			if (this.isEOF(index)) {
				return {token: this.eofToken, state: this.state};
			}

			// Set the next token index, in the case of a lookahead we'll set it back later
			const prevNextTokenIndex = this.nextTokenIndex;
			this.nextTokenIndex = index;

			// Indicate that we're currently tokenizing to catch some weird recursive tokenizing errors
			const wasTokenizing = this.tokenizing;
			this.tokenizing = true;

			// Tokenize and do some validation
			const beforeState = this.state;
			const next = this._tokenizeWithState(index, beforeState);
			if (next === undefined) {
				throw this.unexpected({
					start: this.getPositionFromIndex(index),
				});
			}

			// Reset to old values
			this.tokenizing = wasTokenizing;
			this.nextTokenIndex = prevNextTokenIndex;

			return {
				token: next.token,
				state: Object.assign({}, beforeState, next.state),
			};
		}

		getPositionFromIndex(index) {
			return this.indexTracker.getPositionFromIndex(index);
		}

		getIndexFromPosition(pos, filename) {
			return this.indexTracker.getIndexFromPosition(pos, filename);
		}

		createDiagnostic(opts = {}) {
			const {currentToken} = this;
			let {description} = opts;
			const location = this.getDiagnosticLocation(opts);
			const start = this.getIndexFromPosition(location.start, location.filename);

			// Normalize message, we need to be defensive here because it could have been called while tokenizing the first token
			if (description === undefined) {
				if (currentToken !== undefined && start === currentToken.start) {
					description = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.PARSER_CORE.UNEXPECTED(
						currentToken.type,
					);
				} else {
					if (this.isEOF(start)) {
						description = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.PARSER_CORE.UNEXPECTED_EOF;
					} else {
						const char = this.input[___R$project$rome$$internal$ob1$index_ts$ob1Get0(
							start,
						)];
						description = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.PARSER_CORE.UNEXPECTED_CHARACTER(
							char,
						);
					}
				}
			}

			const descriptionWithCategory = Object.assign(
				{},
				description,
				{
					advice: description.advice == null ? [] : description.advice,
					category: description.category == null
						? this.impl.diagnosticCategory
						: description.category,
				},
			);

			return {
				description: descriptionWithCategory,
				location,
			};
		}

		// Return an error to indicate a parser error, this must be thrown at the callsite for refinement
		unexpected(opts = {}) {
			return ___R$project$rome$$internal$diagnostics$errors_ts$createSingleDiagnosticError(
				this.createDiagnostic(opts),
			);
		}

		unexpectedDiagnostic(opts = {}) {
			this.addDiagnostic(this.createDiagnostic(opts));
		}

		getDiagnosticLocation(opts = {}) {
			let {start, end, token} = opts;

			if (opts.index !== undefined) {
				start = this.getPositionFromIndex(opts.index);
				end = start;
			}

			if (opts.startIndex !== undefined) {
				start = this.getPositionFromIndex(opts.startIndex);
			}

			if (opts.endIndex !== undefined) {
				end = this.getPositionFromIndex(opts.endIndex);
			}

			if (opts.location !== undefined) {
				start = opts.location.start;
				end = opts.location.end;
			}

			if (token !== undefined) {
				start = this.getPositionFromIndex(token.start);
				end = this.getPositionFromIndex(token.end);
			}

			if (start === undefined && end === undefined && opts.loc !== undefined) {
				start = opts.loc.start;
				end = opts.loc.end;
			}

			// If we weren't given a start then default to the provided end, or the current token start
			if (start === undefined && end === undefined) {
				start = this.getPosition();
				end = this.getLastEndPosition();
			}

			if (start === undefined && end !== undefined) {
				start = end;
			}

			if (start !== undefined && end === undefined) {
				end = start;
			}

			if (start === undefined || end === undefined) {
				throw new Error("This condition should have been refined");
			}

			let sourceText;
			if (this.path === undefined) {
				sourceText = this.sourceText;
			}

			return {
				sourceText,
				mtime: this.mtime,
				start,
				end,
				filename: this.filename,
			};
		}

		//# Token utility methods
		assertNoSpace() {
			if (this.currentToken.start !== this.prevToken.end) {
				throw this.unexpected({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.PARSER_CORE.EXPECTED_SPACE,
				});
			}
		}

		// If the current token is the specified type then return the next token, otherwise return null
		eatToken(type) {
			if (this.matchToken(type)) {
				return this.nextToken();
			} else {
				return undefined;
			}
		}

		// Check if we're at the end of the input
		isEOF(index) {
			return (
				___R$project$rome$$internal$ob1$index_ts$ob1Get0(index) >=
				this.input.length
			);
		}

		// Check if the current token matches the input type
		matchToken(type) {
			return this.getToken().type === type;
		}

		// Get the current token and assert that it's of the specified type, the token stream will also be advanced
		expectToken(type, _metadata) {
			const token = this.getToken();
			if (token.type === type) {
				this.nextToken();
				// @ts-ignore
				return token;
			} else {
				throw this.unexpected({
					description: _metadata === undefined
						? ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.PARSER_CORE.EXPECTED_TOKEN(
								token.type,
								(type),
							)
						: _metadata,
				});
			}
		}

		getInputRange(start, count, startOffset) {
			// Allow passing in an `offset` to avoid callsites having to do `ob1Add` themselves
			const startIndex = ___R$project$rome$$internal$ob1$index_ts$ob1Get0(
				startOffset === undefined
					? start
					: ___R$project$rome$$internal$ob1$index_ts$ob1Add(start, startOffset),
			);
			const endIndex = Math.min(startIndex + count, this.input.length - 1);
			return [
				this.input.slice(startIndex, endIndex),
				___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(endIndex + 1),
			];
		}

		getInputCharOnly(index, offset) {
			return this.getInputChar(index, offset)[0];
		}

		getInputChar(index, offset) {
			const {input} = this;

			// Allow passing in an `offset` to avoid callsites having to do `ob1Add` themselves
			const i = ___R$project$rome$$internal$ob1$index_ts$ob1Get0(
				offset === undefined
					? index
					: ___R$project$rome$$internal$ob1$index_ts$ob1Add(index, offset),
			);

			const end = ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(i + 1);

			// Allow an overflow since we call this method to check for trailing characters
			if (i >= input.length || i < 0) {
				return ["", end];
			}

			return [input[i], end];
		}

		// Read from the input starting at the specified index, until the callback returns false
		readInputFrom(index, callback) {
			const {input} = this;
			let value = "";

			while (true) {
				if (
					___R$project$rome$$internal$ob1$index_ts$ob1Get0(index) >=
					input.length
				) {
					return [value, index, true];
				}

				if (
					callback === undefined ||
					callback(
						input[___R$project$rome$$internal$ob1$index_ts$ob1Get0(index)],
						index,
						input,
					)
				) {
					value += input[___R$project$rome$$internal$ob1$index_ts$ob1Get0(index)];
					index = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(index);
				} else {
					break;
				}
			}

			return [value, index, false];
		}

		// Get the string between the specified range
		getRawInput(start, end) {
			return this.input.slice(
				___R$project$rome$$internal$ob1$index_ts$ob1Get0(start),
				___R$project$rome$$internal$ob1$index_ts$ob1Get0(end),
			);
		}

		getInputStartIndex(node) {
			const loc = this.getLoc(node);
			return this.getIndexFromPosition(loc.start, loc.filename);
		}

		getInputEndIndex(node) {
			const loc = this.getLoc(node);
			return this.getIndexFromPosition(loc.end, loc.filename);
		}

		getLoc(node) {
			if (node === undefined || node.loc === undefined) {
				throw new Error("Tried to fetch node loc start but none found");
			} else {
				return node.loc;
			}
		}

		//# Token finalization

		finishToken(
			type,
			end = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(this.nextTokenIndex),
		) {
			return {
				type,
				start: this.nextTokenIndex,
				end,
			};
		}

		finishValueToken(
			type,
			value,
			end = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(this.nextTokenIndex),
		) {
			return {
				type,
				value,
				start: this.nextTokenIndex,
				end,
			};
		}

		finishComplexToken(
			type,
			data,
			end = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(this.nextTokenIndex),
		) {
			return Object.assign({type}, data, {start: this.nextTokenIndex, end});
		}

		//# SourceLocation finalization

		finishLocFromToken(token) {
			return this.finishLocAt(
				this.getPositionFromIndex(token.start),
				this.getPositionFromIndex(token.end),
			);
		}

		finishLoc(start) {
			return this.finishLocAt(start, this.getLastEndPosition());
		}

		finishLocAt(start, end) {
			return {
				filename: this.filename,
				start,
				end,
			};
		}

		//# Node finalization

		finalizeNode(node) {
			// @ts-ignore
			___R$project$rome$$internal$parser$core$comments_ts$attachComments(
				this,
				node,
			);
			return node;
		}

		// Sometimes we want to pretend we're in different locations to consume the comments of other nodes
		finishNodeWithStarts(starts, node) {
			for (const start of starts) {
				node = this.finishNode(start, node);
			}
			return node;
		}

		finishNode(start, node) {
			return this.finishNodeAt(start, this.getLastEndPosition(), node);
		}

		finishNodeAt(start, end, node) {
			// Maybe mutating `node` is better...?
			const newNode = Object.assign(
				{},
				node,
				{loc: this.finishLocAt(start, end)},
			);
			return this.finalizeNode(newNode);
		}

		finishRoot(node) {
			return Object.assign(
				{},
				node,
				{
					corrupt: this.state.corrupt,
					mtime: this.mtime,
					diagnostics: this.getDiagnostics(),
					filename: this.getFilenameAssert(),
					comments: this.state.comments,
				},
			);
		}

		finalize() {
			if (!this.eatToken("EOF")) {
				throw this.unexpected({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.PARSER_CORE.EXPECTED_EOF,
				});
			}
		}

		//# Diagnostics

		getDiagnostics() {
			const collector = new ___R$project$rome$$internal$diagnostics$DiagnosticsProcessor_ts$default({
				origins: [
					{
						category: this.impl.diagnosticCategory,
					},
				],
				//unique: ['start.line'],
			});

			for (const filter of this.state.diagnosticFilters) {
				collector.addFilter(filter);
			}

			// TODO remove any trailing "eof" diagnostic
			return collector.addDiagnostics(this.state.diagnostics).slice(0, 1);
		}

		addDiagnostic(diag) {
			this.state.diagnostics.push(diag);
		}

		addDiagnosticFilter(diag) {
			this.state.diagnosticFilters.push(diag);
		}

		addCompleteDiagnostic(diags) {
			this.state.diagnostics = [...this.state.diagnostics, ...diags];
		}

		//# Comments

		registerComment(comment) {
			this.state.comments.push(comment);
			this.state.trailingComments.push(comment);
			this.state.leadingComments.push(comment);
		}
	}

	const ___R$$priv$project$rome$$internal$parser$core$ParserCore_ts$SOF_TOKEN = {
		type: "SOF",
		start: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
		end: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
	};



  // project-rome/@internal/parser-core/types.ts
const ___R$project$rome$$internal$parser$core$types_ts = {
		get UNKNOWN_POSITION() {
			return ___R$project$rome$$internal$parser$core$types_ts$UNKNOWN_POSITION;
		},
	};
	const ___R$project$rome$$internal$parser$core$types_ts$UNKNOWN_POSITION = {
		line: ___R$project$rome$$internal$ob1$index_ts$ob1Coerce1(-1),
		column: ___R$project$rome$$internal$ob1$index_ts$ob1Number0Neg1,
	};



  // project-rome/@internal/parser-core/index.ts



  // project-rome/@internal/markup/util.ts
const ___R$project$rome$$internal$markup$util_ts = {
		createEmptyAttributes: ___R$project$rome$$internal$markup$util_ts$createEmptyAttributes,
		isSingleEscaped: ___R$project$rome$$internal$markup$util_ts$isSingleEscaped,
		humanizeMarkupFilename: ___R$project$rome$$internal$markup$util_ts$humanizeMarkupFilename,
		buildFileLink: ___R$project$rome$$internal$markup$util_ts$buildFileLink,
		formatApprox: ___R$project$rome$$internal$markup$util_ts$formatApprox,
		formatGrammarNumber: ___R$project$rome$$internal$markup$util_ts$formatGrammarNumber,
		formatNumber: ___R$project$rome$$internal$markup$util_ts$formatNumber,
	};
	function ___R$project$rome$$internal$markup$util_ts$createEmptyAttributes() {
		return ___R$project$rome$$internal$consume$index_ts$consumeUnknown(
			{},
			"parse/stringMarkup",
		);
	}

	function ___R$project$rome$$internal$markup$util_ts$isSingleEscaped(markup) {
		return (
			markup.type === "MARKUP" &&
			markup.parts.length === 1 &&
			typeof markup.parts[0] === "string"
		);
	}

	function ___R$project$rome$$internal$markup$util_ts$humanizeMarkupFilename(
		filename,
		opts = {},
	) {
		if (opts.humanizeFilename !== undefined) {
			const override = opts.humanizeFilename(filename);
			if (override !== undefined) {
				return override;
			}
		}

		return ___R$project$rome$$internal$path$index_ts$createUnknownPath(filename).format(
			opts.cwd,
		);
	}

	function ___R$project$rome$$internal$markup$util_ts$buildFileLink(
		attributes,
		opts,
	) {
		let filename = attributes.get("target").asString("");
		let line = attributes.get("line").asNumberOrVoid();
		let column = attributes.get("column").asNumberOrVoid();

		if (opts.normalizePosition !== undefined) {
			const pos = opts.normalizePosition(
				filename,
				line === undefined
					? undefined
					: ___R$project$rome$$internal$ob1$index_ts$ob1Coerce1(line),
				column === undefined
					? undefined
					: ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(column),
			);
			if (pos !== undefined) {
				filename = pos.filename;
				if (pos.line !== undefined) {
					line = ___R$project$rome$$internal$ob1$index_ts$ob1Get1(pos.line);
				}
				if (pos.column !== undefined) {
					column = ___R$project$rome$$internal$ob1$index_ts$ob1Get0(pos.column);
				}
			}
		}

		let text = ___R$project$rome$$internal$markup$util_ts$humanizeMarkupFilename(
			filename,
			opts,
		);

		if (line !== undefined) {
			text += ":" + line;

			// Ignore a 0 column and just target the line
			if (column !== undefined && column !== 0) {
				text += ":" + column;
			}
		}

		return {
			filename,
			text,
			line: line === undefined ? undefined : String(line),
			column: column === undefined ? undefined : String(column),
		};
	}

	function ___R$project$rome$$internal$markup$util_ts$formatApprox(
		attributes,
		value,
	) {
		if (attributes.get("approx").asUnknown() === true) {
			return "~" + value;
		} else {
			return value;
		}
	}

	function ___R$project$rome$$internal$markup$util_ts$formatGrammarNumber(
		attributes,
		value,
	) {
		const num = Number(value);

		const none = attributes.get("none").asStringOrVoid();
		if (none !== undefined && num === 0) {
			return none;
		}

		const singular = attributes.get("singular").asStringOrVoid();
		if (singular !== undefined && num === 1) {
			return singular;
		}

		const plural = attributes.get("plural").asStringOrVoid();
		if (plural !== undefined) {
			return plural;
		}

		return "";
	}

	function ___R$project$rome$$internal$markup$util_ts$formatNumber(
		attributes,
		value,
	) {
		const num = Number(value);
		const human = ___R$project$rome$$internal$string$utils$humanizeNumber_ts$humanizeNumber(
			num,
		);
		return ___R$project$rome$$internal$markup$util_ts$formatApprox(
			attributes,
			human,
		);
	}


  // project-rome/@internal/markup/tags.ts
const ___R$project$rome$$internal$markup$tags_ts = {
		get globalAttributes() {
			return ___R$project$rome$$internal$markup$tags_ts$globalAttributes;
		},
		get tags() {
			return ___R$project$rome$$internal$markup$tags_ts$tags;
		},
		get tagsToOnlyChildren() {
			return ___R$project$rome$$internal$markup$tags_ts$tagsToOnlyChildren;
		},
		get tagsToOnlyParent() {
			return ___R$project$rome$$internal$markup$tags_ts$tagsToOnlyParent;
		},
		lineWrapValidator: ___R$project$rome$$internal$markup$tags_ts$lineWrapValidator,
		validateTokenType: ___R$project$rome$$internal$markup$tags_ts$validateTokenType,
		validateColor: ___R$project$rome$$internal$markup$tags_ts$validateColor,
	};
	const ___R$$priv$project$rome$$internal$markup$tags_ts$stringValidator = (
		value,
	) => value;

	const ___R$$priv$project$rome$$internal$markup$tags_ts$booleanValidator = (
		value,
		key,
	) => {
		if (value === "false") {
			return false;
		}

		if (value === "true" || value === key) {
			return true;
		}

		return undefined;
	};
	const ___R$$priv$project$rome$$internal$markup$tags_ts$numberValidator = (
		value,
	) => {
		const num = parseFloat(value);
		if (isNaN(num)) {
			return undefined;
		} else {
			return num;
		}
	};

	const ___R$project$rome$$internal$markup$tags_ts$globalAttributes = new Map([
		[
			"emphasis",
			___R$$priv$project$rome$$internal$markup$tags_ts$booleanValidator,
		],
		["dim", ___R$$priv$project$rome$$internal$markup$tags_ts$booleanValidator],
	]);

	const ___R$project$rome$$internal$markup$tags_ts$tags = new Map();

	___R$project$rome$$internal$markup$tags_ts$tags.set("emphasis", new Map());
	___R$project$rome$$internal$markup$tags_ts$tags.set(
		"number",
		new Map([
			[
				"approx",
				___R$$priv$project$rome$$internal$markup$tags_ts$booleanValidator,
			],
			[
				"pluralSuffix",
				___R$$priv$project$rome$$internal$markup$tags_ts$stringValidator,
			],
			[
				"singularSuffix",
				___R$$priv$project$rome$$internal$markup$tags_ts$stringValidator,
			],
		]),
	);
	___R$project$rome$$internal$markup$tags_ts$tags.set("indent", new Map());
	___R$project$rome$$internal$markup$tags_ts$tags.set(
		"view",
		new Map([
			[
				"extraSoftWrapIndent",
				___R$$priv$project$rome$$internal$markup$tags_ts$numberValidator,
			],
			["lineWrap", ___R$project$rome$$internal$markup$tags_ts$lineWrapValidator],
			["align", ___R$$priv$project$rome$$internal$markup$tags_ts$alignValidator],
		]),
	);
	___R$project$rome$$internal$markup$tags_ts$tags.set(
		"viewLinePrefix",
		new Map([
			["type", ___R$$priv$project$rome$$internal$markup$tags_ts$stringValidator],
			["align", ___R$$priv$project$rome$$internal$markup$tags_ts$alignValidator],
		]),
	);
	___R$project$rome$$internal$markup$tags_ts$tags.set(
		"viewPointer",
		new Map([
			["char", ___R$$priv$project$rome$$internal$markup$tags_ts$stringValidator],
			["line", ___R$$priv$project$rome$$internal$markup$tags_ts$numberValidator],
			[
				"start",
				___R$$priv$project$rome$$internal$markup$tags_ts$numberValidator,
			],
			["end", ___R$$priv$project$rome$$internal$markup$tags_ts$numberValidator],
		]),
	);
	___R$project$rome$$internal$markup$tags_ts$tags.set(
		"grammarNumber",
		new Map([
			[
				"plural",
				___R$$priv$project$rome$$internal$markup$tags_ts$stringValidator,
			],
			[
				"singular",
				___R$$priv$project$rome$$internal$markup$tags_ts$stringValidator,
			],
			["none", ___R$$priv$project$rome$$internal$markup$tags_ts$stringValidator],
		]),
	);
	___R$project$rome$$internal$markup$tags_ts$tags.set(
		"hyperlink",
		new Map([
			[
				"target",
				___R$$priv$project$rome$$internal$markup$tags_ts$stringValidator,
			],
		]),
	);
	___R$project$rome$$internal$markup$tags_ts$tags.set(
		"filelink",
		new Map([
			[
				"target",
				___R$$priv$project$rome$$internal$markup$tags_ts$stringValidator,
			],
			[
				"column",
				___R$$priv$project$rome$$internal$markup$tags_ts$numberValidator,
			],
			["line", ___R$$priv$project$rome$$internal$markup$tags_ts$numberValidator],
		]),
	);
	___R$project$rome$$internal$markup$tags_ts$tags.set("inverse", new Map());
	___R$project$rome$$internal$markup$tags_ts$tags.set("dim", new Map());
	___R$project$rome$$internal$markup$tags_ts$tags.set("filesize", new Map());
	___R$project$rome$$internal$markup$tags_ts$tags.set(
		"duration",
		new Map([
			[
				"approx",
				___R$$priv$project$rome$$internal$markup$tags_ts$booleanValidator,
			],
		]),
	);
	___R$project$rome$$internal$markup$tags_ts$tags.set("italic", new Map());
	___R$project$rome$$internal$markup$tags_ts$tags.set("underline", new Map());
	___R$project$rome$$internal$markup$tags_ts$tags.set("strike", new Map());
	___R$project$rome$$internal$markup$tags_ts$tags.set(
		"token",
		new Map([
			["type", ___R$project$rome$$internal$markup$tags_ts$validateTokenType],
		]),
	);
	___R$project$rome$$internal$markup$tags_ts$tags.set("error", new Map());
	___R$project$rome$$internal$markup$tags_ts$tags.set("success", new Map());
	___R$project$rome$$internal$markup$tags_ts$tags.set("warn", new Map());
	___R$project$rome$$internal$markup$tags_ts$tags.set("info", new Map());
	___R$project$rome$$internal$markup$tags_ts$tags.set("code", new Map());
	___R$project$rome$$internal$markup$tags_ts$tags.set(
		"color",
		new Map([
			["fg", ___R$project$rome$$internal$markup$tags_ts$validateColor],
			["bg", ___R$project$rome$$internal$markup$tags_ts$validateColor],
		]),
	);
	___R$project$rome$$internal$markup$tags_ts$tags.set(
		"highlight",
		new Map([
			["i", ___R$$priv$project$rome$$internal$markup$tags_ts$numberValidator],
			[
				"legend",
				___R$$priv$project$rome$$internal$markup$tags_ts$booleanValidator,
			],
		]),
	);
	___R$project$rome$$internal$markup$tags_ts$tags.set("table", new Map());
	___R$project$rome$$internal$markup$tags_ts$tags.set("tr", new Map());
	___R$project$rome$$internal$markup$tags_ts$tags.set(
		"td",
		new Map([
			["align", ___R$$priv$project$rome$$internal$markup$tags_ts$alignValidator],
		]),
	);
	___R$project$rome$$internal$markup$tags_ts$tags.set("hr", new Map());
	___R$project$rome$$internal$markup$tags_ts$tags.set(
		"pad",
		new Map([
			[
				"width",
				___R$$priv$project$rome$$internal$markup$tags_ts$numberValidator,
			],
			["align", ___R$$priv$project$rome$$internal$markup$tags_ts$alignValidator],
		]),
	);
	___R$project$rome$$internal$markup$tags_ts$tags.set("li", new Map());
	___R$project$rome$$internal$markup$tags_ts$tags.set("ul", new Map());
	___R$project$rome$$internal$markup$tags_ts$tags.set(
		"ol",
		new Map([
			[
				"reversed",
				___R$$priv$project$rome$$internal$markup$tags_ts$booleanValidator,
			],
			[
				"start",
				___R$$priv$project$rome$$internal$markup$tags_ts$numberValidator,
			],
		]),
	);

	// Tags that only support certain other tags as their children
	const ___R$project$rome$$internal$markup$tags_ts$tagsToOnlyChildren = new Map();
	___R$project$rome$$internal$markup$tags_ts$tagsToOnlyChildren.set(
		"table",
		["tr"],
	);
	___R$project$rome$$internal$markup$tags_ts$tagsToOnlyChildren.set(
		"tr",
		["td"],
	);
	___R$project$rome$$internal$markup$tags_ts$tagsToOnlyChildren.set(
		"ol",
		["li"],
	);
	___R$project$rome$$internal$markup$tags_ts$tagsToOnlyChildren.set(
		"ul",
		["li"],
	);

	// Tags that should only be children of other tags
	const ___R$project$rome$$internal$markup$tags_ts$tagsToOnlyParent = new Map();
	___R$project$rome$$internal$markup$tags_ts$tagsToOnlyParent.set(
		"tr",
		["table"],
	);
	___R$project$rome$$internal$markup$tags_ts$tagsToOnlyParent.set("td", ["tr"]);
	___R$project$rome$$internal$markup$tags_ts$tagsToOnlyParent.set(
		"li",
		["ol", "ul"],
	);
	___R$project$rome$$internal$markup$tags_ts$tagsToOnlyParent.set(
		"viewLinePrefix",
		["view"],
	);
	___R$project$rome$$internal$markup$tags_ts$tagsToOnlyParent.set(
		"viewPointer",
		["view"],
	);

	function ___R$$priv$project$rome$$internal$markup$tags_ts$alignValidator(
		align,
	) {
		if (align === "left" || align === "right") {
			return align;
		}

		return undefined;
	}

	// Validators
	function ___R$project$rome$$internal$markup$tags_ts$lineWrapValidator(mode) {
		if (mode === "none" || mode === "word-break" || mode === "char-break") {
			return mode;
		}

		return undefined;
	}

	function ___R$project$rome$$internal$markup$tags_ts$validateTokenType(type) {
		switch (type) {
			case "boolean":
			case "keyword":
			case "number":
			case "regex":
			case "string":
			case "comment":
			case "operator":
			case "punctuation":
			case "variable":
			case "attr-name":
			case "function":
			case "attr-value":
			case "attr-equals":
			case "tag":
				return type;

			default:
				return undefined;
		}
	}

	function ___R$project$rome$$internal$markup$tags_ts$validateColor(color) {
		switch (color) {
			case "black":
			case "brightBlack":
			case "red":
			case "brightRed":
			case "green":
			case "brightGreen":
			case "yellow":
			case "brightYellow":
			case "blue":
			case "brightBlue":
			case "magenta":
			case "brightMagenta":
			case "cyan":
			case "brightCyan":
			case "white":
			case "brightWhite":
				return color;

			default:
				return undefined;
		}
	}


  // project-rome/@internal/markup/parse.ts
const ___R$project$rome$$internal$markup$parse_ts = {
		isTagStartChar: ___R$project$rome$$internal$markup$parse_ts$isTagStartChar,
		parseMarkup: ___R$project$rome$$internal$markup$parse_ts$parseMarkup,
	};
	//
	function ___R$$priv$project$rome$$internal$markup$parse_ts$isStringValueChar(
		char,
		index,
		input,
	) {
		if (
			char === '"' &&
			!___R$project$rome$$internal$string$utils$isEscaped_ts$isEscaped(
				index,
				input,
			)
		) {
			return false;
		}

		return true;
	}

	function ___R$$priv$project$rome$$internal$markup$parse_ts$isTextChar(
		char,
		index,
		input,
	) {
		return !___R$project$rome$$internal$markup$parse_ts$isTagStartChar(
			index,
			input,
		);
	}

	function ___R$project$rome$$internal$markup$parse_ts$isTagStartChar(
		index,
		input,
	) {
		const i = ___R$project$rome$$internal$ob1$index_ts$ob1Get0(index);
		return (
			input[i] === "<" &&
			!___R$project$rome$$internal$string$utils$isEscaped_ts$isEscaped(
				index,
				input,
			)
		);
	}

	const ___R$$priv$project$rome$$internal$markup$parse_ts$createStringMarkupParser = ___R$project$rome$$internal$parser$core$utils_ts$createParser({
		diagnosticCategory: "parse/stringMarkup",
		getInitialState: () => ({inTagHead: false}),
		tokenizeWithState(parser, index, state) {
			const escaped = ___R$project$rome$$internal$string$utils$isEscaped_ts$isEscaped(
				index,
				parser.input,
			);
			const char = parser.getInputCharOnly(index);

			if (!escaped && state.inTagHead) {
				if (char === " ") {
					return parser.lookahead(
						___R$project$rome$$internal$ob1$index_ts$ob1Inc(index),
					);
				}

				if (char === "=") {
					return {
						state,
						token: parser.finishToken("Equals"),
					};
				}

				if (char === "/") {
					return {
						state,
						token: parser.finishToken("Slash"),
					};
				}

				if (___R$project$rome$$internal$parser$core$utils_ts$isAlpha(char)) {
					const [value, end] = parser.readInputFrom(
						index,
						___R$project$rome$$internal$parser$core$utils_ts$isAlpha,
					);
					return {
						state,
						token: parser.finishValueToken("Word", value, end),
					};
				}

				if (char === '"') {
					const [value, stringValueEnd, unclosed] = parser.readInputFrom(
						___R$project$rome$$internal$ob1$index_ts$ob1Inc(index),
						___R$$priv$project$rome$$internal$markup$parse_ts$isStringValueChar,
					);

					if (unclosed) {
						throw parser.unexpected({
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.STRING_MARKUP.UNCLOSED_STRING,
							start: parser.getPositionFromIndex(stringValueEnd),
						});
					}

					const end = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
						stringValueEnd,
						1,
					);
					return {
						state,
						token: parser.finishValueToken(
							"String",
							___R$project$rome$$internal$markup$escape_ts$unescapeTextValue(
								value,
							),
							end,
						),
					};
				}

				if (char === ">") {
					return {
						state: Object.assign({}, state, {inTagHead: false}),
						token: parser.finishToken("Greater"),
					};
				}
			}

			if (
				___R$project$rome$$internal$markup$parse_ts$isTagStartChar(
					index,
					parser.input,
				)
			) {
				return {
					state: Object.assign({}, state, {inTagHead: true}),
					token: parser.finishToken("Less"),
				};
			}

			// Keep eating text until we hit a <
			const [value, end] = parser.readInputFrom(
				index,
				___R$$priv$project$rome$$internal$markup$parse_ts$isTextChar,
			);
			return {
				state,
				token: {
					type: "Text",
					value: ___R$project$rome$$internal$markup$escape_ts$unescapeTextValue(
						value,
					),
					start: index,
					end,
				},
			};
		},
	});

	function ___R$$priv$project$rome$$internal$markup$parse_ts$atTagEnd(parser) {
		return (
			parser.matchToken("Less") && parser.lookahead().token.type === "Slash"
		);
	}

	function ___R$$priv$project$rome$$internal$markup$parse_ts$parseTag(
		parser,
		headStart,
		parentTagName,
	) {
		const nameToken = parser.expectToken("Word");
		const tagName = (nameToken.value);

		const allowedAttributes = ___R$project$rome$$internal$markup$tags_ts$tags.get(
			tagName,
		);
		if (allowedAttributes === undefined) {
			throw parser.unexpected({
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.STRING_MARKUP.UNKNOWN_TAG_NAME(
					tagName,
				),
				token: nameToken,
			});
		}

		// Check if this tag is restricted to certain parents
		const onlyAllowedAsChild = ___R$project$rome$$internal$markup$tags_ts$tagsToOnlyParent.get(
			tagName,
		);
		if (onlyAllowedAsChild !== undefined) {
			if (
				parentTagName === undefined ||
				!onlyAllowedAsChild.includes(parentTagName)
			) {
				throw parser.unexpected({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.STRING_MARKUP.RESTRICTED_CHILD(
						tagName,
						onlyAllowedAsChild,
						parentTagName,
					),
					token: nameToken,
				});
			}
		}

		// Check if the parent only allows certain children
		if (parentTagName !== undefined) {
			const onlyAllowedAsParent = ___R$project$rome$$internal$markup$tags_ts$tagsToOnlyChildren.get(
				parentTagName,
			);
			if (
				onlyAllowedAsParent !== undefined &&
				!onlyAllowedAsParent.includes(tagName)
			) {
				throw parser.unexpected({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.STRING_MARKUP.RESTRICTED_PARENT(
						parentTagName,
						onlyAllowedAsParent,
						tagName,
					),
					token: nameToken,
				});
			}
		}

		const attributes = ___R$project$rome$$internal$markup$util_ts$createEmptyAttributes();
		const children = [];
		let selfClosing = false;

		// Parse attributes
		while (!parser.matchToken("EOF") && !parser.matchToken("Greater")) {
			const keyToken = parser.getToken();

			let valueToken;
			let key;
			if (keyToken.type === "Word") {
				key = keyToken.value;

				const validator =
					allowedAttributes.get(key) ||
					___R$project$rome$$internal$markup$tags_ts$globalAttributes.get(key);
				if (validator === undefined) {
					throw parser.unexpected({
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.STRING_MARKUP.INVALID_ATTRIBUTE_NAME_FOR_TAG(
							tagName,
							key,
							[
								...allowedAttributes.keys(),
								...___R$project$rome$$internal$markup$tags_ts$globalAttributes.keys(),
							],
						),
					});
				}

				parser.nextToken();

				let rawValue;

				// Shorthand properties
				if (
					parser.matchToken("Word") ||
					parser.matchToken("Slash") ||
					parser.matchToken("Greater")
				) {
					rawValue = key;
					valueToken = keyToken;
				} else {
					parser.expectToken("Equals");

					valueToken = parser.expectToken("String");
					rawValue = valueToken.value;
				}

				const value = validator(rawValue, key);

				if (value === undefined) {
					throw parser.unexpected({
						token: valueToken,
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.STRING_MARKUP.INVALID_ATTRIBUTE_VALUE(
							tagName,
							key,
							rawValue,
						),
					});
				}

				attributes.get(
					key,
					{
						getDiagnosticLocation: (target) => {
							switch (target) {
								case "key":
									return parser.getDiagnosticLocation({token: keyToken});

								case "value":
									return parser.getDiagnosticLocation({token: valueToken});

								case "inner-value":
									if (valueToken === keyToken) {
										// Shorthand
										return parser.getDiagnosticLocation({token: keyToken});
									} else {
										// Remove string quotes
										return parser.getDiagnosticLocation({
											startIndex: ___R$project$rome$$internal$ob1$index_ts$ob1Inc(
												keyToken.start,
											),
											endIndex: ___R$project$rome$$internal$ob1$index_ts$ob1Dec(
												valueToken.end,
											),
										});
									}

								case "all":
									return parser.getDiagnosticLocation({
										startIndex: keyToken.start,
										endIndex: valueToken.end,
									});
							}
						},
					},
				).setValue(value);
			} else if (keyToken.type === "Slash") {
				parser.nextToken();
				selfClosing = true;
			} else {
				throw parser.unexpected({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.STRING_MARKUP.EXPECTED_ATTRIBUTE_NAME,
				});
			}
		}

		parser.expectToken("Greater");

		const headEnd = parser.getPosition();

		// Verify closing tag
		if (!selfClosing) {
			while (
				// Build children
				!parser.matchToken("EOF") &&
				!___R$$priv$project$rome$$internal$markup$parse_ts$atTagEnd(parser)
			) {
				const child = ___R$$priv$project$rome$$internal$markup$parse_ts$parseChild(
					parser,
					tagName,
				);
				if (child !== undefined) {
					children.push(child);
				}
			}

			if (parser.matchToken("EOF")) {
				throw parser.unexpected({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.STRING_MARKUP.UNCLOSED_TAG(
						tagName,
						parser.finishLocAt(headStart, headEnd),
					),
				});
			} else {
				parser.expectToken("Less");
				parser.expectToken("Slash");

				const name = parser.getToken();
				if (name.type === "Word") {
					if (name.value !== tagName) {
						throw parser.unexpected({
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.STRING_MARKUP.INCORRECT_CLOSING_TAG_NAME(
								tagName,
								name.value,
							),
						});
					}

					parser.nextToken();
				} else {
					throw parser.unexpected({
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.STRING_MARKUP.EXPECTED_CLOSING_TAG_NAME,
					});
				}

				parser.expectToken("Greater");
			}
		}

		return {
			type: "Tag",
			attributes,
			name: tagName,
			children,
		};
	}

	function ___R$$priv$project$rome$$internal$markup$parse_ts$parseChild(
		parser,
		parentTagName,
	) {
		const start = parser.getPosition();
		const token = parser.getToken();
		parser.nextToken();

		if (token.type === "Text") {
			// If this tag has restricted children then no text is allowed
			if (parentTagName !== undefined) {
				const onlyAllowedAsParent = ___R$project$rome$$internal$markup$tags_ts$tagsToOnlyChildren.get(
					parentTagName,
				);
				if (onlyAllowedAsParent !== undefined) {
					// Ignore text that's just whitespace
					if (token.value.trim() === "") {
						return undefined;
					} else {
						throw parser.unexpected({
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.STRING_MARKUP.RESTRICTED_PARENT_TEXT(
								parentTagName,
							),
							token,
						});
					}
				}
			}

			return {
				type: "Text",
				source: true,
				value: token.value,
			};
		} else if (token.type === "Less") {
			return ___R$$priv$project$rome$$internal$markup$parse_ts$parseTag(
				parser,
				start,
				parentTagName,
			);
		} else {
			throw parser.unexpected({
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.STRING_MARKUP.UNKNOWN_START,
			});
		}
	}

	const ___R$$priv$project$rome$$internal$markup$parse_ts$parseCache = new WeakMap();
	function ___R$project$rome$$internal$markup$parse_ts$parseMarkup(
		input,
		opts = {},
	) {
		let cacheKey;
		let children;

		if (typeof input !== "string") {
			cacheKey = ___R$project$rome$$internal$markup$escape_ts$serializeLazyMarkup(
				input,
			);

			const cached = ___R$$priv$project$rome$$internal$markup$parse_ts$parseCache.get(
				cacheKey,
			);
			if (cached !== undefined) {
				return cached;
			}

			// Don't need to parse a single escaped
			if (___R$project$rome$$internal$markup$util_ts$isSingleEscaped(cacheKey)) {
				children = [
					{
						type: "Text",
						value: cacheKey.parts[0],
						source: true,
					},
				];
			}

			input = ___R$project$rome$$internal$markup$escape_ts$readMarkup(input);
		}

		if (children === undefined) {
			children = [];
			const parser = ___R$$priv$project$rome$$internal$markup$parse_ts$createStringMarkupParser(
				Object.assign({}, opts, {input}),
			);
			while (!parser.matchToken("EOF")) {
				const child = ___R$$priv$project$rome$$internal$markup$parse_ts$parseChild(
					parser,
					undefined,
				);
				if (child !== undefined) {
					children.push(child);
				}
			}
		}

		if (cacheKey !== undefined) {
			___R$$priv$project$rome$$internal$markup$parse_ts$parseCache.set(
				cacheKey,
				children,
			);
		}
		return children;
	}


  // project-rome/@internal/markup/types.ts
const ___R$project$rome$$internal$markup$types_ts = {};


  // project-rome/@internal/markup/normalize.ts
const ___R$project$rome$$internal$markup$normalize_ts = {
		joinMarkupLines: ___R$project$rome$$internal$markup$normalize_ts$joinMarkupLines,
		normalizeMarkup: ___R$project$rome$$internal$markup$normalize_ts$normalizeMarkup,
	};
	function ___R$$priv$project$rome$$internal$markup$normalize_ts$buildTag(
		tag,
		inner,
		opts,
	) {
		let {attributes} = tag;

		switch (tag.name) {
			// Normalize filename of <filelink target>
			case "filelink": {
				// Clone
				attributes = attributes.copy();

				const {filename, line, column, text} = ___R$project$rome$$internal$markup$util_ts$buildFileLink(
					attributes,
					opts,
				);

				attributes.get("target").setValue(filename);

				if (
					___R$project$rome$$internal$markup$escape_ts$isEmptyMarkup(inner) ||
					opts.stripFilelinkText
				) {
					inner = ___R$project$rome$$internal$markup$escape_ts$markup`${text}`;
				}

				if (opts.stripPositions) {
					attributes.get("line").setValue(undefined);
					attributes.get("column").setValue(undefined);
				} else {
					attributes.get("column").setValue(column);
					attributes.get("line").setValue(line);
				}
				break;
			}

			// We don't technically need to normalize this but it's one less tag to have to support
			// if other tools need to consume it
			case "grammarNumber":
				return ___R$project$rome$$internal$markup$escape_ts$markup`${___R$project$rome$$internal$markup$util_ts$formatGrammarNumber(
					attributes,
					___R$project$rome$$internal$markup$escape_ts$readMarkup(inner),
				)}`;
		}

		let open = "<" + tag.name;

		// Print attributes
		for (const [key, value] of attributes.asMap()) {
			if (!value.exists()) {
				continue;
			}

			const raw = value.asUnknown();
			if (raw === true) {
				open += " " + key;
			} else {
				open += ___R$project$rome$$internal$markup$escape_ts$readMarkup(
					___R$project$rome$$internal$markup$escape_ts$markup` ${key}="${String(
						raw,
					)}"`,
				);
			}
		}

		if (___R$project$rome$$internal$markup$escape_ts$isEmptyMarkup(inner)) {
			return ___R$project$rome$$internal$markup$escape_ts$convertToMarkupFromRandomString(
				open + " />",
			);
		} else {
			return ___R$project$rome$$internal$markup$escape_ts$convertToMarkupFromRandomString(
				open +
				">" +
				___R$project$rome$$internal$markup$escape_ts$readMarkup(inner) +
				"</" +
				tag.name +
				">",
			);
		}
	}

	function ___R$$priv$project$rome$$internal$markup$normalize_ts$normalizeMarkupChildren(
		children,
		opts,
		remainingChars,
	) {
		// Sometimes we'll populate the inner text of a tag with no children
		if (children.length === 0) {
			return {
				text: ___R$project$rome$$internal$markup$escape_ts$markup``,
				textLength: 0,
			};
		}

		let textLength = 0;

		let parts = [];

		for (const child of children) {
			if (child.type === "Text") {
				let text = ___R$project$rome$$internal$markup$escape_ts$readMarkup(
					___R$project$rome$$internal$markup$escape_ts$markup`${child.value}`,
				);
				textLength += text.length;

				const isVisible = remainingChars > 0;
				if (text.length > remainingChars) {
					text = ___R$project$rome$$internal$string$utils$sliceEscaped_ts$sliceEscaped(
						text,
						remainingChars,
					);
				}
				remainingChars -= text.length;
				if (isVisible) {
					// We already escaped it
					parts.push(
						___R$project$rome$$internal$markup$escape_ts$convertToMarkupFromRandomString(
							text,
						),
					);
				}
			} else if (child.type === "Tag") {
				const inner = ___R$$priv$project$rome$$internal$markup$normalize_ts$normalizeMarkupChildren(
					child.children,
					opts,
					remainingChars,
				);

				if (remainingChars > 0) {
					parts.push(
						___R$$priv$project$rome$$internal$markup$normalize_ts$buildTag(
							child,
							inner.text,
							opts,
						),
					);
				}
				textLength += inner.textLength;
				remainingChars -= inner.textLength;
			} else {
				throw new Error("Unknown child node type");
			}
		}

		return {
			text: ___R$project$rome$$internal$markup$escape_ts$concatMarkup(parts),
			textLength,
		};
	}

	function ___R$project$rome$$internal$markup$normalize_ts$joinMarkupLines(
		{lines},
	) {
		return lines.join("\n");
	}

	function ___R$project$rome$$internal$markup$normalize_ts$normalizeMarkup(
		input,
		opts = {},
		maxLength = Infinity,
	) {
		const {textLength, text} = ___R$$priv$project$rome$$internal$markup$normalize_ts$normalizeMarkupChildren(
			___R$project$rome$$internal$markup$parse_ts$parseMarkup(input),
			opts,
			maxLength,
		);

		const isTruncated = textLength > maxLength;

		return {
			textLength,
			text,
			truncated: isTruncated,
			visibleTextLength: isTruncated ? maxLength : textLength,
			truncatedLength: isTruncated ? textLength - maxLength : 0,
		};
	}


  // project-rome/@internal/markup/index.ts



  // project-rome/@internal/node/errors.ts
const ___R$project$rome$$internal$node$errors_ts = {
		convertPossibleNodeErrorToDiagnostic: ___R$project$rome$$internal$node$errors_ts$convertPossibleNodeErrorToDiagnostic,
	};
	function ___R$$priv$project$rome$$internal$node$errors_ts$getPathFromNodeError(
		err,
	) {
		return err.path == null ? err.address : err.path;
	}

	function ___R$$priv$project$rome$$internal$node$errors_ts$getMessageFromNodeError(
		err,
	) {
		const path = ___R$$priv$project$rome$$internal$node$errors_ts$getPathFromNodeError(
			err,
		);

		switch (err.code) {
			case "ENOENT":
				return {
					message: ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${path}</emphasis> does not exist`,
				};

			case "EPERM":
				return {
					message: ___R$project$rome$$internal$markup$escape_ts$markup`Operation not permitted on <emphasis>${path}</emphasis>`,
				};

			case "EACCES":
				return {
					message: ___R$project$rome$$internal$markup$escape_ts$markup`Permission denied for <emphasis>${path}</emphasis>`,
				};

			case "EISDIR":
				return {
					message: ___R$project$rome$$internal$markup$escape_ts$markup`Trying to perform a file operation on the folder <emphasis>${path}</emphasis>`,
				};

			case "EROFS":
				return {
					message: ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${path}</emphasis> is a read-only file system`,
				};

			case "EPIPE":
				return {
					message: ___R$project$rome$$internal$markup$escape_ts$markup`Pipe closed on other end`,
				};

			case "EMFILE":
				return {
					message: ___R$project$rome$$internal$markup$escape_ts$markup`Too many open files`,
					advice: [
						{
							type: "log",
							category: "info",
							text: ___R$project$rome$$internal$markup$escape_ts$markup`This is encountered when opening many files at once in parallel. To increase this limit you can try running:`,
						},
						{
							type: "command",
							command: "ulimit -n 2048",
						},
						{
							type: "log",
							category: "info",
							text: ___R$project$rome$$internal$markup$escape_ts$markup`Inside the current terminal then run this command again.`,
						},
					],
				};

			default:
				return {
					message: ___R$project$rome$$internal$markup$escape_ts$markup`${err.message}`,
				};
		}
	}

	function ___R$project$rome$$internal$node$errors_ts$convertPossibleNodeErrorToDiagnostic(
		err,
	) {
		if (
			err.code === undefined ||
			err instanceof
			___R$project$rome$$internal$diagnostics$errors_ts$DiagnosticsError
		) {
			return err;
		}

		let {message, advice = []} = ___R$$priv$project$rome$$internal$node$errors_ts$getMessageFromNodeError(
			err,
		);
		const struct = ___R$project$rome$$internal$v8$errors_ts$getErrorStructure(
			err,
			0,
			false,
		);
		let location = {};

		if (err.path !== undefined && struct.frames.length === 0) {
			// If we are an fs error with no frames then recommend adding the envvar so the @internal/fs module will
			// manually capture and set stacktraces
			advice.push({
				type: "log",
				category: "warn",
				text: ___R$project$rome$$internal$markup$escape_ts$markup`No stacktrace available for this error. This is a Node.js limitation: <hyperlink target="https://github.com/nodejs/node/issues/30944" />`,
			});

			advice.push({
				type: "log",
				category: "info",
				text: ___R$project$rome$$internal$markup$escape_ts$markup`Try setting the <code>ROME_FS_ERRORS=1</code> envvar to capture stacktraces for fs calls.`,
			});
		} else {
			advice = ___R$project$rome$$internal$diagnostics$derive_ts$getErrorStackAdvice(
				struct,
			);
			location = ___R$project$rome$$internal$v8$errors_ts$getDiagnosticLocationFromErrorFrame(
				struct.frames[0],
			);
		}

		let category = "internalError/fatal";
		if (err.path !== undefined) {
			category = "internalError/fs";
		} else {
			// TODO probably others
		}

		// If provided with a path, try and get some debug stats
		const pathStr = ___R$$priv$project$rome$$internal$node$errors_ts$getPathFromNodeError(
			err,
		);
		if (pathStr !== undefined) {
			try {
				const path = ___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
					pathStr,
				);

				for (const parent of path.getChain()) {
					try {
						const stat = ___R$project$rome$$internal$fs$index_ts$lstatSync(
							parent,
						);

						advice.push({
							type: "group",
							title: ___R$project$rome$$internal$markup$escape_ts$markup`File stats for <emphasis>${parent}</emphasis>`,
							advice: [
								{
									type: "log",
									category: "none",
									text: ___R$project$rome$$internal$pretty$format$index_ts$prettyFormatEager(
										Object.assign(
											{},
											stat,
											{
												isFile: stat.isFile(),
												isDirectory: stat.isDirectory(),
												isBlockDevice: stat.isBlockDevice(),
												isCharacterDevice: stat.isCharacterDevice(),
												isSymbolicLink: stat.isSymbolicLink(),
												isFIFO: stat.isFIFO(),
												isSocket: stat.isSocket(),
											},
										),
									),
								},
							],
						});
						break;
					} catch (err) {
						// Swallow
					}
				}
			} catch (err) {
				// Swallow
			}
		}

		const diag = {
			description: {
				category,
				message,
				advice,
			},
			location,
			tags: {
				internal: true,
			},
		};

		// Create diagnostic error
		const diagErr = ___R$project$rome$$internal$diagnostics$errors_ts$createSingleDiagnosticError(
			diag,
		);

		// Add on remaining regular error props so it can be treated as a normal error if necessary

		// Inherit NodeSystemError props
		___R$project$rome$$internal$v8$errors_ts$setNodeErrorProps(diagErr, err);

		// Without doing something jank we can't retain the original Error constructor ie. TypeError etc
		// We probably don't need to or actually care
		diagErr.name = err.name;

		// Copy frames
		___R$project$rome$$internal$v8$errors_ts$setErrorFrames(
			diagErr,
			struct.frames,
		);

		return diagErr;
	}



  // project-rome/@internal/node/index.ts



  // project-rome/@internal/v8/errors.ts
const ___R$project$rome$$internal$v8$errors_ts = {
		get ERROR_FRAMES_PROP() {
			return ___R$project$rome$$internal$v8$errors_ts$ERROR_FRAMES_PROP;
		},
		setErrorFrames: ___R$project$rome$$internal$v8$errors_ts$setErrorFrames,
		setNodeErrorProps: ___R$project$rome$$internal$v8$errors_ts$setNodeErrorProps,
		getErrorStructure: ___R$project$rome$$internal$v8$errors_ts$getErrorStructure,
		extractNodeSystemErrorProperties: ___R$project$rome$$internal$v8$errors_ts$extractNodeSystemErrorProperties,
		getDiagnosticLocationFromErrorFrame: ___R$project$rome$$internal$v8$errors_ts$getDiagnosticLocationFromErrorFrame,
	};
	Object.keys(___R$project$rome$$internal$v8$types_ts).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$v8$errors_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$v8$types_ts[key];
				},
			},
		);
	});
	const ___R$project$rome$$internal$v8$errors_ts$ERROR_FRAMES_PROP = "ERROR_FRAMES";

	function ___R$project$rome$$internal$v8$errors_ts$setErrorFrames(err, frames) {
		err[___R$project$rome$$internal$v8$errors_ts$ERROR_FRAMES_PROP] = frames;
	}

	function ___R$project$rome$$internal$v8$errors_ts$setNodeErrorProps(
		err,
		props,
	) {
		err.address = props.address;
		err.code = props.code;
		err.dest = props.dest;
		err.errno = props.errno;
		err.path = props.path;
		err.port = props.port;
		err.syscall = props.syscall;
	}

	function ___R$project$rome$$internal$v8$errors_ts$getErrorStructure(
		err,
		framesToShift = 0,
		shouldConvertPossibleNodeError = true,
	) {
		// Make some node errors more pretty
		if (err instanceof Error && shouldConvertPossibleNodeError) {
			err = ___R$project$rome$$internal$node$errors_ts$convertPossibleNodeErrorToDiagnostic(
				err,
			);
		}

		let name = "Error";
		let message = "Unknown message";
		let stack = undefined;
		let frames = [];
		let looksLikeValidError = false;

		if (
			___R$project$rome$$internal$typescript$helpers$index_ts$isPlainObject(err)
		) {
			if (typeof err.name === "string") {
				looksLikeValidError = true;
				name = err.name;
			}

			if (typeof err.message === "string") {
				looksLikeValidError = true;
				message = err.message;
			}

			if (typeof err.stack === "string") {
				looksLikeValidError = true;
				stack = err.stack;
			}

			if (
				Array.isArray(
					err[___R$project$rome$$internal$v8$errors_ts$ERROR_FRAMES_PROP],
				)
			) {
				// @ts-ignore
				frames = err[___R$project$rome$$internal$v8$errors_ts$ERROR_FRAMES_PROP];
			}
		}

		frames = frames.slice(framesToShift);

		if (!looksLikeValidError) {
			message = "Not an error instance: " + String(err);
		}

		return {
			name,
			message,
			stack,
			frames,
			node: ___R$project$rome$$internal$v8$errors_ts$extractNodeSystemErrorProperties(
				err,
			),
		};
	}

	function ___R$project$rome$$internal$v8$errors_ts$extractNodeSystemErrorProperties(
		err,
	) {
		if (
			___R$project$rome$$internal$typescript$helpers$index_ts$isPlainObject(err)
		) {
			return {
				address: typeof err.address === "string" ? err.address : undefined,
				code: typeof err.code === "string" ? err.code : undefined,
				dest: typeof err.dest === "string" ? err.dest : undefined,
				errno: typeof err.errno === "number" ? err.errno : undefined,
				path: typeof err.path === "string" ? err.path : undefined,
				port: typeof err.port === "string" ? err.port : undefined,
				syscall: typeof err.syscall === "string" ? err.syscall : undefined,
			};
		} else {
			return {
				address: undefined,
				code: undefined,
				dest: undefined,
				errno: undefined,
				path: undefined,
				port: undefined,
				syscall: undefined,
			};
		}
	}

	function ___R$project$rome$$internal$v8$errors_ts$getDiagnosticLocationFromErrorFrame(
		frame,
	) {
		if (frame === undefined) {
			return {};
		}

		const pos = {
			line: frame.lineNumber == null
				? ___R$project$rome$$internal$ob1$index_ts$ob1Number1
				: frame.lineNumber,
			column: frame.columnNumber == null
				? ___R$project$rome$$internal$ob1$index_ts$ob1Number0
				: frame.columnNumber,
		};

		return {
			filename: frame.filename == null ? "unknown" : frame.filename,
			start: pos,
			end: pos,
		};
	}


  // project-rome/@internal/v8/sourceMapManager.ts
let ___R$$priv$project$rome$$internal$v8$sourceMapManager_ts$inited = false;

	function ___R$$priv$project$rome$$internal$v8$sourceMapManager_ts$prepareStackTrace(
		err,
		frames,
	) {
		try {
			___R$$priv$project$rome$$internal$v8$sourceMapManager_ts$addErrorFrames(
				err,
				frames,
			);
			return ___R$$priv$project$rome$$internal$v8$sourceMapManager_ts$buildStackString(
				err,
			);
		} catch (err2) {
			return (
				err.name +
				": " +
				err.message +
				"\n  Failed to generate stacktrace: " +
				err2.message
			);
		}
	}

	function ___R$project$rome$$internal$v8$sourceMapManager_ts$initErrorHooks() {
		if (!___R$$priv$project$rome$$internal$v8$sourceMapManager_ts$inited) {
			___R$$priv$project$rome$$internal$v8$sourceMapManager_ts$inited = true;
			Error.prepareStackTrace = ___R$$priv$project$rome$$internal$v8$sourceMapManager_ts$prepareStackTrace;
		}
	}

	function ___R$project$rome$$internal$v8$sourceMapManager_ts$teardown() {
		Error.prepareStackTrace = undefined;
	}

	function ___R$$priv$project$rome$$internal$v8$sourceMapManager_ts$buildStackString(
		err,
	) {
		const {frames} = ___R$project$rome$$internal$v8$errors_ts$getErrorStructure(
			err,
		);
		const lines = [];

		lines.push(err.name + ": " + err.message);

		for (const frame of frames) {
			const {
				resolvedLocation,
				methodName,
				functionName,
				typeName,
				isNative,
				isAsync,
				isEval,
				isConstructor,
				filename,
				lineNumber,
				columnNumber,
			} = frame;
			const parts = [];

			if (isAsync) {
				parts.push("await");
			}

			if (isEval) {
				parts.push("eval");
			}

			if (isConstructor) {
				parts.push("new");
			}

			let name = "<anonymous>";
			if (functionName !== undefined) {
				name = functionName;
			}
			if (methodName !== undefined) {
				name = methodName;
			}
			if (typeName !== undefined) {
				parts.push(typeName + "." + name);
			} else {
				parts.push(name);
			}

			if (isNative) {
				parts.push("native");
			} else if (
				filename !== undefined &&
				lineNumber !== undefined &&
				columnNumber !== undefined
			) {
				parts.push("(" + filename + ":" + lineNumber + ":" + columnNumber + ")");
			}

			if (!resolvedLocation) {
				parts.push("generated source location");
			}

			lines.push("  at " + parts.join(" "));
		}

		return lines.join("\n");
	}

	function ___R$$priv$project$rome$$internal$v8$sourceMapManager_ts$noNull(val) {
		if (val === null) {
			return undefined;
		} else {
			return val;
		}
	}

	function ___R$$priv$project$rome$$internal$v8$sourceMapManager_ts$addErrorFrames(
		err,
		frames,
	) {
		if (err[___R$project$rome$$internal$v8$errors_ts$ERROR_FRAMES_PROP]) {
			return;
		}

		let builtFrames = frames.map((frameApi) => {
			const filename = frameApi.getFileName();
			const lineNumber = frameApi.getLineNumber();
			const columnNumber = frameApi.getColumnNumber();

			const frame = {
				typeName: ___R$$priv$project$rome$$internal$v8$sourceMapManager_ts$noNull(
					frameApi.getTypeName(),
				),
				functionName: ___R$$priv$project$rome$$internal$v8$sourceMapManager_ts$noNull(
					frameApi.getFunctionName(),
				),
				methodName: ___R$$priv$project$rome$$internal$v8$sourceMapManager_ts$noNull(
					frameApi.getMethodName(),
				),
				isTopLevel: frameApi.isToplevel(),
				isEval: frameApi.isEval(),
				isNative: frameApi.isNative(),
				isConstructor: frameApi.isConstructor(),
				// TODO frameApi.isAsync
				isAsync: false,
				resolvedLocation: true,
				filename: ___R$$priv$project$rome$$internal$v8$sourceMapManager_ts$noNull(
					filename,
				),
				lineNumber: lineNumber == null
					? undefined
					: ___R$project$rome$$internal$ob1$index_ts$ob1Coerce1(lineNumber),
				// Rome expects 0-indexed columns, V8 provides 1-indexed
				columnNumber: columnNumber == null
					? undefined
					: ___R$project$rome$$internal$ob1$index_ts$ob1Coerce1To0(columnNumber),
			};

			if (
				frame.filename !== undefined &&
				frame.lineNumber !== undefined &&
				frame.columnNumber !== undefined
			) {
				const {found, line, column, source, name} = ___R$$priv$project$rome$$internal$v8$sourceMapManager_ts$sourceMaps.assertApproxOriginalPositionFor(
					frame.filename,
					frame.lineNumber,
					frame.columnNumber,
				);

				return Object.assign(
					{},
					frame,
					{
						functionName: frame.functionName == null ? name : frame.functionName,
						methodName: frame.methodName == null ? name : frame.methodName,
						resolvedLocation: found,
						lineNumber: line,
						columnNumber: column,
						filename: source,
					},
				);
			} else {
				return frame;
			}
		});

		___R$project$rome$$internal$v8$errors_ts$setErrorFrames(err, builtFrames);
	}

	const ___R$$priv$project$rome$$internal$v8$sourceMapManager_ts$sourceMaps = new ___R$project$rome$$internal$codec$source$map$SourceMapConsumerCollection_ts$default();
	const ___R$project$rome$$internal$v8$sourceMapManager_ts$default = ___R$$priv$project$rome$$internal$v8$sourceMapManager_ts$sourceMaps;


  // project-rome/@internal/v8/utils.ts
const ___R$project$rome$$internal$v8$utils_ts = {
		hrTime: ___R$project$rome$$internal$v8$utils_ts$hrTime,
		urlToFilename: ___R$project$rome$$internal$v8$utils_ts$urlToFilename,
	};
	function ___R$project$rome$$internal$v8$utils_ts$hrTime() {
		// [seconds, nanoseconds]
		const hrtime = process.hrtime();

		// microseconds
		return hrtime[0] * 1_000_000 + Math.round(hrtime[1] / 1_000);
	}

	const ___R$$priv$project$rome$$internal$v8$utils_ts$FILE_PROTOCOL = "file://";

	function ___R$project$rome$$internal$v8$utils_ts$urlToFilename(url) {
		if (
			url.startsWith(
				___R$$priv$project$rome$$internal$v8$utils_ts$FILE_PROTOCOL,
			)
		) {
			return url.slice(
				___R$$priv$project$rome$$internal$v8$utils_ts$FILE_PROTOCOL.length,
			);
		} else {
			return url;
		}
	}


  // project-rome/@internal/v8/Profiler.ts
const ___R$$priv$project$rome$$internal$v8$Profiler_ts$inspector = require(
		"inspector",
	);
	const ___R$$priv$project$rome$$internal$v8$Profiler_ts$workerThreads = require(
		"worker_threads",
	);
	class ___R$project$rome$$internal$v8$Profiler_ts$default {
		constructor() {
			this.session = undefined;
			this.memoryInterval = undefined;
			this.memorySamples = [];
		}

		async startProfiling(samplingInterval) {
			this.session = new ___R$$priv$project$rome$$internal$v8$Profiler_ts$inspector.Session();
			this.session.connect();

			this.memoryInterval = setInterval(
				() => {
					//const time = hrTime();
					//const size = process.memoryUsage().heapUsed;
					//this.memorySamples.push([time, size]);
				},
				100,
			);

			await Promise.all([
				this.sendCommand(
					"Profiler.setSamplingInterval",
					{
						interval: samplingInterval,
					},
				),
				this.sendCommand("Profiler.enable"),
				this.sendCommand("Profiler.start"),
			]);
		}

		async sendCommand(method, params) {
			const {session} = this;
			if (session === undefined) {
				return Promise.reject(new Error("No current profiler session"));
			} else {
				return new Promise((resolve, reject) => {
					session.post(
						method,
						params,
						(err) => {
							if (err === null) {
								resolve();
							} else {
								reject(err);
							}
						},
					);
				});
			}
		}

		destroy() {
			const {session} = this;
			if (session !== undefined) {
				if (this.memoryInterval !== undefined) {
					clearInterval(this.memoryInterval);
				}
				this.memorySamples = [];
				session.disconnect();
			}
		}

		async stopProfiling() {
			const {session} = this;
			if (session === undefined) {
				return Promise.reject(new Error("No current profiler session"));
			}

			const {memorySamples} = this;

			const res = await new Promise((resolve, reject) => {
				session.post(
					"Profiler.stop",
					(err, params) => {
						if (err === null) {
							resolve(params);
						} else {
							reject(err);
						}
					},
				);
			});

			this.destroy();

			return {
				pid: process.pid,
				tid: ___R$$priv$project$rome$$internal$v8$Profiler_ts$workerThreads.threadId,
				cpuProfile: res.profile,
				memorySamples,
			};
		}
	}


  // project-rome/@internal/v8/Trace.ts
class ___R$project$rome$$internal$v8$Trace_ts$default {
		constructor() {
			this.eventId = 0;
			this.events = [];
		}

		getEventId() {
			const id = this.eventId;
			this.eventId++;
			return id;
		}

		decodeProfileSourceMap(profile) {
			// This method mutates the profile for performance/ergonomics
			// Nothing else should be relying on this so it doesn't really matter
			for (const node of profile.cpuProfile.nodes) {
				const {callFrame} = node;

				// Call frame line numbers are 0-index while Rome is 1-indexed
				const resolved = ___R$project$rome$$internal$v8$sourceMapManager_ts$default.approxOriginalPositionFor(
					___R$project$rome$$internal$v8$utils_ts$urlToFilename(callFrame.url),
					___R$project$rome$$internal$ob1$index_ts$ob1Coerce0To1(
						___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(
							callFrame.lineNumber,
						),
					),
					___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(
						callFrame.columnNumber,
					),
				);
				if (resolved !== undefined) {
					callFrame.url = resolved.source;
					callFrame.lineNumber = ___R$project$rome$$internal$ob1$index_ts$ob1Get0(
						___R$project$rome$$internal$ob1$index_ts$ob1Coerce1To0(
							resolved.line,
						),
					);
					callFrame.columnNumber = ___R$project$rome$$internal$ob1$index_ts$ob1Get0(
						resolved.column,
					);

					if (resolved.name !== undefined) {
						callFrame.functionName = resolved.name;
					}
				}
			}
		}

		addProfile(name, profile) {
			this.decodeProfileSourceMap(profile);

			const {startTime, endTime} = profile.cpuProfile;

			const common = {
				pid: profile.pid,
				tid: profile.tid,
			};

			this.events.push(
				Object.assign(
					{},
					common,
					{ts: 0, ph: "M", cat: "__metadata", name: "thread_name", args: {name}},
				),
			);

			this.events.push(
				Object.assign(
					{},
					common,
					{
						ph: "P",
						name: "CpuProfile",
						id: this.getEventId(),
						cat: "disabled-by-default-v8.cpu_profiler",
						ts: endTime,
						args: {
							data: {
								cpuProfile: profile.cpuProfile,
							},
						},
					},
				),
			);

			this.events.push(
				Object.assign(
					{},
					common,
					{
						ph: "X",
						name: "EvaluateScript",
						id: this.getEventId(),
						cat: "devtools.timeline",
						ts: startTime,
						dur: endTime - startTime,
						args: {
							data: {
								url: "rome.js",
								lineNumber: 1,
								columnNumber: 1,
								frame: "0xFFF",
							},
						},
					},
				),
			);

			for (const [time, size] of profile.memorySamples) {
				this.events.push(
					Object.assign(
						{},
						common,
						{
							ts: time,
							ph: "I",
							cat: "disabled-by-default-devtools.timeline",
							name: "UpdateCounters",
							args: {
								data: {
									jsHeapSizeUsed: size,
								},
							},
							s: "t",
						},
					),
				);
			}
		}

		build() {
			return this.events;
		}
	}


  // project-rome/@internal/v8/InspectorClient.ts
class ___R$project$rome$$internal$v8$InspectorClient_ts$InspectorClientCloseError
		extends Error {
		constructor() {
			super("Inspector connection closed");
		}
	}

	class ___R$project$rome$$internal$v8$InspectorClient_ts$default {
		constructor(socket) {
			this.socket = socket;
			this.id = 0;

			this.subscriptions = new Map();
			this.callbacks = new Map();

			this.alive = true;

			this.init();
		}

		end() {
			this.socket.end();
		}

		init() {
			const {socket} = this;

			socket.errorEvent.subscribe((err) => {
				this.alive = false;
				for (const [, {reject}] of this.callbacks) {
					reject(err);
				}
				this.callbacks.clear();
				this.end();
			});

			socket.endEvent.subscribe(() => {
				this.alive = false;
				for (const [, {reject}] of this.callbacks) {
					reject(
						new ___R$project$rome$$internal$v8$InspectorClient_ts$InspectorClientCloseError(),
					);
				}
				this.callbacks.clear();
			});

			socket.completeFrameEvent.subscribe((frame) => {
				const json = frame.payload.toString();
				const data = ___R$project$rome$$internal$codec$json$index_ts$consumeJSON({
					input: json,
				});

				// Message reply
				const id = data.get("id").asNumberOrVoid();
				if (id !== undefined) {
					const handler = this.callbacks.get(id);
					if (handler !== undefined) {
						if (data.has("error")) {
							const errorMessage = data.get("error").get("message").asString();
							handler.reject(new Error(errorMessage));
						} else {
							handler.resolve(data.get("result"));
						}
						this.callbacks.delete(id);
					}
					return;
				}

				// Event
				const method = data.get("method").asStringOrVoid();
				if (method !== undefined) {
					const subs = this.subscriptions.get(method);
					if (subs !== undefined) {
						for (const sub of subs) {
							const {callback, once} = sub;
							callback(data.get("params"));
							if (once) {
								subs.delete(sub);
							}
						}
					}
				}
			});
		}

		subscribe(method, sub) {
			let subs = this.subscriptions.get(method);
			if (subs === undefined) {
				subs = new Set();
				this.subscriptions.set(method, subs);
			}
			subs.add(sub);
		}

		assertAlive() {
			if (!this.alive) {
				throw new Error("InspectorClient has no active socket");
			}
		}

		async wait(method) {
			return new Promise((resolve) => {
				this.assertAlive();
				this.subscribe(
					method,
					{
						once: true,
						callback: resolve,
					},
				);
			});
		}

		call(method, params) {
			const id = ++this.id;

			return new Promise((resolve, reject) => {
				this.assertAlive();
				this.callbacks.set(id, {resolve, reject});

				this.socket.sendJSON({
					id,
					method,
					params,
				});
			});
		}
	}


  // project-rome/@internal/v8/CoverageCollector.ts
const ___R$$priv$project$rome$$internal$v8$CoverageCollector_ts$inspector = require(
		"inspector",
	);
	function ___R$$priv$project$rome$$internal$v8$CoverageCollector_ts$createCoverageFileStats(
		covered,
		uncovered,
	) {
		const total = uncovered + covered;
		return {
			uncovered,
			covered,
			total,
			percent: total === 0 ? 100 : 100 / total * covered,
		};
	}

	class ___R$project$rome$$internal$v8$CoverageCollector_ts$default {
		constructor() {
			this.sourceMaps = new Map();
		}

		addSourceMap(filename, code, map) {
			this.sourceMaps.set(
				filename,
				{
					ranges: [],
					map,
					code,
				},
			);
		}

		addCoverage(entries) {
			for (const entry of entries) {
				const filename = ___R$project$rome$$internal$v8$utils_ts$urlToFilename(
					entry.url,
				);

				const data = this.sourceMaps.get(filename);
				if (data === undefined) {
					continue;
				}

				for (const {ranges, functionName, isBlockCoverage} of entry.functions) {
					data.ranges = data.ranges.concat(
						ranges.map((range) => {
							let kind = "expression";
							if (functionName !== "") {
								kind = "function";
							} else if (isBlockCoverage) {
								kind = "branch";
							}

							return Object.assign({kind}, range);
						}),
					);
				}
			}
		}

		generate() {
			const insertedLocs = new Map();
			const locs = [];

			for (const data of this.sourceMaps.values()) {
				const {ranges, code, map} = data;

				// Turn an index into a position in the compiled source
				let line = ___R$project$rome$$internal$ob1$index_ts$ob1Number1;
				let column = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;
				let index = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;
				const indexCache = new Map();
				function findIndex(newIndex) {
					const cached = indexCache.get(newIndex);
					if (cached !== undefined) {
						return cached;
					}

					if (newIndex < index) {
						throw new Error(
							"Expected newIndex(" + newIndex + ") >= index(" + index + ")",
						);
					}

					if (
						___R$project$rome$$internal$ob1$index_ts$ob1Get0(newIndex) >
						code.length
					) {
						throw new Error(
							"Expected newIndex(" +
							newIndex +
							") <= code.length(" +
							code.length +
							")",
						);
					}

					while (index < newIndex) {
						const char = code[___R$project$rome$$internal$ob1$index_ts$ob1Get0(
							index,
						)];
						if (char === "\n") {
							line = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(line);
							column = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;
						} else {
							column = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(column);
						}
						index = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(index);
					}

					const pos = {
						line,
						column,
					};
					indexCache.set(newIndex, pos);
					return pos;
				}

				// Prefetch all sorted indexes
				const offsets = [];
				for (const {startOffset, endOffset} of ranges) {
					offsets.push(
						___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(startOffset),
					);
					offsets.push(
						___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(endOffset),
					);
				}
				offsets.sort((a, b) =>
					___R$project$rome$$internal$ob1$index_ts$ob1Get0(a) -
					___R$project$rome$$internal$ob1$index_ts$ob1Get0(b)
				);
				for (const index of offsets) {
					findIndex(index);
				}

				//
				for (const {kind, startOffset, endOffset, count} of ranges) {
					const originalStart = findIndex(
						___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(startOffset),
					);
					const originalEnd = findIndex(
						___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(endOffset),
					);

					const sourceStart = map.approxOriginalPositionFor(
						originalStart.line,
						originalStart.column,
					);
					if (sourceStart === undefined) {
						continue;
					}

					const sourceEnd = map.approxOriginalPositionFor(
						originalEnd.line,
						originalEnd.column,
					);
					if (sourceEnd === undefined) {
						continue;
					}

					if (sourceStart.source !== sourceEnd.source) {
						throw new Error(
							"Expected the same source for start and end: " +
							sourceStart.source +
							" !== " +
							sourceEnd.source,
						);
					}

					const key =
						sourceStart.source +
						":" +
						String(startOffset) +
						"-" +
						String(endOffset);
					const alreadyInserted = insertedLocs.get(key);
					if (alreadyInserted !== undefined) {
						alreadyInserted.count += count;
						continue;
					}

					const loc = {
						kind,
						filename: sourceStart.source,
						count,
						start: {
							line: sourceStart.line,
							column: sourceStart.column,
						},
						end: {
							line: sourceEnd.line,
							column: sourceEnd.column,
						},
					};
					insertedLocs.set(key, loc);
					locs.push(loc);
				}

				map.clearCache();
			}

			// Assemble files
			const rangesByFile = new Map();
			for (const loc of locs) {
				let ranges = rangesByFile.get(loc.filename);
				if (ranges === undefined) {
					ranges = [];
					rangesByFile.set(loc.filename, ranges);
				}
				ranges.push(loc);
			}

			const files = [];
			for (const [filename, ranges] of rangesByFile) {
				const coveredLines = new Set();
				const uncoveredLines = new Set();

				let uncoveredFunctions = new Set();
				let coveredFunctions = new Set();
				let uncoveredBranches = new Set();
				let coveredBranches = new Set();

				for (const {count, kind, start, end} of ranges) {
					// Fill in lines
					for (
						let i = start.line;
						i <= end.line;
						i = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(i)
					) {
						if (count === 0) {
							uncoveredLines.add(i);
						} else {
							coveredLines.add(i);
						}
					}

					// Mark covered kind
					if (kind === "function") {
						if (count === 0) {
							uncoveredBranches.add(
								___R$project$rome$$internal$parser$core$utils_ts$derivePositionKey(
									start,
								),
							);
							uncoveredFunctions.add(start.line);
						} else {
							coveredFunctions.add(start.line);
							coveredBranches.add(
								___R$project$rome$$internal$parser$core$utils_ts$derivePositionKey(
									start,
								),
							);
						}
					} else if (kind === "branch") {
						if (count === 0) {
							uncoveredBranches.add(
								___R$project$rome$$internal$parser$core$utils_ts$derivePositionKey(
									start,
								),
							);
						} else {
							coveredBranches.add(
								___R$project$rome$$internal$parser$core$utils_ts$derivePositionKey(
									start,
								),
							);
						}
					}
				}

				for (const line of coveredLines) {
					uncoveredLines.delete(line);
				}

				for (const index of coveredBranches) {
					uncoveredBranches.delete(index);
				}

				for (const index of coveredFunctions) {
					uncoveredFunctions.delete(index);
				}

				// No point showing fully covered files
				if (
					uncoveredLines.size === 0 &&
					uncoveredBranches.size === 0 &&
					uncoveredFunctions.size === 0
				) {
					continue;
				}

				files.push({
					filename,
					lines: ___R$$priv$project$rome$$internal$v8$CoverageCollector_ts$createCoverageFileStats(
						coveredLines.size,
						uncoveredLines.size,
					),
					branches: ___R$$priv$project$rome$$internal$v8$CoverageCollector_ts$createCoverageFileStats(
						coveredBranches.size,
						uncoveredBranches.size,
					),
					functions: ___R$$priv$project$rome$$internal$v8$CoverageCollector_ts$createCoverageFileStats(
						coveredFunctions.size,
						uncoveredFunctions.size,
					),
				});
			}
			return files;
		}
	}


  // project-rome/@internal/v8/index.ts



  // project-rome/ackage.json
const ___R$project$rome$ackage_json$default = {
		"name": "rome-root",
		"license": "MIT",
		"version": "10.0.4-beta",
		"engines": {"node": ">=12.8.1"},
		"//": "Look! No deps!",
		"dependencies": {},
		"///": "Only used for static type checking",
		"devDependencies": {
			"@types/node": "^14.0.14",
			"@types/react": "^16.9.41",
			"@types/react-dom": "^16.9.8",
			"@types/vscode": "^1.46.0",
			"typescript": "^4.0.0-beta",
		},
		"rome": {
			"root": true,
			"lint": {
				"ignore": [
					"build",
					"coverage",
					"node_modules",
					"core/static",
					"resources",
					"test-fixtures",
					"vendor",
					"type-libs",
					"lib/modules.js",
					"prelude.ts",
					"internal/web-ui",
					"out",
					"vscode/node_modules",
				],
			},
		},
	};


  // project-rome/@internal/core/common/constants.ts
const ___R$project$rome$$internal$core$common$constants_ts = {
		get CHILD_ARGS() {
			return ___R$project$rome$$internal$core$common$constants_ts$CHILD_ARGS;
		},
		getBinPath: ___R$project$rome$$internal$core$common$constants_ts$getBinPath,
		get VERSION() {
			return ___R$project$rome$$internal$core$common$constants_ts$VERSION;
		},
		get REQUIRED_NODE_VERSION_RANGE() {
			return ___R$project$rome$$internal$core$common$constants_ts$REQUIRED_NODE_VERSION_RANGE;
		},
		get MAX_MASTER_BYTES_BEFORE_WORKERS() {
			return ___R$project$rome$$internal$core$common$constants_ts$MAX_MASTER_BYTES_BEFORE_WORKERS;
		},
		get MAX_WORKER_BYTES_BEFORE_ADD() {
			return ___R$project$rome$$internal$core$common$constants_ts$MAX_WORKER_BYTES_BEFORE_ADD;
		},
		get MAX_WORKER_COUNT() {
			return ___R$project$rome$$internal$core$common$constants_ts$MAX_WORKER_COUNT;
		},
		get MOCKS_DIRECTORY_NAME() {
			return ___R$project$rome$$internal$core$common$constants_ts$MOCKS_DIRECTORY_NAME;
		},
		get LAG_INTERVAL() {
			return ___R$project$rome$$internal$core$common$constants_ts$LAG_INTERVAL;
		},
		get USER_CONFIG_DIRECTORY() {
			return ___R$project$rome$$internal$core$common$constants_ts$USER_CONFIG_DIRECTORY;
		},
		get USER_CONFIG_FILENAMES() {
			return ___R$project$rome$$internal$core$common$constants_ts$USER_CONFIG_FILENAMES;
		},
		get DEFAULT_USER_CONFIG_RECOVERY_DIRECTORY() {
			return ___R$project$rome$$internal$core$common$constants_ts$DEFAULT_USER_CONFIG_RECOVERY_DIRECTORY;
		},
		get DEFAULT_CACHE_PATH() {
			return ___R$project$rome$$internal$core$common$constants_ts$DEFAULT_CACHE_PATH;
		},
		get DATA_DIRECTORY() {
			return ___R$project$rome$$internal$core$common$constants_ts$DATA_DIRECTORY;
		},
		get RUNTIME_DIRECTORY() {
			return ___R$project$rome$$internal$core$common$constants_ts$RUNTIME_DIRECTORY;
		},
		get SERVER_SOCKET_PATH() {
			return ___R$project$rome$$internal$core$common$constants_ts$SERVER_SOCKET_PATH;
		},
		get CLI_SOCKET_PATH() {
			return ___R$project$rome$$internal$core$common$constants_ts$CLI_SOCKET_PATH;
		},
	};
	const ___R$$priv$project$rome$$internal$core$common$constants_ts$os = require(
		"os",
	);
	const ___R$project$rome$$internal$core$common$constants_ts$CHILD_ARGS = [
		"--max-old-space-size=8192",
		"--trace-warnings",
	];

	function ___R$project$rome$$internal$core$common$constants_ts$getBinPath() {
		return ___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
			__filename,
		);
	}

	const ___R$$priv$project$rome$$internal$core$common$constants_ts$MEGABYTE = 10_000;

	// Version constants
	let ___R$project$rome$$internal$core$common$constants_ts$VERSION = String(
		___R$project$rome$ackage_json$default.version,
	);
	let ___R$project$rome$$internal$core$common$constants_ts$REQUIRED_NODE_VERSION_RANGE = String(
		___R$project$rome$ackage_json$default.engines.node,
	);

	const ___R$project$rome$$internal$core$common$constants_ts$MAX_MASTER_BYTES_BEFORE_WORKERS =
		0.5 * ___R$$priv$project$rome$$internal$core$common$constants_ts$MEGABYTE;
	const ___R$project$rome$$internal$core$common$constants_ts$MAX_WORKER_BYTES_BEFORE_ADD = ___R$$priv$project$rome$$internal$core$common$constants_ts$MEGABYTE;
	const ___R$$priv$project$rome$$internal$core$common$constants_ts$CPU_COUNT = ___R$$priv$project$rome$$internal$core$common$constants_ts$os.cpus().length;
	const ___R$project$rome$$internal$core$common$constants_ts$MAX_WORKER_COUNT = Math.min(
		___R$$priv$project$rome$$internal$core$common$constants_ts$CPU_COUNT,
		4,
	);

	// Vendor Rome and Trunk Rome could have the same version number if there was no release in between
	// Ensure they are properly namespaced to avoid having daemon socket conflicts
	if (
		___R$project$rome$$internal$cli$environment$index_ts$getEnvVar("ROME_DEV").type ===
		"ENABLED"
	) {
		___R$project$rome$$internal$core$common$constants_ts$VERSION += "-dev";
	}

	// Misc
	const ___R$project$rome$$internal$core$common$constants_ts$MOCKS_DIRECTORY_NAME = "__rmocks__";

	const ___R$project$rome$$internal$core$common$constants_ts$LAG_INTERVAL = 3_000;

	// # Folders
	// XDG environment variables information:
	// - https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html
	// - https://docs.racket-lang.org/basedir/index.html
	function ___R$$priv$project$rome$$internal$core$common$constants_ts$getEnvironmentDirectory(
		key,
		append,
	) {
		const env = process.env[key];
		if (env === undefined) {
			return undefined;
		}

		let dir = ___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
			env,
		);
		if (append !== undefined) {
			dir = dir.append(append);
		}
		return dir;
	}

	function ___R$$priv$project$rome$$internal$core$common$constants_ts$getLocalAppDataDir() {
		return ___R$$priv$project$rome$$internal$core$common$constants_ts$getEnvironmentDirectory(
			"LOCALAPPDATA",
			"Rome",
		) == null
			? ___R$project$rome$$internal$path$index_ts$HOME_PATH.append(
					"AppData",
					"Local",
					"Rome",
				)
			: ___R$$priv$project$rome$$internal$core$common$constants_ts$getEnvironmentDirectory(
					"LOCALAPPDATA",
					"Rome",
				);
	}

	// ## User config directory
	// Where we store user configuration, recoverable files etc

	// XDG/Linux: ~/.config/rome
	// Windows: ~/AppData/Local/Rome/Config
	// Mac: ~/Library/Preferences/Rome
	function ___R$$priv$project$rome$$internal$core$common$constants_ts$getUserConfigDirectory() {
		const XDG_CONFIG_HOME = ___R$$priv$project$rome$$internal$core$common$constants_ts$getEnvironmentDirectory(
			"XDG_CONFIG_HOME",
			"rome",
		);
		if (XDG_CONFIG_HOME !== undefined) {
			return XDG_CONFIG_HOME;
		}

		if (process.platform === "win32") {
			return ___R$$priv$project$rome$$internal$core$common$constants_ts$getLocalAppDataDir().append(
				"Config",
			);
		}

		if (process.platform === "darwin") {
			return ___R$project$rome$$internal$path$index_ts$HOME_PATH.append(
				"Library",
				"Preferences",
				"Rome",
			);
		}

		return ___R$project$rome$$internal$path$index_ts$HOME_PATH.append(
			".config",
			"rome",
		);
	}

	const ___R$project$rome$$internal$core$common$constants_ts$USER_CONFIG_DIRECTORY = ___R$$priv$project$rome$$internal$core$common$constants_ts$getUserConfigDirectory();
	const ___R$project$rome$$internal$core$common$constants_ts$USER_CONFIG_FILENAMES = [
		"config.json",
		"config.rjson",
	];

	const ___R$project$rome$$internal$core$common$constants_ts$DEFAULT_USER_CONFIG_RECOVERY_DIRECTORY = ___R$project$rome$$internal$core$common$constants_ts$USER_CONFIG_DIRECTORY.append(
		"recovery",
	);

	// ## Cache
	// User specific non-essential data files
	// XDG/Linux: ~/.cache/rome
	// Windows: ~/AppData/Local/Temp/Rome
	// Mac: ~/Library/Caches/Rome
	function ___R$$priv$project$rome$$internal$core$common$constants_ts$getCacheDirectory() {
		const XDG_CACHE_HOME = ___R$$priv$project$rome$$internal$core$common$constants_ts$getEnvironmentDirectory(
			"XDG_CACHE_HOME",
			"rome",
		);
		if (XDG_CACHE_HOME !== undefined) {
			return XDG_CACHE_HOME;
		}

		if (process.platform === "win32") {
			// process.env.TEMP also exists, but most apps put caches here
			return ___R$$priv$project$rome$$internal$core$common$constants_ts$getLocalAppDataDir().append(
				"Cache",
			);
		}

		if (process.platform === "darwin") {
			return ___R$project$rome$$internal$path$index_ts$HOME_PATH.append(
				"Library",
				"Caches",
				"Rome",
			);
		}

		return ___R$project$rome$$internal$path$index_ts$HOME_PATH.append(
			".cache",
			"rome",
		);
	}

	const ___R$project$rome$$internal$core$common$constants_ts$DEFAULT_CACHE_PATH = ___R$$priv$project$rome$$internal$core$common$constants_ts$getCacheDirectory();

	// ## Data
	// User specific data files
	// XDG/Linux: ~/.local/share/rome
	// Windows: ~/AppData/Local/Rome/Data
	// Mac: ~/Library/Rome
	function ___R$$priv$project$rome$$internal$core$common$constants_ts$getDataDirectory() {
		const XDG_DATA_HOME = ___R$$priv$project$rome$$internal$core$common$constants_ts$getEnvironmentDirectory(
			"XDG_DATA_HOME",
			"rome",
		);
		if (XDG_DATA_HOME !== undefined) {
			return XDG_DATA_HOME;
		}

		if (process.platform === "win32") {
			return ___R$$priv$project$rome$$internal$core$common$constants_ts$getLocalAppDataDir().append(
				"Data",
			);
		}

		if (process.platform === "darwin") {
			return ___R$project$rome$$internal$path$index_ts$HOME_PATH.append(
				"Library",
				"Rome",
			);
		}

		return ___R$project$rome$$internal$path$index_ts$HOME_PATH.append(
			".local",
			"share",
			"rome",
		);
	}

	const ___R$project$rome$$internal$core$common$constants_ts$DATA_DIRECTORY = ___R$$priv$project$rome$$internal$core$common$constants_ts$getDataDirectory();

	// ## Runtime
	// Ephemeral things like pipes and sockets or other objects restricted to the current run of the program
	// > The directory MUST be owned by the user, and MUST be the only one having read and write access to it.
	// > Its Unix access mode MUST be 0700.
	// XDG/Linux: /run/user/$(id -u)
	// Windows: $TEMP/rome
	// Mac: $TEMP/rome
	function ___R$$priv$project$rome$$internal$core$common$constants_ts$getRuntimeDirectory() {
		const XDG_RUNTIME_DIR = ___R$$priv$project$rome$$internal$core$common$constants_ts$getEnvironmentDirectory(
			"XDG_RUNTIME_DIR",
			"rome",
		);
		if (XDG_RUNTIME_DIR !== undefined) {
			return XDG_RUNTIME_DIR;
		}

		return ___R$project$rome$$internal$path$index_ts$TEMP_PATH.append("rome");
	}

	const ___R$project$rome$$internal$core$common$constants_ts$RUNTIME_DIRECTORY = ___R$$priv$project$rome$$internal$core$common$constants_ts$getRuntimeDirectory();

	function ___R$$priv$project$rome$$internal$core$common$constants_ts$createPipePath(
		name,
	) {
		if (process.platform === "win32") {
			return ___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
				String.raw`\\.\pipe\rome-${___R$project$rome$$internal$core$common$constants_ts$VERSION}-${name}`,
			);
		} else {
			return ___R$project$rome$$internal$core$common$constants_ts$RUNTIME_DIRECTORY.append(
				___R$project$rome$$internal$core$common$constants_ts$VERSION +
				"-wait.sock",
			);
		}
	}

	const ___R$project$rome$$internal$core$common$constants_ts$SERVER_SOCKET_PATH = ___R$$priv$project$rome$$internal$core$common$constants_ts$createPipePath(
		"server",
	);
	const ___R$project$rome$$internal$core$common$constants_ts$CLI_SOCKET_PATH = ___R$$priv$project$rome$$internal$core$common$constants_ts$createPipePath(
		"server-wait",
	);


  // project-rome/@internal/core/common/types/client.ts
const ___R$project$rome$$internal$core$common$types$client_ts = {
		get DEFAULT_CLIENT_FLAGS() {
			return ___R$project$rome$$internal$core$common$types$client_ts$DEFAULT_CLIENT_FLAGS;
		},
		get DEFAULT_CLIENT_REQUEST_FLAGS() {
			return ___R$project$rome$$internal$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS;
		},
	};
	const ___R$project$rome$$internal$core$common$types$client_ts$DEFAULT_CLIENT_FLAGS = {
		clientName: "unknown",
		cwd: ___R$project$rome$$internal$path$index_ts$CWD_PATH,
		realCwd: ___R$project$rome$$internal$path$index_ts$CWD_PATH,
		silent: false,
	};

	const ___R$project$rome$$internal$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS = Object.assign(
		{},
		___R$project$rome$$internal$cli$diagnostics$DiagnosticsPrinter_ts$DEFAULT_PRINTER_FLAGS,
		{
			unsafeWrites: false,
			showAllDiagnostics: false,
			collectMarkers: false,
			timing: false,
			benchmark: false,
			benchmarkIterations: 10,
			watch: false,
			review: false,
			resolverPlatform: undefined,
			resolverScale: undefined,
			resolverMocks: false,
		},
	);



  // project-rome/@internal/core/common/commands.ts
const ___R$project$rome$$internal$core$common$commands_ts$commandCategories = {
		PROCESS_MANAGEMENT: "Process Management",
		CODE_QUALITY: "Code Quality",
		SOURCE_CODE: "Source Code",
		PROJECT_MANAGEMENT: "Project Management",
		SOURCE_CONTROL: "Source Control",
		INTERNAL: "Internal",
	};


  // project-rome/@internal/core/client/commands/start.ts
const ___R$project$rome$$internal$core$client$commands$start_ts$default = ___R$project$rome$$internal$core$client$commands_ts$createLocalCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.PROCESS_MANAGEMENT,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`start daemon (if none running)`,
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback(req) {
			const existingServer = await req.client.tryConnectToExistingDaemon();
			if (existingServer) {
				req.client.reporter.success(
					___R$project$rome$$internal$markup$escape_ts$markup`Already running server.`,
				);
				return true;
			}

			const bridge = await req.client.startDaemon();
			return bridge !== undefined;
		},
	});


  // project-rome/@internal/core/client/commands/develop.ts
const ___R$project$rome$$internal$core$client$commands$develop_ts$default = ___R$project$rome$$internal$core$client$commands_ts$createLocalCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.PROCESS_MANAGEMENT,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`TODO`,
		usage: "",
		examples: [],
		hidden: true,
		defineFlags() {
			return {};
		},
		async callback(req) {
			const existingServer = await req.client.tryConnectToExistingDaemon();
			const hasExistingServer = existingServer !== undefined;

			if (!hasExistingServer) {
				await req.client.forceStartDaemon();
			}

			await req.client.query(
				Object.assign({}, req.query, {terminateWhenIdle: true}),
				"server",
			);

			return true;
		},
	});


  // project-rome/@internal/core/client/commands/stop.ts
const ___R$project$rome$$internal$core$client$commands$stop_ts$default = ___R$project$rome$$internal$core$client$commands_ts$createLocalCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.PROCESS_MANAGEMENT,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`stop a running daemon if one exists`,
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback(req) {
			// We might want to use `terminateWhenIdle` here combined with a timeout instead of forcing it to die straight away
			const {reporter} = req.client;
			const bridge = await req.client.tryConnectToExistingDaemon();
			if (bridge) {
				const stop = await req.client.query(
					{
						commandName: "stop",
					},
					"server",
				);
				if (stop.type === "CANCELLED") {
					reporter.success(
						___R$project$rome$$internal$markup$escape_ts$markup`Stopped server.`,
					);
				} else {
					reporter.error(
						___R$project$rome$$internal$markup$escape_ts$markup`Failed to stop server.`,
					);
					return false;
				}
			} else {
				reporter.warn(
					___R$project$rome$$internal$markup$escape_ts$markup`No running server to stop.`,
				);
			}
			return true;
		},
	});


  // project-rome/@internal/core/common/utils/executeMain.ts
const ___R$$priv$project$rome$$internal$core$common$utils$executeMain_ts$internalModule = require(
		"module",
	);
	const ___R$$priv$project$rome$$internal$core$common$utils$executeMain_ts$vm = require(
		"vm",
	);
	async function ___R$project$rome$$internal$core$common$utils$executeMain_ts$default(
		opts,
	) {
		const {path, code, sourceMap, globals = {}, args = []} = opts;

		const filename = path.join();

		// Create global context
		const sandbox = Object.assign(
			{
				// TODO Find a more reliable way to do this
				TextEncoder,
				TextDecoder,
				Buffer,
				clearImmediate,
				clearInterval,
				clearTimeout,
				setImmediate,
				setInterval,
				setTimeout,
				require: ___R$$priv$project$rome$$internal$core$common$utils$executeMain_ts$internalModule.createRequire
					? ___R$$priv$project$rome$$internal$core$common$utils$executeMain_ts$internalModule.createRequire(
							filename,
						)
					: ___R$$priv$project$rome$$internal$core$common$utils$executeMain_ts$internalModule.createRequireFromPath(
							filename,
						),
				console,
				__dirname: path.getParent().join(),
				__filename: filename,
			},
			globals,
			{
				process: Object.setPrototypeOf(
					Object.assign(
						{argv: ["rome", "run", filename, "--", ...args]},
						globals.process,
					),
					process,
				),
			},
		);
		sandbox.global = sandbox;
		const context = ___R$$priv$project$rome$$internal$core$common$utils$executeMain_ts$vm.createContext(
			sandbox,
		);

		// Here we do some gymnastics to catch a syntax error to correctly identify it as being our fault
		let script;
		try {
			script = new ___R$$priv$project$rome$$internal$core$common$utils$executeMain_ts$vm.Script(
				code,
				{
					filename,
					displayErrors: true,
				},
			);
		} catch (err) {
			if (err instanceof SyntaxError && err.stack !== undefined) {
				const lineMatch = err.stack.match(/^(.*?):(\d+)/);
				if (lineMatch == null) {
					throw err;
				}

				const line = Number(lineMatch[2]);

				const pos = {
					column: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
					line: ___R$project$rome$$internal$ob1$index_ts$ob1Coerce1(line),
				};

				const syntaxError = {
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.V8.SYNTAX_ERROR(
						err.message,
					),
					location: {
						start: pos,
						end: pos,
						filename,
						sourceText: ___R$project$rome$$internal$diagnostics$helpers_ts$truncateSourceText(
							code,
							pos,
							pos,
						),
					},
					tags: {
						internal: true,
					},
				};
				return {syntaxError, exitCode: undefined};
			}

			throw err;
		}

		// Execute the script if there was no syntax error
		if (sourceMap !== undefined) {
			___R$project$rome$$internal$v8$sourceMapManager_ts$default.add(
				filename,
				sourceMap,
			);
		}
		const res = await script.runInContext(context);

		let exitCode;

		if (typeof res === "object" && res != null && typeof res.main === "function") {
			let code = await Promise.resolve(res.main(args));
			if (typeof code === "number") {
				exitCode = code;
			} else {
				exitCode = 0;
			}
		}

		return {syntaxError: undefined, exitCode};
	}


  // project-rome/@internal/core/client/commands/run.ts
const ___R$project$rome$$internal$core$client$commands$run_ts$default = ___R$project$rome$$internal$core$client$commands_ts$createLocalCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.PROJECT_MANAGEMENT,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`TODO`,
		usage: "",
		examples: [],
		hidden: ___R$project$rome$$internal$cli$environment$index_ts$getEnvVar(
			"ROME_DEV",
		).type !== "ENABLED",
		defineFlags() {
			return {};
		},
		async callback(req) {
			const bridge = await req.client.findOrStartServer();
			if (bridge === undefined) {
				return false;
			}

			process.on(
				"unhandledRejection",
				(error) => {
					error;
				},
			);

			const res = await req.client.query(
				{
					commandName: "run",
					args: req.query.args,
				},
				"server",
			);

			if (res.type !== "SUCCESS") {
				return false;
			}

			const data = ___R$project$rome$$internal$consume$index_ts$consumeUnknown(
				res.data,
				"parse/json",
			);

			if (data.exists()) {
				const type = data.get("type").asString();

				switch (type) {
					case "executeCode": {
						const {syntaxError, exitCode} = await ___R$project$rome$$internal$core$common$utils$executeMain_ts$default({
							// Remove the first argument which will be the file path
							args: data.get("args").asMappedArray((item) => item.asString()),
							path: ___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
								data.get("filename").asString(),
							),
							code: data.get("code").asString(),
							sourceMap: ___R$project$rome$$internal$codec$source$map$SourceMapConsumer_ts$default.fromJSON(
								data.get("map").asAny(),
							),
						});
						if (syntaxError !== undefined) {
							throw ___R$project$rome$$internal$diagnostics$errors_ts$createSingleDiagnosticError(
								syntaxError,
							);
						}
						if (exitCode !== undefined) {
							return {
								type: "EXIT",
								code: exitCode,
								markers: [],
							};
						}
						break;
					}
				}
			}

			return true;
		},
	});


  // project-rome/@internal/core/client/commands/restart.ts
const ___R$project$rome$$internal$core$client$commands$restart_ts$default = ___R$project$rome$$internal$core$client$commands_ts$createLocalCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.PROCESS_MANAGEMENT,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`restart daemon`,
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback(req) {
			const stopped = await req.client.query({
				commandName: "stop",
			});

			if (stopped.type === "SUCCESS" && stopped.data === true) {
				const started = await req.client.query({
					commandName: "start",
				});
				return started.type === "SUCCESS" && started.data === true;
			} else {
				return false;
			}
		},
	});


  // project-rome/@internal/core/client/commands/status.ts
const ___R$project$rome$$internal$core$client$commands$status_ts$default = ___R$project$rome$$internal$core$client$commands_ts$createLocalCommand({
		description: ___R$project$rome$$internal$markup$escape_ts$markup`get the current daemon status`,
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.PROCESS_MANAGEMENT,
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback(req) {
			const {reporter} = req.client;
			const bridge = await req.client.tryConnectToExistingDaemon();
			if (bridge) {
				const status = await req.client.query(
					{
						commandName: "status",
					},
					"server",
				);
				if (status.type === "SUCCESS") {
					reporter.inspect(status.data);
					return true;
				} else {
					return false;
				}
			} else {
				reporter.error(
					___R$project$rome$$internal$markup$escape_ts$markup`Server not running.`,
				);
				return false;
			}
		},
	});


  // project-rome/@internal/core/client/commands/lsp.ts
const ___R$project$rome$$internal$core$client$commands$lsp_ts$default = ___R$project$rome$$internal$core$client$commands_ts$createLocalCommand({
		description: ___R$project$rome$$internal$markup$escape_ts$markup`connect to an lsp`,
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.PROJECT_MANAGEMENT,
		usage: "",
		examples: [],
		// vscode-languageclient adds these on
		ignoreFlags: ["stdio", "clientProcessId"],
		defineFlags() {
			return {};
		},
		async callback(req) {
			req.client.setFlags({
				clientName: "lsp",
				silent: true,
			});

			const stdin = req.client.reporter.getStdin();

			const bridge = await req.client.findOrStartServer();
			if (bridge === undefined) {
				return false;
			}

			const {stream} = req.client.derivedReporterStreams.handle;

			bridge.lspFromServerBuffer.subscribe((chunk) => {
				stream.write(chunk, false);
			});

			stdin.on(
				"data",
				(chunk) => {
					bridge.lspFromClientBuffer.call(chunk.toString());
				},
			);

			await req.client.query(
				{
					commandName: "lsp",
				},
				"server",
			);

			return true;
		},
	});


  // project-rome/@internal/core/client/commands.ts
function ___R$project$rome$$internal$core$client$commands_ts$createLocalCommand(
		cmd,
	) {
		return cmd;
	}

	const ___R$project$rome$$internal$core$client$commands_ts$localCommands = new Map();
	___R$project$rome$$internal$core$client$commands_ts$localCommands.set(
		"start",
		___R$project$rome$$internal$core$client$commands$start_ts$default,
	);
	___R$project$rome$$internal$core$client$commands_ts$localCommands.set(
		"develop",
		___R$project$rome$$internal$core$client$commands$develop_ts$default,
	);
	___R$project$rome$$internal$core$client$commands_ts$localCommands.set(
		"stop",
		___R$project$rome$$internal$core$client$commands$stop_ts$default,
	);
	___R$project$rome$$internal$core$client$commands_ts$localCommands.set(
		"run",
		___R$project$rome$$internal$core$client$commands$run_ts$default,
	);
	___R$project$rome$$internal$core$client$commands_ts$localCommands.set(
		"restart",
		___R$project$rome$$internal$core$client$commands$restart_ts$default,
	);
	___R$project$rome$$internal$core$client$commands_ts$localCommands.set(
		"status",
		___R$project$rome$$internal$core$client$commands$status_ts$default,
	);
	___R$project$rome$$internal$core$client$commands_ts$localCommands.set(
		"lsp",
		___R$project$rome$$internal$core$client$commands$lsp_ts$default,
	);


  // project-rome/@internal/core/server/fs/glob.ts
const ___R$$priv$project$rome$$internal$core$server$fs$glob_ts$GLOB_IGNORE = [
		___R$project$rome$$internal$path$match$parse_ts$parsePattern({
			input: "node_modules",
		}),
	];

	function ___R$$priv$project$rome$$internal$core$server$fs$glob_ts$concatGlobIgnore(
		patterns,
	) {
		// If there are any negate patterns then it'll never include GLOB_IGNORE
		for (const pattern of patterns) {
			if (pattern.type === "PathPattern" && pattern.negate) {
				return patterns;
			}
		}

		return [
			...___R$$priv$project$rome$$internal$core$server$fs$glob_ts$GLOB_IGNORE,
			...patterns,
		];
	}

	class ___R$project$rome$$internal$core$server$fs$glob_ts$Globber {
		constructor(server, opts) {
			this.opts = opts;
			this.server = server;
			this.memoryFs = server.memoryFs;
			this.ignoresByProject = new WeakMap();
			this.args = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet(
				opts.args,
			);
		}

		getIgnore(path) {
			const {configCategory, overrideIgnore} = this.opts;
			const project = this.server.projectManager.findLoadedProject(path);

			let ignore = overrideIgnore == null ? [] : overrideIgnore;
			if (configCategory === undefined || project === undefined) {
				return ignore;
			}

			const projectIgnore = this.ignoresByProject.get(project);
			if (projectIgnore === undefined) {
				ignore = ___R$$priv$project$rome$$internal$core$server$fs$glob_ts$concatGlobIgnore([
					...ignore,
					...project.config[configCategory].ignore,
				]);
				this.ignoresByProject.set(project, ignore);
				return ignore;
			} else {
				return projectIgnore;
			}
		}

		search(cwd) {
			const {extensions, test} = this.opts;
			const {memoryFs} = this;

			const matches = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet();

			let queue = [{cwd, path: cwd}];

			while (queue.length > 0) {
				const {path, cwd} = queue.pop();

				const ignore = this.getIgnore(path);
				const ignoreMatched = ___R$project$rome$$internal$path$match$index_ts$matchPathPatterns(
					path,
					ignore,
					cwd,
				);

				// Don't even recurse into explicit matches
				if (ignoreMatched === "EXPLICIT_MATCH") {
					continue;
				}

				// Add if a matching file
				if (memoryFs.isFile(path) && ignoreMatched === "NO_MATCH") {
					if (test !== undefined && !test(path)) {
						continue;
					}

					// Check extensions
					if (extensions !== undefined) {
						let matchedExt = false;
						for (const ext of extensions) {
							matchedExt = path.hasEndExtension(ext);
							if (matchedExt) {
								break;
							}
						}
						if (!matchedExt) {
							continue;
						}
					}

					matches.add(path);
					continue;
				}

				// Crawl if we're a directory
				// NOTE: We still continue crawling on implicit matches
				if (memoryFs.isDirectory(path)) {
					for (const subpath of memoryFs.readdir(path)) {
						queue.push({cwd, path: subpath});
					}
				}

				// TODO maybe throw? not a file or directory, doesn't exist!
			}

			return matches;
		}

		async get(safe = true) {
			let paths = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet();

			for (const arg of this.args) {
				// Make sure project has been initialized
				await this.server.projectManager.findProject(arg);

				const subPaths = this.search(arg);

				if (safe && subPaths.size === 0 && this.opts.onSearchNoMatch) {
					await this.opts.onSearchNoMatch(arg);
				}

				paths = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet([
					...paths,
					...subPaths,
				]);
			}

			return paths;
		}

		async watch(callback) {
			const watcher = new ___R$$priv$project$rome$$internal$core$server$fs$glob_ts$GlobberWatcher(
				this,
				this.server,
				this.args,
				callback,
			);

			const sub = await watcher.init();

			if (this.opts.onWatch !== undefined) {
				this.opts.onWatch(sub);
			}

			return sub;
		}
	}

	class ___R$$priv$project$rome$$internal$core$server$fs$glob_ts$GlobberWatcher {
		constructor(globber, server, args, callback) {
			this.globber = globber;
			this.server = server;
			this.memoryFs = server.memoryFs;

			this.callback = callback;
			this.args = args;
			this.flushLock = new ___R$project$rome$$internal$async$lockers_ts$GlobalLock();

			this.batchPaths = undefined;
		}

		isDependentPath(path) {
			for (const arg of this.args) {
				if (path.equal(arg) || path.isRelativeTo(arg)) {
					return true;
				}
			}
			return false;
		}

		async flushPaths(paths) {
			let pendingPaths = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet();
			for (const path of paths) {
				if (this.isDependentPath(path)) {
					const paths = this.globber.search(path);
					for (const path of paths) {
						if (this.batchPaths === undefined) {
							pendingPaths.add(path);
						} else {
							this.batchPaths.add(path);
						}
					}
				}
			}
			if (pendingPaths.size > 0) {
				await this.flush(pendingPaths);
			}
		}

		async flush(paths, initial = false) {
			await this.flushLock.wrap(async () => {
				// We could be evicting a project as the result of a modification made inside of the watch callback
				// Ensure it's complete before we decide to flush
				await this.server.memoryFs.processingLock.wait();

				if (paths.size === 0 && !initial) {
					return;
				}

				await this.callback({paths, initial});
			});
		}

		setupEvents() {
			const {memoryFs, server} = this;
			const subscriptions = [];

			// Emitted when a file appears for the first time
			subscriptions.push(
				memoryFs.newFileEvent.subscribe((paths) => {
					this.flushPaths(paths);
				}),
			);

			subscriptions.push(
				server.refreshFileEvent.subscribe((paths) => {
					this.flushPaths(paths);
				}),
			);

			return subscriptions;
		}

		async init() {
			const {memoryFs} = this;
			const subs = this.setupEvents();
			const finalSubs = ___R$project$rome$$internal$events$utils_ts$mergeEventSubscriptions([
				...subs,
				{
					unsubscribe: async () => {
						await this.flushLock.wait();
					},
				},
			]);

			try {
				const promises = [];
				const batchPaths = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet();
				this.batchPaths = batchPaths;

				// Determine what arguments are not available in the memory file system
				for (const arg of this.args) {
					// exists returns undefined when it's not available
					if (memoryFs.exists(arg) === undefined) {
						promises.push(this.server.projectManager.findProject(arg));
					} else {
						promises.push(this.flushPaths([arg]));
					}
				}

				await Promise.all(promises);
				this.batchPaths = undefined;
				await this.flush(batchPaths, true);
				await this.globber.get(true);

				return finalSubs;
			} catch (err) {
				await finalSubs.unsubscribe();
				throw err;
			}
		}
	}


  // project-rome/@internal/core/server/ServerRequest.ts
const ___R$$priv$project$rome$$internal$core$server$ServerRequest_ts$crypto = require(
		"crypto",
	);
	let ___R$$priv$project$rome$$internal$core$server$ServerRequest_ts$requestIdCounter = 0;

	const ___R$project$rome$$internal$core$server$ServerRequest_ts$EMPTY_SUCCESS_RESPONSE = {
		type: "SUCCESS",
		hasData: false,
		data: undefined,
		markers: [],
		files: {},
	};

	async function ___R$$priv$project$rome$$internal$core$server$ServerRequest_ts$globUnmatched(
		req,
		opts,
		path,
		location,
	) {
		const {server} = req;
		const {configCategory, ignoreProjectIgnore} = opts;

		let category = "args/fileNotFound";

		let advice = [...(opts.advice || [])];

		// Hint if all files were ignored
		if (configCategory !== undefined && !ignoreProjectIgnore) {
			const globber = await req.glob(
				Object.assign({}, opts, {ignoreProjectIgnore: true}),
			);
			const withoutIgnore = await globber.get(false);

			if (withoutIgnore.size > 0) {
				advice.push({
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`The following files were ignored`,
				});

				advice.push({
					type: "list",
					list: Array.from(
						withoutIgnore,
						(path) =>
							___R$project$rome$$internal$markup$escape_ts$markup`${path}`
						,
					),
					truncate: true,
				});

				const ignoreSource = server.projectManager.findProjectConfigConsumer(
					await req.server.projectManager.assertProject(path, location),
					(consumer) =>
						consumer.has(configCategory) &&
						consumer.get(configCategory).get("ignore")
					,
				);

				if (ignoreSource.value !== undefined) {
					const ignorePointer = ignoreSource.value.getDiagnosticLocation(
						"value",
					);

					advice.push({
						type: "log",
						category: "info",
						text: ___R$project$rome$$internal$markup$escape_ts$markup`Ignore patterns were defined here`,
					});

					advice.push({
						type: "frame",
						location: ignorePointer,
					});
				}
			}
		}

		throw ___R$project$rome$$internal$diagnostics$errors_ts$createSingleDiagnosticError({
			location: Object.assign(
				{},
				location,
				{marker: ___R$project$rome$$internal$markup$escape_ts$markup`${path}`},
			),
			description: Object.assign(
				{},
				___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.FLAGS.NO_FILES_FOUND(
					opts.noun,
				),
				{category, advice},
			),
		});
	}

	class ___R$project$rome$$internal$core$server$ServerRequest_ts$ServerRequestInvalid
		extends ___R$project$rome$$internal$diagnostics$errors_ts$DiagnosticsError {
		constructor(message, diagnostics, showHelp) {
			super(message, diagnostics);
			this.showHelp = showHelp;
		}
	}

	function ___R$$priv$project$rome$$internal$core$server$ServerRequest_ts$hash(
		val,
	) {
		return val === undefined || Object.keys(val).length === 0
			? "none"
			: ___R$$priv$project$rome$$internal$core$server$ServerRequest_ts$crypto.createHash(
					"sha256",
				).update(JSON.stringify(val)).digest("hex");
	}

	class ___R$project$rome$$internal$core$server$ServerRequest_ts$ServerRequestCancelled
		extends Error {
		constructor(reason) {
			super(
				"ServerRequest has been cancelled. This error is meant to be seen by Server",
			);

			this.reason = reason;
		}
	}

	class ___R$project$rome$$internal$core$server$ServerRequest_ts$default {
		constructor({query, server, client}) {
			this.query = query;
			this.server = server;
			this.bridge = client.bridge;
			this.reporter = query.silent
				? new ___R$project$rome$$internal$cli$reporter$Reporter_ts$default()
				: client.reporter.fork();
			this.client = client;

			this.start = Date.now();
			this.id = ___R$$priv$project$rome$$internal$core$server$ServerRequest_ts$requestIdCounter++;
			this.cancelledReason = undefined;
			this.toredown = false;
			this.markers = [];
			this.normalizedCommandFlags = {
				flags: {},
				defaultFlags: {},
			};
			this.files = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();

			this.logger = server.logger.namespace(
				___R$project$rome$$internal$markup$escape_ts$markup`[ServerRequest] Request #${this.id}:`,
			);

			this.markerEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "ServerRequest.marker",
			});
			this.cancelEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "ServerRequest.cancel",
			});
			this.endEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "ServerRequest.end",
				serial: true,
			});

			this.client.requestsInFlight.add(this);
		}

		queueSaveFile(path, opts) {
			this.files.set(path, opts);
		}

		async flushFiles() {
			const {files} = this;
			const {server} = this;
			const {logger} = server;

			if (files.size === 0) {
				this.logger.info(
					___R$project$rome$$internal$markup$escape_ts$markup`No files to write`,
				);
				return 0;
			} else if (this.query.noFileWrites) {
				this.logger.info(
					___R$project$rome$$internal$markup$escape_ts$markup`Writing no files due to noFileWrites flag being set`,
				);
				return 0;
			}

			this.files = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();

			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Flushing files`,
			);
			logger.list(
				Array.from(
					files.keys(),
					(path) => ___R$project$rome$$internal$markup$escape_ts$markup`${path}`,
				),
			);

			// Need to capture this before as it will be modified by server.writeFiles
			const totalFiles = files.size;

			await this.server.recoveryStore.writeFiles(
				files,
				{
					unsafeWrites: this.query.requestFlags.unsafeWrites,
				},
				{
					onFileDone: () => {
						// Maybe a progress bar later?
					},
					beforeFileWrite: async (path, fd) => {
						const content = await fd.readFile();
						await this.server.recoveryStore.save(this, path, content);
					},
					unexpectedModified: (path, expectedMtime, actualMtime) => {
						this.logger.info(
							___R$project$rome$$internal$markup$escape_ts$markup`Skipped writing file ${path} as the mtime ${actualMtime} of the file on disk was newer than when we read it at ${expectedMtime}`,
						);
						this.reporter.warn(
							___R$project$rome$$internal$markup$escape_ts$markup`File <emphasis>${path}</emphasis> was not updated as it was changed since we read it`,
						);
					},
					expectedExists: (path) => {
						this.logger.info(
							___R$project$rome$$internal$markup$escape_ts$markup`Skipped writing file ${path} as it does not exist when we expected it to`,
						);
						this.reporter.warn(
							___R$project$rome$$internal$markup$escape_ts$markup`File <emphasis>${path}</emphasis> was not updated as it does not exist when we expected it to`,
						);
					},
					unexpectedExists: (path) => {
						this.logger.info(
							___R$project$rome$$internal$markup$escape_ts$markup`Skipped writing file ${path} as it exists when we didn't expect it`,
						);
						this.reporter.warn(
							___R$project$rome$$internal$markup$escape_ts$markup`File <emphasis>${path}</emphasis> was not written as it exists when we didn't expect it`,
						);
					},
				},
			);

			await this.server.recoveryStore.commit(this);
			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Flushed ${totalFiles} files`,
			);

			return totalFiles;
		}

		updateRequestFlags(flags) {
			this.query = Object.assign(
				{},
				this.query,
				{requestFlags: Object.assign({}, this.query.requestFlags, flags)},
			);
		}

		async init() {
			if (this.query.requestFlags.collectMarkers) {
				this.markerEvent.subscribe((marker) => {
					this.markers.push(marker);
				});
			}

			await this.server.handleRequestStart(this);
		}

		checkCancelled() {
			if (this.cancelledReason !== undefined) {
				throw new ___R$project$rome$$internal$core$server$ServerRequest_ts$ServerRequestCancelled(
					this.cancelledReason,
				);
			}
		}

		async cancel(reason) {
			await this.cancelEvent.callOptional();
			this.cancelledReason = reason;
			await this.teardown({
				type: "CANCELLED",
				reason,
				markers: [],
			});
		}

		async teardown(res) {
			if (this.toredown) {
				return;
			}

			this.toredown = true;
			this.client.requestsInFlight.delete(this);

			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Response type: ${String(
					res == null ? undefined : res.type,
				)}`,
			);
			if (res.type === "DIAGNOSTICS") {
				this.logDiagnostics(res.diagnostics);
			}

			// Output timing information
			if (this.query.requestFlags.timing) {
				const end = Date.now();
				this.reporter.info(
					___R$project$rome$$internal$markup$escape_ts$markup`Request took <duration emphasis>${String(
						end - this.start,
					)}</duration>`,
				);
			}

			// If the query asked for no data then strip all diagnostics and data values
			if (this.query.noData) {
				switch (res.type) {
					case "SUCCESS": {
						res = Object.assign(
							{},
							___R$project$rome$$internal$core$server$ServerRequest_ts$EMPTY_SUCCESS_RESPONSE,
							{hasData: res.data !== undefined},
						);
						break;
					}

					case "DIAGNOSTICS": {
						res = {
							type: "DIAGNOSTICS",
							hasDiagnostics: res.hasDiagnostics,
							diagnostics: [],
							markers: [],
							files: {},
						};
						break;
					}

					case "INVALID_REQUEST": {
						res = {
							type: "INVALID_REQUEST",
							diagnostics: [],
							markers: [],
							showHelp: res.showHelp,
						};
						break;
					}
				}
			} else {
				switch (res.type) {
					case "SUCCESS":
					case "DIAGNOSTICS": {
						const files = {};
						for (const [path, opts] of this.files) {
							files[path.join()] = opts;
						}
						res = Object.assign({}, res, {files});
						break;
					}
				}
			}

			if (res.type === "DIAGNOSTICS" || res.type === "SUCCESS") {
				await this.flushFiles();
			}

			// Add on markers
			res = Object.assign({}, res, {markers: this.markers});

			await this.endEvent.callOptional(res);
			await this.server.handleRequestEnd(this);
			return res;
		}

		setNormalizedCommandFlags(normalized) {
			this.normalizedCommandFlags = normalized;
		}

		async resolveEntryAssertPathArg(index, max = true) {
			this.expectArgumentLength(index + 1, max ? undefined : Infinity);
			const arg = this.query.args[index];

			return await this.server.resolver.resolveEntryAssertPath(
				Object.assign(
					{},
					this.getResolverOptionsFromFlags(),
					{
						source: ___R$project$rome$$internal$path$index_ts$createUnknownPath(
							arg,
						),
					},
				),
				{
					location: this.getDiagnosticLocationFromFlags({
						type: "arg",
						key: index,
					}),
				},
			);
		}

		async assertClientCwdProject() {
			const location = this.getDiagnosticLocationForClientCwd();
			return this.server.projectManager.assertProject(
				this.client.flags.cwd,
				location,
			);
		}

		async getVCSClient() {
			return this.server.projectManager.getVCSClient(
				await this.assertClientCwdProject(),
			);
		}

		async maybeGetVCSClient() {
			return this.server.projectManager.maybeGetVCSClient(
				await this.assertClientCwdProject(),
			);
		}

		logDiagnostics(diagnostics) {
			for (const diag of diagnostics) {
				this.logger.error(
					___R$project$rome$$internal$markup$escape_ts$markup`Encountered diagnostic: ${diag.description.message}. Category: ${diag.description.category}. Location: ${___R$project$rome$$internal$diagnostics$helpers_ts$diagnosticLocationToMarkupFilelink(
						diag.location,
					)}`,
				);
			}
		}

		async printDiagnostics(
			{diagnostics, suppressions = [], printerOptions, excludeFooter},
		) {
			this.logDiagnostics(diagnostics);

			await ___R$project$rome$$internal$cli$diagnostics$index_ts$printDiagnostics({
				diagnostics,
				suppressions,
				excludeFooter: excludeFooter !== false,
				printerOptions: Object.assign(
					{
						reporter: this.reporter,
						processor: this.createDiagnosticsProcessor(),
						wrapErrors: true,
					},
					printerOptions,
				),
			});
		}

		createDiagnosticsProcessor(opts = {}) {
			return new ___R$project$rome$$internal$diagnostics$DiagnosticsProcessor_ts$default(
				Object.assign({markupOptions: this.reporter.markupOptions}, opts),
			);
		}

		createDiagnosticsPrinter(processor = this.createDiagnosticsProcessor()) {
			processor.unshiftOrigin({
				category: "server",
				message: this.query.commandName + " command was dispatched",
			});

			return new ___R$project$rome$$internal$cli$diagnostics$DiagnosticsPrinter_ts$default({
				processor,
				reporter: this.reporter,
				cwd: this.client.flags.cwd,
				wrapErrors: true,
				flags: this.getDiagnosticsPrinterFlags(),
				fileReaders: this.server.createDiagnosticsPrinterFileReaders(),
			});
		}

		getDiagnosticsPrinterFlags() {
			const {requestFlags} = this.query;
			return {
				auxiliaryDiagnosticFormat: requestFlags.auxiliaryDiagnosticFormat,
				grep: requestFlags.grep,
				inverseGrep: requestFlags.inverseGrep,
				showAllDiagnostics: requestFlags.showAllDiagnostics,
				verboseDiagnostics: requestFlags.verboseDiagnostics,
				maxDiagnostics: requestFlags.maxDiagnostics,
				fieri: requestFlags.fieri,
			};
		}

		expectArgumentLength(min, max = min, advice = []) {
			const {args} = this.query;
			let message;

			let excessive = false;

			if (min === max) {
				if (args.length !== min) {
					if (min === 0) {
						message = ___R$project$rome$$internal$markup$escape_ts$markup`Expected no arguments`;
					} else {
						message = ___R$project$rome$$internal$markup$escape_ts$markup`Expected exactly <number emphasis>${String(
							min,
						)}</number> arguments`;
					}
				}
			} else {
				if (args.length < min) {
					message = ___R$project$rome$$internal$markup$escape_ts$markup`Expected at least <number emphasis>${String(
						min,
					)}</number> arguments`;
				}

				if (args.length > max) {
					excessive = true;
					message = ___R$project$rome$$internal$markup$escape_ts$markup`Expected no more than <number emphasis>${String(
						min,
					)}</number> arguments`;
				}
			}

			if (message !== undefined) {
				const description = ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.FLAGS.INCORRECT_ARG_COUNT(
					excessive,
					message,
				);
				this.throwDiagnosticFlagError({
					target: {
						type: "arg-range",
						from: min,
						to: max,
					},
					description: Object.assign(
						{},
						description,
						{advice: [...description.advice, ...advice]},
					),
				});
			}
		}

		throwDiagnosticFlagError(
			{
				description,
				target = "none",
				showHelp = true,
			},
		) {
			const location = this.getDiagnosticLocationFromFlags(target);

			let {category} = description;
			if (category === undefined) {
				category =
					typeof target !== "string" &&
					(target.type === "arg" || target.type === "arg-range")
						? "args/invalid"
						: "flags/invalid";
			}

			const diag = {
				description: Object.assign({advice: []}, description, {category}),
				location,
			};

			throw new ___R$project$rome$$internal$core$server$ServerRequest_ts$ServerRequestInvalid(
				___R$project$rome$$internal$markup$escape_ts$readMarkup(
					description.message,
				),
				[diag],
				showHelp,
			);
		}

		getDiagnosticLocationForClientCwd() {
			const cwd = this.client.flags.cwd.join();
			return {
				sourceText: cwd,
				start: {
					line: ___R$project$rome$$internal$ob1$index_ts$ob1Number1,
					column: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
				},
				end: {
					line: ___R$project$rome$$internal$ob1$index_ts$ob1Number1,
					column: ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(
						cwd.length,
					),
				},
				filename: "cwd",
			};
		}

		getDiagnosticLocationFromFlags(target) {
			const {query} = this;
			const clientFlags = this.client.flags;

			const flags = Object.assign(
				{silent: clientFlags.silent},
				this.query.requestFlags,
				this.normalizedCommandFlags.flags,
			);

			const defaultFlags = Object.assign(
				{
					silent: ___R$project$rome$$internal$core$common$types$client_ts$DEFAULT_CLIENT_FLAGS.silent,
				},
				___R$project$rome$$internal$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS,
				this.normalizedCommandFlags.defaultFlags,
				{clientName: this.client.flags.clientName},
			);

			// Only include the cwd flag it was different from the cwd of the actual client
			if (!clientFlags.cwd.equal(clientFlags.realCwd)) {
				flags.cwd = clientFlags.cwd.join();
			}

			return ___R$project$rome$$internal$cli$flags$serializeCLIFlags_ts$serializeCLIFlags(
				{
					programName: "rome",
					commandName: query.commandName,
					flags,
					args: query.args,
					defaultFlags,
					incorrectCaseFlags: new Set(),
					shorthandFlags: new Set(),
					cwd: this.client.flags.cwd,
				},
				target,
			);
		}

		getResolverOptionsFromFlags() {
			const {requestFlags} = this.query;
			return {
				origin: this.client.flags.cwd,
				platform: requestFlags.resolverPlatform,
				scale: requestFlags.resolverScale,
				mocks: requestFlags.resolverMocks,
			};
		}

		getBundlerConfigFromFlags(resolverOpts = {}) {
			return {
				inlineSourceMap: false,
				cwd: this.client.flags.cwd,
				resolver: ___R$project$rome$$internal$typescript$helpers$index_ts$mergeObjects(
					this.getResolverOptionsFromFlags(),
					resolverOpts,
				),
			};
		}

		normalizeCompileResult(res) {
			const {projectManager} = this.server;

			// Turn all the cacheDependencies entries from 'absolute paths to UIDs
			return Object.assign(
				{},
				res,
				{
					cacheDependencies: res.cacheDependencies.map((filename) => {
						return projectManager.getFileReference(
							___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
								filename,
							),
						).uid;
					}),
				},
			);
		}

		startMarker(opts) {
			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Started marker: ${opts.label}`,
			);
			return Object.assign({}, opts, {start: Date.now()});
		}

		endMarker(startMarker) {
			const endMarker = Object.assign({}, startMarker, {end: Date.now()});
			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Completed marker: ${startMarker.label}`,
			);
			this.markerEvent.send(endMarker);
			return endMarker;
		}

		async wrapRequestDiagnostic(method, path, factory, opts = {}) {
			await this.server.memoryFs.processingLock.wait();

			const {server} = this;
			const owner = await server.fileAllocator.getOrAssignOwner(path);
			const startMtime = server.memoryFs.maybeGetMtime(path);
			const start = Date.now();
			const lock = await server.requestFileLocker.getLock(path);
			const ref = server.projectManager.getFileReference(path);

			const interval = setInterval(
				() => {
					const took = Date.now() - start;
					this.reporter.warn(
						___R$project$rome$$internal$markup$escape_ts$markup`Running <emphasis>${method}</emphasis> on <emphasis>${path}</emphasis> seems to be taking longer than expected. Have been waiting for <emphasis><duration>${String(
							took,
						)}</duration></emphasis>.`,
					);
				},
				___R$project$rome$$internal$core$common$constants_ts$LAG_INTERVAL,
			);

			const marker = this.startMarker({
				label: method + ": " + ref.relative,
				facet: method,
				rowId: "worker " + owner.id,
			});

			try {
				const res = await factory(owner.bridge, ref);
				this.endMarker(marker);
				return res;
			} catch (err) {
				let diagnostics = ___R$project$rome$$internal$diagnostics$errors_ts$getDiagnosticsFromError(
					err,
				);

				if (diagnostics === undefined) {
					const diag = ___R$project$rome$$internal$diagnostics$derive_ts$deriveDiagnosticFromError(
						err,
						{
							description: {
								category: "internalError/request",
							},
						},
					);

					throw ___R$project$rome$$internal$diagnostics$errors_ts$createSingleDiagnosticError(
						Object.assign(
							{},
							diag,
							{
								description: Object.assign(
									{},
									diag.description,
									{
										advice: [
											...diag.description.advice,
											{
												type: "log",
												category: "info",
												text: ___R$project$rome$$internal$markup$escape_ts$markup`Error occurred while requesting <emphasis>${method}</emphasis> for <filelink emphasis target="${ref.uid}" />`,
											},
										],
									},
								),
							},
						),
					);
				} else {
					// We don't want to tamper with these
					throw err;
				}
			} finally {
				lock.release();
				clearInterval(interval);

				const endMtime = this.server.memoryFs.maybeGetMtime(path);
				if (endMtime !== startMtime && !opts.noRetry) {
					return this.wrapRequestDiagnostic(method, path, factory);
				}
			}
		}

		async requestWorkerGetBuffer(path) {
			this.checkCancelled();

			return this.wrapRequestDiagnostic(
				"getBuffer",
				path,
				async (bridge, ref) => {
					return bridge.getBuffer.call({ref});
				},
			);
		}

		async requestWorkerUpdateBuffer(path, content) {
			this.checkCancelled();

			await this.wrapRequestDiagnostic(
				"updateBuffer",
				path,
				async (bridge, ref) => {
					await bridge.updateBuffer.call({ref, content});
					this.server.memoryFs.addBuffer(path, content);
					await this.server.refreshFileEvent.push(path);
				},
				{noRetry: true},
			);
		}

		async requestWorkerPatchBuffer(path, patches) {
			this.checkCancelled();

			return this.wrapRequestDiagnostic(
				"patchBuffer",
				path,
				async (bridge, ref) => {
					const buffer = await bridge.patchBuffer.call({ref, patches});
					this.server.memoryFs.addBuffer(path, buffer);
					this.server.refreshFileEvent.push(path);
					return buffer;
				},
				{noRetry: true},
			);
		}

		async requestWorkerClearBuffer(path) {
			this.checkCancelled();

			await this.wrapRequestDiagnostic(
				"clearBuffer",
				path,
				async (bridge, ref) => {
					await bridge.clearBuffer.call({ref});
					this.server.memoryFs.clearBuffer(path);
					this.server.refreshFileEvent.push(path);
				},
				{noRetry: true},
			);
		}

		async requestWorkerParse(path, opts) {
			this.checkCancelled();

			return this.wrapRequestDiagnostic(
				"parse",
				path,
				(bridge, ref) => bridge.parse.call({ref, options: opts}),
			);
		}

		async requestWorkerUpdateInlineSnapshots(path, updates, parseOptions) {
			this.checkCancelled();

			return this.wrapRequestDiagnostic(
				"updateInlineSnapshots",
				path,
				(bridge, ref) =>
					bridge.updateInlineSnapshots.call({ref, updates, parseOptions})
				,
			);
		}

		async requestWorkerLint(path, optionsWithoutModSigs) {
			this.checkCancelled();

			const {cache} = this.server;
			const cacheEntry = await cache.get(path);

			const cacheKey = ___R$$priv$project$rome$$internal$core$server$ServerRequest_ts$hash(
				optionsWithoutModSigs,
			);
			const cached = cacheEntry.lint[cacheKey];
			if (cached !== undefined) {
				return cached;
			}

			const prefetchedModuleSignatures = await this.maybePrefetchModuleSignatures(
				path,
			);

			const options = Object.assign(
				{},
				optionsWithoutModSigs,
				{prefetchedModuleSignatures},
			);

			const res = await this.wrapRequestDiagnostic(
				"lint",
				path,
				(bridge, ref) => bridge.lint.call({ref, options, parseOptions: {}}),
			);

			await cache.update(
				path,
				(cacheEntry) =>
					({
						lint: Object.assign({}, cacheEntry.lint, {[cacheKey]: res}),
					})
				,
			);

			return res;
		}

		async requestWorkerFormat(path, options, parseOptions) {
			this.checkCancelled();

			return await this.wrapRequestDiagnostic(
				"format",
				path,
				(bridge, ref) => bridge.format.call({ref, options, parseOptions}),
			);
		}

		async requestWorkerCompile(path, stage, options, parseOptions) {
			this.checkCancelled();

			const {cache} = this.server;

			// Create a cache key comprised of the stage and hash of the options
			const cacheKey =
				stage +
				":" +
				___R$$priv$project$rome$$internal$core$server$ServerRequest_ts$hash(
					options,
				);

			// Check cache for this stage and options
			const cacheEntry = await cache.get(path);
			const cached = cacheEntry.compile[cacheKey];
			if (cached !== undefined) {
				// TODO check cacheDependencies
				return cached;
			}

			const compileRes = await this.wrapRequestDiagnostic(
				"compile",
				path,
				(bridge, ref) => {
					// We allow options to be passed in as undefined so we can compute an easy cache key
					if (options === undefined) {
						options = {};
					}

					return bridge.compile.call({ref, stage, options, parseOptions});
				},
			);

			const res = this.normalizeCompileResult(
				Object.assign({}, compileRes, {cached: false}),
			);

			// There's a race condition here between the file being opened and then rewritten
			await cache.update(
				path,
				(cacheEntry) =>
					({
						compile: Object.assign(
							{},
							cacheEntry.compile,
							{[cacheKey]: Object.assign({}, res, {cached: true})},
						),
					})
				,
			);

			return res;
		}

		async requestWorkerAnalyzeDependencies(path, parseOptions) {
			this.checkCancelled();

			const {cache} = this.server;

			const cacheEntry = await cache.get(path);
			if (cacheEntry.analyzeDependencies !== undefined) {
				return cacheEntry.analyzeDependencies;
			}

			const res = await this.wrapRequestDiagnostic(
				"analyzeDependencies",
				path,
				(bridge, ref) => bridge.analyzeDependencies.call({ref, parseOptions}),
			);
			await cache.update(
				path,
				{
					analyzeDependencies: Object.assign({}, res, {cached: true}),
				},
			);

			return Object.assign({}, res, {cached: false});
		}

		async requestWorkerModuleSignature(path, parseOptions) {
			this.checkCancelled();

			const {cache} = this.server;

			const cacheEntry = await cache.get(path);
			if (cacheEntry.moduleSignature !== undefined) {
				return cacheEntry.moduleSignature;
			}

			const res = await this.wrapRequestDiagnostic(
				"moduleSignature",
				path,
				(bridge, ref) => bridge.moduleSignatureJS.call({ref, parseOptions}),
			);
			await cache.update(
				path,
				{
					moduleSignature: res,
				},
			);
			return res;
		}

		async maybePrefetchModuleSignatures(path) {
			this.checkCancelled();

			const {projectManager} = this.server;

			const prefetchedModuleSignatures = {};
			const project = await projectManager.assertProject(path);
			if (!project.config.typeCheck.enabled) {
				return prefetchedModuleSignatures;
			}

			// get the owner of this file

			/*const rootOwner = await fileAllocator.getOrAssignOwner(filename);
    const rootOwnerId = workerManager.getIdFromBridge(rootOwner);

    // absolute filenames to redupe export graphs
    const absoluteFilenameToGraphKey: Map<string, string> = new Map();

    // TODO exclude graphs that aren't a part of the root graph
    for (const dep of await dependencyGraph.getTransitiveDependencies(
      filename,
    )) {
      const key = `${dep.origin}:${dep.relative}`;
      const absolute = dep.absoluteMocked;

      // TODO check if we have this graph by another key and point to it if necessary
      const existingEntryKey = absoluteFilenameToGraphKey.get(absolute);
      if (existingEntryKey !== undefined) {
        invariant(existingEntryKey !== key, 'duplicate transitive dependency key %s', key);
        prefetchedModuleSignatures[key] = {
          type: 'POINTER',
          key: existingEntryKey,
        };
        continue;
      }

      // set the key so we point to the value instead of reproducing the whole graph
      absoluteFilenameToGraphKey.set(absolute, key);

      // fetch the owner so we can leave out graphs owned by the worker
      const owner = await fileAllocator.getOrAssignOwner(absolute);
      if (owner === rootOwner) {
        const project = await projectManager.assertProject(absolute);
        prefetchedModuleSignatures[key] = {
          type: 'OWNED',
          filename: absolute,
          projectId: project.id,
        };
        continue;
      }

      // get mtime so we can use it for a cache
      const mtime = this.server.memoryFs.getMtime(absolute);

      // check if this worker has it cached
      // TODO figure out some way to evict this on file deletion
      const cacheKey = `moduleSignature:${absolute}`;
      const cachedMtime = workerManager.getValueFromWorkerCache(
        rootOwnerId,
        cacheKey,
      );
      if (cachedMtime === mtime) {
        prefetchedModuleSignatures[key] = {
          type: 'USE_CACHED',
          filename: absolute,
        };
        continue;
      } else {
        workerManager.setWorkerCacheValue(rootOwnerId, cacheKey, mtime);
      }

      // calculate the graph
      const graph = await this.moduleSignature(absolute);
      prefetchedModuleSignatures[key] = {
        type: 'RESOLVED',
        graph,
      };
    }*/
			return prefetchedModuleSignatures;
		}

		async glob(opts) {
			const {cwd} = this.client.flags;

			const argToLocation = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
			const args = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet();

			let rawArgs = opts.args == null ? this.query.args : opts.args;
			if (rawArgs.length === 0) {
				rawArgs = [cwd];
				argToLocation.set(cwd, this.getDiagnosticLocationForClientCwd());
			}

			for (let i = 0; i < rawArgs.length; i++) {
				const path = ___R$project$rome$$internal$path$index_ts$createUnknownPath(
					rawArgs[i],
				);
				let abs;

				if (path.isAbsolute()) {
					abs = path.assertAbsolute();
				} else {
					const resolved = cwd.resolve(path);
					if (await this.server.memoryFs.existsHard(resolved)) {
						abs = resolved;
					} else {
						// Will need to be resolved...
						abs = await this.resolveEntryAssertPathArg(i, false);
					}
				}

				let exists = await this.server.memoryFs.existsHard(abs);

				// If it doesn't exist then let's try finding an alternate path
				if (!exists && opts.tryAlternateArg !== undefined) {
					const alternateSource = opts.tryAlternateArg(path);
					if (alternateSource !== undefined) {
						const resolvedAlternate = await this.server.resolver.resolveEntry({
							origin: cwd,
							source: alternateSource,
							// Allow requests to stop at directories
							requestedType: "directory",
						});
						if (resolvedAlternate.type === "FOUND") {
							abs = resolvedAlternate.path;
							exists = true;
						}
					}
				}

				if (exists) {
					args.add(abs);

					if (!argToLocation.has(abs)) {
						argToLocation.set(
							abs,
							this.getDiagnosticLocationFromFlags({
								type: "arg",
								key: i,
							}),
						);
					}
				} else {
					// This should fail. Resolver produces much nicer error messages.
					await this.resolveEntryAssertPathArg(i, false);
				}
			}

			return new ___R$project$rome$$internal$core$server$fs$glob_ts$Globber(
				this.server,
				Object.assign(
					{},
					opts,
					{
						args,

						onWatch: (sub) => {
							this.endEvent.subscribe(async () => {
								await sub.unsubscribe();
							});
						},

						onSearchNoMatch: async (path) => {
							if (!opts.ignoreArgumentMisses) {
								const location =
									argToLocation.get(path) == null ? {} : argToLocation.get(path);
								await this.server.projectManager.assertProject(path, location);
								await ___R$$priv$project$rome$$internal$core$server$ServerRequest_ts$globUnmatched(
									this,
									opts,
									path,
									location,
								);
							}
						},
					},
				),
			);
		}

		async buildResponseFromError(rawErr) {
			if (!this.bridge.alive) {
				// Doesn't matter
				return {
					type: "CANCELLED",
					reason: "dead",
					markers: [],
				};
			}

			let err = rawErr;
			let printer;

			if (
				err instanceof
				___R$project$rome$$internal$cli$diagnostics$DiagnosticsPrinter_ts$default
			) {
				printer = err;
			} else {
				// If we can derive diagnostics from the error then create a diagnostics printer
				const diagnostics = ___R$project$rome$$internal$diagnostics$errors_ts$getOrDeriveDiagnosticsFromError(
					err,
					{
						description: {
							category: "internalError/request",
						},
						tags: {
							internal: true,
						},
					},
				);

				printer = this.createDiagnosticsPrinter(
					this.createDiagnosticsProcessor({
						origins: [
							{
								category: "internal",
								message: "Derived diagnostics from thrown error",
							},
						],
					}),
				);

				printer.processor.addDiagnostics(diagnostics);
			}

			// Only print when the bridge is alive and we aren't in review mode
			// When we're in review mode we don't expect to show any diagnostics because they'll be intercepted in the client command
			// We will always print invalid request errors
			let shouldPrint = true;
			if (this.query.requestFlags.review) {
				shouldPrint = false;
			}
			if (
				rawErr instanceof
				___R$project$rome$$internal$core$server$ServerRequest_ts$ServerRequestInvalid
			) {
				shouldPrint = true;
			}
			if (!this.bridge.alive) {
				shouldPrint = false;
			}

			if (shouldPrint) {
				await printer.print();

				// Don't output the footer if this is a notifier for an invalid request as it will be followed by a help screen
				if (
					!(rawErr instanceof
					___R$project$rome$$internal$core$server$ServerRequest_ts$ServerRequestInvalid)
				) {
					await printer.footer();
				}
			}

			const diagnostics = printer.processor.getDiagnostics();

			if (
				err instanceof
				___R$project$rome$$internal$core$server$ServerRequest_ts$ServerRequestCancelled
			) {
				return {
					type: "CANCELLED",
					reason: err.reason,
					markers: [],
				};
			} else if (
				err instanceof
				___R$project$rome$$internal$core$server$ServerRequest_ts$ServerRequestInvalid
			) {
				return {
					type: "INVALID_REQUEST",
					diagnostics,
					showHelp: err.showHelp,
					markers: [],
				};
			} else {
				return {
					type: "DIAGNOSTICS",
					files: {},
					hasDiagnostics: diagnostics.length > 0,
					diagnostics,
					markers: [],
				};
			}
		}
	}


  // project-rome/@internal/core/client/review.ts
async function ___R$$priv$project$rome$$internal$core$client$review_ts$check(
		req,
		state,
	) {
		const {reporter} = req.client;

		reporter.clearScreen();

		if (state.initial) {
			reporter.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Fetching initial diagnostics`,
			);
			state.initial = false;
		} else {
			reporter.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Updating diagnostics`,
			);
		}

		const res = await req.fork(
			Object.assign(
				{},
				req.query,
				{
					// We want data no matter what
					noData: false,
				},
			),
		).initCommand();

		if (res.type === "SUCCESS") {
			throw new Error("Expected diagnostics or an error");
		}

		// In case it returned an error
		if (res.type !== "DIAGNOSTICS") {
			return res;
		}

		const diagnostics = res.diagnostics;
		let diag;

		for (const _diag of diagnostics) {
			const key = ___R$project$rome$$internal$diagnostics$derive_ts$derivePositionlessKeyFromDiagnostic(
				_diag,
			);
			if (!state.seen.has(key)) {
				state.seen.add(key);
				diag = _diag;
				break;
			}
		}

		if (diag === undefined) {
			return res;
		}

		return await ___R$$priv$project$rome$$internal$core$client$review_ts$ask(
			diag,
			req,
			state,
			false,
			diagnostics.length,
		);
	}

	async function ___R$$priv$project$rome$$internal$core$client$review_ts$ask(
		diag,
		req,
		state,
		showMoreOptions,
		totalDiagnostics,
	) {
		const {client} = req;
		const {reporter} = client;
		reporter.clearScreen();

		// Extract actions and remove them from the diagnostic
		let {advice = []} = diag.description;
		let hasExtraOptions = false;
		const actions = [];
		for (const item of advice) {
			if (item.type === "action") {
				// Only show extra items and hide all non-extra items when `more === true`
				if (item.extra === true) {
					hasExtraOptions = true;
					if (!showMoreOptions) {
						continue;
					}
				} else if (showMoreOptions) {
					continue;
				}

				actions.push(item);
			}
		}
		advice = advice.filter((item) => item.type !== "action");
		diag = Object.assign(
			{},
			diag,
			{description: Object.assign({}, diag.description, {advice})},
		);

		const optionToAction = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
			"optionToAction",
		);
		const chosenShortcuts = new Set(["n", "escape"]);

		const actionOptions = {};

		let counter = 0;
		for (const action of actions) {
			const key = String(counter++);
			let shortcut =
				action.shortcut !== undefined && !chosenShortcuts.has(action.shortcut)
					? action.shortcut
					: undefined;
			optionToAction.set(key, action);
			actionOptions[key] = {
				label: action.noun,
				shortcut,
			};
		}

		const options = Object.assign(
			{
				ignore: {
					label: ___R$project$rome$$internal$markup$escape_ts$markup`Do nothing`,
					shortcut: "n",
				},
			},
			actionOptions,
			{
				exit: {
					label: ___R$project$rome$$internal$markup$escape_ts$markup`Exit`,
					shortcut: "escape",
				},
			},
		);

		if (hasExtraOptions) {
			if (showMoreOptions) {
				options.more = {
					label: ___R$project$rome$$internal$markup$escape_ts$markup`Less options...`,
					shortcut: "l",
				};
			} else {
				options.more = {
					label: ___R$project$rome$$internal$markup$escape_ts$markup`More options...`,
					shortcut: "m",
				};
			}
		}

		reporter.heading(
			___R$project$rome$$internal$markup$escape_ts$markup`Reviewing diagnostics (<emphasis>${totalDiagnostics}</emphasis><dim>/</dim><emphasis>${totalDiagnostics +
			state.resolvedCount}</emphasis>)`,
		);

		const printer = new ___R$project$rome$$internal$cli$diagnostics$DiagnosticsPrinter_ts$default({
			processor: new ___R$project$rome$$internal$diagnostics$DiagnosticsProcessor_ts$default(),
			reporter,
			wrapErrors: true,
		});
		diag = printer.processor.addDiagnosticAssert(diag);
		await printer.print();

		const answer = await reporter.radio(
			___R$project$rome$$internal$markup$escape_ts$markup`How do you want to resolve this?`,
			{
				options,
			},
		);

		// Check if this diagnostic is now out of date
		await printer.fetchFileSources([diag]);
		const outdatedFiles = printer.getOutdatedFiles(diag);
		if (outdatedFiles.size > 0) {
			const files = Array.from(
				outdatedFiles,
				(path) =>
					___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${path}</emphasis>`
				,
			);

			reporter.br();

			if (files.length === 1) {
				reporter.warn(
					___R$project$rome$$internal$markup$escape_ts$markup`The file ${files[0]} changed while waiting for your response.`,
				);
			} else {
				reporter.warn(
					___R$project$rome$$internal$markup$escape_ts$markup`The following diagnostic dependencies changed while waiting for your response.`,
				);
				reporter.list(files);
			}

			await reporter.confirm("Press any key to try again");

			return await ___R$$priv$project$rome$$internal$core$client$review_ts$check(
				req,
				state,
			);
		}

		if (answer === "less") {
			return await ___R$$priv$project$rome$$internal$core$client$review_ts$ask(
				diag,
				req,
				state,
				false,
				totalDiagnostics,
			);
		}

		if (answer === "more") {
			return await ___R$$priv$project$rome$$internal$core$client$review_ts$ask(
				diag,
				req,
				state,
				true,
				totalDiagnostics,
			);
		}

		if (answer === "ignore") {
			return await ___R$$priv$project$rome$$internal$core$client$review_ts$check(
				req,
				state,
			);
		}

		if (answer === "exit") {
			return ___R$project$rome$$internal$core$server$ServerRequest_ts$EMPTY_SUCCESS_RESPONSE;
		}

		const action = optionToAction.assert(answer);

		const requestFlags = Object.assign({}, action.requestFlags);

		// Execute action
		const actionRes = await client.query(
			{
				commandName: action.command,
				args: action.args,
				commandFlags: action.commandFlags,
				requestFlags,
			},
			"server",
		);
		if (actionRes.type !== "DIAGNOSTICS" && actionRes.type !== "SUCCESS") {
			return actionRes;
		}

		state.resolvedCount++;
		return await ___R$$priv$project$rome$$internal$core$client$review_ts$check(
			req,
			state,
		);
	}

	async function ___R$project$rome$$internal$core$client$review_ts$default(req) {
		const {reporter} = req.client;
		const state = {
			initial: true,
			seen: new Set(),
			resolvedCount: 0,
		};
		const res = await ___R$$priv$project$rome$$internal$core$client$review_ts$check(
			req,
			state,
		);

		reporter.clearScreen();

		if (state.seen.size === 0) {
			reporter.success(
				___R$project$rome$$internal$markup$escape_ts$markup`Nothing to review!`,
			);
		} else {
			if (res.type === "DIAGNOSTICS") {
				await ___R$project$rome$$internal$cli$diagnostics$index_ts$printDiagnostics({
					diagnostics: res.diagnostics,
					suppressions: [],
					excludeFooter: true,
					printerOptions: {
						processor: new ___R$project$rome$$internal$diagnostics$DiagnosticsProcessor_ts$default(),
						reporter,
					},
				});
				reporter.hr();
				reporter.error(
					___R$project$rome$$internal$markup$escape_ts$markup`<number emphasis>${String(
						res.diagnostics.length,
					)}</number> unresolved <grammarNumber plural="issues" singular="issue">${String(
						res.diagnostics.length,
					)}</grammarNumber> remaining`,
				);
			}

			reporter.success(
				___R$project$rome$$internal$markup$escape_ts$markup`<number emphasis>${String(
					state.resolvedCount,
				)}</number> <grammarNumber plural="issues" singular="issue">${String(
					state.resolvedCount,
				)}</grammarNumber> resolved`,
			);
		}

		return res;
	}


  // project-rome/@internal/core/client/ClientRequest.ts
class ___R$project$rome$$internal$core$client$ClientRequest_ts$default {
		constructor(client, type = "local", query) {
			this.client = client;
			this.type = type;
			this.query = query;
		}

		fork(query) {
			return new ___R$project$rome$$internal$core$client$ClientRequest_ts$default(
				this.client,
				this.type,
				query,
			);
		}

		async init() {
			const {requestFlags} = this.query;
			if (requestFlags !== undefined && requestFlags.review) {
				return await this.initReview();
			} else {
				return await this.initCommand();
			}
		}

		async initReview() {
			return ___R$project$rome$$internal$core$client$review_ts$default(this);
		}

		async initCommand() {
			const localCommand = ___R$project$rome$$internal$core$client$commands_ts$localCommands.get(
				this.query.commandName,
			);

			if (this.type === "server" || localCommand === undefined) {
				return this.initFromServer();
			} else {
				return this.initFromLocal(localCommand);
			}
		}

		async initFromLocal(
			// rome-ignore lint/ts/noExplicitAny: future cleanup
			localCommand,
		) {
			const {query} = this;

			let flags;
			if (localCommand.defineFlags !== undefined) {
				flags = localCommand.defineFlags(
					___R$project$rome$$internal$consume$index_ts$consumeUnknown(
						query.commandFlags,
						"flags/invalid",
					),
				);
			}

			const res = await localCommand.callback(this, flags);
			if (res === true) {
				return {
					type: "SUCCESS",
					data: undefined,
					hasData: false,
					markers: [],
					files: {},
				};
			} else if (res === false) {
				return {
					type: "EXIT",
					code: 1,
					markers: [],
				};
			} else {
				return res;
			}
		}

		async initFromServer() {
			const {client} = this;

			try {
				const bridge = await client.findOrStartServer();
				return await bridge.query.call(this.query);
			} catch (err) {
				if (
					err instanceof
					___R$project$rome$$internal$events$BridgeError_ts$default
				) {
					return {
						type: "CANCELLED",
						markers: [],
						reason: err.message,
					};
				} else {
					throw err;
				}
			}
		}
	}


  // project-rome/@internal/core/server/WorkerQueue.ts
class ___R$project$rome$$internal$core$server$WorkerQueue_ts$default
		extends ___R$project$rome$$internal$async$Queue_ts$default {
		constructor(server, opts) {
			super(opts);
			this.server = server;
		}

		// Prematurely fetch the owners so we don't waterfall worker creation
		async prepare(paths) {
			await Promise.all(
				Array.from(
					paths,
					async (path) => {
						return ___R$project$rome$$internal$fs$FileNotFound_ts$FileNotFound.allowMissing(
							path,
							() => this.server.fileAllocator.getOrAssignOwner(path),
						);
					},
				),
			);
		}

		async pushPath(path, metadata) {
			const worker = await this.server.fileAllocator.getOrAssignOwner(path);
			await this.pushQueue(worker, {path, item: metadata});
		}
	}


  // project-rome/@internal/core/server/dependencies/DependencyOrderer.ts
class ___R$project$rome$$internal$core$server$dependencies$DependencyOrderer_ts$default {
		constructor(graph) {
			this.graph = graph;
			this.orderedNodes = new Set();
			this.visitedNodes = new Set();
			this.possibleCyclePaths = new Map();
			this.diagnostics = [];
			this.firstTopAwaitLocations = [];
		}

		handleAlreadyVisitedFile(node, path, ancestry) {
			const filename = path.join();

			// We flag a possible cycle when a dependency has yet to have it's own transitive dependencies resolve but it ends up going back to itself
			const isPossibleCycle =
				this.orderedNodes.has(node) === false && ancestry.includes(filename);
			if (isPossibleCycle) {
				const ourCyclePath = ancestry.concat([filename]);
				const existingCycle = this.possibleCyclePaths.get(node);

				// We want to get the shortest cycle path since it's likely the most easily resolved
				const isShortestCycle =
					existingCycle === undefined ||
					existingCycle.length > ourCyclePath.length;
				if (isShortestCycle) {
					this.possibleCyclePaths.set(node, ourCyclePath);
				}
			}
		}

		addFile(path, ancestry) {
			const node = this.graph.getNode(path);

			if (this.visitedNodes.has(node)) {
				this.handleAlreadyVisitedFile(node, path, ancestry);
				return;
			}

			this.visitedNodes.add(node);

			const {firstTopAwaitLocation} = node.analyze;
			if (firstTopAwaitLocation !== undefined) {
				this.firstTopAwaitLocations.push({
					mtime: node.getMtime(),
					loc: firstTopAwaitLocation,
				});
			}

			const subAncestry = ancestry.concat([path.join()]);
			for (const depPath of node.getAbsoluteDependencies()) {
				const dep = node.getDependencyInfoFromAbsolute(depPath).analyze;
				if (dep.kind === "value") {
					this.addFile(depPath, subAncestry);
				}
			}

			this.orderedNodes.add(node);
		}

		// We detect cycles by determining if there were any references to imports at the top level that
		// are for a module that will be initialized before
		detectCycles() {
			const flatOrder = Array.from(this.orderedNodes);

			for (let i = 0; i < flatOrder.length; i++) {
				const node = flatOrder[i];

				for (const imp of node.analyze.importFirstUsage) {
					const resolved = node.getNodeFromRelativeDependency(imp.source).resolveImport(
						imp.imported,
						imp.loc,
					);
					if (resolved.type !== "FOUND") {
						continue;
					}

					// Hoisted exports will always be accessible
					if (resolved.record.valueType === "function") {
						continue;
					}

					const dep = resolved.node;

					const isBefore = flatOrder.indexOf(dep) > i;
					if (isBefore) {
						this.flagCycle(node, dep, imp);
					}
				}
			}
		}

		flagCycle(node, dep, imp) {
			const path = this.possibleCyclePaths.get(dep);
			if (!path) {
				// idk??
				return;
			}

			const target = path[path.length - 1];
			const culprit = String(
				path.find((value, index) => path[index - 1] === target),
			);

			this.diagnostics.push({
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.BUNDLER.DETECTED_CYCLE(
					imp.local,
					target,
					culprit,
					path,
				),
				location: {
					filename: node.path.join(),
					mtime: node.getMtime(),
					start: imp.loc === undefined ? undefined : imp.loc.start,
					end: imp.loc === undefined ? undefined : imp.loc.end,
				},
			});
		}

		order(path) {
			this.addFile(path, []);
			this.detectCycles();
			return {
				firstTopAwaitLocations: this.firstTopAwaitLocations,
				diagnostics: this.diagnostics,
				files: Array.from(this.orderedNodes, (node) => node.path),
			};
		}
	}


  // project-rome/@internal/core/server/dependencies/DependencyNode.ts
function ___R$$priv$project$rome$$internal$core$server$dependencies$DependencyNode_ts$equalKind(
		producer,
		consumerKind,
	) {
		// Allow importing functions and classes as `type` and `typeof`
		if (
			producer.type === "local" &&
			(producer.valueType === "class" || producer.valueType === "function") &&
			(consumerKind === "type" || consumerKind === "typeof")
		) {
			return true;
		}

		// You can only import a type or a class as a type
		if (producer.kind === "type") {
			return consumerKind === "type";
		}

		// You can only import a value as a value or typeof
		if (producer.kind === "value") {
			return consumerKind === "typeof" || consumerKind === "value";
		}

		return false;
	}

	class ___R$project$rome$$internal$core$server$dependencies$DependencyNode_ts$default {
		constructor(server, graph, ref, res) {
			this.server = server;
			this.graph = graph;

			this.project = server.projectManager.assertProjectExisting(ref.real);
			this.uid = ref.uid;
			this.path = ref.real;
			this.ref = ref;
			this.type = res.moduleType;

			this.usedAsync = false;
			this.all = false;
			this.relativeToAbsolutePath = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
				"relativeToAbsolutePath",
			);
			this.absoluteToAnalyzeDependency = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();

			this.analyze = res;

			const {handler} = ___R$project$rome$$internal$core$common$file$handlers$index_ts$getFileHandlerFromPath(
				ref.real,
				this.project.config,
			);
			this.handler = handler;
		}

		getMtime() {
			return this.server.memoryFs.getMtime(this.path);
		}

		setUsedAsync(usedAsync) {
			this.usedAsync = usedAsync;
		}

		setAll(all) {
			this.all = all;
		}

		getDependents() {
			const dependents = [];
			for (const node of this.graph.getNodes()) {
				if (node.absoluteToAnalyzeDependency.has(this.path)) {
					dependents.push(node);
				}
			}
			return dependents;
		}

		addDependency(relative, absolute, dep) {
			this.relativeToAbsolutePath.set(relative, absolute);
			this.absoluteToAnalyzeDependency.set(
				absolute,
				{
					analyze: dep,
					path: absolute,
				},
			);
		}

		getDependencyInfoFromAbsolute(path) {
			return this.absoluteToAnalyzeDependency.assert(path);
		}

		getNodeFromRelativeDependency(relative) {
			const absolute = this.relativeToAbsolutePath.assert(relative);
			return this.graph.getNode(absolute);
		}

		getAbsoluteDependencies() {
			return Array.from(this.relativeToAbsolutePath.values());
		}

		getDependencyOrder() {
			const orderer = new ___R$project$rome$$internal$core$server$dependencies$DependencyOrderer_ts$default(
				this.graph,
			);
			return orderer.order(this.path);
		}

		// Get a list of all DependencyNodes where exports could be resolved. eg. `export *`
		getExportedModules(chain = new Set()) {
			if (chain.has(this)) {
				return new Set();
			} else {
				chain.add(this);
			}

			for (const exp of this.analyze.exports) {
				if (
					exp.type === "externalAll" &&
					this.relativeToAbsolutePath.has(exp.source)
				) {
					this.getNodeFromRelativeDependency(exp.source).getExportedModules(
						chain,
					);
				}
			}

			return chain;
		}

		getExportedNames(kind, seen = new Set()) {
			if (seen.has(this)) {
				return new Set();
			} else {
				seen.add(this);
			}

			let names = new Set();

			for (const exp of this.analyze.exports) {
				if (
					!___R$$priv$project$rome$$internal$core$server$dependencies$DependencyNode_ts$equalKind(
						exp,
						kind,
					)
				) {
					continue;
				}

				switch (exp.type) {
					case "local": {
						names.add(exp.name);
						break;
					}

					case "external": {
						const resolved = this.getNodeFromRelativeDependency(exp.source).resolveImport(
							exp.imported,
							exp.loc,
						);
						if (
							resolved.type === "FOUND" &&
							___R$$priv$project$rome$$internal$core$server$dependencies$DependencyNode_ts$equalKind(
								resolved.record,
								kind,
							)
						) {
							names.add(exp.exported);
						}
						break;
					}

					case "externalNamespace": {
						names.add(exp.exported);
						break;
					}

					case "externalAll": {
						names = new Set([
							...names,
							...this.getNodeFromRelativeDependency(exp.source).getExportedNames(
								kind,
								seen,
							),
						]);
						break;
					}
				}
			}

			return names;
		}

		buildDiagnosticForUnknownExport(kind, resolved) {
			const location = Object.assign({}, resolved.loc, {mtime: this.getMtime()});

			const expectedName = resolved.name;
			const fromSource = resolved.node.uid;

			// Check if there was a matching local in any of the exported modules
			for (const mod of resolved.node.getExportedModules()) {
				// We use an object as a hash map so need to check for pollution
				if (
					Object.prototype.hasOwnProperty.call(
						mod.analyze.topLevelLocalBindings,
						expectedName,
					)
				) {
					const localLoc = mod.analyze.topLevelLocalBindings[expectedName];
					if (localLoc !== undefined) {
						return {
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.RESOLVER.UNKNOWN_EXPORT_POSSIBLE_UNEXPORTED_LOCAL(
								expectedName,
								fromSource,
								localLoc,
							),
							location,
						};
					}
				}
			}

			return {
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.RESOLVER.UNKNOWN_EXPORT(
					expectedName,
					fromSource,
					Array.from(resolved.node.getExportedNames(kind)),
					(name) => {
						const exportInfo = resolved.node.resolveImport(name, undefined);

						if (exportInfo.type === "NOT_FOUND") {
							throw new Error(
								"mod.resolveImport returned NOT_FOUND for an export " +
								name +
								" in " +
								exportInfo.node.path +
								" despite being returned by getExportedNames",
							);
						}

						return {
							location: exportInfo.record.loc,
							source: exportInfo.node === resolved.node
								? undefined
								: exportInfo.node.path.join(),
						};
					},
				),
				location,
			};
		}

		resolveImports() {
			const cached = this.resolveImportsCache;
			if (cached !== undefined) {
				return cached;
			}

			const {graph} = this;

			// Build up a map of any forwarded imports
			const resolvedImports = {};

			// Diagnostics for unknown imports
			const diagnostics = [];

			// Go through all of our dependencies and check if they have any external exports to forward
			for (const absolute of this.relativeToAbsolutePath.values()) {
				const mod = graph.getNode(absolute);

				// We can't follow CJS names
				if (mod.type === "cjs") {
					continue;
				}

				const usedNames = this.getDependencyInfoFromAbsolute(absolute).analyze.names;

				// Try to resolve these exports
				for (const nameInfo of usedNames) {
					const {name, kind, loc} = nameInfo;
					if (kind === "type" || kind === "typeof") {
						// Disable resolving typed imports for now as there's ridiculous code that hides some behind $FlowFixMe
						continue;
					}

					const resolved = mod.resolveImport(name, loc);

					// Unknown import
					if (resolved.type === "NOT_FOUND") {
						diagnostics.push(
							this.buildDiagnosticForUnknownExport(kind, resolved),
						);
						continue;
					}

					// If the resolved target isn't the same as the file then forward it
					if (resolved.node.uid !== mod.uid) {
						resolvedImports[mod.uid + ":" + name] = {
							id: resolved.node.uid,
							name: resolved.record.name,
						};
					}
				}
			}

			const result = {
				resolved: resolvedImports,
				diagnostics,
			};
			this.resolveImportsCache = result;
			return result;
		}

		resolveImport(name, loc, ignoreDefault = false, ancestry = []) {
			if (ancestry.includes(this)) {
				return {
					type: "NOT_FOUND",
					loc,
					node: this,
					name,
				};
			}

			const subAncestry = [...ancestry, this];

			// We always want to resolve exports from the bottom up
			const exports = this.analyze.exports.reverse();

			for (const record of exports) {
				// When resolving exportAll we never want to include the default export of those modules
				if (
					record.type === "local" &&
					record.name === "default" &&
					ignoreDefault
				) {
					continue;
				}

				if (
					record.type === "local" &&
					(record.name === name || record.name === "*")
				) {
					return {
						type: "FOUND",
						node: this,
						record,
					};
				}

				if (record.type === "external" && record.exported === name) {
					return this.getNodeFromRelativeDependency(record.source).resolveImport(
						record.imported,
						record.loc,
						false,
						subAncestry,
					);
				}

				if (record.type === "externalAll") {
					const resolved = this.getNodeFromRelativeDependency(record.source).resolveImport(
						name,
						record.loc,
						true,
						subAncestry,
					);

					if (resolved.type === "FOUND") {
						return resolved;
					}
				}
			}

			return {
				type: "NOT_FOUND",
				loc,
				node: this,
				name,
			};
		}
	}


  // project-rome/@internal/core/server/dependencies/DependencyGraph.ts
const ___R$$priv$project$rome$$internal$core$server$dependencies$DependencyGraph_ts$NODE_BUILTINS = [
		"electron",
		"buffer",
		"child_process",
		"crypto",
		"dgram",
		"dns",
		"fs",
		"http",
		"https",
		"net",
		"worker_threads",
		"os",
		"readline",
		"stream",
		"string_decoder",
		"tls",
		"tty",
		"zlib",
		"constants",
		"events",
		"url",
		"assert",
		"util",
		"path",
		"punycode",
		"querystring",
		"cluster",
		"console",
		"module",
		"process",
		"vm",
		"domain",
		"v8",
		"repl",
		"timers",
		"inspector",
	];

	class ___R$project$rome$$internal$core$server$dependencies$DependencyGraph_ts$default {
		constructor(request, resolverOpts) {
			this.request = request;
			this.server = request.server;
			this.nodes = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
			this.resolverOpts = resolverOpts;
			this.locker = new ___R$project$rome$$internal$async$lockers_ts$Locker();
		}

		getNodes() {
			return this.nodes.values();
		}

		isExternal(path, source) {
			const project = this.server.projectManager.assertProjectExisting(path);
			return (
				project.config.bundler.externals.includes(source) ||
				___R$$priv$project$rome$$internal$core$server$dependencies$DependencyGraph_ts$NODE_BUILTINS.includes(
					source,
				)
			);
		}

		getBundleBuddyStats(entries) {
			const stats = [];

			for (const node of this.nodes.values()) {
				const source = node.uid;

				for (const absoluteTarget of node.relativeToAbsolutePath.values()) {
					const target = this.getNode(absoluteTarget).uid;
					stats.push({
						target,
						source,
					});
				}
			}

			for (const absoluteEntry of entries) {
				const source = this.getNode(absoluteEntry).uid;
				stats.push({
					source,
					target: undefined,
				});
			}

			return stats;
		}

		deleteNode(path) {
			this.nodes.delete(path);
		}

		addNode(path, res) {
			const module = new ___R$project$rome$$internal$core$server$dependencies$DependencyNode_ts$default(
				this.server,
				this,
				this.server.projectManager.getFileReference(path),
				res,
			);
			this.nodes.set(path, module);
			return module;
		}

		maybeGetNode(path) {
			return this.nodes.get(path);
		}

		getNode(path) {
			const mod = this.maybeGetNode(path);
			if (mod === undefined) {
				throw new ___R$project$rome$$internal$fs$FileNotFound_ts$FileNotFound(
					path,
					"No dependency node found",
				);
			}
			return mod;
		}

		async seed(
			{
				paths,
				diagnosticsProcessor,
				analyzeProgress,
				allowFileNotFound = false,
				validate = false,
			},
		) {
			// Initialize sub dependency queue
			const workerQueue = new ___R$project$rome$$internal$core$server$WorkerQueue_ts$default(
				this.server,
				{
					callback: async ({path, item}) => {
						await this.resolve(
							path,
							{
								workerQueue,
								all: item.all,
								async: item.async,
								ancestry: item.ancestry,
							},
							diagnosticsProcessor,
							analyzeProgress,
						);
					},
				},
			);
			await workerQueue.prepare(paths);

			// Initialize roots
			const rootQueue = new ___R$project$rome$$internal$core$server$WorkerQueue_ts$default(
				this.server,
				{
					callback: async ({path}) => {
						const ret = await ___R$project$rome$$internal$fs$FileNotFound_ts$FileNotFound.maybeAllowMissing(
							allowFileNotFound,
							path,
							() => {
								return this.resolve(
									path,
									{
										workerQueue,
										all: true,
										async: false,
										ancestry: [],
									},
									diagnosticsProcessor,
									analyzeProgress,
								);
							},
						);
						roots.push(ret);
					},
				},
			);
			const roots = [];

			for (const path of paths) {
				await ___R$project$rome$$internal$fs$FileNotFound_ts$FileNotFound.maybeAllowMissing(
					allowFileNotFound,
					path,
					() => rootQueue.pushPath(path),
				);
			}

			// Spin root queue
			await rootQueue.spin();

			// Spin worker queue
			await workerQueue.spin();

			if (diagnosticsProcessor.hasDiagnostics()) {
				return;
			}

			if (validate) {
				for (const ret of roots) {
					if (!ret.missing) {
						const root = ret.value;
						await ___R$project$rome$$internal$fs$FileNotFound_ts$FileNotFound.maybeAllowMissing(
							allowFileNotFound,
							root.path,
							() => this.validateTransitive(root, diagnosticsProcessor),
						);
					}
				}
			}
		}

		validate(node, diagnosticsProcessor) {
			const resolvedImports = node.resolveImports();
			return (
				diagnosticsProcessor.addDiagnostics(resolvedImports.diagnostics).length >
				0
			);
		}

		validateTransitive(node, diagnosticsProcessor) {
			const order = node.getDependencyOrder();
			diagnosticsProcessor.addDiagnostics(order.diagnostics);

			for (const path of order.files) {
				this.validate(this.getNode(path), diagnosticsProcessor);
			}
		}

		async resolve(path, opts, diagnosticsProcessor, analyzeProgress) {
			const filename = path.join();
			const {async, all, ancestry} = opts;
			const {server} = this;

			// We have a lock here in case we hit `this.resolve` while we're waiting for the `analyzeDependencies` result
			const lock = await this.locker.getLock(filename);

			if (this.nodes.has(path)) {
				const node = this.getNode(path);

				if (all) {
					node.setAll(true);
				}

				if (async) {
					node.setUsedAsync(true);
				}

				lock.release();

				return node;
			}

			const progressText = ___R$project$rome$$internal$markup$escape_ts$markup`<filelink target="${filename}" />`;
			let progressId;

			if (analyzeProgress !== undefined) {
				progressId = analyzeProgress.pushText(progressText);
			}

			let res;
			let node;
			try {
				res = await this.request.requestWorkerAnalyzeDependencies(path, {});

				node = this.addNode(path, res);
				node.setAll(all);
				node.setUsedAsync(async);
			} finally {
				lock.release();
			}

			const {dependencies, diagnostics} = res;

			if (diagnostics.length > 0) {
				diagnosticsProcessor.addDiagnostics(diagnostics);
			}

			// If we're a remote path then the origin should be the URL and not our local path
			const remote = this.server.projectManager.getRemoteFromLocalPath(path);
			const origin = remote === undefined ? path : remote.getParent();

			// Resolve full locations
			await Promise.all(
				dependencies.map(async (dep) => {
					const {source, optional} = dep;
					if (this.isExternal(path, source)) {
						return;
					}

					const {diagnostics} = await ___R$project$rome$$internal$diagnostics$wrap_ts$catchDiagnostics(
						async () => {
							const resolved = await server.resolver.resolveAssert(
								Object.assign(
									{},
									this.resolverOpts,
									{
										origin,
										source: ___R$project$rome$$internal$path$index_ts$createUnknownPath(
											source,
										),
									},
								),
								dep.loc === undefined
									? undefined
									: {
											location: Object.assign(
												{sourceText: undefined},
												dep.loc,
												{mtime: undefined},
											),
										},
							);

							node.addDependency(source, resolved.path, dep);
						},
						{
							category: "DependencyGraph",
							message: "Caught by resolve",
						},
					);

					if (diagnostics !== undefined && !optional) {
						diagnosticsProcessor.addDiagnostics(diagnostics);
					}
				}),
			);

			// Queue our dependencies...
			const subAncestry = [...ancestry, filename];
			for (const path of node.getAbsoluteDependencies()) {
				const dep = node.getDependencyInfoFromAbsolute(path).analyze;
				await opts.workerQueue.pushPath(
					path,
					{
						all: dep.all,
						async: dep.async,
						type: dep.type,
						loc: dep.loc,
						ancestry: subAncestry,
					},
				);
			}

			if (analyzeProgress !== undefined && progressId !== undefined) {
				analyzeProgress.popText(progressId);
				analyzeProgress.tick();
			}

			return node;
		}
	}


  // project-rome/@internal/core/server/bundler/BundleRequest.ts
class ___R$project$rome$$internal$core$server$bundler$BundleRequest_ts$default {
		constructor(
			{
				bundler,
				reporter,
				graph,
				request,
				server,
				resolvedEntry,
				options,
			},
		) {
			this.options = options;
			this.reporter = reporter;
			this.bundler = bundler;
			this.graph = graph;
			this.server = server;
			this.cached = true;

			this.resolvedEntry = resolvedEntry;
			this.resolvedEntryUid = server.projectManager.getUid(resolvedEntry);

			this.diagnostics = request.createDiagnosticsProcessor({
				origins: [
					{
						category: "bundler",
						message: 'Requested bundle for <filelink target="' +
						this.resolvedEntryUid +
						'" />',
					},
				],
			});
			this.diagnostics.addAllowedUnusedSuppressionPrefix("lint");

			this.sourceMap = new ___R$project$rome$$internal$codec$source$map$SourceMapGenerator_ts$default({
				file: this.resolvedEntry.getBasename(),
			});

			this.assets = new Map();
		}

		async stepAnalyze() {
			const {reporter, graph} = this;

			const analyzeProgress = reporter.progress({
				name: "bundler:analyze:" + this.resolvedEntryUid,
				title: ___R$project$rome$$internal$markup$escape_ts$markup`Analyzing`,
			});
			this.diagnostics.setThrowAfter(100);
			try {
				await graph.seed({
					paths: [this.resolvedEntry],
					diagnosticsProcessor: this.diagnostics,
					analyzeProgress,
					validate: true,
				});
			} finally {
				analyzeProgress.end();
			}

			return graph.getNode(this.resolvedEntry).getDependencyOrder();
		}

		async stepCompile(paths) {
			const {server} = this;
			const {reporter} = this;
			this.diagnostics.setThrowAfter(undefined);

			const compilingSpinner = reporter.progress({
				name: "bundler:compile:" + this.resolvedEntryUid,
				title: ___R$project$rome$$internal$markup$escape_ts$markup`Compiling`,
			});
			compilingSpinner.setTotal(paths.length);

			const queue = new ___R$project$rome$$internal$core$server$WorkerQueue_ts$default(
				server,
				{
					callback: async ({path}) => {
						const progressId = compilingSpinner.pushText(
							___R$project$rome$$internal$markup$escape_ts$markup`${path}`,
						);

						const res = await this.bundler.compileJS(path);

						if (res.asset !== undefined) {
							this.assets.set(res.asset.path, res.asset.buffer);
						}

						if (!res.cached) {
							this.cached = false;
						}

						this.diagnostics.addSuppressions(res.suppressions);
						this.diagnostics.addDiagnostics(res.diagnostics);

						compilingSpinner.popText(progressId);
						compilingSpinner.tick();
					},
				},
			);

			for (const path of paths) {
				await queue.pushPath(path);
			}

			await queue.spin();
			compilingSpinner.end();
		}

		stepCombine(order, forceSourceMaps = false) {
			const {sourceMap} = this;

			// We allow deferring the generation of source maps. We don't do this by default as it's slower than generating them upfront
			// which is what most callers need. But for things like tests, we want to lazily compute the source map only when diagnostics
			// are present.
			let deferredSourceMaps =
				!forceSourceMaps && this.options.deferredSourceMaps;
			if (deferredSourceMaps) {
				sourceMap.addMaterializer(() => {
					this.stepCombine(order, true);
				});
			}

			const assembled = [];
			let lineOffset = 0;

			function track(str) {
				if (!deferredSourceMaps) {
					lineOffset++;
					for (let cha of str) {
						if (cha === "\n") {
							lineOffset++;
						}
					}
				}
			}

			function push(str) {
				assembled.push([0, str]);
				track(str);
			}

			function addMappings(filename, sourceContent, mappings) {
				if (deferredSourceMaps) {
					return;
				}

				sourceMap.setSourceContent(filename, sourceContent);
				for (const mapping of mappings) {
					sourceMap.addMapping(
						Object.assign(
							{},
							mapping,
							{
								generated: Object.assign(
									{},
									mapping.generated,
									{
										line: ___R$project$rome$$internal$ob1$index_ts$ob1Add(
											lineOffset,
											mapping.generated.line,
										),
									},
								),
							},
						),
					);
				}
			}

			const {interpreter} = this.options;
			if (interpreter !== undefined) {
				push("#!" + interpreter + "\n");
			}

			push(
				___R$project$rome$$internal$string$utils$dedent_ts$dedent`
		(function(res) {
			if (typeof module !== "undefined") {
				module.exports = res;
			}
			return res;
		})(`,
			);

			// add on bootstrap
			if (order.firstTopAwaitLocations.length > 0) {
				push("(async function(global) {");
			} else {
				push("(function(global) {");
			}

			push("  'use strict';");

			// TODO prelude

			/*
		const path = createAbsoluteFilePath(loc);
		const res = await this.bundler.request.requestWorkerCompile(
			path,
			'compile',
		);
		push('(function() {');
		addMappings(
			this.bundler.server.projectManager.getUid(path),
			res.src,
			res.mappings,
		);
		push(res.code);
		push('})();');
		*/
			const declaredCJS = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet();
			const declareCJS = (node) => {
				if (node.type !== "cjs" || declaredCJS.has(node.path)) {
					return;
				}

				declaredCJS.add(node.path);

				const uid = this.server.projectManager.getUid(node.path);
				push(
					"  var " +
					___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(
						uid,
					) +
					" = {};",
				);
			};

			// Add on files
			for (const path of order.files) {
				const node = this.graph.getNode(path);
				const uid = this.server.projectManager.getUid(path);

				for (const path of node.getAbsoluteDependencies()) {
					declareCJS(this.graph.getNode(path));
				}

				const compileResult = this.bundler.compiles.assert(path);

				push("  // " + uid);

				declareCJS(node);

				addMappings(uid, compileResult.sourceText, compileResult.mappings);

				track(compileResult.compiledCode);
				assembled.push([1, path]);
				push("");
			}

			// push on initial entry require
			const entryModuleUid = this.server.projectManager.getUid(
				this.resolvedEntry,
			);
			push(
				"  return " +
				___R$project$rome$$internal$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(
					entryModuleUid,
				) +
				";",
			);

			// push footer
			push(
				"})(typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this));",
			);

			//
			if (this.bundler.config.inlineSourceMap) {
				const sourceMapComment = sourceMap.toComment();
				assembled.push([0, sourceMapComment]);
			} else {
				assembled.push([
					0,
					"//# sourceMappingURL=" + this.sourceMap.file + ".map",
				]);
			}

			return {
				request: this,
				diagnostics: this.diagnostics.getDiagnostics(),
				assembled,
				sourceMap,
				cached: this.cached,
				assets: this.assets,
			};
		}

		shouldAbort() {
			return this.diagnostics.hasDiagnostics();
		}

		abort() {
			return {
				request: this,
				sourceMap: this.sourceMap,
				assembled: [],
				diagnostics: this.diagnostics.getDiagnostics(),
				cached: false,
				assets: this.assets,
			};
		}

		async bundle(combine = true) {
			const order = await this.stepAnalyze();
			if (this.shouldAbort()) {
				return this.abort();
			}

			// Compile
			await this.stepCompile(order.files);
			if (this.shouldAbort() || !combine) {
				return this.abort();
			}

			// Combine
			return this.stepCombine(order);
		}
	}


  // project-rome/@internal/codec-spdx-license/data.ts
const ___R$project$rome$$internal$codec$spdx$license$data_ts$default = {
		licenseListVersion: "3.8-4-gd79c632",
		licenses: [
			{
				reference: "./0BSD.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/0BSD.json",
				referenceNumber: "231",
				name: "BSD Zero Clause License",
				licenseId: "0BSD",
				seeAlso: ["http://landley.net/toybox/license.html"],
				isOsiApproved: true,
			},
			{
				reference: "./AAL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/AAL.json",
				referenceNumber: "57",
				name: "Attribution Assurance License",
				licenseId: "AAL",
				seeAlso: ["https://opensource.org/licenses/attribution"],
				isOsiApproved: true,
			},
			{
				reference: "./ADSL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/ADSL.json",
				referenceNumber: "210",
				name: "Amazon Digital Services License",
				licenseId: "ADSL",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/AmazonDigitalServicesLicense",
				],
				isOsiApproved: false,
			},
			{
				reference: "./AFL-1.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/AFL-1.1.json",
				referenceNumber: "28",
				name: "Academic Free License v1.1",
				licenseId: "AFL-1.1",
				seeAlso: [
					"http://opensource.linux-mirror.org/licenses/afl-1.1.txt",
					"http://wayback.archive.org/web/20021004124254/http://www.opensource.org/licenses/academic.php",
				],
				isOsiApproved: true,
			},
			{
				reference: "./AFL-1.2.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/AFL-1.2.json",
				referenceNumber: "215",
				name: "Academic Free License v1.2",
				licenseId: "AFL-1.2",
				seeAlso: [
					"http://opensource.linux-mirror.org/licenses/afl-1.2.txt",
					"http://wayback.archive.org/web/20021204204652/http://www.opensource.org/licenses/academic.php",
				],
				isOsiApproved: true,
			},
			{
				reference: "./AFL-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/AFL-2.0.json",
				referenceNumber: "330",
				name: "Academic Free License v2.0",
				licenseId: "AFL-2.0",
				seeAlso: [
					"http://wayback.archive.org/web/20060924134533/http://www.opensource.org/licenses/afl-2.0.txt",
				],
				isOsiApproved: true,
			},
			{
				reference: "./AFL-2.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/AFL-2.1.json",
				referenceNumber: "241",
				name: "Academic Free License v2.1",
				licenseId: "AFL-2.1",
				seeAlso: ["http://opensource.linux-mirror.org/licenses/afl-2.1.txt"],
				isOsiApproved: true,
			},
			{
				reference: "./AFL-3.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/AFL-3.0.json",
				referenceNumber: "350",
				name: "Academic Free License v3.0",
				licenseId: "AFL-3.0",
				seeAlso: [
					"http://www.rosenlaw.com/AFL3.0.htm",
					"https://opensource.org/licenses/afl-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./AGPL-1.0.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/AGPL-1.0.json",
				referenceNumber: "169",
				name: "Affero General Public License v1.0",
				licenseId: "AGPL-1.0",
				seeAlso: ["http://www.affero.org/oagpl.html"],
				isOsiApproved: false,
			},
			{
				reference: "./AGPL-1.0-only.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/AGPL-1.0-only.json",
				referenceNumber: "68",
				name: "Affero General Public License v1.0 only",
				licenseId: "AGPL-1.0-only",
				seeAlso: ["http://www.affero.org/oagpl.html"],
				isOsiApproved: false,
			},
			{
				reference: "./AGPL-1.0-or-later.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/AGPL-1.0-or-later.json",
				referenceNumber: "162",
				name: "Affero General Public License v1.0 or later",
				licenseId: "AGPL-1.0-or-later",
				seeAlso: ["http://www.affero.org/oagpl.html"],
				isOsiApproved: false,
			},
			{
				reference: "./AGPL-3.0.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/AGPL-3.0.json",
				referenceNumber: "143",
				name: "GNU Affero General Public License v3.0",
				licenseId: "AGPL-3.0",
				seeAlso: [
					"https://www.gnu.org/licenses/agpl.txt",
					"https://opensource.org/licenses/AGPL-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./AGPL-3.0-only.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/AGPL-3.0-only.json",
				referenceNumber: "287",
				name: "GNU Affero General Public License v3.0 only",
				licenseId: "AGPL-3.0-only",
				seeAlso: [
					"https://www.gnu.org/licenses/agpl.txt",
					"https://opensource.org/licenses/AGPL-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./AGPL-3.0-or-later.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/AGPL-3.0-or-later.json",
				referenceNumber: "154",
				name: "GNU Affero General Public License v3.0 or later",
				licenseId: "AGPL-3.0-or-later",
				seeAlso: [
					"https://www.gnu.org/licenses/agpl.txt",
					"https://opensource.org/licenses/AGPL-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./AMDPLPA.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/AMDPLPA.json",
				referenceNumber: "128",
				name: "AMD's plpa_map.c License",
				licenseId: "AMDPLPA",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/AMD_plpa_map_License",
				],
				isOsiApproved: false,
			},
			{
				reference: "./AML.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/AML.json",
				referenceNumber: "151",
				name: "Apple MIT License",
				licenseId: "AML",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Apple_MIT_License"],
				isOsiApproved: false,
			},
			{
				reference: "./AMPAS.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/AMPAS.json",
				referenceNumber: "131",
				name: "Academy of Motion Picture Arts and Sciences BSD",
				licenseId: "AMPAS",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/BSD#AMPASBSD"],
				isOsiApproved: false,
			},
			{
				reference: "./ANTLR-PD.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/ANTLR-PD.json",
				referenceNumber: "44",
				name: "ANTLR Software Rights Notice",
				licenseId: "ANTLR-PD",
				seeAlso: ["http://www.antlr2.org/license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./APAFML.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/APAFML.json",
				referenceNumber: "240",
				name: "Adobe Postscript AFM License",
				licenseId: "APAFML",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/AdobePostscriptAFM"],
				isOsiApproved: false,
			},
			{
				reference: "./APL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/APL-1.0.json",
				referenceNumber: "268",
				name: "Adaptive Public License 1.0",
				licenseId: "APL-1.0",
				seeAlso: ["https://opensource.org/licenses/APL-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./APSL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/APSL-1.0.json",
				referenceNumber: "375",
				name: "Apple Public Source License 1.0",
				licenseId: "APSL-1.0",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/Apple_Public_Source_License_1.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./APSL-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/APSL-1.1.json",
				referenceNumber: "327",
				name: "Apple Public Source License 1.1",
				licenseId: "APSL-1.1",
				seeAlso: [
					"http://www.opensource.apple.com/source/IOSerialFamily/IOSerialFamily-7/APPLE_LICENSE",
				],
				isOsiApproved: true,
			},
			{
				reference: "./APSL-1.2.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/APSL-1.2.json",
				referenceNumber: "194",
				name: "Apple Public Source License 1.2",
				licenseId: "APSL-1.2",
				seeAlso: [
					"http://www.samurajdata.se/opensource/mirror/licenses/apsl.php",
				],
				isOsiApproved: true,
			},
			{
				reference: "./APSL-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/APSL-2.0.json",
				referenceNumber: "136",
				name: "Apple Public Source License 2.0",
				licenseId: "APSL-2.0",
				seeAlso: ["http://www.opensource.apple.com/license/apsl/"],
				isOsiApproved: true,
			},
			{
				reference: "./Abstyles.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Abstyles.json",
				referenceNumber: "72",
				name: "Abstyles License",
				licenseId: "Abstyles",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Abstyles"],
				isOsiApproved: false,
			},
			{
				reference: "./Adobe-2006.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Adobe-2006.json",
				referenceNumber: "299",
				name: "Adobe Systems Incorporated Source Code License Agreement",
				licenseId: "Adobe-2006",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/AdobeLicense"],
				isOsiApproved: false,
			},
			{
				reference: "./Adobe-Glyph.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Adobe-Glyph.json",
				referenceNumber: "332",
				name: "Adobe Glyph List License",
				licenseId: "Adobe-Glyph",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/MIT#AdobeGlyph"],
				isOsiApproved: false,
			},
			{
				reference: "./Afmparse.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Afmparse.json",
				referenceNumber: "321",
				name: "Afmparse License",
				licenseId: "Afmparse",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Afmparse"],
				isOsiApproved: false,
			},
			{
				reference: "./Aladdin.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Aladdin.json",
				referenceNumber: "304",
				name: "Aladdin Free Public License",
				licenseId: "Aladdin",
				seeAlso: ["http://pages.cs.wisc.edu/~ghost/doc/AFPL/6.01/Public.htm"],
				isOsiApproved: false,
			},
			{
				reference: "./Apache-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Apache-1.0.json",
				referenceNumber: "32",
				name: "Apache License 1.0",
				licenseId: "Apache-1.0",
				seeAlso: ["http://www.apache.org/licenses/LICENSE-1.0"],
				isOsiApproved: false,
			},
			{
				reference: "./Apache-1.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Apache-1.1.json",
				referenceNumber: "264",
				name: "Apache License 1.1",
				licenseId: "Apache-1.1",
				seeAlso: [
					"http://apache.org/licenses/LICENSE-1.1",
					"https://opensource.org/licenses/Apache-1.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./Apache-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Apache-2.0.json",
				referenceNumber: "355",
				name: "Apache License 2.0",
				licenseId: "Apache-2.0",
				seeAlso: [
					"http://www.apache.org/licenses/LICENSE-2.0",
					"https://opensource.org/licenses/Apache-2.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./Artistic-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Artistic-1.0.json",
				referenceNumber: "263",
				name: "Artistic License 1.0",
				licenseId: "Artistic-1.0",
				seeAlso: ["https://opensource.org/licenses/Artistic-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./Artistic-1.0-Perl.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Artistic-1.0-Perl.json",
				referenceNumber: "295",
				name: "Artistic License 1.0 (Perl)",
				licenseId: "Artistic-1.0-Perl",
				seeAlso: ["http://dev.perl.org/licenses/artistic.html"],
				isOsiApproved: true,
			},
			{
				reference: "./Artistic-1.0-cl8.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Artistic-1.0-cl8.json",
				referenceNumber: "221",
				name: "Artistic License 1.0 w/clause 8",
				licenseId: "Artistic-1.0-cl8",
				seeAlso: ["https://opensource.org/licenses/Artistic-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./Artistic-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Artistic-2.0.json",
				referenceNumber: "75",
				name: "Artistic License 2.0",
				licenseId: "Artistic-2.0",
				seeAlso: [
					"http://www.perlfoundation.org/artistic_license_2_0",
					"https://opensource.org/licenses/artistic-license-2.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./BSD-1-Clause.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BSD-1-Clause.json",
				referenceNumber: "377",
				name: "BSD 1-Clause License",
				licenseId: "BSD-1-Clause",
				seeAlso: [
					"https://svnweb.freebsd.org/base/head/include/ifaddrs.h?revision=326823",
				],
				isOsiApproved: false,
			},
			{
				reference: "./BSD-2-Clause.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BSD-2-Clause.json",
				referenceNumber: "296",
				name: 'BSD 2-Clause "Simplified" License',
				licenseId: "BSD-2-Clause",
				seeAlso: ["https://opensource.org/licenses/BSD-2-Clause"],
				isOsiApproved: true,
			},
			{
				reference: "./BSD-2-Clause-FreeBSD.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/BSD-2-Clause-FreeBSD.json",
				referenceNumber: "271",
				name: "BSD 2-Clause FreeBSD License",
				licenseId: "BSD-2-Clause-FreeBSD",
				seeAlso: ["http://www.freebsd.org/copyright/freebsd-license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./BSD-2-Clause-NetBSD.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BSD-2-Clause-NetBSD.json",
				referenceNumber: "179",
				name: "BSD 2-Clause NetBSD License",
				licenseId: "BSD-2-Clause-NetBSD",
				seeAlso: ["http://www.netbsd.org/about/redistribution.html#default"],
				isOsiApproved: false,
			},
			{
				reference: "./BSD-2-Clause-Patent.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BSD-2-Clause-Patent.json",
				referenceNumber: "351",
				name: "BSD-2-Clause Plus Patent License",
				licenseId: "BSD-2-Clause-Patent",
				seeAlso: ["https://opensource.org/licenses/BSDplusPatent"],
				isOsiApproved: true,
			},
			{
				reference: "./BSD-3-Clause.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/BSD-3-Clause.json",
				referenceNumber: "195",
				name: 'BSD 3-Clause "New" or "Revised" License',
				licenseId: "BSD-3-Clause",
				seeAlso: ["https://opensource.org/licenses/BSD-3-Clause"],
				isOsiApproved: true,
			},
			{
				reference: "./BSD-3-Clause-Attribution.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BSD-3-Clause-Attribution.json",
				referenceNumber: "39",
				name: "BSD with attribution",
				licenseId: "BSD-3-Clause-Attribution",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/BSD_with_Attribution",
				],
				isOsiApproved: false,
			},
			{
				reference: "./BSD-3-Clause-Clear.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/BSD-3-Clause-Clear.json",
				referenceNumber: "84",
				name: "BSD 3-Clause Clear License",
				licenseId: "BSD-3-Clause-Clear",
				seeAlso: ["http://labs.metacarta.com/license-explanation.html#license"],
				isOsiApproved: false,
			},
			{
				reference: "./BSD-3-Clause-LBNL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BSD-3-Clause-LBNL.json",
				referenceNumber: "142",
				name: "Lawrence Berkeley National Labs BSD variant license",
				licenseId: "BSD-3-Clause-LBNL",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/LBNLBSD"],
				isOsiApproved: true,
			},
			{
				reference: "./BSD-3-Clause-No-Nuclear-License.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BSD-3-Clause-No-Nuclear-License.json",
				referenceNumber: "59",
				name: "BSD 3-Clause No Nuclear License",
				licenseId: "BSD-3-Clause-No-Nuclear-License",
				seeAlso: [
					"http://download.oracle.com/otn-pub/java/licenses/bsd.txt?AuthParam=1467140197_43d516ce1776bd08a58235a7785be1cc",
				],
				isOsiApproved: false,
			},
			{
				reference: "./BSD-3-Clause-No-Nuclear-License-2014.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BSD-3-Clause-No-Nuclear-License-2014.json",
				referenceNumber: "331",
				name: "BSD 3-Clause No Nuclear License 2014",
				licenseId: "BSD-3-Clause-No-Nuclear-License-2014",
				seeAlso: [
					"https://java.net/projects/javaeetutorial/pages/BerkeleyLicense",
				],
				isOsiApproved: false,
			},
			{
				reference: "./BSD-3-Clause-No-Nuclear-Warranty.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BSD-3-Clause-No-Nuclear-Warranty.json",
				referenceNumber: "113",
				name: "BSD 3-Clause No Nuclear Warranty",
				licenseId: "BSD-3-Clause-No-Nuclear-Warranty",
				seeAlso: [
					"https://jogamp.org/git/?p=gluegen.git;a=blob_plain;f=LICENSE.txt",
				],
				isOsiApproved: false,
			},
			{
				reference: "./BSD-3-Clause-Open-MPI.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BSD-3-Clause-Open-MPI.json",
				referenceNumber: "207",
				name: "BSD 3-Clause Open MPI variant",
				licenseId: "BSD-3-Clause-Open-MPI",
				seeAlso: [
					"https://www.open-mpi.org/community/license.php",
					"http://www.netlib.org/lapack/LICENSE.txt",
				],
				isOsiApproved: false,
			},
			{
				reference: "./BSD-4-Clause.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/BSD-4-Clause.json",
				referenceNumber: "66",
				name: 'BSD 4-Clause "Original" or "Old" License',
				licenseId: "BSD-4-Clause",
				seeAlso: ["http://directory.fsf.org/wiki/License:BSD_4Clause"],
				isOsiApproved: false,
			},
			{
				reference: "./BSD-4-Clause-UC.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BSD-4-Clause-UC.json",
				referenceNumber: "361",
				name: "BSD-4-Clause (University of California-Specific)",
				licenseId: "BSD-4-Clause-UC",
				seeAlso: ["http://www.freebsd.org/copyright/license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./BSD-Protection.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BSD-Protection.json",
				referenceNumber: "388",
				name: "BSD Protection License",
				licenseId: "BSD-Protection",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/BSD_Protection_License",
				],
				isOsiApproved: false,
			},
			{
				reference: "./BSD-Source-Code.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BSD-Source-Code.json",
				referenceNumber: "163",
				name: "BSD Source Code Attribution",
				licenseId: "BSD-Source-Code",
				seeAlso: [
					"https://github.com/robbiehanson/CocoaHTTPServer/blob/server/LICENSE.txt",
				],
				isOsiApproved: false,
			},
			{
				reference: "./BSL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/BSL-1.0.json",
				referenceNumber: "284",
				name: "Boost Software License 1.0",
				licenseId: "BSL-1.0",
				seeAlso: [
					"http://www.boost.org/LICENSE_1_0.txt",
					"https://opensource.org/licenses/BSL-1.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./Bahyph.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Bahyph.json",
				referenceNumber: "146",
				name: "Bahyph License",
				licenseId: "Bahyph",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Bahyph"],
				isOsiApproved: false,
			},
			{
				reference: "./Barr.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Barr.json",
				referenceNumber: "123",
				name: "Barr License",
				licenseId: "Barr",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Barr"],
				isOsiApproved: false,
			},
			{
				reference: "./Beerware.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Beerware.json",
				referenceNumber: "243",
				name: "Beerware License",
				licenseId: "Beerware",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/Beerware",
					"https://people.freebsd.org/~phk/",
				],
				isOsiApproved: false,
			},
			{
				reference: "./BitTorrent-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BitTorrent-1.0.json",
				referenceNumber: "200",
				name: "BitTorrent Open Source License v1.0",
				licenseId: "BitTorrent-1.0",
				seeAlso: [
					"http://sources.gentoo.org/cgi-bin/viewvc.cgi/gentoo-x86/licenses/BitTorrent?r1=1.1&r2=1.1.1.1&diff_format=s",
				],
				isOsiApproved: false,
			},
			{
				reference: "./BitTorrent-1.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/BitTorrent-1.1.json",
				referenceNumber: "181",
				name: "BitTorrent Open Source License v1.1",
				licenseId: "BitTorrent-1.1",
				seeAlso: ["http://directory.fsf.org/wiki/License:BitTorrentOSL1.1"],
				isOsiApproved: false,
			},
			{
				reference: "./BlueOak-1.0.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BlueOak-1.0.0.json",
				referenceNumber: "204",
				name: "Blue Oak Model License 1.0.0",
				licenseId: "BlueOak-1.0.0",
				seeAlso: ["https://blueoakcouncil.org/license/1.0.0"],
				isOsiApproved: false,
			},
			{
				reference: "./Borceux.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Borceux.json",
				referenceNumber: "294",
				name: "Borceux license",
				licenseId: "Borceux",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Borceux"],
				isOsiApproved: false,
			},
			{
				reference: "./CATOSL-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CATOSL-1.1.json",
				referenceNumber: "226",
				name: "Computer Associates Trusted Open Source License 1.1",
				licenseId: "CATOSL-1.1",
				seeAlso: ["https://opensource.org/licenses/CATOSL-1.1"],
				isOsiApproved: true,
			},
			{
				reference: "./CC-BY-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-1.0.json",
				referenceNumber: "23",
				name: "Creative Commons Attribution 1.0 Generic",
				licenseId: "CC-BY-1.0",
				seeAlso: ["https://creativecommons.org/licenses/by/1.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-2.0.json",
				referenceNumber: "58",
				name: "Creative Commons Attribution 2.0 Generic",
				licenseId: "CC-BY-2.0",
				seeAlso: ["https://creativecommons.org/licenses/by/2.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-2.5.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-2.5.json",
				referenceNumber: "180",
				name: "Creative Commons Attribution 2.5 Generic",
				licenseId: "CC-BY-2.5",
				seeAlso: ["https://creativecommons.org/licenses/by/2.5/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-3.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-3.0.json",
				referenceNumber: "333",
				name: "Creative Commons Attribution 3.0 Unported",
				licenseId: "CC-BY-3.0",
				seeAlso: ["https://creativecommons.org/licenses/by/3.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-4.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/CC-BY-4.0.json",
				referenceNumber: "211",
				name: "Creative Commons Attribution 4.0 International",
				licenseId: "CC-BY-4.0",
				seeAlso: ["https://creativecommons.org/licenses/by/4.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-1.0.json",
				referenceNumber: "223",
				name: "Creative Commons Attribution Non Commercial 1.0 Generic",
				licenseId: "CC-BY-NC-1.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nc/1.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-2.0.json",
				referenceNumber: "315",
				name: "Creative Commons Attribution Non Commercial 2.0 Generic",
				licenseId: "CC-BY-NC-2.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nc/2.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-2.5.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-2.5.json",
				referenceNumber: "386",
				name: "Creative Commons Attribution Non Commercial 2.5 Generic",
				licenseId: "CC-BY-NC-2.5",
				seeAlso: ["https://creativecommons.org/licenses/by-nc/2.5/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-3.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-3.0.json",
				referenceNumber: "325",
				name: "Creative Commons Attribution Non Commercial 3.0 Unported",
				licenseId: "CC-BY-NC-3.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nc/3.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-4.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-4.0.json",
				referenceNumber: "262",
				name: "Creative Commons Attribution Non Commercial 4.0 International",
				licenseId: "CC-BY-NC-4.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nc/4.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-ND-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-ND-1.0.json",
				referenceNumber: "98",
				name: "Creative Commons Attribution Non Commercial No Derivatives 1.0 Generic",
				licenseId: "CC-BY-NC-ND-1.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nd-nc/1.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-ND-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-ND-2.0.json",
				referenceNumber: "133",
				name: "Creative Commons Attribution Non Commercial No Derivatives 2.0 Generic",
				licenseId: "CC-BY-NC-ND-2.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nc-nd/2.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-ND-2.5.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-ND-2.5.json",
				referenceNumber: "30",
				name: "Creative Commons Attribution Non Commercial No Derivatives 2.5 Generic",
				licenseId: "CC-BY-NC-ND-2.5",
				seeAlso: ["https://creativecommons.org/licenses/by-nc-nd/2.5/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-ND-3.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-ND-3.0.json",
				referenceNumber: "41",
				name: "Creative Commons Attribution Non Commercial No Derivatives 3.0 Unported",
				licenseId: "CC-BY-NC-ND-3.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nc-nd/3.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-ND-4.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-ND-4.0.json",
				referenceNumber: "166",
				name: "Creative Commons Attribution Non Commercial No Derivatives 4.0 International",
				licenseId: "CC-BY-NC-ND-4.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nc-nd/4.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-SA-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-SA-1.0.json",
				referenceNumber: "116",
				name: "Creative Commons Attribution Non Commercial Share Alike 1.0 Generic",
				licenseId: "CC-BY-NC-SA-1.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nc-sa/1.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-SA-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-SA-2.0.json",
				referenceNumber: "398",
				name: "Creative Commons Attribution Non Commercial Share Alike 2.0 Generic",
				licenseId: "CC-BY-NC-SA-2.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nc-sa/2.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-SA-2.5.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-SA-2.5.json",
				referenceNumber: "208",
				name: "Creative Commons Attribution Non Commercial Share Alike 2.5 Generic",
				licenseId: "CC-BY-NC-SA-2.5",
				seeAlso: ["https://creativecommons.org/licenses/by-nc-sa/2.5/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-SA-3.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-SA-3.0.json",
				referenceNumber: "349",
				name: "Creative Commons Attribution Non Commercial Share Alike 3.0 Unported",
				licenseId: "CC-BY-NC-SA-3.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nc-sa/3.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-SA-4.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-SA-4.0.json",
				referenceNumber: "320",
				name: "Creative Commons Attribution Non Commercial Share Alike 4.0 International",
				licenseId: "CC-BY-NC-SA-4.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-ND-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-ND-1.0.json",
				referenceNumber: "90",
				name: "Creative Commons Attribution No Derivatives 1.0 Generic",
				licenseId: "CC-BY-ND-1.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nd/1.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-ND-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-ND-2.0.json",
				referenceNumber: "46",
				name: "Creative Commons Attribution No Derivatives 2.0 Generic",
				licenseId: "CC-BY-ND-2.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nd/2.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-ND-2.5.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-ND-2.5.json",
				referenceNumber: "27",
				name: "Creative Commons Attribution No Derivatives 2.5 Generic",
				licenseId: "CC-BY-ND-2.5",
				seeAlso: ["https://creativecommons.org/licenses/by-nd/2.5/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-ND-3.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-ND-3.0.json",
				referenceNumber: "274",
				name: "Creative Commons Attribution No Derivatives 3.0 Unported",
				licenseId: "CC-BY-ND-3.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nd/3.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-ND-4.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-ND-4.0.json",
				referenceNumber: "307",
				name: "Creative Commons Attribution No Derivatives 4.0 International",
				licenseId: "CC-BY-ND-4.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nd/4.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-SA-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-SA-1.0.json",
				referenceNumber: "391",
				name: "Creative Commons Attribution Share Alike 1.0 Generic",
				licenseId: "CC-BY-SA-1.0",
				seeAlso: ["https://creativecommons.org/licenses/by-sa/1.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-SA-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-SA-2.0.json",
				referenceNumber: "356",
				name: "Creative Commons Attribution Share Alike 2.0 Generic",
				licenseId: "CC-BY-SA-2.0",
				seeAlso: ["https://creativecommons.org/licenses/by-sa/2.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-SA-2.5.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-SA-2.5.json",
				referenceNumber: "196",
				name: "Creative Commons Attribution Share Alike 2.5 Generic",
				licenseId: "CC-BY-SA-2.5",
				seeAlso: ["https://creativecommons.org/licenses/by-sa/2.5/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-SA-3.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-SA-3.0.json",
				referenceNumber: "225",
				name: "Creative Commons Attribution Share Alike 3.0 Unported",
				licenseId: "CC-BY-SA-3.0",
				seeAlso: ["https://creativecommons.org/licenses/by-sa/3.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-SA-4.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/CC-BY-SA-4.0.json",
				referenceNumber: "286",
				name: "Creative Commons Attribution Share Alike 4.0 International",
				licenseId: "CC-BY-SA-4.0",
				seeAlso: ["https://creativecommons.org/licenses/by-sa/4.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-PDDC.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-PDDC.json",
				referenceNumber: "88",
				name: "Creative Commons Public Domain Dedication and Certification",
				licenseId: "CC-PDDC",
				seeAlso: ["https://creativecommons.org/licenses/publicdomain/"],
				isOsiApproved: false,
			},
			{
				reference: "./CC0-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/CC0-1.0.json",
				referenceNumber: "63",
				name: "Creative Commons Zero v1.0 Universal",
				licenseId: "CC0-1.0",
				seeAlso: ["https://creativecommons.org/publicdomain/zero/1.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CDDL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/CDDL-1.0.json",
				referenceNumber: "324",
				name: "Common Development and Distribution License 1.0",
				licenseId: "CDDL-1.0",
				seeAlso: ["https://opensource.org/licenses/cddl1"],
				isOsiApproved: true,
			},
			{
				reference: "./CDDL-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CDDL-1.1.json",
				referenceNumber: "273",
				name: "Common Development and Distribution License 1.1",
				licenseId: "CDDL-1.1",
				seeAlso: [
					"http://glassfish.java.net/public/CDDL+GPL_1_1.html",
					"https://javaee.github.io/glassfish/LICENSE",
				],
				isOsiApproved: false,
			},
			{
				reference: "./CDLA-Permissive-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CDLA-Permissive-1.0.json",
				referenceNumber: "104",
				name: "Community Data License Agreement Permissive 1.0",
				licenseId: "CDLA-Permissive-1.0",
				seeAlso: ["https://cdla.io/permissive-1-0"],
				isOsiApproved: false,
			},
			{
				reference: "./CDLA-Sharing-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CDLA-Sharing-1.0.json",
				referenceNumber: "172",
				name: "Community Data License Agreement Sharing 1.0",
				licenseId: "CDLA-Sharing-1.0",
				seeAlso: ["https://cdla.io/sharing-1-0"],
				isOsiApproved: false,
			},
			{
				reference: "./CECILL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CECILL-1.0.json",
				referenceNumber: "10",
				name: "CeCILL Free Software License Agreement v1.0",
				licenseId: "CECILL-1.0",
				seeAlso: ["http://www.cecill.info/licences/Licence_CeCILL_V1-fr.html"],
				isOsiApproved: false,
			},
			{
				reference: "./CECILL-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CECILL-1.1.json",
				referenceNumber: "130",
				name: "CeCILL Free Software License Agreement v1.1",
				licenseId: "CECILL-1.1",
				seeAlso: ["http://www.cecill.info/licences/Licence_CeCILL_V1.1-US.html"],
				isOsiApproved: false,
			},
			{
				reference: "./CECILL-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/CECILL-2.0.json",
				referenceNumber: "5",
				name: "CeCILL Free Software License Agreement v2.0",
				licenseId: "CECILL-2.0",
				seeAlso: ["http://www.cecill.info/licences/Licence_CeCILL_V2-en.html"],
				isOsiApproved: false,
			},
			{
				reference: "./CECILL-2.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CECILL-2.1.json",
				referenceNumber: "140",
				name: "CeCILL Free Software License Agreement v2.1",
				licenseId: "CECILL-2.1",
				seeAlso: ["http://www.cecill.info/licences/Licence_CeCILL_V2.1-en.html"],
				isOsiApproved: true,
			},
			{
				reference: "./CECILL-B.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/CECILL-B.json",
				referenceNumber: "89",
				name: "CeCILL-B Free Software License Agreement",
				licenseId: "CECILL-B",
				seeAlso: ["http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html"],
				isOsiApproved: false,
			},
			{
				reference: "./CECILL-C.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/CECILL-C.json",
				referenceNumber: "232",
				name: "CeCILL-C Free Software License Agreement",
				licenseId: "CECILL-C",
				seeAlso: ["http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html"],
				isOsiApproved: false,
			},
			{
				reference: "./CERN-OHL-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CERN-OHL-1.1.json",
				referenceNumber: "118",
				name: "CERN Open Hardware Licence v1.1",
				licenseId: "CERN-OHL-1.1",
				seeAlso: ["https://www.ohwr.org/project/licenses/wikis/cern-ohl-v1.1"],
				isOsiApproved: false,
			},
			{
				reference: "./CERN-OHL-1.2.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CERN-OHL-1.2.json",
				referenceNumber: "161",
				name: "CERN Open Hardware Licence v1.2",
				licenseId: "CERN-OHL-1.2",
				seeAlso: ["https://www.ohwr.org/project/licenses/wikis/cern-ohl-v1.2"],
				isOsiApproved: false,
			},
			{
				reference: "./CNRI-Jython.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CNRI-Jython.json",
				referenceNumber: "74",
				name: "CNRI Jython License",
				licenseId: "CNRI-Jython",
				seeAlso: ["http://www.jython.org/license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./CNRI-Python.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CNRI-Python.json",
				referenceNumber: "92",
				name: "CNRI Python License",
				licenseId: "CNRI-Python",
				seeAlso: ["https://opensource.org/licenses/CNRI-Python"],
				isOsiApproved: true,
			},
			{
				reference: "./CNRI-Python-GPL-Compatible.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CNRI-Python-GPL-Compatible.json",
				referenceNumber: "337",
				name: "CNRI Python Open Source GPL Compatible License Agreement",
				licenseId: "CNRI-Python-GPL-Compatible",
				seeAlso: ["http://www.python.org/download/releases/1.6.1/download_win/"],
				isOsiApproved: false,
			},
			{
				reference: "./CPAL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/CPAL-1.0.json",
				referenceNumber: "275",
				name: "Common Public Attribution License 1.0",
				licenseId: "CPAL-1.0",
				seeAlso: ["https://opensource.org/licenses/CPAL-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./CPL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/CPL-1.0.json",
				referenceNumber: "228",
				name: "Common Public License 1.0",
				licenseId: "CPL-1.0",
				seeAlso: ["https://opensource.org/licenses/CPL-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./CPOL-1.02.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CPOL-1.02.json",
				referenceNumber: "222",
				name: "Code Project Open License 1.02",
				licenseId: "CPOL-1.02",
				seeAlso: ["http://www.codeproject.com/info/cpol10.aspx"],
				isOsiApproved: false,
			},
			{
				reference: "./CUA-OPL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CUA-OPL-1.0.json",
				referenceNumber: "159",
				name: "CUA Office Public License v1.0",
				licenseId: "CUA-OPL-1.0",
				seeAlso: ["https://opensource.org/licenses/CUA-OPL-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./Caldera.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Caldera.json",
				referenceNumber: "242",
				name: "Caldera License",
				licenseId: "Caldera",
				seeAlso: ["http://www.lemis.com/grog/UNIX/ancient-source-all.pdf"],
				isOsiApproved: false,
			},
			{
				reference: "./ClArtistic.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/ClArtistic.json",
				referenceNumber: "237",
				name: "Clarified Artistic License",
				licenseId: "ClArtistic",
				seeAlso: [
					"http://gianluca.dellavedova.org/2011/01/03/clarified-artistic-license/",
					"http://www.ncftp.com/ncftp/doc/LICENSE.txt",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Condor-1.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Condor-1.1.json",
				referenceNumber: "145",
				name: "Condor Public License v1.1",
				licenseId: "Condor-1.1",
				seeAlso: [
					"http://research.cs.wisc.edu/condor/license.html#condor",
					"http://web.archive.org/web/20111123062036/http://research.cs.wisc.edu/condor/license.html#condor",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Crossword.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Crossword.json",
				referenceNumber: "97",
				name: "Crossword License",
				licenseId: "Crossword",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Crossword"],
				isOsiApproved: false,
			},
			{
				reference: "./CrystalStacker.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CrystalStacker.json",
				referenceNumber: "38",
				name: "CrystalStacker License",
				licenseId: "CrystalStacker",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing:CrystalStacker?rd=Licensing/CrystalStacker",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Cube.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Cube.json",
				referenceNumber: "379",
				name: "Cube License",
				licenseId: "Cube",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Cube"],
				isOsiApproved: false,
			},
			{
				reference: "./D-FSL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/D-FSL-1.0.json",
				referenceNumber: "347",
				name: "Deutsche Freie Software Lizenz",
				licenseId: "D-FSL-1.0",
				seeAlso: [
					"http://www.dipp.nrw.de/d-fsl/lizenzen/",
					"http://www.dipp.nrw.de/d-fsl/index_html/lizenzen/de/D-FSL-1_0_de.txt",
					"http://www.dipp.nrw.de/d-fsl/index_html/lizenzen/en/D-FSL-1_0_en.txt",
					"https://www.hbz-nrw.de/produkte/open-access/lizenzen/dfsl",
					"https://www.hbz-nrw.de/produkte/open-access/lizenzen/dfsl/deutsche-freie-software-lizenz",
					"https://www.hbz-nrw.de/produkte/open-access/lizenzen/dfsl/german-free-software-license",
					"https://www.hbz-nrw.de/produkte/open-access/lizenzen/dfsl/D-FSL-1_0_de.txt/at_download/file",
					"https://www.hbz-nrw.de/produkte/open-access/lizenzen/dfsl/D-FSL-1_0_en.txt/at_download/file",
				],
				isOsiApproved: false,
			},
			{
				reference: "./DOC.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/DOC.json",
				referenceNumber: "265",
				name: "DOC License",
				licenseId: "DOC",
				seeAlso: ["http://www.cs.wustl.edu/~schmidt/ACE-copying.html"],
				isOsiApproved: false,
			},
			{
				reference: "./DSDP.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/DSDP.json",
				referenceNumber: "257",
				name: "DSDP License",
				licenseId: "DSDP",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/DSDP"],
				isOsiApproved: false,
			},
			{
				reference: "./Dotseqn.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Dotseqn.json",
				referenceNumber: "33",
				name: "Dotseqn License",
				licenseId: "Dotseqn",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Dotseqn"],
				isOsiApproved: false,
			},
			{
				reference: "./ECL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/ECL-1.0.json",
				referenceNumber: "405",
				name: "Educational Community License v1.0",
				licenseId: "ECL-1.0",
				seeAlso: ["https://opensource.org/licenses/ECL-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./ECL-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/ECL-2.0.json",
				referenceNumber: "1",
				name: "Educational Community License v2.0",
				licenseId: "ECL-2.0",
				seeAlso: ["https://opensource.org/licenses/ECL-2.0"],
				isOsiApproved: true,
			},
			{
				reference: "./EFL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/EFL-1.0.json",
				referenceNumber: "73",
				name: "Eiffel Forum License v1.0",
				licenseId: "EFL-1.0",
				seeAlso: [
					"http://www.eiffel-nice.org/license/forum.txt",
					"https://opensource.org/licenses/EFL-1.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./EFL-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/EFL-2.0.json",
				referenceNumber: "7",
				name: "Eiffel Forum License v2.0",
				licenseId: "EFL-2.0",
				seeAlso: [
					"http://www.eiffel-nice.org/license/eiffel-forum-license-2.html",
					"https://opensource.org/licenses/EFL-2.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./EPL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/EPL-1.0.json",
				referenceNumber: "267",
				name: "Eclipse Public License 1.0",
				licenseId: "EPL-1.0",
				seeAlso: [
					"http://www.eclipse.org/legal/epl-v10.html",
					"https://opensource.org/licenses/EPL-1.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./EPL-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/EPL-2.0.json",
				referenceNumber: "403",
				name: "Eclipse Public License 2.0",
				licenseId: "EPL-2.0",
				seeAlso: [
					"https://www.eclipse.org/legal/epl-2.0",
					"https://www.opensource.org/licenses/EPL-2.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./EUDatagrid.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/EUDatagrid.json",
				referenceNumber: "254",
				name: "EU DataGrid Software License",
				licenseId: "EUDatagrid",
				seeAlso: [
					"http://eu-datagrid.web.cern.ch/eu-datagrid/license.html",
					"https://opensource.org/licenses/EUDatagrid",
				],
				isOsiApproved: true,
			},
			{
				reference: "./EUPL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/EUPL-1.0.json",
				referenceNumber: "94",
				name: "European Union Public License 1.0",
				licenseId: "EUPL-1.0",
				seeAlso: [
					"http://ec.europa.eu/idabc/en/document/7330.html",
					"http://ec.europa.eu/idabc/servlets/Doc027f.pdf?id=31096",
				],
				isOsiApproved: false,
			},
			{
				reference: "./EUPL-1.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/EUPL-1.1.json",
				referenceNumber: "396",
				name: "European Union Public License 1.1",
				licenseId: "EUPL-1.1",
				seeAlso: [
					"https://joinup.ec.europa.eu/software/page/eupl/licence-eupl",
					"https://joinup.ec.europa.eu/sites/default/files/custom-page/attachment/eupl1.1.-licence-en_0.pdf",
					"https://opensource.org/licenses/EUPL-1.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./EUPL-1.2.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/EUPL-1.2.json",
				referenceNumber: "261",
				name: "European Union Public License 1.2",
				licenseId: "EUPL-1.2",
				seeAlso: [
					"https://joinup.ec.europa.eu/page/eupl-text-11-12",
					"https://joinup.ec.europa.eu/sites/default/files/custom-page/attachment/eupl_v1.2_en.pdf",
					"https://joinup.ec.europa.eu/sites/default/files/inline-files/EUPL%20v1_2%20EN(1).txt",
					"http://eur-lex.europa.eu/legal-content/EN/TXT/HTML/?uri=CELEX:32017D0863",
					"https://opensource.org/licenses/EUPL-1.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./Entessa.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Entessa.json",
				referenceNumber: "374",
				name: "Entessa Public License v1.0",
				licenseId: "Entessa",
				seeAlso: ["https://opensource.org/licenses/Entessa"],
				isOsiApproved: true,
			},
			{
				reference: "./ErlPL-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/ErlPL-1.1.json",
				referenceNumber: "395",
				name: "Erlang Public License v1.1",
				licenseId: "ErlPL-1.1",
				seeAlso: ["http://www.erlang.org/EPLICENSE"],
				isOsiApproved: false,
			},
			{
				reference: "./Eurosym.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Eurosym.json",
				referenceNumber: "165",
				name: "Eurosym License",
				licenseId: "Eurosym",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Eurosym"],
				isOsiApproved: false,
			},
			{
				reference: "./FSFAP.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/FSFAP.json",
				referenceNumber: "382",
				name: "FSF All Permissive License",
				licenseId: "FSFAP",
				seeAlso: [
					"https://www.gnu.org/prep/maintain/html_node/License-Notices-for-Other-Files.html",
				],
				isOsiApproved: false,
			},
			{
				reference: "./FSFUL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/FSFUL.json",
				referenceNumber: "2",
				name: "FSF Unlimited License",
				licenseId: "FSFUL",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/FSF_Unlimited_License",
				],
				isOsiApproved: false,
			},
			{
				reference: "./FSFULLR.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/FSFULLR.json",
				referenceNumber: "297",
				name: "FSF Unlimited License (with License Retention)",
				licenseId: "FSFULLR",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/FSF_Unlimited_License#License_Retention_Variant",
				],
				isOsiApproved: false,
			},
			{
				reference: "./FTL.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/FTL.json",
				referenceNumber: "363",
				name: "Freetype Project License",
				licenseId: "FTL",
				seeAlso: [
					"http://freetype.fis.uniroma2.it/FTL.TXT",
					"http://git.savannah.gnu.org/cgit/freetype/freetype2.git/tree/docs/FTL.TXT",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Fair.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Fair.json",
				referenceNumber: "253",
				name: "Fair License",
				licenseId: "Fair",
				seeAlso: [
					"http://fairlicense.org/",
					"https://opensource.org/licenses/Fair",
				],
				isOsiApproved: true,
			},
			{
				reference: "./Frameworx-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Frameworx-1.0.json",
				referenceNumber: "362",
				name: "Frameworx Open License 1.0",
				licenseId: "Frameworx-1.0",
				seeAlso: ["https://opensource.org/licenses/Frameworx-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./FreeImage.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/FreeImage.json",
				referenceNumber: "359",
				name: "FreeImage Public License v1.0",
				licenseId: "FreeImage",
				seeAlso: ["http://freeimage.sourceforge.net/freeimage-license.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./GFDL-1.1.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GFDL-1.1.json",
				referenceNumber: "248",
				name: "GNU Free Documentation License v1.1",
				licenseId: "GFDL-1.1",
				seeAlso: ["https://www.gnu.org/licenses/old-licenses/fdl-1.1.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./GFDL-1.1-only.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GFDL-1.1-only.json",
				referenceNumber: "100",
				name: "GNU Free Documentation License v1.1 only",
				licenseId: "GFDL-1.1-only",
				seeAlso: ["https://www.gnu.org/licenses/old-licenses/fdl-1.1.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./GFDL-1.1-or-later.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GFDL-1.1-or-later.json",
				referenceNumber: "119",
				name: "GNU Free Documentation License v1.1 or later",
				licenseId: "GFDL-1.1-or-later",
				seeAlso: ["https://www.gnu.org/licenses/old-licenses/fdl-1.1.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./GFDL-1.2.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GFDL-1.2.json",
				referenceNumber: "190",
				name: "GNU Free Documentation License v1.2",
				licenseId: "GFDL-1.2",
				seeAlso: ["https://www.gnu.org/licenses/old-licenses/fdl-1.2.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./GFDL-1.2-only.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GFDL-1.2-only.json",
				referenceNumber: "86",
				name: "GNU Free Documentation License v1.2 only",
				licenseId: "GFDL-1.2-only",
				seeAlso: ["https://www.gnu.org/licenses/old-licenses/fdl-1.2.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./GFDL-1.2-or-later.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GFDL-1.2-or-later.json",
				referenceNumber: "127",
				name: "GNU Free Documentation License v1.2 or later",
				licenseId: "GFDL-1.2-or-later",
				seeAlso: ["https://www.gnu.org/licenses/old-licenses/fdl-1.2.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./GFDL-1.3.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GFDL-1.3.json",
				referenceNumber: "354",
				name: "GNU Free Documentation License v1.3",
				licenseId: "GFDL-1.3",
				seeAlso: ["https://www.gnu.org/licenses/fdl-1.3.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./GFDL-1.3-only.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GFDL-1.3-only.json",
				referenceNumber: "193",
				name: "GNU Free Documentation License v1.3 only",
				licenseId: "GFDL-1.3-only",
				seeAlso: ["https://www.gnu.org/licenses/fdl-1.3.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./GFDL-1.3-or-later.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GFDL-1.3-or-later.json",
				referenceNumber: "51",
				name: "GNU Free Documentation License v1.3 or later",
				licenseId: "GFDL-1.3-or-later",
				seeAlso: ["https://www.gnu.org/licenses/fdl-1.3.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./GL2PS.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/GL2PS.json",
				referenceNumber: "303",
				name: "GL2PS License",
				licenseId: "GL2PS",
				seeAlso: ["http://www.geuz.org/gl2ps/COPYING.GL2PS"],
				isOsiApproved: false,
			},
			{
				reference: "./GPL-1.0.html",
				isDeprecatedLicenseId: true,
				detailsUrl: "http://spdx.org/licenses/GPL-1.0.json",
				referenceNumber: "319",
				name: "GNU General Public License v1.0 only",
				licenseId: "GPL-1.0",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/gpl-1.0-standalone.html",
				],
				isOsiApproved: false,
			},
			{
				reference: "./GPL-1.0+.html",
				isDeprecatedLicenseId: true,
				detailsUrl: "http://spdx.org/licenses/GPL-1.0+.json",
				referenceNumber: "198",
				name: "GNU General Public License v1.0 or later",
				licenseId: "GPL-1.0+",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/gpl-1.0-standalone.html",
				],
				isOsiApproved: false,
			},
			{
				reference: "./GPL-1.0-only.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/GPL-1.0-only.json",
				referenceNumber: "15",
				name: "GNU General Public License v1.0 only",
				licenseId: "GPL-1.0-only",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/gpl-1.0-standalone.html",
				],
				isOsiApproved: false,
			},
			{
				reference: "./GPL-1.0-or-later.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/GPL-1.0-or-later.json",
				referenceNumber: "129",
				name: "GNU General Public License v1.0 or later",
				licenseId: "GPL-1.0-or-later",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/gpl-1.0-standalone.html",
				],
				isOsiApproved: false,
			},
			{
				reference: "./GPL-2.0.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GPL-2.0.json",
				referenceNumber: "345",
				name: "GNU General Public License v2.0 only",
				licenseId: "GPL-2.0",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/gpl-2.0-standalone.html",
					"https://opensource.org/licenses/GPL-2.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./GPL-2.0+.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GPL-2.0+.json",
				referenceNumber: "389",
				name: "GNU General Public License v2.0 or later",
				licenseId: "GPL-2.0+",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/gpl-2.0-standalone.html",
					"https://opensource.org/licenses/GPL-2.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./GPL-2.0-only.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GPL-2.0-only.json",
				referenceNumber: "227",
				name: "GNU General Public License v2.0 only",
				licenseId: "GPL-2.0-only",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/gpl-2.0-standalone.html",
					"https://opensource.org/licenses/GPL-2.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./GPL-2.0-or-later.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GPL-2.0-or-later.json",
				referenceNumber: "249",
				name: "GNU General Public License v2.0 or later",
				licenseId: "GPL-2.0-or-later",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/gpl-2.0-standalone.html",
					"https://opensource.org/licenses/GPL-2.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./GPL-2.0-with-GCC-exception.html",
				isDeprecatedLicenseId: true,
				detailsUrl: "http://spdx.org/licenses/GPL-2.0-with-GCC-exception.json",
				referenceNumber: "329",
				name: "GNU General Public License v2.0 w/GCC Runtime Library exception",
				licenseId: "GPL-2.0-with-GCC-exception",
				seeAlso: [
					"https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=gcc/libgcc1.c;h=762f5143fc6eed57b6797c82710f3538aa52b40b;hb=cb143a3ce4fb417c68f5fa2691a1b1b1053dfba9#l10",
				],
				isOsiApproved: false,
			},
			{
				reference: "./GPL-2.0-with-autoconf-exception.html",
				isDeprecatedLicenseId: true,
				detailsUrl: "http://spdx.org/licenses/GPL-2.0-with-autoconf-exception.json",
				referenceNumber: "36",
				name: "GNU General Public License v2.0 w/Autoconf exception",
				licenseId: "GPL-2.0-with-autoconf-exception",
				seeAlso: ["http://ac-archive.sourceforge.net/doc/copyright.html"],
				isOsiApproved: false,
			},
			{
				reference: "./GPL-2.0-with-bison-exception.html",
				isDeprecatedLicenseId: true,
				detailsUrl: "http://spdx.org/licenses/GPL-2.0-with-bison-exception.json",
				referenceNumber: "360",
				name: "GNU General Public License v2.0 w/Bison exception",
				licenseId: "GPL-2.0-with-bison-exception",
				seeAlso: [
					"http://git.savannah.gnu.org/cgit/bison.git/tree/data/yacc.c?id=193d7c7054ba7197b0789e14965b739162319b5e#n141",
				],
				isOsiApproved: false,
			},
			{
				reference: "./GPL-2.0-with-classpath-exception.html",
				isDeprecatedLicenseId: true,
				detailsUrl: "http://spdx.org/licenses/GPL-2.0-with-classpath-exception.json",
				referenceNumber: "219",
				name: "GNU General Public License v2.0 w/Classpath exception",
				licenseId: "GPL-2.0-with-classpath-exception",
				seeAlso: ["https://www.gnu.org/software/classpath/license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./GPL-2.0-with-font-exception.html",
				isDeprecatedLicenseId: true,
				detailsUrl: "http://spdx.org/licenses/GPL-2.0-with-font-exception.json",
				referenceNumber: "24",
				name: "GNU General Public License v2.0 w/Font exception",
				licenseId: "GPL-2.0-with-font-exception",
				seeAlso: ["https://www.gnu.org/licenses/gpl-faq.html#FontException"],
				isOsiApproved: false,
			},
			{
				reference: "./GPL-3.0.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GPL-3.0.json",
				referenceNumber: "401",
				name: "GNU General Public License v3.0 only",
				licenseId: "GPL-3.0",
				seeAlso: [
					"https://www.gnu.org/licenses/gpl-3.0-standalone.html",
					"https://opensource.org/licenses/GPL-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./GPL-3.0+.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GPL-3.0+.json",
				referenceNumber: "147",
				name: "GNU General Public License v3.0 or later",
				licenseId: "GPL-3.0+",
				seeAlso: [
					"https://www.gnu.org/licenses/gpl-3.0-standalone.html",
					"https://opensource.org/licenses/GPL-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./GPL-3.0-only.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GPL-3.0-only.json",
				referenceNumber: "122",
				name: "GNU General Public License v3.0 only",
				licenseId: "GPL-3.0-only",
				seeAlso: [
					"https://www.gnu.org/licenses/gpl-3.0-standalone.html",
					"https://opensource.org/licenses/GPL-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./GPL-3.0-or-later.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GPL-3.0-or-later.json",
				referenceNumber: "387",
				name: "GNU General Public License v3.0 or later",
				licenseId: "GPL-3.0-or-later",
				seeAlso: [
					"https://www.gnu.org/licenses/gpl-3.0-standalone.html",
					"https://opensource.org/licenses/GPL-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./GPL-3.0-with-GCC-exception.html",
				isDeprecatedLicenseId: true,
				detailsUrl: "http://spdx.org/licenses/GPL-3.0-with-GCC-exception.json",
				referenceNumber: "6",
				name: "GNU General Public License v3.0 w/GCC Runtime Library exception",
				licenseId: "GPL-3.0-with-GCC-exception",
				seeAlso: ["https://www.gnu.org/licenses/gcc-exception-3.1.html"],
				isOsiApproved: true,
			},
			{
				reference: "./GPL-3.0-with-autoconf-exception.html",
				isDeprecatedLicenseId: true,
				detailsUrl: "http://spdx.org/licenses/GPL-3.0-with-autoconf-exception.json",
				referenceNumber: "8",
				name: "GNU General Public License v3.0 w/Autoconf exception",
				licenseId: "GPL-3.0-with-autoconf-exception",
				seeAlso: ["https://www.gnu.org/licenses/autoconf-exception-3.0.html"],
				isOsiApproved: false,
			},
			{
				reference: "./Giftware.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Giftware.json",
				referenceNumber: "367",
				name: "Giftware License",
				licenseId: "Giftware",
				seeAlso: [
					"http://liballeg.org/license.html#allegro-4-the-giftware-license",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Glide.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Glide.json",
				referenceNumber: "117",
				name: "3dfx Glide License",
				licenseId: "Glide",
				seeAlso: ["http://www.users.on.net/~triforce/glidexp/COPYING.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./Glulxe.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Glulxe.json",
				referenceNumber: "199",
				name: "Glulxe License",
				licenseId: "Glulxe",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Glulxe"],
				isOsiApproved: false,
			},
			{
				reference: "./HPND.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/HPND.json",
				referenceNumber: "148",
				name: "Historical Permission Notice and Disclaimer",
				licenseId: "HPND",
				seeAlso: ["https://opensource.org/licenses/HPND"],
				isOsiApproved: true,
			},
			{
				reference: "./HPND-sell-variant.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/HPND-sell-variant.json",
				referenceNumber: "158",
				name: "Historical Permission Notice and Disclaimer - sell variant",
				licenseId: "HPND-sell-variant",
				seeAlso: [
					"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/auth_gss/gss_generic_token.c?h=v4.19",
				],
				isOsiApproved: false,
			},
			{
				reference: "./HaskellReport.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/HaskellReport.json",
				referenceNumber: "205",
				name: "Haskell Language Report License",
				licenseId: "HaskellReport",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/Haskell_Language_Report_License",
				],
				isOsiApproved: false,
			},
			{
				reference: "./IBM-pibs.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/IBM-pibs.json",
				referenceNumber: "233",
				name: "IBM PowerPC Initialization and Boot Software",
				licenseId: "IBM-pibs",
				seeAlso: [
					"http://git.denx.de/?p=u-boot.git;a=blob;f=arch/powerpc/cpu/ppc4xx/miiphy.c;h=297155fdafa064b955e53e9832de93bfb0cfb85b;hb=9fab4bf4cc077c21e43941866f3f2c196f28670d",
				],
				isOsiApproved: false,
			},
			{
				reference: "./ICU.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/ICU.json",
				referenceNumber: "174",
				name: "ICU License",
				licenseId: "ICU",
				seeAlso: [
					"http://source.icu-project.org/repos/icu/icu/trunk/license.html",
				],
				isOsiApproved: false,
			},
			{
				reference: "./IJG.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/IJG.json",
				referenceNumber: "236",
				name: "Independent JPEG Group License",
				licenseId: "IJG",
				seeAlso: ["http://dev.w3.org/cvsweb/Amaya/libjpeg/Attic/README?rev=1.2"],
				isOsiApproved: false,
			},
			{
				reference: "./IPA.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/IPA.json",
				referenceNumber: "310",
				name: "IPA Font License",
				licenseId: "IPA",
				seeAlso: ["https://opensource.org/licenses/IPA"],
				isOsiApproved: true,
			},
			{
				reference: "./IPL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/IPL-1.0.json",
				referenceNumber: "309",
				name: "IBM Public License v1.0",
				licenseId: "IPL-1.0",
				seeAlso: ["https://opensource.org/licenses/IPL-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./ISC.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/ISC.json",
				referenceNumber: "353",
				name: "ISC License",
				licenseId: "ISC",
				seeAlso: [
					"https://www.isc.org/downloads/software-support-policy/isc-license/",
					"https://opensource.org/licenses/ISC",
				],
				isOsiApproved: true,
			},
			{
				reference: "./ImageMagick.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/ImageMagick.json",
				referenceNumber: "326",
				name: "ImageMagick License",
				licenseId: "ImageMagick",
				seeAlso: ["http://www.imagemagick.org/script/license.php"],
				isOsiApproved: false,
			},
			{
				reference: "./Imlib2.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Imlib2.json",
				referenceNumber: "135",
				name: "Imlib2 License",
				licenseId: "Imlib2",
				seeAlso: [
					"http://trac.enlightenment.org/e/browser/trunk/imlib2/COPYING",
					"https://git.enlightenment.org/legacy/imlib2.git/tree/COPYING",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Info-ZIP.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Info-ZIP.json",
				referenceNumber: "283",
				name: "Info-ZIP License",
				licenseId: "Info-ZIP",
				seeAlso: ["http://www.info-zip.org/license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./Intel.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Intel.json",
				referenceNumber: "29",
				name: "Intel Open Source License",
				licenseId: "Intel",
				seeAlso: ["https://opensource.org/licenses/Intel"],
				isOsiApproved: true,
			},
			{
				reference: "./Intel-ACPI.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Intel-ACPI.json",
				referenceNumber: "235",
				name: "Intel ACPI Software License Agreement",
				licenseId: "Intel-ACPI",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/Intel_ACPI_Software_License_Agreement",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Interbase-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Interbase-1.0.json",
				referenceNumber: "323",
				name: "Interbase Public License v1.0",
				licenseId: "Interbase-1.0",
				seeAlso: [
					"https://web.archive.org/web/20060319014854/http://info.borland.com/devsupport/interbase/opensource/IPL.html",
				],
				isOsiApproved: false,
			},
			{
				reference: "./JPNIC.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/JPNIC.json",
				referenceNumber: "316",
				name: "Japan Network Information Center License",
				licenseId: "JPNIC",
				seeAlso: [
					"https://gitlab.isc.org/isc-projects/bind9/blob/server/COPYRIGHT#L366",
				],
				isOsiApproved: false,
			},
			{
				reference: "./JSON.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/JSON.json",
				referenceNumber: "197",
				name: "JSON License",
				licenseId: "JSON",
				seeAlso: ["http://www.json.org/license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./JasPer-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/JasPer-2.0.json",
				referenceNumber: "77",
				name: "JasPer License",
				licenseId: "JasPer-2.0",
				seeAlso: ["http://www.ece.uvic.ca/~mdadams/jasper/LICENSE"],
				isOsiApproved: false,
			},
			{
				reference: "./LAL-1.2.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/LAL-1.2.json",
				referenceNumber: "153",
				name: "Licence Art Libre 1.2",
				licenseId: "LAL-1.2",
				seeAlso: ["http://artlibre.org/licence/lal/licence-art-libre-12/"],
				isOsiApproved: false,
			},
			{
				reference: "./LAL-1.3.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/LAL-1.3.json",
				referenceNumber: "357",
				name: "Licence Art Libre 1.3",
				licenseId: "LAL-1.3",
				seeAlso: ["https://artlibre.org/"],
				isOsiApproved: false,
			},
			{
				reference: "./LGPL-2.0.html",
				isDeprecatedLicenseId: true,
				detailsUrl: "http://spdx.org/licenses/LGPL-2.0.json",
				referenceNumber: "276",
				name: "GNU Library General Public License v2 only",
				licenseId: "LGPL-2.0",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/lgpl-2.0-standalone.html",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LGPL-2.0+.html",
				isDeprecatedLicenseId: true,
				detailsUrl: "http://spdx.org/licenses/LGPL-2.0+.json",
				referenceNumber: "139",
				name: "GNU Library General Public License v2 or later",
				licenseId: "LGPL-2.0+",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/lgpl-2.0-standalone.html",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LGPL-2.0-only.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/LGPL-2.0-only.json",
				referenceNumber: "328",
				name: "GNU Library General Public License v2 only",
				licenseId: "LGPL-2.0-only",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/lgpl-2.0-standalone.html",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LGPL-2.0-or-later.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/LGPL-2.0-or-later.json",
				referenceNumber: "35",
				name: "GNU Library General Public License v2 or later",
				licenseId: "LGPL-2.0-or-later",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/lgpl-2.0-standalone.html",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LGPL-2.1.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/LGPL-2.1.json",
				referenceNumber: "182",
				name: "GNU Lesser General Public License v2.1 only",
				licenseId: "LGPL-2.1",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html",
					"https://opensource.org/licenses/LGPL-2.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LGPL-2.1+.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/LGPL-2.1+.json",
				referenceNumber: "202",
				name: "GNU Library General Public License v2.1 or later",
				licenseId: "LGPL-2.1+",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html",
					"https://opensource.org/licenses/LGPL-2.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LGPL-2.1-only.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/LGPL-2.1-only.json",
				referenceNumber: "138",
				name: "GNU Lesser General Public License v2.1 only",
				licenseId: "LGPL-2.1-only",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html",
					"https://opensource.org/licenses/LGPL-2.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LGPL-2.1-or-later.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/LGPL-2.1-or-later.json",
				referenceNumber: "269",
				name: "GNU Lesser General Public License v2.1 or later",
				licenseId: "LGPL-2.1-or-later",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html",
					"https://opensource.org/licenses/LGPL-2.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LGPL-3.0.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/LGPL-3.0.json",
				referenceNumber: "209",
				name: "GNU Lesser General Public License v3.0 only",
				licenseId: "LGPL-3.0",
				seeAlso: [
					"https://www.gnu.org/licenses/lgpl-3.0-standalone.html",
					"https://opensource.org/licenses/LGPL-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LGPL-3.0+.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/LGPL-3.0+.json",
				referenceNumber: "220",
				name: "GNU Lesser General Public License v3.0 or later",
				licenseId: "LGPL-3.0+",
				seeAlso: [
					"https://www.gnu.org/licenses/lgpl-3.0-standalone.html",
					"https://opensource.org/licenses/LGPL-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LGPL-3.0-only.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/LGPL-3.0-only.json",
				referenceNumber: "47",
				name: "GNU Lesser General Public License v3.0 only",
				licenseId: "LGPL-3.0-only",
				seeAlso: [
					"https://www.gnu.org/licenses/lgpl-3.0-standalone.html",
					"https://opensource.org/licenses/LGPL-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LGPL-3.0-or-later.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/LGPL-3.0-or-later.json",
				referenceNumber: "317",
				name: "GNU Lesser General Public License v3.0 or later",
				licenseId: "LGPL-3.0-or-later",
				seeAlso: [
					"https://www.gnu.org/licenses/lgpl-3.0-standalone.html",
					"https://opensource.org/licenses/LGPL-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LGPLLR.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/LGPLLR.json",
				referenceNumber: "404",
				name: "Lesser General Public License For Linguistic Resources",
				licenseId: "LGPLLR",
				seeAlso: ["http://www-igm.univ-mlv.fr/~unitex/lgpllr.html"],
				isOsiApproved: false,
			},
			{
				reference: "./LPL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/LPL-1.0.json",
				referenceNumber: "371",
				name: "Lucent Public License Version 1.0",
				licenseId: "LPL-1.0",
				seeAlso: ["https://opensource.org/licenses/LPL-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./LPL-1.02.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/LPL-1.02.json",
				referenceNumber: "120",
				name: "Lucent Public License v1.02",
				licenseId: "LPL-1.02",
				seeAlso: [
					"http://plan9.bell-labs.com/plan9/license.html",
					"https://opensource.org/licenses/LPL-1.02",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LPPL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/LPPL-1.0.json",
				referenceNumber: "82",
				name: "LaTeX Project Public License v1.0",
				licenseId: "LPPL-1.0",
				seeAlso: ["http://www.latex-project.org/lppl/lppl-1-0.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./LPPL-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/LPPL-1.1.json",
				referenceNumber: "168",
				name: "LaTeX Project Public License v1.1",
				licenseId: "LPPL-1.1",
				seeAlso: ["http://www.latex-project.org/lppl/lppl-1-1.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./LPPL-1.2.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/LPPL-1.2.json",
				referenceNumber: "160",
				name: "LaTeX Project Public License v1.2",
				licenseId: "LPPL-1.2",
				seeAlso: ["http://www.latex-project.org/lppl/lppl-1-2.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./LPPL-1.3a.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/LPPL-1.3a.json",
				referenceNumber: "270",
				name: "LaTeX Project Public License v1.3a",
				licenseId: "LPPL-1.3a",
				seeAlso: ["http://www.latex-project.org/lppl/lppl-1-3a.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./LPPL-1.3c.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/LPPL-1.3c.json",
				referenceNumber: "126",
				name: "LaTeX Project Public License v1.3c",
				licenseId: "LPPL-1.3c",
				seeAlso: [
					"http://www.latex-project.org/lppl/lppl-1-3c.txt",
					"https://opensource.org/licenses/LPPL-1.3c",
				],
				isOsiApproved: true,
			},
			{
				reference: "./Latex2e.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Latex2e.json",
				referenceNumber: "37",
				name: "Latex2e License",
				licenseId: "Latex2e",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Latex2e"],
				isOsiApproved: false,
			},
			{
				reference: "./Leptonica.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Leptonica.json",
				referenceNumber: "300",
				name: "Leptonica License",
				licenseId: "Leptonica",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Leptonica"],
				isOsiApproved: false,
			},
			{
				reference: "./LiLiQ-P-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/LiLiQ-P-1.1.json",
				referenceNumber: "79",
				name: "Licence Libre du Qu\xe9bec \u2013 Permissive version 1.1",
				licenseId: "LiLiQ-P-1.1",
				seeAlso: [
					"https://forge.gouv.qc.ca/licence/fr/liliq-v1-1/",
					"http://opensource.org/licenses/LiLiQ-P-1.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LiLiQ-R-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/LiLiQ-R-1.1.json",
				referenceNumber: "290",
				name: "Licence Libre du Qu\xe9bec \u2013 R\xe9ciprocit\xe9 version 1.1",
				licenseId: "LiLiQ-R-1.1",
				seeAlso: [
					"https://www.forge.gouv.qc.ca/participez/licence-logicielle/licence-libre-du-quebec-liliq-en-francais/licence-libre-du-quebec-reciprocite-liliq-r-v1-1/",
					"http://opensource.org/licenses/LiLiQ-R-1.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LiLiQ-Rplus-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/LiLiQ-Rplus-1.1.json",
				referenceNumber: "335",
				name: "Licence Libre du Qu\xe9bec \u2013 R\xe9ciprocit\xe9 forte version 1.1",
				licenseId: "LiLiQ-Rplus-1.1",
				seeAlso: [
					"https://www.forge.gouv.qc.ca/participez/licence-logicielle/licence-libre-du-quebec-liliq-en-francais/licence-libre-du-quebec-reciprocite-forte-liliq-r-v1-1/",
					"http://opensource.org/licenses/LiLiQ-Rplus-1.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./Libpng.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Libpng.json",
				referenceNumber: "376",
				name: "libpng License",
				licenseId: "Libpng",
				seeAlso: ["http://www.libpng.org/pub/png/src/libpng-LICENSE.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./Linux-OpenIB.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Linux-OpenIB.json",
				referenceNumber: "217",
				name: "Linux Kernel Variant of OpenIB.org license",
				licenseId: "Linux-OpenIB",
				seeAlso: [
					"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/infiniband/core/sa.h",
				],
				isOsiApproved: false,
			},
			{
				reference: "./MIT.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/MIT.json",
				referenceNumber: "256",
				name: "MIT License",
				licenseId: "MIT",
				seeAlso: ["https://opensource.org/licenses/MIT"],
				isOsiApproved: true,
			},
			{
				reference: "./MIT-0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/MIT-0.json",
				referenceNumber: "76",
				name: "MIT No Attribution",
				licenseId: "MIT-0",
				seeAlso: [
					"https://github.com/aws/mit-0",
					"https://romanrm.net/mit-zero",
					"https://github.com/awsdocs/aws-cloud9-user-guide/blob/server/LICENSE-SAMPLECODE",
				],
				isOsiApproved: false,
			},
			{
				reference: "./MIT-CMU.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/MIT-CMU.json",
				referenceNumber: "344",
				name: "CMU License",
				licenseId: "MIT-CMU",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing:MIT?rd=Licensing/MIT#CMU_Style",
					"https://github.com/python-pillow/Pillow/blob/fffb426092c8db24a5f4b6df243a8a3c01fb63cd/LICENSE",
				],
				isOsiApproved: false,
			},
			{
				reference: "./MIT-advertising.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/MIT-advertising.json",
				referenceNumber: "192",
				name: "Enlightenment License (e16)",
				licenseId: "MIT-advertising",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/MIT_With_Advertising",
				],
				isOsiApproved: false,
			},
			{
				reference: "./MIT-enna.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/MIT-enna.json",
				referenceNumber: "52",
				name: "enna License",
				licenseId: "MIT-enna",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/MIT#enna"],
				isOsiApproved: false,
			},
			{
				reference: "./MIT-feh.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/MIT-feh.json",
				referenceNumber: "365",
				name: "feh License",
				licenseId: "MIT-feh",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/MIT#feh"],
				isOsiApproved: false,
			},
			{
				reference: "./MITNFA.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/MITNFA.json",
				referenceNumber: "336",
				name: "MIT +no-false-attribs license",
				licenseId: "MITNFA",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/MITNFA"],
				isOsiApproved: false,
			},
			{
				reference: "./MPL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/MPL-1.0.json",
				referenceNumber: "239",
				name: "Mozilla Public License 1.0",
				licenseId: "MPL-1.0",
				seeAlso: [
					"http://www.mozilla.org/MPL/MPL-1.0.html",
					"https://opensource.org/licenses/MPL-1.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./MPL-1.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/MPL-1.1.json",
				referenceNumber: "394",
				name: "Mozilla Public License 1.1",
				licenseId: "MPL-1.1",
				seeAlso: [
					"http://www.mozilla.org/MPL/MPL-1.1.html",
					"https://opensource.org/licenses/MPL-1.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./MPL-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/MPL-2.0.json",
				referenceNumber: "121",
				name: "Mozilla Public License 2.0",
				licenseId: "MPL-2.0",
				seeAlso: [
					"http://www.mozilla.org/MPL/2.0/",
					"https://opensource.org/licenses/MPL-2.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./MPL-2.0-no-copyleft-exception.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/MPL-2.0-no-copyleft-exception.json",
				referenceNumber: "183",
				name: "Mozilla Public License 2.0 (no copyleft exception)",
				licenseId: "MPL-2.0-no-copyleft-exception",
				seeAlso: [
					"http://www.mozilla.org/MPL/2.0/",
					"https://opensource.org/licenses/MPL-2.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./MS-PL.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/MS-PL.json",
				referenceNumber: "366",
				name: "Microsoft Public License",
				licenseId: "MS-PL",
				seeAlso: [
					"http://www.microsoft.com/opensource/licenses.mspx",
					"https://opensource.org/licenses/MS-PL",
				],
				isOsiApproved: true,
			},
			{
				reference: "./MS-RL.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/MS-RL.json",
				referenceNumber: "4",
				name: "Microsoft Reciprocal License",
				licenseId: "MS-RL",
				seeAlso: [
					"http://www.microsoft.com/opensource/licenses.mspx",
					"https://opensource.org/licenses/MS-RL",
				],
				isOsiApproved: true,
			},
			{
				reference: "./MTLL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/MTLL.json",
				referenceNumber: "102",
				name: "Matrix Template Library License",
				licenseId: "MTLL",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/Matrix_Template_Library_License",
				],
				isOsiApproved: false,
			},
			{
				reference: "./MakeIndex.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/MakeIndex.json",
				referenceNumber: "343",
				name: "MakeIndex License",
				licenseId: "MakeIndex",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/MakeIndex"],
				isOsiApproved: false,
			},
			{
				reference: "./MirOS.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/MirOS.json",
				referenceNumber: "369",
				name: "The MirOS Licence",
				licenseId: "MirOS",
				seeAlso: ["https://opensource.org/licenses/MirOS"],
				isOsiApproved: true,
			},
			{
				reference: "./Motosoto.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Motosoto.json",
				referenceNumber: "12",
				name: "Motosoto License",
				licenseId: "Motosoto",
				seeAlso: ["https://opensource.org/licenses/Motosoto"],
				isOsiApproved: true,
			},
			{
				reference: "./MulanPSL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/MulanPSL-1.0.json",
				referenceNumber: "201",
				name: "Mulan Permissive Software License, Version 1",
				licenseId: "MulanPSL-1.0",
				seeAlso: [
					"https://license.coscl.org.cn/MulanPSL/",
					"https://github.com/yuwenlong/longphp/blob/25dfb70cc2a466dc4bb55ba30901cbce08d164b5/LICENSE",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Multics.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Multics.json",
				referenceNumber: "164",
				name: "Multics License",
				licenseId: "Multics",
				seeAlso: ["https://opensource.org/licenses/Multics"],
				isOsiApproved: true,
			},
			{
				reference: "./Mup.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Mup.json",
				referenceNumber: "305",
				name: "Mup License",
				licenseId: "Mup",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Mup"],
				isOsiApproved: false,
			},
			{
				reference: "./NASA-1.3.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/NASA-1.3.json",
				referenceNumber: "110",
				name: "NASA Open Source Agreement 1.3",
				licenseId: "NASA-1.3",
				seeAlso: [
					"http://ti.arc.nasa.gov/opensource/nosa/",
					"https://opensource.org/licenses/NASA-1.3",
				],
				isOsiApproved: true,
			},
			{
				reference: "./NBPL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/NBPL-1.0.json",
				referenceNumber: "17",
				name: "Net Boolean Public License v1",
				licenseId: "NBPL-1.0",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=37b4b3f6cc4bf34e1d3dec61e69914b9819d8894",
				],
				isOsiApproved: false,
			},
			{
				reference: "./NCSA.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/NCSA.json",
				referenceNumber: "187",
				name: "University of Illinois/NCSA Open Source License",
				licenseId: "NCSA",
				seeAlso: [
					"http://otm.illinois.edu/uiuc_openSource",
					"https://opensource.org/licenses/NCSA",
				],
				isOsiApproved: true,
			},
			{
				reference: "./NGPL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/NGPL.json",
				referenceNumber: "308",
				name: "Nethack General Public License",
				licenseId: "NGPL",
				seeAlso: ["https://opensource.org/licenses/NGPL"],
				isOsiApproved: true,
			},
			{
				reference: "./NLOD-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/NLOD-1.0.json",
				referenceNumber: "134",
				name: "Norwegian Licence for Open Government Data",
				licenseId: "NLOD-1.0",
				seeAlso: ["http://data.norge.no/nlod/en/1.0"],
				isOsiApproved: false,
			},
			{
				reference: "./NLPL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/NLPL.json",
				referenceNumber: "306",
				name: "No Limit Public License",
				licenseId: "NLPL",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/NLPL"],
				isOsiApproved: false,
			},
			{
				reference: "./NOSL.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/NOSL.json",
				referenceNumber: "380",
				name: "Netizen Open Source License",
				licenseId: "NOSL",
				seeAlso: ["http://bits.netizen.com.au/licenses/NOSL/nosl.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./NPL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/NPL-1.0.json",
				referenceNumber: "245",
				name: "Netscape Public License v1.0",
				licenseId: "NPL-1.0",
				seeAlso: ["http://www.mozilla.org/MPL/NPL/1.0/"],
				isOsiApproved: false,
			},
			{
				reference: "./NPL-1.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/NPL-1.1.json",
				referenceNumber: "409",
				name: "Netscape Public License v1.1",
				licenseId: "NPL-1.1",
				seeAlso: ["http://www.mozilla.org/MPL/NPL/1.1/"],
				isOsiApproved: false,
			},
			{
				reference: "./NPOSL-3.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/NPOSL-3.0.json",
				referenceNumber: "150",
				name: "Non-Profit Open Software License 3.0",
				licenseId: "NPOSL-3.0",
				seeAlso: ["https://opensource.org/licenses/NOSL3.0"],
				isOsiApproved: true,
			},
			{
				reference: "./NRL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/NRL.json",
				referenceNumber: "101",
				name: "NRL License",
				licenseId: "NRL",
				seeAlso: ["http://web.mit.edu/network/isakmp/nrllicense.html"],
				isOsiApproved: false,
			},
			{
				reference: "./NTP.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/NTP.json",
				referenceNumber: "258",
				name: "NTP License",
				licenseId: "NTP",
				seeAlso: ["https://opensource.org/licenses/NTP"],
				isOsiApproved: true,
			},
			{
				reference: "./NTP-0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/NTP-0.json",
				referenceNumber: "185",
				name: "NTP No Attribution",
				licenseId: "NTP-0",
				seeAlso: [
					"https://github.com/tytso/e2fsprogs/blob/server/lib/et/et_name.c",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Naumen.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Naumen.json",
				referenceNumber: "282",
				name: "Naumen Public License",
				licenseId: "Naumen",
				seeAlso: ["https://opensource.org/licenses/Naumen"],
				isOsiApproved: true,
			},
			{
				reference: "./Net-SNMP.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Net-SNMP.json",
				referenceNumber: "278",
				name: "Net-SNMP License",
				licenseId: "Net-SNMP",
				seeAlso: ["http://net-snmp.sourceforge.net/about/license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./NetCDF.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/NetCDF.json",
				referenceNumber: "212",
				name: "NetCDF license",
				licenseId: "NetCDF",
				seeAlso: ["http://www.unidata.ucar.edu/software/netcdf/copyright.html"],
				isOsiApproved: false,
			},
			{
				reference: "./Newsletr.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Newsletr.json",
				referenceNumber: "358",
				name: "Newsletr License",
				licenseId: "Newsletr",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Newsletr"],
				isOsiApproved: false,
			},
			{
				reference: "./Nokia.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Nokia.json",
				referenceNumber: "125",
				name: "Nokia Open Source License",
				licenseId: "Nokia",
				seeAlso: ["https://opensource.org/licenses/nokia"],
				isOsiApproved: true,
			},
			{
				reference: "./Noweb.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Noweb.json",
				referenceNumber: "70",
				name: "Noweb License",
				licenseId: "Noweb",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Noweb"],
				isOsiApproved: false,
			},
			{
				reference: "./Nunit.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Nunit.json",
				referenceNumber: "87",
				name: "Nunit License",
				licenseId: "Nunit",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Nunit"],
				isOsiApproved: false,
			},
			{
				reference: "./OCCT-PL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OCCT-PL.json",
				referenceNumber: "65",
				name: "Open CASCADE Technology Public License",
				licenseId: "OCCT-PL",
				seeAlso: ["http://www.opencascade.com/content/occt-public-license"],
				isOsiApproved: false,
			},
			{
				reference: "./OCLC-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OCLC-2.0.json",
				referenceNumber: "341",
				name: "OCLC Research Public License 2.0",
				licenseId: "OCLC-2.0",
				seeAlso: [
					"http://www.oclc.org/research/activities/software/license/v2final.htm",
					"https://opensource.org/licenses/OCLC-2.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./ODC-By-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/ODC-By-1.0.json",
				referenceNumber: "381",
				name: "Open Data Commons Attribution License v1.0",
				licenseId: "ODC-By-1.0",
				seeAlso: ["https://opendatacommons.org/licenses/by/1.0/"],
				isOsiApproved: false,
			},
			{
				reference: "./ODbL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/ODbL-1.0.json",
				referenceNumber: "340",
				name: "ODC Open Database License v1.0",
				licenseId: "ODbL-1.0",
				seeAlso: ["http://www.opendatacommons.org/licenses/odbl/1.0/"],
				isOsiApproved: false,
			},
			{
				reference: "./OFL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/OFL-1.0.json",
				referenceNumber: "80",
				name: "SIL Open Font License 1.0",
				licenseId: "OFL-1.0",
				seeAlso: [
					"http://scripts.sil.org/cms/scripts/page.php?item_id=OFL10_web",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OFL-1.0-RFN.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OFL-1.0-RFN.json",
				referenceNumber: "298",
				name: "SIL Open Font License 1.0 with Reserved Font Name",
				licenseId: "OFL-1.0-RFN",
				seeAlso: [
					"http://scripts.sil.org/cms/scripts/page.php?item_id=OFL10_web",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OFL-1.0-no-RFN.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OFL-1.0-no-RFN.json",
				referenceNumber: "71",
				name: "SIL Open Font License 1.0 with no Reserved Font Name",
				licenseId: "OFL-1.0-no-RFN",
				seeAlso: [
					"http://scripts.sil.org/cms/scripts/page.php?item_id=OFL10_web",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OFL-1.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/OFL-1.1.json",
				referenceNumber: "311",
				name: "SIL Open Font License 1.1",
				licenseId: "OFL-1.1",
				seeAlso: [
					"http://scripts.sil.org/cms/scripts/page.php?item_id=OFL_web",
					"https://opensource.org/licenses/OFL-1.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./OFL-1.1-RFN.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OFL-1.1-RFN.json",
				referenceNumber: "43",
				name: "SIL Open Font License 1.1 with Reserved Font Name",
				licenseId: "OFL-1.1-RFN",
				seeAlso: [
					"http://scripts.sil.org/cms/scripts/page.php?item_id=OFL_web",
					"https://opensource.org/licenses/OFL-1.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./OFL-1.1-no-RFN.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OFL-1.1-no-RFN.json",
				referenceNumber: "238",
				name: "SIL Open Font License 1.1 with no Reserved Font Name",
				licenseId: "OFL-1.1-no-RFN",
				seeAlso: [
					"http://scripts.sil.org/cms/scripts/page.php?item_id=OFL_web",
					"https://opensource.org/licenses/OFL-1.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./OGL-Canada-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OGL-Canada-2.0.json",
				referenceNumber: "346",
				name: "Open Government Licence - Canada",
				licenseId: "OGL-Canada-2.0",
				seeAlso: ["https://open.canada.ca/en/open-government-licence-canada"],
				isOsiApproved: false,
			},
			{
				reference: "./OGL-UK-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OGL-UK-1.0.json",
				referenceNumber: "348",
				name: "Open Government Licence v1.0",
				licenseId: "OGL-UK-1.0",
				seeAlso: [
					"http://www.nationalarchives.gov.uk/doc/open-government-licence/version/1/",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OGL-UK-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OGL-UK-2.0.json",
				referenceNumber: "13",
				name: "Open Government Licence v2.0",
				licenseId: "OGL-UK-2.0",
				seeAlso: [
					"http://www.nationalarchives.gov.uk/doc/open-government-licence/version/2/",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OGL-UK-3.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OGL-UK-3.0.json",
				referenceNumber: "21",
				name: "Open Government Licence v3.0",
				licenseId: "OGL-UK-3.0",
				seeAlso: [
					"http://www.nationalarchives.gov.uk/doc/open-government-licence/version/3/",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OGTSL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OGTSL.json",
				referenceNumber: "26",
				name: "Open Group Test Suite License",
				licenseId: "OGTSL",
				seeAlso: [
					"http://www.opengroup.org/testing/downloads/The_Open_Group_TSL.txt",
					"https://opensource.org/licenses/OGTSL",
				],
				isOsiApproved: true,
			},
			{
				reference: "./OLDAP-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-1.1.json",
				referenceNumber: "55",
				name: "Open LDAP Public License v1.1",
				licenseId: "OLDAP-1.1",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=806557a5ad59804ef3a44d5abfbe91d706b0791f",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-1.2.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-1.2.json",
				referenceNumber: "48",
				name: "Open LDAP Public License v1.2",
				licenseId: "OLDAP-1.2",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=42b0383c50c299977b5893ee695cf4e486fb0dc7",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-1.3.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-1.3.json",
				referenceNumber: "42",
				name: "Open LDAP Public License v1.3",
				licenseId: "OLDAP-1.3",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=e5f8117f0ce088d0bd7a8e18ddf37eaa40eb09b1",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-1.4.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-1.4.json",
				referenceNumber: "50",
				name: "Open LDAP Public License v1.4",
				licenseId: "OLDAP-1.4",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=c9f95c2f3f2ffb5e0ae55fe7388af75547660941",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-2.0.json",
				referenceNumber: "25",
				name: "Open LDAP Public License v2.0 (or possibly 2.0A and 2.0B)",
				licenseId: "OLDAP-2.0",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=cbf50f4e1185a21abd4c0a54d3f4341fe28f36ea",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-2.0.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-2.0.1.json",
				referenceNumber: "280",
				name: "Open LDAP Public License v2.0.1",
				licenseId: "OLDAP-2.0.1",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=b6d68acd14e51ca3aab4428bf26522aa74873f0e",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-2.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-2.1.json",
				referenceNumber: "400",
				name: "Open LDAP Public License v2.1",
				licenseId: "OLDAP-2.1",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=b0d176738e96a0d3b9f85cb51e140a86f21be715",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-2.2.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-2.2.json",
				referenceNumber: "318",
				name: "Open LDAP Public License v2.2",
				licenseId: "OLDAP-2.2",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=470b0c18ec67621c85881b2733057fecf4a1acc3",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-2.2.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-2.2.1.json",
				referenceNumber: "384",
				name: "Open LDAP Public License v2.2.1",
				licenseId: "OLDAP-2.2.1",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=4bc786f34b50aa301be6f5600f58a980070f481e",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-2.2.2.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-2.2.2.json",
				referenceNumber: "170",
				name: "Open LDAP Public License 2.2.2",
				licenseId: "OLDAP-2.2.2",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=df2cc1e21eb7c160695f5b7cffd6296c151ba188",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-2.3.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/OLDAP-2.3.json",
				referenceNumber: "230",
				name: "Open LDAP Public License v2.3",
				licenseId: "OLDAP-2.3",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=d32cf54a32d581ab475d23c810b0a7fbaf8d63c3",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-2.4.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-2.4.json",
				referenceNumber: "115",
				name: "Open LDAP Public License v2.4",
				licenseId: "OLDAP-2.4",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=cd1284c4a91a8a380d904eee68d1583f989ed386",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-2.5.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-2.5.json",
				referenceNumber: "108",
				name: "Open LDAP Public License v2.5",
				licenseId: "OLDAP-2.5",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=6852b9d90022e8593c98205413380536b1b5a7cf",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-2.6.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-2.6.json",
				referenceNumber: "109",
				name: "Open LDAP Public License v2.6",
				licenseId: "OLDAP-2.6",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=1cae062821881f41b73012ba816434897abf4205",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-2.7.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/OLDAP-2.7.json",
				referenceNumber: "229",
				name: "Open LDAP Public License v2.7",
				licenseId: "OLDAP-2.7",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=47c2415c1df81556eeb39be6cad458ef87c534a2",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-2.8.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-2.8.json",
				referenceNumber: "252",
				name: "Open LDAP Public License v2.8",
				licenseId: "OLDAP-2.8",
				seeAlso: ["http://www.openldap.org/software/release/license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./OML.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OML.json",
				referenceNumber: "171",
				name: "Open Market License",
				licenseId: "OML",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/Open_Market_License",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OPL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OPL-1.0.json",
				referenceNumber: "338",
				name: "Open Public License v1.0",
				licenseId: "OPL-1.0",
				seeAlso: [
					"http://old.koalateam.com/jackaroo/OPL_1_0.TXT",
					"https://fedoraproject.org/wiki/Licensing/Open_Public_License",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OSET-PL-2.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OSET-PL-2.1.json",
				referenceNumber: "203",
				name: "OSET Public License version 2.1",
				licenseId: "OSET-PL-2.1",
				seeAlso: [
					"http://www.osetfoundation.org/public-license",
					"https://opensource.org/licenses/OPL-2.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./OSL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/OSL-1.0.json",
				referenceNumber: "95",
				name: "Open Software License 1.0",
				licenseId: "OSL-1.0",
				seeAlso: ["https://opensource.org/licenses/OSL-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./OSL-1.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/OSL-1.1.json",
				referenceNumber: "178",
				name: "Open Software License 1.1",
				licenseId: "OSL-1.1",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/OSL1.1"],
				isOsiApproved: false,
			},
			{
				reference: "./OSL-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/OSL-2.0.json",
				referenceNumber: "364",
				name: "Open Software License 2.0",
				licenseId: "OSL-2.0",
				seeAlso: [
					"http://web.archive.org/web/20041020171434/http://www.rosenlaw.com/osl2.0.html",
				],
				isOsiApproved: true,
			},
			{
				reference: "./OSL-2.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/OSL-2.1.json",
				referenceNumber: "157",
				name: "Open Software License 2.1",
				licenseId: "OSL-2.1",
				seeAlso: [
					"http://web.archive.org/web/20050212003940/http://www.rosenlaw.com/osl21.htm",
					"https://opensource.org/licenses/OSL-2.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./OSL-3.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/OSL-3.0.json",
				referenceNumber: "149",
				name: "Open Software License 3.0",
				licenseId: "OSL-3.0",
				seeAlso: [
					"https://web.archive.org/web/20120101081418/http://rosenlaw.com:80/OSL3.0.htm",
					"https://opensource.org/licenses/OSL-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./OpenSSL.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/OpenSSL.json",
				referenceNumber: "83",
				name: "OpenSSL License",
				licenseId: "OpenSSL",
				seeAlso: ["http://www.openssl.org/source/license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./PDDL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/PDDL-1.0.json",
				referenceNumber: "132",
				name: "ODC Public Domain Dedication & License 1.0",
				licenseId: "PDDL-1.0",
				seeAlso: ["http://opendatacommons.org/licenses/pddl/1.0/"],
				isOsiApproved: false,
			},
			{
				reference: "./PHP-3.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/PHP-3.0.json",
				referenceNumber: "191",
				name: "PHP License v3.0",
				licenseId: "PHP-3.0",
				seeAlso: [
					"http://www.php.net/license/3_0.txt",
					"https://opensource.org/licenses/PHP-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./PHP-3.01.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/PHP-3.01.json",
				referenceNumber: "3",
				name: "PHP License v3.01",
				licenseId: "PHP-3.01",
				seeAlso: ["http://www.php.net/license/3_01.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./PSF-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/PSF-2.0.json",
				referenceNumber: "91",
				name: "Python Software Foundation License 2.0",
				licenseId: "PSF-2.0",
				seeAlso: ["https://opensource.org/licenses/Python-2.0"],
				isOsiApproved: false,
			},
			{
				reference: "./Parity-6.0.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Parity-6.0.0.json",
				referenceNumber: "406",
				name: "The Parity Public License 6.0.0",
				licenseId: "Parity-6.0.0",
				seeAlso: ["https://paritylicense.com/versions/6.0.0.html"],
				isOsiApproved: false,
			},
			{
				reference: "./Plexus.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Plexus.json",
				referenceNumber: "156",
				name: "Plexus Classworlds License",
				licenseId: "Plexus",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/Plexus_Classworlds_License",
				],
				isOsiApproved: false,
			},
			{
				reference: "./PostgreSQL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/PostgreSQL.json",
				referenceNumber: "11",
				name: "PostgreSQL License",
				licenseId: "PostgreSQL",
				seeAlso: [
					"http://www.postgresql.org/about/licence",
					"https://opensource.org/licenses/PostgreSQL",
				],
				isOsiApproved: true,
			},
			{
				reference: "./Python-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Python-2.0.json",
				referenceNumber: "393",
				name: "Python License 2.0",
				licenseId: "Python-2.0",
				seeAlso: ["https://opensource.org/licenses/Python-2.0"],
				isOsiApproved: true,
			},
			{
				reference: "./QPL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/QPL-1.0.json",
				referenceNumber: "289",
				name: "Q Public License 1.0",
				licenseId: "QPL-1.0",
				seeAlso: [
					"http://doc.qt.nokia.com/3.3/license.html",
					"https://opensource.org/licenses/QPL-1.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./Qhull.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Qhull.json",
				referenceNumber: "124",
				name: "Qhull License",
				licenseId: "Qhull",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Qhull"],
				isOsiApproved: false,
			},
			{
				reference: "./RHeCos-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/RHeCos-1.1.json",
				referenceNumber: "61",
				name: "Red Hat eCos Public License v1.1",
				licenseId: "RHeCos-1.1",
				seeAlso: ["http://ecos.sourceware.org/old-license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./RPL-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/RPL-1.1.json",
				referenceNumber: "216",
				name: "Reciprocal Public License 1.1",
				licenseId: "RPL-1.1",
				seeAlso: ["https://opensource.org/licenses/RPL-1.1"],
				isOsiApproved: true,
			},
			{
				reference: "./RPL-1.5.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/RPL-1.5.json",
				referenceNumber: "105",
				name: "Reciprocal Public License 1.5",
				licenseId: "RPL-1.5",
				seeAlso: ["https://opensource.org/licenses/RPL-1.5"],
				isOsiApproved: true,
			},
			{
				reference: "./RPSL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/RPSL-1.0.json",
				referenceNumber: "53",
				name: "RealNetworks Public Source License v1.0",
				licenseId: "RPSL-1.0",
				seeAlso: [
					"https://helixcommunity.org/content/rpsl",
					"https://opensource.org/licenses/RPSL-1.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./RSA-MD.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/RSA-MD.json",
				referenceNumber: "279",
				name: "RSA Message-Digest License ",
				licenseId: "RSA-MD",
				seeAlso: ["http://www.faqs.org/rfcs/rfc1321.html"],
				isOsiApproved: false,
			},
			{
				reference: "./RSCPL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/RSCPL.json",
				referenceNumber: "339",
				name: "Ricoh Source Code Public License",
				licenseId: "RSCPL",
				seeAlso: [
					"http://wayback.archive.org/web/20060715140826/http://www.risource.org/RPL/RPL-1.0A.shtml",
					"https://opensource.org/licenses/RSCPL",
				],
				isOsiApproved: true,
			},
			{
				reference: "./Rdisc.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Rdisc.json",
				referenceNumber: "322",
				name: "Rdisc License",
				licenseId: "Rdisc",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Rdisc_License"],
				isOsiApproved: false,
			},
			{
				reference: "./Ruby.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Ruby.json",
				referenceNumber: "14",
				name: "Ruby License",
				licenseId: "Ruby",
				seeAlso: ["http://www.ruby-lang.org/en/LICENSE.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./SAX-PD.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SAX-PD.json",
				referenceNumber: "152",
				name: "Sax Public Domain Notice",
				licenseId: "SAX-PD",
				seeAlso: ["http://www.saxproject.org/copying.html"],
				isOsiApproved: false,
			},
			{
				reference: "./SCEA.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SCEA.json",
				referenceNumber: "137",
				name: "SCEA Shared Source License",
				licenseId: "SCEA",
				seeAlso: ["http://research.scea.com/scea_shared_source_license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./SGI-B-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SGI-B-1.0.json",
				referenceNumber: "189",
				name: "SGI Free Software License B v1.0",
				licenseId: "SGI-B-1.0",
				seeAlso: ["http://oss.sgi.com/projects/FreeB/SGIFreeSWLicB.1.0.html"],
				isOsiApproved: false,
			},
			{
				reference: "./SGI-B-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SGI-B-1.1.json",
				referenceNumber: "288",
				name: "SGI Free Software License B v1.1",
				licenseId: "SGI-B-1.1",
				seeAlso: ["http://oss.sgi.com/projects/FreeB/"],
				isOsiApproved: false,
			},
			{
				reference: "./SGI-B-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/SGI-B-2.0.json",
				referenceNumber: "31",
				name: "SGI Free Software License B v2.0",
				licenseId: "SGI-B-2.0",
				seeAlso: ["http://oss.sgi.com/projects/FreeB/SGIFreeSWLicB.2.0.pdf"],
				isOsiApproved: false,
			},
			{
				reference: "./SHL-0.5.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SHL-0.5.json",
				referenceNumber: "49",
				name: "Solderpad Hardware License v0.5",
				licenseId: "SHL-0.5",
				seeAlso: ["https://solderpad.org/licenses/SHL-0.5/"],
				isOsiApproved: false,
			},
			{
				reference: "./SHL-0.51.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SHL-0.51.json",
				referenceNumber: "281",
				name: "Solderpad Hardware License, Version 0.51",
				licenseId: "SHL-0.51",
				seeAlso: ["https://solderpad.org/licenses/SHL-0.51/"],
				isOsiApproved: false,
			},
			{
				reference: "./SISSL.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/SISSL.json",
				referenceNumber: "78",
				name: "Sun Industry Standards Source License v1.1",
				licenseId: "SISSL",
				seeAlso: [
					"http://www.openoffice.org/licenses/sissl_license.html",
					"https://opensource.org/licenses/SISSL",
				],
				isOsiApproved: true,
			},
			{
				reference: "./SISSL-1.2.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SISSL-1.2.json",
				referenceNumber: "62",
				name: "Sun Industry Standards Source License v1.2",
				licenseId: "SISSL-1.2",
				seeAlso: [
					"http://gridscheduler.sourceforge.net/Gridengine_SISSL_license.html",
				],
				isOsiApproved: false,
			},
			{
				reference: "./SMLNJ.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/SMLNJ.json",
				referenceNumber: "218",
				name: "Standard ML of New Jersey License",
				licenseId: "SMLNJ",
				seeAlso: ["https://www.smlnj.org/license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./SMPPL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SMPPL.json",
				referenceNumber: "106",
				name: "Secure Messaging Protocol Public License",
				licenseId: "SMPPL",
				seeAlso: [
					"https://github.com/dcblake/SMP/blob/server/Documentation/License.txt",
				],
				isOsiApproved: false,
			},
			{
				reference: "./SNIA.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SNIA.json",
				referenceNumber: "302",
				name: "SNIA Public License 1.1",
				licenseId: "SNIA",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/SNIA_Public_License",
				],
				isOsiApproved: false,
			},
			{
				reference: "./SPL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/SPL-1.0.json",
				referenceNumber: "247",
				name: "Sun Public License v1.0",
				licenseId: "SPL-1.0",
				seeAlso: ["https://opensource.org/licenses/SPL-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./SSH-OpenSSH.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SSH-OpenSSH.json",
				referenceNumber: "22",
				name: "SSH OpenSSH license",
				licenseId: "SSH-OpenSSH",
				seeAlso: [
					"https://github.com/openssh/openssh-portable/blob/1b11ea7c58cd5c59838b5fa574cd456d6047b2d4/LICENCE#L10",
				],
				isOsiApproved: false,
			},
			{
				reference: "./SSH-short.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SSH-short.json",
				referenceNumber: "67",
				name: "SSH short notice",
				licenseId: "SSH-short",
				seeAlso: [
					"https://github.com/openssh/openssh-portable/blob/1b11ea7c58cd5c59838b5fa574cd456d6047b2d4/pathnames.h",
					"http://web.mit.edu/kolya/.f/root/athena.mit.edu/sipb.mit.edu/project/openssh/OldFiles/src/openssh-2.9.9p2/ssh-add.1",
					"https://joinup.ec.europa.eu/svn/lesoll/trunk/italc/lib/src/dsa_key.cpp",
				],
				isOsiApproved: false,
			},
			{
				reference: "./SSPL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SSPL-1.0.json",
				referenceNumber: "334",
				name: "Server Side Public License, v 1",
				licenseId: "SSPL-1.0",
				seeAlso: [
					"https://www.mongodb.com/licensing/server-side-public-license",
				],
				isOsiApproved: false,
			},
			{
				reference: "./SWL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SWL.json",
				referenceNumber: "93",
				name: "Scheme Widget Library (SWL) Software License Agreement",
				licenseId: "SWL",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/SWL"],
				isOsiApproved: false,
			},
			{
				reference: "./Saxpath.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Saxpath.json",
				referenceNumber: "34",
				name: "Saxpath License",
				licenseId: "Saxpath",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Saxpath_License"],
				isOsiApproved: false,
			},
			{
				reference: "./Sendmail.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Sendmail.json",
				referenceNumber: "293",
				name: "Sendmail License",
				licenseId: "Sendmail",
				seeAlso: [
					"http://www.sendmail.com/pdfs/open_source/sendmail_license.pdf",
					"https://web.archive.org/web/20160322142305/https://www.sendmail.com/pdfs/open_source/sendmail_license.pdf",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Sendmail-8.23.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Sendmail-8.23.json",
				referenceNumber: "176",
				name: "Sendmail License 8.23",
				licenseId: "Sendmail-8.23",
				seeAlso: [
					"https://www.proofpoint.com/sites/default/files/sendmail-license.pdf",
					"https://web.archive.org/web/20181003101040/https://www.proofpoint.com/sites/default/files/sendmail-license.pdf",
				],
				isOsiApproved: false,
			},
			{
				reference: "./SimPL-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SimPL-2.0.json",
				referenceNumber: "250",
				name: "Simple Public License 2.0",
				licenseId: "SimPL-2.0",
				seeAlso: ["https://opensource.org/licenses/SimPL-2.0"],
				isOsiApproved: true,
			},
			{
				reference: "./Sleepycat.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Sleepycat.json",
				referenceNumber: "56",
				name: "Sleepycat License",
				licenseId: "Sleepycat",
				seeAlso: ["https://opensource.org/licenses/Sleepycat"],
				isOsiApproved: true,
			},
			{
				reference: "./Spencer-86.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Spencer-86.json",
				referenceNumber: "184",
				name: "Spencer License 86",
				licenseId: "Spencer-86",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/Henry_Spencer_Reg-Ex_Library_License",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Spencer-94.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Spencer-94.json",
				referenceNumber: "213",
				name: "Spencer License 94",
				licenseId: "Spencer-94",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/Henry_Spencer_Reg-Ex_Library_License",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Spencer-99.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Spencer-99.json",
				referenceNumber: "64",
				name: "Spencer License 99",
				licenseId: "Spencer-99",
				seeAlso: [
					"http://www.opensource.apple.com/source/tcl/tcl-5/tcl/generic/regfronts.c",
				],
				isOsiApproved: false,
			},
			{
				reference: "./StandardML-NJ.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/StandardML-NJ.json",
				referenceNumber: "285",
				name: "Standard ML of New Jersey License",
				licenseId: "StandardML-NJ",
				seeAlso: ["http://www.smlnj.org//license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./SugarCRM-1.1.3.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SugarCRM-1.1.3.json",
				referenceNumber: "342",
				name: "SugarCRM Public License v1.1.3",
				licenseId: "SugarCRM-1.1.3",
				seeAlso: ["http://www.sugarcrm.com/crm/SPL"],
				isOsiApproved: false,
			},
			{
				reference: "./TAPR-OHL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/TAPR-OHL-1.0.json",
				referenceNumber: "9",
				name: "TAPR Open Hardware License v1.0",
				licenseId: "TAPR-OHL-1.0",
				seeAlso: ["https://www.tapr.org/OHL"],
				isOsiApproved: false,
			},
			{
				reference: "./TCL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/TCL.json",
				referenceNumber: "54",
				name: "TCL/TK License",
				licenseId: "TCL",
				seeAlso: [
					"http://www.tcl.tk/software/tcltk/license.html",
					"https://fedoraproject.org/wiki/Licensing/TCL",
				],
				isOsiApproved: false,
			},
			{
				reference: "./TCP-wrappers.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/TCP-wrappers.json",
				referenceNumber: "234",
				name: "TCP Wrappers License",
				licenseId: "TCP-wrappers",
				seeAlso: ["http://rc.quest.com/topics/openssh/license.php#tcpwrappers"],
				isOsiApproved: false,
			},
			{
				reference: "./TMate.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/TMate.json",
				referenceNumber: "402",
				name: "TMate Open Source License",
				licenseId: "TMate",
				seeAlso: ["http://svnkit.com/license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./TORQUE-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/TORQUE-1.1.json",
				referenceNumber: "188",
				name: "TORQUE v2.5+ Software License v1.1",
				licenseId: "TORQUE-1.1",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/TORQUEv1.1"],
				isOsiApproved: false,
			},
			{
				reference: "./TOSL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/TOSL.json",
				referenceNumber: "251",
				name: "Trusster Open Source License",
				licenseId: "TOSL",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/TOSL"],
				isOsiApproved: false,
			},
			{
				reference: "./TU-Berlin-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/TU-Berlin-1.0.json",
				referenceNumber: "372",
				name: "Technische Universitaet Berlin License 1.0",
				licenseId: "TU-Berlin-1.0",
				seeAlso: [
					"https://github.com/swh/ladspa/blob/7bf6f3799fdba70fda297c2d8fd9f526803d9680/gsm/COPYRIGHT",
				],
				isOsiApproved: false,
			},
			{
				reference: "./TU-Berlin-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/TU-Berlin-2.0.json",
				referenceNumber: "392",
				name: "Technische Universitaet Berlin License 2.0",
				licenseId: "TU-Berlin-2.0",
				seeAlso: [
					"https://github.com/CorsixTH/deps/blob/fd339a9f526d1d9c9f01ccf39e438a015da50035/licences/libgsm.txt",
				],
				isOsiApproved: false,
			},
			{
				reference: "./UCL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/UCL-1.0.json",
				referenceNumber: "291",
				name: "Upstream Compatibility License v1.0",
				licenseId: "UCL-1.0",
				seeAlso: ["https://opensource.org/licenses/UCL-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./UPL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/UPL-1.0.json",
				referenceNumber: "144",
				name: "Universal Permissive License v1.0",
				licenseId: "UPL-1.0",
				seeAlso: ["https://opensource.org/licenses/UPL"],
				isOsiApproved: true,
			},
			{
				reference: "./Unicode-DFS-2015.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Unicode-DFS-2015.json",
				referenceNumber: "260",
				name: "Unicode License Agreement - Data Files and Software (2015)",
				licenseId: "Unicode-DFS-2015",
				seeAlso: [
					"https://web.archive.org/web/20151224134844/http://unicode.org/copyright.html",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Unicode-DFS-2016.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Unicode-DFS-2016.json",
				referenceNumber: "370",
				name: "Unicode License Agreement - Data Files and Software (2016)",
				licenseId: "Unicode-DFS-2016",
				seeAlso: ["http://www.unicode.org/copyright.html"],
				isOsiApproved: false,
			},
			{
				reference: "./Unicode-TOU.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Unicode-TOU.json",
				referenceNumber: "16",
				name: "Unicode Terms of Use",
				licenseId: "Unicode-TOU",
				seeAlso: ["http://www.unicode.org/copyright.html"],
				isOsiApproved: false,
			},
			{
				reference: "./Unlicense.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Unlicense.json",
				referenceNumber: "173",
				name: "The Unlicense",
				licenseId: "Unlicense",
				seeAlso: ["https://unlicense.org/"],
				isOsiApproved: false,
			},
			{
				reference: "./VOSTROM.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/VOSTROM.json",
				referenceNumber: "352",
				name: "VOSTROM Public License for Open Source",
				licenseId: "VOSTROM",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/VOSTROM"],
				isOsiApproved: false,
			},
			{
				reference: "./VSL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/VSL-1.0.json",
				referenceNumber: "390",
				name: "Vovida Software License v1.0",
				licenseId: "VSL-1.0",
				seeAlso: ["https://opensource.org/licenses/VSL-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./Vim.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Vim.json",
				referenceNumber: "206",
				name: "Vim License",
				licenseId: "Vim",
				seeAlso: ["http://vimdoc.sourceforge.net/htmldoc/uganda.html"],
				isOsiApproved: false,
			},
			{
				reference: "./W3C.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/W3C.json",
				referenceNumber: "107",
				name: "W3C Software Notice and License (2002-12-31)",
				licenseId: "W3C",
				seeAlso: [
					"http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231.html",
					"https://opensource.org/licenses/W3C",
				],
				isOsiApproved: true,
			},
			{
				reference: "./W3C-19980720.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/W3C-19980720.json",
				referenceNumber: "266",
				name: "W3C Software Notice and License (1998-07-20)",
				licenseId: "W3C-19980720",
				seeAlso: [
					"http://www.w3.org/Consortium/Legal/copyright-software-19980720.html",
				],
				isOsiApproved: false,
			},
			{
				reference: "./W3C-20150513.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/W3C-20150513.json",
				referenceNumber: "111",
				name: "W3C Software Notice and Document License (2015-05-13)",
				licenseId: "W3C-20150513",
				seeAlso: [
					"https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document",
				],
				isOsiApproved: false,
			},
			{
				reference: "./WTFPL.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/WTFPL.json",
				referenceNumber: "20",
				name: "Do What The F*ck You Want To Public License",
				licenseId: "WTFPL",
				seeAlso: ["http://sam.zoy.org/wtfpl/COPYING"],
				isOsiApproved: false,
			},
			{
				reference: "./Watcom-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Watcom-1.0.json",
				referenceNumber: "141",
				name: "Sybase Open Watcom Public License 1.0",
				licenseId: "Watcom-1.0",
				seeAlso: ["https://opensource.org/licenses/Watcom-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./Wsuipa.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Wsuipa.json",
				referenceNumber: "255",
				name: "Wsuipa License",
				licenseId: "Wsuipa",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Wsuipa"],
				isOsiApproved: false,
			},
			{
				reference: "./X11.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/X11.json",
				referenceNumber: "99",
				name: "X11 License",
				licenseId: "X11",
				seeAlso: ["http://www.xfree86.org/3.3.6/COPYRIGHT2.html#3"],
				isOsiApproved: false,
			},
			{
				reference: "./XFree86-1.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/XFree86-1.1.json",
				referenceNumber: "155",
				name: "XFree86 License 1.1",
				licenseId: "XFree86-1.1",
				seeAlso: ["http://www.xfree86.org/current/LICENSE4.html"],
				isOsiApproved: false,
			},
			{
				reference: "./XSkat.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/XSkat.json",
				referenceNumber: "81",
				name: "XSkat License",
				licenseId: "XSkat",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/XSkat_License"],
				isOsiApproved: false,
			},
			{
				reference: "./Xerox.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Xerox.json",
				referenceNumber: "224",
				name: "Xerox License",
				licenseId: "Xerox",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Xerox"],
				isOsiApproved: false,
			},
			{
				reference: "./Xnet.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Xnet.json",
				referenceNumber: "313",
				name: "X.Net License",
				licenseId: "Xnet",
				seeAlso: ["https://opensource.org/licenses/Xnet"],
				isOsiApproved: true,
			},
			{
				reference: "./YPL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/YPL-1.0.json",
				referenceNumber: "292",
				name: "Yahoo! Public License v1.0",
				licenseId: "YPL-1.0",
				seeAlso: ["http://www.zimbra.com/license/yahoo_public_license_1.0.html"],
				isOsiApproved: false,
			},
			{
				reference: "./YPL-1.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/YPL-1.1.json",
				referenceNumber: "40",
				name: "Yahoo! Public License v1.1",
				licenseId: "YPL-1.1",
				seeAlso: ["http://www.zimbra.com/license/yahoo_public_license_1.1.html"],
				isOsiApproved: false,
			},
			{
				reference: "./ZPL-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/ZPL-1.1.json",
				referenceNumber: "85",
				name: "Zope Public License 1.1",
				licenseId: "ZPL-1.1",
				seeAlso: ["http://old.zope.org/Resources/License/ZPL-1.1"],
				isOsiApproved: false,
			},
			{
				reference: "./ZPL-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/ZPL-2.0.json",
				referenceNumber: "112",
				name: "Zope Public License 2.0",
				licenseId: "ZPL-2.0",
				seeAlso: [
					"http://old.zope.org/Resources/License/ZPL-2.0",
					"https://opensource.org/licenses/ZPL-2.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./ZPL-2.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/ZPL-2.1.json",
				referenceNumber: "368",
				name: "Zope Public License 2.1",
				licenseId: "ZPL-2.1",
				seeAlso: ["http://old.zope.org/Resources/ZPL/"],
				isOsiApproved: false,
			},
			{
				reference: "./Zed.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Zed.json",
				referenceNumber: "114",
				name: "Zed License",
				licenseId: "Zed",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Zed"],
				isOsiApproved: false,
			},
			{
				reference: "./Zend-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Zend-2.0.json",
				referenceNumber: "373",
				name: "Zend License v2.0",
				licenseId: "Zend-2.0",
				seeAlso: [
					"https://web.archive.org/web/20130517195954/http://www.zend.com/license/2_00.txt",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Zimbra-1.3.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Zimbra-1.3.json",
				referenceNumber: "175",
				name: "Zimbra Public License v1.3",
				licenseId: "Zimbra-1.3",
				seeAlso: [
					"http://web.archive.org/web/20100302225219/http://www.zimbra.com/license/zimbra-public-license-1-3.html",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Zimbra-1.4.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Zimbra-1.4.json",
				referenceNumber: "385",
				name: "Zimbra Public License v1.4",
				licenseId: "Zimbra-1.4",
				seeAlso: ["http://www.zimbra.com/legal/zimbra-public-license-1-4"],
				isOsiApproved: false,
			},
			{
				reference: "./Zlib.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Zlib.json",
				referenceNumber: "45",
				name: "zlib License",
				licenseId: "Zlib",
				seeAlso: [
					"http://www.zlib.net/zlib_license.html",
					"https://opensource.org/licenses/Zlib",
				],
				isOsiApproved: true,
			},
			{
				reference: "./blessing.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/blessing.json",
				referenceNumber: "301",
				name: "SQLite Blessing",
				licenseId: "blessing",
				seeAlso: [
					"https://www.sqlite.org/src/artifact/e33a4df7e32d742a?ln=4-9",
					"https://sqlite.org/src/artifact/df5091916dbb40e6",
				],
				isOsiApproved: false,
			},
			{
				reference: "./bzip2-1.0.5.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/bzip2-1.0.5.json",
				referenceNumber: "186",
				name: "bzip2 and libbzip2 License v1.0.5",
				licenseId: "bzip2-1.0.5",
				seeAlso: ["http://bzip.org/1.0.5/bzip2-manual-1.0.5.html"],
				isOsiApproved: false,
			},
			{
				reference: "./bzip2-1.0.6.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/bzip2-1.0.6.json",
				referenceNumber: "69",
				name: "bzip2 and libbzip2 License v1.0.6",
				licenseId: "bzip2-1.0.6",
				seeAlso: ["https://github.com/asimonov-im/bzip2/blob/server/LICENSE"],
				isOsiApproved: false,
			},
			{
				reference: "./copyleft-next-0.3.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/copyleft-next-0.3.0.json",
				referenceNumber: "312",
				name: "copyleft-next 0.3.0",
				licenseId: "copyleft-next-0.3.0",
				seeAlso: [
					"https://github.com/copyleft-next/copyleft-next/blob/server/Releases/copyleft-next-0.3.0",
				],
				isOsiApproved: false,
			},
			{
				reference: "./copyleft-next-0.3.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/copyleft-next-0.3.1.json",
				referenceNumber: "378",
				name: "copyleft-next 0.3.1",
				licenseId: "copyleft-next-0.3.1",
				seeAlso: [
					"https://github.com/copyleft-next/copyleft-next/blob/server/Releases/copyleft-next-0.3.1",
				],
				isOsiApproved: false,
			},
			{
				reference: "./curl.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/curl.json",
				referenceNumber: "314",
				name: "curl License",
				licenseId: "curl",
				seeAlso: ["https://github.com/bagder/curl/blob/server/COPYING"],
				isOsiApproved: false,
			},
			{
				reference: "./diffmark.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/diffmark.json",
				referenceNumber: "397",
				name: "diffmark license",
				licenseId: "diffmark",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/diffmark"],
				isOsiApproved: false,
			},
			{
				reference: "./dvipdfm.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/dvipdfm.json",
				referenceNumber: "19",
				name: "dvipdfm License",
				licenseId: "dvipdfm",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/dvipdfm"],
				isOsiApproved: false,
			},
			{
				reference: "./eCos-2.0.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/eCos-2.0.json",
				referenceNumber: "272",
				name: "eCos license version 2.0",
				licenseId: "eCos-2.0",
				seeAlso: ["https://www.gnu.org/licenses/ecos-license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./eGenix.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/eGenix.json",
				referenceNumber: "214",
				name: "eGenix.com Public License 1.1.0",
				licenseId: "eGenix",
				seeAlso: [
					"http://www.egenix.com/products/eGenix.com-Public-License-1.1.0.pdf",
					"https://fedoraproject.org/wiki/Licensing/eGenix.com_Public_License_1.1.0",
				],
				isOsiApproved: false,
			},
			{
				reference: "./etalab-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/etalab-2.0.json",
				referenceNumber: "259",
				name: "Etalab Open License 2.0",
				licenseId: "etalab-2.0",
				seeAlso: [
					"https://github.com/DISIC/politique-de-contribution-open-source/blob/server/LICENSE.pdf",
					"https://raw.githubusercontent.com/DISIC/politique-de-contribution-open-source/server/LICENSE",
				],
				isOsiApproved: false,
			},
			{
				reference: "./gSOAP-1.3b.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/gSOAP-1.3b.json",
				referenceNumber: "167",
				name: "gSOAP Public License v1.3b",
				licenseId: "gSOAP-1.3b",
				seeAlso: ["http://www.cs.fsu.edu/~engelen/license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./gnuplot.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/gnuplot.json",
				referenceNumber: "383",
				name: "gnuplot License",
				licenseId: "gnuplot",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Gnuplot"],
				isOsiApproved: false,
			},
			{
				reference: "./iMatix.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/iMatix.json",
				referenceNumber: "177",
				name: "iMatix Standard Function Library Agreement",
				licenseId: "iMatix",
				seeAlso: ["http://legacy.imatix.com/html/sfl/sfl4.htm#license"],
				isOsiApproved: false,
			},
			{
				reference: "./libpng-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/libpng-2.0.json",
				referenceNumber: "103",
				name: "PNG Reference Library version 2",
				licenseId: "libpng-2.0",
				seeAlso: ["http://www.libpng.org/pub/png/src/libpng-LICENSE.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./libselinux-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/libselinux-1.0.json",
				referenceNumber: "18",
				name: "libselinux public domain notice",
				licenseId: "libselinux-1.0",
				seeAlso: [
					"https://github.com/SELinuxProject/selinux/blob/server/libselinux/LICENSE",
				],
				isOsiApproved: false,
			},
			{
				reference: "./libtiff.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/libtiff.json",
				referenceNumber: "407",
				name: "libtiff License",
				licenseId: "libtiff",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/libtiff"],
				isOsiApproved: false,
			},
			{
				reference: "./mpich2.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/mpich2.json",
				referenceNumber: "60",
				name: "mpich2 License",
				licenseId: "mpich2",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/MIT"],
				isOsiApproved: false,
			},
			{
				reference: "./psfrag.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/psfrag.json",
				referenceNumber: "408",
				name: "psfrag License",
				licenseId: "psfrag",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/psfrag"],
				isOsiApproved: false,
			},
			{
				reference: "./psutils.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/psutils.json",
				referenceNumber: "277",
				name: "psutils License",
				licenseId: "psutils",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/psutils"],
				isOsiApproved: false,
			},
			{
				reference: "./wxWindows.html",
				isDeprecatedLicenseId: true,
				detailsUrl: "http://spdx.org/licenses/wxWindows.json",
				referenceNumber: "244",
				name: "wxWindows Library License",
				licenseId: "wxWindows",
				seeAlso: ["https://opensource.org/licenses/WXwindows"],
				isOsiApproved: false,
			},
			{
				reference: "./xinetd.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/xinetd.json",
				referenceNumber: "399",
				name: "xinetd License",
				licenseId: "xinetd",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Xinetd_License"],
				isOsiApproved: false,
			},
			{
				reference: "./xpp.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/xpp.json",
				referenceNumber: "96",
				name: "XPP License",
				licenseId: "xpp",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/xpp"],
				isOsiApproved: false,
			},
			{
				reference: "./zlib-acknowledgement.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/zlib-acknowledgement.json",
				referenceNumber: "246",
				name: "zlib/libpng License with Acknowledgement",
				licenseId: "zlib-acknowledgement",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/ZlibWithAcknowledgement",
				],
				isOsiApproved: false,
			},
		],
		releaseDate: "2020-02-13",
	};


  // project-rome/@internal/codec-spdx-license/parse.ts
function ___R$$priv$project$rome$$internal$codec$spdx$license$parse_ts$isWordChar(
		char,
	) {
		return (
			___R$project$rome$$internal$parser$core$utils_ts$isAlpha(char) ||
			___R$project$rome$$internal$parser$core$utils_ts$isDigit(char) ||
			char === "-" ||
			char === "."
		);
	}

	const ___R$$priv$project$rome$$internal$codec$spdx$license$parse_ts$createSPDXLicenseParser = ___R$project$rome$$internal$parser$core$utils_ts$createParser({
		diagnosticCategory: "parse/spdxLicense",
		ignoreWhitespaceTokens: true,
		tokenize(parser, index) {
			const char = parser.getInputCharOnly(index);

			if (char === "+") {
				return parser.finishToken("Plus");
			}

			if (char === "(") {
				return parser.finishToken("ParenOpen");
			}

			if (char === ")") {
				return parser.finishToken("ParenClose");
			}

			if (
				___R$$priv$project$rome$$internal$codec$spdx$license$parse_ts$isWordChar(
					char,
				)
			) {
				const [value, end] = parser.readInputFrom(
					index,
					___R$$priv$project$rome$$internal$codec$spdx$license$parse_ts$isWordChar,
				);

				if (value === "AND") {
					return parser.finishToken("And", end);
				} else if (value === "OR") {
					return parser.finishToken("Or", end);
				} else if (value === "WITH") {
					return parser.finishToken("With", end);
				} else {
					return parser.finishValueToken("Word", value, end);
				}
			}

			return undefined;
		},
	});

	function ___R$$priv$project$rome$$internal$codec$spdx$license$parse_ts$parseLicense(
		parser,
		token,
	) {
		const startPos = parser.getPosition();
		parser.nextToken();

		// Validate id
		const id = token.value;
		let licenseInfo = ___R$project$rome$$internal$codec$spdx$license$index_ts$getSPDXLicense(
			id,
		);
		const nextToken = parser.getToken();

		// Sometimes licenses will be specified as "Apache 2.0" but what they actually meant was "Apache-2.0"

		// In loose mode, just make it equivalent, otherwise, complain
		if (licenseInfo === undefined && nextToken.type === "Word") {
			const possibleCorrectLicense = id + "-" + nextToken.value;
			const possibleLicenseInfo = ___R$project$rome$$internal$codec$spdx$license$index_ts$getSPDXLicense(
				possibleCorrectLicense,
			);

			if (possibleLicenseInfo !== undefined) {
				if (parser.options.loose) {
					// Just allow it...
					licenseInfo = possibleLicenseInfo;
					parser.nextToken();
				} else {
					throw parser.unexpected({
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SPDX.VALID_LICENSE_WITH_MISSING_DASH(
							possibleCorrectLicense,
						),
						start: parser.getPositionFromIndex(token.start),
						end: parser.getPositionFromIndex(nextToken.end),
					});
				}
			}
		}

		if (licenseInfo === undefined) {
			throw parser.unexpected({
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SPDX.UNKNOWN_LICENSE(
					id,
					___R$project$rome$$internal$codec$spdx$license$index_ts$licenseNames,
				),
				start: parser.getPositionFromIndex(token.start),
				end: parser.getPositionFromIndex(token.end),
			});
		}

		// Is this a plus? (wtf is this)
		const plus = parser.eatToken("Plus") !== undefined;

		// Get exception
		let exception;
		if (parser.eatToken("With")) {
			const token = parser.getToken();
			if (token.type === "Word") {
				exception = token.value;
				parser.nextToken();
			} else {
				throw parser.unexpected({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SPDX.WITH_RIGHT_LICENSE_ONLY,
				});
			}
		}

		return {
			type: "License",
			loc: parser.finishLoc(startPos),
			id: licenseInfo.licenseId,
			exception,
			plus,
		};
	}

	function ___R$$priv$project$rome$$internal$codec$spdx$license$parse_ts$parseExpression(
		parser,
	) {
		const startPos = parser.getPosition();
		const startToken = parser.getToken();

		let value;

		switch (startToken.type) {
			case "ParenOpen": {
				parser.nextToken();
				value = ___R$$priv$project$rome$$internal$codec$spdx$license$parse_ts$parseExpression(
					parser,
				);
				parser.expectToken("ParenClose");
				break;
			}

			case "Word": {
				value = ___R$$priv$project$rome$$internal$codec$spdx$license$parse_ts$parseLicense(
					parser,
					startToken,
				);
				break;
			}

			case "Or":
			case "And":
				throw parser.unexpected({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SPDX.OPERATOR_NOT_BETWEEN_EXPRESSION,
				});

			case "Plus":
				throw parser.unexpected({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SPDX.PLUS_NOT_AFTER_LICENSE,
				});

			case "ParenClose":
				throw parser.unexpected({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SPDX.UNOPENED_PAREN,
				});

			default:
				throw parser.unexpected();
		}

		// Parse and/or
		const nextToken = parser.getToken();
		switch (nextToken.type) {
			case "Or": {
				parser.nextToken();
				return {
					type: "Or",
					loc: parser.finishLoc(startPos),
					left: value,
					right: ___R$$priv$project$rome$$internal$codec$spdx$license$parse_ts$parseExpression(
						parser,
					),
				};
			}

			case "And": {
				parser.nextToken();
				return {
					type: "And",
					loc: parser.finishLoc(startPos),
					left: value,
					right: ___R$$priv$project$rome$$internal$codec$spdx$license$parse_ts$parseExpression(
						parser,
					),
				};
			}

			default:
				return value;
		}
	}

	function ___R$project$rome$$internal$codec$spdx$license$parse_ts$default(opts) {
		const parser = ___R$$priv$project$rome$$internal$codec$spdx$license$parse_ts$createSPDXLicenseParser(
			opts,
		);
		const expr = ___R$$priv$project$rome$$internal$codec$spdx$license$parse_ts$parseExpression(
			parser,
		);
		parser.finalize();
		return expr;
	}


  // project-rome/@internal/codec-spdx-license/stringify.ts
function ___R$project$rome$$internal$codec$spdx$license$stringify_ts$default(
		node,
	) {
		// TODO parens
		switch (node.type) {
			case "Or":
				return (
					___R$project$rome$$internal$codec$spdx$license$stringify_ts$default(
						node.left,
					) +
					" OR " +
					___R$project$rome$$internal$codec$spdx$license$stringify_ts$default(
						node.right,
					)
				);

			case "And":
				return (
					___R$project$rome$$internal$codec$spdx$license$stringify_ts$default(
						node.left,
					) +
					" AND " +
					___R$project$rome$$internal$codec$spdx$license$stringify_ts$default(
						node.right,
					)
				);

			case "License": {
				let str = node.id;
				if (node.plus) {
					str += "+";
				}
				if (node.exception !== undefined) {
					str += " WITH " + node.exception;
				}
				return str;
			}
		}
	}


  // project-rome/@internal/codec-spdx-license/index.ts
const ___R$$priv$project$rome$$internal$codec$spdx$license$index_ts$idToLicense = new Map();
	const ___R$project$rome$$internal$codec$spdx$license$index_ts$licenseNames = [];
	for (const license of ___R$project$rome$$internal$codec$spdx$license$data_ts$default.licenses) {
		___R$project$rome$$internal$codec$spdx$license$index_ts$licenseNames.push(
			license.licenseId,
		);
		___R$$priv$project$rome$$internal$codec$spdx$license$index_ts$idToLicense.set(
			license.licenseId.toLowerCase(),
			license,
		);
	}

	function ___R$project$rome$$internal$codec$spdx$license$index_ts$getSPDXLicense(
		licenseId,
	) {
		return ___R$$priv$project$rome$$internal$codec$spdx$license$index_ts$idToLicense.get(
			licenseId.toLowerCase(),
		);
	}


  // project-rome/@internal/codec-js-manifest/name.ts
function ___R$$priv$project$rome$$internal$codec$js$manifest$name_ts$validateNamePart(
		{loose, unexpected},
		{name, isOrg, isOrgPart, offset},
	) {
		let normalizedName = "";

		for (let i = 0; i < name.length; i++) {
			const char = name[i];

			if (isOrg && char === "@" && i === 0) {
				unexpected({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.MANIFEST.REDUNDANT_ORG_NAME_START,
					start: ___R$project$rome$$internal$ob1$index_ts$ob1Add(offset, i),
				});
			} else if (!isOrgPart && char === "/") {
				/*unexpected({
        at: 'prefix',
        message: `cannot contain any slashes`,
        start: add(offset, i),
        advice: [
          {
            type: 'log',
            category: 'info',
            message:
              'Did you forget a <emphasis>@</emphasis> prefix to make this a scope?',
          },
        ],
      });*/
				normalizedName = "@" + normalizedName + "/";
			} else if (!loose && char.match(/[A-Z]/)) {
				/*unexpected({
          at: 'prefix',
          message: `cannot contain uppercase letters`,
          start: add(offset, i),
        });*/
				normalizedName += char.toLowerCase();
			} else if (char.match(/[A-Za-z0-9\-_.]/)) {
				normalizedName += char;
			} else {
				unexpected({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.MANIFEST.INVALID_NAME_CHAR(
						char,
					),
					start: ___R$project$rome$$internal$ob1$index_ts$ob1Add(offset, i),
				});
			}
		}

		return normalizedName;
	}

	function ___R$project$rome$$internal$codec$js$manifest$name_ts$manifestNameToString(
		name,
	) {
		const {packageName, org} = name;

		if (org === undefined) {
			return packageName;
		}

		return "@" + org + "/" + packageName;
	}

	function ___R$project$rome$$internal$codec$js$manifest$name_ts$normalizeName(
		opts,
	) {
		const {unexpected} = opts;
		let {name} = opts;

		let org;
		let packageName;

		if (name.length > 214) {
			unexpected({
				at: "prefix",
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.MANIFEST.NAME_EXCEEDS,
			});
			name = name.slice(0, 214);
		}

		if (name[0] === "." || name[0] === "_") {
			unexpected({
				at: "prefix",
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.MANIFEST.INVALID_NAME_START,
				start: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
			});
			name = name.slice(1);
		}

		if (name[0] === "@") {
			// Validate org and package name separately
			const [rawOrg, rawPackageName, ...other] = name.slice(1).split("/");

			// Leading @
			let offset = ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(1);

			// Org
			const sanitizedOrg = ___R$$priv$project$rome$$internal$codec$js$manifest$name_ts$validateNamePart(
				opts,
				{
					isOrg: true,
					isOrgPart: true,
					name: rawOrg,
					offset,
				},
			);
			offset = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
				offset,
				rawOrg.length,
			);
			org = sanitizedOrg;

			if (rawPackageName === undefined) {
				unexpected({
					at: "prefix",
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.MANIFEST.ORG_WITH_NO_PACKAGE_NAME,
					start: offset,
				});
			} else {
				// Forward slashSeparator
				offset = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(offset);

				// Package name
				const sanitizedPackageName = ___R$$priv$project$rome$$internal$codec$js$manifest$name_ts$validateNamePart(
					opts,
					{
						isOrg: false,
						isOrgPart: true,
						name: rawPackageName,
						offset,
					},
				);
				offset = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
					offset,
					rawPackageName.length,
				);

				// Complain on excess separators
				if (other.length > 0) {
					unexpected({
						at: "prefix",
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.MANIFEST.ORG_TOO_MANY_PARTS,
						start: offset,
					});
				}

				packageName = sanitizedPackageName;
			}
		} else {
			packageName = ___R$$priv$project$rome$$internal$codec$js$manifest$name_ts$validateNamePart(
				opts,
				{
					name,
					offset: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
					isOrg: false,
					isOrgPart: false,
				},
			);
		}

		return {org, packageName};
	}


  // project-rome/@internal/codec-js-manifest/dependencies.ts
function ___R$project$rome$$internal$codec$js$manifest$dependencies_ts$stringifyDependencyPattern(
		pattern,
	) {
		switch (pattern.type) {
			case "hosted-git": {
				let str = pattern.host + ":" + pattern.user + "/" + pattern.repo;
				if (pattern.commitish !== undefined) {
					str += "#" + pattern.commitish;
				}
				return str;
			}

			case "file":
				return "file:" + pattern.path;

			case "gist":
				return "gist:" + pattern.id;

			case "semver":
				return ___R$project$rome$$internal$codec$semver$stringify_ts$default(
					pattern.range,
				);

			case "tag":
				return pattern.tag;

			case "git":
			case "http-tarball":
				if (pattern.hash === undefined) {
					return pattern.url;
				} else {
					return pattern.url + "#" + pattern.hash;
				}

			case "npm": {
				let str =
					"" +
					___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$NPM_PREFIX +
					pattern.name;
				if (pattern.range !== undefined) {
					str +=
						"@" +
						___R$project$rome$$internal$codec$semver$stringify_ts$default(
							pattern.range,
						);
				}
				return str;
			}

			case "link":
				return (
					"" +
					___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$LINK_PREFIX +
					pattern.path.join()
				);

			case "workspace":
				return (
					"" +
					___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$WORKSPACE_PREFIX +
					pattern.path
				);
		}
	}

	function ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$explodeHashUrl(
		pattern,
		consumer,
	) {
		const parts = pattern.split("#");

		if (parts.length > 2) {
			consumer.unexpected(
				___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.MANIFEST.TOO_MANY_HASH_PARTS,
			);
		}

		return {
			hash: parts[1],
			url: parts[0],
		};
	}

	function ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$removePrefix(
		prefix,
		value,
	) {
		if (value.startsWith(prefix)) {
			return value.slice(prefix.length);
		} else {
			return value;
		}
	}

	//# Gist

	const ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$GIST_PREFIX = "gist:";

	function ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$parseGist(
		pattern,
	) {
		return {
			type: "gist",
			id: pattern.slice(
				___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$GIST_PREFIX.length,
			),
		};
	}

	//# Hosted Gist
	const ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$GITHUB_SHORTHAND = /^[^:@%\/\s.\-][^:@%\/\s]*[\/][^:@\s\/%]+(?:#.*)?$/;

	const ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$HOSTED_GIT_PREFIXES = [
		"bitbucket",
		"github",
		"gitlab",
	];

	function ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$parseHostedGit(
		host,
		pattern,
		consumer,
	) {
		// Extract and trim hash
		let commitish;
		if (pattern.includes("#")) {
			const hashIndex = pattern.indexOf("#");
			commitish = pattern.slice(hashIndex + 1);
			pattern = pattern.slice(0, hashIndex - 1);
		}

		const parts = pattern.split("/");
		if (parts.length > 2) {
			consumer.unexpected(
				___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.MANIFEST.TOO_MANY_HOSTED_GIT_PARTS,
			);
		}

		let user = parts[0];
		if (user === undefined) {
			consumer.unexpected(
				___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.MANIFEST.MISSING_HOSTED_GIT_USER,
			);
			user = "unknown";
		}

		let repo = parts[1];
		if (repo === undefined) {
			consumer.unexpected(
				___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.MANIFEST.MISSING_HOSTED_GIT_REPO,
			);
			repo = "unknown";
		}

		const incomplete = {
			type: "hosted-git",
			host,
			user,
			repo,
			commitish,
		};

		return Object.assign(
			{},
			incomplete,
			{
				url: ___R$project$rome$$internal$codec$js$manifest$dependencies_ts$getHostedGitURL(
					incomplete,
				),
			},
		);
	}

	function ___R$project$rome$$internal$codec$js$manifest$dependencies_ts$getHostedGitURL(
		pattern,
	) {
		switch (pattern.host) {
			case "bitbucket":
				return "";

			case "gitlab":
				return "";

			case "github":
				return "";
		}
	}

	const ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$GIT_PATTERN_MATCHERS = [
		/^git:/,
		/^git\+.+:/,
		/^ssh:/,
		/^https?:.+\.git$/,
		/^https?:.+\.git#.+/,
	];

	function ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$parseGit(
		pattern,
		consumer,
	) {
		return Object.assign(
			{type: "git"},
			___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$explodeHashUrl(
				pattern,
				consumer,
			),
		);
	}

	//# HTTP Tarball
	function ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$parseHttpTarball(
		pattern,
		consumer,
	) {
		return Object.assign(
			{type: "http-tarball"},
			___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$explodeHashUrl(
				pattern,
				consumer,
			),
		);
	}

	//# Semver Range
	function ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$parseSemver(
		pattern,
		consumer,
		loose,
	) {
		const ast = ___R$project$rome$$internal$parser$core$utils_ts$tryParseWithOptionalOffsetPosition(
			{
				loose,
				path: consumer.path,
				input: pattern,
			},
			{
				getOffsetPosition: () => consumer.getLocation("inner-value").start,
				parse: (opts) =>
					___R$project$rome$$internal$codec$semver$parse_ts$parseSemverRange(
						opts,
					)
				,
			},
		);

		return {
			type: "semver",
			range: ast,
		};
	}

	//# File
	const ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$FILE_PREFIX_REGEX = /^\.{1,2}\//;

	function ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$parseFile(
		pattern,
	) {
		return {
			type: "file",
			path: ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$removePrefix(
				"file:",
				pattern,
			),
		};
	}

	//# Tag

	// This regex will likely need to be refined, not sure what the allowable characters of a tag are
	const ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$TAG_REGEX = /^[a-z]+$/g;

	function ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$parseTag(
		pattern,
	) {
		return {
			type: "tag",
			tag: pattern,
		};
	}

	//# Workspace
	const ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$WORKSPACE_PREFIX = "workspace:";

	function ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$parseWorkspace(
		pattern,
	) {
		return {
			type: "workspace",
			path: pattern.slice(
				___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$WORKSPACE_PREFIX.length,
			),
		};
	}

	//# Link
	const ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$LINK_PREFIX = "link:";

	function ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$parseLink(
		pattern,
	) {
		return {
			type: "link",
			path: ___R$project$rome$$internal$path$index_ts$createUnknownPath(
				pattern.slice(
					___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$LINK_PREFIX.length,
				),
			),
		};
	}

	//# Explicit npm
	const ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$NPM_PREFIX = "npm:";

	function ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$parseNpm(
		pattern,
		consumer,
		loose,
	) {
		// Prune prefix
		let offset = ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$NPM_PREFIX.length;
		pattern = pattern.slice(
			___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$NPM_PREFIX.length,
		);

		if (pattern === "") {
			consumer.unexpected(
				___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.MANIFEST.EMPTY_NPM_PATTERN,
			);
			return {
				type: "npm",
				name: {
					org: undefined,
					packageName: undefined,
				},
				range: undefined,
			};
		}

		// Split and verify count
		const parts = pattern.split("@");
		let nameRaw = "";
		let rangeRaw;

		// Org signifier
		if (parts[0] === "") {
			nameRaw += "@";
			parts.shift();
		}

		// Name - We know there'll be at least two due to the empty string conditional
		nameRaw = String(parts.shift());

		// Range
		rangeRaw = parts.shift();

		if (parts.length > 0) {
			consumer.unexpected(
				___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.MANIFEST.TOO_MANY_NPM_PARTS,
			);
		}

		const name = ___R$project$rome$$internal$codec$js$manifest$name_ts$normalizeName({
			name: nameRaw,
			loose,
			unexpected({description, at, start, end}) {
				consumer.unexpected(
					description,
					{
						at,
						loc: start === undefined
							? undefined
							: consumer.getLocationRange(
									___R$project$rome$$internal$ob1$index_ts$ob1Add(start, offset),
									end === undefined
										? undefined
										: ___R$project$rome$$internal$ob1$index_ts$ob1Add(
												end,
												offset,
											),
									"inner-value",
								),
					},
				);
			},
		});

		// Increase offset passed name
		offset += nameRaw.length;
		offset++;

		let range;
		if (rangeRaw !== undefined) {
			range = ___R$project$rome$$internal$parser$core$utils_ts$tryParseWithOptionalOffsetPosition(
				{
					loose,
					path: consumer.path,
					input: rangeRaw,
				},
				{
					getOffsetPosition: () => {
						const pos = consumer.getLocation("inner-value").start;
						return Object.assign(
							{},
							pos,
							{
								column: ___R$project$rome$$internal$ob1$index_ts$ob1Add(
									pos.column,
									offset,
								),
							},
						);
					},
					parse: (opts) =>
						___R$project$rome$$internal$codec$semver$parse_ts$parseSemverRange(
							opts,
						)
					,
				},
			);
		}

		return {
			type: "npm",
			name,
			range,
		};
	}

	//#
	function ___R$project$rome$$internal$codec$js$manifest$dependencies_ts$parseGitDependencyPattern(
		consumer,
	) {
		const pattern = consumer.asString();

		for (const host of ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$HOSTED_GIT_PREFIXES) {
			const prefix = host + ":";
			if (pattern.startsWith(prefix)) {
				return ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$parseHostedGit(
					host,
					___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$removePrefix(
						prefix,
						pattern,
					),
					consumer,
				);
			}
		}

		for (const matcher of ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$GIT_PATTERN_MATCHERS) {
			if (matcher.test(pattern)) {
				return ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$parseGit(
					pattern,
					consumer,
				);
			}
		}

		if (
			___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$GITHUB_SHORTHAND.test(
				pattern,
			)
		) {
			return ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$parseHostedGit(
				"github",
				pattern,
				consumer,
			);
		}

		return undefined;
	}

	// Check if we received something that looks like a pattern that we don't support
	const ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$UNSUPPORTED_PATTERN = /^([a-z]+):/i;

	function ___R$project$rome$$internal$codec$js$manifest$dependencies_ts$parseDependencyPattern(
		consumer,
		loose,
	) {
		const pattern = consumer.asString();

		const gitPattern = ___R$project$rome$$internal$codec$js$manifest$dependencies_ts$parseGitDependencyPattern(
			consumer,
		);
		if (gitPattern !== undefined) {
			return gitPattern;
		}

		if (pattern.startsWith("http://") || pattern.startsWith("https://")) {
			return ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$parseHttpTarball(
				pattern,
				consumer,
			);
		}

		if (
			pattern.startsWith(
				___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$WORKSPACE_PREFIX,
			)
		) {
			return ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$parseWorkspace(
				pattern,
			);
		}

		if (
			pattern.startsWith(
				___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$GIST_PREFIX,
			)
		) {
			return ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$parseGist(
				pattern,
			);
		}

		if (
			pattern.startsWith(
				___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$NPM_PREFIX,
			)
		) {
			return ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$parseNpm(
				pattern,
				consumer,
				loose,
			);
		}

		if (
			pattern.startsWith(
				___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$LINK_PREFIX,
			)
		) {
			return ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$parseLink(
				pattern,
			);
		}

		if (
			___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$FILE_PREFIX_REGEX.test(
				pattern,
			) ||
			___R$project$rome$$internal$path$index_ts$createUnknownPath(pattern).isAbsolute() ||
			pattern.startsWith("file:")
		) {
			return ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$parseFile(
				pattern,
			);
		}

		if (
			pattern.match(
				___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$TAG_REGEX,
			)
		) {
			return ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$parseTag(
				pattern,
			);
		}

		const unsupportedMatch = pattern.match(
			___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$UNSUPPORTED_PATTERN,
		);
		if (unsupportedMatch != null) {
			throw consumer.unexpected(
				___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.MANIFEST.UNSUPPORTED_DEPENDENCY_PATTERN_PREFIX(
					unsupportedMatch[1],
				),
			);
		}

		return ___R$$priv$project$rome$$internal$codec$js$manifest$dependencies_ts$parseSemver(
			pattern,
			consumer,
			loose,
		);
	}

	function ___R$project$rome$$internal$codec$js$manifest$dependencies_ts$normalizeDependencies(
		root,
		key,
		loose,
	) {
		const map = new Map();

		if (!root.has(key)) {
			return map;
		}

		const consumer = root.get(key);

		// Some ridiculous code has the dependencies property as an empty array
		if (Array.isArray(consumer.asUnknown()) && loose) {
			return map;
		}

		for (const [rawName, value] of consumer.asMap()) {
			const nameObj = ___R$project$rome$$internal$codec$js$manifest$name_ts$normalizeName({
				name: rawName,
				loose,
				unexpected: ({description, at}) => {
					value.unexpected(
						description,
						{
							at,
							target: "key",
						},
					);
				},
			});

			const name = ___R$project$rome$$internal$codec$js$manifest$name_ts$manifestNameToString(
				nameObj,
			);
			if (name !== undefined) {
				map.set(
					name,
					___R$project$rome$$internal$codec$js$manifest$dependencies_ts$parseDependencyPattern(
						value,
						loose,
					),
				);
			}
		}

		return map;
	}


  // project-rome/@internal/codec-js-manifest/types.ts
const ___R$project$rome$$internal$codec$js$manifest$types_ts = {};


  // project-rome/@internal/codec-js-manifest/compat.ts
const ___R$project$rome$$internal$codec$js$manifest$compat_ts$PACKAGE_LICENSE_ALIASES = new Map();

	// License isn't specific enough. https://github.com/dcporter/didyoumean.js/blob/master/LICENSE
	___R$project$rome$$internal$codec$js$manifest$compat_ts$PACKAGE_LICENSE_ALIASES.set(
		"didyoumean",
		{
			range: "^1.0.0",
			badLicense: "Apache",
			goodLicense: "Apache-2.0",
		},
	);

	function ___R$project$rome$$internal$codec$js$manifest$compat_ts$normalizeCompatManifest(
		consumer,
		nameObj,
		version,
	) {
		const name = ___R$project$rome$$internal$codec$js$manifest$name_ts$manifestNameToString(
			nameObj,
		);
		if (name === undefined) {
			return;
		}

		// Convert bad licenses
		if (version !== undefined && name === "didyoumean") {
			const license = ___R$project$rome$$internal$codec$js$manifest$compat_ts$PACKAGE_LICENSE_ALIASES.get(
				name,
			);
			if (
				license !== undefined &&
				consumer.get("license").asUnknown() === license.badLicense &&
				___R$project$rome$$internal$codec$semver$index_ts$satisfiesSemver(
					version,
					license.range,
				)
			) {
				consumer.set("license", license.goodLicense);
			}
		}
	}


  // project-rome/@internal/codec-js-manifest/convert.ts
const ___R$project$rome$$internal$codec$js$manifest$convert_ts = {
		convertManifestToJSON: ___R$project$rome$$internal$codec$js$manifest$convert_ts$convertManifestToJSON,
	};
	function ___R$project$rome$$internal$codec$js$manifest$convert_ts$convertManifestToJSON(
		manifest,
	) {
		return Object.assign(
			{},
			manifest.raw,
			{
				name: ___R$project$rome$$internal$codec$js$manifest$name_ts$manifestNameToString(
					manifest.name,
				),
				description: manifest.description,
				private: manifest.private,
				type: manifest.type,
				homepage: manifest.homepage,
				repository: manifest.repository,
				bugs: manifest.bugs,
				main: manifest.main,
				// TODO we now support fallbacks which means manifest.exports is lossy
				exports: ___R$$priv$project$rome$$internal$codec$js$manifest$convert_ts$exportsToObject(
					manifest.exports,
				),
				author: manifest.author,
				contributors: manifest.contributors,
				maintainers: manifest.maintainers,
				version: manifest.version === undefined
					? undefined
					: ___R$project$rome$$internal$codec$semver$stringify_ts$default(
							manifest.version,
						),
				license: manifest.license === undefined
					? undefined
					: ___R$project$rome$$internal$codec$spdx$license$stringify_ts$default(
							manifest.license,
						),
				files: ___R$$priv$project$rome$$internal$codec$js$manifest$convert_ts$maybeArray(
					manifest.files.map((pattern) =>
						___R$project$rome$$internal$path$match$stringify_ts$stringifyPathPattern(
							pattern,
						)
					),
				),
				keywords: ___R$$priv$project$rome$$internal$codec$js$manifest$convert_ts$maybeArray(
					manifest.keywords,
				),
				cpu: ___R$$priv$project$rome$$internal$codec$js$manifest$convert_ts$maybeArray(
					manifest.cpu,
				),
				os: ___R$$priv$project$rome$$internal$codec$js$manifest$convert_ts$maybeArray(
					manifest.os,
				),
				bin: ___R$$priv$project$rome$$internal$codec$js$manifest$convert_ts$mapToObject(
					manifest.bin,
				),
				scripts: ___R$$priv$project$rome$$internal$codec$js$manifest$convert_ts$mapToObject(
					manifest.scripts,
				),
				engines: ___R$$priv$project$rome$$internal$codec$js$manifest$convert_ts$mapToObject(
					manifest.engines,
				),
				dependencies: ___R$$priv$project$rome$$internal$codec$js$manifest$convert_ts$dependencyMapToObject(
					manifest.dependencies,
				),
				devDependencies: ___R$$priv$project$rome$$internal$codec$js$manifest$convert_ts$dependencyMapToObject(
					manifest.devDependencies,
				),
				optionalDependencies: ___R$$priv$project$rome$$internal$codec$js$manifest$convert_ts$dependencyMapToObject(
					manifest.optionalDependencies,
				),
				peerDependencies: ___R$$priv$project$rome$$internal$codec$js$manifest$convert_ts$dependencyMapToObject(
					manifest.peerDependencies,
				),
				// Common misspelling. If this existed then it was turned into bundledDependencies
				bundleDependencies: undefined,
				bundledDependencies: ___R$$priv$project$rome$$internal$codec$js$manifest$convert_ts$maybeArray(
					manifest.bundledDependencies,
				),
			},
		);
	}

	function ___R$$priv$project$rome$$internal$codec$js$manifest$convert_ts$exportsToObject(
		exports,
	) {
		if (exports === false) {
			return false;
		}

		if (exports === true) {
			return;
		}

		if (exports.size === 0) {
			return {};
		}

		const obj = {};

		for (const [key, entries] of exports) {
			const entriesObj = {};
			for (const [type, condition] of entries) {
				entriesObj[type] = ___R$$priv$project$rome$$internal$codec$js$manifest$convert_ts$exportConditionToObject(
					condition,
				);
			}
			obj[key.join()] = entriesObj;
		}

		return obj;
	}

	function ___R$$priv$project$rome$$internal$codec$js$manifest$convert_ts$exportConditionToObject(
		condition,
	) {
		if (condition.type === "relative") {
			return condition.relative.join();
		}

		const obj = {};
		for (const [key, value] of condition.conditions) {
			obj[key] = value.relative.join();
		}
		return obj;
	}

	function ___R$$priv$project$rome$$internal$codec$js$manifest$convert_ts$maybeArray(
		items,
	) {
		if (items.length === 0) {
			return undefined;
		} else {
			return items;
		}
	}

	function ___R$$priv$project$rome$$internal$codec$js$manifest$convert_ts$mapToObject(
		map,
	) {
		if (map.size === 0) {
			return;
		}

		const obj = {};
		for (const [key, value] of map) {
			obj[key] = value;
		}
		return obj;
	}

	function ___R$$priv$project$rome$$internal$codec$js$manifest$convert_ts$dependencyMapToObject(
		map,
	) {
		if (map.size === 0) {
			return;
		}

		const obj = {};
		for (const [name, pattern] of map) {
			obj[name] = ___R$project$rome$$internal$codec$js$manifest$dependencies_ts$stringifyDependencyPattern(
				pattern,
			);
		}
		return obj;
	}


  // project-rome/@internal/codec-js-manifest/index.ts
const ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$TYPO_KEYS = new Map([
		["autohr", "author"],
		["autor", "author"],
		["contributers", "contributors"],
		["depends", "dependencies"],
		["hampage", "homepage"],
		["hompage", "homepage"],
		["prefereGlobal", "preferGlobal"],
		["publicationConfig", "publishConfig"],
		["repo", "repository"],
		["repostitory", "repository"],
		["script", "scripts"],
	]);

	function ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeBoolean(
		consumer,
		key,
	) {
		if (consumer.has(key)) {
			return consumer.get(key).asBoolean();
		} else {
			return undefined;
		}
	}

	function ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeString(
		consumer,
		key,
	) {
		if (consumer.has(key)) {
			return consumer.get(key).asString();
		} else {
			return undefined;
		}
	}

	function ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizePathPatterns(
		consumer,
		loose,
	) {
		return ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeStringArray(
			consumer,
			loose,
		).map((str) =>
			___R$project$rome$$internal$path$match$parse_ts$parsePattern({
				input: str,
			})
		);
	}

	function ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeStringArray(
		consumer,
		loose,
	) {
		if (consumer.exists()) {
			// When we are loose and expect an array but got a string, consider it to be a single element
			if (loose) {
				const val = consumer.asUnknown();

				if (typeof val === "string") {
					return [consumer.asString()];
				}

				// npm for some reason sometimes populates bundleDependencies as false? Despite it being a misspelling?
				if (val === false) {
					return [];
				}
			}

			return consumer.asMappedArray((item) => item.asString());
		} else {
			return [];
		}
	}

	function ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeStringMap(
		root,
		key,
		loose,
	) {
		const map = new Map();

		if (!root.has(key)) {
			return map;
		}

		const consumer = root.get(key);

		// Some code uses arrays for this case... Maybe we can normalize them. A `engines` array becomes an object with '*' properties etc
		if (Array.isArray(consumer.asUnknown()) && loose) {
			return map;
		}

		for (const [name, value] of consumer.asMap()) {
			// In loose mode let's be really generous
			if (loose && typeof value.asUnknown() !== "string") {
				continue;
			}

			map.set(name, value.asString());
		}

		return map;
	}

	function ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeBin(
		consumer,
		name,
		loose,
	) {
		const map = new Map();
		if (!consumer.has("bin")) {
			return map;
		}

		// Allow a `bin` string
		const obj = consumer.get("bin");
		if (typeof obj.asUnknown() === "string") {
			if (name === undefined) {
				obj.unexpected(
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.MANIFEST.STRING_BIN_WITHOUT_NAME,
				);
			} else {
				map.set(name, obj.asString());
				return map;
			}
		}

		// Otherwise expect it to be an object
		return ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeStringMap(
			consumer,
			"bin",
			loose,
		);
	}

	function ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$extractLicenseFromObjectConsumer(
		consumer,
	) {
		const prop = consumer.get("type");
		const value = prop.asString();
		return [value, prop];
	}

	// These are all licenses I found that are wrong, we should eventually remove this as we update those deps
	const ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$INVALID_IGNORE_LICENSES = [
		"UNLICENSED",
		"none",
		"Facebook Platform License",
		"BSD",
		"MIT/X11",
		"Public Domain",
		"MIT License",
		"BSD-like",
	];

	function ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeLicense(
		consumer,
		loose,
	) {
		if (!consumer.has("license")) {
			return undefined;
		}

		let licenseProp = consumer.get("license");
		let licenseId;

		// Support some legacy ways of specifying licenses: https://docs.npmjs.com/files/package.json#license
		const raw = licenseProp.asUnknown();
		if (loose && Array.isArray(raw)) {
			const licenseIds = licenseProp.asMappedArray((consumer) =>
				___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$extractLicenseFromObjectConsumer(
					consumer,
				)[0]
			);
			licenseId = "(" + licenseIds.join(" OR ") + ")";
		} else if (loose && typeof raw === "object") {
			[licenseId, licenseProp] = ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$extractLicenseFromObjectConsumer(
				licenseProp,
			);
		} else {
			licenseId = licenseProp.asString();
		}

		// Allow referring to a custom license
		if (licenseId.startsWith("SEE LICENSE IN ")) {
			return undefined;
		}

		// Not valid licenses...
		if (
			___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$INVALID_IGNORE_LICENSES.includes(
				licenseId,
			)
		) {
			return undefined;
		}

		// Parse as a SPDX expression
		return ___R$project$rome$$internal$parser$core$utils_ts$tryParseWithOptionalOffsetPosition(
			{
				loose,
				path: consumer.path,
				input: licenseId,
			},
			{
				getOffsetPosition: () => licenseProp.getLocation("inner-value").start,
				parse: (opts) =>
					___R$project$rome$$internal$codec$spdx$license$parse_ts$default(opts)
				,
			},
		);
	}

	function ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeVersion(
		consumer,
		loose,
	) {
		if (!consumer.has("version")) {
			return undefined;
		}

		const prop = consumer.get("version");
		const rawVersion = prop.asString();

		// Used in some package.json templates
		if (rawVersion === "VERSION_STRING") {
			return undefined;
		}

		const ast = ___R$project$rome$$internal$parser$core$utils_ts$tryParseWithOptionalOffsetPosition(
			{
				path: consumer.path,
				input: rawVersion,
				// Some node_modules have bogus versions, like being prefixed with a v like:
				// https://github.com/itinance/react-native-fs/commit/6232d4e392d5b52cca0792fdfe5903b7fb6b1c5c#diff-b9cfc7f2cdf78a7f4b91a753d10865a2R3
				loose,
			},
			{
				getOffsetPosition: () => prop.getLocation("inner-value").start,
				parse: (opts) =>
					___R$project$rome$$internal$codec$semver$parse_ts$parseSemverVersion(
						opts,
					)
				,
			},
		);
		return ast;
	}

	function ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizePerson(
		consumer,
		loose,
	) {
		if (typeof consumer.asUnknown() === "string") {
			// Parse the string. Format: name (url) <email>
			const str = consumer.asString();

			const nameMatch = str.match(/^([^(<]+)/);
			let name;
			if (nameMatch) {
				name = nameMatch[0].trim();
			}

			const person = {
				name,
				url: undefined,
				email: undefined,
				twitter: undefined,
				github: undefined,
			};

			const emailMatch = str.match(/<([^>]+)>/);
			if (emailMatch) {
				person.email = emailMatch[1];
			}

			const urlMatch = str.match(/\(([^)]+)\)/);
			if (urlMatch) {
				person.url = urlMatch[1];
			}

			return person;
		} else {
			// Validate as an object
			let url = consumer.get("url").asStringOrVoid();

			// Some packages use "web" or "website" instead of "url"
			if (loose) {
				if (url === undefined) {
					url = consumer.get("web").asStringOrVoid();
				}

				if (url === undefined) {
					url = consumer.get("website").asStringOrVoid();
				}
			}

			let github = consumer.get("github").asStringOrVoid();

			if (loose && github === undefined) {
				// Some rando packages use this
				github =
					consumer.get("githubUsername").asStringOrVoid() ||
					consumer.get("github-username").asStringOrVoid();
			}

			const person = {
				name: consumer.get("name").asString(loose ? "" : undefined),
				email: consumer.get("email").asStringOrVoid(),
				twitter: consumer.get("twitter").asStringOrVoid(),
				github,
				url,
			};
			if (!loose) {
				consumer.enforceUsedProperties();
			}
			return person;
		}
	}

	function ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizePeople(
		consumer,
		loose,
	) {
		if (!consumer.exists()) {
			return;
		}

		// Some packages have a single maintainer object instead of an array
		if (loose && consumer.isObject()) {
			return [
				___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizePerson(
					consumer,
					loose,
				),
			];
		}

		// If it's not an array then just leave it. Some people put a URL here.
		if (loose && !Array.isArray(consumer.asUnknown())) {
			return;
		}

		const people = [];

		for (const item of consumer.asIterable()) {
			people.push(
				___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizePerson(
					item,
					loose,
				),
			);
		}

		return people;
	}

	function ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeRepo(
		consumer,
		loose,
	) {
		if (!consumer.exists()) {
			return;
		}

		if (typeof consumer.asUnknown() === "string") {
			let url = consumer.asString();

			// If this is a hosted git shorthand then explode it
			const parsed = ___R$project$rome$$internal$codec$js$manifest$dependencies_ts$parseGitDependencyPattern(
				consumer,
			);
			if ((parsed == null ? undefined : parsed.type) === "hosted-git") {
				url = parsed.url;
			}

			return {
				type: "git",
				url,
				directory: undefined,
			};
		} else {
			let url;
			let type;

			if (loose) {
				// A lot of packages omit the "type"
				type = consumer.get("type").asString("git");

				// thanks i hate it
				consumer.markUsedProperty("web");
				consumer.markUsedProperty("git");
				consumer.markUsedProperty("dist");

				// Some gross packages use "repository" instead of "url"
				let looseUrl = consumer.get("url").asStringOrVoid();

				if (looseUrl === undefined) {
					looseUrl = consumer.get("repository").asStringOrVoid();
				}

				if (looseUrl === undefined) {
					consumer.unexpected(
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.MANIFEST.MISSING_REPO_URL,
					);
					url = "";
				} else {
					url = looseUrl;
				}
			} else {
				url = consumer.get("url").asString();
				type = consumer.get("type").asString();
			}

			const repo = {
				type,
				url,
				directory: consumer.get("directory").asStringOrVoid(),
			};
			if (!loose) {
				consumer.enforceUsedProperties();
			}
			return repo;
		}
	}

	function ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeExports(
		consumer,
	) {
		const unknown = consumer.asUnknown();

		// "exports": false
		if (typeof unknown === "boolean") {
			return consumer.asBoolean();
		}

		if (!consumer.exists()) {
			return true;
		}

		const exports = new ___R$project$rome$$internal$path$collections_ts$RelativeFilePathMap();

		// "exports": "./index.js"
		if (typeof unknown === "string") {
			exports.set(
				___R$project$rome$$internal$path$index_ts$createRelativeFilePath("."),
				new Map([
					[
						"default",
						___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$createRelativeExportCondition(
							consumer,
						),
					],
				]),
			);
			return exports;
		}

		const dotConditions = new Map();

		for (const [relative, value] of consumer.asMap()) {
			// If it's not a relative path then it's a platform for the root
			if (relative[0] !== ".") {
				if (exports.size > 0) {
					value.unexpected(
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.MANIFEST.MIXED_EXPORTS_PATHS,
					);
				}

				dotConditions.set(
					relative,
					___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$createRelativeExportCondition(
						value,
					),
				);
				continue;
			}

			if (dotConditions.size > 0) {
				value.unexpected(
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.MANIFEST.MIXED_EXPORTS_PATHS,
				);
			}

			const conditions = ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeExportsConditions(
				value,
			);
			exports.set(value.getKey().asExplicitRelativeFilePath(), conditions);
		}

		if (dotConditions.size > 0) {
			exports.set(
				___R$project$rome$$internal$path$index_ts$createRelativeFilePath("."),
				dotConditions,
			);
		}

		return exports;
	}

	function ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$createRelativeExportCondition(
		value,
	) {
		return {
			type: "relative",
			consumer: value,
			relative: value.asExplicitRelativeFilePath(),
		};
	}

	function ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeExportsConditions(
		value,
	) {
		const conditions = new Map();
		const unknown = value.asUnknown();

		if (typeof unknown === "string") {
			conditions.set(
				"default",
				___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$createRelativeExportCondition(
					value,
				),
			);
		} else if (Array.isArray(unknown)) {
			// Find the first item that passes validation
			for (const elem of value.asIterable()) {
				const {consumer, diagnostics} = elem.capture();
				const result = ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeExportsConditions(
					consumer,
				);
				if (diagnostics.length === 0) {
					return result;
				}
			}
		} else {
			for (const [type, prop] of value.asMap()) {
				if (prop.isObject()) {
					const condition = {
						type: "nested",
						consumer: prop,
						conditions: new Map(),
					};

					for (const [name, subprop] of prop.asMap()) {
						condition.conditions.set(
							name,
							___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$createRelativeExportCondition(
								subprop,
							),
						);
					}

					conditions.set(type, condition);
				} else {
					conditions.set(
						type,
						___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$createRelativeExportCondition(
							prop,
						),
					);
				}
			}
		}

		return conditions;
	}

	function ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeBugs(
		consumer,
		loose,
	) {
		if (!consumer.exists()) {
			return;
		}

		if (typeof consumer.asUnknown() === "string") {
			return {
				email: undefined,
				url: consumer.asString(),
			};
		} else {
			let email = consumer.get("email").asStringOrVoid();

			// Some use a `mail` property
			if (loose && email === undefined) {
				email = consumer.get("mail").asStringOrVoid();
			}

			// TODO remove this
			consumer.markUsedProperty("type");

			const bugs = {
				email,
				url: consumer.get("url").asStringOrVoid(),
			};
			if (!loose) {
				consumer.enforceUsedProperties();
			}
			return bugs;
		}
	}

	function ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeRootName(
		consumer,
		loose,
	) {
		if (!consumer.has("name")) {
			return {
				packageName: undefined,
				org: undefined,
			};
		}

		const prop = consumer.get("name");

		return ___R$project$rome$$internal$codec$js$manifest$name_ts$normalizeName({
			name: prop.asString(),
			loose,
			unexpected: ({description, at, start, end}) => {
				prop.unexpected(
					description,
					{
						at,
						loc: start === undefined
							? undefined
							: prop.getLocationRange(start, end, "inner-value"),
					},
				);
			},
		});
	}

	const ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$DEPENDENCIES_KEYS = [
		"",
		"dev",
		"peer",
		"optional",
	];

	const ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$INCORRECT_DEPENDENCIES_SUFFIXES = [
		"depdenencies",
		"dependancies",
		"dependecies",
	];

	function ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$checkDependencyKeyTypo(
		key,
		prop,
	) {
		for (const depPrefixKey of ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$DEPENDENCIES_KEYS) {
			// Ignore if the key is a valid dependency key
			const depKey =
				depPrefixKey === "" ? "dependencies" : depPrefixKey + "Dependencies";
			if (key === depKey) {
				return;
			}

			// Check for casing issues
			const lowerKey = key.toLowerCase();
			if (lowerKey === depKey) {
				prop.unexpected(
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.MANIFEST.INCORRECT_CAMEL_CASING(
						key,
						depKey,
					),
				);
			}

			// Check for common suffix misspellings
			for (const suffix of ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$INCORRECT_DEPENDENCIES_SUFFIXES) {
				if (lowerKey === "" + depPrefixKey + suffix) {
					prop.unexpected(
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.MANIFEST.TYPO(
							key,
							depKey,
						),
					);
				}
			}

			// Check for kebab casing
			if (
				___R$project$rome$$internal$string$utils$toCamelCase_ts$toCamelCase(
					depKey,
				) ===
				lowerKey
			) {
				prop.unexpected(
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.MANIFEST.INCORRECT_CAMEL_CASING(
						key,
						depKey,
					),
				);
			}
		}
	}

	async function ___R$project$rome$$internal$codec$js$manifest$index_ts$normalizeManifest(
		consumer,
	) {
		const loose =
			consumer.path !== undefined &&
			consumer.path.getSegments().includes("node_modules");

		// Check for typos. Ignore them in loose mode.
		if (!loose) {
			for (const [key, prop] of consumer.asMap()) {
				// Check for typos for dependencies
				___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$checkDependencyKeyTypo(
					key,
					prop,
				);

				// Check for other typos
				const correctKey = ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$TYPO_KEYS.get(
					key,
				);
				if (correctKey !== undefined) {
					prop.unexpected(
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.MANIFEST.TYPO(
							key,
							correctKey,
						),
					);
				}
			}
		}

		const name = ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeRootName(
			consumer,
			loose,
		);
		const version = ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeVersion(
			consumer,
			loose,
		);

		if (loose) {
			___R$project$rome$$internal$codec$js$manifest$compat_ts$normalizeCompatManifest(
				consumer,
				name,
				version,
			);
		}

		return {
			name,
			version,
			private: ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeBoolean(
				consumer,
				"private",
			) === true,
			description: ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeString(
				consumer,
				"description",
			),
			license: ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeLicense(
				consumer,
				loose,
			),
			type: consumer.get("type").asStringSetOrVoid(["module", "commonjs"]),
			bin: ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeBin(
				consumer,
				name.packageName,
				loose,
			),
			scripts: ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeStringMap(
				consumer,
				"scripts",
				loose,
			),
			homepage: ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeString(
				consumer,
				"homepage",
			),
			repository: ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeRepo(
				consumer.get("repository"),
				loose,
			),
			bugs: ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeBugs(
				consumer.get("bugs"),
				loose,
			),
			engines: ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeStringMap(
				consumer,
				"engines",
				loose,
			),
			files: ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizePathPatterns(
				consumer.get("files"),
				loose,
			),
			keywords: ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeStringArray(
				consumer.get("keywords"),
				loose,
			),
			cpu: ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeStringArray(
				consumer.get("cpu"),
				loose,
			),
			os: ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeStringArray(
				consumer.get("os"),
				loose,
			),
			main: ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeString(
				consumer,
				"main",
			),
			exports: ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeExports(
				consumer.get("exports"),
			),
			// Dependency fields
			dependencies: ___R$project$rome$$internal$codec$js$manifest$dependencies_ts$normalizeDependencies(
				consumer,
				"dependencies",
				loose,
			),
			devDependencies: ___R$project$rome$$internal$codec$js$manifest$dependencies_ts$normalizeDependencies(
				consumer,
				"devDependencies",
				loose,
			),
			optionalDependencies: ___R$project$rome$$internal$codec$js$manifest$dependencies_ts$normalizeDependencies(
				consumer,
				"optionalDependencies",
				loose,
			),
			peerDependencies: ___R$project$rome$$internal$codec$js$manifest$dependencies_ts$normalizeDependencies(
				consumer,
				"peerDependencies",
				loose,
			),
			bundledDependencies: [
				...___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeStringArray(
					consumer.get("bundledDependencies"),
					loose,
				),
				// Common misspelling. We error on the existence of this for strict manifests already.
				...___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizeStringArray(
					consumer.get("bundleDependencies"),
					loose,
				),
			],
			// People fields
			author: consumer.has("author") && !consumer.get("author").isEmpty()
				? ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizePerson(
						consumer.get("author"),
						loose,
					)
				: undefined,
			contributors: ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizePeople(
				consumer.get("contributors"),
				loose,
			),
			maintainers: ___R$$priv$project$rome$$internal$codec$js$manifest$index_ts$normalizePeople(
				consumer.get("maintainers"),
				loose,
			),
			raw: consumer.asJSONObject(),
		};
	}


  // project-rome/@internal/core/server/bundler/utils.ts
function ___R$project$rome$$internal$core$server$bundler$utils_ts$serializeAssembled(
		assembled,
		getCode,
	) {
		return assembled.map((item) => {
			if (item[0] === 0) {
				return item[1];
			} else {
				const path = item[1];
				const compileResult = getCode(path);
				if (compileResult === undefined) {
					throw new Error("Compiled file not found");
				} else {
					return compileResult;
				}
			}
		}).join("\n");
	}


  // project-rome/@internal/core/server/bundler/Bundler.ts
const ___R$$priv$project$rome$$internal$core$server$bundler$Bundler_ts$crypto = require(
		"crypto",
	);
	class ___R$project$rome$$internal$core$server$bundler$Bundler_ts$default {
		constructor(req, config) {
			this.config = config;
			this.server = req.server;
			this.reporter = req.reporter;
			this.request = req;

			this.compiles = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
			this.entries = [];
			this.graph = new ___R$project$rome$$internal$core$server$dependencies$DependencyGraph_ts$default(
				req,
				config.resolver,
			);
		}

		static createFromServerRequest(req) {
			return new ___R$project$rome$$internal$core$server$bundler$Bundler_ts$default(
				req,
				req.getBundlerConfigFromFlags(),
			);
		}

		async getResolvedEntry(unresolvedEntry) {
			const {cwd} = this.config;

			const res = await this.server.resolver.resolveEntryAssert(
				Object.assign(
					{},
					this.config.resolver,
					{
						origin: cwd,
						source: ___R$project$rome$$internal$path$index_ts$createUnknownPath(
							unresolvedEntry,
						),
					},
				),
			);

			const {server} = this;
			const resolvedEntry = res.path;

			// Now do the same resolver request but with a package
			const manifestRootResolved = server.resolver.resolveLocal(
				Object.assign(
					{},
					this.config.resolver,
					{
						origin: cwd,
						requestedType: "package",
						source: ___R$project$rome$$internal$path$index_ts$createUnknownPath(
							unresolvedEntry,
						),
					},
				),
			);
			const manifestRoot =
				manifestRootResolved.type === "FOUND"
					? manifestRootResolved.path
					: undefined;
			let manifestDef;
			if (manifestRoot !== undefined) {
				const def = server.memoryFs.getManifestDefinition(manifestRoot);
				if (def !== undefined) {
					manifestDef = def;
				}
			}

			return {manifestDef, resolvedEntry};
		}

		createBundleRequest(resolvedEntry, options, reporter) {
			this.entries.push(resolvedEntry);
			return new ___R$project$rome$$internal$core$server$bundler$BundleRequest_ts$default({
				request: this.request,
				bundler: this,
				graph: this.graph,
				server: this.server,
				resolvedEntry,
				options,
				reporter,
			});
		}

		serializeAssembled(assembled) {
			return ___R$project$rome$$internal$core$server$bundler$utils_ts$serializeAssembled(
				assembled,
				(path) => {
					const compiled = this.compiles.get(path);
					if (compiled === undefined) {
						return undefined;
					} else {
						return compiled.compiledCode;
					}
				},
			);
		}

		async compileJS(path) {
			const existing = this.compiles.get(path);
			if (existing !== undefined) {
				return existing;
			}

			const {graph} = this;
			const mod = graph.getNode(path);

			// Build a map of relative module sources to module id
			const relativeSourcesToModuleId = {};
			for (const [relative, absolute] of mod.relativeToAbsolutePath) {
				const moduleId = graph.getNode(absolute).uid;
				relativeSourcesToModuleId[relative] = moduleId;
			}

			// Diagnostics would have already been added during the initial DependencyGraph.seed
			// We're doing the work of resolving everything again, maybe we should cache it?
			const resolvedImports = mod.resolveImports().resolved;

			let asset;
			let assetPath;
			if (mod.handler == null ? undefined : mod.handler.isAsset) {
				const buffer = await ___R$project$rome$$internal$fs$index_ts$readFile(
					mod.path,
				);

				// Asset path in the form of: BASENAME-SHA1HASH.EXTENSIONS
				const hash = ___R$$priv$project$rome$$internal$core$server$bundler$Bundler_ts$crypto.createHash(
					"sha1",
				).update(buffer).digest("hex");
				const basename = mod.path.getExtensionlessBasename();
				const exts = mod.path.getExtensions();

				assetPath = basename + "-" + hash + exts;
				asset = {
					path: assetPath,
					buffer,
				};
			}

			const opts = {
				moduleAll: mod.all,
				moduleId: mod.uid,
				relativeSourcesToModuleId,
				resolvedImports,
				assetPath,
			};

			const res = await this.request.requestWorkerCompile(
				path,
				"compileForBundle",
				{
					bundle: opts,
				},
				{},
			);

			const bundleRes = Object.assign({}, res, {asset});
			this.compiles.set(path, bundleRes);
			return bundleRes;
		}

		async compileSingle(path) {
			const bundleRequest = this.createBundleRequest(path, {}, this.reporter);
			await bundleRequest.stepAnalyze();
			bundleRequest.diagnostics.maybeThrowDiagnosticsError();
			return await this.compileJS(path);
		}

		// This will take multiple entry points and do some magic to make them more efficient to build in parallel
		async bundleMultiple(entries, options = {}) {
			// Clone so we can mess with it
			entries = [...entries];

			// Seed the dependency graph with all the entries at the same time
			const processor = this.request.createDiagnosticsProcessor({
				origins: [
					{
						category: "Bundler",
						message: "Analyzing dependencies for bundleMultiple",
					},
				],
			});
			const entryUids = entries.map((entry) =>
				this.server.projectManager.getUid(entry)
			);
			const analyzeProgress = this.reporter.progress({
				name: "bundler:analyze:" + entryUids.join(","),
				title: ___R$project$rome$$internal$markup$escape_ts$markup`Analyzing`,
			});
			processor.setThrowAfter(100);
			await this.graph.seed({
				paths: entries,
				diagnosticsProcessor: processor,
				analyzeProgress,
				validate: false,
			});
			analyzeProgress.end();
			processor.maybeThrowDiagnosticsError();

			// Compile everything at the same time
			const req = this.createBundleRequest(entries[0], {}, this.reporter);
			await req.stepCompile(
				Array.from(this.graph.getNodes(), (node) => node.path),
			);

			// Now actually bundle them
			const map = new Map();

			const progress = this.reporter.progress({
				title: ___R$project$rome$$internal$markup$escape_ts$markup`Bundling`,
			});
			progress.setTotal(entries.length);

			const silentReporter = this.reporter.fork({
				streams: [],
			});

			const promises = new Set();

			// Could maybe do some of this in parallel?
			while (entries.length > 0) {
				const entry = entries.shift();

				const promise = (async () => {
					const progressId = progress.pushText(
						___R$project$rome$$internal$markup$escape_ts$markup`${entry}`,
					);

					map.set(entry, await this.bundle(entry, options, silentReporter));
					progress.popText(progressId);
					progress.tick();
				})();
				promise.then(() => {
					promises.delete(promise);
				});
				promises.add(promise);

				if (promises.size > 5) {
					await Promise.race(Array.from(promises));
				}
			}

			await Promise.all(Array.from(promises));

			progress.end();

			return map;
		}

		async bundleManifest({resolvedEntry, manifestDef}) {
			let bundles = [];
			const files = new Map();

			const createBundle = async (resolvedSegment, options) => {
				const bundle = await this.bundle(resolvedSegment, options);
				for (const [path, content] of bundle.files) {
					files.set(path, content);
				}
				bundles = bundles.concat(bundle.bundles);
				return bundle.entry;
			};

			const entryBundle = await createBundle(resolvedEntry, {});

			//
			const bundleBuddyStats = this.graph.getBundleBuddyStats(this.entries);
			files.set(
				"bundlebuddy.json",
				{
					kind: "stats",
					content: () =>
						___R$project$rome$$internal$codec$json$index_ts$stringifyJSON(
							bundleBuddyStats,
						)
					,
				},
			);

			// TODO ensure that __dirname is relative to the project root
			if (manifestDef !== undefined) {
				const newManifest = await this.deriveManifest(
					manifestDef,
					entryBundle,
					createBundle,
					(relative, buffer) => {
						if (!files.has(relative)) {
							files.set(
								relative,
								{
									kind: "file",
									content: () => buffer,
								},
							);
						}
					},
				);

				// If we have a `files` array then set it to all the newly added files
				// This will have included files already there that we copied
				if (newManifest.files !== undefined) {
					newManifest.files = Array.from(files.keys());
				}

				// Add a package.json with updated values
				files.set(
					"package.json",
					{
						kind: "manifest",
						content: () =>
							___R$project$rome$$internal$codec$json$index_ts$stringifyJSON(
								newManifest,
							)
						,
					},
				);
			}

			return {
				files,
				bundles,
				entry: entryBundle,
			};
		}

		async deriveManifest(manifestDef, entryBundle, createBundle, addFile) {
			// TODO figure out some way to use bundleMultiple here
			const manifest = manifestDef.manifest;

			const newManifest = Object.assign(
				{},
				___R$project$rome$$internal$codec$js$manifest$convert_ts$convertManifestToJSON(
					manifest,
				),
				{main: entryBundle.js.path},
			);

			// TODO inherit some manifest properties from project configs
			const project = this.server.projectManager.findLoadedProject(
				manifestDef.directory,
			);
			if (project !== undefined) {
				if (newManifest.name === undefined) {
					newManifest.name = project.config.name;
				}
			}

			// TODO remove dependencies fields, probably?

			// TODO Compile a index.d.ts

			// Copy manifest.files
			if (manifest.files !== undefined) {
				const paths = this.server.memoryFs.glob(
					manifestDef.directory,
					{
						overrideIgnore: ___R$project$rome$$internal$path$match$index_ts$flipPathPatterns(
							manifest.files,
						),
					},
				);

				for (const path of paths) {
					const relative = manifestDef.directory.relative(path).join();
					const buffer = await ___R$project$rome$$internal$fs$index_ts$readFile(
						path,
					);
					addFile(relative, buffer);
				}
			}

			// Compile manifest.bin files
			const bin = manifest.bin;
			if (bin !== undefined) {
				const newBin = {};
				newManifest.bin = newBin;

				const binConsumer = manifestDef.consumer.get("bin");
				const isBinShorthand = typeof binConsumer.asUnknown() === "string";

				for (const [binName, relative] of manifest.bin) {
					const location = (isBinShorthand
						? binConsumer
						: binConsumer.get(binName)).getDiagnosticLocation("inner-value");

					const absolute = await this.server.resolver.resolveAssert(
						Object.assign(
							{},
							this.config.resolver,
							{
								origin: manifestDef.directory,
								source: ___R$project$rome$$internal$path$index_ts$createUnknownPath(
									relative,
								).toExplicitRelative(),
							},
						),
						{
							location,
						},
					);

					const res = await createBundle(
						absolute.path,
						{
							prefix: "bin/" + binName,
							interpreter: "/usr/bin/env node",
						},
					);
					newBin[binName] = res.js.path;
				}
			}

			// TODO `{type: "module"}` will always fail since we've produced CJS bundles
			// rome-ignore lint/js/noDelete: future cleanup
			delete newManifest.type;

			// Remove rome project config
			// rome-ignore lint/js/noDelete: future cleanup
			delete newManifest.rome;

			return newManifest;
		}

		async bundle(resolvedEntry, options = {}, reporter = this.reporter) {
			//reporter.info(markup`Bundling <emphasis>${resolvedEntry}</emphasis>`);
			const req = this.createBundleRequest(resolvedEntry, options, reporter);
			const res = await req.bundle();

			const processor = this.request.createDiagnosticsProcessor();
			processor.addDiagnostics(res.diagnostics);
			processor.maybeThrowDiagnosticsError();

			if (res.cached) {
				reporter.warn(
					___R$project$rome$$internal$markup$escape_ts$markup`Bundle was built completely from cache`,
				);
			}

			const prefix = options.prefix === undefined ? "" : options.prefix + "/";
			const jsPath = prefix + "index.js";
			const mapPath = jsPath + ".map";

			let serialized;
			const serializeAssembled = () => {
				if (serialized === undefined) {
					serialized = this.serializeAssembled(res.assembled);
				}
				return serialized;
			};

			const files = new Map();
			files.set(
				jsPath,
				{
					kind: "entry",
					content: serializeAssembled,
				},
			);

			files.set(
				mapPath,
				{
					kind: "sourcemap",
					content: () => res.sourceMap.toJSON(),
				},
			);

			for (const [relative, buffer] of res.assets) {
				files.set(
					relative,
					{
						kind: "asset",
						content: () => buffer,
					},
				);
			}

			const bundle = {
				js: {
					path: jsPath,
					assembled: res.assembled,
					content: serializeAssembled,
				},
				sourceMap: {
					path: mapPath,
					map: res.sourceMap,
				},
			};
			return {
				bundler: this,
				entry: bundle,
				bundles: [bundle],
				files,
			};
		}
	}


  // project-rome/@internal/core/server/commands/run.ts
const ___R$project$rome$$internal$core$server$commands$run_ts$default = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.PROJECT_MANAGEMENT,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`TODO`,
		usage: "",
		examples: [],
		hidden: true,
		defineFlags() {
			return {};
		},
		async callback(req) {
			const {flags} = req.client;
			const {server} = req;
			req.expectArgumentLength(1, Infinity);
			const [arg, ...args] = req.query.args;

			async function executeCode(path) {
				const bundler = ___R$project$rome$$internal$core$server$bundler$Bundler_ts$default.createFromServerRequest(
					req,
				);
				const {entry} = await bundler.bundle(path);
				return {
					type: "executeCode",
					args,
					filename: path.join(),
					code: entry.js.content(),
					map: entry.sourceMap.map.serialize(),
				};
			}

			// Get the current project
			const project = await server.projectManager.findProject(flags.cwd);

			// Check for bin files in any manifests that belong to any projects
			if (project !== undefined) {
				for (const {manifest, directory} of project.packages.values()) {
					const relative = manifest.bin.get(arg);
					if (relative === undefined) {
						continue;
					}

					const resolved = await server.resolver.resolveEntryAssertPath(
						Object.assign(
							{},
							req.getResolverOptionsFromFlags(),
							{
								origin: directory,
								platform: "node",
								source: ___R$project$rome$$internal$path$index_ts$createRelativeFilePath(
									relative,
								),
							},
						),
					);

					return executeCode(resolved);
				}
			}

			// TODO check node_modules/.bin

			// TODO check package.json scripts

			// Resolve path otherwise
			const target = await req.resolveEntryAssertPathArg(0, false);
			return executeCode(target);
		},
	});


  // project-rome/@internal/core/server/commands/publish.ts
const ___R$project$rome$$internal$core$server$commands$publish_ts$default = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.PROJECT_MANAGEMENT,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`TODO`,
		usage: "",
		examples: [],
		hidden: true,
		defineFlags() {
			return {};
		},
		async callback(req) {
			req.expectArgumentLength(1);

			// TODO
		},
	});


  // project-rome/@internal/core/server/commands/status.ts
const ___R$project$rome$$internal$core$server$commands$status_ts$default = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.PROCESS_MANAGEMENT,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`dump memory and process info of server and workers`,
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback({server}) {
			const workers = await Promise.all(
				server.workerManager.getWorkers().map(async (worker) => {
					const workerStatus = await worker.bridge.status.call();

					return {
						astCacheSize: workerStatus.astCacheSize,
						heapTotal: workerStatus.memoryUsage.heapTotal,
						pid: workerStatus.pid,
						uptime: workerStatus.uptime,
						ownedBytes: worker.byteCount,
						ownedFileCount: worker.fileCount,
					};
				}),
			);

			const {heapTotal} = process.memoryUsage();
			return {
				server: {
					heapTotal,
					pid: process.pid,
					uptime: process.uptime(),
				},
				workers,
				projects: server.projectManager.getProjects().map((project) => {
					return {
						id: project.id,
					};
				}),
			};
		},
	});


  // project-rome/@internal/core/server/commands/stop.ts
const ___R$project$rome$$internal$core$server$commands$stop_ts$default = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.PROCESS_MANAGEMENT,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`stop daemon`,
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback({server}) {
			await server.end();
		},
	});


  // project-rome/@internal/codec-websocket/types.ts
const ___R$project$rome$$internal$codec$websocket$types_ts$OPCODES = {
		CONTINUATION: 0,
		TEXT: 1,
		BINARY: 2,
		TERMINATE: 8,
		PING: 9,
		PONG: 10,
	};

	const ___R$project$rome$$internal$codec$websocket$types_ts$GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";


  // project-rome/@internal/codec-websocket/frame.ts
const ___R$$priv$project$rome$$internal$codec$websocket$frame_ts$crypto = require(
		"crypto",
	);
	function ___R$project$rome$$internal$codec$websocket$frame_ts$isCompleteFrame(
		frame,
	) {
		return Buffer.byteLength(frame.payload) >= frame.payloadLength;
	}

	function ___R$project$rome$$internal$codec$websocket$frame_ts$unmaskPayload(
		payload,
		mask,
		offset,
	) {
		if (mask === undefined) {
			return payload;
		}

		for (let i = 0; i < payload.length; i++) {
			payload[i] ^= mask[offset + i & 3];
		}

		return payload;
	}

	function ___R$project$rome$$internal$codec$websocket$frame_ts$buildFrame(
		opts,
		shouldMask,
	) {
		const {opcode, fin, data} = opts;

		let offset = shouldMask ? 6 : 2;
		let dataLength = data.length;

		if (dataLength >= 65_536) {
			offset += 8;
			dataLength = 127;
		} else if (dataLength > 125) {
			offset += 2;
			dataLength = 126;
		}

		const head = Buffer.allocUnsafe(offset);

		head[0] = fin ? opcode | 128 : opcode;
		head[1] = dataLength;

		if (dataLength === 126) {
			head.writeUInt16BE(data.length, 2);
		} else if (dataLength === 127) {
			head.writeUInt32BE(0, 2);
			head.writeUInt32BE(data.length, 6);
		}

		if (shouldMask) {
			const mask = ___R$$priv$project$rome$$internal$codec$websocket$frame_ts$crypto.randomBytes(
				4,
			);
			head[1] |= 128;
			head[offset - 4] = mask[0];
			head[offset - 3] = mask[1];
			head[offset - 2] = mask[2];
			head[offset - 1] = mask[3];

			const masked = Buffer.alloc(dataLength);
			for (let i = 0; i < dataLength; ++i) {
				masked[i] = data[i] ^ mask[i & 3];
			}

			return Buffer.concat([head, masked]);
		} else {
			return Buffer.concat([head, data]);
		}
	}

	function ___R$project$rome$$internal$codec$websocket$frame_ts$parseFrame(
		buffer,
	) {
		const firstByte = buffer.readUInt8(0);
		const isFinalFrame = Boolean(firstByte >>> 7 & 1);
		const opcode = firstByte & 15;

		const [reserved1, reserved2, reserved3] = [
			(firstByte >>> 6 & 1) === 1,
			(firstByte >>> 5 & 1) === 1,
			(firstByte >>> 4 & 1) === 1,
		];
		reserved1;
		reserved2;
		reserved3;

		const secondByte = buffer.readUInt8(1);
		const isMasked = Boolean(secondByte >>> 7 & 1);

		// Keep track of our current position as we advance through the buffer
		let currentOffset = 2;
		let payloadLength = secondByte & 127;
		if (payloadLength > 125) {
			if (payloadLength === 126) {
				payloadLength = buffer.readUInt16BE(currentOffset);
				currentOffset += 2;
			} else if (payloadLength === 127) {
				const leftPart = buffer.readUInt32BE(currentOffset);
				currentOffset += 4;

				// The maximum safe integer in JavaScript is 2^53 - 1. An error is returned

				// if payload length is greater than this number.
				if (leftPart >= Number.MAX_SAFE_INTEGER) {
					throw new Error(
						"Unsupported WebSocket frame: payload length > 2^53 - 1",
					);
				}

				const rightPart = buffer.readUInt32BE(currentOffset);
				currentOffset += 4;

				payloadLength = leftPart * Math.pow(2, 32) + rightPart;
			} else {
				throw new Error("Unknown payload length");
			}
		}

		// Get the masking key if one exists
		let mask;
		if (isMasked) {
			mask = buffer.slice(currentOffset, currentOffset + 4);
			currentOffset += 4;
		}

		let payload = ___R$project$rome$$internal$codec$websocket$frame_ts$unmaskPayload(
			buffer.slice(currentOffset),
			mask,
			0,
		);

		return {
			fin: isFinalFrame,
			opcode,
			mask,
			payload,
			payloadLength,
		};
	}


  // project-rome/@internal/codec-websocket/index.ts
const ___R$$priv$project$rome$$internal$codec$websocket$index_ts$crypto = require(
		"crypto",
	);
	const ___R$$priv$project$rome$$internal$codec$websocket$index_ts$url = require(
		"url",
	);
	const ___R$$priv$project$rome$$internal$codec$websocket$index_ts$http = require(
		"http",
	);
	const ___R$$priv$project$rome$$internal$codec$websocket$index_ts$net = require(
		"net",
	);
	function ___R$project$rome$$internal$codec$websocket$index_ts$createKey(key) {
		return ___R$$priv$project$rome$$internal$codec$websocket$index_ts$crypto.createHash(
			"sha1",
		).update(
			"" + key + ___R$project$rome$$internal$codec$websocket$types_ts$GUID,
		).digest("base64");
	}

	class ___R$project$rome$$internal$codec$websocket$index_ts$WebSocketInterface {
		constructor({type, socket, reporter}) {
			// When a frame is set here then any additional continuation frames payloads will be appended
			this.unfinishedFrame = undefined;

			// When a frame is set here, all additional chunks will be appended until we reach the correct payloadLength
			this.incompleteFrame = undefined;

			this.reporter = reporter;
			this.socket = socket;
			this.alive = true;
			this.type = type;

			this.completeFrameEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "WebSocketInterface.message",
			});
			this.errorEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "WebSocketInterface.error",
			});
			this.endEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "WebSocketInterface.end",
				serial: true,
			});

			socket.on(
				"data",
				(buff) => {
					this.addBuffer(buff);
				},
			);

			socket.on(
				"error",
				(err) => {
					if (err.code === "ECONNRESET") {
						this.endEvent.send();
					} else {
						this.errorEvent.send(err);
					}
				},
			);

			socket.on(
				"close",
				() => {
					this.end();
				},
			);
		}

		end() {
			if (!this.alive) {
				return;
			}

			this.alive = false;
			this.endEvent.send();
			this.socket.end();
		}

		send(buff) {
			if (typeof buff === "string") {
				this.sendFrame({
					opcode: ___R$project$rome$$internal$codec$websocket$types_ts$OPCODES.TEXT,
					fin: true,
					data: Buffer.from(buff),
				});
			} else if (buff instanceof Buffer) {
				this.sendFrame({
					opcode: ___R$project$rome$$internal$codec$websocket$types_ts$OPCODES.BINARY,
					fin: true,
					data: buff,
				});
			} else {
				throw new Error("Don't know how to send this");
			}
		}

		sendJSON(val) {
			this.send(String(JSON.stringify(val)));
		}

		sendFrame(frameOpts) {
			if (this.reporter !== undefined) {
				this.reporter.info(
					___R$project$rome$$internal$markup$escape_ts$markup`Sending frame ${() =>
						___R$project$rome$$internal$pretty$format$index_ts$default({
							fin: frameOpts.fin,
							opcode: frameOpts.opcode,
							msg: frameOpts.data.toString(),
						})
					}`,
				);
			}
			this.socket.write(
				Buffer.from(
					___R$project$rome$$internal$codec$websocket$frame_ts$buildFrame(
						frameOpts,
						this.type === "client",
					),
				),
			);
		}

		completeFrame(frame) {
			// If we have an unfinished frame then only allow continuations
			const {unfinishedFrame} = this;
			if (unfinishedFrame !== undefined) {
				if (
					frame.opcode ===
					___R$project$rome$$internal$codec$websocket$types_ts$OPCODES.CONTINUATION
				) {
					unfinishedFrame.payload = Buffer.concat([
						unfinishedFrame.payload,
						___R$project$rome$$internal$codec$websocket$frame_ts$unmaskPayload(
							frame.payload,
							unfinishedFrame.mask,
							unfinishedFrame.payload.length,
						),
					]);

					if (frame.fin) {
						this.unfinishedFrame = undefined;
						this.completeFrame(unfinishedFrame);
					}
					return;
				} else {
					// Silently ignore the previous frame...
					this.unfinishedFrame = undefined;
					/*throw new Error(
          `We're waiting for a frame to finish so only allow continuation frames. Received frame: ${JSON.stringify(
            frame,
          )} Unfinished frame: ${JSON.stringify(unfinishedFrame)}`,
        );*/
				}
			}

			if (frame.fin) {
				if (
					frame.opcode ===
					___R$project$rome$$internal$codec$websocket$types_ts$OPCODES.PING
				) {
					this.sendFrame({
						opcode: ___R$project$rome$$internal$codec$websocket$types_ts$OPCODES.PONG,
						fin: true,
						data: frame.payload,
					});
				} else {
					// Trim off any excess payload
					let excess;
					if (frame.payload.byteLength > frame.payloadLength) {
						excess = frame.payload.slice(frame.payloadLength);
						frame.payload = frame.payload.slice(0, frame.payloadLength);
					}

					if (this.reporter !== undefined) {
						this.reporter.info(
							___R$project$rome$$internal$markup$escape_ts$markup`Received complete frame ${() =>
								___R$project$rome$$internal$pretty$format$index_ts$default({
									opcode: frame.opcode,
									length: frame.payloadLength,
									msg: frame.payload.toString(),
								})
							}`,
						);
					}

					this.completeFrameEvent.send(frame);

					if (excess !== undefined) {
						this.addBuffer(excess);
					}
				}
			} else {
				this.unfinishedFrame = frame;
			}
		}

		addBufferToIncompleteFrame(incompleteFrame, buff) {
			incompleteFrame.payload = Buffer.concat([
				incompleteFrame.payload,
				___R$project$rome$$internal$codec$websocket$frame_ts$unmaskPayload(
					buff,
					incompleteFrame.mask,
					incompleteFrame.payload.length,
				),
			]);

			if (
				___R$project$rome$$internal$codec$websocket$frame_ts$isCompleteFrame(
					incompleteFrame,
				)
			) {
				this.incompleteFrame = undefined;
				this.completeFrame(incompleteFrame);
			}
		}

		addBuffer(buff) {
			// Check if we're still waiting for the rest of a payload
			const {incompleteFrame} = this;
			if (incompleteFrame !== undefined) {
				this.addBufferToIncompleteFrame(incompleteFrame, buff);
				return;
			}

			const frame = ___R$project$rome$$internal$codec$websocket$frame_ts$parseFrame(
				buff,
			);

			if (
				___R$project$rome$$internal$codec$websocket$frame_ts$isCompleteFrame(
					frame,
				)
			) {
				// Frame has been completed!
				this.completeFrame(frame);
			} else {
				this.incompleteFrame = frame;
			}
		}
	}

	async function ___R$project$rome$$internal$codec$websocket$index_ts$createClient(
		rawUrl,
		reporter,
	) {
		const parts = ___R$$priv$project$rome$$internal$codec$websocket$index_ts$url.parse(
			rawUrl,
		);

		return new Promise((resolve, reject) => {
			const key = ___R$$priv$project$rome$$internal$codec$websocket$index_ts$crypto.randomBytes(
				16,
			).toString("base64");
			const digest = ___R$project$rome$$internal$codec$websocket$index_ts$createKey(
				key,
			);

			const req = ___R$$priv$project$rome$$internal$codec$websocket$index_ts$http.request({
				hostname: parts.hostname,
				port: parts.port,
				path: parts.path,
				method: "GET",
				headers: {
					Connection: "Upgrade",
					Upgrade: "websocket",
					"Sec-WebSocket-Key": key,
					"Sec-WebSocket-Version": "13",
				},
			});

			req.on(
				"upgrade",
				(res, socket, head) => {
					if (res.headers["sec-websocket-accept"] !== digest) {
						socket.end();
						reject(
							new Error(
								"Digest mismatch " +
								digest +
								" !== " +
								res.headers["sec-websocket-accept"],
							),
						);
						return;
					}

					const client = new ___R$project$rome$$internal$codec$websocket$index_ts$WebSocketInterface({
						type: "client",
						socket,
						reporter,
					});
					//client.addBuffer(head);
					head;
					resolve(client);
				},
			);

			req.on(
				"error",
				(err) => {
					reject(err);
				},
			);

			req.end();
		});
	}


  // project-rome/@internal/codec-url/index.ts
const ___R$$priv$project$rome$$internal$codec$url$index_ts$url = require("url");
	function ___R$project$rome$$internal$codec$url$index_ts$consumeUrl(rawUrl) {
		const parts = ___R$$priv$project$rome$$internal$codec$url$index_ts$url.parse(
			rawUrl,
			true,
		);

		const query = ___R$project$rome$$internal$consume$index_ts$consumeUnknown(
			Object.assign({}, parts.query),
			"parse/url/query",
		);

		const path = ___R$project$rome$$internal$consume$index_ts$consume({
			value: parts.pathname,
			context: {
				category: "parse/url",
				getDiagnosticLocation() {
					return {
						language: "url",
						mtime: undefined,
						sourceText: rawUrl,
						filename: "url",
						start: {
							index: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
							line: ___R$project$rome$$internal$ob1$index_ts$ob1Number1,
							column: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
						},
						end: {
							index: ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(
								rawUrl.length - 1,
							),
							line: ___R$project$rome$$internal$ob1$index_ts$ob1Number1,
							column: ___R$project$rome$$internal$ob1$index_ts$ob1Coerce0(
								rawUrl.length - 1,
							),
						},
					};
				},
			},
		});

		return {query, path};
	}


  // project-rome/@internal/core/server/web/WebRequest.ts
const ___R$$priv$project$rome$$internal$core$server$web$WebRequest_ts$http = require(
		"http",
	);
	const ___R$$priv$project$rome$$internal$core$server$web$WebRequest_ts$waitForever = new Promise(() => {});

	function ___R$project$rome$$internal$core$server$web$WebRequest_ts$stripBundleSuffix(
		pathname,
	) {
		return ___R$project$rome$$internal$string$utils$removePrefix_ts$removePrefix(
			___R$project$rome$$internal$string$utils$removeSuffix_ts$removeSuffix(
				pathname,
				".bundle",
			),
			"/",
		);
	}

	class ___R$project$rome$$internal$core$server$web$WebRequest_ts$default {
		constructor({req, res, server, serverRequest, webServer}) {
			this.req = req;
			this.res = res;
			this.webServer = webServer;
			this.reporter = new ___R$project$rome$$internal$cli$reporter$Reporter_ts$default();
			this.reporterStream = this.reporter.attachCaptureStream("markup");
			this.server = server;
			this.serverRequest = serverRequest;

			const reqUrl = req.url;
			if (reqUrl === undefined) {
				throw new Error("req.url should not be undefined");
			}
			this.url = ___R$project$rome$$internal$codec$url$index_ts$consumeUrl(
				reqUrl,
			);
		}

		loadRawBody() {
			const {req} = this;

			req.setEncoding("utf8");
			let rawBody = "";

			return new Promise((resolve) => {
				req.on(
					"data",
					(chunk) => {
						rawBody += chunk;
					},
				);

				req.on(
					"end",
					() => {
						resolve(rawBody);
					},
				);
			});
		}

		async dispatch() {
			const {req, res} = this;

			try {
				const rawBody = await this.loadRawBody();
				await this.dispatchWithBody(rawBody);
				res.end();
			} catch (err) {
				res.writeHead(500, {"Content-Type": "text/plain"});

				let diagnostics = ___R$project$rome$$internal$diagnostics$errors_ts$getDiagnosticsFromError(
					err,
				);
				if (diagnostics === undefined) {
					diagnostics = [
						___R$project$rome$$internal$diagnostics$derive_ts$deriveDiagnosticFromError(
							err,
							{
								description: {
									category: "internalError/httpServer",
								},
							},
						),
					];
				}

				try {
					const printer = this.serverRequest.createDiagnosticsPrinter(
						this.server.createDiagnosticsProcessor({
							origins: [
								{
									category: "WebRequest",
								},
							],
						}),
					);
					printer.processor.addDiagnostics(diagnostics);
					await printer.print();
				} catch (err) {
					this.reporter.warn(
						___R$project$rome$$internal$markup$escape_ts$markup`Failed trying to print diagnostics`,
					);
					this.reporter.error(err.stack);
				}

				res.end("Diagnostics available, see console");
			} finally {
				// Format status code
				// https://en.wikipedia.org/wiki/List_of_HTTP_status_codes
				const statusCode = res.statusCode;
				let status = ___R$project$rome$$internal$markup$escape_ts$markup`${statusCode}`;
				if (statusCode >= 100 && statusCode <= 199) {
					// 1xx informational response – the request was received, continuing process
					status = ___R$project$rome$$internal$markup$escape_ts$markup`<info>${status}</info>`;
				} else if (statusCode >= 200 && statusCode <= 299) {
					// 2xx successful – the request was successfully received, understood, and accepted
					status = ___R$project$rome$$internal$markup$escape_ts$markup`<success>${status}</success>`;
				} else if (statusCode >= 300 && statusCode <= 399) {
					// 3xx redirection – further action needs to be taken in order to complete the request
					status = ___R$project$rome$$internal$markup$escape_ts$markup`<info>${status}</info>`;
				} else if (statusCode >= 400 && statusCode <= 499) {
					// 4xx client error – the request contains bad syntax or cannot be fulfilled
					status = ___R$project$rome$$internal$markup$escape_ts$markup`<error>${status}</error>`;
				} else if (statusCode >= 500 && statusCode <= 599) {
					// 5xx server error – the server failed to fulfil an apparently valid request
					status = ___R$project$rome$$internal$markup$escape_ts$markup`<error>${status}</error>`;
				}

				// Log <METHOD> <URL> <STATUS>
				this.webServer.reporter.log(
					this.reporterStream.readAsMarkup(),
					{noNewline: true},
				);
				this.reporter.log(
					___R$project$rome$$internal$markup$escape_ts$markup`<dim>${req.method}</dim> ${req.url} ${status}`,
				);
			}
		}

		async dispatchWithBody(body) {
			const {res} = this;
			const pathname = this.url.path.asString();
			body;

			switch (pathname) {
				case "/favicon.ico": {
					res.end("");
					break;
				}

				case "/__rome__/websocket":
					return this.handleFrontendWebsocket();

				case "/__rome__/script.js":
					return this.handleFrontendScript();

				case "/__rome__": {
					res.writeHead(200, {"Content-Type": "text/html"});
					res.end(
						___R$project$rome$$internal$string$utils$dedent_ts$dedent`
            <!doctype html>
            <html>
              <head>
                <meta charset="utf-8">
                <title>Rome</title>
                <link rel="stylesheet" href="https://meyerweb.com/eric/tools/css/reset/reset.css">
              </head>
              <body>
                <div id="app"></div>
                <script src="/__rome__/script.js"></script>
              </body>
            </html>
          `,
					);
					break;
				}

				default:
					return this.handleWildcard(pathname);
			}
		}

		async handleWildcard(pathname) {
			const {req, res} = this;

			// Check for *.bundle
			if (pathname.endsWith(".bundle")) {
				const handled = await this.handleBundleRequest();
				if (handled) {
					return;
				}
			}

			// Look up static file
			const project = await this.serverRequest.assertClientCwdProject();
			if (project.config.develop.serveStatic) {
				const handled = await this.handlePossibleStatic(pathname, project);
				if (handled) {
					return;
				}
			}

			this.reporter.error(
				___R$project$rome$$internal$markup$escape_ts$markup`Unknown request for ${String(
					req.url,
				)}`,
			);
			res.writeHead(404);
			res.end("Not found");
		}

		async handlePossibleStatic(pathname, project) {
			project;

			const possibleStaticPath = await this.webServer.pathnameToAbsolutePath(
				pathname,
			);

			// TODO check if it is a file
			if (
				possibleStaticPath !== undefined &&
				(await this.server.memoryFs.existsHard(possibleStaticPath))
			) {
				return true;
			}

			return false;
		}

		async handleFrontendScript() {
			const {res} = this;
			res.writeHead(200, {"Content-Type": "application/javascript"});

			const bundler = new ___R$project$rome$$internal$core$server$bundler$Bundler_ts$default(
				this.serverRequest,
				{
					inlineSourceMap: false,
					cwd: this.serverRequest.client.flags.cwd,
					resolver: {
						platform: "web",
					},
				},
			);
			const resolved = await this.server.resolver.resolveEntryAssertPath({
				origin: this.serverRequest.client.flags.cwd,
				source: ___R$project$rome$$internal$path$index_ts$createUnknownPath(
					"@internal/web-ui",
				),
			});
			const bundle = await bundler.bundle(resolved);
			res.end(bundle.entry.js.content);
		}

		negotiateWebsocket() {
			const {req} = this;

			const digest = ___R$project$rome$$internal$codec$websocket$index_ts$createKey(
				String(req.headers["sec-websocket-key"]),
			);

			const headers = [
				"HTTP/1.1 101 Switching Protocols",
				"Upgrade: websocket",
				"Connection: Upgrade",
				"Sec-WebSocket-Protocol: rome",
				"Sec-WebSocket-Accept: " + digest,
				"",
				"",
			];

			req.socket.write(headers.join("\r\n"));
		}

		async handleFrontendWebsocket() {
			const {req} = this;
			this.negotiateWebsocket();

			const socket = new ___R$project$rome$$internal$codec$websocket$index_ts$WebSocketInterface({
				type: "server",
				socket: req.socket,
			});
			const bridge = ___R$project$rome$$internal$events$bridgeCreators_ts$createBridgeFromWebSocketInterface(
				___R$project$rome$$internal$core$common$bridges$WebBridge_ts$default,
				socket,
				{
					type: "client",
				},
			);
			this.webServer.onWebsocketBridge(req, bridge);

			await bridge.handshake();

			this.reporter.success(
				___R$project$rome$$internal$markup$escape_ts$markup`websocket client connected`,
			);

			this.webServer.sendRequests(bridge);

			await ___R$$priv$project$rome$$internal$core$server$web$WebRequest_ts$waitForever;
		}

		async handleBundleRequest() {
			const {res} = this;

			const {bundler, path} = await this.webServer.getBundler(this.url);
			const bundle = await bundler.bundle(path);
			const content = bundle.entry.js.content;

			res.writeHead(200, {"Content-Type": "application/javascript"});
			res.end(content);
			return true;
		}
	}


  // project-rome/@internal/core/server/web/index.ts
const ___R$$priv$project$rome$$internal$core$server$web$index_ts$http = require(
		"http",
	);
	class ___R$project$rome$$internal$core$server$web$index_ts$WebServer {
		constructor(req) {
			const {server} = req;

			this.serverRequest = req;
			this.reporter = req.reporter;
			this.server = server;

			this.bundlerCache = new Map();

			this.savingRequests = false;
			this.clientRequestHistory = new Map();
			this.clientHistory = new Map();

			this.websocketBridges = new Set();

			this.httpServer = ___R$$priv$project$rome$$internal$core$server$web$index_ts$http.createServer((
				req,
				res,
			) => {
				const webRequest = new ___R$project$rome$$internal$core$server$web$WebRequest_ts$default({
					req,
					res,
					server: this.server,
					serverRequest: this.serverRequest,
					webServer: this,
				});
				server.wrapFatalPromise(webRequest.dispatch());
			});

			server.clientStartEvent.subscribe((client) => {
				if (!this.savingRequests) {
					return;
				}

				const data = {
					id: client.id,
					flags: client.flags,
					startTime: Date.now(),
					endTime: undefined,
					stdoutAnsi: "",
					stdoutHTML: "",
				};
				this.clientHistory.set(client.id, data);
				this.refreshRequests();

				const ansiReporterStream = client.reporter.addStream({
					format: "ansi",
					features: ___R$project$rome$$internal$cli$environment$index_ts$DEFAULT_TERMINAL_FEATURES,
					write(chunk) {
						data.stdoutAnsi += chunk;
					},
				});

				const htmlReporterStream = client.reporter.addStream({
					format: "html",
					features: ___R$project$rome$$internal$cli$environment$index_ts$DEFAULT_TERMINAL_FEATURES,
					write(chunk) {
						data.stdoutHTML += chunk;
					},
				});

				const handles = [
					ansiReporterStream,
					htmlReporterStream,
					server.connectedReporters.addAttachedStream(ansiReporterStream.stream),
					server.connectedReporters.addAttachedStream(htmlReporterStream.stream),
				];

				client.bridge.endEvent.subscribe(() => {
					for (const handle of handles) {
						handle.remove();
					}

					data.endTime = Date.now();
					this.refreshRequests();
				});
			});

			server.requestStartEvent.subscribe((request) => {
				if (!this.savingRequests) {
					return;
				}

				const data = {
					id: request.id,
					client: request.client.id,
					query: request.query,
					markers: [],
					response: undefined,
					startTime: Date.now(),
					endTime: undefined,
				};
				this.clientRequestHistory.set(request.id, data);
				this.refreshRequests();

				request.markerEvent.subscribe((marker) => {
					data.markers.push(marker);
					this.refreshRequests();
				});

				request.endEvent.subscribe((response) => {
					// Update completion fields
					data.response = response;
					data.endTime = Date.now();
					this.refreshRequests();
				});
			});
		}

		onWebsocketBridge(req, bridge) {
			this.websocketBridges.add(bridge);

			req.socket.on(
				"close",
				() => {
					this.websocketBridges.delete(bridge);
				},
			);
		}

		sendRequests(bridge) {
			bridge.requests.send({
				requests: Array.from(this.clientRequestHistory.values()),
				clients: Array.from(this.clientHistory.values()),
			});
		}

		refreshRequests() {
			for (const bridge of this.websocketBridges) {
				this.sendRequests(bridge);
			}
		}

		close() {
			this.httpServer.close();
		}

		listen(port) {
			this.httpServer.listen(port);

			this.reporter.clearScreen();
			const url = "http://localhost:" + String(port);
			this.reporter.success(
				___R$project$rome$$internal$markup$escape_ts$markup`Listening on <hyperlink emphasis>${url}</hyperlink>`,
			);
			this.reporter.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Web console available at <hyperlink emphasis>${url}/__rome__</hyperlink>`,
			);
		}

		async pathnameToAbsolutePath(pathname) {
			const project = await this.serverRequest.assertClientCwdProject();
			const possibleStaticPath = project.directory.append(pathname);

			// This check makes sure that files outside of the project directory cannot be served
			if (possibleStaticPath.isRelativeTo(project.directory)) {
				return possibleStaticPath;
			} else {
				return undefined;
			}
		}

		async getBundler(url) {
			const pathname = ___R$project$rome$$internal$core$server$web$WebRequest_ts$stripBundleSuffix(
				String(url.path.asString()),
			);

			const absolute = await this.pathnameToAbsolutePath(pathname);
			if (absolute === undefined) {
				throw new Error("Pathname is attempting to escalate out of cwd");
			}

			const pathPointer = url.path.getDiagnosticLocation();
			const path = await this.server.resolver.resolveEntryAssertPath(
				{
					origin: this.serverRequest.client.flags.cwd,
					source: absolute,
				},
				pathPointer === undefined ? undefined : {location: pathPointer},
			);

			const platform = url.query.get("platform").asStringSetOrVoid(
				___R$project$rome$$internal$core$common$types$platform_ts$PLATFORMS,
			);
			const cacheKey = JSON.stringify({
				platform,
			});

			const cached = this.bundlerCache.get(cacheKey);
			if (cached !== undefined) {
				return {bundler: cached, path};
			}

			const bundlerConfig = this.serverRequest.getBundlerConfigFromFlags({
				platform,
			});

			const bundler = new ___R$project$rome$$internal$core$server$bundler$Bundler_ts$default(
				this.serverRequest,
				bundlerConfig,
			);
			this.bundlerCache.set(cacheKey, bundler);
			return {bundler, path};
		}
	}


  // project-rome/@internal/core/server/commands/develop.ts
const ___R$$priv$project$rome$$internal$core$server$commands$develop_ts$DEFAULT_PORT = 8_081;
	const ___R$project$rome$$internal$core$server$commands$develop_ts$default = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.SOURCE_CODE,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`start a web server`,
		usage: "",
		examples: [],
		hidden: true,
		defineFlags(c) {
			return {
				port: c.get("port").asNumber(
					___R$$priv$project$rome$$internal$core$server$commands$develop_ts$DEFAULT_PORT,
				),
			};
		},
		async callback(req, flags) {
			// Initialize cwd early since we'll need it for any requests
			await req.server.projectManager.findProject(req.client.flags.cwd);

			const web = new ___R$project$rome$$internal$core$server$web$index_ts$WebServer(
				req,
			);
			web.listen(flags.port);

			req.endEvent.subscribe(() => {
				web.close();
			});

			await new Promise(() => {});
		},
	});


  // project-rome/@internal/core/common/userConfig.ts
const ___R$project$rome$$internal$core$common$userConfig_ts$DEFAULT_USER_CONFIG = {
		configPath: undefined,
		cachePath: ___R$project$rome$$internal$core$common$constants_ts$DEFAULT_CACHE_PATH,
		recoveryPath: ___R$project$rome$$internal$core$common$constants_ts$DEFAULT_USER_CONFIG_RECOVERY_DIRECTORY,
		syntaxTheme: undefined,
	};

	async function ___R$project$rome$$internal$core$common$userConfig_ts$normalizeUserConfig(
		consumer,
		configPath,
	) {
		const userConfig = Object.assign(
			{},
			___R$project$rome$$internal$core$common$userConfig_ts$DEFAULT_USER_CONFIG,
		);

		if (consumer.has("cachePath")) {
			userConfig.cachePath = consumer.get("cachePath").asAbsoluteFilePath(
				undefined,
				configPath.getParent(),
			);
		}

		if (consumer.has("vscodeTheme")) {
			const prop = consumer.get("vscodeTheme");
			const path = prop.asAbsoluteFilePath(undefined, configPath.getParent());

			if (await ___R$project$rome$$internal$fs$index_ts$exists(path)) {
				const input = await ___R$project$rome$$internal$fs$index_ts$readFileText(
					path,
				);

				userConfig.syntaxTheme = ___R$project$rome$$internal$codec$json$index_ts$consumeJSON({
					consumeDiagnosticCategory: "parse/vscodeTheme",
					input,
					path,
				});
			} else {
				throw prop.unexpected(
					___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.USER_CONFIG.VSCODE_THEME_NOT_FOUND,
				);
			}
		}

		consumer.enforceUsedProperties("config property");

		return userConfig;
	}

	let ___R$$priv$project$rome$$internal$core$common$userConfig_ts$loadedUserConfig;

	async function ___R$project$rome$$internal$core$common$userConfig_ts$getUserConfigFile() {
		for (const configFilename of ___R$project$rome$$internal$core$common$constants_ts$USER_CONFIG_FILENAMES) {
			const configPath = ___R$project$rome$$internal$core$common$constants_ts$USER_CONFIG_DIRECTORY.append(
				configFilename,
			);

			if (!(await ___R$project$rome$$internal$fs$index_ts$exists(configPath))) {
				continue;
			}

			const configFile = await ___R$project$rome$$internal$fs$index_ts$readFileText(
				configPath,
			);
			const consumer = ___R$project$rome$$internal$codec$json$index_ts$consumeJSON({
				path: configPath,
				input: configFile,
			});
			return {consumer, configPath};
		}

		return undefined;
	}

	async function ___R$project$rome$$internal$core$common$userConfig_ts$loadUserConfig() {
		if (
			___R$$priv$project$rome$$internal$core$common$userConfig_ts$loadedUserConfig !==
			undefined
		) {
			return ___R$$priv$project$rome$$internal$core$common$userConfig_ts$loadedUserConfig;
		}

		const res = await ___R$project$rome$$internal$core$common$userConfig_ts$getUserConfigFile();
		if (res === undefined) {
			___R$$priv$project$rome$$internal$core$common$userConfig_ts$loadedUserConfig = ___R$project$rome$$internal$core$common$userConfig_ts$DEFAULT_USER_CONFIG;
			return ___R$$priv$project$rome$$internal$core$common$userConfig_ts$loadedUserConfig;
		} else {
			___R$$priv$project$rome$$internal$core$common$userConfig_ts$loadedUserConfig = await ___R$project$rome$$internal$core$common$userConfig_ts$normalizeUserConfig(
				res.consumer,
				res.configPath,
			);
			return ___R$$priv$project$rome$$internal$core$common$userConfig_ts$loadedUserConfig;
		}
	}


  // project-rome/@internal/core/server/commands/config.ts
const ___R$project$rome$$internal$core$server$commands$config_ts = {
		get location() {
			return ___R$project$rome$$internal$core$server$commands$config_ts$location;
		},
		get enable() {
			return ___R$project$rome$$internal$core$server$commands$config_ts$enable;
		},
		get disable() {
			return ___R$project$rome$$internal$core$server$commands$config_ts$disable;
		},
		get setDirectory() {
			return ___R$project$rome$$internal$core$server$commands$config_ts$setDirectory;
		},
		get set() {
			return ___R$project$rome$$internal$core$server$commands$config_ts$set;
		},
		get push() {
			return ___R$project$rome$$internal$core$server$commands$config_ts$push;
		},
	};
	function ___R$$priv$project$rome$$internal$core$server$commands$config_ts$defineFlags(
		c,
	) {
		return {
			user: c.get("user").asBoolean(false),
		};
	}

	async function ___R$$priv$project$rome$$internal$core$server$commands$config_ts$runCommand(
		req,
		flags,
		value,
		action,
	) {
		const {reporter} = req;
		const [keyParts] = req.query.args;

		function modify(consumer) {
			// Set the specified value
			let keyConsumer = consumer;
			for (const key of keyParts.split(".")) {
				if (!keyConsumer.exists()) {
					keyConsumer.setValue({});
				}
				keyConsumer = keyConsumer.get(key);
			}

			if (action === "push") {
				keyConsumer.setValue([
					...Array.from(keyConsumer.asIterable(true), (c) => c.asUnknown()),
					...(Array.isArray(value) ? value : []),
				]);
			} else {
				keyConsumer.setValue(value);
			}
		}

		async function handleConfig(configPath, subKey, validate) {
			if (action === "location") {
				reporter.log(
					___R$project$rome$$internal$markup$escape_ts$markup`${configPath.join()}`,
				);
				return;
			}

			reporter.success(
				___R$project$rome$$internal$markup$escape_ts$markup`${action === "push"
					? "Adding"
					: "Setting"} <emphasis>${keyParts}</emphasis> to <emphasis>${JSON.stringify(
					value,
				)}</emphasis> in the config <emphasis>${configPath}</emphasis>`,
			);

			if (value === "true" || value === "false") {
				const suggestedCommand = value === "true" ? "enable" : "disable";
				reporter.warn(
					___R$project$rome$$internal$markup$escape_ts$markup`Value is the string <emphasis>${value}</emphasis> but it looks like a boolean. You probably meant to use the command:`,
				);
				reporter.command("config " + suggestedCommand + " " + keyParts);
			}

			// Load the config file again
			const configFile = await ___R$project$rome$$internal$fs$index_ts$readFileText(
				configPath,
			);
			const res = ___R$project$rome$$internal$codec$json$index_ts$consumeJSONExtra({
				path: configPath,
				input: configFile,
			});

			const {consumer} = res;
			if (subKey === undefined) {
				modify(consumer);
			} else {
				modify(consumer.get(subKey));
			}

			// Stringify the config
			const stringified = ___R$project$rome$$internal$codec$json$index_ts$stringifyJSONExtra(
				res,
			);

			// Test if this project config doesn't result in errors
			await ___R$project$rome$$internal$diagnostics$wrap_ts$interceptDiagnostics(
				async () => {
					// Reconsume with new stringified config
					const res = ___R$project$rome$$internal$codec$json$index_ts$consumeJSONExtra({
						path: configPath,
						input: stringified,
					});

					await validate(res, stringified);
				},
				(processor) => {
					processor.normalizer.setInlineSourceText(
						configPath.join(),
						stringified,
					);
				},
			);

			// Write it out
			await ___R$project$rome$$internal$fs$index_ts$writeFile(
				configPath,
				stringified,
			);
		}

		try {
			if (flags.user) {
				let {configPath: existingConfigPath} = await ___R$project$rome$$internal$core$common$userConfig_ts$loadUserConfig();

				let configPath;
				if (existingConfigPath === undefined) {
					configPath = ___R$project$rome$$internal$core$common$constants_ts$USER_CONFIG_DIRECTORY.append(
						"rome.rjson",
					);
					await ___R$project$rome$$internal$fs$index_ts$writeFile(
						configPath,
						"",
					);
					reporter.info(
						___R$project$rome$$internal$markup$escape_ts$markup`Created user config at <emphasis>${configPath}</emphasis> as it did not exist`,
					);
				} else {
					configPath = existingConfigPath;
				}

				await handleConfig(
					configPath,
					undefined,
					async (res) => {
						await ___R$project$rome$$internal$core$common$userConfig_ts$normalizeUserConfig(
							res.consumer,
							configPath,
						);
					},
				);
			} else {
				const project = await req.assertClientCwdProject();
				const meta = ___R$project$rome$$internal$project$utils_ts$assertHardMeta(
					project.meta,
				);
				const {configPath, configSourceSubKey} = meta;

				await handleConfig(
					configPath,
					configSourceSubKey,
					async (res, stringified) => {
						await ___R$project$rome$$internal$project$load_ts$normalizeProjectConfig(
							res,
							meta.configPath,
							stringified,
							meta.projectDirectory,
						);
					},
				);
			}
		} catch (err) {
			reporter.warn(
				___R$project$rome$$internal$markup$escape_ts$markup`Error occured while validating new config. Your changes have not been saved. Listed locations are not accurate.`,
			);
			throw err;
		}
	}

	const ___R$project$rome$$internal$core$server$commands$config_ts$location = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.PROJECT_MANAGEMENT,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`show the config location`,
		usage: "",
		examples: [],
		defineFlags: ___R$$priv$project$rome$$internal$core$server$commands$config_ts$defineFlags,
		async callback(req, flags) {
			req.expectArgumentLength(0);
			await ___R$$priv$project$rome$$internal$core$server$commands$config_ts$runCommand(
				req,
				flags,
				"",
				"location",
			);
		},
	});

	const ___R$project$rome$$internal$core$server$commands$config_ts$enable = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.PROJECT_MANAGEMENT,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`modify a project config- set the ${"<key>"} to true`,
		usage: "<key>",
		examples: [],
		defineFlags: ___R$$priv$project$rome$$internal$core$server$commands$config_ts$defineFlags,
		async callback(req, flags) {
			req.expectArgumentLength(1);
			await ___R$$priv$project$rome$$internal$core$server$commands$config_ts$runCommand(
				req,
				flags,
				true,
				"enable",
			);
		},
	});

	const ___R$project$rome$$internal$core$server$commands$config_ts$disable = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.PROJECT_MANAGEMENT,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`modify a project config- set the ${"<key>"} to false`,
		usage: "<key>",
		examples: [],
		defineFlags: ___R$$priv$project$rome$$internal$core$server$commands$config_ts$defineFlags,
		async callback(req, flags) {
			req.expectArgumentLength(1);
			await ___R$$priv$project$rome$$internal$core$server$commands$config_ts$runCommand(
				req,
				flags,
				false,
				"disable",
			);
		},
	});

	const ___R$project$rome$$internal$core$server$commands$config_ts$setDirectory = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.PROJECT_MANAGEMENT,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`modify a project config - set the ${"<key>"} to ${"<value>"}`,
		usage: "<key> <value>",
		examples: [],
		defineFlags: ___R$$priv$project$rome$$internal$core$server$commands$config_ts$defineFlags,
		async callback(req, flags) {
			req.expectArgumentLength(2);

			let value = req.query.args[1];
			const path = ___R$project$rome$$internal$path$index_ts$createUnknownPath(
				value,
			);

			// If the value is an absolute path, then make it relative to the project directory
			if (path.isAbsolute()) {
				let cwd;
				if (flags.user) {
					// Relative to home user config
					cwd = ___R$project$rome$$internal$core$common$constants_ts$USER_CONFIG_DIRECTORY;
				} else {
					// Relative to project config folder
					const project = await req.assertClientCwdProject();
					cwd = ___R$project$rome$$internal$project$utils_ts$assertHardMeta(
						project.meta,
					).configPath.getParent();
				}

				value = cwd.relative(path).join();
			}

			await ___R$$priv$project$rome$$internal$core$server$commands$config_ts$runCommand(
				req,
				flags,
				value,
				"setDirectory",
			);
		},
	});

	const ___R$project$rome$$internal$core$server$commands$config_ts$set = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.PROJECT_MANAGEMENT,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`modify a project config - set the ${"<key>"} to ${"<value>"}`,
		usage: "<key> <value>",
		examples: [],
		defineFlags: ___R$$priv$project$rome$$internal$core$server$commands$config_ts$defineFlags,
		async callback(req, flags) {
			req.expectArgumentLength(2);
			await ___R$$priv$project$rome$$internal$core$server$commands$config_ts$runCommand(
				req,
				flags,
				req.query.args[1],
				"set",
			);
		},
	});

	const ___R$project$rome$$internal$core$server$commands$config_ts$push = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.PROJECT_MANAGEMENT,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`modify a project config - push ${"<values>"} to ${"<key>"}`,
		usage: "<key> <...values>",
		examples: [],
		defineFlags: ___R$$priv$project$rome$$internal$core$server$commands$config_ts$defineFlags,
		async callback(req, flags) {
			req.expectArgumentLength(2, Infinity);
			await ___R$$priv$project$rome$$internal$core$server$commands$config_ts$runCommand(
				req,
				flags,
				req.query.args.slice(1),
				"push",
			);
		},
	});


  // project-rome/@internal/core/server/commands/compile.ts
const ___R$project$rome$$internal$core$server$commands$compile_ts$default = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.SOURCE_CODE,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`compile a single file`,
		usage: "",
		examples: [],
		hidden: true,
		defineFlags(c) {
			return {
				bundle: c.get("bundle").asBoolean(false),
			};
		},
		async callback(req, commandFlags) {
			const {reporter} = req;
			const resolved = await req.resolveEntryAssertPathArg(0);

			let res;
			if (commandFlags.bundle) {
				const bundler = ___R$project$rome$$internal$core$server$bundler$Bundler_ts$default.createFromServerRequest(
					req,
				);
				res = await bundler.compileSingle(resolved);
			} else {
				res = await req.requestWorkerCompile(resolved, "compile", {}, {});
			}

			const {compiledCode, diagnostics, suppressions} = res;

			if (diagnostics.length > 0) {
				throw new ___R$project$rome$$internal$diagnostics$errors_ts$DiagnosticsError(
					"Compile diagnostics",
					diagnostics,
					suppressions,
				);
			}

			reporter.write(compiledCode);
		},
	});


  // project-rome/@internal/core/server/commands/resolve.ts
const ___R$project$rome$$internal$core$server$commands$resolve_ts$default = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.SOURCE_CODE,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`resolve a file`,
		usage: "",
		examples: [],
		hidden: true,
		defineFlags() {
			return {};
		},
		async callback(req) {
			const {server, reporter} = req;
			const {args} = req.query;
			const {flags} = req.client;
			req.expectArgumentLength(1, 2);

			let origin;
			let relative = "";
			let key;

			if (args.length === 2) {
				origin = flags.cwd.resolveMaybeUrl(args[0]);
				relative = args[1];
				key = 1;
			} else {
				origin = flags.cwd;
				relative = args[0];
				key = 0;
			}

			const query = Object.assign(
				{},
				req.getResolverOptionsFromFlags(),
				{
					origin,
					source: ___R$project$rome$$internal$path$index_ts$createUnknownPath(
						relative,
					),
				},
			);

			const resolved = await server.resolver.resolveEntryAssert(
				query,
				{
					location: req.getDiagnosticLocationFromFlags({type: "arg", key}),
				},
			);
			reporter.log(
				___R$project$rome$$internal$markup$escape_ts$markup`${resolved.ref.real}`,
			);
			return resolved.ref.real.join();
		},
	});


  // project-rome/@internal/core/server/commands/analyzeDependencies.ts
function ___R$$priv$project$rome$$internal$core$server$commands$analyzeDependencies_ts$removeLoc(
		obj,
	) {
		const ___R$ = obj;
		const locless = Object.assign({}, ___R$);
		delete locless.loc;
		const {loc} = ___R$;
		loc;
		return locless;
	}
	const ___R$project$rome$$internal$core$server$commands$analyzeDependencies_ts$default = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.SOURCE_CODE,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`analyze and dump the dependencies of a file`,
		usage: "",
		examples: [],
		hidden: true,
		defineFlags(c) {
			return {
				compact: c.get("compact").asBoolean(false),
				focusSource: c.get("focusSource").asStringOrVoid(),
			};
		},
		async callback(req, commandFlags) {
			const {reporter} = req;
			const filename = await req.resolveEntryAssertPathArg(0);

			let res = await req.requestWorkerAnalyzeDependencies(filename, {});

			const {focusSource} = commandFlags;
			if (focusSource !== undefined) {
				res = Object.assign(
					{},
					res,
					{
						importFirstUsage: res.importFirstUsage.filter((dep) => {
							return dep.source === focusSource;
						}),
						dependencies: res.dependencies.filter((dep) => {
							return dep.source === focusSource;
						}),
					},
				);
			}

			if (commandFlags.compact) {
				res = Object.assign(
					{},
					res,
					{
						topLevelLocalBindings: {},
						importFirstUsage: res.importFirstUsage.map((imp) => {
							return ___R$$priv$project$rome$$internal$core$server$commands$analyzeDependencies_ts$removeLoc(
								imp,
							);
						}),
						exports: res.exports.map((exp) => {
							// This weird switch is because TS only returns an object with the properties common amongst all
							switch (exp.type) {
								case "local":
									return ___R$$priv$project$rome$$internal$core$server$commands$analyzeDependencies_ts$removeLoc(
										exp,
									);

								case "external":
									return ___R$$priv$project$rome$$internal$core$server$commands$analyzeDependencies_ts$removeLoc(
										exp,
									);

								case "externalAll":
									return ___R$$priv$project$rome$$internal$core$server$commands$analyzeDependencies_ts$removeLoc(
										exp,
									);

								case "externalNamespace":
									return ___R$$priv$project$rome$$internal$core$server$commands$analyzeDependencies_ts$removeLoc(
										exp,
									);
							}
						}),
						dependencies: res.dependencies.map((dep) => {
							return Object.assign(
								{},
								___R$$priv$project$rome$$internal$core$server$commands$analyzeDependencies_ts$removeLoc(
									dep,
								),
								{
									names: dep.names.map((name) => {
										return ___R$$priv$project$rome$$internal$core$server$commands$analyzeDependencies_ts$removeLoc(
											name,
										);
									}),
								},
							);
						}),
					},
				);
			}

			reporter.inspect(res);
		},
	});


  // project-rome/@internal/core/server/commands/parse.ts
const ___R$project$rome$$internal$core$server$commands$parse_ts$default = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.SOURCE_CODE,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`parse a single file and dump its ast`,
		usage: "",
		examples: [],
		hidden: true,
		defineFlags(c) {
			return {
				allowDiagnostics: c.get("allowDiagnostics").asBoolean(false),
				compact: c.get("compact").asBoolean(true),
				sourceType: c.get("sourceType").asStringSetOrVoid(["module", "script"]),
			};
		},
		async callback(req, flags) {
			const {reporter} = req;
			const filename = await req.resolveEntryAssertPathArg(0);

			let ast = await req.requestWorkerParse(
				filename,
				{
					sourceTypeJS: flags.sourceType,
					allowParserDiagnostics: flags.allowDiagnostics,
				},
			);

			if (flags.compact) {
				ast = ___R$project$rome$$internal$ast$utils$assertRoot_ts$assertRoot(
					___R$project$rome$$internal$js$ast$utils$assertSingleNode_ts$assertSingleNode(
						___R$project$rome$$internal$ast$utils$removeLoc_ts$removeLoc(ast),
					),
				);
			}

			reporter.inspect(ast);
		},
	});


  // project-rome/@internal/core/server/commands/bundle.ts
const ___R$project$rome$$internal$core$server$commands$bundle_ts$default = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.SOURCE_CODE,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`build a standalone js bundle for a package`,
		usage: "",
		examples: [],
		hidden: true,
		defineFlags(consumer) {
			return {
				quiet: consumer.get("quiet").asBoolean(false),
			};
		},
		async callback(req, commandFlags) {
			const {flags} = req.client;
			const {args} = req.query;
			const {reporter} = req;
			req.expectArgumentLength(2);

			const [entryFilename, outputDirectory] = args;
			const bundler = ___R$project$rome$$internal$core$server$bundler$Bundler_ts$default.createFromServerRequest(
				req,
			);

			const resolution = await bundler.getResolvedEntry(entryFilename);
			const {files: outFiles} = await bundler.bundleManifest(resolution);

			const savedList = [];
			const dir = flags.cwd.resolve(outputDirectory);
			for (const [filename, {kind, content}] of outFiles) {
				const buff = content();
				const file = dir.append(filename);
				const loc = file.join();
				savedList.push(
					___R$project$rome$$internal$markup$escape_ts$markup`<filelink target="${loc}">${filename}</filelink> <filesize dim>${String(
						Buffer.byteLength(buff),
					)}</filesize> <inverse> ${kind} </inverse>`,
				);
				await ___R$project$rome$$internal$fs$index_ts$createDirectory(
					file.getParent(),
				);
				await ___R$project$rome$$internal$fs$index_ts$writeFile(file, buff);
			}

			await req.flushFiles();

			if (commandFlags.quiet) {
				reporter.success(
					___R$project$rome$$internal$markup$escape_ts$markup`Saved to <emphasis>${dir}</emphasis>`,
				);
			} else {
				reporter.success(
					___R$project$rome$$internal$markup$escape_ts$markup`Saved the following files to <emphasis>${dir}</emphasis>`,
				);
				reporter.list(savedList);
			}
		},
	});


  // project-rome/@internal/core/server/commands/format.ts
const ___R$project$rome$$internal$core$server$commands$format_ts$default = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.INTERNAL,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`formats a single file`,
		usage: "",
		examples: [],
		defineFlags(c) {
			return {
				allowDiagnostics: c.get("allowDiagnostics").asBoolean(false),
			};
		},
		async callback(req, flags) {
			const {reporter} = req;
			const filename = await req.resolveEntryAssertPathArg(0);

			const res = await req.requestWorkerFormat(
				filename,
				{},
				{
					allowParserDiagnostics: flags.allowDiagnostics,
				},
			);

			if (res === undefined) {
				reporter.error(
					___R$project$rome$$internal$markup$escape_ts$markup`No formatter for this file`,
				);
				return undefined;
			} else {
				reporter.write(res.formatted);
				return res.formatted;
			}
		},
	});


  // project-rome/@internal/core/server/linter/Linter.ts
function ___R$$priv$project$rome$$internal$core$server$linter$Linter_ts$createDiagnosticsPrinter(
		request,
		processor,
		totalCount,
		savedCount,
	) {
		const printer = request.createDiagnosticsPrinter(processor);

		printer.onFooterPrint(async (reporter, isError) => {
			if (isError) {
				let hasPendingFixes = false;

				for (const {tags} of processor.getDiagnostics()) {
					if (tags !== undefined && tags.fixable) {
						hasPendingFixes = true;
					}
				}

				if (hasPendingFixes) {
					reporter.info(
						___R$project$rome$$internal$markup$escape_ts$markup`Fixes available. To apply safe fixes and formatting run`,
					);
					reporter.command("rome check --apply");
					reporter.info(
						___R$project$rome$$internal$markup$escape_ts$markup`To choose fix suggestions run`,
					);
					reporter.command("rome check --review");
					reporter.br();
				}
			}

			if (savedCount > 0) {
				reporter.success(
					___R$project$rome$$internal$markup$escape_ts$markup`<number emphasis>${String(
						savedCount,
					)}</number> <grammarNumber plural="files" singular="file">${String(
						savedCount,
					)}</grammarNumber> updated`,
				);
				reporter.info(
					___R$project$rome$$internal$markup$escape_ts$markup`You can revert these changes with the <code>rome recover pop</code> command`,
				);
				reporter.br();
			}

			if (!isError) {
				if (totalCount === 0) {
					reporter.warn(
						___R$project$rome$$internal$markup$escape_ts$markup`No files linted`,
					);
				} else {
					reporter.info(
						___R$project$rome$$internal$markup$escape_ts$markup`<number emphasis>${String(
							totalCount,
						)}</number> <grammarNumber plural="files" singular="file">${String(
							totalCount,
						)}</grammarNumber> linted`,
					);
				}
			}
		});

		return printer;
	}

	class ___R$$priv$project$rome$$internal$core$server$linter$Linter_ts$LintRunner {
		constructor(
			linter,
			{
				graph,
				events,
			},
		) {
			this.linter = linter;
			this.server = linter.request.server;
			this.graph = graph;
			this.request = linter.request;
			this.options = linter.options;
			this.events = events;
			this.compilerDiagnosticsCache = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
			this.hadDependencyValidationErrors = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
		}

		hasCompilerDiagnostics(path) {
			return this.compilerDiagnosticsCache.has(path);
		}

		clearCompilerDiagnosticsForPath(path) {
			this.compilerDiagnosticsCache.set(
				path,
				{suppressions: [], diagnostics: []},
			);
		}

		async runLint({paths}, processor) {
			const {server} = this.request;
			const {
				lintCompilerOptionsPerFile = {},
				globalDecisions = [],
				hasDecisions,
			} = this.options;
			const shouldSave = this.linter.shouldSave();
			const applySafeFixes = !this.linter.shouldOnlyFormat();

			const queue = new ___R$project$rome$$internal$core$server$WorkerQueue_ts$default(
				server,
				{
					callback: async ({path}) => {
						const filename = path.join();
						const progressId = progress.pushText(
							___R$project$rome$$internal$markup$escape_ts$markup`<filelink target="${filename}" />`,
						);

						let compilerOptions = lintCompilerOptionsPerFile[filename];

						// If we have decisions then make sure it's declared on all files
						if (hasDecisions) {
							if (compilerOptions === undefined) {
								compilerOptions = {
									hasDecisions: true,
									globalDecisions,
									decisionsByPosition: {},
								};
							} else {
								compilerOptions = Object.assign(
									{},
									compilerOptions,
									{
										hasDecisions: true,
										globalDecisions: [
											...(compilerOptions.globalDecisions || []),
											...globalDecisions,
										],
									},
								);
							}
						}

						const res = await ___R$project$rome$$internal$fs$FileNotFound_ts$FileNotFound.allowMissing(
							path,
							() =>
								this.request.requestWorkerLint(
									path,
									{
										save: shouldSave,
										applySafeFixes,
										compilerOptions,
										suppressionExplanation: this.options.suppressionExplanation,
									},
								)
							,
						);

						if (res.missing) {
							return;
						}

						const {
							diagnostics,
							suppressions,
							save,
						} = res.value;
						processor.addSuppressions(suppressions);
						processor.addDiagnostics(diagnostics);
						this.compilerDiagnosticsCache.set(path, {suppressions, diagnostics});
						if (save !== undefined) {
							this.request.queueSaveFile(path, save);
						}

						progress.popText(progressId);
						progress.tick();
					},
				},
			);

			const progress = this.events.createProgress({
				title: ___R$project$rome$$internal$markup$escape_ts$markup`Linting`,
			});
			progress.setTotal(paths.size);

			await queue.prepare(paths);

			for (const path of paths) {
				await ___R$project$rome$$internal$fs$FileNotFound_ts$FileNotFound.allowMissing(
					path,
					() => queue.pushPath(path),
				);
			}

			await queue.spin();
			progress.end();
		}

		async runGraph(event, processor) {
			const {graph} = this;
			const evictedPaths = event.paths;

			// Get all the current dependency nodes for the evicted files, and invalidate their nodes
			const oldEvictedNodes = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
			for (const path of evictedPaths) {
				const node = graph.maybeGetNode(path);
				if (node !== undefined) {
					oldEvictedNodes.set(path, node);
					graph.deleteNode(path);
				}
			}

			// Refresh only the evicted paths
			const progress = this.events.createProgress({
				title: event.initial
					? ___R$project$rome$$internal$markup$escape_ts$markup`Analyzing files`
					: ___R$project$rome$$internal$markup$escape_ts$markup`Analyzing changed files`,
			});
			await graph.seed({
				allowFileNotFound: true,
				paths: Array.from(evictedPaths),
				diagnosticsProcessor: processor,
				validate: false,
				analyzeProgress: progress,
			});
			progress.end();

			// Maintain a list of all the dependencies we revalidated
			const validatedDependencyPaths = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet();

			// Maintain a list of all the dependents that need to be revalidated
			const validatedDependencyPathDependents = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet();

			// Build a list of dependents to recheck
			for (const path of evictedPaths) {
				const newNode = graph.maybeGetNode(path);
				if (newNode === undefined) {
					continue;
				}

				validatedDependencyPaths.add(path);

				// Get the previous node and see if the exports have actually changed
				const oldNode = oldEvictedNodes.get(path);
				const sameShape =
					oldNode !== undefined &&
					___R$project$rome$$internal$compiler$api$analyzeDependencies$utils_ts$areAnalyzeDependencyResultsEqual(
						oldNode.analyze,
						newNode.analyze,
					);

				for (const depNode of newNode.getDependents()) {
					// If the old node has the same shape as the new one, only revalidate the dependent if it had dependency errors
					if (
						sameShape &&
						this.hadDependencyValidationErrors.get(depNode.path) === false
					) {
						continue;
					}

					validatedDependencyPaths.add(depNode.path);
					validatedDependencyPathDependents.add(depNode.path);
				}
			}

			// Revalidate dependents
			if (validatedDependencyPathDependents.size > 0) {
				const progress = this.events.createProgress({
					title: ___R$project$rome$$internal$markup$escape_ts$markup`Analyzing dependents`,
				});

				await graph.seed({
					paths: Array.from(validatedDependencyPaths),
					diagnosticsProcessor: processor,
					validate: false,
					analyzeProgress: progress,
				});

				progress.end();
			}

			// Validate connections
			for (const path of validatedDependencyPaths) {
				const hasValidationErrors = graph.validate(
					graph.getNode(path),
					processor,
				);
				this.hadDependencyValidationErrors.set(path, hasValidationErrors);
			}

			return validatedDependencyPaths;
		}

		computeChanges({paths: evictedPaths}, processor, validatedDependencyPaths) {
			const {server} = this;
			const changes = [];

			const updatedPaths = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet([
				...validatedDependencyPaths,
			]);

			// Deleted paths wont show up in validatedDependencyPaths so we need to readd them
			for (const path of evictedPaths) {
				if (!server.memoryFs.exists(path)) {
					updatedPaths.add(path);
					this.clearCompilerDiagnosticsForPath(path);
				}
			}

			const diagnosticsByFilename = processor.getDiagnosticsByFilename();

			// In case we pushed on any diagnostics that aren't from the input paths, try to resolve them
			const includedFilenamesInDiagnostics = server.projectManager.normalizeFilenamesToFilePaths(
				diagnosticsByFilename.keys(),
			);
			for (const path of includedFilenamesInDiagnostics.absolutes) {
				updatedPaths.add(path);
			}

			// validatedDependencyPaths can include paths that weren't changed, but needed to be recomputed
			// as they were dependents of one of the files that was
			// In that case we need to push their previous compiler diagnostics
			for (const path of validatedDependencyPaths) {
				if (!evictedPaths.has(path)) {
					const compilerDiagnostics = this.compilerDiagnosticsCache.get(path);
					if (compilerDiagnostics !== undefined) {
						processor.addSuppressions(compilerDiagnostics.suppressions);
						processor.addDiagnostics(compilerDiagnostics.diagnostics);
					}
				}
			}

			// We can't just use getDiagnosticFilenames as we need to produce empty arrays for removed diagnostics
			for (const path of updatedPaths) {
				const filename = path.join();
				let diagnostics = [...(diagnosticsByFilename.get(filename) || [])];

				// Could have been a UID that we turned into an absolute path so turn it back
				diagnostics = [
					...diagnostics,
					...(diagnosticsByFilename.get(
						this.server.projectManager.getUid(path, true),
					) || []),
				];

				changes.push({
					type: "absolute",
					filename,
					diagnostics,
				});
			}

			// We can produce diagnostics that don't actually point at a file. For LSP we will just throw these away,
			// otherwise inside of Rome we can display them.
			// These filenames may be relative or undefined
			for (const filename of includedFilenamesInDiagnostics.others) {
				changes.push({
					type: "unknown",
					filename,
					diagnostics: diagnosticsByFilename.get(filename) || [],
				});
			}

			return changes;
		}

		async run(event, processor) {
			this.events.onRunStart();

			// Run compiler lint
			await this.runLint(event, processor);

			// Update dependency graph
			const validatedDependencyPaths = await this.runGraph(event, processor);

			// Computed diagnostic changes
			const changes = await this.computeChanges(
				event,
				processor,
				validatedDependencyPaths,
			);

			// Flush saved files
			const savedCount = await this.request.flushFiles();

			return {
				evictedPaths: event.paths,
				changes,
				savedCount,
				totalCount: event.paths.size,
				runner: this,
			};
		}
	}

	class ___R$project$rome$$internal$core$server$linter$Linter_ts$default {
		constructor(req, opts) {
			this.request = req;
			this.options = opts;
		}

		shouldOnlyFormat() {
			const {formatOnly} = this.options;
			const {review} = this.request.query.requestFlags;
			return formatOnly || review;
		}

		shouldSave() {
			const {apply, hasDecisions} = this.options;
			return apply || hasDecisions || this.shouldOnlyFormat();
		}

		createDiagnosticsProcessor(evictedPaths, runner) {
			const processor = this.request.createDiagnosticsProcessor({
				origins: [
					{
						category: "lint",
						message: "Dispatched",
					},
				],
			});

			processor.addAllowedUnusedSuppressionPrefix("bundler");

			// Only display files that aren't absolute, are in the changed paths, or have had previous compiler diagnostics
			// This hides errors that have been lint ignored but may have been produced by dependency analysis
			processor.addFilter({
				test: (diag) => {
					const absolute = this.request.server.projectManager.getFilePathFromUidOrAbsolute(
						diag.location.filename,
					);
					return (
						absolute === undefined ||
						evictedPaths.has(absolute) ||
						(runner !== undefined && runner.hasCompilerDiagnostics(absolute))
					);
				},
			});

			return processor;
		}

		async watch(events) {
			const graph = new ___R$project$rome$$internal$core$server$dependencies$DependencyGraph_ts$default(
				this.request,
				this.request.getResolverOptionsFromFlags(),
			);

			const runner = new ___R$$priv$project$rome$$internal$core$server$linter$Linter_ts$LintRunner(
				this,
				{events, graph},
			);

			const globber = await this.request.glob({
				args: this.options.args,
				noun: "lint",
				verb: "linting",
				configCategory: "lint",
				extensions: ___R$project$rome$$internal$core$common$file$handlers$index_ts$LINTABLE_EXTENSIONS,
				disabledDiagnosticCategory: "lint/disabled",
			});

			return globber.watch(async (event) => {
				const processor = this.createDiagnosticsProcessor(event.paths, runner);
				const result = await runner.run(event, processor);
				await events.onChanges(result);
			});
		}

		async runWatch() {
			const {request} = this;
			const {reporter} = request;

			const diagnosticsByFilename = new Map();

			await this.watch({
				onRunStart: () => {
					reporter.clearScreen();
				},
				createProgress: (opts) => {
					return reporter.progress(opts);
				},
				onChanges: async (
					{evictedPaths, changes, totalCount, savedCount, runner},
				) => {
					const printer = ___R$$priv$project$rome$$internal$core$server$linter$Linter_ts$createDiagnosticsPrinter(
						request,
						this.createDiagnosticsProcessor(evictedPaths, runner),
						totalCount,
						savedCount,
					);

					// Update our diagnostics with the changes
					for (const {filename, diagnostics} of changes) {
						if (diagnostics.length === 0) {
							diagnosticsByFilename.delete(filename);
						} else {
							diagnosticsByFilename.set(filename, diagnostics);
						}
					}

					// Print all diagnostics
					for (const diagnostics of diagnosticsByFilename.values()) {
						printer.processor.addDiagnostics(diagnostics);
					}

					reporter.clearScreen();
					await printer.print();
					await printer.footer();
				},
			});

			await request.endEvent.wait();
		}

		async runSingle() {
			const {request} = this;
			const {reporter} = request;
			const diagnosticsByFilename = new Map();

			let savedCount = 0;
			let paths = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet();

			const watchEvent = await this.watch({
				onRunStart: () => {},
				createProgress: (opts) => {
					return reporter.progress(opts);
				},
				onChanges: (res) => {
					// Update counts
					savedCount += res.savedCount;
					paths = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet([
						...paths,
						...res.evictedPaths,
					]);

					// Update our diagnostics with the changes
					for (const {filename, diagnostics} of res.changes) {
						if (diagnostics.length === 0) {
							diagnosticsByFilename.delete(filename);
						} else {
							diagnosticsByFilename.set(filename, diagnostics);
						}
					}
				},
			});

			await watchEvent.unsubscribe();

			const printer = ___R$$priv$project$rome$$internal$core$server$linter$Linter_ts$createDiagnosticsPrinter(
				request,
				this.createDiagnosticsProcessor(paths),
				paths.size,
				savedCount,
			);

			for (const diagnostics of diagnosticsByFilename.values()) {
				printer.processor.addDiagnostics(diagnostics);
			}

			return {printer, savedCount};
		}

		async throwSingle() {
			const {printer} = await this.runSingle();
			throw printer;
		}
	}


  // project-rome/@internal/core/server/lsp/protocol.ts
const ___R$$priv$project$rome$$internal$core$server$lsp$protocol_ts$HEADERS_END = "\r\n\r\n";

	function ___R$$priv$project$rome$$internal$core$server$lsp$protocol_ts$parseHeaders(
		buffer,
	) {
		const headers = new Map();

		for (const line of buffer.split("\n")) {
			const clean = line.trim();
			const match = clean.match(/^(.*?): (.*?)$/);
			if (match == null) {
				throw new Error("Invalid header: " + clean);
			}

			const [, key, value] = match;
			headers.set(key.toLowerCase(), value);
		}

		const length = headers.get("content-length");
		if (length === undefined) {
			throw new Error("Expected Content-Length");
		}
		headers.delete("content-length");

		return {
			expectedLength: Number(length),
			extra: headers,
		};
	}

	class ___R$project$rome$$internal$core$server$lsp$protocol_ts$LSPTransport {
		constructor(reporter) {
			this.status = "IDLE";
			this.nextHeaders = undefined;
			this.buffer = "";
			this.bufferLength = 0;
			this.reporter = reporter;
			this.requestIdCounter = 0;
			this.requestCallbacks = new Map();

			this.requestEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "request",
			});
			this.notificationEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "notification",
			});
			this.writeEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "write",
			});
			this.errorEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "error",
			});
		}

		write(res) {
			const json = JSON.stringify(res);
			const out =
				"Content-Length: " +
				Buffer.byteLength(json) +
				___R$$priv$project$rome$$internal$core$server$lsp$protocol_ts$HEADERS_END +
				json;
			this.writeEvent.send(out);
		}

		async request(req) {
			return new Promise((resolve, reject) => {
				const id = ++this.requestIdCounter;
				this.requestCallbacks.set(id, {resolve, reject});
				this.write(Object.assign({}, req, {id}));
			});
		}

		normalizeMessage(content) {
			try {
				const data = JSON.parse(content);
				const consumer = ___R$project$rome$$internal$consume$index_ts$consumeUnknown(
					data,
					"lsp/parse",
				);
				return consumer;
			} catch (err) {
				if (err instanceof SyntaxError) {
					console.error("JSON parse error", content);
					return undefined;
				} else {
					throw err;
				}
			}
		}

		async onMessage(headers, content) {
			const consumer = this.normalizeMessage(content);
			if (consumer === undefined) {
				return;
			}

			if (!consumer.has("method")) {
				if (!consumer.has("id")) {
					return;
				}
				const id = consumer.get("id").asNumber();
				const callbacks = this.requestCallbacks.get(id);
				this.requestCallbacks.delete(id);
				if (callbacks === undefined) {
					return;
				}
				if (consumer.has("result")) {
					callbacks.resolve(consumer.get("result"));
				} else if (consumer.has("error")) {
					callbacks.reject(consumer.get("error"));
				}
				return;
			}

			const method = consumer.get("method").asString();
			const params = consumer.get("params");

			if (consumer.has("id")) {
				const id = consumer.get("id").asNumber();

				try {
					let result = null;
					if (this.requestEvent.hasSubscriptions()) {
						result = await this.requestEvent.call({method, params});
					}
					const res = {
						id,
						result,
					};
					this.write(res);
				} catch (err) {
					const res = {
						id,
						error: {
							code: -32_603,
							message: err.message,
						},
					};
					this.write(res);
				}
			} else {
				await this.notificationEvent.callOptional({method, params});
			}
		}

		log(message) {
			this.reporter.info(
				___R$project$rome$$internal$markup$escape_ts$markup` ${message}`,
			);
		}

		setStatus(status) {
			this.status = status;
			this.log(
				___R$project$rome$$internal$markup$escape_ts$markup`Status: ${status}`,
			);
		}

		process() {
			switch (this.status) {
				case "IDLE": {
					if (this.bufferLength > 0) {
						this.setStatus("WAITING_FOR_HEADERS_END");
						this.process();
					}
					break;
				}

				case "WAITING_FOR_HEADERS_END": {
					const endIndex = this.buffer.indexOf(
						___R$$priv$project$rome$$internal$core$server$lsp$protocol_ts$HEADERS_END,
					);
					if (endIndex !== -1) {
						// Parse headers
						const rawHeaders = this.buffer.slice(0, endIndex);
						this.nextHeaders = ___R$$priv$project$rome$$internal$core$server$lsp$protocol_ts$parseHeaders(
							rawHeaders,
						);
						this.log(
							___R$project$rome$$internal$markup$escape_ts$markup`Headers for next message: ${___R$project$rome$$internal$pretty$format$index_ts$default(
								this.nextHeaders,
							)}`,
						);

						// Process rest of the buffer
						this.setStatus("WAITING_FOR_RESPONSE_END");
						this.buffer = this.buffer.slice(
							endIndex +
							___R$$priv$project$rome$$internal$core$server$lsp$protocol_ts$HEADERS_END.length,
						);
						this.process();
					}
					break;
				}

				case "WAITING_FOR_RESPONSE_END": {
					const headers = this.nextHeaders;
					if (headers === undefined) {
						throw new Error("Expected headers due to our status");
					}
					if (this.bufferLength >= headers.expectedLength) {
						const content = this.buffer.slice(0, headers.expectedLength);
						this.onMessage(headers, content).catch((err) => {
							this.errorEvent.send(err, true);
						});
						this.log(
							___R$project$rome$$internal$markup$escape_ts$markup`Received message content: ${content}`,
						);

						// Reset headers and trim content
						this.nextHeaders = undefined;
						this.buffer = this.buffer.slice(headers.expectedLength);
						this.bufferLength = Buffer.byteLength(this.buffer);

						// Process rest of the buffer
						this.setStatus("IDLE");
						this.process();
					}
					break;
				}
			}
		}

		append(data) {
			this.buffer += data;
			this.bufferLength += Buffer.byteLength(data);
			this.process();
		}
	}


  // project-rome/@internal/core/server/lsp/LSPProgress.ts
let ___R$$priv$project$rome$$internal$core$server$lsp$LSPProgress_ts$progressTokenCounter = 0;

	// The server can sometimes emit progress bars to all connected clients.
	// This allows us to send those same progress events over the LSP.

	class ___R$project$rome$$internal$core$server$lsp$LSPProgress_ts$default
		extends ___R$project$rome$$internal$cli$reporter$ProgressBase_ts$default {
		constructor(transport, reporter, opts) {
			super(reporter, opts);
			this.transport = transport;
			this.token = ___R$$priv$project$rome$$internal$core$server$lsp$LSPProgress_ts$progressTokenCounter++;
			this.lastRenderKey = "";

			transport.write({
				type: "$/progress",
				params: {
					token: this.token,
					value: {
						kind: "begin",
						cancellable: false,
						title: this.title,
						percentage: 0,
					},
				},
			});
		}

		render() {
			const total = this.total === undefined ? 0 : this.total;
			const percentage = Math.floor(100 / total * this.current);

			// Make sure we don't send pointless duplicate messages
			const renderKey = "percent:" + percentage + ",text:" + this.text;
			if (this.lastRenderKey === renderKey) {
				return;
			}

			this.lastRenderKey = renderKey;
			this.transport.write({
				type: "$/progress",
				params: {
					token: this.token,
					value: {
						kind: "report",
						cancellable: false,
						message: this.text === undefined
							? ""
							: ___R$project$rome$$internal$cli$layout$format_ts$markupToJoinedPlainText(
									this.text,
								),
						percentage,
					},
				},
			});
		}

		end() {
			this.transport.write({
				type: "$/progress",
				params: {
					token: this.token,
					value: {
						kind: "end",
					},
				},
			});
		}
	}


  // project-rome/@internal/core/server/lsp/utils.ts
function ___R$project$rome$$internal$core$server$lsp$utils_ts$convertPositionToLSP(
		pos,
	) {
		if (pos === undefined) {
			return {
				line: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
				character: ___R$project$rome$$internal$ob1$index_ts$ob1Number0,
			};
		} else {
			return {
				line: ___R$project$rome$$internal$ob1$index_ts$ob1Coerce1To0(pos.line),
				character: pos.column,
			};
		}
	}

	function ___R$project$rome$$internal$core$server$lsp$utils_ts$convertDiagnosticLocationToLSPRange(
		location,
	) {
		return {
			start: ___R$project$rome$$internal$core$server$lsp$utils_ts$convertPositionToLSP(
				location.start,
			),
			end: ___R$project$rome$$internal$core$server$lsp$utils_ts$convertPositionToLSP(
				location.end,
			),
		};
	}

	function ___R$project$rome$$internal$core$server$lsp$utils_ts$convertDiagnosticsToLSP(
		diagnostics,
		server,
	) {
		const lspDiagnostics = [];

		for (const {description, location} of diagnostics) {
			// Infer relatedInformation from log messages followed by frames
			let relatedInformation = [];
			const {advice} = description;
			for (let i = 0; i < advice.length; i++) {
				const item = advice[i];
				const nextItem = advice[i + 1];
				if (
					item.type === "log" &&
					nextItem !== undefined &&
					nextItem.type === "frame"
				) {
					const abs = server.projectManager.getFilePathFromUidOrAbsolute(
						nextItem.location.filename,
					);
					if (abs !== undefined) {
						relatedInformation.push({
							message: ___R$project$rome$$internal$cli$layout$format_ts$markupToJoinedPlainText(
								item.text,
							),
							location: {
								uri: "file://" + abs.join(),
								range: ___R$project$rome$$internal$core$server$lsp$utils_ts$convertDiagnosticLocationToLSPRange(
									nextItem.location,
								),
							},
						});
					}
				}
			}

			lspDiagnostics.push({
				severity: 1,
				range: ___R$project$rome$$internal$core$server$lsp$utils_ts$convertDiagnosticLocationToLSPRange(
					location,
				),
				message: ___R$project$rome$$internal$cli$layout$format_ts$markupToJoinedPlainText(
					description.message,
				),
				code: description.category,
				source: "rome",
				relatedInformation,
			});
		}

		return lspDiagnostics;
	}

	function ___R$project$rome$$internal$core$server$lsp$utils_ts$getPathFromTextDocument(
		consumer,
	) {
		return ___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
			consumer.get("uri").asString(),
		);
	}

	function ___R$project$rome$$internal$core$server$lsp$utils_ts$diffTextEdits(
		original,
		desired,
	) {
		const edits = [];

		const diffs = ___R$project$rome$$internal$string$diff$index_ts$default(
			original,
			desired,
		);

		let currLine = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;
		let currChar = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;

		function advance(str) {
			for (const char of str) {
				if (char === "\n") {
					currLine = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(currLine);
					currChar = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;
				} else {
					currChar = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(currChar);
				}
			}
		}

		function getPosition() {
			return {
				line: currLine,
				character: currChar,
			};
		}

		for (const [type, text] of diffs) {
			switch (type) {
				case ___R$project$rome$$internal$string$diff$index_ts$diffConstants.ADD: {
					const pos = getPosition();
					edits.push({
						range: {
							start: pos,
							end: pos,
						},
						newText: text,
					});
					break;
				}

				case ___R$project$rome$$internal$string$diff$index_ts$diffConstants.DELETE: {
					const start = getPosition();
					advance(text);
					const end = getPosition();
					edits.push({
						range: {
							start,
							end,
						},
						newText: "",
					});
					break;
				}

				case ___R$project$rome$$internal$string$diff$index_ts$diffConstants.EQUAL: {
					advance(text);
					break;
				}
			}
		}

		return edits;
	}

	function ___R$project$rome$$internal$core$server$lsp$utils_ts$getLSPRange(
		range,
	) {
		const start = range.get("start");
		const end = range.get("end");

		return {
			start: {
				line: start.get("line").asZeroIndexedNumber(),
				character: start.get("character").asZeroIndexedNumber(),
			},
			end: {
				line: end.get("line").asZeroIndexedNumber(),
				character: end.get("character").asZeroIndexedNumber(),
			},
		};
	}

	function ___R$project$rome$$internal$core$server$lsp$utils_ts$getWorkerBufferPatches(
		contentChanges,
	) {
		return contentChanges.asMappedArray((change) => {
			const range = ___R$project$rome$$internal$core$server$lsp$utils_ts$getLSPRange(
				change.get("range"),
			);

			return {
				text: change.get("text").asString(),
				range,
			};
		});
	}

	function ___R$project$rome$$internal$core$server$lsp$utils_ts$getDecisionFromAdviceAction(
		advice,
	) {
		const decisions =
			(advice == null ? undefined : advice.commandFlags) == null
				? undefined
				: (advice == null ? undefined : advice.commandFlags).decisions;
		if (Array.isArray(decisions)) {
			return decisions[0];
		}
		return;
	}

	function ___R$project$rome$$internal$core$server$lsp$utils_ts$doRangesOverlap(
		a,
		b,
	) {
		if (a.start.line > b.end.line || b.start.line > a.end.line) {
			return false;
		}
		if (a.start.line === b.end.line && a.start.character > b.end.character) {
			return false;
		}
		if (b.start.line === a.end.line && b.start.character > a.end.character) {
			return false;
		}
		return true;
	}


  // project-rome/@internal/core/server/lsp/LSPServer.ts
class ___R$project$rome$$internal$core$server$lsp$LSPServer_ts$default {
		constructor(request) {
			this.request = request;
			this.server = request.server;
			this.client = request.client;

			this.lintSessionsPending = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet();
			this.lintSessions = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
			this.fileBuffers = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet();
			this.fileVersions = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
			this.pathToDiagnostics = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();

			this.watchProjectEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "watchProject",
			});

			request.endEvent.subscribe(async () => {
				await this.shutdown();
			});

			const transport = new ___R$project$rome$$internal$core$server$lsp$protocol_ts$LSPTransport(
				this.server.logger,
			);
			this.transport = transport;

			transport.notificationEvent.subscribe(({method, params}) => {
				return this.handleNotification(method, params);
			});

			transport.requestEvent.subscribe(({method, params}) => {
				return this.handleRequest(method, params);
			});

			transport.errorEvent.subscribe((err) => {
				request.server.onFatalError(err);
			});
		}

		logMessage(path, message) {
			this.server.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`[LSPServer] ${message}`,
			);
			this.transport.write({
				method: "window/logMessage",
				params: {
					uri: "file://" + path.join(),
					message,
				},
			});
		}

		logDiagnostics(path, diagnostics = []) {
			if (diagnostics.length === 0) {
				return;
			}

			const lines = [];
			const date = new Date();

			lines.push("[Diagnostics - " + date.toTimeString() + "] " + path.join());
			for (const diag of diagnostics) {
				lines.push(
					"  (" +
					diag.description.category +
					") " +
					___R$project$rome$$internal$markup$escape_ts$readMarkup(
						diag.description.message,
					),
				);
			}
			this.logMessage(path, lines.join("\n"));
		}

		createFakeServerRequest(commandName, args = []) {
			return new ___R$project$rome$$internal$core$server$ServerRequest_ts$default({
				client: this.client,
				server: this.server,
				query: {
					requestFlags: ___R$project$rome$$internal$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS,
					commandFlags: {},
					args,
					commandName,
					silent: true,
					noData: false,
					noFileWrites: false,
					terminateWhenIdle: false,
				},
			});
		}

		unwatchProject(path) {
			// TODO maybe unset all buffers?
			const req = this.lintSessions.get(path);
			if (req !== undefined) {
				this.server.wrapFatalPromise(
					req.teardown(
						___R$project$rome$$internal$core$server$ServerRequest_ts$EMPTY_SUCCESS_RESPONSE,
					),
				);
				this.lintSessions.delete(path);
			}
		}

		createProgress(opts) {
			return new ___R$project$rome$$internal$core$server$lsp$LSPProgress_ts$default(
				this.transport,
				this.request.reporter,
				opts,
			);
		}

		async initProject(path) {
			if (this.lintSessions.has(path) || this.lintSessionsPending.has(path)) {
				return;
			}

			this.lintSessionsPending.add(path);

			const project = await this.server.projectManager.findProject(path);

			if (project === undefined) {
				// Not a Rome project
				this.lintSessionsPending.delete(path);
				return;
			}

			const req = this.createFakeServerRequest("lsp_project", [path.join()]);
			await req.init();

			// This is not awaited so it doesn't delay the initialize response
			this.server.wrapFatalPromise(this.watchProject(path, req));
		}

		async watchProject(path, req) {
			const linter = new ___R$project$rome$$internal$core$server$linter$Linter_ts$default(
				req,
				{
					apply: false,
					hasDecisions: false,
					formatOnly: false,
					suppressionExplanation: "suppressed via editor",
				},
			);

			const subscription = await linter.watch({
				onRunStart: () => {},
				createProgress: () => {
					return this.createProgress();
				},
				onChanges: ({changes}) => {
					for (const {type, filename, diagnostics} of changes) {
						if (filename === undefined || type !== "absolute") {
							// Can only display absolute path diagnostics
							continue;
						}

						// We want to filter pendingFixes because we'll autoformat the file on save if necessary and it's just noise
						const processor = this.request.createDiagnosticsProcessor();
						processor.addFilter({
							category: "lint/pendingFixes",
						});
						processor.addDiagnostics(diagnostics);

						this.pathToDiagnostics.set(
							___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
								filename,
							),
							processor.getDiagnostics(),
						);

						this.transport.write({
							method: "textDocument/publishDiagnostics",
							params: {
								uri: "file://" + filename,
								diagnostics: ___R$project$rome$$internal$core$server$lsp$utils_ts$convertDiagnosticsToLSP(
									processor.getDiagnostics(),
									this.server,
								),
							},
						});
					}
				},
			});

			req.endEvent.subscribe(() => {
				subscription.unsubscribe();
			});

			this.lintSessions.set(path, req);
			this.lintSessionsPending.delete(path);

			const date = new Date();
			this.logMessage(
				path,
				"Watching " + path.join() + " at " + date.toTimeString(),
			);
			this.watchProjectEvent.send(path);
		}

		async shutdown() {
			// Unwatch projects
			for (const path of this.lintSessions.keys()) {
				this.unwatchProject(path);
			}
			this.lintSessions.clear();

			// Clear set buffers
			for (const path of this.fileBuffers) {
				await this.request.requestWorkerClearBuffer(path);
			}
			this.fileBuffers.clear();
		}

		async sendClientRequest(req) {
			return this.server.handleRequest(
				this.client,
				Object.assign({silent: true}, req),
			);
		}

		async handleRequest(method, params) {
			switch (method) {
				case "initialize": {
					const rootUri = params.get("rootUri");
					if (rootUri.exists()) {
						await this.initProject(
							___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
								rootUri.asString(),
							),
						);
					}

					const workspaceDirectories = params.get("workspaceDirectories");
					if (workspaceDirectories.exists()) {
						for (const elem of workspaceDirectories.asIterable()) {
							await this.initProject(
								___R$project$rome$$internal$core$server$lsp$utils_ts$getPathFromTextDocument(
									elem,
								),
							);
						}
					}

					return {
						capabilities: {
							textDocumentSync: {
								openClose: true,
								// This sends over incremental patches on change
								change: 2,
							},
							documentFormattingProvider: true,
							codeActionProvider: true,
							executeCommandProvider: {
								commands: ["rome.check.decisions", "rome.check.apply"],
							},
							workspaceDirectories: {
								supported: true,
								changeNotifications: true,
							},
						},
						serverInfo: {
							name: "rome",
						},
					};
				}

				case "textDocument/codeAction": {
					const path = ___R$project$rome$$internal$core$server$lsp$utils_ts$getPathFromTextDocument(
						params.get("textDocument"),
					);
					const codeActionRange = ___R$project$rome$$internal$core$server$lsp$utils_ts$getLSPRange(
						params.get("range"),
					);

					const codeActions = [];
					const seenDecisions = new Set();

					const diagnostics = this.pathToDiagnostics.get(path);
					if (diagnostics === undefined) {
						return codeActions;
					}

					for (const diag of diagnostics) {
						const diagRange = ___R$project$rome$$internal$core$server$lsp$utils_ts$convertDiagnosticLocationToLSPRange(
							diag.location,
						);

						if (
							!___R$project$rome$$internal$core$server$lsp$utils_ts$doRangesOverlap(
								diagRange,
								codeActionRange,
							)
						) {
							continue;
						}
						for (const advice of diag.description.advice) {
							if (advice.type !== "action" || advice.extra === true) {
								continue;
							}

							const decision = ___R$project$rome$$internal$core$server$lsp$utils_ts$getDecisionFromAdviceAction(
								advice,
							);
							if (decision === undefined || seenDecisions.has(decision)) {
								continue;
							}
							seenDecisions.add(decision);

							codeActions.push({
								title: ___R$project$rome$$internal$markup$escape_ts$readMarkup(
									advice.noun,
								) +
								": " +
								diag.description.category,
								command: {
									title: "Rome: Check",
									command: "rome.check.decisions",
									arguments: [path.join(), decision],
								},
							});
						}
					}

					codeActions.push({
						title: "Rome: Fix All",
						kind: "source.fixAll.rome",
						command: {
							title: "Rome: Fix All",
							command: "rome.check.apply",
							arguments: [path.join()],
						},
					});

					return codeActions;
				}

				case "workspace/executeCommand": {
					const command = params.get("command").asString();
					const filename = params.get("arguments").getIndex(0).asString();

					const path = ___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
						filename,
					);
					const startVersion = this.fileVersions.get(path);

					let req;

					if (command === "rome.check.apply") {
						req = {
							commandName: "check",
							args: [filename],
							commandFlags: {apply: true},
							noFileWrites: true,
						};
					}

					if (command === "rome.check.decisions") {
						const decisions = params.get("arguments").getIndex(1).asString();
						req = {
							commandName: "check",
							args: [filename],
							commandFlags: {decisions},
							noFileWrites: true,
						};
					}

					if (req === undefined) {
						return null;
					}

					const response = await this.sendClientRequest(req);

					if (response.type === "SUCCESS" || response.type === "DIAGNOSTICS") {
						const original = await this.request.requestWorkerGetBuffer(path);
						const saveFile = response.files[filename];
						if (original === undefined || saveFile === undefined) {
							return null;
						}
						const endVersion = this.fileVersions.get(path);
						if (startVersion !== endVersion) {
							this.logMessage(
								path,
								"Can't update " + filename + " because it was modified,",
							);
							return null;
						}

						const edits = ___R$project$rome$$internal$core$server$lsp$utils_ts$diffTextEdits(
							original,
							saveFile.content,
						);

						await this.transport.request({
							method: "workspace/applyEdit",
							params: {
								label: "Rome Action",
								edit: {
									documentChanges: [
										{
											textDocument: {
												uri: "file://" + filename,
												version: endVersion,
											},
											edits,
										},
									],
								},
							},
						});
					}

					return null;
				}

				case "textDocument/formatting": {
					const path = ___R$project$rome$$internal$core$server$lsp$utils_ts$getPathFromTextDocument(
						params.get("textDocument"),
					);

					const project = this.server.projectManager.findLoadedProject(path);
					if (project === undefined) {
						// Not in a Rome project
						return null;
					}

					const {value, diagnostics} = await ___R$project$rome$$internal$diagnostics$wrap_ts$catchDiagnostics(async () => {
						return this.request.requestWorkerFormat(path, {}, {});
					});

					this.logDiagnostics(path, diagnostics);

					if (value === undefined) {
						// Not a file we support formatting or has diagnostics
						return null;
					}

					return ___R$project$rome$$internal$core$server$lsp$utils_ts$diffTextEdits(
						value.original,
						value.formatted,
					);
				}

				case "shutdown": {
					await this.shutdown();
					break;
				}
			}

			return null;
		}

		async handleNotification(method, params) {
			switch (method) {
				case "workspace/didChangeWorkspaceDirectories": {
					for (const elem of params.get("added").asIterable()) {
						await this.initProject(
							___R$project$rome$$internal$core$server$lsp$utils_ts$getPathFromTextDocument(
								elem,
							),
						);
					}
					for (const elem of params.get("removed").asIterable()) {
						this.unwatchProject(
							___R$project$rome$$internal$core$server$lsp$utils_ts$getPathFromTextDocument(
								elem,
							),
						);
					}
					break;
				}

				case "textDocument/didOpen": {
					const textDocument = params.get("textDocument");
					const path = ___R$project$rome$$internal$core$server$lsp$utils_ts$getPathFromTextDocument(
						textDocument,
					);
					const project = this.server.projectManager.findLoadedProject(path);
					if (project === undefined) {
						return;
					}
					this.fileVersions.set(path, textDocument.get("version").asNumber());
					const content = textDocument.get("text").asString();
					await this.request.requestWorkerUpdateBuffer(path, content);
					this.fileBuffers.add(path);
					this.logMessage(path, "Opened: " + path.join());
					break;
				}

				case "textDocument/didChange": {
					const textDocument = params.get("textDocument");
					const path = ___R$project$rome$$internal$core$server$lsp$utils_ts$getPathFromTextDocument(
						textDocument,
					);
					if (!this.fileBuffers.has(path)) {
						return;
					}
					this.fileVersions.set(path, textDocument.get("version").asNumber());
					const contentChanges = params.get("contentChanges");

					if (contentChanges.getIndex(0).has("range")) {
						const patches = ___R$project$rome$$internal$core$server$lsp$utils_ts$getWorkerBufferPatches(
							contentChanges,
						);
						await this.request.requestWorkerPatchBuffer(path, patches);
					} else {
						const content = contentChanges.getIndex(0).get("text").asString();
						await this.request.requestWorkerUpdateBuffer(path, content);
					}
					break;
				}

				case "textDocument/didClose": {
					const path = ___R$project$rome$$internal$core$server$lsp$utils_ts$getPathFromTextDocument(
						params.get("textDocument"),
					);
					if (!this.fileBuffers.has(path)) {
						return;
					}
					this.fileBuffers.delete(path);
					this.fileVersions.delete(path);
					await this.request.requestWorkerClearBuffer(path);
					this.logMessage(path, "Closed: " + path.join());
					break;
				}
			}
		}
	}


  // project-rome/@internal/core/server/commands/lsp.ts
const ___R$project$rome$$internal$core$server$commands$lsp_ts$default = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.PROJECT_MANAGEMENT,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`TODO`,
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback(req) {
			const {server, bridge, reporter} = req;

			// This way we can still log stuff since it'll be redirected to stderr and stdout will be reserved for messages
			reporter.redirectOutToErr(true);

			const lsp = new ___R$project$rome$$internal$core$server$lsp$LSPServer_ts$default(
				req,
			);
			server.onLSPServer(req, lsp);

			const {transport} = lsp;

			bridge.lspFromClientBuffer.subscribe((chunk) => {
				transport.append(chunk);
			});

			transport.writeEvent.subscribe((msg) => {
				bridge.lspFromServerBuffer.send(msg);
			});

			await req.endEvent.wait();
		},
	});


  // project-rome/@internal/core/server/commands/check.ts
let ___R$$priv$project$rome$$internal$core$server$commands$check_ts$cachedSuppressionExplanation;
	const ___R$project$rome$$internal$core$server$commands$check_ts$default = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.CODE_QUALITY,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`run lint against a set of files`,
		allowRequestFlags: ["watch", "review"],
		usage: "",
		examples: [],
		defineFlags(consumer) {
			return {
				decisions: consumer.get("decisions").asImplicitMappedArray((item) =>
					item.asString()
				),
				apply: consumer.get(
					"apply",
					{
						description: ___R$project$rome$$internal$markup$escape_ts$markup`apply safe fixes and formatting`,
					},
				).asBoolean(false),
				formatOnly: consumer.get(
					"formatOnly",
					{
						description: ___R$project$rome$$internal$markup$escape_ts$markup`only formatting is applied`,
					},
				).asBoolean(false),
				changed: consumer.get(
					"changed",
					{
						description: ___R$project$rome$$internal$markup$escape_ts$markup`only include files that have changed from the specified branch/commit (defaults to main)`,
					},
				).asStringOrVoid(),
				suppressionExplanation: consumer.get(
					"suppressionExplanation",
					{
						description: ___R$project$rome$$internal$markup$escape_ts$markup`insert a predefined explanation for suppressions`,
					},
				).asStringOrVoid(),
			};
		},
		async callback(req, flags) {
			if (flags.suppressionExplanation) {
				___R$$priv$project$rome$$internal$core$server$commands$check_ts$cachedSuppressionExplanation = flags.suppressionExplanation;
			}

			const {reporter} = req;

			let lintCompilerOptionsPerFile = {};
			let globalDecisions = [];
			const {decisions} = flags;
			if (decisions !== undefined) {
				({lintCompilerOptionsPerFile, globalDecisions} = ___R$project$rome$$internal$compiler$lint$decisions_ts$parseDecisionStrings(
					decisions,
					req.client.flags.cwd,
					(description) => {
						throw req.throwDiagnosticFlagError({
							description,
							target: {type: "flag", key: "decisions"},
						});
					},
				));
			}

			// Look up arguments manually in vsc if we were passed a changes branch
			let args;
			if (flags.changed !== undefined) {
				// No arguments expected when using this flag
				req.expectArgumentLength(0);

				const client = await req.getVCSClient();
				const target =
					flags.changed === "" ? await client.getDefaultBranch() : flags.changed;
				args = await client.getModifiedFiles(target);

				// Only include lintable files
				args = args.filter((arg) => {
					const path = ___R$project$rome$$internal$path$index_ts$createUnknownPath(
						arg,
					);

					for (const ext of ___R$project$rome$$internal$core$common$file$handlers$index_ts$LINTABLE_EXTENSIONS) {
						if (path.hasEndExtension(ext)) {
							return true;
						}
					}

					return false;
				});

				if (args.length === 0) {
					reporter.warn(
						___R$project$rome$$internal$markup$escape_ts$markup`No files changed from <emphasis>${target}</emphasis>`,
					);
				} else {
					reporter.info(
						___R$project$rome$$internal$markup$escape_ts$markup`Files changed from <emphasis>${target}</emphasis>`,
					);
					reporter.list(
						args.map((arg) =>
							___R$project$rome$$internal$markup$escape_ts$markup`<filelink target="${arg}" />`
						),
					);
					reporter.hr();
				}
			}

			const opts = {
				hasDecisions: flags.decisions.length > 0,
				lintCompilerOptionsPerFile,
				globalDecisions,
				apply: flags.apply,
				formatOnly: flags.formatOnly,
				suppressionExplanation: ___R$$priv$project$rome$$internal$core$server$commands$check_ts$cachedSuppressionExplanation,
				args,
			};
			const linter = new ___R$project$rome$$internal$core$server$linter$Linter_ts$default(
				req,
				opts,
			);
			if (req.query.requestFlags.watch) {
				await linter.runWatch();
			} else {
				await linter.throwSingle();
			}
		},
	});


  // project-rome/@internal/core/server/testing/utils.ts
function ___R$project$rome$$internal$core$server$testing$utils_ts$sortMapKeys(
		map,
	) {
		const sortedKeys = Array.from(map.keys()).sort(
			___R$project$rome$$internal$string$utils$naturalCompare_ts$naturalCompare,
		);
		const newMap = new Map();
		for (const key of sortedKeys) {
			const val = map.get(key);
			if (val === undefined) {
				throw new Error("Expected value");
			}
			newMap.set(key, val);
		}
		return newMap;
	}

	function ___R$project$rome$$internal$core$server$testing$utils_ts$formatPercent(
		num,
	) {
		const str = ___R$project$rome$$internal$markup$escape_ts$markup`${Math.floor(
			num,
		)}`;
		if (num > 80) {
			return ___R$project$rome$$internal$markup$escape_ts$markup`<success>${str}</success>`;
		} else if (num > 40) {
			return ___R$project$rome$$internal$markup$escape_ts$markup`<warn>${str}</warn>`;
		} else {
			return ___R$project$rome$$internal$markup$escape_ts$markup`<error>${str}</error>`;
		}
	}

	function ___R$project$rome$$internal$core$server$testing$utils_ts$percentInsideCoverageDirectory(
		directory,
	) {
		let totalFiles = 0;
		let functions = 0;
		let branches = 0;
		let lines = 0;

		const directories = [directory];
		while (directories.length > 0) {
			const directory = directories.shift();

			for (const file of directory.files.values()) {
				totalFiles++;
				functions += file.functions.percent;
				branches += file.branches.percent;
				lines += file.lines.percent;
			}

			for (const subDirectory of directory.directories.values()) {
				directories.push(subDirectory);
			}
		}

		return {
			functions: totalFiles === 0 ? 100 : functions / totalFiles,
			branches: totalFiles === 0 ? 100 : branches / totalFiles,
			lines: totalFiles === 0 ? 100 : lines / totalFiles,
		};
	}


  // project-rome/@internal/core/common/utils/fork.ts
const ___R$$priv$project$rome$$internal$core$common$utils$fork_ts$workerThreads = require(
		"worker_threads",
	);
	const ___R$$priv$project$rome$$internal$core$common$utils$fork_ts$child = require(
		"child_process",
	);
	function ___R$$priv$project$rome$$internal$core$common$utils$fork_ts$createEnv(
		processType,
	) {
		return Object.assign(
			{},
			process.env,
			{
				ROME_PROCESS_VERSION: ___R$project$rome$$internal$core$common$constants_ts$VERSION,
				ROME_PROCESS_TYPE: processType,
			},
		);
	}

	function ___R$project$rome$$internal$core$common$utils$fork_ts$forkProcess(
		processType,
		opts = {},
		args = [],
	) {
		return ___R$$priv$project$rome$$internal$core$common$utils$fork_ts$child.fork(
			___R$project$rome$$internal$core$common$constants_ts$getBinPath().join(),
			args,
			Object.assign(
				{
					stdio: "inherit",
					execArgv: ___R$project$rome$$internal$core$common$constants_ts$CHILD_ARGS,
				},
				opts,
				{
					env: ___R$$priv$project$rome$$internal$core$common$utils$fork_ts$createEnv(
						processType,
					),
				},
			),
		);
	}

	function ___R$project$rome$$internal$core$common$utils$fork_ts$forkThread(
		processType,
		opts = {},
	) {
		return new ___R$$priv$project$rome$$internal$core$common$utils$fork_ts$workerThreads.Worker(
			"require(" +
			JSON.stringify(
				___R$project$rome$$internal$core$common$constants_ts$getBinPath().join(),
			) +
			");",
			Object.assign(
				{},
				opts,
				{
					eval: true,
					env: ___R$$priv$project$rome$$internal$core$common$utils$fork_ts$createEnv(
						processType,
					),
				},
			),
		);
	}


  // project-rome/@internal/core/server/testing/TestServerWorker.ts
const ___R$$priv$project$rome$$internal$core$server$testing$TestServerWorker_ts$workerThreads = require(
		"worker_threads",
	);
	class ___R$project$rome$$internal$core$server$testing$TestServerWorker_ts$default {
		constructor({server, request, runner, flags}) {
			this.server = server;
			this.runner = runner;
			this.request = request;

			this.thread = ___R$project$rome$$internal$core$common$utils$fork_ts$forkThread(
				"test-worker",
				{
					workerData: flags,
					stdin: true,
					stdout: true,
					stderr: true,
				},
			);

			this.bridge = ___R$project$rome$$internal$events$bridgeCreators_ts$createBridgeFromWorkerThread(
				___R$project$rome$$internal$core$common$bridges$TestWorkerBridge_ts$default,
				this.thread,
				{
					type: "client",
				},
			);

			this.inspector = undefined;

			this.prepareLock = new ___R$project$rome$$internal$async$lockers_ts$FilePathLocker();
			this.preparedPaths = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet();
			this.transferredCompiled = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet();
		}

		async init() {
			const {thread, bridge, runner} = this;
			const {stdout, stderr} = thread;

			stdout.on(
				"data",
				(chunk) => {
					process.stdout.write(chunk);
				},
			);

			// Suppress any debugger logs
			stderr.on(
				"data",
				(chunk) => {
					const str = chunk.toString();

					if (str.startsWith("Waiting for the debugger to disconnect...")) {
						if (this.inspector !== undefined) {
							this.inspector.end();
							return;
						}
					}

					process.stderr.write(chunk);
				},
			);

			await bridge.handshake();

			bridge.monitorHeartbeat(
				5_000,
				async () => {
					this.server.wrapFatalPromise(this.handleTimeout("10 seconds"));
				},
			);

			// Start debugger
			const {inspectorUrl} = await bridge.inspectorDetails.call();
			if (inspectorUrl !== undefined) {
				const client = new ___R$project$rome$$internal$v8$InspectorClient_ts$default(
					await ___R$project$rome$$internal$codec$websocket$index_ts$createClient(
						inspectorUrl,
					),
				);
				this.inspector = client;

				await client.call("Debugger.enable");

				// When a debugger is attached there's always a "Debugger attached" log emitted
				// This is written to stderr from native and there's no way for us to intercept it, and no way to disable it
				// https://github.com/nodejs/node/issues/34799
				// Until we have a way to disable it we need to resort to grossness like this...
				process.stderr.write(
					___R$project$rome$$internal$cli$layout$ansi_ts$ansiEscapes.cursorUp(),
				);
				process.stderr.write(
					___R$project$rome$$internal$cli$layout$ansi_ts$ansiEscapes.eraseLine,
				);

				bridge.endEvent.subscribe(() => {
					client.end();
				});
			}

			bridge.testDiagnostic.subscribe(({testPath, diagnostic, origin}) => {
				if (testPath !== undefined) {
					this.runner.files.assert(testPath).onDiagnostics();
				}

				runner.printer.processor.addDiagnostic(diagnostic, origin);
			});
		}

		async handleTimeout(duration) {
			return new Promise((resolve, reject) => {
				const timeout = setTimeout(
					() => {
						resolve(
							this.bridge.end(
								"Test worker was unresponsive for " +
								duration +
								". We tried to collect some additional metadata but we timed out again trying to fetch it...",
							),
						);
					},
					3_000,
				);

				this._handleTimeout(duration).then(() => {
					clearTimeout(timeout);
					resolve();
				}).catch((err) => {
					clearTimeout(timeout);
					if (
						err instanceof
						___R$project$rome$$internal$v8$InspectorClient_ts$InspectorClientCloseError
					) {
						return this.bridge.end(
							"Test worker was unresponsive for " +
							duration +
							". We tried to collect some additional metadata but the inspector connection closed abruptly",
						);
					} else {
						reject(err);
					}
				});
			});
		}

		async _handleTimeout(duration) {
			const {inspector, bridge} = this;
			if (inspector === undefined) {
				bridge.end(
					"Test worker was unresponsive for " +
					duration +
					". There was no inspector connected so we were unable to capture stack frames before it was terminated.",
				);
				return undefined;
			}

			inspector.call("Debugger.pause");

			const params = await inspector.wait("Debugger.paused");

			const frames = [];

			const callFrames = Array.from(params.get("callFrames").asIterable()).slice(
				0,
				20,
			);
			for (const callFrame of callFrames) {
				const loc = callFrame.get("location");

				const resolved = this.runner.sourceMaps.assertApproxOriginalPositionFor(
					___R$project$rome$$internal$v8$utils_ts$urlToFilename(
						callFrame.get("url").asString(),
					),
					___R$project$rome$$internal$ob1$index_ts$ob1Coerce0To1(
						loc.get("lineNumber").asZeroIndexedNumber(),
					),
					loc.get("columnNumber").asZeroIndexedNumber(),
				);

				const name = callFrame.get("scopeChain").getIndex(0).get("name").asString(
					"",
				).split("$").pop();

				frames.push({
					resolvedLocation: resolved.found,
					typeName: undefined,
					functionName: name,
					methodName: undefined,
					filename: resolved.source,
					lineNumber: resolved.line,
					columnNumber: resolved.column,
					isTopLevel: false,
					isEval: false,
					isNative: false,
					isConstructor: false,
					isAsync: false,
				});
			}

			bridge.endWithError(
				new ___R$project$rome$$internal$core$server$testing$TestServer_ts$BridgeDiagnosticsError(
					___R$project$rome$$internal$diagnostics$derive_ts$deriveDiagnosticFromErrorStructure(
						{
							name: "Error",
							frames,
						},
						{
							description: {
								category: "tests/timeout",
								message: ___R$project$rome$$internal$markup$escape_ts$markup`Test worker was unresponsive for <emphasis>${duration}</emphasis>. Possible infinite loop. Below is a stack trace before the test was terminated.`,
								advice: [
									{
										type: "log",
										category: "info",
										text: ___R$project$rome$$internal$markup$escape_ts$markup`You can find the specific test that caused this by running <code>rome test --sync-tests</code>`,
									},
								],
							},
						},
					),
					bridge,
				),
			);
		}

		async prepareAll(progress, fileQueue) {
			const {inspector, runner} = this;
			const {options: opts} = runner;

			if (inspector !== undefined && opts.coverage) {
				await inspector.call("Profiler.enable");
				await inspector.call(
					"Profiler.startPreciseCoverage",
					{
						// Turning this on disables V8 optimizations https://v8.dev/blog/javascript-code-coverage#precise-coverage-(function-granularity)
						callCount: false,
						// Otherwise coverage will only have function granularity
						detailed: true,
					},
				);
			}

			while (fileQueue.length > 0) {
				const file = fileQueue.pop();
				await this.prepareTest({file, progress, partial: false});
			}
		}

		async prepareTest({file, progress, partial}) {
			const {bridge, runner} = this;
			const globalOptions = runner.options;
			const {ref, bundle} = file;
			const req = this.request;
			const {flags} = req.client;

			const path = ref.real;
			const lock = this.prepareLock.getNewLock(path);

			this.preparedPaths.add(path);

			let progressId;
			if (progress !== undefined) {
				progressId = progress.pushText(
					___R$project$rome$$internal$markup$escape_ts$markup`<filelink target="${ref.uid}" />`,
				);
			}

			try {
				const assembled = bundle.entry.js.assembled;

				// Transfer over compiled code that this test worker needs to assemble the file but doesn't have
				const pending = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
				for (const item of assembled) {
					if (item[0] === 1) {
						const path = item[1];
						if (!this.transferredCompiled.has(path)) {
							this.transferredCompiled.add(path);
							const compiled = bundle.bundler.compiles.get(path);
							if (compiled !== undefined) {
								pending.set(path, compiled.compiledCode);
							}
						}
					}
				}
				if (pending.size > 0) {
					await bridge.receiveCompiled.call(pending);
				}

				const {focusedTests, foundTests} = await bridge.prepareTest.call({
					globalOptions,
					partial,
					projectDirectory: req.server.projectManager.assertProjectExisting(
						ref.real,
					).directory.join(),
					path,
					cwd: flags.cwd.join(),
					assembled,
					logFound: true,
				});

				if (!partial) {
					for (const testName of foundTests) {
						runner.onTestFound({testName, path});
					}

					for (const test of focusedTests) {
						runner.focusedTests.push(test);
					}
				}
			} catch (err) {
				runner.handlePossibleBridgeError(err);
			}

			lock.release();

			if (progress !== undefined && progressId !== undefined) {
				progress.popText(progressId);
				progress.tick();
			}
		}

		async runTest() {
			const {bridge} = this;

			// Find a test we've already prepared
			for (const path of this.preparedPaths) {
				const file = this.runner.files.assert(path);

				for (const testName of file.getPendingTests()) {
					file.removePendingTest(testName);
					await this.prepareLock.waitLock(path);
					await bridge.runTest.call({
						path,
						testNames: [testName],
					});
					await this.runTest();
				}
			}

			// Prepare another
			while (this.runner.testFilesStack.length > 0) {
				const path = this.runner.testFilesStack.shift();
				const file = this.runner.files.assert(path);
				const pendingTests = file.getPendingTests();

				if (pendingTests.size === 0) {
					continue;
				} else {
					this.runner.testFilesStack.push(path);
				}

				await this.prepareTest({partial: true, file, progress: undefined});
				await this.runTest();
			}
		}

		async run() {
			const {bridge, thread, inspector, runner} = this;
			const {options: opts} = runner;

			try {
				const promises = [];
				for (let i = 0; i < 10; i++) {
					promises.push(this.runTest());
				}
				await Promise.all(promises);

				for (const path of this.preparedPaths) {
					const result = await bridge.teardownTest.call(path);
					await this.runner.files.assert(path).addResult(result);
				}
			} catch (err) {
				runner.handlePossibleBridgeError(err);
			} finally {
				if (inspector !== undefined) {
					if (opts.coverage) {
						if (inspector.alive) {
							const profile = await inspector.call(
								"Profiler.takePreciseCoverage",
							);
							runner.coverageCollector.addCoverage(
								profile.get("result").asAny(),
							);

							// Not really necessary but let's clean up anyway for completeness
							await inspector.call("Profiler.stopPreciseCoverage");
							await inspector.call("Profiler.disable");
						} else {
							// TODO log that we failed to fetch some coverage
						}
					}

					inspector.end();
				}

				await thread.terminate();
			}
		}
	}


  // project-rome/@internal/core/test-worker/SnapshotParser.ts
function ___R$$priv$project$rome$$internal$core$test$worker$SnapshotParser_ts$isHash(
		char,
	) {
		return char === "#";
	}

	function ___R$$priv$project$rome$$internal$core$test$worker$SnapshotParser_ts$isCodeBlockEnd(
		index,
		input,
	) {
		return (
			input[___R$project$rome$$internal$ob1$index_ts$ob1Get0(index)] === "`" &&
			!___R$project$rome$$internal$string$utils$isEscaped_ts$isEscaped(
				index,
				input,
			) &&
			input[___R$project$rome$$internal$ob1$index_ts$ob1Get0(
				___R$project$rome$$internal$ob1$index_ts$ob1Add(index, 1),
			)] === "`" &&
			input[___R$project$rome$$internal$ob1$index_ts$ob1Get0(
				___R$project$rome$$internal$ob1$index_ts$ob1Add(index, 2),
			)] === "`"
		);
	}

	function ___R$$priv$project$rome$$internal$core$test$worker$SnapshotParser_ts$isInCodeBlock(
		char,
		index,
		input,
	) {
		return !___R$$priv$project$rome$$internal$core$test$worker$SnapshotParser_ts$isCodeBlockEnd(
			index,
			input,
		);
	}

	function ___R$$priv$project$rome$$internal$core$test$worker$SnapshotParser_ts$isntNewline(
		char,
	) {
		return char !== "\n";
	}

	function ___R$$priv$project$rome$$internal$core$test$worker$SnapshotParser_ts$unescapeTicks(
		code,
	) {
		return code;
	}

	const ___R$project$rome$$internal$core$test$worker$SnapshotParser_ts$createSnapshotParser = ___R$project$rome$$internal$parser$core$utils_ts$createParser({
		diagnosticCategory: "parse/snapshots",
		ignoreWhitespaceTokens: true,

		tokenize(parser, index) {
			const char = parser.getInputCharOnly(index);

			switch (char) {
				case "#": {
					const [hashes] = parser.readInputFrom(
						index,
						___R$$priv$project$rome$$internal$core$test$worker$SnapshotParser_ts$isHash,
					);
					const level = hashes.length;
					return parser.finishValueToken(
						"Hashes",
						level,
						___R$project$rome$$internal$ob1$index_ts$ob1Add(index, level),
					);
				}

				case "`": {
					const nextChar = parser.getInputCharOnly(index, 1);
					const nextNextChar = parser.getInputCharOnly(index, 2);

					if (nextChar === "`" && nextNextChar === "`") {
						let codeOffset = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
							index,
							3,
						);

						let language;
						if (parser.getInputCharOnly(codeOffset) !== "\n") {
							[language, codeOffset] = parser.readInputFrom(
								codeOffset,
								___R$$priv$project$rome$$internal$core$test$worker$SnapshotParser_ts$isntNewline,
							);
						}

						// Expect the first offset character to be a newline
						if (parser.getInputCharOnly(codeOffset) === "\n") {
							// Skip leading newline
							codeOffset = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
								codeOffset,
								1,
							);
						} else {
							throw parser.unexpected({
								description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SNAPSHOTS.MISSING_NEWLINE_AFTER_CODE_BLOCK,
								start: parser.getPositionFromIndex(codeOffset),
							});
						}

						let [code] = parser.readInputFrom(
							codeOffset,
							___R$$priv$project$rome$$internal$core$test$worker$SnapshotParser_ts$isInCodeBlock,
						);

						let end = ___R$project$rome$$internal$ob1$index_ts$ob1Add(
							codeOffset,
							code.length,
						);

						if (
							___R$$priv$project$rome$$internal$core$test$worker$SnapshotParser_ts$isCodeBlockEnd(
								end,
								parser.input,
							)
						) {
							// Check for trailing newline
							if (code[code.length - 1] === "\n") {
								// Trim trailing newline
								code = code.slice(0, -1);

								// Skip closing ticks
								end = ___R$project$rome$$internal$ob1$index_ts$ob1Add(end, 3);

								return parser.finishValueToken(
									"CodeBlock",
									{
										language,
										text: ___R$$priv$project$rome$$internal$core$test$worker$SnapshotParser_ts$unescapeTicks(
											code,
										),
									},
									end,
								);
							} else {
								throw parser.unexpected({
									description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SNAPSHOTS.MISSING_NEWLINE_BEFORE_CODE_BLOCK,
									start: parser.getPositionFromIndex(end),
								});
							}
						} else {
							throw parser.unexpected({
								description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SNAPSHOTS.UNCLOSED_CODE_BLOCK,
								start: parser.getPositionFromIndex(end),
							});
						}
					}
				}
			}

			const [text, end] = parser.readInputFrom(
				index,
				___R$$priv$project$rome$$internal$core$test$worker$SnapshotParser_ts$isntNewline,
			);
			return parser.finishValueToken("TextLine", text, end);
		},
	});

	function ___R$project$rome$$internal$core$test$worker$SnapshotParser_ts$parseSnapshot(
		parser,
	) {
		const nodes = [];

		while (!parser.matchToken("EOF")) {
			const start = parser.getPosition();
			const token = parser.getToken();

			switch (token.type) {
				case "Hashes": {
					const level = token.value;
					parser.nextToken();
					const text = parser.expectToken("TextLine").value;
					nodes.push({
						type: "Heading",
						level,
						text,
						loc: parser.finishLoc(start),
					});
					break;
				}

				case "CodeBlock": {
					nodes.push(
						Object.assign(
							{type: "CodeBlock"},
							token.value,
							{loc: parser.finishLoc(start)},
						),
					);
					parser.nextToken();
					break;
				}

				case "TextLine": {
					nodes.push({
						type: "TextLine",
						text: token.value,
						loc: parser.finishLoc(start),
					});
					parser.nextToken();
					break;
				}

				default:
					throw parser.unexpected();
			}
		}

		return nodes;
	}


  // project-rome/@internal/core/test-worker/SnapshotManager.ts
function ___R$$priv$project$rome$$internal$core$test$worker$SnapshotManager_ts$cleanHeading(
		key,
	) {
		if (key[0] === "`") {
			key = key.slice(1);
		}

		if (key[key.length - 1] === "`") {
			key = key.slice(0, -1);
		}

		return key.trim();
	}

	const ___R$project$rome$$internal$core$test$worker$SnapshotManager_ts$SNAPSHOT_EXT = ".test.md";

	function ___R$$priv$project$rome$$internal$core$test$worker$SnapshotManager_ts$buildEntriesKey(
		testName,
		entryName,
	) {
		return testName + "#" + entryName;
	}

	function ___R$$priv$project$rome$$internal$core$test$worker$SnapshotManager_ts$stringOrPrettyFormat(
		value,
	) {
		if (typeof value === "string") {
			return value;
		} else {
			return ___R$project$rome$$internal$pretty$format$index_ts$prettyFormatToString(
				value,
			);
		}
	}

	class ___R$project$rome$$internal$core$test$worker$SnapshotManager_ts$default {
		constructor(runner, testPath) {
			this.defaultSnapshotPath = testPath.getParent().append(
				"" +
				testPath.getExtensionlessBasename() +
				___R$project$rome$$internal$core$test$worker$SnapshotManager_ts$SNAPSHOT_EXT,
			);
			this.runner = runner;
			this.options = runner.globalOptions;
			this.snapshots = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
			this.fileLocker = new ___R$project$rome$$internal$async$lockers_ts$FilePathLocker();
			this.inlineSnapshotsUpdates = [];
		}

		static buildSnapshot({entries, absolute, relative}) {
			// Build the snapshot
			let lines = [];

			function pushNewline() {
				if (lines[lines.length - 1] !== "") {
					lines.push("");
				}
			}

			lines.push("# `" + absolute.getBasename() + "`");
			pushNewline();
			lines.push(
				"**DO NOT MODIFY**. This file has been autogenerated. Run `rome test " +
				relative.join() +
				" --update-snapshots` to update.",
			);
			pushNewline();

			const testNameToEntries = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
				"testNameToEntries",
				() => new Map(),
			);
			for (const entry of entries) {
				if (!entry.used) {
					continue;
				}
				let entriesByTestName = testNameToEntries.assert(entry.testName);
				entriesByTestName.set(entry.entryName, entry);
			}

			// Get test names and sort them so they are in a predictable
			const testNames = Array.from(testNameToEntries.keys()).sort();

			for (const testName of testNames) {
				const entries = testNameToEntries.get(testName);

				lines.push("## `" + testName + "`");
				pushNewline();
				const entryNames = Array.from(entries.keys()).sort(
					___R$project$rome$$internal$string$utils$naturalCompare_ts$naturalCompare,
				);

				for (const snapshotName of entryNames) {
					const entry = entries.get(snapshotName);

					const {value} = entry;
					const language = entry.language === undefined ? "" : entry.language;

					// If the test only has one snapshot then omit the heading
					const skipHeading = snapshotName === "0" && entryNames.length === 1;
					if (!skipHeading) {
						lines.push("### `" + snapshotName + "`");
					}

					pushNewline();
					lines.push("```" + language);
					// TODO escape triple backquotes
					lines.push(value);
					lines.push("```");
					pushNewline();
				}
			}
			return lines.join("\n");
		}

		getModifiedSnapshots() {
			const snapshots = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();

			for (const [name, snapshot] of this.snapshots) {
				let filteredEntries = snapshot.entries;

				// If we are a partial runner, then filter all unused entries as they'll be dispatched by the dedicated runner
				if (!this.runner.options.partial) {
					filteredEntries = new Map(snapshot.entries);
					for (const [name, entry] of filteredEntries) {
						if (!entry.used) {
							filteredEntries.delete(name);
						}
					}
				}

				snapshots.set(
					name,
					Object.assign({}, snapshot, {entries: filteredEntries}),
				);
			}

			return snapshots;
		}

		normalizeSnapshotPath(filename) {
			if (filename === undefined) {
				return this.defaultSnapshotPath;
			}

			const path = this.runner.path.getParent().resolve(filename);
			const ext = path.getExtensions();
			if (
				ext.endsWith(
					___R$project$rome$$internal$core$test$worker$SnapshotManager_ts$SNAPSHOT_EXT,
				)
			) {
				return path;
			} else {
				return path.addExtension(
					___R$project$rome$$internal$core$test$worker$SnapshotManager_ts$SNAPSHOT_EXT,
				);
			}
		}

		async init() {
			await this.loadSnapshot(this.defaultSnapshotPath);
		}

		async loadSnapshot(path) {
			if (!(await ___R$project$rome$$internal$fs$index_ts$exists(path))) {
				return;
			}

			return this.fileLocker.wrapLock(
				path,
				async () => {
					const loadedSnapshot = this.snapshots.get(path);
					if (loadedSnapshot !== undefined) {
						return loadedSnapshot;
					}

					const content = await ___R$project$rome$$internal$fs$index_ts$readFileText(
						path,
					);
					const parser = ___R$project$rome$$internal$core$test$worker$SnapshotParser_ts$createSnapshotParser({
						path,
						input: content,
					});
					const nodes = ___R$project$rome$$internal$core$test$worker$SnapshotParser_ts$parseSnapshot(
						parser,
					);

					const snapshot = {
						existsOnDisk: true,
						used: false,
						raw: parser.input,
						entries: new Map(),
					};
					this.snapshots.set(path, snapshot);

					while (nodes.length > 0) {
						const node = nodes.shift();

						if (node.type === "Heading" && node.level === 1) {
							// Title
							continue;
						}

						if (node.type === "Heading" && node.level === 2) {
							const testName = ___R$$priv$project$rome$$internal$core$test$worker$SnapshotManager_ts$cleanHeading(
								node.text,
							);

							while (nodes.length > 0) {
								const node = nodes[0];

								if (node.type === "Heading" && node.level === 3) {
									nodes.shift();

									const entryName = ___R$$priv$project$rome$$internal$core$test$worker$SnapshotManager_ts$cleanHeading(
										node.text,
									);

									const codeBlock = nodes.shift();
									if (codeBlock === undefined || codeBlock.type !== "CodeBlock") {
										throw parser.unexpected({
											description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SNAPSHOTS.EXPECTED_CODE_BLOCK_AFTER_HEADING,
											loc: node.loc,
										});
									}

									snapshot.entries.set(
										___R$$priv$project$rome$$internal$core$test$worker$SnapshotManager_ts$buildEntriesKey(
											testName,
											entryName,
										),
										{
											testName,
											entryName,
											language: codeBlock.language,
											value: codeBlock.text,
											used: false,
										},
									);

									continue;
								}

								if (node.type === "CodeBlock") {
									nodes.shift();

									snapshot.entries.set(
										___R$$priv$project$rome$$internal$core$test$worker$SnapshotManager_ts$buildEntriesKey(
											testName,
											"0",
										),
										{
											testName,
											entryName: "0",
											language: node.language,
											value: node.text,
											used: false,
										},
									);
								}

								break;
							}
						}
					}
					return snapshot;
				},
			);
		}

		testInlineSnapshot(callFrame, received, expected) {
			let receivedFormat = ___R$$priv$project$rome$$internal$core$test$worker$SnapshotManager_ts$stringOrPrettyFormat(
				received,
			);
			let expectedFormat = ___R$$priv$project$rome$$internal$core$test$worker$SnapshotManager_ts$stringOrPrettyFormat(
				expected,
			);

			// Matches, no need to do anything
			if (receivedFormat === expectedFormat) {
				return {status: "MATCH"};
			}

			const shouldSave = this.options.updateSnapshots || expected === undefined;
			if (shouldSave) {
				const {lineNumber, columnNumber} = callFrame;
				if (lineNumber === undefined || columnNumber === undefined) {
					throw new Error("Call frame has no line or column");
				}

				if (!this.options.freezeSnapshots) {
					let snapshot = receivedFormat;
					if (
						typeof received === "string" ||
						typeof received === "number" ||
						typeof received === "boolean" ||
						received === null
					) {
						snapshot = received;
					}

					this.inlineSnapshotsUpdates.push({
						line: lineNumber,
						column: columnNumber,
						snapshot,
					});
				}

				return {status: "UPDATE"};
			}

			return {status: "NO_MATCH"};
		}

		async get(testName, entryName, optionalFilename) {
			const snapshotPath = this.normalizeSnapshotPath(optionalFilename);
			let snapshot = this.snapshots.get(snapshotPath);

			if (snapshot === undefined) {
				snapshot = await this.loadSnapshot(snapshotPath);
			}

			if (snapshot === undefined) {
				return undefined;
			}

			snapshot.used = true;

			// If we're force updating, pretend that there was no entry
			if (this.options.updateSnapshots) {
				return undefined;
			}

			const entry = snapshot.entries.get(
				___R$$priv$project$rome$$internal$core$test$worker$SnapshotManager_ts$buildEntriesKey(
					testName,
					entryName,
				),
			);
			if (entry === undefined) {
				return undefined;
			} else {
				entry.used = true;
				return entry.value;
			}
		}

		set(
			{
				testName,
				entryName,
				value,
				language,
				optionalFilename,
			},
		) {
			const snapshotPath = this.normalizeSnapshotPath(optionalFilename);
			let snapshot = this.snapshots.get(snapshotPath);
			if (snapshot === undefined) {
				snapshot = {
					raw: "",
					existsOnDisk: false,
					used: true,
					entries: new Map(),
				};
				this.snapshots.set(snapshotPath, snapshot);
			}

			snapshot.entries.set(
				___R$$priv$project$rome$$internal$core$test$worker$SnapshotManager_ts$buildEntriesKey(
					testName,
					entryName,
				),
				{
					testName,
					entryName,
					language,
					value,
					used: true,
				},
			);
		}
	}


  // project-rome/@internal/core/server/testing/TestServerFile.ts
class ___R$project$rome$$internal$core$server$testing$TestServerFile_ts$default {
		constructor({ref, bundle, runner, request}) {
			this.request = request;
			this.runner = runner;
			this.path = ref.real;
			this.ref = ref;
			this.bundle = bundle;

			this.hasDiagnostics = false;
			this.pendingTests = new Set();
			this.snapshots = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
			this.inlineSnapshotUpdates = [];
		}

		onDiagnostics() {
			this.hasDiagnostics = true;
		}

		getPendingTests() {
			return this.pendingTests;
		}

		removePendingTest(testName) {
			this.pendingTests.delete(testName);
		}

		addPendingTest(testName) {
			this.pendingTests.add(testName);
		}

		clearPendingTests() {
			this.pendingTests.clear();
		}

		addResult(result) {
			for (const [path, snapshot] of result.snapshots) {
				const existing = this.snapshots.get(path);
				if (existing === undefined) {
					this.snapshots.set(path, snapshot);
					continue;
				}

				const mergedEntries = new Map(existing.entries);

				for (const [name, entry] of snapshot.entries) {
					const existing = mergedEntries.get(name);
					if (existing === undefined || entry.used) {
						mergedEntries.set(name, entry);
					}
				}

				const merged = {
					// This should be the same. Maybe validate?
					existsOnDisk: existing.existsOnDisk,
					raw: existing.raw,
					used: existing.used || snapshot.used,
					entries: mergedEntries,
				};
				this.snapshots.set(path, merged);
			}

			this.inlineSnapshotUpdates = [
				...this.inlineSnapshotUpdates,
				...result.inlineSnapshotUpdates,
			];
		}

		async writeSnapshots() {
			const {snapshots, runner, request} = this;
			if (snapshots.size === 0) {
				return;
			}

			const {hasDiagnostics} = this;
			const {processor} = runner.printer;

			for (const [path, {used, existsOnDisk, raw, entries}] of this.snapshots) {
				const formatted = ___R$project$rome$$internal$core$test$worker$SnapshotManager_ts$default.buildSnapshot({
					entries: Array.from(entries.values()),
					absolute: this.path,
					relative: this.ref.relative,
				});

				const location = {
					filename: path.join(),
				};

				if (runner.options.freezeSnapshots) {
					if (used) {
						if (formatted !== raw) {
							processor.addDiagnostic({
								description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SNAPSHOTS.INCORRECT(
									raw,
									formatted,
								),
								location,
							});
						}
					} else {
						processor.addDiagnostic({
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SNAPSHOTS.REDUNDANT,
							location,
						});
					}
				} else {
					// Don't delete or write a snapshot if there are test failures as those failures may be hiding snapshot usages
					if (hasDiagnostics && !runner.options.updateSnapshots) {
						continue;
					}

					if (existsOnDisk && !used) {
						// If a snapshot wasn't used or is empty then delete it!
						await ___R$project$rome$$internal$fs$index_ts$removeFile(path);
						runner.progress.deletedSnapshots++;
					} else if (used && formatted !== raw) {
						// Fresh snapshot!
						request.queueSaveFile(
							path,
							{
								type: "UNSAFE_WRITE",
								content: formatted,
							},
						);
						if (existsOnDisk) {
							runner.progress.updatedSnapshots++;
						} else {
							runner.progress.createdSnapshots++;
						}
					}
				}
			}
		}

		async writeInlineSnapshots() {
			let {inlineSnapshotUpdates, path, ref, request, runner} = this;
			if (inlineSnapshotUpdates.length === 0) {
				return;
			}

			const filename = path.join();

			// Resolve source maps. These will originally be pointed to the compiled source.
			inlineSnapshotUpdates = inlineSnapshotUpdates.map((update) => {
				const resolved = runner.sourceMaps.assertApproxOriginalPositionFor(
					filename,
					update.line,
					update.column,
				);

				if (!resolved.found) {
					throw new Error(
						"Could not find inline snapshot location in source map",
					);
				}

				if (resolved.source !== filename && resolved.source !== ref.uid) {
					throw new Error(
						"Inline snapshot update resolved to " +
						resolved.source +
						" when it should be " +
						filename,
					);
				}

				return Object.assign(
					{},
					update,
					{line: resolved.line, column: resolved.column},
				);
			});

			const {diagnostics, file} = await request.requestWorkerUpdateInlineSnapshots(
				path,
				inlineSnapshotUpdates,
				{},
			);
			runner.printer.processor.addDiagnostics(diagnostics);
			if (file !== undefined) {
				request.queueSaveFile(path, file);
				runner.progress.updatedInlineSnapshots++;
			}
		}

		async finish() {
			await this.writeSnapshots();
			await this.writeInlineSnapshots();
		}
	}


  // project-rome/@internal/core/server/testing/TestServer.ts
const ___R$$priv$project$rome$$internal$core$server$testing$TestServer_ts$net = require(
		"net",
	);
	class ___R$project$rome$$internal$core$server$testing$TestServer_ts$BridgeDiagnosticsError
		extends ___R$project$rome$$internal$diagnostics$errors_ts$DiagnosticsError {
		constructor(diag, bridge) {
			super(
				___R$project$rome$$internal$markup$escape_ts$readMarkup(
					diag.description.message,
				),
				[diag],
			);
			this.bridge = bridge;
		}
	}

	function ___R$$priv$project$rome$$internal$core$server$testing$TestServer_ts$grammarNumberTests(
		num,
	) {
		return ___R$project$rome$$internal$markup$escape_ts$markup`<grammarNumber plural="tests" singular="test">${String(
			num,
		)}</grammarNumber>`;
	}

	function ___R$$priv$project$rome$$internal$core$server$testing$TestServer_ts$getProgressTestRefText(
		ref,
	) {
		return ___R$project$rome$$internal$markup$escape_ts$markup`<filelink target="${ref.path.join()}" />: ${ref.testName}`;
	}

	function ___R$$priv$project$rome$$internal$core$server$testing$TestServer_ts$findAvailablePort() {
		return new Promise((resolve, reject) => {
			// When you create a server without specifying a port then the OS will choose a port number for you!
			const server = ___R$$priv$project$rome$$internal$core$server$testing$TestServer_ts$net.createServer();
			server.unref();
			server.on("error", reject);
			server.listen(
				undefined,
				() => {
					const address = server.address();
					if (address == null || typeof address === "string") {
						throw new Error("Invalid address value");
					}

					server.close(() => {
						resolve(address.port);
					});
				},
			);
		});
	}

	function ___R$$priv$project$rome$$internal$core$server$testing$TestServer_ts$refToKey(
		ref,
	) {
		return ref.path.join() + ": " + ref.testName;
	}

	class ___R$project$rome$$internal$core$server$testing$TestServer_ts$default {
		constructor(opts) {
			this.paths = opts.paths;
			this.reporter = opts.request.reporter;
			this.server = opts.request.server;
			this.logger = this.server.logger.namespace(
				___R$project$rome$$internal$markup$escape_ts$markup`[TestServerRunner]`,
			);
			this.request = opts.request;
			this.options = opts.options;

			this.ignoreBridgeEndError = new Set();

			this.coverageCollector = new ___R$project$rome$$internal$v8$CoverageCollector_ts$default();

			this.progress = {
				totalTests: 0,
				startedTests: 0,
				finishedTests: 0,
				updatedSnapshots: 0,
				deletedSnapshots: 0,
				createdSnapshots: 0,
				updatedInlineSnapshots: 0,
			};

			this.files = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
			this.focusedTests = [];
			this.testFilesStack = [];
			this.runningTests = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
				"runningTests",
			);

			this.sourceMaps = new ___R$project$rome$$internal$codec$source$map$SourceMapConsumerCollection_ts$default();
			this.printer = opts.request.createDiagnosticsPrinter(
				this.request.createDiagnosticsProcessor({
					origins: [
						{
							category: "test",
							message: "Run initiated",
						},
					],
					sourceMaps: this.sourceMaps,
				}),
			);
		}

		handlePossibleBridgeError(err) {
			let diagnostics = ___R$project$rome$$internal$diagnostics$errors_ts$getDiagnosticsFromError(
				err,
			);
			let bridge;

			if (
				err instanceof
				___R$project$rome$$internal$core$server$testing$TestServer_ts$BridgeDiagnosticsError
			) {
				bridge = err.bridge;
			}

			if (
				err instanceof
				___R$project$rome$$internal$events$BridgeError_ts$default
			) {
				bridge = err.bridge;
				diagnostics = [
					___R$project$rome$$internal$diagnostics$derive_ts$deriveDiagnosticFromError(
						err,
						{
							description: {
								category: "tests/failure",
							},
						},
					),
				];
			}

			if (diagnostics === undefined || bridge === undefined) {
				throw err;
			} else {
				if (!this.ignoreBridgeEndError.has(bridge)) {
					this.printer.processor.addDiagnostics(diagnostics);
				}
			}
		}

		async setupWorkers() {
			// TODO some smarter logic. we may not need all these workers
			const workers = [];
			for (
				let i = 0;
				i <
				___R$project$rome$$internal$core$common$constants_ts$MAX_WORKER_COUNT;
				i++
			) {
				const inspectorPort = await ___R$$priv$project$rome$$internal$core$server$testing$TestServer_ts$findAvailablePort();
				const worker = new ___R$project$rome$$internal$core$server$testing$TestServerWorker_ts$default({
					runner: this,
					flags: {inspectorPort},
					server: this.server,
					request: this.request,
				});
				workers.push(worker.init().then(() => worker));
			}
			return Promise.all(workers);
		}

		async init() {
			const fileQueue = [];
			const workers = await this.setupWorkers();

			await this.reporter.steps([
				{
					message: ___R$project$rome$$internal$markup$escape_ts$markup`Bundling test files`,
					callback: async () => {
						const bundler = new ___R$project$rome$$internal$core$server$bundler$Bundler_ts$default(
							this.request,
							this.request.getBundlerConfigFromFlags({
								mocks: true,
							}),
						);
						for (const [path, bundle] of await bundler.bundleMultiple(
							Array.from(this.paths),
							{
								deferredSourceMaps: true,
							},
						)) {
							if (this.options.sourceMaps) {
								const sourceMap = bundle.entry.sourceMap.map;
								const consumer = sourceMap.toConsumer();
								//this.coverageCollector.addSourceMap(path.join(), code, consumer);
								this.sourceMaps.add(path.join(), consumer);
							}

							const ref = this.server.projectManager.getFileReference(path);
							const file = new ___R$project$rome$$internal$core$server$testing$TestServerFile_ts$default({
								ref,
								bundle,
								runner: this,
								request: this.request,
							});
							this.files.set(path, file);
							fileQueue.push(file);
							this.testFilesStack.push(path);
						}
					},
				},
				{
					message: ___R$project$rome$$internal$markup$escape_ts$markup`Loading test files`,
					callback: async () => {
						const progress = this.reporter.progress({
							title: ___R$project$rome$$internal$markup$escape_ts$markup`Preparing`,
						});
						progress.setTotal(this.paths.size);
						await Promise.all(
							workers.map((worker) => worker.prepareAll(progress, fileQueue)),
						);
						progress.end();

						// If we have focused tests, clear the pending queues and populate it with only ours
						if (this.focusedTests.length > 0) {
							for (const file of this.files.values()) {
								file.clearPendingTests();
							}

							for (const {ref} of this.focusedTests) {
								this.files.assert(ref.path).addPendingTest(ref.testName);
							}
						}
					},
				},
				{
					message: ___R$project$rome$$internal$markup$escape_ts$markup`Running tests`,
					callback: async () => {
						const runProgress = this.setupRunProgress(workers);
						await Promise.all(workers.map((worker) => worker.run()));
						runProgress.teardown();
					},
				},
			]);

			if (this.focusedTests.length === 0) {
				for (const file of this.files.values()) {
					await file.finish();
				}
			}
			await this.request.flushFiles();
			this.throwPrinter();
		}

		getTotalTests() {
			if (this.focusedTests.length > 0) {
				return this.focusedTests.length;
			} else {
				return this.progress.totalTests;
			}
		}

		onTestStart(worker, ref, timeoutMs) {
			this.progress.startedTests++;

			let timeout = undefined;
			if (timeoutMs !== undefined) {
				timeout = setTimeout(
					() => {
						// TODO This will kill the whole worker, maybe it's possible to just terminate the current test? Throw an error, see if the next test was ran, or else terminate completely
						this.server.wrapFatalPromise(
							worker.handleTimeout(String(timeoutMs) + "ms"),
						);
					},
					timeoutMs,
				);
			}

			const key = ___R$$priv$project$rome$$internal$core$server$testing$TestServer_ts$refToKey(
				ref,
			);
			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Running test ${key}`,
			);
			this.runningTests.set(
				key,
				{
					ref,
					timeout,
				},
			);
		}

		onTestFound(ref) {
			const file = this.files.assert(ref.path);
			file.addPendingTest(ref.testName);
			this.progress.totalTests++;
		}

		onTestFinished(ref) {
			const key = ___R$$priv$project$rome$$internal$core$server$testing$TestServer_ts$refToKey(
				ref,
			);
			const running = this.runningTests.assert(key);

			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Finished test ${key}`,
			);
			if (running.timeout !== undefined) {
				clearTimeout(running.timeout);
			}
			this.runningTests.delete(key);
			this.progress.finishedTests++;
		}

		setupRunProgress(workers) {
			const progress = this.request.reporter.progress({
				persistent: true,
				title: ___R$project$rome$$internal$markup$escape_ts$markup`Running`,
			});
			progress.setTotal(this.getTotalTests());

			for (const worker of workers) {
				const {bridge} = worker;
				const ourRunningTests = new Set();

				bridge.endEvent.subscribe((error) => {
					// Cancel all currently running tests
					const cancelTests = [];

					for (const key of ourRunningTests) {
						const test = this.runningTests.get(key);
						if (test !== undefined) {
							cancelTests.push(test.ref);
						}
					}

					for (const ref of cancelTests) {
						this.onTestFinished(ref);

						if (cancelTests.length === 1) {
							// If we only have one test to cancel then let's only point the bridge error to this test
							this.ignoreBridgeEndError.add(bridge);

							const errDiag = ___R$project$rome$$internal$diagnostics$derive_ts$deriveDiagnosticFromError(
								error,
								{
									label: ___R$project$rome$$internal$markup$escape_ts$markup`${ref.testName}`,
									filename: ref.path.join(),
									description: {
										category: "tests/failure",
									},
									tags: {
										internal: true,
									},
								},
							);

							this.printer.processor.addDiagnostic(
								Object.assign(
									{},
									errDiag,
									{
										description: Object.assign(
											{},
											errDiag.description,
											{
												// We don't care about the advice
												advice: [
													{
														type: "log",
														category: "info",
														text: ___R$project$rome$$internal$markup$escape_ts$markup`Was executing test file <emphasis>${ref.path}</emphasis>`,
													},
												],
											},
										),
									},
								),
							);
						} else {
							this.printer.processor.addDiagnostic({
								label: ___R$project$rome$$internal$markup$escape_ts$markup`${ref.testName}`,
								description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.TESTS.CANCELLED,
								location: {
									filename: ref.path.join(),
								},
							});
						}
					}
				});

				bridge.testStart.subscribe((data) => {
					const key = ___R$$priv$project$rome$$internal$core$server$testing$TestServer_ts$refToKey(
						data.ref,
					);
					ourRunningTests.add(key);
					this.onTestStart(worker, data.ref, data.timeout);
					progress.pushText(
						___R$$priv$project$rome$$internal$core$server$testing$TestServer_ts$getProgressTestRefText(
							data.ref,
						),
						key,
					);
				});

				bridge.testFinish.subscribe((data) => {
					this.onTestFinished(data.ref);
					progress.popText(
						___R$$priv$project$rome$$internal$core$server$testing$TestServer_ts$refToKey(
							data.ref,
						),
					);
					progress.tick();
				});
			}

			return {
				teardown() {
					progress.end();
				},
			};
		}

		printCoverageReport(isError) {
			const {reporter, server, coverageCollector} = this;

			if (isError && this.options.showAllCoverage) {
				// Only show coverage for errors when --show-all-coverage has been specified
				return;
			}

			if (!this.options.coverage) {
				return;
			}

			reporter.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Generating coverage`,
			);

			// Fetch coverage entries
			const files = coverageCollector.generate();
			if (files.length === 0) {
				return;
			}

			reporter.heading(
				___R$project$rome$$internal$markup$escape_ts$markup`Code coverage`,
			);

			// Get the packages associated with all the ran tests, we will filter code coverage to those packages only
			const testedPackages = new Set();
			for (const path of this.paths) {
				testedPackages.add(server.memoryFs.getOwnedManifest(path));
			}

			let root = {
				name: undefined,
				directories: new Map(),
				files: new Map(),
			};

			let totalFiles = 0;

			// Turn the flat list of filenames into a directory tree
			for (const file of files) {
				const {filename} = file;

				// Get the absolute filename
				const absolute = server.projectManager.getFilePathFromUid(filename);
				if (absolute === undefined) {
					continue;
				}

				// Filter out untested packages
				const pkg = server.memoryFs.getOwnedManifest(absolute);
				if (testedPackages.has(pkg) === false) {
					continue;
				}

				// TODO maybe filter out test files too?

				// Track unfiltered files
				totalFiles++;

				const filenameParts = filename.split("/");
				const basename = filenameParts.pop();
				if (basename === undefined) {
					throw new Error(
						"Should always be at least one element from a split()",
					);
				}

				let target = root;

				for (const part of filenameParts) {
					const existingDirectory = target.directories.get(part);
					if (existingDirectory === undefined) {
						const newDirectory = {
							name: part,
							directories: new Map(),
							files: new Map(),
						};
						target.directories.set(part, newDirectory);
						target = newDirectory;
					} else {
						target = existingDirectory;
					}
				}

				target.files.set(basename, file);
			}

			// Continuously merge all entries with only a single directory from the root
			while (root.directories.size === 1 && root.files.size === 0) {
				// Awkward way to get the first value out of the directories map...
				const newRoot = root.directories.values().next().value;
				root = Object.assign(
					{},
					newRoot,
					{
						name: root.name !== undefined && newRoot.name !== undefined
							? root.name + "/" + newRoot.name
							: newRoot.name,
					},
				);
			}

			const rows = [];

			// If there's more than 15 files to show, and we don't have the explicit showAllCoverage flag
			// then truncate the output
			const showAllCoverage = this.options.showAllCoverage || totalFiles < 15;

			function buildRows(directory, depth) {
				const name =
					directory.name === undefined ? "All files" : directory.name + "/";
				const directoryPercent = ___R$project$rome$$internal$core$server$testing$utils_ts$percentInsideCoverageDirectory(
					directory,
				);

				rows.push([
					___R$project$rome$$internal$markup$escape_ts$markup`${" ".repeat(
						depth,
					)}<emphasis>${name}</emphasis>`,
					___R$project$rome$$internal$core$server$testing$utils_ts$formatPercent(
						directoryPercent.functions,
					),
					___R$project$rome$$internal$core$server$testing$utils_ts$formatPercent(
						directoryPercent.branches,
					),
					___R$project$rome$$internal$core$server$testing$utils_ts$formatPercent(
						directoryPercent.lines,
					),
				]);

				// Don't ever show anything deeper than a single level when showAllCoverage is off
				if (!showAllCoverage && depth > 0) {
					return;
				}

				const fileIndent = " ".repeat(depth + 1);
				for (const [name, file] of ___R$project$rome$$internal$core$server$testing$utils_ts$sortMapKeys(
					directory.files,
				)) {
					let absolute = file.filename;

					// Exchange any UIDs
					const absolutePath = server.projectManager.getFilePathFromUid(
						file.filename,
					);
					if (absolutePath !== undefined) {
						absolute = absolutePath.join();
					}

					rows.push([
						___R$project$rome$$internal$markup$escape_ts$markup`${fileIndent}<filelink target="${absolute}">${name}</filelink>`,
						___R$project$rome$$internal$core$server$testing$utils_ts$formatPercent(
							file.functions.percent,
						),
						___R$project$rome$$internal$core$server$testing$utils_ts$formatPercent(
							file.branches.percent,
						),
						___R$project$rome$$internal$core$server$testing$utils_ts$formatPercent(
							file.lines.percent,
						),
					]);
				}

				for (const subDirectory of ___R$project$rome$$internal$core$server$testing$utils_ts$sortMapKeys(
					directory.directories,
				).values()) {
					buildRows(subDirectory, depth + 1);
				}
			}

			buildRows(root, 0);

			reporter.table(
				[
					___R$project$rome$$internal$markup$escape_ts$markup`File`,
					___R$project$rome$$internal$markup$escape_ts$markup`% Functions`,
					___R$project$rome$$internal$markup$escape_ts$markup`% Branches`,
					___R$project$rome$$internal$markup$escape_ts$markup`% Lines`,
				],
				rows,
			);

			if (!showAllCoverage) {
				reporter.br();
				reporter.info(
					___R$project$rome$$internal$markup$escape_ts$markup`Additional coverage information available. Refine the executed tests or add the <emphasis>--show-all-coverage</emphasis> flag`,
				);
			}

			reporter.hr();
		}

		printFocusedTestWarning(reporter) {
			const {focusedTests} = this;
			if (focusedTests.length === 0) {
				return;
			}

			const formattedFocusedTests = focusedTests.map(({ref, location}) => {
				const loc = this.printer.processor.normalizer.normalizeLocation(
					location,
				);

				return ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${ref.testName}</emphasis> at <emphasis>${___R$project$rome$$internal$diagnostics$helpers_ts$diagnosticLocationToMarkupFilelink(
					loc,
				)}</emphasis>`;
			});

			if (focusedTests.length === 1) {
				reporter.warn(
					___R$project$rome$$internal$markup$escape_ts$markup`Only ran the focused test ${formattedFocusedTests[0]}`,
				);
			} else {
				reporter.warn(
					___R$project$rome$$internal$markup$escape_ts$markup`Only ran the following <number emphasis>${String(
						focusedTests.length,
					)}</number> focused ${___R$$priv$project$rome$$internal$core$server$testing$TestServer_ts$grammarNumberTests(
						focusedTests.length,
					)}`,
				);
				reporter.list(formattedFocusedTests);
			}

			const otherTotal = this.progress.totalTests - this.focusedTests.length;
			reporter.warn(
				___R$project$rome$$internal$markup$escape_ts$markup`<number emphasis>${String(
					otherTotal,
				)}</number> other ${___R$$priv$project$rome$$internal$core$server$testing$TestServer_ts$grammarNumberTests(
					otherTotal,
				)} ignored`,
			);
		}

		printSnapshotCounts(reporter) {
			const {
				createdSnapshots,
				deletedSnapshots,
				updatedSnapshots,
				updatedInlineSnapshots,
			} = this.progress;

			let snapshotCounts = [
				{inline: false, count: createdSnapshots, noun: "created"},
				{inline: false, count: updatedSnapshots, noun: "updated"},
				{inline: false, count: deletedSnapshots, noun: "deleted"},
				{inline: true, count: updatedInlineSnapshots, noun: "updated"},
			];
			snapshotCounts = snapshotCounts.filter(({count}) => count > 0);
			if (snapshotCounts.length === 0) {
				return;
			}

			const formatted = snapshotCounts.map(({inline, count, noun}) => {
				const words = [
					___R$project$rome$$internal$markup$escape_ts$markup`<number emphasis>${String(
						count,
					)}</number>`,
				];
				if (inline) {
					words.push(
						___R$project$rome$$internal$markup$escape_ts$markup`inline`,
					);
					words.push(
						___R$project$rome$$internal$markup$escape_ts$markup`<grammarNumber plural="snapshots" singular="snapshot">${String(
							count,
						)}</grammarNumber>`,
					);
				} else {
					words.push(
						___R$project$rome$$internal$markup$escape_ts$markup`snapshot`,
					);
					words.push(
						___R$project$rome$$internal$markup$escape_ts$markup`<grammarNumber plural="files" singular="file">${String(
							count,
						)}</grammarNumber>`,
					);
				}
				words.push(___R$project$rome$$internal$markup$escape_ts$markup`${noun}`);
				return ___R$project$rome$$internal$markup$escape_ts$concatMarkup(
					words,
					___R$project$rome$$internal$markup$escape_ts$markup` `,
				);
			});
			for (const msg of formatted) {
				reporter.info(msg);
			}
		}

		throwPrinter() {
			const {printer} = this;

			printer.onFooterPrint(async (reporter, isError) => {
				this.printCoverageReport(isError);
				this.printSnapshotCounts(reporter);
				this.printFocusedTestWarning(reporter);

				const totalCount = this.getTotalTests();
				if (totalCount > 0 || !isError) {
					reporter.success(
						___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${___R$project$rome$$internal$string$utils$humanizeNumber_ts$humanizeNumber(
							totalCount,
						)}</emphasis> ${___R$$priv$project$rome$$internal$core$server$testing$TestServer_ts$grammarNumberTests(
							totalCount,
						)} passed!`,
					);
					if (!isError) {
						printer.disableDefaultFooter();
					}
				}
			});

			throw printer;
		}
	}


  // project-rome/@internal/core/server/commands/test.ts
const ___R$project$rome$$internal$core$server$commands$test_ts$default = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.CODE_QUALITY,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`run tests`,
		hidden: true,
		usage: "",
		examples: [],
		defineFlags(c) {
			return {
				filter: c.get("filter").asStringOrVoid(),
				coverage: c.get("coverage").asBoolean(false),
				showAllCoverage: c.get("showAllCoverage").asBoolean(false),
				updateSnapshots: c.get("updateSnapshots").asBoolean(false),
				freezeSnapshots: c.get("freezeSnapshots").asBoolean(false),
				focusAllowed: c.get("focusAllowed").asBoolean(true),
				syncTests: c.get("syncTests").asBoolean(false),
				sourceMaps: c.get("sourceMaps").asBoolean(true),
			};
		},
		async callback(req, commandFlags) {
			const globber = await req.glob({
				tryAlternateArg: (path) => {
					if (path.hasExtension("test")) {
						return undefined;
					} else {
						return path.getParent().append(
							path.getExtensionlessBasename() + ".test" + path.getExtensions(),
						);
					}
				},
				test: (path) => path.hasExtension("test"),
				noun: "test",
				verb: "testing",
				configCategory: "tests",
				advice: [
					{
						type: "log",
						category: "info",
						text: ___R$project$rome$$internal$markup$escape_ts$markup`Searched for files with <emphasis>.test.*</emphasis> file extension`,
					},
				],
				extensions: ___R$project$rome$$internal$core$common$file$handlers$javascript_ts$JS_EXTENSIONS,
				disabledDiagnosticCategory: "tests/disabled",
			});
			const paths = await globber.get();

			const runner = new ___R$project$rome$$internal$core$server$testing$TestServer_ts$default({
				options: Object.assign(
					{},
					commandFlags,
					{verboseDiagnostics: req.query.requestFlags.verboseDiagnostics},
				),
				paths,
				request: req,
			});
			await runner.init();
		},
	});


  // project-rome/@internal/core/server/commands/ci.ts
const ___R$project$rome$$internal$core$server$commands$ci_ts$default = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.CODE_QUALITY,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`run lint and tests`,
		usage: "",
		hidden: true,
		examples: [],
		defineFlags(consumer) {
			return {
				fix: consumer.get(
					"fix",
					{
						description: ___R$project$rome$$internal$markup$escape_ts$markup`enables --update-snapshots for test, and --apply for the lint command`,
					},
				).asBoolean(false),
			};
		},
		async callback(req, flags) {
			req.updateRequestFlags({
				verboseDiagnostics: "NO_TRUNCATE",
			});

			await ___R$project$rome$$internal$core$server$commands_ts$chainCommands(
				req,
				[
					{
						title: ___R$project$rome$$internal$markup$escape_ts$markup`<code>rome check</code>`,
						progress: ___R$project$rome$$internal$markup$escape_ts$markup`Running check`,
						callback: async () => {
							await ___R$project$rome$$internal$core$server$commands$check_ts$default.callback(
								req,
								{
									formatOnly: false,
									decisions: [],
									apply: flags.fix,
									changed: undefined,
									suppressionExplanation: undefined,
								},
							);
						},
					},
					{
						title: ___R$project$rome$$internal$markup$escape_ts$markup`<code>rome test</code>`,
						progress: ___R$project$rome$$internal$markup$escape_ts$markup`Running tests`,
						callback: async () => {
							await ___R$project$rome$$internal$core$server$commands$test_ts$default.callback(
								req,
								{
									filter: undefined,
									focusAllowed: false,
									coverage: false,
									freezeSnapshots: !flags.fix,
									updateSnapshots: flags.fix,
									showAllCoverage: false,
									syncTests: false,
									sourceMaps: true,
								},
							);
						},
					},
				],
			);
		},
	});


  // project-rome/@internal/core/server/commands/noop.ts
const ___R$project$rome$$internal$core$server$commands$noop_ts$default = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.INTERNAL,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`do nothing`,
		usage: "",
		examples: [],
		defineFlags(c) {
			return {
				hang: c.get(
					"hang",
					{
						description: ___R$project$rome$$internal$markup$escape_ts$markup`Hang rather than instantly quitting`,
					},
				).asBoolean(false),
			};
		},
		async callback(req, flags) {
			if (flags.hang) {
				if (!req.server.options.dedicated) {
					req.reporter.warn(
						___R$project$rome$$internal$markup$escape_ts$markup`Passed <emphasis>--hang</emphasis> flag but server not connected to a dedicated server so request will hang forever`,
					);
				}
				await req.endEvent.wait();
			}
		},
	});


  // project-rome/@internal/core/server/commands/json.ts
const ___R$project$rome$$internal$core$server$commands$json_ts$default = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.INTERNAL,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`dump an RJSON file to regular JSON`,
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback(req) {
			const {reporter} = req;
			const path = await req.resolveEntryAssertPathArg(0);

			const file = await ___R$project$rome$$internal$fs$index_ts$readFileText(
				path,
			);
			const value = ___R$project$rome$$internal$codec$json$index_ts$parseJSON({
				path,
				input: file,
			});

			const json = ___R$project$rome$$internal$codec$json$index_ts$stringifyJSON(
				value,
			);
			reporter.write(json);
			return json;
		},
	});


  // project-rome/@internal/core/server/commands/recover.ts
const ___R$project$rome$$internal$core$server$commands$recover_ts = {
		get list() {
			return ___R$project$rome$$internal$core$server$commands$recover_ts$list;
		},
		get diff() {
			return ___R$project$rome$$internal$core$server$commands$recover_ts$diff;
		},
		get apply() {
			return ___R$project$rome$$internal$core$server$commands$recover_ts$apply;
		},
		get pop() {
			return ___R$project$rome$$internal$core$server$commands$recover_ts$pop;
		},
		get clear() {
			return ___R$project$rome$$internal$core$server$commands$recover_ts$clear;
		},
		get dir() {
			return ___R$project$rome$$internal$core$server$commands$recover_ts$dir;
		},
	};
	async function ___R$$priv$project$rome$$internal$core$server$commands$recover_ts$applyStore(
		req,
		storeId,
	) {
		const {server, reporter} = req;

		const entries = await server.recoveryStore.apply(
			req,
			storeId,
			req.getDiagnosticLocationFromFlags({
				type: "arg",
				key: 1,
			}),
			/*async (store) => {
			if (!flags.select) {
				return undefined;
			}

			const options: SelectOptions = {};
			for (const {fileId, originalPath, artifactPath} of store.entries) {
				options[fileId] = {
					label: markup`${artifactPath} -> ${originalPath}`,
				};
			}

			const selected = await reporter.select(markup`Select files to apply`, {options});
			return Array.from(selected);
		},*/
		);

		reporter.success(
			___R$project$rome$$internal$markup$escape_ts$markup`Successfully applied patch <emphasis>${storeId}</emphasis>`,
		);
		reporter.list(
			Array.from(
				entries,
				({artifactPath, originalPath}) =>
					___R$project$rome$$internal$markup$escape_ts$markup`${artifactPath} -> ${originalPath}`
				,
			),
		);
	}

	async function ___R$$priv$project$rome$$internal$core$server$commands$recover_ts$getAllStores(
		req,
	) {
		const {server, reporter} = req;
		const {stores, diagnostics} = await server.recoveryStore.getAllStores();

		// May have encountered some issues loading corrupted stores. Invalid index.json files etc
		if (diagnostics.length > 0) {
			reporter.warn(
				___R$project$rome$$internal$markup$escape_ts$markup`Encountered errors reading from recovery store`,
			);
			await req.printDiagnostics({diagnostics});
			reporter.hr();
		}

		return stores;
	}

	const ___R$project$rome$$internal$core$server$commands$recover_ts$list = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.SOURCE_CODE,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`show all patches in the recovery store`,
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback(req) {
			const {reporter} = req;
			req.expectArgumentLength(0);

			const stores = await ___R$$priv$project$rome$$internal$core$server$commands$recover_ts$getAllStores(
				req,
			);

			if (stores.length === 0) {
				reporter.info(
					___R$project$rome$$internal$markup$escape_ts$markup`Recovery store is empty`,
				);
			} else {
				reporter.heading(
					___R$project$rome$$internal$markup$escape_ts$markup`Recovery stores`,
				);

				for (const {storeId, timestamp, command, entries} of stores) {
					await reporter.section(
						___R$project$rome$$internal$markup$escape_ts$markup`${storeId}`,
						() => {
							reporter.log(
								___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>Ran <duration>${String(
									Date.now() - new Date(timestamp).valueOf(),
								)}</duration> ago</emphasis> <dim>(${timestamp})</dim>`,
							);
							reporter.command(command);
							reporter.br();
							reporter.list(
								Array.from(
									entries,
									({artifactPath, originalPath}) =>
										___R$project$rome$$internal$markup$escape_ts$markup`${originalPath} -> ${artifactPath}`
									,
								),
							);
							reporter.br();

							reporter.info(
								___R$project$rome$$internal$markup$escape_ts$markup`To select specific files to patch run:`,
							);
							reporter.command("rome recover apply " + storeId + " --select");
							reporter.br();

							reporter.info(
								___R$project$rome$$internal$markup$escape_ts$markup`To see the changes with this patch run:`,
							);
							reporter.command("rome recover diff " + storeId);
							reporter.br();

							reporter.info(
								___R$project$rome$$internal$markup$escape_ts$markup`To apply <emphasis>everything</emphasis> in this patch run:`,
							);
							reporter.command("rome recover apply " + storeId);
							reporter.br();
						},
					);
				}
			}
		},
	});

	const ___R$project$rome$$internal$core$server$commands$recover_ts$diff = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.SOURCE_CODE,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`show the differences that would be applied for a given patch`,
		usage: "<id>",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback(req) {
			const {server} = req;
			req.expectArgumentLength(1);
			const storeId = req.query.args[0];
			const diagnostics = [];

			const store = await server.recoveryStore.getStore(
				storeId,
				req.getDiagnosticLocationFromFlags({
					type: "arg",
					key: 0,
				}),
			);

			for (const {originalPath, artifactPath} of store.entries) {
				// Original may have been deleted
				let original = "";
				if (await ___R$project$rome$$internal$fs$index_ts$exists(originalPath)) {
					original = await ___R$project$rome$$internal$fs$index_ts$readFileText(
						originalPath,
					);
				}

				const artifact = await ___R$project$rome$$internal$fs$index_ts$readFileText(
					artifactPath,
				);

				diagnostics.push({
					location: {
						filename: originalPath.join(),
					},
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.RECOVERY_STORE.DIFF(
						original,
						artifact,
					),
				});
			}

			await req.printDiagnostics({diagnostics});
		},
	});

	const ___R$project$rome$$internal$core$server$commands$recover_ts$apply = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.SOURCE_CODE,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`apply a specific patch from the recovery store`,
		usage: "<id>",
		examples: [],
		defineFlags(c) {
			return {
				select: c.get(
					"select",
					{
						description: ___R$project$rome$$internal$markup$escape_ts$markup`When applying a patch show an interactive prompt to select specific files`,
					},
				).asBoolean(false),
			};
		},
		async callback(req, flags) {
			flags.select;
			req.expectArgumentLength(1);
			await ___R$$priv$project$rome$$internal$core$server$commands$recover_ts$applyStore(
				req,
				req.query.args[0],
			);
		},
	});

	const ___R$project$rome$$internal$core$server$commands$recover_ts$pop = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.SOURCE_CODE,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`apply the most recent patch in the recovery story`,
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback(req) {
			req.expectArgumentLength(0);

			const stores = await ___R$$priv$project$rome$$internal$core$server$commands$recover_ts$getAllStores(
				req,
			);

			if (stores.length === 0) {
				req.reporter.error(
					___R$project$rome$$internal$markup$escape_ts$markup`No recovery stores`,
				);
			} else {
				const latestStoreId = stores[stores.length - 1].storeId;
				await ___R$$priv$project$rome$$internal$core$server$commands$recover_ts$applyStore(
					req,
					latestStoreId,
				);
			}
		},
	});

	const ___R$project$rome$$internal$core$server$commands$recover_ts$clear = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.SOURCE_CODE,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`clear the contents of the recovery store`,
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback(req) {
			req.expectArgumentLength(0);
			await req.server.recoveryStore.clear();
			req.reporter.success(
				___R$project$rome$$internal$markup$escape_ts$markup`Cleared recovery store at <emphasis>${req.server.recoveryStore.getDirectory()}</emphasis>`,
			);
		},
	});

	const ___R$project$rome$$internal$core$server$commands$recover_ts$dir = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.SOURCE_CODE,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`print the location of the recovery store`,
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback(req) {
			req.expectArgumentLength(0);
			req.reporter.log(
				___R$project$rome$$internal$markup$escape_ts$markup`${req.server.recoveryStore.getDirectory()}`,
			);
		},
	});


  // project-rome/@internal/core/server/commands/cache.ts
const ___R$project$rome$$internal$core$server$commands$cache_ts = {
		get dir() {
			return ___R$project$rome$$internal$core$server$commands$cache_ts$dir;
		},
		get clear() {
			return ___R$project$rome$$internal$core$server$commands$cache_ts$clear;
		},
	};
	const ___R$project$rome$$internal$core$server$commands$cache_ts$dir = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.SOURCE_CODE,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`show the location of the cache directory`,
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback(req) {
			req.reporter.log(
				___R$project$rome$$internal$markup$escape_ts$markup`${req.server.cache.getDirectory()}`,
			);
		},
	});

	const ___R$project$rome$$internal$core$server$commands$cache_ts$clear = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.SOURCE_CODE,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`clear the cache directory`,
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback(req) {
			await req.server.cache.clear();
			req.reporter.success(
				___R$project$rome$$internal$markup$escape_ts$markup`Cleared cache at <emphasis>${req.server.cache.getDirectory()}</emphasis>`,
			);
		},
	});


  // project-rome/@internal/core/server/commands/_evict.ts
const ___R$project$rome$$internal$core$server$commands$_evict_ts$default = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		description: ___R$project$rome$$internal$markup$escape_ts$markup`evict a file from the memory cache`,
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.INTERNAL,
		usage: "",
		examples: [],
		hidden: true,
		defineFlags() {
			return {};
		},
		async callback(req) {
			const {
				server,
				reporter,
				client,
				query: {args},
			} = req;

			const files =
				args.length === 0 ? server.fileAllocator.getAllOwnedFilenames() : args;

			for (const file of files) {
				const path = client.flags.cwd.resolve(file);
				await server.fileAllocator.evict(
					path,
					___R$project$rome$$internal$markup$escape_ts$markup`client request`,
				);
				reporter.success(
					___R$project$rome$$internal$markup$escape_ts$markup`Evicted ${path}`,
				);
			}

			reporter.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Evicted ${String(
					files.length,
				)} files`,
			);
		},
	});


  // project-rome/@internal/core/server/commands/_moduleSignature.ts
const ___R$project$rome$$internal$core$server$commands$_moduleSignature_ts$default = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.INTERNAL,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`get the module type signature of a file`,
		usage: "",
		examples: [],
		hidden: true,
		defineFlags() {
			return {};
		},
		async callback(req) {
			const {reporter} = req;
			const filename = await req.resolveEntryAssertPathArg(0);
			reporter.inspect(await req.requestWorkerModuleSignature(filename, {}));
		},
	});


  // project-rome/@internal/core/server/commands/_projectDump.ts
const ___R$project$rome$$internal$core$server$commands$_projectDump_ts$default = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.INTERNAL,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`TODO`,
		usage: "",
		examples: [],
		hidden: true,
		defineFlags(c) {
			return {
				complete: c.get("complete").asBoolean(false),
			};
		},
		async callback(req, flags) {
			const path = await req.resolveEntryAssertPathArg(0);
			let project = req.server.projectManager.assertProjectExisting(path);

			while (project !== undefined) {
				req.reporter.log(
					___R$project$rome$$internal$markup$escape_ts$markup`${project.directory}`,
				);
				if (flags.complete) {
					req.reporter.inspect(project.config);
				} else {
					const {consumer} = project.meta;
					if (consumer !== undefined) {
						req.reporter.inspect(consumer.asUnknown());
					}
				}
				project = project.parent;
			}
		},
	});


  // project-rome/@internal/child-process/index.ts
const ___R$$priv$project$rome$$internal$child$process$index_ts$childProcess = require(
		"child_process",
	);
	class ___R$project$rome$$internal$child$process$index_ts$ChildProcess {
		constructor(command, args, opts) {
			this.process = ___R$$priv$project$rome$$internal$child$process$index_ts$childProcess.spawn(
				command,
				args,
				Object.assign({}, opts, {cwd: opts.cwd.join()}),
			);
			this.cwd = opts.cwd;
			this.command = command;
			this.args = args;
			this.output = [];

			const {stdout, stderr} = this.process;

			if (stdout != null) {
				stdout.on(
					"data",
					(chunk) => {
						this.output.push([0, chunk]);
					},
				);
			}

			if (stderr != null) {
				stderr.on(
					"data",
					(chunk) => {
						this.output.push([1, chunk]);
					},
				);
			}
		}

		getDisplayCommand() {
			return this.command + " " + this.args.join(" ");
		}

		getOutput(out = true, err = true) {
			if (!out && !err) {
				return "";
			}

			return this.output.map(([code, chunk]) => {
				if (code === 0 && !out) {
					return "";
				}

				if (code === 1 && !err) {
					return "";
				}

				return chunk;
			}).join("");
		}

		unexpected(message, category = "childProcess/failure") {
			throw ___R$project$rome$$internal$diagnostics$errors_ts$createSingleDiagnosticError({
				description: {
					category,
					message,
					advice: [
						{
							type: "log",
							category: "info",
							text: ___R$project$rome$$internal$markup$escape_ts$markup`Full command`,
						},
						{
							type: "command",
							command: this.getDisplayCommand(),
						},
						{
							type: "log",
							category: "info",
							text: ___R$project$rome$$internal$markup$escape_ts$markup`Output`,
						},
						{
							type: "code",
							language: "text",
							sourceText: this.getOutput(),
						},
					],
				},
				location: {
					filename: this.cwd.join(),
				},
			});
		}

		async waitSuccess() {
			const code = await this.wait();
			if (code !== 0) {
				throw this.unexpected(
					___R$project$rome$$internal$markup$escape_ts$markup`Command <emphasis>${this.command}</emphasis> failed. Exited with code ${code}.`,
				);
			}
			return this;
		}

		wait() {
			return new Promise((resolve) => {
				this.process.on(
					"close",
					(code) => {
						resolve(code);
					},
				);
			});
		}
	}

	function ___R$project$rome$$internal$child$process$index_ts$spawn(
		command,
		args,
		opts,
	) {
		return new ___R$project$rome$$internal$child$process$index_ts$ChildProcess(
			command,
			args,
			opts,
		);
	}


  // project-rome/@internal/vcs/index.ts
function ___R$project$rome$$internal$vcs$index_ts$extractFileList(out) {
		const lines = out.trim().split("\n");

		const files = [];

		for (const line of lines) {
			const match = line.trim().match(/^(?:[AM]|\?\?)\s+(.*?)$/);
			if (match != null) {
				files.push(match[1]);
			}
		}

		return files;
	}

	class ___R$project$rome$$internal$vcs$index_ts$VCSClient {
		constructor(root) {
			this.root = root;
		}

		getDefaultBranch() {
			throw new Error("unimplemented");
		}

		getModifiedFiles(branch) {
			throw new Error("unimplemented");
		}

		getUncommittedFiles() {
			throw new Error("unimplemented");
		}
	}

	class ___R$$priv$project$rome$$internal$vcs$index_ts$GitVCSClient
		extends ___R$project$rome$$internal$vcs$index_ts$VCSClient {
		constructor(root) {
			super(root);
		}

		async getDefaultBranch() {
			const exitCode = await ___R$project$rome$$internal$child$process$index_ts$spawn(
				"git",
				["show-ref", "--verify", "--quiet", "refs/heads/main"],
				{cwd: this.root},
			).wait();
			return exitCode === 0 ? "main" : "master";
		}

		async getUncommittedFiles() {
			const stdout = (await ___R$project$rome$$internal$child$process$index_ts$spawn(
				"git",
				["status", "--short"],
				{cwd: this.root},
			).waitSuccess()).getOutput(true, false);
			return ___R$project$rome$$internal$vcs$index_ts$extractFileList(stdout);
		}

		async getModifiedFiles(branch) {
			const stdout = (await ___R$project$rome$$internal$child$process$index_ts$spawn(
				"git",
				["diff", "--name-status", branch],
				{cwd: this.root},
			).waitSuccess()).getOutput(true, false);
			return ___R$project$rome$$internal$vcs$index_ts$extractFileList(stdout);
		}
	}

	async function ___R$project$rome$$internal$vcs$index_ts$getVCSClient(root) {
		if (
			await ___R$project$rome$$internal$fs$index_ts$exists(root.append(".git"))
		) {
			return new ___R$$priv$project$rome$$internal$vcs$index_ts$GitVCSClient(
				root,
			);
		}

		return undefined;
	}


  // project-rome/@internal/core/server/commands/init.ts
const ___R$project$rome$$internal$core$server$commands$init_ts$default = ___R$project$rome$$internal$core$server$commands_ts$createServerCommand({
		category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.PROCESS_MANAGEMENT,
		description: ___R$project$rome$$internal$markup$escape_ts$markup`initialise the project`,
		usage: "",
		examples: [],
		defineFlags(c) {
			return {
				apply: c.get(
					"apply",
					{
						description: ___R$project$rome$$internal$markup$escape_ts$markup``,
					},
				).asBoolean(false),
				allowDirty: c.get(
					"allowDirty",
					{
						description: ___R$project$rome$$internal$markup$escape_ts$markup`Allow running command with a dirty checkout`,
					},
				).asBoolean(false),
			};
		},
		async callback(req, flags) {
			const {server, client, reporter} = req;

			const {args} = req.query;
			let {cwd} = client.flags;

			// Warn if provided with arguments
			if (args.length > 0) {
				req.expectArgumentLength(
					0,
					0,
					[
						{
							type: "log",
							category: "info",
							text: ___R$project$rome$$internal$markup$escape_ts$markup`If you meant to specify a specific folder to initialize other than the one you're in, use the <code>--cwd</code> flag:`,
						},
						{
							type: "command",
							command: "rome init --cwd " + args[0],
						},
					],
				);
			}

			// Check for sensitive directory
			if (server.projectManager.isBannedProjectPath(cwd)) {
				const diagnostic = {
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.PROJECT_MANAGER.INITING_SENSITIVE(
						cwd,
					),
					location: req.getDiagnosticLocationFromFlags("cwd"),
				};
				throw ___R$project$rome$$internal$diagnostics$errors_ts$createSingleDiagnosticError(
					diagnostic,
				);
			}

			// Don't allow if we're already in a project
			const existingProject = await server.projectManager.findProject(cwd);
			if (existingProject !== undefined) {
				reporter.error(
					___R$project$rome$$internal$markup$escape_ts$markup`Project already exists. Defined at <emphasis>${existingProject.meta.configPath}</emphasis>`,
				);
				reporter.info(
					___R$project$rome$$internal$markup$escape_ts$markup`Use <code>rome config</code> to update an existing config`,
				);
				return;
			}

			// Check for no or dirty repo
			if (flags.apply && !flags.allowDirty) {
				const vcsClient = await ___R$project$rome$$internal$vcs$index_ts$getVCSClient(
					cwd,
				);

				if (vcsClient === undefined) {
					throw ___R$project$rome$$internal$diagnostics$errors_ts$createSingleDiagnosticError({
						location: req.getDiagnosticLocationFromFlags("cwd"),
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.INIT_COMMAND.EXPECTED_REPO,
					});
				} else {
					const uncommittedFiles = await vcsClient.getUncommittedFiles();
					if (uncommittedFiles.length > 0) {
						throw ___R$project$rome$$internal$diagnostics$errors_ts$createSingleDiagnosticError({
							location: req.getDiagnosticLocationFromFlags("cwd"),
							description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.INIT_COMMAND.UNCOMMITTED_CHANGES,
						});
					}
				}
			}

			reporter.heading(
				___R$project$rome$$internal$markup$escape_ts$markup`Welcome to Rome! Let's get you started...`,
			);

			const configPath = cwd.append(
				___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_DIRECTORY,
				"rome.rjson",
			);

			// Track some information about our project generation
			let savedCheckFiles = undefined;
			let remainingCheckErrors = undefined;
			const files = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
			files.set(
				configPath,
				___R$project$rome$$internal$markup$escape_ts$markup`Your project configuration. Documentation: <hyperlink target="https://romefrontend.dev/#project-configuration" />`,
			);

			// We are only using JSONObject here because we don't have an accurate type definition for what
			// the config actually looks like on disk
			let config = {
				root: true,
				name: cwd.getBasename(),
			};

			// Comments to include in the created project config
			const comments = new Map();
			comments.set(
				"",
				{
					inner: [],
					outer: [
						{
							type: "LineComment",
							value: " For configuration documentation see https://romefrontend.dev/#project-configuration",
						},
					],
				},
			);

			async function updateConfig(partial = {}) {
				// Update it on disk
				config = Object.assign({}, config, partial);
				await ___R$project$rome$$internal$fs$index_ts$writeFile(
					configPath,
					___R$project$rome$$internal$codec$json$index_ts$stringifyRJSON(
						config,
						comments,
					) + "\n",
				);
			}

			// Create initial project config
			await ___R$project$rome$$internal$fs$index_ts$createDirectory(
				configPath.getParent(),
			);
			await updateConfig();

			//
			const manifestPath = cwd.append("package.json");
			let manifest;
			if (await ___R$project$rome$$internal$fs$index_ts$exists(manifestPath)) {
				manifest = await ___R$project$rome$$internal$codec$js$manifest$index_ts$normalizeManifest(
					___R$project$rome$$internal$codec$json$index_ts$consumeJSON(
						await ___R$project$rome$$internal$fs$index_ts$readFileTextMeta(
							manifestPath,
						),
					),
				);
			}

			// Generate files
			await reporter.steps([
				{
					message: ___R$project$rome$$internal$markup$escape_ts$markup`Installing Rome as a dependency`,
					test() {
						return (
							manifest !== undefined &&
							!manifest.dependencies.has("rome") &&
							!manifest.devDependencies.has("rome")
						);
					},
					async callback() {
						if (manifest === undefined) {
							// Should not be because of test()
							return;
						}

						// Modify package.json
						manifest.devDependencies.set(
							"rome",
							{
								type: "semver",
								range: ___R$project$rome$$internal$codec$semver$parse_ts$parseSemverRange({
									input: "^" +
									___R$project$rome$$internal$core$common$constants_ts$VERSION,
								}),
							},
						);
						await ___R$project$rome$$internal$fs$index_ts$writeFile(
							manifestPath,
							JSON.stringify(
								___R$project$rome$$internal$codec$js$manifest$convert_ts$convertManifestToJSON(
									manifest,
								),
								null,
								"  ",
							),
						);

						// Run package manager
						let installCommand;
						if (
							await ___R$project$rome$$internal$fs$index_ts$exists(
								cwd.append("yarn.lock"),
							)
						) {
							installCommand = "yarn";
						} else if (
							await ___R$project$rome$$internal$fs$index_ts$exists(
								cwd.append("package-lock.json"),
							)
						) {
							installCommand = "npm";
						}
						if (installCommand !== undefined) {
							const proc = ___R$project$rome$$internal$child$process$index_ts$spawn(
								installCommand,
								["install"],
								{
									cwd,
								},
							);
							await proc.waitSuccess();
						}
					},
				},
				{
					message: ___R$project$rome$$internal$markup$escape_ts$markup`Generating lint config and apply formatting`,
					test() {
						return flags.apply;
					},
					async callback() {
						const linter = new ___R$project$rome$$internal$core$server$linter$Linter_ts$default(
							req,
							{
								apply: true,
							},
						);
						const {printer, savedCount} = await linter.runSingle();
						savedCheckFiles = savedCount;

						const globals = [];
						remainingCheckErrors = 0;
						for (const diag of printer.processor.getDiagnostics()) {
							if (diag.description.category === "lint/js/noUndeclaredVariables") {
								if (diag.meta && diag.meta.identifierName) {
									globals.push(diag.meta.identifierName);
								}
							} else {
								remainingCheckErrors++;
							}
						}
						if (globals.length > 0) {
							await updateConfig({
								lint: {
									globals,
								},
							});
						}
					},
				},
				{
					message: ___R$project$rome$$internal$markup$escape_ts$markup`Generating .editorconfig`,
					async callback() {
						const editorConfigPath = cwd.append(".editorconfig");
						if (
							await ___R$project$rome$$internal$fs$index_ts$exists(
								editorConfigPath,
							)
						) {
							reporter.warn(
								___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${editorConfigPath}</emphasis> already exists`,
							);
							return;
						}

						await server.projectManager.assertProject(cwd);

						// Get unique handlers
						const uniqueHandlers = new Map();
						for (const path of server.memoryFs.glob(cwd)) {
							const {handler} = ___R$project$rome$$internal$core$common$file$handlers$index_ts$getFileHandlerFromPath(
								path,
								undefined,
							);
							if (handler !== undefined) {
								uniqueHandlers.set(handler.ext, handler);
							}
						}

						let editorConfigTabExtensions = [];
						for (const [ext, handler] of uniqueHandlers) {
							if (handler.hasTabs) {
								editorConfigTabExtensions.push("*." + ext);
							}
						}

						let editorConfigTemplate = "";

						if (editorConfigTabExtensions.length > 0) {
							editorConfigTemplate = ___R$project$rome$$internal$string$utils$dedent_ts$dedent`
							[{${editorConfigTabExtensions.sort().join(", ")}}]
							end_of_line = lf
							trim_trailing_whitespace = true
							insert_final_newline = true
							charset = utf-8
							indent_style = tab
							indent_size = 2
						`;
						}

						files.set(
							editorConfigPath,
							___R$project$rome$$internal$markup$escape_ts$markup`Sets editor formatting and indentation options. Documentation: <hyperlink target="https://editorconfig.org/" />`,
						);
						await ___R$project$rome$$internal$fs$index_ts$writeFile(
							editorConfigPath,
							editorConfigTemplate.trim() + "\n",
						);
					},
				},
			]);

			if (savedCheckFiles !== undefined && remainingCheckErrors !== undefined) {
				await reporter.section(
					___R$project$rome$$internal$markup$escape_ts$markup`Summary`,
					async () => {
						if (savedCheckFiles !== undefined && savedCheckFiles > 0) {
							reporter.info(
								___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${savedCheckFiles}</emphasis> <grammarNumber plural="files" singular="file">${String(
									savedCheckFiles,
								)}</grammarNumber> saved`,
							);
						}
						if (remainingCheckErrors === 0) {
							reporter.success(
								___R$project$rome$$internal$markup$escape_ts$markup`No problems found!`,
							);
						} else {
							reporter.warn(
								___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${remainingCheckErrors}</emphasis> errors remaining. Run <code>rome check</code> to view.`,
							);
						}
						reporter.br();
					},
				);
			}

			await reporter.section(
				___R$project$rome$$internal$markup$escape_ts$markup`Files created`,
				async () => {
					reporter.list(
						Array.from(
							files,
							([path, purpose]) =>
								___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${path}</emphasis>: ${purpose}`
							,
						),
					);
				},
			);

			await reporter.section(
				___R$project$rome$$internal$markup$escape_ts$markup`What next?`,
				() => {
					reporter.list(
						[
							___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>Setup an editor extension</emphasis>\nGet live errors as you type and format when you save. Learn more: <hyperlink target="https://romefrontend.dev/#editor-integration" />`,
							___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>Try a command</emphasis>\n<code>rome check</code> is used to validate your code, verify formatting, and check for lint errors. Run <code>rome --help</code> for a full list of commands and flags.`,
							___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>Read documentation</emphasis>\nOur website serves as a comprehensive source of guides and documentation <hyperlink target="https://romefrontend.dev/" />`,
							___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>Get involved in the community</emphasis>\nAsk questions, get support, or contribute by participating on GitHub (<hyperlink target="https://github.com/romefrontend/rome"/>) or our community Discord (<hyperlink target="https://discord.gg/rome" />)`,
						],
						{
							ordered: true,
							pad: true,
						},
					);
					reporter.br();
				},
			);

			return true;
		},
	});


  // project-rome/@internal/core/server/commands.ts
function ___R$project$rome$$internal$core$server$commands_ts$createServerCommand(
		cmd,
	) {
		return cmd;
	}

	async function ___R$project$rome$$internal$core$server$commands_ts$chainCommands(
		req,
		fns,
	) {
		let printer;

		await req.reporter.steps(
			fns.map(({callback, progress, title}) => {
				return {
					clear: true,
					message: progress,
					async callback() {
						try {
							await callback();
						} catch (err) {
							if (
								err instanceof
								___R$project$rome$$internal$cli$diagnostics$DiagnosticsPrinter_ts$default
							) {
								if (printer === undefined) {
									printer = req.createDiagnosticsPrinter();
								}
								printer.inject(title, err);
							} else {
								throw err;
							}
						}
					},
				};
			}),
		);

		if (printer !== undefined) {
			throw printer;
		}
	}

	const ___R$project$rome$$internal$core$server$commands_ts$serverCommands = new Map();
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"_evict",
		___R$project$rome$$internal$core$server$commands$_evict_ts$default,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"_moduleSignature",
		___R$project$rome$$internal$core$server$commands$_moduleSignature_ts$default,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"_projectDump",
		___R$project$rome$$internal$core$server$commands$_projectDump_ts$default,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"analyzeDependencies",
		___R$project$rome$$internal$core$server$commands$analyzeDependencies_ts$default,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"bundle",
		___R$project$rome$$internal$core$server$commands$bundle_ts$default,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"cache dir",
		___R$project$rome$$internal$core$server$commands$cache_ts.dir,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"cache clear",
		___R$project$rome$$internal$core$server$commands$cache_ts.clear,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"check",
		___R$project$rome$$internal$core$server$commands$check_ts$default,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"ci",
		___R$project$rome$$internal$core$server$commands$ci_ts$default,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"compile",
		___R$project$rome$$internal$core$server$commands$compile_ts$default,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"config location",
		___R$project$rome$$internal$core$server$commands$config_ts.location,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"config disable",
		___R$project$rome$$internal$core$server$commands$config_ts.disable,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"config enable",
		___R$project$rome$$internal$core$server$commands$config_ts.enable,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"config push",
		___R$project$rome$$internal$core$server$commands$config_ts.push,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"config set",
		___R$project$rome$$internal$core$server$commands$config_ts.set,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"config set-directory",
		___R$project$rome$$internal$core$server$commands$config_ts.setDirectory,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"develop",
		___R$project$rome$$internal$core$server$commands$develop_ts$default,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"format",
		___R$project$rome$$internal$core$server$commands$format_ts$default,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"init",
		___R$project$rome$$internal$core$server$commands$init_ts$default,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"lsp",
		___R$project$rome$$internal$core$server$commands$lsp_ts$default,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"json",
		___R$project$rome$$internal$core$server$commands$json_ts$default,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"noop",
		___R$project$rome$$internal$core$server$commands$noop_ts$default,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"parse",
		___R$project$rome$$internal$core$server$commands$parse_ts$default,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"publish",
		___R$project$rome$$internal$core$server$commands$publish_ts$default,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"resolve",
		___R$project$rome$$internal$core$server$commands$resolve_ts$default,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"run",
		___R$project$rome$$internal$core$server$commands$run_ts$default,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"stop",
		___R$project$rome$$internal$core$server$commands$stop_ts$default,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"status",
		___R$project$rome$$internal$core$server$commands$status_ts$default,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"test",
		___R$project$rome$$internal$core$server$commands$test_ts$default,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"recover apply",
		___R$project$rome$$internal$core$server$commands$recover_ts.apply,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"recover clear",
		___R$project$rome$$internal$core$server$commands$recover_ts.clear,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"recover diff",
		___R$project$rome$$internal$core$server$commands$recover_ts.diff,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"recover dir",
		___R$project$rome$$internal$core$server$commands$recover_ts.dir,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"recover list",
		___R$project$rome$$internal$core$server$commands$recover_ts.list,
	);
	___R$project$rome$$internal$core$server$commands_ts$serverCommands.set(
		"recover pop",
		___R$project$rome$$internal$core$server$commands$recover_ts.pop,
	);


  // project-rome/@internal/core/server/project/ProjectManager.ts
function ___R$$priv$project$rome$$internal$core$server$project$ProjectManager_ts$cleanUidParts(
		parts,
	) {
		let uid = "";

		let lastPart = "";
		for (const part of parts) {
			if (uid !== "") {
				uid += "/";
			}

			// Prune off any prefix shared with the last part
			let sharedPrefix = "";
			for (let i = 0; i < part.length && lastPart[i] === part[i]; i++) {
				sharedPrefix += part[i];
			}

			const partWithoutExtension = part.split(".")[0];
			if (sharedPrefix === partWithoutExtension) {
				uid += part;
			} else {
				uid += part.slice(sharedPrefix.length);
			}

			lastPart = part;
		}

		return uid;
	}

	// If a UID has a relative path that's just index.js, index.ts etc then omit it
	function ___R$$priv$project$rome$$internal$core$server$project$ProjectManager_ts$cleanRelativeUidPath(
		relative,
	) {
		return relative.join();

		const segments = relative.getSegments();

		// Quick deopt if there last segment is not index.
		if (!segments[segments.length - 1].startsWith("index.")) {
			return relative.join();
		}

		// Verify and pop off the last segment if it matches index.VALID_JS_EXTENSION
		const basename = relative.getBasename();
		for (const ext of ___R$project$rome$$internal$core$common$file$handlers$javascript_ts$IMPLICIT_JS_EXTENSIONS) {
			// Got a matching basename that we should omit
			if (basename === "index." + ext) {
				if (segments.length === 1) {
					// If there's a single segment then we don't want anything
					return undefined;
				} else {
					return relative.getParent().join();
				}
			}
		}

		// No matches, we hit the index. check above but not any of the valid extensions
		return relative.join();
	}

	class ___R$project$rome$$internal$core$server$project$ProjectManager_ts$default {
		constructor(server) {
			this.server = server;
			this.logger = server.logger.namespace(
				___R$project$rome$$internal$markup$escape_ts$markup`[ProjectManager]`,
			);

			this.projectIdCounter = 0;
			this.projectConfigDependenciesToIds = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
			this.projectLoadingLocks = new ___R$project$rome$$internal$async$lockers_ts$FilePathLocker();
			this.projectDirectoryToProject = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
			this.projects = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
				"projects",
			);

			// We maintain these maps so we can reverse any uids, and protect against collisions
			this.uidToFilename = new Map();
			this.filenameToUid = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
			this.remoteToLocalPath = new ___R$project$rome$$internal$path$collections_ts$UnknownPathMap();
			this.localPathToRemote = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
		}

		async init() {
			await this.injectVirtualModules();

			this.server.memoryFs.deletedFileEvent.subscribe((paths) => {
				this.handleDeleted(paths);
			});

			const vendorProjectConfig = Object.assign(
				{},
				___R$project$rome$$internal$project$types_ts$createDefaultProjectConfig(),
				{name: "rome-internal-remote"},
			);
			const defaultVendorPath = vendorProjectConfig.files.vendorPath;
			// TODO find a way to do th
			await ___R$project$rome$$internal$fs$index_ts$createDirectory(
				defaultVendorPath,
			);
			await this.declareProject({
				projectDirectory: defaultVendorPath,
				meta: ___R$project$rome$$internal$project$types_ts$createDefaultProjectConfigMeta(),
				config: vendorProjectConfig,
			});
			await this.server.memoryFs.watch(defaultVendorPath);
		}

		// Add a default project for virtual modules
		// This will automatically be sent to workers
		async injectVirtualModules() {
			const projectDirectory = this.server.virtualModules.getMockDirectory();

			const projectConfig = Object.assign(
				{},
				___R$project$rome$$internal$project$types_ts$createDefaultProjectConfig(),
				{name: "rome-virtual-modules"},
			);

			await this.declareProject({
				projectDirectory,
				meta: ___R$project$rome$$internal$project$types_ts$createDefaultProjectConfigMeta(),
				config: projectConfig,
			});
		}

		handleDeleted(paths) {
			for (const path of paths) {
				const filename = path.join();

				this.projectConfigDependenciesToIds.delete(path);

				// Remove uids
				const uid = this.filenameToUid.get(path);
				this.filenameToUid.delete(path);
				if (uid !== undefined) {
					this.uidToFilename.delete(filename);
				}
			}
		}

		getRemoteFromLocalPath(path) {
			return this.localPathToRemote.get(path);
		}

		getFilePathFromUid(uid) {
			return this.uidToFilename.get(uid);
		}

		getFilePathFromUidOrAbsolute(uid) {
			if (uid === undefined) {
				return undefined;
			}

			const uidToPath = this.getFilePathFromUid(uid);
			if (uidToPath !== undefined) {
				return uidToPath;
			}

			const path = ___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
				uid,
			);
			if (path.isAbsolute()) {
				return path.assertAbsolute();
			}

			return undefined;
		}

		normalizeFilenamesToFilePaths(filenames) {
			const others = new Set();
			const absolutes = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet();

			for (const filename of filenames) {
				if (filename === undefined) {
					others.add(undefined);
					continue;
				}

				const absolute = this.getFilePathFromUidOrAbsolute(filename);
				if (absolute === undefined) {
					// Relative path
					others.add(filename);
				} else {
					absolutes.add(absolute);
				}
			}

			return {absolutes, others};
		}

		setUid(path, uid) {
			const filename = path.join();

			// Verify we didn't already generate this uid for another file
			const collided = this.uidToFilename.get(uid);
			if (collided !== undefined && !collided.equal(path)) {
				throw new Error(
					"UID collision between " + filename + " and " + collided + ": " + uid,
				);
			}

			this.uidToFilename.set(uid, path);
			this.filenameToUid.set(path, uid);
		}

		getUid(path, allowMissing = false) {
			// We maintain a map of file paths to UIDs
			// We clear the UID when a path is deleted.
			// If getUid is called on a file that doesn't exist then we'll populate it and it will exist forever.
			if (!this.server.memoryFs.exists(path) && !allowMissing) {
				throw new ___R$project$rome$$internal$fs$FileNotFound_ts$FileNotFound(
					path,
				);
			}

			// Allow passing in a UID
			const filename = path.join();
			if (this.uidToFilename.has(filename)) {
				return filename;
			}

			// Check if we've already calculated and saved a UID
			const existing = this.filenameToUid.get(path);
			if (existing !== undefined) {
				return existing;
			}

			const project = this.assertProjectExisting(path);

			// Format of uids will be <PROJECT_NAME>/<PACKAGE_NAME>/<RELATIVE>
			const parts = [];

			let root = project.directory;

			// Push on parent package names
			let targetPackagePath = path;
			while (true) {
				const pkg = this.server.memoryFs.getOwnedManifest(targetPackagePath);
				if (pkg === undefined || pkg.directory.equal(project.directory)) {
					break;
				} else {
					const name = ___R$project$rome$$internal$codec$js$manifest$name_ts$manifestNameToString(
						pkg.manifest.name,
					);
					if (name !== undefined) {
						parts.unshift(name);

						if (targetPackagePath === path) {
							root = pkg.directory;
						}
					}
					targetPackagePath = pkg.directory.getParent();
				}
			}

			parts.unshift(project.config.name);

			const relative = ___R$$priv$project$rome$$internal$core$server$project$ProjectManager_ts$cleanRelativeUidPath(
				root.relative(path),
			);
			if (relative !== undefined) {
				parts.push(relative);
			}

			const uid = ___R$$priv$project$rome$$internal$core$server$project$ProjectManager_ts$cleanUidParts(
				parts,
			);
			if (this.server.memoryFs.exists(path) || !allowMissing) {
				this.setUid(path, uid);
			}
			return uid;
		}

		getFileReference(path) {
			const project = this.assertProjectExisting(path);
			const uid = this.getUid(path);
			const pkg = this.server.memoryFs.getOwnedManifest(path);
			return {
				uid,
				project: project.id,
				real: path,
				manifest: pkg === undefined ? undefined : pkg.id,
				relative: project.directory.relative(path).assertRelative(),
				remote: this.localPathToRemote.has(path),
			};
		}

		getURLFileReference(local, url) {
			if (!this.remoteToLocalPath.has(url)) {
				this.remoteToLocalPath.set(url, local);
				this.localPathToRemote.set(local, url);
			}

			return this.getFileReference(local);
		}

		async maybeEvictProjects(paths) {
			// Check if this filename is a rome config dependency
			let projectIds = new Set();
			for (const path of paths) {
				const pathProjectIds = this.projectConfigDependenciesToIds.get(path);
				if (pathProjectIds !== undefined) {
					projectIds = new Set([...projectIds, ...pathProjectIds]);
				}
			}
			if (projectIds.size === 0) {
				return false;
			}

			const projectsToEvict = new Set();

			function getAllProjects(project) {
				let children = [];
				for (const child of project.children) {
					children = children.concat(getAllProjects(child));
				}
				return [project, ...children];
			}

			for (const evictProjectId of projectIds) {
				// Fetch the project
				const project = this.projects.assert(evictProjectId);

				// Add all parent projects
				let topProject = project;
				while (topProject.parent !== undefined) {
					topProject = topProject.parent;
				}
				for (const project of getAllProjects(topProject)) {
					projectsToEvict.add(project);
				}
			}

			// Evict
			for (const project of projectsToEvict) {
				await this.evictProject(project, true);
			}

			return true;
		}

		async evictProject(project, reload) {
			await this.server.memoryFs.processingLock.wrap(async () => {
				const evictProjectId = project.id;

				// Remove the config locs from our internal map that belong to this project
				for (const [configLoc, projectIds] of this.projectConfigDependenciesToIds) {
					if (projectIds.has(evictProjectId)) {
						projectIds.delete(evictProjectId);
					}

					if (projectIds.size === 0) {
						this.projectConfigDependenciesToIds.delete(configLoc);
					}
				}

				// Notify all workers that it should delete the project
				for (const {bridge} of this.server.workerManager.getWorkers()) {
					// Evict project
					bridge.updateProjects.send({
						projects: [
							{
								id: evictProjectId,
								directory: project.directory,
								config: undefined,
							},
						],
					});

					// Evict packages
					bridge.updateManifests.send({
						manifests: Array.from(
							project.manifests.values(),
							(def) => ({
								id: def.id,
								manifest: undefined,
							}),
						),
					});
				}

				// Delete the project from 'our internal map
				this.projects.delete(evictProjectId);
				this.projectDirectoryToProject.delete(project.directory);

				// Tell the MemoryFileSystem to close the watcher so new file events are not emitted
				this.server.memoryFs.close(project.directory);

				// Evict all files that belong to this project and delete their project mapping
				const ownedFiles = Array.from(
					this.server.memoryFs.glob(project.directory),
				);
				this.handleDeleted(ownedFiles);
				await Promise.all(
					ownedFiles.map((path) =>
						this.server.fileAllocator.evict(
							path,
							___R$project$rome$$internal$markup$escape_ts$markup`project dependency change`,
						)
					),
				);

				// Tell the MemoryFileSystem to clear it's maps
				this.server.memoryFs.unwatch(project.directory);

				this.logger.info(
					___R$project$rome$$internal$markup$escape_ts$markup`Evicted project <emphasis>${project.directory}</emphasis>`,
				);

				if (reload) {
					this.logger.info(
						___R$project$rome$$internal$markup$escape_ts$markup`Reloading evicted project <emphasis>${project.directory}</emphasis>`,
					);
					await this.findProject(project.directory);
				}
			});
		}

		getProjects() {
			return Array.from(this.projects.values());
		}

		addDependencyToProjectId(path, projectId) {
			const ids = this.projectConfigDependenciesToIds.get(path);

			if (ids === undefined) {
				this.projectConfigDependenciesToIds.set(path, new Set([projectId]));
			} else {
				ids.add(projectId);
			}
		}

		findProjectConfigConsumer(def, test) {
			const meta = ___R$project$rome$$internal$project$utils_ts$assertHardMeta(
				def.meta,
			);

			for (const consumer of meta.consumersChain) {
				const value = test(consumer);
				if (value !== undefined && value !== false && value.exists()) {
					return {value, consumer: meta.consumer};
				}
			}

			return {value: undefined, consumer: meta.consumer};
		}

		async getVCSClient(project) {
			const client = await this.maybeGetVCSClient(project);

			if (client === undefined) {
				const {
					value: rootConfigConsumer,
					consumer,
				} = this.findProjectConfigConsumer(
					project,
					(consumer) => consumer.has("vsc") && consumer.get("vsc").get("root"),
				);

				const rootConfigLocation =
					rootConfigConsumer === undefined
						? undefined
						: rootConfigConsumer.getDiagnosticLocation();

				const location =
					rootConfigLocation === undefined
						? consumer.getDiagnosticLocation()
						: rootConfigLocation;

				throw ___R$project$rome$$internal$diagnostics$errors_ts$createSingleDiagnosticError({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.PROJECT_MANAGER.NO_VCS(
						rootConfigLocation,
					),
					location,
				});
			} else {
				return client;
			}
		}

		async maybeGetVCSClient(project) {
			return await ___R$project$rome$$internal$vcs$index_ts$getVCSClient(
				project.config.vcs.root,
			);
		}

		addDiskProject(opts) {
			const {projectDirectory, configPath} = opts;

			return this.projectLoadingLocks.wrapLock(
				projectDirectory,
				async () => {
					if (this.hasLoadedProjectDirectory(projectDirectory)) {
						// Already defined
						return;
					}

					const {config, meta} = await ___R$project$rome$$internal$project$load_ts$loadCompleteProjectConfig(
						projectDirectory,
						configPath,
					);

					await this.declareProject({
						projectDirectory: opts.projectDirectory,
						meta,
						config,
					});
				},
			);
		}

		async declareProject(
			{
				projectDirectory,
				meta,
				config,
			},
		) {
			// Make sure there's no project with the same `name` as us
			for (const project of this.getProjects()) {
				if (project.config.name === config.name) {
					// TODO
					throw new Error(
						"Conflicting project name " +
						config.name +
						". " +
						projectDirectory.join() +
						" and " +
						project.directory.join(),
					);
				}
			}

			// Declare the project
			const parentProject = this.findLoadedProject(projectDirectory.getParent());
			const project = {
				config,
				meta,
				directory: projectDirectory,
				id: this.projectIdCounter++,
				packages: new Map(),
				manifests: new Map(),
				parent: parentProject,
				children: new Set(),
				initialized: false,
			};

			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Declared project <emphasis>#${project.id}</emphasis> from <emphasis>${projectDirectory}</emphasis>`,
			);

			this.projects.set(project.id, project);
			this.projectDirectoryToProject.set(projectDirectory, project);

			if (parentProject !== undefined) {
				parentProject.children.add(project);
			}

			// Add all project config dependencies so changes invalidate the whole project
			if (meta.configPath !== undefined) {
				this.addDependencyToProjectId(meta.configPath, project.id);
			}
			for (const loc of meta.configDependencies) {
				this.addDependencyToProjectId(loc, project.id);
			}

			// Notify other pieces of our creation
			await this.server.workerManager.onNewProject(project);
		}

		declareManifest(project, isProjectPackage, def, diagnostics) {
			const name = ___R$project$rome$$internal$codec$js$manifest$name_ts$manifestNameToString(
				def.manifest.name,
			);

			const type = isProjectPackage ? "project package manifest" : "manifest";
			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Declaring ${type} <emphasis>${name}</emphasis> in project <emphasis>#${project.id}</emphasis> in <emphasis>${def.directory}</emphasis>`,
			);

			// Declare this package in all projects
			const projects = this.getHierarchyFromProject(project);

			// Check for collisions
			if (isProjectPackage && name !== undefined) {
				for (const project of projects) {
					// If there is no package then there's nothing to collide
					const existingPackage = project.packages.get(name);
					if (existingPackage === undefined) {
						continue;
					}

					diagnostics.addDiagnostic({
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.PROJECT_MANAGER.DUPLICATE_PACKAGE(
							name,
							existingPackage.path.join(),
						),
						location: def.consumer.get("name").getDiagnosticLocation(
							"inner-value",
						),
					});
					return;
				}
			}

			// Set as a package
			for (const project of projects) {
				this.addDependencyToProjectId(def.path, project.id);
				project.manifests.set(def.id, def);

				if (isProjectPackage && name !== undefined) {
					project.packages.set(name, def);
				}
			}
		}

		async notifyWorkersOfProjects(workers, projects) {
			if (projects === undefined) {
				projects = Array.from(this.projects.values());
			}

			const manifestsSerial = [];
			const projectsSerial = [];
			for (const project of projects) {
				projectsSerial.push({
					config: project.config,
					id: project.id,
					directory: project.directory,
				});

				for (const def of project.manifests.values()) {
					manifestsSerial.push({
						id: def.id,
						manifest: this.server.memoryFs.getPartialManifest(def),
					});
				}
			}

			const promises = [];

			for (const worker of workers) {
				promises.push(
					worker.bridge.updateProjects.call({projects: projectsSerial}),
				);
				promises.push(
					worker.bridge.updateManifests.call({
						manifests: manifestsSerial,
					}),
				);
			}

			await Promise.all(promises);
		}

		async assertProject(path, location) {
			const project =
				this.findLoadedProject(path) || (await this.findProject(path));
			if (project) {
				return project;
			}

			if (location === undefined) {
				throw new Error(
					"Couldn't find a project. Checked " +
					___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_FILENAMES.join(
						" or ",
					) +
					" for " +
					path.join(),
				);
			} else {
				throw ___R$project$rome$$internal$diagnostics$errors_ts$createSingleDiagnosticError({
					location,
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.PROJECT_MANAGER.NOT_FOUND,
				});
			}
		}

		hasLoadedProjectDirectory(path) {
			return this.projectDirectoryToProject.has(path);
		}

		// Convenience method to get the project config and pass it to the file handler class
		getHandlerWithProject(path) {
			const project = this.findLoadedProject(path);
			if (project === undefined) {
				return {ext: "", handler: undefined};
			} else {
				return ___R$project$rome$$internal$core$common$file$handlers$index_ts$getFileHandlerFromPath(
					path,
					project.config,
				);
			}
		}

		getHierarchyFromProject(project) {
			const projects = [];

			let currProject = project;
			while (currProject !== undefined) {
				projects.push(currProject);

				// root projects shouldn't be considered to have any parents
				if (currProject.config.root) {
					break;
				}

				currProject = project.parent;
			}

			return projects;
		}

		assertProjectExisting(path) {
			const project = this.findLoadedProject(path);
			if (project === undefined) {
				throw new Error(
					"Expected existing project for " +
					path.join() +
					" only have " +
					Array.from(
						this.projectDirectoryToProject.keys(),
						(directory) => directory.join(),
					).join(", "),
				);
			}
			return project;
		}

		getProjectFromPath(path) {
			return this.projectDirectoryToProject.get(path);
		}

		findLoadedProject(path) {
			for (const dir of path.getChain()) {
				const project = this.projectDirectoryToProject.get(dir);
				if (project !== undefined) {
					return project;
				}
			}

			return undefined;
		}

		// Attempt to find a project on the real disk and seed it into the memory file system
		async findProject(cwd) {
			await this.server.memoryFs.processingLock.wait();

			// Check if we have an existing project
			const syncProject = this.findLoadedProject(cwd);
			if (syncProject !== undefined) {
				return syncProject;
			}

			const processor = ___R$project$rome$$internal$diagnostics$DiagnosticsProcessor_ts$default.createImmediateThrower([
				{
					category: "project-manager",
					message: "Find project",
				},
			]);

			const parentDirectories = cwd.getChain();

			// If not then let's access the file system and try to find one
			for (const dir of parentDirectories.slice().reverse()) {
				// Check for dedicated project configs
				for (const configFilename of ___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_FILENAMES) {
					// Check in root
					const configPath = dir.append(
						___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_DIRECTORY,
						configFilename,
					);

					const hasProject = await this.server.memoryFs.existsHard(configPath);
					if (hasProject) {
						if (this.isLoadingBannedProjectPath(dir, configPath, processor)) {
							// Would have emitted a diagnostic
							return;
						}

						await this.server.memoryFs.watch(dir);
						return this.assertProjectExisting(cwd);
					}
				}

				// Check for package.json
				const packagePath = dir.append("package.json");
				if (await this.server.memoryFs.existsHard(packagePath)) {
					const input = await ___R$project$rome$$internal$fs$index_ts$readFileText(
						packagePath,
					);
					const json = await ___R$project$rome$$internal$codec$json$index_ts$consumeJSON({
						input,
						path: packagePath,
					});
					if (
						json.has(
							___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_PACKAGE_JSON_FIELD,
						)
					) {
						if (this.isLoadingBannedProjectPath(dir, packagePath, processor)) {
							// Would have emitted a diagnostic
							return;
						}

						await this.server.memoryFs.watch(dir);
						return this.assertProjectExisting(cwd);
					}
				}
			}

			// If we didn't find a project config then
			for (const dir of parentDirectories) {
				// Check for typo config filenames
				for (const basename of ___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_WARN_FILENAMES) {
					const path = dir.append(basename);

					if (await this.server.memoryFs.existsHard(path)) {
						this.checkPathForIncorrectConfig(path, processor);
					}
				}

				// Check for configs outside of a .config directory
				for (const configFilename of ___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_FILENAMES) {
					const path = dir.append(configFilename);

					if (await this.server.memoryFs.existsHard(path)) {
						this.checkPathForIncorrectConfig(path, processor);
					}
				}
			}

			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Found no project for <emphasis>${cwd}</emphasis>`,
			);

			return undefined;
		}

		// Refuse to load project path or root as valid project directories
		isBannedProjectPath(projectFolder) {
			return (
				projectFolder.isRoot() ||
				___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_SENSITIVE_DIRECTORIES.has(
					projectFolder,
				)
			);
		}

		// Create a diagnostic if the project folder is sensitive
		isLoadingBannedProjectPath(projectFolder, configPath, diagnostics) {
			if (this.isBannedProjectPath(projectFolder)) {
				diagnostics.addDiagnostic({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.PROJECT_MANAGER.LOADING_SENSITIVE(
						projectFolder,
					),
					location: {
						filename: configPath.join(),
					},
				});
				return true;
			} else {
				return false;
			}
		}

		checkPathForIncorrectConfig(path, diagnostics) {
			if (
				___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_WARN_FILENAMES.includes(
					path.getBasename(),
				)
			) {
				diagnostics.addDiagnostic({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.PROJECT_MANAGER.TYPO_CONFIG_FILENAME(
						path.getBasename(),
						___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_FILENAMES,
					),
					location: {
						filename: path.join(),
					},
				});
			}

			if (
				___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_FILENAMES.includes(
					path.getBasename(),
				) &&
				path.getParent().getBasename() !==
				___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_DIRECTORY
			) {
				diagnostics.addDiagnostic({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.PROJECT_MANAGER.MISPLACED_CONFIG(
						path.getBasename(),
					),
					location: {
						filename: path.join(),
					},
				});
			}
		}
	}


  // project-rome/@internal/core/server/WorkerManager.ts
const ___R$$priv$project$rome$$internal$core$server$WorkerManager_ts$workerThreads = require(
		"worker_threads",
	);
	class ___R$project$rome$$internal$core$server$WorkerManager_ts$default {
		constructor(server) {
			this.server = server;

			this.workerStartEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "WorkerManager.workerStart",
			});
			this.selfWorker = true;
			this.locker = new ___R$project$rome$$internal$async$lockers_ts$Locker();
			this.workers = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
				"workers",
			);
			this.idCounter = 0;

			this.logger = server.logger.namespace(
				___R$project$rome$$internal$markup$escape_ts$markup`[WorkerManager]`,
			);
		}

		getNextWorkerId() {
			return this.idCounter++;
		}

		getWorkerAssert(id) {
			return this.workers.assert(id);
		}

		getWorkers() {
			return Array.from(this.workers.values());
		}

		// Get worker count, excluding ghost workers
		getWorkerCount() {
			let count = 0;
			for (const worker of this.workers.values()) {
				if (worker.ghost === false) {
					count++;
				}
			}
			return count;
		}

		// Get all the workers that live in external processes
		getExternalWorkers() {
			return this.getWorkers().filter((worker) => worker.thread !== undefined);
		}

		async end() {
			// Shutdown all workers, no need to clean up any internal data structures since they will never be used
			await Promise.all(
				Array.from(
					this.workers.values(),
					async ({thread, bridge}) => {
						if (thread !== undefined) {
							bridge.end();
							await thread.terminate();
						}
					},
				),
			);
		}

		getLowestByteCountWorker() {
			// Find the worker with the lowest byteCount value
			let smallestWorker;
			let byteCount;
			for (const worker of this.workers.values()) {
				if (
					!worker.ghost &&
					(byteCount === undefined || byteCount > worker.byteCount)
				) {
					smallestWorker = worker;
					byteCount = worker.byteCount;
				}
			}

			if (smallestWorker === undefined) {
				// This shouldn't be possible
				throw new Error("No worker found");
			} else {
				return smallestWorker;
			}
		}

		async init() {
			// Create the worker
			const bridge = ___R$project$rome$$internal$events$bridgeCreators_ts$createBridgeFromLocal(
				___R$project$rome$$internal$core$common$bridges$WorkerBridge_ts$default,
				{
					onSendMessage: (msg) => {
						this.logger.info(
							___R$project$rome$$internal$markup$escape_ts$markup`Sending local worker request: ${___R$project$rome$$internal$pretty$format$index_ts$default(
								msg,
							)}`,
						);
					},
				},
			);
			const worker = new ___R$project$rome$$internal$core$worker$Worker_ts$default({
				id: 0,
				userConfig: this.server.userConfig,
				bridge,
				dedicated: false,
			});

			// We make an assumption elsewhere in the code that this is always the first worker
			// Let's use an invariant here for completeness
			const id = this.getNextWorkerId();
			if (id !== 0) {
				throw new Error("Expected server worker id to be 0");
			}

			const container = {
				id: 0,
				fileCount: 0,
				byteCount: 0,
				thread: undefined,
				bridge,
				ghost: false,
				ready: false,
			};
			this.workers.set(0, container);
			await worker.init();

			await Promise.all([this.workerHandshake(container), bridge.handshake()]);

			this.workerStartEvent.send(bridge);
		}

		async replaceOwnWorker() {
			const lock = this.locker.getNewLock(0);

			try {
				const serverWorker = this.getWorkerAssert(0);
				this.logger.info(
					___R$project$rome$$internal$markup$escape_ts$markup`Spawning first worker outside of server after exceeding ${String(
						___R$project$rome$$internal$core$common$constants_ts$MAX_MASTER_BYTES_BEFORE_WORKERS,
					)} bytes`,
				);
				this.selfWorker = false;

				// Spawn a new worker
				const newWorker = await this.spawnWorker(this.getNextWorkerId(), true);

				// Transfer buffers to the new worker
				const buffers = await serverWorker.bridge.getFileBuffers.call();

				for (const {filename, content} of buffers) {
					await newWorker.bridge.updateBuffer.call({
						ref: this.server.projectManager.getFileReference(
							___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
								filename,
							),
						),
						content,
					});
				}

				// End the old worker, will automatically cleanup
				serverWorker.bridge.end();

				// Swap the workers

				// We perform this as a single atomic operation rather than doing it in spawnWorker so we have predictable worker retrieval
				this.workers.set(
					0,
					{
						id: 0,
						fileCount: serverWorker.fileCount,
						byteCount: serverWorker.byteCount,
						bridge: newWorker.bridge,
						thread: newWorker.thread,
						ghost: false,
						ready: true,
					},
				);
				this.workers.delete(newWorker.id);
			} finally {
				lock.release();
			}
		}

		async onNewProject(newProject) {
			await this.server.projectManager.notifyWorkersOfProjects(
				this.getWorkers(),
				[newProject],
			);
		}

		async workerHandshake(worker) {
			const {bridge} = worker;
			await bridge.handshake({timeout: 3_000});
			await this.server.projectManager.notifyWorkersOfProjects([worker]);
			worker.ready = true;
		}

		async spawnWorker(workerId, isGhost = false) {
			const lock = this.locker.getNewLock(workerId);
			try {
				return await this._spawnWorker(workerId, isGhost);
			} finally {
				lock.release();
			}
		}

		async _spawnWorker(workerId, isGhost) {
			const fatalErrorSource = ___R$project$rome$$internal$markup$escape_ts$markup`worker ${workerId}`;
			const start = Date.now();

			const thread = ___R$project$rome$$internal$core$common$utils$fork_ts$forkThread(
				"worker",
				{
					workerData: {
						id: workerId,
					},
				},
			);

			const bridge = ___R$project$rome$$internal$events$bridgeCreators_ts$createBridgeFromWorkerThread(
				___R$project$rome$$internal$core$common$bridges$WorkerBridge_ts$default,
				thread,
				{
					type: "client",
					onSendMessage: (data) => {
						this.logger.info(
							___R$project$rome$$internal$markup$escape_ts$markup`Sending dedicated worker request to ${String(
								workerId,
							)}: ${___R$project$rome$$internal$pretty$format$index_ts$default(
								data,
							)}`,
						);
					},
				},
			);

			bridge.fatalError.subscribe((details) => {
				this.server.onFatalError(bridge.hydrateError(details), fatalErrorSource);
			});

			bridge.monitorHeartbeat(
				___R$project$rome$$internal$core$common$constants_ts$LAG_INTERVAL,
				({summary, totalTime, iterations}) => {
					const reporter = this.server.getImportantReporter();
					reporter.warn(
						___R$project$rome$$internal$markup$escape_ts$markup`Worker <emphasis>${workerId}</emphasis> has not responded for <emphasis><duration>${String(
							totalTime,
						)}</duration> seconds</emphasis>. It is unlikely to become responsive. Currently processing:`,
					);
					reporter.list(summary);
					reporter.info(
						___R$project$rome$$internal$markup$escape_ts$markup`Please open an issue with the details provided above if necessary`,
					);

					if (iterations > 5) {
						this.server.onFatalError(
							new Error(
								"Did not respond for " +
								totalTime +
								"ms and was checked " +
								iterations +
								" times",
							),
							fatalErrorSource,
						);
					}
				},
			);

			const worker = {
				id: workerId,
				fileCount: 0,
				byteCount: 0,
				thread,
				bridge,
				ghost: isGhost,
				ready: false,
			};
			this.workers.set(workerId, worker);

			thread.once(
				"error",
				(err) => {
					// The process could not be spawned, or
					// The process could not be killed, or
					// Sending a message to the child process failed.
					this.server.onFatalError(err, fatalErrorSource);
					thread.terminate();
				},
			);

			process.once(
				"exit",
				() => {
					this.server.onFatalError(
						new Error("Process unexpectedly exit"),
						fatalErrorSource,
					);
				},
			);

			await this.workerHandshake(worker);

			// If a worker is spawned while we're profiling then make sure it's profiling too
			const profileData = this.server.getRunningProfilingData();
			if (profileData !== undefined) {
				await bridge.profilingStart.call(profileData);
			}

			this.workerStartEvent.send(bridge);

			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Worker ${String(
					workerId,
				)} started after <duration>${String(Date.now() - start)}</duration>`,
			);

			return worker;
		}

		own(workerId, stats) {
			const worker = this.getWorkerAssert(workerId);
			worker.byteCount += stats.size;
			worker.fileCount++;
		}

		disown(workerId, stats) {
			const worker = this.getWorkerAssert(workerId);
			worker.byteCount -= stats.size;
			worker.fileCount--;
		}

		async getNextWorker(path) {
			const {logger, memoryFs, fileAllocator} = this.server;

			// Get stats first
			let stats = memoryFs.getFileStats(path);
			if (stats === undefined) {
				// Give memoryFs a chance to finish initializing if it's in a pending project
				await this.server.memoryFs.waitIfInitializingWatch(path);

				stats = memoryFs.getFileStatsAssert(path);
			}

			// Verify that this file doesn't exceed any size limit
			fileAllocator.verifySize(path, stats);

			// Lock in case we're in the process of swapping the server worker with a dedicated worker
			await this.locker.waitLock(0);

			// If we are inband only then we should never fork workers
			if (this.server.options.inbandOnly) {
				this.own(0, stats);
				return this.getWorkerAssert(0);
			}

			// If the worker is running in the server process and we've exceed our byte limit
			// then start up a dedicated worker process
			if (this.selfWorker) {
				const worker = this.getWorkerAssert(0);
				if (
					worker.byteCount >
					___R$project$rome$$internal$core$common$constants_ts$MAX_MASTER_BYTES_BEFORE_WORKERS
				) {
					await this.replaceOwnWorker();
				}
			}

			// Find the worker with the lowest owned byte size
			const smallestWorker = this.getLowestByteCountWorker();
			let workerId = smallestWorker.id;

			// When the smallest worker exceeds the max worker byte limit and we're still under
			// our max worker limit, then let's start a new one
			if (
				smallestWorker.byteCount >
				___R$project$rome$$internal$core$common$constants_ts$MAX_WORKER_BYTES_BEFORE_ADD &&
				this.getWorkerCount() <
				___R$project$rome$$internal$core$common$constants_ts$MAX_WORKER_COUNT
			) {
				logger.info(
					___R$project$rome$$internal$markup$escape_ts$markup`[WorkerManager] Spawning a new worker as we've exceeded ${String(
						___R$project$rome$$internal$core$common$constants_ts$MAX_WORKER_BYTES_BEFORE_ADD,
					)} bytes across each worker`,
				);
				workerId = this.getNextWorkerId();
				await this.spawnWorker(workerId);
			}

			// Register size of file
			this.own(workerId, stats);

			// Just in case we've chosen a worker that's still spawning
			await this.locker.waitLock(workerId);

			return this.getWorkerAssert(workerId);
		}
	}


  // project-rome/@internal/core/common/types/platform.ts
const ___R$project$rome$$internal$core$common$types$platform_ts = {
		get PLATFORMS() {
			return ___R$project$rome$$internal$core$common$types$platform_ts$PLATFORMS;
		},
		get PLATFORM_ALIASES() {
			return ___R$project$rome$$internal$core$common$types$platform_ts$PLATFORM_ALIASES;
		},
	};
	const ___R$project$rome$$internal$core$common$types$platform_ts$PLATFORMS = [
		"ios",
		"android",
		"mobile",
		"electron",
		"web",
		"node",
	];

	const ___R$project$rome$$internal$core$common$types$platform_ts$PLATFORM_ALIASES = {
		ios: ["mobile"],
		android: ["mobile"],
		electron: ["web"],
		mobile: [],
		node: [],
		web: [],
	};


  // project-rome/@internal/core/server/fs/resolverSuggest.ts
function ___R$project$rome$$internal$core$server$fs$resolverSuggest_ts$default(
		{resolver, query, resolved, origQuerySource, server},
	) {
		let errMsg = "";
		if (resolved.type === "UNSUPPORTED") {
			errMsg = "Unsupported path format";
		} else if (resolved.type === "MISSING") {
			errMsg = "Cannot find";
		} else if (resolved.type === "FETCH_ERROR") {
			errMsg = "Failed to fetch";
		}

		errMsg +=
			' "' + query.source.join() + '" from "' + query.origin.join() + '"';

		// Use the querySource returned by the resolution which will be the one that actually triggered this error, otherwise use the query source provided to us
		const querySource =
			resolved.source === undefined ? origQuerySource : resolved.source;
		if (querySource === undefined || querySource.location === undefined) {
			// TODO do something about the `advice` on some `resolved` that may contain metadata?
			throw new Error(errMsg);
		}

		const {location} = querySource;

		let advice = [];

		if (query.origin.isAbsolute()) {
			const localQuery = Object.assign(
				{},
				query,
				{origin: query.origin.assertAbsolute()},
			);

			// Provide advice in strict-mode if a non-strict version existed
			if (query.strict) {
				const nonStrictResolved = resolver.resolveLocal(
					Object.assign({}, localQuery, {strict: false}),
				);

				if (nonStrictResolved.type === "FOUND") {
					if (nonStrictResolved.types.includes("implicitIndex")) {
						advice.push({
							type: "log",
							category: "info",
							text: ___R$project$rome$$internal$markup$escape_ts$markup`This successfully resolves as an implicit index file. Trying adding <emphasis>/index${nonStrictResolved.path.getExtensions()}</emphasis> to the end of the import source`,
						});
					} else if (nonStrictResolved.types.includes("implicitExtension")) {
						advice.push({
							type: "log",
							category: "info",
							text: ___R$project$rome$$internal$markup$escape_ts$markup`This successfully resolves as an implicit extension. Try adding the extension <emphasis>${nonStrictResolved.path.getExtensions()}</emphasis>`,
						});
					}
				}
			}

			// We may set this to `true` for stuff like forgetting a platform
			let skipSimilaritySuggestions = false;

			// Try other platforms
			const validPlatforms = [];
			for (const PLATFORM of ___R$project$rome$$internal$core$common$types$platform_ts$PLATFORMS) {
				if (PLATFORM === query.platform) {
					continue;
				}

				const resolved = resolver.resolveLocal(
					Object.assign({}, localQuery, {platform: PLATFORM}),
				);

				if (resolved.type === "FOUND") {
					validPlatforms.push(
						___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${PLATFORM}</emphasis> at <filelink emphasis target="${resolved.ref.uid}" />`,
					);
				}
			}
			if (validPlatforms.length > 0) {
				if (query.platform === undefined) {
					advice.push({
						type: "log",
						category: "info",
						text: ___R$project$rome$$internal$markup$escape_ts$markup`No platform was specified but we found modules for the following platforms`,
					});
				} else {
					advice.push({
						type: "log",
						category: "info",
						text: ___R$project$rome$$internal$markup$escape_ts$markup`No module found for the platform <emphasis>${query.platform}</emphasis> but we found these others`,
					});
				}

				skipSimilaritySuggestions = true;

				advice.push({
					type: "list",
					list: validPlatforms,
				});
			}

			// Hint on any indirection
			if (
				origQuerySource !== undefined &&
				origQuerySource.location !== undefined &&
				resolved.source !== undefined
			) {
				advice.push({
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Found while resolving <emphasis>${query.source}</emphasis> from <filelink emphasis target="${query.origin}" />`,
				});

				const origPointer = origQuerySource.location;

				advice.push({
					type: "frame",
					location: origPointer,
				});
			}

			// Suggestions based on similarity to paths and packages on disk
			if (!skipSimilaritySuggestions) {
				const suggestions = ___R$$priv$project$rome$$internal$core$server$fs$resolverSuggest_ts$getSuggestions(
					server,
					resolver,
					localQuery,
				);
				if (suggestions.size > 0) {
					const originDirectory = resolver.getOriginDirectory(localQuery);

					// Relative paths to absolute
					const relativeToAbsolute = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
						"relativeToAbsolute",
					);

					const relativeSuggestions = Array.from(
						suggestions,
						([human, absolute]) => {
							if (human !== absolute) {
								relativeToAbsolute.set(human, absolute);
								return human;
							}

							let relativePath = originDirectory.relative(absolute);

							// If the user didn't use extensions, then neither should we
							if (!query.source.hasExtensions()) {
								// TODO only do this if it's an implicit extension
								relativePath = relativePath.changeBasename(
									relativePath.getExtensionlessBasename(),
								);
							}

							const relativeStr = relativePath.toExplicitRelative().join();
							relativeToAbsolute.set(relativeStr, absolute);
							return relativeStr;
						},
					);

					advice = [
						...advice,
						...___R$project$rome$$internal$diagnostics$helpers_ts$buildSuggestionAdvice(
							query.source.join(),
							relativeSuggestions,
							{
								formatItem: (relative) => {
									const absolute = relativeToAbsolute.assert(relative);
									return ___R$project$rome$$internal$markup$escape_ts$markup`<filelink target="${absolute}">${relative}</filelink>`;
								},
							},
						),
					];
				}
			}

			// Hint if this was an entry resolve and the cwd wasn't a project
			if (
				query.entry === true &&
				server.projectManager.findLoadedProject(localQuery.origin) === undefined
			) {
				advice.push({
					type: "log",
					category: "warn",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`You aren't in a Rome project`,
				});
			}
		}

		// TODO check if this would have been successful if not for exports access control
		const source =
			querySource.source === undefined
				? query.source.join()
				: querySource.source;

		if (resolved.advice !== undefined) {
			advice = advice.concat(resolved.advice);
		}

		throw ___R$project$rome$$internal$diagnostics$errors_ts$createSingleDiagnosticError({
			location,
			description: Object.assign(
				{},
				___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.RESOLVER.NOT_FOUND(
					resolved.type,
					source,
					location,
				),
				{advice},
			),
		});
	}

	function ___R$$priv$project$rome$$internal$core$server$fs$resolverSuggest_ts$getPathSuggestions(
		server,
		resolver,
		query,
	) {
		const {source} = query;
		const originDirectory = resolver.getOriginDirectory(query);
		const suggestions = new Map();

		// Try normal resolved
		___R$$priv$project$rome$$internal$core$server$fs$resolverSuggest_ts$tryPathSuggestions({
			server,
			resolver,
			suggestions,
			path: originDirectory.resolve(source),
		});

		// Remove . and .. entries from beginning
		const sourceParts = [...source.getSegments()];
		while (sourceParts[0] === "." || sourceParts[0] === "..") {
			sourceParts.shift();
		}

		// Try parent directories of the origin

		for (const path of originDirectory.getChain()) {
			var ___R$;
			___R$$priv$project$rome$$internal$core$server$fs$resolverSuggest_ts$tryPathSuggestions({
				server,
				resolver,
				suggestions,
				path: (___R$ = path, ___R$.append.apply(___R$, [...sourceParts])),
			});
		}

		return suggestions;
	}

	const ___R$$priv$project$rome$$internal$core$server$fs$resolverSuggest_ts$MIN_SIMILARITY = 0.8;

	function ___R$$priv$project$rome$$internal$core$server$fs$resolverSuggest_ts$tryPathSuggestions(
		{server, resolver, suggestions, path},
	) {
		const {memoryFs} = server;

		const segments = path.getSegments();
		const chain = path.getChain();

		// Get all segments that are unknown
		for (let i = chain.length - 1; i >= 0; i--) {
			const path = chain[i];

			if (memoryFs.exists(path)) {
				// If this is an absolute match then we should be a suggestion
				if (i === chain.length) {
					const filename = path.join();
					suggestions.set(filename, filename);
				}

				// Otherwise this segment exists and should have been dealt with previously in the loop
				break;
			}

			const parentPath = path.getParent();

			// Our basename isn't valid, but our parent exists
			if (!memoryFs.exists(path) && memoryFs.exists(parentPath)) {
				const entries = Array.from(
					memoryFs.readdir(parentPath),
					(path) => path.join(),
				);
				if (entries.length === 0) {
					continue;
				}

				const ratings = ___R$project$rome$$internal$string$utils$orderBySimilarity_ts$orderBySimilarity(
					path.getExtensionlessBasename(),
					entries.map((target) => {
						return ___R$project$rome$$internal$path$index_ts$createUnknownPath(
							target,
						).getExtensionlessBasename();
					}),
					{
						minRating: ___R$$priv$project$rome$$internal$core$server$fs$resolverSuggest_ts$MIN_SIMILARITY,
					},
				);

				for (const rating of ratings) {
					var ___R$1;
					___R$$priv$project$rome$$internal$core$server$fs$resolverSuggest_ts$tryPathSuggestions({
						server,
						resolver,
						suggestions,
						path: (___R$1 = ___R$project$rome$$internal$path$index_ts$createUnknownPath(
							rating.target,
						),
						___R$1.append.apply(___R$1, [...segments.slice(1)])).assertAbsolute(),
					});
				}
			}
		}
	}

	function ___R$$priv$project$rome$$internal$core$server$fs$resolverSuggest_ts$getPackageSuggestions(
		server,
		query,
	) {
		const possibleGlobalPackages = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
			"possibleGlobalPackages",
		);

		const mainProject = server.projectManager.findLoadedProject(query.origin);
		if (mainProject !== undefined) {
			const projects = server.projectManager.getHierarchyFromProject(
				mainProject,
			);

			for (const project of projects) {
				for (const [name, value] of project.packages) {
					possibleGlobalPackages.set(name, value.directory.join());
				}
			}
		}

		// TODO Add node_modules
		const matches = ___R$project$rome$$internal$string$utils$orderBySimilarity_ts$orderBySimilarity(
			query.source.join(),
			Array.from(possibleGlobalPackages.keys()),
			{
				minRating: ___R$$priv$project$rome$$internal$core$server$fs$resolverSuggest_ts$MIN_SIMILARITY,
			},
		).map((item) => {
			const name = item.target;
			const absolute = possibleGlobalPackages.assert(name);
			return [name, absolute];
		});
		return new Map(matches);
	}

	function ___R$$priv$project$rome$$internal$core$server$fs$resolverSuggest_ts$getSuggestions(
		server,
		resolver,
		query,
	) {
		if (query.entry === true) {
			return new Map([
				...___R$$priv$project$rome$$internal$core$server$fs$resolverSuggest_ts$getPathSuggestions(
					server,
					resolver,
					query,
				),
				...___R$$priv$project$rome$$internal$core$server$fs$resolverSuggest_ts$getPackageSuggestions(
					server,
					query,
				),
			]);
		} else if (
			___R$project$rome$$internal$core$server$fs$Resolver_ts$isPathLike(
				query.source,
			)
		) {
			return ___R$$priv$project$rome$$internal$core$server$fs$resolverSuggest_ts$getPathSuggestions(
				server,
				resolver,
				query,
			);
		} else {
			return ___R$$priv$project$rome$$internal$core$server$fs$resolverSuggest_ts$getPackageSuggestions(
				server,
				query,
			);
		}
	}


  // project-rome/@internal/core/server/fs/Resolver.ts
const ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$https = require(
		"https",
	);
	function ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$request(
		url,
	) {
		return new Promise((resolve) => {
			const req = ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$https.get(
				url,
				(res) => {
					if (res.statusCode !== 200) {
						resolve({
							type: "FETCH_ERROR",
							source: undefined,
							advice: [
								{
									type: "log",
									category: "info",
									text: ___R$project$rome$$internal$markup$escape_ts$markup`<hyperlink target="${url}" /> returned a ${String(
										res.statusCode,
									)} HTTP status code`,
								},
							],
						});
						return;
					}

					let data = "";

					res.on(
						"data",
						(chunk) => {
							data += chunk;
						},
					);

					res.on(
						"end",
						() => {
							resolve({type: "DOWNLOADED", content: data});
						},
					);
				},
			);

			req.on(
				"error",
				(err) => {
					resolve({
						type: "FETCH_ERROR",
						source: undefined,
						advice: [
							{
								type: "log",
								category: "info",
								text: ___R$project$rome$$internal$markup$escape_ts$markup`<hyperlink target="${url}" /> resulted in the error "${err.message}"`,
							},
						],
					});
				},
			);
		});
	}

	const ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$NODE_MODULES = "node_modules";

	const ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$QUERY_RESPONSE_MISSING = {
		type: "MISSING",
		source: undefined,
	};

	function ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$shouldReturnQueryResponse(
		res,
	) {
		return res.type === "FOUND" || res.source !== undefined;
	}

	function ___R$project$rome$$internal$core$server$fs$Resolver_ts$isPathLike(
		source,
	) {
		return source.isAbsolute() || source.isExplicitRelative();
	}

	function ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$appendTypeQueryResponse(
		res,
		types,
	) {
		if (res.type === "FOUND") {
			return Object.assign({}, res, {types: [...res.types, ...types]});
		} else {
			return res;
		}
	}

	function ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$attachExportAliasIfUnresolved(
		res,
		alias,
	) {
		if (res.type === "FOUND") {
			return res;
		}

		const location = alias.key.getDiagnosticLocation("value");

		return Object.assign(
			{},
			res,
			{
				source: location === undefined
					? undefined
					: {
							location,
							source: alias.value.join(),
						},
			},
		);
	}

	function ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$getExportsAlias(
		{
			manifest,
			relative,
			platform,
		},
	) {
		if (typeof manifest.exports === "boolean") {
			return undefined;
		}

		if (platform === undefined) {
			return undefined;
		}

		if (!relative.isRelative()) {
			return undefined;
		}

		const aliases = manifest.exports.get(relative.assertRelative());
		if (aliases === undefined) {
			return undefined;
		}

		const alias = ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$resolveExportCondition(
			aliases.get(platform),
		);
		if (alias !== undefined) {
			return alias;
		}

		const def = ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$resolveExportCondition(
			aliases.get("default"),
		);
		if (def !== undefined) {
			return def;
		}

		// TODO check for directory aliases
		return undefined;
	}

	function ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$resolveExportCondition(
		entry,
	) {
		if (entry === undefined) {
			return undefined;
		} else if (entry.type === "relative") {
			return {
				key: entry.consumer,
				value: entry.relative,
			};
		} else {
			return ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$resolveExportCondition(
				entry.conditions.get(""),
			);
		}
	}

	function ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$getPreferredMainKey(
		consumer,
		manifest,
		platform,
	) {
		const alias = ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$getExportsAlias({
			manifest,
			relative: ___R$project$rome$$internal$path$index_ts$createRelativeFilePath(
				".",
			),
			platform,
		});
		if (alias !== undefined) {
			return alias;
		}

		if (manifest.main !== undefined) {
			return {
				key: consumer.get("main"),
				value: ___R$project$rome$$internal$path$index_ts$createRelativeFilePath(
					manifest.main,
				),
			};
		}

		return undefined;
	}

	class ___R$project$rome$$internal$core$server$fs$Resolver_ts$default {
		constructor(server) {
			this.server = server;
		}

		init() {}

		async findProjectFromQuery(query) {
			// If we were passed an absolute path then we should find and add the project it belongs to
			if (query.source.isAbsolute()) {
				await this.server.projectManager.findProject(
					query.source.assertAbsolute(),
				);
			} else if (query.origin.isAbsolute()) {
				const origin = query.origin.assertAbsolute();
				await this.server.projectManager.findProject(origin);
				await this.server.projectManager.findProject(
					origin.append(query.source.assertRelative()),
				);
			}
		}

		async resolveEntryAssert(query, querySource) {
			await this.findProjectFromQuery(query);
			return this.resolveAssert(
				Object.assign({}, query, {entry: true}),
				querySource,
			);
		}

		// I found myself wanting only `ref.path` a lot so this is just a helper method
		async resolveEntryAssertPath(query, querySource) {
			const res = await this.resolveEntryAssert(query, querySource);
			return res.path;
		}

		async resolveEntry(query) {
			await this.findProjectFromQuery(query);
			return this.resolveRemote(Object.assign({}, query, {entry: true}));
		}

		async resolveAssert(query, origQuerySource) {
			const resolved = await this.resolveRemote(query);
			if (resolved.type === "FOUND") {
				return resolved;
			} else {
				throw ___R$project$rome$$internal$core$server$fs$resolverSuggest_ts$default({
					resolver: this,
					server: this.server,
					query,
					resolved,
					origQuerySource,
				});
			}
		}

		async resolveRemote(query) {
			const {origin, source} = query;

			if (source.isURL()) {
				const sourceURL = source.assertURL();
				const protocol = sourceURL.getProtocol();

				switch (protocol) {
					case "http":
					case "https": {
						let projectConfig = ___R$project$rome$$internal$project$types_ts$createDefaultProjectConfig();

						if (origin.isAbsolute()) {
							const project = this.server.projectManager.findLoadedProject(
								query.origin.assertAbsolute(),
							);
							if (project !== undefined) {
								projectConfig = project.config;
							}
						}

						const remotePath = projectConfig.files.vendorPath.append(
							source.join().replace(/[\/:]/g, "$").replace(/\$+/g, "$"),
						);

						if (!this.server.memoryFs.exists(remotePath)) {
							const result = await ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$request(
								source.join(),
							);
							if (result.type === "DOWNLOADED") {
								await ___R$project$rome$$internal$fs$index_ts$writeFile(
									remotePath,
									result.content,
								);
							} else {
								return result;
							}
						}

						return {
							type: "FOUND",
							types: [],
							ref: this.server.projectManager.getURLFileReference(
								remotePath,
								sourceURL,
							),
							path: remotePath,
						};
					}

					default:
						return {
							type: "UNSUPPORTED",
							source: undefined,
							advice: [
								{
									type: "log",
									category: "info",
									text: ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${protocol}</emphasis> is not a supported remote protocol`,
								},
							],
						};
				}
			}

			if (origin.isURL()) {
				if (source.isAbsolute() || source.isExplicitRelative()) {
					// Relative to the origin
					return this.resolveRemote(
						Object.assign({}, query, {source: origin.resolve(source)}),
					);
				} else {
					// TODO add support for import maps
					return {
						type: "MISSING",
						source: undefined,
					};
				}
			}

			return this.resolveLocal(
				Object.assign({}, query, {origin: query.origin.assertAbsolute()}),
			);
		}

		resolveLocal(query) {
			// Do some basic checks to determine if this is an absolute or relative path
			if (
				___R$project$rome$$internal$core$server$fs$Resolver_ts$isPathLike(
					query.source,
				)
			) {
				return this.resolvePath(query);
			}

			// Now resolve it as a module
			const resolved = this.resolveModule(query);

			// If we didn't resolve to a module, and we were asked to resolve relative, then do that
			if (resolved.type === "MISSING" && query.entry === true) {
				return this.resolvePath(query);
			}

			return resolved;
		}

		*getFilenameVariants(query, path) {
			const seen = new Set();
			for (const variant of this._getFilenameVariants(query, path, [])) {
				const filename = variant.path.join();
				if (seen.has(filename)) {
					continue;
				}

				seen.add(filename);
				yield variant;
			}
		}

		*_getFilenameVariants(query, path, callees) {
			const {platform} = query;

			yield {path, types: callees};

			//
			const {handler} = this.server.projectManager.getHandlerWithProject(
				path.isAbsolute() ? path.assertAbsolute() : query.origin,
			);
			const usesUnknownExtension = !query.strict && handler === undefined;

			// Check with appended `platform`
			if (platform !== undefined && !callees.includes("implicitPlatform")) {
				yield* this._getFilenameVariants(
					query,
					path.addExtension("." + platform),
					[...callees, "implicitPlatform"],
				);

				// Check if this platform has any subplatforms
				const platformAliases = ___R$project$rome$$internal$core$common$types$platform_ts$PLATFORM_ALIASES[platform];
				if (platformAliases !== undefined) {
					for (const platform of platformAliases) {
						yield* this._getFilenameVariants(
							query,
							path.addExtension("." + platform, true),
							[...callees, "implicitPlatform"],
						);
					}
				}
			}

			// Check with appended extensions
			if (usesUnknownExtension && !callees.includes("implicitExtension")) {
				for (const ext of ___R$project$rome$$internal$core$common$file$handlers$javascript_ts$IMPLICIT_JS_EXTENSIONS) {
					yield* this._getFilenameVariants(
						query,
						path.addExtension("." + ext),
						[...callees, "implicitExtension"],
					);
				}
			}

			// Check with appended `scale`, other.filename
			if (
				handler !== undefined &&
				handler.canHaveScale === true &&
				!callees.includes("implicitScale")
			) {
				const scale = query.scale == null ? 3 : query.scale;
				for (let i = scale; i >= 1; i--) {
					yield* this._getFilenameVariants(
						query,
						path.changeBasename(
							path.getExtensionlessBasename() +
							"@" +
							String(i) +
							"x" +
							path.getExtensions(),
						),
						[...callees, "implicitScale"],
					);
				}
			}
		}

		finishResolverQueryResponse(path, types = []) {
			return {
				type: "FOUND",
				types,
				ref: this.server.projectManager.getFileReference(path),
				path,
			};
		}

		getOriginDirectory(query) {
			const {memoryFs} = this.server;
			const {origin} = query;

			if (memoryFs.isFile(origin)) {
				return origin.getParent();
			} else {
				return origin;
			}
		}

		resolvePath(query, checkVariants = true, types) {
			const {memoryFs} = this.server;

			// Resolve the path heiarchy
			const originDirectory = this.getOriginDirectory(query);
			const resolvedOrigin = originDirectory.resolve(query.source);

			// Check if this is an absolute filename
			if (memoryFs.isFile(resolvedOrigin)) {
				// If we're querying a package then we should never return a file
				if (query.requestedType === "package") {
					return ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
				}

				return this.finishResolverQueryResponse(resolvedOrigin, types);
			}

			// Check variants
			if (checkVariants) {
				for (const variant of this.getFilenameVariants(query, resolvedOrigin)) {
					if (variant.path.equal(resolvedOrigin)) {
						continue;
					}

					const resolved = this.resolvePath(
						Object.assign({}, query, {source: variant.path}),
						false,
						variant.types,
					);

					if (
						___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$shouldReturnQueryResponse(
							resolved,
						)
					) {
						return ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$appendTypeQueryResponse(
							resolved,
							variant.types,
						);
					}
				}
			}

			// check if this is a directory
			if (memoryFs.isDirectory(resolvedOrigin)) {
				if (query.requestedType === "directory") {
					return this.finishResolverQueryResponse(resolvedOrigin, types);
				}

				// If this has a package.json then follow the `main` field
				const manifestDef = memoryFs.getManifestDefinition(resolvedOrigin);
				if (manifestDef !== undefined) {
					// If we're resolving a package then don't follow this
					if (query.requestedType === "package") {
						return this.finishResolverQueryResponse(resolvedOrigin, types);
					}

					const main = ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$getPreferredMainKey(
						manifestDef.consumer,
						manifestDef.manifest,
						query.platform,
					);
					if (main !== undefined) {
						const resolved = this.resolvePath(
							Object.assign(
								{},
								query,
								{origin: resolvedOrigin, source: main.value},
							),
							true,
							["package"],
						);

						return ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$attachExportAliasIfUnresolved(
							resolved,
							main,
						);
					}
				}

				if (!query.strict) {
					// Check if it has an index.* file
					for (const ext of ___R$project$rome$$internal$core$common$file$handlers$javascript_ts$IMPLICIT_JS_EXTENSIONS) {
						const indexResolved = this.resolvePath(
							Object.assign(
								{},
								query,
								{source: resolvedOrigin.append("index." + ext)},
							),
							true,
							["implicitIndex"],
						);

						if (
							___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$shouldReturnQueryResponse(
								indexResolved,
							)
						) {
							return indexResolved;
						}
					}
				}
			}

			return ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
		}

		resolvePackageDirectory(query, moduleName) {
			// Find the project
			const project = this.server.projectManager.findLoadedProject(query.origin);
			if (project === undefined) {
				return undefined;
			}

			// Find the package
			const projects = this.server.projectManager.getHierarchyFromProject(
				project,
			);

			for (const project of projects) {
				const pkg = project.packages.get(moduleName);
				if (pkg !== undefined) {
					return pkg;
				}
			}

			return undefined;
		}

		resolvePackage(query, moduleName, moduleNameParts) {
			const manifestDef = this.resolvePackageDirectory(query, moduleName);
			return this.resolveManifest(query, manifestDef, moduleNameParts);
		}

		resolveManifest(query, manifestDef, moduleNameParts) {
			var ___R$;
			if (manifestDef === undefined) {
				return ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
			}

			if (moduleNameParts.length > 0) {
				// Submodules of this package are private
				if (manifestDef.manifest.exports === false) {
					return ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
				}

				// Check if we're allowed to touch this submodule
				if (manifestDef.manifest.exports !== true) {
					const alias = ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$getExportsAlias({
						manifest: manifestDef.manifest,
						relative: ___R$project$rome$$internal$path$index_ts$createFilePathFromSegments(
							moduleNameParts,
							"relative",
						).assertRelative(),
						platform: query.platform,
					});

					if (alias === undefined) {
						// No submodule found
						return ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
					}

					// Alias found!
					const resolved = this.resolvePath(
						Object.assign(
							{},
							query,
							{source: manifestDef.directory.append(alias.value)},
						),
						true,
						["package"],
					);
					return ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$attachExportAliasIfUnresolved(
						resolved,
						alias,
					);
				}
			}

			// All exports are enabled or we are importing the root
			return this.resolvePath(
				Object.assign(
					{},
					query,
					{
						source: (___R$ = manifestDef.directory,
						___R$.append.apply(___R$, [...moduleNameParts])),
					},
				),
				true,
				["package"],
			);
		}

		resolveMock(query, project, parentDirectories) {
			if (project === undefined) {
				return ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
			}

			const moduleName = query.source.assertRelative();

			for (const dir of parentDirectories) {
				const mocksDir = dir.append(
					___R$project$rome$$internal$core$common$constants_ts$MOCKS_DIRECTORY_NAME,
				);

				// No use resolving against a directory that doesn't exist
				if (!this.server.memoryFs.exists(mocksDir)) {
					continue;
				}

				const resolved = this.resolveLocal(
					Object.assign({}, query, {source: mocksDir.append(moduleName)}),
				);

				if (
					___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$shouldReturnQueryResponse(
						resolved,
					)
				) {
					return ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$appendTypeQueryResponse(
						resolved,
						["mock"],
					);
				}
			}

			return ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
		}

		// Given a reference to a module, extract the module name and any trailing relative paths
		splitModuleName(path) {
			// fetch the first part of the path as that's the module name
			// possible values of `moduleNameFull` could be `react` or `react/lib/whatever`
			const [moduleName, ...moduleNameParts] = path.getSegments();

			// For scoped modules in the form of `@internal/bar`, make sure we keep the `/bar` on the module name
			if (moduleName[0] === "@" && moduleNameParts.length > 0) {
				return [moduleName + "/" + moduleNameParts.shift(), moduleNameParts];
			}

			return [moduleName, moduleNameParts];
		}

		resolveModule(query) {
			const {origin, source} = query;

			// Get project for the origin
			const project = this.server.projectManager.findLoadedProject(origin);

			// Get all the parent directories for when we crawl up
			const parentDirectories = this.getOriginDirectory(query).getChain();

			// If mocks are enabled for this query then check all parent mocks directory
			if (query.mocks === true) {
				const mockResolved = this.resolveMock(query, project, parentDirectories);
				if (
					___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$shouldReturnQueryResponse(
						mockResolved,
					)
				) {
					return mockResolved;
				}
			}

			// Extract the module name and it's relative file parts
			const [moduleName, moduleNameParts] = this.splitModuleName(source);

			// Resolve a virtual module
			const virtualResolved = this.server.virtualModules.resolvePossibleVirtualModuleName(
				moduleName,
			);
			if (virtualResolved !== undefined) {
				var ___R$1;
				return this.resolvePath(
					Object.assign(
						{},
						query,
						{
							source: (___R$1 = virtualResolved,
							___R$1.append.apply(___R$1, [...moduleNameParts])),
						},
					),
					true,
					["virtual"],
				);
			}

			// Check if it matches any of our project packages
			const packageResolved = this.resolvePackage(
				query,
				moduleName,
				moduleNameParts,
			);
			if (
				___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$shouldReturnQueryResponse(
					packageResolved,
				)
			) {
				return packageResolved;
			}

			// Check all parent directories for node_modules
			for (const dir of parentDirectories) {
				const modulePath = dir.append(
					___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$NODE_MODULES,
				).append(moduleName);
				const manifestDef = this.server.memoryFs.getManifestDefinition(
					modulePath,
				);
				if (manifestDef !== undefined) {
					return this.resolveManifest(query, manifestDef, moduleNameParts);
				}
			}

			return ___R$$priv$project$rome$$internal$core$server$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
		}
	}


  // project-rome/@internal/core/server/fs/FileAllocator.ts
class ___R$project$rome$$internal$core$server$fs$FileAllocator_ts$default {
		constructor(server) {
			this.server = server;
			this.fileToWorker = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
			this.locker = new ___R$project$rome$$internal$async$lockers_ts$FilePathLocker();
			this.logger = server.logger.namespace(
				___R$project$rome$$internal$markup$escape_ts$markup`[FileAllocator]`,
			);
		}

		init() {
			this.server.memoryFs.deletedFileEvent.subscribe((paths) => {
				return this.handleDeleted(paths);
			});

			this.server.memoryFs.changedFileEvent.subscribe((events) => {
				return this.handleChange(events);
			});
		}

		getAllOwnedFilenames() {
			return Array.from(this.fileToWorker.keys());
		}

		hasOwner(path) {
			return this.getOwnerId(path) !== undefined;
		}

		getOwnerId(path) {
			return this.fileToWorker.get(path);
		}

		verifySize(path, stats) {
			const project = this.server.projectManager.findLoadedProject(path);
			if (project === undefined) {
				return;
			}

			const maxSize = project.config.files.maxSize;
			if (stats.size > maxSize) {
				throw new Error(
					"The file " +
					path.join() +
					" exceeds the project config max size of " +
					maxSize +
					" bytes",
				);
			}
		}

		getOwnerAssert(path) {
			const {workerManager} = this.server;
			const workerId = this.getOwnerId(path);
			if (workerId === undefined) {
				throw new Error("No worker found for " + path);
			}

			const worker = workerManager.getWorkerAssert(workerId);
			if (!worker.ready) {
				throw new Error("Worker " + workerId + " isn't ready");
			}
			return worker;
		}

		async getOrAssignOwner(path) {
			const {workerManager} = this.server;

			const workerId = this.getOwnerId(path);
			if (workerId === undefined) {
				return this.assignOwner(path);
			} else {
				await workerManager.locker.waitLock(workerId);
				return workerManager.getWorkerAssert(workerId);
			}
		}

		async evict(path, reason) {
			// Find owner
			const workerId = this.getOwnerId(path);
			if (workerId === undefined) {
				return;
			}

			// Notify the worker to remove it from 'it's cache
			const filename = path.join();
			const worker = this.server.workerManager.getWorkerAssert(workerId);
			await worker.bridge.evict.call({
				filename,
			});

			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Evicted <emphasis>${path}</emphasis> due to <emphasis>${reason}</emphasis>`,
			);
		}

		async handleDeleted(paths) {
			for (const path of paths) {
				// Find owner
				const workerId = this.getOwnerId(path);
				if (workerId === undefined) {
					continue;
				}

				// Evict file from 'worker cache
				await this.evict(
					path,
					___R$project$rome$$internal$markup$escape_ts$markup`file deleted`,
				);

				// Disown it from 'our internal map
				this.fileToWorker.delete(path);

				// Remove the total size from 'this worker so it'll be assigned next
				const stats = this.server.memoryFs.getFileStatsAssert(path);
				this.server.workerManager.disown(workerId, stats);
			}
		}

		async handleChange(events) {
			const {workerManager} = this.server;

			for (const {path, oldStats, newStats} of events) {
				// Send update to worker owner
				if (this.hasOwner(path)) {
					// Get the worker
					const workerId = this.getOwnerId(path);
					if (workerId === undefined) {
						throw new Error("Expected worker id for " + path.join());
					}

					// Evict the file from cache
					await this.evict(
						path,
						___R$project$rome$$internal$markup$escape_ts$markup`file change`,
					);

					// Verify that this file doesn't exceed any size limit
					this.verifySize(path, newStats);

					// Add on the new size, and remove the old
					if (oldStats === undefined) {
						throw new Error(
							"File already has an owner so expected to have old stats but had none",
						);
					}
					workerManager.disown(workerId, oldStats);
					workerManager.own(workerId, newStats);
				} else {
					this.logger.info(
						___R$project$rome$$internal$markup$escape_ts$markup`No owner for eviction ${path}`,
					);
				}
			}

			const paths = events.map((event) => event.path);
			if (await this.server.projectManager.maybeEvictProjects(paths)) {
				const displayPaths = ___R$project$rome$$internal$markup$escape_ts$concatMarkup(
					paths.map((path) =>
						___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${path}</emphasis>`
					),
					___R$project$rome$$internal$markup$escape_ts$markup`, `,
				);
				this.logger.info(
					___R$project$rome$$internal$markup$escape_ts$markup`Evicted projects belonging to dependencies ${displayPaths}`,
				);
			}
		}

		async assignOwner(path) {
			const {workerManager, memoryFs} = this.server;

			const lock = await this.locker.getLock(path);

			// We may have waited on the lock and could already have an owner
			if (this.hasOwner(path)) {
				lock.release();
				return this.getOwnerAssert(path);
			}

			try {
				const worker = await workerManager.getNextWorker(path);

				// Add ourselves to the file map
				this.logger.info(
					___R$project$rome$$internal$markup$escape_ts$markup`File <emphasis>${path}</emphasis> (file size <filesize>${String(
						memoryFs.getFileStats(path) == null
							? undefined
							: memoryFs.getFileStats(path).size,
					)}</filesize>) assigned to worker ${worker.id}`,
				);
				this.fileToWorker.set(path, worker.id);

				return worker;
			} finally {
				// Release and continue
				lock.release();
			}
		}
	}


  // project-rome/@internal/core/common/utils/Logger.ts
const ___R$$priv$project$rome$$internal$core$common$utils$Logger_ts$workerThreads = require(
		"worker_threads",
	);
	class ___R$project$rome$$internal$core$common$utils$Logger_ts$default
		extends ___R$project$rome$$internal$cli$reporter$Reporter_ts$default {
		constructor(opts, {loggerType, write, check}) {
			super(opts);
			this.loggerType = loggerType;

			this.conditionalStream = this.attachConditionalStream(
				{
					format: "markup",
					features: Object.assign(
						{},
						___R$project$rome$$internal$cli$environment$index_ts$DEFAULT_TERMINAL_FEATURES,
						{columns: undefined},
					),
					write,
				},
				check,
			);
		}

		updateStream() {
			this.conditionalStream.update();
		}

		getMessagePrefix() {
			const inner =
				this.loggerType +
				" " +
				process.pid +
				":" +
				___R$$priv$project$rome$$internal$core$common$utils$Logger_ts$workerThreads.threadId;
			const timestamp = new Date().toISOString();
			return ___R$project$rome$$internal$markup$escape_ts$markup`<dim>[${timestamp}] [${inner}]</dim> `;
		}
	}


  // project-rome/@internal/core/server/fs/MemoryFileSystem.ts
const ___R$$priv$project$rome$$internal$core$server$fs$MemoryFileSystem_ts$crypto = require(
		"crypto",
	);
	// Paths that we will under no circumstance want to include
	const ___R$$priv$project$rome$$internal$core$server$fs$MemoryFileSystem_ts$DEFAULT_DENYLIST = [
		".hg",
		".git",
		".idea",
		"node_modules/.staging",
		"node_modules/.cache",
	];

	function ___R$$priv$project$rome$$internal$core$server$fs$MemoryFileSystem_ts$isValidManifest(
		path,
	) {
		if (path.getBasename() !== "package.json") {
			return false;
		}

		// If a manifest is in node_modules, then make sure we're directly inside
		// a directory in node_modules.
		//
		// For unscoped package, the segments should be:
		//   -1: package.json
		//   -2: module directory
		//   -3: node_modules
		//
		// For scoped package (@scope/some-module), the segments should be:
		//   -1: package.json
		//   -2: module directory
		//   -3: scope directory
		//   -4: node_modules
		const segments = path.getSegments();
		if (segments.includes("node_modules")) {
			// Unscoped package
			if (segments[segments.length - 3] === "node_modules") {
				return true;
			}

			// Scoped module
			if (
				segments[segments.length - 4] === "node_modules" &&
				segments[segments.length - 3].startsWith("@")
			) {
				return true;
			}

			return false;
		}

		return true;
	}

	// Whenever we're performing an operation on a set of files, always do these first as they may influence how the rest are processed
	const ___R$$priv$project$rome$$internal$core$server$fs$MemoryFileSystem_ts$PRIORITY_FILES = new Set([
		___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_DIRECTORY,
		"package.json",
	]);

	class ___R$project$rome$$internal$core$server$fs$MemoryFileSystem_ts$default {
		constructor(server) {
			this.server = server;

			this.directoryListings = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
			this.directories = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
			this.files = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
			this.buffers = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();

			this.manifestCounter = 0;
			this.manifests = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();

			this.logger = server.logger.namespace(
				___R$project$rome$$internal$markup$escape_ts$markup`[MemoryFileSystem]`,
			);

			this.watcherCounter = 0;
			this.watchPromises = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
			this.watchers = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
			this.activeWatcherIds = new Set();

			this.changedFileEvent = new ___R$project$rome$$internal$events$EventQueue_ts$default();
			this.deletedFileEvent = new ___R$project$rome$$internal$events$EventQueue_ts$default();
			this.newFileEvent = new ___R$project$rome$$internal$events$EventQueue_ts$default();

			this.processingLock = new ___R$project$rome$$internal$async$lockers_ts$GlobalLock();
			this.processingLock.attachLock(this.changedFileEvent.lock);
			this.processingLock.attachLock(this.deletedFileEvent.lock);
		}

		isActiveWatcherId(id) {
			return id === undefined || this.activeWatcherIds.has(id);
		}

		async init() {
			await this.injectVirtualModules();
		}

		// Inject virtual modules so they are discoverable
		async injectVirtualModules() {
			const files = this.server.virtualModules.getStatMap();

			for (const [path, {stats, content}] of files) {
				if (stats.type === "directory") {
					this.directories.set(path, stats);
				} else {
					this.files.set(path, stats);
					this.addFileToDirectoryListing(path);

					if (
						___R$$priv$project$rome$$internal$core$server$fs$MemoryFileSystem_ts$isValidManifest(
							path,
						)
					) {
						await this.declareManifest({
							content,
							diagnostics: this.server.createDisconnectedDiagnosticsProcessor([]),
							dirname: path.getParent(),
							path,
						});
					}
				}
			}
		}

		hasBuffer(path) {
			return this.buffers.has(path);
		}

		addBuffer(path, content) {
			this.buffers.set(
				path,
				{
					type: "file",
					size: content.length,
					mtime: Date.now(),
				},
			);
		}

		clearBuffer(path) {
			this.buffers.delete(path);
		}

		async createWatcher(diagnostics, projectDirectory, id) {
			const {server} = this;
			const {logger} = server;
			const projectDirectoryMarkup = ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${projectDirectory}</emphasis>`;

			// Create activity spinners for all connected reporters
			const activity = this.server.connectedReporters.progress({
				initDelay: 1_000,
				title: ___R$project$rome$$internal$markup$escape_ts$markup`Adding project ${projectDirectoryMarkup}`,
			});

			const watchers = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
			this.activeWatcherIds.add(id);

			try {
				const onFoundDirectory = (directoryPath) => {
					if (watchers.has(directoryPath)) {
						return;
					}

					let recursive = true;

					if (process.platform === "linux" || process.platform === "android") {
						// Node on Linux doesn't support recursive directory watching so we need an fs.watch for every directory...
						recursive = false;
					} else if (!directoryPath.equal(projectDirectory)) {
						// If we're on any other platform then only watch the root project directory
						return;
					}

					const watcher = ___R$project$rome$$internal$fs$index_ts$watch(
						directoryPath,
						{recursive, persistent: false},
						(eventType, filename) => {
							this.logger.info(
								___R$project$rome$$internal$markup$escape_ts$markup`Raw fs.watch event in <emphasis>${directoryPath}</emphasis> type ${eventType} for ${String(
									filename,
								)}`,
							);

							if (filename === null) {
								// TODO not sure how we want to handle this?
								return;
							}

							const path = directoryPath.resolve(filename);
							this.refreshPath(
								path,
								{onFoundDirectory, watcherId: id},
								"Processing fs.watch changes",
							);
						},
					);
					watchers.set(directoryPath, watcher);
				};

				// No need to call watch() on the projectDirectory since it will call us

				// Perform an initial crawl
				const start = Date.now();
				const stats = await this.hardStat(projectDirectory);
				await this.addDirectory(
					projectDirectory,
					stats,
					{
						diagnostics,
						onFoundDirectory,
						reason: "initial",
					},
				);
				const took = Date.now() - start;
				logger.info(
					___R$project$rome$$internal$markup$escape_ts$markup`[MemoryFileSystem] Finished initial crawl for <emphasis>${projectDirectory}</emphasis>. Added <number>${String(
						this.countFiles(projectDirectory),
					)}</number> files. Took <duration>${String(took)}</duration>`,
				);
			} finally {
				activity.end();
			}

			return () => {
				this.activeWatcherIds.delete(id);
				for (const watcher of watchers.values()) {
					watcher.close();
				}
			};
		}

		close(dirPath) {
			const watcher = this.watchers.get(dirPath);
			if (watcher === undefined) {
				return;
			}

			this.watchers.delete(dirPath);
			watcher.close();
		}

		unwatch(dirPath) {
			this.close(dirPath);

			// Go through and clear all files and directories from our internal maps
			// NOTE: We deliberately do not call 'deletedFileEvent' as the code that
			// calls us will already be cleaning up
			let queue = [dirPath];
			while (queue.length > 0) {
				const path = queue.pop();

				this.directories.delete(path);
				this.manifests.delete(path);
				this.files.delete(path);

				const listing = this.directoryListings.get(path);
				if (listing !== undefined) {
					this.directoryListings.delete(path);
					queue = queue.concat(Array.from(listing.values()));
				}
			}
		}

		unwatchAll() {
			for (const {close} of this.watchers.values()) {
				close();
			}
		}

		readdir(path) {
			const listing = this.directoryListings.get(path);
			if (listing === undefined) {
				return [];
			} else {
				return listing.values();
			}
		}

		isDirectory(path) {
			return this.directories.has(path);
		}

		isFile(path) {
			return this.files.has(path);
		}

		getManifestDefinition(dirname) {
			return this.manifests.get(dirname);
		}

		getOwnedManifest(path) {
			for (const dir of path.getChain()) {
				const def = this.server.memoryFs.getManifestDefinition(dir);
				if (def !== undefined) {
					return def;
				}
			}
			return undefined;
		}

		getPartialManifest(def) {
			return {
				path: def.path,
				type: def.manifest.type,
			};
		}

		addFileToDirectoryListing(path) {
			const dirname = path.getParent();
			let listing = this.directoryListings.get(dirname);
			if (listing === undefined) {
				listing = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
				this.directoryListings.set(dirname, listing);
			}
			listing.set(path, path);
		}

		async handleDeletion(path) {
			// If a directory then evict all children
			const directoryInfo = this.directories.get(path);
			if (directoryInfo !== undefined) {
				this.directories.delete(path);

				const listing = this.directoryListings.get(path);
				if (listing !== undefined) {
					this.directoryListings.delete(path);
					for (const path of listing.values()) {
						await this.handleDeletion(path);
					}
				}
			}

			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`File deleted: ${path}`,
			);

			// Wait for any subscribers that might need the file's stats
			// Only emit these events for files
			if (directoryInfo === undefined) {
				await Promise.all([
					this.deletedFileEvent.push(path),
					this.server.refreshFileEvent.push(path),
				]);
			}

			// Remove from 'all possible caches
			this.files.delete(path);

			// If this is a manifest filename then clear it from 'any possible package and our internal module map
			const basename = path.getBasename();
			if (basename === "package.json") {
				this.handleDeletedManifest(path);
			}

			// Remove from 'parent directory listing
			const dirname = path.getParent();
			const parentListing = this.directoryListings.get(dirname);
			if (parentListing !== undefined) {
				parentListing.delete(path);
			}
		}

		handleDeletedManifest(path) {
			const directory = path.getParent();
			const def = this.manifests.get(directory);
			if (def !== undefined) {
				this.manifests.delete(directory);
			}
		}

		async waitIfInitializingWatch(projectDirectoryPath) {
			// Defer if we're initializing a parent directory
			for (const [path, promise] of this.watchPromises) {
				if (projectDirectoryPath.isRelativeTo(path)) {
					await promise;
					return;
				}
			}

			// Wait if we're initializing descendents
			for (const [path, promise] of this.watchPromises) {
				if (path.isRelativeTo(projectDirectoryPath)) {
					await promise;
				}
			}
		}

		async watch(projectDirectory) {
			const directoryLink = ___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${projectDirectory}</emphasis>`;

			// Defer if we're already currently initializing this project
			const cached = this.watchPromises.get(projectDirectory);
			if (cached !== undefined) {
				await cached;
				return undefined;
			}

			// Check if we're already watching this directory
			if (this.watchers.has(projectDirectory)) {
				return undefined;
			}

			// Check if we're already watching a parent directory
			for (const {path} of this.watchers.values()) {
				if (projectDirectory.isRelativeTo(path)) {
					this.logger.info(
						___R$project$rome$$internal$markup$escape_ts$markup`Skipped crawl for ${directoryLink} because we're already watching the parent directory ${path}`,
					);
					return undefined;
				}
			}

			// Wait for other initializations
			await this.waitIfInitializingWatch(projectDirectory);

			// New watch target
			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Adding new project directory ${directoryLink}`,
			);

			// Remove watchers that are descedents of this directory as this watcher will handle them
			for (const [loc, {close, path}] of this.watchers) {
				if (path.isRelativeTo(projectDirectory)) {
					this.watchers.delete(loc);
					close();
				}
			}

			const diagnostics = this.server.createDiagnosticsProcessor({
				origins: [
					{
						category: "memory-fs",
						message: "Crawling project directory",
					},
				],
			});

			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Watching ${directoryLink}`,
			);
			const id = this.watcherCounter++;
			const promise = this.createWatcher(diagnostics, projectDirectory, id);
			this.watchPromises.set(projectDirectory, promise);

			await this.processingLock.wrap(async () => {
				const watcherClose = await promise;
				this.watchers.set(
					projectDirectory,
					{
						path: projectDirectory,
						close: watcherClose,
					},
				);
				this.watchPromises.delete(projectDirectory);
			});

			diagnostics.maybeThrowDiagnosticsError();
		}

		// Query actual file system for stats
		async hardStat(path) {
			const stats = await ___R$project$rome$$internal$fs$index_ts$lstat(path);

			let type = "unknown";
			if (stats.isDirectory()) {
				type = "directory";
			} else if (stats.isFile()) {
				type = "file";
			}

			return {
				type,
				size: stats.size,
				mtime: stats.mtimeMs,
			};
		}

		maybeGetMtime(path) {
			const stats = this.buffers.get(path) || this.files.get(path);
			if (stats === undefined) {
				return undefined;
			} else {
				return stats.mtime;
			}
		}

		getMtime(path) {
			const mtime = this.maybeGetMtime(path);
			if (mtime === undefined) {
				throw new ___R$project$rome$$internal$fs$FileNotFound_ts$FileNotFound(
					path,
					"Not found in memory file system",
				);
			} else {
				return mtime;
			}
		}

		getFileStats(path) {
			return this.files.get(path);
		}

		getFileStatsAssert(path) {
			const stats = this.getFileStats(path);
			if (stats === undefined) {
				throw new ___R$project$rome$$internal$fs$FileNotFound_ts$FileNotFound(
					path,
					"Not found in memory file system",
				);
			}
			return stats;
		}

		isIgnored(path, type) {
			const project = this.server.projectManager.findLoadedProject(path);
			if (project === undefined) {
				return false;
			}

			// If we're a file and don't have an extension handler so there's no reason for us to care about it
			if (
				type === "file" &&
				___R$project$rome$$internal$core$common$file$handlers$index_ts$getFileHandlerFromPath(
					path,
					project.config,
				) === undefined
			) {
				return true;
			}

			// Ensure we aren't in any of the default denylists
			const basename = path.getBasename();
			if (
				___R$$priv$project$rome$$internal$core$server$fs$MemoryFileSystem_ts$DEFAULT_DENYLIST.includes(
					basename,
				)
			) {
				return true;
			}

			return false;
		}

		isInsideProject(path) {
			return path.getSegments().includes("node_modules") === false;
		}

		// This is a wrapper around _declareManifest as it can produce diagnostics
		async declareManifest(opts) {
			const {diagnostics} = await ___R$project$rome$$internal$diagnostics$wrap_ts$catchDiagnostics(() => {
				return this.declareManifestWithPossibleDiagnosticsThrow(opts);
			});

			if (diagnostics !== undefined) {
				opts.diagnostics.addDiagnostics(diagnostics);
			}
		}

		async declareManifestWithPossibleDiagnosticsThrow(
			{
				path,
				diagnostics,
				content,
			},
		) {
			// Fetch the manifest
			const manifestRaw =
				content == null
					? await ___R$project$rome$$internal$fs$index_ts$readFileText(path)
					: content;
			const hash = ___R$$priv$project$rome$$internal$core$server$fs$MemoryFileSystem_ts$crypto.createHash(
				"sha256",
			).update(manifestRaw).digest("hex");

			const consumer = ___R$project$rome$$internal$codec$json$index_ts$consumeJSON({
				path,
				input: manifestRaw,
				consumeDiagnosticCategory: "parse/manifest",
			});

			const {consumer: normalizeConsumer, diagnostics: rawDiagnostics} = consumer.capture();
			const manifest = await ___R$project$rome$$internal$codec$js$manifest$index_ts$normalizeManifest(
				normalizeConsumer,
			);

			// If manifest is undefined then we failed to validate and have diagnostics
			if (rawDiagnostics.length > 0) {
				const normalizedDiagnostics = rawDiagnostics.map((diag) =>
					Object.assign(
						{},
						diag,
						{
							description: Object.assign(
								{},
								diag.description,
								{
									advice: [
										...diag.description.advice,
										{
											type: "log",
											category: "info",
											text: ___R$project$rome$$internal$markup$escape_ts$markup`Error occurred for package <emphasis>${___R$project$rome$$internal$codec$js$manifest$name_ts$manifestNameToString(
												manifest.name,
											)}</emphasis> at <emphasis>${path.getParent()}</emphasis>`,
										},
									],
								},
							),
						},
					)
				);
				diagnostics.addDiagnostics(normalizedDiagnostics);
				return;
			}

			const directory = path.getParent();
			const manifestId = this.manifestCounter++;
			const def = {
				id: manifestId,
				path,
				directory,
				consumer,
				manifest,
				hash,
			};

			this.manifests.set(directory, def);

			// If we aren't in node_modules then this is a project package
			const isProjectPackage = this.isInsideProject(path);
			const {projectManager} = this.server;

			if (
				isProjectPackage &&
				consumer.has(
					___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_PACKAGE_JSON_FIELD,
				)
			) {
				await projectManager.addDiskProject({
					projectDirectory: directory,
					configPath: path,
				});
			}

			const project = projectManager.findLoadedProject(path);
			if (project === undefined) {
				// Project failed to load. We'll display the errors but failing hard here with assertProjectExisting will hide them.
				return;
			}

			projectManager.declareManifest(
				project,
				isProjectPackage,
				def,
				diagnostics,
			);

			// Tell all workers of our discovery
			for (const worker of this.server.workerManager.getWorkers()) {
				worker.bridge.updateManifests.send({
					manifests: [{id: def.id, manifest: this.getPartialManifest(def)}],
				});
			}
		}

		countFiles(directory) {
			let count = 0;

			const listing = this.directoryListings.get(directory);
			if (listing !== undefined) {
				for (const file of listing.keys()) {
					count++;
					count += this.countFiles(file);
				}
			}

			return count;
		}

		hasStatsChanged(path, newStats) {
			const oldStats = this.directories.get(path) || this.files.get(path);
			return oldStats === undefined || newStats.mtime !== oldStats.mtime;
		}

		async addDirectory(directoryPath, stats, opts) {
			if (!this.hasStatsChanged(directoryPath, stats)) {
				return false;
			}

			// Check if this directory has been ignored
			if (this.isIgnored(directoryPath, "directory")) {
				return false;
			}

			if (opts.tick !== undefined) {
				opts.tick(directoryPath);
			}

			this.addFileToDirectoryListing(directoryPath);
			this.directories.set(directoryPath, stats);

			if (opts.onFoundDirectory !== undefined) {
				opts.onFoundDirectory(directoryPath);
			}

			// Crawl the directory
			const paths = await ___R$project$rome$$internal$fs$index_ts$readDirectory(
				directoryPath,
			);

			// Declare the file
			const declareItem = async (path) => {
				// Watcher could have been closed by an event
				if (!this.isActiveWatcherId(opts.watcherId)) {
					return;
				}

				const stats = await this.hardStat(path);
				if (stats.type === "file") {
					await this.addFile(path, stats, opts);
				} else if (stats.type === "directory") {
					await this.addDirectory(path, stats, opts);
				}
			};

			// Give priority to package.json in case we want to derive something from the project config
			for (const priorityBasename of ___R$$priv$project$rome$$internal$core$server$fs$MemoryFileSystem_ts$PRIORITY_FILES) {
				for (const file of paths) {
					if (priorityBasename === file.getBasename()) {
						paths.delete(file);
						await declareItem(file);
					}
				}
			}

			// Add the rest of the items
			await Promise.all(Array.from(paths, declareItem));

			// If this directory is a project then mark it as initialized as we've crawled all their descendents
			const project = this.server.projectManager.getProjectFromPath(
				directoryPath,
			);
			if (project !== undefined) {
				project.initialized = true;
			}

			return true;
		}

		exists(path) {
			// if we have this in our cache then the file exists
			if (this.files.has(path) || this.directories.has(path)) {
				return true;
			}

			// If we're still performing an initial crawl of any path higher in the tree then we don't know if it exists yet
			for (const projectDirectory of this.watchPromises.keys()) {
				if (path.isRelativeTo(projectDirectory)) {
					return undefined;
				}
			}

			// if we're watching the parent directory then we'd have it in our cache if it existed
			const parent = path.getParent();
			if (this.directories.has(parent)) {
				return false;
			}

			return undefined;
		}

		async existsHard(path) {
			const resolvedExistence = this.exists(path);
			if (resolvedExistence === undefined) {
				return ___R$project$rome$$internal$fs$index_ts$exists(path);
			} else {
				return resolvedExistence;
			}
		}

		async refreshPath(
			path,
			customCrawlOpts = {},
			originMessage = "maybeRefreshFile",
		) {
			if (!this.isActiveWatcherId(customCrawlOpts.watcherId)) {
				return;
			}

			const diagnostics = this.server.createDisconnectedDiagnosticsProcessor([
				{
					category: "memory-fs",
					message: originMessage,
				},
			]);

			let newStats;
			try {
				newStats = await this.hardStat(path);
			} catch (err) {
				if (err.code === "ENOENT") {
					// Only call handleDeletion if we think this file still exists
					if (this.exists(path)) {
						await this.handleDeletion(path);
					}
				} else {
					throw err;
				}
			}
			if (newStats === undefined) {
				// Deleted
				return;
			}

			const crawlOpts = Object.assign(
				{reason: "watch", diagnostics},
				customCrawlOpts,
			);

			if (newStats.type === "directory") {
				await this.addDirectory(path, newStats, crawlOpts);
			} else if (newStats.type === "file") {
				await this.addFile(path, newStats, crawlOpts);
			}
		}

		async addFile(path, stats, opts) {
			if (!this.hasStatsChanged(path, stats)) {
				return false;
			}

			// Check if this file has been ignored
			if (this.isIgnored(path, "file")) {
				return false;
			}

			if (opts.tick !== undefined) {
				opts.tick(path);
			}

			const isNew = !this.files.has(path);
			this.files.set(path, stats);
			this.addFileToDirectoryListing(path);

			const basename = path.getBasename();
			const dirname = path.getParent();

			// Warn about potentially incorrect Rome config filenames
			const {projectManager} = this.server;
			projectManager.checkPathForIncorrectConfig(path, opts.diagnostics);

			// Detect file changes
			const oldStats = this.getFileStats(path);
			if (oldStats !== undefined && opts.reason === "watch") {
				this.logger.info(
					___R$project$rome$$internal$markup$escape_ts$markup`File change: <emphasis>${path}</emphasis>`,
				);

				await Promise.all([
					this.server.refreshFileEvent.push(path),
					this.changedFileEvent.push({path, oldStats, newStats: stats}),
				]);

				// Watcher could have been closed by an event
				if (!this.isActiveWatcherId(opts.watcherId)) {
					return false;
				}
			}

			//this.logger.info(markup`Found: <emphasis>${path}</emphasis>`);

			// Add project if this is a config
			if (
				dirname.getBasename() ===
				___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_DIRECTORY &&
				___R$project$rome$$internal$project$constants_ts$PROJECT_CONFIG_FILENAMES.includes(
					basename,
				)
			) {
				await projectManager.addDiskProject({
					// Get the directory above .config
					projectDirectory: dirname.getParent(),
					configPath: path,
				});
			}

			if (
				___R$$priv$project$rome$$internal$core$server$fs$MemoryFileSystem_ts$isValidManifest(
					path,
				)
			) {
				await this.declareManifest({
					content: undefined,
					diagnostics: opts.diagnostics,
					dirname,
					path,
				});
			}

			if (isNew) {
				await this.newFileEvent.push(path);
			}

			return true;
		}

		glob(arg, opts = {}) {
			const globber = new ___R$project$rome$$internal$core$server$fs$glob_ts$Globber(
				this.server,
				Object.assign({}, opts, {args: [arg]}),
			);
			return globber.search(arg);
		}
	}


  // project-rome/@internal/core/server/Cache.ts
// Basic checks to determine if we can consider a and b to be mergable
	function ___R$$priv$project$rome$$internal$core$server$Cache_ts$areEntriesEqual(
		a,
		b,
	) {
		if (a.version !== b.version) {
			// Outdated cache file
			return false;
		}

		if (a.configHash !== b.configHash) {
			// Project config has been changed since this was last updated
			return false;
		}

		if (a.mtime !== b.mtime) {
			// File has been changed
			return false;
		}

		return true;
	}

	// Write cache entries every 5 seconds after the first modification
	const ___R$$priv$project$rome$$internal$core$server$Cache_ts$BATCH_WRITES_MS = 5_000;

	class ___R$project$rome$$internal$core$server$Cache_ts$default {
		constructor(server) {
			let disabled = false;
			if (
				___R$project$rome$$internal$cli$environment$index_ts$getEnvVar(
					"ROME_DEV",
				).type ===
				"ENABLED"
			) {
				disabled = true;
			}
			if (
				___R$project$rome$$internal$cli$environment$index_ts$getEnvVar(
					"ROME_CACHE",
				).type ===
				"DISABLED"
			) {
				disabled = true;
			}
			if (server.options.forceCacheEnabled) {
				disabled = false;
			}

			this.server = server;
			this.loadedEntries = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
			this.disabled = disabled;
			this.cachePath = server.userConfig.cachePath;

			this.runningWritePromise = undefined;
			this.pendingWriteTimer = undefined;
			this.pendingWrites = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
		}

		getDirectory() {
			return this.cachePath;
		}

		async init() {
			this.server.memoryFs.deletedFileEvent.subscribe(async (paths) => {
				for (const path of paths) {
					await this.server.cache.handleDeleted(path);
				}
			});

			const {memoryFs} = this.server;
			await ___R$project$rome$$internal$fs$index_ts$createDirectory(
				this.cachePath,
			);
			await memoryFs.watch(this.cachePath);

			this.server.endEvent.subscribe(async () => {
				// Wait on possible running writePending
				await this.runningWritePromise;

				// Write any remaining
				await this.writePending("end");
			});
		}

		async clear() {
			// Remove contents but not the directory itself
			for (const path of await ___R$project$rome$$internal$fs$index_ts$readDirectory(
				this.cachePath,
			)) {
				await ___R$project$rome$$internal$fs$index_ts$removeDirectory(path);
			}

			// Clear internal structures
			this.loadedEntries.clear();
			this.pendingWrites.clear();
		}

		async writePending(reason) {
			// Clear timer since we're now running
			const {pendingWriteTimer} = this;
			if (pendingWriteTimer !== undefined) {
				clearTimeout(pendingWriteTimer);
			}

			const {pendingWrites} = this;
			this.pendingWrites = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();

			// Write pending files
			const filelinks = [];
			for (const [path, entry] of pendingWrites) {
				filelinks.push(
					___R$project$rome$$internal$markup$escape_ts$markup`${path}`,
				);
				await ___R$project$rome$$internal$fs$index_ts$createDirectory(
					path.getParent(),
				);
				await ___R$project$rome$$internal$fs$index_ts$writeFile(
					path,
					___R$project$rome$$internal$codec$json$index_ts$stringifyJSON(entry),
				);
			}

			// Log
			const {logger} = this.server;
			if (filelinks.length > 0) {
				logger.info(
					___R$project$rome$$internal$markup$escape_ts$markup`[Cache] Wrote entries due to ${reason}`,
				);
				logger.list(filelinks);
			}
		}

		addPendingWrite(path, entry) {
			this.pendingWrites.set(path, entry);

			// Set a write timer
			const {pendingWriteTimer} = this;
			if (pendingWriteTimer !== undefined) {
				return;
			}

			this.pendingWriteTimer = setTimeout(
				() => {
					this.runningWritePromise = this.writePending("queue").catch((err) => {
						this.server.onFatalError(err);
					}).finally(() => {
						// Finished running
						this.runningWritePromise = undefined;
					});
				},
				___R$$priv$project$rome$$internal$core$server$Cache_ts$BATCH_WRITES_MS,
			);
		}

		async createEmptyEntry(path) {
			const {projectManager, memoryFs} = this.server;

			const project = await projectManager.assertProject(path);

			const configHashes = [...project.meta.configHashes];
			const pkg = this.server.memoryFs.getOwnedManifest(path);
			if (pkg !== undefined) {
				configHashes.push(pkg.hash);
			}

			return {
				version: ___R$project$rome$$internal$core$common$constants_ts$VERSION,
				projectDir: project.directory.join(),
				configHash: configHashes.join(";"),
				mtime: memoryFs.getMtime(path),
				compile: {},
				analyzeDependencies: undefined,
				moduleSignature: undefined,
				lint: {},
			};
		}

		getCacheFilename(path) {
			const uid = this.server.projectManager.getUid(path, true);
			// We add a single underscore to prevent the extension from being registered
			return this.cachePath.append(uid + "_");
		}

		async handleDeleted(path) {
			// Handle the file not existing
			const cacheFilename = this.getCacheFilename(path);
			await ___R$project$rome$$internal$fs$index_ts$removeFile(cacheFilename);
			this.loadedEntries.delete(path);
		}

		async get(path) {
			const emptyEntry = await this.createEmptyEntry(path);

			// If we have a loaded memory entry, make sure it's valid compared to the default entry (file changes etc)
			let loaded = this.loadedEntries.get(path);
			if (
				loaded !== undefined &&
				___R$$priv$project$rome$$internal$core$server$Cache_ts$areEntriesEqual(
					loaded,
					emptyEntry,
				)
			) {
				return loaded;
			}

			if (this.disabled) {
				return emptyEntry;
			}

			const cacheFilename = this.getCacheFilename(path);
			const entry = await this.checkPossibleDiskCacheEntry(
				cacheFilename,
				emptyEntry,
			);
			this.loadedEntries.set(path, entry);
			return entry;
		}

		async checkPossibleDiskCacheEntry(cacheFilename, emptyEntry) {
			const {memoryFs} = this.server;

			if (!memoryFs.exists(cacheFilename)) {
				return emptyEntry;
			}

			try {
				const json = await ___R$project$rome$$internal$fs$index_ts$readFileText(
					cacheFilename,
				);
				const obj = JSON.parse(json);

				if (
					___R$$priv$project$rome$$internal$core$server$Cache_ts$areEntriesEqual(
						emptyEntry,
						obj,
					)
				) {
					return Object.assign({}, emptyEntry, obj);
				} else {
					// If the entries aren't equal then there's something wrong with the cache entry
					await this.handleDeleted(cacheFilename);
					return emptyEntry;
				}
			} catch (err) {
				// TODO add some heuristic to only catch json and cache permission errors
				return emptyEntry;
			}
		}

		async update(path, partialEntryCallback) {
			const currEntry = await this.get(path);
			const partialEntry =
				typeof partialEntryCallback === "function"
					? partialEntryCallback(currEntry)
					: partialEntryCallback;

			const entry = Object.assign({}, currEntry, partialEntry);

			const cacheFilename = this.getCacheFilename(path);
			this.loadedEntries.set(path, entry);

			if (this.disabled) {
				return;
			}

			// If we have a file buffer then there's no point at all in writing this cache file
			// Since it will have an mtime that doesn't exist on disk, and will never be validated
			// if the server is restarted.
			if (this.server.memoryFs.hasBuffer(path)) {
				return;
			}

			this.addPendingWrite(cacheFilename, entry);
		}
	}


  // project-rome/@internal/core/common/utils/setupGlobalErrorHandlers.ts
function ___R$project$rome$$internal$core$common$utils$setupGlobalErrorHandlers_ts$default(
		callback,
	) {
		const onUncaughtException = (err) => {
			callback(err);
		};
		process.on("uncaughtException", onUncaughtException);

		const onUnhandledRejection = (reason, promise) => {
			promise.then(() => {
				throw new Error(
					"Promise is rejected so should never hit this condition",
				);
			}).catch((err) => {
				callback(err);
			});
		};
		process.on("unhandledRejection", onUnhandledRejection);

		return () => {
			process.removeListener("uncaughtException", onUncaughtException);
			process.removeListener("unhandledRejection", onUnhandledRejection);
		};
	}


  // project-rome/@internal/core/server/ServerReporter.ts
class ___R$project$rome$$internal$core$server$ServerReporter_ts$default
		extends ___R$project$rome$$internal$cli$reporter$Reporter_ts$default {
		constructor(server) {
			super({
				wrapperFactory: server.wrapFatal.bind(server),
			});
			this.server = server;
		}

		progress(opts) {
			return this.server.createConnectedProgress(opts);
		}
	}


  // project-rome/@internal/core/common/virtual-modules.ts
const ___R$project$rome$$internal$core$common$virtual$modules_ts$modules = new Map();

	/* GENERATED:START(hash:62fae5f175b94703729e1cc6f8b17087fd7f0d3c,id:main) Everything below is automatically generated. DO NOT MODIFY. Run `./rome run scripts/generated-files/virtual-modules` to update. */
	___R$project$rome$$internal$core$common$virtual$modules_ts$modules.set(
		"rome",
		new Map([
			[
				"index.ts",
				{
					"mtime": 1_596_092_146_931.4539,
					"content": '/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport {TestHelper, test, testOptions} from "./test";\n',
				},
			],
			[
				"package.json",
				{
					"mtime": 1_596_913_605_922.6692,
					"content": '{\n  "name": "@internal/virtual-rome",\n  "type": "module",\n  "private": true,\n  "main": "index.ts"\n}\n',
				},
			],
			[
				"test.ts",
				{
					"mtime": 1_596_599_768_028.357,
					"content": '/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {AsyncVoidCallback, JSONPropertyValue, VoidCallback} from "./types";\n\nexport type ExpectedError = undefined | string | RegExp | Function;\n\nexport type TestSnapshotOptions = {\n\tfilename?: string;\n\tlanguage?: string;\n};\n\n// These diagnostics are subsets of the official diagnostics\n// We can potentially normalize these and ensure backwards compatibility with the official diagnostics\n\nexport type TestDiagnosticLogCategory = "none" | "info" | "warn" | "error";\n\nexport type TestDiagnosticAdviceInspect = {\n\ttype: "inspect";\n\tdata: JSONPropertyValue;\n};\n\nexport type TestDiagnosticAdviceList = {\n\ttype: "list";\n\tlist: Array<string>;\n};\n\nexport type TestDiagnosticAdviceCode = {\n\ttype: "code";\n\tsourceText: string;\n};\n\nexport type TestDiagnosticAdviceLog = {\n\ttype: "log";\n\tcategory: TestDiagnosticLogCategory;\n\ttext: string;\n};\n\nexport type TestDiagnosticAdviceItem =\n\t| TestDiagnosticAdviceInspect\n\t| TestDiagnosticAdviceCode\n\t| TestDiagnosticAdviceLog\n\t| TestDiagnosticAdviceList;\n\nexport interface TestHelper {\n\taddToAdvice(\n\t\titem: TestDiagnosticAdviceItem | (() => TestDiagnosticAdviceItem),\n\t): void;\n\tclearAdvice(): void;\n\tonTeardown(callback: AsyncVoidCallback): void;\n\tclearTimeout(): void;\n\textendTimeout(time: number): void;\n\tsetTimeout(time: number): void;\n\tcheckTimeout(): void;\n\ttruthy(value: unknown, message?: string): void;\n\tfalsy(value: unknown, message?: string): void;\n\ttrue(value: unknown, message?: string): void;\n\tfalse(value: unknown, message?: string): void;\n\tis(received: unknown, expected: unknown, message?: string): void;\n\tnot(received: unknown, expected: unknown, message?: string): void;\n\tlooksLike(received: unknown, expected: unknown, message?: string): void;\n\tnotLooksLike(received: unknown, expected: unknown, message?: string): void;\n\tthrows(\n\t\tthrower: VoidCallback,\n\t\texpected?: ExpectedError,\n\t\tmessage?: string,\n\t): void;\n\tthrowsAsync(\n\t\tthrower: AsyncVoidCallback,\n\t\texpected?: ExpectedError,\n\t\tmessage?: string,\n\t): Promise<void>;\n\tnotThrows(nonThrower: VoidCallback, message?: string): void;\n\tnotThrowsAsync(\n\t\tnonThrower: AsyncVoidCallback,\n\t\tmessage?: string,\n\t): Promise<void>;\n\tregex(contents: string, regex: RegExp, message?: string): void;\n\tnotRegex(contents: string, regex: RegExp, message?: string): void;\n\tsnapshot(\n\t\texpected: unknown,\n\t\tmessage?: string,\n\t\topts?: TestSnapshotOptions,\n\t): string;\n\tinlineSnapshot(received: unknown, expected?: string | boolean | number): void;\n\tnamedSnapshot(\n\t\tname: string,\n\t\texpected: unknown,\n\t\tmessage?: string,\n\t\topts?: TestSnapshotOptions,\n\t): string;\n}\n\nexport type TestName = string | Array<string>;\n\ndeclare const __ROME__TEST_OPTIONS__: GlobalTestOptions;\n\nexport type GlobalTestOptions =\n\t| undefined\n\t| {\n\t\t\tdirname?: string;\n\t\t\tregister?: (err: Error, opts: TestOptions, callback: TestCallback) => void;\n\t\t};\n\ntype NamelessTestOptions = {\n\ttimeout?: number;\n\tonly?: boolean;\n};\n\nexport type TestCallback = (t: TestHelper) => void | undefined | Promise<void>;\n\nexport type TestOptions = NamelessTestOptions & {\n\tname: TestName;\n};\n\ntype TestArg = TestName | NamelessTestOptions | TestCallback | undefined;\n\nexport const testOptions: NonNullable<GlobalTestOptions> =\n\ttypeof __ROME__TEST_OPTIONS__ === "undefined" ? {} : __ROME__TEST_OPTIONS__;\n\nfunction registerTest(\n\tcallsiteError: Error,\n\topts: TestOptions,\n\tcallback: TestCallback,\n) {\n\tconst register = testOptions.register;\n\n\tif (typeof register !== "function") {\n\t\tthrow new Error("Test harness does not exist");\n\t}\n\n\tregister(callsiteError, opts, callback);\n}\n\nfunction isOptionsObject(arg: TestArg): arg is NamelessTestOptions {\n\treturn typeof arg === "object" && arg != null && !Array.isArray(arg);\n}\n\nfunction splitArgs(\n\targs: TestRegisterFunctionArgs,\n): {\n\toptions: TestOptions;\n\tcallback: TestCallback;\n} {\n\tconst name = args.shift();\n\tif (typeof name !== "string" && !Array.isArray(name)) {\n\t\tthrow new Error("Expected test name to be a string or an array of strings");\n\t}\n\n\tconst callback = args.pop();\n\tif (typeof callback !== "function") {\n\t\tthrow new Error("Expected options callback");\n\t}\n\n\tconst options = args.pop();\n\tif (options !== undefined && !isOptionsObject(options)) {\n\t\tthrow new Error("Expected options object");\n\t}\n\n\tif (args.length > 0) {\n\t\tthrow new Error("Expected to have exhausted test register arguments");\n\t}\n\n\treturn {\n\t\toptions: {\n\t\t\t...options,\n\t\t\tname,\n\t\t},\n\t\tcallback,\n\t};\n}\n\ntype TestRegisterFunctionArgs =\n\t| [TestName, TestCallback]\n\t| [TestName, NamelessTestOptions, TestCallback];\n\ntype TestRegisterFunction = (...args: TestRegisterFunctionArgs) => void;\n\nexport const test: TestRegisterFunction & {\n\tonly: TestRegisterFunction;\n} = function(...args: TestRegisterFunctionArgs) {\n\tconst {options, callback} = splitArgs(args);\n\tregisterTest(new Error(), options, callback);\n};\n\ntest.only = function(...args: TestRegisterFunctionArgs) {\n\tconst {options, callback} = splitArgs(args);\n\tregisterTest(\n\t\tnew Error(),\n\t\t{\n\t\t\t...options,\n\t\t\tonly: true,\n\t\t},\n\t\tcallback,\n\t);\n};\n',
				},
			],
			[
				"types.ts",
				{
					"mtime": 1_596_271_135_840.0615,
					"content": "/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// These are copied from internal/codec-config/types.ts\nexport type JSONValue =\n\t| null\n\t| string\n\t| number\n\t| boolean\n\t| JSONObject\n\t| JSONArray;\n\nexport type JSONPropertyValue = undefined | void | JSONValue;\n\nexport type JSONObject = {\n\t[x: string]: JSONPropertyValue;\n};\n\nexport type JSONArray = Array<JSONValue>;\n\nexport type VoidCallback = () => void | undefined;\n\nexport type AsyncVoidCallback = () =>\n\t| void\n\t| undefined\n\t| Promise<void | undefined>;\n",
				},
			],
		]),
	);
	/* GENERATED:END(id:main) */


  // project-rome/@internal/core/common/VirtualModules.ts
class ___R$project$rome$$internal$core$common$VirtualModules_ts$default {
		constructor() {
			// A NULL character isn't allowed in Windows or Unix file paths
			// We abuse that to distinguish and represent virtual paths
			this.nullAbsolute = ___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
				"/\0",
			);

			this.statMap = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
		}

		getMockDirectory() {
			return this.nullAbsolute;
		}

		init() {
			const {statMap} = this;

			for (const [moduleName, files] of ___R$project$rome$$internal$core$common$virtual$modules_ts$modules) {
				for (const [subpath, {content, mtime}] of files) {
					statMap.set(
						this.nullAbsolute.append(moduleName).append(subpath),
						{
							content,
							stats: {
								type: "file",
								size: content.length,
								mtime,
							},
						},
					);
				}
			}

			// Add directories
			for (const [path, {stats: fileStats}] of statMap) {
				if (fileStats.type !== "file") {
					continue;
				}

				for (const directory of path.getParent().getChain()) {
					const directoryEntry = statMap.get(directory);
					if (directoryEntry !== undefined) {
						// Directory mtime is the newest file
						if (fileStats.mtime > directoryEntry.stats.mtime) {
							directoryEntry.stats.mtime = fileStats.mtime;
						}
						continue;
					}

					if (directory.getBasename() === "\0") {
						// Reached the "root"
						break;
					}

					statMap.set(
						directory,
						{
							content: undefined,
							stats: {
								type: "directory",
								size: 0,
								// Init to mtime of the first entry. We'll pick the highest mtime of all listings later if necessary.
								mtime: fileStats.mtime,
							},
						},
					);
				}
			}
		}

		getStatMap() {
			return this.statMap;
		}

		isVirtualPath(path) {
			const segments = path.getSegments();
			return segments[0] === "" && segments[1] === "\0";
		}

		getPossibleVirtualFileContents(path) {
			if (this.isVirtualPath(path)) {
				const entry = this.statMap.assert(path);
				return entry.content;
			}

			return undefined;
		}

		resolvePossibleVirtualModuleName(name) {
			if (
				___R$project$rome$$internal$core$common$virtual$modules_ts$modules.has(
					name,
				)
			) {
				return this.nullAbsolute.append(name);
			} else {
				return undefined;
			}
		}
	}


  // project-rome/@internal/core/server/fs/RecoveryStore.ts
const ___R$$priv$project$rome$$internal$core$server$fs$RecoveryStore_ts$DEFAULT_WRITE_FILES_EVENTS = {
		onFileDone() {},
		beforeFileWrite() {},
		unexpectedModified: (path, expectedMtime, actualMtime) => {
			throw new Error(
				"File " +
				path.join() +
				" was not updated as it was changed since we read it",
			);
		},
		expectedExists: (path) => {
			throw new Error(
				"File " +
				path.join() +
				" was not updated as it does not exist when we expected it to",
			);
		},
		unexpectedExists: (path) => {
			throw new Error(
				"File " +
				path.join() +
				" was not written as it exists when we didn't expect it",
			);
		},
	};

	// Chosen arbitrarily
	const ___R$$priv$project$rome$$internal$core$server$fs$RecoveryStore_ts$MAX_STORE_ENTRIES = 5;

	// This class is used for saving files before we modify them. This is to protect users from
	// data loss when running commands.
	// We are deliberately careful here to avoid race conditions and properly clear and restore.
	class ___R$project$rome$$internal$core$server$fs$RecoveryStore_ts$default {
		constructor(server) {
			this.server = server;
			this.requestIdToStore = new Map();
			this.evictableStoreIds = [];
			this.blockSave = undefined;
			this.logger = server.logger.namespace(
				___R$project$rome$$internal$markup$escape_ts$markup`[RecoveryStore]`,
			);
			this.shouldTruncate = true;
			this.recoveryDirectoryPath = server.userConfig.recoveryPath;
		}

		getDirectory() {
			return this.recoveryDirectoryPath;
		}

		getStoreDirectoryPath(storeId) {
			return this.recoveryDirectoryPath.append(storeId);
		}

		getStoreIndexPath(storeId) {
			return this.getStoreDirectoryPath(storeId).append("index.json");
		}

		async readRecoveryDirectory() {
			const paths = [];

			for (const path of await ___R$project$rome$$internal$fs$index_ts$readDirectory(
				this.recoveryDirectoryPath,
			)) {
				const basename = path.getBasename();
				if (basename[0] === ".") {
					continue;
				}

				// First segment is a unix epoch
				const timestamp = new Date(Number(basename.split("-")[0])).valueOf();
				if (isNaN(timestamp)) {
					// Malformed
					continue;
				}

				paths.push([path, timestamp]);
			}

			paths.sort((a, b) => b[1] - a[1]);

			return new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet(
				paths.map(([path]) => path),
			);
		}

		async init() {
			await ___R$project$rome$$internal$fs$index_ts$createDirectory(
				this.recoveryDirectoryPath,
			);

			// Register initial stores
			this.evictableStoreIds = Array.from(
				await this.readRecoveryDirectory(),
				(path) => path.getBasename(),
			);
			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Initial store content ${___R$project$rome$$internal$pretty$format$index_ts$default(
					this.evictableStoreIds,
				)}`,
			);

			// Drop excessive directories
			await this.truncate();
		}

		async clear() {
			this.evictableStoreIds = [];
			this.requestIdToStore.clear();

			for (const path of await this.readRecoveryDirectory()) {
				await this.drop(path.getBasename(), "Clear requested");
			}
		}

		// Drop old stores if we are at max entries
		async truncate() {
			if (!this.shouldTruncate) {
				return;
			}

			while (
				this.evictableStoreIds.length >
				___R$$priv$project$rome$$internal$core$server$fs$RecoveryStore_ts$MAX_STORE_ENTRIES
			) {
				const dropStoreId = this.evictableStoreIds.pop();
				await this.drop(dropStoreId, "Reached capacity");
			}
		}

		async drop(storeId, reason) {
			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Dropping recovery store <emphasis>${storeId}</emphasis>. Reason: ${reason}`,
			);
			await ___R$project$rome$$internal$fs$index_ts$removeDirectory(
				this.getStoreDirectoryPath(storeId),
			);
		}

		async getAllStores() {
			const stores = [];
			let diagnostics = [];

			for (const path of await this.readRecoveryDirectory()) {
				const {diagnostics: storeDiagnostics} = await ___R$project$rome$$internal$diagnostics$wrap_ts$catchDiagnostics(async () => {
					const store = await this.maybeGetStore(path.getBasename());
					if (store !== undefined) {
						stores.push(store);
					}
				});
				if (storeDiagnostics !== undefined) {
					diagnostics = diagnostics.concat(storeDiagnostics);
				}
			}

			return {stores, diagnostics};
		}

		async getStore(storeId, location = {}) {
			const store = await this.maybeGetStore(storeId);
			if (store === undefined) {
				throw ___R$project$rome$$internal$diagnostics$errors_ts$createSingleDiagnosticError({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.RECOVERY_STORE.NOT_FOUND(
						storeId,
					),
					location,
				});
			} else {
				return store;
			}
		}

		async maybeGetStore(storeId) {
			const indexPath = this.getStoreIndexPath(storeId);
			if (!(await ___R$project$rome$$internal$fs$index_ts$exists(indexPath))) {
				return undefined;
			}

			const indexContent = await ___R$project$rome$$internal$fs$index_ts$readFileText(
				indexPath,
			);
			const index = ___R$project$rome$$internal$codec$json$index_ts$consumeJSON({
				input: indexContent,
				path: indexPath,
			});

			const entries = [];

			for (const [key, value] of index.get("files").asMap()) {
				entries.push({
					fileId: key,
					artifactPath: this.getStoreDirectoryPath(storeId).append(key),
					originalPath: value.asAbsoluteFilePath(),
				});
			}

			return {
				storeId,
				timestamp: index.get("timestamp").asString(),
				command: index.get("command").asString(),
				entries,
			};
		}

		async createRequestStore(req) {
			await this.truncate();
			const timestamp = new Date().toISOString();
			const storeId = Date.now() + "-" + req.query.commandName + "-" + req.id;
			const command = req.getDiagnosticLocationFromFlags("none").sourceText;
			const store = {
				index: {
					timestamp,
					command,
					files: {},
				},
				fileCounter: 0,
				storeId,
				requestId: req.id,
			};
			this.requestIdToStore.set(req.id, store);

			const path = this.getStoreDirectoryPath(store.storeId);
			await ___R$project$rome$$internal$fs$index_ts$createDirectory(path);
			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Created store <emphasis>${store.storeId}</emphasis> at <emphasis>${path}</emphasis>`,
			);

			// Only consider a request up for eviction when the request has finished
			req.endEvent.subscribe(async () => {
				await this.commit(req);
				this.evictableStoreIds.unshift(storeId);
			});

			return store;
		}

		async save(req, path, content) {
			if (this.blockSave !== undefined) {
				await this.blockSave;
			}

			let store = this.requestIdToStore.get(req.id);
			if (store === undefined) {
				const promise = this.createRequestStore(req);
				this.blockSave = promise;
				store = await promise;
			}

			const fileId = String(store.fileCounter++);
			store.index.files[fileId] = path.join();

			const storePath = this.getStoreDirectoryPath(store.storeId).append(fileId);
			await ___R$project$rome$$internal$fs$index_ts$writeFile(
				storePath,
				content,
			);
			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Save file from <emphasis>${path}</emphasis> to <emphasis>${storePath}</emphasis>`,
			);
		}

		// Take the contents of the store and write the artifacts back to their original location
		async apply(req, storeId, location = {}, filter) {
			const store = await this.getStore(storeId, location);

			let entries = [];

			let fileIdsAllowlist;
			if (filter !== undefined) {
				fileIdsAllowlist = await filter(store);
			}

			for (const entry of store.entries) {
				const {fileId, artifactPath, originalPath} = entry;
				if (fileIdsAllowlist !== undefined && !fileIdsAllowlist.includes(fileId)) {
					continue;
				}

				// Calculate mtime we expect
				let mtime;
				if (await ___R$project$rome$$internal$fs$index_ts$exists(originalPath)) {
					mtime = (await ___R$project$rome$$internal$fs$index_ts$lstat(
						originalPath,
					)).mtimeMs;
				}

				const content = await ___R$project$rome$$internal$fs$index_ts$readFileText(
					artifactPath,
				);

				req.queueSaveFile(
					originalPath,
					{
						type: "WRITE",
						mtime,
						content,
					},
				);
				entries.push(entry);
			}

			try {
				// Pause truncation since declaring this new store could cause the one we're applying to overflow
				this.shouldTruncate = false;
				await req.flushFiles();
				await this.drop(storeId, "Applied patch already");
			} finally {
				this.shouldTruncate = true;
			}

			return entries;
		}

		// Commits the index file that we use to map the artifacts to original paths
		async commit(req) {
			const store = this.requestIdToStore.get(req.id);
			if (store !== undefined) {
				const indexPath = this.getStoreIndexPath(store.storeId);
				await ___R$project$rome$$internal$fs$index_ts$writeFile(
					indexPath,
					___R$project$rome$$internal$codec$json$index_ts$stringifyJSON(
						store.index,
					),
				);
				this.logger.info(
					___R$project$rome$$internal$markup$escape_ts$markup`Committed store index to <emphasis>${indexPath}</emphasis>`,
				);
			}
		}

		async writeFile(path, op, events, registerFile) {
			const {server} = this;
			let fd;
			let success = false;

			try {
				if (op.type === "UNSAFE_WRITE") {
					await ___R$project$rome$$internal$fs$index_ts$writeFile(
						path,
						op.content,
					);
					success = true;
				} else if (op.type === "WRITE") {
					const {mtime, content} = op;

					if (mtime === undefined) {
						const {content} = op;
						try {
							// `mtime === undefined` means we expect the file to not exist
							// wx: Open file for writing. Fails if the path exists.
							fd = await ___R$project$rome$$internal$fs$index_ts$openFile(
								path,
								"wx",
							);
							await fd.writeFile(content);
							success = true;
						} catch (err) {
							if (err.code === "EEXIST") {
								events.unexpectedExists(path);
							} else {
								throw err;
							}
						}
					} else {
						try {
							// `mtime !== undefined` means we expect the file to exist
							// r+: Open file for reading and writing. An exception occurs if the file does not exist.
							fd = await ___R$project$rome$$internal$fs$index_ts$openFile(
								path,
								"r+",
							);

							// First verify the mtime
							const stats = await fd.stat();
							if (stats.mtimeMs === mtime) {
								await events.beforeFileWrite(path, fd);
								await fd.truncate(0);
								await fd.write(content, 0);
								success = true;
							} else {
								registerFile([path]);
								events.unexpectedModified(path, mtime, stats.mtimeMs);
							}
						} catch (err) {
							if (err.code === "ENOENT") {
								events.expectedExists(path);
							} else {
								throw err;
							}
						}
					}
				}
			} catch (err) {
				registerFile([path]);
			} finally {
				// Close file descriptor
				if (fd !== undefined) {
					await fd.close();
				}

				// We want writeFiles to only return once all the refreshFileEvent handlers have ran
				// We call maybeRefreshPath to do a hard check on the filesystem and update our in memory fs
				// This mitigates slow watch events
				server.wrapFatalPromise(
					server.memoryFs.refreshPath(path, {}, "Server.writeFiles"),
				);
			}

			return success;
		}

		// Utility to write a list of files and wait for all refresh events to be emitted
		// We optionally validate mtime of the existing file if specified
		// The bar here for race conditions should be extremely high as we want to minimize bad writes
		async writeFiles(
			files,
			opts = {unsafeWrites: false},
			events = ___R$$priv$project$rome$$internal$core$server$fs$RecoveryStore_ts$DEFAULT_WRITE_FILES_EVENTS,
		) {
			if (files.size === 0) {
				return 0;
			}

			// For unsafe writes we don't bother checking for locks or mtime
			if (opts.unsafeWrites) {
				await Promise.all(
					Array.from(
						files,
						async ([path, {content}]) => {
							await ___R$project$rome$$internal$fs$index_ts$writeFile(
								path,
								content,
							);
						},
					),
				);
				return files.size;
			}

			const paths = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathSet(
				files.keys(),
			);
			const teardowns = [];
			const {server} = this;

			// Files successfully written
			let fileCount = 0;

			let registerFile = (paths) => {
				throw new Error("Function should have been replaced");
			};

			// refreshFileEvent doesn't resolve
			const waitRefresh = new Promise((resolve) => {
				registerFile = (refreshedPaths) => {
					for (const path of refreshedPaths) {
						if (!paths.has(path)) {
							continue;
						}

						events.onFileDone(path);
						paths.delete(path);
						if (paths.size === 0) {
							resolve();
						}
					}
				};

				const sub = server.refreshFileEvent.subscribe(registerFile);
				teardowns.push(() => sub.unsubscribe());
			});

			try {
				// Write files
				// We call fs.open to avoid race conditions since we want to check the mtime, and then update the
				// file if it's the same
				await Promise.all(
					Array.from(
						files,
						async ([path, op]) => {
							const success = await this.writeFile(
								path,
								op,
								events,
								registerFile,
							);
							if (success) {
								fileCount++;
							}
						},
					),
				);

				// Protects against file events not being emitted and causing hanging
				const timeoutPromise = new Promise((resolve, reject) => {
					const timeout = setTimeout(
						() => {
							const lines = [
								"File events should have been emitted within a second. Did not receive an event for:",
							];
							for (const path of paths) {
								lines.push(" - " + path.join());
							}
							reject(new Error(lines.join("\n")));
						},
						1_000,
					);

					teardowns.push(async () => {
						clearTimeout(timeout);
					});
				});

				await Promise.race([waitRefresh, timeoutPromise]);
			} finally {
				for (const teardown of teardowns) {
					await teardown();
				}
				await this.server.memoryFs.processingLock.wait();
			}

			return fileCount;
		}
	}


  // project-rome/@internal/core/common/handleFatalError.ts
function ___R$project$rome$$internal$core$common$handleFatalError_ts$default(
		opts,
	) {
		// Swallow promise. Should never throw an error.
		___R$$priv$project$rome$$internal$core$common$handleFatalError_ts$_handleFatalError(
			opts,
		).then();
	}

	async function ___R$$priv$project$rome$$internal$core$common$handleFatalError_ts$_handleFatalError(
		{error, source, reporter, exit = true},
	) {
		try {
			const diagnostics = ___R$project$rome$$internal$diagnostics$errors_ts$getOrDeriveDiagnosticsFromError(
				error,
				{
					description: {
						category: "internalError/fatal",
					},
					label: source,
					tags: {
						internal: true,
						fatal: true,
					},
				},
			);

			await ___R$project$rome$$internal$cli$diagnostics$index_ts$printDiagnostics({
				diagnostics,
				suppressions: [],
				excludeFooter: true,
				printerOptions: {
					reporter,
					processor: new ___R$project$rome$$internal$diagnostics$DiagnosticsProcessor_ts$default(),
				},
			});
		} catch (logErr) {
			console.error(
				"Failed to output detailed fatal error information. Original error:",
			);
			console.error(error.stack);
			console.error("Log error:");
			console.error(logErr.stack);
		} finally {
			if (exit) {
				process.exit(1);
			}
		}
	}


  // project-rome/@internal/core/server/Server.ts
const ___R$$priv$project$rome$$internal$core$server$Server_ts$disallowedFlagsWhenReviewing = [
		"watch",
	];

	function ___R$project$rome$$internal$core$server$Server_ts$partialServerQueryRequestToFull(
		partialQuery,
	) {
		const requestFlags = ___R$project$rome$$internal$typescript$helpers$index_ts$mergeObjects(
			___R$project$rome$$internal$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS,
			partialQuery.requestFlags || {},
		);

		return {
			commandName: partialQuery.commandName,
			args: partialQuery.args == null ? [] : partialQuery.args,
			noData: partialQuery.noData === true,
			noFileWrites: partialQuery.noFileWrites === true,
			requestFlags,
			silent: partialQuery.silent === true || requestFlags.benchmark,
			terminateWhenIdle: partialQuery.terminateWhenIdle === true,
			commandFlags: partialQuery.commandFlags === undefined
				? {}
				: partialQuery.commandFlags,
			cancelToken: partialQuery.cancelToken,
		};
	}

	async function ___R$$priv$project$rome$$internal$core$server$Server_ts$validateRequestFlags(
		req,
		serverCommand,
	) {
		const {requestFlags} = req.query;

		// Commands need to explicitly allow these flags
		___R$$priv$project$rome$$internal$core$server$Server_ts$validateAllowedRequestFlag(
			req,
			"watch",
			serverCommand,
		);
		___R$$priv$project$rome$$internal$core$server$Server_ts$validateAllowedRequestFlag(
			req,
			"review",
			serverCommand,
		);

		// Don't allow review in combination with other flags
		if (requestFlags.review) {
			for (const key of ___R$$priv$project$rome$$internal$core$server$Server_ts$disallowedFlagsWhenReviewing) {
				if (requestFlags[key]) {
					throw req.throwDiagnosticFlagError({
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.FLAGS.DISALLOWED_REVIEW_FLAG(
							key,
						),
						target: {type: "flag", key},
					});
				}
			}
		}
	}

	function ___R$$priv$project$rome$$internal$core$server$Server_ts$validateAllowedRequestFlag(
		req,
		flagKey,
		serverCommand,
	) {
		const allowRequestFlags = serverCommand.allowRequestFlags || [];
		if (req.query.requestFlags[flagKey] && !allowRequestFlags.includes(flagKey)) {
			throw req.throwDiagnosticFlagError({
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.FLAGS.DISALLOWED_REQUEST_FLAG(
					flagKey,
				),
				target: {type: "flag", key: flagKey},
			});
		}
	}

	class ___R$project$rome$$internal$core$server$Server_ts$default {
		constructor(opts) {
			this.onFatalErrorBound = this.onFatalError.bind(this);

			this.profiling = undefined;
			this.options = opts;

			this.userConfig = opts.userConfig;

			this.requestFileLocker = new ___R$project$rome$$internal$async$lockers_ts$FilePathLocker();

			this.connectedReporters = new ___R$project$rome$$internal$core$server$ServerReporter_ts$default(
				this,
			);

			this.connectedClientsListeningForLogs = new Set();
			this.connectedLSPServers = new Set();
			this.connectedClients = new Set();

			this.clientIdCounter = 0;

			this.logInitBuffer = "";
			this.requestRunningCounter = 0;
			this.terminateWhenIdle = false;

			this.clientStartEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "Server.clientStart",
			});

			this.requestStartEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "Server.requestStart",
			});

			this.refreshFileEvent = new ___R$project$rome$$internal$events$EventQueue_ts$default();

			this.endEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "Server.end",
				serial: true,
			});

			this.logger = new ___R$project$rome$$internal$core$common$utils$Logger_ts$default(
				{
					markupOptions: {
						userConfig: this.userConfig,
						humanizeFilename: (filename) => {
							const path = ___R$project$rome$$internal$path$index_ts$createUnknownPath(
								filename,
							);
							if (path.isAbsolute()) {
								const remote = this.projectManager.getRemoteFromLocalPath(
									path.assertAbsolute(),
								);
								if (remote !== undefined) {
									return remote.join();
								}
							}
							return undefined;
						},
						normalizePosition: (filename, line, column) => {
							const path = this.projectManager.getFilePathFromUid(filename);
							if (path === undefined) {
								return {filename, line, column};
							} else {
								return {filename: path.join(), line, column};
							}
						},
					},
				},
				{
					loggerType: "server",
					write: (chunk) => {
						this.emitServerLog(chunk);
					},
					check: () => {
						return (
							this.clientIdCounter === 0 ||
							this.connectedClientsListeningForLogs.size > 0
						);
					},
				},
			);
			this.logger.updateStream();

			this.virtualModules = new ___R$project$rome$$internal$core$common$VirtualModules_ts$default();
			this.recoveryStore = new ___R$project$rome$$internal$core$server$fs$RecoveryStore_ts$default(
				this,
			);
			this.memoryFs = new ___R$project$rome$$internal$core$server$fs$MemoryFileSystem_ts$default(
				this,
			);
			this.projectManager = new ___R$project$rome$$internal$core$server$project$ProjectManager_ts$default(
				this,
			);
			this.workerManager = new ___R$project$rome$$internal$core$server$WorkerManager_ts$default(
				this,
			);
			this.fileAllocator = new ___R$project$rome$$internal$core$server$fs$FileAllocator_ts$default(
				this,
			);
			this.resolver = new ___R$project$rome$$internal$core$server$fs$Resolver_ts$default(
				this,
			);
			this.cache = new ___R$project$rome$$internal$core$server$Cache_ts$default(
				this,
			);

			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`[Server] Created Server with options: ${___R$project$rome$$internal$pretty$format$index_ts$default(
					opts,
				)}`,
			);
		}

		// Used when starting up child processes and indicates whether they should start profiling
		// on init
		getRunningProfilingData() {
			return this.profiling;
		}

		// Derive a concatenated reporter from the logger and all connected clients
		// This should only be used synchronously as the streams will not stay in sync
		// Used for very important log messages
		getImportantReporter() {
			return ___R$project$rome$$internal$cli$reporter$Reporter_ts$default.concat([
				this.logger,
				this.connectedReporters,
			]);
		}

		emitServerLog(chunk) {
			if (this.clientIdCounter === 0) {
				this.logInitBuffer += chunk;
			}

			for (const {bridge} of this.connectedClientsListeningForLogs) {
				// Sometimes the bridge hasn't completely been teardown and we still consider it connected
				if (bridge.alive) {
					bridge.log.send({chunk, origin: "server"});
				}
			}
		}

		onFatalError(
			error,
			source = ___R$project$rome$$internal$markup$escape_ts$markup`server`,
		) {
			// Ensure workers are properly ended as they could be hanging
			this.workerManager.end();

			// NB: This will call process.exit. If we want to expose this for other use-cases then we will probably want to
			// make this customizable
			___R$project$rome$$internal$core$common$handleFatalError_ts$default({
				error,
				source,
				reporter: this.getImportantReporter(),
				exit: this.options.dedicated,
			});
		}

		// This is so all progress bars are renderer on each client. If we just use this.progressLocal then
		// while it would work, we would be doing all the rendering work on the server
		// The CLI also needs to know all the activeElements so it can properly draw and clear lines
		// We also create a progress bar for all connected LSP clients
		// Refer to ServerReporter
		createConnectedProgress(opts) {
			const progresses = [];

			for (const client of this.connectedClients) {
				progresses.push(client.reporter.progress(opts));
			}

			for (const server of this.connectedLSPServers) {
				progresses.push(server.createProgress(opts));
			}

			return ___R$project$rome$$internal$cli$reporter$util_ts$mergeProgresses(
				progresses,
			);
		}

		wrapFatalPromise(promise) {
			promise.catch(this.onFatalErrorBound);
		}

		// rome-ignore lint/ts/noExplicitAny: future cleanup
		wrapFatal(callback) {
			return (((...args) => {
				try {
					const res = callback.apply(null, [...args]);
					if (res instanceof Promise) {
						res.catch(this.onFatalErrorBound);
					}
					return res;
				} catch (err) {
					throw this.onFatalError(err);
				}
			}));
		}

		async handleDisconnectedDiagnostics(diagnostics) {
			this.connectedReporters.error(
				___R$project$rome$$internal$markup$escape_ts$markup`Generated diagnostics without a current request`,
			);

			await ___R$project$rome$$internal$cli$diagnostics$index_ts$printDiagnostics({
				diagnostics,
				suppressions: [],
				printerOptions: {
					processor: this.createDiagnosticsProcessor(),
					reporter: this.connectedReporters,
					fileReaders: this.createDiagnosticsPrinterFileReaders(),
				},
			});
		}

		createDiagnosticsPrinterFileReaders() {
			return {
				read: async (path) => {
					const virtualContents = this.virtualModules.getPossibleVirtualFileContents(
						path,
					);
					if (virtualContents === undefined) {
						return undefined;
					} else {
						return virtualContents;
					}
				},

				getMtime: async (path) => {
					const virtualContents = this.virtualModules.getPossibleVirtualFileContents(
						path,
					);
					if (virtualContents === undefined) {
						return undefined;
					} else {
						return this.memoryFs.getMtime(path);
					}
				},
			};
		}

		createDiagnosticsProcessor(opts = {}) {
			return new ___R$project$rome$$internal$diagnostics$DiagnosticsProcessor_ts$default(
				Object.assign({markupOptions: this.logger.markupOptions}, opts),
			);
		}

		createDisconnectedDiagnosticsProcessor(origins) {
			return this.createDiagnosticsProcessor({
				onDiagnostics: (diagnostics) => {
					this.wrapFatalPromise(this.handleDisconnectedDiagnostics(diagnostics));
				},
				origins: [
					...origins,
					{
						category: "server",
						message: "Created disconnected diagnostics collector",
					},
				],
			});
		}

		maybeSetupGlobalErrorHandlers() {
			if (!this.options.globalErrorHandlers) {
				return;
			}

			const teardown = ___R$project$rome$$internal$core$common$utils$setupGlobalErrorHandlers_ts$default((
				err,
			) => {
				this.onFatalError(err);
			});

			this.endEvent.subscribe(() => {
				teardown();
			});
		}

		async init() {
			this.maybeSetupGlobalErrorHandlers();
			await this.recoveryStore.init();
			await this.virtualModules.init();
			await this.projectManager.init();
			await this.memoryFs.init();
			await this.fileAllocator.init();
			await this.resolver.init();
			await this.cache.init();
			await this.workerManager.init();
		}

		async end() {
			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`[Server] Teardown triggered`,
			);

			// Unwatch all project directories
			// We do this before anything else as we don't want events firing while we're in a teardown state
			this.memoryFs.unwatchAll();

			// Cancel all queries in flight
			for (const client of this.connectedClients) {
				for (const req of client.requestsInFlight) {
					await req.cancel("server ended");
				}

				// Kill socket
				client.bridge.end();
			}

			// We should remove everything that has an external dependency like a socket or process
			await this.endEvent.callOptional();
			await this.workerManager.end();

			if (this.options.dedicated) {
				process.exit();
			}
		}

		onLSPServer(req, lsp) {
			this.connectedLSPServers.add(lsp);

			req.endEvent.subscribe(() => {
				this.connectedLSPServers.delete(lsp);
			});
		}

		async attachToBridge(bridge) {
			let profiler;

			// If we aren't a dedicated process then we should only expect a single connection
			// and when that ends. End the Server.
			if (!this.options.dedicated) {
				bridge.endEvent.subscribe(() => {
					this.end();
				});
			}

			bridge.profilingStart.subscribe(async (data) => {
				if (profiler !== undefined) {
					throw new Error("Expected no profiler to be running");
				}
				profiler = new ___R$project$rome$$internal$v8$Profiler_ts$default();
				await profiler.startProfiling(data.samplingInterval);
				this.profiling = data;
				for (const {bridge} of this.workerManager.getExternalWorkers()) {
					await bridge.profilingStart.call(data);
				}
			});

			bridge.profilingStop.subscribe(async () => {
				if (profiler === undefined) {
					throw new Error("Expected profiler to be running");
				}
				const serverProfile = await profiler.stopProfiling();
				profiler = undefined;
				this.profiling = undefined;
				return serverProfile;
			});

			bridge.profilingGetWorkers.subscribe(async () => {
				const ids = [];
				for (const {id} of this.workerManager.getExternalWorkers()) {
					ids.push(id);
				}
				return ids;
			});

			bridge.profilingStopWorker.subscribe(async (id) => {
				const worker = this.workerManager.getWorkerAssert(id);
				return await worker.bridge.profilingStop.call();
			});

			// When enableWorkerLogs is called we setup subscriptions to the worker logs
			// Logs are never transported from workers to the server unless there is a subscription
			let subscribedWorkers = false;
			bridge.enableWorkerLogs.subscribe(() => {
				// enableWorkerLogs could be called twice in the case of `--logs --rage`. We'll only want to setup the subscriptions once
				if (subscribedWorkers) {
					return;
				} else {
					subscribedWorkers = true;
				}

				function onLog(chunk) {
					bridge.log.call({origin: "worker", chunk});
				}

				// Add on existing workers if there are any
				for (const worker of this.workerManager.getWorkers()) {
					bridge.attachEndSubscriptionRemoval(
						worker.bridge.log.subscribe(onLog),
					);
				}

				// Listen for logs for any workers that start later
				this.workerManager.workerStartEvent.subscribe((worker) => {
					bridge.attachEndSubscriptionRemoval(worker.log.subscribe(onLog));
				});
			});

			await bridge.handshake();

			const client = await this.createClient(bridge);

			if (
				client.version !==
				___R$project$rome$$internal$core$common$constants_ts$VERSION
			) {
				// TODO this wont ever actually be printed?
				client.reporter.error(
					___R$project$rome$$internal$markup$escape_ts$markup`Client version ${client.version} does not match server version ${___R$project$rome$$internal$core$common$constants_ts$VERSION}. Goodbye lol.`,
				);
				client.bridge.end();
				return client;
			}

			bridge.query.subscribe(async (request) => {
				return await this.handleRequest(client, request);
			});

			bridge.cancelQuery.subscribe(async (token) => {
				for (const req of client.requestsInFlight) {
					if (req.query.cancelToken === token) {
						await req.cancel("user requested");
					}
				}
			});

			bridge.endServer.subscribe(async () => this.end());

			await this.clientStartEvent.callOptional(client);
			await bridge.serverReady.call();

			return client;
		}

		async createClient(bridge) {
			const {
				flags,
				streamState,
				outputFormat,
				outputSupport,
				version,
			} = await bridge.getClientInfo.call();

			// Initialize the reporter
			const reporter = new ___R$project$rome$$internal$cli$reporter$Reporter_ts$default({
				wrapperFactory: this.wrapFatal.bind(this),
				markupOptions: Object.assign(
					{},
					this.logger.markupOptions,
					{cwd: flags.cwd},
				),
			});

			const streamHandle = reporter.addStream(
				{
					format: outputFormat,
					features: outputSupport,
					write(chunk, error) {
						if (flags.silent && !error) {
							return;
						}

						bridge.write.send([chunk, error]);
					},
				},
				streamState,
			);

			bridge.updateFeatures.subscribe((features) => {
				streamHandle.stream.updateFeatures(features);
			});

			// Streams to teardown on client disconnect
			const streamHandles = [streamHandle];

			// Add reporter to connected set, important logs may be output to these
			streamHandles.push(
				this.connectedReporters.addAttachedStream(streamHandle.stream),
			);

			// Warn about disabled disk caching. Don't bother if it's only been set due to ROME_DEV. We don't care to see it in development.
			if (
				this.cache.disabled &&
				___R$project$rome$$internal$cli$environment$index_ts$getEnvVar(
					"ROME_DEV",
				).type !== "ENABLED"
			) {
				reporter.warn(
					___R$project$rome$$internal$markup$escape_ts$markup`Disk caching has been disabled due to the <emphasis>ROME_CACHE=0</emphasis> environment variable`,
				);
			}

			const client = {
				id: this.clientIdCounter++,
				bridge,
				reporter,
				flags,
				version,
				requestsInFlight: new Set(),
			};

			this.connectedClients.add(client);

			bridge.updatedListenersEvent.subscribe((listeners) => {
				if (listeners.has("log")) {
					if (!this.connectedClientsListeningForLogs.has(client)) {
						this.connectedClientsListeningForLogs.add(client);
						let buffer = this.logInitBuffer;
						buffer += ".".repeat(20);
						buffer += "\n";
						bridge.log.send({
							chunk: buffer,
							origin: "server",
						});
					}
				} else {
					this.connectedClientsListeningForLogs.delete(client);
				}
				this.logger.updateStream();
			});

			bridge.endEvent.subscribe(() => {
				this.connectedClients.delete(client);
				this.connectedClientsListeningForLogs.delete(client);
				for (const handle of streamHandles) {
					handle.remove();
				}
				this.logger.updateStream();

				// Cancel any requests still in flight
				for (const req of client.requestsInFlight) {
					req.cancel("bridge died");
				}

				// Teardown reporter
				client.reporter.teardown();
			});

			return client;
		}

		async handleRequestStart(req) {
			req.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Start ${___R$project$rome$$internal$pretty$format$index_ts$default(
					req.query,
				)}`,
			);

			// Hook used by the web server to track and collect server requests
			await this.requestStartEvent.callOptional(req);

			// Track the amount of running queries for terminateWhenIdle
			this.requestRunningCounter++;

			// Sometimes we'll want to terminate the process once all queries have finished
			if (req.query.terminateWhenIdle) {
				this.terminateWhenIdle = true;
			}
		}

		async handleRequestEnd(req) {
			this.requestRunningCounter--;
			req.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Request end`,
			);

			// If we're waiting to terminate ourselves when idle, then do so when there's no running requests
			if (this.terminateWhenIdle && this.requestRunningCounter === 0) {
				await this.end();
			}
		}

		async handleRequest(client, partialQuery) {
			const query = ___R$project$rome$$internal$core$server$Server_ts$partialServerQueryRequestToFull(
				partialQuery,
			);

			const {bridge} = client;

			// Create a promise for the client dying so we can race it later
			let bridgeEndEvent;
			const bridgeEndPromise = new Promise((resolve, reject) => {
				bridgeEndEvent = bridge.endEvent.subscribe((err) => {
					reject(err);
				});
			});
			if (bridgeEndEvent === undefined) {
				throw new Error("Expected bridgeEndEvent to have been initialized");
			}

			const req = new ___R$project$rome$$internal$core$server$ServerRequest_ts$default({
				client,
				query,
				server: this,
			});

			await req.init();

			try {
				let res = await this.dispatchRequest(req, bridgeEndPromise, []);

				res = await req.teardown(res);

				if (res === undefined) {
					throw new Error(
						"teardown should have returned a normalized ServerQueryResponse",
					);
				}

				return res;
			} catch (err) {
				await this.onFatalErrorBound(err);
				throw new Error("Should never meet this condition");
			} finally {
				// We no longer care if the client dies
				await bridgeEndEvent.unsubscribe();
			}
		}

		async dispatchBenchmarkRequest(req, bridgeEndPromise) {
			const {client} = req;
			const {reporter} = client;
			const {benchmarkIterations} = req.query.requestFlags;

			// Warmup
			const warmupStart = Date.now();
			const result = await this.dispatchRequest(
				req,
				bridgeEndPromise,
				["benchmark"],
			);
			const warmupTook = Date.now() - warmupStart;

			// Benchmark
			const progress = req.reporter.progress({
				title: ___R$project$rome$$internal$markup$escape_ts$markup`Running benchmark`,
			});
			progress.setTotal(benchmarkIterations);
			const benchmarkStart = Date.now();
			for (let i = 0; i < benchmarkIterations; i++) {
				await this.dispatchRequest(req, bridgeEndPromise, ["benchmark"]);
				progress.tick();
			}
			progress.end();
			const benchmarkTook = Date.now() - benchmarkStart;

			await reporter.section(
				___R$project$rome$$internal$markup$escape_ts$markup`Benchmark results`,
				() => {
					reporter.info(
						___R$project$rome$$internal$markup$escape_ts$markup`Request artifacts may have been cached after the first run, artificially decreasing subsequent run time`,
					);
					reporter.heading(
						___R$project$rome$$internal$markup$escape_ts$markup`Query`,
					);
					reporter.inspect(req.query);
					reporter.heading(
						___R$project$rome$$internal$markup$escape_ts$markup`Stats`,
					);
					reporter.list([
						___R$project$rome$$internal$markup$escape_ts$markup`Warmup took <duration emphasis>${String(
							warmupTook,
						)}</duration>`,
						___R$project$rome$$internal$markup$escape_ts$markup`<number emphasis>${String(
							benchmarkIterations,
						)}</number> runs`,
						___R$project$rome$$internal$markup$escape_ts$markup`<duration emphasis>${String(
							benchmarkTook,
						)}</duration> total`,
						___R$project$rome$$internal$markup$escape_ts$markup`<duration emphasis approx>${String(
							benchmarkTook / benchmarkIterations,
						)}</duration> per run`,
					]);
				},
			);

			return result;
		}

		async dispatchRequest(req, bridgeEndPromise, origins) {
			const {query} = req;
			const {requestFlags} = query;

			if (requestFlags.benchmark && !origins.includes("benchmark")) {
				return this.dispatchBenchmarkRequest(req, bridgeEndPromise);
			}

			try {
				const defaultCommandFlags = {};

				// A type-safe wrapper for retrieving command flags
				// TODO perhaps present this as JSON or something if this isn't a request from the CLI?
				const flagsConsumer = ___R$project$rome$$internal$consume$index_ts$consume({
					filePath: ___R$project$rome$$internal$path$index_ts$createUnknownPath(
						"argv",
					),
					parent: undefined,
					value: query.commandFlags,
					onDefinition(def) {
						// objectPath should only have a depth of 1
						defaultCommandFlags[def.objectPath[0]] = def.default;
					},
					objectPath: [],
					context: {
						category: "flags/invalid",
						getOriginalValue: () => {
							return undefined;
						},
						normalizeKey: (key) => {
							return ___R$project$rome$$internal$string$utils$toKebabCase_ts$toKebabCase(
								key,
							);
						},
						getDiagnosticLocation: (keys) => {
							return req.getDiagnosticLocationFromFlags({
								type: "flag",
								key: String(keys[0]),
								target: "value",
							});
						},
					},
				});

				// An array of promises that we'll race, the only promise that will ever resolve will be the command one
				let promises = [bridgeEndPromise];

				// Get command
				const serverCommand = ___R$project$rome$$internal$core$server$commands_ts$serverCommands.get(
					query.commandName,
				);
				if (serverCommand) {
					await ___R$$priv$project$rome$$internal$core$server$Server_ts$validateRequestFlags(
						req,
						serverCommand,
					);

					let commandFlags;
					if (serverCommand.defineFlags !== undefined) {
						commandFlags = serverCommand.defineFlags(flagsConsumer);
					}

					req.setNormalizedCommandFlags({
						flags: commandFlags,
						defaultFlags: defaultCommandFlags,
					});

					// @ts-ignore
					const commandPromise = serverCommand.callback(req, commandFlags);
					promises.push(commandPromise);

					await Promise.race(promises);

					// Only the command promise should have won the race with a resolve
					const data = await commandPromise;
					return Object.assign(
						{},
						___R$project$rome$$internal$core$server$ServerRequest_ts$EMPTY_SUCCESS_RESPONSE,
						{hasData: data !== undefined, data},
					);
				} else {
					throw new Error("Unknown command " + String(query.commandName));
				}
			} catch (err) {
				return await req.buildResponseFromError(err);
			}
		}
	}


  // project-rome/@internal/codec-tar/index.ts
const ___R$$priv$project$rome$$internal$codec$tar$index_ts$stream = require(
		"stream",
	);
	const ___R$$priv$project$rome$$internal$codec$tar$index_ts$END_OF_TAR = Buffer.alloc(
		1_024,
	);
	const ___R$$priv$project$rome$$internal$codec$tar$index_ts$ZEROS = "0000000000000000000";
	const ___R$$priv$project$rome$$internal$codec$tar$index_ts$SEVENS = "7777777777777777777";
	const ___R$$priv$project$rome$$internal$codec$tar$index_ts$ZERO_OFFSET = "0".charCodeAt(
		0,
	);
	const ___R$$priv$project$rome$$internal$codec$tar$index_ts$USTAR = "ustar\x0000";
	const ___R$$priv$project$rome$$internal$codec$tar$index_ts$MASK = 4_095;
	const ___R$$priv$project$rome$$internal$codec$tar$index_ts$DMODE = 493;
	const ___R$$priv$project$rome$$internal$codec$tar$index_ts$FMODE = 420;

	function ___R$$priv$project$rome$$internal$codec$tar$index_ts$encodeOct(
		num,
		n,
	) {
		const oct = num.toString(8);
		if (oct.length > n) {
			return (
				___R$$priv$project$rome$$internal$codec$tar$index_ts$SEVENS.slice(0, n) +
				" "
			);
		} else {
			return (
				"" +
				___R$$priv$project$rome$$internal$codec$tar$index_ts$ZEROS.slice(
					0,
					n - oct.length,
				) +
				oct +
				" "
			);
		}
	}

	function ___R$$priv$project$rome$$internal$codec$tar$index_ts$checksum(block) {
		let sum = 8 * 32;
		for (let i = 0; i < 148; i++) {
			sum += block[i];
		}
		for (let j = 156; j < 512; j++) {
			sum += block[j];
		}
		return sum;
	}

	function ___R$$priv$project$rome$$internal$codec$tar$index_ts$toTypeflag(type) {
		switch (type) {
			case "file":
				return 0;
			case "link":
				return 1;
			case "symlink":
				return 2;
			case "character-device":
				return 3;
			case "block-device":
				return 4;
			case "directory":
				return 5;
			case "fifo":
				return 6;
			case "contiguous-file":
				return 7;
		}

		return 0;
	}

	function ___R$$priv$project$rome$$internal$codec$tar$index_ts$encodeHeader(
		header,
	) {
		const buf = Buffer.alloc(512);

		let name = header.name;
		let prefix = "";

		if (Buffer.byteLength(name) !== name.length) {
			throw new Error(
				"utf-8 filename is only supported in PAX, we only support USTAR",
			);
		}

		// If a filename is over 100 characters then split it up if possible (requires a directory)
		while (Buffer.byteLength(name) > 100) {
			const i = name.indexOf("/");
			if (i === -1) {
				throw new Error(
					"filename is too long for USTAR and it was in no directory",
				);
			}

			prefix += prefix ? "/" + name.slice(0, i) : name.slice(0, i);
			name = name.slice(i + 1);
		}

		if (Buffer.byteLength(name) > 100) {
			throw new Error("filename is too long for USTAR");
		}

		if (Buffer.byteLength(prefix) > 155) {
			throw new Error("prefix is too long for USTAR");
		}

		if (
			header.linkname !== undefined &&
			Buffer.byteLength(header.linkname) > 100
		) {
			throw new Error("linkname is too long for USTAR");
		}

		buf.write(name);
		buf.write(
			___R$$priv$project$rome$$internal$codec$tar$index_ts$encodeOct(
				header.mode & ___R$$priv$project$rome$$internal$codec$tar$index_ts$MASK,
				6,
			),
			100,
		);
		buf.write(
			___R$$priv$project$rome$$internal$codec$tar$index_ts$encodeOct(
				header.uid,
				6,
			),
			108,
		);
		buf.write(
			___R$$priv$project$rome$$internal$codec$tar$index_ts$encodeOct(
				header.gid,
				6,
			),
			116,
		);
		buf.write(
			___R$$priv$project$rome$$internal$codec$tar$index_ts$encodeOct(
				header.size,
				11,
			),
			124,
		);
		buf.write(
			___R$$priv$project$rome$$internal$codec$tar$index_ts$encodeOct(
				header.mtime.getTime() / 1_000 | 0,
				11,
			),
			136,
		);

		buf[156] =
			___R$$priv$project$rome$$internal$codec$tar$index_ts$ZERO_OFFSET +
			___R$$priv$project$rome$$internal$codec$tar$index_ts$toTypeflag(
				header.type,
			);

		if (header.linkname !== undefined) {
			buf.write(header.linkname, 157);
		}

		buf.write(___R$$priv$project$rome$$internal$codec$tar$index_ts$USTAR, 257);
		if (header.uname !== undefined) {
			buf.write(header.uname, 265);
		}
		if (header.gname !== undefined) {
			buf.write(header.gname, 297);
		}
		buf.write(
			___R$$priv$project$rome$$internal$codec$tar$index_ts$encodeOct(
				header.devmajor || 0,
				6,
			),
			329,
		);
		buf.write(
			___R$$priv$project$rome$$internal$codec$tar$index_ts$encodeOct(
				header.devminor || 0,
				6,
			),
			337,
		);

		if (prefix !== "") {
			buf.write(prefix, 345);
		}

		buf.write(
			___R$$priv$project$rome$$internal$codec$tar$index_ts$encodeOct(
				___R$$priv$project$rome$$internal$codec$tar$index_ts$checksum(buf),
				6,
			),
			148,
		);

		return buf;
	}

	class ___R$project$rome$$internal$codec$tar$index_ts$TarWriter {
		constructor(stream) {
			this.finalized = false;
			this.stream = stream;
		}

		static normalizeHeader(partial, size) {
			let mode = partial.mode;
			if (mode === undefined) {
				if (partial.type === "directory") {
					mode = ___R$$priv$project$rome$$internal$codec$tar$index_ts$DMODE;
				} else {
					mode = ___R$$priv$project$rome$$internal$codec$tar$index_ts$FMODE;
				}
			}

			return {
				name: partial.name,
				size,
				mode,
				mtime: partial.mtime == null ? new Date() : partial.mtime,
				type: partial.type == null ? "file" : partial.type,
				linkname: partial.linkname,
				uid: partial.uid == null ? 0 : partial.uid,
				gid: partial.gid == null ? 0 : partial.gid,
				uname: partial.uname,
				gname: partial.gname,
				devmajor: partial.devmajor == null ? 0 : partial.devmajor,
				devminor: partial.devminor == null ? 0 : partial.devminor,
			};
		}

		overflow(size) {
			size &= 511;
			if (size > 0) {
				this.stream.write(
					___R$$priv$project$rome$$internal$codec$tar$index_ts$END_OF_TAR.slice(
						0,
						512 - size,
					),
				);
			}
		}

		append(rawHeader, rawBuffer) {
			if (this.finalized) {
				throw new Error("Already finalized file");
			}

			const buffer =
				rawBuffer instanceof Buffer ? rawBuffer : Buffer.from(rawBuffer);
			const header = ___R$project$rome$$internal$codec$tar$index_ts$TarWriter.normalizeHeader(
				rawHeader,
				buffer.length,
			);

			this.stream.write(
				___R$$priv$project$rome$$internal$codec$tar$index_ts$encodeHeader(
					header,
				),
			);
			this.stream.write(buffer);
			this.overflow(header.size);
		}

		finalize() {
			this.finalized = true;

			return new Promise((resolve, reject) => {
				const {stream} = this;

				stream.on(
					"close",
					() => {
						resolve();
					},
				);

				stream.on(
					"error",
					(err) => {
						reject(err);
					},
				);

				stream.write(
					___R$$priv$project$rome$$internal$codec$tar$index_ts$END_OF_TAR,
				);
				stream.end();
			});
		}
	}


  // project-rome/@internal/core/client/Client.ts
const ___R$$priv$project$rome$$internal$core$client$Client_ts$stream = require(
		"stream",
	);
	const ___R$$priv$project$rome$$internal$core$client$Client_ts$net = require(
		"net",
	);
	const ___R$$priv$project$rome$$internal$core$client$Client_ts$zlib = require(
		"zlib",
	);
	const ___R$$priv$project$rome$$internal$core$client$Client_ts$os = require(
		"os",
	);
	const ___R$$priv$project$rome$$internal$core$client$Client_ts$child = require(
		"child_process",
	);
	function ___R$project$rome$$internal$core$client$Client_ts$getFilenameTimestamp() {
		return new Date().toISOString().replace(/[^0-9a-zA-Z]/g, "");
	}

	const ___R$$priv$project$rome$$internal$core$client$Client_ts$NEW_SERVER_INIT_TIMEOUT = 10_000;

	class ___R$project$rome$$internal$core$client$Client_ts$default {
		constructor(opts) {
			this.options = opts;
			this.userConfig = opts.userConfig;
			this.queryCounter = 0;
			this.flags = ___R$project$rome$$internal$typescript$helpers$index_ts$mergeObjects(
				___R$project$rome$$internal$core$common$types$client_ts$DEFAULT_CLIENT_FLAGS,
				opts.flags,
			);

			this.requestResponseEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "Client.requestResponseEvent",
			});
			this.endEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "Client.endEvent",
				serial: true,
			});
			this.bridgeStatus = undefined;

			this.bridgeAttachedEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "Client.bridgeAttached",
			});

			this.reporter = new ___R$project$rome$$internal$cli$reporter$Reporter_ts$default({
				stdin: opts.stdin,
				markupOptions: {
					userConfig: this.userConfig,
					cwd: this.flags.cwd,
				},
			});
			this.reporter.redirectOutToErr(true);

			this.derivedReporterStreams = this.reporter.attachStdoutStreams(
				// Suppress stdout when silent is set
				this.flags.silent ? undefined : opts.stdout,
				opts.stderr,
				this.options.terminalFeatures,
			);
		}

		assertBridgeStatus() {
			const {bridgeStatus} = this;
			if (bridgeStatus === undefined) {
				throw new Error("Expected a connected bridge but found none");
			}
			return bridgeStatus;
		}

		async onBridge(callback) {
			if (this.bridgeStatus === undefined) {
				const helper = ___R$project$rome$$internal$events$utils_ts$createSubscriptionHelper();

				helper.add(
					this.bridgeAttachedEvent.subscribe(async (bridgeStatus) => {
						const subscription = await callback(bridgeStatus);
						if (subscription !== undefined) {
							helper.add(subscription);
						}
					}),
				);

				return helper;
			} else {
				const subscription = await callback(this.bridgeStatus);
				return subscription == null
					? ___R$project$rome$$internal$events$utils_ts$createEmptySubscription()
					: subscription;
			}
		}

		getBridgeStatus() {
			return this.bridgeStatus;
		}

		setFlags(flags) {
			if (this.bridgeStatus !== undefined) {
				throw new Error(
					"Already connected to bridge. Cannot change client flags.",
				);
			}

			this.flags = Object.assign({}, this.flags, flags);
		}

		async profile(opts, callback) {
			this.reporter.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Starting CPU profile...`,
			);
			return this._profile(opts, callback);
		}

		async _profile(opts, callback) {
			const {samplingInterval, timeoutInterval, includeWorkers} = opts;

			// Start server and start profiling
			const bridge = await this.findOrStartServer();
			await bridge.profilingStart.call({
				samplingInterval,
			});

			// Start cli profiling
			let cliProfiler;
			const bridgeStatus = this.getBridgeStatus();
			if (bridgeStatus === undefined || bridgeStatus.dedicated) {
				cliProfiler = new ___R$project$rome$$internal$v8$Profiler_ts$default();
				await cliProfiler.startProfiling(samplingInterval);
			}

			// Start a profile timer if one was specified
			let hasProfiled;
			let timeout;
			if (timeoutInterval !== undefined) {
				timeout = setTimeout(
					() => {
						hasProfiled = stopProfile(true);
					},
					timeoutInterval,
				);
			}

			const stopProfile = async (isTimeout) => {
				// This is to prevent stopping the profile multiple times via the timeout and then at the end
				// It's a promise so that the final stopProfile call will block until the first has finished
				if (hasProfiled) {
					return hasProfiled;
				}

				// Stop the timeout if it hasn't been triggered
				if (timeout !== undefined) {
					clearTimeout(timeout);
				}

				//
				const trace = new ___R$project$rome$$internal$v8$Trace_ts$default();
				const fetchers = [];

				// CLI
				if (cliProfiler !== undefined) {
					const cliProfilerAssert = cliProfiler;
					fetchers.push([
						"CLI",
						async () => {
							return cliProfilerAssert.stopProfiling();
						},
					]);
				}

				// Server
				fetchers.push([
					cliProfiler === undefined ? "Server/CLI" : "Server",
					async () => {
						return await bridge.profilingStop.call(
							undefined,
							{
								priority: true,
							},
						);
					},
				]);

				// Workers
				if (includeWorkers) {
					const workerIds = await bridge.profilingGetWorkers.call();
					for (const id of workerIds) {
						fetchers.push([
							"Worker " + id,
							async () => {
								return await bridge.profilingStopWorker.call(
									id,
									{
										priority: true,
									},
								);
							},
						]);
					}
				}

				// Fetch profiles
				const progress = this.reporter.progress({
					title: ___R$project$rome$$internal$markup$escape_ts$markup`Fetching profiles`,
				});
				progress.setTotal(fetchers.length);
				for (const [text, callback] of fetchers) {
					progress.setText(
						___R$project$rome$$internal$markup$escape_ts$markup`${text}`,
					);
					const profile = await callback();
					trace.addProfile(text, profile);
					progress.tick();
				}
				progress.end();

				const events = trace.build();
				await callback(events);

				// If we're a timeout than separate these logs from the
				if (isTimeout) {
					this.reporter.hr();
				}
			};

			this.endEvent.subscribe(() => {
				return stopProfile(false);
			});
		}

		subscribeLogs(includeWorkerLogs, callback) {
			return this.onBridge(async ({bridge}) => {
				if (includeWorkerLogs) {
					await bridge.enableWorkerLogs.call();
				}

				return bridge.log.subscribe(({origin, chunk}) => {
					if (origin === "worker" && !includeWorkerLogs) {
						// We allow multiple calls to bridge.enableWorkerLogs
						// Filter the event if necessary if it wasn't requested by this log subscription
						return;
					}

					callback(chunk);
				});
			});
		}

		async generateRageSummary() {
			let summary = [];

			function push(name, value) {
				const formatted =
					typeof value === "string"
						? ___R$project$rome$$internal$markup$escape_ts$markup`${value}`
						: ___R$project$rome$$internal$pretty$format$index_ts$default(
								value,
								{
									compact: true,
								},
							);
				summary.push(
					___R$project$rome$$internal$markup$escape_ts$markup`<emphasis>${name}</emphasis>\n<indent>${formatted}</indent>\n\n`,
				);
			}

			const envVars = [
				"ROME_CACHE",
				"LANG",
				"COLORFGBG",

				// Variables used by process.stdout.getColorDepth
				"FORCE_COLOR",
				"NODE_DISABLE_COLORS",
				"NO_COLOR",
				"TERM",
				"TMUX",
				"CI",
				"TRAVIS",
				"CIRCLECI",
				"APPVEYOR",
				"GITLAB_CI",
				"CI_NAME",
				"TEAMCITY_VERSION",
				"TERM_PROGRAM",
				"COLORTERM",
			];
			const env = {};
			for (const key of envVars) {
				env[key] = process.env[key];
			}
			push("Environment Variables", env);

			const userConfig = await ___R$project$rome$$internal$core$common$userConfig_ts$getUserConfigFile();
			push(
				"User Config",
				userConfig === undefined ? "unset" : userConfig.consumer.asUnknown(),
			);

			push(
				"Rome Version",
				___R$project$rome$$internal$core$common$constants_ts$VERSION,
			);
			push("Node Version", process.versions.node);
			push(
				"Platform",
				process.platform +
				" " +
				process.arch +
				" " +
				___R$$priv$project$rome$$internal$core$client$Client_ts$os.release(),
			);
			push("Terminal Features", this.derivedReporterStreams.features);
			push("Client Flags", this.flags);

			// Don't do this if we never connected to the server
			const bridgeStatus = this.getBridgeStatus();
			if (bridgeStatus !== undefined) {
				const status = await this.query(
					{
						silent: true,
						commandName: "status",
					},
					"server",
				);
				if (status.type === "SUCCESS") {
					push("Server Status", status.data);
				}
			}

			return ___R$project$rome$$internal$markup$escape_ts$concatMarkup(summary);
		}

		async rage(ragePath, profileOpts) {
			const {bridge} = this.assertBridgeStatus();

			this.reporter.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Rage enabled \u{1f620}`,
			);

			let logsHTML = "";
			let logsPlain = "";
			await this.subscribeLogs(
				true,
				(chunk) => {
					logsPlain += ___R$project$rome$$internal$markup$normalize_ts$joinMarkupLines(
						___R$project$rome$$internal$cli$layout$format_ts$markupToPlainText(
							___R$project$rome$$internal$markup$escape_ts$convertToMarkupFromRandomString(
								chunk,
							),
						),
					);
					logsHTML += ___R$project$rome$$internal$markup$normalize_ts$joinMarkupLines(
						___R$project$rome$$internal$cli$layout$format_ts$markupToHtml(
							___R$project$rome$$internal$markup$escape_ts$convertToMarkupFromRandomString(
								chunk,
							),
						),
					);
				},
			);

			// Collect CPU profile
			// Callback will be called later once it has been collected
			// Initial async work is just connecting to the processes and setting up handlers
			let profileEvents = [];
			await this._profile(
				profileOpts,
				async (_profileEvents) => {
					profileEvents = _profileEvents;
				},
			);

			// Collect all responses
			const responses = [];
			this.requestResponseEvent.subscribe((result) => {
				responses.push(result);
			});

			// Capture terminal output
			let output = "";
			const writeEvent = bridge.write.subscribe(([chunk]) => {
				output += chunk;
			});

			this.endEvent.subscribe(async () => {
				const stream = ___R$$priv$project$rome$$internal$core$client$Client_ts$zlib.createGzip();
				stream.pipe(
					___R$project$rome$$internal$fs$index_ts$createWriteStream(ragePath),
				);

				const writer = new ___R$project$rome$$internal$codec$tar$index_ts$TarWriter(
					stream,
				);

				writer.append(
					{name: "profile.json"},
					___R$project$rome$$internal$codec$json$index_ts$stringifyJSON(
						profileEvents,
					),
				);
				writer.append({name: "logs.txt"}, logsPlain);
				writer.append(
					{name: "logs.html"},
					"<pre><code>" + logsHTML + "</code></pre>",
				);
				writer.append({name: "output.txt"}, output);

				await writeEvent.unsubscribe();

				// Add requests
				for (let i = 0; i < responses.length; i++) {
					const {request, response} = responses[i];
					// If there are multiple responses then use a directory otherwise just dump it in the root
					const dirname =
						responses.length === 1
							? ""
							: "requests/" + i + "-" + request.commandName + "/";
					writer.append(
						{name: dirname + "request.json"},
						___R$project$rome$$internal$codec$json$index_ts$stringifyJSON(
							request,
						),
					);
					writer.append(
						{name: dirname + "response.json"},
						___R$project$rome$$internal$codec$json$index_ts$stringifyJSON(
							response,
						),
					);
				}

				writer.append(
					{name: "summary.txt"},
					___R$project$rome$$internal$cli$layout$format_ts$markupToJoinedPlainText(
						await this.generateRageSummary(),
					),
				);

				await writer.finalize();
				this.reporter.success(
					___R$project$rome$$internal$markup$escape_ts$markup`Rage archive written to <emphasis>${ragePath}</emphasis>`,
				);
			});
		}

		async query(query, type) {
			const request = new ___R$project$rome$$internal$core$client$ClientRequest_ts$default(
				this,
				type,
				query,
			);
			const res = await request.init();
			this.requestResponseEvent.send({request: query, response: res});
			return res;
		}

		cancellableQuery(query, type) {
			const cancelToken = String(this.queryCounter++);

			return {
				promise: this.query(Object.assign({}, query, {cancelToken}), type),
				cancel: async () => {
					const status = this.getBridgeStatus();
					if (status !== undefined) {
						await status.bridge.cancelQuery.call(cancelToken);
					}
				},
			};
		}

		async shutdownServer() {
			await this._shutdownServer();
			await this.end();
		}

		async _shutdownServer() {
			const status = this.bridgeStatus;
			if (status !== undefined && status.bridge.alive) {
				try {
					await status.bridge.endServer.call();
				} catch (err) {
					// Swallow BridgeErrors since we expect one to be emitted as the endServer call will be an unanswered request
					// when the server ends all client sockets
					if (
						!(err instanceof
						___R$project$rome$$internal$events$BridgeError_ts$default)
					) {
						throw err;
					}
				}
			}
		}

		async end() {
			await this.endEvent.callOptional();

			const status = this.bridgeStatus;

			if (status !== undefined && status.bridge.alive) {
				if (status.dedicated) {
					status.socket.end();
				} else {
					await this._shutdownServer();
				}
			}

			this.reporter.teardown();
			this.bridgeStatus = undefined;
		}

		async attachBridge(status) {
			const {handle, featuresUpdated, features, format} = this.derivedReporterStreams;
			const {terminalFeatures = {}} = this.options;

			if (this.bridgeStatus !== undefined) {
				throw new Error("Already attached bridge to API");
			}

			this.bridgeStatus = status;

			const {bridge} = status;

			bridge.write.subscribe(([chunk, error]) => {
				const isError = error && !terminalFeatures.redirectError;
				handle.stream.write(chunk, isError);
			});

			// Listen for resize column events if stdout is a TTY
			featuresUpdated.subscribe((features) => {
				bridge.updateFeatures.call(features);
			});

			await Promise.all([
				bridge.getClientInfo.wait({
					version: ___R$project$rome$$internal$core$common$constants_ts$VERSION,
					outputFormat: format,
					outputSupport: features,
					streamState: Object.assign(
						{},
						handle.stream.state,
						{lineSnapshots: undefined},
					),
					flags: this.flags,
				}),
				bridge.handshake(),
				bridge.serverReady.wait(),
			]);

			await this.bridgeAttachedEvent.callOptional(status);
		}

		async findOrStartServer() {
			// First check if we already have a bridge connection
			const connected = this.getBridgeStatus();
			if (connected !== undefined) {
				return connected.bridge;
			}

			// Then check if there's already a running daemon
			const runningDaemon = await this.tryConnectToExistingDaemon();
			if (runningDaemon) {
				return runningDaemon;
			}

			const status = await this.startInternalServer();
			return status.bridge;
		}

		async startInternalServer(opts) {
			// Otherwise, start a server inside this process
			const server = new ___R$project$rome$$internal$core$server$Server_ts$default(
				Object.assign(
					{
						userConfig: this.userConfig,
						dedicated: false,
						globalErrorHandlers: this.options.globalErrorHandlers === true,
					},
					opts,
				),
			);
			await server.init();

			const bridge = ___R$project$rome$$internal$events$bridgeCreators_ts$createBridgeFromLocal(
				___R$project$rome$$internal$core$common$bridges$ServerBridge_ts$default,
				{},
			);
			const status = {bridge, server, dedicated: false};

			const [serverClient] = await Promise.all([
				server.attachToBridge(bridge),
				this.attachBridge(status),
			]);

			this.endEvent.subscribe(async () => {
				await server.end();
			});

			return {serverClient, bridge, server};
		}

		async forceStartDaemon() {
			const daemon = await this.startDaemon();
			if (daemon === undefined) {
				this.reporter.error(
					___R$project$rome$$internal$markup$escape_ts$markup`Failed to start daemon`,
				);
				throw new Error("Failed to start daemon");
			} else {
				return daemon;
			}
		}

		async startDaemon() {
			const {reporter} = this;

			if (this.bridgeStatus !== undefined) {
				throw new Error("Already started server");
			}

			reporter.info(
				___R$project$rome$$internal$markup$escape_ts$markup`No running daemon found. Starting one...`,
			);

			let exited = false;
			let proc;

			const newDaemon = await new Promise((resolve, reject) => {
				const timeout = setTimeout(
					() => {
						reporter.error(
							___R$project$rome$$internal$markup$escape_ts$markup`Daemon connection timed out`,
						);
						cleanup();
						resolve();
					},
					___R$$priv$project$rome$$internal$core$client$Client_ts$NEW_SERVER_INIT_TIMEOUT,
				);

				const socketServer = ___R$$priv$project$rome$$internal$core$client$Client_ts$net.createServer(() => {
					cleanup();

					resolve(
						this.tryConnectToExistingDaemon().then((bridge) => {
							if (bridge !== undefined) {
								this.reporter.success(
									___R$project$rome$$internal$markup$escape_ts$markup`Started daemon!`,
								);
							}
							return bridge;
						}),
					);
				});

				socketServer.on("error", reject);

				function listen() {
					socketServer.listen(
						___R$project$rome$$internal$core$common$constants_ts$CLI_SOCKET_PATH.join(),
					);

					proc = ___R$project$rome$$internal$core$common$utils$fork_ts$forkProcess(
						"server",
						{
							detached: true,
						},
					);
					proc.unref();

					proc.on(
						"close",
						() => {
							exited = true;
							cleanup();
							resolve();
						},
					);
				}

				___R$project$rome$$internal$fs$index_ts$removeFile(
					___R$project$rome$$internal$core$common$constants_ts$CLI_SOCKET_PATH,
				).finally(() => {
					listen();
				});

				function cleanup() {
					clearTimeout(timeout);
					socketServer.close();
				}
			});
			if (newDaemon) {
				return newDaemon;
			}

			// as a final precaution kill the server
			if (exited) {
				reporter.error(
					___R$project$rome$$internal$markup$escape_ts$markup`Daemon died while initialising.`,
				);
			} else {
				reporter.error(
					___R$project$rome$$internal$markup$escape_ts$markup`Failed to connect. Killing daemon.`,
				);
			}

			if (proc !== undefined) {
				proc.kill();
			}

			return undefined;
		}

		async tryConnectToExistingDaemon() {
			if (this.bridgeStatus !== undefined) {
				return this.bridgeStatus.bridge;
			}

			const promise = new Promise((resolve, reject) => {
				const socket = ___R$$priv$project$rome$$internal$core$client$Client_ts$net.createConnection(
					{
						path: ___R$project$rome$$internal$core$common$constants_ts$SERVER_SOCKET_PATH.join(),
					},
					() => {
						resolve(socket);
					},
				);

				socket.on(
					"error",
					(err) => {
						if (
							err.code === "ENOENT" ||
							err.code === "ECONNREFUSED" ||
							err.code === "EADDRINUSE"
						) {
							resolve();
						} else {
							reject(err);
						}
					},
				);
			});

			const socket = await promise;
			if (socket === undefined) {
				return undefined;
			}

			const bridge = ___R$project$rome$$internal$events$bridgeCreators_ts$createBridgeFromSocket(
				___R$project$rome$$internal$core$common$bridges$ServerBridge_ts$default,
				socket,
				{
					type: "server",
				},
			);
			await this.attachBridge({socket, bridge, dedicated: true});
			this.reporter.success(
				___R$project$rome$$internal$markup$escape_ts$markup`Connected to daemon`,
			);
			return bridge;
		}
	}


  // project-rome/@internal/core/common/bridges/WorkerBridge.ts
class ___R$project$rome$$internal$core$common$bridges$WorkerBridge_ts$default
		extends ___R$project$rome$$internal$events$Bridge_ts$default {
		constructor(...args) {
			super(...args);
			this.log = this.createEvent({
				name: "log",
				direction: "server<-client",
			});
			this.fatalError = this.createEvent({
				name: "fatalError",
				direction: "server<-client",
			});
			this.updateProjects = this.createEvent({
				name: "updateProjects",
				direction: "server->client",
			});
			this.updateManifests = this.createEvent({
				name: "updateManifests",
				direction: "server->client",
			});
			this.profilingStart = this.createEvent({
				name: "profiling.start",
				direction: "server->client",
			});
			this.profilingStop = this.createEvent({
				name: "profiling.stop",
				direction: "server->client",
			});
			this.status = this.createEvent({
				name: "status",
				direction: "server->client",
			});
			this.evict = this.createEvent({
				name: "evict",
				direction: "server->client",
			});
			this.format = this.createEvent({
				name: "format",
				direction: "server->client",
			});
			this.moduleSignatureJS = this.createEvent({
				name: "moduleSignatureJS",
				direction: "server->client",
			});
			this.analyzeDependencies = this.createEvent({
				name: "analyzeDependencies",
				direction: "server->client",
			});
			this.lint = this.createEvent({name: "lint", direction: "server->client"});
			this.updateInlineSnapshots = this.createEvent({
				name: "updateInlineSnapshots",
				direction: "server->client",
			});
			this.compile = this.createEvent({
				name: "compile",
				direction: "server->client",
			});
			this.parse = this.createEvent({name: "parse", direction: "server->client"});
			this.getFileBuffers = this.createEvent({
				name: "getFileBuffers",
				direction: "server->client",
			});
			this.getBuffer = this.createEvent({
				name: "getBuffer",
				direction: "server->client",
			});
			this.updateBuffer = this.createEvent({
				name: "updateBuffer",
				direction: "server->client",
			});
			this.patchBuffer = this.createEvent({
				name: "patchBuffer",
				direction: "server->client",
			});
			this.clearBuffer = this.createEvent({
				name: "clearBuffer",
				direction: "server->client",
			});
		}
		init() {
			this.addErrorTransport(
				"FileNotFound",
				{
					serialize(err) {
						if (
							!(err instanceof
							___R$project$rome$$internal$fs$FileNotFound_ts$FileNotFound)
						) {
							throw new Error("Expected FileNotFound");
						}

						return {
							suffixMessage: err.suffixMessage,
							path: err._path.join(),
						};
					},
					hydrate(err, data) {
						return new ___R$project$rome$$internal$fs$FileNotFound_ts$FileNotFound(
							___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
								data.path,
							),
							data.suffixMessage,
						);
					},
				},
			);

			this.addErrorTransport(
				"DiagnosticsError",
				{
					serialize(err) {
						if (
							!(err instanceof
							___R$project$rome$$internal$diagnostics$errors_ts$DiagnosticsError)
						) {
							throw new Error("Expected DiagnosticsError");
						}

						return {
							diagnostics: err.diagnostics,
						};
					},
					hydrate(err, data) {
						return new ___R$project$rome$$internal$diagnostics$errors_ts$DiagnosticsError(
							err.message,
							data.diagnostics,
						);
					},
				},
			);
		}
	}


  // project-rome/@internal/core/common/bridges/ServerBridge.ts
class ___R$project$rome$$internal$core$common$bridges$ServerBridge_ts$default
		extends ___R$project$rome$$internal$events$Bridge_ts$default {
		constructor(...args) {
			super(...args);
			this.getClientInfo = this.createEvent({
				name: "getClientInfo",
				direction: "server->client",
			});
			this.serverReady = this.createEvent({
				name: "serverReady",
				direction: "server->client",
			});
			this.write = this.createEvent({
				name: "write",
				direction: "server->client",
			});
			this.enableWorkerLogs = this.createEvent({
				name: "enableWorkerLogs",
				direction: "server<-client",
			});
			this.log = this.createEvent({
				name: "log",
				direction: "server->client",
			});
			this.updateFeatures = this.createEvent({
				name: "updateFeatures",
				direction: "server<-client",
			});
			this.query = this.createEvent({
				name: "query",
				direction: "server<-client",
			});
			this.cancelQuery = this.createEvent({
				name: "cancel",
				direction: "server<-client",
			});
			this.profilingGetWorkers = this.createEvent({
				name: "profiling.getWorkers",
				direction: "server<-client",
			});
			this.profilingStart = this.createEvent({
				name: "profiling.start",
				direction: "server<-client",
			});
			this.profilingStop = this.createEvent({
				name: "profiling.stop",
				direction: "server<-client",
			});
			this.profilingStopWorker = this.createEvent({
				name: "profile.stopWorker",
				direction: "server<-client",
			});
			this.lspFromClientBuffer = this.createEvent({
				name: "lspFromClientBuffer",
				direction: "server<-client",
			});
			this.lspFromServerBuffer = this.createEvent({
				name: "lspFromServerBuffer",
				direction: "server->client",
			});
			this.endServer = this.createEvent({
				name: "endServer",
				direction: "server<-client",
			});
		}
	}


  // project-rome/@internal/core/common/bridges/WebBridge.ts
class ___R$project$rome$$internal$core$common$bridges$WebBridge_ts$default
		extends ___R$project$rome$$internal$events$Bridge_ts$default {
		constructor(...args) {
			super(...args);
			this.requests = this.createEvent({
				name: "WebBridge.requests",
				direction: "server->client",
			});
		}
	}


  // project-rome/@internal/core/common/bridges/TestWorkerBridge.ts
class ___R$project$rome$$internal$core$common$bridges$TestWorkerBridge_ts$default
		extends ___R$project$rome$$internal$events$Bridge_ts$default {
		constructor(...args) {
			super(...args);
			this.inspectorDetails = this.createEvent({
				name: "inspectorDetails",
				direction: "server->client",
			});
			this.receiveCompiled = this.createEvent({
				name: "receiveCompiled",
				direction: "server->client",
			});
			this.prepareTest = this.createEvent({
				name: "prepareTest",
				direction: "server->client",
			});
			this.runTest = this.createEvent({
				name: "runTest",
				direction: "server->client",
			});
			this.teardownTest = this.createEvent({
				name: "teardownTest",
				direction: "server->client",
			});
			this.testStart = this.createEvent({
				name: "onTestStart",
				direction: "server<-client",
			});
			this.testDiagnostic = this.createEvent({
				name: "testDiagnostic",
				direction: "server<-client",
			});
			this.testFinish = this.createEvent({
				name: "onTestSuccess",
				direction: "server<-client",
			});
		}
	}


  // project-rome/@internal/core/common/types/bundler.ts
const ___R$project$rome$$internal$core$common$types$bundler_ts = {};


  // project-rome/@internal/core/common/types/files.ts
const ___R$project$rome$$internal$core$common$types$files_ts = {};


  // project-rome/@internal/core/common/types/analyzeDependencies.ts
const ___R$project$rome$$internal$core$common$types$analyzeDependencies_ts = {
		get UNKNOWN_ANALYZE_DEPENDENCIES_RESULT() {
			return ___R$project$rome$$internal$core$common$types$analyzeDependencies_ts$UNKNOWN_ANALYZE_DEPENDENCIES_RESULT;
		},
	};
	const ___R$project$rome$$internal$core$common$types$analyzeDependencies_ts$UNKNOWN_ANALYZE_DEPENDENCIES_RESULT = {
		topLevelLocalBindings: {},
		moduleType: "unknown",
		diagnostics: [],
		firstTopAwaitLocation: undefined,
		importFirstUsage: [],
		exports: [],
		dependencies: [],
	};


  // project-rome/@internal/js-analysis/Graph.ts
class ___R$project$rome$$internal$js$analysis$Graph_ts$default {
		constructor() {
			this.nodes = [];
			this.nodesByValue = new Map();
		}

		addNode(value) {
			if (this.find(value)) {
				return;
			}

			const node = {lines: [], value};
			this.nodesByValue.set(value, node);
			this.nodes.push(node);
		}

		find(value) {
			return this.nodesByValue.get(value);
		}

		hasConnections(value) {
			const node = this.nodesByValue.get(value);
			return (
				node !== undefined && (node == null ? undefined : node.lines).length > 0
			);
		}

		addLine(startValue, endValue) {
			const startNode = this.find(startValue);
			const endNode = this.find(endValue);

			if (!startNode || !endNode) {
				throw new Error("Both nodes need to exist");
			}

			startNode.lines.push(endNode);
		}
	}


  // project-rome/@internal/js-analysis/types/T.ts
let ___R$$priv$project$rome$$internal$js$analysis$types$T_ts$counter = 0;

	class ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		constructor(scope, originNode) {
			this.human = undefined;
			this.scope = scope;

			const {hub} = scope;
			this.hub = hub;
			this.utils = hub.utils;
			this.evaluator = hub.evaluator;
			this.originEvaluator = scope.evaluator.evaluatingType;

			// setup graph
			this.graph = scope.evaluator.graph;
			this.graph.addNode(this);

			this.originNode = originNode;
			this.originLoc = originNode === undefined ? undefined : originNode.loc;
			this.id =
				String(process.pid) +
				":" +
				String(
					___R$$priv$project$rome$$internal$js$analysis$types$T_ts$counter++,
				);

			this.compatibilityCache = new Map();
		}

		getConstructor() {
			// @ts-ignore
			return this.constructor;
		}

		setHuman(human) {
			this.human = human;
		}

		shouldMatch(type) {
			this.hub.assertOpen();
			this.graph.addLine(this, type);
		}

		hasConnections() {
			return this.graph.hasConnections(this);
		}

		explodeUnion() {
			return [this];
		}

		compatibleWith(otherType) {
			return otherType instanceof this.constructor;
		}

		clone() {
			const idsToType = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
				"idsToType",
			);

			const addType = (type) => {
				const reduced = this.utils.reduce(type);
				idsToType.set(type.id, type);
				return reduced.id;
			};

			const data = this.serialize(addType);

			const getType = (id) => {
				if (typeof id !== "string") {
					throw new Error("Expected id to be a string");
				}

				return idsToType.assert(id);
			};

			return this.getConstructor().hydrate(
				this.scope,
				this.originNode,
				data,
				getType,
			);
		}

		static hydrate(scope, originNode, data, getType) {
			throw new Error("Unimplemented " + this.type + ".hydrate");
		}

		serialize(addType) {
			throw new Error(
				"Unimplemented " + this.getConstructor().type + ".prototype.serialize",
			);
		}

		reduce() {
			return this;
		}

		humanize(builder) {
			const reduced = this.utils.reduce(this);
			if (reduced === this) {
				throw new Error("unimplemented");
			} else {
				return builder.humanize(reduced);
			}
		}

		inspect() {
			return this.utils.inspect(this);
		}
	}
	___R$project$rome$$internal$js$analysis$types$T_ts$default.type = "T";


  // project-rome/@internal/js-analysis/types/UnknownT.ts
class ___R$project$rome$$internal$js$analysis$types$UnknownT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		serialize() {
			return {};
		}

		static hydrate(scope, originNode) {
			return new ___R$project$rome$$internal$js$analysis$types$UnknownT_ts$default(
				scope,
				originNode,
			);
		}

		humanize() {
			return ___R$project$rome$$internal$markup$escape_ts$markup`unknown`;
		}

		compatibleWith() {
			return false;
		}
	}
	___R$project$rome$$internal$js$analysis$types$UnknownT_ts$default.type = "UnknownT";


  // project-rome/@internal/js-analysis/types/OpenT.ts
class ___R$project$rome$$internal$js$analysis$types$OpenT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		humanize(builder) {
			const type = this.utils.reduce(this);
			if (type === this) {
				return ___R$project$rome$$internal$markup$escape_ts$markup`open`;
			} else {
				return builder.humanize(type);
			}
		}

		reduce() {
			const node = this.graph.find(this);
			if (node === undefined) {
				return new ___R$project$rome$$internal$js$analysis$types$UnknownT_ts$default(
					this.scope,
					this.originNode,
				);
			}

			const values = node.lines.map((line) => this.utils.reduce(line.value));
			return this.scope.createUnion(values, this.originNode);
		}
	}
	___R$project$rome$$internal$js$analysis$types$OpenT_ts$default.type = "OpenT";


  // project-rome/@internal/js-analysis/types/OpenIntrinsicT.ts
class ___R$project$rome$$internal$js$analysis$types$OpenIntrinsicT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$OpenT_ts$default {
		constructor(scope, originNode, name) {
			super(scope, originNode);
			this.name = name;
		}

		serialize() {
			return {
				name: this.name,
			};
		}

		static hydrate(scope, originNode, data) {
			return scope.intrinsics.get(String(data.name));
		}

		humanize() {
			return ___R$project$rome$$internal$markup$escape_ts$markup`open intrinsic`;
		}
	}
	___R$project$rome$$internal$js$analysis$types$OpenIntrinsicT_ts$default.type = "OpenIntrinsicT";


  // project-rome/@internal/js-analysis/Intrinsics.ts
class ___R$project$rome$$internal$js$analysis$Intrinsics_ts$default {
		constructor(scope) {
			this.scope = scope;

			this.intrinsicByName = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
				"intrinsicByName",
			);

			this.NumberPrototype = this.createOpenT("NumberPrototype");
			this.Number = this.createOpenT("Number");

			this.StringPrototype = this.createOpenT("StringPrototype");
			this.String = this.createOpenT("String");

			this.ObjectPrototype = this.createOpenT("ObjectPrototype");
			this.Object = this.createOpenT("Object");

			this.ArrayPrototype = this.createOpenT("ArrayPrototype");
			this.Array = this.createOpenT("Array");

			this.RegExpPrototype = this.createOpenT("RegExpPrototype");
			this.RegExp = this.createOpenT("RegExp");
		}

		get(name) {
			return this.intrinsicByName.assert(name);
		}

		createOpenT(name) {
			const t = new ___R$project$rome$$internal$js$analysis$types$OpenIntrinsicT_ts$default(
				this.scope,
				undefined,
				name,
			);
			this.intrinsicByName.set(name, t);
			return t;
		}

		link() {
			this.String.shouldMatch(this.scope.query(["String"]));
			this.StringPrototype.shouldMatch(
				this.scope.query(["String", "prototype"]),
			);

			this.Object.shouldMatch(this.scope.query(["Object"]));
			this.ObjectPrototype.shouldMatch(
				this.scope.query(["Object", "prototype"]),
			);

			this.Array.shouldMatch(this.scope.query(["Array"]));
			this.ArrayPrototype.shouldMatch(this.scope.query(["Array", "prototype"]));

			this.RegExp.shouldMatch(this.scope.query(["RegExp"]));
			this.RegExpPrototype.shouldMatch(
				this.scope.query(["RegExp", "prototype"]),
			);

			this.Number.shouldMatch(this.scope.query(["Number"]));
			this.NumberPrototype.shouldMatch(
				this.scope.query(["Number", "prototype"]),
			);
		}
	}


  // project-rome/@internal/js-analysis/types/ObjPropT.ts
class ___R$project$rome$$internal$js$analysis$types$ObjPropT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		constructor(scope, originNode, key, value) {
			super(scope, originNode);
			this.key = key;
			this.value = value;
		}

		serialize(addType) {
			return {
				key: this.key,
				value: addType(this.value),
			};
		}

		static hydrate(scope, originNode, data, getType) {
			return new ___R$project$rome$$internal$js$analysis$types$ObjPropT_ts$default(
				scope,
				originNode,
				String(data.key),
				getType(data.value),
			);
		}

		compatibleWith(otherType) {
			if (
				otherType instanceof
				___R$project$rome$$internal$js$analysis$types$ObjPropT_ts$default &&
				otherType.key === this.key
			) {
				return this.utils.checkCompability(this.value, otherType.value);
			} else {
				return false;
			}
		}

		humanize(builder) {
			return ___R$project$rome$$internal$markup$escape_ts$markup`${this.key}: ${builder.humanize(
				this.value,
			)}`;
		}
	}
	___R$project$rome$$internal$js$analysis$types$ObjPropT_ts$default.type = "ObjPropT";


  // project-rome/@internal/js-analysis/types/ObjT.ts
class ___R$project$rome$$internal$js$analysis$types$ObjT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		constructor(scope, originNode, opts) {
			super(scope, originNode);
			this.calls = opts.calls == null ? [] : opts.calls;
			this.props = opts.props == null ? [] : opts.props;
			this.proto = opts.proto;
		}

		serialize(addType) {
			if (
				this.constructor !==
				___R$project$rome$$internal$js$analysis$types$ObjT_ts$default
			) {
				throw new Error(
					"Expected ObjT to be constructor, youve likely forgot to define this method in the type subclass",
				);
			}

			return {
				calls: this.calls.map((type) => addType(type)),
				proto: this.proto === undefined ? undefined : addType(this.proto),
				props: this.props.map((type) => addType(type)),
			};
		}

		static hydrate(scope, originNode, data, getType) {
			return new ___R$project$rome$$internal$js$analysis$types$ObjT_ts$default(
				scope,
				originNode,
				{
					props: Array(data.props).map((id) => getType(id)),
					proto: data.proto === undefined ? undefined : getType(data.proto),
					calls: Array(data.calls).map((id) => getType(id)),
				},
			);
		}

		compatibleWith(otherType) {
			if (
				!(otherType instanceof
				___R$project$rome$$internal$js$analysis$types$ObjT_ts$default)
			) {
				return false;
			}

			const ourProps = this.props;
			const theirProps = otherType.props;

			// check that the other type has all of our props
			for (const ourPropRaw of ourProps) {
				// reduce and get the key of this prop
				const ourProp = this.utils.reduce(ourPropRaw);
				let key;
				if (
					ourProp instanceof
					___R$project$rome$$internal$js$analysis$types$ObjPropT_ts$default
				) {
					key = ourProp.key;
				} else {
					// should probably do something here
					continue;
				}

				// try and find a prop of the same key in the other object
				let theirProp;
				for (const theirPropRaw of theirProps) {
					const maybeTheirProp = this.utils.reduce(theirPropRaw);
					if (
						maybeTheirProp instanceof
						___R$project$rome$$internal$js$analysis$types$ObjPropT_ts$default &&
						maybeTheirProp.key === key
					) {
						theirProp = maybeTheirProp;
						break;
					}
				}

				if (!ourProp || !theirProp) {
					return false;
				}

				const compatibility = this.utils.checkCompability(ourProp, theirProp);
				if (compatibility.type === "incompatible") {
					return compatibility;
				}
			}

			return true;
		}

		humanize(builder) {
			if (this.props.length === 0) {
				return ___R$project$rome$$internal$markup$escape_ts$markup`{}`;
			} else {
				return ___R$project$rome$$internal$markup$escape_ts$concatMarkup(
					[
						___R$project$rome$$internal$markup$escape_ts$markup`{`,
						...this.props.map((prop) => {
							return builder.humanize(prop);
						}),
						___R$project$rome$$internal$markup$escape_ts$markup`}`,
					],
					___R$project$rome$$internal$markup$escape_ts$markup`\n`,
				);
			}
		}
	}
	___R$project$rome$$internal$js$analysis$types$ObjT_ts$default.type = "ObjT";


  // project-rome/@internal/js-analysis/types/StringLiteralT.ts
class ___R$project$rome$$internal$js$analysis$types$StringLiteralT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$ObjT_ts$default {
		constructor(scope, originNode, value) {
			super(
				scope,
				originNode,
				{
					props: [],
					proto: scope.intrinsics.StringPrototype,
					calls: [],
				},
			);
			this.value = value;
		}

		serialize() {
			return {value: this.value};
		}

		static hydrate(scope, originNode, data) {
			return new ___R$project$rome$$internal$js$analysis$types$StringLiteralT_ts$default(
				scope,
				originNode,
				String(data.value),
			);
		}

		humanize() {
			let str = JSON.stringify(this.value);
			return ___R$project$rome$$internal$markup$escape_ts$markup`${str}`;
		}

		compatibleWith(type) {
			return (
				type instanceof
				___R$project$rome$$internal$js$analysis$types$StringLiteralT_ts$default &&
				type.value === this.value
			);
		}
	}
	___R$project$rome$$internal$js$analysis$types$StringLiteralT_ts$default.type = "StringLiteralT";


  // project-rome/@internal/js-analysis/types/AnyT.ts
class ___R$project$rome$$internal$js$analysis$types$AnyT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		serialize() {
			return {};
		}

		static hydrate(scope, originNode) {
			return new ___R$project$rome$$internal$js$analysis$types$AnyT_ts$default(
				scope,
				originNode,
			);
		}

		compatibleWith() {
			return true;
		}

		humanize() {
			return ___R$project$rome$$internal$markup$escape_ts$markup`any`;
		}
	}
	___R$project$rome$$internal$js$analysis$types$AnyT_ts$default.type = "AnyT";


  // project-rome/@internal/js-analysis/types/errors/E.ts
class ___R$project$rome$$internal$js$analysis$types$errors$E_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		static hydrate(scope, originNode) {
			return new ___R$project$rome$$internal$js$analysis$types$AnyT_ts$default(
				scope,
				originNode,
			);
		}

		humanize() {
			return this.getError().description.message;
		}

		getError() {
			throw new Error("unimplemented");
		}

		compatibleWith() {
			return false;
		}
	}
	___R$project$rome$$internal$js$analysis$types$errors$E_ts$default.type = "E";


  // project-rome/@internal/js-analysis/types/errors/UnknownPropE.ts
class ___R$project$rome$$internal$js$analysis$types$errors$UnknownPropE_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$errors$E_ts$default {
		constructor(scope, originNode, opts) {
			super(scope, originNode);
			this.thisKeys = opts.thisKeys;
			this.protoKeys = opts.protoKeys;
			this.allProps = [...this.thisKeys, ...this.protoKeys];
			this.key = opts.key;
			this.object = opts.object;
			this.property = opts.property;
		}

		sortProps(props) {
			if (props.length === 0) {
				return props;
			}

			const ratings = ___R$project$rome$$internal$string$utils$orderBySimilarity_ts$orderBySimilarity(
				this.key,
				props,
			);
			const sortedProps = ratings.map((prop) => prop.target);
			return sortedProps;
		}

		getError() {
			return {
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.TYPE_CHECK.UNKNOWN_PROP(
					this.key,
					this.allProps,
				),
				lowerTarget: this.property,
				upperTarget: this.object,
			};
		}
	}
	___R$project$rome$$internal$js$analysis$types$errors$UnknownPropE_ts$default.type = "UnknownPropE";


  // project-rome/@internal/js-analysis/types/ObjIndexPropT.ts
class ___R$project$rome$$internal$js$analysis$types$ObjIndexPropT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		constructor(scope, originNode, key, value) {
			super(scope, originNode);
			this.key = key;
			this.value = value;
		}

		serialize(addType) {
			return {
				key: addType(this.key),
				value: addType(this.value),
			};
		}

		static hydrate(scope, originNode, data, getType) {
			return new ___R$project$rome$$internal$js$analysis$types$ObjIndexPropT_ts$default(
				scope,
				originNode,
				getType(data.key),
				getType(data.value),
			);
		}

		humanize(builder) {
			return ___R$project$rome$$internal$markup$escape_ts$markup`[${builder.humanize(
				this.key,
			)}]: ${builder.humanize(this.value)}`;
		}
	}
	___R$project$rome$$internal$js$analysis$types$ObjIndexPropT_ts$default.type = "ObjIndexPropT";


  // project-rome/@internal/js-analysis/types/GetPropT.ts
class ___R$project$rome$$internal$js$analysis$types$GetPropT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		constructor(scope, originNode, object, property) {
			super(scope, originNode);
			this.object = object;
			this.property = property;
		}

		serialize(addType) {
			return {
				object: addType(this.object),
				property: addType(this.property),
			};
		}

		static hydrate(scope, originNode, data, getType) {
			return new ___R$project$rome$$internal$js$analysis$types$GetPropT_ts$default(
				scope,
				originNode,
				getType(data.object),
				getType(data.property),
			);
		}

		lookup(object, property, opts = {}) {
			object = this.utils.reduce(object);
			property = this.utils.reduce(property);

			const thisKeys = new Set();

			//
			const protoKeys = opts.protoKeys === undefined ? [] : opts.protoKeys;
			const topObject = opts.topObject === undefined ? object : opts.topObject;

			// turn property into string key
			let key;
			if (
				property instanceof
				___R$project$rome$$internal$js$analysis$types$StringLiteralT_ts$default
			) {
				key = property.value;
			}

			// look up on object
			if (
				key !== undefined &&
				object instanceof
				___R$project$rome$$internal$js$analysis$types$ObjT_ts$default
			) {
				//
				const indexers = [];
				for (const maybePropRaw of object.props) {
					const maybeProp = this.utils.reduce(maybePropRaw);
					if (
						maybeProp instanceof
						___R$project$rome$$internal$js$analysis$types$ObjPropT_ts$default
					) {
						if (maybeProp.key === key) {
							// TODO collate these in case there's multiple properties of this name
							return this.utils.reduce(maybeProp.value);
						} else {
							thisKeys.add(maybeProp.key);
						}
					} else if (
						maybeProp instanceof
						___R$project$rome$$internal$js$analysis$types$ObjIndexPropT_ts$default
					) {
						indexers.push(maybeProp);
					}
				}

				//
				for (const indexer of indexers) {
					if (this.utils.isCompatibleWith(indexer.key, property)) {
						return this.utils.reduce(indexer.value);
					}
				}

				//
				if (object.proto) {
					return this.lookup(
						object.proto,
						property,
						{
							topObject,
							protoKeys: [...protoKeys, ...thisKeys],
						},
					);
				}
			}

			// property lookups on an `any` return `any`!
			if (
				object instanceof
				___R$project$rome$$internal$js$analysis$types$AnyT_ts$default ||
				object instanceof
				___R$project$rome$$internal$js$analysis$types$errors$E_ts$default
			) {
				return new ___R$project$rome$$internal$js$analysis$types$AnyT_ts$default(
					this.scope,
					this.originNode,
				);
			}

			//
			if (typeof key === "string") {
				return new ___R$project$rome$$internal$js$analysis$types$errors$UnknownPropE_ts$default(
					this.scope,
					this.originNode,
					{
						object: topObject,
						property,
						key,
						thisKeys: Array.from(thisKeys),
						protoKeys,
					},
				);
			} else {
				return new ___R$project$rome$$internal$js$analysis$types$UnknownT_ts$default(
					this.scope,
					this.originNode,
				);
			}
		}

		reduce() {
			return this.lookup(this.object, this.property);
		}
	}
	___R$project$rome$$internal$js$analysis$types$GetPropT_ts$default.type = "GetPropT";


  // project-rome/@internal/js-analysis/types/UnionT.ts
class ___R$project$rome$$internal$js$analysis$types$UnionT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		constructor(scope, originNode, types) {
			super(scope, originNode);
			this.types = [...new Set(types)];
		}

		serialize(addType) {
			return {
				types: this.types.map((type) => addType(type)),
			};
		}

		static hydrate(scope, originNode, data, getType) {
			return new ___R$project$rome$$internal$js$analysis$types$UnionT_ts$default(
				scope,
				originNode,
				Array(data.types).map((id) => getType(id)),
			);
		}

		reduce() {
			const uniqTypes = [];
			const types = this.explodeUnion();

			for (const type of types) {
				let foundMatch = false;
				for (const compareType of uniqTypes) {
					const isCompatible = this.utils.isCompatibleWith(compareType, type);
					if (isCompatible) {
						foundMatch = true;
						break;
					}
				}
				if (!foundMatch) {
					uniqTypes.push(type);
				}
			}

			if (uniqTypes.length === types.length) {
				return this;
			} else if (uniqTypes.length === 1) {
				return uniqTypes[0];
			} else {
				return new ___R$project$rome$$internal$js$analysis$types$UnionT_ts$default(
					this.scope,
					this.originNode,
					uniqTypes,
				);
			}
		}

		explodeUnion() {
			let types = [];
			const visited = new Set([this]);

			for (const type of this.types) {
				const reduced = this.utils.reduce(type);
				if (visited.has(reduced)) {
					continue;
				} else {
					visited.add(reduced);
				}

				types = types.concat(this.utils.explodeUnion(type));
			}

			return types;
		}

		compatibleWith(otherType) {
			const ourTypes = this.utils.explodeUnion(this);

			// fast path to check if a union contains a type
			if (ourTypes.includes(otherType)) {
				return true;
			}

			const otherTypes = this.utils.explodeUnion(otherType);
			const missing = [];

			for (const type of ourTypes) {
				let compatible = false;

				for (const otherType of otherTypes) {
					if (this.utils.isCompatibleWith(type, otherType)) {
						compatible = true;
					}
				}

				if (!compatible) {
					missing.push(type);
				}
			}

			if (missing.length === 0) {
				return true;
			} else {
				// create custom error with the types that weren't in the opposing one
				//return new MissingUnionE(this.scope, otherType.originNode, otherType, this, missing);
				return false;
			}
		}

		humanize(builder) {
			return ___R$project$rome$$internal$markup$escape_ts$concatMarkup(
				this.types.map((type) => builder.humanize(type)),
				___R$project$rome$$internal$markup$escape_ts$markup` | `,
			);
		}
	}
	___R$project$rome$$internal$js$analysis$types$UnionT_ts$default.type = "UnionT";


  // project-rome/@internal/js-analysis/scopes.ts
class ___R$project$rome$$internal$js$analysis$scopes_ts$Scope {
		constructor(opts) {
			let {evaluator, parentScope} = opts;
			if (evaluator === undefined && parentScope !== undefined) {
				evaluator = parentScope.evaluator;
			}

			if (evaluator === undefined) {
				throw new Error("No evaluator was passed or inferred");
			}

			this.intrinsics = evaluator.intrinsics;
			this.evaluator = evaluator;
			this.hub = evaluator.hub;
			this.parentScope = parentScope;

			this.bindings = new Map();
		}

		getBinding(name) {
			let scope = this;
			while (scope) {
				const binding = scope.bindings.get(name);
				if (binding) {
					return binding.type;
				}
				scope = scope.parentScope;
			}
			return undefined;
		}

		getBindingAssert(name) {
			const binding = this.getBinding(name);
			if (binding === undefined) {
				throw new Error("Expected binding " + name);
			}
			return binding;
		}

		query(paths) {
			let initial = this.getBinding(paths[0]);
			if (initial === undefined) {
				throw new Error(
					'Expected "' +
					paths[0] +
					'" binding, found ' +
					JSON.stringify(this.getBindingNames()) +
					" " +
					this.evaluator.filename,
				);
			}

			//invariant(initial !== undefined, `Expected "${paths[0]}" binding`);
			for (let i = 1; i < paths.length; i++) {
				initial = new ___R$project$rome$$internal$js$analysis$types$GetPropT_ts$default(
					this,
					undefined,
					initial,
					new ___R$project$rome$$internal$js$analysis$types$StringLiteralT_ts$default(
						this,
						undefined,
						paths[i],
					),
				);
			}

			return initial;
		}

		declareBinding(name, originNode) {
			if (name === undefined) {
				throw new Error("Expected name");
			}
			this.bindings.set(
				name,
				{
					type: new ___R$project$rome$$internal$js$analysis$types$OpenT_ts$default(
						this,
						originNode,
					),
					status: "declared",
				},
			);
		}

		addBinding(name, type) {
			if (name === undefined) {
				throw new Error("Expected name");
			}

			const existingBinding = this.bindings.get(name);
			if (existingBinding !== undefined && existingBinding.status === "declared") {
				if (
					!(existingBinding.type instanceof
					___R$project$rome$$internal$js$analysis$types$OpenT_ts$default)
				) {
					throw new Error("expected OpenT");
				}

				existingBinding.type.shouldMatch(type);
			}

			this.bindings.set(
				name,
				{
					type,
					status: "initialized",
				},
			);
		}

		getBindingNames() {
			const names = new Set(
				this.parentScope ? this.parentScope.getBindingNames() : [],
			);

			for (const [name] of this.bindings) {
				names.add(name);
			}

			return Array.from(names);
		}

		getOwnBindingNames() {
			return Array.from(this.bindings.keys());
		}

		createUnion(types, originNode) {
			if (types.length === 0) {
				return new ___R$project$rome$$internal$js$analysis$types$UnknownT_ts$default(
					this,
					originNode,
				);
			} else if (types.length === 1) {
				return types[0];
			} else {
				return new ___R$project$rome$$internal$js$analysis$types$UnionT_ts$default(
					this,
					originNode,
					types,
				);
			}
		}

		fork() {
			return new ___R$project$rome$$internal$js$analysis$scopes_ts$Scope({
				evaluator: this.evaluator,
				parentScope: this,
			});
		}

		// rome-ignore lint/ts/noExplicitAny: future cleanup
		find(klass) {
			const scope = this.findOptional(klass);
			if (scope === undefined) {
				throw new Error("Failed to find class");
			} else {
				return scope;
			}
		}

		findOptional(
			// rome-ignore lint/ts/noExplicitAny: future cleanup
			klass,
		) {
			let scope = this;

			do {
				if (scope instanceof klass) {
					return scope;
				}

				scope = scope.parentScope;
			} while (scope !== undefined);

			return undefined;
		}

		refine() {
			return new ___R$project$rome$$internal$js$analysis$scopes_ts$RefineScope({
				evaluator: this.evaluator,
				parentScope: this,
			});
		}

		evaluate(node) {
			return this.evaluator.evaluate(node, this);
		}
	}

	class ___R$project$rome$$internal$js$analysis$scopes_ts$RefineScope
		extends ___R$project$rome$$internal$js$analysis$scopes_ts$Scope {}

	class ___R$project$rome$$internal$js$analysis$scopes_ts$ClassScope
		extends ___R$project$rome$$internal$js$analysis$scopes_ts$Scope {
		constructor(opts, meta) {
			super(opts);
			this.meta = meta;
		}
	}

	class ___R$project$rome$$internal$js$analysis$scopes_ts$ThisScope
		extends ___R$project$rome$$internal$js$analysis$scopes_ts$Scope {
		constructor(opts, context) {
			super(opts);
			this.context = context;
		}
	}

	class ___R$project$rome$$internal$js$analysis$scopes_ts$FunctionScope
		extends ___R$project$rome$$internal$js$analysis$scopes_ts$ThisScope {
		constructor(opts, meta) {
			super(opts, meta.thisContext);
			this.meta = meta;
		}
	}


  // project-rome/@internal/js-analysis/types/errors/UnknownImportE.ts
class ___R$project$rome$$internal$js$analysis$types$errors$UnknownImportE_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$errors$E_ts$default {
		constructor(scope, originNode, opts) {
			super(scope, originNode);
			this.possibleNames = opts.possibleNames;
			this.importedName = opts.importedName;
			this.source = opts.source;
		}

		getError() {
			return {
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.TYPE_CHECK.UNKNOWN_IMPORT(
					this.importedName,
					this.source,
					this.possibleNames,
				),
				lowerTarget: this,
			};
		}
	}
	___R$project$rome$$internal$js$analysis$types$errors$UnknownImportE_ts$default.type = "UnknownImportE";


  // project-rome/@internal/js-analysis/types/VoidT.ts
class ___R$project$rome$$internal$js$analysis$types$VoidT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		serialize() {
			return {};
		}

		static hydrate(scope, originNode) {
			return new ___R$project$rome$$internal$js$analysis$types$VoidT_ts$default(
				scope,
				originNode,
			);
		}

		humanize() {
			return ___R$project$rome$$internal$markup$escape_ts$markup`void`;
		}
	}
	___R$project$rome$$internal$js$analysis$types$VoidT_ts$default.type = "VoidT";


  // project-rome/@internal/js-analysis/types/EmptyT.ts
class ___R$project$rome$$internal$js$analysis$types$EmptyT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		serialize() {
			return {};
		}

		static hydrate(scope, originNode) {
			return new ___R$project$rome$$internal$js$analysis$types$EmptyT_ts$default(
				scope,
				originNode,
			);
		}

		humanize() {
			return ___R$project$rome$$internal$markup$escape_ts$markup`empty`;
		}

		compatibleWith(otherType) {
			return (
				otherType instanceof
				___R$project$rome$$internal$js$analysis$types$EmptyT_ts$default ||
				otherType instanceof
				___R$project$rome$$internal$js$analysis$types$VoidT_ts$default
			);
		}
	}
	___R$project$rome$$internal$js$analysis$types$EmptyT_ts$default.type = "EmptyT";


  // project-rome/@internal/js-analysis/types/BooleanLiteralT.ts
class ___R$project$rome$$internal$js$analysis$types$BooleanLiteralT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		constructor(scope, originNode, value) {
			super(scope, originNode);
			this.value = value;
		}

		serialize() {
			return {value: this.value};
		}

		static hydrate(scope, originNode, data) {
			return new ___R$project$rome$$internal$js$analysis$types$BooleanLiteralT_ts$default(
				scope,
				originNode,
				Boolean(data.value),
			);
		}

		humanize() {
			if (this.value) {
				return ___R$project$rome$$internal$markup$escape_ts$markup`true`;
			} else {
				return ___R$project$rome$$internal$markup$escape_ts$markup`false`;
			}
		}

		compatibleWith(type) {
			return (
				type instanceof
				___R$project$rome$$internal$js$analysis$types$BooleanLiteralT_ts$default &&
				type.value === this.value
			);
		}
	}
	___R$project$rome$$internal$js$analysis$types$BooleanLiteralT_ts$default.type = "BooleanLiteralT";


  // project-rome/@internal/js-analysis/types/BooleanT.ts
class ___R$project$rome$$internal$js$analysis$types$BooleanT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		serialize() {
			return {};
		}

		static hydrate(scope, originNode) {
			return new ___R$project$rome$$internal$js$analysis$types$BooleanT_ts$default(
				scope,
				originNode,
			);
		}

		humanize() {
			return ___R$project$rome$$internal$markup$escape_ts$markup`boolean`;
		}

		compatibleWith(type) {
			// A boolean literal can flow into a generic boolean
			return (
				type instanceof
				___R$project$rome$$internal$js$analysis$types$BooleanT_ts$default ||
				type instanceof
				___R$project$rome$$internal$js$analysis$types$BooleanLiteralT_ts$default
			);
		}
	}
	___R$project$rome$$internal$js$analysis$types$BooleanT_ts$default.type = "BooleanT";


  // project-rome/@internal/js-analysis/types/errors/NotCallableE.ts
class ___R$project$rome$$internal$js$analysis$types$errors$NotCallableE_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$errors$E_ts$default {
		constructor(scope, originNode, callee) {
			super(scope, originNode);
			this.callee = callee;
		}

		getError() {
			return {
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.TYPE_CHECK.NOT_CALLABLE,
				lowerTarget: this.callee,
			};
		}
	}
	___R$project$rome$$internal$js$analysis$types$errors$NotCallableE_ts$default.type = "NotCallableE";


  // project-rome/@internal/js-analysis/types/FunctionT.ts
class ___R$project$rome$$internal$js$analysis$types$FunctionT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$ObjT_ts$default {
		constructor(scope, originNode, opts) {
			super(
				scope,
				originNode,
				{
					props: opts.props,
					proto: opts.proto,
					calls: [],
				},
			);
			this.params = opts.params;
			this.rest = opts.rest;
			this.returns = opts.returns;
			this.body = opts.body;
		}

		serialize(addType) {
			return {
				params: this.params.map((type) => addType(type)),
				rest: this.rest ? addType(this.rest) : undefined,
				returns: addType(this.returns),
				proto: this.proto === undefined ? undefined : addType(this.proto),
				body: this.body === undefined ? undefined : addType(this.body),
				props: this.props.map((type) => addType(type)),
			};
		}

		static hydrate(scope, originNode, data, getType) {
			return new ___R$project$rome$$internal$js$analysis$types$FunctionT_ts$default(
				scope,
				originNode,
				{
					params: Array(data.params).map((id) => getType(id)),
					rest: data.rest === undefined ? undefined : getType(data.rest),
					returns: getType(data.returns),
					props: Array(data.props).map((id) => getType(id)),
					proto: data.proto === undefined ? undefined : getType(data.proto),
					body: data.body === undefined ? undefined : getType(data.body),
				},
			);
		}

		humanize(builder) {
			return ___R$project$rome$$internal$markup$escape_ts$markup`(${this.params.map((
				param,
			) => builder.humanize(param)).join(", ")}) => ${builder.humanize(
				this.returns,
			)}`;
		}

		reduce() {
			// No body, just a type signature
			const {body} = this;
			if (body === undefined) {
				return this;
			}

			// Reduce the body and create a new function
			const reducedBody = this.utils.reduce(body);
			if (reducedBody !== body) {
				return new ___R$project$rome$$internal$js$analysis$types$FunctionT_ts$default(
					this.scope,
					this.originNode,
					{
						params: this.params,
						rest: this.rest,
						returns: this.returns,
						props: this.props,
						proto: this.proto,
						body: reducedBody,
					},
				);
			}

			// Already been reduced
			return this;
		}
	}
	___R$project$rome$$internal$js$analysis$types$FunctionT_ts$default.type = "FunctionT";


  // project-rome/@internal/js-analysis/types/CallT.ts
class ___R$project$rome$$internal$js$analysis$types$CallT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		constructor(scope, originNode, callee, args) {
			super(scope, originNode);
			this.callee = callee;
			this.args = args;
		}

		reduce() {
			let callee = this.utils.reduce(this.callee);
			if (
				callee instanceof
				___R$project$rome$$internal$js$analysis$types$ObjT_ts$default &&
				callee.calls.length
			) {
				callee = this.utils.reduce(callee.calls[0]);
			}

			if (
				callee instanceof
				___R$project$rome$$internal$js$analysis$types$AnyT_ts$default ||
				callee instanceof
				___R$project$rome$$internal$js$analysis$types$errors$E_ts$default
			) {
				return new ___R$project$rome$$internal$js$analysis$types$AnyT_ts$default(
					this.scope,
					this.originNode,
				);
			} else if (
				callee instanceof
				___R$project$rome$$internal$js$analysis$types$FunctionT_ts$default
			) {
				return this.utils.reduce(callee.returns);
			} else {
				return new ___R$project$rome$$internal$js$analysis$types$errors$NotCallableE_ts$default(
					this.scope,
					this.originNode,
					this.callee,
				);
			}
		}
	}
	___R$project$rome$$internal$js$analysis$types$CallT_ts$default.type = "CallT";


  // project-rome/@internal/js-analysis/types/ClassT.ts
class ___R$project$rome$$internal$js$analysis$types$ClassT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$ObjT_ts$default {
		constructor(scope, originNode, opts) {
			// point `class.prototype.__proto__` to `superClass.prototype`
			let protoProp = undefined;
			if (opts.extends) {
				const originNode = opts.extends.originNode;
				protoProp = new ___R$project$rome$$internal$js$analysis$types$GetPropT_ts$default(
					scope,
					originNode,
					opts.extends,
					new ___R$project$rome$$internal$js$analysis$types$StringLiteralT_ts$default(
						scope,
						originNode,
						"prototype",
					),
				);
			}

			// create `class.prototype.constructor`
			const constructorOpen = new ___R$project$rome$$internal$js$analysis$types$OpenT_ts$default(
				scope,
				undefined,
			);
			const constructorProp = new ___R$project$rome$$internal$js$analysis$types$ObjPropT_ts$default(
				scope,
				undefined,
				"constructor",
				constructorOpen,
			);
			const instances = [...opts.instances, constructorProp];

			// create `class.prototype`
			const protoObj = new ___R$project$rome$$internal$js$analysis$types$ObjT_ts$default(
				scope,
				originNode,
				{
					props: instances,
					proto: protoProp,
					calls: [],
				},
			);

			super(
				scope,
				originNode,
				{
					props: [
						...opts.statics,
						new ___R$project$rome$$internal$js$analysis$types$ObjPropT_ts$default(
							scope,
							originNode,
							"prototype",
							protoObj,
						),
					],
					proto: opts.extends,
					calls: opts.calls === undefined ? [] : opts.calls,
				},
			);

			constructorOpen.shouldMatch(this);

			this._constructor = opts._constructor;
			this._statics = opts.statics;
			this._instances = opts.instances;
			this._extends = opts.extends;
		}

		serialize(addType) {
			return {
				constructor: this._constructor === undefined
					? undefined
					: addType(this._constructor),
				statics: this._statics.map((type) => addType(type)),
				instances: this._instances.map((type) => addType(type)),
				extends: this._extends === undefined
					? undefined
					: addType(this._extends),
			};
		}

		static hydrate(scope, originNode, data, getType) {
			return new ___R$project$rome$$internal$js$analysis$types$ClassT_ts$default(
				scope,
				originNode,
				{
					_constructor: data.constructor === undefined
						? undefined
						: getType(data.constructor),
					statics: Array(data.statics).map((id) => getType(id)),
					instances: Array(data.instances).map((id) => getType(id)),
					extends: data.extends === undefined
						? undefined
						: getType(data.extends),
				},
			);
		}
	}
	___R$project$rome$$internal$js$analysis$types$ClassT_ts$default.type = "ClassT";


  // project-rome/@internal/js-analysis/types/IntersectionT.ts
class ___R$project$rome$$internal$js$analysis$types$IntersectionT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		constructor(scope, originNode, types) {
			super(scope, originNode);
			this.types = types;
		}

		serialize(addType) {
			return {
				types: this.types.map((type) => addType(type)),
			};
		}

		static hydrate(scope, originNode, data, getType) {
			return new ___R$project$rome$$internal$js$analysis$types$IntersectionT_ts$default(
				scope,
				originNode,
				Array(data.types).map((id) => getType(id)),
			);
		}

		compatibleWith(otherType) {
			for (const type of this.types) {
				const compatibility = this.utils.checkCompability(type, otherType);
				if (compatibility.type === "incompatible") {
					return compatibility;
				}
			}
			return true;
		}

		humanize(builder) {
			return ___R$project$rome$$internal$markup$escape_ts$concatMarkup(
				this.types.map((type) => builder.humanize(type)),
				___R$project$rome$$internal$markup$escape_ts$markup` & `,
			);
		}
	}
	___R$project$rome$$internal$js$analysis$types$IntersectionT_ts$default.type = "IntersectionT";


  // project-rome/@internal/js-analysis/types/NullT.ts
class ___R$project$rome$$internal$js$analysis$types$NullT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		serialize() {
			return {};
		}

		static hydrate(scope, originNode) {
			return new ___R$project$rome$$internal$js$analysis$types$NullT_ts$default(
				scope,
				originNode,
			);
		}

		humanize() {
			return ___R$project$rome$$internal$markup$escape_ts$markup`null`;
		}
	}
	___R$project$rome$$internal$js$analysis$types$NullT_ts$default.type = "NullT";


  // project-rome/@internal/js-analysis/types/MaybeT.ts
class ___R$project$rome$$internal$js$analysis$types$MaybeT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		constructor(scope, originNode, parent) {
			super(scope, originNode);
			this.parent = parent;
		}

		serialize(addType) {
			return {
				parent: addType(this.parent),
			};
		}

		static hydrate(scope, originNode, data, getType) {
			return new ___R$project$rome$$internal$js$analysis$types$MaybeT_ts$default(
				scope,
				originNode,
				getType(data.parent),
			);
		}

		humanize(builder) {
			return ___R$project$rome$$internal$markup$escape_ts$markup`?${builder.humanize(
				this.parent,
			)}`;
		}

		explodeUnion() {
			return [
				new ___R$project$rome$$internal$js$analysis$types$VoidT_ts$default(
					this.scope,
					this.originNode,
				),
				new ___R$project$rome$$internal$js$analysis$types$NullT_ts$default(
					this.scope,
					this.originNode,
				),
				...this.utils.explodeUnion(this.parent),
			];
		}

		compatibleWith(otherType) {
			if (
				otherType instanceof
				___R$project$rome$$internal$js$analysis$types$MaybeT_ts$default
			) {
				return this.utils.checkCompability(this.parent, otherType.parent);
			} else {
				return (
					otherType instanceof
					___R$project$rome$$internal$js$analysis$types$VoidT_ts$default ||
					otherType instanceof
					___R$project$rome$$internal$js$analysis$types$NullT_ts$default ||
					this.utils.checkCompability(this.parent, otherType)
				);
			}
		}
	}
	___R$project$rome$$internal$js$analysis$types$MaybeT_ts$default.type = "MaybeT";


  // project-rome/@internal/js-analysis/types/MixedT.ts
class ___R$project$rome$$internal$js$analysis$types$MixedT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		serialize() {
			return {};
		}

		static hydrate(scope, originNode) {
			return new ___R$project$rome$$internal$js$analysis$types$MixedT_ts$default(
				scope,
				originNode,
			);
		}

		compatibleWith() {
			return false;
		}

		humanize() {
			return ___R$project$rome$$internal$markup$escape_ts$markup`mixed`;
		}
	}
	___R$project$rome$$internal$js$analysis$types$MixedT_ts$default.type = "MixedT";


  // project-rome/@internal/js-analysis/types/NumericT.ts
class ___R$project$rome$$internal$js$analysis$types$NumericT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$ObjT_ts$default {
		constructor(scope, originNode) {
			super(
				scope,
				originNode,
				{
					props: [],
					proto: scope.intrinsics.NumberPrototype,
					calls: [],
				},
			);
		}

		serialize() {
			return {};
		}

		static hydrate(scope, originNode) {
			return new ___R$project$rome$$internal$js$analysis$types$NumericT_ts$default(
				scope,
				originNode,
			);
		}

		humanize() {
			return ___R$project$rome$$internal$markup$escape_ts$markup`number`;
		}

		compatibleWith(type) {
			// a numeric literal can flow into a generic number
			return (
				type instanceof
				___R$project$rome$$internal$js$analysis$types$NumericT_ts$default ||
				type instanceof
				___R$project$rome$$internal$js$analysis$types$NumericLiteralT_ts$default
			);
		}
	}
	___R$project$rome$$internal$js$analysis$types$NumericT_ts$default.type = "NumericT";


  // project-rome/@internal/js-analysis/types/NumericLiteralT.ts
class ___R$project$rome$$internal$js$analysis$types$NumericLiteralT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$ObjT_ts$default {
		constructor(scope, originNode, value) {
			super(
				scope,
				originNode,
				{
					props: [],
					proto: scope.intrinsics.NumberPrototype,
					calls: [],
				},
			);
			this.value = value;
		}

		serialize() {
			return {value: this.value};
		}

		static hydrate(scope, originNode, data) {
			return new ___R$project$rome$$internal$js$analysis$types$NumericLiteralT_ts$default(
				scope,
				originNode,
				Number(data.value),
			);
		}

		humanize() {
			return ___R$project$rome$$internal$markup$escape_ts$markup`${String(
				this.value,
			)}`;
		}

		compatibleWith(type) {
			return (
				type instanceof
				___R$project$rome$$internal$js$analysis$types$NumericT_ts$default ||
				(type instanceof
				___R$project$rome$$internal$js$analysis$types$NumericLiteralT_ts$default &&
				type.value === this.value)
			);
		}
	}
	___R$project$rome$$internal$js$analysis$types$NumericLiteralT_ts$default.type = "NumericLiteralT";


  // project-rome/@internal/js-analysis/types/ImportT.ts
class ___R$project$rome$$internal$js$analysis$types$ImportT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		constructor(scope, originNode, opts) {
			super(scope, originNode);
			this.importedName = opts.importedName;
			this.relative =
				opts.relative === undefined ? scope.evaluator.filename : opts.relative;
			this.source = opts.source;
			this.absolute = undefined;
			this.resolvedType = undefined;
			scope.evaluator.addImport(
				this,
				{
					importedName: this.importedName,
					relative: this.relative,
					source: this.source,
				},
			);
		}

		setAbsolute(absolute) {
			this.absolute = absolute;
		}

		setResolvedType(resolvedType) {
			this.resolvedType = resolvedType;
		}

		serialize() {
			return {
				importedName: this.importedName,
				relative: this.relative,
				source: this.source,
			};
		}

		static hydrate(scope, originNode, data) {
			return new ___R$project$rome$$internal$js$analysis$types$ImportT_ts$default(
				scope,
				originNode,
				{
					importedName: String(data.importedName),
					source: String(data.source),
					relative: String(data.relative),
				},
			);
		}

		humanize(builder) {
			let object;
			if (this.resolvedType !== undefined) {
				object = builder.humanize(this.resolvedType);
			} else if (this.absolute === undefined) {
				object = ___R$project$rome$$internal$markup$escape_ts$markup`$Exports<"${this.source}", "${this.relative}">`;
			} else {
				object = ___R$project$rome$$internal$markup$escape_ts$markup`$Exports<"${this.absolute}">`;
			}

			if (this.importedName === undefined) {
				return object;
			} else {
				return ___R$project$rome$$internal$markup$escape_ts$markup`${object}.${this.importedName}`;
			}
		}

		reduce() {
			if (this.resolvedType === undefined) {
				return this;
			} else {
				return this.resolvedType;
			}
		}
	}
	___R$project$rome$$internal$js$analysis$types$ImportT_ts$default.type = "ImportT";


  // project-rome/@internal/js-analysis/types/StringT.ts
class ___R$project$rome$$internal$js$analysis$types$StringT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$ObjT_ts$default {
		constructor(scope, originNode) {
			super(
				scope,
				originNode,
				{
					props: [],
					proto: scope.intrinsics.StringPrototype,
					calls: [],
				},
			);
		}

		serialize() {
			return {};
		}

		static hydrate(scope, originNode) {
			return new ___R$project$rome$$internal$js$analysis$types$StringT_ts$default(
				scope,
				originNode,
			);
		}

		humanize() {
			return ___R$project$rome$$internal$markup$escape_ts$markup`string`;
		}

		compatibleWith(type) {
			// a string literal can flow into a generic string
			return (
				type instanceof
				___R$project$rome$$internal$js$analysis$types$StringT_ts$default ||
				type instanceof
				___R$project$rome$$internal$js$analysis$types$StringLiteralT_ts$default
			);
		}
	}
	___R$project$rome$$internal$js$analysis$types$StringT_ts$default.type = "StringT";


  // project-rome/@internal/js-analysis/types/ExhaustiveT.ts
class ___R$$priv$project$rome$$internal$js$analysis$types$ExhaustiveT_ts$ENotExhaustive
		extends ___R$project$rome$$internal$js$analysis$types$errors$E_ts$default {
		constructor(scope, originNode, target, only, extraenous) {
			super(scope, originNode);
			this.target = target;
			this.only = only;
			this.extraenous = extraenous;
		}

		getError() {
			return {
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.TYPE_CHECK.NOT_EXHAUSTIVE(
					this.utils.humanize(this.only),
					this.utils.humanize(this.target),
				),
				lowerTarget: this.target,
			};
		}
	}
	___R$$priv$project$rome$$internal$js$analysis$types$ExhaustiveT_ts$ENotExhaustive.type = "ENotExhaustive";
	class ___R$project$rome$$internal$js$analysis$types$ExhaustiveT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		constructor(scope, originNode, target, only) {
			super(scope, originNode);
			this.target = target;
			this.only = only;
		}

		serialize(addType) {
			return {
				target: addType(this.target),
				only: addType(this.only),
			};
		}

		static hydrate(scope, originNode, data, getType) {
			return new ___R$project$rome$$internal$js$analysis$types$ExhaustiveT_ts$default(
				scope,
				originNode,
				getType(data.target),
				getType(data.only),
			);
		}

		reduce() {
			const target = this.utils.reduce(this.target);
			const only = this.utils.reduce(this.only);
			if (
				target instanceof
				___R$project$rome$$internal$js$analysis$types$AnyT_ts$default ||
				only instanceof
				___R$project$rome$$internal$js$analysis$types$AnyT_ts$default
			) {
				return this.only;
			}

			const targetCandidates = this.utils.explodeUnion(target);
			const onlyCandidates = this.utils.explodeUnion(only);

			const extraneous = [];
			for (const possible of targetCandidates) {
				let compatible = false;

				for (const otherType of onlyCandidates) {
					if (this.utils.isCompatibleWith(possible, otherType)) {
						compatible = true;
					}
				}

				if (!compatible) {
					extraneous.push(possible);
				}
			}

			if (extraneous.length === 0) {
				return target;
			} else {
				return new ___R$$priv$project$rome$$internal$js$analysis$types$ExhaustiveT_ts$ENotExhaustive(
					this.scope,
					this.originNode,
					this.target,
					this.only,
					extraneous,
				);
			}
		}

		humanize(builder) {
			return ___R$project$rome$$internal$markup$escape_ts$markup`exhaustive ${builder.humanize(
				this.target,
			)} should only match ${builder.humanize(this.target)}`;
		}
	}
	___R$project$rome$$internal$js$analysis$types$ExhaustiveT_ts$default.type = "ExhaustiveT";


  // project-rome/@internal/js-analysis/types/InstanceT.ts
class ___R$project$rome$$internal$js$analysis$types$InstanceT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$ObjT_ts$default {
		constructor(scope, originNode, target, typeParameters) {
			const prototype = new ___R$project$rome$$internal$js$analysis$types$GetPropT_ts$default(
				scope,
				originNode,
				target,
				new ___R$project$rome$$internal$js$analysis$types$StringLiteralT_ts$default(
					scope,
					originNode,
					"prototype",
				),
			);
			super(
				scope,
				originNode,
				{
					props: [],
					proto: prototype,
					calls: [],
				},
			);

			this.typeParameters = typeParameters;
			this.target = target;
		}

		serialize(addType) {
			return {
				target: addType(this.target),
				params: this.typeParameters.map((type) => addType(type)),
			};
		}

		static hydrate(scope, originNode, data, getType) {
			return new ___R$project$rome$$internal$js$analysis$types$InstanceT_ts$default(
				scope,
				originNode,
				getType(data.target),
				Array(data.params).map((id) => getType(id)),
			);
		}

		humanize(builder) {
			const name = builder.humanize(this.target);
			const typeParams = this.typeParameters;
			if (typeParams.length === 0) {
				return ___R$project$rome$$internal$markup$escape_ts$markup`${name}`;
			} else {
				return ___R$project$rome$$internal$markup$escape_ts$markup`${name}<${typeParams.map((
					param,
				) => builder.humanize(param)).join(", ")}>`;
			}
		}

		compatibleWith(otherType) {
			return (
				otherType instanceof
				___R$project$rome$$internal$js$analysis$types$InstanceT_ts$default &&
				this.utils.checkCompability(this.target, otherType.target)
			);
		}
	}
	___R$project$rome$$internal$js$analysis$types$InstanceT_ts$default.type = "InstanceT";


  // project-rome/@internal/js-analysis/types/GenericT.ts
class ___R$project$rome$$internal$js$analysis$types$GenericT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		constructor(scope, originNode, name, type) {
			super(scope, originNode);
			this.name = name;
			this.type = type;
		}

		serialize(addType) {
			return {
				name: this.name,
				type: addType(this.type),
			};
		}

		static hydrate(scope, originNode, data, getType) {
			return new ___R$project$rome$$internal$js$analysis$types$GenericT_ts$default(
				scope,
				originNode,
				String(data.name),
				getType(data.type),
			);
		}

		humanize() {
			return ___R$project$rome$$internal$markup$escape_ts$markup`${this.name}`;
		}

		reduce() {
			const type = this.utils.reduce(this.type);
			if (
				type instanceof
				___R$project$rome$$internal$js$analysis$types$ClassT_ts$default
			) {
				return new ___R$project$rome$$internal$js$analysis$types$InstanceT_ts$default(
					this.scope,
					this.originNode,
					this.type,
					[],
				);
			} else {
				return type;
			}
		}
	}
	___R$project$rome$$internal$js$analysis$types$GenericT_ts$default.type = "GenericT";


  // project-rome/@internal/js-analysis/types/BinaryOpT.ts
function ___R$$priv$project$rome$$internal$js$analysis$types$BinaryOpT_ts$isNumber(
		t,
	) {
		return (
			t instanceof
			___R$project$rome$$internal$js$analysis$types$NumericT_ts$default ||
			t instanceof
			___R$project$rome$$internal$js$analysis$types$NumericLiteralT_ts$default
		);
	}

	class ___R$project$rome$$internal$js$analysis$types$BinaryOpT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		constructor(scope, originNode, left, operator, right) {
			super(scope, originNode);
			this.operator = operator;
			this.left = left;
			this.right = right;
		}

		serialize(addType) {
			return {
				left: addType(this.left),
				right: addType(this.right),
			};
		}

		static hydrate(scope, originNode, data, getType) {
			return new ___R$project$rome$$internal$js$analysis$types$BinaryOpT_ts$default(
				scope,
				originNode,
				getType(data.left),
				String(data.operator),
				getType(data.right),
			);
		}

		reduce() {
			const left = this.utils.reduce(this.left);
			const right = this.utils.reduce(this.right);
			const {scope, originNode, operator} = this;

			// return type
			switch (operator) {
				case // returns booleans
				"===":
				case "==":
				case "!=":
				case "!==":
				case "<":
				case "<=":
				case ">":
				case ">=":
				case "in":
				case "instanceof":
					// TODO return BooleanLiteralT in the cases whe we have all the info
					return new ___R$project$rome$$internal$js$analysis$types$BooleanT_ts$default(
						scope,
						originNode,
					);

				// Returns a string or a number
				case "+":
					if (
						left instanceof
						___R$project$rome$$internal$js$analysis$types$AnyT_ts$default ||
						right instanceof
						___R$project$rome$$internal$js$analysis$types$AnyT_ts$default
					) {
						return new ___R$project$rome$$internal$js$analysis$types$AnyT_ts$default(
							scope,
							originNode,
						);
					} else if (
						left instanceof
						___R$project$rome$$internal$js$analysis$types$NumericLiteralT_ts$default &&
						right instanceof
						___R$project$rome$$internal$js$analysis$types$NumericLiteralT_ts$default
					) {
						return new ___R$project$rome$$internal$js$analysis$types$NumericLiteralT_ts$default(
							scope,
							originNode,
							left.value + right.value,
						);
					} else if (
						___R$$priv$project$rome$$internal$js$analysis$types$BinaryOpT_ts$isNumber(
							left,
						) &&
						___R$$priv$project$rome$$internal$js$analysis$types$BinaryOpT_ts$isNumber(
							right,
						)
					) {
						return new ___R$project$rome$$internal$js$analysis$types$NumericT_ts$default(
							scope,
							originNode,
						);
					} else if (
						left instanceof
						___R$project$rome$$internal$js$analysis$types$StringLiteralT_ts$default &&
						right instanceof
						___R$project$rome$$internal$js$analysis$types$StringLiteralT_ts$default
					) {
						return new ___R$project$rome$$internal$js$analysis$types$StringLiteralT_ts$default(
							scope,
							originNode,
							left.value + right.value,
						);
					} else {
						return new ___R$project$rome$$internal$js$analysis$types$StringT_ts$default(
							scope,
							originNode,
						);
					}

				// returns a number
				case "<<":
				case ">>":
				case ">>>":
				case "-":
				case "*":
				case "/":
				case "%":
				case "**":
				case "|":
				case "^":
				case "&":
					// TODO return NumericLiteralT if left/right are literals too
					return new ___R$project$rome$$internal$js$analysis$types$NumericT_ts$default(
						scope,
						originNode,
					);

				default:
					throw new Error("Unknown operator");
			}
		}
	}
	___R$project$rome$$internal$js$analysis$types$BinaryOpT_ts$default.type = "BinaryOpT";


  // project-rome/@internal/js-analysis/types/errors/MissingUnionE.ts
class ___R$project$rome$$internal$js$analysis$types$errors$MissingUnionE_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$errors$E_ts$default {
		constructor(scope, originNode, target, union, missing) {
			super(scope, originNode);
			this.target = target;
			this.union = union;
			this.missing = missing;
		}

		getError() {
			return {
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.TYPE_CHECK.MISSING_CONDITION(
					this.missing.map((type) => this.utils.humanize(type)),
				),
				lowerTarget: this.target,
			};
		}
	}
	___R$project$rome$$internal$js$analysis$types$errors$MissingUnionE_ts$default.type = "MissingUnionE";


  // project-rome/@internal/js-analysis/types/RefinedT.ts
class ___R$project$rome$$internal$js$analysis$types$RefinedT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		constructor(scope, originNode, root, remove) {
			super(scope, originNode);
			this.root = root;
			this.remove = remove;
		}

		reduce() {
			const {root} = this;

			const exploded = this.utils.explodeUnion(root);
			const removeTypes = this.utils.explodeUnion(this.remove);

			const clean = [];
			const removed = [];

			// remove any possible derived types from the root that are compatible with the removed type
			for (const type of exploded) {
				let compatible = false;

				// check if any of the removed types are compatible, if every removed type is incompatible then

				// we've refined away the type
				for (const remove of removeTypes) {
					if (this.utils.isCompatibleWith(type, remove)) {
						compatible = true;
					}
				}

				if (compatible) {
					removed.push(type);
				} else {
					clean.push(type);
				}
			}

			if (removed.length === 0) {
				// return an error here because the removed type doesn't exist in the root
				return new ___R$project$rome$$internal$js$analysis$types$errors$MissingUnionE_ts$default(
					root.scope,
					root.originNode,
					root,
					this.remove,
					removed,
				);
			} else {
				return root.scope.createUnion(clean, root.originNode);
			}
		}
	}
	___R$project$rome$$internal$js$analysis$types$RefinedT_ts$default.type = "RefinedT";


  // project-rome/@internal/js-analysis/types/RefineTypeofT.ts
class ___R$project$rome$$internal$js$analysis$types$RefineTypeofT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		constructor(scope, node, str, fallback) {
			super(scope, node);
			this.str = str;
			this.fallback = fallback;
		}

		reduce() {
			const {fallback, utils} = this;
			const str = utils.reduce(this.str);

			if (
				str instanceof
				___R$project$rome$$internal$js$analysis$types$StringLiteralT_ts$default
			) {
				let val;

				switch (str.value) {
					case "string": {
						val = new ___R$project$rome$$internal$js$analysis$types$StringT_ts$default(
							this.scope,
							undefined,
						);
						break;
					}

					case "number": {
						val = new ___R$project$rome$$internal$js$analysis$types$NumericT_ts$default(
							this.scope,
							undefined,
						);
						break;
					}

					case "undefined": {
						val = new ___R$project$rome$$internal$js$analysis$types$VoidT_ts$default(
							this.scope,
							undefined,
						);
						break;
					}

					case "boolean": {
						val = new ___R$project$rome$$internal$js$analysis$types$BooleanT_ts$default(
							this.scope,
							undefined,
						);
						break;
					}

					case "symbol":
					case "function":
					case "object":
						// TODO
						return utils.reduce(fallback);

					default:
						// TODO complain about unknown value
						return utils.reduce(fallback);
				}

				// make sure our refinement is actually possible and matches a value in `fallback`

				// then pluck the matching type
				const types = utils.explodeUnion(fallback);
				for (const type of types) {
					if (utils.isCompatibleWith(type, val)) {
						return utils.reduce(type);
					}
				}

				// TODO complain of a missing condition
				return utils.reduce(fallback);
			}

			return utils.reduce(fallback);
		}
	}
	___R$project$rome$$internal$js$analysis$types$RefineTypeofT_ts$default.type = "RefineTypeofT";


  // project-rome/@internal/js-analysis/types/TypeofT.ts
class ___R$project$rome$$internal$js$analysis$types$TypeofT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		constructor(scope, node, obj) {
			super(scope, node);
			this.obj = obj;
		}

		reduce() {
			const types = this.utils.explodeUnion(this.obj);

			const possibleTypes = [];
			for (const rawType of types) {
				const type = this.utils.reduce(rawType);
				let typeStr;

				if (
					type instanceof
					___R$project$rome$$internal$js$analysis$types$StringT_ts$default ||
					type instanceof
					___R$project$rome$$internal$js$analysis$types$StringLiteralT_ts$default
				) {
					typeStr = "string";
				}

				if (
					type instanceof
					___R$project$rome$$internal$js$analysis$types$NumericT_ts$default ||
					type instanceof
					___R$project$rome$$internal$js$analysis$types$NumericLiteralT_ts$default
				) {
					typeStr = "number";
				}

				if (
					type instanceof
					___R$project$rome$$internal$js$analysis$types$BooleanT_ts$default ||
					type instanceof
					___R$project$rome$$internal$js$analysis$types$BooleanLiteralT_ts$default
				) {
					typeStr = "boolean";
				}

				if (
					type instanceof
					___R$project$rome$$internal$js$analysis$types$VoidT_ts$default
				) {
					typeStr = "undefined";
				}

				if (
					type instanceof
					___R$project$rome$$internal$js$analysis$types$ObjT_ts$default
				) {
					if (type.calls.length === 0) {
						typeStr = "object";
					} else {
						typeStr = "function";
					}
				}

				if (
					type instanceof
					___R$project$rome$$internal$js$analysis$types$NullT_ts$default
				) {
					typeStr = "object";
				}

				// TODO symbol

				// TODO bigint
				if (typeStr !== undefined) {
					possibleTypes.push(
						new ___R$project$rome$$internal$js$analysis$types$StringLiteralT_ts$default(
							this.scope,
							this.originNode,
							typeStr,
						),
					);
				}
			}

			if (possibleTypes.length === 0) {
				return new ___R$project$rome$$internal$js$analysis$types$StringT_ts$default(
					this.scope,
					this.originNode,
				);
			} else {
				return this.scope.createUnion(possibleTypes, this.originNode);
			}
		}
	}
	___R$project$rome$$internal$js$analysis$types$TypeofT_ts$default.type = "TypeofT";


  // project-rome/@internal/js-analysis/types/SideEffectT.ts
class ___R$project$rome$$internal$js$analysis$types$SideEffectT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		constructor(scope, originNode, actualType) {
			super(scope, originNode);
			this.actualType = actualType;
		}

		reduce() {
			return this.utils.reduce(this.actualType);
		}
	}
	___R$project$rome$$internal$js$analysis$types$SideEffectT_ts$default.type = "SideEffectT";


  // project-rome/@internal/js-analysis/types/BlockT.ts
class ___R$project$rome$$internal$js$analysis$types$BlockT_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$T_ts$default {
		constructor(scope, originNode, body) {
			super(scope, originNode);
			this.body = body;
		}

		reduce() {
			const body = [];
			let changed = false;

			for (const type of this.body) {
				const reduced = this.utils.reduce(type);
				body.push(reduced);
				if (reduced !== type) {
					changed = true;
				}
			}

			if (changed) {
				return new ___R$project$rome$$internal$js$analysis$types$BlockT_ts$default(
					this.scope,
					this.originNode,
					body,
				);
			} else {
				return this;
			}
		}

		humanize() {
			return ___R$project$rome$$internal$markup$escape_ts$markup`{}`;
		}
	}
	___R$project$rome$$internal$js$analysis$types$BlockT_ts$default.type = "BlockT";


  // project-rome/@internal/js-analysis/types/errors/UndeclaredVarE.ts
class ___R$project$rome$$internal$js$analysis$types$errors$UndeclaredVarE_ts$default
		extends ___R$project$rome$$internal$js$analysis$types$errors$E_ts$default {
		constructor(scope, originNode, name) {
			super(scope, originNode);
			this.name = name;
		}

		getError() {
			const possibleNames = this.scope.getBindingNames();
			return {
				description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.TYPE_CHECK.UNDECLARED_VARIABLE(
					this.name,
					possibleNames,
				),
				lowerTarget: this,
			};
		}
	}
	___R$project$rome$$internal$js$analysis$types$errors$UndeclaredVarE_ts$default.type = "UndeclaredVarE";


  // project-rome/@internal/js-analysis/types/index.ts
const ___R$project$rome$$internal$js$analysis$types$index_ts = {
		get default() {
			return ___R$project$rome$$internal$js$analysis$types$index_ts$default;
		},
	};
	// rome-ignore lint/ts/noExplicitAny: future cleanup
	const ___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
		"types",
	);
	const ___R$project$rome$$internal$js$analysis$types$index_ts$default = ___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types;
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"AnyT",
		___R$project$rome$$internal$js$analysis$types$AnyT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"BooleanLiteralT",
		___R$project$rome$$internal$js$analysis$types$BooleanLiteralT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"BooleanT",
		___R$project$rome$$internal$js$analysis$types$BooleanT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"CallT",
		___R$project$rome$$internal$js$analysis$types$CallT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"ClassT",
		___R$project$rome$$internal$js$analysis$types$ClassT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"EmptyT",
		___R$project$rome$$internal$js$analysis$types$EmptyT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"FunctionT",
		___R$project$rome$$internal$js$analysis$types$FunctionT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"GetPropT",
		___R$project$rome$$internal$js$analysis$types$GetPropT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"IntersectionT",
		___R$project$rome$$internal$js$analysis$types$IntersectionT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"MaybeT",
		___R$project$rome$$internal$js$analysis$types$MaybeT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"MixedT",
		___R$project$rome$$internal$js$analysis$types$MixedT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"NullT",
		___R$project$rome$$internal$js$analysis$types$NullT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"NumericLiteralT",
		___R$project$rome$$internal$js$analysis$types$NumericLiteralT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"NumericT",
		___R$project$rome$$internal$js$analysis$types$NumericT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"ObjPropT",
		___R$project$rome$$internal$js$analysis$types$ObjPropT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"ObjT",
		___R$project$rome$$internal$js$analysis$types$ObjT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"OpenIntrinsicT",
		___R$project$rome$$internal$js$analysis$types$OpenIntrinsicT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"ImportT",
		___R$project$rome$$internal$js$analysis$types$ImportT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"OpenT",
		___R$project$rome$$internal$js$analysis$types$OpenT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"StringLiteralT",
		___R$project$rome$$internal$js$analysis$types$StringLiteralT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"StringT",
		___R$project$rome$$internal$js$analysis$types$StringT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"UnionT",
		___R$project$rome$$internal$js$analysis$types$UnionT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"UnknownT",
		___R$project$rome$$internal$js$analysis$types$UnknownT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"VoidT",
		___R$project$rome$$internal$js$analysis$types$VoidT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"ExhaustiveT",
		___R$project$rome$$internal$js$analysis$types$ExhaustiveT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"InstanceT",
		___R$project$rome$$internal$js$analysis$types$InstanceT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"GenericT",
		___R$project$rome$$internal$js$analysis$types$GenericT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"ObjIndexPropT",
		___R$project$rome$$internal$js$analysis$types$ObjIndexPropT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"BinaryOpT",
		___R$project$rome$$internal$js$analysis$types$BinaryOpT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"RefinedT",
		___R$project$rome$$internal$js$analysis$types$RefinedT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"RefineTypeofT",
		___R$project$rome$$internal$js$analysis$types$RefineTypeofT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"TypeofT",
		___R$project$rome$$internal$js$analysis$types$TypeofT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"SideEffectT",
		___R$project$rome$$internal$js$analysis$types$SideEffectT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"BlockT",
		___R$project$rome$$internal$js$analysis$types$BlockT_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"E",
		___R$project$rome$$internal$js$analysis$types$errors$E_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"NotCallableE",
		___R$project$rome$$internal$js$analysis$types$errors$NotCallableE_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"UndeclaredVarE",
		___R$project$rome$$internal$js$analysis$types$errors$UndeclaredVarE_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"UnknownPropE",
		___R$project$rome$$internal$js$analysis$types$errors$UnknownPropE_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"UnknownImportE",
		___R$project$rome$$internal$js$analysis$types$errors$UnknownImportE_ts$default,
	);
	___R$$priv$project$rome$$internal$js$analysis$types$index_ts$types.set(
		"MissingUnionE",
		___R$project$rome$$internal$js$analysis$types$errors$MissingUnionE_ts$default,
	);


  // project-rome/@internal/js-analysis/evaluators/temp/JSAmbiguousFlowTypeCastExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$temp$JSAmbiguousFlowTypeCastExpression_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$temp$JSAmbiguousFlowTypeCastExpression_ts$jsAmbiguousFlowTypeCastExpression.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/expressions/JSArrayExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$expressions$JSArrayExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$expressions$JSArrayExpression_ts$jsArrayExpression.assert(
			node,
		);
		const elems = [];

		for (const expr of node.elements) {
			if (expr === undefined) {
				// TODO array hole, add undefined here
			} else {
				elems.push(scope.evaluate(expr));
			}
		}

		let value;
		if (elems.length === 0) {
			value = new ___R$project$rome$$internal$js$analysis$types$OpenT_ts$default(
				scope,
				node,
			);
		} else {
			value = scope.createUnion(elems, node);
		}
		return new ___R$project$rome$$internal$js$analysis$types$InstanceT_ts$default(
			scope,
			node,
			scope.intrinsics.Array,
			[value],
		);
	}


  // project-rome/@internal/js-analysis/evaluators/auxiliary/JSArrayHole.ts
function ___R$project$rome$$internal$js$analysis$evaluators$auxiliary$JSArrayHole_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$auxiliary$JSArrayHole_ts$jsArrayHole.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/utils/executeAtom.ts
function ___R$project$rome$$internal$js$analysis$utils$executeAtom_ts$default(
		leftNode,
		rightType,
		scope,
	) {
		switch (leftNode.type) {
			case "JSBindingIdentifier": {
				scope.addBinding(leftNode.name, rightType);
				break;
			}

			case "JSBindingObjectPattern": {
				for (const prop of leftNode.properties) {
					___R$project$rome$$internal$js$analysis$utils$executeAtom_ts$default(
						prop,
						rightType,
						scope,
					);
				}
				break;
			}

			case "JSBindingObjectPatternProperty": {
				const {key} = leftNode;
				if (
					key.type === "JSComputedPropertyKey" ||
					key.value.type !== "JSIdentifier"
				) {
					throw new Error("unimplemented");
				}

				const propKey = new ___R$project$rome$$internal$js$analysis$types$StringLiteralT_ts$default(
					scope,
					key,
					key.value.name,
				);
				const getProp = new ___R$project$rome$$internal$js$analysis$types$GetPropT_ts$default(
					scope,
					leftNode,
					rightType,
					propKey,
				);
				___R$project$rome$$internal$js$analysis$utils$executeAtom_ts$default(
					leftNode.value,
					getProp,
					scope,
				);
				break;
			}

			case "JSBindingArrayPattern": {
				for (let i = 0; i < leftNode.elements.length; i++) {
					const elem = leftNode.elements[i];
					if (elem === undefined) {
						continue;
					}

					const propKey = new ___R$project$rome$$internal$js$analysis$types$NumericLiteralT_ts$default(
						scope,
						elem,
						i,
					);
					const getProp = new ___R$project$rome$$internal$js$analysis$types$GetPropT_ts$default(
						scope,
						leftNode,
						rightType,
						propKey,
					);
					___R$project$rome$$internal$js$analysis$utils$executeAtom_ts$default(
						elem,
						getProp,
						scope,
					);
				}
				break;
			}

			case "JSBindingAssignmentPattern": {
				___R$project$rome$$internal$js$analysis$utils$executeAtom_ts$default(
					leftNode.left,
					rightType,
					scope,
				);
				break;
			}
		}
	}


  // project-rome/@internal/js-analysis/utils/executeFunction.ts
function ___R$project$rome$$internal$js$analysis$utils$executeFunction_ts$default(
		node,
		scope,
		bindId,
		thisContext,
	) {
		const {head} = node;

		// build return type
		const returns = new ___R$project$rome$$internal$js$analysis$types$OpenT_ts$default(
			scope,
			head.returnType ? head.returnType : node,
		);

		// type check the body
		const bodyScope = new ___R$project$rome$$internal$js$analysis$scopes_ts$FunctionScope(
			{
				parentScope: scope,
			},
			{
				thisContext: thisContext
					? thisContext
					: new ___R$project$rome$$internal$js$analysis$types$VoidT_ts$default(
							scope,
							undefined,
						),
				returnType: returns,
			},
		);
		if (head.typeParameters) {
			bodyScope.evaluate(head.typeParameters);
		}

		// build param types
		const params = [];
		let rest;
		for (let paramNode of head.params) {
			let optional =
				paramNode.meta !== undefined && paramNode.meta.optional === true;
			if (paramNode.type === "JSBindingAssignmentPattern") {
				optional = false;
				paramNode = paramNode.left;
			}

			let paramType;
			if (
				paramNode.meta !== undefined &&
				paramNode.meta.typeAnnotation !== undefined
			) {
				paramType = scope.evaluate(paramNode.meta.typeAnnotation);
			} else {
				paramType = new ___R$project$rome$$internal$js$analysis$types$OpenT_ts$default(
					scope,
					paramNode,
				);
			}

			if (optional) {
				paramType = new ___R$project$rome$$internal$js$analysis$types$MaybeT_ts$default(
					scope,
					paramNode,
					paramType,
				);
			}

			params.push(paramType);
		}

		for (let i = 0; i < head.params.length; i++) {
			___R$project$rome$$internal$js$analysis$utils$executeAtom_ts$default(
				head.params[i],
				params[i],
				scope,
			);
		}
		const block = bodyScope.evaluate(node.body);

		// if no types have flowed into the return type then it'll return undefined
		if (!returns.hasConnections()) {
			//const ret = new VoidT(scope, node);
			//returns.shouldMatch(ret);
		}

		if (head.returnType) {
			returns.shouldMatch(scope.evaluate(head.returnType));
		}

		// create the function
		return new ___R$project$rome$$internal$js$analysis$types$FunctionT_ts$default(
			scope,
			node,
			{params, rest, returns, body: block},
		);
	}


  // project-rome/@internal/js-analysis/evaluators/expressions/JSArrowFunctionExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$expressions$JSArrowFunctionExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$expressions$JSArrowFunctionExpression_ts$jsArrowFunctionExpression.assert(
			node,
		);

		let thisContext;
		const funcScope = scope.findOptional(
			___R$project$rome$$internal$js$analysis$scopes_ts$FunctionScope,
		);
		if (funcScope !== undefined) {
			thisContext = funcScope.meta.thisContext;
		}

		return ___R$project$rome$$internal$js$analysis$utils$executeFunction_ts$default(
			node,
			scope,
			true,
			thisContext,
		);
	}


  // project-rome/@internal/js-analysis/evaluators/patterns/JSAssignmentArrayPattern.ts
function ___R$project$rome$$internal$js$analysis$evaluators$patterns$JSAssignmentArrayPattern_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$patterns$JSAssignmentArrayPattern_ts$jsAssignmentArrayPattern.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/patterns/JSAssignmentAssignmentPattern.ts
function ___R$project$rome$$internal$js$analysis$evaluators$patterns$JSAssignmentAssignmentPattern_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$patterns$JSAssignmentAssignmentPattern_ts$jsAssignmentAssignmentPattern.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/expressions/JSAssignmentExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$expressions$JSAssignmentExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$expressions$JSAssignmentExpression_ts$jsAssignmentExpression.assert(
			node,
		);

		const {left, right, operator} = node;

		if (operator === "=") {
			const rightType = scope.evaluate(right);
			const leftType = scope.evaluate(left);
			leftType.shouldMatch(rightType);
			return new ___R$project$rome$$internal$js$analysis$types$SideEffectT_ts$default(
				scope,
				node,
				rightType,
			);
		} else {
			// TODO!
			return undefined;
		}
	}


  // project-rome/@internal/js-analysis/evaluators/patterns/JSAssignmentIdentifier.ts
function ___R$project$rome$$internal$js$analysis$evaluators$patterns$JSAssignmentIdentifier_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$patterns$JSAssignmentIdentifier_ts$jsAssignmentIdentifier.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/patterns/JSAssignmentObjectPattern.ts
function ___R$project$rome$$internal$js$analysis$evaluators$patterns$JSAssignmentObjectPattern_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$patterns$JSAssignmentObjectPattern_ts$jsAssignmentObjectPattern.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/patterns/JSAssignmentObjectPatternProperty.ts
function ___R$project$rome$$internal$js$analysis$evaluators$patterns$JSAssignmentObjectPatternProperty_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$patterns$JSAssignmentObjectPatternProperty_ts$jsAssignmentObjectPatternProperty.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/expressions/JSAwaitExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$expressions$JSAwaitExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$expressions$JSAwaitExpression_ts$jsAwaitExpression.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/literals/JSBigIntLiteral.ts
function ___R$project$rome$$internal$js$analysis$evaluators$literals$JSBigIntLiteral_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$literals$JSBigIntLiteral_ts$jsBigIntLiteral.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/expressions/JSBinaryExpression.ts
function ___R$$priv$project$rome$$internal$js$analysis$evaluators$expressions$JSBinaryExpression_ts$maybeRefine(
		node,
		left,
		right,
		scope,
	) {
		const evaluator = scope.evaluator;

		if (left.type === "JSIdentifier") {
			scope.addBinding(left.name, evaluator.getTypeFromEvaluatedNode(right));
			return true;
		}

		if (
			left.type === "JSUnaryExpression" &&
			left.operator === "typeof" &&
			left.argument.type === "JSReferenceIdentifier"
		) {
			const name = left.argument.name;
			const binding = scope.getBinding(name);
			if (binding !== undefined) {
				const type = new ___R$project$rome$$internal$js$analysis$types$RefineTypeofT_ts$default(
					scope,
					node,
					evaluator.getTypeFromEvaluatedNode(right),
					binding,
				);
				scope.addBinding(name, type);
				return true;
			}
		}

		return false;
	}

	function ___R$project$rome$$internal$js$analysis$evaluators$expressions$JSBinaryExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$expressions$JSBinaryExpression_ts$jsBinaryExpression.assert(
			node,
		);

		const left = scope.evaluate(node.left);
		const right = scope.evaluate(node.right);

		// Enforce that the left and right sides of these operators are numbers
		switch (node.operator) {
			case "<<":
			case ">>":
			case ">>>":
			case "-":
			case "*":
			case "/":
			case "%":
			case "**":
			case "|":
			case "^":
			case "&":
			case "<":
			case "<=":
			case ">":
			case ">=": {
				const num = new ___R$project$rome$$internal$js$analysis$types$NumericT_ts$default(
					scope,
					undefined,
				);
				new ___R$project$rome$$internal$js$analysis$types$ExhaustiveT_ts$default(
					scope,
					node,
					left,
					num,
				);
				new ___R$project$rome$$internal$js$analysis$types$ExhaustiveT_ts$default(
					scope,
					node,
					right,
					num,
				);
				break;
			}
		}

		// Refinements
		let refinedScope = scope;
		if (node.operator === "===") {
			refinedScope = scope.refine();
			___R$$priv$project$rome$$internal$js$analysis$evaluators$expressions$JSBinaryExpression_ts$maybeRefine(
				node,
				node.left,
				node.right,
				refinedScope,
			) ||
			___R$$priv$project$rome$$internal$js$analysis$evaluators$expressions$JSBinaryExpression_ts$maybeRefine(
				node,
				node.right,
				node.left,
				refinedScope,
			);
		}

		return new ___R$project$rome$$internal$js$analysis$types$BinaryOpT_ts$default(
			refinedScope,
			node,
			left,
			node.operator,
			right,
		);
	}


  // project-rome/@internal/js-analysis/evaluators/patterns/JSBindingArrayPattern.ts
function ___R$project$rome$$internal$js$analysis$evaluators$patterns$JSBindingArrayPattern_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$patterns$JSBindingArrayPattern_ts$jsBindingArrayPattern.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/patterns/JSBindingAssignmentPattern.ts
function ___R$project$rome$$internal$js$analysis$evaluators$patterns$JSBindingAssignmentPattern_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$patterns$JSBindingAssignmentPattern_ts$jsBindingAssignmentPattern.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/patterns/JSBindingIdentifier.ts
function ___R$project$rome$$internal$js$analysis$evaluators$patterns$JSBindingIdentifier_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$patterns$JSBindingIdentifier_ts$jsBindingIdentifier.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/patterns/JSBindingObjectPattern.ts
function ___R$project$rome$$internal$js$analysis$evaluators$patterns$JSBindingObjectPattern_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$patterns$JSBindingObjectPattern_ts$jsBindingObjectPattern.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/patterns/JSBindingObjectPatternProperty.ts
function ___R$project$rome$$internal$js$analysis$evaluators$patterns$JSBindingObjectPatternProperty_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$patterns$JSBindingObjectPatternProperty_ts$jsBindingObjectPatternProperty.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/statements/JSBlockStatement.ts
function ___R$$priv$project$rome$$internal$js$analysis$evaluators$statements$JSBlockStatement_ts$shouldHoistExecute(
		node,
	) {
		if (node === undefined) {
			return false;
		}

		if (
			node.type === "JSFunctionDeclaration" ||
			___R$project$rome$$internal$js$ast$utils$isTypeNode_ts$isTypeNode(node)
		) {
			return true;
		}

		if (
			node.type === "JSExportLocalDeclaration" ||
			node.type === "JSExportDefaultDeclaration"
		) {
			return ___R$$priv$project$rome$$internal$js$analysis$evaluators$statements$JSBlockStatement_ts$shouldHoistExecute(
				node.declaration,
			);
		}

		return false;
	}

	function ___R$project$rome$$internal$js$analysis$evaluators$statements$JSBlockStatement_ts$default(
		node,
		scope,
	) {
		node =
			node.type === "JSRoot"
				? node
				: ___R$project$rome$$internal$ast$js$statements$JSBlockStatement_ts$jsBlockStatement.assert(
						node,
					);

		// Declare variables
		for (const child of node.body) {
			if (child.type === "JSImportDeclaration") {
				scope.evaluate(child);
			}

			const declarations = ___R$project$rome$$internal$js$ast$utils$getBindingIdentifiers_ts$getBindingIdentifiers(
				child,
			);
			for (const id of declarations) {
				scope.declareBinding(id.name, id);
			}
		}

		const types = [];

		// Execute hoisted nodes
		const body = [];
		for (const child of node.body) {
			if (child.type === "JSImportDeclaration") {
				// already executed
			} else if (
				___R$$priv$project$rome$$internal$js$analysis$evaluators$statements$JSBlockStatement_ts$shouldHoistExecute(
					child,
				)
			) {
				types.push(scope.evaluate(child));
			} else {
				body.push(child);
			}
		}

		// Execute rest
		for (const child of body) {
			types.push(scope.evaluate(child));
		}

		return new ___R$project$rome$$internal$js$analysis$types$BlockT_ts$default(
			scope,
			node,
			types,
		);
	}


  // project-rome/@internal/js-analysis/evaluators/literals/JSBooleanLiteral.ts
function ___R$project$rome$$internal$js$analysis$evaluators$literals$JSBooleanLiteral_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$literals$JSBooleanLiteral_ts$jsBooleanLiteral.assert(
			node,
		);
		return new ___R$project$rome$$internal$js$analysis$types$BooleanLiteralT_ts$default(
			scope,
			node,
			node.value,
		);
	}


  // project-rome/@internal/js-analysis/evaluators/statements/JSBreakStatement.ts
function ___R$project$rome$$internal$js$analysis$evaluators$statements$JSBreakStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$statements$JSBreakStatement_ts$jsBreakStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/expressions/JSCallExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$expressions$JSCallExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$expressions$JSCallExpression_ts$jsCallExpression.assert(
			node,
		);

		return new ___R$project$rome$$internal$js$analysis$types$CallT_ts$default(
			scope,
			node,
			scope.evaluate(node.callee),
			node.arguments.map((arg) => {
				return scope.evaluate(arg);
			}),
		);
	}


  // project-rome/@internal/js-analysis/evaluators/auxiliary/JSCatchClause.ts
function ___R$project$rome$$internal$js$analysis$evaluators$auxiliary$JSCatchClause_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$auxiliary$JSCatchClause_ts$jsCatchClause.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/classes/JSClassExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$classes$JSClassExpression_ts$default(
		node,
		scope,
	) {
		node =
			node.type === "JSClassDeclaration"
				? node
				: ___R$project$rome$$internal$ast$js$classes$JSClassExpression_ts$jsClassExpression.assert(
						node,
					);

		const instances = [];
		const statics = [];

		//
		const classInstance = new ___R$project$rome$$internal$js$analysis$types$OpenT_ts$default(
			scope,
			node,
		);
		const classId = new ___R$project$rome$$internal$js$analysis$types$OpenT_ts$default(
			scope,
			node,
		);

		//
		const bodyScope = new ___R$project$rome$$internal$js$analysis$scopes_ts$ClassScope(
			{parentScope: scope},
			{
				instance: classInstance,
				static: classId,
			},
		);

		if (node.id !== undefined) {
			bodyScope.addBinding(node.id.name, classId);
		}

		if (node.meta.typeParameters !== undefined) {
			bodyScope.evaluate(node.meta.typeParameters);
		}

		let _constructor = undefined;

		for (const bodyNode of node.meta.body) {
			const type = bodyScope.evaluate(bodyNode);

			if (bodyNode.type === "JSClassMethod" && bodyNode.kind === "constructor") {
				_constructor = type;
			} else {
				if (
					bodyNode.type !== "TSIndexSignature" &&
					bodyNode.meta.static === true
				) {
					statics.push(type);
				} else {
					instances.push(type);
				}
			}
		}

		//
		const classOrigin = node.id ? node.id : node;
		let type = new ___R$project$rome$$internal$js$analysis$types$ClassT_ts$default(
			scope,
			classOrigin,
			{
				_constructor,
				instances,
				statics,
				extends: node.meta.superClass
					? scope.evaluate(node.meta.superClass)
					: undefined,
			},
		);
		if (node.id) {
			type.setHuman(
				___R$project$rome$$internal$markup$escape_ts$markup`${node.id.name}`,
			);
		}

		//
		classId.shouldMatch(type);

		//
		const instance = new ___R$project$rome$$internal$js$analysis$types$InstanceT_ts$default(
			scope,
			classOrigin,
			type,
			[],
		);
		classInstance.shouldMatch(instance);

		return type;
	}


  // project-rome/@internal/js-analysis/evaluators/classes/JSClassDeclaration.ts
function ___R$project$rome$$internal$js$analysis$evaluators$classes$JSClassDeclaration_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$classes$JSClassDeclaration_ts$jsClassDeclaration.assert(
			node,
		);
		const type = ___R$project$rome$$internal$js$analysis$evaluators$classes$JSClassExpression_ts$default(
			node,
			scope,
		);
		if (node.id) {
			scope.addBinding(node.id.name, type);
		}
		return type;
	}


  // project-rome/@internal/js-analysis/evaluators/classes/JSClassHead.ts
function ___R$project$rome$$internal$js$analysis$evaluators$classes$JSClassHead_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$classes$JSClassHead_ts$jsClassHead.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/classes/JSClassMethod.ts
function ___R$project$rome$$internal$js$analysis$evaluators$classes$JSClassMethod_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$classes$JSClassMethod_ts$jsClassMethod.assert(
			node,
		);
		if (node.key.type === "JSComputedPropertyKey") {
			// TODO
			return undefined;
		}

		const classScope = scope.find(
			___R$project$rome$$internal$js$analysis$scopes_ts$ClassScope,
		);
		const thisContext =
			node.meta.static === true
				? classScope.meta.static
				: classScope.meta.instance;
		const func = ___R$project$rome$$internal$js$analysis$utils$executeFunction_ts$default(
			node,
			scope,
			false,
			thisContext,
		);

		if (node.key.value.type !== "JSIdentifier") {
			throw new Error("Expected only an jsIdentifier key");
		}
		return new ___R$project$rome$$internal$js$analysis$types$ObjPropT_ts$default(
			scope,
			node,
			node.key.value.name,
			func,
		);
	}


  // project-rome/@internal/js-analysis/evaluators/classes/JSClassPrivateMethod.ts
function ___R$project$rome$$internal$js$analysis$evaluators$classes$JSClassPrivateMethod_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$classes$JSClassPrivateMethod_ts$jsClassPrivateMethod.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/classes/JSClassPrivateProperty.ts
function ___R$project$rome$$internal$js$analysis$evaluators$classes$JSClassPrivateProperty_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$classes$JSClassPrivateProperty_ts$jsClassPrivateProperty.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/classes/JSClassProperty.ts
function ___R$project$rome$$internal$js$analysis$evaluators$classes$JSClassProperty_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$classes$JSClassProperty_ts$jsClassProperty.assert(
			node,
		);

		if (node.key.type === "JSComputedPropertyKey") {
			// TODO
			return undefined;
		}

		const classScope = scope.find(
			___R$project$rome$$internal$js$analysis$scopes_ts$ClassScope,
		);
		const funcScope = new ___R$project$rome$$internal$js$analysis$scopes_ts$ThisScope(
			{parentScope: scope},
			classScope.meta.instance,
		);

		let annotatedType;
		let inferredType;

		if (node.typeAnnotation) {
			annotatedType = funcScope.evaluate(node.typeAnnotation);
		}

		if (node.value) {
			inferredType = funcScope.evaluate(node.value);

			if (annotatedType !== undefined) {
				inferredType.shouldMatch(annotatedType);
			}
		}

		if (annotatedType === undefined && inferredType === undefined) {
			// TODO what do we do here?
			inferredType = new ___R$project$rome$$internal$js$analysis$types$AnyT_ts$default(
				scope,
				node,
			);
		}

		const actualValue =
			annotatedType === undefined ? inferredType : annotatedType;
		if (actualValue === undefined) {
			throw new Error("Expected actual value");
		}

		if (node.key.value.type !== "JSIdentifier") {
			throw new Error("Expected only an jsIdentifier key");
		}

		return new ___R$project$rome$$internal$js$analysis$types$ObjPropT_ts$default(
			scope,
			node,
			node.key.value.name,
			actualValue,
		);
	}


  // project-rome/@internal/js-analysis/evaluators/classes/JSClassPropertyMeta.ts
function ___R$project$rome$$internal$js$analysis$evaluators$classes$JSClassPropertyMeta_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$classes$JSClassPropertyMeta_ts$jsClassPropertyMeta.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/auxiliary/JSComputedMemberProperty.ts
function ___R$project$rome$$internal$js$analysis$evaluators$auxiliary$JSComputedMemberProperty_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$auxiliary$JSComputedMemberProperty_ts$jsComputedMemberProperty.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/objects/JSComputedPropertyKey.ts
function ___R$project$rome$$internal$js$analysis$evaluators$objects$JSComputedPropertyKey_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$objects$JSComputedPropertyKey_ts$jsComputedPropertyKey.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/statements/JSIfStatement.ts
function ___R$project$rome$$internal$js$analysis$evaluators$statements$JSIfStatement_ts$default(
		node,
		scope,
	) {
		node =
			node.type === "JSConditionalExpression"
				? node
				: ___R$project$rome$$internal$ast$js$statements$JSIfStatement_ts$jsIfStatement.assert(
						node,
					);

		const test = scope.evaluate(node.test);
		new ___R$project$rome$$internal$js$analysis$types$ExhaustiveT_ts$default(
			scope,
			node,
			test,
			new ___R$project$rome$$internal$js$analysis$types$BooleanT_ts$default(
				scope,
				undefined,
			),
		);

		const hasRefinedTest =
			test.scope instanceof
			___R$project$rome$$internal$js$analysis$scopes_ts$RefineScope;

		const consequentScope = hasRefinedTest ? test.scope : scope;
		const consequent = consequentScope.evaluate(node.consequent);

		if (node.alternate === undefined) {
			return consequent;
		} else {
			const alternateScope = scope.fork();

			/*if (hasRefinedTest) {
      // get bindings from 'test.scope and flip them
      for (const name of test.scope.getOwnBindingNames()) {
        const outerBinding = scope.getBinding(name);
        invariant(outerBinding !== undefined, 'expected outerBinding for %s', name);

        const refinedBinding = test.scope.getBinding(name);
        invariant(refinedBinding !== undefined, 'expected refinedBinding for %s', name);

        const opposite = new RefinedT(alternateScope, refinedBinding.originNode, outerBinding, refinedBinding);
        alternateScope.addBinding(name, opposite);
      }
    }*/
			return new ___R$project$rome$$internal$js$analysis$types$UnionT_ts$default(
				scope,
				undefined,
				[consequent, alternateScope.evaluate(node.alternate)],
			);
		}
	}


  // project-rome/@internal/js-analysis/evaluators/expressions/JSConditionalExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$expressions$JSConditionalExpression_ts$default(
		node,
		scope,
	) {
		return ___R$project$rome$$internal$js$analysis$evaluators$statements$JSIfStatement_ts$default(
			node,
			scope,
		);
	}


  // project-rome/@internal/js-analysis/evaluators/statements/JSContinueStatement.ts
function ___R$project$rome$$internal$js$analysis$evaluators$statements$JSContinueStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$statements$JSContinueStatement_ts$jsContinueStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/statements/JSDebuggerStatement.ts
function ___R$project$rome$$internal$js$analysis$evaluators$statements$JSDebuggerStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$statements$JSDebuggerStatement_ts$jsDebuggerStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/core/JSDirective.ts
function ___R$project$rome$$internal$js$analysis$evaluators$core$JSDirective_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$core$JSDirective_ts$jsDirective.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/expressions/JSDoExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$expressions$JSDoExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$expressions$JSDoExpression_ts$jsDoExpression.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/statements/JSDoWhileStatement.ts
function ___R$project$rome$$internal$js$analysis$evaluators$statements$JSDoWhileStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$statements$JSDoWhileStatement_ts$jsDoWhileStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/statements/JSEmptyStatement.ts
function ___R$project$rome$$internal$js$analysis$evaluators$statements$JSEmptyStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$statements$JSEmptyStatement_ts$jsEmptyStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/modules/JSExportAllDeclaration.ts
function ___R$project$rome$$internal$js$analysis$evaluators$modules$JSExportAllDeclaration_ts$default(
		node,
		scope,
		{evaluator},
	) {
		node = ___R$project$rome$$internal$ast$js$modules$JSExportAllDeclaration_ts$jsExportAllDeclaration.assert(
			node,
		);
		evaluator.addExportAll(node.source.value);
	}


  // project-rome/@internal/js-analysis/evaluators/modules/JSExportDefaultDeclaration.ts
function ___R$project$rome$$internal$js$analysis$evaluators$modules$JSExportDefaultDeclaration_ts$default(
		node,
		scope,
		{evaluator},
	) {
		node = ___R$project$rome$$internal$ast$js$modules$JSExportDefaultDeclaration_ts$jsExportDefaultDeclaration.assert(
			node,
		);

		const decl = node.declaration;
		const declType = scope.evaluate(decl);
		evaluator.addExport("default", declType);
		return declType;
	}


  // project-rome/@internal/js-analysis/evaluators/modules/JSExportDefaultSpecifier.ts
function ___R$project$rome$$internal$js$analysis$evaluators$modules$JSExportDefaultSpecifier_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$modules$JSExportDefaultSpecifier_ts$jsExportDefaultSpecifier.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/modules/JSExportExternalDeclaration.ts
function ___R$project$rome$$internal$js$analysis$evaluators$modules$JSExportExternalDeclaration_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$modules$JSExportExternalDeclaration_ts$jsExportExternalDeclaration.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/modules/JSExportExternalSpecifier.ts
function ___R$project$rome$$internal$js$analysis$evaluators$modules$JSExportExternalSpecifier_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$modules$JSExportExternalSpecifier_ts$jsExportExternalSpecifier.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/modules/JSExportLocalDeclaration.ts
function ___R$project$rome$$internal$js$analysis$evaluators$modules$JSExportLocalDeclaration_ts$default(
		node,
		scope,
		{evaluator},
	) {
		node = ___R$project$rome$$internal$ast$js$modules$JSExportLocalDeclaration_ts$jsExportLocalDeclaration.assert(
			node,
		);

		// export const foo = 'bar';

		// export default function foo() {}
		const decl = node.declaration;
		if (decl !== undefined) {
			const declType = scope.evaluate(decl);

			switch (decl.type) {
				case "JSFunctionDeclaration":
				case "JSClassDeclaration": {
					const id = decl.id;
					if (id === undefined) {
						throw new Error("Expected id");
					}
					evaluator.addExport(id.name, declType);
					break;
				}

				case "JSVariableDeclarationStatement": {
					for (const id of ___R$project$rome$$internal$js$ast$utils$getBindingIdentifiers_ts$getBindingIdentifiers(
						decl,
					)) {
						const type = scope.getBinding(id.name);
						if (type === undefined) {
							throw new Error("Couldn't find binding type for " + id.name);
						}
						evaluator.addExport(id.name, type);
					}
					break;
				}

				case "TSTypeAlias": {
					const type = scope.getBinding(decl.id.name);
					if (type === undefined) {
						throw new Error("Couldn't find binding type for " + decl.id.name);
					}
					evaluator.addExport(decl.id.name, type);
					break;
				}
			}

			return declType;
		}

		// export {foo, bar};

		// export {foo, bar} from './foo';
		const source = undefined; // TODO node.source === undefined ? undefined : node.source.value;
		const {specifiers} = node;
		if (specifiers !== undefined) {
			for (const specifier of specifiers) {
				if (
					specifier.type === "JSExportLocalSpecifier" ||
					specifier.type === "JSExportExternalSpecifier"
				) {
					let type;
					if (source === undefined) {
						type = scope.evaluate(specifier.local);
					} else {
						type = new ___R$project$rome$$internal$js$analysis$types$ImportT_ts$default(
							scope,
							node,
							{
								importedName: specifier.local.name,
								source,
							},
						);
					}
					evaluator.addExport(specifier.exported.name, type);
				}
			}
		}

		return undefined;
	}


  // project-rome/@internal/js-analysis/evaluators/modules/JSExportLocalSpecifier.ts
function ___R$project$rome$$internal$js$analysis$evaluators$modules$JSExportLocalSpecifier_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$modules$JSExportLocalSpecifier_ts$jsExportLocalSpecifier.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/modules/JSExportNamespaceSpecifier.ts
function ___R$project$rome$$internal$js$analysis$evaluators$modules$JSExportNamespaceSpecifier_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$modules$JSExportNamespaceSpecifier_ts$jsExportNamespaceSpecifier.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/statements/JSExpressionStatement.ts
function ___R$project$rome$$internal$js$analysis$evaluators$statements$JSExpressionStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$statements$JSExpressionStatement_ts$jsExpressionStatement.assert(
			node,
		);

		return scope.evaluate(node.expression);
	}


  // project-rome/@internal/js-analysis/evaluators/statements/JSForInStatement.ts
function ___R$project$rome$$internal$js$analysis$evaluators$statements$JSForInStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$statements$JSForInStatement_ts$jsForInStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/statements/JSForOfStatement.ts
function ___R$project$rome$$internal$js$analysis$evaluators$statements$JSForOfStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$statements$JSForOfStatement_ts$jsForOfStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/statements/JSForStatement.ts
function ___R$project$rome$$internal$js$analysis$evaluators$statements$JSForStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$statements$JSForStatement_ts$jsForStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/statements/JSFunctionDeclaration.ts
function ___R$project$rome$$internal$js$analysis$evaluators$statements$JSFunctionDeclaration_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$statements$JSFunctionDeclaration_ts$jsFunctionDeclaration.assert(
			node,
		);

		const func = ___R$project$rome$$internal$js$analysis$utils$executeFunction_ts$default(
			node,
			scope,
			false,
		);
		if (node.id !== undefined) {
			scope.addBinding(node.id.name, func);
		}
		return func;
	}


  // project-rome/@internal/js-analysis/evaluators/expressions/JSFunctionExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$expressions$JSFunctionExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$expressions$JSFunctionExpression_ts$jsFunctionExpression.assert(
			node,
		);
		return ___R$project$rome$$internal$js$analysis$utils$executeFunction_ts$default(
			node,
			scope,
			true,
		);
	}


  // project-rome/@internal/js-analysis/evaluators/auxiliary/JSFunctionHead.ts
function ___R$project$rome$$internal$js$analysis$evaluators$auxiliary$JSFunctionHead_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$auxiliary$JSFunctionHead_ts$jsFunctionHead.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/auxiliary/JSIdentifier.ts
function ___R$project$rome$$internal$js$analysis$evaluators$auxiliary$JSIdentifier_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$auxiliary$JSIdentifier_ts$jsIdentifier.assert(
			node,
		);

		const binding = scope.getBinding(node.name);
		if (binding) {
			const type = new ___R$project$rome$$internal$js$analysis$types$OpenT_ts$default(
				scope,
				node,
			);
			type.shouldMatch(binding);
			return type;
		} else {
			switch (node.name) {
				case "React$PropType$Primitive":
				case "React$PropType$ArrayOf":
				case "React$PropType$InstanceOf":
				case "React$PropType$ObjectOf":
				case "React$PropType$OneOf":
				case "React$PropType$OneOfType":
				case "React$PropTypePartial":
				case "React$ElementProps":
				case "React$ElementRef":
				case "$Exact":
				case "Partial":
				case "$Keys":
				case "Object$Assign":
				case "Object$GetPrototypeOf":
				case "Object$SetPrototypeOf":
				case "$CharSet":
				case "Class":
				case "$Compose":
				case "$ComposeReverse":
				case "$Subtype":
				case "Function$Prototype$Apply":
				case "Function$Prototype$Bind":
				case "Function$Prototype$Call":
				case "$Exports":
					return new ___R$project$rome$$internal$js$analysis$types$AnyT_ts$default(
						scope,
						node,
					);

				default:
					return new ___R$project$rome$$internal$js$analysis$types$errors$UndeclaredVarE_ts$default(
						scope,
						node,
						node.name,
					);
			}
		}
	}


  // project-rome/@internal/js-analysis/evaluators/modules/JSImportCall.ts
function ___R$project$rome$$internal$js$analysis$evaluators$modules$JSImportCall_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$modules$JSImportCall_ts$jsImportCall.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/modules/JSImportDeclaration.ts
function ___R$project$rome$$internal$js$analysis$evaluators$modules$JSImportDeclaration_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$modules$JSImportDeclaration_ts$jsImportDeclaration.assert(
			node,
		);

		const source = node.source.value;

		for (const specifier of ___R$project$rome$$internal$js$ast$utils$getImportSpecifiers_ts$getImportSpecifiers(
			node,
		)) {
			if (specifier.type === "JSImportSpecifier") {
				const localName = specifier.local.name.name;
				const importedName = specifier.imported.name;

				const open = new ___R$project$rome$$internal$js$analysis$types$ImportT_ts$default(
					scope,
					specifier,
					{
						importedName,
						source,
					},
				);
				scope.addBinding(localName, open);
			} else if (specifier.type === "JSImportDefaultSpecifier") {
				const localName = specifier.local.name.name;
				const open = new ___R$project$rome$$internal$js$analysis$types$ImportT_ts$default(
					scope,
					specifier,
					{
						importedName: "default",
						source,
					},
				);
				scope.addBinding(localName, open);
			} else if (specifier.type === "JSImportNamespaceSpecifier") {
				const localName = specifier.local.name.name;
				const open = new ___R$project$rome$$internal$js$analysis$types$ImportT_ts$default(
					scope,
					specifier,
					{
						importedName: undefined,
						source,
					},
				);
				scope.addBinding(localName, open);
			} else {
				// TODO error
			}
		}
	}


  // project-rome/@internal/js-analysis/evaluators/modules/JSImportDefaultSpecifier.ts
function ___R$project$rome$$internal$js$analysis$evaluators$modules$JSImportDefaultSpecifier_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$modules$JSImportDefaultSpecifier_ts$jsImportDefaultSpecifier.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/modules/JSImportNamespaceSpecifier.ts
function ___R$project$rome$$internal$js$analysis$evaluators$modules$JSImportNamespaceSpecifier_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$modules$JSImportNamespaceSpecifier_ts$jsImportNamespaceSpecifier.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/modules/JSImportSpecifier.ts
function ___R$project$rome$$internal$js$analysis$evaluators$modules$JSImportSpecifier_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$modules$JSImportSpecifier_ts$jsImportSpecifier.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/modules/JSImportSpecifierLocal.ts
function ___R$project$rome$$internal$js$analysis$evaluators$modules$JSImportSpecifierLocal_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$modules$JSImportSpecifierLocal_ts$jsImportSpecifierLocal.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/core/JSInterpreterDirective.ts
function ___R$project$rome$$internal$js$analysis$evaluators$core$JSInterpreterDirective_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$core$JSInterpreterDirective_ts$jsInterpreterDirective.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/statements/JSLabeledStatement.ts
function ___R$project$rome$$internal$js$analysis$evaluators$statements$JSLabeledStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$statements$JSLabeledStatement_ts$jsLabeledStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/expressions/JSLogicalExpression.ts
function ___R$$priv$project$rome$$internal$js$analysis$evaluators$expressions$JSLogicalExpression_ts$uniq(
		args,
	) {
		return [...new Set(args)];
	}

	function ___R$project$rome$$internal$js$analysis$evaluators$expressions$JSLogicalExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$expressions$JSLogicalExpression_ts$jsLogicalExpression.assert(
			node,
		);

		switch (node.operator) {
			case "||": {
				const left = scope.refine().evaluate(node.left);
				const right = scope.refine().evaluate(node.right);

				// create a new scope that has unions of all the refined bindings
				const refinedScope = scope.refine();
				const refinedNames = ___R$$priv$project$rome$$internal$js$analysis$evaluators$expressions$JSLogicalExpression_ts$uniq([
					...left.scope.getOwnBindingNames(),
					...right.scope.getOwnBindingNames(),
				]);
				const mergeScopes = [left.scope, right.scope];
				for (const name of refinedNames) {
					const rawTypes = new Set();
					for (const scope of mergeScopes) {
						const binding = scope.getBinding(name);
						if (binding !== undefined) {
							rawTypes.add(binding);
						}
					}

					const types = Array.from(rawTypes);
					refinedScope.addBinding(name, refinedScope.createUnion(types));
				}

				return new ___R$project$rome$$internal$js$analysis$types$UnionT_ts$default(
					refinedScope,
					node,
					[left, right],
				);
			}

			case "&&": {
				const left = scope.evaluate(node.left);
				const right = left.scope.evaluate(node.right);
				return new ___R$project$rome$$internal$js$analysis$types$UnionT_ts$default(
					right.scope,
					node,
					[left, right],
				);
			}

			default:
				throw new Error("Unknown operator");
		}
	}


  // project-rome/@internal/js-analysis/evaluators/expressions/JSMemberExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$expressions$JSMemberExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$expressions$JSMemberExpression_ts$jsMemberExpression.assert(
			node,
		);
		if (node.property.type === "JSComputedMemberProperty") {
			throw new Error("Computed properties not supportd yet");
		}

		if (node.property.value.type === "JSPrivateName") {
			throw new Error("PrivateName in static member not supported yet");
		}

		const prop = new ___R$project$rome$$internal$js$analysis$types$StringLiteralT_ts$default(
			scope,
			node.property.value,
			node.property.value.name,
		);
		return new ___R$project$rome$$internal$js$analysis$types$GetPropT_ts$default(
			scope,
			node,
			scope.evaluate(node.object),
			prop,
		);
	}


  // project-rome/@internal/js-analysis/evaluators/expressions/JSMetaProperty.ts
function ___R$project$rome$$internal$js$analysis$evaluators$expressions$JSMetaProperty_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$expressions$JSMetaProperty_ts$jsMetaProperty.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/expressions/JSNewExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$expressions$JSNewExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$expressions$JSNewExpression_ts$jsNewExpression.assert(
			node,
		);
		return new ___R$project$rome$$internal$js$analysis$types$InstanceT_ts$default(
			scope,
			node,
			scope.evaluate(node.callee),
			[],
		);
	}


  // project-rome/@internal/js-analysis/evaluators/literals/JSNullLiteral.ts
function ___R$project$rome$$internal$js$analysis$evaluators$literals$JSNullLiteral_ts$default(
		node,
		scope,
	) {
		node = node = ___R$project$rome$$internal$ast$js$literals$JSNullLiteral_ts$jsNullLiteral.assert(
			node,
		);
		return new ___R$project$rome$$internal$js$analysis$types$NullT_ts$default(
			scope,
			node,
		);
	}


  // project-rome/@internal/js-analysis/evaluators/literals/JSNumericLiteral.ts
function ___R$project$rome$$internal$js$analysis$evaluators$literals$JSNumericLiteral_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$literals$JSNumericLiteral_ts$jsNumericLiteral.assert(
			node,
		);
		return new ___R$project$rome$$internal$js$analysis$types$NumericLiteralT_ts$default(
			scope,
			node,
			node.value,
		);
	}


  // project-rome/@internal/js-analysis/evaluators/objects/JSObjectExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$objects$JSObjectExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$objects$JSObjectExpression_ts$jsObjectExpression.assert(
			node,
		);
		const props = [];

		for (const prop of node.properties) {
			if (prop.type === "JSSpreadProperty") {
				// TODO
			} else if (prop.type === "JSObjectProperty") {
				if (prop.key.type === "JSComputedPropertyKey") {
					// TODO
				} else {
					const {
						key: {value: key},
						value,
					} = prop;

					let keyStr;
					if (key.type === "JSIdentifier") {
						keyStr = key.name;
					} else {
						// TODO
						continue;
					}

					if (keyStr === undefined) {
						throw new Error("Expected keyStr");
					}

					props.push(
						new ___R$project$rome$$internal$js$analysis$types$ObjPropT_ts$default(
							scope,
							prop,
							keyStr,
							scope.evaluate(value),
						),
					);
				}
			} else {
				// TODO
			}
		}

		return new ___R$project$rome$$internal$js$analysis$types$ObjT_ts$default(
			scope,
			node,
			{
				calls: [],
				props,
				proto: scope.intrinsics.ObjectPrototype,
			},
		);
	}


  // project-rome/@internal/js-analysis/evaluators/objects/JSObjectMethod.ts
function ___R$project$rome$$internal$js$analysis$evaluators$objects$JSObjectMethod_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$objects$JSObjectMethod_ts$jsObjectMethod.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/objects/JSObjectProperty.ts
function ___R$project$rome$$internal$js$analysis$evaluators$objects$JSObjectProperty_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$objects$JSObjectProperty_ts$jsObjectProperty.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/expressions/JSOptionalCallExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$expressions$JSOptionalCallExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$expressions$JSOptionalCallExpression_ts$jsOptionalCallExpression.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/patterns/JSPatternMeta.ts
function ___R$project$rome$$internal$js$analysis$evaluators$patterns$JSPatternMeta_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$patterns$JSPatternMeta_ts$jsPatternMeta.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/classes/JSPrivateName.ts
function ___R$project$rome$$internal$js$analysis$evaluators$classes$JSPrivateName_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$classes$JSPrivateName_ts$jsPrivateName.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/expressions/JSReferenceIdentifier.ts
function ___R$project$rome$$internal$js$analysis$evaluators$expressions$JSReferenceIdentifier_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$expressions$JSReferenceIdentifier_ts$jsReferenceIdentifier.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/regex/JSRegExpAlternation.ts
function ___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpAlternation_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$regex$JSRegExpAlternation_ts$jsRegExpAlternation.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/regex/JSRegExpAnyCharacter.ts
function ___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpAnyCharacter_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$regex$JSRegExpAnyCharacter_ts$jsRegExpAnyCharacter.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/regex/JSRegExpCharacter.ts
function ___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpCharacter_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$regex$JSRegExpCharacter_ts$jsRegExpCharacter.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/regex/JSRegExpCharSet.ts
function ___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpCharSet_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$regex$JSRegExpCharSet_ts$jsRegExpCharSet.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/regex/JSRegExpCharSetRange.ts
function ___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpCharSetRange_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$regex$JSRegExpCharSetRange_ts$jsRegExpCharSetRange.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/regex/JSRegExpControlCharacter.ts
function ___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpControlCharacter_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$regex$JSRegExpControlCharacter_ts$jsRegExpControlCharacter.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/regex/JSRegExpDigitCharacter.ts
function ___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpDigitCharacter_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$regex$JSRegExpDigitCharacter_ts$jsRegExpDigitCharacter.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/regex/JSRegExpEndCharacter.ts
function ___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpEndCharacter_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$regex$JSRegExpEndCharacter_ts$jsRegExpEndCharacter.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/regex/JSRegExpGroupCapture.ts
function ___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpGroupCapture_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$regex$JSRegExpGroupCapture_ts$jsRegExpGroupCapture.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/regex/JSRegExpGroupNonCapture.ts
function ___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpGroupNonCapture_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$regex$JSRegExpGroupNonCapture_ts$jsRegExpGroupNonCapture.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/literals/JSRegExpLiteral.ts
function ___R$project$rome$$internal$js$analysis$evaluators$literals$JSRegExpLiteral_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$literals$JSRegExpLiteral_ts$jsRegExpLiteral.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/regex/JSRegExpNamedBackReference.ts
function ___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpNamedBackReference_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$regex$JSRegExpNamedBackReference_ts$jsRegExpNamedBackReference.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/regex/JSRegExpNonDigitCharacter.ts
function ___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpNonDigitCharacter_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$regex$JSRegExpNonDigitCharacter_ts$jsRegExpNonDigitCharacter.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/regex/JSRegExpNonWhiteSpaceCharacter.ts
function ___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpNonWhiteSpaceCharacter_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$regex$JSRegExpNonWhiteSpaceCharacter_ts$jsRegExpNonWhiteSpaceCharacter.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/regex/JSRegExpNonWordBoundaryCharacter.ts
function ___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpNonWordBoundaryCharacter_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$regex$JSRegExpNonWordBoundaryCharacter_ts$jsRegExpNonWordBoundaryCharacter.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/regex/JSRegExpNonWordCharacter.ts
function ___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpNonWordCharacter_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$regex$JSRegExpNonWordCharacter_ts$jsRegExpNonWordCharacter.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/regex/JSRegExpNumericBackReference.ts
function ___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpNumericBackReference_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$regex$JSRegExpNumericBackReference_ts$jsRegExpNumericBackReference.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/regex/JSRegExpQuantified.ts
function ___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpQuantified_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$regex$JSRegExpQuantified_ts$jsRegExpQuantified.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/regex/JSRegExpStartCharacter.ts
function ___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpStartCharacter_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$regex$JSRegExpStartCharacter_ts$jsRegExpStartCharacter.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/regex/JSRegExpSubExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpSubExpression_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$regex$JSRegExpSubExpression_ts$jsRegExpSubExpression.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/regex/JSRegExpWhiteSpaceCharacter.ts
function ___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpWhiteSpaceCharacter_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$regex$JSRegExpWhiteSpaceCharacter_ts$jsRegExpWhiteSpaceCharacter.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/regex/JSRegExpWordBoundaryCharacter.ts
function ___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpWordBoundaryCharacter_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$regex$JSRegExpWordBoundaryCharacter_ts$jsRegExpWordBoundaryCharacter.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/regex/JSRegExpWordCharacter.ts
function ___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpWordCharacter_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$regex$JSRegExpWordCharacter_ts$jsRegExpWordCharacter.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/statements/JSReturnStatement.ts
function ___R$project$rome$$internal$js$analysis$evaluators$statements$JSReturnStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$statements$JSReturnStatement_ts$jsReturnStatement.assert(
			node,
		);
		const funcScope = scope.find(
			___R$project$rome$$internal$js$analysis$scopes_ts$FunctionScope,
		);
		if (node.argument === undefined) {
			// TODO connect to undefined
		} else {
			const type = scope.evaluate(node.argument);
			funcScope.meta.returnType.shouldMatch(type);
		}
	}


  // project-rome/@internal/js-analysis/evaluators/core/JSRoot.ts
function ___R$project$rome$$internal$js$analysis$evaluators$core$JSRoot_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$core$JSRoot_ts$jsRoot.assert(node);
		___R$project$rome$$internal$js$analysis$evaluators$statements$JSBlockStatement_ts$default(
			node,
			scope,
		);
	}


  // project-rome/@internal/js-analysis/evaluators/expressions/JSSequenceExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$expressions$JSSequenceExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$expressions$JSSequenceExpression_ts$jsSequenceExpression.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/auxiliary/JSSpreadElement.ts
function ___R$project$rome$$internal$js$analysis$evaluators$auxiliary$JSSpreadElement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$auxiliary$JSSpreadElement_ts$jsSpreadElement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/objects/JSSpreadProperty.ts
function ___R$project$rome$$internal$js$analysis$evaluators$objects$JSSpreadProperty_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$objects$JSSpreadProperty_ts$jsSpreadProperty.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/auxiliary/JSStaticMemberProperty.ts
function ___R$project$rome$$internal$js$analysis$evaluators$auxiliary$JSStaticMemberProperty_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$auxiliary$JSStaticMemberProperty_ts$jsStaticMemberProperty.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/objects/JSStaticPropertyKey.ts
function ___R$project$rome$$internal$js$analysis$evaluators$objects$JSStaticPropertyKey_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$objects$JSStaticPropertyKey_ts$jsStaticPropertyKey.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/literals/JSStringLiteral.ts
function ___R$project$rome$$internal$js$analysis$evaluators$literals$JSStringLiteral_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$literals$JSStringLiteral_ts$jsStringLiteral.assert(
			node,
		);
		return new ___R$project$rome$$internal$js$analysis$types$StringLiteralT_ts$default(
			scope,
			node,
			node.value,
		);
	}


  // project-rome/@internal/js-analysis/evaluators/expressions/JSSuper.ts
function ___R$project$rome$$internal$js$analysis$evaluators$expressions$JSSuper_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$expressions$JSSuper_ts$jsSuper.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/auxiliary/JSSwitchCase.ts
function ___R$project$rome$$internal$js$analysis$evaluators$auxiliary$JSSwitchCase_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$auxiliary$JSSwitchCase_ts$jsSwitchCase.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/statements/JSSwitchStatement.ts
function ___R$project$rome$$internal$js$analysis$evaluators$statements$JSSwitchStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$statements$JSSwitchStatement_ts$jsSwitchStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/expressions/JSTaggedTemplateExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$expressions$JSTaggedTemplateExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$expressions$JSTaggedTemplateExpression_ts$jsTaggedTemplateExpression.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/auxiliary/JSTemplateElement.ts
function ___R$project$rome$$internal$js$analysis$evaluators$auxiliary$JSTemplateElement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$auxiliary$JSTemplateElement_ts$jsTemplateElement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/literals/JSTemplateLiteral.ts
function ___R$project$rome$$internal$js$analysis$evaluators$literals$JSTemplateLiteral_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$literals$JSTemplateLiteral_ts$jsTemplateLiteral.assert(
			node,
		);
		for (const expr of node.expressions) {
			new ___R$project$rome$$internal$js$analysis$types$ExhaustiveT_ts$default(
				scope,
				expr,
				scope.evaluate(expr),
				new ___R$project$rome$$internal$js$analysis$types$StringT_ts$default(
					scope,
					undefined,
				),
			);
		}
		return new ___R$project$rome$$internal$js$analysis$types$StringT_ts$default(
			scope,
			node,
		);
	}


  // project-rome/@internal/js-analysis/evaluators/expressions/JSThisExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$expressions$JSThisExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$expressions$JSThisExpression_ts$jsThisExpression.assert(
			node,
		);
		const thisScope = scope.find(
			___R$project$rome$$internal$js$analysis$scopes_ts$ThisScope,
		);
		if (thisScope === undefined) {
			// TODO complain
			return undefined;
		} else {
			const type = new ___R$project$rome$$internal$js$analysis$types$OpenT_ts$default(
				scope,
				node,
			);
			type.shouldMatch(thisScope.context);
			return type;
		}
	}


  // project-rome/@internal/js-analysis/evaluators/statements/JSThrowStatement.ts
function ___R$project$rome$$internal$js$analysis$evaluators$statements$JSThrowStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$statements$JSThrowStatement_ts$jsThrowStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/statements/JSTryStatement.ts
function ___R$project$rome$$internal$js$analysis$evaluators$statements$JSTryStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$statements$JSTryStatement_ts$jsTryStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/expressions/JSUnaryExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$expressions$JSUnaryExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$expressions$JSUnaryExpression_ts$jsUnaryExpression.assert(
			node,
		);
		const argType = scope.evaluate(node.argument);

		switch (node.operator) {
			case // booleans
			"delete":
			case "!":
				return new ___R$project$rome$$internal$js$analysis$types$BooleanT_ts$default(
					scope,
					node,
				);

			// numbers
			case "+":
			case "-":
			case "~":
				return new ___R$project$rome$$internal$js$analysis$types$NumericT_ts$default(
					scope,
					node,
				);

			// strings
			case "typeof":
				return new ___R$project$rome$$internal$js$analysis$types$TypeofT_ts$default(
					scope,
					node,
					argType,
				);

			// void
			case "void":
				return new ___R$project$rome$$internal$js$analysis$types$VoidT_ts$default(
					scope,
					node,
				);

			// empty!
			case "throw":
				break;
		}

		return undefined;
	}


  // project-rome/@internal/js-analysis/evaluators/expressions/JSUpdateExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$expressions$JSUpdateExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$expressions$JSUpdateExpression_ts$jsUpdateExpression.assert(
			node,
		);
		const type = new ___R$project$rome$$internal$js$analysis$types$NumericT_ts$default(
			scope,
			node,
		);
		new ___R$project$rome$$internal$js$analysis$types$ExhaustiveT_ts$default(
			scope,
			node.argument,
			scope.evaluate(node.argument),
			type,
		);
		return type;
	}


  // project-rome/@internal/js-analysis/evaluators/auxiliary/JSVariableDeclaration.ts
function ___R$project$rome$$internal$js$analysis$evaluators$auxiliary$JSVariableDeclaration_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclaration_ts$jsVariableDeclaration.assert(
			node,
		);

		for (const declarator of node.declarations) {
			const {id, init} = declarator;
			let inferredType;

			if (init === undefined) {
				inferredType = new ___R$project$rome$$internal$js$analysis$types$OpenT_ts$default(
					scope,
					declarator,
				);
				inferredType.shouldMatch(
					new ___R$project$rome$$internal$js$analysis$types$VoidT_ts$default(
						scope,
						declarator,
					),
				);
			} else {
				inferredType = scope.evaluate(init);
			}

			let actualType = inferredType;

			if (id.meta !== undefined && id.meta.typeAnnotation !== undefined) {
				const annotatedType = scope.evaluate(id.meta.typeAnnotation);
				inferredType.shouldMatch(annotatedType);
				actualType = annotatedType;
			}

			___R$project$rome$$internal$js$analysis$utils$executeAtom_ts$default(
				id,
				actualType,
				scope,
			);
		}
	}


  // project-rome/@internal/js-analysis/evaluators/statements/JSVariableDeclarationStatement.ts
function ___R$project$rome$$internal$js$analysis$evaluators$statements$JSVariableDeclarationStatement_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$statements$JSVariableDeclarationStatement_ts$jsVariableDeclarationStatement.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/auxiliary/JSVariableDeclarator.ts
function ___R$project$rome$$internal$js$analysis$evaluators$auxiliary$JSVariableDeclarator_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$auxiliary$JSVariableDeclarator_ts$jsVariableDeclarator.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/statements/JSWhileStatement.ts
function ___R$project$rome$$internal$js$analysis$evaluators$statements$JSWhileStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$statements$JSWhileStatement_ts$jsWhileStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/statements/JSWithStatement.ts
function ___R$project$rome$$internal$js$analysis$evaluators$statements$JSWithStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$statements$JSWithStatement_ts$jsWithStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/jsx/JSXAttribute.ts
function ___R$project$rome$$internal$js$analysis$evaluators$jsx$JSXAttribute_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$jsx$JSXAttribute_ts$jsxAttribute.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/jsx/JSXElement.ts
function ___R$project$rome$$internal$js$analysis$evaluators$jsx$JSXElement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$jsx$JSXElement_ts$jsxElement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/jsx/JSXEmptyExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$jsx$JSXEmptyExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$jsx$JSXEmptyExpression_ts$jsxEmptyExpression.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/jsx/JSXExpressionContainer.ts
function ___R$project$rome$$internal$js$analysis$evaluators$jsx$JSXExpressionContainer_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$jsx$JSXExpressionContainer_ts$jsxExpressionContainer.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/jsx/JSXFragment.ts
function ___R$project$rome$$internal$js$analysis$evaluators$jsx$JSXFragment_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$jsx$JSXFragment_ts$jsxFragment.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/jsx/JSXIdentifier.ts
function ___R$project$rome$$internal$js$analysis$evaluators$jsx$JSXIdentifier_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$jsx$JSXIdentifier_ts$jsxIdentifier.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/jsx/JSXMemberExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$jsx$JSXMemberExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$jsx$JSXMemberExpression_ts$jsxMemberExpression.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/jsx/JSXNamespacedName.ts
function ___R$project$rome$$internal$js$analysis$evaluators$jsx$JSXNamespacedName_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$jsx$JSXNamespacedName_ts$jsxNamespacedName.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/jsx/JSXReferenceIdentifier.ts
function ___R$project$rome$$internal$js$analysis$evaluators$jsx$JSXReferenceIdentifier_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$jsx$JSXReferenceIdentifier_ts$jsxReferenceIdentifier.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/jsx/JSXSpreadAttribute.ts
function ___R$project$rome$$internal$js$analysis$evaluators$jsx$JSXSpreadAttribute_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$jsx$JSXSpreadAttribute_ts$jsxSpreadAttribute.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/jsx/JSXSpreadChild.ts
function ___R$project$rome$$internal$js$analysis$evaluators$jsx$JSXSpreadChild_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$jsx$JSXSpreadChild_ts$jsxSpreadChild.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/jsx/JSXText.ts
function ___R$project$rome$$internal$js$analysis$evaluators$jsx$JSXText_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$jsx$JSXText_ts$jsxText.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/expressions/JSYieldExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$expressions$JSYieldExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$expressions$JSYieldExpression_ts$jsYieldExpression.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSAnyKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSAnyKeywordTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSAnyKeywordTypeAnnotation_ts$tsAnyKeywordTypeAnnotation.assert(
			node,
		);
		return new ___R$project$rome$$internal$js$analysis$types$AnyT_ts$default(
			scope,
			node,
		);
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSArrayType.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSArrayType_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSArrayType_ts$tsArrayType.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSAsExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSAsExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSAsExpression_ts$tsAsExpression.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSAssignmentAsExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSAssignmentAsExpression_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSAssignmentAsExpression_ts$tsAssignmentAsExpression.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSAssignmentNonNullExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSAssignmentNonNullExpression_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSAssignmentNonNullExpression_ts$tsAssignmentNonNullExpression.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSAssignmentTypeAssertion.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSAssignmentTypeAssertion_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSAssignmentTypeAssertion_ts$tsAssignmentTypeAssertion.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSBigIntKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSBigIntKeywordTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSBigIntKeywordTypeAnnotation_ts$tsBigIntKeywordTypeAnnotation.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSBigIntLiteralTypeAnnotation.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSBigIntLiteralTypeAnnotation_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSBigIntLiteralTypeAnnotation_ts$tsBigIntLiteralTypeAnnotation.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSBooleanKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSBooleanKeywordTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSBooleanKeywordTypeAnnotation_ts$tsBooleanKeywordTypeAnnotation.assert(
			node,
		);
		return new ___R$project$rome$$internal$js$analysis$types$BooleanT_ts$default(
			scope,
			node,
		);
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSBooleanLiteralTypeAnnotation.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSBooleanLiteralTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSBooleanLiteralTypeAnnotation_ts$tsBooleanLiteralTypeAnnotation.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSCallSignatureDeclaration.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSCallSignatureDeclaration_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSCallSignatureDeclaration_ts$tsCallSignatureDeclaration.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSConditionalType.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSConditionalType_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSConditionalType_ts$tsConditionalType.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSConstKeyword.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSConstKeyword_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSConstKeyword_ts$tsConstKeyword.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSConstructorType.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSConstructorType_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSConstructorType_ts$tsConstructorType.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSConstructSignatureDeclaration.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSConstructSignatureDeclaration_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSConstructSignatureDeclaration_ts$tsConstructSignatureDeclaration.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSDeclareFunction.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSDeclareFunction_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSDeclareFunction_ts$tsDeclareFunction.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSDeclareMethod.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSDeclareMethod_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSDeclareMethod_ts$tsDeclareMethod.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSEmptyKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSEmptyKeywordTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSEmptyKeywordTypeAnnotation_ts$tsEmptyKeywordTypeAnnotation.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSEnumDeclaration.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSEnumDeclaration_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSEnumDeclaration_ts$tsEnumDeclaration.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSEnumMember.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSEnumMember_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSEnumMember_ts$tsEnumMember.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSExportAssignment.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSExportAssignment_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSExportAssignment_ts$tsExportAssignment.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSExpressionWithTypeArguments.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSExpressionWithTypeArguments_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSExpressionWithTypeArguments_ts$tsExpressionWithTypeArguments.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSExternalModuleReference.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSExternalModuleReference_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSExternalModuleReference_ts$tsExternalModuleReference.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSFunctionType.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSFunctionType_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSFunctionType_ts$tsFunctionType.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSImportEqualsDeclaration.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSImportEqualsDeclaration_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSImportEqualsDeclaration_ts$tsImportEqualsDeclaration.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSImportType.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSImportType_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSImportType_ts$tsImportType.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSIndexedAccessType.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSIndexedAccessType_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSIndexedAccessType_ts$tsIndexedAccessType.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSIndexSignature.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSIndexSignature_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSIndexSignature_ts$tsIndexSignature.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSInferType.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSInferType_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSInferType_ts$tsInferType.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSInterfaceBody.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSInterfaceBody_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSInterfaceBody_ts$tsInterfaceBody.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSInterfaceDeclaration.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSInterfaceDeclaration_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSInterfaceDeclaration_ts$tsInterfaceDeclaration.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSIntersectionTypeAnnotation.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSIntersectionTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSIntersectionTypeAnnotation_ts$tsIntersectionTypeAnnotation.assert(
			node,
		);

		return new ___R$project$rome$$internal$js$analysis$types$IntersectionT_ts$default(
			scope,
			node,
			node.types.map((type) => {
				return scope.evaluate(type);
			}),
		);
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSMappedType.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSMappedType_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSMappedType_ts$tsMappedType.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSMethodSignature.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSMethodSignature_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSMethodSignature_ts$tsMethodSignature.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSMixedKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSMixedKeywordTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSMixedKeywordTypeAnnotation_ts$tsMixedKeywordTypeAnnotation.assert(
			node,
		);
		return new ___R$project$rome$$internal$js$analysis$types$MixedT_ts$default(
			scope,
			node,
		);
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSModuleBlock.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSModuleBlock_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSModuleBlock_ts$tsModuleBlock.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSModuleDeclaration.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSModuleDeclaration_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSModuleDeclaration_ts$tsModuleDeclaration.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSNamespaceExportDeclaration.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSNamespaceExportDeclaration_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSNamespaceExportDeclaration_ts$tsNamespaceExportDeclaration.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSNeverKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSNeverKeywordTypeAnnotation_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSNeverKeywordTypeAnnotation_ts$tsNeverKeywordTypeAnnotation.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSNonNullExpression.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSNonNullExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSNonNullExpression_ts$tsNonNullExpression.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSNullKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSNullKeywordTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSNullKeywordTypeAnnotation_ts$tsNullKeywordTypeAnnotation.assert(
			node,
		);
		return new ___R$project$rome$$internal$js$analysis$types$NullT_ts$default(
			scope,
			node,
		);
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSNumberKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSNumberKeywordTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSNumberKeywordTypeAnnotation_ts$tsNumberKeywordTypeAnnotation.assert(
			node,
		);
		return new ___R$project$rome$$internal$js$analysis$types$NumericT_ts$default(
			scope,
			node,
		);
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSNumericLiteralTypeAnnotation.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSNumericLiteralTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSNumericLiteralTypeAnnotation_ts$tsNumericLiteralTypeAnnotation.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSObjectKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSObjectKeywordTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSObjectKeywordTypeAnnotation_ts$tsObjectKeywordTypeAnnotation.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSObjectTypeAnnotation.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSObjectTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSObjectTypeAnnotation_ts$tsObjectTypeAnnotation.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSParenthesizedType.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSParenthesizedType_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSParenthesizedType_ts$tsParenthesizedType.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSPropertySignature.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSPropertySignature_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSPropertySignature_ts$tsPropertySignature.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSQualifiedName.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSQualifiedName_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSQualifiedName_ts$tsQualifiedName.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSSignatureDeclarationMeta.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSSignatureDeclarationMeta_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSSignatureDeclarationMeta_ts$tsSignatureDeclarationMeta.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSStringKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSStringKeywordTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSStringKeywordTypeAnnotation_ts$tsStringKeywordTypeAnnotation.assert(
			node,
		);
		return new ___R$project$rome$$internal$js$analysis$types$StringT_ts$default(
			scope,
			node,
		);
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSStringLiteralTypeAnnotation.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSStringLiteralTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSStringLiteralTypeAnnotation_ts$tsStringLiteralTypeAnnotation.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSSymbolKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSSymbolKeywordTypeAnnotation_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSSymbolKeywordTypeAnnotation_ts$tsSymbolKeywordTypeAnnotation.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSTemplateLiteralTypeAnnotation.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSTemplateLiteralTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSTemplateLiteralTypeAnnotation_ts$tsTemplateLiteralTypeAnnotation.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSThisType.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSThisType_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSThisType_ts$tsThisType.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSTupleElement.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSTupleElement_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSTupleElement_ts$tsTupleElement.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSTupleType.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSTupleType_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSTupleType_ts$tsTupleType.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSTypeAlias.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSTypeAlias_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSTypeAlias_ts$tsTypeAlias.assert(
			node,
		);

		const typeScope = scope.fork();
		if (node.typeParameters) {
			typeScope.evaluate(node.typeParameters);
		}

		const right = typeScope.evaluate(node.right);
		scope.addBinding(node.id.name, right);
		return right;
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSTypeAssertion.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSTypeAssertion_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSTypeAssertion_ts$tsTypeAssertion.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSTypeOperator.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSTypeOperator_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSTypeOperator_ts$tsTypeOperator.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSTypeParameter.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSTypeParameter_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSTypeParameter_ts$tsTypeParameter.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSTypeParameterDeclaration.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSTypeParameterDeclaration_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSTypeParameterDeclaration_ts$tsTypeParameterDeclaration.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSTypeParameterInstantiation.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSTypeParameterInstantiation_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSTypeParameterInstantiation_ts$tsTypeParameterInstantiation.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSTypePredicate.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSTypePredicate_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSTypePredicate_ts$tsTypePredicate.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSTypeQuery.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSTypeQuery_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSTypeQuery_ts$tsTypeQuery.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSTypeReference.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSTypeReference_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSTypeReference_ts$tsTypeReference.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSUndefinedKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSUndefinedKeywordTypeAnnotation_ts$default(
		node,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSUndefinedKeywordTypeAnnotation_ts$tsUndefinedKeywordTypeAnnotation.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSUnionTypeAnnotation.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSUnionTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSUnionTypeAnnotation_ts$tsUnionTypeAnnotation.assert(
			node,
		);

		return new ___R$project$rome$$internal$js$analysis$types$UnionT_ts$default(
			scope,
			node,
			node.types.map((type) => {
				return scope.evaluate(type);
			}),
		);
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSUnknownKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSUnknownKeywordTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSUnknownKeywordTypeAnnotation_ts$tsUnknownKeywordTypeAnnotation.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@internal/js-analysis/evaluators/typescript/TSVoidKeywordTypeAnnotation.ts
function ___R$project$rome$$internal$js$analysis$evaluators$typescript$TSVoidKeywordTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$internal$ast$js$typescript$TSVoidKeywordTypeAnnotation_ts$tsVoidKeywordTypeAnnotation.assert(
			node,
		);
		return new ___R$project$rome$$internal$js$analysis$types$VoidT_ts$default(
			scope,
			node,
		);
	}


  // project-rome/@internal/js-analysis/evaluators/index.ts
const ___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
		"evaluators",
	);
	const ___R$project$rome$$internal$js$analysis$evaluators$index_ts$default = ___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators;
	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSAmbiguousFlowTypeCastExpression",
		___R$project$rome$$internal$js$analysis$evaluators$temp$JSAmbiguousFlowTypeCastExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSArrayExpression",
		___R$project$rome$$internal$js$analysis$evaluators$expressions$JSArrayExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSArrayHole",
		___R$project$rome$$internal$js$analysis$evaluators$auxiliary$JSArrayHole_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSArrowFunctionExpression",
		___R$project$rome$$internal$js$analysis$evaluators$expressions$JSArrowFunctionExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSAssignmentArrayPattern",
		___R$project$rome$$internal$js$analysis$evaluators$patterns$JSAssignmentArrayPattern_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSAssignmentAssignmentPattern",
		___R$project$rome$$internal$js$analysis$evaluators$patterns$JSAssignmentAssignmentPattern_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSAssignmentExpression",
		___R$project$rome$$internal$js$analysis$evaluators$expressions$JSAssignmentExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSAssignmentIdentifier",
		___R$project$rome$$internal$js$analysis$evaluators$patterns$JSAssignmentIdentifier_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSAssignmentObjectPattern",
		___R$project$rome$$internal$js$analysis$evaluators$patterns$JSAssignmentObjectPattern_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSAssignmentObjectPatternProperty",
		___R$project$rome$$internal$js$analysis$evaluators$patterns$JSAssignmentObjectPatternProperty_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSAwaitExpression",
		___R$project$rome$$internal$js$analysis$evaluators$expressions$JSAwaitExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSBigIntLiteral",
		___R$project$rome$$internal$js$analysis$evaluators$literals$JSBigIntLiteral_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSBinaryExpression",
		___R$project$rome$$internal$js$analysis$evaluators$expressions$JSBinaryExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSBindingArrayPattern",
		___R$project$rome$$internal$js$analysis$evaluators$patterns$JSBindingArrayPattern_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSBindingAssignmentPattern",
		___R$project$rome$$internal$js$analysis$evaluators$patterns$JSBindingAssignmentPattern_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSBindingIdentifier",
		___R$project$rome$$internal$js$analysis$evaluators$patterns$JSBindingIdentifier_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSBindingObjectPattern",
		___R$project$rome$$internal$js$analysis$evaluators$patterns$JSBindingObjectPattern_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSBindingObjectPatternProperty",
		___R$project$rome$$internal$js$analysis$evaluators$patterns$JSBindingObjectPatternProperty_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSBlockStatement",
		___R$project$rome$$internal$js$analysis$evaluators$statements$JSBlockStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSBooleanLiteral",
		___R$project$rome$$internal$js$analysis$evaluators$literals$JSBooleanLiteral_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSBreakStatement",
		___R$project$rome$$internal$js$analysis$evaluators$statements$JSBreakStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSCallExpression",
		___R$project$rome$$internal$js$analysis$evaluators$expressions$JSCallExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSCatchClause",
		___R$project$rome$$internal$js$analysis$evaluators$auxiliary$JSCatchClause_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSClassDeclaration",
		___R$project$rome$$internal$js$analysis$evaluators$classes$JSClassDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSClassExpression",
		___R$project$rome$$internal$js$analysis$evaluators$classes$JSClassExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSClassHead",
		___R$project$rome$$internal$js$analysis$evaluators$classes$JSClassHead_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSClassMethod",
		___R$project$rome$$internal$js$analysis$evaluators$classes$JSClassMethod_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSClassPrivateMethod",
		___R$project$rome$$internal$js$analysis$evaluators$classes$JSClassPrivateMethod_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSClassPrivateProperty",
		___R$project$rome$$internal$js$analysis$evaluators$classes$JSClassPrivateProperty_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSClassProperty",
		___R$project$rome$$internal$js$analysis$evaluators$classes$JSClassProperty_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSClassPropertyMeta",
		___R$project$rome$$internal$js$analysis$evaluators$classes$JSClassPropertyMeta_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSComputedMemberProperty",
		___R$project$rome$$internal$js$analysis$evaluators$auxiliary$JSComputedMemberProperty_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSComputedPropertyKey",
		___R$project$rome$$internal$js$analysis$evaluators$objects$JSComputedPropertyKey_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSConditionalExpression",
		___R$project$rome$$internal$js$analysis$evaluators$expressions$JSConditionalExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSContinueStatement",
		___R$project$rome$$internal$js$analysis$evaluators$statements$JSContinueStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSDebuggerStatement",
		___R$project$rome$$internal$js$analysis$evaluators$statements$JSDebuggerStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSDirective",
		___R$project$rome$$internal$js$analysis$evaluators$core$JSDirective_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSDoExpression",
		___R$project$rome$$internal$js$analysis$evaluators$expressions$JSDoExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSDoWhileStatement",
		___R$project$rome$$internal$js$analysis$evaluators$statements$JSDoWhileStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSEmptyStatement",
		___R$project$rome$$internal$js$analysis$evaluators$statements$JSEmptyStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSExportAllDeclaration",
		___R$project$rome$$internal$js$analysis$evaluators$modules$JSExportAllDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSExportDefaultDeclaration",
		___R$project$rome$$internal$js$analysis$evaluators$modules$JSExportDefaultDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSExportDefaultSpecifier",
		___R$project$rome$$internal$js$analysis$evaluators$modules$JSExportDefaultSpecifier_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSExportExternalDeclaration",
		___R$project$rome$$internal$js$analysis$evaluators$modules$JSExportExternalDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSExportExternalSpecifier",
		___R$project$rome$$internal$js$analysis$evaluators$modules$JSExportExternalSpecifier_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSExportLocalDeclaration",
		___R$project$rome$$internal$js$analysis$evaluators$modules$JSExportLocalDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSExportLocalSpecifier",
		___R$project$rome$$internal$js$analysis$evaluators$modules$JSExportLocalSpecifier_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSExportNamespaceSpecifier",
		___R$project$rome$$internal$js$analysis$evaluators$modules$JSExportNamespaceSpecifier_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSExpressionStatement",
		___R$project$rome$$internal$js$analysis$evaluators$statements$JSExpressionStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSForInStatement",
		___R$project$rome$$internal$js$analysis$evaluators$statements$JSForInStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSForOfStatement",
		___R$project$rome$$internal$js$analysis$evaluators$statements$JSForOfStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSForStatement",
		___R$project$rome$$internal$js$analysis$evaluators$statements$JSForStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSFunctionDeclaration",
		___R$project$rome$$internal$js$analysis$evaluators$statements$JSFunctionDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSFunctionExpression",
		___R$project$rome$$internal$js$analysis$evaluators$expressions$JSFunctionExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSFunctionHead",
		___R$project$rome$$internal$js$analysis$evaluators$auxiliary$JSFunctionHead_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSIdentifier",
		___R$project$rome$$internal$js$analysis$evaluators$auxiliary$JSIdentifier_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSIfStatement",
		___R$project$rome$$internal$js$analysis$evaluators$statements$JSIfStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSImportCall",
		___R$project$rome$$internal$js$analysis$evaluators$modules$JSImportCall_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSImportDeclaration",
		___R$project$rome$$internal$js$analysis$evaluators$modules$JSImportDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSImportDefaultSpecifier",
		___R$project$rome$$internal$js$analysis$evaluators$modules$JSImportDefaultSpecifier_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSImportNamespaceSpecifier",
		___R$project$rome$$internal$js$analysis$evaluators$modules$JSImportNamespaceSpecifier_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSImportSpecifier",
		___R$project$rome$$internal$js$analysis$evaluators$modules$JSImportSpecifier_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSImportSpecifierLocal",
		___R$project$rome$$internal$js$analysis$evaluators$modules$JSImportSpecifierLocal_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSInterpreterDirective",
		___R$project$rome$$internal$js$analysis$evaluators$core$JSInterpreterDirective_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSLabeledStatement",
		___R$project$rome$$internal$js$analysis$evaluators$statements$JSLabeledStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSLogicalExpression",
		___R$project$rome$$internal$js$analysis$evaluators$expressions$JSLogicalExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSMemberExpression",
		___R$project$rome$$internal$js$analysis$evaluators$expressions$JSMemberExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSMetaProperty",
		___R$project$rome$$internal$js$analysis$evaluators$expressions$JSMetaProperty_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSNewExpression",
		___R$project$rome$$internal$js$analysis$evaluators$expressions$JSNewExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSNullLiteral",
		___R$project$rome$$internal$js$analysis$evaluators$literals$JSNullLiteral_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSNumericLiteral",
		___R$project$rome$$internal$js$analysis$evaluators$literals$JSNumericLiteral_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSObjectExpression",
		___R$project$rome$$internal$js$analysis$evaluators$objects$JSObjectExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSObjectMethod",
		___R$project$rome$$internal$js$analysis$evaluators$objects$JSObjectMethod_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSObjectProperty",
		___R$project$rome$$internal$js$analysis$evaluators$objects$JSObjectProperty_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSOptionalCallExpression",
		___R$project$rome$$internal$js$analysis$evaluators$expressions$JSOptionalCallExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSPatternMeta",
		___R$project$rome$$internal$js$analysis$evaluators$patterns$JSPatternMeta_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSPrivateName",
		___R$project$rome$$internal$js$analysis$evaluators$classes$JSPrivateName_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSReferenceIdentifier",
		___R$project$rome$$internal$js$analysis$evaluators$expressions$JSReferenceIdentifier_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSRegExpAlternation",
		___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpAlternation_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSRegExpAnyCharacter",
		___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpAnyCharacter_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSRegExpCharacter",
		___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpCharacter_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSRegExpCharSet",
		___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpCharSet_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSRegExpCharSetRange",
		___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpCharSetRange_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSRegExpControlCharacter",
		___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpControlCharacter_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSRegExpDigitCharacter",
		___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpDigitCharacter_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSRegExpEndCharacter",
		___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpEndCharacter_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSRegExpGroupCapture",
		___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpGroupCapture_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSRegExpGroupNonCapture",
		___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpGroupNonCapture_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSRegExpLiteral",
		___R$project$rome$$internal$js$analysis$evaluators$literals$JSRegExpLiteral_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSRegExpNamedBackReference",
		___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpNamedBackReference_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSRegExpNonDigitCharacter",
		___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpNonDigitCharacter_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSRegExpNonWhiteSpaceCharacter",
		___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpNonWhiteSpaceCharacter_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSRegExpNonWordBoundaryCharacter",
		___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpNonWordBoundaryCharacter_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSRegExpNonWordCharacter",
		___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpNonWordCharacter_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSRegExpNumericBackReference",
		___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpNumericBackReference_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSRegExpQuantified",
		___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpQuantified_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSRegExpStartCharacter",
		___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpStartCharacter_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSRegExpSubExpression",
		___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpSubExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSRegExpWhiteSpaceCharacter",
		___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpWhiteSpaceCharacter_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSRegExpWordBoundaryCharacter",
		___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpWordBoundaryCharacter_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSRegExpWordCharacter",
		___R$project$rome$$internal$js$analysis$evaluators$regex$JSRegExpWordCharacter_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSReturnStatement",
		___R$project$rome$$internal$js$analysis$evaluators$statements$JSReturnStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSRoot",
		___R$project$rome$$internal$js$analysis$evaluators$core$JSRoot_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSSequenceExpression",
		___R$project$rome$$internal$js$analysis$evaluators$expressions$JSSequenceExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSSpreadElement",
		___R$project$rome$$internal$js$analysis$evaluators$auxiliary$JSSpreadElement_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSSpreadProperty",
		___R$project$rome$$internal$js$analysis$evaluators$objects$JSSpreadProperty_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSStaticMemberProperty",
		___R$project$rome$$internal$js$analysis$evaluators$auxiliary$JSStaticMemberProperty_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSStaticPropertyKey",
		___R$project$rome$$internal$js$analysis$evaluators$objects$JSStaticPropertyKey_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSStringLiteral",
		___R$project$rome$$internal$js$analysis$evaluators$literals$JSStringLiteral_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSSuper",
		___R$project$rome$$internal$js$analysis$evaluators$expressions$JSSuper_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSSwitchCase",
		___R$project$rome$$internal$js$analysis$evaluators$auxiliary$JSSwitchCase_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSSwitchStatement",
		___R$project$rome$$internal$js$analysis$evaluators$statements$JSSwitchStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSTaggedTemplateExpression",
		___R$project$rome$$internal$js$analysis$evaluators$expressions$JSTaggedTemplateExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSTemplateElement",
		___R$project$rome$$internal$js$analysis$evaluators$auxiliary$JSTemplateElement_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSTemplateLiteral",
		___R$project$rome$$internal$js$analysis$evaluators$literals$JSTemplateLiteral_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSThisExpression",
		___R$project$rome$$internal$js$analysis$evaluators$expressions$JSThisExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSThrowStatement",
		___R$project$rome$$internal$js$analysis$evaluators$statements$JSThrowStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSTryStatement",
		___R$project$rome$$internal$js$analysis$evaluators$statements$JSTryStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSUnaryExpression",
		___R$project$rome$$internal$js$analysis$evaluators$expressions$JSUnaryExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSUpdateExpression",
		___R$project$rome$$internal$js$analysis$evaluators$expressions$JSUpdateExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSVariableDeclaration",
		___R$project$rome$$internal$js$analysis$evaluators$auxiliary$JSVariableDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSVariableDeclarationStatement",
		___R$project$rome$$internal$js$analysis$evaluators$statements$JSVariableDeclarationStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSVariableDeclarator",
		___R$project$rome$$internal$js$analysis$evaluators$auxiliary$JSVariableDeclarator_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSWhileStatement",
		___R$project$rome$$internal$js$analysis$evaluators$statements$JSWhileStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSWithStatement",
		___R$project$rome$$internal$js$analysis$evaluators$statements$JSWithStatement_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSXAttribute",
		___R$project$rome$$internal$js$analysis$evaluators$jsx$JSXAttribute_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSXElement",
		___R$project$rome$$internal$js$analysis$evaluators$jsx$JSXElement_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSXEmptyExpression",
		___R$project$rome$$internal$js$analysis$evaluators$jsx$JSXEmptyExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSXExpressionContainer",
		___R$project$rome$$internal$js$analysis$evaluators$jsx$JSXExpressionContainer_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSXFragment",
		___R$project$rome$$internal$js$analysis$evaluators$jsx$JSXFragment_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSXIdentifier",
		___R$project$rome$$internal$js$analysis$evaluators$jsx$JSXIdentifier_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSXMemberExpression",
		___R$project$rome$$internal$js$analysis$evaluators$jsx$JSXMemberExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSXNamespacedName",
		___R$project$rome$$internal$js$analysis$evaluators$jsx$JSXNamespacedName_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSXReferenceIdentifier",
		___R$project$rome$$internal$js$analysis$evaluators$jsx$JSXReferenceIdentifier_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSXSpreadAttribute",
		___R$project$rome$$internal$js$analysis$evaluators$jsx$JSXSpreadAttribute_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSXSpreadChild",
		___R$project$rome$$internal$js$analysis$evaluators$jsx$JSXSpreadChild_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSXText",
		___R$project$rome$$internal$js$analysis$evaluators$jsx$JSXText_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"JSYieldExpression",
		___R$project$rome$$internal$js$analysis$evaluators$expressions$JSYieldExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSAnyKeywordTypeAnnotation",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSAnyKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSArrayType",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSArrayType_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSAsExpression",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSAsExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSAssignmentAsExpression",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSAssignmentAsExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSAssignmentNonNullExpression",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSAssignmentNonNullExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSAssignmentTypeAssertion",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSAssignmentTypeAssertion_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSBigIntKeywordTypeAnnotation",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSBigIntKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSBigIntLiteralTypeAnnotation",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSBigIntLiteralTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSBooleanKeywordTypeAnnotation",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSBooleanKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSBooleanLiteralTypeAnnotation",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSBooleanLiteralTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSCallSignatureDeclaration",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSCallSignatureDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSConditionalType",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSConditionalType_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSConstKeyword",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSConstKeyword_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSConstructorType",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSConstructorType_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSConstructSignatureDeclaration",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSConstructSignatureDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSDeclareFunction",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSDeclareFunction_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSDeclareMethod",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSDeclareMethod_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSEmptyKeywordTypeAnnotation",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSEmptyKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSEnumDeclaration",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSEnumDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSEnumMember",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSEnumMember_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSExportAssignment",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSExportAssignment_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSExpressionWithTypeArguments",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSExpressionWithTypeArguments_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSExternalModuleReference",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSExternalModuleReference_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSFunctionType",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSFunctionType_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSImportEqualsDeclaration",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSImportEqualsDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSImportType",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSImportType_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSIndexedAccessType",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSIndexedAccessType_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSIndexSignature",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSIndexSignature_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSInferType",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSInferType_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSInterfaceBody",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSInterfaceBody_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSInterfaceDeclaration",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSInterfaceDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSIntersectionTypeAnnotation",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSIntersectionTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSMappedType",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSMappedType_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSMethodSignature",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSMethodSignature_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSMixedKeywordTypeAnnotation",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSMixedKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSModuleBlock",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSModuleBlock_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSModuleDeclaration",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSModuleDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSNamespaceExportDeclaration",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSNamespaceExportDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSNeverKeywordTypeAnnotation",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSNeverKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSNonNullExpression",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSNonNullExpression_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSNullKeywordTypeAnnotation",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSNullKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSNumberKeywordTypeAnnotation",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSNumberKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSNumericLiteralTypeAnnotation",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSNumericLiteralTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSObjectKeywordTypeAnnotation",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSObjectKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSObjectTypeAnnotation",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSObjectTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSParenthesizedType",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSParenthesizedType_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSPropertySignature",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSPropertySignature_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSQualifiedName",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSQualifiedName_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSSignatureDeclarationMeta",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSSignatureDeclarationMeta_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSStringKeywordTypeAnnotation",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSStringKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSStringLiteralTypeAnnotation",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSStringLiteralTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSSymbolKeywordTypeAnnotation",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSSymbolKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSTemplateLiteralTypeAnnotation",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSTemplateLiteralTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSThisType",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSThisType_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSTupleElement",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSTupleElement_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSTupleType",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSTupleType_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSTypeAlias",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSTypeAlias_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSTypeAssertion",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSTypeAssertion_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSTypeOperator",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSTypeOperator_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSTypeParameter",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSTypeParameter_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSTypeParameterDeclaration",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSTypeParameterDeclaration_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSTypeParameterInstantiation",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSTypeParameterInstantiation_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSTypePredicate",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSTypePredicate_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSTypeQuery",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSTypeQuery_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSTypeReference",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSTypeReference_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSUndefinedKeywordTypeAnnotation",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSUndefinedKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSUnionTypeAnnotation",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSUnionTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSUnknownKeywordTypeAnnotation",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSUnknownKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$internal$js$analysis$evaluators$index_ts$evaluators.set(
		"TSVoidKeywordTypeAnnotation",
		___R$project$rome$$internal$js$analysis$evaluators$typescript$TSVoidKeywordTypeAnnotation_ts$default,
	);
	/* GENERATED:END(id:main) */


  // project-rome/@internal/js-analysis/Evaluator.ts
class ___R$project$rome$$internal$js$analysis$Evaluator_ts$ModuleSignatureManager {
		constructor(graph, getModuleSignature, topScope) {
			this.topScope = topScope;
			this.getModuleSignature = getModuleSignature;
			this.graph = graph;
			this.openTypes = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
				"openTypes",
			);
			this.filename = graph.filename;

			this.exportNamesToTypeId = new Map();
		}

		addAll(manager) {
			for (const [name, id] of manager.exportNamesToTypeId) {
				if (name === "default") {
					// ignore `default`
					continue;
				}

				this.exportNamesToTypeId.set(name, id);

				const openType = manager.openTypes.assert(id);
				this.openTypes.set(id, openType);
			}
		}

		async init() {
			const {graph, openTypes} = this;

			// Create initial open types for all the nodes in this graph
			for (const id in graph.types) {
				const open = new ___R$project$rome$$internal$js$analysis$types$OpenT_ts$default(
					this.topScope,
					undefined,
				);
				openTypes.set(id, open);
			}

			let currGetType;

			// Create a factory to fetch the open ids
			const getType = (id) => {
				if (id === undefined) {
					throw new Error("expected id");
				}

				if (typeof id !== "string") {
					throw new Error("expected string id");
				}

				const type = openTypes.get(id);

				if (type === undefined) {
					throw new Error(
						graph.filename +
						": Expected type of id " +
						id +
						" but it doesn't exist, serialized data: " +
						String(JSON.stringify(currGetType)),
					);
				}

				return type;
			};

			// Fetch the graphs of `export *` dependencies, future calls to `this.getModuleSignature` will fetch from 'cache
			await Promise.all(
				graph.exports.map((def) => {
					if (def.type === "all") {
						return this.getModuleSignature(def.source, graph.filename);
					} else {
						return undefined;
					}
				}),
			);

			// Resolve all exports
			for (const def of graph.exports) {
				if (def.type === "all") {
					const manager = await this.getModuleSignature(
						def.source,
						graph.filename,
					);
					if (manager !== undefined) {
						this.addAll(manager);
					}
				} else {
					this.exportNamesToTypeId.set(def.name, def.value);
				}
			}

			// Hydrate all types in the graph and link them to their open types
			for (const id in graph.types) {
				const node = graph.types[id];
				const {origin, type, data, human} = node;
				currGetType = node;

				// Retrieve the open type
				const openT = openTypes.assert(id);

				// Get the type constructor
				const TConstructor = ___R$project$rome$$internal$js$analysis$types$index_ts$default.assert(
					type,
				);

				// Create the type

				// @ts-ignore
				const realT = TConstructor.hydrate(
					this.topScope,
					{loc: origin},
					data,
					getType,
				);

				//
				realT.setHuman(human);

				// Link it to the open type
				openT.shouldMatch(realT);
			}
		}

		link(importedName, type) {
			const graph = this.graph;

			// Get type id for this export
			const maybeExportId = this.exportNamesToTypeId.get(importedName);
			if (maybeExportId === undefined) {
				// Export not found in the module so let's link it to an error
				const error = new ___R$project$rome$$internal$js$analysis$types$errors$UnknownImportE_ts$default(
					this.topScope,
					type.originNode,
					{
						possibleNames: Array.from(this.exportNamesToTypeId.keys()),
						importedName,
						source: graph.filename,
					},
				);
				error.shouldMatch(type);
				return;
			}

			// Retrieve the open type
			const openT = this.openTypes.assert(maybeExportId);

			// Link it to this type
			type.setResolvedType(openT);
		}
	}

	class ___R$project$rome$$internal$js$analysis$Evaluator_ts$default {
		constructor(hub, filename) {
			this.filename = filename;
			this.nodeToType = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
				"nodeToType",
			);
			this.exports = [];
			this.imports = [];
			this.hub = hub;
			this.graph = hub.graph;
			// TODO we should use `ThisScope` and set it correctly to `window` or `undefined` depending on strict mode
			this.topScope = new ___R$project$rome$$internal$js$analysis$scopes_ts$Scope({
				evaluator: this,
			});
			this.intrinsics = this.topScope.intrinsics = new ___R$project$rome$$internal$js$analysis$Intrinsics_ts$default(
				this.topScope,
			);
			this.evaluatingType = undefined;
		}

		initModuleSignature(graph, getModuleSignature) {
			return new ___R$project$rome$$internal$js$analysis$Evaluator_ts$ModuleSignatureManager(
				graph,
				getModuleSignature,
				this.topScope,
			);
		}

		seed(ast) {
			return this.evaluate(ast, this.topScope);
		}

		evaluate(node, scope) {
			if (node === undefined) {
				throw new Error("Expected node but received undefined");
			}

			const evaluator = ___R$project$rome$$internal$js$analysis$evaluators$index_ts$default.assert(
				node.type,
			);
			const oldEvaluatingType = this.evaluatingType;
			this.evaluatingType = node.type;
			let type = evaluator(node, scope, this.hub);
			if (type === undefined) {
				type = new ___R$project$rome$$internal$js$analysis$types$EmptyT_ts$default(
					scope,
					node,
				);
			}
			this.evaluatingType = oldEvaluatingType;
			this.nodeToType.set(node, type);
			return type;
		}

		getTypeFromEvaluatedNode(node) {
			const type = this.nodeToType.assert(node);
			return type;
		}

		addExport(name, type) {
			this.exports.push({
				type: "local",
				name,
				value: type,
			});
		}

		addExportAll(source) {
			this.exports.push({
				type: "all",
				source,
			});
		}

		addImport(t, opts) {
			this.imports.push({
				relative: opts.relative,
				importedName: opts.importedName,
				source: opts.source,
				type: t,
			});
		}
	}


  // project-rome/@internal/js-analysis/Utils.ts
class ___R$$priv$project$rome$$internal$js$analysis$Utils_ts$ReduceRecursionError
		extends Error {}

	const ___R$$priv$project$rome$$internal$js$analysis$Utils_ts$TYPE_COMPATIBLE = {
		type: "compatible",
	};

	const ___R$$priv$project$rome$$internal$js$analysis$Utils_ts$MAX_DEPTH = 100;

	class ___R$project$rome$$internal$js$analysis$Utils_ts$HumanBuilder {
		constructor() {
			this.stack = new Set();
			this.usedAliases = new Set();
			this.aliases = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
				"aliases",
			);
		}

		isRecursive(t) {
			if (t.human !== undefined) {
				return false;
			}

			if (this.aliases.has(t)) {
				return true;
			}

			if (this.stack.has(t)) {
				return true;
			}

			return false;
		}

		humanize(type) {
			// Check if we already have a human form for this type
			if (type.human !== undefined) {
				return type.human;
			}

			// Check if we have an already created alias
			if (this.aliases.has(type)) {
				return this.aliases.assert(type);
			}

			// Generate an alias if we've determined this as recursive
			if (this.isRecursive(type)) {
				const alias = ___R$project$rome$$internal$markup$escape_ts$markup`Alias${type.id}`;
				this.aliases.set(type, alias);
				return alias;
			}

			// Setup the stack and call
			this.stack.add(type);
			try {
				let humanized = type.humanize(this);

				// Check if an alias was created
				const alias = this.aliases.get(type);
				if (alias !== undefined) {
					humanized = ___R$project$rome$$internal$markup$escape_ts$markup`${alias} = ${humanized}`;
				}
				return humanized;
			} finally {
				this.stack.delete(type);
			}
		}
	}

	class ___R$project$rome$$internal$js$analysis$Utils_ts$default {
		constructor(hub) {
			this.reduceCatchers = new Set();
			this.reduceCache = new Map();
			this.reduceStack = new Set();
			this.compatibilityDepth = 0;
			this.hub = hub;
			this.debug = false;
		}

		inspect(t, safe = false) {
			const prevDebug = this.debug;
			this.debug = true;

			const data = new Map();
			data.set("id", String(t.id));

			const {originLoc, originEvaluator} = t;
			if (originLoc === undefined) {
				data.set("origin", "unknown");
			} else {
				data.set(
					"origin",
					String(originLoc.filename) +
					":" +
					String(originLoc.start.line) +
					":" +
					String(originLoc.start.column),
				);
			}
			if (originEvaluator !== undefined) {
				data.set("evaluator", originEvaluator);
			}

			const dataStr = Array.from(data.keys()).map((key) =>
				key + ": " + String(data.get(key))
			).join(", ");

			let info = t.getConstructor().type + "<";
			if (!safe) {
				info += this.humanize(t) + ", ";
			}
			info += dataStr + ">";

			this.debug = prevDebug;
			return info;
		}

		assertClosed() {
			if (!this.debug) {
				this.hub.assertClosed();
			}
		}

		explodeUnion(type) {
			return Array.from(new Set(this.reduce(type).explodeUnion()));
		}

		isCompatibleWith(a, b) {
			return this.checkCompability(a, b).type === "compatible";
		}

		checkCompability(a, b) {
			this.assertClosed();

			const lower = this.reduce(a);
			const upper = this.reduce(b);

			// Exact same type
			if (lower === upper) {
				return ___R$$priv$project$rome$$internal$js$analysis$Utils_ts$TYPE_COMPATIBLE;
			}

			// Any types shouldn't cause errors
			if (
				lower instanceof
				___R$project$rome$$internal$js$analysis$types$AnyT_ts$default ||
				upper instanceof
				___R$project$rome$$internal$js$analysis$types$AnyT_ts$default
			) {
				return ___R$$priv$project$rome$$internal$js$analysis$Utils_ts$TYPE_COMPATIBLE;
			}

			// Simple check for call stack limits
			if (
				this.compatibilityDepth >
				___R$$priv$project$rome$$internal$js$analysis$Utils_ts$MAX_DEPTH
			) {
				throw new Error(
					"Max depth exceeded when checking compatibility of " +
					lower.inspect() +
					" to " +
					upper.inspect(),
				);
			}

			const cached = lower.compatibilityCache.get(upper);
			if (cached === undefined) {
				lower.compatibilityCache.set(
					upper,
					{
						type: "incompatible",
						lower,
						upper,
					},
				);
			} else {
				return cached;
			}

			// Check this relationship for compatibility
			this.compatibilityDepth++;
			let ret;
			try {
				ret = lower.compatibleWith(upper);
			} catch (err) {
				if (
					err instanceof
					___R$$priv$project$rome$$internal$js$analysis$Utils_ts$ReduceRecursionError
				) {
					ret = ___R$$priv$project$rome$$internal$js$analysis$Utils_ts$TYPE_COMPATIBLE;
				} else {
					throw err;
				}
			} finally {
				this.compatibilityDepth--;
			}

			let res;
			if (ret === true) {
				res = ___R$$priv$project$rome$$internal$js$analysis$Utils_ts$TYPE_COMPATIBLE;
			} else if (ret === false) {
				res = {type: "incompatible", lower: a, upper: b};
			} else if (
				ret instanceof
				___R$project$rome$$internal$js$analysis$types$errors$E_ts$default
			) {
				res = {type: "incompatible", lower: a, upper: ret};
			} else {
				res = ret;
			}

			lower.compatibilityCache.set(upper, res);

			return res;
		}

		humanize(type) {
			this.assertClosed();

			return new ___R$project$rome$$internal$js$analysis$Utils_ts$HumanBuilder().humanize(
				type,
			);
		}

		reduce(type) {
			//
			this.assertClosed();

			//
			const cached = this.reduceCache.get(type);
			if (cached !== undefined) {
				return cached;
			}

			// Check if we're already trying to reduce this node, in that case this is a recursion error
			if (this.reduceStack.has(type)) {
				//throw new ReduceRecursionError(`Reduce recursion error for ${this.inspect(type, true)}`);
				return new ___R$project$rome$$internal$js$analysis$types$UnknownT_ts$default(
					type.scope,
					type.originNode,
				);
			}

			//
			if (
				this.reduceStack.size >
				___R$$priv$project$rome$$internal$js$analysis$Utils_ts$MAX_DEPTH
			) {
				throw new Error("Max depth exceeded when reducing");
			}

			this.reduceStack.add(type);

			if (this.reduceCatchers.size) {
				for (const set of this.reduceCatchers) {
					set.add(type);
				}
			}

			try {
				const reduced = type.reduce();

				if (reduced === undefined) {
					throw new Error(
						"The reduce() method for " +
						this.inspect(type, true) +
						" returned null",
					);
				}

				if (reduced.getConstructor().type === "OpenT") {
					throw new Error(
						"The reduce() method for " +
						this.inspect(type, true) +
						" returned an OpenT. This should never be possible. It likely forgot to return utils.reduce() on it.",
					);
				}

				if (!this.debug) {
					this.reduceCache.set(type, reduced);
				}

				return reduced;
			} finally {
				this.reduceStack.delete(type);
			}
		}

		reduceCatch(type) {
			const involved = new Set();
			this.reduceCatchers.add(involved);

			const final = this.reduce(type);
			this.reduceCatchers.delete(involved);

			return {final, involved};
		}
	}


  // project-rome/@internal/js-analysis/Hub.ts
const ___R$$priv$project$rome$$internal$js$analysis$Hub_ts$statuses = {
		OPEN: 0,
		CLOSING: 1,
		CLOSED: 2,
	};

	class ___R$project$rome$$internal$js$analysis$Hub_ts$default {
		constructor(ast, project) {
			this.context = new ___R$project$rome$$internal$compiler$lib$CompilerContext_ts$default({
				ast,
				project,
				origin: {
					category: "typeChecking",
				},
			});
			this.utils = new ___R$project$rome$$internal$js$analysis$Utils_ts$default(
				this,
			);
			this.graph = new ___R$project$rome$$internal$js$analysis$Graph_ts$default();
			this.evaluator = new ___R$project$rome$$internal$js$analysis$Evaluator_ts$default(
				this,
				ast.filename,
			);
			this.status = ___R$$priv$project$rome$$internal$js$analysis$Hub_ts$statuses.OPEN;
		}

		close() {
			this.status = ___R$$priv$project$rome$$internal$js$analysis$Hub_ts$statuses.CLOSING;

			for (const [node] of this.graph.nodesByValue) {
				this.utils.reduce(node);
			}

			this.status = ___R$$priv$project$rome$$internal$js$analysis$Hub_ts$statuses.CLOSED;
		}

		isClosing() {
			return (
				this.status ===
				___R$$priv$project$rome$$internal$js$analysis$Hub_ts$statuses.CLOSING
			);
		}

		isOpen() {
			return (
				this.isClosing() ||
				this.status ===
				___R$$priv$project$rome$$internal$js$analysis$Hub_ts$statuses.OPEN
			);
		}

		isClosed() {
			return (
				this.isClosing() ||
				this.status ===
				___R$$priv$project$rome$$internal$js$analysis$Hub_ts$statuses.CLOSED
			);
		}

		assertOpen() {
			if (this.isClosed() && !this.isClosing()) {
				throw new Error(
					"This method can only be called when the graph has been open",
				);
			}
		}

		assertClosed() {
			if (this.isOpen() && !this.isClosing()) {
				throw new Error(
					"This method can only be called when the graph has been closed",
				);
			}
		}
	}


  // project-rome/@internal/js-analysis/api/buildGraph.ts
async function ___R$project$rome$$internal$js$analysis$api$buildGraph_ts$default(
		opts,
	) {
		const {ast, connected, project, provider} = opts;

		const hub = new ___R$project$rome$$internal$js$analysis$Hub_ts$default(
			ast,
			project,
		);
		const {evaluator} = hub;
		if (provider.libs !== undefined) {
			let body = [];
			for (const ast of provider.libs) {
				body = [...body, ...ast.body];
			}
			evaluator.seed(Object.assign({}, ast, {body}));
		}
		evaluator.seed(ast);

		// fetch imports
		if (connected) {
			// create graphs
			const graphs = new Map();
			async function getModuleSignature(source, relative) {
				const graphKey = relative + ":" + source;
				if (graphs.has(graphKey)) {
					// already prepared graph
					return graphs.get(graphKey);
				}

				// query the provider for the export types
				const graph = await provider.getExportTypes(relative, source);

				// check if the resolved graph even exists
				if (graph === undefined) {
					// TODO unknown module, create an error
					graphs.set(graphKey, undefined);
					return undefined;
				}

				// check if we've already initialised this graph before, in the case of different relative URLs
				if (graphs.has(graph.filename)) {
					// TODO this is pretty inefficient, we shouldn't even receive it
					const manager = graphs.get(graph.filename);
					graphs.set(graphKey, manager);
					return manager;
				}

				// create the graph
				const manager = evaluator.initModuleSignature(graph, getModuleSignature);
				graphs.set(graphKey, manager);
				graphs.set(graph.filename, manager);
				await manager.init();
				return manager;
			}

			// seed graphs
			const seedCache = new Set();
			await Promise.all(
				evaluator.imports.map(({source, relative}) => {
					const cacheKey = source + ":" + relative;
					if (seedCache.has(cacheKey)) {
						return undefined;
					}

					seedCache.add(cacheKey);
					return getModuleSignature(source, relative);
				}),
			);

			// link imports
			for (const {source, importedName, relative, type} of evaluator.imports) {
				const graphKey = relative + ":" + source;
				const graph = graphs.get(graphKey);
				if (graph === undefined) {
					// unknown module, an error would have been created in the initial graph prep
					continue;
				}

				if (importedName === undefined) {
					// nothing to link here!
					continue;
				}

				type.setAbsolute(graph.filename);
				graph.link(importedName, type);
			}
		}

		evaluator.intrinsics.link();
		hub.close();
		return hub;
	}


  // project-rome/@internal/js-analysis/api/getModuleSignature.ts
const ___R$$priv$project$rome$$internal$js$analysis$api$getModuleSignature_ts$exportsCache = new WeakMap();

	async function ___R$project$rome$$internal$js$analysis$api$getModuleSignature_ts$default(
		opts,
	) {
		const {ast, provider} = opts;
		const {filename} = ast;

		if (filename.includes("node_modules")) {
			return {
				filename,
				exports: [],
				types: {},
			};
		}

		const cached = ___R$$priv$project$rome$$internal$js$analysis$api$getModuleSignature_ts$exportsCache.get(
			ast,
		);
		if (cached !== undefined) {
			return cached;
		}

		const {
			evaluator: {exports},
			utils,
		} = await ___R$project$rome$$internal$js$analysis$api$buildGraph_ts$default({
			ast,
			project: opts.project,
			connected: false,
			provider,
		});
		const types = {};
		const exportMap = [];

		const added = new Set();

		function addType(type) {
			const reducedType = utils.reduce(type);
			if (added.has(reducedType)) {
				return reducedType.id;
			} else {
				added.add(reducedType);
			}

			// export errors as any types to suppress errors
			if (
				reducedType instanceof
				___R$project$rome$$internal$js$analysis$types$errors$E_ts$default
			) {
				types[reducedType.id] = {
					human: undefined,
					origin: reducedType.originLoc,
					type: "AnyT",
					data: {},
				};
				return reducedType.id;
			}

			const data = reducedType.serialize(addType);

			types[reducedType.id] = {
				human: reducedType.human,
				origin: reducedType.originLoc,
				type: reducedType.getConstructor().type,
				data,
			};
			return reducedType.id;
		}

		for (const def of exports) {
			if (def.type === "all") {
				exportMap.push({
					type: "all",
					source: def.source,
				});
			} else if (def.type === "local") {
				exportMap.push({
					type: "local",
					name: def.name,
					value: addType(def.value),
				});
			} else {
				throw new Error("unknown export def type");
			}
		}

		const result = {
			filename,
			exports: exportMap,
			types,
		};
		___R$$priv$project$rome$$internal$js$analysis$api$getModuleSignature_ts$exportsCache.set(
			ast,
			result,
		);
		return result;
	}


  // project-rome/@internal/js-analysis/api/check.ts
async function ___R$project$rome$$internal$js$analysis$api$check_ts$default(
		opts,
	) {
		const hub = await ___R$project$rome$$internal$js$analysis$api$buildGraph_ts$default({
			ast: opts.ast,
			connected: true,
			provider: opts.provider,
			project: opts.project,
		});
		___R$$priv$project$rome$$internal$js$analysis$api$check_ts$resolveGraph(hub);
		return hub.context.diagnostics.getDiagnostics();
	}

	function ___R$$priv$project$rome$$internal$js$analysis$api$check_ts$isError(t) {
		return (
			t !== undefined &&
			t instanceof
			___R$project$rome$$internal$js$analysis$types$errors$E_ts$default
		);
	}

	function ___R$$priv$project$rome$$internal$js$analysis$api$check_ts$resolveGraph(
		hub,
	) {
		const {graph, utils, context} = hub;

		// we track caught errors here as if a normal type returns a error in it's reduce() method

		// then it will be added to the graph, however we'd have already dealt with it
		const caughtErrors = new Set();

		for (const node of graph.nodes) {
			const lower = node.value;

			// unconnected node, we'll resolve these if they've been connected to any nodes
			if (
				lower instanceof
				___R$project$rome$$internal$js$analysis$types$OpenT_ts$default
			) {
				continue;
			}

			// see if this reduces to a type error
			const reduced = utils.reduce(lower);
			if (
				reduced instanceof
				___R$project$rome$$internal$js$analysis$types$errors$E_ts$default
			) {
				if (caughtErrors.has(reduced)) {
					continue;
				} else {
					caughtErrors.add(reduced);
				}

				let {description, lowerTarget, upperTarget} = reduced.getError();

				// ignore errors inside
				if (
					___R$$priv$project$rome$$internal$js$analysis$api$check_ts$isError(
						lowerTarget,
					) ||
					___R$$priv$project$rome$$internal$js$analysis$api$check_ts$isError(
						upperTarget,
					)
				) {
					continue;
				}

				let advice = [];

				if (upperTarget !== undefined) {
					const marker =
						upperTarget && !(upperTarget instanceof reduced.constructor)
							? utils.humanize(upperTarget)
							: undefined;
					const {originLoc} = upperTarget;

					if (originLoc !== undefined && marker !== undefined) {
						advice.push({
							type: "log",
							category: "info",
							text: marker,
						});
					} else if (originLoc !== undefined) {
						advice.push({
							type: "frame",
							location: {
								filename: originLoc.filename,
								start: originLoc.start,
								end: originLoc.end,
								marker,
							},
						});
					}
				}

				description = Object.assign(
					{},
					description,
					{advice: [...advice, ...description.advice]},
				);

				context.addNodeDiagnostic(
					lowerTarget.originNode,
					description,
					{
						marker: lowerTarget && !(lowerTarget instanceof reduced.constructor)
							? utils.humanize(lowerTarget)
							: undefined,
					},
				);
				continue;
			}

			// ignore unconnected nodes
			if (node.lines.length === 0) {
				continue;
			}

			for (const line of node.lines) {
				const upper = line.value;
				const compatibility = utils.checkCompability(upper, lower);

				if (compatibility.type === "incompatible") {
					// ignore associated errors, as they've already been handled
					if (
						___R$$priv$project$rome$$internal$js$analysis$api$check_ts$isError(
							compatibility.lower,
						) ||
						___R$$priv$project$rome$$internal$js$analysis$api$check_ts$isError(
							compatibility.upper,
						)
					) {
						continue;
					}

					context.addNodeDiagnostic(
						compatibility.lower.originNode,
						___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.TYPE_CHECK.INCOMPATIBILITY(
							utils.humanize(upper),
							upper.originLoc,
						),
						{
							marker: utils.humanize(compatibility.lower),
						},
					);
				}
			}
		}

		return context.diagnostics.getDiagnostics();
	}


  // project-rome/@internal/js-analysis/types.ts
const ___R$project$rome$$internal$js$analysis$types_ts = {};


  // project-rome/@internal/js-analysis/index.ts
const ___R$project$rome$$internal$js$analysis$index_ts = {
		get getModuleSignature() {
			return ___R$project$rome$$internal$js$analysis$api$getModuleSignature_ts$default;
		},
		get buildGraph() {
			return ___R$project$rome$$internal$js$analysis$api$buildGraph_ts$default;
		},
		get check() {
			return ___R$project$rome$$internal$js$analysis$api$check_ts$default;
		},
	};
	Object.keys(___R$project$rome$$internal$js$analysis$types$index_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$js$analysis$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$js$analysis$types$index_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$internal$js$analysis$types_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$internal$js$analysis$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$internal$js$analysis$types_ts[key];
				},
			},
		);
	});


  // project-rome/@internal/core/worker/WorkerAPI.ts
// Some Windows git repos will automatically convert Unix line endings to Windows
	// This retains the line endings for the formatted code if they were present in the source
	function ___R$$priv$project$rome$$internal$core$worker$WorkerAPI_ts$normalizeFormattedLineEndings(
		sourceText,
		formatted,
	) {
		if (sourceText.includes("\r")) {
			return formatted.replace(/\n/g, "\r\n");
		} else {
			return formatted;
		}
	}

	class ___R$project$rome$$internal$core$worker$WorkerAPI_ts$default {
		constructor(worker) {
			this.worker = worker;
			this.logger = worker.logger;
		}

		interceptDiagnostics(val, {astModifiedFromSource}) {
			if (astModifiedFromSource) {
				const diagnostics = val.diagnostics.map((diag) => {
					return Object.assign(
						{},
						diag,
						{
							metadata: Object.assign(
								{},
								diag.description,
								{
									advice: [
										...diag.description.advice,
										{
											type: "log",
											category: "warn",
											text: "We manipulated this file before parsing it so the source locations are likely incorrect",
										},
									],
								},
							),
						},
					);
				});

				return Object.assign({}, val, {diagnostics});
			} else {
				return val;
			}
		}

		async moduleSignatureJS(ref, parseOptions) {
			const {ast, project} = await this.worker.parse(ref, parseOptions);

			if (ast.type !== "JSRoot") {
				throw new Error(
					"Expected a JSRoot for moduleSignatureJS but got " + ast.type,
				);
			}

			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Generating module signature: ${ref.real}`,
			);

			return await ___R$project$rome$$internal$js$analysis$index_ts.getModuleSignature({
				ast,
				project,
				provider: await this.worker.getTypeCheckProvider(
					ref.project,
					{},
					parseOptions,
				),
			});
		}

		async updateInlineSnapshots(ref, updates, parseOptions) {
			let {ast, mtime} = await this.worker.parse(ref, parseOptions);

			const appliedUpdatesToCallees = new Set();
			const pendingUpdates = new Set(updates);
			const context = new ___R$project$rome$$internal$compiler$lib$CompilerContext_ts$default({
				ast,
				ref,
			});
			ast = context.reduceRoot({
				name: "updateInlineSnapshots",
				enter(path) {
					const {node} = path;
					if (node.type !== "JSCallExpression" || pendingUpdates.size === 0) {
						return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
					}

					let matchedUpdate;

					const {callee} = node;
					for (const {node} of ___R$project$rome$$internal$js$ast$utils$getNodeReferenceParts_ts$getNodeReferenceParts(
						callee,
					).parts) {
						const {loc} = node;
						if (loc === undefined) {
							continue;
						}

						for (const update of pendingUpdates) {
							if (
								loc.start.column === update.column &&
								loc.start.line === update.line
							) {
								matchedUpdate = update;
								break;
							}
						}

						if (matchedUpdate !== undefined) {
							break;
						}
					}

					if (matchedUpdate !== undefined) {
						if (appliedUpdatesToCallees.has(callee)) {
							context.addNodeDiagnostic(
								node,
								___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SNAPSHOTS.INLINE_COLLISION,
							);
							return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
						}

						pendingUpdates.delete(matchedUpdate);
						appliedUpdatesToCallees.add(callee);

						const args = node.arguments;
						if (args.length < 1) {
							context.addNodeDiagnostic(
								node,
								___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SNAPSHOTS.INLINE_MISSING_RECEIVED,
							);
							return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
						}

						return ___R$project$rome$$internal$compiler$index_ts$signals.replace(
							Object.assign(
								{},
								node,
								{
									arguments: [
										args[0],
										___R$project$rome$$internal$js$ast$utils$valueToNode_ts$valueToNode(
											matchedUpdate.snapshot,
										),
									],
								},
							),
						);
					}

					return ___R$project$rome$$internal$compiler$index_ts$signals.retain;
				},
			});

			const diags = context.diagnostics.getDiagnostics();

			if (pendingUpdates.size > 0 && diags.length === 0) {
				throw new Error(
					pendingUpdates.size +
					" left over inline snapshots that were not updated " +
					JSON.stringify(Array.from(pendingUpdates)),
				);
			}

			let file;

			if (diags.length === 0) {
				const formatted = ___R$project$rome$$internal$formatter$index_ts$formatAST(
					ast,
				).code;
				file = {
					type: "WRITE",
					content: formatted,
					mtime,
				};
			}

			return {diagnostics: diags, file};
		}

		async analyzeDependencies(ref, parseOptions) {
			const project = this.worker.getProject(ref.project);
			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Analyze dependencies: ${ref.real}`,
			);

			const parseResult = await ___R$project$rome$$internal$diagnostics$wrap_ts$catchDiagnostics(async () =>
				this.worker.parse(ref, parseOptions)
			);

			if (parseResult.diagnostics !== undefined) {
				return Object.assign(
					{},
					___R$project$rome$$internal$core$common$types$analyzeDependencies_ts$UNKNOWN_ANALYZE_DEPENDENCIES_RESULT,
					{diagnostics: parseResult.diagnostics},
				);
			}

			const {ast, sourceText, astModifiedFromSource} = parseResult.value;

			const analyzeResult = await ___R$project$rome$$internal$diagnostics$wrap_ts$catchDiagnostics(async () =>
				this.interceptDiagnostics(
					await ___R$project$rome$$internal$compiler$api$analyzeDependencies$index_ts$default({
						ref,
						ast,
						sourceText,
						project,
						options: {},
					}),
					{astModifiedFromSource},
				)
			);

			if (analyzeResult.diagnostics !== undefined) {
				return Object.assign(
					{},
					___R$project$rome$$internal$core$common$types$analyzeDependencies_ts$UNKNOWN_ANALYZE_DEPENDENCIES_RESULT,
					{diagnostics: analyzeResult.diagnostics},
				);
			}

			return analyzeResult.value;
		}

		async workerCompilerOptionsToCompilerOptions(
			ref,
			workerOptions,
			parseOptions,
		) {
			const ___R$ = workerOptions;
			const options = Object.assign({}, ___R$);
			delete options.bundle;
			const {bundle} = ___R$;
			if (bundle === undefined) {
				return options;
			} else {
				return Object.assign(
					{},
					options,
					{
						bundle: Object.assign(
							{},
							bundle,
							{analyze: await this.analyzeDependencies(ref, parseOptions)},
						),
					},
				);
			}
		}

		async compile(ref, stage, options, parseOptions) {
			const {ast, project, sourceText, astModifiedFromSource} = await this.worker.parse(
				ref,
				parseOptions,
			);
			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Compiling: ${ref.real}`,
			);

			const compilerOptions = await this.workerCompilerOptionsToCompilerOptions(
				ref,
				options,
				parseOptions,
			);
			return this.interceptDiagnostics(
				await ___R$project$rome$$internal$compiler$api$compile_ts$default({
					ref,
					ast,
					sourceText,
					options: compilerOptions,
					project,
					stage,
				}),
				{astModifiedFromSource},
			);
		}

		async parse(ref, opts) {
			let {ast, astModifiedFromSource} = await this.worker.parse(
				ref,
				Object.assign({}, opts, {sourceTypeJS: opts.sourceTypeJS, cache: false}),
			);

			return this.interceptDiagnostics(ast, {astModifiedFromSource});
		}

		async format(ref, formatOptions, parseOptions) {
			const res = await this._format(ref, formatOptions, parseOptions);
			if (res === undefined) {
				return undefined;
			} else {
				return {
					formatted: ___R$$priv$project$rome$$internal$core$worker$WorkerAPI_ts$normalizeFormattedLineEndings(
						res.sourceText,
						res.formatted,
					),
					original: res.sourceText,
					diagnostics: res.diagnostics,
					suppressions: res.suppressions,
				};
			}
		}

		async _format(ref, formatOptions, parseOptions) {
			const project = this.worker.getProject(ref.project);
			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Formatting: ${ref.real}`,
			);

			const {handler} = ___R$project$rome$$internal$core$common$file$handlers$index_ts$getFileHandlerFromPathAssert(
				ref.real,
				project.config,
			);

			if (!handler.capabilities.format) {
				return;
			}

			const {customFormat} = handler;
			if (customFormat !== undefined) {
				return await customFormat({
					mtime: await this.worker.getMtime(ref.real),
					file: ref,
					project,
					worker: this.worker,
					parseOptions,
				});
			}

			const {ast, mtime, sourceText, astModifiedFromSource} = await this.worker.parse(
				ref,
				parseOptions,
			);

			const out = ___R$project$rome$$internal$formatter$index_ts$formatAST(
				ast,
				formatOptions,
			);

			return this.interceptDiagnostics(
				{
					mtime,
					formatted: out.code,
					sourceText,
					suppressions: [],
					diagnostics: ast.diagnostics,
				},
				{astModifiedFromSource},
			);
		}

		async lint(ref, options, parseOptions) {
			const project = this.worker.getProject(ref.project);
			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Linting: ${ref.real}`,
			);

			// Get the extension handler
			const {handler} = ___R$project$rome$$internal$core$common$file$handlers$index_ts$getFileHandlerFromPathAssert(
				ref.real,
				project.config,
			);

			if (!handler.capabilities.lint && !handler.capabilities.format) {
				return {
					save: undefined,
					diagnostics: [],
					suppressions: [],
				};
			}

			// Catch any diagnostics, in the case of syntax errors etc
			const res = await ___R$project$rome$$internal$diagnostics$wrap_ts$catchDiagnostics(
				() => {
					if (handler.capabilities.lint) {
						return this.compilerLint(ref, options, parseOptions);
					} else {
						return this._format(ref, {}, parseOptions);
					}
				},
				{
					category: "lint",
					message: "Caught by WorkerAPI.lint",
				},
			);

			// These are fatal diagnostics
			if (res.diagnostics !== undefined) {
				return {
					save: undefined,
					suppressions: [],
					diagnostics: res.diagnostics,
				};
			}

			// `format` could have return undefined
			if (res.value === undefined) {
				return {
					save: undefined,
					diagnostics: [],
					suppressions: [],
				};
			}

			// These are normal diagnostics returned from the linter
			const {
				sourceText,
				diagnostics,
				suppressions,
				mtime,
			} = res.value;

			const formatted = ___R$$priv$project$rome$$internal$core$worker$WorkerAPI_ts$normalizeFormattedLineEndings(
				sourceText,
				res.value.formatted,
			);

			// If the file has pending fixes
			const needsSave = formatted !== sourceText;

			// Autofix if necessary
			if (options.save && needsSave) {
				return {
					save: {
						type: "WRITE",
						mtime,
						content: formatted,
					},
					diagnostics,
					suppressions,
				};
			}

			// If there's no pending fix then no need for diagnostics
			if (!needsSave) {
				return {
					save: undefined,
					diagnostics,
					suppressions,
				};
			}

			// Add pending autofix diagnostic
			return {
				save: undefined,
				suppressions,
				diagnostics: [
					...diagnostics,
					{
						tags: {fixable: true},
						location: {
							filename: ref.uid,
						},
						description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.LINT.PENDING_FIXES(
							ref.relative.join(),
							handler.language,
							sourceText,
							formatted,
						),
					},
				],
			};
		}

		async compilerLint(ref, options, parseOptions) {
			const {ast, mtime, sourceText, project, astModifiedFromSource} = await this.worker.parse(
				ref,
				parseOptions,
			);

			// Run the compiler in lint-mode which is where all the rules are actually ran
			const res = await ___R$project$rome$$internal$compiler$lint$index_ts$default({
				applySafeFixes: options.applySafeFixes,
				suppressionExplanation: options.suppressionExplanation,
				ref,
				options: {
					lint: options.compilerOptions,
				},
				ast,
				project,
				sourceText,
			});

			// Extract lint diagnostics
			let {diagnostics} = res;

			// Only enable typechecking if enabled in .romeconfig
			let typeCheckingEnabled = project.config.typeCheck.enabled;
			if (project.config.typeCheck.libs.has(ref.real)) {
				// don't typecheck lib files
				typeCheckingEnabled = false;
			}

			// Run type checking if necessary
			if (typeCheckingEnabled && ast.type === "JSRoot") {
				const typeCheckProvider = await this.worker.getTypeCheckProvider(
					ref.project,
					options.prefetchedModuleSignatures,
					parseOptions,
				);
				const typeDiagnostics = await ___R$project$rome$$internal$js$analysis$index_ts.check({
					ast,
					provider: typeCheckProvider,
					project,
				});
				diagnostics = [...diagnostics, ...typeDiagnostics];
			}

			return this.interceptDiagnostics(
				{
					suppressions: res.suppressions,
					diagnostics,
					sourceText,
					formatted: res.src,
					mtime,
				},
				{astModifiedFromSource},
			);
		}
	}


  // project-rome/@internal/core/worker/utils/applyWorkerBufferPatch.ts
function ___R$project$rome$$internal$core$worker$utils$applyWorkerBufferPatch_ts$applyWorkerBufferPatch(
		original,
		{range: {start, end}, text},
	) {
		let currLine = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;
		let currChar = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;
		let cursor = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;

		let buffer;

		// Offset based on UTF-16 code units
		while (
			___R$project$rome$$internal$ob1$index_ts$ob1Get0(cursor) <=
			original.length
		) {
			// Start position
			if (currLine === start.line && currChar === start.character) {
				// Include anything before the start of the patch range
				const preText = original.slice(
					0,
					___R$project$rome$$internal$ob1$index_ts$ob1Get0(cursor),
				);
				buffer = preText + text;
			}

			// End position
			if (currLine === end.line && currChar === end.character) {
				if (buffer === undefined) {
					// Start position was not encountered
					return undefined;
				}
				// Append anything after the end of the patch range
				const postText = original.slice(
					___R$project$rome$$internal$ob1$index_ts$ob1Get0(cursor),
				);
				buffer += postText;
				return buffer;
			}

			switch (original[___R$project$rome$$internal$ob1$index_ts$ob1Get0(cursor)]) {
				case "\n": {
					currLine = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(currLine);
					currChar = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;
					break;
				}
				case "\r": {
					currLine = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(currLine);
					currChar = ___R$project$rome$$internal$ob1$index_ts$ob1Number0;

					//  \r\n should only advance 1 line
					if (
						original[___R$project$rome$$internal$ob1$index_ts$ob1Get0(cursor) +
						1] ===
						"\n"
					) {
						cursor = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(cursor);
					}
					break;
				}
				default: {
					currChar = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(currChar);
				}
			}

			cursor = ___R$project$rome$$internal$ob1$index_ts$ob1Inc(cursor);
		}

		// End position was not encountered
		return undefined;
	}


  // project-rome/@internal/core/worker/Worker.ts
class ___R$project$rome$$internal$core$worker$Worker_ts$default {
		constructor(opts) {
			this.bridge = opts.bridge;

			this.userConfig = opts.userConfig;
			this.partialManifests = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
				"partialManifests",
			);
			this.projects = new Map();
			this.astCache = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
			this.moduleSignatureCache = new ___R$project$rome$$internal$path$collections_ts$UnknownPathMap();
			this.buffers = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
			this.virtualModules = new ___R$project$rome$$internal$core$common$VirtualModules_ts$default();

			this.logger = new ___R$project$rome$$internal$core$common$utils$Logger_ts$default(
				{},
				{
					loggerType: "worker",
					check: () => opts.bridge.log.hasSubscribers(),
					write(chunk) {
						opts.bridge.log.send(chunk.toString());
					},
				},
			);
			opts.bridge.updatedListenersEvent.subscribe(() => {
				this.logger.updateStream();
			});

			this.api = new ___R$project$rome$$internal$core$worker$WorkerAPI_ts$default(
				this,
			);

			if (opts.dedicated) {
				___R$project$rome$$internal$core$common$utils$setupGlobalErrorHandlers_ts$default((
					err,
				) => {
					try {
						// Dispatch error to the server and trigger a fatal
						opts.bridge.fatalError.send(opts.bridge.serializeError(err));
					} catch (err) {
						if (
							!(err instanceof
							___R$project$rome$$internal$events$BridgeError_ts$default)
						) {
							console.error(
								"Worker encountered error while attempting to send a fatal to the server",
							);
							console.error(err.stack);
						}
						process.exit(1);
					}
				});

				// Pretty sure we'll hit another error condition before this but for completeness
				/*opts.bridge.monitorHeartbeat(
				LAG_INTERVAL,
				({iterations, totalTime}) => {
					if (iterations >= 5) {
						console.error(`Server has not responded for ${totalTime}ms. Exiting.`)
						process.exit(1);
					}
				},
			);*/
			}
		}

		getPartialManifest(id) {
			return this.partialManifests.assert(id);
		}

		end() {
			// This will only actually be called when a Worker is created inside of the Server
			// Clear internal maps for memory, in case the Worker instance sticks around
			this.astCache.clear();
			this.projects.clear();
			this.moduleSignatureCache.clear();
		}

		async init() {
			this.virtualModules.init();

			const bridge = this.bridge;

			bridge.endEvent.subscribe(() => {
				this.end();
			});

			let profiler;
			bridge.profilingStart.subscribe(async (data) => {
				if (profiler !== undefined) {
					throw new Error("Expected no profiler to be running");
				}
				profiler = new ___R$project$rome$$internal$v8$Profiler_ts$default();
				await profiler.startProfiling(data.samplingInterval);
			});

			bridge.profilingStop.subscribe(async () => {
				if (profiler === undefined) {
					throw new Error("Expected a profiler to be running");
				}
				const workerProfile = await profiler.stopProfiling();
				profiler = undefined;
				return workerProfile;
			});

			bridge.compile.subscribe((payload) => {
				return this.api.compile(
					payload.ref,
					payload.stage,
					payload.options,
					payload.parseOptions,
				);
			});

			bridge.parse.subscribe((payload) => {
				return this.api.parse(payload.ref, payload.options);
			});

			bridge.lint.subscribe((payload) => {
				return this.api.lint(payload.ref, payload.options, payload.parseOptions);
			});

			bridge.format.subscribe((payload) => {
				return this.api.format(
					payload.ref,
					payload.options,
					payload.parseOptions,
				);
			});

			bridge.updateInlineSnapshots.subscribe((payload) => {
				return this.api.updateInlineSnapshots(
					payload.ref,
					payload.updates,
					payload.parseOptions,
				);
			});

			bridge.analyzeDependencies.subscribe((payload) => {
				return this.api.analyzeDependencies(payload.ref, payload.parseOptions);
			});

			bridge.evict.subscribe((payload) => {
				this.evict(
					___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
						payload.filename,
					),
				);
				return undefined;
			});

			bridge.moduleSignatureJS.subscribe((payload) => {
				return this.api.moduleSignatureJS(payload.ref, payload.parseOptions);
			});

			bridge.updateProjects.subscribe((payload) => {
				return this.updateProjects(payload.projects);
			});

			bridge.updateManifests.subscribe((payload) => {
				return this.updateManifests(payload.manifests);
			});

			bridge.status.subscribe(() => {
				return {
					astCacheSize: this.astCache.size,
					pid: process.pid,
					memoryUsage: process.memoryUsage(),
					uptime: process.uptime(),
				};
			});

			bridge.getBuffer.subscribe((payload) => {
				return this.getBuffer(payload.ref);
			});

			bridge.updateBuffer.subscribe((payload) => {
				return this.updateBuffer(payload.ref, payload.content);
			});

			bridge.patchBuffer.subscribe((payload) => {
				return this.patchBuffer(payload.ref, payload.patches);
			});

			bridge.clearBuffer.subscribe((payload) => {
				return this.clearBuffer(payload.ref);
			});

			bridge.getFileBuffers.subscribe(() => {
				return this.getFileBuffers();
			});
		}

		getBuffer(ref) {
			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Returned ${ref.real} buffer`,
			);
			return this.buffers.get(ref.real);
		}

		clearBuffer({real}) {
			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Cleared ${real} buffer`,
			);
			this.buffers.delete(real);
			this.evict(real);
		}

		updateBuffer(ref, content) {
			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Updated ${ref.real} buffer`,
			);
			this.buffers.set(ref.real, content);
			this.evict(ref.real);
		}

		getFileBuffers() {
			return Array.from(
				this.buffers,
				([path, content]) => ({filename: path.join(), content}),
			);
		}

		patchBuffer(ref, patches) {
			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Patched ${ref.real} buffer`,
			);
			let buffer = this.buffers.assert(ref.real);

			// Patches must be applied sequentially
			for (const patch of patches) {
				buffer = ___R$project$rome$$internal$core$worker$utils$applyWorkerBufferPatch_ts$applyWorkerBufferPatch(
					buffer,
					patch,
				);

				if (buffer === undefined) {
					throw new Error("Invalid patch for buffer of " + ref.real.join());
				}
			}

			this.buffers.set(ref.real, buffer);
			this.evict(ref.real);
			return buffer;
		}

		async getTypeCheckProvider(
			projectId,
			prefetchedModuleSignatures = {},
			parseOptions,
		) {
			const libs = [];

			// TODO Figure out how to get the uids for the libraries, probably adding some additional stuff to ProjectConfig?

			/*
    const projectConfig = this.getProjectConfig(projectId);
    for (const filename of projectConfig.typeChecking.libs) {
      const {ast, err} = await this.parse(filename, uid, projectId);
      if (err) {
        throw err;
      } else {
        invariant(ast, 'expected ast');
        libs.push(ast);
      }
    }
    */
			const resolveGraph = async (key) => {
				const value = prefetchedModuleSignatures[key];
				if (value === undefined) {
					return undefined;
				}

				switch (value.type) {
					case "RESOLVED": {
						this.moduleSignatureCache.set(
							___R$project$rome$$internal$path$index_ts$createUnknownPath(
								value.graph.filename,
							),
							value.graph,
						);
						return value.graph;
					}

					case "OWNED":
						return this.api.moduleSignatureJS(value.ref, parseOptions);

					case "POINTER":
						return resolveGraph(value.key);

					case "USE_CACHED": {
						return this.moduleSignatureCache.assert(
							___R$project$rome$$internal$path$index_ts$createUnknownPath(
								value.filename,
							),
						);
					}
				}
			};

			return {
				getExportTypes: async (origin, relative) => {
					return resolveGraph(origin + ":" + relative);
				},
				libs,
			};
		}

		async readFile(path) {
			const buffer = this.buffers.get(path);
			if (buffer !== undefined) {
				return buffer;
			}

			const virtual = this.virtualModules.getPossibleVirtualFileContents(path);
			if (virtual !== undefined) {
				return virtual;
			}

			return await ___R$project$rome$$internal$fs$index_ts$readFileText(path);
		}

		async parse(ref, options) {
			const path = ___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
				ref.real,
			);

			const {project: projectId, uid} = ref;
			const project = this.getProject(projectId);

			// Fetch and validate extension handler
			const {handler} = ___R$project$rome$$internal$core$common$file$handlers$index_ts$getFileHandlerFromPathAssert(
				ref.real,
				project.config,
			);
			if (handler.parse === undefined) {
				throw new Error("We don't know how to parse " + path);
			}

			// Get source type
			let sourceTypeJS;
			if (options.sourceTypeJS !== undefined) {
				sourceTypeJS = options.sourceTypeJS;
			} else if (handler.sourceTypeJS !== undefined) {
				sourceTypeJS = handler.sourceTypeJS;
			} else {
				sourceTypeJS = "script";

				if (ref.manifest !== undefined) {
					const manifest = this.getPartialManifest(ref.manifest);
					if (manifest.type === "module") {
						sourceTypeJS = "module";
					}
				}
			}

			const cacheEnabled = options.cache !== false;

			if (cacheEnabled) {
				// Update the lastAccessed of the ast cache and return it, it will be evicted on
				// any file change
				const cachedResult = this.astCache.get(path);
				if (cachedResult !== undefined) {
					let useCached = true;

					if (
						cachedResult.ast.type === "JSRoot" &&
						cachedResult.ast.sourceType !== sourceTypeJS
					) {
						useCached = false;
					}

					if (useCached) {
						this.astCache.set(
							path,
							Object.assign({}, cachedResult, {lastAccessed: Date.now()}),
						);
						return cachedResult;
					}
				}
			}

			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Parsing: ${path}`,
			);

			const mtime = await this.getMtime(path);

			let manifestPath;
			if (ref.manifest !== undefined) {
				manifestPath = this.getPartialManifest(ref.manifest).path.join();
			}

			const {sourceText, astModifiedFromSource, ast} = await handler.parse({
				sourceTypeJS,
				path: ___R$project$rome$$internal$path$index_ts$createUnknownPath(uid),
				manifestPath,
				mtime,
				file: ref,
				worker: this,
				project,
				parseOptions: options,
			});

			// If the AST is corrupt then we don't under any circumstance allow it
			if (ast.corrupt && !options.allowCorrupt) {
				throw new ___R$project$rome$$internal$diagnostics$errors_ts$DiagnosticsError(
					"Corrupt AST",
					ast.diagnostics,
				);
			}

			// Sometimes we may want to allow the "fixed" AST
			if (
				!options.allowParserDiagnostics &&
				!options.allowCorrupt &&
				ast.diagnostics.length > 0
			) {
				throw new ___R$project$rome$$internal$diagnostics$errors_ts$DiagnosticsError(
					"AST diagnostics aren't allowed",
					ast.diagnostics,
				);
			}

			const res = {
				ast,
				lastAccessed: Date.now(),
				sourceText,
				project,
				path,
				astModifiedFromSource,
				mtime,
			};

			if (cacheEnabled) {
				this.astCache.set(path, res);
			}

			return res;
		}

		// Get the file mtime to warn about outdated diagnostics
		// If we have a buffer or virtual module for this file then don't set an mtime since our diagnostics
		// explicitly do not match the file system
		async getMtime(path) {
			if (this.buffers.has(path) || this.virtualModules.isVirtualPath(path)) {
				return undefined;
			} else {
				const stat = await ___R$project$rome$$internal$fs$index_ts$lstat(path);
				return stat.mtimeMs;
			}
		}

		getProject(id) {
			const config = this.projects.get(id);
			if (config === undefined) {
				throw new Error(
					"Unknown project " +
					id +
					", known projects are " +
					this.projects.keys(),
				);
			}
			return config;
		}

		evict(path) {
			this.logger.info(
				___R$project$rome$$internal$markup$escape_ts$markup`Evicted ${path}`,
			);
			this.astCache.delete(path);
			this.moduleSignatureCache.delete(path);
		}

		updateManifests(manifests) {
			for (const {id, manifest} of manifests) {
				if (manifest === undefined) {
					this.partialManifests.delete(id);
				} else {
					this.partialManifests.set(id, manifest);
				}
			}
		}

		updateProjects(projects) {
			for (const {config, directory, id} of projects) {
				if (config === undefined) {
					this.projects.delete(id);
				} else {
					this.projects.set(
						id,
						{
							directory,
							config,
						},
					);
				}
			}
		}
	}


  // project-rome/@internal/core/test-worker/TestWorkerFile.ts
function ___R$project$rome$$internal$core$test$worker$TestWorkerFile_ts$cleanFrames(
		frames,
	) {
		// TODO we should actually get the frames before module init and do it that way
		// Remove everything before the original module factory
		let latestTestWorkerFrame = frames.find((frame, i) => {
			if (
				frame.typeName === "global" &&
				frame.methodName === undefined &&
				frame.functionName === undefined
			) {
				// We are the global.<anonymous> frame
				// Now check for Script.runInContext
				const nextFrame = frames[i + 1];
				if (
					nextFrame !== undefined &&
					nextFrame.typeName === "Script" &&
					nextFrame.methodName === "runInContext"
				) {
					// Yes!
					// TODO also check for ___$romefrontend$core$common$utils$executeMain_ts$default (internal/romefrontend/core/common/utils/executeMain.ts:69:17)
					return true;
				}
			}

			return false;
		});

		// And if there was no module factory frame, then we must be inside of a test
		if (latestTestWorkerFrame === undefined) {
			latestTestWorkerFrame = frames.find((frame) => {
				return (
					frame.filename !== undefined &&
					frame.filename.includes("TestWorkerFile")
				);
			});
		}

		if (latestTestWorkerFrame === undefined) {
			return frames;
		}

		return frames.slice(0, frames.indexOf(latestTestWorkerFrame));
	}

	class ___R$project$rome$$internal$core$test$worker$TestWorkerFile_ts$default {
		constructor(worker, bridge, opts) {
			this.opts = opts;
			this.locked = false;
			this.path = opts.path;
			this.options = opts;
			this.globalOptions = opts.globalOptions;
			this.bridge = bridge;
			this.worker = worker;
			this.projectDirectory = ___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
				opts.projectDirectory,
			);

			this.snapshotManager = new ___R$project$rome$$internal$core$test$worker$SnapshotManager_ts$default(
				this,
				___R$project$rome$$internal$path$index_ts$createAbsoluteFilePath(
					opts.path,
				),
			);

			this.onlyFocusedTests = false;
			this.hasDiagnostics = false;
			this.consoleAdvice = [];
			this.focusedTests = [];
			this.pendingDiagnostics = [];
			this.foundTests = new ___R$project$rome$$internal$collections$index_ts$ExtendedMap(
				"foundTests",
			);
		}

		createTestRef(test) {
			return {
				testName: test.name,
				path: this.path,
			};
		}

		createConsole() {
			const addDiagnostic = (category, args) => {
				const err = new Error();

				// Remove the first two frames to get to the actual source
				const struct = ___R$project$rome$$internal$v8$errors_ts$getErrorStructure(
					err,
				);
				const frames = ___R$project$rome$$internal$core$test$worker$TestWorkerFile_ts$cleanFrames(
					struct.frames.slice(2),
				);

				this.consoleAdvice.push(() => {
					let text;
					if (args.length === 1 && typeof args[0] === "string") {
						text = ___R$project$rome$$internal$markup$escape_ts$markup`${args[0]}`;
					} else {
						text = ___R$project$rome$$internal$markup$escape_ts$concatMarkup(
							args.map((arg) =>
								___R$project$rome$$internal$markup$escape_ts$serializeLazyMarkup(
									___R$project$rome$$internal$pretty$format$index_ts$default(
										arg,
										{allowCustom: false},
									),
								)
							),
							___R$project$rome$$internal$markup$escape_ts$markup` `,
						);
					}

					if (___R$project$rome$$internal$markup$escape_ts$isEmptyMarkup(text)) {
						text = ___R$project$rome$$internal$markup$escape_ts$markup`<dim>empty log</dim>`;
					}

					return [
						{
							type: "log",
							category,
							text,
						},
						...___R$project$rome$$internal$diagnostics$derive_ts$getErrorStackAdvice(
							Object.assign({}, struct, {frames}),
						),
					];
				});
			};

			function log(...args) {
				addDiagnostic("none", args);
			}

			return {
				assert(expression, ...args) {
					if (!expression) {
						args[0] =
							"Assertion failed" + (args.length === 0 ? "" : ": " + args[0]);
						addDiagnostic("warn", args);
					}
				},
				dir(obj) {
					addDiagnostic("info", [obj]);
				},
				error: (...args) => {
					addDiagnostic("error", args);
				},
				warn: (...args) => {
					addDiagnostic("warn", args);
				},
				dirxml: log,
				debug: log,
				info: (...args) => {
					addDiagnostic("info", args);
				},
				log,
				trace: log,
				// Noop
				count() {},
				countReset() {},
				table() {},
				time() {},
				timeEnd() {},
				timeLog() {},
				clear() {},
				group() {},
				groupCollapsed() {},
				groupEnd() {},
				profile() {},
				profileEnd() {},
				timeStamp() {},
			};
		}

		//  Global variables to expose to tests
		getEnvironment() {
			const testOptions = {
				dirname: this.path.getParent().join(),
				register: (callsiteError, opts, callback) => {
					this.registerTest(callsiteError, opts, callback);
				},
			};

			return {
				__ROME__TEST_OPTIONS__: testOptions,
				console: this.createConsole(),
			};
		}

		// execute the test file and discover tests
		async discoverTests() {
			const code = this.worker.serializeAssembled(this.opts.assembled);

			try {
				const res = await ___R$project$rome$$internal$core$common$utils$executeMain_ts$default({
					path: this.path,
					code,
					globals: this.getEnvironment(),
				});

				if (res.syntaxError !== undefined) {
					const message = ___R$project$rome$$internal$markup$escape_ts$markup`A bundle was generated that contained a syntax error: ${___R$project$rome$$internal$markup$escape_ts$readMarkup(
						res.syntaxError.description.message,
					)}`;

					throw ___R$project$rome$$internal$diagnostics$errors_ts$createSingleDiagnosticError(
						Object.assign(
							{},
							res.syntaxError,
							{
								description: Object.assign(
									{},
									res.syntaxError.description,
									{message},
								),
								location: Object.assign(
									{},
									res.syntaxError.location,
									{filename: this.path.join()},
								),
								tags: Object.assign({}, res.syntaxError, {internal: true}),
							},
						),
					);
				}
			} catch (err) {
				await this.emitError({
					origin: {type: "EXECUTING"},
					error: err,
				});
			}

			// Emit error about no found tests. If we already have diagnostics then there was an issue
			// during initialization.
			if (this.foundTests.size === 0 && !this.hasDiagnostics) {
				await this.emitDiagnostic({
					location: {
						filename: this.path.join(),
					},
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.TESTS.UNDECLARED,
				});
			}
		}

		lockTests() {
			this.locked = true;
		}

		isFocusedTest({name, only}) {
			const {filter} = this.globalOptions;
			if (filter === undefined) {
				return only === true;
			} else {
				return name.includes(filter);
			}
		}

		registerTest(callsiteError, options, callback) {
			if (this.locked) {
				throw new Error("Test can't be added outside of init");
			}

			let testName = options.name;
			if (Array.isArray(testName)) {
				testName = testName.join(" > ");
			}

			if (this.foundTests.has(testName)) {
				throw new Error("Test " + testName + " has already been defined");
			}

			// Get the frame where this test was declared. We pop 1 off as the error is created inside the test function.
			const callsiteStruct = ___R$project$rome$$internal$v8$errors_ts$getErrorStructure(
				callsiteError,
				1,
			);
			const callsiteLocation = ___R$project$rome$$internal$v8$errors_ts$getDiagnosticLocationFromErrorFrame(
				callsiteStruct.frames[0],
			);

			const foundTest = {
				callsiteLocation,
				name: testName,
				callback,
				options,
			};

			this.foundTests.set(testName, foundTest);

			if (this.isFocusedTest(options)) {
				this.focusedTests.push({
					ref: this.createTestRef(foundTest),
					location: callsiteLocation,
				});

				if (!this.globalOptions.focusAllowed) {
					const diag = this.deriveDiagnosticFromErrorStructure(callsiteStruct);

					this.pendingDiagnostics.push(
						Object.assign(
							{},
							diag,
							{
								description: Object.assign(
									{},
									diag.description,
									{
										message: ___R$project$rome$$internal$markup$escape_ts$markup`Focused tests are not allowed due to a set flag`,
									},
								),
							},
						),
					);
				}
			}
		}

		async emitDiagnostic(diag, test) {
			let label = diag.label;
			if (label === undefined && test !== undefined) {
				label = ___R$project$rome$$internal$markup$escape_ts$markup`${test.name}`;
			}

			diag = Object.assign(
				{},
				diag,
				{label, tags: Object.assign({}, diag.tags, {unique: true})},
			);

			this.hasDiagnostics = true;
			await this.bridge.testDiagnostic.call({
				diagnostic: diag,
				origin: undefined,
				testPath: this.path,
			});
		}

		deriveDiagnosticFromErrorStructure(struct) {
			return ___R$project$rome$$internal$diagnostics$derive_ts$deriveDiagnosticFromErrorStructure(
				struct,
				{
					description: {
						category: "tests/failure",
					},
					filename: this.path.join(),
					cleanFrames: ___R$project$rome$$internal$core$test$worker$TestWorkerFile_ts$cleanFrames,
					stackAdviceOptions: {
						importantFilenames: [this.path.join()],
					},
				},
			);
		}

		async emitError(opts) {
			const {origin, error, trailingAdvice = []} = opts;

			let diagnostic = this.deriveDiagnosticFromErrorStructure(
				___R$project$rome$$internal$v8$errors_ts$getErrorStructure(error),
			);
			let {location} = diagnostic;
			let {advice} = diagnostic.description;
			let test;

			switch (origin.type) {
				case "EXECUTING": {
					advice.push({
						type: "log",
						category: "info",
						text: ___R$project$rome$$internal$markup$escape_ts$markup`Error occured while executing test file <filelink emphasis target="${this.path.join()}" />`,
					});
					break;
				}

				case "TEST": {
					advice.push({
						type: "log",
						category: "info",
						text: ___R$project$rome$$internal$markup$escape_ts$markup`Test declared at <emphasis>${___R$project$rome$$internal$diagnostics$helpers_ts$diagnosticLocationToMarkupFilelink(
							origin.test.callsiteLocation,
						)}:</emphasis>`,
					});
					advice.push({
						type: "frame",
						location: origin.test.callsiteLocation,
					});
					test = origin.test;
					break;
				}

				case "TEARDOWN": {
					advice.push({
						type: "log",
						category: "info",
						text: ___R$project$rome$$internal$markup$escape_ts$markup`Error occured while running <emphasis>teardown</emphasis> for test declared at <emphasis>${___R$project$rome$$internal$diagnostics$helpers_ts$diagnosticLocationToMarkupFilelink(
							origin.test.callsiteLocation,
						)}:</emphasis>`,
					});
					advice.push({
						type: "frame",
						location: origin.test.callsiteLocation,
					});
					test = origin.test;
					break;
				}
			}

			advice = [...advice, ...trailingAdvice];

			diagnostic = Object.assign(
				{},
				diagnostic,
				{
					location,
					tags: Object.assign({}, diagnostic.tags, {unique: true}),
					description: Object.assign({}, diagnostic.description, {advice}),
				},
			);

			if (origin.type === "INTERNAL") {
				diagnostic = Object.assign(
					{},
					diagnostic,
					{tags: Object.assign({}, diagnostic.tags, {internal: true})},
				);
			}

			await this.emitDiagnostic(diagnostic, test);
		}

		async teardownTest(test, api) {
			api.clearTimeout();

			try {
				await api.teardownEvent.callOptional();
				return true;
			} catch (err) {
				await this.emitError({
					origin: {type: "TEARDOWN", test},
					error: err,
					trailingAdvice: api.getAdvice(),
				});
				return false;
			}
		}

		async runTest(test) {
			const {callback, name: testName} = test;

			let onTimeout = () => {
				throw new Error("Promise wasn't created. Should be impossible.");
			};

			const timeoutPromise = new Promise((resolve, reject) => {
				onTimeout = (time) => {
					reject(new Error("Test timeout - exceeded " + String(time) + "ms"));
				};
			});

			const emitDiagnostic = (diag) => {
				return this.emitDiagnostic(
					Object.assign(
						{},
						diag,
						{
							description: Object.assign(
								{},
								diag.description,
								{advice: api.getAdvice(diag.description.advice)},
							),
						},
					),
					test,
				);
			};

			const api = new ___R$project$rome$$internal$core$test$worker$TestAPI_ts$default({
				path: this.path,
				testName,
				onTimeout,
				snapshotManager: this.snapshotManager,
				options: this.globalOptions,
				emitDiagnostic,
			});

			let testSuccess = false;

			try {
				const {diagnostics} = await ___R$project$rome$$internal$diagnostics$wrap_ts$catchDiagnostics(async () => {
					const res = callback(api);

					// Ducktyping this to detect a cross-realm Promise
					if (res !== undefined && typeof res.then === "function") {
						await Promise.race([timeoutPromise, res]);
					}
				});

				if (diagnostics !== undefined) {
					for (const diag of diagnostics) {
						await emitDiagnostic(diag);
					}
				}

				testSuccess = true;
			} catch (err) {
				await this.emitError({
					origin: {type: "TEST", test},
					error: err,
					trailingAdvice: api.getAdvice(),
				});
			} finally {
				const teardownSuccess = await this.teardownTest(test, api);
				await this.bridge.testFinish.call({
					success: testSuccess && teardownSuccess,
					ref: this.createTestRef(test),
				});
			}
		}

		async run(runOptions) {
			for (const testName of runOptions.testNames) {
				const test = this.foundTests.assert(testName);
				const {options} = test;

				this.bridge.testStart.send({
					ref: this.createTestRef(test),
					timeout: options.timeout,
				});

				await this.runTest(test);
			}
		}

		async teardown() {
			if (this.hasDiagnostics && this.consoleAdvice.length > 0) {
				let advice = [];
				for (const factory of this.consoleAdvice) {
					advice = advice.concat(factory());
				}
				await this.emitDiagnostic({
					description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.TESTS.LOGS(
						advice,
					),
					location: {
						filename: this.path.join(),
					},
				});
			}

			for (const diag of this.pendingDiagnostics) {
				await this.emitDiagnostic(diag);
			}

			return {
				snapshots: this.snapshotManager.getModifiedSnapshots(),
				inlineSnapshotUpdates: this.snapshotManager.inlineSnapshotsUpdates,
			};
		}

		async wrap(callback) {
			try {
				const {diagnostics} = await ___R$project$rome$$internal$diagnostics$wrap_ts$catchDiagnostics(
					callback,
				);

				if (diagnostics !== undefined) {
					for (const diagnostic of diagnostics) {
						await this.emitDiagnostic(diagnostic);
					}
				}
			} catch (err) {
				await this.emitError({
					origin: {type: "INTERNAL"},
					error: err,
				});
			}
		}

		async prepare() {
			await this.wrap(async () => {
				await this.snapshotManager.init();
				await this.discoverTests();
				this.lockTests();
			});

			return {
				foundTests: Array.from(this.foundTests.keys()),
				focusedTests: this.focusedTests,
			};
		}
	}


  // project-rome/@internal/core/test-worker/TestAPI.ts
function ___R$$priv$project$rome$$internal$core$test$worker$TestAPI_ts$formatExpectedError(
		expected,
	) {
		if (typeof expected === "string") {
			return JSON.stringify(expected);
		}

		if (expected instanceof RegExp) {
			return String(expected);
		}

		if (typeof expected === "function") {
			return expected.name;
		}

		return "unknown";
	}

	function ___R$$priv$project$rome$$internal$core$test$worker$TestAPI_ts$matchExpectedError(
		error,
		expected,
	) {
		if (expected === undefined) {
			return true;
		}

		if (typeof expected === "string") {
			return error.message.includes(expected);
		}

		if (expected instanceof RegExp) {
			return expected.test(error.message);
		}

		if (typeof expected === "function") {
			return error instanceof expected;
		}

		return false;
	}

	function ___R$$priv$project$rome$$internal$core$test$worker$TestAPI_ts$normalizeUserAdvice(
		advice,
	) {
		return advice.map((item) => {
			if (typeof item === "function") {
				return ___R$$priv$project$rome$$internal$core$test$worker$TestAPI_ts$normalizeUserAdviceItem(
					item(),
				);
			} else {
				return ___R$$priv$project$rome$$internal$core$test$worker$TestAPI_ts$normalizeUserAdviceItem(
					item,
				);
			}
		});
	}

	// Once we have a public test framework we should perform normalization here
	function ___R$$priv$project$rome$$internal$core$test$worker$TestAPI_ts$normalizeUserAdviceItem(
		item,
	) {
		switch (item.type) {
			case "code":
				return Object.assign({}, item, {language: "unknown"});

			case "log":
				return Object.assign(
					{},
					item,
					{
						text: ___R$project$rome$$internal$markup$escape_ts$markup`${item.text}`,
					},
				);

			case "list":
				return Object.assign(
					{},
					item,
					{
						list: item.list.map((item) =>
							___R$project$rome$$internal$markup$escape_ts$markup`${item}`
						),
					},
				);

			default:
				return item;
		}
	}

	class ___R$project$rome$$internal$core$test$worker$TestAPI_ts$default {
		constructor(
			{
				testName,
				onTimeout,
				path,
				snapshotManager,
				options,
				emitDiagnostic,
			},
		) {
			this.testName = testName;
			this.options = options;
			this.snapshotManager = snapshotManager;
			this.snapshotCounter = 0;
			this.path = path;
			this.teardownEvent = new ___R$project$rome$$internal$events$Event_ts$default({
				name: "TestAPI.teardown",
			});
			this.startTime = Date.now();
			this.onTimeout = onTimeout;
			this.emitDiagnostic = emitDiagnostic;
			this.timeoutMax = 0;
			this.timeoutId = undefined;
			this.setTimeout(5_000);
			this.advice = [];
		}

		getAdvice(startAdvice = []) {
			const {advice} = this;

			if (advice.length === 0) {
				return startAdvice;
			}

			const userAdvice = ___R$$priv$project$rome$$internal$core$test$worker$TestAPI_ts$normalizeUserAdvice(
				advice,
			);

			return [
				...startAdvice,
				{
					type: "group",
					title: ___R$project$rome$$internal$markup$escape_ts$markup`User-specified test advice`,
					advice: userAdvice,
				},
			];
		}

		buildMatchAdvice(
			received,
			expected,
			{
				visualMethod,
				expectedAlias,
				receivedAlias,
			} = {},
		) {
			let expectedFormat;
			let receivedFormat;
			if (typeof received === "string" && typeof expected === "string") {
				expectedFormat = expected;
				receivedFormat = received;
			} else {
				expectedFormat = ___R$project$rome$$internal$pretty$format$index_ts$prettyFormatToString(
					expected,
				);
				receivedFormat = ___R$project$rome$$internal$pretty$format$index_ts$prettyFormatToString(
					received,
				);
			}

			const advice = [];

			if (expectedFormat === receivedFormat) {
				// Better error message when both values are visually identical
				advice.push({
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Both the received and expected values are visually identical`,
				});

				advice.push({
					type: "code",
					language: "unknown",
					sourceText: expectedFormat,
				});

				if (visualMethod !== undefined) {
					advice.push({
						type: "log",
						category: "info",
						text: ___R$project$rome$$internal$markup$escape_ts$markup`Try using t.${visualMethod} if you wanted a visual match`,
					});
				}
			} else {
				advice.push({
					type: "log",
					category: "info",
					text: ___R$project$rome$$internal$markup$escape_ts$markup`Comparison`,
				});

				advice.push({
					type: "diff",
					language: "unknown",
					diff: ___R$project$rome$$internal$string$diff$index_ts$default(
						expectedFormat,
						receivedFormat,
					),
					legend: {
						add: receivedAlias ? receivedAlias : "Received",
						delete: expectedAlias ? expectedAlias : "Expected",
					},
				});
			}

			return advice;
		}

		// We allow lazy construction of test advice when an error actually occurs
		addToAdvice(item) {
			this.advice.push(item);
		}

		clearAdvice() {
			this.advice = [];
		}

		onTeardown(callback) {
			this.teardownEvent.subscribe(callback);
		}

		clearTimeout() {
			if (this.timeoutId !== undefined) {
				clearTimeout(this.timeoutId);
			}

			this.timeoutMax = undefined;
			this.timeoutStart = undefined;
		}

		extendTimeout(time) {
			const {timeoutMax, timeoutStart} = this;
			if (timeoutMax === undefined || timeoutStart === undefined) {
				throw new Error("No timeout set");
			}

			const elapsed = Date.now() - timeoutStart;
			const newTime = timeoutMax - elapsed + time;
			this.setTimeout(newTime);
		}

		setTimeout(time) {
			this.clearTimeout();

			this.timeoutStart = Date.now();
			this.timeoutMax = time;

			this.timeoutId = setTimeout(
				() => {
					this.onTimeout(time);
				},
				time,
			);
		}

		checkTimeout() {
			const {startTime, timeoutMax} = this;
			if (timeoutMax === undefined) {
				return;
			}

			const delta = Date.now() - startTime;
			if (delta > timeoutMax) {
				throw new Error("Test timeout - exceeded " + String(timeoutMax) + "ms");
			}
		}

		fail(
			message = "Test failure triggered by t.fail()",
			advice = [],
			framesToShift = 0,
		) {
			const diag = ___R$project$rome$$internal$diagnostics$derive_ts$deriveDiagnosticFromErrorStructure(
				___R$project$rome$$internal$v8$errors_ts$getErrorStructure(
					new Error(),
					framesToShift + 1,
				),
				{
					description: {
						category: "tests/failure",
						message: ___R$project$rome$$internal$markup$escape_ts$markup`${message}`,
						advice,
					},
				},
			);
			throw ___R$project$rome$$internal$diagnostics$errors_ts$createSingleDiagnosticError(
				diag,
			);
		}

		truthy(value, message = "Expected value to be truthy") {
			if (Boolean(value) === false) {
				this.fail(
					message,
					[
						{
							type: "log",
							category: "info",
							text: ___R$project$rome$$internal$markup$escape_ts$markup`Received`,
						},
						{
							type: "code",
							language: "unknown",
							sourceText: ___R$project$rome$$internal$pretty$format$index_ts$prettyFormatToString(
								value,
							),
						},
					],
					1,
				);
			}
		}

		falsy(value, message = "Expected value to be falsy") {
			if (Boolean(value) === true) {
				this.fail(
					message,
					[
						{
							type: "log",
							category: "info",
							text: ___R$project$rome$$internal$markup$escape_ts$markup`Received`,
						},
						{
							type: "code",
							language: "unknown",
							sourceText: ___R$project$rome$$internal$pretty$format$index_ts$prettyFormatToString(
								value,
							),
						},
					],
					1,
				);
			}
		}

		true(value, message = "Expected value to be true") {
			if (value !== true) {
				this.fail(
					message,
					[
						{
							type: "log",
							category: "info",
							text: ___R$project$rome$$internal$markup$escape_ts$markup`Received`,
						},
						{
							type: "code",
							language: "unknown",
							sourceText: ___R$project$rome$$internal$pretty$format$index_ts$prettyFormatToString(
								value,
							),
						},
					],
					1,
				);
			}
		}

		false(value, message = "Expected value to be false") {
			if (value !== false) {
				this.fail(
					message,
					[
						{
							type: "log",
							category: "info",
							text: ___R$project$rome$$internal$markup$escape_ts$markup`Received`,
						},
						{
							type: "code",
							language: "unknown",
							sourceText: ___R$project$rome$$internal$pretty$format$index_ts$prettyFormatToString(
								value,
							),
						},
					],
					1,
				);
			}
		}

		is(received, expected, message = "t.is() failed, using Object.is semantics") {
			if (Object.is(received, expected) !== true) {
				this.fail(
					message,
					this.buildMatchAdvice(
						received,
						expected,
						{
							visualMethod: "looksLike",
						},
					),
					1,
				);
			}
		}

		not(
			received,
			expected,
			message = "t.not() failed, using !Object.is semantics",
		) {
			if (Object.is(received, expected) === true) {
				this.fail(
					message,
					this.buildMatchAdvice(
						received,
						expected,
						{
							visualMethod: "notLooksLike",
						},
					),
					1,
				);
			}
		}

		looksLike(
			received,
			expected,
			message = "t.looksLike() failed, using prettyFormat semantics",
		) {
			const actualInspect = ___R$project$rome$$internal$pretty$format$index_ts$prettyFormatToString(
				received,
			);
			const expectedInspect = ___R$project$rome$$internal$pretty$format$index_ts$prettyFormatToString(
				expected,
			);

			if (actualInspect !== expectedInspect) {
				this.fail(message, this.buildMatchAdvice(received, expected), 1);
			}
		}

		notLooksLike(
			received,
			expected,
			message = "t.notLooksLike() failed, using !prettyFormat semantics",
		) {
			const actualInspect = ___R$project$rome$$internal$pretty$format$index_ts$prettyFormatToString(
				received,
			);
			const expectedInspect = ___R$project$rome$$internal$pretty$format$index_ts$prettyFormatToString(
				expected,
			);

			if (actualInspect === expectedInspect) {
				this.fail(message, this.buildMatchAdvice(received, expected), 1);
			}
		}

		throws(
			thrower,
			expected,
			message = "t.throws() failed, callback did not throw an error",
		) {
			try {
				thrower();
			} catch (err) {
				if (
					___R$$priv$project$rome$$internal$core$test$worker$TestAPI_ts$matchExpectedError(
						err,
						expected,
					)
				) {
					return undefined;
				} else {
					this.fail(
						"t.throws() expected an error to be thrown that matches " +
						___R$$priv$project$rome$$internal$core$test$worker$TestAPI_ts$formatExpectedError(
							expected,
						) +
						" but got " +
						err.name +
						": " +
						JSON.stringify(err.message),
						___R$project$rome$$internal$diagnostics$derive_ts$getErrorStackAdvice(
							___R$project$rome$$internal$v8$errors_ts$getErrorStructure(err),
							{
								title: ___R$project$rome$$internal$markup$escape_ts$markup`Incorrect error stack trace`,
							},
						),
						1,
					);
				}
			}

			this.fail(message, undefined, 1);
		}

		async throwsAsync(
			thrower,
			expected,
			message = "t.throwsAsync() failed, callback did not throw an error",
		) {
			try {
				await thrower();
			} catch (err) {
				if (
					___R$$priv$project$rome$$internal$core$test$worker$TestAPI_ts$matchExpectedError(
						err,
						expected,
					)
				) {
					return undefined;
				} else {
					this.fail(
						"t.throwsAsync() expected an error to be thrown that matches " +
						___R$$priv$project$rome$$internal$core$test$worker$TestAPI_ts$formatExpectedError(
							expected,
						) +
						" but got " +
						err.name +
						": " +
						JSON.stringify(err.message),
						___R$project$rome$$internal$diagnostics$derive_ts$getErrorStackAdvice(
							___R$project$rome$$internal$v8$errors_ts$getErrorStructure(err),
							{
								title: ___R$project$rome$$internal$markup$escape_ts$markup`Incorrect error stack trace`,
							},
						),
						1,
					);
				}
			}
			this.fail(message, undefined, 1);
		}

		notThrows(
			nonThrower,
			message = "t.notThrows() failed, callback threw an error",
		) {
			try {
				nonThrower();
			} catch (err) {
				const advice = ___R$project$rome$$internal$diagnostics$derive_ts$getErrorStackAdvice(
					___R$project$rome$$internal$v8$errors_ts$getErrorStructure(err),
					{
						title: ___R$project$rome$$internal$markup$escape_ts$markup`t.notThrows() did not expect an error to be thrown but got ${err.name}: ${JSON.stringify(
							err.message,
						)}`,
					},
				);
				this.fail(message, advice, 1);
			}
		}

		async notThrowsAsync(
			nonThrower,
			message = "t.notThrowsAsync() failed, callback threw an error",
		) {
			try {
				await nonThrower();
			} catch (err) {
				const advice = ___R$project$rome$$internal$diagnostics$derive_ts$getErrorStackAdvice(
					___R$project$rome$$internal$v8$errors_ts$getErrorStructure(err),
					{
						title: ___R$project$rome$$internal$markup$escape_ts$markup`t.notThrowsAsync() did not expect an error to be thrown but got ${err.name}: ${JSON.stringify(
							err.message,
						)}`,
					},
				);
				this.fail(message, advice, 1);
			}
		}

		regex(
			contents,
			regex,
			message = "t.regex() failed, using RegExp.test semantics",
		) {
			if (!regex.test(contents)) {
				this.fail(
					message,
					[
						{
							type: "log",
							category: "info",
							text: ___R$project$rome$$internal$markup$escape_ts$markup`Expected`,
						},
						{
							type: "code",
							language: "unknown",
							sourceText: ___R$project$rome$$internal$pretty$format$index_ts$prettyFormatToString(
								contents,
							),
						},
						{
							type: "log",
							category: "info",
							text: ___R$project$rome$$internal$markup$escape_ts$markup`to match pattern`,
						},
						{
							type: "code",
							language: "unknown",
							sourceText: ___R$project$rome$$internal$pretty$format$index_ts$prettyFormatToString(
								regex.source,
							),
						},
					],
					1,
				);
			}
		}

		notRegex(
			contents,
			regex,
			message = "t.notRegex() failed, using !RegExp.test semantics",
		) {
			if (regex.test(contents)) {
				this.fail(
					message,
					[
						{
							type: "log",
							category: "info",
							text: ___R$project$rome$$internal$markup$escape_ts$markup`Expected`,
						},
						{
							type: "code",
							language: "unknown",
							sourceText: ___R$project$rome$$internal$pretty$format$index_ts$prettyFormatToString(
								contents,
							),
						},
						{
							type: "log",
							category: "info",
							text: ___R$project$rome$$internal$markup$escape_ts$markup`to not match pattern`,
						},
						{
							type: "code",
							language: "unknown",
							sourceText: ___R$project$rome$$internal$pretty$format$index_ts$prettyFormatToString(
								regex.source,
							),
						},
					],
					1,
				);
			}
		}

		inlineSnapshot(received, snapshot) {
			const callFrame = ___R$project$rome$$internal$v8$errors_ts$getErrorStructure(
				new Error(),
			).frames[1];
			const callError = ___R$project$rome$$internal$v8$errors_ts$getErrorStructure(
				new Error(),
				1,
			);

			this.onTeardown(async () => {
				const {status} = this.snapshotManager.testInlineSnapshot(
					callFrame,
					received,
					snapshot,
				);

				if (status === "UPDATE" && this.options.freezeSnapshots) {
					await this.emitDiagnostic(
						___R$project$rome$$internal$diagnostics$derive_ts$deriveDiagnosticFromErrorStructure(
							callError,
							{
								description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SNAPSHOTS.INLINE_FROZEN,
								cleanFrames: ___R$project$rome$$internal$core$test$worker$TestWorkerFile_ts$cleanFrames,
							},
						),
					);
				}

				if (status === "NO_MATCH") {
					await this.emitDiagnostic(
						___R$project$rome$$internal$diagnostics$derive_ts$deriveDiagnosticFromErrorStructure(
							callError,
							{
								cleanFrames: ___R$project$rome$$internal$core$test$worker$TestWorkerFile_ts$cleanFrames,
								description: Object.assign(
									{},
									___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SNAPSHOTS.INLINE_BAD_MATCH,
									{
										advice: this.buildMatchAdvice(
											received,
											snapshot,
											{
												receivedAlias: "What the code gave us",
												expectedAlias: "Existing inline snapshot",
											},
										),
									},
								),
							},
						),
					);
				}
			});
		}

		snapshot(expected, message, opts) {
			const id = this.snapshotCounter++;
			return this.bufferSnapshot({
				entryName: String(id),
				expected,
				message,
				opts,
			});
		}

		namedSnapshot(entryName, expected, message, opts) {
			return this.bufferSnapshot({
				entryName,
				expected,
				message,
				opts,
			});
		}

		bufferSnapshot(
			{
				entryName,
				message,
				expected,
				opts = {},
			},
		) {
			let language = opts.language;

			let formatted = "";
			if (typeof expected === "string") {
				formatted = expected;
			} else {
				// Close enough syntax highlighting to pretty-format
				language = "javascript";
				formatted = ___R$project$rome$$internal$pretty$format$index_ts$prettyFormatToString(
					expected,
				);
			}

			const callError = ___R$project$rome$$internal$v8$errors_ts$getErrorStructure(
				new Error(),
				2,
			);

			this.onTeardown(async () => {
				// Get the current snapshot
				const existingSnapshot = await this.snapshotManager.get(
					this.testName,
					entryName,
					opts.filename,
				);
				if (existingSnapshot === undefined) {
					if (this.options.freezeSnapshots) {
						await this.emitDiagnostic(
							___R$project$rome$$internal$diagnostics$derive_ts$deriveDiagnosticFromErrorStructure(
								callError,
								{
									cleanFrames: ___R$project$rome$$internal$core$test$worker$TestWorkerFile_ts$cleanFrames,
									description: ___R$project$rome$$internal$diagnostics$descriptions$index_ts$descriptions.SNAPSHOTS.FROZEN,
								},
							),
						);
					} else {
						// No snapshot exists, let's save this one!
						this.snapshotManager.set({
							testName: this.testName,
							entryName,
							value: formatted,
							language,
							optionalFilename: opts.filename,
						});
					}
					return;
				}

				// Compare the snapshots
				const snapshotPath = this.snapshotManager.normalizeSnapshotPath(
					opts.filename,
				);
				if (formatted !== existingSnapshot) {
					const advice = this.buildMatchAdvice(
						formatted,
						existingSnapshot,
						{
							receivedAlias: "What the code gave us",
							expectedAlias: "Existing snapshot",
						},
					);

					let markupMessage;

					if (message === undefined) {
						markupMessage = ___R$project$rome$$internal$markup$escape_ts$markup`Snapshot <emphasis>"${entryName}"</emphasis> at <emphasis>${snapshotPath}</emphasis> doesn't match`;
					} else {
						markupMessage = ___R$project$rome$$internal$markup$escape_ts$markup`${message}`;

						advice.push({
							type: "log",
							category: "info",
							text: ___R$project$rome$$internal$markup$escape_ts$markup`Snapshot can be found at <emphasis>${snapshotPath}</emphasis>`,
						});
					}

					advice.push({
						type: "log",
						category: "info",
						text: ___R$project$rome$$internal$markup$escape_ts$markup`Run <code>rome test <filelink target="${this.path.join()}" /> --update-snapshots</code> to update this snapshot`,
					});

					await this.emitDiagnostic(
						___R$project$rome$$internal$diagnostics$derive_ts$deriveDiagnosticFromErrorStructure(
							callError,
							{
								cleanFrames: ___R$project$rome$$internal$core$test$worker$TestWorkerFile_ts$cleanFrames,
								description: {
									category: "tests/snapshots/incorrect",
									message: markupMessage,
									advice,
								},
							},
						),
					);
				}
			});

			return entryName;
		}
	}


  // project-rome/@internal/core/test-worker/TestWorker.ts
const ___R$$priv$project$rome$$internal$core$test$worker$TestWorker_ts$inspector = require(
		"inspector",
	);
	class ___R$project$rome$$internal$core$test$worker$TestWorker_ts$default {
		constructor() {
			this.bridge = this.buildBridge();
			this.runners = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
			this.compiled = new ___R$project$rome$$internal$path$collections_ts$AbsoluteFilePathMap();
		}

		serializeAssembled(assembled) {
			return ___R$project$rome$$internal$core$server$bundler$utils_ts$serializeAssembled(
				assembled,
				(path) => {
					return this.compiled.get(path);
				},
			);
		}

		async init(flags) {
			___R$$priv$project$rome$$internal$core$test$worker$TestWorker_ts$inspector.open(
				flags.inspectorPort,
			);

			await this.bridge.handshake();
		}

		buildBridge() {
			const bridge = ___R$project$rome$$internal$events$bridgeCreators_ts$createBridgeFromWorkerThreadParentPort(
				___R$project$rome$$internal$core$common$bridges$TestWorkerBridge_ts$default,
				{
					type: "server",
				},
			);

			___R$project$rome$$internal$core$common$utils$setupGlobalErrorHandlers_ts$default((
				err,
			) => {
				bridge.testDiagnostic.send({
					testPath: undefined,
					origin: undefined,
					diagnostic: ___R$project$rome$$internal$diagnostics$derive_ts$deriveDiagnosticFromError(
						err,
						{
							description: {
								category: "tests/unhandledRejection",
							},
						},
					),
				});
			});

			bridge.inspectorDetails.subscribe(() => {
				return {
					inspectorUrl: ___R$$priv$project$rome$$internal$core$test$worker$TestWorker_ts$inspector.url(),
				};
			});

			bridge.prepareTest.subscribe(async (opts) => {
				const runner = new ___R$project$rome$$internal$core$test$worker$TestWorkerFile_ts$default(
					this,
					this.bridge,
					opts,
				);
				this.runners.set(opts.path, runner);
				return await runner.prepare();
			});

			bridge.teardownTest.subscribe(async (path) => {
				const runner = this.runners.assert(path);
				return await runner.teardown();
			});

			bridge.runTest.subscribe(async (opts) => {
				const {path} = opts;
				const runner = this.runners.assert(path);
				return await runner.run(opts);
			});

			bridge.receiveCompiled.subscribe((map) => {
				for (const [path, content] of map) {
					this.compiled.set(path, content);
				}
			});

			return bridge;
		}
	}


  // project-rome/@internal/core/index.ts



  // project-rome/@internal/cli/utils/setProcessTitle.ts
function ___R$project$rome$$internal$cli$utils$setProcessTitle_ts$default(title) {
		process.title = "rome-" + title;
	}


  // project-rome/@internal/cli/cli.ts
async function ___R$project$rome$$internal$cli$cli_ts$default() {
		___R$project$rome$$internal$cli$utils$setProcessTitle_ts$default("cli");

		// Verify correct Node version
		if (
			!___R$project$rome$$internal$codec$semver$index_ts$satisfiesSemver(
				process.version,
				___R$project$rome$$internal$core$common$constants_ts$REQUIRED_NODE_VERSION_RANGE,
				{loose: true},
			)
		) {
			const reporter = ___R$project$rome$$internal$cli$reporter$Reporter_ts$default.fromProcess();
			reporter.error(
				___R$project$rome$$internal$markup$escape_ts$markup`Node <emphasis>${___R$project$rome$$internal$core$common$constants_ts$REQUIRED_NODE_VERSION_RANGE}</emphasis> is required, but you are on <emphasis>${process.version}</emphasis>`,
			);
			process.exit(1);
		}

		const p = ___R$project$rome$$internal$cli$flags$index_ts$parseCLIFlagsFromProcess({
			programName: ___R$project$rome$$internal$cli$environment$index_ts$getEnvVar(
				"ROME_DEV",
			).type === "ENABLED"
				? "dev-rome"
				: "rome",
			usage: "[command] [flags]",
			version: ___R$project$rome$$internal$core$common$constants_ts$VERSION,
			commandRequired: true,
			shellCompletionDirectory: ___R$project$rome$$internal$core$common$constants_ts$USER_CONFIG_DIRECTORY,
			commandSuggestions: {
				lint: {
					commandName: "check",
					description: ___R$project$rome$$internal$markup$escape_ts$markup`The <emphasis>check</emphasis> command covers linting, formatting, and more`,
				},
			},
			defineFlags(c) {
				// We need this to resolve other flags relative to
				// We do the word `void ||` nonsense to avoid setting a default flag value
				const cwd =
					c.get(
						"cwd",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Specify a different working directory`,
						},
					).asAbsoluteFilePathOrVoid() ||
					___R$project$rome$$internal$path$index_ts$CWD_PATH;

				const terminalFeatures = {
					format: c.get(
						"outputFormat",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Change the output format. By default it is automatically inferred from terminal settings.`,
						},
					).asStringSetOrVoid(["ansi", "html", "none"]),
					isTTY: c.get(
						"outputTty",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Treat output as TTY regardless of terminal information. This will enable things like ANSI cursor, progress bars etc.`,
						},
					).asBooleanOrVoid(),
					columns: c.get(
						"outputColumns",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Change the display width. By default it is automatically inferred and updated from the terminal.`,
						},
					).asOneIndexedNumberOrVoid(),
					colorDepth: c.get(
						"outputColorDepth",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Change the display width. By default it is automatically inferred and updated from the terminal.`,
						},
					).asNumberSetOrVoid([1, 4, 8, 24]),
					redirectError: c.get(
						"outputRedirectError",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Redirect stderr to stdout.`,
						},
					).asBooleanOrVoid(),
				};

				const clientFlags = {
					realCwd: ___R$project$rome$$internal$path$index_ts$CWD_PATH,
					clientName: "cli",
					cwd,
					silent: c.get(
						"silent",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Don't write anything to the console`,
						},
					).asBoolean(
						___R$project$rome$$internal$core$common$types$client_ts$DEFAULT_CLIENT_FLAGS.silent,
					),
				};

				const cliFlags = {
					markersPath: c.get(
						"markersPath",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Path where to write markers. When ommitted defaults to Marker-TIMESTAMP.json`,
						},
					).asAbsoluteFilePathOrVoid(cwd),
					profile: c.get(
						"profile",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Collect and write profile to disk. Includes profiles for all processes.`,
						},
					).asBoolean(false),
					profilePath: c.get(
						"profilePath",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Path where to write profile. When omitted defaults to Profile-TIMESTAMP.json`,
						},
					).asAbsoluteFilePathOrVoid(cwd),
					profileTimeout: c.get(
						"profileTimeout",
						{
							inputName: "millisec",
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Stop the profile after the milliseconds specified. When omitted the profile is of the whole command`,
						},
					).asNumberOrVoid(),
					profileWorkers: c.get(
						"profileWorkers",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Exclude workers from profile`,
						},
					).asBoolean(true),
					profileSampling: c.get(
						"profileSampling",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Profiler sampling interval in microseconds`,
							inputName: "microsec",
						},
					).asNumber(100),
					temporaryDaemon: c.get(
						"temporaryDaemon",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Start a daemon, if one isn't already running, for the lifetime of this command`,
						},
					).asBoolean(false),
					rage: c.get(
						"rage",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Create a rage tarball of debug information`,
						},
					).asBoolean(false),
					ragePath: c.get(
						"ragePath",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Path where to write rage tarball. When omitted defaults to Rage-TIMESTAMP.tgz`,
						},
					).asAbsoluteFilePathOrVoid(cwd),
					logs: c.get(
						"logs",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Output server logs`,
						},
					).asBoolean(false),
					logWorkers: c.get(
						"logWorkers",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Output worker logs`,
						},
					).asBooleanOrVoid(),
					logPath: c.get(
						"logPath",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Path where to output logs. When omitted logs are not written anywhere`,
						},
					).asAbsoluteFilePathOrVoid(cwd),
				};

				const requestFlags = {
					unsafeWrites: c.get(
						"unsafeWrites",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`When writing files, don't verify mtime or existence. Potentially dangerous and could lead to unintended data loss`,
						},
					).asBoolean(
						___R$project$rome$$internal$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.unsafeWrites,
					),
					auxiliaryDiagnosticFormat: c.get(
						"auxiliaryDiagnosticFormat",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`When printing diagnostics, output another format alongside`,
						},
					).asStringSetOrVoid(["github-actions"]),
					benchmark: c.get(
						"benchmark",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Run a command multiple times, calculating average`,
						},
					).asBoolean(
						___R$project$rome$$internal$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.benchmark,
					),
					benchmarkIterations: c.get(
						"benchmarkIterations",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`The amount of benchmark iterations to perform`,
						},
					).asNumber(
						___R$project$rome$$internal$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.benchmarkIterations,
					),
					collectMarkers: c.get(
						"collectMarkers",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Collect and write performance markers to disk`,
						},
					).asBoolean(
						___R$project$rome$$internal$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.collectMarkers,
					),
					timing: c.get(
						"timing",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Dump timing information after running the command`,
						},
					).asBoolean(
						___R$project$rome$$internal$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.timing,
					),
					review: c.get(
						"review",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Display and perform actions on diagnostics. Only some commands support this.`,
						},
					).asBoolean(
						___R$project$rome$$internal$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.review,
					),
					watch: c.get(
						"watch",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Keep running command and update on file changes. Only some commands support this.`,
						},
					).asBoolean(
						___R$project$rome$$internal$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.watch,
					),
					fieri: c.get(
						"fieri",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Head to flavortown`,
						},
					).asBoolean(
						___R$project$rome$$internal$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.fieri,
					),
					grep: c.get(
						"grep",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Only display diagnostics with messages containing this string`,
						},
					).asString(
						___R$project$rome$$internal$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.grep,
					),
					inverseGrep: c.get(
						"inverseGrep",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Flip grep match. Only display diagnostics with messages that do NOT contain the grep string`,
						},
					).asBoolean(
						___R$project$rome$$internal$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.inverseGrep,
					),
					maxDiagnostics: c.get(
						"maxDiagnostics",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Cap the amount of diagnostics displayed`,
						},
					).asNumber(
						___R$project$rome$$internal$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.maxDiagnostics,
					),
					// DiagnosticsPrinterFlags["verboseDiagnostics"] can be a boolean or some string constants
					// But we only want to allow booleans in the CLI
					verboseDiagnostics: c.get(
						"verboseDiagnostics",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Display hidden and truncated diagnostic information`,
						},
					).asBoolean(false),
					showAllDiagnostics: c.get(
						"showAllDiagnostics",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Display all diagnostics ignoring caps`,
						},
					).asBoolean(
						___R$project$rome$$internal$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.showAllDiagnostics,
					),
					resolverPlatform: c.get(
						"resolverPlatform",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Specify the platform for module resolution`,
							inputName: "platform",
						},
					).asStringSetOrVoid(
						___R$project$rome$$internal$core$common$types$platform_ts$PLATFORMS,
					),
					resolverScale: c.get(
						"resolverScale",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Specify the image scale for module resolution`,
						},
					).asNumberOrVoid(),
					resolverMocks: c.get(
						"resolverMocks",
						{
							description: ___R$project$rome$$internal$markup$escape_ts$markup`Enable mocks for module resolution`,
						},
					).asBoolean(
						___R$project$rome$$internal$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.resolverMocks,
					),
				};

				return {terminalFeatures, clientFlags, requestFlags, cliFlags};
			},
		});

		let command = "";
		let overrideCLIFlags = {};
		let commandFlags = {};
		let args = [];

		const isRelease =
			___R$project$rome$$internal$cli$environment$index_ts$getEnvVar("ROME_DEV").type !==
			"ENABLED";

		// Create command handlers. We use a set here since we may have some conflicting server and local command names. We always want the local command to take precedence.
		const commandNames = new Set([
			...___R$project$rome$$internal$core$client$commands_ts$localCommands.keys(),
			...___R$project$rome$$internal$core$server$commands_ts$serverCommands.keys(),
		]);
		for (const cmd of commandNames) {
			const local = ___R$project$rome$$internal$core$client$commands_ts$localCommands.get(
				cmd,
			);
			if (local !== undefined) {
				p.command({
					name: cmd,
					category: local.category,
					description: local.description,
					defineFlags: local.defineFlags,
					ignoreFlags: local.ignoreFlags,
					examples: local.examples,
					usage: local.usage,
					hidden: isRelease && local.hidden,
					callback(_commandFlags) {
						commandFlags = _commandFlags;
						args = p.getArgs();
						command = cmd;
					},
				});
				continue;
			}

			const server = ___R$project$rome$$internal$core$server$commands_ts$serverCommands.get(
				cmd,
			);
			if (server !== undefined) {
				p.command({
					name: cmd,
					category: server.category,
					description: server.description,
					defineFlags: server.defineFlags,
					ignoreFlags: server.ignoreFlags,
					usage: server.usage,
					examples: server.examples,
					hidden: isRelease && server.hidden,
					callback(_commandFlags) {
						commandFlags = _commandFlags;
						args = p.getArgs();
						command = cmd;
					},
				});
			}
		}

		// Mock `rage` command that just uses the server noop command and adds the --rage flag
		p.command({
			name: "rage",
			category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.INTERNAL,
			description: ___R$project$rome$$internal$markup$escape_ts$markup`create a rage archive for debugging`,
			defineFlags(c) {
				return {
					summary: c.get("summary").asBoolean(false),
				};
			},
			callback(_commandFlags) {
				commandFlags = _commandFlags;

				overrideCLIFlags = {
					rage: true,
				};

				command = "noop";
			},
		});

		// Mock `logs` command that just uses the server noop command and adds the --logs flag
		p.command({
			name: "logs",
			category: ___R$project$rome$$internal$core$common$commands_ts$commandCategories.INTERNAL,
			description: ___R$project$rome$$internal$markup$escape_ts$markup`view the logs stream`,
			callback() {
				overrideCLIFlags = {
					logs: true,
				};

				commandFlags = {
					hang: true,
				};

				command = "noop";
			},
		});

		// Initialize flags
		let {terminalFeatures, clientFlags, cliFlags, requestFlags} = await p.init();

		// We force some cli flags to be set for certain commands
		cliFlags = Object.assign({}, cliFlags, overrideCLIFlags);

		// Default according to env vars
		if (requestFlags.auxiliaryDiagnosticFormat === undefined) {
			if (
				___R$project$rome$$internal$cli$environment$index_ts$getEnvVar(
					"GITHUB_ACTIONS",
				).type ===
				"ENABLED"
			) {
				requestFlags.auxiliaryDiagnosticFormat = "github-actions";
			}
		}

		// Force collection of markers if markersPath or we are raging
		// Save the real value here since if rage is set we don't want to save them
		const shouldCollectMarkers =
			requestFlags.collectMarkers || cliFlags.markersPath !== undefined;
		if (cliFlags.markersPath || cliFlags.rage) {
			requestFlags.collectMarkers = true;
		}

		// Force logs when logPath or logWorkers is set
		if (cliFlags.logPath !== undefined || cliFlags.logWorkers === true) {
			cliFlags.logs = true;
		}

		const userConfig = await ___R$project$rome$$internal$core$common$userConfig_ts$loadUserConfig();
		const client = new ___R$project$rome$$internal$core$client$Client_ts$default({
			userConfig,
			terminalFeatures,
			globalErrorHandlers: true,
			flags: clientFlags,
			stdin: process.stdin,
			stdout: process.stdout,
			stderr: process.stderr,
		});

		client.bridgeAttachedEvent.subscribe(async () => {
			const profileOptions = {
				samplingInterval: cliFlags.profileSampling,
				timeoutInterval: cliFlags.profileTimeout,
				includeWorkers: cliFlags.profileWorkers,
			};

			if (cliFlags.rage) {
				if (commandFlags.summary === true) {
					client.reporter.log(await client.generateRageSummary());
				} else {
					let {ragePath} = cliFlags;

					// Resolve or add default filename
					ragePath = clientFlags.cwd.resolve(
						ragePath === undefined
							? "Rage-" +
								___R$project$rome$$internal$core$client$Client_ts$getFilenameTimestamp() +
								".tgz"
							: ragePath,
					);
					await client.rage(ragePath, profileOptions);
				}
				return;
			}

			if (cliFlags.profile) {
				await client.profile(
					profileOptions,
					async (events) => {
						const {cwd} = clientFlags;
						const {profilePath} = cliFlags;

						const resolvedProfilePath = cwd.resolve(
							profilePath === undefined
								? "Profile-" +
									___R$project$rome$$internal$core$client$Client_ts$getFilenameTimestamp() +
									".json"
								: profilePath,
						);

						const str = ___R$project$rome$$internal$codec$json$index_ts$stringifyJSON(
							events,
						);
						await ___R$project$rome$$internal$fs$index_ts$writeFile(
							resolvedProfilePath,
							str,
						);

						client.reporter.success(
							___R$project$rome$$internal$markup$escape_ts$markup`Wrote CPU profile to <emphasis>${resolvedProfilePath}</emphasis>`,
						);
					},
				);
			}

			if (cliFlags.logs) {
				let fileout;
				if (cliFlags.logPath !== undefined) {
					fileout = ___R$project$rome$$internal$fs$index_ts$createWriteStream(
						clientFlags.cwd.resolve(cliFlags.logPath),
					);

					client.endEvent.subscribe(() => {
						if (fileout !== undefined) {
							fileout.end();
						}
					});
				}

				await client.subscribeLogs(
					cliFlags.logWorkers === true,
					(chunk) => {
						if (fileout === undefined) {
							client.reporter.log(
								___R$project$rome$$internal$markup$escape_ts$convertToMarkupFromRandomString(
									chunk,
								),
								{noNewline: true},
							);
						} else {
							fileout.write(
								___R$project$rome$$internal$markup$normalize_ts$joinMarkupLines(
									___R$project$rome$$internal$cli$layout$format_ts$markupToPlainText(
										___R$project$rome$$internal$markup$escape_ts$convertToMarkupFromRandomString(
											chunk,
										),
									),
								),
							);
						}
					},
				);
			}
		});

		if (cliFlags.temporaryDaemon) {
			await client.forceStartDaemon();
		}

		const res = await client.query({
			commandName: command,
			commandFlags,
			args,
			requestFlags,
			// Daemon would have been started before, so terminate when we complete
			terminateWhenIdle: cliFlags.temporaryDaemon,
			// We don't use the data result, so no point transporting it over the bridge
			// We want it in rage mode though for debugging
			noData: !cliFlags.rage,
		});
		await client.end();

		// Write markers if we were collecting them
		if (shouldCollectMarkers && res.markers.length > 0) {
			const markersPath = clientFlags.cwd.resolve(
				cliFlags.markersPath === undefined
					? "Markers-" +
						___R$project$rome$$internal$core$client$Client_ts$getFilenameTimestamp() +
						".json"
					: cliFlags.markersPath,
			);

			await ___R$project$rome$$internal$fs$index_ts$writeFile(
				markersPath,
				___R$project$rome$$internal$codec$json$index_ts$stringifyJSON(
					res.markers,
				),
			);

			client.reporter.success(
				___R$project$rome$$internal$markup$escape_ts$markup`Wrote markers to <emphasis>${markersPath}</emphasis>`,
			);
		}

		switch (res.type) {
			case "EXIT": {
				process.exit(res.code);
				break;
			}

			case "INVALID_REQUEST": {
				if (res.showHelp) {
					await p.showHelp();
				}
				process.exit(1);
				break;
			}

			case "DIAGNOSTICS": {
				process.exit(res.hasDiagnostics ? 1 : 0);
				break;
			}

			case "CANCELLED": {
				client.reporter.error(
					___R$project$rome$$internal$markup$escape_ts$markup`Command cancelled: ${res.reason}`,
				);
				process.exit(0);
				break;
			}

			case "SUCCESS": {
				process.exit(0);
				break;
			}
		}
	}


  // project-rome/@internal/cli/server.ts
const ___R$$priv$project$rome$$internal$cli$server_ts$net = require("net");
	async function ___R$project$rome$$internal$cli$server_ts$default() {
		___R$project$rome$$internal$cli$utils$setProcessTitle_ts$default("server");

		const userConfig = await ___R$project$rome$$internal$core$common$userConfig_ts$loadUserConfig();
		const server = new ___R$project$rome$$internal$core$server$Server_ts$default({
			userConfig,
			dedicated: true,
			globalErrorHandlers: true,
		});

		await server.init();

		const socketServer = ___R$$priv$project$rome$$internal$cli$server_ts$net.createServer(function(
			socket,
		) {
			const client = ___R$project$rome$$internal$events$bridgeCreators_ts$createBridgeFromSocket(
				___R$project$rome$$internal$core$common$bridges$ServerBridge_ts$default,
				socket,
				{
					type: "client",
				},
			);
			server.attachToBridge(client);
		});

		if (
			await ___R$project$rome$$internal$fs$index_ts$exists(
				___R$project$rome$$internal$core$common$constants_ts$SERVER_SOCKET_PATH,
			)
		) {
			await ___R$project$rome$$internal$fs$index_ts$removeFile(
				___R$project$rome$$internal$core$common$constants_ts$SERVER_SOCKET_PATH,
			);
		}

		socketServer.listen(
			___R$project$rome$$internal$core$common$constants_ts$SERVER_SOCKET_PATH.join(),
			() => {
				const socket = ___R$$priv$project$rome$$internal$cli$server_ts$net.createConnection(
					___R$project$rome$$internal$core$common$constants_ts$CLI_SOCKET_PATH.join(),
					() => {
						socket.end();
					},
				);

				socket.on(
					"error",
					(err) => {
						// Socket error occured, cli could have died before it caught us
						err;
						process.exit();
					},
				);
			},
		);
	}


  // project-rome/@internal/cli/testWorker.ts
const ___R$$priv$project$rome$$internal$cli$testWorker_ts$workerThreads = require(
		"worker_threads",
	);
	async function ___R$project$rome$$internal$cli$testWorker_ts$default() {
		___R$project$rome$$internal$cli$utils$setProcessTitle_ts$default(
			"test-worker",
		);

		const {inspectorPort} = ___R$$priv$project$rome$$internal$cli$testWorker_ts$workerThreads.workerData;
		if (typeof inspectorPort !== "number") {
			throw new Error(
				"Expected inspectorPort to be a number but got " + inspectorPort,
			);
		}

		const worker = new ___R$project$rome$$internal$core$test$worker$TestWorker_ts$default();
		await worker.init({
			inspectorPort,
		});
	}


  // project-rome/@internal/cli/worker.ts
const ___R$$priv$project$rome$$internal$cli$worker_ts$workerThreads = require(
		"worker_threads",
	);
	async function ___R$project$rome$$internal$cli$worker_ts$default() {
		___R$project$rome$$internal$cli$utils$setProcessTitle_ts$default("worker");
		const bridge = ___R$project$rome$$internal$events$bridgeCreators_ts$createBridgeFromWorkerThreadParentPort(
			___R$project$rome$$internal$core$common$bridges$WorkerBridge_ts$default,
			{
				type: "server",
			},
		);

		const {id} = ___R$$priv$project$rome$$internal$cli$worker_ts$workerThreads.workerData;
		if (typeof id !== "number") {
			throw new Error("Expected id to be a number but got " + id);
		}

		const userConfig = await ___R$project$rome$$internal$core$common$userConfig_ts$loadUserConfig();
		const worker = new ___R$project$rome$$internal$core$worker$Worker_ts$default({
			id,
			userConfig,
			bridge,
			dedicated: true,
		});
		await worker.init();
		await bridge.handshake();
	}


  // project-rome/@internal/cli/bin/rome.ts
async function ___R$$priv$project$rome$$internal$cli$bin$rome_ts$main() {
		switch (
			process.env.ROME_PROCESS_VERSION ===
			___R$project$rome$$internal$core$common$constants_ts$VERSION &&
			process.env.ROME_PROCESS_TYPE
		) {
			case "server":
				return ___R$project$rome$$internal$cli$server_ts$default();

			case "worker":
				return ___R$project$rome$$internal$cli$worker_ts$default();

			case "test-worker":
				return ___R$project$rome$$internal$cli$testWorker_ts$default();

			default:
				return ___R$project$rome$$internal$cli$cli_ts$default();
		}
	}

	const ___R$$priv$project$rome$$internal$cli$bin$rome_ts$bin = ___R$project$rome$$internal$core$common$constants_ts$getBinPath().join();
	___R$project$rome$$internal$v8$sourceMapManager_ts$default.add(
		___R$$priv$project$rome$$internal$cli$bin$rome_ts$bin,
		___R$project$rome$$internal$codec$source$map$SourceMapConsumer_ts$default.fromJSONLazy(
			___R$$priv$project$rome$$internal$cli$bin$rome_ts$bin,
			() =>
				JSON.parse(
					___R$project$rome$$internal$fs$index_ts$readFileTextSync(
						___R$project$rome$$internal$core$common$constants_ts$getBinPath().addExtension(
							".map",
						),
					),
				)
			,
		),
	);

	function ___R$project$rome$$internal$cli$bin$rome_ts$executeCLIMain() {
		___R$project$rome$$internal$v8$sourceMapManager_ts$initErrorHooks();

		setInterval(
			() => {
				// We want to exit on our own terms
			},
			1_000_000,
		);

		___R$$priv$project$rome$$internal$cli$bin$rome_ts$main().catch((error) => {
			___R$project$rome$$internal$core$common$handleFatalError_ts$default({
				error,
				source: ___R$project$rome$$internal$markup$escape_ts$markup`cli`,
				reporter: ___R$project$rome$$internal$cli$reporter$Reporter_ts$default.fromProcess(),
			});
		});
	}

	___R$project$rome$$internal$cli$bin$rome_ts$executeCLIMain();


  // project-rome/rome/bin/rome.ts
const ___R$project$rome$rome$bin$rome_ts = {};


  return ___R$project$rome$rome$bin$rome_ts;
})(typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this));
//# sourceMappingURL=rome.ts.map
