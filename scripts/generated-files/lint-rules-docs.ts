import {createIntegrationWorker} from "@romefrontend/test-helpers";
import {tests} from "@romefrontend/compiler/lint/rules/tests";
import {
	DiagnosticCategory,
	DiagnosticsProcessor,
} from "@romefrontend/diagnostics";
import {printDiagnosticsToString} from "@romefrontend/cli-diagnostics";
import highlightCode from "@romefrontend/cli-diagnostics/highlightCode";
import {inferDiagnosticLanguageFromFilename} from "@romefrontend/core/common/file-handlers";
import {joinMarkupLines, markupToHtml} from "@romefrontend/cli-layout/format";
import {readFileText, writeFile} from "@romefrontend/fs";
import {
	AbsoluteFilePath,
	createAbsoluteFilePath,
	createUnknownFilePath,
} from "@romefrontend/path";
import {dedent} from "@romefrontend/string-utils";
import {ob1Coerce1} from "@romefrontend/ob1";

const {worker, createFileReference} = createIntegrationWorker();

function pre(inner: string): string {
	return `<pre class="language-text"><code class="language-text">${inner}</code></pre>`;
}

function highlightPre(filename: string, code: string): string {
	const path = createUnknownFilePath(filename);
	return pre(
		joinMarkupLines(
			markupToHtml(
				highlightCode({
					path,
					input: code,
					sourceTypeJS: undefined,
					language: inferDiagnosticLanguageFromFilename(path),
					highlight: true,
				}),
			),
		),
	);
}

async function run(
	category: DiagnosticCategory,
	i: number,
	filename: string,
	code: string,
) {
	const {ref} = createFileReference({
		uid: `${category}/${i}/${filename}`,
		sourceText: code,
	});

	const res = await worker.api.lint(
		ref,
		{
			applyRecommendedFixes: true,
			prefetchedModuleSignatures: {},
			save: true,
		},
		{},
	);

	const processor = new DiagnosticsProcessor({
		markupOptions: {
			normalizePosition() {
				return {filename};
			},
		},
	});
	processor.normalizer.setInlineSourceText(ref.uid, code);
	processor.addFilter({
		test(diag) {
			return (
				diag.description.category === `lint/${category}` ||
				diag.description.category === "parse/js"
			);
		},
	});
	processor.addSuppressions(res.suppressions);
	processor.addDiagnostics(res.diagnostics);

	const diagnostics = processor.getDiagnostics();
	const diagnosticsHTML = printDiagnosticsToString({
		diagnostics,
		suppressions: [],
		format: "html",
		excludeFooter: true,
		features: {
			columns: ob1Coerce1(75),
		},
	});

	return [highlightPre(filename, code), pre(diagnosticsHTML)].join("\n");
}

async function main() {
	for (const category in tests) {
		const rawCases = tests[category];
		const cases = Array.isArray(rawCases) ? rawCases : [rawCases];
		const docsPath = createAbsoluteFilePath(__dirname).append(
			`../../website/src/docs/lint/rules/${category}.md`,
		);
		let docs = [await readGeneratedFile(docsPath)];

		docs.push("## Examples");

		docs.push("### Invalid");

		for (const {filename, invalid} of cases) {
			if (invalid) {
				for (let i = 0; i < invalid.length; i++) {
					if (i > 0) {
						docs.push("");
						docs.push("---------------");
						docs.push("");
					}
					docs.push(
						await run(
							(category as DiagnosticCategory),
							i,
							filename,
							dedent(invalid[i]),
						),
					);
				}
			}
		}

		docs.push("### Valid");

		for (const {filename, valid} of cases) {
			if (valid) {
				for (const code of valid) {
					docs.push(highlightPre(filename, dedent(code)));
				}
			}
		}

		docs.push("");

		console.log(`Write ${docsPath.join()}`);
		await writeFile(docsPath, docs.join("\n"));
	}
}

const COMMENT_REGEX = /(\/\/|<!--) EVERYTHING BELOW IS AUTOGENERATED\. SEE SCRIPTS FOLDER FOR UPDATE SCRIPTS([\s\S]+)$/;
const COMMENT_TEXT = "EVERYTHING BELOW IS AUTOGENERATED. SEE SCRIPTS FOLDER FOR UPDATE SCRIPTS";

async function readGeneratedFile(path: AbsoluteFilePath): Promise<string> {
	let file = await readFileText(path);
	const isJS = path.hasExtension("ts") || path.hasExtension("js");

	file = file.replace(COMMENT_REGEX, "");
	file = file.trim();
	file += "\n\n";
	if (isJS) {
		file += "// ";
	} else {
		file += "<!-- ";
	}
	file += COMMENT_TEXT;
	if (!isJS) {
		file += " -->";
	}
	file += "\n\n";
	return file;
}
main().then(() => {
	process.exit(0);
}).catch((err) => {
	console.error(err.stack);
	process.exit(1);
});
