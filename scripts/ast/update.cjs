/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

require('../_setup.cjs');

const path = require('path');
const fs = require('fs');

const {write, getBuilderName} = require('../_utils.cjs');

const {
  generatorsFolder,
  analysisFolder,
  astFolder,
} = require('../_constants.cjs');

let defs = [];

for (const category of fs.readdirSync(astFolder)) {
  const loc = path.join(astFolder, category);

  if (fs.statSync(loc).isFile()) {
    continue;
  }

  for (const basename of fs.readdirSync(loc)) {
    const nodeType = path.basename(basename, path.extname(basename));
    defs.push({
      category,
      builderName: getBuilderName(nodeType),
      nodeType,
    });
  }
}

defs = defs.sort((a, b) => {
  return a.nodeType.localeCompare(b.nodeType);
});

const COMMENT_REGEX = /\/\/ EVERYTHING BELOW IS AUTOGENERATED\. SEE SCRIPTS FOLDER FOR UPDATE SCRIPTS([\s\S]+)$/;
const COMMENT_TEXT = `// EVERYTHING BELOW IS AUTOGENERATED. SEE SCRIPTS FOLDER FOR UPDATE SCRIPTS`;

function readIndexFile(loc, handlers) {
  let file = fs.readFileSync(loc, 'utf8');

  file = file.replace(COMMENT_REGEX, '');

  file = file.trim();
  file += '\n\n';
  file += COMMENT_TEXT;
  file += '\n\n';

  for (const {iterator, wrapCallback} of handlers) {
    let buff = '';

    for (const def of defs) {
      const defBuff = iterator(def);
      if (defBuff) {
        buff += defBuff;
      }
    }

    if (wrapCallback) {
      buff = wrapCallback(buff);
    }

    file += buff;

    file = file.trim();
    file += '\n\n';
  }

  file = file.trim();
  file += '\n';

  write(loc, file);
}

// Add to ast index
readIndexFile(path.join(astFolder, 'index.ts'), [
  {
    iterator({category, nodeType}) {
      return `export * from './${category}/${nodeType}';\n`;
    },
  },
]);

// Add to generators
readIndexFile(path.join(generatorsFolder, 'index.ts'), [
  {
    iterator({category, nodeType}) {
      return `import ${nodeType} from './${category}/${nodeType}';\n` +
        `generators.set('${nodeType}', ${nodeType});\n\n`;
    },
  },
]);

// Add to analysis
readIndexFile(path.join(analysisFolder, 'index.ts'), [
  {
    iterator({category, nodeType}) {
      return `import ${nodeType} from './${category}/${nodeType}';\n` +
        `evaluators.set('${nodeType}', ${nodeType});\n\n`;
    },
  },
]);

// Update unions.ts
const unionsLoc = path.join(astFolder, 'unions.ts');
readIndexFile(unionsLoc, [
  /*{
    iterator(def) {
      if (def.category === 'typescript') {
        return `\n  | n.${def.nodeType}`;
      }
    },
    wrapCallback(buff) {
      return `export type AnyTS = ${buff};`;
    },
  },
  {
    iterator(def) {
      if (def.category === 'flow') {
        return `\n  | n.${def.nodeType}`;
      }
    },
    wrapCallback(buff) {
      return `export type AnyFlow = ${buff};`;
    },
  },*/
  {
    iterator(def) {
      return `\n  | n.${def.nodeType}`;
    },

    wrapCallback(buff) {
      return `export type AnyNode = ${buff};`;
    },
  },
]);
