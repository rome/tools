// Javascript Un-Grammar.
//
// This grammar specifies the structure of Rust's concrete syntax tree.
// It does not specify parsing rules (ambiguities, precedence, etc are out of scope).
// Tokens are processed -- contextual keywords are recognised, compound operators glued.
//
// Legend:
//
//   //          				-- comment
//   Name =      				-- non-terminal definition
//   'ident'     				-- token (terminal)
//   A B         				-- sequence
//   A | B       				-- alternation
//   A*          				-- zero or more repetition
//   (A (',' A)* ','?)	        -- repetition of node A separated by ',' and allowing a trailing comma
//   (A (',' A)*)	            -- repetition of node A separated by ',' without a trailing comma
//   A?          				-- zero or one repetition
//   (A)         				-- same as A
//   label:A     				-- suggested name for field of AST node

// NOTES
//
// - SyntaxNode, SyntaxToken and SyntaxElement will be stripped from the codegen
// - Bogus nodes are special nodes used to keep track of broken code; they are
//   not part of the grammar but they will appear inside the green tree
//


///////////////
// Bogus NODES
///////////////
// SyntaxElement is a generic data structure that is meant to track nodes and tokens
// in cases where we care about both types
//
// As Bogus* node will need to yield both tokens and nodes without discrimination,
// and their children will need to yield nodes and tokens as well.
// For this reason, SyntaxElement = SyntaxElement
SyntaxElement = SyntaxElement

JsBogus = SyntaxElement*
JsBogusStatement = SyntaxElement*
JsBogusExpression = SyntaxElement*
JsBogusMember = SyntaxElement*
JsBogusBinding = SyntaxElement*
JsBogusAssignment = SyntaxElement*
JsBogusParameter = SyntaxElement*
JsBogusImportAssertionEntry = SyntaxElement*
JsBogusNamedImportSpecifier = SyntaxElement*
TsBogusType = SyntaxElement*

AnyJsRoot =
	JsScript | JsModule | JsExpressionSnipped

JsScript =
	interpreter: 'js_shebang'?
	directives: JsDirectiveList
	statements: JsStatementList
	eof: 'EOF'

JsModule =
	interpreter: 'js_shebang'?
	directives: JsDirectiveList
	items: JsModuleItemList
	eof: 'EOF'

JsExpressionSnipped =
	expression: AnyJsExpression
	eof: 'EOF'


JsDirective =
	value: 'js_string_literal'
	';'?

JsDirectiveList = JsDirective*

///////////////
// STATEMENTS
///////////////

AnyJsStatement =
	JsBlockStatement
	| JsBreakStatement
	| JsClassDeclaration
	| JsContinueStatement
	| JsDebuggerStatement
	| JsDoWhileStatement
	| JsEmptyStatement
	| JsExpressionStatement
	| JsForInStatement
	| JsForOfStatement
	| JsForStatement
	| JsIfStatement
	| JsLabeledStatement
	| JsReturnStatement
	| JsSwitchStatement
	| JsThrowStatement
	| JsTryFinallyStatement
	| JsTryStatement
	| JsBogusStatement
	| JsVariableStatement
	| JsWhileStatement
	| JsWithStatement
	| JsFunctionDeclaration
	| TsEnumDeclaration
	| TsTypeAliasDeclaration
	| TsInterfaceDeclaration
	| TsDeclareFunctionDeclaration
	| TsDeclareStatement
	| TsModuleDeclaration
	| TsExternalModuleDeclaration
	| TsGlobalDeclaration
	| TsImportEqualsDeclaration


JsBlockStatement =
	'{'
	statements: JsStatementList
	'}'

JsStatementList = AnyJsStatement*

JsEmptyStatement =
    ';'

JsExpressionStatement =
    expression: AnyJsExpression ';'?


JsWhileStatement =
    'while' '(' test: AnyJsExpression ')'
    body: AnyJsStatement


JsDoWhileStatement =
    'do'
    body: AnyJsStatement
    'while' '(' test: AnyJsExpression ')'
    ';'?


// if statement
JsIfStatement =
	'if' '(' test: AnyJsExpression ')'
	consequent: AnyJsStatement
	else_clause: JsElseClause?

JsElseClause =
	'else'
	alternate: AnyJsStatement


// for..in statement
JsForStatement =
	'for'
	'('
	initializer: AnyJsForInitializer?
	first_semi: ';'
	test: AnyJsExpression?
	second_semi: ';'
	update: AnyJsExpression?
	')'
	body: AnyJsStatement

AnyJsForInitializer = JsVariableDeclaration | AnyJsExpression

// for..in statement
JsForInStatement =
	'for'
	'('
	initializer: AnyJsForInOrOfInitializer
	'in'
	expression: AnyJsExpression
	')'
	body: AnyJsStatement

// for..of statement
JsForOfStatement =
	'for'
	'await'?
	'('
	initializer: AnyJsForInOrOfInitializer
	'of'
	expression: AnyJsExpression
	')'
	body: AnyJsStatement

AnyJsForInOrOfInitializer =
	AnyJsAssignmentPattern
	| JsForVariableDeclaration

JsForVariableDeclaration =
	'await'?
	kind_token: ('var' | 'let' | 'const' | 'using')
	declarator: JsVariableDeclarator

JsBreakStatement =
    'break'
    (label: 'ident')?
    ';'?

JsContinueStatement =
    'continue'
    (label: 'ident')?
    ';'?


JsReturnStatement =
    'return'
    argument: AnyJsExpression?
    ';'?


JsWithStatement =
    'with' '(' object: AnyJsExpression ')'
    body: AnyJsStatement


JsLabeledStatement =
    label: 'ident' ':'
    body: AnyJsStatement


JsSwitchStatement =
    'switch' '(' discriminant: AnyJsExpression ')'
    '{'
    cases: JsSwitchCaseList
    '}'

JsSwitchCaseList = AnyJsSwitchClause*

AnyJsSwitchClause = JsCaseClause | JsDefaultClause
JsCaseClause = 'case' test: AnyJsExpression ':' consequent: JsStatementList
JsDefaultClause = 'default' ':' consequent: JsStatementList


JsThrowStatement =
    'throw'
    argument: AnyJsExpression
    ';'?

// try..catch..finally statement
JsTryStatement =
    'try'
    body: JsBlockStatement
    catch_clause: JsCatchClause

JsTryFinallyStatement =
    'try'
    body: JsBlockStatement
    catch_clause: JsCatchClause?
    finally_clause: JsFinallyClause

JsCatchClause =
    'catch'
    declaration: JsCatchDeclaration?
    body: JsBlockStatement

JsCatchDeclaration =
    '('
    binding: AnyJsBindingPattern
    type_annotation: TsTypeAnnotation?
    ')'

JsFinallyClause =
    'finally'
    body: JsBlockStatement


// debugger statement
JsDebuggerStatement =
	'debugger' ';'?

// declare function test();
TsDeclareStatement =
	'declare'
	declaration: AnyJsDeclarationClause


///////////////
// EXPRESSIONS
///////////////

// Expression
AnyJsExpression =
	AnyJsLiteralExpression
	| JsImportMetaExpression
	| JsArrayExpression
	| JsArrowFunctionExpression
	| JsAssignmentExpression
	| JsAwaitExpression
	| JsBinaryExpression
	| JsCallExpression
	| JsClassExpression
	| JsComputedMemberExpression
	| JsConditionalExpression
	| JsFunctionExpression
	| JsIdentifierExpression
	| JsImportCallExpression
	| JsInExpression
	| JsInstanceofExpression
	| JsLogicalExpression
	| JsNewExpression
	| JsObjectExpression
	| JsParenthesizedExpression
	| JsPostUpdateExpression
	| JsPreUpdateExpression
	| JsSequenceExpression
	| JsStaticMemberExpression
	| JsSuperExpression
	| JsThisExpression
	| JsUnaryExpression
	| JsBogusExpression
	| JsYieldExpression
	| JsNewTargetExpression
	| JsTemplateExpression
	// Typescript
	| TsTypeAssertionExpression
	| TsAsExpression
	| TsSatisfiesExpression
	| TsNonNullAssertionExpression
	| TsInstantiationExpression
	// JSX
	| JsxTagExpression

JsTemplateExpression =
	tag: AnyJsExpression?
	type_arguments: TsTypeArguments?
	l_tick: '`'
	elements: JsTemplateElementList
	r_tick: '`'

JsTemplateElementList = AnyJsTemplateElement*

AnyJsTemplateElement =
	JsTemplateChunkElement
	| JsTemplateElement

JsTemplateChunkElement = 'template_chunk'

JsTemplateElement =
	'dollar_curly'
	expression: AnyJsExpression
	'}'

JsThisExpression = 'this'

JsSuperExpression = 'super'

// new expression
JsNewExpression =
	'new'
	callee: AnyJsExpression
	type_arguments: TsTypeArguments?
	arguments: JsCallArguments?

// call expression
JsCallExpression =
	callee: AnyJsExpression
	optional_chain: '?.'?
	type_arguments: TsTypeArguments?
	arguments: JsCallArguments


JsAwaitExpression =
	'await'
	argument: AnyJsExpression


JsYieldExpression =
	'yield'
	argument: JsYieldArgument?

JsYieldArgument =
	'*'?
	expression: AnyJsExpression

JsImportCallExpression =
	'import'
	arguments: JsCallArguments

// new target expression
JsNewTargetExpression = 'new' '.' 'target'


JsConditionalExpression =
	test: AnyJsExpression
	'?'
	consequent: AnyJsExpression
	':'
	alternate: AnyJsExpression

// import meta expression
JsImportMetaExpression = 'import' '.' 'meta'

JsFunctionExpression =
	'async'?
	'function'
	'*'?
	id: AnyJsBinding?
	type_parameters: TsTypeParameters?
	parameters: JsParameters
	return_type_annotation: TsReturnTypeAnnotation?
	body: JsFunctionBody


JsArrowFunctionExpression =
	'async'?
	type_parameters: TsTypeParameters?
	parameters: AnyJsArrowFunctionParameters
	return_type_annotation: TsReturnTypeAnnotation?
	'=>'
	body: AnyJsFunctionBody

AnyJsArrowFunctionParameters = JsParameters | AnyJsBinding
AnyJsFunctionBody = AnyJsExpression | JsFunctionBody

// Array expression
JsArrayExpression =
	'['
	elements: JsArrayElementList
	']'

JsArrayElementList = (AnyJsArrayElement (',' AnyJsArrayElement)* ','?)

AnyJsArrayElement =
	AnyJsExpression
	| JsSpread
	| JsArrayHole

JsArrayHole = hole: ''?

JsAssignmentExpression =
  left: AnyJsAssignmentPattern
  operator_token: (
		'=' |'+=' | '-=' | '*=' | '/=' | '%=' |
		'**=' | '>>=' | '<<=' | '>>>=' | '&=' |
		'|=' | '^=' | '&&=' | '||=' | '??='
  )
  right: AnyJsExpression


JsSequenceExpression =
	left: AnyJsExpression
	comma: ','
	right: AnyJsExpression


JsParenthesizedExpression =
	'(' expression: AnyJsExpression ')'


JsIdentifierExpression = name: JsReferenceIdentifier

// a.b
// a.#b
JsStaticMemberExpression =
	object: AnyJsExpression
	operator_token: ('.' | '?.')
	member: AnyJsName

// a[b]
JsComputedMemberExpression =
	object: AnyJsExpression
	optional_chain: '?.'?
	'['
	member: AnyJsExpression
	']'

JsBinaryExpression =
    left: AnyJsExpression
    operator_token: (
    	'<' | '>' | '<=' | '>=' | '==' | '===' | '!=' | '!=='
    	| '+' | '-' | '*' | '/' | '%' | '**' | '<<' | '>>' | '>>>'
    	| '&' | '|' | '^'
		)
    right: AnyJsExpression

JsInstanceofExpression =
	left: AnyJsExpression
	'instanceof'
	right: AnyJsExpression

JsInExpression =
	property: AnyJsInProperty
	'in'
	object: AnyJsExpression

AnyJsInProperty =
	JsPrivateName
	| AnyJsExpression

JsLogicalExpression =
	left: AnyJsExpression
	operator_token: ('??' | '||' | '&&')
	right: AnyJsExpression

// unary expression
JsUnaryExpression =
  operator_token: ('delete' | 'void' | 'typeof' | '+' | '-' | '~' | '!')
  argument: AnyJsExpression

JsPreUpdateExpression =
    operator_token: ('++' | '--')
    operand: AnyJsAssignment

JsPostUpdateExpression =
    operand: AnyJsAssignment
    operator_token: ('++' | '--')


///////////////
// OBJECTS
///////////////
AnyJsObjectMemberName =
	JsLiteralMemberName
	| JsComputedMemberName

JsObjectExpression =
	'{'
	members: JsObjectMemberList
	'}'

JsObjectMemberList = (AnyJsObjectMember (',' AnyJsObjectMember)* ','?)

AnyJsObjectMember =
	JsPropertyObjectMember
	| JsMethodObjectMember
	| JsGetterObjectMember
	| JsSetterObjectMember
	| JsShorthandPropertyObjectMember
	| JsSpread
	| JsBogusMember


// { a: 5, b: () => {} }
//   ^^^^  ^^^^^^^^^^^
JsPropertyObjectMember =
	name: AnyJsObjectMemberName
	':'
	value: AnyJsExpression

// { get a() {} }
//   ^^^^^^^^^^
JsGetterObjectMember =
	'get'
	name: AnyJsObjectMemberName
	'('')'
	return_type: TsTypeAnnotation?
	body: JsFunctionBody

//  { set a(value) {} }
//    ^^^^^^^^^^^^^^^
JsSetterObjectMember =
	'set'
	name: AnyJsObjectMemberName
	'('
	parameter: AnyJsFormalParameter
	')'
	body: JsFunctionBody

// { a() {}, async b() {}, async * c() {} }
//   ^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^^^^
JsMethodObjectMember =
	'async'?
	'*'?
	name: AnyJsObjectMemberName
	type_parameters: TsTypeParameters?
	parameters: JsParameters
	return_type_annotation: TsReturnTypeAnnotation?
	body: JsFunctionBody

// { a }
//   ^
JsShorthandPropertyObjectMember = name: JsReferenceIdentifier

///////////////
// CLASSES
///////////////

JsClassDeclaration =
	decorators: JsDecoratorList
	'abstract'?
	'class'
	id: AnyJsBinding
	type_parameters: TsTypeParameters?
	extends_clause: JsExtendsClause?
	implements_clause: TsImplementsClause?
	'{'
	members: JsClassMemberList
	'}'

JsClassExpression =
	decorators: JsDecoratorList
	'class'
	id: AnyJsBinding?
	type_parameters: TsTypeParameters?
	extends_clause: JsExtendsClause?
	implements_clause: TsImplementsClause?
	'{'
	members: JsClassMemberList
	'}'

JsClassMemberList = AnyJsClassMember*

AnyJsClass =
	JsClassDeclaration
	| JsClassExpression
	| JsClassExportDefaultDeclaration

// class Test extends A {}
//            ^^^^^^^^^
JsExtendsClause =
	'extends'
	super_class: AnyJsExpression
	type_arguments: TsTypeArguments?

TsImplementsClause =
	'implements'
	types: TsTypeList

// class Test { #test; }
//              ^^^^^
JsPrivateClassMemberName = '#' id: 'ident'

AnyJsClassMemberName =
	JsLiteralMemberName
	| JsComputedMemberName
	| JsPrivateClassMemberName

AnyJsClassMember =
	JsConstructorClassMember
	| JsStaticInitializationBlockClassMember
	| JsPropertyClassMember
	| JsMethodClassMember
	| JsGetterClassMember
	| JsSetterClassMember
	| TsConstructorSignatureClassMember
	| TsPropertySignatureClassMember
	| TsInitializedPropertySignatureClassMember
	| TsMethodSignatureClassMember
	| TsGetterSignatureClassMember
	| TsSetterSignatureClassMember
	| TsIndexSignatureClassMember
	| JsEmptyClassMember
	| JsBogusMember

JsStaticModifier = modifier: 'static'
JsAccessorModifier = modifier: 'accessor'
TsDeclareModifier = modifier: 'declare'
TsReadonlyModifier = modifier: 'readonly'
TsAbstractModifier = modifier: 'abstract'
TsOverrideModifier = modifier: 'override'
TsAccessibilityModifier = modifier_token: ('private' | 'protected' | 'public')
TsConstModifier = modifier: 'const'
TsInModifier = modifier: 'in'
TsOutModifier = modifier: 'out'

JsStaticInitializationBlockClassMember =
	'static'
	'{'
	statements: JsStatementList
	'}'


// class Test { constructor() {} }
//              ^^^^^^^^^^^^^^^^
// class Test { "constructor"() {} }
//              ^^^^^^^^^^^^^^^^^^
// class Test { 'constructor'() {} }
//              ^^^^^^^^^^^^^^^^^^
JsConstructorClassMember =
	modifiers: JsConstructorModifierList
	name: JsLiteralMemberName
	parameters: JsConstructorParameters
	body: JsFunctionBody

JsConstructorModifierList = TsAccessibilityModifier*

JsConstructorParameters =
	'('
	parameters: JsConstructorParameterList
	')'

JsConstructorParameterList = (AnyJsConstructorParameter (',' AnyJsConstructorParameter)* ','?)

AnyJsConstructorParameter =
	AnyJsFormalParameter
	| JsRestParameter
	| TsPropertyParameter

// constructor(private a: string)
//             ^^^^^^^^^^^^^^^^^
TsPropertyParameter =
	decorators: JsDecoratorList
	modifiers: TsPropertyParameterModifierList
	formal_parameter: AnyJsFormalParameter

TsPropertyParameterModifierList = AnyTsPropertyParameterModifier*

AnyTsPropertyParameterModifier =
	TsAccessibilityModifier
	| TsReadonlyModifier
	| TsOverrideModifier

TsConstructorSignatureClassMember =
	modifiers: JsConstructorModifierList
	name: JsLiteralMemberName
	parameters: JsConstructorParameters
	';'?

// class Test { a; b = 1; static c; }
//              ^^ ^^^^^^ ^^^^^^^^^
JsPropertyClassMember =
	modifiers: JsPropertyModifierList
	name: AnyJsClassMemberName
	property_annotation: AnyTsPropertyAnnotation?
	value: JsInitializerClause?
	';'?

AnyJsPropertyModifier =
	TsAccessibilityModifier
	| JsStaticModifier
	| JsAccessorModifier
	| JsDecorator
	| TsReadonlyModifier
	| TsOverrideModifier

JsPropertyModifierList = AnyJsPropertyModifier*

TsPropertySignatureClassMember =
	modifiers: TsPropertySignatureModifierList
	name: AnyJsClassMemberName
	property_annotation: AnyTsPropertySignatureAnnotation?
	';'?

TsInitializedPropertySignatureClassMember =
	modifiers: TsPropertySignatureModifierList
	name: AnyJsClassMemberName
	'?'?
	value: JsInitializerClause
	';'?

TsPropertySignatureModifierList = AnyTsPropertySignatureModifier*

AnyTsPropertySignatureModifier =
	TsDeclareModifier
  	| TsAccessibilityModifier
  	| JsStaticModifier
  	| JsDecorator
  	| JsAccessorModifier
  	| TsReadonlyModifier
  	| TsOverrideModifier
  	| TsAbstractModifier

AnyTsPropertySignatureAnnotation =
	TsTypeAnnotation
	| TsOptionalPropertyAnnotation

AnyTsPropertyAnnotation =
	TsTypeAnnotation
	| TsOptionalPropertyAnnotation
	| TsDefinitePropertyAnnotation

TsOptionalPropertyAnnotation =
	'?'
	type_annotation: TsTypeAnnotation?

TsDefinitePropertyAnnotation =
	'!'
	type_annotation: TsTypeAnnotation

// class Test { a() {} }
//              ^^^^^^
JsMethodClassMember =
	modifiers: JsMethodModifierList
	'async'?
	'*'?
	name: AnyJsClassMemberName
	'?'?
	type_parameters: TsTypeParameters?
	parameters: JsParameters
	return_type_annotation: TsReturnTypeAnnotation?
	body: JsFunctionBody

AnyJsMethodModifier =
	TsAccessibilityModifier
	| JsStaticModifier
	| JsDecorator
	| TsOverrideModifier

JsMethodModifierList = AnyJsMethodModifier*

TsMethodSignatureClassMember =
	modifiers: TsMethodSignatureModifierList
	'async'?
	name: AnyJsClassMemberName
	'?'?
	type_parameters: TsTypeParameters?
	parameters: JsParameters
	return_type_annotation: TsReturnTypeAnnotation?
	';'?

TsMethodSignatureModifierList = AnyTsMethodSignatureModifier*
AnyTsMethodSignatureModifier =
	TsAccessibilityModifier
	| JsDecorator
	| JsStaticModifier
	| TsOverrideModifier
	| TsAbstractModifier

// class Test { get a() {} }
//              ^^^^^^^^^^
JsGetterClassMember =
	modifiers: JsMethodModifierList
	'get'
	name: AnyJsClassMemberName
	'(' ')'
	return_type: TsTypeAnnotation?
	body: JsFunctionBody

TsGetterSignatureClassMember =
	modifiers: TsMethodSignatureModifierList
	'get'
	name: AnyJsClassMemberName
	'(' ')'
	return_type: TsTypeAnnotation?
	';'?

// class Test { set a(v) {} }
//              ^^^^^^^^^^^
JsSetterClassMember =
	modifiers: JsMethodModifierList
	'set'
	name: AnyJsClassMemberName
	'('
	parameter: AnyJsFormalParameter
	')'
	body: JsFunctionBody

TsSetterSignatureClassMember =
	modifiers: TsMethodSignatureModifierList
	'set'
	name: AnyJsClassMemberName
	'('
	parameter: AnyJsFormalParameter
	')'
	';'?

// class Test { [a: string]: number }
//
TsIndexSignatureClassMember =
	modifiers: TsIndexSignatureModifierList
	'['
	parameter: TsIndexSignatureParameter
	']'
	type_annotation: TsTypeAnnotation
	';'?

AnyTsIndexSignatureModifier =
	JsStaticModifier
	| TsReadonlyModifier

TsIndexSignatureModifierList = AnyTsIndexSignatureModifier*

JsEmptyClassMember = ';'

///////////////
// ASSIGNMENT TARGETS
///////////////

AnyJsAssignment =
	JsIdentifierAssignment
	| JsStaticMemberAssignment
	| JsComputedMemberAssignment
	| JsParenthesizedAssignment
	| TsNonNullAssertionAssignment
	| TsAsAssignment
	| TsSatisfiesAssignment
	| TsTypeAssertionAssignment
	| JsBogusAssignment


JsAssignmentWithDefault =
	pattern: AnyJsAssignmentPattern
	'='
	default: AnyJsExpression

// (a) = "test"
// ^^^
JsParenthesizedAssignment =
	'('
	assignment: AnyJsAssignment
	')'

// Assignment to an identifier from the lexical scope
// b = "test"
// ^
JsIdentifierAssignment = name: 'ident'

// a.b = a.#b = "test"
// ^^^   ^^^^
JsStaticMemberAssignment =
	object: AnyJsExpression
	'.'
	member: AnyJsName

// a['b'] = a[expr] = "test"
// ^^^^^^   ^^^^^^^
JsComputedMemberAssignment =
	object: AnyJsExpression
	'['
	member: AnyJsExpression
	']'

TsNonNullAssertionAssignment =
	assignment: AnyJsAssignment
	'!'

// Only valid inside of parenthesized assignments
// (a as string) = "test";
//  ^^^^^^^^^^^^
TsAsAssignment =
	assignment: AnyJsAssignment
	'as'
	type: AnyTsType

// Only valid inside of parenthesized assignments
// (a satisfies string) = "test";
//  ^^^^^^^^^^^^
TsSatisfiesAssignment =
	assignment: AnyJsAssignment
	'satisfies'
	type: AnyTsType

TsTypeAssertionAssignment =
	'<'
	type: AnyTsType
	'>'
	assignment: AnyJsAssignment

AnyJsAssignmentPattern =
	AnyJsAssignment
	| JsArrayAssignmentPattern
	| JsObjectAssignmentPattern


// [a, b = "b", ...rest] = bar
// ^^^^^^^^^^^^^^^^^^^^^^
JsArrayAssignmentPattern =
	'['
	elements: JsArrayAssignmentPatternElementList
	']'

JsArrayAssignmentPatternElementList = (AnyJsArrayAssignmentPatternElement (',' AnyJsArrayAssignmentPatternElement)* ','?)

AnyJsArrayAssignmentPatternElement =
	JsAssignmentWithDefault
	| AnyJsAssignmentPattern
	| JsArrayAssignmentPatternRestElement
	| JsArrayHole

// [a, b, ...rest] = [];
//        ^^^^^^^
JsArrayAssignmentPatternRestElement =
	'...'
	pattern: AnyJsAssignmentPattern

// ({a, b: x, ...rest} = c)
//  ^^^^^^^^^^^^^^^^^^
JsObjectAssignmentPattern =
	'{'
	properties: JsObjectAssignmentPatternPropertyList
	'}'

JsObjectAssignmentPatternPropertyList = (AnyJsObjectAssignmentPatternMember (',' AnyJsObjectAssignmentPatternMember)* ','?)

AnyJsObjectAssignmentPatternMember =
	JsObjectAssignmentPatternShorthandProperty
	| JsObjectAssignmentPatternProperty
	| JsObjectAssignmentPatternRest
	| JsBogusAssignment

// ({ x } = b) or ({ x = "test" } = b)
//    ^              ^^^^^^^^^^
JsObjectAssignmentPatternShorthandProperty =
	identifier: JsIdentifierAssignment
	init: JsInitializerClause?

// ({ x: a } = b) or ({ x: a = "test" } = b)
//    ^^^^              ^^^^^^^^^^^^^
JsObjectAssignmentPatternProperty =
	member: AnyJsObjectMemberName
	':'
	pattern: AnyJsAssignmentPattern
	init: JsInitializerClause?

// ({ a, ...b } = a)
//       ^^^^
JsObjectAssignmentPatternRest =
	'...'
	target: AnyJsAssignment

///////////////
// BINDINGS
///////////////

AnyJsBinding =
	JsIdentifierBinding
	| JsBogusBinding

// Binds a value to an identifier.
// let x = OR function(test) {}
//     ^               ^^^^
JsIdentifierBinding =
	name: 'ident'

// [ a = "b"] = [];
//   ^^^^^^^
JsBindingPatternWithDefault =
	pattern: AnyJsBindingPattern
	'='
	default: AnyJsExpression

AnyJsBindingPattern =
	AnyJsBinding
	| JsArrayBindingPattern
	| JsObjectBindingPattern

// let [a, b] = [1, 2];
//     ^^^^^^
JsArrayBindingPattern =
	'['
	elements: JsArrayBindingPatternElementList
	']'

JsArrayBindingPatternElementList = (AnyJsArrayBindingPatternElement (',' AnyJsArrayBindingPatternElement)* ','?)

AnyJsArrayBindingPatternElement =
	JsArrayHole
	| AnyJsBindingPattern
	| JsBindingPatternWithDefault
	| JsArrayBindingPatternRestElement

JsArrayBindingPatternRestElement =
	'...'
	pattern: AnyJsBindingPattern

// let { a, b} = c;
//     ^^^^^^^
JsObjectBindingPattern =
	'{'
	properties: JsObjectBindingPatternPropertyList
	'}'

JsObjectBindingPatternPropertyList = (AnyJsObjectBindingPatternMember (',' AnyJsObjectBindingPatternMember)* ','?)

AnyJsObjectBindingPatternMember =
	JsObjectBindingPatternProperty
	| JsObjectBindingPatternRest
	| JsObjectBindingPatternShorthandProperty
	| JsBogusBinding

// let { a: b.m } = {}
//       ^^^^^^
// let { a: b.m = "test" } = {}
//       ^^^^^^^^^^^^^^^
JsObjectBindingPatternProperty =
	member: AnyJsObjectMemberName
	':'
	pattern: AnyJsBindingPattern
	init: JsInitializerClause?

// let { a } = c
//       ^
// let { a = "test" } = c
//       ^^^^^^^^^^
JsObjectBindingPatternShorthandProperty =
	identifier: AnyJsBinding
	init: JsInitializerClause?

// let { ...a } = c
//       ^^^^
JsObjectBindingPatternRest =
	'...'
	binding: AnyJsBinding


///////////////
// LITERALS
///////////////

AnyJsLiteralExpression =
	JsStringLiteralExpression
	| JsNumberLiteralExpression
	| JsBigintLiteralExpression
	| JsBooleanLiteralExpression
	| JsNullLiteralExpression
	| JsRegexLiteralExpression

// "abcd" | 'abcd'
JsStringLiteralExpression = value: 'js_string_literal'

// 4, 5.5, 0x00, ...
JsNumberLiteralExpression = value: 'js_number_literal'

// 45n
JsBigintLiteralExpression =  value: 'js_bigint_literal'

// true, false
JsBooleanLiteralExpression = value_token: ('true' | 'false')

// null
JsNullLiteralExpression = value: 'null'

JsRegexLiteralExpression = value: 'js_regex_literal'


///////////////
// DECLARATIONS
///////////////

AnyJsDeclaration =
	JsClassDeclaration
	| JsFunctionDeclaration
	| JsVariableDeclaration
	| TsEnumDeclaration
	| TsTypeAliasDeclaration
	| TsInterfaceDeclaration
	| TsDeclareFunctionDeclaration
	| TsModuleDeclaration
	| TsExternalModuleDeclaration
	| TsGlobalDeclaration
	| TsImportEqualsDeclaration

// Used when declarations appear in a non-statement position.
// export let a, b;
//        ^^^^^^^^^
// declare let a, b;
//         ^^^^^^^^^
AnyJsDeclarationClause =
	JsClassDeclaration
	| JsFunctionDeclaration
	| JsVariableDeclarationClause
	| TsEnumDeclaration
	| TsTypeAliasDeclaration
	| TsInterfaceDeclaration
	| TsDeclareFunctionDeclaration
	| TsModuleDeclaration
	| TsExternalModuleDeclaration
	| TsGlobalDeclaration
	| TsImportEqualsDeclaration

JsVariableDeclarationClause =
	declaration: JsVariableDeclaration
	';'?


JsFunctionDeclaration =
	'async'?
	'function'
	'*'?
	id: AnyJsBinding
	type_parameters: TsTypeParameters?
	parameters: JsParameters
	return_type_annotation: TsReturnTypeAnnotation?
	body: JsFunctionBody

TsTypeAnnotation =
	':'
	type: AnyTsType

TsReturnTypeAnnotation =
	':'
	type: AnyTsReturnType

// let a, b = c;
JsVariableStatement =
	declaration: JsVariableDeclaration
	 ';'?

// Declaration of multiple variables
// let a, b = c;
// ^^^^^^^^
JsVariableDeclaration =
		'await'?
		kind: ('var' | 'const' | 'let' | 'using')
		declarators: JsVariableDeclaratorList

JsVariableDeclaratorList = (JsVariableDeclarator (',' JsVariableDeclarator)*)

// let b = c;
//     ^^^^^
JsVariableDeclarator =
    id: AnyJsBindingPattern
    variable_annotation: AnyTsVariableAnnotation?
    initializer: JsInitializerClause?

AnyTsVariableAnnotation =
	TsTypeAnnotation
	| TsDefiniteVariableAnnotation

TsDefiniteVariableAnnotation =
	'!'
	type_annotation: TsTypeAnnotation


///////////////
// MODULE SYNTAX
///////////////

AnyJsModuleItem =
	AnyJsStatement
	| JsExport
	| JsImport
JsModuleItemList = AnyJsModuleItem*

JsImport =
	'import'
	import_clause: AnyJsImportClause
	';'?

AnyJsImportClause =
    JsImportBareClause
    | JsImportNamedClause
    | JsImportDefaultClause
    | JsImportNamespaceClause

// import "abcd"
// import "abcd" assert ...
JsImportBareClause =
	source: JsModuleSource
	assertion: JsImportAssertion?

// import foo from "mod"
// import type foo from "mod"
JsImportDefaultClause =
		'type'?
		local_name: AnyJsBinding
		'from'
		source: JsModuleSource
		assertion: JsImportAssertion?

// import * as foo from "mod";
// import type * as foo from "mod";
JsImportNamespaceClause =
  'type'?
	'*'
	'as'
	local_name: AnyJsBinding
	'from'
	source: JsModuleSource
	assertion: JsImportAssertion?

// import { a, b: c } from "d"
//        ^^^^^^^^^^^^^^^^^^^^
// import c, { b } from "c"
//        ^^^^^^^^^^^^^^^^^
// import { type a } from "c"
//        ^^^^^^^^^^^^^^^^^^^
// import foo, * as bar from "mod"
//        ^^^^^^^^^^^^^^^^^^^^^^^^
// import type { foo } from "mod";
//        ^^^^^^^^^^^^^^^^^^^^^^^
// import foo, { type bar } from "mod";
JsImportNamedClause =
    'type'?
    default_specifier: JsDefaultImportSpecifier?
    named_import: AnyJsNamedImport
    'from'
    source: JsModuleSource
    assertion: JsImportAssertion?

// import a, { b, c } from "d";
//        ^^
JsDefaultImportSpecifier =
    local_name: AnyJsBinding
    trailing_comma: ','

AnyJsNamedImport =
	JsNamedImportSpecifiers
	|  JsNamespaceImportSpecifier

// import a, * as b from "d";
//           ^^^^^^
JsNamespaceImportSpecifier =
    '*'
    'as'
    local_name: AnyJsBinding

// import a, { b, c } from "d";
//           ^^^^^^^^
JsNamedImportSpecifiers =
    '{'
    specifiers: JsNamedImportSpecifierList
    '}'

JsNamedImportSpecifierList = (AnyJsNamedImportSpecifier (',' AnyJsNamedImportSpecifier)* ','?)

AnyJsNamedImportSpecifier =
    JsShorthandNamedImportSpecifier
    | JsNamedImportSpecifier
    | JsBogusNamedImportSpecifier

// import { foo as test } from "mod";
//          ^^^^^^^^^^^
// import { type foo as test } from "mod";
//          ^^^^^^^^^^^^^^^^^
JsNamedImportSpecifier =
    'type'?
    name: JsLiteralExportName
    'as'
    local_name: AnyJsBinding

// import { type foo } from "mod";
//          ^^^^^^^^
JsShorthandNamedImportSpecifier =
    'type'?
    local_name: AnyJsBinding

// import a from "mod" assert { type: "json" }
//                     ^^^^^^^^^^^^^^^^^^^^^^^
JsImportAssertion =
    assertion_kind: ('assert' | 'with')
    '{'
    assertions: JsImportAssertionEntryList
    '}'

JsImportAssertionEntryList = (AnyJsImportAssertionEntry (',' AnyJsImportAssertionEntry)* ','?)

AnyJsImportAssertionEntry =
	JsImportAssertionEntry
	| JsBogusImportAssertionEntry

// import a from "mod" assert { type: "json" }
//                              ^^^^^^^^^^^^
JsImportAssertionEntry =
    key: ('ident' | 'js_string_literal')
    ':'
    value: 'js_string_literal'

// import { a as b } from "c"
//          ^
// export { a as "a-b-c" };
//               ^^^^^^^
JsLiteralExportName = value: ('ident' | 'js_string_literal')


// import "test"
//        ^^^^^^
// export a from "b"
//               ^^^
JsModuleSource = value: 'js_string_literal'


JsExport =
	decorators: JsDecoratorList
	'export'
	export_clause: AnyJsExportClause


// export function a() {}
// export default function () {}
// export class A {}
// export default class A {}
// export let a, b, c, d;
// export default a, b, c;
// export { a, b as c };
// export * from "b";
// export { a, b as c } from "b";
//
// Typescript:
// export type A = string;
// export enum B { A, B }
// export interface C {}
// export namespace D {}
// export as namespace c;
// export = b;
// export import a = b;
AnyJsExportClause =
	JsExportDefaultDeclarationClause
	| JsExportDefaultExpressionClause
	| JsExportNamedClause
	| JsExportFromClause
	| JsExportNamedFromClause
	| AnyJsDeclarationClause
	| TsExportAsNamespaceClause
	| TsExportAssignmentClause
	| TsExportDeclareClause


// export default a;
//        ^^^^^^^^^^
JsExportDefaultExpressionClause =
	'default'
	expression: AnyJsExpression
	';'?

// export default class {}
//        ^^^^^^^^^^^^^^^^
JsExportDefaultDeclarationClause =
	'default'
	declaration: AnyJsExportDefaultDeclaration
	';'?

AnyJsExportDefaultDeclaration =
	JsClassExportDefaultDeclaration
	| JsFunctionExportDefaultDeclaration
	| TsInterfaceDeclaration
	| TsDeclareFunctionExportDefaultDeclaration


// export default class {}
//                ^^^^^^^^
JsClassExportDefaultDeclaration =
	decorators: JsDecoratorList
	'abstract'?
	'class'
	id: AnyJsBinding?
	type_parameters: TsTypeParameters?
	extends_clause: JsExtendsClause?
	implements_clause: TsImplementsClause?
	'{'
	members: JsClassMemberList
	'}'

// export default function () {}
//                ^^^^^^^^^^^^^^
JsFunctionExportDefaultDeclaration =
	'async'?
	'function'
	'*'?
	id: AnyJsBinding?
	type_parameters: TsTypeParameters?
	parameters: JsParameters
	return_type_annotation: TsReturnTypeAnnotation?
	body: JsFunctionBody

// export { myFunction as default };
// export { myFunction, myVariable };
JsExportNamedClause =
	'type'?
	'{'
	specifiers: JsExportNamedSpecifierList
	'}'
	';'?

JsExportNamedSpecifierList = (AnyJsExportNamedSpecifier (',' AnyJsExportNamedSpecifier)* ','?)

AnyJsExportNamedSpecifier =
    JsExportNamedShorthandSpecifier
    | JsExportNamedSpecifier

// export { a };
//          ^
JsExportNamedShorthandSpecifier =
    'type'?
    name: JsReferenceIdentifier

// export { a as b };
//          ^^^^^^
// export { a as default };
//          ^^^^^^^^^^^^
JsExportNamedSpecifier =
    'type'?
    local_name: JsReferenceIdentifier
    'as'
    exported_name: JsLiteralExportName

JsExportFromClause =
	'type'?
	'*'
	export_as: JsExportAsClause?
	'from'
	source: JsModuleSource
	assertion: JsImportAssertion?
	';'?

// export { a } from "b";
// export { default, … } from …;
// export { type default as C } from "a";
// export { type default } from "a";
JsExportNamedFromClause =
	'type'?
	'{'
	specifiers: JsExportNamedFromSpecifierList
	'}'
	'from'
	source: JsModuleSource
	assertion: JsImportAssertion?
	';'?

JsExportNamedFromSpecifierList = (JsExportNamedFromSpecifier (',' JsExportNamedFromSpecifier)* ','?)

// export { a } from "b";
//          ^
// export { a as b } from "c";
//          ^^^^^^
JsExportNamedFromSpecifier =
    'type'?
    source_name: JsLiteralExportName
    export_as: JsExportAsClause?


// export { a as b } from "c";
//            ^^^^
JsExportAsClause =
    'as'
    exported_name: JsLiteralExportName

// export as namespace mathLib
//        ^^^^^^^^^^^^^^^^^^^^
TsExportAsNamespaceClause =
	'as'
	'namespace'
	name: JsName
	';'?

// export = a
//        ^^^
// export = a.b.c;
//        ^^^^^^^^
// export = class {}
TsExportAssignmentClause =
	'='
	expression: AnyJsExpression
	';'?

// export declare class A {}
//        ^^^^^^^^^^^^^^^^^^
TsExportDeclareClause =
	'declare'
	declaration: AnyJsDeclarationClause

///////////////
// AUXILIARY
///////////////

// { ...a }
//   ^^^^
// [ ...a ]
//   ^^^^
JsSpread =
	'...'
	argument: AnyJsExpression


// Reference to an identifier from the lexical scope
JsReferenceIdentifier = value: 'ident'

// A js identifier that is neither a binding, assignment, nor a reference.
// For example a member name
JsName = value: 'ident'

JsPrivateName =
	'#'
	value: 'ident'

AnyJsName =
	JsName
	| JsPrivateName


AnyJsFunction =
	JsFunctionExpression
	| JsFunctionDeclaration
	| JsArrowFunctionExpression
	| JsFunctionExportDefaultDeclaration


// { a: ..., "b": ..., 4: ... }
//   ^       ^^^       ^
JsLiteralMemberName = value: ('ident' | 'js_string_literal' | 'js_number_literal')

// { [call()]: ... }
//   ^^^^^^^^
JsComputedMemberName =
	'['
	expression: AnyJsExpression
	']'


JsParameters =
	'('
	items: JsParameterList
	')'

JsParameterList = (AnyJsParameter (',' AnyJsParameter)* ','?)

AnyJsFormalParameter =
	JsFormalParameter
	| JsBogusParameter

AnyJsParameter =
	AnyJsFormalParameter
	| JsRestParameter
	| TsThisParameter

// (a?: string) => {}
//  ^^^^^^^^^^
JsFormalParameter =
	decorators: JsDecoratorList
	binding: AnyJsBindingPattern
	'?'?
	type_annotation: TsTypeAnnotation?
	initializer: JsInitializerClause?

// (...a) => {}
//  ^^^^
JsRestParameter =
	decorators: JsDecoratorList
	'...'
	binding: AnyJsBindingPattern
	type_annotation: TsTypeAnnotation?

// function a(this: string) {}
//  ^^^^
TsThisParameter =
	'this'
	type_annotation: TsTypeAnnotation?

JsCallArguments = '(' args: JsCallArgumentList ')'

JsCallArgumentList = (AnyJsCallArgument (',' AnyJsCallArgument)* ','?)

AnyJsCallArgument =
	AnyJsExpression
	| JsSpread


// let a = 10;
//       ^^^^
// class { a = 10; }
//           ^^^^
JsInitializerClause =
	'='
	expression: AnyJsExpression

JsFunctionBody =
	'{'
	directives: JsDirectiveList
	statements: JsStatementList
	'}'

JsDecoratorList = JsDecorator*

JsDecorator =
	'@'
	expression: AnyJsDecorator

AnyJsDecorator =
	JsParenthesizedExpression
	| JsCallExpression
	| JsStaticMemberExpression
	| JsIdentifierExpression
	| JsBogusExpression

///////////////
// TYPESCRIPT
///////////////
//
// Below here we want to keep all the TypeScript types
// Typescript definitions
//

AnyTsType =
	// Predefined types
	TsAnyType
	| TsUnknownType
	| TsNumberType
	| TsBooleanType
	| TsBigintType
	| TsStringType
	| TsSymbolType
	| TsVoidType
	| TsUndefinedType
	| TsNeverType
	// Primary types, without predefined types
	| TsParenthesizedType
	| TsReferenceType
	| TsArrayType
	| TsTupleType
	| TsTypeofType
	| TsImportType
	| TsTypeOperatorType
	| TsIndexedAccessType
	| TsMappedType
	| TsObjectType
	| TsNonPrimitiveType
	| TsThisType
	| TsNumberLiteralType
	| TsBigintLiteralType
	| TsStringLiteralType
	| TsNullLiteralType
	| TsBooleanLiteralType
	| TsTemplateLiteralType
	| TsInferType
	// Intersection or higher types
	| TsIntersectionType
	| TsUnionType
	| TsFunctionType
	| TsConstructorType
	| TsConditionalType
	| TsBogusType

// Predefined types
TsAnyType = 'any'
TsUnknownType = 'unknown'
TsNumberType = 'number'
TsNonPrimitiveType = 'object'
TsBooleanType = 'boolean'
TsBigintType = 'bigint'
TsStringType = 'string'
TsSymbolType = 'symbol'
TsVoidType = 'void'
TsUndefinedType = 'undefined'
TsNeverType = 'never'
TsThisType = 'this'

TsParenthesizedType =
	'('
	ty: AnyTsType
	')'

TsReferenceType =
	name: AnyTsName
	type_arguments: TsTypeArguments?

TsTypeAliasDeclaration =
	'type'
	binding_identifier: TsIdentifierBinding
	type_parameters: TsTypeParameters?
	'='
	ty: AnyTsType
	';'?

// Binds a type identifier
TsIdentifierBinding = name: 'ident'

// typescript enum
TsEnumDeclaration =
	'const'?
	'enum'
	id: AnyJsBinding
	'{'
	members: TsEnumMemberList
	'}'

TsEnumMemberList = (TsEnumMember (',' TsEnumMember)* ','?)

TsEnumMember =
	name: AnyJsObjectMemberName
	initializer: JsInitializerClause?

TsImportEqualsDeclaration =
	'import'
	'type'?
	id: AnyJsBinding
	'='
	module_reference: AnyTsModuleReference
	';'?

AnyTsModuleReference =
	AnyTsName
	| TsExternalModuleReference

TsExternalModuleReference =
	'require'
	'('
	source: JsModuleSource
	')'


// declaration of a function without a body
//
// declare function test();
//         ^^^^^^^^^^^^^^^^
// function test();
// ^^^^^^^^^^^^^^^^
TsDeclareFunctionDeclaration =
	'async'?
	'function'
	id: AnyJsBinding
	type_parameters: TsTypeParameters?
	parameters: JsParameters
	return_type_annotation: TsReturnTypeAnnotation?
	';'?

// declaration of a export default function without a body
// declare module 'x' {
//   export default function(option: any): void
//									^^^^^^^^^^^^^^^^^^^^^^^^^^^
// }
TsDeclareFunctionExportDefaultDeclaration =
	'async'?
	'function'
	id: AnyJsBinding?
	type_parameters: TsTypeParameters?
	parameters: JsParameters
	return_type_annotation: TsReturnTypeAnnotation?
	';'?


TsModuleDeclaration =
	module_or_namespace: ('module' | 'namespace')
	name: AnyTsModuleName
	body: TsModuleBlock

// declare global {}
// d.ts: global {}
TsGlobalDeclaration =
	'global'
	body: TsModuleBlock

TsModuleBlock =
	'{'
	items: JsModuleItemList
	'}'

AnyTsModuleName =
	TsIdentifierBinding
	| TsQualifiedModuleName

// declare module a.b.c {}
//                ^^^^^
TsQualifiedModuleName =
	left: AnyTsModuleName
	'.'
	right: JsName

// Can appear on statement level if inside of an ambient context
// declare module "jest";
//         ^^^^^^^^^^^^^^
// declare module "jest" { ... }
//         ^^^^^^^^^^^^^^^^^^^^^
TsExternalModuleDeclaration =
	'module'
	source: JsModuleSource
	body: AnyTsExternalModuleDeclarationBody?

AnyTsExternalModuleDeclarationBody =
	TsEmptyExternalModuleDeclarationBody
	| TsModuleBlock

TsEmptyExternalModuleDeclarationBody = ';'

// | a | b
TsUnionType =
	leading_separator: '|'?
	types: TsUnionTypeVariantList

TsUnionTypeVariantList = (AnyTsType ('|' AnyTsType)*)

// & a & b
TsIntersectionType =
	leading_separator: '&'?
	types: TsIntersectionTypeElementList

TsIntersectionTypeElementList = (AnyTsType ('&' AnyTsType)*)

// keyof A;
// ^^^^^^^
// const a: unique symbol = symbol();
//          ^^^^^^^^^^^^^
// readonly string[];
// ^^^^^^^^^^^^^^^^^
TsTypeOperatorType =
	operator_token: ('keyof' | 'unique' | 'readonly')
	type: AnyTsType

// infer A;
// ^^^^^^^
// { a: infer U; b: infer U }
//      ^^^^^^^     ^^^^^^^
TsInferType =
	'infer'
	name: TsTypeParameterName
	constraint: TsTypeConstraintClause?

TsFunctionType =
	type_parameters: TsTypeParameters?
	parameters: JsParameters
	'=>'
	return_type: AnyTsReturnType

AnyTsReturnType =
	AnyTsType
	| TsPredicateReturnType
	| TsAssertsReturnType

// function test(a): a is string { return true }
TsPredicateReturnType =
	parameter_name: AnyTsTypePredicateParameterName
	'is'
	type: AnyTsType

// function test(a): asserts a { ... }
//                   ^^^^^^^^^
// function test2(a): asserts a is string { ... }
//                    ^^^^^^^^^^^^^^^^^^^
TsAssertsReturnType =
	'asserts'
	parameter_name: AnyTsTypePredicateParameterName
	predicate: TsAssertsCondition?

TsAssertsCondition =
	'is'
	type: AnyTsType


AnyTsTypePredicateParameterName =
	JsReferenceIdentifier
	| TsThisType

TsTypeofType =
	'typeof'
	expression_name: AnyTsName
	type_arguments: TsTypeArguments?

TsConstructorType =
	'abstract'?
	'new'
	type_parameters: TsTypeParameters?
	parameters: JsParameters
	'=>'
	return_type: AnyTsType

TsConditionalType =
	check_type: AnyTsType
	'extends'
	extends_type: AnyTsType
	'?'
	true_type: AnyTsType
	':'
	false_type: AnyTsType


// type A<X, Y> = { x: X, y: Y }
//       ^^^^^^
TsTypeParameters =
	'<'
	items: TsTypeParameterList
	'>'

TsTypeParameterList = (TsTypeParameter (',' TsTypeParameter)* ','?)


// type A<B extends string = "1"> = { b: B }
//        ^^^^^^^^^^^^^^^^^^^^^^
TsTypeParameter =
	modifiers: TsTypeParameterModifierList
	name: TsTypeParameterName
	constraint: TsTypeConstraintClause?
	default: TsDefaultTypeClause?

TsTypeParameterModifierList = AnyTsTypeParameterModifier*

AnyTsTypeParameterModifier =
	TsConstModifier
	| TsInModifier
	| TsOutModifier

TsTypeParameterName = 'ident'

TsTypeConstraintClause =
	'extends'
	type: AnyTsType

TsDefaultTypeClause =
	'='
	type: AnyTsType

// { a: string }
TsObjectType = '{' members: TsTypeMemberList '}'

TsInterfaceDeclaration =
	'interface'
	id: TsIdentifierBinding
	type_parameters: TsTypeParameters?
	extends_clause: TsExtendsClause?
	'{'
	members: TsTypeMemberList
	'}'

TsExtendsClause =
	'extends'
	types: TsTypeList

TsTypeList = (TsNameWithTypeArguments (',' TsNameWithTypeArguments)*)

TsTypeMemberList = AnyTsTypeMember*

AnyTsTypeMember =
	TsCallSignatureTypeMember
	| TsPropertySignatureTypeMember
	| TsConstructSignatureTypeMember
	| TsMethodSignatureTypeMember
	| TsGetterSignatureTypeMember
	| TsSetterSignatureTypeMember
	| TsIndexSignatureTypeMember
	| JsBogusMember

// { <A>(a: A): number }
//   ^^^^^^^^^^^^^^^^^
TsCallSignatureTypeMember =
	type_parameters: TsTypeParameters?
	parameters: JsParameters
	return_type_annotation: TsReturnTypeAnnotation?
	separator_token: (',' | ';')?

// { a: string }
//   ^^^^^^^^^
TsPropertySignatureTypeMember =
	'readonly'?
	name: AnyJsObjectMemberName
	optional: '?'?
	type_annotation: TsTypeAnnotation?
	separator_token: (',' | ';')?

// { new(): number }
//   ^^^^^^^^^^^^^
TsConstructSignatureTypeMember =
	'new'
	type_parameters: TsTypeParameters?
	parameters: JsParameters
	type_annotation: TsTypeAnnotation?
	separator_token: (',' | ';')?

// { a?(): number }
//   ^^^^^^^^^^^^
TsMethodSignatureTypeMember =
	name: AnyJsObjectMemberName
	optional: '?'?
	type_parameters: TsTypeParameters?
	parameters: JsParameters
	return_type_annotation: TsReturnTypeAnnotation?
	separator_token: (',' | ';')?

// { get a(): number }
//   ^^^^^^^^^^^^^^^
TsGetterSignatureTypeMember =
	'get'
	name: AnyJsObjectMemberName
	'('
	')'
	type_annotation: TsTypeAnnotation?
	separator_token: (',' | ';')?

// { set a(value: number) }
//   ^^^^^^^^^^^^^^^^^^^^
TsSetterSignatureTypeMember =
	'set'
	name: AnyJsObjectMemberName
	'('
	parameter: AnyJsFormalParameter
	')'
	separator_token: (',' | ';')?

//  { [a: string]: number }
TsIndexSignatureTypeMember =
	'readonly'?
	'['
	parameter: TsIndexSignatureParameter
	']'
	type_annotation: TsTypeAnnotation
	separator_token: (',' | ';')?

// { [a: string]: number }
//    ^^^^^^^^^
TsIndexSignatureParameter =
	binding: JsIdentifierBinding
	type_annotation: TsTypeAnnotation

// type OptionsFlags<Type> = {
//   [Property in keyof Type]: boolean;
// };
TsMappedType =
	'{'
	readonly_modifier: TsMappedTypeReadonlyModifierClause?
	'['
	property_name: TsTypeParameterName
	'in'
	keys_type: AnyTsType
	as_clause: TsMappedTypeAsClause?
	']'
	optional_modifier: TsMappedTypeOptionalModifierClause?
	mapped_type: TsTypeAnnotation?
	';'?
	'}'

TsMappedTypeAsClause =
	'as'
	type: AnyTsType

TsMappedTypeOptionalModifierClause =
	operator_token: ('+' | '-')?
	'?'

TsMappedTypeReadonlyModifierClause =
	operator_token: ('+' | '-')?
	'readonly'

// a: import("./test").T<typeof X>
//    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// a: import("./test")<string>
//    ^^^^^^^^^^^^^^^^^^^^^^^^^
TsImportType =
	'typeof'?
	'import'
	'('
	argument: 'js_string_literal'
	')'
	qualifier_clause: TsImportTypeQualifier?
	type_arguments: TsTypeArguments?

TsImportTypeQualifier =
	'.'
	right: AnyTsName


TsArrayType =
	element_type: AnyTsType
	'['
	']'

TsIndexedAccessType =
	object_type: AnyTsType
	'['
	index_type: AnyTsType
	']'

TsTupleType =
	'['
	elements: TsTupleTypeElementList
	']'

TsTupleTypeElementList = (AnyTsTupleTypeElement (',' AnyTsTupleTypeElement)* ','?)

AnyTsTupleTypeElement =
	TsNamedTupleTypeElement
	| AnyTsType
	| TsRestTupleTypeElement
	| TsOptionalTupleTypeElement

TsNamedTupleTypeElement =
	'...'?
	name: JsName
	'?'?
	':'
	type: AnyTsType

TsRestTupleTypeElement =
	'...'
	type: AnyTsType

TsOptionalTupleTypeElement =
	type: AnyTsType
	'?'

TsStringLiteralType = literal: 'js_string_literal'
TsNumberLiteralType = '-'? literal: 'js_number_literal'
TsBigintLiteralType = '-'? literal: 'js_bigint_literal'
TsBooleanLiteralType = literal: ('true' | 'false')
TsNullLiteralType = literal: 'null'
TsTemplateLiteralType =
	l_tick: '`'
	elements: TsTemplateElementList
	r_tick: '`'

TsTemplateElementList = AnyTsTemplateElement*

AnyTsTemplateElement =
	TsTemplateChunkElement
	| TsTemplateElement

TsTemplateChunkElement = 'template_chunk'
TsTemplateElement =
	'dollar_curly'
	type: AnyTsType
	'}'

TsTypeAssertionExpression =
	'<'
	type: AnyTsType
	'>'
	expression: AnyJsExpression

// This `SyntaxKind` is related to `ExpressionWithTypeArguments` in Typescript
TsInstantiationExpression =
	expression: AnyJsExpression
	arguments: TsTypeArguments

TsAsExpression =
	expression: AnyJsExpression
	'as'
	type: AnyTsType

TsSatisfiesExpression =
	expression: AnyJsExpression
	'satisfies'
	type: AnyTsType

TsNonNullAssertionExpression =
	expression: AnyJsExpression
	'!'

TsNameWithTypeArguments =
	name: AnyTsName
	type_arguments: TsTypeArguments?

AnyTsName =
	JsReferenceIdentifier
	| TsQualifiedName

TsQualifiedName =
	left: AnyTsName
	'.'
	right: JsName

TsTypeArguments =
	'<'
	TsTypeArgumentList
	'>'

TsTypeArgumentList = (AnyTsType (',' AnyTsType)* )

/////////////////////////////////////////////////////// JSX

// ==================================
// Tags
// ==================================

JsxTagExpression =
	tag: AnyJsxTag

AnyJsxTag =
	JsxElement
	| JsxSelfClosingElement
	| JsxFragment

// <a />
JsxSelfClosingElement =
	'<'
	name: AnyJsxElementName
	type_arguments: TsTypeArguments?
	attributes: JsxAttributeList
	'/'
	'>'

JsxElement =
	opening_element: JsxOpeningElement
	children: JsxChildList
	closing_element: JsxClosingElement

JsxOpeningElement =
	'<'
	name: AnyJsxElementName
	type_arguments: TsTypeArguments?
	attributes: JsxAttributeList
	'>'

JsxClosingElement =
	'<'
	'/'
	name: AnyJsxElementName
	'>'

// <>content</>
JsxFragment =
	opening_fragment: JsxOpeningFragment
	children: JsxChildList
	closing_fragment: JsxClosingFragment

JsxOpeningFragment =
	'<'
	'>'

JsxClosingFragment =
	'<'
	'/'
	'>'

// ==================================
// Names
// ==================================

JsxName = value: 'jsx_ident'
JsxReferenceIdentifier = value: 'jsx_ident'

// <a:test>
JsxNamespaceName =
	namespace: JsxName
	':'
	name: JsxName

AnyJsxElementName =
	JsxName
	| JsxReferenceIdentifier
	| JsxMemberName
	| JsxNamespaceName

AnyJsxObjectName =
	JsxReferenceIdentifier
	| JsxMemberName
	| JsxNamespaceName

// <a.test>
JsxMemberName =
	object: AnyJsxObjectName
	'.'
	member: JsName

AnyJsxName =
	JsxName
	| JsxNamespaceName

// ==================================
// Attributes
// ==================================

JsxAttributeList = AnyJsxAttribute*

AnyJsxAttribute =
	JsxAttribute
	| JsxSpreadAttribute

JsxAttribute =
	name: AnyJsxAttributeName
	initializer: JsxAttributeInitializerClause?

JsxAttributeInitializerClause =
	'='
	value: AnyJsxAttributeValue

AnyJsxAttributeValue =
	AnyJsxTag
	| JsxString
	| JsxExpressionAttributeValue

JsxExpressionAttributeValue =
	'{'
	expression: AnyJsExpression
	'}'

AnyJsxAttributeName =
	JsxName
	| JsxNamespaceName

// <a {...b} />
//    ^^^^^^
JsxSpreadAttribute =
	'{'
	'...'
	argument: AnyJsExpression // parse_assignment_expression_or_higher
	'}'

// ==================================
// Children
// ==================================

JsxChildList = AnyJsxChild*

AnyJsxChild =
	JsxElement
	| JsxSelfClosingElement
	| JsxText
	| JsxExpressionChild
	| JsxSpreadChild
	| JsxFragment

JsxExpressionChild =
	'{'
	expression: AnyJsExpression?
	'}'

JsxSpreadChild =
	'{'
	'...'
	expression: AnyJsExpression
	'}'

// ==================================
// Auxiliary
// ==================================

JsxText = value: 'jsx_text_literal'

JsxString = value: 'jsx_string_literal'
