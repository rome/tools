// Javascript Un-Grammar.
//
// This grammar specifies the structure of Rust's concrete syntax tree.
// It does not specify parsing rules (ambiguities, precedence, etc are out of scope).
// Tokens are processed -- contextual keywords are recognised, compound operators glued.
//
// Legend:
//
//   //          				-- comment
//   Name =      				-- non-terminal definition
//   'ident'     				-- token (terminal)
//   A B         				-- sequence
//   A | B       				-- alternation
//   A*          				-- zero or more repetition
//   (A (',' A)* ','?)	        -- repetition of node A separated by ',' and allowing a trailing comma
//   (A (',' A)*)	            -- repetition of node A separated by ',' without a trailing comma
//   A?          				-- zero or one repetition
//   (A)         				-- same as A
//   label:A     				-- suggested name for field of AST node

// NOTES
//
// - SyntaxNode, SyntaxToken and SyntaxElement will be stripped from the codegen
// - Unknown nodes are special nodes used to keep track of broken code; they are
//   not part of the grammar but they will appear inside the green tree
//


///////////////
// UNKNOWN NODES
///////////////
// SyntaxElement is a generic data structure that is meant to track nodes and tokens
// in cases where we care about both types
//
// As Unknown* node will need to yield both tokens and nodes without discrimination,
// and their children will need to yield nodes and tokens as well.
// For this reason, SyntaxElement = SyntaxElement
SyntaxElement = SyntaxElement

JsUnknown = SyntaxElement*
JsUnknownStatement = SyntaxElement*
JsUnknownExpression = SyntaxElement*
JsUnknownMember = SyntaxElement*
JsUnknownBinding = SyntaxElement*
JsUnknownAssignment = SyntaxElement*
JsUnknownParameter = SyntaxElement*
JsUnknownImportAssertionEntry = SyntaxElement*
JsUnknownNamedImportSpecifier = SyntaxElement*

Ident = 'ident'

JsAnyRoot =
	JsScript | JsModule | JsExpressionSnipped

JsScript =
	interpreter: 'js_shebang'?
	directives: JsDirectiveList
	statements: JsStatementList
	eof: 'EOF'

JsModule =
	interpreter: 'js_shebang'?
	directives: JsDirectiveList
	items: JsModuleItemList
	eof: 'EOF'

JsExpressionSnipped =
	expression: JsAnyExpression
	eof: 'EOF'


JsDirective =
	value: 'js_string_literal'
	';'?

JsDirectiveList = JsDirective*

///////////////
// STATEMENTS
///////////////

JsAnyStatement =
	JsBlockStatement
	| JsBreakStatement
	| JsClassStatement
	| JsContinueStatement
	| JsDebuggerStatement
	| JsDoWhileStatement
	| JsEmptyStatement
	| JsExpressionStatement
	| JsForInStatement
	| JsForOfStatement
	| JsForStatement
	| JsIfStatement
	| JsLabeledStatement
	| JsReturnStatement
	| JsSwitchStatement
	| JsThrowStatement
	| JsTryFinallyStatement
	| JsTryStatement
	| JsUnknownStatement
	| JsVariableStatement
	| JsWhileStatement
	| JsWithStatement
	| TsEnum
  | JsFunctionStatement
  | TsTypeAliasStatement


JsBlockStatement =
	'{'
	statements: JsStatementList
	'}'

JsStatementList = JsAnyStatement*

JsEmptyStatement =
    ';'

JsExpressionStatement =
    expression: JsAnyExpression ';'?


JsWhileStatement =
    'while' '(' test: JsAnyExpression ')'
    body: JsAnyStatement


JsDoWhileStatement =
    'do'
    body: JsAnyStatement
    'while' '(' test: JsAnyExpression ')'
    ';'?


// if statement
JsIfStatement =
	'if' '(' test: JsAnyExpression ')'
	consequent: JsAnyStatement
	else_clause: JsElseClause?

JsElseClause =
	'else'
	alternate: JsAnyStatement


// for..in statement
JsForStatement =
	'for'
	'('
	initializer: JsAnyForInitializer?
	first_semi: ';'
	test: JsAnyExpression?
	second_semi: ';'
	update: JsAnyExpression?
	')'
	body: JsAnyStatement

JsAnyForInitializer = JsVariableDeclarations | JsAnyExpression

// for..in statement
JsForInStatement =
	'for'
	'('
	initializer: JsAnyForInOrOfInitializer
	'in'
	expression: JsAnyExpression
	')'
	body: JsAnyStatement

// for..of statement
JsForOfStatement =
	'for'
	'await'?
	'('
	initializer: JsAnyForInOrOfInitializer
	'of'
	expression: JsAnyExpression
	')'
	body: JsAnyStatement

JsAnyForInOrOfInitializer =
	JsAnyAssignmentPattern
	| JsForVariableDeclaration

JsForVariableDeclaration =
	kind_token: ('var' | 'let' | 'const')
	declaration: JsVariableDeclaration

JsBreakStatement =
    'break'
    (label: 'ident')?
    ';'?

JsContinueStatement =
    'continue'
    (label: 'ident')?
    ';'?


JsReturnStatement =
    'return'
    argument: JsAnyExpression?
    ';'?


JsWithStatement =
    'with' '(' object: JsAnyExpression ')'
    body: JsAnyStatement


JsLabeledStatement =
    label: 'ident' ':'
    body: JsAnyStatement


JsSwitchStatement =
    'switch' '(' discriminant: JsAnyExpression ')'
    '{'
    cases: JsSwitchCaseList
    '}'

JsSwitchCaseList = JsAnySwitchClause*

JsAnySwitchClause = JsCaseClause | JsDefaultClause
JsCaseClause = 'case' test: JsAnyExpression ':' consequent: JsStatementList
JsDefaultClause = 'default' ':' consequent: JsStatementList


JsThrowStatement =
    'throw'
    argument: JsAnyExpression
    ';'?

// try..catch..finally statement
JsTryStatement =
    'try'
    body: JsBlockStatement
    catch_clause: JsCatchClause

JsTryFinallyStatement =
    'try'
    body: JsBlockStatement
    catch_clause: JsCatchClause?
    finally_clause: JsFinallyClause

JsCatchClause =
    'catch'
    declaration: JsCatchDeclaration?
    body: JsBlockStatement

JsCatchDeclaration =
    '(' binding: JsAnyBindingPattern ')'

JsFinallyClause =
    'finally'
    body: JsBlockStatement


// debugger statement
JsDebuggerStatement =
	'debugger' ';'?


///////////////
// EXPRESSIONS
///////////////

// Expression
JsAnyExpression =
	JsAnyLiteralExpression
	| ImportMeta
	| JsArrayExpression
	| JsArrowFunctionExpression
	| JsAssignmentExpression
	| JsAwaitExpression
	| JsBinaryExpression
	| JsCallExpression
	| JsClassExpression
	| JsComputedMemberExpression
	| JsConditionalExpression
	| JsFunctionExpression
	| JsIdentifierExpression
	| JsImportCallExpression
	| JsInExpression
	| JsInstanceofExpression
	| JsLogicalExpression
	| JsNewExpression
	| JsObjectExpression
	| JsParenthesizedExpression
	| JsPostUpdateExpression
	| JsPreUpdateExpression
	| JsSequenceExpression
	| JsStaticMemberExpression
	| JsSuperExpression
	| JsThisExpression
	| JsUnaryExpression
	| JsUnknownExpression
	| JsYieldExpression
	| NewTarget
	| JsTemplate
	| TsTypeAssertionExpression
	| TsAsExpression
	| TsNonNullAssertionExpression


JsTemplate =
	tag: JsAnyExpression?
	type_arguments: TsTypeArguments?
	l_tick: '`'
	elements: JsTemplateElementList
	r_tick: '`'

JsTemplateElementList = JsAnyTemplateElement*

JsAnyTemplateElement =
	JsTemplateChunkElement
	| JsTemplateElement

JsTemplateChunkElement = 'template_chunk'

JsTemplateElement =
	'dollar_curly'
	expression: JsAnyExpression
	'}'

JsThisExpression = 'this'

JsSuperExpression = 'super'

// new expression
JsNewExpression =
	'new'
	callee: JsAnyExpression
	type_arguments: TsTypeArguments?
	arguments: JsCallArguments?

// call expression
JsCallExpression =
	callee: JsAnyExpression
	optional_chain_token: '?.'?
	type_arguments: TsTypeArguments?
	arguments: JsCallArguments


JsAwaitExpression =
	'await'
	argument: JsAnyExpression


JsYieldExpression =
	'yield'
	argument: JsYieldArgument?

JsYieldArgument =
	'*'?
	expression: JsAnyExpression

JsImportCallExpression =
	'import'
	arguments: JsCallArguments

// new target expression
NewTarget = 'new' '.' 'target'


JsConditionalExpression =
	test: JsAnyExpression
	'?'
	consequent: JsAnyExpression
	':'
	alternate: JsAnyExpression

// import meta expression
ImportMeta = 'import' '.' 'meta'

JsFunctionExpression =
	'async'?
	'function'
	'*'?
	id: JsAnyBinding?
	type_parameters: TsTypeParameters?
	parameters: JsParameters
	return_type_annotation: TsReturnTypeAnnotation?
	body: JsFunctionBody


JsArrowFunctionExpression =
	'async'?
	type_parameters: TsTypeParameters?
	parameters: JsAnyArrowFunctionParameters
	return_type_annotation: TsReturnTypeAnnotation?
	'=>'
	body: JsAnyFunctionBody

JsAnyArrowFunctionParameters = JsParameters | JsAnyBinding
JsAnyFunctionBody = JsAnyExpression | JsFunctionBody

// Array expression
JsArrayExpression =
	'['
	elements: JsArrayElementList
	']'

JsArrayElementList = (JsAnyArrayElement (',' JsAnyArrayElement)* ','?)

JsAnyArrayElement =
	JsAnyExpression
	| JsSpread
	| JsArrayHole

JsArrayHole = hole: ''?

JsAssignmentExpression =
  left: JsAnyAssignmentPattern
  operator_token: (
		'=' |'+=' | '-=' | '*=' | '/=' | '%=' |
		'**=' | '>>=' | '<<=' | '>>>=' | '&=' |
		'|=' | '^=' | '&&=' | '||=' | '??='
  )
  right: JsAnyExpression


JsSequenceExpression =
	left: JsAnyExpression
	comma: ','
	right: JsAnyExpression


JsParenthesizedExpression =
	'(' expression: JsAnyExpression ')'


JsIdentifierExpression = name: JsReferenceIdentifier

// a.b
// a.#b
JsStaticMemberExpression =
	object: JsAnyExpression
	operator: ('.' | '?.')
	member: JsAnyName

// a[b]
JsComputedMemberExpression =
	object: JsAnyExpression
	optional_chain: '?.'?
	'['
	member: JsAnyExpression
	']'

JsBinaryExpression =
    left: JsAnyExpression
    operator: (
    	'<' | '>' | '<=' | '>=' | '==' | '===' | '!=' | '!=='
    	| '+' | '-' | '*' | '/' | '%' | '**' | '<<' | '>>' | '>>>'
    	| '&' | '|' | '^'
		)
    right: JsAnyExpression

JsInstanceofExpression =
	left: JsAnyExpression
	'instanceof'
	right: JsAnyExpression

JsInExpression =
	property: JsAnyInProperty
	'in'
	object: JsAnyExpression

JsAnyInProperty =
	JsPrivateName
	| JsAnyExpression

JsLogicalExpression =
	left: JsAnyExpression
	operator: ('??' | '||' | '&&')
	right: JsAnyExpression

// unary expression
JsUnaryExpression =
  operator: ('delete' | 'void' | 'typeof' | '+' | '-' | '~' | '!')
  argument: JsAnyExpression

JsPreUpdateExpression =
    operator: ('++' | '--')
    operand: JsAnyAssignment

JsPostUpdateExpression =
    operand: JsAnyAssignment
    operator: ('++' | '--')


///////////////
// OBJECTS
///////////////
JsAnyObjectMemberName =
	JsLiteralMemberName
	| JsComputedMemberName

JsObjectExpression =
	'{'
	members: JsObjectMemberList
	'}'

JsObjectMemberList = (JsAnyObjectMember (',' JsAnyObjectMember)* ','?)

JsAnyObjectMember =
	JsPropertyObjectMember
	| JsMethodObjectMember
	| JsGetterObjectMember
	| JsSetterObjectMember
	| JsShorthandPropertyObjectMember
	| JsSpread
	| JsUnknownMember


// { a: 5, b: () => {} }
//   ^^^^  ^^^^^^^^^^^
JsPropertyObjectMember =
	name: JsAnyObjectMemberName
	':'
	value: JsAnyExpression

// { get a() {} }
//   ^^^^^^^^^^
JsGetterObjectMember =
	'get'
	name: JsAnyObjectMemberName
	'('')'
	return_type: TsTypeAnnotation?
	body: JsFunctionBody

//  { set a(value) {} }
//    ^^^^^^^^^^^^^^^
JsSetterObjectMember =
	'set'
	name: JsAnyObjectMemberName
	'('
	parameter: JsAnyParameter
	')'
	body: JsFunctionBody

// { a() {}, async b() {}, async * c() {} }
//   ^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^^^^
JsMethodObjectMember =
	'async'?
	'*'?
	name: JsAnyObjectMemberName
	type_params: TsTypeParameters?
	parameters: JsParameters
	return_type_annotation: TsReturnTypeAnnotation?
	body: JsFunctionBody

// { a }
//   ^
JsShorthandPropertyObjectMember = name: JsReferenceIdentifier

///////////////
// CLASSES
///////////////

JsClassStatement =
	'class'
	id: JsAnyBinding
	type_parameters: TsTypeParameters?
	extends_clause: JsExtendsClause?
	implements_clause: TsImplementsClause?
	'{'
	members: JsClassMemberList
	'}'


JsClassExpression =
	'class'
	id: JsAnyBinding?
	type_parameters: TsTypeParameters?
	extends_clause: JsExtendsClause?
	implements_clause: TsImplementsClause?
	'{'
	members: JsClassMemberList
	'}'

JsClassMemberList = JsAnyClassMember*

JsAnyClass =
	JsClassStatement
	| JsClassExpression
	| JsExportClassClause
	| JsExportDefaultClassClause


TsImplementsClause =
	'implements'
	interfaces: TsTypeList

TsTypeList = (TsExprWithTypeArgs (',' TsExprWithTypeArgs)*)

// class Test extends A {}
//            ^^^^^^^^^
JsExtendsClause =
	'extends'
	super_class: JsAnyExpression

// class Test { #test; }
//              ^^^^^
JsPrivateClassMemberName = '#' id: 'ident'

JsAnyClassMemberName =
	JsLiteralMemberName
	| JsComputedMemberName
	| JsPrivateClassMemberName

JsAnyClassMember =
	JsConstructorClassMember
	| JsStaticInitializationBlockClassMember
	| JsPropertyClassMember
	| JsMethodClassMember
	| JsGetterClassMember
	| JsSetterClassMember
	| JsEmptyClassMember
	| JsUnknownMember

JsStaticInitializationBlockClassMember =
	'static'
	'{'
	statements: JsStatementList
	'}'

// class Test { constructor() {} }
//              ^^^^^^^^^^^^^^^^
// class Test { "constructor"() {} }
//              ^^^^^^^^^^^^^^^^^^
// class Test { 'constructor'() {} }
//              ^^^^^^^^^^^^^^^^^^
JsConstructorClassMember =
	access_modifier: ('private' | 'protected' | 'public')?
	name: JsLiteralMemberName
	type_parameters: TsTypeParameters?
	parameters: JsConstructorParameters
	body: JsFunctionBody

JsConstructorParameters =
	'('
	parameters: JsConstructorParameterList
	')'

JsConstructorParameterList = (JsAnyConstructorParameter (',' JsAnyConstructorParameter)* ','?)

JsAnyConstructorParameter =
	JsParameter
	| JsUnknownParameter
	| JsRestParameter
	| TsPropertyParameter
	| TsReadonlyPropertyParameter

// constructor(private a: string)
//             ^^^^^^^^^^^^^^^^^
TsPropertyParameter =
	accessibility: ('private' | 'protected' | 'public')
	parameter: JsParameter

// constructor(private readonly a: string, readonly b: number)
//             ^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^
TsReadonlyPropertyParameter =
	accessibility: ('private' | 'protected' | 'public')?
	'readonly'
	parameter: JsParameter

TsAnyPropertyParameter =
	TsPropertyParameter
	| TsReadonlyPropertyParameter


// class Test { a; b = 1; static c; }
//              ^^ ^^^^^^ ^^^^^^^^^
JsPropertyClassMember =
	'declare'?
	access_modifier: ('private' | 'protected' | 'public')?
	'static'?
	'readonly'?
	'abstract'?
	name: JsAnyClassMemberName
	'?'?
	'!'?
	type: TsTypeAnnotation?
	value: JsInitializerClause?
	';'?

// class Test { a() {} }
//              ^^^^^^
JsMethodClassMember =
	access_modifier: ('private' | 'protected' | 'public')?
	'static'?
	'abstract'?
	'async'?
	'*'?
	name: JsAnyClassMemberName
	type_parameters: TsTypeParameters?
	parameters: JsParameters
	return_type_annotation: TsReturnTypeAnnotation?
	body: JsFunctionBody

// class Test { get a() {} }
//              ^^^^^^^^^^
JsGetterClassMember =
	access_modifier: ('private' | 'protected' | 'public')?
	'static'?
	'abstract'?
	'get'
	name: JsAnyClassMemberName
	'(' ')'
	return_type: TsTypeAnnotation?
	body: JsFunctionBody

// class Test { set a(v) {} }
//              ^^^^^^^^^^^
JsSetterClassMember =
	access_modifier: ('private' | 'protected' | 'public')?
	'static'?
	'abstract'?
	'set'
	name: JsAnyClassMemberName
	'('
	parameter: JsAnyParameter
	')'
	body: JsFunctionBody

JsEmptyClassMember = ';'

///////////////
// ASSIGNMENT TARGETS
///////////////

JsAnyAssignment =
	JsIdentifierAssignment
	| JsStaticMemberAssignment
	| JsComputedMemberAssignment
	| JsParenthesizedAssignment
	| JsUnknownAssignment


JsAssignmentWithDefault =
	pattern: JsAnyAssignmentPattern
	'='
	default: JsAnyExpression

// (a) = "test"
// ^^^
JsParenthesizedAssignment =
	'('
	assignment: JsAnyAssignment
	')'

// Assignment to an identifier from the lexical scope
// b = "test"
// ^
JsIdentifierAssignment = name: 'ident'

// a.b = a.#b = "test"
// ^^^   ^^^^
JsStaticMemberAssignment =
	object: JsAnyExpression
	'.'
	member: JsAnyName

// a['b'] = a[expr] = "test"
// ^^^^^^   ^^^^^^^
JsComputedMemberAssignment =
	object: JsAnyExpression
	'['
	member: JsAnyExpression
	']'

JsAnyAssignmentPattern =
	JsAnyAssignment
	| JsArrayAssignmentPattern
	| JsObjectAssignmentPattern


// [a, b = "b", ...rest] = bar
// ^^^^^^^^^^^^^^^^^^^^^^
JsArrayAssignmentPattern =
	'['
	elements: JsArrayAssignmentPatternElementList
	']'

JsArrayAssignmentPatternElementList = (JsAnyArrayAssignmentPatternElement (',' JsAnyArrayAssignmentPatternElement)* ','?)

JsAnyArrayAssignmentPatternElement =
	JsAssignmentWithDefault
	| JsAnyAssignmentPattern
	| JsArrayAssignmentPatternRestElement
	| JsArrayHole
	| JsUnknownAssignment

// [a, b, ...rest] = [];
//        ^^^^^^^
JsArrayAssignmentPatternRestElement =
	'...'
	pattern: JsAnyAssignmentPattern

// ({a, b: x, ...rest} = c)
//  ^^^^^^^^^^^^^^^^^^
JsObjectAssignmentPattern =
	'{'
	properties: JsObjectAssignmentPatternPropertyList
	'}'

JsObjectAssignmentPatternPropertyList = (JsAnyObjectAssignmentPatternMember (',' JsAnyObjectAssignmentPatternMember)* ','?)

JsAnyObjectAssignmentPatternMember =
	JsObjectAssignmentPatternShorthandProperty
	| JsObjectAssignmentPatternProperty
	| JsObjectAssignmentPatternRest
	| JsUnknownAssignment

// ({ x } = b) or ({ x = "test" } = b)
//    ^              ^^^^^^^^^^
JsObjectAssignmentPatternShorthandProperty =
	identifier: JsAnyAssignment
	init: JsInitializerClause?

// ({ x: a } = b) or ({ x: a = "test" } = b)
//    ^^^^              ^^^^^^^^^^^^^
JsObjectAssignmentPatternProperty =
	member: JsAnyObjectMemberName
	':'
	pattern: JsAnyAssignmentPattern
	init: JsInitializerClause?

// ({ a, ...b } = a)
//       ^^^^
JsObjectAssignmentPatternRest =
	'...'
	target: JsAnyAssignment

///////////////
// BINDINGS
///////////////

JsAnyBinding =
	JsIdentifierBinding
	| JsUnknownBinding

// Binds a value to an identifier.
// let x = OR function(test) {}
//     ^               ^^^^
JsIdentifierBinding =
	name: 'ident'

// [ a = "b"] = [];
//   ^^^^^^^
JsBindingPatternWithDefault =
	pattern: JsAnyBindingPattern
	'='
	default: JsAnyExpression

JsAnyBindingPattern =
	JsAnyBinding
	| JsArrayBindingPattern
	| JsObjectBindingPattern

// let [a, b] = [1, 2];
//     ^^^^^^
JsArrayBindingPattern =
	'['
	elements: JsArrayBindingPatternElementList
	']'

JsArrayBindingPatternElementList = (JsAnyArrayBindingPatternElement (',' JsAnyArrayBindingPatternElement)* ','?)

JsAnyArrayBindingPatternElement =
	JsArrayHole
	| JsAnyBindingPattern
	| JsBindingPatternWithDefault
	| JsArrayBindingPatternRestElement

JsArrayBindingPatternRestElement =
	'...'
	pattern: JsAnyBindingPattern

// let { a, b} = c;
//     ^^^^^^^
JsObjectBindingPattern =
	'{'
	properties: JsObjectBindingPatternPropertyList
	'}'

JsObjectBindingPatternPropertyList = (JsAnyObjectBindingPatternMember (',' JsAnyObjectBindingPatternMember)* ','?)

JsAnyObjectBindingPatternMember =
	JsObjectBindingPatternProperty
	| JsObjectBindingPatternRest
	| JsObjectBindingPatternShorthandProperty
	| JsIdentifierBinding
	| JsUnknownBinding

// let { a: b.m } = {}
//       ^^^^^^
// let { a: b.m = "test" } = {}
//       ^^^^^^^^^^^^^^^
JsObjectBindingPatternProperty =
	member: JsAnyObjectMemberName
	':'
	pattern: JsAnyBindingPattern
	init: JsInitializerClause?

// let { a } = c
//       ^
// let { a = "test" } = c
//       ^^^^^^^^^^
JsObjectBindingPatternShorthandProperty =
	identifier: JsAnyBinding
	init: JsInitializerClause?

// let { ...a } = c
//       ^^^^
JsObjectBindingPatternRest =
	'...'
	binding: JsAnyBinding


///////////////
// LITERALS
///////////////

JsAnyLiteralExpression =
	JsStringLiteralExpression
	| JsNumberLiteralExpression
	| JsBigIntLiteralExpression
	| JsBooleanLiteralExpression
	| JsNullLiteralExpression
	| JsRegexLiteralExpression

// "abcd" | 'abcd'
JsStringLiteralExpression = value: 'js_string_literal'

// 4, 5.5, 0x00, ...
JsNumberLiteralExpression = value: 'js_number_literal'

// 45n
JsBigIntLiteralExpression =  value: 'js_big_int_literal'

// true, false
JsBooleanLiteralExpression = value_token: ('true' | 'false')

// null
JsNullLiteralExpression = value: 'null'

JsRegexLiteralExpression = value: 'js_regex_literal'


///////////////
// DECLARATIONS
///////////////

JsFunctionStatement =
	'async'?
	'function'
	'*'?
	id: JsAnyBinding
	type_parameters: TsTypeParameters?
	parameters: JsParameters
	return_type_annotation: TsReturnTypeAnnotation?
	body: JsFunctionBody

TsTypeAnnotation =
	':'
	type: TsType

TsReturnTypeAnnotation =
	':'
	type: TsAnyReturnType

// let a, b = c;
JsVariableStatement =
    declarations: JsVariableDeclarations ';'?

// Declaration of multiple variables
// let a, b = c;
// ^^^^^^^^
JsVariableDeclarations =
    kind: ('var' | 'const' | 'let')
    items: JsVariableDeclarationList

JsVariableDeclarationList = (JsVariableDeclaration (',' JsVariableDeclaration)*)

// let b = c;
//     ^^^^^
JsVariableDeclaration =
    id: JsAnyBindingPattern
    '!'?
    type_annotation: TsTypeAnnotation?
    initializer: JsInitializerClause?


///////////////
// MODULE SYNTAX
///////////////

JsAnyModuleItem =
	JsAnyStatement
	| JsExport
	| JsImport
JsModuleItemList = JsAnyModuleItem*

JsImport = 'import'
	import_clause: AnyJsImportClause
	';'?

AnyJsImportClause =
    JsImportBareClause
    | JsImportNamedClause
    | JsImportDefaultClause
    | JsImportNamespaceClause
//    | TsImportRequireClause
//    | TsImportAliasClause

// import "abcd"
// import "abcd" assert ...
JsImportBareClause =
	source: JsModuleSource
	assertion: JsImportAssertion?

// import foo from "mod"
// import type foo from "mod"
JsImportDefaultClause =
		// 'type'?
		local_name: JsAnyBinding
		'from'
		source: JsModuleSource
		assertion: JsImportAssertion?

// import * as foo from "mod";
// import type * as foo from "mod";
JsImportNamespaceClause =
  // 'type'
	'*'
	'as'
	local_name: JsAnyBinding
	'from'
	source: JsModuleSource
	assertion: JsImportAssertion?

// import { a, b: c } from "d"
//        ^^^^^^^^^^^^^^^^^^^^
// import c, { b } from "c"
//        ^^^^^^^^^^^^^^^^^
// import { type a } from "c"
//        ^^^^^^^^^^^^^^^^^^^
// import foo, * as bar from "mod"
//        ^^^^^^^^^^^^^^^^^^^^^^^^
// import type { foo } from "mod";
//        ^^^^^^^^^^^^^^^^^^^^^^^
// import foo, { type bar } from "mod";
JsImportNamedClause =
    // 'type'?
    default_specifier: JsDefaultImportSpecifier?
    named_import: JsAnyNamedImport
    'from'
    source: JsModuleSource
    assertion: JsImportAssertion?

// import a, { b, c } from "d";
//        ^^
JsDefaultImportSpecifier =
    local_name: JsAnyBinding
    trailing_comma: ','

JsAnyNamedImport =
	JsNamedImportSpecifiers
	|  JsNamespaceImportSpecifier

// import a, * as b from "d";
//           ^^^^^^
JsNamespaceImportSpecifier =
    '*'
    'as'
    local_name: JsAnyBinding

// import a, { b, c } from "d";
//           ^^^^^^^^
JsNamedImportSpecifiers =
    '{'
    specifiers: JsNamedImportSpecifierList
    '}'

JsNamedImportSpecifierList = (JsAnyNamedImportSpecifier (',' JsAnyNamedImportSpecifier)* ','?)

JsAnyNamedImportSpecifier =
    JsShorthandNamedImportSpecifier
    | JsNamedImportSpecifier
    | JsUnknownNamedImportSpecifier

// import { foo as test } from "mod";
//          ^^^^^^^^^^^
// import { type foo as test } from "mod";
//          ^^^^^^^^^^^^^^^^^
JsNamedImportSpecifier =
    // 'type'?
    name: JsLiteralExportName
    'as'
    local_name: JsAnyBinding

// import { type foo } from "mod";
//          ^^^^^^^^
JsShorthandNamedImportSpecifier =
    // 'type'?
    local_name: JsAnyBinding

// import a from "mod" assert { type: "json" }
//                     ^^^^^^^^^^^^^^^^^^^^^^^
JsImportAssertion =
    'assert'
    '{'
    assertions: JsImportAssertionEntryList
    '}'

JsImportAssertionEntryList = (JsAnyImportAssertionEntry (',' JsAnyImportAssertionEntry)* ','?)

JsAnyImportAssertionEntry =
	JsImportAssertionEntry
	| JsUnknownImportAssertionEntry

// import a from "mod" assert { type: "json" }
//                              ^^^^^^^^^^^^
JsImportAssertionEntry =
    key: ('ident' | 'js_string_literal')
    ':'
    value: 'js_string_literal'

// import { a as b } from "c"
//          ^
// export { a as "a-b-c" };
//               ^^^^^^^
JsLiteralExportName = value: ('ident' | 'js_string_literal')


// import "test"
//        ^^^^^^
// export a from "b"
//               ^^^
JsModuleSource = value: 'js_string_literal'


JsExport =
	'export'
	export_clause: JsAnyExportClause


// export function a() {}
// export default function () {}
// export class A {}
// export default class A {}
// export let a, b, c, d;
// export default a, b, c;
// export { a, b as c };
// export * from "b";
// export { a, b as c } from "b";
//
// Typescript:
// export type A = string;
// export enum B { A, B }
// export interface C {}
// export namespace D {}
// export as namespace c;
// export = b;
// export import a = b;
JsAnyExportClause =
	JsExportFunctionClause
	| JsExportDefaultFunctionClause
	| JsExportClassClause
	| JsExportDefaultClassClause
	| JsExportVariableClause
	| JsExportDefaultExpressionClause
	| JsExportNamedClause
	| JsExportFromClause
	| JsExportNamedFromClause

// export let a, b, c;
//        ^^^^^^^^^^^
JsExportVariableClause =
	declarations: JsVariableDeclarations
	';'?

// export function a() {}
//        ^^^^^^^^^^^^^^^
JsExportFunctionClause =
	'async'?
	'function'
	'*'?
	id: JsAnyBinding
	type_parameters: TsTypeParameters?
	parameters: JsParameters
	return_type_annotation: TsReturnTypeAnnotation?
	body: JsFunctionBody

// export class A {}
//        ^^^^^^^^^^
JsExportClassClause =
	'class'
	id: JsAnyBinding
	type_parameters: TsTypeParameters?
	extends_clause: JsExtendsClause?
	implements_clause: TsImplementsClause?
	'{'
	members: JsClassMemberList
	'}'

// export default a;
//        ^^^^^^^^^^
JsExportDefaultExpressionClause =
	'default'
	expression: JsAnyExpression
	';'?

// export default class {}
//        ^^^^^^^^^^^^^^^^
JsExportDefaultClassClause =
	'default'
	'class'
	id: JsAnyBinding?
	type_parameters: TsTypeParameters?
	extends_clause: JsExtendsClause?
	implements_clause: TsImplementsClause?
	'{'
	members: JsClassMemberList
	'}'

// export default function () {}
//        ^^^^^^^^^^^^^^^^^^^^^^
JsExportDefaultFunctionClause =
	'default'
	'async'?
	'function'
	'*'?
	id: JsAnyBinding?
	type_parameters: TsTypeParameters?
	parameters: JsParameters
	return_type_annotation: TsReturnTypeAnnotation?
	body: JsFunctionBody

// export { myFunction as default };
// export { myFunction, myVariable };
JsExportNamedClause =
    '{'
    specifiers: JsExportNamedSpecifierList
    '}'
    ';'?

JsExportNamedSpecifierList = (JsAnyExportNamedSpecifier (',' JsAnyExportNamedSpecifier)* ','?)

JsAnyExportNamedSpecifier =
    JsExportNamedShorthandSpecifier
    | JsExportNamedSpecifier

// export { a };
//          ^
JsExportNamedShorthandSpecifier =
    'type'?
    name: JsReferenceIdentifier

// export { a as b };
//          ^^^^^^
// export { a as default };
//          ^^^^^^^^^^^^
JsExportNamedSpecifier =
    'type'?
    local_name: JsReferenceIdentifier
    'as'
    exported_name: JsLiteralExportName

JsExportFromClause =
	'*'
	export_as: JsExportAsClause?
	'from'
	source: JsModuleSource
	assertion: JsImportAssertion?
	';'?

// export { a } from "b";
// export { default, … } from …;
// export { type default as C } from "a";
// export { type default } from "a";
JsExportNamedFromClause =
    '{'
    specifiers: JsExportNamedFromSpecifierList
    '}'
    'from'
    source: JsModuleSource
    assertion: JsImportAssertion?
    ';'?

JsExportNamedFromSpecifierList = (JsExportNamedFromSpecifier (',' JsExportNamedFromSpecifier)* ','?)

// export { a } from "b";
//          ^
// export { a as b } from "c";
//          ^^^^^^
JsExportNamedFromSpecifier =
    'type'?
    source_name: JsLiteralExportName
    export_as: JsExportAsClause?


// export { a as b } from "c";
//            ^^^^
JsExportAsClause =
    'as'
    exported_name: JsLiteralExportName

///////////////
// AUXILIARY
///////////////

// { ...a }
//   ^^^^
// [ ...a ]
//   ^^^^
JsSpread =
	'...'
	argument: JsAnyExpression


// Reference to an identifier from the lexical scope
JsReferenceIdentifier = value: 'ident'

// A js identifier that is neither a binding, assignment, nor a reference.
// For example a member name
JsName = value: 'ident'

JsPrivateName =
	'#'
	value: 'ident'

JsAnyName =
	JsName
	| JsPrivateName


JsAnyFunction =
	JsFunctionExpression
	| JsFunctionStatement
	| JsArrowFunctionExpression
	| JsExportFunctionClause
	| JsExportDefaultFunctionClause


// { a: ..., "b": ..., 4: ... }
//   ^       ^^^       ^
JsLiteralMemberName = value: ('ident' | 'js_string_literal' | 'js_number_literal')

// { [call()]: ... }
//   ^^^^^^^^
JsComputedMemberName =
	'['
	expression: JsAnyExpression
	']'


JsParameters =
	'('
	items: JsParameterList
	')'

JsParameterList = (JsAnyParameter (',' JsAnyParameter)* ','?)

JsAnyParameter =
	JsParameter
	| JsUnknownParameter
	| JsRestParameter
	| TsThisParameter

// (a?: string) => {}
//  ^^^^^^^^^^
JsParameter =
	binding: JsAnyBindingPattern
	'?'?
	type_annotation: TsTypeAnnotation?
	initializer: JsInitializerClause?

// (...a) => {}
//  ^^^^
JsRestParameter =
	'...'
	binding: JsAnyBindingPattern
	type_annotation: TsTypeAnnotation?

// (this) => {}
//  ^^^^
TsThisParameter =
	'this'
	type_annotation: TsTypeAnnotation?

JsCallArguments = '(' args: JsCallArgumentList ')'

JsCallArgumentList = (JsAnyExpression (',' JsAnyExpression)* ','?)


// let a = 10;
//       ^^^^
// class { a = 10; }
//           ^^^^
JsInitializerClause =
	'='
	expression: JsAnyExpression

JsFunctionBody =
	'{'
	directives: JsDirectiveList
	statements: JsStatementList
	'}'

///////////////
// TYPESCRIPT
///////////////
//
// Below here we want to keep all the TypeScript types
// Typescript definitions
//

TsImportEqualsDecl =
	('import' | 'export') ident: Ident '=' module:TsModuleRef ';'?


TsModuleRef =
	TsExternalModuleRef |
	TsAnyName


TsExternalModuleRef = 'require' '(' module: 'js_string_literal' ')'

TsType =
	// Predefined types
	TsAnyType
	| TsUnknownType
	| TsNumberType
	| TsBooleanType
	| TsBigintType
	| TsStringType
	| TsSymbolType
	| TsVoidType
	| TsUndefinedType
	| TsNeverType
	// Primary types, without predefined types
	| TsParenthesizedType
	| TsReferenceType
	| TsArrayType
	| TsTupleType
	| TsTypeofType
	| TsImportType
	| TsTypeOperatorType
	| TsIndexedAccessType
	| TsMappedType
	| TsObjectType
	| TsNonPrimitiveType
	| TsThisType
	| TsNumberLiteralType
	| TsBigIntLiteralType
	| TsStringLiteralType
	| TsNullLiteralType
	| TsBooleanLiteralType
	| TsTemplateLiteralType
	| TsInferType
	// Intersection or higher types
	| TsIntersectionType
	| TsUnionType
	| TsFunctionType
	| TsConstructorType
	| TsConditionalType

// Predefined types
TsAnyType = 'any'
TsUnknownType = 'unknown'
TsNumberType = 'number'
TsNonPrimitiveType = 'object'
TsBooleanType = 'boolean'
TsBigintType = 'bigint'
TsStringType = 'string'
TsSymbolType = 'symbol'
TsVoidType = 'void'
TsUndefinedType = 'undefined'
TsNeverType = 'never'
TsThisType = 'this'

TsParenthesizedType =
	'('
	ty: TsType
	')'

TsReferenceType =
	name: TsAnyName
	type_arguments: TsTypeArguments?

TsTypeAliasStatement =
	'type'
	binding_identifier: TsIdentifierBinding
	type_parameters: TsTypeParameters
	'='
	ty: TsType
	';'?

// Binds a type identifier
TsIdentifierBinding = name: 'ident'

// typescript enum
TsEnum = 'const'? 'enum'  ident: Ident '{' members: TsEnumMemberList '}'

TsEnumMemberList = TsEnumMember*
TsEnumMember = ident: Ident '=' value:JsAnyExpression

// | a | b
TsUnionType =
	leading_separator_token: '|'?
	types: TsUnionTypeVariantList

TsUnionTypeVariantList = (TsType ('|' TsType)*)

// & a & b
TsIntersectionType =
	leading_separator_token: '&'?
	types: TsIntersectionTypeElementList

TsIntersectionTypeElementList = (TsType ('&' TsType)*)

// keyof A;
// ^^^^^^^
// const a: unique symbol = symbol();
//          ^^^^^^^^^^^^^
// readonly string[];
// ^^^^^^^^^^^^^^^^^
TsTypeOperatorType =
	operator_token: ('keyof' | 'unique' | 'readonly')
	type: TsType

// infer A;
// ^^^^^^^
// { a: infer U; b: infer U }
//      ^^^^^^^     ^^^^^^^
TsInferType =
	'infer'
	type_parameter: TsTypeParameterName

TsFunctionType =
	type_parameters: TsTypeParameters?
	parameters: JsParameters
	'=>'
	return_type: TsAnyReturnType

TsAnyReturnType =
	TsType
	| TsTypePredicate

TsTypePredicate =
	'asserts'?
	parameter_name: TsAnyTypePredicateParameterName
	'is'
	type: TsType

TsAnyTypePredicateParameterName =
	JsReferenceIdentifier
	| TsThisType

TsTypeofType =
	'typeof'
	expression_name: TsAnyName

TsConstructorType =
	'abstract'?
	'new'
	type_parameters: TsTypeParameters?
	parameters: JsParameters
	'=>'
	return_type: TsType

TsConditionalType =
	check_type: TsType
	'extends'
	extends_type: TsType
	'?'
	true_type: TsType
	':'
	false_type: TsType


// type A<X, Y> = { x: X, y: Y }
//       ^^^^^^
TsTypeParameters =
	'<'
	items: TsTypeParameterList
	'>'

TsTypeParameterList = (TsTypeParameter (',' TsTypeParameter)* ','?)


// type A<B extends string = "1"> = { b: B }
//        ^^^^^^^^^^^^^^^^^^^^^^
TsTypeParameter =
	name: TsTypeParameterName
	constraint: TsTypeConstraintClause?
	default: TsDefaultTypeClause?

TsTypeParameterName = 'ident'

TsTypeConstraintClause =
	'extends'
	type: TsType

TsDefaultTypeClause =
	'='
	type: TsType

// { a: string }
TsObjectType = '{' members: TsObjectTypeMemberList '}'

TsObjectTypeMemberList = TsAnyObjectTypeMember*

TsAnyObjectTypeMember =
	TsCallSignatureObjectTypeMember
	| TsPropertySignatureObjectTypeMember
	| TsConstructSignatureObjectTypeMember
	| TsMethodSignatureObjectTypeMember
	| TsGetterSignatureObjectTypeMember
	| TsSetterSignatureObjectTypeMember
	| TsIndexSignatureObjectTypeMember

// { <A>(a: A): number }
//   ^^^^^^^^^^^^^^^^^
TsCallSignatureObjectTypeMember =
	type_parameters: TsTypeParameters?
	parameter_list: JsParameters
	return_type_annotation: TsReturnTypeAnnotation?
	separator_token: (',' | ';')?

// { a: string }
//   ^^^^^^^^^
TsPropertySignatureObjectTypeMember =
	'readonly'?
	name: JsAnyObjectMemberName
	optional_token: '?'?
	type_annotation: TsTypeAnnotation?
	separator_token: (',' | ';')?

// { new(): number }
//   ^^^^^^^^^^^^^
TsConstructSignatureObjectTypeMember =
	'new'
	type_parameters: TsTypeParameters?
	parameter_list: JsParameters
	type_annotation: TsTypeAnnotation?
	separator_token: (',' | ';')?

// { a?(): number }
//   ^^^^^^^^^^^^
TsMethodSignatureObjectTypeMember =
	name: JsAnyObjectMemberName
	optional_token: '?'?
	type_parameters: TsTypeParameters?
	parameter_list: JsParameters
	return_type_annotation: TsReturnTypeAnnotation?
	separator_token: (',' | ';')?

// { get a(): number }
//   ^^^^^^^^^^^^^^^
TsGetterSignatureObjectTypeMember =
	'get'
	name: JsAnyObjectMemberName
	'('
	')'
	type_annotation: TsTypeAnnotation?
	separator_token: (',' | ';')?

// { set a(value: number) }
//   ^^^^^^^^^^^^^^^^^^^^
TsSetterSignatureObjectTypeMember =
	'set'
	name: JsAnyObjectMemberName
	'('
	parameter: JsAnyParameter
	')'
	separator_token: (',' | ';')?

//  { [a: string]: number }
TsIndexSignatureObjectTypeMember =
	'readonly'?
	'['
	parameter: TsIndexSignatureParameter
	']'
	type_annotation: TsTypeAnnotation
	separator_token: (',' | ';')?

// { [a: string]: number }
//    ^^^^^^^^^
TsIndexSignatureParameter =
	binding: JsIdentifierBinding
	type_annotation: TsTypeAnnotation

// type OptionsFlags<Type> = {
//   [Property in keyof Type]: boolean;
// };
TsMappedType =
	'{'
	readonly_modifier: TsMappedTypeReadonlyModifierClause?
	'['
	property_name: TsTypeParameterName
	'in'
	keys_type: TsType
	as_clause: TsMappedTypeAsClause?
	']'
	optional_modifier: TsMappedTypeOptionalModifierClause?
	mapped_type: TsTypeAnnotation?
	';'?
	'}'

TsMappedTypeAsClause =
	'as'
	type: TsType

TsMappedTypeOptionalModifierClause =
	operator_token: ('+' | '-')
	'?'

TsMappedTypeReadonlyModifierClause =
	operator_token: ('+' | '-')
	'readonly'

TsImportType =
	'typeof'?
	'import'
	'('
	argument: 'js_string_literal'
	')'
	qualifier_clause: TsImportTypeQualifier?

TsImportTypeQualifier =
	'.'
	right: TsAnyName


TsArrayType =
	element_type: TsType
	'['
	']'

TsIndexedAccessType =
	object_type: TsType
	'['
	index_type: TsType
	']'

TsTupleType =
	'['
	elements: TsTupleTypeElementList
	']'

TsTupleTypeElementList = (TsAnyTupleTypeElement (',' TsAnyTupleTypeElement)* ','?)

TsAnyTupleTypeElement =
	TsNamedTupleTypeElement
	| TsType
	| TsRestTupleTypeElement
	| TsOptionalTupleTypeElement

TsNamedTupleTypeElement =
	'...'?
	name: JsName
	'?'?
	':'
	type: TsType

TsRestTupleTypeElement =
	'...'
	type: TsType

TsOptionalTupleTypeElement =
	type: TsType
	'?'

TsStringLiteralType = literal: 'js_string_literal'
TsNumberLiteralType = '-'? literal: 'js_number_literal'
TsBigIntLiteralType = '-'? literal: 'js_big_int_literal'
TsBooleanLiteralType = literal: ('true' | 'false')
TsNullLiteralType = literal: 'null'
TsTemplateLiteralType =
	l_tick: '`'
	elements: TsTemplateElementList
	r_tick: '`'

TsTemplateElementList = TsAnyTemplateElement*

TsAnyTemplateElement =
	TsTemplateChunkElement
	| TsTemplateElement

TsTemplateChunkElement = 'template_chunk'
TsTemplateElement =
	'dollar_curly'
	type: TsType
	'}'

TsTypeAssertionExpression =
	'<'
	type: TsType
	'>'
	expression: JsAnyExpression

TsAsExpression =
	expression: JsAnyExpression
	'as'
	type: TsType

TsNonNullAssertionExpression =
	expression: JsAnyExpression
	'!'

TsExprWithTypeArgs =
	item: TsAnyName
	type_arguments: TsTypeArguments?

TsAnyName =
	JsReferenceIdentifier
	| TsQualifiedName

TsQualifiedName =
	left: TsAnyName
	'.'
	right: JsName

TsTypeArguments =
	'<'
	TsTypeArgumentList
	'>'

TsTypeArgumentList = (TsType (',' TsType)* )

