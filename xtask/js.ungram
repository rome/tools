// Rust Un-Grammar.
//
// This grammar specifies the structure of Rust's concrete syntax tree.
// It does not specify parsing rules (ambiguities, precedence, etc are out of scope).
// Tokens are processed -- contextual keywords are recognised, compound operators glued.
//
// Legend:
//
//   //          -- comment
//   Name =      -- non-terminal definition
//   'ident'     -- token (terminal)
//   A B         -- sequence
//   A | B       -- alternation
//   A*          -- zero or more repetition
//   A?          -- zero or one repetition
//   (A)         -- same as A
//   label:A     -- suggested name for field of AST node

Ident = 'ident'
Script = 'shebang'? Stmt*

///////////////
// STATEMENTS
///////////////

Stmt =
	BlockStmt
	| EmptyStmt
	| ExprStmt
	| IfStmt
	| DoWhileStmt
	| WhileStmt
	| ForStmt
	| ForInStmt
	| ForOfStmt
	| ContinueStmt
	| BreakStmt
	| ReturnStmt
	| WithStmt
	| LabelledStmt
	| SwitchStmt
	| ThrowStmt
	| TryStmt
	| DebuggerStmt
	| Decl


// Block statement
BlockStmt = '{' Stmt* '}'


// Empty statemnet
EmptyStmt = ';'?


// Expression statement
ExprStmt = Expr


// while statement
WhileStmt = 'while' condition:Condition cons:Stmt

// do while statement
DoWhileStmt = 'do'  cons:Stmt 'while' condition:Condition ';'


// if statement
IfStmt = 'if' condition:Condition cons:Stmt 'else' alt:Stmt


// for statement
ForStmt =
	'for'
	'('
	init:ForStmtInit?
	';'
	test:ForStmtTest?
	';'
	update:ForStmtUpdate?
	')'
	cons:Stmt

ForStmtInit = inner:ForHead
ForHead = Decl | Expr

ForStmtTest = expr:Expr

ForStmtUpdate = expr:Expr


// for..in statement
ForInStmt = 'for' '(' left:ForStmtInit 'in' right:Expr ')' cons:Stmt

// for..of statement
ForOfStmt = 'for' '(' left:ForStmtInit 'of' right:Expr ')' cons:Stmt


// continue statement
ContinueStmt = 'continue' Ident ';'?


// break statement
BreakStmt = 'break' ';'?


// return statement
ReturnStmt = 'return' value:Expr ';'?

// with statement
WithStmt = 'with' condition:Condition cons:Stmt

// labelled statement
LabelledStmt = label:Name ':' Stmt

// switch statement
SwitchStmt =
	'switch'
	test:Condition
	'{'
	cases:SwitchCase*
	'}'

SwitchCase = CaseClause | DefaultCase

CaseClause = 'case' test:Expr ':' cons:Stmt*
DefaultCase = 'default' ':' cons:Stmt*


// throw statement
ThrowStmt = 'throw' exception:Expr ';'

// try..catch..finally statement

TryStmt = 'try' test:BlockStmt handler:CatchClause finalizer:Finalizer

// TODO: fix it, the pattern is not mandatory anymore
CatchClause = 'catch' '(' error:Pattern ')' cons:BlockStmt
Finalizer = 'finally' cons:BlockStmt


// debugger statement
DebuggerStmt = 'debugger' ';'?


///////////////
// EXPRESSIONS
///////////////

// Expression
Expr =
	ArrowExpr
	| Literal
	// | Template
	| NameRef
	| ThisExpr
	| ArrayExpr
	| ObjectExpr
	| GroupingExpr
	| BracketExpr
	| DotExpr
	| NewExpr
	| CallExpr
	| UnaryExpr
	| BinExpr
	| CondExpr
	| AssignExpr
	| SequenceExpr
	| FnExpr
	| ClassExpr
	| NewTarget
	| ImportMeta
	| SuperCall
	| ImportCall
	| YieldExpr
	| AwaitExpr
	| PrivatePropAccess
	// | TsNonNull
	// | TsAssertion
	// | TsConstAssertion



// This Expression
ThisExpr = 'this'

// Dot exprssion
DotExpr = '.'

// new expression
// TODO: add typescript types
NewExpr = 'new' object:Expr arguments:ArgList

// call expression
// TODO: add typescript types
CallExpr = callee:Expr arguments:ArgList

// await expression
AwaitExpr = 'await' Expr

// yield expressoin
YieldExpr = 'yield' '*' value:Expr

// super call expression
SuperCall = 'super' arguments:ArgList

// import call exression
ImportCall = 'import' '(' argument:Expr ')'

// new target expression
NewTarget = 'new' '.' 'target'

// conditional expression
CondExpr = '?' ':'?

// import meta expression
ImportMeta = 'import' '.'

// function expression
// TODO: add typescript types
FnExpr =
	'async'? 'function' '*'? name:Name parameters:ArgList body:BlockStmt

// Arrow expression
ArrowExpr =
	'async'? type_params:TsTypeParams? params:ArrowExprParams? '=>' (':' return_type:TsType)? body:ExprOrBlock
ArrowExprParams =
	Name
	| ParameterList

// Object expression
ObjectExpr = '{' props:ObjectProp* '}'

// class expression
// TODO: add typescript types
ClassExpr = 'class' Name 'extends' parent:Name body:ClassBody

ClassBody =  '{' elements:ClassElement* '}'


ClassElement =
	EmptyStmt
	| Method
	// probably PrivateProp is not needed
	| PrivateProp
	| ClassProp
	| Constructor
	// | TsIndexSignature
	| Getter
	| Setter

// TODO: add typescript types
Constructor = name:PropName parameters:ParameterList body:BlockStmt

// This type is here only to matain compatiblity with rslit_parser
// A private property should only have the hash (#) or have the
// keyword `private` in the typescript version
PrivateProp = ClassProp
// TODO: add typescript types
// Note: they way it's written now is awful and can be improved a lot
ClassProp = 'static'? '#'? key:PropName '='? value:Expr? ';'?

// Array expression
ArrayExpr = '[' elements:ExprOrSpread* ']'

ExprOrSpread =
	Expr
	| SpreadElement


// assign expression
AssignExpr =
  lhs:PatternOrExpr
  op:(
		'=' |'+=' | '-=' | '*=' | '%=' |
		'**=' | '>>=' | '<<=' | '>>>=' | '&=' |
		'|=' | '^=' | '&&=' | '||=' | '??='
  )
  rhs:PatternOrExpr


PatternOrExpr = Pattern | Expr

// sequence expression
SequenceExpr = exprs:Expr*

// grouping expression
GroupingExpr = '(' inner:Expr ')'

// bracket expression
BracketExpr =  'super'? object:Expr '[' prop:Expr ']'


// binary expression
BinExpr =
  lhs:Expr
  op:(
		'<' | '>' | '<=' | '>=' | '==' | '===' | '!=' | '!=='
		| '+' | '-' | '*' | '/' | '%' | '**' | '<<' | '>>' | '>>>'
		| '&' | '|' | '^' | '??' | '||' | '&&' | 'in' | 'instanceof'
  )
  rhs:Expr

// unary expression
UnaryExpr =
  lhs:Expr
  op:(
		'++' | '--' | 'delete' | 'void' | 'typeof' | '+' | '-' | '~'
		| '!' | 'await'
  )
  rhs:Expr

// Literals
Literal =
	StringValue
	| BooleanValue
	| NumberValue
	| RegexValue
	| NumberValue
	| FloatValue
	| BigIntValue

StringValue = 'string'
BooleanValue = 'true' | 'false'
NumberValue = 'number'
FloatValue = 'float'
BigIntValue = 'big_int'
RegexValue = 'regex'
NullValue = 'null'
UndefinedValue = 'undefined'

ExprOrBlock =
	Expr
	| BlockStmt

ParameterList = '(' Pattern* ')'
ArgList = '(' Expr* ')'


// Patterns
Pattern =
	SinglePattern
	| RestPattern
	// | AssignPattern
	// | ObjectPattern
	// | ArrayPattern
	// | ExprPattern

// TODO:  add here the typescript tokens and nodes
SinglePattern
	= name:Ident

RestPattern = '...' pa:Pattern


NameRef = Ident


///////////////
// PROPS
///////////////
ObjectProp =
	LiteralProp
	| Getter
	// | Setter
	// | SpreadProp
	// | InitializedProp
	// | IdentProp
	// | Method


LiteralProp = key:PropName ':' value:Expr

PropName =
	ComputedPropertyName
	Literal
	Ident


ComputedPropertyName = '[' Expr ']'


PrivatePropAccess = lhs:Expr '.' rhs:PrivateName

///////////////
// MISCELLANEOUS
///////////////

// TODO: add typescript types
Getter =  'get' key:PropName parameters:ParameterList  body:BlockStmt

// TODO: add typescript types
Setter = 'set' key:PropName parameters:ParameterList  body:BlockStmt

// TODO: add typescript types
Method = 'static'? 'async'? '*'? name:PropName parameters:ParameterList  body:BlockStmt

SpreadElement = '...' element:Expr

PrivateName = '#' Name

Name = Ident


Condition = '(' condition:Expr ')'

///////////////
// DECLARATIONS
///////////////

Decl =
	FnDecl
	// | ClassDecl
	// | VarDecl
	// | TsEnum
	// | TsTypeAliasDecl
	// | TsNamespaceDecl
	// | TsModuleDecl
	// | TsInterfaceDecl


// TODO: add typescript types
FnDecl =
	'async'?
	'function'
	'*'?
	Name
	parameters:ParameterList
	body:BlockStmt

///////////////
// TYPESCRIPT
///////////////
//
// Below here we want to keep all the TypeScript types
// Typescript definitions
//
TsTypeParams = '<'  '>'
TsType =
	TsAny
	| TsUnknown
	// | TsNumber
	// | TsObject
	// | TsBoolean
	// | TsBigint
	// | TsString
	// | TsSymbol
	// | TsVoid
	// | TsUndefined
	// | TsNull
	// | TsNever
	// | TsThis
	// | TsLiteral
	// | TsPredicate
	// | TsTuple
	// | TsParen
	// | TsTypeRef
	// | TsTemplate
	// | TsMappedType
	// | TsImport
	// | TsArray
	// | TsIndexedArray
	// | TsTypeOperator
	// | TsIntersection
	// | TsUnion
	// | TsFnType
	// | TsConstructorType
	// | TsConditionalType
	// | TsObjectType
	// | TsInfer


TsAny = 'any'
TsUnknown = 'unknown'
