// Javascript Un-Grammar.
//
// This grammar specifies the structure of Rust's concrete syntax tree.
// It does not specify parsing rules (ambiguities, precedence, etc are out of scope).
// Tokens are processed -- contextual keywords are recognised, compound operators glued.
//
// Legend:
//
//   //          				-- comment
//   Name =      				-- non-terminal definition
//   'ident'     				-- token (terminal)
//   A B         				-- sequence
//   A | B       				-- alternation
//   A*          				-- zero or more repetition
//   (A (',' A)* ','?)	        -- repetition of node A separated by ',' and allowing a trailing comma
//   (A (',' A)*)	            -- repetition of node A separated by ',' without a trailing comma
//   A?          				-- zero or one repetition
//   (A)         				-- same as A
//   label:A     				-- suggested name for field of AST node

// NOTES
//
// - "manual__" prefix is used to _exclude_ those method from being autogenerated
//   and they will be manually implemented
// - SyntaxNode, SyntaxToken and SyntaxElement will be stripped from the codegen
// - Unknown nodes are special nodes used to keep track of broken code; they are
//   not part of the grammar but they will appear inside the green tree
//


///////////////
// UNKNOWN NODES
///////////////
// SyntaxElement is a generic data structure that is meant to track nodes and tokens
// in cases where we care about both types
//
// As Unknown* node will need to yield both tokens and nodes without discrimination,
// and their children will need to yield nodes and tokens as well.
// For this reason, SyntaxElement = SyntaxElement
SyntaxElement = SyntaxElement

JsUnknownStatement = SyntaxElement*
JsUnknownExpression = SyntaxElement*
JsUnknownMember = SyntaxElement*
JsUnknownBinding = SyntaxElement*
JsUnknownAssignment = SyntaxElement*
JsUnknownModifier = SyntaxElement*
JsUnknownImportAssertionEntry = SyntaxElement*
JsUnknownNamedImportSpecifier = SyntaxElement*
List = SyntaxElement*

Ident = 'ident'

JsAnyRoot =
	JsScript | JsModule

JsScript =
	interpreter: 'js_shebang'?
	directives: JsDirective*
	statements: JsAnyStatement*
	eof: 'EOF'

JsModule =
	interpreter: 'js_shebang'?
	directives: JsDirective*
	items: JsAnyModuleItem*
	eof: 'EOF'


JsDirective =
	value: 'js_string_literal'
	';'?

///////////////
// STATEMENTS
///////////////

JsAnyStatement =
	JsBlockStatement
	| JsEmptyStatement
	| JsExpressionStatement
	| JsIfStatement
	| JsDoWhileStatement
	| JsWhileStatement
	| ForStmt
	| JsForInStatement
	| JsForOfStatement
	| JsContinueStatement
	| JsBreakStatement
	| JsReturnStatement
	| JsWithStatement
	| JsLabeledStatement
	| JsSwitchStatement
	| JsThrowStatement
	| JsTryStatement
	| JsTryFinallyStatement
	| JsDebuggerStatement
  | JsFunctionDeclaration
	| JsClassDeclaration
	| JsVariableStatement
	| TsEnum
	| TsTypeAliasDecl
	| TsNamespaceDecl
	| TsModuleDecl
	| TsInterfaceDecl
	| JsUnknownStatement


JsBlockStatement =
	'{'
	statements: JsAnyStatement*
	'}'


JsEmptyStatement =
    ';'

JsExpressionStatement =
    expression: JsAnyExpression ';'?


JsWhileStatement =
    'while' '(' test: JsAnyExpression ')'
    body: JsAnyStatement


JsDoWhileStatement =
    'do'
    body: JsAnyStatement
    'while' '(' test: JsAnyExpression ')'
    ';'?


// if statement
JsIfStatement =
	'if' '(' test: JsAnyExpression ')'
	consequent: JsAnyStatement
	else_clause: JsElseClause?

JsElseClause =
	'else'
	alternate: JsAnyStatement


// for..in statement
ForStmt =
	'for'
	'('
	initializer: JsAnyForInitializer?
	first_semi: ';'
	test:ForStmtTest?
	manual__second_semi: ';'
	update:ForStmtUpdate?
	')'
	cons:JsAnyStatement

JsAnyForInitializer = JsVariableDeclarationList | JsAnyExpression

// TODO #1724 Inline when AST facade uses fixed offsets
ForStmtTest = expr:JsAnyExpression
ForStmtUpdate = expr:JsAnyExpression


// for..in statement
JsForInStatement =
	'for'
	'('
	initializer: JsAnyForInOrOfInitializer
	'in'
	expression: JsAnyExpression
	')'
	body: JsAnyStatement

// for..of statement
JsForOfStatement =
	'for'
	'await'?
	'('
	initializer: JsAnyForInOrOfInitializer
	'of'
	expression: JsAnyExpression
	')'
	body: JsAnyStatement

JsAnyForInOrOfInitializer =
	JsAnyAssignmentPattern
	| JsForVariableDeclaration

JsForVariableDeclaration =
	kind_token: ('var' | 'let' | 'const')
	declaration: JsVariableDeclaration

JsBreakStatement =
    'break'
    (label: 'ident')?
    ';'?

JsContinueStatement =
    'continue'
    (label: 'ident')?
    ';'?


JsReturnStatement =
    'return'
    argument: JsAnyExpression?
    ';'?


JsWithStatement =
    'with' '(' object: JsAnyExpression ')'
    body: JsAnyStatement


JsLabeledStatement =
    label: 'ident' ':'
    body: JsAnyStatement


JsSwitchStatement =
    'switch' '(' discriminant: JsAnyExpression ')'
    '{'
    cases: JsAnySwitchClause*
    '}'

JsAnySwitchClause = JsCaseClause | JsDefaultClause
JsCaseClause = 'case' test: JsAnyExpression ':' consequent: JsAnyStatement*
JsDefaultClause = 'default' ':' consequent: JsAnyStatement*


JsThrowStatement =
    'throw'
    argument: JsAnyExpression
    ';'?

// try..catch..finally statement
JsTryStatement =
    'try'
    body: JsBlockStatement
    catch_clause: JsCatchClause

JsTryFinallyStatement =
    'try'
    body: JsBlockStatement
    catch_clause: JsCatchClause?
    finally_clause: JsFinallyClause

JsCatchClause =
    'catch'
    declaration: JsCatchDeclaration?
    body: JsBlockStatement

JsCatchDeclaration =
    '(' binding: JsAnyBindingPattern ')'

JsFinallyClause =
    'finally'
    body: JsBlockStatement


// debugger statement
JsDebuggerStatement =
	'debugger' ';'?


///////////////
// EXPRESSIONS
///////////////

// Expression
JsAnyExpression =
	JsAnyLiteralExpression
	| JsArrayExpression
	| JsArrowFunctionExpression
	| JsAssignmentExpression
	| JsAwaitExpression
	| JsBinaryExpression
	| JsClassExpression
	| JsConditionalExpression
	| JsComputedMemberExpression
	| JsFunctionExpression
	| JsImportCallExpression
	| JsLogicalExpression
	| JsObjectExpression
	| JsParenthesizedExpression
	| JsIdentifierExpression
	| JsSequenceExpression
	| JsStaticMemberExpression
	| JsSuperExpression
	| JsThisExpression
	| JsUnaryExpression
	| JsPreUpdateExpression
	| JsPostUpdateExpression
	| JsYieldExpression
	| Template
	| NewExpr
	| CallExpr
	| NewTarget
	| ImportMeta
	| TsNonNull
	| TsAssertion
	| TsConstAssertion
	| JsUnknownExpression


// the backtick is just a placeholder, see parser in rslint_parser/src/ast/expr_ext.rs
Template = '`'

JsThisExpression = 'this'

JsSuperExpression = 'super'

// new expression
NewExpr = 'new' object:JsAnyExpression type_args:TsTypeArgs?  arguments:ArgList

// call expression
CallExpr = callee:JsAnyExpression type_args:TsTypeArgs? arguments:ArgList


JsAwaitExpression =
	'await'
	argument: JsAnyExpression


JsYieldExpression =
	'yield'
	'*'?
	argument: JsAnyExpression?

JsImportCallExpression =
	'import'
	'('
	argument: JsAnyExpression
	')'

// new target expression
NewTarget = 'new' '.' 'target'


JsConditionalExpression =
	test: JsAnyExpression
	'?'
	manual__consequent: JsAnyExpression
	':'
	manual__alternate: JsAnyExpression

// import meta expression
ImportMeta = 'import' '.' 'meta'

JsFunctionExpression =
	'async'?
	'function'
	'*'?
	id: JsAnyBinding?
	type_parameters: TsTypeParams?
	parameters: JsParameterList
	return_type: TsTypeAnnotation?
	body: JsFunctionBody


JsArrowFunctionExpression =
	'async'?
	type_parameters: TsTypeParams?
	parameter_list: JsAnyArrowFunctionParameters?
	return_type: TsTypeAnnotation?
	'=>'
	manual__body: JsAnyArrowFunctionBody

JsAnyArrowFunctionParameters = JsParameterList | JsAnyBinding
JsAnyArrowFunctionBody = JsAnyExpression | JsFunctionBody

// Array expression
JsArrayExpression =
	'['
	elements: (JsAnyArrayElement (',' JsAnyArrayElement)* ','?)
	']'

JsAnyArrayElement =
	JsAnyExpression
	| JsSpread
	| JsArrayHole

JsArrayHole = manual__hole: ''?

JsAssignmentExpression =
  left: JsAnyAssignmentPattern
  operator_token: (
		'=' |'+=' | '-=' | '*=' | '/=' | '%=' |
		'**=' | '>>=' | '<<=' | '>>>=' | '&=' |
		'|=' | '^=' | '&&=' | '||=' | '??='
  )
  right: JsAnyExpression


JsSequenceExpression =
	left: JsAnyExpression
	comma: ','
	manual__right: JsAnyExpression


JsParenthesizedExpression =
	'(' expression: JsAnyExpression ')'


JsIdentifierExpression = name: JsReferenceIdentifier

// a.b
// a.#b
JsStaticMemberExpression =
	object: JsAnyExpression
	operator: ('.' | '?.')
	member: JsAnyName

// a[b]
JsComputedMemberExpression =
	object: JsAnyExpression
	optional_chain_token: '?.'?
	'['
	manual__member: JsAnyExpression
	']'

JsBinaryExpression =
    left: JsAnyExpression
    operator: (
    	'<' | '>' | '<=' | '>=' | '==' | '===' | '!=' | '!=='
    	| '+' | '-' | '*' | '/' | '%' | '**' | '<<' | '>>' | '>>>'
    	| '&' | '|' | '^' | 'in' | 'instanceof'
		)
    manual__right: JsAnyExpression

JsLogicalExpression =
	left: JsAnyExpression
	operator: ('??' | '||' | '&&')
	manual__right: JsAnyExpression

// unary expression
JsUnaryExpression =
  operator: ('delete' | 'void' | 'typeof' | '+' | '-' | '~' | '!')
  argument: JsAnyExpression

JsPreUpdateExpression =
    operator: ('++' | '--')
    operand: JsAnyAssignment

JsPostUpdateExpression =
    operand: JsAnyAssignment
    operator: ('++' | '--')


///////////////
// OBJECTS
///////////////
JsAnyObjectMemberName =
	JsLiteralMemberName
	| JsComputedMemberName

JsObjectExpression =
	'{'
	members: (JsAnyObjectMember (',' JsAnyObjectMember)* ','?)
	'}'

JsAnyObjectMember =
	JsPropertyObjectMember
	| JsMethodObjectMember
	| JsGetterObjectMember
	| JsSetterObjectMember
	| JsShorthandPropertyObjectMember
	| JsSpread
	| JsUnknownMember


// { a: 5, b: () => {} }
//   ^^^^  ^^^^^^^^^^^
JsPropertyObjectMember =
	name: JsAnyObjectMemberName
	':'
	manual__value: JsAnyExpression

// { get a() {} }
//   ^^^^^^^^^^
JsGetterObjectMember =
	'get'
	name: JsAnyObjectMemberName
	'('')'
	return_type: TsTypeAnnotation?
	body: JsFunctionBody

//  { set a(value) {} }
//    ^^^^^^^^^^^^^^^
JsSetterObjectMember =
	'set'
	name: JsAnyObjectMemberName
	'('
	parameter: JsAnyBindingPattern
	')'
	body: JsFunctionBody

// { a() {}, async b() {}, async * c() {} }
//   ^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^^^^
JsMethodObjectMember =
	'async'?
	'*'?
	name: JsAnyObjectMemberName
	type_params: TsTypeParams?
	parameter_list: JsParameterList
	return_type: TsTypeAnnotation?
	body: JsFunctionBody

// { a }
//   ^
JsShorthandPropertyObjectMember = name: JsReferenceIdentifier

///////////////
// CLASSES
///////////////

JsClassDeclaration  =
	'class'
	id: JsAnyBinding
	implements_clause: TsImplementsClause?
	extends_clause: JsExtendsClause?
	'{'
	members: JsAnyClassMember*
	'}'

JsClassExpression =
	'class'
	id: JsAnyBinding?
	extends_clause: JsExtendsClause?
	'{'
	members: JsAnyClassMember*
	'}'

TsImplementsClause =
	'implements'
	interfaces: (TsExprWithTypeArgs (',' TsExprWithTypeArgs)*)

// class Test extends A {}
//            ^^^^^^^^^
JsExtendsClause =
	'extends'
	super_class: JsAnyExpression

// class Test { #test; }
//              ^^^^^
JsPrivateClassMemberName = '#' id: 'ident'

JsAnyClassMemberName =
	JsLiteralMemberName
	| JsComputedMemberName
	| JsPrivateClassMemberName

JsAnyClassMember =
	JsConstructorClassMember
	| JsPropertyClassMember
	| JsMethodClassMember
	| JsGetterClassMember
	| JsSetterClassMember
	| JsEmptyClassMember
	| TsIndexSignature
	| JsUnknownMember

// class Test { constructor() {} }
//              ^^^^^^^^^^^^^^^^
// class Test { "constructor"() {} }
//              ^^^^^^^^^^^^^^^^^^
// class Test { 'constructor'() {} }
//              ^^^^^^^^^^^^^^^^^^
JsConstructorClassMember =
	access_modifier: TsAnyAccessibility?
	name: JsLiteralMemberName
	parameter_list: JsConstructorParameterList
	body: JsFunctionBody

JsConstructorParameterList =
	'('
	parameters: (JsAnyConstructorParameter (',' JsAnyConstructorParameter)* ','?)
	')'

JsAnyConstructorParameter =
	TsConstructorParam
	| JsAnyBindingPattern
	| JsBindingPatternWithDefault

// class Test { a; b = 1; static c; }
//              ^^ ^^^^^^ ^^^^^^^^^
JsPropertyClassMember =
	modifiers: JsAnyModifier?
	access_modifier: TsAnyAccessibility?
	name: JsAnyClassMemberName
	'?'?
	'!'?
	type: TsTypeAnnotation?
	value: JsInitializerClause?
	';'?

// class Test { a() {} }
//              ^^^^^^
JsMethodClassMember =
	modifiers: JsAnyModifier?
	access_modifier: TsAnyAccessibility?
	'async'?
	'*'?
	name: JsAnyClassMemberName
	type_parameters: TsTypeParams?
	parameter_list: JsParameterList
	return_type: TsTypeAnnotation?
	body: JsFunctionBody

// class Test { get a() {} }
//              ^^^^^^^^^^
JsGetterClassMember =
	modifiers: JsAnyModifier?
	access_modifier: TsAnyAccessibility?
	'get'
	name: JsAnyClassMemberName
	'(' ')'
	return_type: TsTypeAnnotation?
	body: JsFunctionBody

// class Test { set a(v) {} }
//              ^^^^^^^^^^^
JsSetterClassMember =
	modifiers: JsAnyModifier?
	access_modifier: TsAnyAccessibility?
	'set'
	name: JsAnyClassMemberName
	'('
	parameter: JsAnyBindingPattern
	')'
	body: JsFunctionBody

JsEmptyClassMember = ';'

JsAnyModifier =
	JsModifier
	| JsUnknownModifier

JsModifier = 'declare'? 'static'? 'abstract'?

///////////////
// ASSIGNMENT TARGETS
///////////////

JsAnyAssignment =
	JsIdentifierAssignment
	| JsStaticMemberAssignment
	| JsComputedMemberAssignment
	| JsParenthesizedAssignment
	| JsUnknownAssignment


JsAssignmentWithDefault =
	pattern: JsAnyAssignmentPattern
	'='
	default: JsAnyExpression

// (a) = "test"
// ^^^
JsParenthesizedAssignment =
	'('
	assignment: JsAnyAssignment
	')'

// Assignment to an identifier from the lexical scope
// b = "test"
// ^
JsIdentifierAssignment = name: 'ident'

// a.b = a.#b = "test"
// ^^^   ^^^^
JsStaticMemberAssignment =
	object: JsAnyExpression
	'.'
	member: JsAnyName

// a['b'] = a[expr] = "test"
// ^^^^^^   ^^^^^^^
JsComputedMemberAssignment =
	object: JsAnyExpression
	'['
	manual__member: JsAnyExpression
	']'

JsAnyAssignmentPattern =
	JsAnyAssignment
	| JsArrayAssignmentPattern
	| JsObjectAssignmentPattern


// [a, b = "b", ...rest] = bar
// ^^^^^^^^^^^^^^^^^^^^^^
JsArrayAssignmentPattern =
	'['
	elements: (JsAnyArrayAssignmentPatternElement (',' JsAnyArrayAssignmentPatternElement)* ','?)
	']'

JsAnyArrayAssignmentPatternElement =
	JsAssignmentWithDefault
	| JsAnyAssignmentPattern
	| JsArrayAssignmentPatternRestElement
	| JsArrayHole
	| JsUnknownAssignment

// [a, b, ...rest] = [];
//        ^^^^^^^
JsArrayAssignmentPatternRestElement =
	'...'
	pattern: JsAnyAssignmentPattern

// ({a, b: x, ...rest} = c)
//  ^^^^^^^^^^^^^^^^^^
JsObjectAssignmentPattern =
	'{'
	properties: (JsAnyObjectAssignmentPatternMember (',' JsAnyObjectAssignmentPatternMember)* ','?)
	'}'

JsAnyObjectAssignmentPatternMember =
	JsObjectAssignmentPatternShorthandProperty
	| JsObjectAssignmentPatternProperty
	| JsObjectAssignmentPatternRest
	| JsUnknownAssignment

// ({ x } = b) or ({ x = "test" } = b)
//    ^              ^^^^^^^^^^
JsObjectAssignmentPatternShorthandProperty =
	identifier: JsAnyAssignment
	init: JsInitializerClause?

// ({ x: a } = b) or ({ x: a = "test" } = b)
//    ^^^^              ^^^^^^^^^^^^^
JsObjectAssignmentPatternProperty =
	member: JsName
	':'
	pattern: JsAnyAssignmentPattern
	init: JsInitializerClause?

// ({ a, ...b } = a)
//       ^^^^
JsObjectAssignmentPatternRest =
	'...'
	target: JsAnyAssignment

///////////////
// BINDINGS
///////////////

JsAnyBinding =
	JsIdentifierBinding
	| JsUnknownBinding

// Binds a value to an identifier.
// let x = OR function(test) {}
//     ^               ^^^^
JsIdentifierBinding =
	name: 'ident'

// [ a = "b"] = [];
//   ^^^^^^^
JsBindingPatternWithDefault =
	pattern: JsAnyBindingPattern
	'='
	default: JsAnyExpression

JsAnyBindingPattern =
	JsAnyBinding
	| JsArrayBindingPattern
	| JsObjectBindingPattern

// let [a, b] = [1, 2];
//     ^^^^^^
JsArrayBindingPattern =
	'['
	elements: (JsAnyArrayBindingPatternElement (',' JsAnyArrayBindingPatternElement)* ','?)
	']'

JsAnyArrayBindingPatternElement =
	JsArrayHole
	| JsAnyBindingPattern
	| JsBindingPatternWithDefault
	| JsArrayBindingPatternRestElement

JsArrayBindingPatternRestElement =
	'...'
	pattern: JsAnyBindingPattern

// let { a, b} = c;
//     ^^^^^^^
JsObjectBindingPattern =
	'{'
	properties: (JsAnyObjectBindingPatternMember (',' JsAnyObjectBindingPatternMember)* ','?)
	'}'

JsAnyObjectBindingPatternMember =
	JsObjectBindingPatternProperty
	| JsObjectBindingPatternRest
	| JsObjectBindingPatternShorthandProperty
	| JsIdentifierBinding
	| JsUnknownBinding

// let { a: b.m } = {}
//       ^^^^^^
// let { a: b.m = "test" } = {}
//       ^^^^^^^^^^^^^^^
JsObjectBindingPatternProperty =
	member: JsAnyObjectMemberName
	':'
	pattern: JsAnyBindingPattern
	init: JsInitializerClause?

// let { a } = c
//       ^
// let { a = "test" } = c
//       ^^^^^^^^^^
JsObjectBindingPatternShorthandProperty =
	identifier: JsAnyBinding
	init: JsInitializerClause?

// let { ...a } = c
//       ^^^^
JsObjectBindingPatternRest =
	'...'
	binding: JsAnyBinding


///////////////
// LITERALS
///////////////

JsAnyLiteralExpression =
	JsStringLiteralExpression
	| JsNumberLiteralExpression
	| JsBigIntLiteralExpression
	| JsBooleanLiteralExpression
	| JsNullLiteralExpression
	| JsRegexLiteralExpression

// "abcd" | 'abcd'
JsStringLiteralExpression = value: 'js_string_literal'

// 4, 5.5, 0x00, ...
JsNumberLiteralExpression = value: 'js_number_literal'

// 45n
JsBigIntLiteralExpression =  value: 'js_big_int_literal'

// true, false
JsBooleanLiteralExpression = value_token: ('true' | 'false')

// null
JsNullLiteralExpression = value: 'null'

JsRegexLiteralExpression = value: 'js_regex_literal'


///////////////
// DECLARATIONS
///////////////

JsFunctionDeclaration =
	'async'?
	'function'
	'*'?
	id: JsAnyBinding
	type_parameters: TsTypeParams?
	parameter_list: JsParameterList
	return_type: TsTypeAnnotation?
	body: JsFunctionBody

TsTypeAnnotation =
	':'
	type: TsType

// let a, b = c;
JsVariableStatement =
    declaration_list: JsVariableDeclarationList ';'?

// Declaration of multiple variables
// let a, b = c;
// ^^^^^^^^
JsVariableDeclarationList =
    kind_token: ('var' | 'const' | 'let')
    declarations: (JsVariableDeclaration (',' JsVariableDeclaration)*)

// let b = c;
//     ^^^^^
JsVariableDeclaration =
    id: JsAnyBindingPattern
    '!'?
    type_annotation: TsTypeAnnotation?
    initializer: JsInitializerClause?


///////////////
// MODULE SYNTAX
///////////////

JsAnyModuleItem =
	JsAnyStatement
	| JsImport
	| ExportDefaultDecl
	| ExportDefaultExpr
	| ExportWildcard
	| ExportDecl
	| TsImportEqualsDecl
	| TsExportAssignment
	| TsNamespaceExportDecl

JsImport = 'import'
	import_clause: AnyJsImportClause
	';'?

AnyJsImportClause =
    JsImportBareClause
    | JsName
    | JsImportNamedClause
    | JsImportDefaultClause
    | JsImportNamespaceClause
//    | TsImportRequireClause
//    | TsImportAliasClause

// import "abcd"
// import "abcd" assert ...
JsImportBareClause =
	source: JsModuleSource
	assertion: JsImportAssertion?

// import foo from "mod"
// import type foo from "mod"
JsImportDefaultClause =
		// 'type'?
		local_name: JsAnyBinding
		'from'
		source: JsModuleSource
		assertion: JsImportAssertion?

// import * as foo from "mod";
// import type * as foo from "mod";
JsImportNamespaceClause =
  // 'type'
	'*'
	'as'
	local_name: JsAnyBinding
	'from'
	source: JsModuleSource
	assertion: JsImportAssertion?

// import { a, b: c } from "d"
//        ^^^^^^^^^^^^^^^^^^^^
// import c, { b } from "c"
//        ^^^^^^^^^^^^^^^^^
// import { type a } from "c"
//        ^^^^^^^^^^^^^^^^^^^
// import foo, * as bar from "mod"
//        ^^^^^^^^^^^^^^^^^^^^^^^^
// import type { foo } from "mod";
//        ^^^^^^^^^^^^^^^^^^^^^^^
// import foo, { type bar } from "mod";
JsImportNamedClause =
    // 'type'?
    default_specifier: JsDefaultImportSpecifier?
    named_import: JsAnyNamedImport
    'from'
    source: JsModuleSource
    assertion: JsImportAssertion?

// import a, { b, c } from "d";
//        ^^
JsDefaultImportSpecifier =
    local_name: JsAnyBinding
    trailing_comma: ','

JsAnyNamedImport =
	JsNamedImportSpecifierList
	|  JsNamespaceImportSpecifier

// import a, * as b from "d";
//           ^^^^^^
JsNamespaceImportSpecifier =
    '*'
    'as'
    local_name: JsAnyBinding

// import a, { b, c } from "d";
//           ^^^^^^^^
JsNamedImportSpecifierList =
    '{'
    specifiers: (JsAnyNamedImportSpecifier (',' JsAnyNamedImportSpecifier)* ','?)
    '}'

JsAnyNamedImportSpecifier =
    JsShorthandNamedImportSpecifier
    | JsNamedImportSpecifier
    | JsUnknownNamedImportSpecifier

// import { foo as test } from "mod";
//          ^^^^^^^^^^^
// import { type foo as test } from "mod";
//          ^^^^^^^^^^^^^^^^^
JsNamedImportSpecifier =
    // 'type'?
    name: JsLiteralExportName
    'as'
    local_name: JsAnyBinding

// import { type foo } from "mod";
//          ^^^^^^^^
JsShorthandNamedImportSpecifier =
    // 'type'?
    local_name: JsAnyBinding

// import a from "mod" assert { type: "json" }
//                     ^^^^^^^^^^^^^^^^^^^^^^^
JsImportAssertion =
    'assert'
    '{'
    assertions: (JsAnyImportAssertionEntry (',' JsAnyImportAssertionEntry)* ','?)
    '}'

JsAnyImportAssertionEntry =
	JsImportAssertionEntry
	| JsUnknownImportAssertionEntry

// import a from "mod" assert { type: "json" }
//                              ^^^^^^^^^^^^
JsImportAssertionEntry =
    key: ('ident' | 'js_string_literal')
    ':'
    value: 'js_string_literal'

// import { a as b } from "c"
//          ^
// export { a as "a-b-c" };
//               ^^^^^^^
JsLiteralExportName = value: ('ident' | 'js_string_literal')


// import "test"
//        ^^^^^^
// export a from "b"
//               ^^^
JsModuleSource = value: 'js_string_literal'

// export default declaration
ExportDefaultDecl = 'export' 'default'? 'type'? decl:DefaultDecl
DefaultDecl =
	JsFunctionDeclaration
	| JsClassDeclaration


// export default expression
ExportDefaultExpr = 'export' 'type'? 'default'? expr:JsAnyExpression

// export wildcard
ExportWildcard = 'export' 'type'? '*' 'as'? ident: Ident? 'from' source: 'js_string_literal'


// export declaration
ExportDecl = 'export' 'type'? decl: JsAnyExportDeclaration

JsAnyExportDeclaration =
	JsFunctionDeclaration
	| JsClassDeclaration
	| JsVariableStatement
	| ExportNamed
	| TsEnum
	| TsTypeAliasDecl
	| TsNamespaceDecl
	| TsModuleDecl
	| TsInterfaceDecl


// typescript export assignment
TsExportAssignment = 'export' '=' expr: JsAnyExpression ';'?


// typescript namespace export
TsNamespaceExportDecl = 'export' 'as' 'namespace' ident: Ident? ';'?

Specifier = name:JsName 'as'? manual__alias: JsName?

// @ematipico this one is not entirely correct I think..
ExportNamed = '{' specifiers:(Specifier (',' Specifier)* ','?) '}' 'from'?  'js_string_literal'? ';'?

///////////////
// AUXILIARY
///////////////

// { ...a }
//   ^^^^
// [ ...a ]
//   ^^^^
JsSpread =
	'...'
	argument: JsAnyExpression


// Reference to an identifier from the lexical scope
JsReferenceIdentifier = value: 'ident'

// A js identifier that is neither a binding, assignment, nor a reference.
// For example a member name
JsName = value: 'ident'

JsPrivateName =
	'#'
	value: 'ident'

JsAnyName =
	JsName
	| JsPrivateName


// { a: ..., "b": ..., 4: ... }
//   ^       ^^^       ^
JsLiteralMemberName = value: ('ident' | 'js_string_literal' | 'js_number_literal')

// { [call()]: ... }
//   ^^^^^^^^
JsComputedMemberName =
	'['
	expression: JsAnyExpression
	']'


JsParameterList =
	'('
	parameters: (JsAnyParameter (',' JsAnyParameter)* ','?)
	')'

JsAnyParameter = JsAnyBindingPattern | JsBindingPatternWithDefault | JsRestParameter

JsRestParameter =
	'...'
	binding: JsAnyBindingPattern

ArgList = '(' args:(JsAnyExpression (',' JsAnyExpression)* ','?) ')'


// let a = 10;
//       ^^^^
// class { a = 10; }
//           ^^^^
JsInitializerClause =
	'='
	expression: JsAnyExpression

JsFunctionBody =
	'{'
	directives: JsDirective*
	statements: JsAnyStatement*
	'}'

///////////////
// TYPESCRIPT
///////////////
//
// Below here we want to keep all the TypeScript types
// Typescript definitions
//

TsImportEqualsDecl =
	('import' | 'export') ident: Ident '=' module:TsModuleRef ';'?


TsModuleRef =
	TsExternalModuleRef |
	TsEntityName


TsExternalModuleRef = 'require' '(' module: 'js_string_literal' ')'

TsType =
	TsAny
	| TsUnknown
	| TsNumber
	| TsObject
	| TsBoolean
	| TsBigint
	| TsString
	| TsSymbol
	| TsVoid
	| TsUndefined
	| TsNull
	| TsNever
	| TsThis
	| TsLiteral
	| TsPredicate
	| TsTuple
	| TsParen
	| TsTypeRef
	| TsTemplate
	| TsMappedType
	| TsImport
	| TsArray
	| TsIndexedArray
	| TsTypeOperator
	| TsIntersection
	| TsUnion
	| TsFnType
	| TsConstructorType
	| TsConditionalType
	| TsObjectType
	| TsInfer


TsAny = 'any'
TsUnknown = 'unknown'
TsNumber = ident: Ident
TsObject = ident: Ident
TsBoolean = ident: Ident
TsBigint = ident: Ident
TsString = ident: Ident
TsSymbol = ident: Ident
TsVoid = 'void'
TsUndefined = 'undefined'
TsNull= 'null'
TsNever = 'never'
TsThis = 'this'
TsLiteral = ident: Ident


// typescript tuples
TsTuple = '[' elements:TsTupleElement ']'
// @ematipico: this is ugly and it's here only to maintain compatibility
// with the current parser API
TsTupleElement = ident: Ident ':' '?' '...'? ty:TsType

TsParen = '(' ty:TsType ')'

// typescript type reference
TsTypeRef = name:TsEntityName type_args:TsTypeArgs


// typescript enum
TsEnum = 'const'? 'enum'  ident: Ident '{' members:TsEnumMember* '}'
TsEnumMember = ident: Ident '=' value:JsAnyExpression

// typescript template literal types
TsTemplate = elements:TsTemplateElement
// @ematipico: this is broken and it's here only for compatibility
TsTemplateElement = ty:TsType '}'


// typescript mappend type
// plus and minus should be mutually exclusive
TsMappedType =
	'{'
	readonly_modifier:TsMappedTypeReadonly?
	'-'?
	'+'?
	'?'?
	param:TsMappedTypeParam
	':'
	ty:TsType
	'}'
	';'?

TsMappedTypeReadonly = '-'? '+'? 'readonly'?

// @ematipico: this type is correct and it's here only for compatibility
TsMappedTypeParam = '['? name:TsTypeName? ']'? ident: Ident? ty:TsType


// typescript array
TsArray = '[' ty:TsType ']'

// typescript indexed array
TsIndexedArray = '[' ty:TsType ']'


// typescript predicate
TsPredicate = lhs:TsThisOrMore rhs:TsType
TsThisOrMore = TsThis | TsTypeName

// typescript type operator
TsTypeOperator = ty:TsType

// typescript intersection
// @ematipico this one should contains the "|" operator
TsIntersection = types:TsType*

// typescript union
// @ematipico this one should contains the "&" operator
TsUnion = types:TsType*


// typescript function type
// Example: (something: String) => bool
TsFnType = params:JsParameterList '=>' return_type:TsType?


// typescript constructor type
// Exapmle: new (something: String): SomethingElse
TsConstructorType = 'new' params:JsParameterList ':' return_type:TsType?


// typescript conditional type
// @ematipico example? can't understand what grammar it is
TsConditionalType = ty:TsType '?' ':' extends:TsExtends
TsExtends = 'extends' ty:TsType


// typescript object type
TsObjectType = '{' members:TsTypeElement* '}'


// typescript infer
TsInfer = 'infer' ident: Ident

// typescript import
// @ematipico not sure where the dot token should be placed
// @ematipico not sure where type_args should be placed
// TsImport = 'import' '(' qualifier:TsEntityName '.' ')' type_args:TsTypeArgs


// typescrit namesapce
// TODO: not sure where to put the dot
// https://github.com/rome/tools/issues/1729
TsNamespaceDecl = 'declare' ident: Ident '.'? body: TsNamespaceBody
TsNamespaceBody = TsModuleBlock | TsNamespaceDecl
TsModuleBlock = '{' items: JsAnyStatement '}'


// type alias declaration
TsTypeAliasDecl = 'type' type_params:TsTypeParams '=' ty:TsType
TsTypeParams = '<'? params:TsTypeParam '>'?
TsTypeParam = ident: Ident constraint:TsConstraint default:TsDefault

TsDefault = '=' ty:TsType
TsConstraint = 'extends' ty:TsType



// typescript module declaration
// TODO: where does the dot go exactly?
TsModuleDecl = 'declare' 'global'? 'module' '.'? ident: Ident body:TsNamespaceBody


// typescript interface declaration
// TODO: extends and its children should be optional, together
TsInterfaceDecl =
	'declare'? 'interface' type_params:TsTypeParams
	'extends'? extends:TsExprWithTypeArgs?
	'{' members:TsTypeElement '}'


TsExprWithTypeArgs = item:TsEntityName type_params:TsTypeArgs
TsTypeElement =
	TsCallSignatureDecl
	| TsConstructSignatureDecl
	| TsPropertySignature
	| TsMethodSignature
	| TsIndexSignature

TsEntityName =
	TsTypeName
	| TsQualifiedPath

TsTypeName = ident: Ident
TsQualifiedPath = lhs:TsEntityName '.' rhs:TsTypeName


TsTypeArgs = '<' args:TsType '>'


// @ematipico we should make an example here
TsCallSignatureDecl =  type_params:TsTypeParams parameters:JsParameterList  ':' return_type:TsType
TsConstructSignatureDecl =
	'new'
	type_params:TsTypeParams
	parameters:JsParameterList
	// these two should be optional together
	':'? return_type:TsType

// typescript property signature
TsPropertySignature = 'readonly'? prop:JsAnyExpression '?' ':' ty:TsType

// typescript method signature
TsMethodSignature =
	'readonly'?
	key:JsAnyExpression
	type_params:TsTypeParams
	parameters:JsParameterList
	'?'?
	':'
	return_type:TsType

// @ematipico not sure where the dot goes here
TsImport = 'import' type_args:TsTypeArgs '.'? '(' qualifier:TsEntityName ')'

// typescript index signature
TsIndexSignature = 'readonly'? '[' pat:JsAnyBinding ':' ty:TsType ']'

// typescript type of access
TsAnyAccessibility =
	TsUnknownAccessibilityModifier
	| TsAccessibility

TsAccessibility = 'private' | 'readonly'

TsConstructorParam = 'readonly'? pat:JsAnyBindingPattern

TsNonNull = expr:JsAnyExpression '!'

TsAssertion = expr:JsAnyExpression ident: Ident '<' ty:TsType '>'

TsConstAssertion = expr:JsAnyExpression ident: Ident '<' 'const' '>'
