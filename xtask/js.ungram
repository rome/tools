// Javascript Un-Grammar.
//
// This grammar specifies the structure of Rust's concrete syntax tree.
// It does not specify parsing rules (ambiguities, precedence, etc are out of scope).
// Tokens are processed -- contextual keywords are recognised, compound operators glued.
//
// Legend:
//
//   //          				-- comment
//   Name =      				-- non-terminal definition
//   'ident'     				-- token (terminal)
//   A B         				-- sequence
//   A | B       				-- alternation
//   A*          				-- zero or more repetition
//   (A (',' A)* ','?)	        -- repetition of node A separated by ',' and allowing a trailing comma
//   (A (',' A)*)	            -- repetition of node A separated by ',' without a trailing comma
//   A?          				-- zero or one repetition
//   (A)         				-- same as A
//   label:A     				-- suggested name for field of AST node

// NOTES
//
// - "manual__" prefix is used to _exclude_ those method from being autogenerated
//   and they will be manually implemented
// - SyntaxNode, SyntaxToken and SyntaxElement will be stripped from the codegen
// - Unknown nodes are special nodes used to keep track of broken code; they are
//   not part of the grammar but they will appear inside the green tree
//


///////////////
// UNKNOWN NODES
///////////////
// SyntaxElement is a generic data structure that is meant to track nodes and tokens
// in cases where we care about both types
//
// As Unknown* node will need to yield both tokens and nodes without discrimition,
// and their children will need to yield nodes and tokens as well.
// For this reason, SyntaxElement = SyntaxElement
SyntaxElement = SyntaxElement

JsUnknownStatement = SyntaxElement*
JsUnknownExpression = SyntaxElement*
JsUnknownPattern = SyntaxElement*
JsUnknownMember = SyntaxElement*
JsUnknownBinding = SyntaxElement*
JsUnknownAssignmentTarget = SyntaxElement*

Ident = 'ident'

JsRoot =
	interpreter: 'js_shebang'?
	directives: JsDirective*
	statements: JsAnyStatement*

JsDirective =
	value: 'js_string_literal'
	';'?

///////////////
// STATEMENTS
///////////////

JsAnyStatement =
	JsBlockStatement
	| JsEmptyStatement
	| JsExpressionStatement
	| JsIfStatement
	| JsDoWhileStatement
	| JsWhileStatement
	| ForStmt
	| ForInStmt
	| ForOfStmt
	| JsContinueStatement
	| JsBreakStatement
	| JsReturnStatement
	| JsWithStatement
	| JsLabeledStatement
	| JsSwitchStatement
	| JsThrowStatement
	| JsTryStatement
	| JsTryFinallyStatement
	| JsDebuggerStatement
  | JsFunctionDeclaration
	| JsClassDeclaration
	| JsVariableDeclarationStatement
	| TsEnum
	| TsTypeAliasDecl
	| TsNamespaceDecl
	| TsModuleDecl
	| TsInterfaceDecl
	| ImportDecl
	| ExportNamed
	| ExportDefaultDecl
	| ExportDefaultExpr
	| ExportWildcard
	| ExportDecl
	| TsImportEqualsDecl
	| TsExportAssignment
	| TsNamespaceExportDecl
	| JsUnknownStatement


JsBlockStatement =
	'{'
	statements: JsAnyStatement*
	'}'


JsEmptyStatement =
    ';'

JsExpressionStatement =
    expression: JsAnyExpression ';'?


JsWhileStatement =
    'while' '(' test: JsAnyExpression ')'
    body: JsAnyStatement


JsDoWhileStatement =
    'do'
    body: JsAnyStatement
    'while' '(' test: JsAnyExpression ')'
    ';'?


// if statement
JsIfStatement =
	'if' '(' test: JsAnyExpression ')'
	consequent: JsAnyStatement
	else_clause: JsElseClause?

JsElseClause =
	'else'
	alternate: JsAnyStatement


// for..in statement
ForStmt =
	'for'
	'('
	init:ForStmtInit?
	first_semi: ';'
	test:ForStmtTest?
	manual__second_semi: ';'
	update:ForStmtUpdate?
	')'
	cons:JsAnyStatement

ForStmtInit = inner: ForHead
ForHead = JsVariableDeclaration | JsAnyExpression
ForStmtTest = expr:JsAnyExpression
ForStmtUpdate = expr:JsAnyExpression


// for..in statement
ForInStmt = 'for' '(' left:ForLeft 'in' right:JsAnyExpression ')' cons:JsAnyStatement

// for..of statement
ForOfStmt = 'for' '(' left:ForLeft 'of' right:JsAnyExpression ')' cons:JsAnyStatement
ForLeft = JsAnyAssignmentTarget | JsVariableDeclaration


JsBreakStatement =
    'break'
    (label: 'ident')?
    ';'?

JsContinueStatement =
    'continue'
    (label: 'ident')?
    ';'?


JsReturnStatement =
    'return'
    argument: JsAnyExpression?
    ';'?


JsWithStatement =
    'with' '(' object: JsAnyExpression ')'
    body: JsAnyStatement


JsLabeledStatement =
    label: 'ident' ':'
    body: JsAnyStatement


JsSwitchStatement =
    'switch' '(' discriminant: JsAnyExpression ')'
    '{'
    cases: JsAnySwitchClause*
    '}'

JsAnySwitchClause = JsCaseClause | JsDefaultClause
JsCaseClause = 'case' test: JsAnyExpression ':' consequent: JsAnyStatement*
JsDefaultClause = 'default' ':' consequent: JsAnyStatement*


JsThrowStatement =
    'throw'
    argument: JsAnyExpression
    ';'?

// try..catch..finally statement
JsTryStatement =
    'try'
    body: JsBlockStatement
    catch_clause: JsCatchClause

JsTryFinallyStatement =
    'try'
    body: JsBlockStatement
    catch_clause: JsCatchClause?
    finally_clause: JsFinallyClause

JsCatchClause =
    'catch'
    declaration: JsCatchDeclaration?
    body: JsBlockStatement

JsCatchDeclaration =
    '(' binding: Pattern ')'

JsFinallyClause =
    'finally'
    body: JsBlockStatement


// debugger statement
JsDebuggerStatement =
	'debugger' ';'?


///////////////
// EXPRESSIONS
///////////////

// Expression
JsAnyExpression =
	JsAnyLiteralExpression
	| JsArrayExpression
	| JsArrowFunctionExpression
	| JsAssignmentExpression
	| JsAwaitExpression
	| JsBinaryExpression
	| JsClassExpression
	| JsConditionalExpression
	| JsComputedMemberExpression
	| JsFunctionExpression
	| JsImportCallExpression
	| JsLogicalExpression
	| JsObjectExpression
	| JsParenthesizedExpression
	| JsReferenceIdentifierExpression
	| JsSequenceExpression
	| JsStaticMemberExpression
	| JsSuperExpression
	| JsThisExpression
	| JsUnaryExpression
	| JsPreUpdateExpression
	| JsPostUpdateExpression
	| JsYieldExpression
	| Template
	| NewExpr
	| CallExpr
	| NewTarget
	| ImportMeta
	| TsNonNull
	| TsAssertion
	| TsConstAssertion
	| JsUnknownExpression


// the backtick is just a placeholder, there's
Template = '`'

JsThisExpression = 'this'

JsSuperExpression = 'super'

// new expression
NewExpr = 'new' type_args:TsTypeArgs? object:JsAnyExpression arguments:ArgList

// call expression
CallExpr = type_args:TsTypeArgs? callee:JsAnyExpression arguments:ArgList


JsAwaitExpression =
	'await'
	argument: JsAnyExpression


JsYieldExpression =
	'yield'
	'*'?
	argument: JsAnyExpression?

JsImportCallExpression =
	'import'
	'('
	argument: JsAnyExpression
	')'

// new target expression
NewTarget = 'new' '.' 'target'


JsConditionalExpression =
	test: JsAnyExpression
	'?'
	manual__consequent: JsAnyExpression
	':'
	manual__alternate: JsAnyExpression

// import meta expression
ImportMeta = 'import' '.'

JsFunctionExpression =
	'async'?
	'function'
	'*'?
	id: JsIdentifierBinding?
	type_parameters: TsTypeParams?
	parameters: JsParameterList
	return_type: TsTypeAnnotation?
	body: JsFunctionBody


JsArrowFunctionExpression =
	'async'?
	type_parameters: TsTypeParams?
	parameter_list: JsAnyArrowFunctionParameters?
	'=>'
	return_type: TsTypeAnnotation?
	manual__body: JsAnyArrowFunctionBody

JsAnyArrowFunctionParameters = JsParameterList | JsIdentifierBinding
JsAnyArrowFunctionBody = JsAnyExpression | JsFunctionBody

// Array expression\
JsArrayExpression =
	'['
	elements: (JsAnyArrayElement (',' JsAnyArrayElement)* ','?)
	']'

JsAnyArrayElement =
	JsAnyExpression
	| SpreadElement
	| JsArrayHole

JsArrayHole = manual__hole: ''

JsAssignmentExpression =
  left: JsAnyAssignmentTarget
  operator_token: (
		'=' |'+=' | '-=' | '*=' | '%=' |
		'**=' | '>>=' | '<<=' | '>>>=' | '&=' |
		'|=' | '^=' | '&&=' | '||=' | '??='
  )
  right: JsAnyExpression


PatternOrExpr = Pattern | JsAnyExpression

JsSequenceExpression =
	left: JsAnyExpression
	comma: ','
	manual__right: JsAnyExpression


JsParenthesizedExpression =
	'(' expression: JsAnyExpression ')'

// a.b
// a.#b
JsStaticMemberExpression =
	object: JsAnyExpression
	operator: ('.' | '?.')
	member: JsAnyReferenceMember

// a[b]
JsComputedMemberExpression =
	object: JsAnyExpression
	optional_chain_token: '?.'?
	'['
	manual__member: JsAnyExpression
	']'

JsBinaryExpression =
    left: JsAnyExpression
    operator: (
    	'<' | '>' | '<=' | '>=' | '==' | '===' | '!=' | '!=='
    	| '+' | '-' | '*' | '/' | '%' | '**' | '<<' | '>>' | '>>>'
    	| '&' | '|' | '^' | 'in' | 'instanceof'
		)
    manual__right: JsAnyExpression

JsLogicalExpression =
	left: JsAnyExpression
	operator: ('??' | '||' | '&&')
	manual__right: JsAnyExpression

// unary expression
JsUnaryExpression =
  operator: ('delete' | 'void' | 'typeof' | '+' | '-' | '~' | '!')
  argument: JsAnyExpression

JsPreUpdateExpression =
    operator: ('++' | '--')
    operand: JsAnySimpleAssignmentTarget

JsPostUpdateExpression =
    operand: JsAnySimpleAssignmentTarget
    operator: ('++' | '--')


///////////////
// OBJECTS
///////////////
JsAnyObjectMemberName =
	JsLiteralMemberName
	| JsComputedMemberName

JsObjectExpression =
	'{'
	members: (JsAnyObjectMember (',' JsAnyObjectMember)* ','?)
	'}'

JsAnyObjectMember =
	JsPropertyObjectMember
	| JsMethodObjectMember
	| JsGetterObjectMember
	| JsSetterObjectMember
	| InitializedProp // TODO #1725 Delete after finishing assignment targets work
	| JsShorthandPropertyObjectMember
	| JsSpread
	| JsUnknownMember


// { a: 5, b: () => {} }
//   ^^^^  ^^^^^^^^^^^
JsPropertyObjectMember =
	name: JsAnyObjectMemberName
	':'
	manual__value: JsAnyExpression

// { get a() {} }
//   ^^^^^^^^^^
JsGetterObjectMember =
	'get'
	name: JsAnyObjectMemberName
	'('')'
	return_type: TsTypeAnnotation?
	body: JsFunctionBody

//  { set a(value) {} }
//    ^^^^^^^^^^^^^^^
JsSetterObjectMember =
	'set'
	name: JsAnyObjectMemberName
	'('
	parameter: Pattern
	')'
	body: JsFunctionBody

// { a() {}, async b() {}, async * c() {} }
//   ^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^^^^
JsMethodObjectMember =
	'async'?
	'*'?
	name: JsAnyObjectMemberName
	type_params: TsTypeParams?
	parameter_list: JsParameterList
	return_type: TsTypeAnnotation?
	body: JsFunctionBody

// { a }
//   ^
JsShorthandPropertyObjectMember = name: JsReferenceIdentifierExpression

// TODO #1725 Delete after finishing work around Classes & Assignment targets
PropName =
	JsComputedMemberName
	| JsStringLiteralExpression
	| JsNumberLiteralExpression
	| Ident
	| Name
	| JsUnknownBinding

// initialised property
InitializedProp = key:Name '=' value:JsAnyExpression

///////////////
// CLASSES
///////////////

JsClassDeclaration  =
	'class'
	id: JsIdentifierBinding
	implements_clause: TsImplementsClause?
	extends_clause: JsExtendsClause?
	'{'
	members: JsAnyClassMember*
	'}'

JsClassExpression =
	'class'
	id: JsIdentifierBinding?
	extends_clause: JsExtendsClause?
	'{'
	members: JsAnyClassMember*
	'}'

TsImplementsClause =
	'implements'
	interfaces: (TsExprWithTypeArgs (',' TsExprWithTypeArgs)*)

// class Test extends A {}
//            ^^^^^^^^^
JsExtendsClause =
	'extends'
	super_class: JsAnyExpression

// class Test { #test; }
//              ^^^^^
JsPrivateClassMemberName = '#' id: 'ident'

JsAnyClassMemberName =
	JsLiteralMemberName
	| JsComputedMemberName
	| JsPrivateClassMemberName

JsAnyClassMember =
	JsConstructorClassMember
	| JsPropertyClassMember
	| JsMethodClassMember
	| JsGetterClassMember
	| JsSetterClassMember
	| JsEmptyClassMember
	| TsIndexSignature
	| JsUnknownMember

// class Test { constructor() {} }
//              ^^^^^^^^^^^^^^^^
// class Test { "constructor"() {} }
//              ^^^^^^^^^^^^^^^^^^
// class Test { 'constructor'() {} }
//              ^^^^^^^^^^^^^^^^^^
JsConstructorClassMember =
	access_modifier: TsAccessibility?
	name: JsLiteralMemberName
	parameter_list: JsConstructorParameterList
	body: JsFunctionBody

JsConstructorParameterList =
	'('
	parameters: (JsAnyConstructorParameter (',' JsAnyConstructorParameter)* ','?)
	')'

JsAnyConstructorParameter =
	TsConstructorParam
	| Pattern

// class Test { a; b = 1; static c; }
//              ^^ ^^^^^^ ^^^^^^^^^
JsPropertyClassMember =
	'declare'?
	access_modifier: TsAccessibility?
	'abstract'?
	'static'?
	name: JsAnyClassMemberName
	'?'?
	'!'?
	type: TsTypeAnnotation?
	value: JsEqualValueClause?
	';'?

// class Test { a() {} }
//              ^^^^^^
JsMethodClassMember =
	access_modifier: TsAccessibility?
	'static'?
	'abstract'?
	'async'?
	'*'?
	name: JsAnyClassMemberName
	type_parameters: TsTypeParams?
	parameter_list: JsParameterList
	return_type: TsTypeAnnotation?
	body: JsFunctionBody

// class Test { get a() {} }
//              ^^^^^^^^^^
JsGetterClassMember =
	access_modifier: TsAccessibility?
	'abstract'?
	'static'?
	'get'
	name: JsAnyClassMemberName
	'(' ')'
	return_type: TsTypeAnnotation?
	body: JsFunctionBody

// class Test { set a(v) {} }
//              ^^^^^^^^^^^
JsSetterClassMember =
	access_modifier: TsAccessibility?
	'abstract'?
	'static'?
	'set'
	name: JsAnyClassMemberName
	'('
	parameter: Pattern
	')'
	body: JsFunctionBody

JsEmptyClassMember = ';'

///////////////
// ASSIGNMENT TARGETS
///////////////

JsAnyAssignmentTarget =
	JsAnySimpleAssignmentTarget
	| JsArrayAssignmentTarget
	| JsObjectAssignmentTarget

JsAnySimpleAssignmentTarget =
	JsIdentifierAssignmentTarget
	| JsStaticMemberAssignmentTarget
	| JsComputedMemberAssignmentTarget
	| JsParenthesizedAssignmentTarget

JsAssignmentTargetWithDefault =
	target: JsAnyAssignmentTarget
	'='
	default: JsAnyExpression

JsParenthesizedAssignmentTarget =
	'('
	target: JsAnySimpleAssignmentTarget
	')'

// b = "test"
// ^
JsIdentifierAssignmentTarget = name: 'ident'

// a.b = a.#b = "test"
// ^^^   ^^^^
JsStaticMemberAssignmentTarget =
	object: JsAnyExpression
	'.'
	member: JsAnyReferenceMember

// a['b'] = a[expr] = "test"
// ^^^^^^   ^^^^^^^
JsComputedMemberAssignmentTarget =
	object: JsAnyExpression
	'['
	member: JsAnyExpression
	']'

// [a, b = "b"", ...rest] = bar
// ^^^^^^^^^^^^^^^^^^^^^^
JsArrayAssignmentTarget =
	'['
	elements: (JsAnyArrayAssignmentTargetElement (',' JsAnyArrayAssignmentTargetElement)* ','?)
	']'

JsAnyArrayAssignmentTargetElement =
	JsAssignmentTargetWithDefault
	| JsAnyAssignmentTarget
	| JsArrayAssignmentTargetRestElement
	| JsArrayHole

// [a, b, ...rest] = [];
//        ^^^^^^^
JsArrayAssignmentTargetRestElement =
	'...'
	target: JsAnyAssignmentTarget

// ({a, b: x, ...rest} = c)
//  ^^^^^^^^^^^^^^^^^^
JsObjectAssignmentTarget =
	'{'
	properties: (JsAnyPropertyAssignmentTarget (',' JsAnyPropertyAssignmentTarget)* ','?)
	'}'

JsAnyPropertyAssignmentTarget =
	JsShorthandPropertyAssignmentTarget
	| JsObjectPropertyAssignmentTarget
	| JsObjectRestPropertyAssignmentTarget

// ({ x } = b) or ({ x = "test" } = b)
//    ^              ^^^^^^^^^^
JsShorthandPropertyAssignmentTarget =
	identifier: JsIdentifierAssignmentTarget
	init: JsEqualValueClause?

// ({ x: a } = b) or ({ x: a = "test" } = b)
//    ^^^^              ^^^^^^^^^^^^^
JsObjectPropertyAssignmentTarget =
	member: JsReferenceIdentifierMember
	':'
	target: JsAnyAssignmentTarget
	init: JsEqualValueClause?

// ({ a, ...b } = a)
//       ^^^^
JsObjectRestPropertyAssignmentTarget =
	'...'
	target: JsAnySimpleAssignmentTarget

///////////////
// LITERALS
///////////////

JsAnyLiteralExpression =
	JsStringLiteralExpression
	| JsNumberLiteralExpression
	| JsBigIntLiteralExpression
	| JsBooleanLiteralExpression
	| JsNullLiteralExpression
	| JsRegexLiteralExpression

// "abcd" | 'abcd'
JsStringLiteralExpression = value: 'js_string_literal'

// 4, 5.5, 0x00, ...
JsNumberLiteralExpression = value: 'js_number_literal'

// 45n
JsBigIntLiteralExpression =  value: 'js_big_int_literal'

// true, false
JsBooleanLiteralExpression = value_token: ('true' | 'false')

// null
JsNullLiteralExpression = value: 'null'

JsRegexLiteralExpression = value: 'js_regex_literal'


///////////////
// PATTERNS
///////////////

Pattern =
	SinglePattern
	| RestPattern
	| AssignPattern
	| ObjectPattern
	| ArrayPattern
	| ExprPattern
	| JsUnknownPattern

// single pattern
SinglePattern
	= name:Name '?'? '!'? ty: TsTypeAnnotation?

// rest pattern
RestPattern = '...' pat:Pattern

// array pattern
ArrayPattern = '[' elements:Pattern* ']' '!' ty: TsTypeAnnotation?

// object pattern
ObjectPattern = '{' elements:(ObjectPatternProp (',' ObjectPatternProp)* ','?) '}'

// object pattern prop
ObjectPatternProp =
	AssignPattern
	| KeyValuePattern
	| RestPattern
	| SinglePattern
	| JsUnknownPattern

// assign pattern
AssignPattern = key:Pattern ty: TsTypeAnnotation? '=' value:JsAnyExpression

// key value pattern
KeyValuePattern = key:PropName ':' manual__value:Pattern


// expression pattern
ExprPattern = expr: JsAnyExpression

///////////////
// MISCELLANEOUS
///////////////

SpreadElement = '...' element:JsAnyExpression

Name = 'ident'

JsReferenceIdentifierExpression = name: 'ident'

///////////////
// DECLARATIONS
///////////////

JsFunctionDeclaration =
	'async'?
	'function'
	'*'?
	id: JsIdentifierBinding
	type_parameters: TsTypeParams?
	parameter_list: JsParameterList
	return_type: TsTypeAnnotation?
	body: JsFunctionBody

TsTypeAnnotation =
	':'
	type: TsType

JsVariableDeclarationStatement =
    declaration: JsVariableDeclaration ';'?

JsVariableDeclaration =
    kind_token: ('var' | 'const' | 'let')
    declarators: (JsVariableDeclarator (',' JsVariableDeclarator)*)

JsVariableDeclarator =
		// TODO #1725 change to `JsAnyBinding`
    id: Pattern
    init: JsEqualValueClause?


///////////////
// MODULE SYNTAX
///////////////

ImportDecl =
	'import'
	imports:ImportClause*
	'type'?
	'from'
	source: 'js_string_literal'
	asserted_object: JsObjectExpression
	'assert'?
	';'?

// export default declaration
ExportDefaultDecl = 'export' 'default'? 'type'? decl:DefaultDecl
DefaultDecl =
	JsFunctionDeclaration
	| JsClassDeclaration


// export default expression
ExportDefaultExpr = 'export' 'type'? 'default'? expr:JsAnyExpression

// export wildcard
ExportWildcard = 'export' 'type'? '*' 'as'? ident: Ident? 'from' source: 'js_string_literal'


// export declaration
ExportDecl = 'export' 'type'? decl: JsAnyExportDeclaration

JsAnyExportDeclaration =
	JsFunctionDeclaration
	| JsClassDeclaration
	| JsVariableDeclarationStatement
	| TsEnum
	| TsTypeAliasDecl
	| TsNamespaceDecl
	| TsModuleDecl
	| TsInterfaceDecl


// typescript export assignment
TsExportAssignment = 'export' '=' expr: JsAnyExpression ';'?


// typescript namespace export
TsNamespaceExportDecl = 'export' 'as' 'namespace' ident: Ident? ';'?

ImportClause =
	WildcardImport
	| NamedImports
	| Name
	| ImportStringSpecifier


NamedImports = '{' specifiers:(Specifier (',' Specifier)* ','?) '}'


Specifier = name:Ident manual__:'as'? manual__alias:Name


// this is not currently implemented in rslint parser
ImportStringSpecifier = source: 'js_string_literal'


WildcardImport = '*' 'as'? ident: Ident?

// @ematipico this one is not entirely correct I think..
ExportNamed = 'export' 'type'? 'from'?  '{' specifiers:(Specifier (',' Specifier)* ','?) * '}'

///////////////
// BINDINGS
///////////////

// Binds a value to an identifier.
// let x = OR function(test) {}
//     ^               ^^^^
JsIdentifierBinding = name: 'ident'

///////////////
// AUXILIARY
///////////////

// { ...a }
//   ^^^^
// [ ...a ]
//   ^^^^
JsSpread =
	'...'
	argument: JsAnyExpression


// { a: ..., "b": ..., 4: ... }
//   ^       ^^^       ^
JsLiteralMemberName = value: ('ident' | 'js_string_literal' | 'js_number_literal')

// { [call()]: ... }
//   ^^^^^^^^
JsComputedMemberName =
	'['
	expression: JsAnyExpression
	']'


JsAnyReferenceMember =
	JsReferenceIdentifierMember
	| JsReferencePrivateMember

// A reference to a member
// a.b
//   ^
// let { b: c } = a
//       ^
JsReferenceIdentifierMember =
	name: 'ident'

// A reference to a private member
// a.#b
//   ^^
// let { #b: c } = a
//       ^^
JsReferencePrivateMember =
	'#'
	name: 'ident'


JsParameterList =
	'('
	parameters: (JsAnyParameter (',' JsAnyParameter)* ','?)
	')'

JsAnyParameter = Pattern | JsRestParameter

JsRestParameter =
	'...'
	binding: Pattern

ArgList = '(' args:(JsAnyExpression (',' JsAnyExpression)* ','?) ')'


// let a = 10;
//       ^^^^
// class { a = 10; }
//           ^^^^
JsEqualValueClause =
	'='
	expression: JsAnyExpression

JsFunctionBody =
	'{'
	directives: JsDirective*
	statements: JsAnyStatement*
	'}'

///////////////
// TYPESCRIPT
///////////////
//
// Below here we want to keep all the TypeScript types
// Typescript definitions
//

TsImportEqualsDecl =
	('import' | 'export') ident: Ident '=' module:TsModuleRef ';'?


TsModuleRef =
	TsExternalModuleRef |
	TsEntityName


TsExternalModuleRef = 'require' '(' module: 'js_string_literal' ')'

TsType =
	TsAny
	| TsUnknown
	| TsNumber
	| TsObject
	| TsBoolean
	| TsBigint
	| TsString
	| TsSymbol
	| TsVoid
	| TsUndefined
	| TsNull
	| TsNever
	| TsThis
	| TsLiteral
	| TsPredicate
	| TsTuple
	| TsParen
	| TsTypeRef
	| TsTemplate
	| TsMappedType
	| TsImport
	| TsArray
	| TsIndexedArray
	| TsTypeOperator
	| TsIntersection
	| TsUnion
	| TsFnType
	| TsConstructorType
	| TsConditionalType
	| TsObjectType
	| TsInfer


TsAny = 'any'
TsUnknown = 'unknown'
TsNumber = ident: Ident
TsObject = ident: Ident
TsBoolean = ident: Ident
TsBigint = ident: Ident
TsString = ident: Ident
TsSymbol = ident: Ident
TsVoid = 'void'
TsUndefined = 'undefined'
TsNull= 'null'
TsNever = 'never'
TsThis = 'this'
TsLiteral = ident: Ident


// typescript tuples
TsTuple = '[' elements:TsTupleElement ']'
// @ematipico: this is ugly and it's here only to maintain compatibility
// with the current parser API
TsTupleElement = ident: Ident ':' '?' '...'? ty:TsType

TsParen = '(' ty:TsType ')'

// typescript type reference
TsTypeRef = name:TsEntityName type_args:TsTypeArgs


// typescript enum
TsEnum = 'const'? 'enum'  ident: Ident '{' members:TsEnumMember* '}'
TsEnumMember = ident: Ident '=' value:JsAnyExpression

// typescript template literal types
TsTemplate = elements:TsTemplateElement
// @ematipico: this is broken and it's here only for compatibility
TsTemplateElement = ty:TsType '}'


// typescript mappend type
// plus and minus should be mutually exclusive
TsMappedType =
	'{'
	readonly_modifier:TsMappedTypeReadonly?
	'-'?
	'+'?
	'?'?
	param:TsMappedTypeParam
	':'
	ty:TsType
	'}'
	';'?

TsMappedTypeReadonly = '-'? '+'? 'readonly'?

// @ematipico: this type is correct and it's here only for compatibility
TsMappedTypeParam = '['? name:TsTypeName? ']'? ident: Ident? ty:TsType


// typescript array
TsArray = '[' ty:TsType ']'

// typescript indexed array
TsIndexedArray = '[' ty:TsType ']'


// typescript predicate
TsPredicate = lhs:TsThisOrMore rhs:TsType
TsThisOrMore = TsThis | TsTypeName

// typescript type operator
TsTypeOperator = ty:TsType

// typescript intersection
// @ematipico this one should contains the "|" operator
TsIntersection = types:TsType*

// typescript union
// @ematipico this one should contains the "&" operator
TsUnion = types:TsType*


// typescript function type
// Example: (something: String) => bool
TsFnType = params:JsParameterList '=>' return_type:TsType?


// typescript constructor type
// Exapmle: new (something: String): SomethingElse
TsConstructorType = 'new' params:JsParameterList ':' return_type:TsType?


// typescript conditional type
// @ematipico example? can't understand what grammar it is
TsConditionalType = ty:TsType '?' ':' extends:TsExtends
TsExtends = 'extends' ty:TsType


// typescript object type
TsObjectType = '{' members:TsTypeElement* '}'


// typescript infer
TsInfer = 'infer' ident: Ident

// typescript import
// @ematipico not sure where the dot token should be placed
// @ematipico not sure where type_args should be placed
// TsImport = 'import' '(' qualifier:TsEntityName '.' ')' type_args:TsTypeArgs


// typescrit namesapce
// TODO: not sure where to put the dot
// https://github.com/rome/tools/issues/1729
TsNamespaceDecl = 'declare' ident: Ident '.'? body: TsNamespaceBody
TsNamespaceBody = TsModuleBlock | TsNamespaceDecl
TsModuleBlock = '{' items: JsAnyStatement '}'


// type alias declaration
TsTypeAliasDecl = 'type' type_params:TsTypeParams '=' ty:TsType
TsTypeParams = '<'? params:TsTypeParam '>'?
TsTypeParam = ident: Ident constraint:TsConstraint default:TsDefault

TsDefault = '=' ty:TsType
TsConstraint = 'extends' ty:TsType



// typescript module declaration
// TODO: where does the dot go exactly?
TsModuleDecl = 'declare' 'global'? 'module' '.'? ident: Ident body:TsNamespaceBody


// typescript interface declaration
// TODO: extends and its children should be optional, together
TsInterfaceDecl =
	'declare'? 'interface' type_params:TsTypeParams
	'extends'? extends:TsExprWithTypeArgs?
	'{' members:TsTypeElement '}'


TsExprWithTypeArgs = item:TsEntityName type_params:TsTypeArgs
TsTypeElement =
	TsCallSignatureDecl
	| TsConstructSignatureDecl
	| TsPropertySignature
	| TsMethodSignature
	| TsIndexSignature

TsEntityName =
	TsTypeName
	| TsQualifiedPath

TsTypeName = ident: Ident
TsQualifiedPath = lhs:TsEntityName '.' rhs:TsTypeName


TsTypeArgs = '<' args:TsType '>'


// @ematipico we should make an example here
TsCallSignatureDecl =  type_params:TsTypeParams parameters:JsParameterList  ':' return_type:TsType
TsConstructSignatureDecl =
	'new'
	type_params:TsTypeParams
	parameters:JsParameterList
	// these two should be optional together
	':'? return_type:TsType

// typescript property signature
TsPropertySignature = 'readonly'? prop:JsAnyExpression '?' ':' ty:TsType

// typescript method signature
TsMethodSignature =
	'readonly'?
	key:JsAnyExpression
	type_params:TsTypeParams
	parameters:JsParameterList
	'?'?
	':'
	return_type:TsType

// @ematipico not sure where the dot goes here
TsImport = 'import' type_args:TsTypeArgs '.'? '(' qualifier:TsEntityName ')'

// typescript index signature
TsIndexSignature = 'readonly'? '[' pat:SinglePattern ':' ty:TsType ']'

// typescript type of access
TsAccessibility = 'private' | 'readonly'


TsConstructorParam = 'readonly' pat:Pattern

TsNonNull = expr:JsAnyExpression '!'

TsAssertion = expr:JsAnyExpression ident: Ident '<' ty:TsType '>'

TsConstAssertion = expr:JsAnyExpression ident: Ident '<' 'const' '>'
