// Javascript Un-Grammar.
//
// This grammar specifies the structure of Rust's concrete syntax tree.
// It does not specify parsing rules (ambiguities, precedence, etc are out of scope).
// Tokens are processed -- contextual keywords are recognised, compound operators glued.
//
// Legend:
//
//   //          				-- comment
//   Name =      				-- non-terminal definition
//   'ident'     				-- token (terminal)
//   A B         				-- sequence
//   A | B       				-- alternation
//   A*          				-- zero or more repetition
//   (A (',' A)* ','?)	        -- repetition of node A separated by ',' and allowing a trailing comma
//   (A (',' A)*)	            -- repetition of node A separated by ',' without a trailing comma
//   A?          				-- zero or one repetition
//   (A)         				-- same as A
//   label:A     				-- suggested name for field of AST node

// NOTES
//
// - "manual__" prefix is used to _exclude_ those method from being autogenerated
//   and they will be manually implemented
// - SyntaxNode, SyntaxToken and SyntaxElement will be stripped from the codegen
// - Unknown nodes are special nodes used to keep track of broken code; they are
//   not part of the grammar but they will appear inside the green tree
//


///////////////
// UNKNOWN NODES
///////////////
// SyntaxElement is a generic data structure that is meant to track nodes and tokens
// in cases where we care about both types
//
// As Unknown* node will need to yield both tokens and nodes without discrimition,
// and their children will need to yield nodes and tokens as well.
// For this reason, SyntaxElement = SyntaxElement
SyntaxElement = SyntaxElement

JsUnknownStatement = SyntaxElement*
JsUnknownExpression = SyntaxElement*
JsUnknownPattern = SyntaxElement*
JsUnknownMember = SyntaxElement*
JsUnknownBinding = SyntaxElement*
JsUnknownAssignmentTarget = SyntaxElement*

Ident = 'ident'

JsRoot =
	interpreter: 'js_shebang'?
	directives: JsDirective*
	statements: JsAnyStatement*

JsDirective =
	value: 'js_string_literal_token'
	';'?

///////////////
// STATEMENTS
///////////////

JsAnyStatement =
	JsBlockStatement
	| JsEmptyStatement
	| JsExpressionStatement
	| JsIfStatement
	| JsDoWhileStatement
	| JsWhileStatement
	| ForStmt
	| ForInStmt
	| ForOfStmt
	| JsContinueStatement
	| JsBreakStatement
	| JsReturnStatement
	| JsWithStatement
	| JsLabeledStatement
	| JsSwitchStatement
	| JsThrowStatement
	| JsTryStatement
	| JsTryFinallyStatement
	| JsDebuggerStatement
	| Decl
	| ImportDecl
	| ExportNamed
	| ExportDefaultDecl
	| ExportDefaultExpr
	| ExportWildcard
	| ExportDecl
	| TsImportEqualsDecl
	| TsExportAssignment
	| TsNamespaceExportDecl
	| JsUnknownStatement


JsBlockStatement =
	'{'
	statements: JsAnyStatement*
	'}'


JsEmptyStatement =
    ';'

JsExpressionStatement =
    expression: JsAnyExpression ';'?


JsWhileStatement =
    'while' '(' test: JsAnyExpression ')'
    body: JsAnyStatement


JsDoWhileStatement =
    'do'
    body: JsAnyStatement
    'while' '(' test: JsAnyExpression ')'
    ';'?


// if statement
JsIfStatement =
	'if' '(' test: JsAnyExpression ')'
	consequent: JsAnyStatement
	else_clause: JsElseClause?

JsElseClause =
	'else'
	alternate: JsAnyStatement


// for..in statement
ForStmt =
	'for'
	'('
	init:ForStmtInit?
	test:ForStmtTest?
	update:ForStmtUpdate?
	')'
	cons:JsAnyStatement

ForStmtInit = inner:ForHead ';'
ForHead = JsVariableDeclaration | JsAnyExpression

ForStmtTest = expr:JsAnyExpression ';'

ForStmtUpdate = expr:JsAnyExpression


// for..in statement
ForInStmt = 'for' '(' left:ForStmtInit 'in' right:JsAnyExpression ')' cons:JsAnyStatement

// for..of statement
ForOfStmt = 'for' '(' left:ForStmtInit 'of' right:JsAnyExpression ')' cons:JsAnyStatement


JsBreakStatement =
    'break'
    (label: 'ident')?
    ';'?

JsContinueStatement =
    'continue'
    (label: 'ident')?
    ';'?


JsReturnStatement =
    'return'
    argument: JsAnyExpression?
    ';'?


JsWithStatement =
    'with' '(' object: JsAnyExpression ')'
    body: JsAnyStatement


JsLabeledStatement =
    label: 'ident' ':'
    body: JsAnyStatement


JsSwitchStatement =
    'switch' '(' discriminant: JsAnyExpression ')'
    '{'
    cases: JsAnySwitchClause*
    '}'

JsAnySwitchClause = JsCaseClause | JsDefaultClause
JsCaseClause = 'case' test: JsAnyExpression ':' consequent: JsAnyStatement*
JsDefaultClause = 'default' ':' consequent: JsAnyStatement*


JsThrowStatement =
    'throw'
    argument: JsAnyExpression
    ';'?

// try..catch..finally statement
JsTryStatement =
    'try'
    body: JsBlockStatement
    catch_clause: JsCatchClause

JsTryFinallyStatement =
    'try'
    body: JsBlockStatement
    catch_clause: JsCatchClause?
    finally_clause: JsFinallyClause

JsCatchClause =
    'catch'
    declaration: JsCatchDeclaration?
    body: JsBlockStatement

JsCatchDeclaration =
    '(' binding: Pattern ')'

JsFinallyClause =
    'finally'
    body: JsBlockStatement


// debugger statement
JsDebuggerStatement =
	'debugger' ';'?


///////////////
// EXPRESSIONS
///////////////

// Expression
JsAnyExpression =
	JsAnyLiteral
	| JsArrayExpression
	| JsAwaitExpression
	| JsBinaryExpression
	| JsConditionalExpression
	| JsImportCallExpression
	| JsLogicalExpression
	| JsParenthesizedExpression
	| JsReferenceIdentifierExpression
	| JsSequenceExpression
	| JsThisExpression
	| JsUnaryExpression
	| JsPreUpdateExpression
	| JsPostUpdateExpression
	| JsYieldExpression
	| ArrowExpr
	| Template
	| ObjectExpr
	| BracketExpr
	| DotExpr
	| NewExpr
	| CallExpr
	| AssignExpr
	| FnExpr
	| ClassExpr
	| NewTarget
	| ImportMeta
	| SuperCall
	| PrivatePropAccess
	| TsNonNull
	| TsAssertion
	| TsConstAssertion
	| JsUnknownExpression


// the backtick is just a placeholder, there's
Template = '`'

JsThisExpression = 'this'

// Dot expression
// TODO: review the 'super' token
// https://github.com/rome/tools/issues/1729
DotExpr = 'super'? object:JsAnyExpression '.' prop:Name

// new expression
NewExpr = 'new' type_args:TsTypeArgs? object:JsAnyExpression arguments:ArgList

// call expression
CallExpr = type_args:TsTypeArgs? callee:JsAnyExpression arguments:ArgList


JsAwaitExpression =
	'await'
	argument: JsAnyExpression


JsYieldExpression =
	'yield'
	'*'?
	argument: JsAnyExpression?

// super call expression
SuperCall = 'super' arguments:ArgList

JsImportCallExpression =
	'import'
	'('
	argument: JsAnyExpression
	')'

// new target expression
NewTarget = 'new' '.' 'target'


JsConditionalExpression =
	test: JsAnyExpression
	'?'
	manual__consequent: JsAnyExpression
	':'
	manual__alternate: JsAnyExpression

// import meta expression
ImportMeta = 'import' '.'

// function expression
FnExpr =
	'async'?
	'function'
	'*'?
	name:Name
	type_params:TsTypeParams?
	parameters:ArgList
	':'?
	return_type:TsType?
	body:JsFunctionBody

// Arrow expression
ArrowExpr =
	'async'?
	type_params:TsTypeParams?
	params:ArrowExprParams?
	'=>'
	':'?
	return_type:TsType?
	manual__body:ExprOrBlock

ArrowExprParams =
	Name
	| ParameterList

// Object expression
ObjectExpr = '{' props:(ObjectProp (',' ObjectProp)* ','?) '}'

// class expression
ClassExpr =
	'class'
	name: Name
	type_params:TsTypeParams?
	parent:JsAnyExpression?
	'implements'?
	implements:TsExprWithTypeArgs?
	body:ClassBody

ClassBody =  '{' elements:ClassElement* '}'


ClassElement =
	JsEmptyStatement
	| Method
	// probably PrivateProp is not needed
	| PrivateProp
	| ClassProp
	| Constructor
	| TsIndexSignature
	| Getter
	| Setter
	| JsUnknownMember

Constructor =
	accessibility:TsAccessibility?
	name:PropName
	type_params:TsTypeParams?
	parameters:ParameterList
	body:JsFunctionBody


ConstructorParameters =
		'(' parameters:(ConstructorParamOrPat (',' ConstructorParamOrPat)* ','?) ')'


ConstructorParamOrPat =
	TsConstructorParam
	| Pattern



// This type is here only to matain compatiblity with rslit_parser
// A private property should only have the hash (#) or have the
// keyword `private` in the typescript version
PrivateProp = class_prop: ClassProp
// @ematipico: they way it's written now is awful and can be improved a lot
ClassProp =
	'declare'?
	'abstract'?
	'static'?
	accessibility:TsAccessibility?
	'#'?
	key:PropName
	'?'?
	'!'?
	ty:TsType
	'='?
	value:JsAnyExpression?
	';'?

// Array expression\
JsArrayExpression =
	'['
	elements: (JsAnyArrayElement (',' JsAnyArrayElement)* ','?)
	']'

JsAnyArrayElement =
	JsAnyExpression
	| SpreadElement
	| JsArrayHole

JsArrayHole = manual__hole: ''

// assign expression
AssignExpr =
  manual__lhs:PatternOrExpr
  operator:(
		'=' |'+=' | '-=' | '*=' | '%=' |
		'**=' | '>>=' | '<<=' | '>>>=' | '&=' |
		'|=' | '^=' | '&&=' | '||=' | '??='
  )
  manual__rhs:PatternOrExpr


PatternOrExpr = Pattern | JsAnyExpression

JsSequenceExpression =
	left: JsAnyExpression
	comma: ','
	manual__right: JsAnyExpression


JsParenthesizedExpression =
	'(' expression: JsAnyExpression ')'

// bracket expression
BracketExpr =  'super'? manual__object:JsAnyExpression '[' manual__prop:JsAnyExpression ']'


JsBinaryExpression =
    left: JsAnyExpression
    operator: (
    	'<' | '>' | '<=' | '>=' | '==' | '===' | '!=' | '!=='
    	| '+' | '-' | '*' | '/' | '%' | '**' | '<<' | '>>' | '>>>'
    	| '&' | '|' | '^' | 'in' | 'instanceof'
		)
    manual__right: JsAnyExpression

JsLogicalExpression =
	left: JsAnyExpression
	operator: ('??' | '||' | '&&')
	manual__right: JsAnyExpression

// unary expression
JsUnaryExpression =
  operator: ('delete' | 'void' | 'typeof' | '+' | '-' | '~' | '!')
  argument: JsAnyExpression

JsPreUpdateExpression =
    operator:('++' | '--')
    operand:JsAnyExpression

JsPostUpdateExpression =
    operand:JsAnyExpression
    operator:('++' | '--')


///////////////
// LITERALS
///////////////

JsAnyLiteral =
	JsStringLiteral
	| JsNumberLiteral
	| JsBigIntLiteral
	| JsBooleanLiteral
	| JsNullLiteral
	| JsRegexLiteral

// "abcd" | 'abcd'
JsStringLiteral = value: 'js_string_literal_token'

// 4, 5.5, 0x00, ...
JsNumberLiteral = value: 'js_number_literal_token'

// 45n
JsBigIntLiteral =  value: 'js_big_int_literal_token'

// true, false
JsBooleanLiteral = value_token: ('true' | 'false')

// null
JsNullLiteral = value: 'null'

JsRegexLiteral = value: 'js_regex_literal_token'


///////////////
// PATTERNS
///////////////

Pattern =
	SinglePattern
	| RestPattern
	| AssignPattern
	| ObjectPattern
	| ArrayPattern
	| ExprPattern
	| JsUnknownPattern

// single pattern
SinglePattern
	= name:Name '?'? '!'? ':'? ty:TsType

// rest pattern
RestPattern = '...' pat:Pattern

// array pattern
ArrayPattern = '[' elements:Pattern* ']' '!' ':' ty:TsType

// object pattern
ObjectPattern = '{' elements:(ObjectPatternProp (',' ObjectPatternProp)* ','?) '}'

// object pattern prop
ObjectPatternProp =
	AssignPattern
	| KeyValuePattern
	| RestPattern
	| SinglePattern
	| JsUnknownPattern

// assign pattern
AssignPattern = key:Pattern ':'? ty:TsType '=' value:JsAnyExpression

// key value pattern
KeyValuePattern = key:PropName ':' manual__value:Pattern


// expression pattern
ExprPattern = expr: JsAnyExpression




///////////////
// PROPS
///////////////
ObjectProp =
	LiteralProp
	| Getter
	| Setter
	| SpreadProp
	| InitializedProp
	| IdentProp
	| Method
	| JsUnknownMember


// literal prop
LiteralProp = manual__key:PropName ':' manual__value:JsAnyExpression

PropName =
	ComputedPropertyName
	| JsStringLiteral
	| JsNumberLiteral
	| Ident
	| Name
	| JsUnknownBinding


// computed property
ComputedPropertyName = '[' expr: JsAnyExpression ']'

// private property access
PrivatePropAccess = lhs:JsAnyExpression '.' rhs:PrivateName

// spread property
SpreadProp = '...' value:JsAnyExpression

// initialised property
InitializedProp = key:Name '=' value:JsAnyExpression

// property identifier
IdentProp = name: Name

///////////////
// MISCELLANEOUS
///////////////

Getter =  'get' key:PropName parameters:ParameterList  body:JsFunctionBody

Setter = 'set' key:PropName parameters:ParameterList  body:JsFunctionBody

Method =
	'static'?
	'async'?
	'*'?
	name:PropName
	type_params:TsTypeParams?
	parameters:ParameterList
	':'?
	return_type:TsType?
	body:JsFunctionBody

SpreadElement = '...' element:JsAnyExpression

PrivateName = '#' name: Name

Name = 'ident'

Condition = '(' condition:JsAnyExpression ')'

JsReferenceIdentifierExpression = name: 'ident'

///////////////
// DECLARATIONS
///////////////

Decl =
	FnDecl
	| ClassDecl
	| JsVariableDeclarationStatement
	| TsEnum
	| TsTypeAliasDecl
	| TsNamespaceDecl
	| TsModuleDecl
	| TsInterfaceDecl

FnDecl =
	'async'?
	'function'
	'*'?
	name: Name
	type_parameters:TsTypeParams?
	parameters:ParameterList
	':'?
	return_type:TsType?
	body:JsFunctionBody


JsVariableDeclarationStatement =
    declaration: JsVariableDeclaration ';'?

JsVariableDeclaration =
    kind_token: ('var' | 'const' | 'let')
    declarators: (JsVariableDeclarator (',' JsVariableDeclarator)*)

JsVariableDeclarator =
		// TODO 1725 change to `JsAnyBinding`
    id: Pattern
    init: JsEqualValueClause?

// @ematipico: should we consider ClassDecl = ClassExpr ?
ClassDecl  = 'class' name: Name ('extends' parent: JsAnyExpression)? body:ClassBody


///////////////
// MODULE SYNTAX
///////////////

ImportDecl =
	'import'
	imports:ImportClause*
	'type'?
	'from'
	source: JsStringLiteral
	asserted_object:ObjectExpr
	'assert'?
	';'?

// export default declaration
ExportDefaultDecl = 'export' 'default'? 'type'? decl:DefaultDecl
DefaultDecl =
	FnDecl
	| ClassDecl


// export default expression
ExportDefaultExpr = 'export' 'type'? 'default'? expr:JsAnyExpression

// export wildcard
ExportWildcard = 'export' 'type'? '*' 'as'? ident: Ident? 'from' source: JsStringLiteral


// export declaration
ExportDecl = 'export' 'type'? decl: Decl


// typescript export assignment
TsExportAssignment = 'export' '=' expr: JsAnyExpression ';'?


// typescript namespace export
TsNamespaceExportDecl = 'export' 'as' 'namespace' ident: Ident? ';'?

ImportClause =
	WildcardImport
	| NamedImports
	| Name
	| ImportStringSpecifier


NamedImports = '{' specifiers:(Specifier (',' Specifier)* ','?) '}'


Specifier = name:Ident manual__:'as'? manual__alias:Name


// this is not currently implemented in rslint parser
ImportStringSpecifier = 'js_string_literal_token'


WildcardImport = '*' 'as'? ident: Ident?

// @ematipico this one is not entirely correct I think..
ExportNamed = 'export' 'type'? 'from'?  '{' specifiers:(Specifier (',' Specifier)* ','?) * '}'

///////////////
// AUXILIARY
///////////////

ExprOrBlock =
	JsAnyExpression
	| JsFunctionBody

ParameterList = '(' parameters:(Pattern (',' Pattern)* ','?) ')'
ArgList = '(' args:(JsAnyExpression (',' JsAnyExpression)* ','?) ')'


// let a = 10;
//       ^^^^
// class { a = 10; }
//           ^^^^
JsEqualValueClause =
	'='
	expression: JsAnyExpression

JsFunctionBody =
	'{'
	directives: JsDirective*
	statements: JsAnyStatement*
	'}'

///////////////
// TYPESCRIPT
///////////////
//
// Below here we want to keep all the TypeScript types
// Typescript definitions
//

TsImportEqualsDecl =
	('import' | 'export') ident: Ident '=' module:TsModuleRef ';'?


TsModuleRef =
	TsExternalModuleRef |
	TsEntityName


TsExternalModuleRef = 'require' '(' 'js_string_literal_token' ')'

TsType =
	TsAny
	| TsUnknown
	| TsNumber
	| TsObject
	| TsBoolean
	| TsBigint
	| TsString
	| TsSymbol
	| TsVoid
	| TsUndefined
	| TsNull
	| TsNever
	| TsThis
	| TsLiteral
	| TsPredicate
	| TsTuple
	| TsParen
	| TsTypeRef
	| TsTemplate
	| TsMappedType
	| TsImport
	| TsArray
	| TsIndexedArray
	| TsTypeOperator
	| TsIntersection
	| TsUnion
	| TsFnType
	| TsConstructorType
	| TsConditionalType
	| TsObjectType
	| TsInfer


TsAny = 'any'
TsUnknown = 'unknown'
TsNumber = ident: Ident
TsObject = ident: Ident
TsBoolean = ident: Ident
TsBigint = ident: Ident
TsString = ident: Ident
TsSymbol = ident: Ident
TsVoid = 'void'
TsUndefined = 'undefined'
TsNull= 'null'
TsNever = 'never'
TsThis = 'this'
TsLiteral = ident: Ident


// typescript tuples
TsTuple = '[' elements:TsTupleElement ']'
// @ematipico: this is ugly and it's here only to maintain compatibility
// with the current parser API
TsTupleElement = ident: Ident ':' '?' '...'? ty:TsType

TsParen = '(' ty:TsType ')'

// typescript type reference
TsTypeRef = name:TsEntityName type_args:TsTypeArgs


// typescript enum
TsEnum = 'const'? 'enum'  ident: Ident '{' members:TsEnumMember* '}'
TsEnumMember = ident: Ident '=' value:JsAnyExpression

// typescript template literal types
TsTemplate = elements:TsTemplateElement
// @ematipico: this is broken and it's here only for compatibility
TsTemplateElement = ty:TsType '}'


// typescript mappend type
// plus and minus should be mutually exclusive
TsMappedType =
	'{'
	readonly_modifier:TsMappedTypeReadonly?
	'-'?
	'+'?
	'?'?
	param:TsMappedTypeParam
	':'
	ty:TsType
	'}'
	';'?

TsMappedTypeReadonly = '-'? '+'? 'readonly'?

// @ematipico: this type is correct and it's here only for compatibility
TsMappedTypeParam = '['? name:TsTypeName? ']'? ident: Ident? ty:TsType


// typescript array
TsArray = '[' ty:TsType ']'

// typescript indexed array
TsIndexedArray = '[' ty:TsType ']'


// typescript predicate
TsPredicate = lhs:TsThisOrMore rhs:TsType
TsThisOrMore = TsThis | TsTypeName

// typescript type operator
TsTypeOperator = ty:TsType

// typescript intersection
// @ematipico this one should contains the "|" operator
TsIntersection = types:TsType*

// typescript union
// @ematipico this one should contains the "&" operator
TsUnion = types:TsType*


// typescript function type
// Example: (something: String) => bool
TsFnType = params:ParameterList '=>' return_type:TsType?


// typescript constructor type
// Exapmle: new (something: String): SomethingElse
TsConstructorType = 'new' params:ParameterList ':' return_type:TsType?


// typescript conditional type
// @ematipico example? can't understand what grammar it is
TsConditionalType = ty:TsType '?' ':' extends:TsExtends
TsExtends = 'extends' ty:TsType


// typescript object type
TsObjectType = '{' members:TsTypeElement* '}'


// typescript infer
TsInfer = 'infer' ident: Ident

// typescript import
// @ematipico not sure where the dot token should be placed
// @ematipico not sure where type_args should be placed
// TsImport = 'import' '(' qualifier:TsEntityName '.' ')' type_args:TsTypeArgs


// typescrit namesapce
// TODO: not sure where to put the dot
// https://github.com/rome/tools/issues/1729
TsNamespaceDecl = 'declare' ident: Ident '.'? body: TsNamespaceBody
TsNamespaceBody = TsModuleBlock | TsNamespaceDecl
TsModuleBlock = '{' items: JsAnyStatement '}'


// type alias declaration
TsTypeAliasDecl = 'type' type_params:TsTypeParams '=' ty:TsType
TsTypeParams = '<'? params:TsTypeParam '>'?
TsTypeParam = ident: Ident constraint:TsConstraint default:TsDefault

TsDefault = '=' ty:TsType
TsConstraint = 'extends' ty:TsType



// typescript module declaration
// TODO: where does the dot go exactly?
TsModuleDecl = 'declare' 'global'? 'module' '.'? ident: Ident body:TsNamespaceBody


// typescript interface declaration
// TODO: extends and its children should be optional, together
TsInterfaceDecl =
	'declare'? 'interface' type_params:TsTypeParams
	'extends'? extends:TsExprWithTypeArgs?
	'{' members:TsTypeElement '}'


TsExprWithTypeArgs = item:TsEntityName type_params:TsTypeArgs
TsTypeElement =
	TsCallSignatureDecl
	| TsConstructSignatureDecl
	| TsPropertySignature
	| TsMethodSignature
	| TsIndexSignature

TsEntityName =
	TsTypeName
	| TsQualifiedPath

TsTypeName = ident: Ident
TsQualifiedPath = lhs:TsEntityName '.' rhs:TsTypeName


TsTypeArgs = '<' args:TsType '>'


// @ematipico we should make an example here
TsCallSignatureDecl =  type_params:TsTypeParams parameters:ParameterList  ':' return_type:TsType
TsConstructSignatureDecl =
	'new'
	type_params:TsTypeParams
	parameters:ParameterList
	// these two should be optional together
	':'? return_type:TsType

// typescript property signature
TsPropertySignature = 'readonly'? prop:JsAnyExpression '?' ':' ty:TsType

// typescript method signature
TsMethodSignature =
	'readonly'?
	key:JsAnyExpression
	type_params:TsTypeParams
	parameters:ParameterList
	'?'?
	':'
	return_type:TsType

// @ematipico not sure where the dot goes here
TsImport = 'import' type_args:TsTypeArgs '.'? '(' qualifier:TsEntityName ')'

// typescript index signature
TsIndexSignature = 'readonly'? '[' pat:SinglePattern ':' ty:TsType ']'

// typescript type of access
TsAccessibility = 'private' | 'readonly'


TsConstructorParam = 'readonly' pat:Pattern

TsNonNull = expr:JsAnyExpression '!'

TsAssertion = expr:JsAnyExpression ident: Ident '<' ty:TsType '>'

TsConstAssertion = expr:JsAnyExpression ident: Ident '<' 'const' '>'
