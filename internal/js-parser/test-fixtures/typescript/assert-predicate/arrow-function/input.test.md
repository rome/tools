# `index.test.ts`

**DO NOT MODIFY**. This file has been autogenerated. Run `rome test internal/js-parser/index.test.ts --update-snapshots` to update.

## `typescript > assert-predicate > arrow-function`

### `ast`

```javascript
JSRoot {
	body: [
		JSVariableDeclarationStatement {
			declaration: JSVariableDeclaration {
				kind: "const"
				declarations: [
					JSVariableDeclarator {
						id: JSBindingIdentifier {
							name: "assert1"
							loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 1:6-1:13 (assert1)
						}
						init: JSArrowFunctionExpression {
							body: JSBlockStatement {
								body: []
								directives: []
								loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 1:61-1:63
							}
							head: JSFunctionHead {
								async: false
								hasHoistedVars: false
								params: [
									JSBindingIdentifier {
										name: "value"
										meta: JSPatternMeta {
											typeAnnotation: TSUnknownKeywordTypeAnnotation {
												loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 1:24-1:31
											}
											loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 1:61-1:60
										}
										loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 1:61-1:60
									}
								]
								returnType: TSTypePredicate {
									asserts: true
									parameterName: JSIdentifier {
										name: "value"
										loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 1:42-1:47 (value)
									}
									typeAnnotation: TSStringKeywordTypeAnnotation {
										loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 1:51-1:57
									}
									loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 1:42-1:57
								}
								loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 1:16-1:60
							}
							loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 1:16-1:63
						}
						loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 1:6-1:63
					}
				]
				loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 1:0-1:63
			}
			loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 1:0-1:63
		}
		JSVariableDeclarationStatement {
			declaration: JSVariableDeclaration {
				kind: "const"
				declarations: [
					JSVariableDeclarator {
						id: JSBindingIdentifier {
							name: "assert2"
							loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 2:6-2:13 (assert2)
						}
						init: JSArrowFunctionExpression {
							body: JSBlockStatement {
								body: []
								directives: []
								loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 2:51-2:53
							}
							head: JSFunctionHead {
								async: false
								hasHoistedVars: false
								params: [
									JSBindingIdentifier {
										name: "value"
										meta: JSPatternMeta {
											typeAnnotation: TSUnknownKeywordTypeAnnotation {
												loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 2:24-2:31
											}
											loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 2:51-2:50
										}
										loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 2:51-2:50
									}
								]
								returnType: TSTypePredicate {
									asserts: true
									parameterName: JSIdentifier {
										name: "value"
										loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 2:42-2:47 (value)
									}
									loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 2:32-2:47
								}
								loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 2:16-2:50
							}
							loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 2:16-2:53
						}
						loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 2:6-2:53
					}
				]
				loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 2:0-2:53
			}
			loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 2:0-2:53
		}
		JSVariableDeclarationStatement {
			declaration: JSVariableDeclaration {
				kind: "const"
				declarations: [
					JSVariableDeclarator {
						id: JSBindingIdentifier {
							name: "assert3"
							loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 3:6-3:13 (assert3)
						}
						init: JSReferenceIdentifier {
							name: "value"
							loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 3:17-3:22 (value)
						}
						loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 3:6-3:32
					}
				]
				loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 3:0-3:32
			}
			loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 3:0-3:32
		}
		JSExpressionStatement {
			expression: JSReferenceIdentifier {
				name: "INVALID_PLACEHOLDER"
				loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 3:32-3:33
			}
			loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 3:32-3:33
		}
		JSExpressionStatement {
			expression: JSArrowFunctionExpression {
				body: JSBlockStatement {
					body: []
					directives: []
					loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 3:45-3:47
				}
				head: JSFunctionHead {
					async: false
					hasHoistedVars: false
					params: [
						JSBindingIdentifier {
							name: "asserts"
							loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 3:34-3:41 (asserts)
						}
					]
					loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 3:34-3:44
				}
				loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 3:34-3:47
			}
			loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 3:34-3:47
		}
	]
	comments: []
	corrupt: true
	diagnostics: [
		{
			origins: [{category: "parse"}]
			description: {
				advice: []
				category: ["parse"]
				categoryValue: "js"
				message: RAW_MARKUP {value: "Flow type cast expressions aren't allowed in TypeScript"}
			}
			location: {
				language: "js"
				path: UIDPath<typescript/assert-predicate/arrow-function/input.ts>
				end: Position 3:31
				start: Position 3:17
			}
		}
	]
	directives: []
	hasHoistedVars: false
	sourceType: "module"
	syntax: ["ts"]
	path: UIDPath<typescript/assert-predicate/arrow-function/input.ts>
	loc: SourceLocation typescript/assert-predicate/arrow-function/input.ts 1:0-4:0
}
```

### `diagnostics`

```

 typescript/assert-predicate/arrow-function/input.ts:3:17 parse(js) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ✖ Flow type cast expressions aren't allowed in TypeScript

    1 │ const assert1 = (value: unknown): asserts value is string => {}
    2 │ const assert2 = (value: unknown): asserts value => {}
  > 3 │ const assert3 = (value: unknown): asserts => {}
    → │                  <error><emphasis>^</emphasis></error>
    → │ <error><emphasis>^</emphasis></error><error><emphasis>^</emphasis></error>
    → │ <error><emphasis>^</emphasis></error><error><emphasis>^</emphasis></error>
    → │ <error><emphasis>^</emphasis></error><error><emphasis>^</emphasis></error>
    → │ <error><emphasis>^</emphasis></error><error><emphasis>^</emphasis></error>
    → │ <error><emphasis>^</emphasis></error><error><emphasis>^</emphasis></error>
    → │ <error><emphasis>^</emphasis></error><error><emphasis>^</emphasis></error>
      │ <error><emphasis>^</emphasis></error>


```
