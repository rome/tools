---
title: Announcing Rome v10!
description: Announcing Rome v10, the first stable release of Rome.
author_name: Micha Reiser
author_avatar: /img/blog/micha-avatar.jpg
author_url: https://twitter.com/MichaReiser
coauthor_name: Rome Team
coauthor_avatar: /img/circle-indent-logo.png
date: 2022-11-08
tags:
	- update
	- post
	- release
permalink: /blog/2022/11/08/rome-10.html
layout: layouts/blog.liquid
cover-image: formatter-cover.webp
cover-image-alt-text: Scattered Lego bricks in front of a partially assembled cube of Legos. A light beige background frames the cube with the rest of the background in black. Illustration by Toma Vagner at https://tomavagner.com.
cover-image-caption: Illustration by <a href="https://tomavagner.com">Toma Vagner</a>
social-image: social-logo-formatter.png
---

We are thrilled to announce **Rome v10**, the first stable release since the start of the [Rust rewrite](/blog/2021/09/21/rome-will-be-rewritten-in-rust.html) and the first release shipping the **Rome linter**. Rome is a fast [formatter](/blog/#announcing-rome-formatter) and linter; it requires minimal configuration, comes with beautiful and descriptive diagnostics, and has built-in support for JavaScript and TypeScript.

<!-- DESCRIPTION_END -->

To use Rome, run the following commands in a project with a `package.json`.

```bash
npm install --save-dev rome
npx rome init
```

Then format your files with `npx rome format <files>` and lint them with `npx rome check <files>`. Or install Rome's [VS Code extension](/editors) to get linting and formatting in your editor.

This blog post explains why Rome's different from other web tooling and why we're excited about our new linter.

Head to our [documentation](/docs/#getting-started) to learn how to use Rome instead.


## Background
The web development ecosystem has a rich offering of excellent tooling that fulfills different needs during the development cycle. Here is a small selection of well-known tools:

* Code formatting: Prettier, dprint
* Linting: ESLint, Stylelint,
* Test runner: Vitest, Jest, AVA
* Transpilers: Babel, SWC, TypeScript
* Bundlers: webpack, esbuild, Vite, SWC, Rollup, Parcel

It is nice to have a wide range of options. However, time spent evaluating, installing, and configuring is time spent not working on your project. Setting up your tool stack is only the start; maintaining and scaling it with your project requires expertise and continuous time investment.

Projects like [*Create React App*](https://create-react-app.dev/) (close to 100k stars) recognize this pain point and provide you with a configured development stack by composing existing tools for React. The downside of this approach is that it only partially hides the underlying tooling: Most tools use different diagnostic formats, configurations, and editor integrations.

Rome is different: It is a [monolithic](https://en.wikipedia.org/wiki/Monolithic_application) runtime-agnostic multi-language toolchain built from the ground. It is a dependency-free formatter, linter, and in the future: compiler, bundler, test runner, and [more](/#development-status). Its monolithic architecture unlocks a new developer experience that is difficult to achieve with a many-tool development stack:

* **Avoid unnecessary work**: Formatting your files with Prettier and linting them with ESLint means that both tools spend significant time traversing directories and parsing. Rome is fast because it never does the same work twice. It goes as far as to avoid reparsing a file for bundling if it already linted the file in the editor.
* **Reduce repetition**: Rome uses a single configuration for all tools to reduce the number of configuration files in your project and avoid repetition. You shouldn't have to install the React plugins and configure React support for ESLint and webpack. All it should take is to change a single configuration to enable the React lint rules, the React JSX transpilation, and FastRefresh support.
* **Learn once**: Many-tool development stacks suffer that engineers must interact with each tool, having to learn and remember the command names, configuration schemas, CLI arguments, and diagnostics formats. This is a lot to remember. It is why Rome is a single binary and standardizes its CLI arguments and diagnostic format so that you only have to learn it once.
* **Remove entry barriers**: Advanced analysis and checks, like analyzing the size of a bundle or bundle size budgeting, often require additional tools and lack editor or linter integration. This added complexity is an entry barrier for many to use the information or automate checks in their CI pipeline. Rome's editor-first design and end-to-end architecture significantly lower the barrier by bringing the information into your editor or exposing it to lint rules that can run as part of your CI.

We hope you are as excited as we are about the functionalities this architecture unlocks. However, shipping a toolchain rather than a set of tools is no guarantee for a delightful developer experience. That's why it is as important to us that each tool can stand on its own and brings additional value. The following section will walk you through our new linter and explains how it improves the developer experience.

## New Linter
Rome's linter focuses on ease of adoption, editor integration, and comprehensible diagnostics. It supports more than [60 stable rules](/docs/lint/rules) for JavaScript, TypeScript, JSX, and React and is fast; It processes 6'000 files in ~300ms [^1].

Most of Rome's rules have been inspired by their ESLint equivalents. A huge thanks to the ESLint team and community for establishing these recommended patterns. We would not have been able to pull this off without their fantastic work.

The following sections explain why error recovery is vital for a first-class editor integration and our philosophy on diagnostics.

<!-- TODO: Update benchmarks closer to release. -->

[^1]: **Test Setup** Device: MacBook Pro (13-inch, M1, 2020), Project and Revision: [9fcaa24](https://github.com/webpack/webpack/commit/9fcaa243573005d6fdece9a3f8d89a0e8b399613), Command: `hyperfine -N --warmup 5 'rome check webpack/' -i`,

### Error Recovery

An essential aspect of an editor integration is that it gracefully handles syntax errors the same as editors do. For example, syntax highlighting keeps functioning even if the code contains a syntax error. That means for linting that errors and warnings should not disappear because of an unrelated syntax error in the same file.
We created a small video that illustrates the problem by comparing ESLint's and Rome's VS Code extensions. Pay attention to how the lint promoting strict equality over `==` disappears and reappears for ESLint, where Rome always shows the error.

<figure aria-describedby="video-alt" >
	<video loop muted controls autoplay src="/img/blog/eslint-rome-comparison.mp4"/>
	<figcaption>
		The video compares Rome's and ESLint's handling of syntax errors in VS Code.
	</figcaption>
	<p class="sr-only" id="video-alt">
	The video shows VS Code with ESLint installed on the left and Rome's plugin on the right. Both editors show a lint error promoting strict equality over `==` for `if(a == b)`. The lint error disappears for ESLint when the user adds the unfinished statement `console.`. The error reappears after completing the statement to `console.log("Test")`. The Rome plugin handles the syntax error gracefully so that the lint error doesn't disappear.
	</p>
</figure>

Rome can lint files with syntax errors because of its error-tolerant parser and AST design. You can learn more about the AST design from our [Rust rewrite blog post](http://localhost:8081/blog/2021/09/21/rome-will-be-rewritten-in-rust.html#whats-the-deal-with-abstract-syntax-trees).

### Rich and Comprehensible Diagnostics
Reading and understanding diagnostics is part of a software engineer's job. But staring at diagnostics for minutes, entirely lost even to have the slightest clue what it's trying to tell you, should not. That's why Rome sets [high standards](https://github.com/rome/tools/blob/main/crates/rome_diagnostics/CONTRIBUTING.md#writing-a-diagnostic) for its diagnostics to state what's wrong, why it went wrong, and, if applicable, guide the user towards a fix. Diagnostics should not only tell but by printing rich content like code frames or diffs because they are easier to understand.

Let's look at the concrete diagnostic Rome emits when linting the following code.

```javascript
function test(callback) {
  try {
    return callback();
  } catch (e) {
    console.log(e);
    throw e;
  }

  return 20;
}
```

And here's the diagnostic:

{% render docs/cli-screenshots/noUnreachable-example.md %}

The diagnostic tells the user that the `return 20` statement is unreachable and uses a code frame to show the problematic statement in context. It explains *why* the statement is unreachable and uses code frames to provide additional context.

Not all diagnostics have received as much love as the `noUnreachable` diagnostic yet, but we are committed to improving them over time. We ask you to [file](https://github.com/rome/tools/issues) an issue if you find a diagnostic difficult to understand.

## Try Rome

Give Rome a try. Other users adopting Rome have reported massive speedups, simplified configurations, and a considerable reduction of dependencies and size of the node_modules folder.

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">In terms of dependencies, <a href="https://twitter.com/rometools?ref_src=twsrc%5Etfw">@rometools</a> also saves us more than 100MB and 7,500 files. ðŸ¤¯<br>I was never comfortable with such huge dependencies, just to lint a vanilla TypeScript project. <a href="https://t.co/i6RBJxRSAD">pic.twitter.com/i6RBJxRSAD</a></p>&mdash; Lucas Garron (@lgarron) <a href="https://twitter.com/lgarron/status/1568797658692866050?ref_src=twsrc%5Etfw">September 11, 2022</a></blockquote>

To start using Rome, run the following commands in a project with a `package.json`.

```bash
npm install --save-dev rome
npx rome init
```

Then format files with `npx rome format <files>` and lint them with `npx rome check <files>`. Install Rome's [VS Code extension](/editors) to get linting and formatting in your editor. To learn more, check out our [documentation](/docs) and join us on [Discord](https://discord.gg/rome), where we offer support and discuss what we're working on.

Not yet ready to install new software. That's OK; play with Rome in our [playground](https://play.rome.tools/).


## Acknowledgments
Rome wasn't built in a day, and certainly not without the help of many. Many thanks to all contributors that helped build Rome. Especially:
* [Boshen](https://github.com/Boshen) for integrating the T262 parser test suite and parser benchmarks into our CI pipeline. This work has been a game changer in tracking the parser compliance and performance! Thank you for your many contributions to Rome's JavaScript lexer and parser and insightful engagement on Twitter and our Discord channel.
* [IWANABETHATGUY](https://github.com/IWANABETHATGUY) for contributing close to 20 lint rules, adding syntax highlighting to the [playground's](https://play.rome.tools) AST and IR tabs, and your numerous contributions to the JavaScript parser.
* [Denis Bezrukov](https://github.com/denbezrukov) for your countless contributions to the JavaScript formatter, most notably: formatting of assignment like nodes, whitespace handling in JSX, and last but not least, the trailing comma option.
* [rust-analzyer](https://rust-analyzer.github.io/): A huge shoutout to the rust-analyzer team. Rust-analyzer makes it a joy to write Rust, and it inspired Rome's [AST representation](https://github.com/rome/tools/tree/main/crates/rome_rowan) and [parser implementation](https://github.com/rome/tools/tree/main/crates/rome_js_parser).
* [RSLint](https://github.com/rslint/rslint): Especially to [Stupremee](https://github.com/rslint/rslint/commits?author=Stupremee) and [RDambrosio016](https://github.com/RDambrosio016) for their work on RSLint and help Rome forking their JavaScript parser and diagnostic system.
* [Prettier](https://prettier.io/): Rome formatter is heavily inspired by Prettier's architecture and style decisions. It's impressive how Prettier changed formatting in the web ecosystem, and walking in its footsteps helped us save a huge amount of time and decision-making.


<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
