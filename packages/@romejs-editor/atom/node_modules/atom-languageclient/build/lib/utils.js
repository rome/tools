Object.defineProperty(exports, "__esModule", {
  value: true
});

var _atom = require('atom');

var _vscodeJsonrpc = require('vscode-jsonrpc');

class Utils {
  /**
   * Obtain the range of the word at the given editor position.
   * Uses the non-word characters from the position's grammar scope.
   */
  static getWordAtPosition(editor, position) {
    const scopeDescriptor = editor.scopeDescriptorForBufferPosition(position);
    const nonWordCharacters = Utils.escapeRegExp(editor.getNonWordCharacters(scopeDescriptor));
    const range = Utils._getRegexpRangeAtPosition(editor.getBuffer(), position, new RegExp(`^[\t ]*$|[^\\s${nonWordCharacters}]+`, 'g'));
    if (range == null) {
      return new _atom.Range(position, position);
    }
    return range;
  }

  static escapeRegExp(string) {
    // From atom/underscore-plus.
    return string.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
  }

  static _getRegexpRangeAtPosition(buffer, position, wordRegex) {
    const { row, column } = position;
    const rowRange = buffer.rangeForRow(row);
    let matchData;
    // Extract the expression from the row text.
    buffer.scanInRange(wordRegex, rowRange, data => {
      const { range } = data;
      if (position.isGreaterThanOrEqual(range.start) &&
      // Range endpoints are exclusive.
      position.isLessThan(range.end)) {
        matchData = data;
        data.stop();
        return;
      }
      // Stop the scan if the scanner has passed our position.
      if (range.end.column > column) {
        data.stop();
      }
    });
    return matchData == null ? null : matchData.range;
  }

  /**
   * For the given connection and cancellationTokens map, cancel the existing
   * CancellationToken for that connection then create and store a new
   * CancellationToken to be used for the current request.
   */
  static cancelAndRefreshCancellationToken(key, cancellationTokens) {

    let cancellationToken = cancellationTokens.get(key);
    if (cancellationToken !== undefined && !cancellationToken.token.isCancellationRequested) {
      cancellationToken.cancel();
    }

    cancellationToken = new _vscodeJsonrpc.CancellationTokenSource();
    cancellationTokens.set(key, cancellationToken);
    return cancellationToken.token;
  }

  static async doWithCancellationToken(key, cancellationTokens, work) {
    const token = Utils.cancelAndRefreshCancellationToken(key, cancellationTokens);
    const result = await work(token);
    cancellationTokens.delete(key);
    return result;
  }
}
exports.default = Utils;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi91dGlscy5qcyJdLCJuYW1lcyI6WyJVdGlscyIsImdldFdvcmRBdFBvc2l0aW9uIiwiZWRpdG9yIiwicG9zaXRpb24iLCJzY29wZURlc2NyaXB0b3IiLCJzY29wZURlc2NyaXB0b3JGb3JCdWZmZXJQb3NpdGlvbiIsIm5vbldvcmRDaGFyYWN0ZXJzIiwiZXNjYXBlUmVnRXhwIiwiZ2V0Tm9uV29yZENoYXJhY3RlcnMiLCJyYW5nZSIsIl9nZXRSZWdleHBSYW5nZUF0UG9zaXRpb24iLCJnZXRCdWZmZXIiLCJSZWdFeHAiLCJzdHJpbmciLCJyZXBsYWNlIiwiYnVmZmVyIiwid29yZFJlZ2V4Iiwicm93IiwiY29sdW1uIiwicm93UmFuZ2UiLCJyYW5nZUZvclJvdyIsIm1hdGNoRGF0YSIsInNjYW5JblJhbmdlIiwiZGF0YSIsImlzR3JlYXRlclRoYW5PckVxdWFsIiwic3RhcnQiLCJpc0xlc3NUaGFuIiwiZW5kIiwic3RvcCIsImNhbmNlbEFuZFJlZnJlc2hDYW5jZWxsYXRpb25Ub2tlbiIsImtleSIsImNhbmNlbGxhdGlvblRva2VucyIsImNhbmNlbGxhdGlvblRva2VuIiwiZ2V0IiwidW5kZWZpbmVkIiwidG9rZW4iLCJpc0NhbmNlbGxhdGlvblJlcXVlc3RlZCIsImNhbmNlbCIsInNldCIsImRvV2l0aENhbmNlbGxhdGlvblRva2VuIiwid29yayIsInJlc3VsdCIsImRlbGV0ZSJdLCJtYXBwaW5ncyI6Ijs7OztBQUVBOztBQUNBOztBQUVlLE1BQU1BLEtBQU4sQ0FBWTtBQUN6Qjs7OztBQUlBLFNBQU9DLGlCQUFQLENBQXlCQyxNQUF6QixFQUE2Q0MsUUFBN0MsRUFBMEU7QUFDeEUsVUFBTUMsa0JBQWtCRixPQUFPRyxnQ0FBUCxDQUF3Q0YsUUFBeEMsQ0FBeEI7QUFDQSxVQUFNRyxvQkFBb0JOLE1BQU1PLFlBQU4sQ0FBbUJMLE9BQU9NLG9CQUFQLENBQTRCSixlQUE1QixDQUFuQixDQUExQjtBQUNBLFVBQU1LLFFBQVFULE1BQU1VLHlCQUFOLENBQ1pSLE9BQU9TLFNBQVAsRUFEWSxFQUVaUixRQUZZLEVBR1osSUFBSVMsTUFBSixDQUFZLGlCQUFnQk4saUJBQWtCLElBQTlDLEVBQW1ELEdBQW5ELENBSFksQ0FBZDtBQUtBLFFBQUlHLFNBQVMsSUFBYixFQUFtQjtBQUNqQixhQUFPLGdCQUFVTixRQUFWLEVBQW9CQSxRQUFwQixDQUFQO0FBQ0Q7QUFDRCxXQUFPTSxLQUFQO0FBQ0Q7O0FBRUQsU0FBT0YsWUFBUCxDQUFvQk0sTUFBcEIsRUFBNEM7QUFDMUM7QUFDQSxXQUFPQSxPQUFPQyxPQUFQLENBQWUsdUJBQWYsRUFBd0MsTUFBeEMsQ0FBUDtBQUNEOztBQUVELFNBQU9KLHlCQUFQLENBQWlDSyxNQUFqQyxFQUEwRFosUUFBMUQsRUFBZ0ZhLFNBQWhGLEVBQTJHO0FBQ3pHLFVBQU0sRUFBQ0MsR0FBRCxFQUFNQyxNQUFOLEtBQWdCZixRQUF0QjtBQUNBLFVBQU1nQixXQUFXSixPQUFPSyxXQUFQLENBQW1CSCxHQUFuQixDQUFqQjtBQUNBLFFBQUlJLFNBQUo7QUFDQTtBQUNBTixXQUFPTyxXQUFQLENBQW1CTixTQUFuQixFQUE4QkcsUUFBOUIsRUFBd0NJLFFBQVE7QUFDOUMsWUFBTSxFQUFDZCxLQUFELEtBQVVjLElBQWhCO0FBQ0EsVUFDRXBCLFNBQVNxQixvQkFBVCxDQUE4QmYsTUFBTWdCLEtBQXBDO0FBQ0E7QUFDQXRCLGVBQVN1QixVQUFULENBQW9CakIsTUFBTWtCLEdBQTFCLENBSEYsRUFJRTtBQUNBTixvQkFBWUUsSUFBWjtBQUNBQSxhQUFLSyxJQUFMO0FBQ0E7QUFDRDtBQUNEO0FBQ0EsVUFBSW5CLE1BQU1rQixHQUFOLENBQVVULE1BQVYsR0FBbUJBLE1BQXZCLEVBQStCO0FBQzdCSyxhQUFLSyxJQUFMO0FBQ0Q7QUFDRixLQWZEO0FBZ0JBLFdBQU9QLGFBQWEsSUFBYixHQUFvQixJQUFwQixHQUEyQkEsVUFBVVosS0FBNUM7QUFDRDs7QUFFRDs7Ozs7QUFLQSxTQUFPb0IsaUNBQVAsQ0FDRUMsR0FERixFQUVFQyxrQkFGRixFQUU4RTs7QUFFNUUsUUFBSUMsb0JBQW9CRCxtQkFBbUJFLEdBQW5CLENBQXVCSCxHQUF2QixDQUF4QjtBQUNBLFFBQUlFLHNCQUFzQkUsU0FBdEIsSUFBbUMsQ0FBQ0Ysa0JBQWtCRyxLQUFsQixDQUF3QkMsdUJBQWhFLEVBQXlGO0FBQ3ZGSix3QkFBa0JLLE1BQWxCO0FBQ0Q7O0FBRURMLHdCQUFvQiw0Q0FBcEI7QUFDQUQsdUJBQW1CTyxHQUFuQixDQUF1QlIsR0FBdkIsRUFBNEJFLGlCQUE1QjtBQUNBLFdBQU9BLGtCQUFrQkcsS0FBekI7QUFDRDs7QUFFRCxlQUFhSSx1QkFBYixDQUNFVCxHQURGLEVBRUVDLGtCQUZGLEVBR0VTLElBSEYsRUFJZTtBQUNiLFVBQU1MLFFBQVFuQyxNQUFNNkIsaUNBQU4sQ0FBd0NDLEdBQXhDLEVBQTZDQyxrQkFBN0MsQ0FBZDtBQUNBLFVBQU1VLFNBQVksTUFBTUQsS0FBS0wsS0FBTCxDQUF4QjtBQUNBSix1QkFBbUJXLE1BQW5CLENBQTBCWixHQUExQjtBQUNBLFdBQU9XLE1BQVA7QUFDRDtBQTVFd0I7a0JBQU56QyxLIiwiZmlsZSI6InV0aWxzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcclxuXHJcbmltcG9ydCB7UmFuZ2V9IGZyb20gJ2F0b20nO1xyXG5pbXBvcnQge0NhbmNlbGxhdGlvblRva2VuU291cmNlfSBmcm9tICd2c2NvZGUtanNvbnJwYyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVdGlscyB7XHJcbiAgLyoqXHJcbiAgICogT2J0YWluIHRoZSByYW5nZSBvZiB0aGUgd29yZCBhdCB0aGUgZ2l2ZW4gZWRpdG9yIHBvc2l0aW9uLlxyXG4gICAqIFVzZXMgdGhlIG5vbi13b3JkIGNoYXJhY3RlcnMgZnJvbSB0aGUgcG9zaXRpb24ncyBncmFtbWFyIHNjb3BlLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXRXb3JkQXRQb3NpdGlvbihlZGl0b3I6IFRleHRFZGl0b3IsIHBvc2l0aW9uOiBhdG9tJFBvaW50KTogUmFuZ2Uge1xyXG4gICAgY29uc3Qgc2NvcGVEZXNjcmlwdG9yID0gZWRpdG9yLnNjb3BlRGVzY3JpcHRvckZvckJ1ZmZlclBvc2l0aW9uKHBvc2l0aW9uKTtcclxuICAgIGNvbnN0IG5vbldvcmRDaGFyYWN0ZXJzID0gVXRpbHMuZXNjYXBlUmVnRXhwKGVkaXRvci5nZXROb25Xb3JkQ2hhcmFjdGVycyhzY29wZURlc2NyaXB0b3IpKTtcclxuICAgIGNvbnN0IHJhbmdlID0gVXRpbHMuX2dldFJlZ2V4cFJhbmdlQXRQb3NpdGlvbihcclxuICAgICAgZWRpdG9yLmdldEJ1ZmZlcigpLFxyXG4gICAgICBwb3NpdGlvbixcclxuICAgICAgbmV3IFJlZ0V4cChgXltcXHQgXSokfFteXFxcXHMke25vbldvcmRDaGFyYWN0ZXJzfV0rYCwgJ2cnKSxcclxuICAgICk7XHJcbiAgICBpZiAocmFuZ2UgPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gbmV3IFJhbmdlKHBvc2l0aW9uLCBwb3NpdGlvbik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmFuZ2U7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZXNjYXBlUmVnRXhwKHN0cmluZzogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIC8vIEZyb20gYXRvbS91bmRlcnNjb3JlLXBsdXMuXHJcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1stL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBfZ2V0UmVnZXhwUmFuZ2VBdFBvc2l0aW9uKGJ1ZmZlcjogYXRvbSRUZXh0QnVmZmVyLCBwb3NpdGlvbjogYXRvbSRQb2ludCwgd29yZFJlZ2V4OiBSZWdFeHApOiA/UmFuZ2Uge1xyXG4gICAgY29uc3Qge3JvdywgY29sdW1ufSA9IHBvc2l0aW9uO1xyXG4gICAgY29uc3Qgcm93UmFuZ2UgPSBidWZmZXIucmFuZ2VGb3JSb3cocm93KTtcclxuICAgIGxldCBtYXRjaERhdGE7XHJcbiAgICAvLyBFeHRyYWN0IHRoZSBleHByZXNzaW9uIGZyb20gdGhlIHJvdyB0ZXh0LlxyXG4gICAgYnVmZmVyLnNjYW5JblJhbmdlKHdvcmRSZWdleCwgcm93UmFuZ2UsIGRhdGEgPT4ge1xyXG4gICAgICBjb25zdCB7cmFuZ2V9ID0gZGF0YTtcclxuICAgICAgaWYgKFxyXG4gICAgICAgIHBvc2l0aW9uLmlzR3JlYXRlclRoYW5PckVxdWFsKHJhbmdlLnN0YXJ0KSAmJlxyXG4gICAgICAgIC8vIFJhbmdlIGVuZHBvaW50cyBhcmUgZXhjbHVzaXZlLlxyXG4gICAgICAgIHBvc2l0aW9uLmlzTGVzc1RoYW4ocmFuZ2UuZW5kKVxyXG4gICAgICApIHtcclxuICAgICAgICBtYXRjaERhdGEgPSBkYXRhO1xyXG4gICAgICAgIGRhdGEuc3RvcCgpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICAvLyBTdG9wIHRoZSBzY2FuIGlmIHRoZSBzY2FubmVyIGhhcyBwYXNzZWQgb3VyIHBvc2l0aW9uLlxyXG4gICAgICBpZiAocmFuZ2UuZW5kLmNvbHVtbiA+IGNvbHVtbikge1xyXG4gICAgICAgIGRhdGEuc3RvcCgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBtYXRjaERhdGEgPT0gbnVsbCA/IG51bGwgOiBtYXRjaERhdGEucmFuZ2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGb3IgdGhlIGdpdmVuIGNvbm5lY3Rpb24gYW5kIGNhbmNlbGxhdGlvblRva2VucyBtYXAsIGNhbmNlbCB0aGUgZXhpc3RpbmdcclxuICAgKiBDYW5jZWxsYXRpb25Ub2tlbiBmb3IgdGhhdCBjb25uZWN0aW9uIHRoZW4gY3JlYXRlIGFuZCBzdG9yZSBhIG5ld1xyXG4gICAqIENhbmNlbGxhdGlvblRva2VuIHRvIGJlIHVzZWQgZm9yIHRoZSBjdXJyZW50IHJlcXVlc3QuXHJcbiAgICovXHJcbiAgc3RhdGljIGNhbmNlbEFuZFJlZnJlc2hDYW5jZWxsYXRpb25Ub2tlbjxUPihcclxuICAgIGtleTogVCxcclxuICAgIGNhbmNlbGxhdGlvblRva2VuczogV2Vha01hcDxULCBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZT4pOiBDYW5jZWxsYXRpb25Ub2tlbiB7XHJcblxyXG4gICAgbGV0IGNhbmNlbGxhdGlvblRva2VuID0gY2FuY2VsbGF0aW9uVG9rZW5zLmdldChrZXkpO1xyXG4gICAgaWYgKGNhbmNlbGxhdGlvblRva2VuICE9PSB1bmRlZmluZWQgJiYgIWNhbmNlbGxhdGlvblRva2VuLnRva2VuLmlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKSB7XHJcbiAgICAgIGNhbmNlbGxhdGlvblRva2VuLmNhbmNlbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNhbmNlbGxhdGlvblRva2VuID0gbmV3IENhbmNlbGxhdGlvblRva2VuU291cmNlKCk7XHJcbiAgICBjYW5jZWxsYXRpb25Ub2tlbnMuc2V0KGtleSwgY2FuY2VsbGF0aW9uVG9rZW4pO1xyXG4gICAgcmV0dXJuIGNhbmNlbGxhdGlvblRva2VuLnRva2VuO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGFzeW5jIGRvV2l0aENhbmNlbGxhdGlvblRva2VuPFQxLCBUMj4oXHJcbiAgICBrZXk6IFQxLFxyXG4gICAgY2FuY2VsbGF0aW9uVG9rZW5zOiBXZWFrTWFwPFQxLCBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZT4sXHJcbiAgICB3b3JrOiAoQ2FuY2VsbGF0aW9uVG9rZW4pID0+IFByb21pc2U8VDI+LFxyXG4gICk6IFByb21pc2U8VDI+IHtcclxuICAgIGNvbnN0IHRva2VuID0gVXRpbHMuY2FuY2VsQW5kUmVmcmVzaENhbmNlbGxhdGlvblRva2VuKGtleSwgY2FuY2VsbGF0aW9uVG9rZW5zKTtcclxuICAgIGNvbnN0IHJlc3VsdDpUMiA9IGF3YWl0IHdvcmsodG9rZW4pO1xyXG4gICAgY2FuY2VsbGF0aW9uVG9rZW5zLmRlbGV0ZShrZXkpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbn1cclxuIl19