var __assign = (this && this.__assign) || function () {
	__assign = Object.assign || function (t) {
		for (var s, i = 1, n = arguments.length; i < n; i++) {
			s = arguments[i];
			for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
		}
		return t;
	};
	return __assign.apply(this, arguments);
};
var __generator = (this && this.__generator) || function (thisArg, body) {
	var _ = {
		label: 0,
		sent: function () {
			if (t[0] & 1) throw t[1];
			return t[1];
		},
		trys: [],
		ops: [],
	},
		f,
		y,
		t,
		g;
	return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
		return this;
	}), g;
	function verb(n) {
		return function (v) {
			return step([n, v]);
		};
	}
	function step(op) {
		if (f) throw new TypeError("Generator is already executing.");
		while (_) try {
			if (
				f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(
					y,
				), 0) : y.next) && !(t = t.call(y, op[1])).done
			) return t;
			if (y = 0, t) op = [op[0] & 2, t.value];
			switch (op[0]) {
				case 0:
				case 1:
					t = op;
					break;
				case 4:
					_.label++;
					return { value: op[1], done: false };
				case 5:
					_.label++;
					y = op[1];
					op = [0];
					continue;
				case 7:
					op = _.ops.pop();
					_.trys.pop();
					continue;
				default:
					if (
						!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)
					) {
						_ = 0;
						continue;
					}
					if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
						_.label = op[1];
						break;
					}
					if (op[0] === 6 && _.label < t[1]) {
						_.label = t[1];
						t = op;
						break;
					}
					if (t && _.label < t[2]) {
						_.label = t[2];
						_.ops.push(op);
						break;
					}
					if (t[2]) _.ops.pop();
					_.trys.pop();
					continue;
			}
			op = body.call(thisArg, _);
		} catch (e) {
			op = [6, e];
			y = 0;
		} finally {
			f = t = 0;
		}
		if (op[0] & 5) throw op[1];
		return { value: op[0] ? op[1] : void 0, done: true };
	}
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
	if (pack || arguments.length === 2) for (
		var i = 0, l = from.length, ar;
		i < l;
		i++
	) {
		if (ar || !(i in from)) {
			if (!ar) ar = Array.prototype.slice.call(from, 0, i);
			ar[i] = from[i];
		}
	}
	return to.concat(ar || Array.prototype.slice.call(from));
};
/* @internal */
var ts;
(function (ts) {
	var ambientModuleSymbolRegex = /^".+"$/;
	var anon = "(anonymous)";
	var nextSymbolId = 1;
	var nextNodeId = 1;
	var nextMergeId = 1;
	var nextFlowId = 1;
	var typeofEQFacts = new Map(
		getEntries(
			{
				string: 1, /* TypeofEQString */
				number: 2, /* TypeofEQNumber */
				bigint: 4, /* TypeofEQBigInt */
				boolean: 8, /* TypeofEQBoolean */
				symbol: 16, /* TypeofEQSymbol */
				undefined: 65536, /* EQUndefined */
				object: 32, /* TypeofEQObject */
				"function": 64, /* TypeofEQFunction */
			},
		),
	);
	var typeofNEFacts = new Map(
		getEntries(
			{
				string: 256, /* TypeofNEString */
				number: 512, /* TypeofNENumber */
				bigint: 1024, /* TypeofNEBigInt */
				boolean: 2048, /* TypeofNEBoolean */
				symbol: 4096, /* TypeofNESymbol */
				undefined: 524288, /* NEUndefined */
				object: 8192, /* TypeofNEObject */
				"function": 16384, /* TypeofNEFunction */
			},
		),
	);
	var isNotOverloadAndNotAccessor = and(isNotOverload, isNotAccessor);
	var intrinsicTypeKinds = new Map(
		getEntries(
			{
				Uppercase: 0, /* Uppercase */
				Lowercase: 1, /* Lowercase */
				Capitalize: 2, /* Capitalize */
				Uncapitalize: 3, /* Uncapitalize */
			},
		),
	);
	function SymbolLinks() {}
	function NodeLinks() {
		this.flags = 0;
	}
	function getNodeId(node) {
		if (!node.id) {
			node.id = nextNodeId;
			nextNodeId++;
		}
		return node.id;
	}
	ts.getNodeId = getNodeId;
	function getSymbolId(symbol) {
		if (!symbol.id) {
			symbol.id = nextSymbolId;
			nextSymbolId++;
		}
		return symbol.id;
	}
	ts.getSymbolId = getSymbolId;
	function isInstantiatedModule(node, preserveConstEnums) {
		var moduleState = getModuleInstanceState(node);
		return moduleState === ModuleInstanceState.Instantiated || (preserveConstEnums && moduleState === ModuleInstanceState.ConstEnumOnly);
	}
	ts.isInstantiatedModule = isInstantiatedModule;
	function createTypeChecker(host, produceDiagnostics) {
		var getPackagesMap = memoize(
			function () {
				// A package name maps to true when we detect it has .d.ts files.
				// This is useful as an approximation of whether a package bundles its own types.
				// Note: we only look at files already found by module resolution,
				// so there may be files we did not consider.
				var map = new Map();
				host.getSourceFiles().forEach(
					function (sf) {
						if (!sf.resolvedModules) return;
						sf.resolvedModules.forEach(
							function (r) {
								if (r && r.packageId) map.set(
									r.packageId.name,
									r.extension === Extension.Dts || !!map.get(r.packageId.name),
								);
							},
						);
					},
				);
				return map;
			},
		);
		// Cancellation that controls whether or not we can cancel in the middle of type checking.
		// In general cancelling is *not* safe for the type checker.  We might be in the middle of
		// computing something, and we will leave our internals in an inconsistent state.  Callers
		// who set the cancellation token should catch if a cancellation exception occurs, and
		// should throw away and create a new TypeChecker.
		//
		// Currently we only support setting the cancellation token when getting diagnostics.  This
		// is because diagnostics can be quite expensive, and we want to allow hosts to bail out if
		// they no longer need the information (for example, if the user started editing again).
		var cancellationToken;
		var requestedExternalEmitHelpers;
		var externalHelpersModule;
		var Symbol = objectAllocator.getSymbolConstructor();
		var Type = objectAllocator.getTypeConstructor();
		var Signature = objectAllocator.getSignatureConstructor();
		var typeCount = 0;
		var symbolCount = 0;
		var enumCount = 0;
		var totalInstantiationCount = 0;
		var instantiationCount = 0;
		var instantiationDepth = 0;
		var inlineLevel = 0;
		var currentNode;
		var emptySymbols = createSymbolTable();
		var arrayVariances = [VarianceFlags.Covariant];
		var compilerOptions = host.getCompilerOptions();
		var languageVersion = getEmitScriptTarget(compilerOptions);
		var moduleKind = getEmitModuleKind(compilerOptions);
		var useDefineForClassFields = getUseDefineForClassFields(compilerOptions);
		var allowSyntheticDefaultImports = getAllowSyntheticDefaultImports(
			compilerOptions,
		);
		var strictNullChecks = getStrictOptionValue(
			compilerOptions,
			"strictNullChecks",
		);
		var strictFunctionTypes = getStrictOptionValue(
			compilerOptions,
			"strictFunctionTypes",
		);
		var strictBindCallApply = getStrictOptionValue(
			compilerOptions,
			"strictBindCallApply",
		);
		var strictPropertyInitialization = getStrictOptionValue(
			compilerOptions,
			"strictPropertyInitialization",
		);
		var noImplicitAny = getStrictOptionValue(compilerOptions, "noImplicitAny");
		var noImplicitThis = getStrictOptionValue(compilerOptions, "noImplicitThis");
		var useUnknownInCatchVariables = getStrictOptionValue(
			compilerOptions,
			"useUnknownInCatchVariables",
		);
		var keyofStringsOnly = !!compilerOptions.keyofStringsOnly;
		var freshObjectLiteralFlag = compilerOptions.suppressExcessPropertyErrors ? 0 : ObjectFlags.FreshLiteral;
		var exactOptionalPropertyTypes = compilerOptions.exactOptionalPropertyTypes;
		var checkBinaryExpression = createCheckBinaryExpression();
		var emitResolver = createResolver();
		var nodeBuilder = createNodeBuilder();
		var globals = createSymbolTable();
		var undefinedSymbol = createSymbol(SymbolFlags.Property, "undefined");
		undefinedSymbol.declarations = [];
		var globalThisSymbol = createSymbol(
			SymbolFlags.Module,
			"globalThis",
			CheckFlags.Readonly,
		);
		globalThisSymbol.exports = globals;
		globalThisSymbol.declarations = [];
		globals.set(globalThisSymbol.escapedName, globalThisSymbol);
		var argumentsSymbol = createSymbol(SymbolFlags.Property, "arguments");
		var requireSymbol = createSymbol(SymbolFlags.Property, "require");
		/** This will be set during calls to `getResolvedSignature` where services determines an apparent number of arguments greater than what is actually provided. */
		var apparentArgumentCount;
		// for public members that accept a Node or one of its subtypes, we must guard against
		// synthetic nodes created during transformations by calling `getParseTreeNode`.
		// for most of these, we perform the guard only on `checker` to avoid any possible
		// extra cost of calling `getParseTreeNode` when calling these functions from inside the
		// checker.
		var checker = {
			getNodeCount: function () {
				return sum(host.getSourceFiles(), "nodeCount");
			},
			getIdentifierCount: function () {
				return sum(host.getSourceFiles(), "identifierCount");
			},
			getSymbolCount: function () {
				return sum(host.getSourceFiles(), "symbolCount") + symbolCount;
			},
			getTypeCount: function () {
				return typeCount;
			},
			getInstantiationCount: function () {
				return totalInstantiationCount;
			},
			getRelationCacheSizes: function () {
				return ({
					assignable: assignableRelation.size,
					identity: identityRelation.size,
					subtype: subtypeRelation.size,
					strictSubtype: strictSubtypeRelation.size,
				});
			},
			isUndefinedSymbol: function (symbol) {
				return symbol === undefinedSymbol;
			},
			isArgumentsSymbol: function (symbol) {
				return symbol === argumentsSymbol;
			},
			isUnknownSymbol: function (symbol) {
				return symbol === unknownSymbol;
			},
			getMergedSymbol: getMergedSymbol,
			getDiagnostics: getDiagnostics,
			getGlobalDiagnostics: getGlobalDiagnostics,
			getRecursionIdentity: getRecursionIdentity,
			getUnmatchedProperties: getUnmatchedProperties,
			getTypeOfSymbolAtLocation: function (symbol, locationIn) {
				var location = getParseTreeNode(locationIn);
				return location ? getTypeOfSymbolAtLocation(symbol, location) : errorType;
			},
			getTypeOfSymbol: getTypeOfSymbol,
			getSymbolsOfParameterPropertyDeclaration: function (
				parameterIn,
				parameterName,
			) {
				var parameter = getParseTreeNode(parameterIn, isParameter);
				if (parameter === undefined) return Debug.fail(
					"Cannot get symbols of a synthetic parameter that cannot be resolved to a parse-tree node.",
				);
				return getSymbolsOfParameterPropertyDeclaration(
					parameter,
					escapeLeadingUnderscores(parameterName),
				);
			},
			getDeclaredTypeOfSymbol: getDeclaredTypeOfSymbol,
			getPropertiesOfType: getPropertiesOfType,
			getPropertyOfType: function (type, name) {
				return getPropertyOfType(type, escapeLeadingUnderscores(name));
			},
			getPrivateIdentifierPropertyOfType: function (leftType, name, location) {
				var node = getParseTreeNode(location);
				if (!node) {
					return undefined;
				}
				var propName = escapeLeadingUnderscores(name);
				var lexicallyScopedIdentifier = lookupSymbolForPrivateIdentifierDeclaration(
					propName,
					node,
				);
				return lexicallyScopedIdentifier ? getPrivateIdentifierPropertyOfType(
					leftType,
					lexicallyScopedIdentifier,
				) : undefined;
			},
			getTypeOfPropertyOfType: function (type, name) {
				return getTypeOfPropertyOfType(type, escapeLeadingUnderscores(name));
			},
			getIndexInfoOfType: function (type, kind) {
				return getIndexInfoOfType(
					type,
					kind === IndexKind.String ? stringType : numberType,
				);
			},
			getIndexInfosOfType: getIndexInfosOfType,
			getSignaturesOfType: getSignaturesOfType,
			getIndexTypeOfType: function (type, kind) {
				return getIndexTypeOfType(
					type,
					kind === IndexKind.String ? stringType : numberType,
				);
			},
			getIndexType: function (type) {
				return getIndexType(type);
			},
			getBaseTypes: getBaseTypes,
			getBaseTypeOfLiteralType: getBaseTypeOfLiteralType,
			getWidenedType: getWidenedType,
			getTypeFromTypeNode: function (nodeIn) {
				var node = getParseTreeNode(nodeIn, isTypeNode);
				return node ? getTypeFromTypeNode(node) : errorType;
			},
			getParameterType: getTypeAtPosition,
			getParameterIdentifierNameAtPosition: getParameterIdentifierNameAtPosition,
			getPromisedTypeOfPromise: getPromisedTypeOfPromise,
			getAwaitedType: function (type) {
				return getAwaitedType(type);
			},
			getReturnTypeOfSignature: getReturnTypeOfSignature,
			isNullableType: isNullableType,
			getNullableType: getNullableType,
			getNonNullableType: getNonNullableType,
			getNonOptionalType: removeOptionalTypeMarker,
			getTypeArguments: getTypeArguments,
			typeToTypeNode: nodeBuilder.typeToTypeNode,
			indexInfoToIndexSignatureDeclaration: nodeBuilder.indexInfoToIndexSignatureDeclaration,
			signatureToSignatureDeclaration: nodeBuilder.signatureToSignatureDeclaration,
			symbolToEntityName: nodeBuilder.symbolToEntityName,
			symbolToExpression: nodeBuilder.symbolToExpression,
			symbolToTypeParameterDeclarations: nodeBuilder.symbolToTypeParameterDeclarations,
			symbolToParameterDeclaration: nodeBuilder.symbolToParameterDeclaration,
			typeParameterToDeclaration: nodeBuilder.typeParameterToDeclaration,
			getSymbolsInScope: function (locationIn, meaning) {
				var location = getParseTreeNode(locationIn);
				return location ? getSymbolsInScope(location, meaning) : [];
			},
			getSymbolAtLocation: function (nodeIn) {
				var node = getParseTreeNode(nodeIn);
				// set ignoreErrors: true because any lookups invoked by the API shouldn't cause any new errors
				return node ? getSymbolAtLocation(node, /*ignoreErrors*/ true) : undefined;
			},
			getIndexInfosAtLocation: function (nodeIn) {
				var node = getParseTreeNode(nodeIn);
				return node ? getIndexInfosAtLocation(node) : undefined;
			},
			getShorthandAssignmentValueSymbol: function (nodeIn) {
				var node = getParseTreeNode(nodeIn);
				return node ? getShorthandAssignmentValueSymbol(node) : undefined;
			},
			getExportSpecifierLocalTargetSymbol: function (nodeIn) {
				var node = getParseTreeNode(nodeIn, isExportSpecifier);
				return node ? getExportSpecifierLocalTargetSymbol(node) : undefined;
			},
			getExportSymbolOfSymbol: function (symbol) {
				return getMergedSymbol(symbol.exportSymbol || symbol);
			},
			getTypeAtLocation: function (nodeIn) {
				var node = getParseTreeNode(nodeIn);
				return node ? getTypeOfNode(node) : errorType;
			},
			getTypeOfAssignmentPattern: function (nodeIn) {
				var node = getParseTreeNode(nodeIn, isAssignmentPattern);
				return node && getTypeOfAssignmentPattern(node) || errorType;
			},
			getPropertySymbolOfDestructuringAssignment: function (locationIn) {
				var location = getParseTreeNode(locationIn, isIdentifier);
				return location ? getPropertySymbolOfDestructuringAssignment(location) : undefined;
			},
			signatureToString: function (signature, enclosingDeclaration, flags, kind) {
				return signatureToString(
					signature,
					getParseTreeNode(enclosingDeclaration),
					flags,
					kind,
				);
			},
			typeToString: function (type, enclosingDeclaration, flags) {
				return typeToString(type, getParseTreeNode(enclosingDeclaration), flags);
			},
			symbolToString: function (symbol, enclosingDeclaration, meaning, flags) {
				return symbolToString(
					symbol,
					getParseTreeNode(enclosingDeclaration),
					meaning,
					flags,
				);
			},
			typePredicateToString: function (predicate, enclosingDeclaration, flags) {
				return typePredicateToString(
					predicate,
					getParseTreeNode(enclosingDeclaration),
					flags,
				);
			},
			writeSignature: function (
				signature,
				enclosingDeclaration,
				flags,
				kind,
				writer,
			) {
				return signatureToString(
					signature,
					getParseTreeNode(enclosingDeclaration),
					flags,
					kind,
					writer,
				);
			},
			writeType: function (type, enclosingDeclaration, flags, writer) {
				return typeToString(
					type,
					getParseTreeNode(enclosingDeclaration),
					flags,
					writer,
				);
			},
			writeSymbol: function (
				symbol,
				enclosingDeclaration,
				meaning,
				flags,
				writer,
			) {
				return symbolToString(
					symbol,
					getParseTreeNode(enclosingDeclaration),
					meaning,
					flags,
					writer,
				);
			},
			writeTypePredicate: function (
				predicate,
				enclosingDeclaration,
				flags,
				writer,
			) {
				return typePredicateToString(
					predicate,
					getParseTreeNode(enclosingDeclaration),
					flags,
					writer,
				);
			},
			getAugmentedPropertiesOfType: getAugmentedPropertiesOfType,
			getRootSymbols: getRootSymbols,
			getSymbolOfExpando: getSymbolOfExpando,
			getContextualType: function (nodeIn, contextFlags) {
				var node = getParseTreeNode(nodeIn, isExpression);
				if (!node) {
					return undefined;
				}
				var containingCall = findAncestor(node, isCallLikeExpression);
				var containingCallResolvedSignature = containingCall && getNodeLinks(
					containingCall,
				).resolvedSignature;
				if (contextFlags & ContextFlags.Completions && containingCall) {
					var toMarkSkip = node;
					do {
						getNodeLinks(toMarkSkip).skipDirectInference = true;
						toMarkSkip = toMarkSkip.parent;
					} while (toMarkSkip && toMarkSkip !== containingCall);
					getNodeLinks(containingCall).resolvedSignature = undefined;
				}
				var result = getContextualType(node, contextFlags);
				if (contextFlags & ContextFlags.Completions && containingCall) {
					var toMarkSkip = node;
					do {
						getNodeLinks(toMarkSkip).skipDirectInference = undefined;
						toMarkSkip = toMarkSkip.parent;
					} while (toMarkSkip && toMarkSkip !== containingCall);
					getNodeLinks(containingCall).resolvedSignature = containingCallResolvedSignature;
				}
				return result;
			},
			getContextualTypeForObjectLiteralElement: function (nodeIn) {
				var node = getParseTreeNode(nodeIn, isObjectLiteralElementLike);
				return node ? getContextualTypeForObjectLiteralElement(node) : undefined;
			},
			getContextualTypeForArgumentAtIndex: function (nodeIn, argIndex) {
				var node = getParseTreeNode(nodeIn, isCallLikeExpression);
				return node && getContextualTypeForArgumentAtIndex(node, argIndex);
			},
			getContextualTypeForJsxAttribute: function (nodeIn) {
				var node = getParseTreeNode(nodeIn, isJsxAttributeLike);
				return node && getContextualTypeForJsxAttribute(node);
			},
			isContextSensitive: isContextSensitive,
			getTypeOfPropertyOfContextualType: getTypeOfPropertyOfContextualType,
			getFullyQualifiedName: getFullyQualifiedName,
			getResolvedSignature: function (node, candidatesOutArray, argumentCount) {
				return getResolvedSignatureWorker(
					node,
					candidatesOutArray,
					argumentCount,
					0, /* Normal */
				);
			},
			getResolvedSignatureForSignatureHelp: function (
				node,
				candidatesOutArray,
				argumentCount,
			) {
				return getResolvedSignatureWorker(
					node,
					candidatesOutArray,
					argumentCount,
					16, /* IsForSignatureHelp */
				);
			},
			getExpandedParameters: getExpandedParameters,
			hasEffectiveRestParameter: hasEffectiveRestParameter,
			containsArgumentsReference: containsArgumentsReference,
			getConstantValue: function (nodeIn) {
				var node = getParseTreeNode(nodeIn, canHaveConstantValue);
				return node ? getConstantValue(node) : undefined;
			},
			isValidPropertyAccess: function (nodeIn, propertyName) {
				var node = getParseTreeNode(
					nodeIn,
					isPropertyAccessOrQualifiedNameOrImportTypeNode,
				);
				return !!node && isValidPropertyAccess(
					node,
					escapeLeadingUnderscores(propertyName),
				);
			},
			isValidPropertyAccessForCompletions: function (nodeIn, type, property) {
				var node = getParseTreeNode(nodeIn, isPropertyAccessExpression);
				return !!node && isValidPropertyAccessForCompletions(
					node,
					type,
					property,
				);
			},
			getSignatureFromDeclaration: function (declarationIn) {
				var declaration = getParseTreeNode(declarationIn, isFunctionLike);
				return declaration ? getSignatureFromDeclaration(declaration) : undefined;
			},
			isImplementationOfOverload: function (nodeIn) {
				var node = getParseTreeNode(nodeIn, isFunctionLike);
				return node ? isImplementationOfOverload(node) : undefined;
			},
			getImmediateAliasedSymbol: getImmediateAliasedSymbol,
			getAliasedSymbol: resolveAlias,
			getEmitResolver: getEmitResolver,
			getExportsOfModule: getExportsOfModuleAsArray,
			getExportsAndPropertiesOfModule: getExportsAndPropertiesOfModule,
			forEachExportAndPropertyOfModule: forEachExportAndPropertyOfModule,
			getSymbolWalker: createGetSymbolWalker(
				getRestTypeOfSignature,
				getTypePredicateOfSignature,
				getReturnTypeOfSignature,
				getBaseTypes,
				resolveStructuredTypeMembers,
				getTypeOfSymbol,
				getResolvedSymbol,
				getConstraintOfTypeParameter,
				getFirstIdentifier,
				getTypeArguments,
			),
			getAmbientModules: getAmbientModules,
			getJsxIntrinsicTagNamesAt: getJsxIntrinsicTagNamesAt,
			isOptionalParameter: function (nodeIn) {
				var node = getParseTreeNode(nodeIn, isParameter);
				return node ? isOptionalParameter(node) : false;
			},
			tryGetMemberInModuleExports: function (name, symbol) {
				return tryGetMemberInModuleExports(
					escapeLeadingUnderscores(name),
					symbol,
				);
			},
			tryGetMemberInModuleExportsAndProperties: function (name, symbol) {
				return tryGetMemberInModuleExportsAndProperties(
					escapeLeadingUnderscores(name),
					symbol,
				);
			},
			tryFindAmbientModule: function (moduleName) {
				return tryFindAmbientModule(moduleName, /*withAugmentations*/ true);
			},
			tryFindAmbientModuleWithoutAugmentations: function (moduleName) {
				// we deliberately exclude augmentations
				// since we are only interested in declarations of the module itself
				return tryFindAmbientModule(moduleName, /*withAugmentations*/ false);
			},
			getApparentType: getApparentType,
			getUnionType: getUnionType,
			isTypeAssignableTo: isTypeAssignableTo,
			createAnonymousType: createAnonymousType,
			createSignature: createSignature,
			createSymbol: createSymbol,
			createIndexInfo: createIndexInfo,
			getAnyType: function () {
				return anyType;
			},
			getStringType: function () {
				return stringType;
			},
			getNumberType: function () {
				return numberType;
			},
			createPromiseType: createPromiseType,
			createArrayType: createArrayType,
			getElementTypeOfArrayType: getElementTypeOfArrayType,
			getBooleanType: function () {
				return booleanType;
			},
			getFalseType: function (fresh) {
				return fresh ? falseType : regularFalseType;
			},
			getTrueType: function (fresh) {
				return fresh ? trueType : regularTrueType;
			},
			getVoidType: function () {
				return voidType;
			},
			getUndefinedType: function () {
				return undefinedType;
			},
			getNullType: function () {
				return nullType;
			},
			getESSymbolType: function () {
				return esSymbolType;
			},
			getNeverType: function () {
				return neverType;
			},
			getOptionalType: function () {
				return optionalType;
			},
			getPromiseType: function () {
				return getGlobalPromiseType( /*reportErrors*/ false);
			},
			getPromiseLikeType: function () {
				return getGlobalPromiseLikeType( /*reportErrors*/ false);
			},
			isSymbolAccessible: isSymbolAccessible,
			isArrayType: isArrayType,
			isTupleType: isTupleType,
			isArrayLikeType: isArrayLikeType,
			isTypeInvalidDueToUnionDiscriminant: isTypeInvalidDueToUnionDiscriminant,
			getExactOptionalProperties: getExactOptionalProperties,
			getAllPossiblePropertiesOfTypes: getAllPossiblePropertiesOfTypes,
			getSuggestedSymbolForNonexistentProperty: getSuggestedSymbolForNonexistentProperty,
			getSuggestionForNonexistentProperty: getSuggestionForNonexistentProperty,
			getSuggestedSymbolForNonexistentJSXAttribute: getSuggestedSymbolForNonexistentJSXAttribute,
			getSuggestedSymbolForNonexistentSymbol: function (location, name, meaning) {
				return getSuggestedSymbolForNonexistentSymbol(
					location,
					escapeLeadingUnderscores(name),
					meaning,
				);
			},
			getSuggestionForNonexistentSymbol: function (location, name, meaning) {
				return getSuggestionForNonexistentSymbol(
					location,
					escapeLeadingUnderscores(name),
					meaning,
				);
			},
			getSuggestedSymbolForNonexistentModule: getSuggestedSymbolForNonexistentModule,
			getSuggestionForNonexistentExport: getSuggestionForNonexistentExport,
			getSuggestedSymbolForNonexistentClassMember: getSuggestedSymbolForNonexistentClassMember,
			getBaseConstraintOfType: getBaseConstraintOfType,
			getDefaultFromTypeParameter: function (type) {
				return type && type.flags & TypeFlags.TypeParameter ? getDefaultFromTypeParameter(
					type,
				) : undefined;
			},
			resolveName: function (name, location, meaning, excludeGlobals) {
				return resolveName(
					location,
					escapeLeadingUnderscores(name),
					meaning, /*nameNotFoundMessage*/
					undefined, /*nameArg*/
					undefined, /*isUse*/
					false,
					excludeGlobals,
				);
			},
			getJsxNamespace: function (n) {
				return unescapeLeadingUnderscores(getJsxNamespace(n));
			},
			getJsxFragmentFactory: function (n) {
				var jsxFragmentFactory = getJsxFragmentFactoryEntity(n);
				return jsxFragmentFactory && unescapeLeadingUnderscores(
					getFirstIdentifier(jsxFragmentFactory).escapedText,
				);
			},
			getAccessibleSymbolChain: getAccessibleSymbolChain,
			getTypePredicateOfSignature: getTypePredicateOfSignature,
			resolveExternalModuleName: function (moduleSpecifierIn) {
				var moduleSpecifier = getParseTreeNode(moduleSpecifierIn, isExpression);
				return moduleSpecifier && resolveExternalModuleName(
					moduleSpecifier,
					moduleSpecifier, /*ignoreErrors*/
					true,
				);
			},
			resolveExternalModuleSymbol: resolveExternalModuleSymbol,
			tryGetThisTypeAt: function (nodeIn, includeGlobalThis) {
				var node = getParseTreeNode(nodeIn);
				return node && tryGetThisTypeAt(node, includeGlobalThis);
			},
			getTypeArgumentConstraint: function (nodeIn) {
				var node = getParseTreeNode(nodeIn, isTypeNode);
				return node && getTypeArgumentConstraint(node);
			},
			getSuggestionDiagnostics: function (fileIn, ct) {
				var file = getParseTreeNode(fileIn, isSourceFile) || Debug.fail(
					"Could not determine parsed source file.",
				);
				if (skipTypeChecking(file, compilerOptions, host)) {
					return emptyArray;
				}
				var diagnostics;
				try {
					// Record the cancellation token so it can be checked later on during checkSourceElement.
					// Do this in a finally block so we can ensure that it gets reset back to nothing after
					// this call is done.
					cancellationToken = ct;
					// Ensure file is type checked
					checkSourceFile(file);
					Debug.assert(
						!!(getNodeLinks(file).flags & NodeCheckFlags.TypeChecked),
					);
					diagnostics = addRange(
						diagnostics,
						suggestionDiagnostics.getDiagnostics(file.fileName),
					);
					checkUnusedIdentifiers(
						getPotentiallyUnusedIdentifiers(file),
						function (containingNode, kind, diag) {
							if (
								!containsParseError(containingNode) && !unusedIsError(
									kind,
									!!(containingNode.flags & NodeFlags.Ambient),
								)
							) {
								(diagnostics || (diagnostics = [])).push(
									__assign(
										__assign({}, diag),
										{ category: DiagnosticCategory.Suggestion },
									),
								);
							}
						},
					);
					return diagnostics || emptyArray;
				} finally {
					cancellationToken = undefined;
				}
			},
			runWithCancellationToken: function (token, callback) {
				try {
					cancellationToken = token;
					return callback(checker);
				} finally {
					cancellationToken = undefined;
				}
			},
			getLocalTypeParametersOfClassOrInterfaceOrTypeAlias: getLocalTypeParametersOfClassOrInterfaceOrTypeAlias,
			isDeclarationVisible: isDeclarationVisible,
			isPropertyAccessible: isPropertyAccessible,
			getTypeOnlyAliasDeclaration: getTypeOnlyAliasDeclaration,
			getMemberOverrideModifierStatus: getMemberOverrideModifierStatus,
		};
		function getResolvedSignatureWorker(
			nodeIn,
			candidatesOutArray,
			argumentCount,
			checkMode,
		) {
			var node = getParseTreeNode(nodeIn, isCallLikeExpression);
			apparentArgumentCount = argumentCount;
			var res = node ? getResolvedSignature(node, candidatesOutArray, checkMode) : undefined;
			apparentArgumentCount = undefined;
			return res;
		}
		var tupleTypes = new Map();
		var unionTypes = new Map();
		var intersectionTypes = new Map();
		var stringLiteralTypes = new Map();
		var numberLiteralTypes = new Map();
		var bigIntLiteralTypes = new Map();
		var enumLiteralTypes = new Map();
		var indexedAccessTypes = new Map();
		var templateLiteralTypes = new Map();
		var stringMappingTypes = new Map();
		var substitutionTypes = new Map();
		var subtypeReductionCache = new Map();
		var evolvingArrayTypes = [];
		var undefinedProperties = new Map();
		var unknownSymbol = createSymbol(SymbolFlags.Property, "unknown");
		var resolvingSymbol = createSymbol(0, InternalSymbolName.Resolving);
		var unresolvedSymbols = new Map();
		var errorTypes = new Map();
		var anyType = createIntrinsicType(TypeFlags.Any, "any");
		var autoType = createIntrinsicType(TypeFlags.Any, "any");
		var wildcardType = createIntrinsicType(TypeFlags.Any, "any");
		var errorType = createIntrinsicType(TypeFlags.Any, "error");
		var unresolvedType = createIntrinsicType(TypeFlags.Any, "unresolved");
		var nonInferrableAnyType = createIntrinsicType(
			TypeFlags.Any,
			"any",
			ObjectFlags.ContainsWideningType,
		);
		var intrinsicMarkerType = createIntrinsicType(TypeFlags.Any, "intrinsic");
		var unknownType = createIntrinsicType(TypeFlags.Unknown, "unknown");
		var nonNullUnknownType = createIntrinsicType(TypeFlags.Unknown, "unknown");
		var undefinedType = createIntrinsicType(TypeFlags.Undefined, "undefined");
		var undefinedWideningType = strictNullChecks ? undefinedType : createIntrinsicType(
			TypeFlags.Undefined,
			"undefined",
			ObjectFlags.ContainsWideningType,
		);
		var optionalType = createIntrinsicType(TypeFlags.Undefined, "undefined");
		var missingType = exactOptionalPropertyTypes ? createIntrinsicType(
			TypeFlags.Undefined,
			"undefined",
		) : undefinedType;
		var nullType = createIntrinsicType(TypeFlags.Null, "null");
		var nullWideningType = strictNullChecks ? nullType : createIntrinsicType(
			TypeFlags.Null,
			"null",
			ObjectFlags.ContainsWideningType,
		);
		var stringType = createIntrinsicType(TypeFlags.String, "string");
		var numberType = createIntrinsicType(TypeFlags.Number, "number");
		var bigintType = createIntrinsicType(TypeFlags.BigInt, "bigint");
		var falseType = createIntrinsicType(TypeFlags.BooleanLiteral, "false");
		var regularFalseType = createIntrinsicType(
			TypeFlags.BooleanLiteral,
			"false",
		);
		var trueType = createIntrinsicType(TypeFlags.BooleanLiteral, "true");
		var regularTrueType = createIntrinsicType(TypeFlags.BooleanLiteral, "true");
		trueType.regularType = regularTrueType;
		trueType.freshType = trueType;
		regularTrueType.regularType = regularTrueType;
		regularTrueType.freshType = trueType;
		falseType.regularType = regularFalseType;
		falseType.freshType = falseType;
		regularFalseType.regularType = regularFalseType;
		regularFalseType.freshType = falseType;
		var booleanType = getUnionType([regularFalseType, regularTrueType]);
		var esSymbolType = createIntrinsicType(TypeFlags.ESSymbol, "symbol");
		var voidType = createIntrinsicType(TypeFlags.Void, "void");
		var neverType = createIntrinsicType(TypeFlags.Never, "never");
		var silentNeverType = createIntrinsicType(TypeFlags.Never, "never");
		var nonInferrableType = createIntrinsicType(
			TypeFlags.Never,
			"never",
			ObjectFlags.NonInferrableType,
		);
		var implicitNeverType = createIntrinsicType(TypeFlags.Never, "never");
		var unreachableNeverType = createIntrinsicType(TypeFlags.Never, "never");
		var nonPrimitiveType = createIntrinsicType(TypeFlags.NonPrimitive, "object");
		var stringOrNumberType = getUnionType([stringType, numberType]);
		var stringNumberSymbolType = getUnionType(
			[stringType, numberType, esSymbolType],
		);
		var keyofConstraintType = keyofStringsOnly ? stringType : stringNumberSymbolType;
		var numberOrBigIntType = getUnionType([numberType, bigintType]);
		var templateConstraintType = getUnionType(
			[stringType, numberType, booleanType, bigintType, nullType, undefinedType],
		);
		var restrictiveMapper = makeFunctionTypeMapper(
			function (t) {
				return t.flags & TypeFlags.TypeParameter ? getRestrictiveTypeParameter(
					t,
				) : t;
			},
		);
		var permissiveMapper = makeFunctionTypeMapper(
			function (t) {
				return t.flags & TypeFlags.TypeParameter ? wildcardType : t;
			},
		);
		var emptyObjectType = createAnonymousType(
			undefined,
			emptySymbols,
			emptyArray,
			emptyArray,
			emptyArray,
		);
		var emptyJsxObjectType = createAnonymousType(
			undefined,
			emptySymbols,
			emptyArray,
			emptyArray,
			emptyArray,
		);
		emptyJsxObjectType.objectFlags |= ObjectFlags.JsxAttributes;
		var emptyTypeLiteralSymbol = createSymbol(
			SymbolFlags.TypeLiteral,
			InternalSymbolName.Type,
		);
		emptyTypeLiteralSymbol.members = createSymbolTable();
		var emptyTypeLiteralType = createAnonymousType(
			emptyTypeLiteralSymbol,
			emptySymbols,
			emptyArray,
			emptyArray,
			emptyArray,
		);
		var emptyGenericType = createAnonymousType(
			undefined,
			emptySymbols,
			emptyArray,
			emptyArray,
			emptyArray,
		);
		emptyGenericType.instantiations = new Map();
		var anyFunctionType = createAnonymousType(
			undefined,
			emptySymbols,
			emptyArray,
			emptyArray,
			emptyArray,
		);
		// The anyFunctionType contains the anyFunctionType by definition. The flag is further propagated
		// in getPropagatingFlagsOfTypes, and it is checked in inferFromTypes.
		anyFunctionType.objectFlags |= ObjectFlags.NonInferrableType;
		var noConstraintType = createAnonymousType(
			undefined,
			emptySymbols,
			emptyArray,
			emptyArray,
			emptyArray,
		);
		var circularConstraintType = createAnonymousType(
			undefined,
			emptySymbols,
			emptyArray,
			emptyArray,
			emptyArray,
		);
		var resolvingDefaultType = createAnonymousType(
			undefined,
			emptySymbols,
			emptyArray,
			emptyArray,
			emptyArray,
		);
		var markerSuperType = createTypeParameter();
		var markerSubType = createTypeParameter();
		markerSubType.constraint = markerSuperType;
		var markerOtherType = createTypeParameter();
		var noTypePredicate = createTypePredicate(
			TypePredicateKind.Identifier,
			"<<unresolved>>",
			0,
			anyType,
		);
		var anySignature = createSignature(
			undefined,
			undefined,
			undefined,
			emptyArray,
			anyType, /*resolvedTypePredicate*/
			undefined,
			0,
			SignatureFlags.None,
		);
		var unknownSignature = createSignature(
			undefined,
			undefined,
			undefined,
			emptyArray,
			errorType, /*resolvedTypePredicate*/
			undefined,
			0,
			SignatureFlags.None,
		);
		var resolvingSignature = createSignature(
			undefined,
			undefined,
			undefined,
			emptyArray,
			anyType, /*resolvedTypePredicate*/
			undefined,
			0,
			SignatureFlags.None,
		);
		var silentNeverSignature = createSignature(
			undefined,
			undefined,
			undefined,
			emptyArray,
			silentNeverType, /*resolvedTypePredicate*/
			undefined,
			0,
			SignatureFlags.None,
		);
		var enumNumberIndexInfo = createIndexInfo(
			numberType,
			stringType, /*isReadonly*/
			true,
		);
		var iterationTypesCache = new Map(); // cache for common IterationTypes instances
		var noIterationTypes = {
			get yieldType() {
				return Debug.fail("Not supported");
			},
			get returnType() {
				return Debug.fail("Not supported");
			},
			get nextType() {
				return Debug.fail("Not supported");
			},
		};
		var anyIterationTypes = createIterationTypes(anyType, anyType, anyType);
		var anyIterationTypesExceptNext = createIterationTypes(
			anyType,
			anyType,
			unknownType,
		);
		var defaultIterationTypes = createIterationTypes(
			neverType,
			anyType,
			undefinedType,
		); // default iteration types for `Iterator`.
		var asyncIterationTypesResolver = {
			iterableCacheKey: "iterationTypesOfAsyncIterable",
			iteratorCacheKey: "iterationTypesOfAsyncIterator",
			iteratorSymbolName: "asyncIterator",
			getGlobalIteratorType: getGlobalAsyncIteratorType,
			getGlobalIterableType: getGlobalAsyncIterableType,
			getGlobalIterableIteratorType: getGlobalAsyncIterableIteratorType,
			getGlobalGeneratorType: getGlobalAsyncGeneratorType,
			resolveIterationType: getAwaitedType,
			mustHaveANextMethodDiagnostic: Diagnostics.An_async_iterator_must_have_a_next_method,
			mustBeAMethodDiagnostic: Diagnostics.The_0_property_of_an_async_iterator_must_be_a_method,
			mustHaveAValueDiagnostic: Diagnostics.The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property,
		};
		var syncIterationTypesResolver = {
			iterableCacheKey: "iterationTypesOfIterable",
			iteratorCacheKey: "iterationTypesOfIterator",
			iteratorSymbolName: "iterator",
			getGlobalIteratorType: getGlobalIteratorType,
			getGlobalIterableType: getGlobalIterableType,
			getGlobalIterableIteratorType: getGlobalIterableIteratorType,
			getGlobalGeneratorType: getGlobalGeneratorType,
			resolveIterationType: function (type, _errorNode) {
				return type;
			},
			mustHaveANextMethodDiagnostic: Diagnostics.An_iterator_must_have_a_next_method,
			mustBeAMethodDiagnostic: Diagnostics.The_0_property_of_an_iterator_must_be_a_method,
			mustHaveAValueDiagnostic: Diagnostics.The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property,
		};
		/** Key is "/path/to/a.ts|/path/to/b.ts". */
		var amalgamatedDuplicates;
		var reverseMappedCache = new Map();
		var inInferTypeForHomomorphicMappedType = false;
		var ambientModulesCache;
		/**
         * List of every ambient module with a "*" wildcard.
         * Unlike other ambient modules, these can't be stored in `globals` because symbol tables only deal with exact matches.
         * This is only used if there is no exact match.
         */
		var patternAmbientModules;
		var patternAmbientModuleAugmentations;
		var globalObjectType;
		var globalFunctionType;
		var globalCallableFunctionType;
		var globalNewableFunctionType;
		var globalArrayType;
		var globalReadonlyArrayType;
		var globalStringType;
		var globalNumberType;
		var globalBooleanType;
		var globalRegExpType;
		var globalThisType;
		var anyArrayType;
		var autoArrayType;
		var anyReadonlyArrayType;
		var deferredGlobalNonNullableTypeAlias;
		// The library files are only loaded when the feature is used.
		// This allows users to just specify library files they want to used through --lib
		// and they will not get an error from not having unrelated library files
		var deferredGlobalESSymbolConstructorSymbol;
		var deferredGlobalESSymbolConstructorTypeSymbol;
		var deferredGlobalESSymbolType;
		var deferredGlobalTypedPropertyDescriptorType;
		var deferredGlobalPromiseType;
		var deferredGlobalPromiseLikeType;
		var deferredGlobalPromiseConstructorSymbol;
		var deferredGlobalPromiseConstructorLikeType;
		var deferredGlobalIterableType;
		var deferredGlobalIteratorType;
		var deferredGlobalIterableIteratorType;
		var deferredGlobalGeneratorType;
		var deferredGlobalIteratorYieldResultType;
		var deferredGlobalIteratorReturnResultType;
		var deferredGlobalAsyncIterableType;
		var deferredGlobalAsyncIteratorType;
		var deferredGlobalAsyncIterableIteratorType;
		var deferredGlobalAsyncGeneratorType;
		var deferredGlobalTemplateStringsArrayType;
		var deferredGlobalImportMetaType;
		var deferredGlobalImportMetaExpressionType;
		var deferredGlobalImportCallOptionsType;
		var deferredGlobalExtractSymbol;
		var deferredGlobalOmitSymbol;
		var deferredGlobalAwaitedSymbol;
		var deferredGlobalBigIntType;
		var allPotentiallyUnusedIdentifiers = new Map(); // key is file name
		var flowLoopStart = 0;
		var flowLoopCount = 0;
		var sharedFlowCount = 0;
		var flowAnalysisDisabled = false;
		var flowInvocationCount = 0;
		var lastFlowNode;
		var lastFlowNodeReachable;
		var flowTypeCache;
		var emptyStringType = getStringLiteralType("");
		var zeroType = getNumberLiteralType(0);
		var zeroBigIntType = getBigIntLiteralType(
			{ negative: false, base10Value: "0" },
		);
		var resolutionTargets = [];
		var resolutionResults = [];
		var resolutionPropertyNames = [];
		var suggestionCount = 0;
		var maximumSuggestionCount = 10;
		var mergedSymbols = [];
		var symbolLinks = [];
		var nodeLinks = [];
		var flowLoopCaches = [];
		var flowLoopNodes = [];
		var flowLoopKeys = [];
		var flowLoopTypes = [];
		var sharedFlowNodes = [];
		var sharedFlowTypes = [];
		var flowNodeReachable = [];
		var flowNodePostSuper = [];
		var potentialThisCollisions = [];
		var potentialNewTargetCollisions = [];
		var potentialWeakMapSetCollisions = [];
		var potentialReflectCollisions = [];
		var awaitedTypeStack = [];
		var diagnostics = createDiagnosticCollection();
		var suggestionDiagnostics = createDiagnosticCollection();
		var typeofTypesByName = new Map(
			getEntries(
				{
					string: stringType,
					number: numberType,
					bigint: bigintType,
					boolean: booleanType,
					symbol: esSymbolType,
					undefined: undefinedType,
				},
			),
		);
		var typeofType = createTypeofType();
		var _jsxNamespace;
		var _jsxFactoryEntity;
		var outofbandVarianceMarkerHandler;
		var subtypeRelation = new Map();
		var strictSubtypeRelation = new Map();
		var assignableRelation = new Map();
		var comparableRelation = new Map();
		var identityRelation = new Map();
		var enumRelation = new Map();
		var builtinGlobals = createSymbolTable();
		builtinGlobals.set(undefinedSymbol.escapedName, undefinedSymbol);
		// Extensions suggested for path imports when module resolution is node12 or higher.
		// The first element of each tuple is the extension a file has.
		// The second element of each tuple is the extension that should be used in a path import.
		// e.g. if we want to import file `foo.mts`, we should write `import {} from "./foo.mjs".
		var suggestedExtensions = [
			[".mts", ".mjs"],
			[".ts", ".js"],
			[".cts", ".cjs"],
			[".mjs", ".mjs"],
			[".js", ".js"],
			[".cjs", ".cjs"],
			[".tsx", compilerOptions.jsx === JsxEmit.Preserve ? ".jsx" : ".js"],
			[".jsx", ".jsx"],
			[".json", ".json"],
		];
		initializeTypeChecker();
		return checker;
		function getJsxNamespace(location) {
			if (location) {
				var file = getSourceFileOfNode(location);
				if (file) {
					if (isJsxOpeningFragment(location)) {
						if (file.localJsxFragmentNamespace) {
							return file.localJsxFragmentNamespace;
						}
						var jsxFragmentPragma = file.pragmas.get("jsxfrag");
						if (jsxFragmentPragma) {
							var chosenPragma = isArray(jsxFragmentPragma) ? jsxFragmentPragma[0] : jsxFragmentPragma;
							file.localJsxFragmentFactory = parseIsolatedEntityName(
								chosenPragma.arguments.factory,
								languageVersion,
							);
							visitNode(file.localJsxFragmentFactory, markAsSynthetic);
							if (file.localJsxFragmentFactory) {
								return file.localJsxFragmentNamespace = getFirstIdentifier(
									file.localJsxFragmentFactory,
								).escapedText;
							}
						}
						var entity = getJsxFragmentFactoryEntity(location);
						if (entity) {
							file.localJsxFragmentFactory = entity;
							return file.localJsxFragmentNamespace = getFirstIdentifier(entity).escapedText;
						}
					} else {
						var localJsxNamespace = getLocalJsxNamespace(file);
						if (localJsxNamespace) {
							return file.localJsxNamespace = localJsxNamespace;
						}
					}
				}
			}
			if (!_jsxNamespace) {
				_jsxNamespace = "React";
				if (compilerOptions.jsxFactory) {
					_jsxFactoryEntity = parseIsolatedEntityName(
						compilerOptions.jsxFactory,
						languageVersion,
					);
					visitNode(_jsxFactoryEntity, markAsSynthetic);
					if (_jsxFactoryEntity) {
						_jsxNamespace = getFirstIdentifier(_jsxFactoryEntity).escapedText;
					}
				} else if (compilerOptions.reactNamespace) {
					_jsxNamespace = escapeLeadingUnderscores(
						compilerOptions.reactNamespace,
					);
				}
			}
			if (!_jsxFactoryEntity) {
				_jsxFactoryEntity = factory.createQualifiedName(
					factory.createIdentifier(unescapeLeadingUnderscores(_jsxNamespace)),
					"createElement",
				);
			}
			return _jsxNamespace;
		}
		function getLocalJsxNamespace(file) {
			if (file.localJsxNamespace) {
				return file.localJsxNamespace;
			}
			var jsxPragma = file.pragmas.get("jsx");
			if (jsxPragma) {
				var chosenPragma = isArray(jsxPragma) ? jsxPragma[0] : jsxPragma;
				file.localJsxFactory = parseIsolatedEntityName(
					chosenPragma.arguments.factory,
					languageVersion,
				);
				visitNode(file.localJsxFactory, markAsSynthetic);
				if (file.localJsxFactory) {
					return file.localJsxNamespace = getFirstIdentifier(
						file.localJsxFactory,
					).escapedText;
				}
			}
		}
		function markAsSynthetic(node) {
			setTextRangePosEnd(node, -1, -1);
			return visitEachChild(node, markAsSynthetic, nullTransformationContext);
		}
		function getEmitResolver(sourceFile, cancellationToken) {
			// Ensure we have all the type information in place for this file so that all the
			// emitter questions of this resolver will return the right information.
			getDiagnostics(sourceFile, cancellationToken);
			return emitResolver;
		}
		function lookupOrIssueError(location, message, arg0, arg1, arg2, arg3) {
			var diagnostic = location ? createDiagnosticForNode(
				location,
				message,
				arg0,
				arg1,
				arg2,
				arg3,
			) : createCompilerDiagnostic(message, arg0, arg1, arg2, arg3);
			var existing = diagnostics.lookup(diagnostic);
			if (existing) {
				return existing;
			} else {
				diagnostics.add(diagnostic);
				return diagnostic;
			}
		}
		function errorSkippedOn(key, location, message, arg0, arg1, arg2, arg3) {
			var diagnostic = error(location, message, arg0, arg1, arg2, arg3);
			diagnostic.skippedOn = key;
			return diagnostic;
		}
		function createError(location, message, arg0, arg1, arg2, arg3) {
			return location ? createDiagnosticForNode(
				location,
				message,
				arg0,
				arg1,
				arg2,
				arg3,
			) : createCompilerDiagnostic(message, arg0, arg1, arg2, arg3);
		}
		function error(location, message, arg0, arg1, arg2, arg3) {
			var diagnostic = createError(location, message, arg0, arg1, arg2, arg3);
			diagnostics.add(diagnostic);
			return diagnostic;
		}
		function addErrorOrSuggestion(isError, diagnostic) {
			if (isError) {
				diagnostics.add(diagnostic);
			} else {
				suggestionDiagnostics.add(
					__assign(
						__assign({}, diagnostic),
						{ category: DiagnosticCategory.Suggestion },
					),
				);
			}
		}
		function errorOrSuggestion(
			isError,
			location,
			message,
			arg0,
			arg1,
			arg2,
			arg3,
		) {
			// Pseudo-synthesized input node
			if (location.pos < 0 || location.end < 0) {
				if (!isError) {
					return; // Drop suggestions (we have no span to suggest on)
				}
				// Issue errors globally
				var file = getSourceFileOfNode(location);
				addErrorOrSuggestion(
					isError,
					"message" in message ? createFileDiagnostic(
						file,
						0,
						0,
						message,
						arg0,
						arg1,
						arg2,
						arg3,
					) : createDiagnosticForFileFromMessageChain(file, message),
				); // eslint-disable-line no-in-operator
				return;
			}
			addErrorOrSuggestion(
				isError,
				"message" in message ? createDiagnosticForNode(
					location,
					message,
					arg0,
					arg1,
					arg2,
					arg3,
				) : createDiagnosticForNodeFromMessageChain(location, message),
			); // eslint-disable-line no-in-operator
		}
		function errorAndMaybeSuggestAwait(
			location,
			maybeMissingAwait,
			message,
			arg0,
			arg1,
			arg2,
			arg3,
		) {
			var diagnostic = error(location, message, arg0, arg1, arg2, arg3);
			if (maybeMissingAwait) {
				var related = createDiagnosticForNode(
					location,
					Diagnostics.Did_you_forget_to_use_await,
				);
				addRelatedInfo(diagnostic, related);
			}
			return diagnostic;
		}
		function addDeprecatedSuggestionWorker(declarations, diagnostic) {
			var deprecatedTag = Array.isArray(declarations) ? forEach(
				declarations,
				getJSDocDeprecatedTag,
			) : getJSDocDeprecatedTag(declarations);
			if (deprecatedTag) {
				addRelatedInfo(
					diagnostic,
					createDiagnosticForNode(
						deprecatedTag,
						Diagnostics.The_declaration_was_marked_as_deprecated_here,
					),
				);
			}
			// We call `addRelatedInfo()` before adding the diagnostic to prevent duplicates.
			suggestionDiagnostics.add(diagnostic);
			return diagnostic;
		}
		function addDeprecatedSuggestion(location, declarations, deprecatedEntity) {
			var diagnostic = createDiagnosticForNode(
				location,
				Diagnostics._0_is_deprecated,
				deprecatedEntity,
			);
			return addDeprecatedSuggestionWorker(declarations, diagnostic);
		}
		function addDeprecatedSuggestionWithSignature(
			location,
			declaration,
			deprecatedEntity,
			signatureString,
		) {
			var diagnostic = deprecatedEntity ? createDiagnosticForNode(
				location,
				Diagnostics.The_signature_0_of_1_is_deprecated,
				signatureString,
				deprecatedEntity,
			) : createDiagnosticForNode(
				location,
				Diagnostics._0_is_deprecated,
				signatureString,
			);
			return addDeprecatedSuggestionWorker(declaration, diagnostic);
		}
		function createSymbol(flags, name, checkFlags) {
			symbolCount++;
			var symbol = new Symbol(flags | SymbolFlags.Transient, name);
			symbol.checkFlags = checkFlags || 0;
			return symbol;
		}
		function getExcludedSymbolFlags(flags) {
			var result = 0;
			if (flags & SymbolFlags.BlockScopedVariable) result |= SymbolFlags.BlockScopedVariableExcludes;
			if (flags & SymbolFlags.FunctionScopedVariable) result |= SymbolFlags.FunctionScopedVariableExcludes;
			if (flags & SymbolFlags.Property) result |= SymbolFlags.PropertyExcludes;
			if (flags & SymbolFlags.EnumMember) result |= SymbolFlags.EnumMemberExcludes;
			if (flags & SymbolFlags.Function) result |= SymbolFlags.FunctionExcludes;
			if (flags & SymbolFlags.Class) result |= SymbolFlags.ClassExcludes;
			if (flags & SymbolFlags.Interface) result |= SymbolFlags.InterfaceExcludes;
			if (flags & SymbolFlags.RegularEnum) result |= SymbolFlags.RegularEnumExcludes;
			if (flags & SymbolFlags.ConstEnum) result |= SymbolFlags.ConstEnumExcludes;
			if (flags & SymbolFlags.ValueModule) result |= SymbolFlags.ValueModuleExcludes;
			if (flags & SymbolFlags.Method) result |= SymbolFlags.MethodExcludes;
			if (flags & SymbolFlags.GetAccessor) result |= SymbolFlags.GetAccessorExcludes;
			if (flags & SymbolFlags.SetAccessor) result |= SymbolFlags.SetAccessorExcludes;
			if (flags & SymbolFlags.TypeParameter) result |= SymbolFlags.TypeParameterExcludes;
			if (flags & SymbolFlags.TypeAlias) result |= SymbolFlags.TypeAliasExcludes;
			if (flags & SymbolFlags.Alias) result |= SymbolFlags.AliasExcludes;
			return result;
		}
		function recordMergedSymbol(target, source) {
			if (!source.mergeId) {
				source.mergeId = nextMergeId;
				nextMergeId++;
			}
			mergedSymbols[source.mergeId] = target;
		}
		function cloneSymbol(symbol) {
			var result = createSymbol(symbol.flags, symbol.escapedName);
			result.declarations = symbol.declarations ? symbol.declarations.slice() : [];
			result.parent = symbol.parent;
			if (symbol.valueDeclaration) result.valueDeclaration = symbol.valueDeclaration;
			if (symbol.constEnumOnlyModule) result.constEnumOnlyModule = true;
			if (symbol.members) result.members = new Map(symbol.members);
			if (symbol.exports) result.exports = new Map(symbol.exports);
			recordMergedSymbol(result, symbol);
			return result;
		}
		/**
         * Note: if target is transient, then it is mutable, and mergeSymbol with both mutate and return it.
         * If target is not transient, mergeSymbol will produce a transient clone, mutate that and return it.
         */
		function mergeSymbol(target, source, unidirectional) {
			if (unidirectional === void 0) {
				unidirectional = false;
			}
			if (
				!(target.flags & getExcludedSymbolFlags(source.flags)) || (source.flags | target.flags) & SymbolFlags.Assignment
			) {
				if (source === target) {
					// This can happen when an export assigned namespace exports something also erroneously exported at the top level
					// See `declarationFileNoCrashOnExtraExportModifier` for an example
					return target;
				}
				if (!(target.flags & SymbolFlags.Transient)) {
					var resolvedTarget = resolveSymbol(target);
					if (resolvedTarget === unknownSymbol) {
						return source;
					}
					target = cloneSymbol(resolvedTarget);
				}
				// Javascript static-property-assignment declarations always merge, even though they are also values
				if (
					source.flags & SymbolFlags.ValueModule && target.flags & SymbolFlags.ValueModule && target.constEnumOnlyModule && !source.constEnumOnlyModule
				) {
					// reset flag when merging instantiated module into value module that has only const enums
					target.constEnumOnlyModule = false;
				}
				target.flags |= source.flags;
				if (source.valueDeclaration) {
					setValueDeclaration(target, source.valueDeclaration);
				}
				addRange(target.declarations, source.declarations);
				if (source.members) {
					if (!target.members) target.members = createSymbolTable();
					mergeSymbolTable(target.members, source.members, unidirectional);
				}
				if (source.exports) {
					if (!target.exports) target.exports = createSymbolTable();
					mergeSymbolTable(target.exports, source.exports, unidirectional);
				}
				if (!unidirectional) {
					recordMergedSymbol(target, source);
				}
			} else if (target.flags & SymbolFlags.NamespaceModule) {
				// Do not report an error when merging `var globalThis` with the built-in `globalThis`,
				// as we will already report a "Declaration name conflicts..." error, and this error
				// won't make much sense.
				if (target !== globalThisSymbol) {
					error(
						source.declarations && getNameOfDeclaration(source.declarations[0]),
						Diagnostics.Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity,
						symbolToString(target),
					);
				}
			} else {
				var isEitherEnum = !!(target.flags & SymbolFlags.Enum || source.flags & SymbolFlags.Enum); // error
				var isEitherBlockScoped_1 = !!(target.flags & SymbolFlags.BlockScopedVariable || source.flags & SymbolFlags.BlockScopedVariable);
				var message = isEitherEnum ? Diagnostics.Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations : isEitherBlockScoped_1 ? Diagnostics.Cannot_redeclare_block_scoped_variable_0 : Diagnostics.Duplicate_identifier_0;
				var sourceSymbolFile = source.declarations && getSourceFileOfNode(
					source.declarations[0],
				);
				var targetSymbolFile = target.declarations && getSourceFileOfNode(
					target.declarations[0],
				);
				var symbolName = symbolToString(source);
				// Collect top-level duplicate identifier errors into one mapping, so we can then merge their diagnostics if there are a bunch
				if (
					sourceSymbolFile && targetSymbolFile && amalgamatedDuplicates && !isEitherEnum && sourceSymbolFile !== targetSymbolFile
				) {
					var firstFile_1 = comparePaths(
						sourceSymbolFile.path,
						targetSymbolFile.path,
					) === Comparison.LessThan ? sourceSymbolFile : targetSymbolFile;
					var secondFile_1 = firstFile_1 === sourceSymbolFile ? targetSymbolFile : sourceSymbolFile;
					var filesDuplicates = getOrUpdate(
						amalgamatedDuplicates,
						"".concat(firstFile_1.path, "|").concat(secondFile_1.path),
						function () {
							return ({
								firstFile: firstFile_1,
								secondFile: secondFile_1,
								conflictingSymbols: new Map(),
							});
						},
					);
					var conflictingSymbolInfo = getOrUpdate(
						filesDuplicates.conflictingSymbols,
						symbolName,
						function () {
							return ({
								isBlockScoped: isEitherBlockScoped_1,
								firstFileLocations: [],
								secondFileLocations: [],
							});
						},
					);
					addDuplicateLocations(
						conflictingSymbolInfo.firstFileLocations,
						source,
					);
					addDuplicateLocations(
						conflictingSymbolInfo.secondFileLocations,
						target,
					);
				} else {
					addDuplicateDeclarationErrorsForSymbols(
						source,
						message,
						symbolName,
						target,
					);
					addDuplicateDeclarationErrorsForSymbols(
						target,
						message,
						symbolName,
						source,
					);
				}
			}
			return target;
			function addDuplicateLocations(locs, symbol) {
				if (symbol.declarations) {
					for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
						var decl = _a[_i];
						pushIfUnique(locs, decl);
					}
				}
			}
		}
		function addDuplicateDeclarationErrorsForSymbols(
			target,
			message,
			symbolName,
			source,
		) {
			forEach(
				target.declarations,
				function (node) {
					addDuplicateDeclarationError(
						node,
						message,
						symbolName,
						source.declarations,
					);
				},
			);
		}
		function addDuplicateDeclarationError(
			node,
			message,
			symbolName,
			relatedNodes,
		) {
			var errorNode = (getExpandoInitializer(
				node, /*isPrototypeAssignment*/
				false,
			) ? getNameOfExpando(node) : getNameOfDeclaration(node)) || node;
			var err = lookupOrIssueError(errorNode, message, symbolName);
			var _loop_1 = function (relatedNode) {
				var adjustedNode = (getExpandoInitializer(
					relatedNode, /*isPrototypeAssignment*/
					false,
				) ? getNameOfExpando(relatedNode) : getNameOfDeclaration(relatedNode)) || relatedNode;
				if (adjustedNode === errorNode) return "continue";
				err.relatedInformation = err.relatedInformation || [];
				var leadingMessage = createDiagnosticForNode(
					adjustedNode,
					Diagnostics._0_was_also_declared_here,
					symbolName,
				);
				var followOnMessage = createDiagnosticForNode(
					adjustedNode,
					Diagnostics.and_here,
				);
				if (
					length(err.relatedInformation) >= 5 || some(
						err.relatedInformation,
						function (r) {
							return compareDiagnostics(r, followOnMessage) === Comparison.EqualTo || compareDiagnostics(
								r,
								leadingMessage,
							) === Comparison.EqualTo;
						},
					)
				) return "continue";
				addRelatedInfo(
					err,
					!length(err.relatedInformation) ? leadingMessage : followOnMessage,
				);
			};
			for (var _i = 0, _a = relatedNodes || emptyArray; _i < _a.length; _i++) {
				var relatedNode = _a[_i];
				_loop_1(relatedNode);
			}
		}
		function combineSymbolTables(first, second) {
			if (!(first === null || first === void 0 ? void 0 : first.size)) return second;
			if (!(second === null || second === void 0 ? void 0 : second.size)) return first;
			var combined = createSymbolTable();
			mergeSymbolTable(combined, first);
			mergeSymbolTable(combined, second);
			return combined;
		}
		function mergeSymbolTable(target, source, unidirectional) {
			if (unidirectional === void 0) {
				unidirectional = false;
			}
			source.forEach(
				function (sourceSymbol, id) {
					var targetSymbol = target.get(id);
					target.set(
						id,
						targetSymbol ? mergeSymbol(
							targetSymbol,
							sourceSymbol,
							unidirectional,
						) : sourceSymbol,
					);
				},
			);
		}
		function mergeModuleAugmentation(moduleName) {
			var _a, _b, _c;
			var moduleAugmentation = moduleName.parent;
			if (
				((_a = moduleAugmentation.symbol.declarations) === null || _a === void 0 ? void 0 : _a[0]) !== moduleAugmentation
			) {
				// this is a combined symbol for multiple augmentations within the same file.
				// its symbol already has accumulated information for all declarations
				// so we need to add it just once - do the work only for first declaration
				Debug.assert(moduleAugmentation.symbol.declarations.length > 1);
				return;
			}
			if (isGlobalScopeAugmentation(moduleAugmentation)) {
				mergeSymbolTable(globals, moduleAugmentation.symbol.exports);
			} else {
				// find a module that about to be augmented
				// do not validate names of augmentations that are defined in ambient context
				var moduleNotFoundError = !(moduleName.parent.parent.flags & NodeFlags.Ambient) ? Diagnostics.Invalid_module_name_in_augmentation_module_0_cannot_be_found : undefined;
				var mainModule_1 = resolveExternalModuleNameWorker(
					moduleName,
					moduleName,
					moduleNotFoundError, /*isForAugmentation*/
					true,
				);
				if (!mainModule_1) {
					return;
				}
				// obtain item referenced by 'export='
				mainModule_1 = resolveExternalModuleSymbol(mainModule_1);
				if (mainModule_1.flags & SymbolFlags.Namespace) {
					// If we're merging an augmentation to a pattern ambient module, we want to
					// perform the merge unidirectionally from the augmentation ('a.foo') to
					// the pattern ('*.foo'), so that 'getMergedSymbol()' on a.foo gives you
					// all the exports both from the pattern and from the augmentation, but
					// 'getMergedSymbol()' on *.foo only gives you exports from *.foo.
					if (
						some(
							patternAmbientModules,
							function (module) {
								return mainModule_1 === module.symbol;
							},
						)
					) {
						var merged = mergeSymbol(
							moduleAugmentation.symbol,
							mainModule_1, /*unidirectional*/
							true,
						);
						if (!patternAmbientModuleAugmentations) {
							patternAmbientModuleAugmentations = new Map();
						}
						// moduleName will be a StringLiteral since this is not `declare global`.
						patternAmbientModuleAugmentations.set(moduleName.text, merged);
					} else {
						if (
							((_b = mainModule_1.exports) === null || _b === void 0 ? void 0 : _b.get(
								InternalSymbolName.ExportStar,
							)) && ((_c = moduleAugmentation.symbol.exports) === null || _c === void 0 ? void 0 : _c.size)
						) {
							// We may need to merge the module augmentation's exports into the target symbols of the resolved exports
							var resolvedExports = getResolvedMembersOrExportsOfSymbol(
								mainModule_1,
								"resolvedExports", /* resolvedExports */
							);
							for (
								var _i = 0,
									_d = arrayFrom(moduleAugmentation.symbol.exports.entries());
								_i < _d.length;
								_i++
							) {
								var _e = _d[_i], key = _e[0], value = _e[1];
								if (resolvedExports.has(key) && !mainModule_1.exports.has(key)) {
									mergeSymbol(resolvedExports.get(key), value);
								}
							}
						}
						mergeSymbol(mainModule_1, moduleAugmentation.symbol);
					}
				} else {
					// moduleName will be a StringLiteral since this is not `declare global`.
					error(
						moduleName,
						Diagnostics.Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity,
						moduleName.text,
					);
				}
			}
		}
		function addToSymbolTable(target, source, message) {
			source.forEach(
				function (sourceSymbol, id) {
					var targetSymbol = target.get(id);
					if (targetSymbol) {
						// Error on redeclarations
						forEach(
							targetSymbol.declarations,
							addDeclarationDiagnostic(unescapeLeadingUnderscores(id), message),
						);
					} else {
						target.set(id, sourceSymbol);
					}
				},
			);
			function addDeclarationDiagnostic(id, message) {
				return function (declaration) {
					return diagnostics.add(
						createDiagnosticForNode(declaration, message, id),
					);
				};
			}
		}
		function getSymbolLinks(symbol) {
			if (symbol.flags & SymbolFlags.Transient) return symbol;
			var id = getSymbolId(symbol);
			return symbolLinks[id] || (symbolLinks[id] = new SymbolLinks());
		}
		function getNodeLinks(node) {
			var nodeId = getNodeId(node);
			return nodeLinks[nodeId] || (nodeLinks[nodeId] = new NodeLinks());
		}
		function isGlobalSourceFile(node) {
			return node.kind === SyntaxKind.SourceFile && !isExternalOrCommonJsModule(
				node,
			);
		}
		function getSymbol(symbols, name, meaning) {
			if (meaning) {
				var symbol = getMergedSymbol(symbols.get(name));
				if (symbol) {
					Debug.assert(
						(getCheckFlags(symbol) & CheckFlags.Instantiated) === 0,
						"Should never get an instantiated symbol here.",
					);
					if (symbol.flags & meaning) {
						return symbol;
					}
					if (symbol.flags & SymbolFlags.Alias) {
						var target = resolveAlias(symbol);
						// Unknown symbol means an error occurred in alias resolution, treat it as positive answer to avoid cascading errors
						if (target === unknownSymbol || target.flags & meaning) {
							return symbol;
						}
					}
				}
			} // return undefined if we can't find a symbol.
		}
		/**
         * Get symbols that represent parameter-property-declaration as parameter and as property declaration
         * @param parameter a parameterDeclaration node
         * @param parameterName a name of the parameter to get the symbols for.
         * @return a tuple of two symbols
         */
		function getSymbolsOfParameterPropertyDeclaration(parameter, parameterName) {
			var constructorDeclaration = parameter.parent;
			var classDeclaration = parameter.parent.parent;
			var parameterSymbol = getSymbol(
				constructorDeclaration.locals,
				parameterName,
				SymbolFlags.Value,
			);
			var propertySymbol = getSymbol(
				getMembersOfSymbol(classDeclaration.symbol),
				parameterName,
				SymbolFlags.Value,
			);
			if (parameterSymbol && propertySymbol) {
				return [parameterSymbol, propertySymbol];
			}
			return Debug.fail(
				"There should exist two symbols, one as property declaration and one as parameter declaration",
			);
		}
		function isBlockScopedNameDeclaredBeforeUse(declaration, usage) {
			var declarationFile = getSourceFileOfNode(declaration);
			var useFile = getSourceFileOfNode(usage);
			var declContainer = getEnclosingBlockScopeContainer(declaration);
			if (declarationFile !== useFile) {
				if (
					(moduleKind && (declarationFile.externalModuleIndicator || useFile.externalModuleIndicator)) || (!outFile(
						compilerOptions,
					)) || isInTypeQuery(usage) || declaration.flags & NodeFlags.Ambient
				) {
					// nodes are in different files and order cannot be determined
					return true;
				}
				// declaration is after usage
				// can be legal if usage is deferred (i.e. inside function or in initializer of instance property)
				if (isUsedInFunctionOrInstanceProperty(usage, declaration)) {
					return true;
				}
				var sourceFiles = host.getSourceFiles();
				return sourceFiles.indexOf(declarationFile) <= sourceFiles.indexOf(
					useFile,
				);
			}
			if (
				declaration.pos <= usage.pos && !(isPropertyDeclaration(declaration) && isThisProperty(
					usage.parent,
				) && !declaration.initializer && !declaration.exclamationToken)
			) {
				// declaration is before usage
				if (declaration.kind === SyntaxKind.BindingElement) {
					// still might be illegal if declaration and usage are both binding elements (eg var [a = b, b = b] = [1, 2])
					var errorBindingElement = getAncestor(
						usage,
						SyntaxKind.BindingElement,
					);
					if (errorBindingElement) {
						return findAncestor(errorBindingElement, isBindingElement) !== findAncestor(
							declaration,
							isBindingElement,
						) || declaration.pos < errorBindingElement.pos;
					}
					// or it might be illegal if usage happens before parent variable is declared (eg var [a] = a)
					return isBlockScopedNameDeclaredBeforeUse(
						getAncestor(declaration, SyntaxKind.VariableDeclaration),
						usage,
					);
				} else if (declaration.kind === SyntaxKind.VariableDeclaration) {
					// still might be illegal if usage is in the initializer of the variable declaration (eg var a = a)
					return !isImmediatelyUsedInInitializerOfBlockScopedVariable(
						declaration,
						usage,
					);
				} else if (isClassDeclaration(declaration)) {
					// still might be illegal if the usage is within a computed property name in the class (eg class A { static p = "a"; [A.p]() {} })
					return !findAncestor(
						usage,
						function (n) {
							return isComputedPropertyName(n) && n.parent.parent === declaration;
						},
					);
				} else if (isPropertyDeclaration(declaration)) {
					// still might be illegal if a self-referencing property initializer (eg private x = this.x)
					return !isPropertyImmediatelyReferencedWithinDeclaration(
						declaration,
						usage, /*stopAtAnyPropertyDeclaration*/
						false,
					);
				} else if (
					isParameterPropertyDeclaration(declaration, declaration.parent)
				) {
					// foo = this.bar is illegal in esnext+useDefineForClassFields when bar is a parameter property
					return !(getEmitScriptTarget(compilerOptions) === ScriptTarget.ESNext && useDefineForClassFields && getContainingClass(
						declaration,
					) === getContainingClass(usage) && isUsedInFunctionOrInstanceProperty(
						usage,
						declaration,
					));
				}
				return true;
			}
			// declaration is after usage, but it can still be legal if usage is deferred:
			// 1. inside an export specifier
			// 2. inside a function
			// 3. inside an instance property initializer, a reference to a non-instance property
			//    (except when target: "esnext" and useDefineForClassFields: true and the reference is to a parameter property)
			// 4. inside a static property initializer, a reference to a static method in the same class
			// 5. inside a TS export= declaration (since we will move the export statement during emit to avoid TDZ)
			// or if usage is in a type context:
			// 1. inside a type query (typeof in type position)
			// 2. inside a jsdoc comment
			if (
				usage.parent.kind === SyntaxKind.ExportSpecifier || (usage.parent.kind === SyntaxKind.ExportAssignment && usage.parent.isExportEquals)
			) {
				// export specifiers do not use the variable, they only make it available for use
				return true;
			}
			// When resolving symbols for exports, the `usage` location passed in can be the export site directly
			if (usage.kind === SyntaxKind.ExportAssignment && usage.isExportEquals) {
				return true;
			}
			if (
				!!(usage.flags & NodeFlags.JSDoc) || isInTypeQuery(usage) || usageInTypeDeclaration()
			) {
				return true;
			}
			if (isUsedInFunctionOrInstanceProperty(usage, declaration)) {
				if (
					getEmitScriptTarget(compilerOptions) === ScriptTarget.ESNext && useDefineForClassFields && getContainingClass(
						declaration,
					) && (isPropertyDeclaration(declaration) || isParameterPropertyDeclaration(
						declaration,
						declaration.parent,
					))
				) {
					return !isPropertyImmediatelyReferencedWithinDeclaration(
						declaration,
						usage, /*stopAtAnyPropertyDeclaration*/
						true,
					);
				} else {
					return true;
				}
			}
			return false;
			function usageInTypeDeclaration() {
				return !!findAncestor(
					usage,
					function (node) {
						return isInterfaceDeclaration(node) || isTypeAliasDeclaration(node);
					},
				);
			}
			function isImmediatelyUsedInInitializerOfBlockScopedVariable(
				declaration,
				usage,
			) {
				switch (declaration.parent.parent.kind) {
					case SyntaxKind.VariableStatement:
					case SyntaxKind.ForStatement:
					case SyntaxKind.ForOfStatement:
						// variable statement/for/for-of statement case,
						// use site should not be inside variable declaration (initializer of declaration or binding element)
						if (isSameScopeDescendentOf(usage, declaration, declContainer)) {
							return true;
						}
						break;
				}
				// ForIn/ForOf case - use site should not be used in expression part
				var grandparent = declaration.parent.parent;
				return isForInOrOfStatement(grandparent) && isSameScopeDescendentOf(
					usage,
					grandparent.expression,
					declContainer,
				);
			}
			function isUsedInFunctionOrInstanceProperty(usage, declaration) {
				return !!findAncestor(
					usage,
					function (current) {
						if (current === declContainer) {
							return "quit";
						}
						if (isFunctionLike(current)) {
							return true;
						}
						if (isClassStaticBlockDeclaration(current)) {
							return declaration.pos < usage.pos;
						}
						var propertyDeclaration = tryCast(
							current.parent,
							isPropertyDeclaration,
						);
						if (propertyDeclaration) {
							var initializerOfProperty = propertyDeclaration.initializer === current;
							if (initializerOfProperty) {
								if (isStatic(current.parent)) {
									if (declaration.kind === SyntaxKind.MethodDeclaration) {
										return true;
									}
									if (
										isPropertyDeclaration(declaration) && getContainingClass(
											usage,
										) === getContainingClass(declaration)
									) {
										var propName = declaration.name;
										if (isIdentifier(propName) || isPrivateIdentifier(propName)) {
											var type = getTypeOfSymbol(getSymbolOfNode(declaration));
											var staticBlocks = filter(
												declaration.parent.members,
												isClassStaticBlockDeclaration,
											);
											if (
												isPropertyInitializedInStaticBlocks(
													propName,
													type,
													staticBlocks,
													declaration.parent.pos,
													current.pos,
												)
											) {
												return true;
											}
										}
									}
								} else {
									var isDeclarationInstanceProperty = declaration.kind === SyntaxKind.PropertyDeclaration && !isStatic(
										declaration,
									);
									if (
										!isDeclarationInstanceProperty || getContainingClass(usage) !== getContainingClass(
											declaration,
										)
									) {
										return true;
									}
								}
							}
						}
						return false;
					},
				);
			}
			/** stopAtAnyPropertyDeclaration is used for detecting ES-standard class field use-before-def errors */
			function isPropertyImmediatelyReferencedWithinDeclaration(
				declaration,
				usage,
				stopAtAnyPropertyDeclaration,
			) {
				// always legal if usage is after declaration
				if (usage.end > declaration.end) {
					return false;
				}
				// still might be legal if usage is deferred (e.g. x: any = () => this.x)
				// otherwise illegal if immediately referenced within the declaration (e.g. x: any = this.x)
				var ancestorChangingReferenceScope = findAncestor(
					usage,
					function (node) {
						if (node === declaration) {
							return "quit";
						}
						switch (node.kind) {
							case SyntaxKind.ArrowFunction:
								return true;
							case SyntaxKind.PropertyDeclaration:
								// even when stopping at any property declaration, they need to come from the same class
								return stopAtAnyPropertyDeclaration && (isPropertyDeclaration(
									declaration,
								) && node.parent === declaration.parent || isParameterPropertyDeclaration(
									declaration,
									declaration.parent,
								) && node.parent === declaration.parent.parent) ? "quit" : true;
							case SyntaxKind.Block:
								switch (node.parent.kind) {
									case SyntaxKind.GetAccessor:
									case SyntaxKind.MethodDeclaration:
									case SyntaxKind.SetAccessor:
										return true;
									default:
										return false;
								}
							default:
								return false;
						}
					},
				);
				return ancestorChangingReferenceScope === undefined;
			}
		}
		function useOuterVariableScopeInParameter(result, location, lastLocation) {
			var target = getEmitScriptTarget(compilerOptions);
			var functionLocation = location;
			if (
				isParameter(lastLocation) && functionLocation.body && result.valueDeclaration && result.valueDeclaration.pos >= functionLocation.body.pos && result.valueDeclaration.end <= functionLocation.body.end
			) {
				// check for several cases where we introduce temporaries that require moving the name/initializer of the parameter to the body
				// - static field in a class expression
				// - optional chaining pre-es2020
				// - nullish coalesce pre-es2020
				// - spread assignment in binding pattern pre-es2017
				if (target >= ScriptTarget.ES2015) {
					var links = getNodeLinks(functionLocation);
					if (links.declarationRequiresScopeChange === undefined) {
						links.declarationRequiresScopeChange = forEach(
							functionLocation.parameters,
							requiresScopeChange,
						) || false;
					}
					return !links.declarationRequiresScopeChange;
				}
			}
			return false;
			function requiresScopeChange(node) {
				return requiresScopeChangeWorker(node.name) || !!node.initializer && requiresScopeChangeWorker(
					node.initializer,
				);
			}
			function requiresScopeChangeWorker(node) {
				switch (node.kind) {
					case SyntaxKind.ArrowFunction:
					case SyntaxKind.FunctionExpression:
					case SyntaxKind.FunctionDeclaration:
					case SyntaxKind.Constructor:
						// do not descend into these
						return false;
					case SyntaxKind.MethodDeclaration:
					case SyntaxKind.GetAccessor:
					case SyntaxKind.SetAccessor:
					case SyntaxKind.PropertyAssignment:
						return requiresScopeChangeWorker(node.name);
					case SyntaxKind.PropertyDeclaration:
						// static properties in classes introduce temporary variables
						if (hasStaticModifier(node)) {
							return target < ScriptTarget.ESNext || !useDefineForClassFields;
						}
						return requiresScopeChangeWorker(node.name);
					default:
						// null coalesce and optional chain pre-es2020 produce temporary variables
						if (isNullishCoalesce(node) || isOptionalChain(node)) {
							return target < ScriptTarget.ES2020;
						}
						if (
							isBindingElement(node) && node.dotDotDotToken && isObjectBindingPattern(
								node.parent,
							)
						) {
							return target < ScriptTarget.ES2017;
						}
						if (isTypeNode(node)) return false;
						return forEachChild(node, requiresScopeChangeWorker) || false;
				}
			}
		}
		/**
         * Resolve a given name for a given meaning at a given location. An error is reported if the name was not found and
         * the nameNotFoundMessage argument is not undefined. Returns the resolved symbol, or undefined if no symbol with
         * the given name can be found.
         *
         * @param isUse If true, this will count towards --noUnusedLocals / --noUnusedParameters.
         */
		function resolveName(
			location,
			name,
			meaning,
			nameNotFoundMessage,
			nameArg,
			isUse,
			excludeGlobals,
			getSpellingSuggstions,
		) {
			if (excludeGlobals === void 0) {
				excludeGlobals = false;
			}
			if (getSpellingSuggstions === void 0) {
				getSpellingSuggstions = true;
			}
			return resolveNameHelper(
				location,
				name,
				meaning,
				nameNotFoundMessage,
				nameArg,
				isUse,
				excludeGlobals,
				getSpellingSuggstions,
				getSymbol,
			);
		}
		function resolveNameHelper(
			location,
			name,
			meaning,
			nameNotFoundMessage,
			nameArg,
			isUse,
			excludeGlobals,
			getSpellingSuggestions,
			lookup,
		) {
			var _a, _b, _c;
			var originalLocation = location; // needed for did-you-mean error reporting, which gathers candidates starting from the original location
			var result;
			var lastLocation;
			var lastSelfReferenceLocation;
			var propertyWithInvalidInitializer;
			var associatedDeclarationForContainingInitializerOrBindingName;
			var withinDeferredContext = false;
			var errorLocation = location;
			var grandparent;
			var isInExternalModule = false;
			loop: while (location) {
				// Locals of a source file are not in scope (because they get merged into the global symbol table)
				if (location.locals && !isGlobalSourceFile(location)) {
					if (result = lookup(location.locals, name, meaning)) {
						var useResult = true;
						if (
							isFunctionLike(location) && lastLocation && lastLocation !== location.body
						) {
							// symbol lookup restrictions for function-like declarations
							// - Type parameters of a function are in scope in the entire function declaration, including the parameter
							//   list and return type. However, local types are only in scope in the function body.
							// - parameters are only in the scope of function body
							// This restriction does not apply to JSDoc comment types because they are parented
							// at a higher level than type parameters would normally be
							if (
								meaning & result.flags & SymbolFlags.Type && lastLocation.kind !== SyntaxKind.JSDocComment
							) {
								useResult = result.flags & SymbolFlags.TypeParameter ? lastLocation === location.type || lastLocation.kind === SyntaxKind.Parameter || lastLocation.kind === SyntaxKind.TypeParameter : false; // type parameters are visible in parameter list, return type and type parameter list // local types not visible outside the function body
							}
							if (meaning & result.flags & SymbolFlags.Variable) {
								// expression inside parameter will lookup as normal variable scope when targeting es2015+
								if (
									useOuterVariableScopeInParameter(
										result,
										location,
										lastLocation,
									)
								) {
									useResult = false;
								} else if (result.flags & SymbolFlags.FunctionScopedVariable) {
									// parameters are visible only inside function body, parameter list and return type
									// technically for parameter list case here we might mix parameters and variables declared in function,
									// however it is detected separately when checking initializers of parameters
									// to make sure that they reference no variables declared after them.
									useResult = lastLocation.kind === SyntaxKind.Parameter || (lastLocation === location.type && !!findAncestor(
										result.valueDeclaration,
										isParameter,
									));
								}
							}
						} else if (location.kind === SyntaxKind.ConditionalType) {
							// A type parameter declared using 'infer T' in a conditional type is visible only in
							// the true branch of the conditional type.
							useResult = lastLocation === location.trueType;
						}
						if (useResult) {
							break loop;
						} else {
							result = undefined;
						}
					}
				}
				withinDeferredContext = withinDeferredContext || getIsDeferredContext(
					location,
					lastLocation,
				);
				switch (location.kind) {
					case SyntaxKind.SourceFile:
						if (!isExternalOrCommonJsModule(location)) break;
						isInExternalModule = true;
					// falls through
					case SyntaxKind.ModuleDeclaration:
						var moduleExports = ((_a = getSymbolOfNode(location)) === null || _a === void 0 ? void 0 : _a.exports) || emptySymbols;
						if (
							location.kind === SyntaxKind.SourceFile || (isModuleDeclaration(
								location,
							) && location.flags & NodeFlags.Ambient && !isGlobalScopeAugmentation(
								location,
							))
						) {
							// It's an external module. First see if the module has an export default and if the local
							// name of that export default matches.
							if (result = moduleExports.get(InternalSymbolName.Default)) {
								var localSymbol = getLocalSymbolForExportDefault(result);
								if (
									localSymbol && (result.flags & meaning) && localSymbol.escapedName === name
								) {
									break loop;
								}
								result = undefined;
							}
							// Because of module/namespace merging, a module's exports are in scope,
							// yet we never want to treat an export specifier as putting a member in scope.
							// Therefore, if the name we find is purely an export specifier, it is not actually considered in scope.
							// Two things to note about this:
							//     1. We have to check this without calling getSymbol. The problem with calling getSymbol
							//        on an export specifier is that it might find the export specifier itself, and try to
							//        resolve it as an alias. This will cause the checker to consider the export specifier
							//        a circular alias reference when it might not be.
							//     2. We check === SymbolFlags.Alias in order to check that the symbol is *purely*
							//        an alias. If we used &, we'd be throwing out symbols that have non alias aspects,
							//        which is not the desired behavior.
							var moduleExport = moduleExports.get(name);
							if (
								moduleExport && moduleExport.flags === SymbolFlags.Alias && (getDeclarationOfKind(
									moduleExport,
									SyntaxKind.ExportSpecifier,
								) || getDeclarationOfKind(
									moduleExport,
									SyntaxKind.NamespaceExport,
								))
							) {
								break;
							}
						}
						// ES6 exports are also visible locally (except for 'default'), but commonjs exports are not (except typedefs)
						if (
							name !== InternalSymbolName.Default && (result = lookup(
								moduleExports,
								name,
								meaning & SymbolFlags.ModuleMember,
							))
						) {
							if (
								isSourceFile(location) && location.commonJsModuleIndicator && !((_b = result.declarations) === null || _b === void 0 ? void 0 : _b.some(
									isJSDocTypeAlias,
								))
							) {
								result = undefined;
							} else {
								break loop;
							}
						}
						break;
					case SyntaxKind.EnumDeclaration:
						if (
							result = lookup(
								((_c = getSymbolOfNode(location)) === null || _c === void 0 ? void 0 : _c.exports) || emptySymbols,
								name,
								meaning & SymbolFlags.EnumMember,
							)
						) {
							break loop;
						}
						break;
					case SyntaxKind.PropertyDeclaration:
						// TypeScript 1.0 spec (April 2014): 8.4.1
						// Initializer expressions for instance member variables are evaluated in the scope
						// of the class constructor body but are not permitted to reference parameters or
						// local variables of the constructor. This effectively means that entities from outer scopes
						// by the same name as a constructor parameter or local variable are inaccessible
						// in initializer expressions for instance member variables.
						if (!isStatic(location)) {
							var ctor = findConstructorDeclaration(location.parent);
							if (ctor && ctor.locals) {
								if (lookup(ctor.locals, name, meaning & SymbolFlags.Value)) {
									// Remember the property node, it will be used later to report appropriate error
									propertyWithInvalidInitializer = location;
								}
							}
						}
						break;
					case SyntaxKind.ClassDeclaration:
					case SyntaxKind.ClassExpression:
					case SyntaxKind.InterfaceDeclaration:
						// The below is used to lookup type parameters within a class or interface, as they are added to the class/interface locals
						// These can never be latebound, so the symbol's raw members are sufficient. `getMembersOfNode` cannot be used, as it would
						// trigger resolving late-bound names, which we may already be in the process of doing while we're here!
						if (
							result = lookup(
								getSymbolOfNode(location).members || emptySymbols,
								name,
								meaning & SymbolFlags.Type,
							)
						) {
							if (!isTypeParameterSymbolDeclaredInContainer(result, location)) {
								// ignore type parameters not declared in this container
								result = undefined;
								break;
							}
							if (lastLocation && isStatic(lastLocation)) {
								// TypeScript 1.0 spec (April 2014): 3.4.1
								// The scope of a type parameter extends over the entire declaration with which the type
								// parameter list is associated, with the exception of static member declarations in classes.
								error(
									errorLocation,
									Diagnostics.Static_members_cannot_reference_class_type_parameters,
								);
								return undefined;
							}
							break loop;
						}
						if (
							location.kind === SyntaxKind.ClassExpression && meaning & SymbolFlags.Class
						) {
							var className = location.name;
							if (className && name === className.escapedText) {
								result = location.symbol;
								break loop;
							}
						}
						break;
					case SyntaxKind.ExpressionWithTypeArguments:
						// The type parameters of a class are not in scope in the base class expression.
						if (
							lastLocation === location.expression && location.parent.token === SyntaxKind.ExtendsKeyword
						) {
							var container = location.parent.parent;
							if (
								isClassLike(container) && (result = lookup(
									getSymbolOfNode(container).members,
									name,
									meaning & SymbolFlags.Type,
								))
							) {
								if (nameNotFoundMessage) {
									error(
										errorLocation,
										Diagnostics.Base_class_expressions_cannot_reference_class_type_parameters,
									);
								}
								return undefined;
							}
						}
						break;
					// It is not legal to reference a class's own type parameters from a computed property name that
					// belongs to the class. For example:
					//
					//   function foo<T>() { return '' }
					//   class C<T> { // <-- Class's own type parameter T
					//       [foo<T>()]() { } // <-- Reference to T from class's own computed property
					//   }
					//
					case SyntaxKind.ComputedPropertyName:
						grandparent = location.parent.parent;
						if (
							isClassLike(grandparent) || grandparent.kind === SyntaxKind.InterfaceDeclaration
						) {
							// A reference to this grandparent's type parameters would be an error
							if (
								result = lookup(
									getSymbolOfNode(grandparent).members,
									name,
									meaning & SymbolFlags.Type,
								)
							) {
								error(
									errorLocation,
									Diagnostics.A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type,
								);
								return undefined;
							}
						}
						break;
					case SyntaxKind.ArrowFunction:
						// when targeting ES6 or higher there is no 'arguments' in an arrow function
						// for lower compile targets the resolved symbol is used to emit an error
						if (getEmitScriptTarget(compilerOptions) >= ScriptTarget.ES2015) {
							break;
						}
					// falls through
					case SyntaxKind.MethodDeclaration:
					case SyntaxKind.Constructor:
					case SyntaxKind.GetAccessor:
					case SyntaxKind.SetAccessor:
					case SyntaxKind.FunctionDeclaration:
						if (meaning & SymbolFlags.Variable && name === "arguments") {
							result = argumentsSymbol;
							break loop;
						}
						break;
					case SyntaxKind.FunctionExpression:
						if (meaning & SymbolFlags.Variable && name === "arguments") {
							result = argumentsSymbol;
							break loop;
						}
						if (meaning & SymbolFlags.Function) {
							var functionName = location.name;
							if (functionName && name === functionName.escapedText) {
								result = location.symbol;
								break loop;
							}
						}
						break;
					case SyntaxKind.Decorator:
						// Decorators are resolved at the class declaration. Resolving at the parameter
						// or member would result in looking up locals in the method.
						//
						//   function y() {}
						//   class C {
						//       method(@y x, y) {} // <-- decorator y should be resolved at the class declaration, not the parameter.
						//   }
						//
						if (
							location.parent && location.parent.kind === SyntaxKind.Parameter
						) {
							location = location.parent;
						}
						//
						//   function y() {}
						//   class C {
						//       @y method(x, y) {} // <-- decorator y should be resolved at the class declaration, not the method.
						//   }
						//
						// class Decorators are resolved outside of the class to avoid referencing type parameters of that class.
						//
						//   type T = number;
						//   declare function y(x: T): any;
						//   @param(1 as T) // <-- T should resolve to the type alias outside of class C
						//   class C<T> {}
						if (
							location.parent && (isClassElement(location.parent) || location.parent.kind === SyntaxKind.ClassDeclaration)
						) {
							location = location.parent;
						}
						break;
					case SyntaxKind.JSDocTypedefTag:
					case SyntaxKind.JSDocCallbackTag:
					case SyntaxKind.JSDocEnumTag:
						// js type aliases do not resolve names from their host, so skip past it
						var root = getJSDocRoot(location);
						if (root) {
							location = root.parent;
						}
						break;
					case SyntaxKind.Parameter:
						if (
							lastLocation && (lastLocation === location.initializer || lastLocation === location.name && isBindingPattern(
								lastLocation,
							))
						) {
							if (!associatedDeclarationForContainingInitializerOrBindingName) {
								associatedDeclarationForContainingInitializerOrBindingName = location;
							}
						}
						break;
					case SyntaxKind.BindingElement:
						if (
							lastLocation && (lastLocation === location.initializer || lastLocation === location.name && isBindingPattern(
								lastLocation,
							))
						) {
							if (
								isParameterDeclaration(location) && !associatedDeclarationForContainingInitializerOrBindingName
							) {
								associatedDeclarationForContainingInitializerOrBindingName = location;
							}
						}
						break;
					case SyntaxKind.InferType:
						if (meaning & SymbolFlags.TypeParameter) {
							var parameterName = location.typeParameter.name;
							if (parameterName && name === parameterName.escapedText) {
								result = location.typeParameter.symbol;
								break loop;
							}
						}
						break;
				}
				if (isSelfReferenceLocation(location)) {
					lastSelfReferenceLocation = location;
				}
				lastLocation = location;
				location = isJSDocTemplateTag(location) ? getEffectiveContainerForJSDocTemplateTag(
					location,
				) || location.parent : location.parent;
			}
			// We just climbed up parents looking for the name, meaning that we started in a descendant node of `lastLocation`.
			// If `result === lastSelfReferenceLocation.symbol`, that means that we are somewhere inside `lastSelfReferenceLocation` looking up a name, and resolving to `lastLocation` itself.
			// That means that this is a self-reference of `lastLocation`, and shouldn't count this when considering whether `lastLocation` is used.
			if (
				isUse && result && (!lastSelfReferenceLocation || result !== lastSelfReferenceLocation.symbol)
			) {
				result.isReferenced |= meaning;
			}
			if (!result) {
				if (lastLocation) {
					Debug.assert(lastLocation.kind === SyntaxKind.SourceFile);
					if (
						lastLocation.commonJsModuleIndicator && name === "exports" && meaning & lastLocation.symbol.flags
					) {
						return lastLocation.symbol;
					}
				}
				if (!excludeGlobals) {
					result = lookup(globals, name, meaning);
				}
			}
			if (!result) {
				if (
					originalLocation && isInJSFile(originalLocation) && originalLocation.parent
				) {
					if (
						isRequireCall(
							originalLocation.parent, /*checkArgumentIsStringLiteralLike*/
							false,
						)
					) {
						return requireSymbol;
					}
				}
			}
			if (!result) {
				if (nameNotFoundMessage && produceDiagnostics) {
					if (
						!errorLocation || !checkAndReportErrorForMissingPrefix(
							errorLocation,
							name,
							nameArg,
						) && !checkAndReportErrorForExtendingInterface(errorLocation) && !checkAndReportErrorForUsingTypeAsNamespace(
							errorLocation, // TODO: GH#18217
							name,
							meaning,
						) && !checkAndReportErrorForExportingPrimitiveType(
							errorLocation,
							name,
						) && !checkAndReportErrorForUsingTypeAsValue(
							errorLocation,
							name,
							meaning,
						) && !checkAndReportErrorForUsingNamespaceModuleAsValue(
							errorLocation,
							name,
							meaning,
						) && !checkAndReportErrorForUsingValueAsType(
							errorLocation,
							name,
							meaning,
						)
					) {
						var suggestion = void 0;
						if (
							getSpellingSuggestions && suggestionCount < maximumSuggestionCount
						) {
							suggestion = getSuggestedSymbolForNonexistentSymbol(
								originalLocation,
								name,
								meaning,
							);
							var isGlobalScopeAugmentationDeclaration = (suggestion === null || suggestion === void 0 ? void 0 : suggestion.valueDeclaration) && isAmbientModule(
								suggestion.valueDeclaration,
							) && isGlobalScopeAugmentation(suggestion.valueDeclaration);
							if (isGlobalScopeAugmentationDeclaration) {
								suggestion = undefined;
							}
							if (suggestion) {
								var suggestionName = symbolToString(suggestion);
								var isUncheckedJS = isUncheckedJSSuggestion(
									originalLocation,
									suggestion, /*excludeClasses*/
									false,
								);
								var message = meaning === SymbolFlags.Namespace || nameArg && typeof nameArg !== "string" && nodeIsSynthesized(
									nameArg,
								) ? Diagnostics.Cannot_find_namespace_0_Did_you_mean_1 : isUncheckedJS ? Diagnostics.Could_not_find_name_0_Did_you_mean_1 : Diagnostics.Cannot_find_name_0_Did_you_mean_1;
								var diagnostic = createError(
									errorLocation,
									message,
									diagnosticName(nameArg),
									suggestionName,
								);
								addErrorOrSuggestion(!isUncheckedJS, diagnostic);
								if (suggestion.valueDeclaration) {
									addRelatedInfo(
										diagnostic,
										createDiagnosticForNode(
											suggestion.valueDeclaration,
											Diagnostics._0_is_declared_here,
											suggestionName,
										),
									);
								}
							}
						}
						if (!suggestion) {
							if (nameArg) {
								var lib = getSuggestedLibForNonExistentName(nameArg);
								if (lib) {
									error(
										errorLocation,
										nameNotFoundMessage,
										diagnosticName(nameArg),
										lib,
									);
								} else {
									error(
										errorLocation,
										nameNotFoundMessage,
										diagnosticName(nameArg),
									);
								}
							}
						}
						suggestionCount++;
					}
				}
				return undefined;
			}
			// Perform extra checks only if error reporting was requested
			if (nameNotFoundMessage && produceDiagnostics) {
				if (
					propertyWithInvalidInitializer && !(getEmitScriptTarget(
						compilerOptions,
					) === ScriptTarget.ESNext && useDefineForClassFields)
				) {
					// We have a match, but the reference occurred within a property initializer and the identifier also binds
					// to a local variable in the constructor where the code will be emitted. Note that this is actually allowed
					// with ESNext+useDefineForClassFields because the scope semantics are different.
					var propertyName = propertyWithInvalidInitializer.name;
					error(
						errorLocation,
						Diagnostics.Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor,
						declarationNameToString(propertyName),
						diagnosticName(nameArg),
					);
					return undefined;
				}
				// Only check for block-scoped variable if we have an error location and are looking for the
				// name with variable meaning
				//      For example,
				//          declare module foo {
				//              interface bar {}
				//          }
				//      const foo/*1*/: foo/*2*/.bar;
				// The foo at /*1*/ and /*2*/ will share same symbol with two meanings:
				// block-scoped variable and namespace module. However, only when we
				// try to resolve name in /*1*/ which is used in variable position,
				// we want to check for block-scoped
				if (
					errorLocation && (meaning & SymbolFlags.BlockScopedVariable || ((meaning & SymbolFlags.Class || meaning & SymbolFlags.Enum) && (meaning & SymbolFlags.Value) === SymbolFlags.Value))
				) {
					var exportOrLocalSymbol = getExportSymbolOfValueSymbolIfExported(
						result,
					);
					if (
						exportOrLocalSymbol.flags & SymbolFlags.BlockScopedVariable || exportOrLocalSymbol.flags & SymbolFlags.Class || exportOrLocalSymbol.flags & SymbolFlags.Enum
					) {
						checkResolvedBlockScopedVariable(exportOrLocalSymbol, errorLocation);
					}
				}
				// If we're in an external module, we can't reference value symbols created from UMD export declarations
				if (
					result && isInExternalModule && (meaning & SymbolFlags.Value) === SymbolFlags.Value && !(originalLocation.flags & NodeFlags.JSDoc)
				) {
					var merged = getMergedSymbol(result);
					if (
						length(merged.declarations) && every(
							merged.declarations,
							function (d) {
								return isNamespaceExportDeclaration(d) || isSourceFile(d) && !!d.symbol.globalExports;
							},
						)
					) {
						errorOrSuggestion(
							!compilerOptions.allowUmdGlobalAccess,
							errorLocation,
							Diagnostics._0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead,
							unescapeLeadingUnderscores(name),
						);
					}
				}
				// If we're in a parameter initializer or binding name, we can't reference the values of the parameter whose initializer we're within or parameters to the right
				if (
					result && associatedDeclarationForContainingInitializerOrBindingName && !withinDeferredContext && (meaning & SymbolFlags.Value) === SymbolFlags.Value
				) {
					var candidate = getMergedSymbol(getLateBoundSymbol(result));
					var root = getRootDeclaration(
						associatedDeclarationForContainingInitializerOrBindingName,
					);
					// A parameter initializer or binding pattern initializer within a parameter cannot refer to itself
					if (
						candidate === getSymbolOfNode(
							associatedDeclarationForContainingInitializerOrBindingName,
						)
					) {
						error(
							errorLocation,
							Diagnostics.Parameter_0_cannot_reference_itself,
							declarationNameToString(
								associatedDeclarationForContainingInitializerOrBindingName.name,
							),
						);
					} else if (
						candidate.valueDeclaration && candidate.valueDeclaration.pos > associatedDeclarationForContainingInitializerOrBindingName.pos && root.parent.locals && lookup( // And it cannot refer to any declarations which come after it
							root.parent.locals,
							candidate.escapedName,
							meaning,
						) === candidate
					) {
						error(
							errorLocation,
							Diagnostics.Parameter_0_cannot_reference_identifier_1_declared_after_it,
							declarationNameToString(
								associatedDeclarationForContainingInitializerOrBindingName.name,
							),
							declarationNameToString(errorLocation),
						);
					}
				}
				if (
					result && errorLocation && meaning & SymbolFlags.Value && result.flags & SymbolFlags.Alias
				) {
					checkSymbolUsageInExpressionContext(result, name, errorLocation);
				}
			}
			return result;
		}
		function checkSymbolUsageInExpressionContext(symbol, name, useSite) {
			if (!isValidTypeOnlyAliasUseSite(useSite)) {
				var typeOnlyDeclaration = getTypeOnlyAliasDeclaration(symbol);
				if (typeOnlyDeclaration) {
					var message = typeOnlyDeclaration.kind === SyntaxKind.ExportSpecifier ? Diagnostics._0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type : Diagnostics._0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type;
					var unescapedName = unescapeLeadingUnderscores(name);
					addTypeOnlyDeclarationRelatedInfo(
						error(useSite, message, unescapedName),
						typeOnlyDeclaration,
						unescapedName,
					);
				}
			}
		}
		function addTypeOnlyDeclarationRelatedInfo(
			diagnostic,
			typeOnlyDeclaration,
			unescapedName,
		) {
			if (!typeOnlyDeclaration) return diagnostic;
			return addRelatedInfo(
				diagnostic,
				createDiagnosticForNode(
					typeOnlyDeclaration,
					typeOnlyDeclaration.kind === SyntaxKind.ExportSpecifier ? Diagnostics._0_was_exported_here : Diagnostics._0_was_imported_here,
					unescapedName,
				),
			);
		}
		function getIsDeferredContext(location, lastLocation) {
			if (
				location.kind !== SyntaxKind.ArrowFunction && location.kind !== SyntaxKind.FunctionExpression
			) {
				// initializers in instance property declaration of class like entities are executed in constructor and thus deferred
				return isTypeQueryNode(location) || ((isFunctionLikeDeclaration(
					location,
				) || (location.kind === SyntaxKind.PropertyDeclaration && !isStatic(
					location,
				))) && (!lastLocation || lastLocation !== location.name)); // A name is evaluated within the enclosing scope - so it shouldn't count as deferred
			}
			if (lastLocation && lastLocation === location.name) {
				return false;
			}
			// generator functions and async functions are not inlined in control flow when immediately invoked
			if (
				location.asteriskToken || hasSyntacticModifier(
					location,
					ModifierFlags.Async,
				)
			) {
				return true;
			}
			return !getImmediatelyInvokedFunctionExpression(location);
		}
		function isSelfReferenceLocation(node) {
			switch (node.kind) {
				case SyntaxKind.FunctionDeclaration:
				case SyntaxKind.ClassDeclaration:
				case SyntaxKind.InterfaceDeclaration:
				case SyntaxKind.EnumDeclaration:
				case SyntaxKind.TypeAliasDeclaration:
				case SyntaxKind.ModuleDeclaration: // For `namespace N { N; }`
					return true;
				default:
					return false;
			}
		}
		function diagnosticName(nameArg) {
			return isString(nameArg) ? unescapeLeadingUnderscores(nameArg) : declarationNameToString(
				nameArg,
			);
		}
		function isTypeParameterSymbolDeclaredInContainer(symbol, container) {
			if (symbol.declarations) {
				for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
					var decl = _a[_i];
					if (decl.kind === SyntaxKind.TypeParameter) {
						var parent_1 = isJSDocTemplateTag(decl.parent) ? getJSDocHost(
							decl.parent,
						) : decl.parent;
						if (parent_1 === container) {
							return !(isJSDocTemplateTag(decl.parent) && find(
								decl.parent.parent.tags,
								isJSDocTypeAlias,
							)); // TODO: GH#18217
						}
					}
				}
			}
			return false;
		}
		function checkAndReportErrorForMissingPrefix(errorLocation, name, nameArg) {
			if (
				!isIdentifier(errorLocation) || errorLocation.escapedText !== name || isTypeReferenceIdentifier(
					errorLocation,
				) || isInTypeQuery(errorLocation)
			) {
				return false;
			}
			var container = getThisContainer(
				errorLocation, /*includeArrowFunctions*/
				false,
			);
			var location = container;
			while (location) {
				if (isClassLike(location.parent)) {
					var classSymbol = getSymbolOfNode(location.parent);
					if (!classSymbol) {
						break;
					}
					// Check to see if a static member exists.
					var constructorType = getTypeOfSymbol(classSymbol);
					if (getPropertyOfType(constructorType, name)) {
						error(
							errorLocation,
							Diagnostics.Cannot_find_name_0_Did_you_mean_the_static_member_1_0,
							diagnosticName(nameArg),
							symbolToString(classSymbol),
						);
						return true;
					}
					// No static member is present.
					// Check if we're in an instance method and look for a relevant instance member.
					if (location === container && !isStatic(location)) {
						var instanceType = getDeclaredTypeOfSymbol(classSymbol).thisType; // TODO: GH#18217
						if (getPropertyOfType(instanceType, name)) {
							error(
								errorLocation,
								Diagnostics.Cannot_find_name_0_Did_you_mean_the_instance_member_this_0,
								diagnosticName(nameArg),
							);
							return true;
						}
					}
				}
				location = location.parent;
			}
			return false;
		}
		function checkAndReportErrorForExtendingInterface(errorLocation) {
			var expression = getEntityNameForExtendingInterface(errorLocation);
			if (
				expression && resolveEntityName(
					expression,
					SymbolFlags.Interface, /*ignoreErrors*/
					true,
				)
			) {
				error(
					errorLocation,
					Diagnostics.Cannot_extend_an_interface_0_Did_you_mean_implements,
					getTextOfNode(expression),
				);
				return true;
			}
			return false;
		}
		/**
         * Climbs up parents to an ExpressionWithTypeArguments, and returns its expression,
         * but returns undefined if that expression is not an EntityNameExpression.
         */
		function getEntityNameForExtendingInterface(node) {
			switch (node.kind) {
				case SyntaxKind.Identifier:
				case SyntaxKind.PropertyAccessExpression:
					return node.parent ? getEntityNameForExtendingInterface(node.parent) : undefined;
				case SyntaxKind.ExpressionWithTypeArguments:
					if (isEntityNameExpression(node.expression)) {
						return node.expression;
					}
				// falls through
				default:
					return undefined;
			}
		}
		function checkAndReportErrorForUsingTypeAsNamespace(
			errorLocation,
			name,
			meaning,
		) {
			var namespaceMeaning = SymbolFlags.Namespace | (isInJSFile(errorLocation) ? SymbolFlags.Value : 0);
			if (meaning === namespaceMeaning) {
				var symbol = resolveSymbol(
					resolveName(
						errorLocation,
						name,
						SymbolFlags.Type & ~namespaceMeaning, /*nameNotFoundMessage*/
						undefined, /*nameArg*/
						undefined, /*isUse*/
						false,
					),
				);
				var parent_2 = errorLocation.parent;
				if (symbol) {
					if (isQualifiedName(parent_2)) {
						Debug.assert(
							parent_2.left === errorLocation,
							"Should only be resolving left side of qualified name as a namespace",
						);
						var propName = parent_2.right.escapedText;
						var propType = getPropertyOfType(
							getDeclaredTypeOfSymbol(symbol),
							propName,
						);
						if (propType) {
							error(
								parent_2,
								Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1,
								unescapeLeadingUnderscores(name),
								unescapeLeadingUnderscores(propName),
							);
							return true;
						}
					}
					error(
						errorLocation,
						Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here,
						unescapeLeadingUnderscores(name),
					);
					return true;
				}
			}
			return false;
		}
		function checkAndReportErrorForUsingValueAsType(
			errorLocation,
			name,
			meaning,
		) {
			if (meaning & (SymbolFlags.Type & ~SymbolFlags.Namespace)) {
				var symbol = resolveSymbol(
					resolveName(
						errorLocation,
						name,
						~SymbolFlags.Type & SymbolFlags.Value, /*nameNotFoundMessage*/
						undefined, /*nameArg*/
						undefined, /*isUse*/
						false,
					),
				);
				if (symbol && !(symbol.flags & SymbolFlags.Namespace)) {
					error(
						errorLocation,
						Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0,
						unescapeLeadingUnderscores(name),
					);
					return true;
				}
			}
			return false;
		}
		function isPrimitiveTypeName(name) {
			return name === "any" || name === "string" || name === "number" || name === "boolean" || name === "never" || name === "unknown";
		}
		function checkAndReportErrorForExportingPrimitiveType(errorLocation, name) {
			if (
				isPrimitiveTypeName(name) && errorLocation.parent.kind === SyntaxKind.ExportSpecifier
			) {
				error(
					errorLocation,
					Diagnostics.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module,
					name,
				);
				return true;
			}
			return false;
		}
		function checkAndReportErrorForUsingTypeAsValue(
			errorLocation,
			name,
			meaning,
		) {
			if (meaning & (SymbolFlags.Value & ~SymbolFlags.NamespaceModule)) {
				if (isPrimitiveTypeName(name)) {
					error(
						errorLocation,
						Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here,
						unescapeLeadingUnderscores(name),
					);
					return true;
				}
				var symbol = resolveSymbol(
					resolveName(
						errorLocation,
						name,
						SymbolFlags.Type & ~SymbolFlags.Value, /*nameNotFoundMessage*/
						undefined, /*nameArg*/
						undefined, /*isUse*/
						false,
					),
				);
				if (symbol && !(symbol.flags & SymbolFlags.NamespaceModule)) {
					var rawName = unescapeLeadingUnderscores(name);
					if (isES2015OrLaterConstructorName(name)) {
						error(
							errorLocation,
							Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_es2015_or_later,
							rawName,
						);
					} else if (maybeMappedType(errorLocation, symbol)) {
						error(
							errorLocation,
							Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0,
							rawName,
							rawName === "K" ? "P" : "K",
						);
					} else {
						error(
							errorLocation,
							Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here,
							rawName,
						);
					}
					return true;
				}
			}
			return false;
		}
		function maybeMappedType(node, symbol) {
			var container = findAncestor(
				node.parent,
				function (n) {
					return isComputedPropertyName(n) || isPropertySignature(n) ? false : isTypeLiteralNode(
						n,
					) || "quit";
				},
			);
			if (container && container.members.length === 1) {
				var type = getDeclaredTypeOfSymbol(symbol);
				return !!(type.flags & TypeFlags.Union) && allTypesAssignableToKind(
					type,
					TypeFlags.StringOrNumberLiteral, /*strict*/
					true,
				);
			}
			return false;
		}
		function isES2015OrLaterConstructorName(n) {
			switch (n) {
				case "Promise":
				case "Symbol":
				case "Map":
				case "WeakMap":
				case "Set":
				case "WeakSet":
					return true;
			}
			return false;
		}
		function checkAndReportErrorForUsingNamespaceModuleAsValue(
			errorLocation,
			name,
			meaning,
		) {
			if (
				meaning & (SymbolFlags.Value & ~SymbolFlags.NamespaceModule & ~SymbolFlags.Type)
			) {
				var symbol = resolveSymbol(
					resolveName(
						errorLocation,
						name,
						SymbolFlags.NamespaceModule & ~SymbolFlags.Value, /*nameNotFoundMessage*/
						undefined, /*nameArg*/
						undefined, /*isUse*/
						false,
					),
				);
				if (symbol) {
					error(
						errorLocation,
						Diagnostics.Cannot_use_namespace_0_as_a_value,
						unescapeLeadingUnderscores(name),
					);
					return true;
				}
			} else if (
				meaning & (SymbolFlags.Type & ~SymbolFlags.NamespaceModule & ~SymbolFlags.Value)
			) {
				var symbol = resolveSymbol(
					resolveName(
						errorLocation,
						name,
						(SymbolFlags.ValueModule | SymbolFlags.NamespaceModule) & ~SymbolFlags.Type, /*nameNotFoundMessage*/
						undefined, /*nameArg*/
						undefined, /*isUse*/
						false,
					),
				);
				if (symbol) {
					error(
						errorLocation,
						Diagnostics.Cannot_use_namespace_0_as_a_type,
						unescapeLeadingUnderscores(name),
					);
					return true;
				}
			}
			return false;
		}
		function checkResolvedBlockScopedVariable(result, errorLocation) {
			var _a;
			Debug.assert(
				!!(result.flags & SymbolFlags.BlockScopedVariable || result.flags & SymbolFlags.Class || result.flags & SymbolFlags.Enum),
			);
			if (
				result.flags & (SymbolFlags.Function | SymbolFlags.FunctionScopedVariable | SymbolFlags.Assignment) && result.flags & SymbolFlags.Class
			) {
				// constructor functions aren't block scoped
				return;
			}
			// Block-scoped variables cannot be used before their definition
			var declaration = (_a = result.declarations) === null || _a === void 0 ? void 0 : _a.find(
				function (d) {
					return isBlockOrCatchScoped(d) || isClassLike(d) || (d.kind === SyntaxKind.EnumDeclaration);
				},
			);
			if (declaration === undefined) return Debug.fail(
				"checkResolvedBlockScopedVariable could not find block-scoped declaration",
			);
			if (
				!(declaration.flags & NodeFlags.Ambient) && !isBlockScopedNameDeclaredBeforeUse(
					declaration,
					errorLocation,
				)
			) {
				var diagnosticMessage = void 0;
				var declarationName = declarationNameToString(
					getNameOfDeclaration(declaration),
				);
				if (result.flags & SymbolFlags.BlockScopedVariable) {
					diagnosticMessage = error(
						errorLocation,
						Diagnostics.Block_scoped_variable_0_used_before_its_declaration,
						declarationName,
					);
				} else if (result.flags & SymbolFlags.Class) {
					diagnosticMessage = error(
						errorLocation,
						Diagnostics.Class_0_used_before_its_declaration,
						declarationName,
					);
				} else if (result.flags & SymbolFlags.RegularEnum) {
					diagnosticMessage = error(
						errorLocation,
						Diagnostics.Enum_0_used_before_its_declaration,
						declarationName,
					);
				} else {
					Debug.assert(!!(result.flags & SymbolFlags.ConstEnum));
					if (shouldPreserveConstEnums(compilerOptions)) {
						diagnosticMessage = error(
							errorLocation,
							Diagnostics.Enum_0_used_before_its_declaration,
							declarationName,
						);
					}
				}
				if (diagnosticMessage) {
					addRelatedInfo(
						diagnosticMessage,
						createDiagnosticForNode(
							declaration,
							Diagnostics._0_is_declared_here,
							declarationName,
						),
					);
				}
			}
		}
		/* Starting from 'initial' node walk up the parent chain until 'stopAt' node is reached.
         * If at any point current node is equal to 'parent' node - return true.
         * If current node is an IIFE, continue walking up.
         * Return false if 'stopAt' node is reached or isFunctionLike(current) === true.
         */
		function isSameScopeDescendentOf(initial, parent, stopAt) {
			return !!parent && !!findAncestor(
				initial,
				function (n) {
					return n === parent || (n === stopAt || isFunctionLike(n) && !getImmediatelyInvokedFunctionExpression(
						n,
					) ? "quit" : false);
				},
			);
		}
		function getAnyImportSyntax(node) {
			switch (node.kind) {
				case SyntaxKind.ImportEqualsDeclaration:
					return node;
				case SyntaxKind.ImportClause:
					return node.parent;
				case SyntaxKind.NamespaceImport:
					return node.parent.parent;
				case SyntaxKind.ImportSpecifier:
					return node.parent.parent.parent;
				default:
					return undefined;
			}
		}
		function getDeclarationOfAliasSymbol(symbol) {
			return symbol.declarations && findLast(
				symbol.declarations,
				isAliasSymbolDeclaration,
			);
		}
		/**
         * An alias symbol is created by one of the following declarations:
         * import <symbol> = ...
         * import <symbol> from ...
         * import * as <symbol> from ...
         * import { x as <symbol> } from ...
         * export { x as <symbol> } from ...
         * export * as ns <symbol> from ...
         * export = <EntityNameExpression>
         * export default <EntityNameExpression>
         * module.exports = <EntityNameExpression>
         * {<Identifier>}
         * {name: <EntityNameExpression>}
         * const { x } = require ...
         */
		function isAliasSymbolDeclaration(node) {
			return node.kind === SyntaxKind.ImportEqualsDeclaration || node.kind === SyntaxKind.NamespaceExportDeclaration || node.kind === SyntaxKind.ImportClause && !!node.name || node.kind === SyntaxKind.NamespaceImport || node.kind === SyntaxKind.NamespaceExport || node.kind === SyntaxKind.ImportSpecifier || node.kind === SyntaxKind.ExportSpecifier || node.kind === SyntaxKind.ExportAssignment && exportAssignmentIsAlias(
				node,
			) || isBinaryExpression(node) && getAssignmentDeclarationKind(node) === AssignmentDeclarationKind.ModuleExports && exportAssignmentIsAlias(
				node,
			) || isAccessExpression(node) && isBinaryExpression(node.parent) && node.parent.left === node && node.parent.operatorToken.kind === SyntaxKind.EqualsToken && isAliasableOrJsExpression(
				node.parent.right,
			) || node.kind === SyntaxKind.ShorthandPropertyAssignment || node.kind === SyntaxKind.PropertyAssignment && isAliasableOrJsExpression(
				node.initializer,
			) || isRequireVariableDeclaration(node);
		}
		function isAliasableOrJsExpression(e) {
			return isAliasableExpression(e) || isFunctionExpression(e) && isJSConstructor(
				e,
			);
		}
		function getTargetOfImportEqualsDeclaration(node, dontResolveAlias) {
			var commonJSPropertyAccess = getCommonJSPropertyAccess(node);
			if (commonJSPropertyAccess) {
				var name_1 = getLeftmostAccessExpression(
					commonJSPropertyAccess.expression,
				).arguments[0];
				return isIdentifier(commonJSPropertyAccess.name) ? resolveSymbol(
					getPropertyOfType(
						resolveExternalModuleTypeByLiteral(name_1),
						commonJSPropertyAccess.name.escapedText,
					),
				) : undefined;
			}
			if (
				isVariableDeclaration(node) || node.moduleReference.kind === SyntaxKind.ExternalModuleReference
			) {
				var immediate = resolveExternalModuleName(
					node,
					getExternalModuleRequireArgument(node) || getExternalModuleImportEqualsDeclarationExpression(
						node,
					),
				);
				var resolved_1 = resolveExternalModuleSymbol(immediate);
				markSymbolOfAliasDeclarationIfTypeOnly(
					node,
					immediate,
					resolved_1, /*overwriteEmpty*/
					false,
				);
				return resolved_1;
			}
			var resolved = getSymbolOfPartOfRightHandSideOfImportEquals(
				node.moduleReference,
				dontResolveAlias,
			);
			checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol(node, resolved);
			return resolved;
		}
		function checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol(
			node,
			resolved,
		) {
			if (
				markSymbolOfAliasDeclarationIfTypeOnly(
					node, /*immediateTarget*/
					undefined,
					resolved, /*overwriteEmpty*/
					false,
				) && !node.isTypeOnly
			) {
				var typeOnlyDeclaration = getTypeOnlyAliasDeclaration(
					getSymbolOfNode(node),
				);
				var isExport = typeOnlyDeclaration.kind === SyntaxKind.ExportSpecifier;
				var message = isExport ? Diagnostics.An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type : Diagnostics.An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type;
				var relatedMessage = isExport ? Diagnostics._0_was_exported_here : Diagnostics._0_was_imported_here;
				var name_2 = unescapeLeadingUnderscores(
					typeOnlyDeclaration.name.escapedText,
				);
				addRelatedInfo(
					error(node.moduleReference, message),
					createDiagnosticForNode(typeOnlyDeclaration, relatedMessage, name_2),
				);
			}
		}
		function resolveExportByName(
			moduleSymbol,
			name,
			sourceNode,
			dontResolveAlias,
		) {
			var exportValue = moduleSymbol.exports.get(
				InternalSymbolName.ExportEquals,
			);
			var exportSymbol = exportValue ? getPropertyOfType(
				getTypeOfSymbol(exportValue),
				name,
			) : moduleSymbol.exports.get(name);
			var resolved = resolveSymbol(exportSymbol, dontResolveAlias);
			markSymbolOfAliasDeclarationIfTypeOnly(
				sourceNode,
				exportSymbol,
				resolved, /*overwriteEmpty*/
				false,
			);
			return resolved;
		}
		function isSyntacticDefault(node) {
			return ((isExportAssignment(node) && !node.isExportEquals) || hasSyntacticModifier(
				node,
				ModifierFlags.Default,
			) || isExportSpecifier(node));
		}
		function getUsageModeForExpression(usage) {
			return isStringLiteralLike(usage) ? getModeForUsageLocation(
				getSourceFileOfNode(usage),
				usage,
			) : undefined;
		}
		function isESMFormatImportImportingCommonjsFormatFile(usageMode, targetMode) {
			return usageMode === ModuleKind.ESNext && targetMode === ModuleKind.CommonJS;
		}
		function isOnlyImportedAsDefault(usage) {
			var usageMode = getUsageModeForExpression(usage);
			return usageMode === ModuleKind.ESNext && endsWith(
				usage.text,
				Extension.Json,
			);
		}
		function canHaveSyntheticDefault(
			file,
			moduleSymbol,
			dontResolveAlias,
			usage,
		) {
			var usageMode = file && getUsageModeForExpression(usage);
			if (file && usageMode !== undefined) {
				var result = isESMFormatImportImportingCommonjsFormatFile(
					usageMode,
					file.impliedNodeFormat,
				);
				if (usageMode === ModuleKind.ESNext || result) {
					return result;
				} // fallthrough on cjs usages so we imply defaults for interop'd imports, too
			}
			if (!allowSyntheticDefaultImports) {
				return false;
			}
			// Declaration files (and ambient modules)
			if (!file || file.isDeclarationFile) {
				// Definitely cannot have a synthetic default if they have a syntactic default member specified
				var defaultExportSymbol = resolveExportByName(
					moduleSymbol,
					InternalSymbolName.Default, /*sourceNode*/
					undefined, /*dontResolveAlias*/
					true,
				); // Dont resolve alias because we want the immediately exported symbol's declaration
				if (
					defaultExportSymbol && some(
						defaultExportSymbol.declarations,
						isSyntacticDefault,
					)
				) {
					return false;
				}
				// It _might_ still be incorrect to assume there is no __esModule marker on the import at runtime, even if there is no `default` member
				// So we check a bit more,
				if (
					resolveExportByName(
						moduleSymbol,
						escapeLeadingUnderscores("__esModule"), /*sourceNode*/
						undefined,
						dontResolveAlias,
					)
				) {
					// If there is an `__esModule` specified in the declaration (meaning someone explicitly added it or wrote it in their code),
					// it definitely is a module and does not have a synthetic default
					return false;
				}
				// There are _many_ declaration files not written with esmodules in mind that still get compiled into a format with __esModule set
				// Meaning there may be no default at runtime - however to be on the permissive side, we allow access to a synthetic default member
				// as there is no marker to indicate if the accompanying JS has `__esModule` or not, or is even native esm
				return true;
			}
			// TypeScript files never have a synthetic default (as they are always emitted with an __esModule marker) _unless_ they contain an export= statement
			if (!isSourceFileJS(file)) {
				return hasExportAssignmentSymbol(moduleSymbol);
			}
			// JS files have a synthetic default if they do not contain ES2015+ module syntax (export = is not valid in js) _and_ do not have an __esModule marker
			return !file.externalModuleIndicator && !resolveExportByName(
				moduleSymbol,
				escapeLeadingUnderscores("__esModule"), /*sourceNode*/
				undefined,
				dontResolveAlias,
			);
		}
		function getTargetOfImportClause(node, dontResolveAlias) {
			var _a;
			var moduleSymbol = resolveExternalModuleName(
				node,
				node.parent.moduleSpecifier,
			);
			if (moduleSymbol) {
				var exportDefaultSymbol = void 0;
				if (isShorthandAmbientModuleSymbol(moduleSymbol)) {
					exportDefaultSymbol = moduleSymbol;
				} else {
					exportDefaultSymbol = resolveExportByName(
						moduleSymbol,
						InternalSymbolName.Default,
						node,
						dontResolveAlias,
					);
				}
				var file = (_a = moduleSymbol.declarations) === null || _a === void 0 ? void 0 : _a.find(
					isSourceFile,
				);
				var hasDefaultOnly = isOnlyImportedAsDefault(
					node.parent.moduleSpecifier,
				);
				var hasSyntheticDefault = canHaveSyntheticDefault(
					file,
					moduleSymbol,
					dontResolveAlias,
					node.parent.moduleSpecifier,
				);
				if (!exportDefaultSymbol && !hasSyntheticDefault && !hasDefaultOnly) {
					if (hasExportAssignmentSymbol(moduleSymbol)) {
						var compilerOptionName = moduleKind >= ModuleKind.ES2015 ? "allowSyntheticDefaultImports" : "esModuleInterop";
						var exportEqualsSymbol = moduleSymbol.exports.get(
							InternalSymbolName.ExportEquals,
						);
						var exportAssignment = exportEqualsSymbol.valueDeclaration;
						var err = error(
							node.name,
							Diagnostics.Module_0_can_only_be_default_imported_using_the_1_flag,
							symbolToString(moduleSymbol),
							compilerOptionName,
						);
						if (exportAssignment) {
							addRelatedInfo(
								err,
								createDiagnosticForNode(
									exportAssignment,
									Diagnostics.This_module_is_declared_with_using_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag,
									compilerOptionName,
								),
							);
						}
					} else {
						reportNonDefaultExport(moduleSymbol, node);
					}
				} else if (hasSyntheticDefault || hasDefaultOnly) {
					// per emit behavior, a synthetic default overrides a "real" .default member if `__esModule` is not present
					var resolved = resolveExternalModuleSymbol(
						moduleSymbol,
						dontResolveAlias,
					) || resolveSymbol(moduleSymbol, dontResolveAlias);
					markSymbolOfAliasDeclarationIfTypeOnly(
						node,
						moduleSymbol,
						resolved, /*overwriteTypeOnly*/
						false,
					);
					return resolved;
				}
				markSymbolOfAliasDeclarationIfTypeOnly(
					node,
					exportDefaultSymbol, /*finalTarget*/
					undefined, /*overwriteTypeOnly*/
					false,
				);
				return exportDefaultSymbol;
			}
		}
		function reportNonDefaultExport(moduleSymbol, node) {
			var _a, _b, _c;
			if (
				(_a = moduleSymbol.exports) === null || _a === void 0 ? void 0 : _a.has(
					node.symbol.escapedName,
				)
			) {
				error(
					node.name,
					Diagnostics.Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead,
					symbolToString(moduleSymbol),
					symbolToString(node.symbol),
				);
			} else {
				var diagnostic = error(
					node.name,
					Diagnostics.Module_0_has_no_default_export,
					symbolToString(moduleSymbol),
				);
				var exportStar = (_b = moduleSymbol.exports) === null || _b === void 0 ? void 0 : _b.get(
					InternalSymbolName.ExportStar,
				);
				if (exportStar) {
					var defaultExport = (_c = exportStar.declarations) === null || _c === void 0 ? void 0 : _c.find(
						function (decl) {
							var _a, _b;
							return !!(isExportDeclaration(decl) && decl.moduleSpecifier && ((_b = (_a = resolveExternalModuleName(
								decl,
								decl.moduleSpecifier,
							)) === null || _a === void 0 ? void 0 : _a.exports) === null || _b === void 0 ? void 0 : _b.has(
								InternalSymbolName.Default,
							)));
						},
					);
					if (defaultExport) {
						addRelatedInfo(
							diagnostic,
							createDiagnosticForNode(
								defaultExport,
								Diagnostics.export_Asterisk_does_not_re_export_a_default,
							),
						);
					}
				}
			}
		}
		function getTargetOfNamespaceImport(node, dontResolveAlias) {
			var moduleSpecifier = node.parent.parent.moduleSpecifier;
			var immediate = resolveExternalModuleName(node, moduleSpecifier);
			var resolved = resolveESModuleSymbol(
				immediate,
				moduleSpecifier,
				dontResolveAlias, /*suppressUsageError*/
				false,
			);
			markSymbolOfAliasDeclarationIfTypeOnly(
				node,
				immediate,
				resolved, /*overwriteEmpty*/
				false,
			);
			return resolved;
		}
		function getTargetOfNamespaceExport(node, dontResolveAlias) {
			var moduleSpecifier = node.parent.moduleSpecifier;
			var immediate = moduleSpecifier && resolveExternalModuleName(
				node,
				moduleSpecifier,
			);
			var resolved = moduleSpecifier && resolveESModuleSymbol(
				immediate,
				moduleSpecifier,
				dontResolveAlias, /*suppressUsageError*/
				false,
			);
			markSymbolOfAliasDeclarationIfTypeOnly(
				node,
				immediate,
				resolved, /*overwriteEmpty*/
				false,
			);
			return resolved;
		}
		// This function creates a synthetic symbol that combines the value side of one symbol with the
		// type/namespace side of another symbol. Consider this example:
		//
		//   declare module graphics {
		//       interface Point {
		//           x: number;
		//           y: number;
		//       }
		//   }
		//   declare var graphics: {
		//       Point: new (x: number, y: number) => graphics.Point;
		//   }
		//   declare module "graphics" {
		//       export = graphics;
		//   }
		//
		// An 'import { Point } from "graphics"' needs to create a symbol that combines the value side 'Point'
		// property with the type/namespace side interface 'Point'.
		function combineValueAndTypeSymbols(valueSymbol, typeSymbol) {
			if (valueSymbol === unknownSymbol && typeSymbol === unknownSymbol) {
				return unknownSymbol;
			}
			if (valueSymbol.flags & (SymbolFlags.Type | SymbolFlags.Namespace)) {
				return valueSymbol;
			}
			var result = createSymbol(
				valueSymbol.flags | typeSymbol.flags,
				valueSymbol.escapedName,
			);
			result.declarations = deduplicate(
				concatenate(valueSymbol.declarations, typeSymbol.declarations),
				equateValues,
			);
			result.parent = valueSymbol.parent || typeSymbol.parent;
			if (valueSymbol.valueDeclaration) result.valueDeclaration = valueSymbol.valueDeclaration;
			if (typeSymbol.members) result.members = new Map(typeSymbol.members);
			if (valueSymbol.exports) result.exports = new Map(valueSymbol.exports);
			return result;
		}
		function getExportOfModule(symbol, name, specifier, dontResolveAlias) {
			if (symbol.flags & SymbolFlags.Module) {
				var exportSymbol = getExportsOfSymbol(symbol).get(name.escapedText);
				var resolved = resolveSymbol(exportSymbol, dontResolveAlias);
				markSymbolOfAliasDeclarationIfTypeOnly(
					specifier,
					exportSymbol,
					resolved, /*overwriteEmpty*/
					false,
				);
				return resolved;
			}
		}
		function getPropertyOfVariable(symbol, name) {
			if (symbol.flags & SymbolFlags.Variable) {
				var typeAnnotation = symbol.valueDeclaration.type;
				if (typeAnnotation) {
					return resolveSymbol(
						getPropertyOfType(getTypeFromTypeNode(typeAnnotation), name),
					);
				}
			}
		}
		function getExternalModuleMember(node, specifier, dontResolveAlias) {
			var _a, _b;
			if (dontResolveAlias === void 0) {
				dontResolveAlias = false;
			}
			var moduleSpecifier = getExternalModuleRequireArgument(node) || node.moduleSpecifier;
			var moduleSymbol = resolveExternalModuleName(node, moduleSpecifier); // TODO: GH#18217
			var name = !isPropertyAccessExpression(specifier) && specifier.propertyName || specifier.name;
			if (!isIdentifier(name)) {
				return undefined;
			}
			var suppressInteropError = name.escapedText === InternalSymbolName.Default && !!(compilerOptions.allowSyntheticDefaultImports || getESModuleInterop(
				compilerOptions,
			));
			var targetSymbol = resolveESModuleSymbol(
				moduleSymbol,
				moduleSpecifier, /*dontResolveAlias*/
				false,
				suppressInteropError,
			);
			if (targetSymbol) {
				if (name.escapedText) {
					if (isShorthandAmbientModuleSymbol(moduleSymbol)) {
						return moduleSymbol;
					}
					var symbolFromVariable = void 0;
					// First check if module was specified with "export=". If so, get the member from the resolved type
					if (
						moduleSymbol && moduleSymbol.exports && moduleSymbol.exports.get(
							InternalSymbolName.ExportEquals,
						)
					) {
						symbolFromVariable = getPropertyOfType(
							getTypeOfSymbol(targetSymbol),
							name.escapedText, /*skipObjectFunctionPropertyAugment*/
							true,
						);
					} else {
						symbolFromVariable = getPropertyOfVariable(
							targetSymbol,
							name.escapedText,
						);
					}
					// if symbolFromVariable is export - get its final target
					symbolFromVariable = resolveSymbol(
						symbolFromVariable,
						dontResolveAlias,
					);
					var symbolFromModule = getExportOfModule(
						targetSymbol,
						name,
						specifier,
						dontResolveAlias,
					);
					if (
						symbolFromModule === undefined && name.escapedText === InternalSymbolName.Default
					) {
						var file = (_a = moduleSymbol.declarations) === null || _a === void 0 ? void 0 : _a.find(
							isSourceFile,
						);
						if (
							isOnlyImportedAsDefault(moduleSpecifier) || canHaveSyntheticDefault(
								file,
								moduleSymbol,
								dontResolveAlias,
								moduleSpecifier,
							)
						) {
							symbolFromModule = resolveExternalModuleSymbol(
								moduleSymbol,
								dontResolveAlias,
							) || resolveSymbol(moduleSymbol, dontResolveAlias);
						}
					}
					var symbol = symbolFromModule && symbolFromVariable && symbolFromModule !== symbolFromVariable ? combineValueAndTypeSymbols(
						symbolFromVariable,
						symbolFromModule,
					) : symbolFromModule || symbolFromVariable;
					if (!symbol) {
						var moduleName = getFullyQualifiedName(moduleSymbol, node);
						var declarationName = declarationNameToString(name);
						var suggestion = getSuggestedSymbolForNonexistentModule(
							name,
							targetSymbol,
						);
						if (suggestion !== undefined) {
							var suggestionName = symbolToString(suggestion);
							var diagnostic = error(
								name,
								Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2,
								moduleName,
								declarationName,
								suggestionName,
							);
							if (suggestion.valueDeclaration) {
								addRelatedInfo(
									diagnostic,
									createDiagnosticForNode(
										suggestion.valueDeclaration,
										Diagnostics._0_is_declared_here,
										suggestionName,
									),
								);
							}
						} else {
							if (
								(_b = moduleSymbol.exports) === null || _b === void 0 ? void 0 : _b.has(
									InternalSymbolName.Default,
								)
							) {
								error(
									name,
									Diagnostics.Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead,
									moduleName,
									declarationName,
								);
							} else {
								reportNonExportedMember(
									node,
									name,
									declarationName,
									moduleSymbol,
									moduleName,
								);
							}
						}
					}
					return symbol;
				}
			}
		}
		function reportNonExportedMember(
			node,
			name,
			declarationName,
			moduleSymbol,
			moduleName,
		) {
			var _a, _b;
			var localSymbol = (_b = (_a = moduleSymbol.valueDeclaration) === null || _a === void 0 ? void 0 : _a.locals) === null || _b === void 0 ? void 0 : _b.get(
				name.escapedText,
			);
			var exports = moduleSymbol.exports;
			if (localSymbol) {
				var exportedEqualsSymbol = exports === null || exports === void 0 ? void 0 : exports.get(
					InternalSymbolName.ExportEquals,
				);
				if (exportedEqualsSymbol) {
					getSymbolIfSameReference(exportedEqualsSymbol, localSymbol) ? reportInvalidImportEqualsExportMember(
						node,
						name,
						declarationName,
						moduleName,
					) : error(
						name,
						Diagnostics.Module_0_has_no_exported_member_1,
						moduleName,
						declarationName,
					);
				} else {
					var exportedSymbol = exports ? find(
						symbolsToArray(exports),
						function (symbol) {
							return !!getSymbolIfSameReference(symbol, localSymbol);
						},
					) : undefined;
					var diagnostic = exportedSymbol ? error(
						name,
						Diagnostics.Module_0_declares_1_locally_but_it_is_exported_as_2,
						moduleName,
						declarationName,
						symbolToString(exportedSymbol),
					) : error(
						name,
						Diagnostics.Module_0_declares_1_locally_but_it_is_not_exported,
						moduleName,
						declarationName,
					);
					if (localSymbol.declarations) {
						addRelatedInfo.apply(
							void 0,
							__spreadArray(
								[diagnostic],
								map(
									localSymbol.declarations,
									function (decl, index) {
										return createDiagnosticForNode(
											decl,
											index === 0 ? Diagnostics._0_is_declared_here : Diagnostics.and_here,
											declarationName,
										);
									},
								),
								false,
							),
						);
					}
				}
			} else {
				error(
					name,
					Diagnostics.Module_0_has_no_exported_member_1,
					moduleName,
					declarationName,
				);
			}
		}
		function reportInvalidImportEqualsExportMember(
			node,
			name,
			declarationName,
			moduleName,
		) {
			if (moduleKind >= ModuleKind.ES2015) {
				var message = getESModuleInterop(compilerOptions) ? Diagnostics._0_can_only_be_imported_by_using_a_default_import : Diagnostics._0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import;
				error(name, message, declarationName);
			} else {
				if (isInJSFile(node)) {
					var message = getESModuleInterop(compilerOptions) ? Diagnostics._0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import : Diagnostics._0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import;
					error(name, message, declarationName);
				} else {
					var message = getESModuleInterop(compilerOptions) ? Diagnostics._0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import : Diagnostics._0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import;
					error(name, message, declarationName, declarationName, moduleName);
				}
			}
		}
		function getTargetOfImportSpecifier(node, dontResolveAlias) {
			var root = isBindingElement(node) ? getRootDeclaration(node) : node.parent.parent.parent;
			var commonJSPropertyAccess = getCommonJSPropertyAccess(root);
			var resolved = getExternalModuleMember(
				root,
				commonJSPropertyAccess || node,
				dontResolveAlias,
			);
			var name = node.propertyName || node.name;
			if (commonJSPropertyAccess && resolved && isIdentifier(name)) {
				return resolveSymbol(
					getPropertyOfType(getTypeOfSymbol(resolved), name.escapedText),
					dontResolveAlias,
				);
			}
			markSymbolOfAliasDeclarationIfTypeOnly(
				node, /*immediateTarget*/
				undefined,
				resolved, /*overwriteEmpty*/
				false,
			);
			return resolved;
		}
		function getCommonJSPropertyAccess(node) {
			if (
				isVariableDeclaration(node) && node.initializer && isPropertyAccessExpression(
					node.initializer,
				)
			) {
				return node.initializer;
			}
		}
		function getTargetOfNamespaceExportDeclaration(node, dontResolveAlias) {
			var resolved = resolveExternalModuleSymbol(
				node.parent.symbol,
				dontResolveAlias,
			);
			markSymbolOfAliasDeclarationIfTypeOnly(
				node, /*immediateTarget*/
				undefined,
				resolved, /*overwriteEmpty*/
				false,
			);
			return resolved;
		}
		function getTargetOfExportSpecifier(node, meaning, dontResolveAlias) {
			var resolved = node.parent.parent.moduleSpecifier ? getExternalModuleMember(
				node.parent.parent,
				node,
				dontResolveAlias,
			) : resolveEntityName(
				node.propertyName || node.name,
				meaning, /*ignoreErrors*/
				false,
				dontResolveAlias,
			);
			markSymbolOfAliasDeclarationIfTypeOnly(
				node, /*immediateTarget*/
				undefined,
				resolved, /*overwriteEmpty*/
				false,
			);
			return resolved;
		}
		function getTargetOfExportAssignment(node, dontResolveAlias) {
			var expression = isExportAssignment(node) ? node.expression : node.right;
			var resolved = getTargetOfAliasLikeExpression(
				expression,
				dontResolveAlias,
			);
			markSymbolOfAliasDeclarationIfTypeOnly(
				node, /*immediateTarget*/
				undefined,
				resolved, /*overwriteEmpty*/
				false,
			);
			return resolved;
		}
		function getTargetOfAliasLikeExpression(expression, dontResolveAlias) {
			if (isClassExpression(expression)) {
				return checkExpressionCached(expression).symbol;
			}
			if (!isEntityName(expression) && !isEntityNameExpression(expression)) {
				return undefined;
			}
			var aliasLike = resolveEntityName(
				expression,
				SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, /*ignoreErrors*/
				true,
				dontResolveAlias,
			);
			if (aliasLike) {
				return aliasLike;
			}
			checkExpressionCached(expression);
			return getNodeLinks(expression).resolvedSymbol;
		}
		function getTargetOfPropertyAssignment(node, dontRecursivelyResolve) {
			var expression = node.initializer;
			return getTargetOfAliasLikeExpression(expression, dontRecursivelyResolve);
		}
		function getTargetOfAccessExpression(node, dontRecursivelyResolve) {
			if (
				!(isBinaryExpression(node.parent) && node.parent.left === node && node.parent.operatorToken.kind === SyntaxKind.EqualsToken)
			) {
				return undefined;
			}
			return getTargetOfAliasLikeExpression(
				node.parent.right,
				dontRecursivelyResolve,
			);
		}
		function getTargetOfAliasDeclaration(node, dontRecursivelyResolve) {
			if (dontRecursivelyResolve === void 0) {
				dontRecursivelyResolve = false;
			}
			switch (node.kind) {
				case SyntaxKind.ImportEqualsDeclaration:
				case SyntaxKind.VariableDeclaration:
					return getTargetOfImportEqualsDeclaration(
						node,
						dontRecursivelyResolve,
					);
				case SyntaxKind.ImportClause:
					return getTargetOfImportClause(node, dontRecursivelyResolve);
				case SyntaxKind.NamespaceImport:
					return getTargetOfNamespaceImport(node, dontRecursivelyResolve);
				case SyntaxKind.NamespaceExport:
					return getTargetOfNamespaceExport(node, dontRecursivelyResolve);
				case SyntaxKind.ImportSpecifier:
				case SyntaxKind.BindingElement:
					return getTargetOfImportSpecifier(node, dontRecursivelyResolve);
				case SyntaxKind.ExportSpecifier:
					return getTargetOfExportSpecifier(
						node,
						SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace,
						dontRecursivelyResolve,
					);
				case SyntaxKind.ExportAssignment:
				case SyntaxKind.BinaryExpression:
					return getTargetOfExportAssignment(node, dontRecursivelyResolve);
				case SyntaxKind.NamespaceExportDeclaration:
					return getTargetOfNamespaceExportDeclaration(
						node,
						dontRecursivelyResolve,
					);
				case SyntaxKind.ShorthandPropertyAssignment:
					return resolveEntityName(
						node.name,
						SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, /*ignoreErrors*/
						true,
						dontRecursivelyResolve,
					);
				case SyntaxKind.PropertyAssignment:
					return getTargetOfPropertyAssignment(node, dontRecursivelyResolve);
				case SyntaxKind.ElementAccessExpression:
				case SyntaxKind.PropertyAccessExpression:
					return getTargetOfAccessExpression(node, dontRecursivelyResolve);
				default:
					return Debug.fail();
			}
		}
		/**
         * Indicates that a symbol is an alias that does not merge with a local declaration.
         * OR Is a JSContainer which may merge an alias with a local declaration
         */
		function isNonLocalAlias(symbol, excludes) {
			if (excludes === void 0) {
				excludes = SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace;
			}
			if (!symbol) return false;
			return (symbol.flags & (SymbolFlags.Alias | excludes)) === SymbolFlags.Alias || !!(symbol.flags & SymbolFlags.Alias && symbol.flags & SymbolFlags.Assignment);
		}
		function resolveSymbol(symbol, dontResolveAlias) {
			return !dontResolveAlias && isNonLocalAlias(symbol) ? resolveAlias(symbol) : symbol;
		}
		function resolveAlias(symbol) {
			Debug.assert(
				(symbol.flags & SymbolFlags.Alias) !== 0,
				"Should only get Alias here.",
			);
			var links = getSymbolLinks(symbol);
			if (!links.target) {
				links.target = resolvingSymbol;
				var node = getDeclarationOfAliasSymbol(symbol);
				if (!node) return Debug.fail();
				var target = getTargetOfAliasDeclaration(node);
				if (links.target === resolvingSymbol) {
					links.target = target || unknownSymbol;
				} else {
					error(
						node,
						Diagnostics.Circular_definition_of_import_alias_0,
						symbolToString(symbol),
					);
				}
			} else if (links.target === resolvingSymbol) {
				links.target = unknownSymbol;
			}
			return links.target;
		}
		function tryResolveAlias(symbol) {
			var links = getSymbolLinks(symbol);
			if (links.target !== resolvingSymbol) {
				return resolveAlias(symbol);
			}
			return undefined;
		}
		/**
         * Marks a symbol as type-only if its declaration is syntactically type-only.
         * If it is not itself marked type-only, but resolves to a type-only alias
         * somewhere in its resolution chain, save a reference to the type-only alias declaration
         * so the alias _not_ marked type-only can be identified as _transitively_ type-only.
         *
         * This function is called on each alias declaration that could be type-only or resolve to
         * another type-only alias during `resolveAlias`, so that later, when an alias is used in a
         * JS-emitting expression, we can quickly determine if that symbol is effectively type-only
         * and issue an error if so.
         *
         * @param aliasDeclaration The alias declaration not marked as type-only
         * @param immediateTarget The symbol to which the alias declaration immediately resolves
         * @param finalTarget The symbol to which the alias declaration ultimately resolves
         * @param overwriteEmpty Checks `resolvesToSymbol` for type-only declarations even if `aliasDeclaration`
         * has already been marked as not resolving to a type-only alias. Used when recursively resolving qualified
         * names of import aliases, e.g. `import C = a.b.C`. If namespace `a` is not found to be type-only, the
         * import declaration will initially be marked as not resolving to a type-only symbol. But, namespace `b`
         * must still be checked for a type-only marker, overwriting the previous negative result if found.
         */
		function markSymbolOfAliasDeclarationIfTypeOnly(
			aliasDeclaration,
			immediateTarget,
			finalTarget,
			overwriteEmpty,
		) {
			if (!aliasDeclaration || isPropertyAccessExpression(aliasDeclaration)) return false;
			// If the declaration itself is type-only, mark it and return.
			// No need to check what it resolves to.
			var sourceSymbol = getSymbolOfNode(aliasDeclaration);
			if (isTypeOnlyImportOrExportDeclaration(aliasDeclaration)) {
				var links_1 = getSymbolLinks(sourceSymbol);
				links_1.typeOnlyDeclaration = aliasDeclaration;
				return true;
			}
			var links = getSymbolLinks(sourceSymbol);
			return markSymbolOfAliasDeclarationIfTypeOnlyWorker(
				links,
				immediateTarget,
				overwriteEmpty,
			) || markSymbolOfAliasDeclarationIfTypeOnlyWorker(
				links,
				finalTarget,
				overwriteEmpty,
			);
		}
		function markSymbolOfAliasDeclarationIfTypeOnlyWorker(
			aliasDeclarationLinks,
			target,
			overwriteEmpty,
		) {
			var _a, _b, _c;
			if (
				target && (aliasDeclarationLinks.typeOnlyDeclaration === undefined || overwriteEmpty && aliasDeclarationLinks.typeOnlyDeclaration === false)
			) {
				var exportSymbol = (_b = (_a = target.exports) === null || _a === void 0 ? void 0 : _a.get(
					InternalSymbolName.ExportEquals,
				)) !== null && _b !== void 0 ? _b : target;
				var typeOnly = exportSymbol.declarations && find(
					exportSymbol.declarations,
					isTypeOnlyImportOrExportDeclaration,
				);
				aliasDeclarationLinks.typeOnlyDeclaration = (_c = typeOnly !== null && typeOnly !== void 0 ? typeOnly : getSymbolLinks(
					exportSymbol,
				).typeOnlyDeclaration) !== null && _c !== void 0 ? _c : false;
			}
			return !!aliasDeclarationLinks.typeOnlyDeclaration;
		}
		/** Indicates that a symbol directly or indirectly resolves to a type-only import or export. */
		function getTypeOnlyAliasDeclaration(symbol) {
			if (!(symbol.flags & SymbolFlags.Alias)) {
				return undefined;
			}
			var links = getSymbolLinks(symbol);
			return links.typeOnlyDeclaration || undefined;
		}
		function markExportAsReferenced(node) {
			var symbol = getSymbolOfNode(node);
			var target = resolveAlias(symbol);
			if (target) {
				var markAlias = target === unknownSymbol || ((target.flags & SymbolFlags.Value) && !isConstEnumOrConstEnumOnlyModule(
					target,
				) && !getTypeOnlyAliasDeclaration(symbol));
				if (markAlias) {
					markAliasSymbolAsReferenced(symbol);
				}
			}
		}
		// When an alias symbol is referenced, we need to mark the entity it references as referenced and in turn repeat that until
		// we reach a non-alias or an exported entity (which is always considered referenced). We do this by checking the target of
		// the alias as an expression (which recursively takes us back here if the target references another alias).
		function markAliasSymbolAsReferenced(symbol) {
			var links = getSymbolLinks(symbol);
			if (!links.referenced) {
				links.referenced = true;
				var node = getDeclarationOfAliasSymbol(symbol);
				if (!node) return Debug.fail();
				// We defer checking of the reference of an `import =` until the import itself is referenced,
				// This way a chain of imports can be elided if ultimately the final input is only used in a type
				// position.
				if (isInternalModuleImportEqualsDeclaration(node)) {
					var target = resolveSymbol(symbol);
					if (target === unknownSymbol || target.flags & SymbolFlags.Value) {
						// import foo = <symbol>
						checkExpressionCached(node.moduleReference);
					}
				}
			}
		}
		// Aliases that resolve to const enums are not marked as referenced because they are not emitted,
		// but their usage in value positions must be tracked to determine if the import can be type-only.
		function markConstEnumAliasAsReferenced(symbol) {
			var links = getSymbolLinks(symbol);
			if (!links.constEnumReferenced) {
				links.constEnumReferenced = true;
			}
		}
		// This function is only for imports with entity names
		function getSymbolOfPartOfRightHandSideOfImportEquals(
			entityName,
			dontResolveAlias,
		) {
			// There are three things we might try to look for. In the following examples,
			// the search term is enclosed in |...|:
			//
			//     import a = |b|; // Namespace
			//     import a = |b.c|; // Value, type, namespace
			//     import a = |b.c|.d; // Namespace
			if (
				entityName.kind === SyntaxKind.Identifier && isRightSideOfQualifiedNameOrPropertyAccess(
					entityName,
				)
			) {
				entityName = entityName.parent;
			}
			// Check for case 1 and 3 in the above example
			if (
				entityName.kind === SyntaxKind.Identifier || entityName.parent.kind === SyntaxKind.QualifiedName
			) {
				return resolveEntityName(
					entityName,
					SymbolFlags.Namespace, /*ignoreErrors*/
					false,
					dontResolveAlias,
				);
			} else {
				// Case 2 in above example
				// entityName.kind could be a QualifiedName or a Missing identifier
				Debug.assert(
					entityName.parent.kind === SyntaxKind.ImportEqualsDeclaration,
				);
				return resolveEntityName(
					entityName,
					SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, /*ignoreErrors*/
					false,
					dontResolveAlias,
				);
			}
		}
		function getFullyQualifiedName(symbol, containingLocation) {
			return symbol.parent ? getFullyQualifiedName(
				symbol.parent,
				containingLocation,
			) + "." + symbolToString(symbol) : symbolToString(
				symbol,
				containingLocation, /*meaning*/
				undefined,
				SymbolFormatFlags.DoNotIncludeSymbolChain | SymbolFormatFlags.AllowAnyNodeKind,
			);
		}
		function getContainingQualifiedNameNode(node) {
			while (isQualifiedName(node.parent)) {
				node = node.parent;
			}
			return node;
		}
		function tryGetQualifiedNameAsValue(node) {
			var left = getFirstIdentifier(node);
			var symbol = resolveName(
				left,
				left.escapedText,
				SymbolFlags.Value,
				undefined,
				left, /*isUse*/
				true,
			);
			if (!symbol) {
				return undefined;
			}
			while (isQualifiedName(left.parent)) {
				var type = getTypeOfSymbol(symbol);
				symbol = getPropertyOfType(type, left.parent.right.escapedText);
				if (!symbol) {
					return undefined;
				}
				left = left.parent;
			}
			return symbol;
		}
		/**
         * Resolves a qualified name and any involved aliases.
         */
		function resolveEntityName(
			name,
			meaning,
			ignoreErrors,
			dontResolveAlias,
			location,
		) {
			if (nodeIsMissing(name)) {
				return undefined;
			}
			var namespaceMeaning = SymbolFlags.Namespace | (isInJSFile(name) ? meaning & SymbolFlags.Value : 0);
			var symbol;
			if (name.kind === SyntaxKind.Identifier) {
				var message = meaning === namespaceMeaning || nodeIsSynthesized(name) ? Diagnostics.Cannot_find_namespace_0 : getCannotFindNameDiagnosticForName(
					getFirstIdentifier(name),
				);
				var symbolFromJSPrototype = isInJSFile(name) && !nodeIsSynthesized(name) ? resolveEntityNameFromAssignmentDeclaration(
					name,
					meaning,
				) : undefined;
				symbol = getMergedSymbol(
					resolveName(
						location || name,
						name.escapedText,
						meaning,
						ignoreErrors || symbolFromJSPrototype ? undefined : message,
						name, /*isUse*/
						true,
						false,
					),
				);
				if (!symbol) {
					return getMergedSymbol(symbolFromJSPrototype);
				}
			} else if (
				name.kind === SyntaxKind.QualifiedName || name.kind === SyntaxKind.PropertyAccessExpression
			) {
				var left = name.kind === SyntaxKind.QualifiedName ? name.left : name.expression;
				var right = name.kind === SyntaxKind.QualifiedName ? name.right : name.name;
				var namespace = resolveEntityName(
					left,
					namespaceMeaning,
					ignoreErrors, /*dontResolveAlias*/
					false,
					location,
				);
				if (!namespace || nodeIsMissing(right)) {
					return undefined;
				} else if (namespace === unknownSymbol) {
					return namespace;
				}
				if (
					namespace.valueDeclaration && isInJSFile(namespace.valueDeclaration) && isVariableDeclaration(
						namespace.valueDeclaration,
					) && namespace.valueDeclaration.initializer && isCommonJsRequire(
						namespace.valueDeclaration.initializer,
					)
				) {
					var moduleName = namespace.valueDeclaration.initializer.arguments[0];
					var moduleSym = resolveExternalModuleName(moduleName, moduleName);
					if (moduleSym) {
						var resolvedModuleSymbol = resolveExternalModuleSymbol(moduleSym);
						if (resolvedModuleSymbol) {
							namespace = resolvedModuleSymbol;
						}
					}
				}
				symbol = getMergedSymbol(
					getSymbol(getExportsOfSymbol(namespace), right.escapedText, meaning),
				);
				if (!symbol) {
					if (!ignoreErrors) {
						var namespaceName = getFullyQualifiedName(namespace);
						var declarationName = declarationNameToString(right);
						var suggestionForNonexistentModule = getSuggestedSymbolForNonexistentModule(
							right,
							namespace,
						);
						if (suggestionForNonexistentModule) {
							error(
								right,
								Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2,
								namespaceName,
								declarationName,
								symbolToString(suggestionForNonexistentModule),
							);
							return undefined;
						}
						var containingQualifiedName = isQualifiedName(name) && getContainingQualifiedNameNode(
							name,
						);
						var canSuggestTypeof = globalObjectType && (meaning & SymbolFlags.Type) && containingQualifiedName && !isTypeOfExpression(
							containingQualifiedName.parent, // <-- can't pull on types if global types aren't initialized yet
						) && tryGetQualifiedNameAsValue(containingQualifiedName);
						if (canSuggestTypeof) {
							error(
								containingQualifiedName,
								Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0,
								entityNameToString(containingQualifiedName),
							);
							return undefined;
						}
						if (meaning & SymbolFlags.Namespace && isQualifiedName(name.parent)) {
							var exportedTypeSymbol = getMergedSymbol(
								getSymbol(
									getExportsOfSymbol(namespace),
									right.escapedText,
									SymbolFlags.Type,
								),
							);
							if (exportedTypeSymbol) {
								error(
									name.parent.right,
									Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1,
									symbolToString(exportedTypeSymbol),
									unescapeLeadingUnderscores(name.parent.right.escapedText),
								);
								return undefined;
							}
						}
						error(
							right,
							Diagnostics.Namespace_0_has_no_exported_member_1,
							namespaceName,
							declarationName,
						);
					}
					return undefined;
				}
			} else {
				throw Debug.assertNever(name, "Unknown entity name kind.");
			}
			Debug.assert(
				(getCheckFlags(symbol) & CheckFlags.Instantiated) === 0,
				"Should never get an instantiated symbol here.",
			);
			if (
				!nodeIsSynthesized(name) && isEntityName(name) && (symbol.flags & SymbolFlags.Alias || name.parent.kind === SyntaxKind.ExportAssignment)
			) {
				markSymbolOfAliasDeclarationIfTypeOnly(
					getAliasDeclarationFromName(name),
					symbol, /*finalTarget*/
					undefined, /*overwriteEmpty*/
					true,
				);
			}
			return (symbol.flags & meaning) || dontResolveAlias ? symbol : resolveAlias(
				symbol,
			);
		}
		/**
         * 1. For prototype-property methods like `A.prototype.m = function () ...`, try to resolve names in the scope of `A` too.
         * Note that prototype-property assignment to locations outside the current file (eg globals) doesn't work, so
         * name resolution won't work either.
         * 2. For property assignments like `{ x: function f () { } }`, try to resolve names in the scope of `f` too.
         */
		function resolveEntityNameFromAssignmentDeclaration(name, meaning) {
			if (isJSDocTypeReference(name.parent)) {
				var secondaryLocation = getAssignmentDeclarationLocation(name.parent);
				if (secondaryLocation) {
					return resolveName(
						secondaryLocation,
						name.escapedText,
						meaning, /*nameNotFoundMessage*/
						undefined,
						name, /*isUse*/
						true,
					);
				}
			}
		}
		function getAssignmentDeclarationLocation(node) {
			var typeAlias = findAncestor(
				node,
				function (node) {
					return !(isJSDocNode(node) || node.flags & NodeFlags.JSDoc) ? "quit" : isJSDocTypeAlias(
						node,
					);
				},
			);
			if (typeAlias) {
				return;
			}
			var host = getJSDocHost(node);
			if (
				host && isExpressionStatement(host) && isBinaryExpression(
					host.expression,
				) && getAssignmentDeclarationKind(host.expression) === AssignmentDeclarationKind.PrototypeProperty
			) {
				// X.prototype.m = /** @param {K} p */ function () { } <-- look for K on X's declaration
				var symbol = getSymbolOfNode(host.expression.left);
				if (symbol) {
					return getDeclarationOfJSPrototypeContainer(symbol);
				}
			}
			if (
				host && (isObjectLiteralMethod(host) || isPropertyAssignment(host)) && isBinaryExpression(
					host.parent.parent,
				) && getAssignmentDeclarationKind(host.parent.parent) === AssignmentDeclarationKind.Prototype
			) {
				// X.prototype = { /** @param {K} p */m() { } } <-- look for K on X's declaration
				var symbol = getSymbolOfNode(host.parent.parent.left);
				if (symbol) {
					return getDeclarationOfJSPrototypeContainer(symbol);
				}
			}
			var sig = getEffectiveJSDocHost(node);
			if (sig && isFunctionLike(sig)) {
				var symbol = getSymbolOfNode(sig);
				return symbol && symbol.valueDeclaration;
			}
		}
		function getDeclarationOfJSPrototypeContainer(symbol) {
			var decl = symbol.parent.valueDeclaration;
			if (!decl) {
				return undefined;
			}
			var initializer = isAssignmentDeclaration(decl) ? getAssignedExpandoInitializer(
				decl,
			) : hasOnlyExpressionInitializer(decl) ? getDeclaredExpandoInitializer(
				decl,
			) : undefined;
			return initializer || decl;
		}
		/**
         * Get the real symbol of a declaration with an expando initializer.
         *
         * Normally, declarations have an associated symbol, but when a declaration has an expando
         * initializer, the expando's symbol is the one that has all the members merged into it.
         */
		function getExpandoSymbol(symbol) {
			var decl = symbol.valueDeclaration;
			if (
				!decl || !isInJSFile(decl) || symbol.flags & SymbolFlags.TypeAlias || getExpandoInitializer(
					decl, /*isPrototypeAssignment*/
					false,
				)
			) {
				return undefined;
			}
			var init = isVariableDeclaration(decl) ? getDeclaredExpandoInitializer(
				decl,
			) : getAssignedExpandoInitializer(decl);
			if (init) {
				var initSymbol = getSymbolOfNode(init);
				if (initSymbol) {
					return mergeJSSymbols(initSymbol, symbol);
				}
			}
		}
		function resolveExternalModuleName(
			location,
			moduleReferenceExpression,
			ignoreErrors,
		) {
			var isClassic = getEmitModuleResolutionKind(compilerOptions) === ModuleResolutionKind.Classic;
			var errorMessage = isClassic ? Diagnostics.Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_node_or_to_add_aliases_to_the_paths_option : Diagnostics.Cannot_find_module_0_or_its_corresponding_type_declarations;
			return resolveExternalModuleNameWorker(
				location,
				moduleReferenceExpression,
				ignoreErrors ? undefined : errorMessage,
			);
		}
		function resolveExternalModuleNameWorker(
			location,
			moduleReferenceExpression,
			moduleNotFoundError,
			isForAugmentation,
		) {
			if (isForAugmentation === void 0) {
				isForAugmentation = false;
			}
			return isStringLiteralLike(moduleReferenceExpression) ? resolveExternalModule(
				location,
				moduleReferenceExpression.text,
				moduleNotFoundError,
				moduleReferenceExpression,
				isForAugmentation,
			) : undefined;
		}
		function resolveExternalModule(
			location,
			moduleReference,
			moduleNotFoundError,
			errorNode,
			isForAugmentation,
		) {
			var _a, _b, _c, _d, _e, _f, _g;
			if (isForAugmentation === void 0) {
				isForAugmentation = false;
			}
			if (startsWith(moduleReference, "@types/")) {
				var diag = Diagnostics.Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1;
				var withoutAtTypePrefix = removePrefix(moduleReference, "@types/");
				error(errorNode, diag, withoutAtTypePrefix, moduleReference);
			}
			var ambientModule = tryFindAmbientModule(
				moduleReference, /*withAugmentations*/
				true,
			);
			if (ambientModule) {
				return ambientModule;
			}
			var currentSourceFile = getSourceFileOfNode(location);
			var contextSpecifier = isStringLiteralLike(location) ? location : ((_a = findAncestor(
				location,
				isImportCall,
			)) === null || _a === void 0 ? void 0 : _a.arguments[0]) || ((_b = findAncestor(
				location,
				isImportDeclaration,
			)) === null || _b === void 0 ? void 0 : _b.moduleSpecifier) || ((_c = findAncestor(
				location,
				isExternalModuleImportEqualsDeclaration,
			)) === null || _c === void 0 ? void 0 : _c.moduleReference.expression) || ((_d = findAncestor(
				location,
				isExportDeclaration,
			)) === null || _d === void 0 ? void 0 : _d.moduleSpecifier) || ((_e = (isModuleDeclaration(
				location,
			) ? location : location.parent && isModuleDeclaration(location.parent) && location.parent.name === location ? location.parent : undefined)) === null || _e === void 0 ? void 0 : _e.name) || ((_f = (isLiteralImportTypeNode(
				location,
			) ? location : undefined)) === null || _f === void 0 ? void 0 : _f.argument.literal);
			var mode = contextSpecifier && isStringLiteralLike(contextSpecifier) ? getModeForUsageLocation(
				currentSourceFile,
				contextSpecifier,
			) : currentSourceFile.impliedNodeFormat;
			var resolvedModule = getResolvedModule(
				currentSourceFile,
				moduleReference,
				mode,
			);
			var resolutionDiagnostic = resolvedModule && getResolutionDiagnostic(
				compilerOptions,
				resolvedModule,
			);
			var sourceFile = resolvedModule && !resolutionDiagnostic && host.getSourceFile(
				resolvedModule.resolvedFileName,
			);
			if (sourceFile) {
				if (sourceFile.symbol) {
					if (
						resolvedModule.isExternalLibraryImport && !resolutionExtensionIsTSOrJson(
							resolvedModule.extension,
						)
					) {
						errorOnImplicitAnyModule(
							false, /*isError*/
							errorNode,
							resolvedModule,
							moduleReference,
						);
					}
					if (
						getEmitModuleResolutionKind(compilerOptions) === ModuleResolutionKind.Node12 || getEmitModuleResolutionKind(
							compilerOptions,
						) === ModuleResolutionKind.NodeNext
					) {
						var isSyncImport = (currentSourceFile.impliedNodeFormat === ModuleKind.CommonJS && !findAncestor(
							location,
							isImportCall,
						)) || !!findAncestor(location, isImportEqualsDeclaration);
						if (
							isSyncImport && sourceFile.impliedNodeFormat === ModuleKind.ESNext
						) {
							error(
								errorNode,
								Diagnostics.Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_cannot_be_imported_synchronously_Use_dynamic_import_instead,
								moduleReference,
							);
						}
						if (
							mode === ModuleKind.ESNext && compilerOptions.resolveJsonModule && resolvedModule.extension === Extension.Json
						) {
							error(
								errorNode,
								Diagnostics.JSON_imports_are_experimental_in_ES_module_mode_imports,
							);
						}
					}
					// merged symbol is module declaration symbol combined with all augmentations
					return getMergedSymbol(sourceFile.symbol);
				}
				if (moduleNotFoundError) {
					// report errors only if it was requested
					error(
						errorNode,
						Diagnostics.File_0_is_not_a_module,
						sourceFile.fileName,
					);
				}
				return undefined;
			}
			if (patternAmbientModules) {
				var pattern = findBestPatternMatch(
					patternAmbientModules,
					function (_) {
						return _.pattern;
					},
					moduleReference,
				);
				if (pattern) {
					// If the module reference matched a pattern ambient module ('*.foo') but there's also a
					// module augmentation by the specific name requested ('a.foo'), we store the merged symbol
					// by the augmentation name ('a.foo'), because asking for *.foo should not give you exports
					// from a.foo.
					var augmentation = patternAmbientModuleAugmentations && patternAmbientModuleAugmentations.get(
						moduleReference,
					);
					if (augmentation) {
						return getMergedSymbol(augmentation);
					}
					return getMergedSymbol(pattern.symbol);
				}
			}
			// May be an untyped module. If so, ignore resolutionDiagnostic.
			if (
				resolvedModule && !resolutionExtensionIsTSOrJson(
					resolvedModule.extension,
				) && resolutionDiagnostic === undefined || resolutionDiagnostic === Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type
			) {
				if (isForAugmentation) {
					var diag = Diagnostics.Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augmented;
					error(
						errorNode,
						diag,
						moduleReference,
						resolvedModule.resolvedFileName,
					);
				} else {
					errorOnImplicitAnyModule(
						noImplicitAny && !!moduleNotFoundError, /*isError*/
						errorNode,
						resolvedModule,
						moduleReference,
					);
				}
				// Failed imports and untyped modules are both treated in an untyped manner; only difference is whether we give a diagnostic first.
				return undefined;
			}
			if (moduleNotFoundError) {
				// See if this was possibly a projectReference redirect
				if (resolvedModule) {
					var redirect = host.getProjectReferenceRedirect(
						resolvedModule.resolvedFileName,
					);
					if (redirect) {
						error(
							errorNode,
							Diagnostics.Output_file_0_has_not_been_built_from_source_file_1,
							redirect,
							resolvedModule.resolvedFileName,
						);
						return undefined;
					}
				}
				if (resolutionDiagnostic) {
					error(
						errorNode,
						resolutionDiagnostic,
						moduleReference,
						resolvedModule.resolvedFileName,
					);
				} else {
					var tsExtension = tryExtractTSExtension(moduleReference);
					var isExtensionlessRelativePathImport = pathIsRelative(
						moduleReference,
					) && !hasExtension(moduleReference);
					var moduleResolutionKind = getEmitModuleResolutionKind(
						compilerOptions,
					);
					var resolutionIsNode12OrNext = moduleResolutionKind === ModuleResolutionKind.Node12 || moduleResolutionKind === ModuleResolutionKind.NodeNext;
					if (tsExtension) {
						var diag = Diagnostics.An_import_path_cannot_end_with_a_0_extension_Consider_importing_1_instead;
						var importSourceWithoutExtension = removeExtension(
							moduleReference,
							tsExtension,
						);
						var replacedImportSource = importSourceWithoutExtension;
						/**
                         * Direct users to import source with .js extension if outputting an ES module.
                         * @see https://github.com/microsoft/TypeScript/issues/42151
                         */
						if (moduleKind >= ModuleKind.ES2015) {
							replacedImportSource += tsExtension === Extension.Mts ? ".mjs" : tsExtension === Extension.Cts ? ".cjs" : ".js";
						}
						error(errorNode, diag, tsExtension, replacedImportSource);
					} else if (
						!compilerOptions.resolveJsonModule && fileExtensionIs(
							moduleReference,
							Extension.Json,
						) && getEmitModuleResolutionKind(compilerOptions) !== ModuleResolutionKind.Classic && hasJsonModuleEmitEnabled(
							compilerOptions,
						)
					) {
						error(
							errorNode,
							Diagnostics.Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension,
							moduleReference,
						);
					} else if (
						mode === ModuleKind.ESNext && resolutionIsNode12OrNext && isExtensionlessRelativePathImport
					) {
						var absoluteRef_1 = getNormalizedAbsolutePath(
							moduleReference,
							getDirectoryPath(currentSourceFile.path),
						);
						var suggestedExt = (_g = suggestedExtensions.find(
							function (_a) {
								var actualExt = _a[0], _importExt = _a[1];
								return host.fileExists(absoluteRef_1 + actualExt);
							},
						)) === null || _g === void 0 ? void 0 : _g[1];
						if (suggestedExt) {
							error(
								errorNode,
								Diagnostics.Relative_import_paths_need_explicit_file_extensions_in_EcmaScript_imports_when_moduleResolution_is_node12_or_nodenext_Did_you_mean_0,
								moduleReference + suggestedExt,
							);
						} else {
							error(
								errorNode,
								Diagnostics.Relative_import_paths_need_explicit_file_extensions_in_EcmaScript_imports_when_moduleResolution_is_node12_or_nodenext_Consider_adding_an_extension_to_the_import_path,
							);
						}
					} else {
						error(errorNode, moduleNotFoundError, moduleReference);
					}
				}
			}
			return undefined;
		}
		function errorOnImplicitAnyModule(isError, errorNode, _a, moduleReference) {
			var packageId = _a.packageId, resolvedFileName = _a.resolvedFileName;
			var errorInfo = !isExternalModuleNameRelative(moduleReference) && packageId ? typesPackageExists(
				packageId.name,
			) ? chainDiagnosticMessages(
				/*details*/ undefined,
				Diagnostics.If_the_0_package_actually_exposes_this_module_consider_sending_a_pull_request_to_amend_https_Colon_Slash_Slashgithub_com_SlashDefinitelyTyped_SlashDefinitelyTyped_Slashtree_Slashmaster_Slashtypes_Slash_1,
				packageId.name,
				mangleScopedPackageName(packageId.name),
			) : packageBundlesTypes(packageId.name) ? chainDiagnosticMessages(
				/*details*/ undefined,
				Diagnostics.If_the_0_package_actually_exposes_this_module_try_adding_a_new_declaration_d_ts_file_containing_declare_module_1,
				packageId.name,
				moduleReference,
			) : chainDiagnosticMessages(
				/*details*/ undefined,
				Diagnostics.Try_npm_i_save_dev_types_Slash_1_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare_module_0,
				moduleReference,
				mangleScopedPackageName(packageId.name),
			) : undefined;
			errorOrSuggestion(
				isError,
				errorNode,
				chainDiagnosticMessages(
					errorInfo,
					Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type,
					moduleReference,
					resolvedFileName,
				),
			);
		}
		function typesPackageExists(packageName) {
			return getPackagesMap().has(getTypesPackageName(packageName));
		}
		function packageBundlesTypes(packageName) {
			return !!getPackagesMap().get(packageName);
		}
		function resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) {
			if (
				moduleSymbol === null || moduleSymbol === void 0 ? void 0 : moduleSymbol.exports
			) {
				var exportEquals = resolveSymbol(
					moduleSymbol.exports.get(InternalSymbolName.ExportEquals),
					dontResolveAlias,
				);
				var exported = getCommonJsExportEquals(
					getMergedSymbol(exportEquals),
					getMergedSymbol(moduleSymbol),
				);
				return getMergedSymbol(exported) || moduleSymbol;
			}
			return undefined;
		}
		function getCommonJsExportEquals(exported, moduleSymbol) {
			if (
				!exported || exported === unknownSymbol || exported === moduleSymbol || moduleSymbol.exports.size === 1 || exported.flags & SymbolFlags.Alias
			) {
				return exported;
			}
			var links = getSymbolLinks(exported);
			if (links.cjsExportMerged) {
				return links.cjsExportMerged;
			}
			var merged = exported.flags & SymbolFlags.Transient ? exported : cloneSymbol(
				exported,
			);
			merged.flags = merged.flags | SymbolFlags.ValueModule;
			if (merged.exports === undefined) {
				merged.exports = createSymbolTable();
			}
			moduleSymbol.exports.forEach(
				function (s, name) {
					if (name === InternalSymbolName.ExportEquals) return;
					merged.exports.set(
						name,
						merged.exports.has(name) ? mergeSymbol(merged.exports.get(name), s) : s,
					);
				},
			);
			getSymbolLinks(merged).cjsExportMerged = merged;
			return links.cjsExportMerged = merged;
		}
		// An external module with an 'export =' declaration may be referenced as an ES6 module provided the 'export ='
		// references a symbol that is at least declared as a module or a variable. The target of the 'export =' may
		// combine other declarations with the module or variable (e.g. a class/module, function/module, interface/variable).
		function resolveESModuleSymbol(
			moduleSymbol,
			referencingLocation,
			dontResolveAlias,
			suppressInteropError,
		) {
			var symbol = resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias);
			if (!dontResolveAlias && symbol) {
				if (
					!suppressInteropError && !(symbol.flags & (SymbolFlags.Module | SymbolFlags.Variable)) && !getDeclarationOfKind(
						symbol,
						SyntaxKind.SourceFile,
					)
				) {
					var compilerOptionName = moduleKind >= ModuleKind.ES2015 ? "allowSyntheticDefaultImports" : "esModuleInterop";
					error(
						referencingLocation,
						Diagnostics.This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_referencing_its_default_export,
						compilerOptionName,
					);
					return symbol;
				}
				var referenceParent = referencingLocation.parent;
				if (
					(isImportDeclaration(referenceParent) && getNamespaceDeclarationNode(
						referenceParent,
					)) || isImportCall(referenceParent)
				) {
					var reference = isImportCall(referenceParent) ? referenceParent.arguments[0] : referenceParent.moduleSpecifier;
					var type = getTypeOfSymbol(symbol);
					var defaultOnlyType = getTypeWithSyntheticDefaultOnly(
						type,
						symbol,
						moduleSymbol,
						reference,
					);
					if (defaultOnlyType) {
						return cloneTypeAsModuleType(
							symbol,
							defaultOnlyType,
							referenceParent,
						);
					}
					if (getESModuleInterop(compilerOptions)) {
						var sigs = getSignaturesOfStructuredType(type, SignatureKind.Call);
						if (!sigs || !sigs.length) {
							sigs = getSignaturesOfStructuredType(
								type,
								SignatureKind.Construct,
							);
						}
						if (
							(sigs && sigs.length) || getPropertyOfType(
								type,
								InternalSymbolName.Default, /*skipObjectFunctionPropertyAugment*/
								true,
							)
						) {
							var moduleType = getTypeWithSyntheticDefaultImportType(
								type,
								symbol,
								moduleSymbol,
								reference,
							);
							return cloneTypeAsModuleType(symbol, moduleType, referenceParent);
						}
					}
				}
			}
			return symbol;
		}
		/**
         * Create a new symbol which has the module's type less the call and construct signatures
         */
		function cloneTypeAsModuleType(symbol, moduleType, referenceParent) {
			var result = createSymbol(symbol.flags, symbol.escapedName);
			result.declarations = symbol.declarations ? symbol.declarations.slice() : [];
			result.parent = symbol.parent;
			result.target = symbol;
			result.originatingImport = referenceParent;
			if (symbol.valueDeclaration) result.valueDeclaration = symbol.valueDeclaration;
			if (symbol.constEnumOnlyModule) result.constEnumOnlyModule = true;
			if (symbol.members) result.members = new Map(symbol.members);
			if (symbol.exports) result.exports = new Map(symbol.exports);
			var resolvedModuleType = resolveStructuredTypeMembers(moduleType); // Should already be resolved from the signature checks above
			result.type = createAnonymousType(
				result,
				resolvedModuleType.members,
				emptyArray,
				emptyArray,
				resolvedModuleType.indexInfos,
			);
			return result;
		}
		function hasExportAssignmentSymbol(moduleSymbol) {
			return moduleSymbol.exports.get(InternalSymbolName.ExportEquals) !== undefined;
		}
		function getExportsOfModuleAsArray(moduleSymbol) {
			return symbolsToArray(getExportsOfModule(moduleSymbol));
		}
		function getExportsAndPropertiesOfModule(moduleSymbol) {
			var exports = getExportsOfModuleAsArray(moduleSymbol);
			var exportEquals = resolveExternalModuleSymbol(moduleSymbol);
			if (exportEquals !== moduleSymbol) {
				var type = getTypeOfSymbol(exportEquals);
				if (shouldTreatPropertiesOfExternalModuleAsExports(type)) {
					addRange(exports, getPropertiesOfType(type));
				}
			}
			return exports;
		}
		function forEachExportAndPropertyOfModule(moduleSymbol, cb) {
			var exports = getExportsOfModule(moduleSymbol);
			exports.forEach(
				function (symbol, key) {
					if (!isReservedMemberName(key)) {
						cb(symbol, key);
					}
				},
			);
			var exportEquals = resolveExternalModuleSymbol(moduleSymbol);
			if (exportEquals !== moduleSymbol) {
				var type = getTypeOfSymbol(exportEquals);
				if (shouldTreatPropertiesOfExternalModuleAsExports(type)) {
					forEachPropertyOfType(
						type,
						function (symbol, escapedName) {
							cb(symbol, escapedName);
						},
					);
				}
			}
		}
		function tryGetMemberInModuleExports(memberName, moduleSymbol) {
			var symbolTable = getExportsOfModule(moduleSymbol);
			if (symbolTable) {
				return symbolTable.get(memberName);
			}
		}
		function tryGetMemberInModuleExportsAndProperties(memberName, moduleSymbol) {
			var symbol = tryGetMemberInModuleExports(memberName, moduleSymbol);
			if (symbol) {
				return symbol;
			}
			var exportEquals = resolveExternalModuleSymbol(moduleSymbol);
			if (exportEquals === moduleSymbol) {
				return undefined;
			}
			var type = getTypeOfSymbol(exportEquals);
			return shouldTreatPropertiesOfExternalModuleAsExports(type) ? getPropertyOfType(
				type,
				memberName,
			) : undefined;
		}
		function shouldTreatPropertiesOfExternalModuleAsExports(
			resolvedExternalModuleType,
		) {
			return !(resolvedExternalModuleType.flags & TypeFlags.Primitive || getObjectFlags(
				resolvedExternalModuleType,
			) & ObjectFlags.Class || isArrayType(resolvedExternalModuleType) || isTupleType(
				resolvedExternalModuleType, // `isArrayOrTupleLikeType` is too expensive to use in this auto-imports hot path
			));
		}
		function getExportsOfSymbol(symbol) {
			return symbol.flags & SymbolFlags.LateBindingContainer ? getResolvedMembersOrExportsOfSymbol(
				symbol,
				"resolvedExports", /* resolvedExports */
			) : symbol.flags & SymbolFlags.Module ? getExportsOfModule(symbol) : symbol.exports || emptySymbols;
		}
		function getExportsOfModule(moduleSymbol) {
			var links = getSymbolLinks(moduleSymbol);
			return links.resolvedExports || (links.resolvedExports = getExportsOfModuleWorker(
				moduleSymbol,
			));
		}
		/**
         * Extends one symbol table with another while collecting information on name collisions for error message generation into the `lookupTable` argument
         * Not passing `lookupTable` and `exportNode` disables this collection, and just extends the tables
         */
		function extendExportSymbols(target, source, lookupTable, exportNode) {
			if (!source) return;
			source.forEach(
				function (sourceSymbol, id) {
					if (id === InternalSymbolName.Default) return;
					var targetSymbol = target.get(id);
					if (!targetSymbol) {
						target.set(id, sourceSymbol);
						if (lookupTable && exportNode) {
							lookupTable.set(
								id,
								{ specifierText: getTextOfNode(exportNode.moduleSpecifier) },
							);
						}
					} else if (
						lookupTable && exportNode && targetSymbol && resolveSymbol(
							targetSymbol,
						) !== resolveSymbol(sourceSymbol)
					) {
						var collisionTracker = lookupTable.get(id);
						if (!collisionTracker.exportsWithDuplicate) {
							collisionTracker.exportsWithDuplicate = [exportNode];
						} else {
							collisionTracker.exportsWithDuplicate.push(exportNode);
						}
					}
				},
			);
		}
		function getExportsOfModuleWorker(moduleSymbol) {
			var visitedSymbols = [];
			// A module defined by an 'export=' consists of one export that needs to be resolved
			moduleSymbol = resolveExternalModuleSymbol(moduleSymbol);
			return visit(moduleSymbol) || emptySymbols;
			// The ES6 spec permits export * declarations in a module to circularly reference the module itself. For example,
			// module 'a' can 'export * from "b"' and 'b' can 'export * from "a"' without error.
			function visit(symbol) {
				if (!(symbol && symbol.exports && pushIfUnique(visitedSymbols, symbol))) {
					return;
				}
				var symbols = new Map(symbol.exports);
				// All export * declarations are collected in an __export symbol by the binder
				var exportStars = symbol.exports.get(InternalSymbolName.ExportStar);
				if (exportStars) {
					var nestedSymbols = createSymbolTable();
					var lookupTable_1 = new Map();
					if (exportStars.declarations) {
						for (var _i = 0, _a = exportStars.declarations; _i < _a.length; _i++) {
							var node = _a[_i];
							var resolvedModule = resolveExternalModuleName(
								node,
								node.moduleSpecifier,
							);
							var exportedSymbols = visit(resolvedModule);
							extendExportSymbols(
								nestedSymbols,
								exportedSymbols,
								lookupTable_1,
								node,
							);
						}
					}
					lookupTable_1.forEach(
						function (_a, id) {
							var exportsWithDuplicate = _a.exportsWithDuplicate;
							// It's not an error if the file with multiple `export *`s with duplicate names exports a member with that name itself
							if (
								id === "export=" || !(exportsWithDuplicate && exportsWithDuplicate.length) || symbols.has(
									id,
								)
							) {
								return;
							}
							for (
								var _i = 0, exportsWithDuplicate_1 = exportsWithDuplicate;
								_i < exportsWithDuplicate_1.length;
								_i++
							) {
								var node = exportsWithDuplicate_1[_i];
								diagnostics.add(
									createDiagnosticForNode(
										node,
										Diagnostics.Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity,
										lookupTable_1.get(id).specifierText,
										unescapeLeadingUnderscores(id),
									),
								);
							}
						},
					);
					extendExportSymbols(symbols, nestedSymbols);
				}
				return symbols;
			}
		}
		function getMergedSymbol(symbol) {
			var merged;
			return symbol && symbol.mergeId && (merged = mergedSymbols[symbol.mergeId]) ? merged : symbol;
		}
		function getSymbolOfNode(node) {
			return getMergedSymbol(node.symbol && getLateBoundSymbol(node.symbol));
		}
		function getParentOfSymbol(symbol) {
			return getMergedSymbol(symbol.parent && getLateBoundSymbol(symbol.parent));
		}
		function getAlternativeContainingModules(symbol, enclosingDeclaration) {
			var containingFile = getSourceFileOfNode(enclosingDeclaration);
			var id = getNodeId(containingFile);
			var links = getSymbolLinks(symbol);
			var results;
			if (
				links.extendedContainersByFile && (results = links.extendedContainersByFile.get(
					id,
				))
			) {
				return results;
			}
			if (containingFile && containingFile.imports) {
				// Try to make an import using an import already in the enclosing file, if possible
				for (var _i = 0, _a = containingFile.imports; _i < _a.length; _i++) {
					var importRef = _a[_i];
					if (nodeIsSynthesized(importRef)) continue; // Synthetic names can't be resolved by `resolveExternalModuleName` - they'll cause a debug assert if they error
					var resolvedModule = resolveExternalModuleName(
						enclosingDeclaration,
						importRef, /*ignoreErrors*/
						true,
					);
					if (!resolvedModule) continue;
					var ref = getAliasForSymbolInContainer(resolvedModule, symbol);
					if (!ref) continue;
					results = append(results, resolvedModule);
				}
				if (length(results)) {
					(links.extendedContainersByFile || (links.extendedContainersByFile = new Map())).set(
						id,
						results,
					);
					return results;
				}
			}
			if (links.extendedContainers) {
				return links.extendedContainers;
			}
			// No results from files already being imported by this file - expand search (expensive, but not location-specific, so cached)
			var otherFiles = host.getSourceFiles();
			for (var _b = 0, otherFiles_1 = otherFiles; _b < otherFiles_1.length; _b++) {
				var file = otherFiles_1[_b];
				if (!isExternalModule(file)) continue;
				var sym = getSymbolOfNode(file);
				var ref = getAliasForSymbolInContainer(sym, symbol);
				if (!ref) continue;
				results = append(results, sym);
			}
			return links.extendedContainers = results || emptyArray;
		}
		/**
         * Attempts to find the symbol corresponding to the container a symbol is in - usually this
         * is just its' `.parent`, but for locals, this value is `undefined`
         */
		function getContainersOfSymbol(symbol, enclosingDeclaration, meaning) {
			var container = getParentOfSymbol(symbol);
			// Type parameters end up in the `members` lists but are not externally visible
			if (container && !(symbol.flags & SymbolFlags.TypeParameter)) {
				var additionalContainers = mapDefined(
					container.declarations,
					fileSymbolIfFileSymbolExportEqualsContainer,
				);
				var reexportContainers = enclosingDeclaration && getAlternativeContainingModules(
					symbol,
					enclosingDeclaration,
				);
				var objectLiteralContainer = getVariableDeclarationOfObjectLiteral(
					container,
					meaning,
				);
				if (
					enclosingDeclaration && container.flags & getQualifiedLeftMeaning(
						meaning,
					) && getAccessibleSymbolChain(
						container,
						enclosingDeclaration,
						SymbolFlags.Namespace, /*externalOnly*/
						false,
					)
				) {
					return append(
						concatenate(
							concatenate([container], additionalContainers),
							reexportContainers,
						),
						objectLiteralContainer,
					); // This order expresses a preference for the real container if it is in scope
				}
				// we potentially have a symbol which is a member of the instance side of something - look for a variable in scope with the container's type
				// which may be acting like a namespace (eg, `Symbol` acts like a namespace when looking up `Symbol.toStringTag`)
				var firstVariableMatch = !(container.flags & getQualifiedLeftMeaning(
					meaning,
				)) && container.flags & SymbolFlags.Type && getDeclaredTypeOfSymbol(
					container,
				).flags & TypeFlags.Object && meaning === SymbolFlags.Value ? forEachSymbolTableInScope(
					enclosingDeclaration,
					function (t) {
						return forEachEntry(
							t,
							function (s) {
								if (
									s.flags & getQualifiedLeftMeaning(meaning) && getTypeOfSymbol(
										s,
									) === getDeclaredTypeOfSymbol(container)
								) {
									return s;
								}
							},
						);
					},
				) : undefined;
				var res = firstVariableMatch ? __spreadArray(
					__spreadArray([firstVariableMatch], additionalContainers, true),
					[container],
					false,
				) : __spreadArray(
					__spreadArray([], additionalContainers, true),
					[container],
					false,
				);
				res = append(res, objectLiteralContainer);
				res = addRange(res, reexportContainers);
				return res;
			}
			var candidates = mapDefined(
				symbol.declarations,
				function (d) {
					if (
						!isAmbientModule(d) && d.parent && hasNonGlobalAugmentationExternalModuleSymbol(
							d.parent,
						)
					) {
						return getSymbolOfNode(d.parent);
					}
					if (
						isClassExpression(d) && isBinaryExpression(d.parent) && d.parent.operatorToken.kind === SyntaxKind.EqualsToken && isAccessExpression(
							d.parent.left,
						) && isEntityNameExpression(d.parent.left.expression)
					) {
						if (
							isModuleExportsAccessExpression(d.parent.left) || isExportsIdentifier(
								d.parent.left.expression,
							)
						) {
							return getSymbolOfNode(getSourceFileOfNode(d));
						}
						checkExpressionCached(d.parent.left.expression);
						return getNodeLinks(d.parent.left.expression).resolvedSymbol;
					}
				},
			);
			if (!length(candidates)) {
				return undefined;
			}
			return mapDefined(
				candidates,
				function (candidate) {
					return getAliasForSymbolInContainer(candidate, symbol) ? candidate : undefined;
				},
			);
			function fileSymbolIfFileSymbolExportEqualsContainer(d) {
				return container && getFileSymbolIfFileSymbolExportEqualsContainer(
					d,
					container,
				);
			}
		}
		function getVariableDeclarationOfObjectLiteral(symbol, meaning) {
			// If we're trying to reference some object literal in, eg `var a = { x: 1 }`, the symbol for the literal, `__object`, is distinct
			// from the symbol of the declaration it is being assigned to. Since we can use the declaration to refer to the literal, however,
			// we'd like to make that connection here - potentially causing us to paint the declaration's visibility, and therefore the literal.
			var firstDecl = !!length(symbol.declarations) && first(
				symbol.declarations,
			);
			if (
				meaning & SymbolFlags.Value && firstDecl && firstDecl.parent && isVariableDeclaration(
					firstDecl.parent,
				)
			) {
				if (
					isObjectLiteralExpression(firstDecl) && firstDecl === firstDecl.parent.initializer || isTypeLiteralNode(
						firstDecl,
					) && firstDecl === firstDecl.parent.type
				) {
					return getSymbolOfNode(firstDecl.parent);
				}
			}
		}
		function getFileSymbolIfFileSymbolExportEqualsContainer(d, container) {
			var fileSymbol = getExternalModuleContainer(d);
			var exported = fileSymbol && fileSymbol.exports && fileSymbol.exports.get(
				InternalSymbolName.ExportEquals,
			);
			return exported && getSymbolIfSameReference(exported, container) ? fileSymbol : undefined;
		}
		function getAliasForSymbolInContainer(container, symbol) {
			if (container === getParentOfSymbol(symbol)) {
				// fast path, `symbol` is either already the alias or isn't aliased
				return symbol;
			}
			// Check if container is a thing with an `export=` which points directly at `symbol`, and if so, return
			// the container itself as the alias for the symbol
			var exportEquals = container.exports && container.exports.get(
				InternalSymbolName.ExportEquals,
			);
			if (exportEquals && getSymbolIfSameReference(exportEquals, symbol)) {
				return container;
			}
			var exports = getExportsOfSymbol(container);
			var quick = exports.get(symbol.escapedName);
			if (quick && getSymbolIfSameReference(quick, symbol)) {
				return quick;
			}
			return forEachEntry(
				exports,
				function (exported) {
					if (getSymbolIfSameReference(exported, symbol)) {
						return exported;
					}
				},
			);
		}
		/**
         * Checks if two symbols, through aliasing and/or merging, refer to the same thing
         */
		function getSymbolIfSameReference(s1, s2) {
			if (
				getMergedSymbol(resolveSymbol(getMergedSymbol(s1))) === getMergedSymbol(
					resolveSymbol(getMergedSymbol(s2)),
				)
			) {
				return s1;
			}
		}
		function getExportSymbolOfValueSymbolIfExported(symbol) {
			return getMergedSymbol(
				symbol && (symbol.flags & SymbolFlags.ExportValue) !== 0 ? symbol.exportSymbol : symbol,
			);
		}
		function symbolIsValue(symbol) {
			return !!(symbol.flags & SymbolFlags.Value || symbol.flags & SymbolFlags.Alias && resolveAlias(
				symbol,
			).flags & SymbolFlags.Value && !getTypeOnlyAliasDeclaration(symbol));
		}
		function findConstructorDeclaration(node) {
			var members = node.members;
			for (var _i = 0, members_1 = members; _i < members_1.length; _i++) {
				var member = members_1[_i];
				if (
					member.kind === SyntaxKind.Constructor && nodeIsPresent(member.body)
				) {
					return member;
				}
			}
		}
		function createType(flags) {
			var result = new Type(checker, flags);
			typeCount++;
			result.id = typeCount;
			if (produceDiagnostics) {
				tracing === null || tracing === void 0 ? void 0 : tracing.recordType(
					result, // Only record types from one checker
				);
			}
			return result;
		}
		function createOriginType(flags) {
			return new Type(checker, flags);
		}
		function createIntrinsicType(kind, intrinsicName, objectFlags) {
			if (objectFlags === void 0) {
				objectFlags = 0;
			}
			var type = createType(kind);
			type.intrinsicName = intrinsicName;
			type.objectFlags = objectFlags;
			return type;
		}
		function createObjectType(objectFlags, symbol) {
			var type = createType(TypeFlags.Object);
			type.objectFlags = objectFlags;
			type.symbol = symbol;
			type.members = undefined;
			type.properties = undefined;
			type.callSignatures = undefined;
			type.constructSignatures = undefined;
			type.indexInfos = undefined;
			return type;
		}
		function createTypeofType() {
			return getUnionType(arrayFrom(typeofEQFacts.keys(), getStringLiteralType));
		}
		function createTypeParameter(symbol) {
			var type = createType(TypeFlags.TypeParameter);
			if (symbol) type.symbol = symbol;
			return type;
		}
		// A reserved member name starts with two underscores, but the third character cannot be an underscore,
		// @, or #. A third underscore indicates an escaped form of an identifier that started
		// with at least two underscores. The @ character indicates that the name is denoted by a well known ES
		// Symbol instance and the # character indicates that the name is a PrivateIdentifier.
		function isReservedMemberName(name) {
			return name.charCodeAt(0) === CharacterCodes._ && name.charCodeAt(1) === CharacterCodes._ && name.charCodeAt(
				2,
			) !== CharacterCodes._ && name.charCodeAt(2) !== CharacterCodes.at && name.charCodeAt(
				2,
			) !== CharacterCodes.hash;
		}
		function getNamedMembers(members) {
			var result;
			members.forEach(
				function (symbol, id) {
					if (isNamedMember(symbol, id)) {
						(result || (result = [])).push(symbol);
					}
				},
			);
			return result || emptyArray;
		}
		function isNamedMember(member, escapedName) {
			return !isReservedMemberName(escapedName) && symbolIsValue(member);
		}
		function getNamedOrIndexSignatureMembers(members) {
			var result = getNamedMembers(members);
			var index = getIndexSymbolFromSymbolTable(members);
			return index ? concatenate(result, [index]) : result;
		}
		function setStructuredTypeMembers(
			type,
			members,
			callSignatures,
			constructSignatures,
			indexInfos,
		) {
			var resolved = type;
			resolved.members = members;
			resolved.properties = emptyArray;
			resolved.callSignatures = callSignatures;
			resolved.constructSignatures = constructSignatures;
			resolved.indexInfos = indexInfos;
			// This can loop back to getPropertyOfType() which would crash if `callSignatures` & `constructSignatures` are not initialized.
			if (members !== emptySymbols) resolved.properties = getNamedMembers(
				members,
			);
			return resolved;
		}
		function createAnonymousType(
			symbol,
			members,
			callSignatures,
			constructSignatures,
			indexInfos,
		) {
			return setStructuredTypeMembers(
				createObjectType(ObjectFlags.Anonymous, symbol),
				members,
				callSignatures,
				constructSignatures,
				indexInfos,
			);
		}
		function getResolvedTypeWithoutAbstractConstructSignatures(type) {
			if (type.constructSignatures.length === 0) return type;
			if (type.objectTypeWithoutAbstractConstructSignatures) return type.objectTypeWithoutAbstractConstructSignatures;
			var constructSignatures = filter(
				type.constructSignatures,
				function (signature) {
					return !(signature.flags & SignatureFlags.Abstract);
				},
			);
			if (type.constructSignatures === constructSignatures) return type;
			var typeCopy = createAnonymousType(
				type.symbol,
				type.members,
				type.callSignatures,
				some(constructSignatures) ? constructSignatures : emptyArray,
				type.indexInfos,
			);
			type.objectTypeWithoutAbstractConstructSignatures = typeCopy;
			typeCopy.objectTypeWithoutAbstractConstructSignatures = typeCopy;
			return typeCopy;
		}
		function forEachSymbolTableInScope(enclosingDeclaration, callback) {
			var result;
			var _loop_2 = function (location_1) {
				// Locals of a source file are not in scope (because they get merged into the global symbol table)
				if (location_1.locals && !isGlobalSourceFile(location_1)) {
					if (
						result = callback(
							location_1.locals, /*ignoreQualification*/
							undefined, /*isLocalNameLookup*/
							true,
							location_1,
						)
					) {
						return { value: result };
					}
				}
				switch (location_1.kind) {
					case SyntaxKind.SourceFile:
						if (!isExternalOrCommonJsModule(location_1)) {
							break;
						}
					// falls through
					case SyntaxKind.ModuleDeclaration:
						var sym = getSymbolOfNode(location_1);
						// `sym` may not have exports if this module declaration is backed by the symbol for a `const` that's being rewritten
						// into a namespace - in such cases, it's best to just let the namespace appear empty (the const members couldn't have referred
						// to one another anyway)
						if (
							result = callback(
								(sym === null || sym === void 0 ? void 0 : sym.exports) || emptySymbols, /*ignoreQualification*/
								undefined, /*isLocalNameLookup*/
								true,
								location_1,
							)
						) {
							return { value: result };
						}
						break;
					case SyntaxKind.ClassDeclaration:
					case SyntaxKind.ClassExpression:
					case SyntaxKind.InterfaceDeclaration:
						// Type parameters are bound into `members` lists so they can merge across declarations
						// This is troublesome, since in all other respects, they behave like locals :cries:
						// TODO: the below is shared with similar code in `resolveName` - in fact, rephrasing all this symbol
						// lookup logic in terms of `resolveName` would be nice
						// The below is used to lookup type parameters within a class or interface, as they are added to the class/interface locals
						// These can never be latebound, so the symbol's raw members are sufficient. `getMembersOfNode` cannot be used, as it would
						// trigger resolving late-bound names, which we may already be in the process of doing while we're here!
						var table_1;
						// TODO: Should this filtered table be cached in some way?
						(getSymbolOfNode(location_1).members || emptySymbols).forEach(
							function (memberSymbol, key) {
								if (
									memberSymbol.flags & (SymbolFlags.Type & ~SymbolFlags.Assignment)
								) {
									(table_1 || (table_1 = createSymbolTable())).set(
										key,
										memberSymbol,
									);
								}
							},
						);
						if (
							table_1 && (result = callback(
								table_1, /*ignoreQualification*/
								undefined, /*isLocalNameLookup*/
								false,
								location_1,
							))
						) {
							return { value: result };
						}
						break;
				}
			};
			for (
				var location_1 = enclosingDeclaration;
				location_1;
				location_1 = location_1.parent
			) {
				var state_1 = _loop_2(location_1);
				if (typeof state_1 === "object") return state_1.value;
			}
			return callback(
				globals, /*ignoreQualification*/
				undefined, /*isLocalNameLookup*/
				true,
			);
		}
		function getQualifiedLeftMeaning(rightMeaning) {
			// If we are looking in value space, the parent meaning is value, other wise it is namespace
			return rightMeaning === SymbolFlags.Value ? SymbolFlags.Value : SymbolFlags.Namespace;
		}
		function getAccessibleSymbolChain(
			symbol,
			enclosingDeclaration,
			meaning,
			useOnlyExternalAliasing,
			visitedSymbolTablesMap,
		) {
			if (visitedSymbolTablesMap === void 0) {
				visitedSymbolTablesMap = new Map();
			}
			if (!(symbol && !isPropertyOrMethodDeclarationSymbol(symbol))) {
				return undefined;
			}
			var links = getSymbolLinks(symbol);
			var cache = (links.accessibleChainCache || (links.accessibleChainCache = new Map()));
			// Go from enclosingDeclaration to the first scope we check, so the cache is keyed off the scope and thus shared more
			var firstRelevantLocation = forEachSymbolTableInScope(
				enclosingDeclaration,
				function (_, __, ___, node) {
					return node;
				},
			);
			var key = "".concat(useOnlyExternalAliasing ? 0 : 1, "|").concat(
				firstRelevantLocation && getNodeId(firstRelevantLocation),
				"|",
			).concat(meaning);
			if (cache.has(key)) {
				return cache.get(key);
			}
			var id = getSymbolId(symbol);
			var visitedSymbolTables = visitedSymbolTablesMap.get(id);
			if (!visitedSymbolTables) {
				visitedSymbolTablesMap.set(id, visitedSymbolTables = []);
			}
			var result = forEachSymbolTableInScope(
				enclosingDeclaration,
				getAccessibleSymbolChainFromSymbolTable,
			);
			cache.set(key, result);
			return result;
			/**
             * @param {ignoreQualification} boolean Set when a symbol is being looked for through the exports of another symbol (meaning we have a route to qualify it already)
             */
			function getAccessibleSymbolChainFromSymbolTable(
				symbols,
				ignoreQualification,
				isLocalNameLookup,
			) {
				if (!pushIfUnique(visitedSymbolTables, symbols)) {
					return undefined;
				}
				var result = trySymbolTable(
					symbols,
					ignoreQualification,
					isLocalNameLookup,
				);
				visitedSymbolTables.pop();
				return result;
			}
			function canQualifySymbol(symbolFromSymbolTable, meaning) {
				// If the symbol is equivalent and doesn't need further qualification, this symbol is accessible
				return !needsQualification(
					symbolFromSymbolTable,
					enclosingDeclaration,
					meaning,
				) || !!getAccessibleSymbolChain(
					symbolFromSymbolTable.parent, // If symbol needs qualification, make sure that parent is accessible, if it is then this symbol is accessible too
					enclosingDeclaration,
					getQualifiedLeftMeaning(meaning),
					useOnlyExternalAliasing,
					visitedSymbolTablesMap,
				);
			}
			function isAccessible(
				symbolFromSymbolTable,
				resolvedAliasSymbol,
				ignoreQualification,
			) {
				return (symbol === (resolvedAliasSymbol || symbolFromSymbolTable) || getMergedSymbol(
					symbol,
				) === getMergedSymbol(resolvedAliasSymbol || symbolFromSymbolTable)) && // check the symbol can be qualified, it is only then this symbol is accessible // and if symbolFromSymbolTable or alias resolution matches the symbol, // if the symbolFromSymbolTable is not external module (it could be if it was determined as ambient external module and would be in globals table)
				!some(
					symbolFromSymbolTable.declarations,
					hasNonGlobalAugmentationExternalModuleSymbol,
				) && (ignoreQualification || canQualifySymbol(
					getMergedSymbol(symbolFromSymbolTable),
					meaning,
				));
			}
			function trySymbolTable(symbols, ignoreQualification, isLocalNameLookup) {
				// If symbol is directly available by its name in the symbol table
				if (
					isAccessible(
						symbols.get(symbol.escapedName), /*resolvedAliasSymbol*/
						undefined,
						ignoreQualification,
					)
				) {
					return [symbol];
				}
				// Check if symbol is any of the aliases in scope
				var result = forEachEntry(
					symbols,
					function (symbolFromSymbolTable) {
						if (
							symbolFromSymbolTable.flags & SymbolFlags.Alias && symbolFromSymbolTable.escapedName !== InternalSymbolName.ExportEquals && symbolFromSymbolTable.escapedName !== InternalSymbolName.Default && !(isUMDExportSymbol(
								symbolFromSymbolTable,
							) && enclosingDeclaration && isExternalModule(
								getSourceFileOfNode(enclosingDeclaration),
							)) && (!useOnlyExternalAliasing || some(
								symbolFromSymbolTable.declarations, // If `!useOnlyExternalAliasing`, we can use any type of alias to get the name
								isExternalModuleImportEqualsDeclaration,
							)) && (isLocalNameLookup ? !some(
								symbolFromSymbolTable.declarations, // If we're looking up a local name to reference directly, omit namespace reexports, otherwise when we're trawling through an export list to make a dotted name, we can keep it
								isNamespaceReexportDeclaration,
							) : true) && (ignoreQualification || !getDeclarationOfKind( // See similar comment in `resolveName` for details // While exports are generally considered to be in scope, export-specifier declared symbols are _not_
								symbolFromSymbolTable,
								SyntaxKind.ExportSpecifier,
							))
						) {
							var resolvedImportedSymbol = resolveAlias(symbolFromSymbolTable);
							var candidate = getCandidateListForSymbol(
								symbolFromSymbolTable,
								resolvedImportedSymbol,
								ignoreQualification,
							);
							if (candidate) {
								return candidate;
							}
						}
						if (
							symbolFromSymbolTable.escapedName === symbol.escapedName && symbolFromSymbolTable.exportSymbol
						) {
							if (
								isAccessible(
									getMergedSymbol(symbolFromSymbolTable.exportSymbol), /*aliasSymbol*/
									undefined,
									ignoreQualification,
								)
							) {
								return [symbol];
							}
						}
					},
				);
				// If there's no result and we're looking at the global symbol table, treat `globalThis` like an alias and try to lookup thru that
				return result || (symbols === globals ? getCandidateListForSymbol(
					globalThisSymbol,
					globalThisSymbol,
					ignoreQualification,
				) : undefined);
			}
			function getCandidateListForSymbol(
				symbolFromSymbolTable,
				resolvedImportedSymbol,
				ignoreQualification,
			) {
				if (
					isAccessible(
						symbolFromSymbolTable,
						resolvedImportedSymbol,
						ignoreQualification,
					)
				) {
					return [symbolFromSymbolTable];
				}
				// Look in the exported members, if we can find accessibleSymbolChain, symbol is accessible using this chain
				// but only if the symbolFromSymbolTable can be qualified
				var candidateTable = getExportsOfSymbol(resolvedImportedSymbol);
				var accessibleSymbolsFromExports = candidateTable && getAccessibleSymbolChainFromSymbolTable(
					candidateTable, /*ignoreQualification*/
					true,
				);
				if (
					accessibleSymbolsFromExports && canQualifySymbol(
						symbolFromSymbolTable,
						getQualifiedLeftMeaning(meaning),
					)
				) {
					return [symbolFromSymbolTable].concat(accessibleSymbolsFromExports);
				}
			}
		}
		function needsQualification(symbol, enclosingDeclaration, meaning) {
			var qualify = false;
			forEachSymbolTableInScope(
				enclosingDeclaration,
				function (symbolTable) {
					// If symbol of this name is not available in the symbol table we are ok
					var symbolFromSymbolTable = getMergedSymbol(
						symbolTable.get(symbol.escapedName),
					);
					if (!symbolFromSymbolTable) {
						// Continue to the next symbol table
						return false;
					}
					// If the symbol with this name is present it should refer to the symbol
					if (symbolFromSymbolTable === symbol) {
						// No need to qualify
						return true;
					}
					// Qualify if the symbol from symbol table has same meaning as expected
					symbolFromSymbolTable = (symbolFromSymbolTable.flags & SymbolFlags.Alias && !getDeclarationOfKind(
						symbolFromSymbolTable,
						SyntaxKind.ExportSpecifier,
					)) ? resolveAlias(symbolFromSymbolTable) : symbolFromSymbolTable;
					if (symbolFromSymbolTable.flags & meaning) {
						qualify = true;
						return true;
					}
					// Continue to the next symbol table
					return false;
				},
			);
			return qualify;
		}
		function isPropertyOrMethodDeclarationSymbol(symbol) {
			if (symbol.declarations && symbol.declarations.length) {
				for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
					var declaration = _a[_i];
					switch (declaration.kind) {
						case SyntaxKind.PropertyDeclaration:
						case SyntaxKind.MethodDeclaration:
						case SyntaxKind.GetAccessor:
						case SyntaxKind.SetAccessor:
							continue;
						default:
							return false;
					}
				}
				return true;
			}
			return false;
		}
		function isTypeSymbolAccessible(typeSymbol, enclosingDeclaration) {
			var access = isSymbolAccessibleWorker(
				typeSymbol,
				enclosingDeclaration,
				SymbolFlags.Type, /*shouldComputeAliasesToMakeVisible*/
				false, /*allowModules*/
				true,
			);
			return access.accessibility === SymbolAccessibility.Accessible;
		}
		function isValueSymbolAccessible(typeSymbol, enclosingDeclaration) {
			var access = isSymbolAccessibleWorker(
				typeSymbol,
				enclosingDeclaration,
				SymbolFlags.Value, /*shouldComputeAliasesToMakeVisible*/
				false, /*allowModules*/
				true,
			);
			return access.accessibility === SymbolAccessibility.Accessible;
		}
		function isSymbolAccessibleByFlags(typeSymbol, enclosingDeclaration, flags) {
			var access = isSymbolAccessibleWorker(
				typeSymbol,
				enclosingDeclaration,
				flags, /*shouldComputeAliasesToMakeVisible*/
				false, /*allowModules*/
				false,
			);
			return access.accessibility === SymbolAccessibility.Accessible;
		}
		function isAnySymbolAccessible(
			symbols,
			enclosingDeclaration,
			initialSymbol,
			meaning,
			shouldComputeAliasesToMakeVisible,
			allowModules,
		) {
			if (!length(symbols)) return;
			var hadAccessibleChain;
			var earlyModuleBail = false;
			for (var _i = 0, _a = symbols; _i < _a.length; _i++) {
				var symbol = _a[_i];
				// Symbol is accessible if it by itself is accessible
				var accessibleSymbolChain = getAccessibleSymbolChain(
					symbol,
					enclosingDeclaration,
					meaning, /*useOnlyExternalAliasing*/
					false,
				);
				if (accessibleSymbolChain) {
					hadAccessibleChain = symbol;
					var hasAccessibleDeclarations = hasVisibleDeclarations(
						accessibleSymbolChain[0],
						shouldComputeAliasesToMakeVisible,
					);
					if (hasAccessibleDeclarations) {
						return hasAccessibleDeclarations;
					}
				}
				if (allowModules) {
					if (
						some(
							symbol.declarations,
							hasNonGlobalAugmentationExternalModuleSymbol,
						)
					) {
						if (shouldComputeAliasesToMakeVisible) {
							earlyModuleBail = true;
							// Generally speaking, we want to use the aliases that already exist to refer to a module, if present
							// In order to do so, we need to find those aliases in order to retain them in declaration emit; so
							// if we are in declaration emit, we cannot use the fast path for module visibility until we've exhausted
							// all other visibility options (in order to capture the possible aliases used to reference the module)
							continue;
						}
						// Any meaning of a module symbol is always accessible via an `import` type
						return { accessibility: SymbolAccessibility.Accessible };
					}
				}
				// If we haven't got the accessible symbol, it doesn't mean the symbol is actually inaccessible.
				// It could be a qualified symbol and hence verify the path
				// e.g.:
				// module m {
				//     export class c {
				//     }
				// }
				// const x: typeof m.c
				// In the above example when we start with checking if typeof m.c symbol is accessible,
				// we are going to see if c can be accessed in scope directly.
				// But it can't, hence the accessible is going to be undefined, but that doesn't mean m.c is inaccessible
				// It is accessible if the parent m is accessible because then m.c can be accessed through qualification
				var containers = getContainersOfSymbol(
					symbol,
					enclosingDeclaration,
					meaning,
				);
				var parentResult = isAnySymbolAccessible(
					containers,
					enclosingDeclaration,
					initialSymbol,
					initialSymbol === symbol ? getQualifiedLeftMeaning(meaning) : meaning,
					shouldComputeAliasesToMakeVisible,
					allowModules,
				);
				if (parentResult) {
					return parentResult;
				}
			}
			if (earlyModuleBail) {
				return { accessibility: SymbolAccessibility.Accessible };
			}
			if (hadAccessibleChain) {
				return {
					accessibility: SymbolAccessibility.NotAccessible,
					errorSymbolName: symbolToString(
						initialSymbol,
						enclosingDeclaration,
						meaning,
					),
					errorModuleName: hadAccessibleChain !== initialSymbol ? symbolToString(
						hadAccessibleChain,
						enclosingDeclaration,
						SymbolFlags.Namespace,
					) : undefined,
				};
			}
		}
		/**
         * Check if the given symbol in given enclosing declaration is accessible and mark all associated alias to be visible if requested
         *
         * @param symbol a Symbol to check if accessible
         * @param enclosingDeclaration a Node containing reference to the symbol
         * @param meaning a SymbolFlags to check if such meaning of the symbol is accessible
         * @param shouldComputeAliasToMakeVisible a boolean value to indicate whether to return aliases to be mark visible in case the symbol is accessible
         */
		function isSymbolAccessible(
			symbol,
			enclosingDeclaration,
			meaning,
			shouldComputeAliasesToMakeVisible,
		) {
			return isSymbolAccessibleWorker(
				symbol,
				enclosingDeclaration,
				meaning,
				shouldComputeAliasesToMakeVisible, /*allowModules*/
				true,
			);
		}
		function isSymbolAccessibleWorker(
			symbol,
			enclosingDeclaration,
			meaning,
			shouldComputeAliasesToMakeVisible,
			allowModules,
		) {
			if (symbol && enclosingDeclaration) {
				var result = isAnySymbolAccessible(
					[symbol],
					enclosingDeclaration,
					symbol,
					meaning,
					shouldComputeAliasesToMakeVisible,
					allowModules,
				);
				if (result) {
					return result;
				}
				// This could be a symbol that is not exported in the external module
				// or it could be a symbol from different external module that is not aliased and hence cannot be named
				var symbolExternalModule = forEach(
					symbol.declarations,
					getExternalModuleContainer,
				);
				if (symbolExternalModule) {
					var enclosingExternalModule = getExternalModuleContainer(
						enclosingDeclaration,
					);
					if (symbolExternalModule !== enclosingExternalModule) {
						// name from different external module that is not visible
						return {
							accessibility: SymbolAccessibility.CannotBeNamed,
							errorSymbolName: symbolToString(
								symbol,
								enclosingDeclaration,
								meaning,
							),
							errorModuleName: symbolToString(symbolExternalModule),
							errorNode: isInJSFile(enclosingDeclaration) ? enclosingDeclaration : undefined,
						};
					}
				}
				// Just a local name that is not accessible
				return {
					accessibility: SymbolAccessibility.NotAccessible,
					errorSymbolName: symbolToString(symbol, enclosingDeclaration, meaning),
				};
			}
			return { accessibility: SymbolAccessibility.Accessible };
		}
		function getExternalModuleContainer(declaration) {
			var node = findAncestor(declaration, hasExternalModuleSymbol);
			return node && getSymbolOfNode(node);
		}
		function hasExternalModuleSymbol(declaration) {
			return isAmbientModule(declaration) || (declaration.kind === SyntaxKind.SourceFile && isExternalOrCommonJsModule(
				declaration,
			));
		}
		function hasNonGlobalAugmentationExternalModuleSymbol(declaration) {
			return isModuleWithStringLiteralName(declaration) || (declaration.kind === SyntaxKind.SourceFile && isExternalOrCommonJsModule(
				declaration,
			));
		}
		function hasVisibleDeclarations(symbol, shouldComputeAliasToMakeVisible) {
			var aliasesToMakeVisible;
			if (
				!every(
					filter(
						symbol.declarations,
						function (d) {
							return d.kind !== SyntaxKind.Identifier;
						},
					),
					getIsDeclarationVisible,
				)
			) {
				return undefined;
			}
			return {
				accessibility: SymbolAccessibility.Accessible,
				aliasesToMakeVisible: aliasesToMakeVisible,
			};
			function getIsDeclarationVisible(declaration) {
				var _a, _b;
				if (!isDeclarationVisible(declaration)) {
					// Mark the unexported alias as visible if its parent is visible
					// because these kind of aliases can be used to name types in declaration file
					var anyImportSyntax = getAnyImportSyntax(declaration);
					if (
						anyImportSyntax && !hasSyntacticModifier(
							anyImportSyntax,
							ModifierFlags.Export,
						) && isDeclarationVisible(
							anyImportSyntax.parent,
						) // import clause without export
					) {
						return addVisibleAlias(declaration, anyImportSyntax);
					} else if (
						isVariableDeclaration(declaration) && isVariableStatement(
							declaration.parent.parent,
						) && !hasSyntacticModifier(
							declaration.parent.parent,
							ModifierFlags.Export,
						) && isDeclarationVisible(
							declaration.parent.parent.parent,
						) // unexported variable statement
					) {
						return addVisibleAlias(declaration, declaration.parent.parent);
					} else if (
						isLateVisibilityPaintedStatement(declaration) && !hasSyntacticModifier(
							declaration,
							ModifierFlags.Export,
						) && isDeclarationVisible(
							declaration.parent, // unexported top-level statement
						)
					) {
						return addVisibleAlias(declaration, declaration);
					} else if (
						symbol.flags & SymbolFlags.Alias && isBindingElement(declaration) && isInJSFile(
							declaration,
						) && ((_a = declaration.parent) === null || _a === void 0 ? void 0 : _a.parent) && isVariableDeclaration(
							declaration.parent.parent, // exported import-like top-level JS require statement
						) && ((_b = declaration.parent.parent.parent) === null || _b === void 0 ? void 0 : _b.parent) && isVariableStatement(
							declaration.parent.parent.parent.parent,
						) && !hasSyntacticModifier(
							declaration.parent.parent.parent.parent,
							ModifierFlags.Export,
						) && declaration.parent.parent.parent.parent.parent && isDeclarationVisible(
							declaration.parent.parent.parent.parent.parent, // check if the thing containing the variable statement is visible (ie, the file)
						)
					) {
						return addVisibleAlias(
							declaration,
							declaration.parent.parent.parent.parent,
						);
					}
					// Declaration is not visible
					return false;
				}
				return true;
			}
			function addVisibleAlias(declaration, aliasingStatement) {
				// In function "buildTypeDisplay" where we decide whether to write type-alias or serialize types,
				// we want to just check if type- alias is accessible or not but we don't care about emitting those alias at that time
				// since we will do the emitting later in trackSymbol.
				if (shouldComputeAliasToMakeVisible) {
					getNodeLinks(declaration).isVisible = true;
					aliasesToMakeVisible = appendIfUnique(
						aliasesToMakeVisible,
						aliasingStatement,
					);
				}
				return true;
			}
		}
		function isEntityNameVisible(entityName, enclosingDeclaration) {
			// get symbol of the first identifier of the entityName
			var meaning;
			if (
				entityName.parent.kind === SyntaxKind.TypeQuery || isExpressionWithTypeArgumentsInClassExtendsClause(
					entityName.parent,
				) || entityName.parent.kind === SyntaxKind.ComputedPropertyName
			) {
				// Typeof value
				meaning = SymbolFlags.Value | SymbolFlags.ExportValue;
			} else if (
				entityName.kind === SyntaxKind.QualifiedName || entityName.kind === SyntaxKind.PropertyAccessExpression || entityName.parent.kind === SyntaxKind.ImportEqualsDeclaration
			) {
				// Left identifier from type reference or TypeAlias
				// Entity name of the import declaration
				meaning = SymbolFlags.Namespace;
			} else {
				// Type Reference or TypeAlias entity = Identifier
				meaning = SymbolFlags.Type;
			}
			var firstIdentifier = getFirstIdentifier(entityName);
			var symbol = resolveName(
				enclosingDeclaration,
				firstIdentifier.escapedText,
				meaning, /*nodeNotFoundErrorMessage*/
				undefined, /*nameArg*/
				undefined, /*isUse*/
				false,
			);
			if (
				symbol && symbol.flags & SymbolFlags.TypeParameter && meaning & SymbolFlags.Type
			) {
				return { accessibility: SymbolAccessibility.Accessible };
			}
			// Verify if the symbol is accessible
			return (symbol && hasVisibleDeclarations(
				symbol, /*shouldComputeAliasToMakeVisible*/
				true,
			)) || {
				accessibility: SymbolAccessibility.NotAccessible,
				errorSymbolName: getTextOfNode(firstIdentifier),
				errorNode: firstIdentifier,
			};
		}
		function symbolToString(
			symbol,
			enclosingDeclaration,
			meaning,
			flags,
			writer,
		) {
			if (flags === void 0) {
				flags = SymbolFormatFlags.AllowAnyNodeKind;
			}
			var nodeFlags = NodeBuilderFlags.IgnoreErrors;
			if (flags & SymbolFormatFlags.UseOnlyExternalAliasing) {
				nodeFlags |= NodeBuilderFlags.UseOnlyExternalAliasing;
			}
			if (flags & SymbolFormatFlags.WriteTypeParametersOrArguments) {
				nodeFlags |= NodeBuilderFlags.WriteTypeParametersInQualifiedName;
			}
			if (flags & SymbolFormatFlags.UseAliasDefinedOutsideCurrentScope) {
				nodeFlags |= NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope;
			}
			if (flags & SymbolFormatFlags.DoNotIncludeSymbolChain) {
				nodeFlags |= NodeBuilderFlags.DoNotIncludeSymbolChain;
			}
			var builder = flags & SymbolFormatFlags.AllowAnyNodeKind ? nodeBuilder.symbolToExpression : nodeBuilder.symbolToEntityName;
			return writer ? symbolToStringWorker(writer).getText() : usingSingleLineStringWriter(
				symbolToStringWorker,
			);
			function symbolToStringWorker(writer) {
				var entity = builder(symbol, meaning, enclosingDeclaration, nodeFlags); // TODO: GH#18217
				// add neverAsciiEscape for GH#39027
				var printer = (enclosingDeclaration === null || enclosingDeclaration === void 0 ? void 0 : enclosingDeclaration.kind) === SyntaxKind.SourceFile ? createPrinter(
					{ removeComments: true, neverAsciiEscape: true },
				) : createPrinter({ removeComments: true });
				var sourceFile = enclosingDeclaration && getSourceFileOfNode(
					enclosingDeclaration,
				);
				printer.writeNode(
					EmitHint.Unspecified,
					entity, /*sourceFile*/
					sourceFile,
					writer,
				);
				return writer;
			}
		}
		function signatureToString(
			signature,
			enclosingDeclaration,
			flags,
			kind,
			writer,
		) {
			if (flags === void 0) {
				flags = TypeFormatFlags.None;
			}
			return writer ? signatureToStringWorker(writer).getText() : usingSingleLineStringWriter(
				signatureToStringWorker,
			);
			function signatureToStringWorker(writer) {
				var sigOutput;
				if (flags & TypeFormatFlags.WriteArrowStyleSignature) {
					sigOutput = kind === SignatureKind.Construct ? SyntaxKind.ConstructorType : SyntaxKind.FunctionType;
				} else {
					sigOutput = kind === SignatureKind.Construct ? SyntaxKind.ConstructSignature : SyntaxKind.CallSignature;
				}
				var sig = nodeBuilder.signatureToSignatureDeclaration(
					signature,
					sigOutput,
					enclosingDeclaration,
					toNodeBuilderFlags(flags) | NodeBuilderFlags.IgnoreErrors | NodeBuilderFlags.WriteTypeParametersInQualifiedName,
				);
				var printer = createPrinter(
					{ removeComments: true, omitTrailingSemicolon: true },
				);
				var sourceFile = enclosingDeclaration && getSourceFileOfNode(
					enclosingDeclaration,
				);
				printer.writeNode(
					EmitHint.Unspecified,
					sig, /*sourceFile*/
					sourceFile,
					getTrailingSemicolonDeferringWriter(writer),
				); // TODO: GH#18217
				return writer;
			}
		}
		function typeToString(type, enclosingDeclaration, flags, writer) {
			if (flags === void 0) {
				flags = TypeFormatFlags.AllowUniqueESSymbolType | TypeFormatFlags.UseAliasDefinedOutsideCurrentScope;
			}
			if (writer === void 0) {
				writer = createTextWriter("");
			}
			var noTruncation = compilerOptions.noErrorTruncation || flags & TypeFormatFlags.NoTruncation;
			var typeNode = nodeBuilder.typeToTypeNode(
				type,
				enclosingDeclaration,
				toNodeBuilderFlags(flags) | NodeBuilderFlags.IgnoreErrors | (noTruncation ? NodeBuilderFlags.NoTruncation : 0),
				writer,
			);
			if (typeNode === undefined) return Debug.fail(
				"should always get typenode",
			);
			// The unresolved type gets a synthesized comment on `any` to hint to users that it's not a plain `any`.
			// Otherwise, we always strip comments out.
			var options = { removeComments: type !== unresolvedType };
			var printer = createPrinter(options);
			var sourceFile = enclosingDeclaration && getSourceFileOfNode(
				enclosingDeclaration,
			);
			printer.writeNode(
				EmitHint.Unspecified,
				typeNode, /*sourceFile*/
				sourceFile,
				writer,
			);
			var result = writer.getText();
			var maxLength = noTruncation ? noTruncationMaximumTruncationLength * 2 : defaultMaximumTruncationLength * 2;
			if (maxLength && result && result.length >= maxLength) {
				return result.substr(0, maxLength - "...".length) + "...";
			}
			return result;
		}
		function getTypeNamesForErrorDisplay(left, right) {
			var leftStr = symbolValueDeclarationIsContextSensitive(left.symbol) ? typeToString(
				left,
				left.symbol.valueDeclaration,
			) : typeToString(left);
			var rightStr = symbolValueDeclarationIsContextSensitive(right.symbol) ? typeToString(
				right,
				right.symbol.valueDeclaration,
			) : typeToString(right);
			if (leftStr === rightStr) {
				leftStr = getTypeNameForErrorDisplay(left);
				rightStr = getTypeNameForErrorDisplay(right);
			}
			return [leftStr, rightStr];
		}
		function getTypeNameForErrorDisplay(type) {
			return typeToString(
				type, /*enclosingDeclaration*/
				undefined,
				TypeFormatFlags.UseFullyQualifiedType,
			);
		}
		function symbolValueDeclarationIsContextSensitive(symbol) {
			return symbol && !!symbol.valueDeclaration && isExpression(
				symbol.valueDeclaration,
			) && !isContextSensitive(symbol.valueDeclaration);
		}
		function toNodeBuilderFlags(flags) {
			if (flags === void 0) {
				flags = TypeFormatFlags.None;
			}
			return flags & TypeFormatFlags.NodeBuilderFlagsMask;
		}
		function isClassInstanceSide(type) {
			return !!type.symbol && !!(type.symbol.flags & SymbolFlags.Class) && (type === getDeclaredTypeOfClassOrInterface(
				type.symbol,
			) || (!!(type.flags & TypeFlags.Object) && !!(getObjectFlags(type) & ObjectFlags.IsClassInstanceClone)));
		}
		function createNodeBuilder() {
			return {
				typeToTypeNode: function (type, enclosingDeclaration, flags, tracker) {
					return withContext(
						enclosingDeclaration,
						flags,
						tracker,
						function (context) {
							return typeToTypeNodeHelper(type, context);
						},
					);
				},
				indexInfoToIndexSignatureDeclaration: function (
					indexInfo,
					enclosingDeclaration,
					flags,
					tracker,
				) {
					return withContext(
						enclosingDeclaration,
						flags,
						tracker,
						function (context) {
							return indexInfoToIndexSignatureDeclarationHelper(
								indexInfo,
								context, /*typeNode*/
								undefined,
							);
						},
					);
				},
				signatureToSignatureDeclaration: function (
					signature,
					kind,
					enclosingDeclaration,
					flags,
					tracker,
				) {
					return withContext(
						enclosingDeclaration,
						flags,
						tracker,
						function (context) {
							return signatureToSignatureDeclarationHelper(
								signature,
								kind,
								context,
							);
						},
					);
				},
				symbolToEntityName: function (
					symbol,
					meaning,
					enclosingDeclaration,
					flags,
					tracker,
				) {
					return withContext(
						enclosingDeclaration,
						flags,
						tracker,
						function (context) {
							return symbolToName(
								symbol,
								context,
								meaning, /*expectsIdentifier*/
								false,
							);
						},
					);
				},
				symbolToExpression: function (
					symbol,
					meaning,
					enclosingDeclaration,
					flags,
					tracker,
				) {
					return withContext(
						enclosingDeclaration,
						flags,
						tracker,
						function (context) {
							return symbolToExpression(symbol, context, meaning);
						},
					);
				},
				symbolToTypeParameterDeclarations: function (
					symbol,
					enclosingDeclaration,
					flags,
					tracker,
				) {
					return withContext(
						enclosingDeclaration,
						flags,
						tracker,
						function (context) {
							return typeParametersToTypeParameterDeclarations(symbol, context);
						},
					);
				},
				symbolToParameterDeclaration: function (
					symbol,
					enclosingDeclaration,
					flags,
					tracker,
				) {
					return withContext(
						enclosingDeclaration,
						flags,
						tracker,
						function (context) {
							return symbolToParameterDeclaration(symbol, context);
						},
					);
				},
				typeParameterToDeclaration: function (
					parameter,
					enclosingDeclaration,
					flags,
					tracker,
				) {
					return withContext(
						enclosingDeclaration,
						flags,
						tracker,
						function (context) {
							return typeParameterToDeclaration(parameter, context);
						},
					);
				},
				symbolTableToDeclarationStatements: function (
					symbolTable,
					enclosingDeclaration,
					flags,
					tracker,
					bundled,
				) {
					return withContext(
						enclosingDeclaration,
						flags,
						tracker,
						function (context) {
							return symbolTableToDeclarationStatements(
								symbolTable,
								context,
								bundled,
							);
						},
					);
				},
			};
			function withContext(enclosingDeclaration, flags, tracker, cb) {
				var _a, _b;
				Debug.assert(
					enclosingDeclaration === undefined || (enclosingDeclaration.flags & NodeFlags.Synthesized) === 0,
				);
				var context = {
					enclosingDeclaration: enclosingDeclaration,
					flags: flags || NodeBuilderFlags.None,
					// If no full tracker is provided, fake up a dummy one with a basic limited-functionality moduleResolverHost
					tracker: tracker && tracker.trackSymbol ? tracker : {
						trackSymbol: function () {
							return false;
						},
						moduleResolverHost: flags & NodeBuilderFlags.DoNotIncludeSymbolChain ? {
							getCommonSourceDirectory: !!host.getCommonSourceDirectory ? function () {
								return host.getCommonSourceDirectory();
							} : function () {
								return "";
							},
							getCurrentDirectory: function () {
								return host.getCurrentDirectory();
							},
							getSymlinkCache: maybeBind(host, host.getSymlinkCache),
							useCaseSensitiveFileNames: maybeBind(
								host,
								host.useCaseSensitiveFileNames,
							),
							redirectTargetsMap: host.redirectTargetsMap,
							getProjectReferenceRedirect: function (fileName) {
								return host.getProjectReferenceRedirect(fileName);
							},
							isSourceOfProjectReferenceRedirect: function (fileName) {
								return host.isSourceOfProjectReferenceRedirect(fileName);
							},
							fileExists: function (fileName) {
								return host.fileExists(fileName);
							},
							getFileIncludeReasons: function () {
								return host.getFileIncludeReasons();
							},
							readFile: host.readFile ? (function (fileName) {
								return host.readFile(fileName);
							}) : undefined,
						} : undefined,
					},
					encounteredError: false,
					reportedDiagnostic: false,
					visitedTypes: undefined,
					symbolDepth: undefined,
					inferTypeParameters: undefined,
					approximateLength: 0,
				};
				context.tracker = wrapSymbolTrackerToReportForContext(
					context,
					context.tracker,
				);
				var resultingNode = cb(context);
				if (context.truncating && context.flags & NodeBuilderFlags.NoTruncation) {
					(_b = (_a = context.tracker) === null || _a === void 0 ? void 0 : _a.reportTruncationError) === null || _b === void 0 ? void 0 : _b.call(
						_a,
					);
				}
				return context.encounteredError ? undefined : resultingNode;
			}
			function wrapSymbolTrackerToReportForContext(context, tracker) {
				var oldTrackSymbol = tracker.trackSymbol;
				return __assign(
					__assign({}, tracker),
					{
						reportCyclicStructureError: wrapReportedDiagnostic(
							tracker.reportCyclicStructureError,
						),
						reportInaccessibleThisError: wrapReportedDiagnostic(
							tracker.reportInaccessibleThisError,
						),
						reportInaccessibleUniqueSymbolError: wrapReportedDiagnostic(
							tracker.reportInaccessibleUniqueSymbolError,
						),
						reportLikelyUnsafeImportRequiredError: wrapReportedDiagnostic(
							tracker.reportLikelyUnsafeImportRequiredError,
						),
						reportNonlocalAugmentation: wrapReportedDiagnostic(
							tracker.reportNonlocalAugmentation,
						),
						reportPrivateInBaseOfClassExpression: wrapReportedDiagnostic(
							tracker.reportPrivateInBaseOfClassExpression,
						),
						reportNonSerializableProperty: wrapReportedDiagnostic(
							tracker.reportNonSerializableProperty,
						),
						trackSymbol: oldTrackSymbol && (function () {
							var args = [];
							for (var _i = 0; _i < arguments.length; _i++) {
								args[_i] = arguments[_i];
							}
							var result = oldTrackSymbol.apply(void 0, args);
							if (result) {
								context.reportedDiagnostic = true;
							}
							return result;
						}),
					},
				);
				function wrapReportedDiagnostic(method) {
					if (!method) {
						return method;
					}
					return (function () {
						var args = [];
						for (var _i = 0; _i < arguments.length; _i++) {
							args[_i] = arguments[_i];
						}
						context.reportedDiagnostic = true;
						return method.apply(void 0, args);
					});
				}
			}
			function checkTruncationLength(context) {
				if (context.truncating) return context.truncating;
				return context.truncating = context.approximateLength > ((context.flags & NodeBuilderFlags.NoTruncation) ? noTruncationMaximumTruncationLength : defaultMaximumTruncationLength);
			}
			function typeToTypeNodeHelper(type, context) {
				if (cancellationToken && cancellationToken.throwIfCancellationRequested) {
					cancellationToken.throwIfCancellationRequested();
				}
				var inTypeAlias = context.flags & NodeBuilderFlags.InTypeAlias;
				context.flags &= ~NodeBuilderFlags.InTypeAlias;
				if (!type) {
					if (!(context.flags & NodeBuilderFlags.AllowEmptyUnionOrIntersection)) {
						context.encounteredError = true;
						return undefined; // TODO: GH#18217
					}
					context.approximateLength += 3;
					return factory.createKeywordTypeNode(SyntaxKind.AnyKeyword);
				}
				if (!(context.flags & NodeBuilderFlags.NoTypeReduction)) {
					type = getReducedType(type);
				}
				if (type.flags & TypeFlags.Any) {
					if (type.aliasSymbol) {
						return factory.createTypeReferenceNode(
							symbolToEntityNameNode(type.aliasSymbol),
							mapToTypeNodes(type.aliasTypeArguments, context),
						);
					}
					if (type === unresolvedType) {
						return addSyntheticLeadingComment(
							factory.createKeywordTypeNode(SyntaxKind.AnyKeyword),
							SyntaxKind.MultiLineCommentTrivia,
							"unresolved",
						);
					}
					context.approximateLength += 3;
					return factory.createKeywordTypeNode(
						type === intrinsicMarkerType ? SyntaxKind.IntrinsicKeyword : SyntaxKind.AnyKeyword,
					);
				}
				if (type.flags & TypeFlags.Unknown) {
					return factory.createKeywordTypeNode(SyntaxKind.UnknownKeyword);
				}
				if (type.flags & TypeFlags.String) {
					context.approximateLength += 6;
					return factory.createKeywordTypeNode(SyntaxKind.StringKeyword);
				}
				if (type.flags & TypeFlags.Number) {
					context.approximateLength += 6;
					return factory.createKeywordTypeNode(SyntaxKind.NumberKeyword);
				}
				if (type.flags & TypeFlags.BigInt) {
					context.approximateLength += 6;
					return factory.createKeywordTypeNode(SyntaxKind.BigIntKeyword);
				}
				if (type.flags & TypeFlags.Boolean && !type.aliasSymbol) {
					context.approximateLength += 7;
					return factory.createKeywordTypeNode(SyntaxKind.BooleanKeyword);
				}
				if (
					type.flags & TypeFlags.EnumLiteral && !(type.flags & TypeFlags.Union)
				) {
					var parentSymbol = getParentOfSymbol(type.symbol);
					var parentName = symbolToTypeNode(
						parentSymbol,
						context,
						SymbolFlags.Type,
					);
					if (getDeclaredTypeOfSymbol(parentSymbol) === type) {
						return parentName;
					}
					var memberName = symbolName(type.symbol);
					if (isIdentifierText(memberName, ScriptTarget.ES3)) {
						return appendReferenceToType(
							parentName,
							factory.createTypeReferenceNode(
								memberName, /*typeArguments*/
								undefined,
							),
						);
					}
					if (isImportTypeNode(parentName)) {
						parentName.isTypeOf = true; // mutably update, node is freshly manufactured anyhow
						return factory.createIndexedAccessTypeNode(
							parentName,
							factory.createLiteralTypeNode(
								factory.createStringLiteral(memberName),
							),
						);
					} else if (isTypeReferenceNode(parentName)) {
						return factory.createIndexedAccessTypeNode(
							factory.createTypeQueryNode(parentName.typeName),
							factory.createLiteralTypeNode(
								factory.createStringLiteral(memberName),
							),
						);
					} else {
						return Debug.fail(
							"Unhandled type node kind returned from `symbolToTypeNode`.",
						);
					}
				}
				if (type.flags & TypeFlags.EnumLike) {
					return symbolToTypeNode(type.symbol, context, SymbolFlags.Type);
				}
				if (type.flags & TypeFlags.StringLiteral) {
					context.approximateLength += (type.value.length + 2);
					return factory.createLiteralTypeNode(
						setEmitFlags(
							factory.createStringLiteral(
								type.value,
								!!(context.flags & NodeBuilderFlags.UseSingleQuotesForStringLiteralType),
							),
							EmitFlags.NoAsciiEscaping,
						),
					);
				}
				if (type.flags & TypeFlags.NumberLiteral) {
					var value = type.value;
					context.approximateLength += ("" + value).length;
					return factory.createLiteralTypeNode(
						value < 0 ? factory.createPrefixUnaryExpression(
							SyntaxKind.MinusToken,
							factory.createNumericLiteral(-value),
						) : factory.createNumericLiteral(value),
					);
				}
				if (type.flags & TypeFlags.BigIntLiteral) {
					context.approximateLength += (pseudoBigIntToString(type.value).length) + 1;
					return factory.createLiteralTypeNode(
						(factory.createBigIntLiteral(type.value)),
					);
				}
				if (type.flags & TypeFlags.BooleanLiteral) {
					context.approximateLength += type.intrinsicName.length;
					return factory.createLiteralTypeNode(
						type.intrinsicName === "true" ? factory.createTrue() : factory.createFalse(),
					);
				}
				if (type.flags & TypeFlags.UniqueESSymbol) {
					if (!(context.flags & NodeBuilderFlags.AllowUniqueESSymbolType)) {
						if (
							isValueSymbolAccessible(type.symbol, context.enclosingDeclaration)
						) {
							context.approximateLength += 6;
							return symbolToTypeNode(type.symbol, context, SymbolFlags.Value);
						}
						if (context.tracker.reportInaccessibleUniqueSymbolError) {
							context.tracker.reportInaccessibleUniqueSymbolError();
						}
					}
					context.approximateLength += 13;
					return factory.createTypeOperatorNode(
						SyntaxKind.UniqueKeyword,
						factory.createKeywordTypeNode(SyntaxKind.SymbolKeyword),
					);
				}
				if (type.flags & TypeFlags.Void) {
					context.approximateLength += 4;
					return factory.createKeywordTypeNode(SyntaxKind.VoidKeyword);
				}
				if (type.flags & TypeFlags.Undefined) {
					context.approximateLength += 9;
					return factory.createKeywordTypeNode(SyntaxKind.UndefinedKeyword);
				}
				if (type.flags & TypeFlags.Null) {
					context.approximateLength += 4;
					return factory.createLiteralTypeNode(factory.createNull());
				}
				if (type.flags & TypeFlags.Never) {
					context.approximateLength += 5;
					return factory.createKeywordTypeNode(SyntaxKind.NeverKeyword);
				}
				if (type.flags & TypeFlags.ESSymbol) {
					context.approximateLength += 6;
					return factory.createKeywordTypeNode(SyntaxKind.SymbolKeyword);
				}
				if (type.flags & TypeFlags.NonPrimitive) {
					context.approximateLength += 6;
					return factory.createKeywordTypeNode(SyntaxKind.ObjectKeyword);
				}
				if (isThisTypeParameter(type)) {
					if (context.flags & NodeBuilderFlags.InObjectTypeLiteral) {
						if (
							!context.encounteredError && !(context.flags & NodeBuilderFlags.AllowThisInObjectLiteral)
						) {
							context.encounteredError = true;
						}
						if (context.tracker.reportInaccessibleThisError) {
							context.tracker.reportInaccessibleThisError();
						}
					}
					context.approximateLength += 4;
					return factory.createThisTypeNode();
				}
				if (
					!inTypeAlias && type.aliasSymbol && (context.flags & NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope || isTypeSymbolAccessible(
						type.aliasSymbol,
						context.enclosingDeclaration,
					))
				) {
					var typeArgumentNodes = mapToTypeNodes(
						type.aliasTypeArguments,
						context,
					);
					if (
						isReservedMemberName(type.aliasSymbol.escapedName) && !(type.aliasSymbol.flags & SymbolFlags.Class)
					) return factory.createTypeReferenceNode(
						factory.createIdentifier(""),
						typeArgumentNodes,
					);
					return symbolToTypeNode(
						type.aliasSymbol,
						context,
						SymbolFlags.Type,
						typeArgumentNodes,
					);
				}
				var objectFlags = getObjectFlags(type);
				if (objectFlags & ObjectFlags.Reference) {
					Debug.assert(!!(type.flags & TypeFlags.Object));
					return type.node ? visitAndTransformType(
						type,
						typeReferenceToTypeNode,
					) : typeReferenceToTypeNode(type);
				}
				if (
					type.flags & TypeFlags.TypeParameter || objectFlags & ObjectFlags.ClassOrInterface
				) {
					if (
						type.flags & TypeFlags.TypeParameter && contains(
							context.inferTypeParameters,
							type,
						)
					) {
						context.approximateLength += (symbolName(type.symbol).length + 6);
						return factory.createInferTypeNode(
							typeParameterToDeclarationWithConstraint(
								type,
								context, /*constraintNode*/
								undefined,
							),
						);
					}
					if (
						context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams && type.flags & TypeFlags.TypeParameter && !isTypeSymbolAccessible(
							type.symbol,
							context.enclosingDeclaration,
						)
					) {
						var name_3 = typeParameterToName(type, context);
						context.approximateLength += idText(name_3).length;
						return factory.createTypeReferenceNode(
							factory.createIdentifier(idText(name_3)), /*typeArguments*/
							undefined,
						);
					}
					// Ignore constraint/default when creating a usage (as opposed to declaration) of a type parameter.
					return type.symbol ? symbolToTypeNode(
						type.symbol,
						context,
						SymbolFlags.Type,
					) : factory.createTypeReferenceNode(
						factory.createIdentifier("?"), /*typeArguments*/
						undefined,
					);
				}
				if (type.flags & TypeFlags.Union && type.origin) {
					type = type.origin;
				}
				if (type.flags & (TypeFlags.Union | TypeFlags.Intersection)) {
					var types = type.flags & TypeFlags.Union ? formatUnionTypes(
						type.types,
					) : type.types;
					if (length(types) === 1) {
						return typeToTypeNodeHelper(types[0], context);
					}
					var typeNodes = mapToTypeNodes(types, context, /*isBareList*/ true);
					if (typeNodes && typeNodes.length > 0) {
						return type.flags & TypeFlags.Union ? factory.createUnionTypeNode(
							typeNodes,
						) : factory.createIntersectionTypeNode(typeNodes);
					} else {
						if (
							!context.encounteredError && !(context.flags & NodeBuilderFlags.AllowEmptyUnionOrIntersection)
						) {
							context.encounteredError = true;
						}
						return undefined; // TODO: GH#18217
					}
				}
				if (objectFlags & (ObjectFlags.Anonymous | ObjectFlags.Mapped)) {
					Debug.assert(!!(type.flags & TypeFlags.Object));
					// The type is an object literal type.
					return createAnonymousTypeNode(type);
				}
				if (type.flags & TypeFlags.Index) {
					var indexedType = type.type;
					context.approximateLength += 6;
					var indexTypeNode = typeToTypeNodeHelper(indexedType, context);
					return factory.createTypeOperatorNode(
						SyntaxKind.KeyOfKeyword,
						indexTypeNode,
					);
				}
				if (type.flags & TypeFlags.TemplateLiteral) {
					var texts_1 = type.texts;
					var types_1 = type.types;
					var templateHead = factory.createTemplateHead(texts_1[0]);
					var templateSpans = factory.createNodeArray(
						map(
							types_1,
							function (t, i) {
								return factory.createTemplateLiteralTypeSpan(
									typeToTypeNodeHelper(t, context),
									(i < types_1.length - 1 ? factory.createTemplateMiddle : factory.createTemplateTail)(
										texts_1[i + 1],
									),
								);
							},
						),
					);
					context.approximateLength += 2;
					return factory.createTemplateLiteralType(templateHead, templateSpans);
				}
				if (type.flags & TypeFlags.StringMapping) {
					var typeNode = typeToTypeNodeHelper(type.type, context);
					return symbolToTypeNode(
						type.symbol,
						context,
						SymbolFlags.Type,
						[typeNode],
					);
				}
				if (type.flags & TypeFlags.IndexedAccess) {
					var objectTypeNode = typeToTypeNodeHelper(type.objectType, context);
					var indexTypeNode = typeToTypeNodeHelper(type.indexType, context);
					context.approximateLength += 2;
					return factory.createIndexedAccessTypeNode(
						objectTypeNode,
						indexTypeNode,
					);
				}
				if (type.flags & TypeFlags.Conditional) {
					return visitAndTransformType(
						type,
						function (type) {
							return conditionalTypeToTypeNode(type);
						},
					);
				}
				if (type.flags & TypeFlags.Substitution) {
					return typeToTypeNodeHelper(type.baseType, context);
				}
				return Debug.fail("Should be unreachable.");
				function conditionalTypeToTypeNode(type) {
					var checkTypeNode = typeToTypeNodeHelper(type.checkType, context);
					var saveInferTypeParameters = context.inferTypeParameters;
					context.inferTypeParameters = type.root.inferTypeParameters;
					var extendsTypeNode = typeToTypeNodeHelper(type.extendsType, context);
					context.inferTypeParameters = saveInferTypeParameters;
					var trueTypeNode = typeToTypeNodeOrCircularityElision(
						getTrueTypeFromConditionalType(type),
					);
					var falseTypeNode = typeToTypeNodeOrCircularityElision(
						getFalseTypeFromConditionalType(type),
					);
					context.approximateLength += 15;
					return factory.createConditionalTypeNode(
						checkTypeNode,
						extendsTypeNode,
						trueTypeNode,
						falseTypeNode,
					);
				}
				function typeToTypeNodeOrCircularityElision(type) {
					var _a, _b, _c;
					if (type.flags & TypeFlags.Union) {
						if (
							(_a = context.visitedTypes) === null || _a === void 0 ? void 0 : _a.has(
								getTypeId(type),
							)
						) {
							if (!(context.flags & NodeBuilderFlags.AllowAnonymousIdentifier)) {
								context.encounteredError = true;
								(_c = (_b = context.tracker) === null || _b === void 0 ? void 0 : _b.reportCyclicStructureError) === null || _c === void 0 ? void 0 : _c.call(
									_b,
								);
							}
							return createElidedInformationPlaceholder(context);
						}
						return visitAndTransformType(
							type,
							function (type) {
								return typeToTypeNodeHelper(type, context);
							},
						);
					}
					return typeToTypeNodeHelper(type, context);
				}
				function createMappedTypeNodeFromType(type) {
					Debug.assert(!!(type.flags & TypeFlags.Object));
					var readonlyToken = type.declaration.readonlyToken ? factory.createToken(
						type.declaration.readonlyToken.kind,
					) : undefined;
					var questionToken = type.declaration.questionToken ? factory.createToken(
						type.declaration.questionToken.kind,
					) : undefined;
					var appropriateConstraintTypeNode;
					if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
						// We have a { [P in keyof T]: X }
						// We do this to ensure we retain the toplevel keyof-ness of the type which may be lost due to keyof distribution during `getConstraintTypeFromMappedType`
						appropriateConstraintTypeNode = factory.createTypeOperatorNode(
							SyntaxKind.KeyOfKeyword,
							typeToTypeNodeHelper(
								getModifiersTypeFromMappedType(type),
								context,
							),
						);
					} else {
						appropriateConstraintTypeNode = typeToTypeNodeHelper(
							getConstraintTypeFromMappedType(type),
							context,
						);
					}
					var typeParameterNode = typeParameterToDeclarationWithConstraint(
						getTypeParameterFromMappedType(type),
						context,
						appropriateConstraintTypeNode,
					);
					var nameTypeNode = type.declaration.nameType ? typeToTypeNodeHelper(
						getNameTypeFromMappedType(type),
						context,
					) : undefined;
					var templateTypeNode = typeToTypeNodeHelper(
						removeMissingType(
							getTemplateTypeFromMappedType(type),
							!!(getMappedTypeModifiers(type) & 4), /* IncludeOptional */
						),
						context,
					);
					var mappedTypeNode = factory.createMappedTypeNode(
						readonlyToken,
						typeParameterNode,
						nameTypeNode,
						questionToken,
						templateTypeNode, /*members*/
						undefined,
					);
					context.approximateLength += 10;
					return setEmitFlags(mappedTypeNode, EmitFlags.SingleLine);
				}
				function createAnonymousTypeNode(type) {
					var _a;
					var typeId = type.id;
					var symbol = type.symbol;
					if (symbol) {
						var isInstanceType = isClassInstanceSide(type) ? SymbolFlags.Type : SymbolFlags.Value;
						if (isJSConstructor(symbol.valueDeclaration)) {
							// Instance and static types share the same symbol; only add 'typeof' for the static side.
							return symbolToTypeNode(symbol, context, isInstanceType);
						} else if (
							symbol.flags & SymbolFlags.Class && !getBaseTypeVariableOfClass( // Always use 'typeof T' for type of class, enum, and module objects
								symbol,
							) && !(symbol.valueDeclaration && symbol.valueDeclaration.kind === SyntaxKind.ClassExpression && context.flags & NodeBuilderFlags.WriteClassExpressionAsTypeLiteral) || symbol.flags & (SymbolFlags.Enum | SymbolFlags.ValueModule) || shouldWriteTypeOfFunctionSymbol()
						) {
							return symbolToTypeNode(symbol, context, isInstanceType);
						} else if (
							(_a = context.visitedTypes) === null || _a === void 0 ? void 0 : _a.has(
								typeId,
							)
						) {
							// If type is an anonymous type literal in a type alias declaration, use type alias name
							var typeAlias = getTypeAliasForTypeLiteral(type);
							if (typeAlias) {
								// The specified symbol flags need to be reinterpreted as type flags
								return symbolToTypeNode(typeAlias, context, SymbolFlags.Type);
							} else {
								return createElidedInformationPlaceholder(context);
							}
						} else {
							return visitAndTransformType(type, createTypeNodeFromObjectType);
						}
					} else {
						// Anonymous types without a symbol are never circular.
						return createTypeNodeFromObjectType(type);
					}
					function shouldWriteTypeOfFunctionSymbol() {
						var _a;
						var isStaticMethodSymbol = !!(symbol.flags & SymbolFlags.Method) && some(
							symbol.declarations, // typeof static method
							function (declaration) {
								return isStatic(declaration);
							},
						);
						var isNonLocalFunctionSymbol = !!(symbol.flags & SymbolFlags.Function) && (symbol.parent || forEach(
							symbol.declarations, // is exported function symbol
							function (declaration) {
								return declaration.parent.kind === SyntaxKind.SourceFile || declaration.parent.kind === SyntaxKind.ModuleBlock;
							},
						));
						if (isStaticMethodSymbol || isNonLocalFunctionSymbol) {
							// typeof is allowed only for static/non local functions
							return (!!(context.flags & NodeBuilderFlags.UseTypeOfFunction) || ((_a = context.visitedTypes) === null || _a === void 0 ? void 0 : _a.has(
								typeId,
							))) && (!(context.flags & NodeBuilderFlags.UseStructuralFallback) || isValueSymbolAccessible(
								symbol, // it is type of the symbol uses itself recursively
								context.enclosingDeclaration,
							)); // And the build is going to succeed without visibility error or there is no structural fallback allowed
						}
					}
				}
				function visitAndTransformType(type, transform) {
					var _a, _b;
					var typeId = type.id;
					var isConstructorObject = getObjectFlags(type) & ObjectFlags.Anonymous && type.symbol && type.symbol.flags & SymbolFlags.Class;
					var id = getObjectFlags(type) & ObjectFlags.Reference && type.node ? "N" + getNodeId(
						type.node,
					) : type.flags & TypeFlags.Conditional ? "N" + getNodeId(
						type.root.node,
					) : type.symbol ? (isConstructorObject ? "+" : "") + getSymbolId(
						type.symbol,
					) : undefined;
					// Since instantiations of the same anonymous type have the same symbol, tracking symbols instead
					// of types allows us to catch circular references to instantiations of the same anonymous type
					if (!context.visitedTypes) {
						context.visitedTypes = new Set();
					}
					if (id && !context.symbolDepth) {
						context.symbolDepth = new Map();
					}
					var links = context.enclosingDeclaration && getNodeLinks(
						context.enclosingDeclaration,
					);
					var key = "".concat(getTypeId(type), "|").concat(context.flags);
					if (links) {
						links.serializedTypes || (links.serializedTypes = new Map());
					}
					var cachedResult = (_a = links === null || links === void 0 ? void 0 : links.serializedTypes) === null || _a === void 0 ? void 0 : _a.get(
						key,
					);
					if (cachedResult) {
						if (cachedResult.truncating) {
							context.truncating = true;
						}
						context.approximateLength += cachedResult.addedLength;
						return deepCloneOrReuseNode(cachedResult);
					}
					var depth;
					if (id) {
						depth = context.symbolDepth.get(id) || 0;
						if (depth > 10) {
							return createElidedInformationPlaceholder(context);
						}
						context.symbolDepth.set(id, depth + 1);
					}
					context.visitedTypes.add(typeId);
					var startLength = context.approximateLength;
					var result = transform(type);
					var addedLength = context.approximateLength - startLength;
					if (!context.reportedDiagnostic && !context.encounteredError) {
						if (context.truncating) {
							result.truncating = true;
						}
						result.addedLength = addedLength;
						(_b = links === null || links === void 0 ? void 0 : links.serializedTypes) === null || _b === void 0 ? void 0 : _b.set(
							key,
							result,
						);
					}
					context.visitedTypes["delete"](typeId);
					if (id) {
						context.symbolDepth.set(id, depth);
					}
					return result;
					function deepCloneOrReuseNode(node) {
						if (!nodeIsSynthesized(node) && getParseTreeNode(node) === node) {
							return node;
						}
						return setTextRange(
							factory.cloneNode(
								visitEachChild(
									node,
									deepCloneOrReuseNode,
									nullTransformationContext,
								),
							),
							node,
						);
					}
				}
				function createTypeNodeFromObjectType(type) {
					if (isGenericMappedType(type) || type.containsError) {
						return createMappedTypeNodeFromType(type);
					}
					var resolved = resolveStructuredTypeMembers(type);
					if (!resolved.properties.length && !resolved.indexInfos.length) {
						if (
							!resolved.callSignatures.length && !resolved.constructSignatures.length
						) {
							context.approximateLength += 2;
							return setEmitFlags(
								factory.createTypeLiteralNode( /*members*/ undefined),
								EmitFlags.SingleLine,
							);
						}
						if (
							resolved.callSignatures.length === 1 && !resolved.constructSignatures.length
						) {
							var signature = resolved.callSignatures[0];
							var signatureNode = signatureToSignatureDeclarationHelper(
								signature,
								SyntaxKind.FunctionType,
								context,
							);
							return signatureNode;
						}
						if (
							resolved.constructSignatures.length === 1 && !resolved.callSignatures.length
						) {
							var signature = resolved.constructSignatures[0];
							var signatureNode = signatureToSignatureDeclarationHelper(
								signature,
								SyntaxKind.ConstructorType,
								context,
							);
							return signatureNode;
						}
					}
					var abstractSignatures = filter(
						resolved.constructSignatures,
						function (signature) {
							return !!(signature.flags & SignatureFlags.Abstract);
						},
					);
					if (some(abstractSignatures)) {
						var types = map(abstractSignatures, getOrCreateTypeFromSignature);
						// count the number of type elements excluding abstract constructors
						var typeElementCount = resolved.callSignatures.length + (resolved.constructSignatures.length - abstractSignatures.length) + resolved.indexInfos.length + (context.flags & NodeBuilderFlags.WriteClassExpressionAsTypeLiteral ? countWhere( // the logic in `createTypeNodesFromResolvedType`. // exclude `prototype` when writing a class expression as a type literal, as per
							resolved.properties,
							function (p) {
								return !(p.flags & SymbolFlags.Prototype);
							},
						) : length(resolved.properties));
						// don't include an empty object literal if there were no other static-side
						// properties to write, i.e. `abstract class C { }` becomes `abstract new () => {}`
						// and not `(abstract new () => {}) & {}`
						if (typeElementCount) {
							// create a copy of the object type without any abstract construct signatures.
							types.push(
								getResolvedTypeWithoutAbstractConstructSignatures(resolved),
							);
						}
						return typeToTypeNodeHelper(getIntersectionType(types), context);
					}
					var savedFlags = context.flags;
					context.flags |= NodeBuilderFlags.InObjectTypeLiteral;
					var members = createTypeNodesFromResolvedType(resolved);
					context.flags = savedFlags;
					var typeLiteralNode = factory.createTypeLiteralNode(members);
					context.approximateLength += 2;
					setEmitFlags(
						typeLiteralNode,
						(context.flags & NodeBuilderFlags.MultilineObjectLiterals) ? 0 : EmitFlags.SingleLine,
					);
					return typeLiteralNode;
				}
				function typeReferenceToTypeNode(type) {
					var typeArguments = getTypeArguments(type);
					if (
						type.target === globalArrayType || type.target === globalReadonlyArrayType
					) {
						if (context.flags & NodeBuilderFlags.WriteArrayAsGenericType) {
							var typeArgumentNode = typeToTypeNodeHelper(
								typeArguments[0],
								context,
							);
							return factory.createTypeReferenceNode(
								type.target === globalArrayType ? "Array" : "ReadonlyArray",
								[typeArgumentNode],
							);
						}
						var elementType = typeToTypeNodeHelper(typeArguments[0], context);
						var arrayType = factory.createArrayTypeNode(elementType);
						return type.target === globalArrayType ? arrayType : factory.createTypeOperatorNode(
							SyntaxKind.ReadonlyKeyword,
							arrayType,
						);
					} else if (type.target.objectFlags & ObjectFlags.Tuple) {
						typeArguments = sameMap(
							typeArguments,
							function (t, i) {
								return removeMissingType(
									t,
									!!(type.target.elementFlags[i] & ElementFlags.Optional),
								);
							},
						);
						if (typeArguments.length > 0) {
							var arity = getTypeReferenceArity(type);
							var tupleConstituentNodes = mapToTypeNodes(
								typeArguments.slice(0, arity),
								context,
							);
							if (tupleConstituentNodes) {
								if (type.target.labeledElementDeclarations) {
									for (var i = 0; i < tupleConstituentNodes.length; i++) {
										var flags = type.target.elementFlags[i];
										tupleConstituentNodes[i] = factory.createNamedTupleMember(
											flags & ElementFlags.Variable ? factory.createToken(
												SyntaxKind.DotDotDotToken,
											) : undefined,
											factory.createIdentifier(
												unescapeLeadingUnderscores(
													getTupleElementLabel(
														type.target.labeledElementDeclarations[i],
													),
												),
											),
											flags & ElementFlags.Optional ? factory.createToken(
												SyntaxKind.QuestionToken,
											) : undefined,
											flags & ElementFlags.Rest ? factory.createArrayTypeNode(
												tupleConstituentNodes[i],
											) : tupleConstituentNodes[i],
										);
									}
								} else {
									for (
										var i = 0;
										i < Math.min(arity, tupleConstituentNodes.length);
										i++
									) {
										var flags = type.target.elementFlags[i];
										tupleConstituentNodes[i] = flags & ElementFlags.Variable ? factory.createRestTypeNode(
											flags & ElementFlags.Rest ? factory.createArrayTypeNode(
												tupleConstituentNodes[i],
											) : tupleConstituentNodes[i],
										) : flags & ElementFlags.Optional ? factory.createOptionalTypeNode(
											tupleConstituentNodes[i],
										) : tupleConstituentNodes[i];
									}
								}
								var tupleTypeNode = setEmitFlags(
									factory.createTupleTypeNode(tupleConstituentNodes),
									EmitFlags.SingleLine,
								);
								return type.target.readonly ? factory.createTypeOperatorNode(
									SyntaxKind.ReadonlyKeyword,
									tupleTypeNode,
								) : tupleTypeNode;
							}
						}
						if (
							context.encounteredError || (context.flags & NodeBuilderFlags.AllowEmptyTuple)
						) {
							var tupleTypeNode = setEmitFlags(
								factory.createTupleTypeNode([]),
								EmitFlags.SingleLine,
							);
							return type.target.readonly ? factory.createTypeOperatorNode(
								SyntaxKind.ReadonlyKeyword,
								tupleTypeNode,
							) : tupleTypeNode;
						}
						context.encounteredError = true;
						return undefined; // TODO: GH#18217
					} else if (
						context.flags & NodeBuilderFlags.WriteClassExpressionAsTypeLiteral && type.symbol.valueDeclaration && isClassLike(
							type.symbol.valueDeclaration,
						) && !isValueSymbolAccessible(
							type.symbol,
							context.enclosingDeclaration,
						)
					) {
						return createAnonymousTypeNode(type);
					} else {
						var outerTypeParameters = type.target.outerTypeParameters;
						var i = 0;
						var resultType = void 0;
						if (outerTypeParameters) {
							var length_1 = outerTypeParameters.length;
							while (i < length_1) {
								// Find group of type arguments for type parameters with the same declaring container.
								var start = i;
								var parent_3 = getParentSymbolOfTypeParameter(
									outerTypeParameters[i],
								);
								do {
									i++;
								} while (
									i < length_1 && getParentSymbolOfTypeParameter(
										outerTypeParameters[i],
									) === parent_3
								);
								// When type parameters are their own type arguments for the whole group (i.e. we have
								// the default outer type arguments), we don't show the group.
								if (!rangeEquals(outerTypeParameters, typeArguments, start, i)) {
									var typeArgumentSlice = mapToTypeNodes(
										typeArguments.slice(start, i),
										context,
									);
									var flags_1 = context.flags;
									context.flags |= NodeBuilderFlags.ForbidIndexedAccessSymbolReferences;
									var ref = symbolToTypeNode(
										parent_3,
										context,
										SymbolFlags.Type,
										typeArgumentSlice,
									);
									context.flags = flags_1;
									resultType = !resultType ? ref : appendReferenceToType(
										resultType,
										ref,
									);
								}
							}
						}
						var typeArgumentNodes = void 0;
						if (typeArguments.length > 0) {
							var typeParameterCount = (type.target.typeParameters || emptyArray).length;
							typeArgumentNodes = mapToTypeNodes(
								typeArguments.slice(i, typeParameterCount),
								context,
							);
						}
						var flags = context.flags;
						context.flags |= NodeBuilderFlags.ForbidIndexedAccessSymbolReferences;
						var finalRef = symbolToTypeNode(
							type.symbol,
							context,
							SymbolFlags.Type,
							typeArgumentNodes,
						);
						context.flags = flags;
						return !resultType ? finalRef : appendReferenceToType(
							resultType,
							finalRef,
						);
					}
				}
				function appendReferenceToType(root, ref) {
					if (isImportTypeNode(root)) {
						// first shift type arguments
						var typeArguments = root.typeArguments;
						var qualifier = root.qualifier;
						if (qualifier) {
							if (isIdentifier(qualifier)) {
								qualifier = factory.updateIdentifier(qualifier, typeArguments);
							} else {
								qualifier = factory.updateQualifiedName(
									qualifier,
									qualifier.left,
									factory.updateIdentifier(qualifier.right, typeArguments),
								);
							}
						}
						typeArguments = ref.typeArguments;
						// then move qualifiers
						var ids = getAccessStack(ref);
						for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
							var id = ids_1[_i];
							qualifier = qualifier ? factory.createQualifiedName(qualifier, id) : id;
						}
						return factory.updateImportTypeNode(
							root,
							root.argument,
							qualifier,
							typeArguments,
							root.isTypeOf,
						);
					} else {
						// first shift type arguments
						var typeArguments = root.typeArguments;
						var typeName = root.typeName;
						if (isIdentifier(typeName)) {
							typeName = factory.updateIdentifier(typeName, typeArguments);
						} else {
							typeName = factory.updateQualifiedName(
								typeName,
								typeName.left,
								factory.updateIdentifier(typeName.right, typeArguments),
							);
						}
						typeArguments = ref.typeArguments;
						// then move qualifiers
						var ids = getAccessStack(ref);
						for (var _a = 0, ids_2 = ids; _a < ids_2.length; _a++) {
							var id = ids_2[_a];
							typeName = factory.createQualifiedName(typeName, id);
						}
						return factory.updateTypeReferenceNode(
							root,
							typeName,
							typeArguments,
						);
					}
				}
				function getAccessStack(ref) {
					var state = ref.typeName;
					var ids = [];
					while (!isIdentifier(state)) {
						ids.unshift(state.right);
						state = state.left;
					}
					ids.unshift(state);
					return ids;
				}
				function createTypeNodesFromResolvedType(resolvedType) {
					if (checkTruncationLength(context)) {
						return [
							factory.createPropertySignature(
								undefined, /*modifiers*/
								"...", /*questionToken*/
								undefined, /*type*/
								undefined,
							),
						];
					}
					var typeElements = [];
					for (
						var _i = 0, _a = resolvedType.callSignatures;
						_i < _a.length;
						_i++
					) {
						var signature = _a[_i];
						typeElements.push(
							signatureToSignatureDeclarationHelper(
								signature,
								SyntaxKind.CallSignature,
								context,
							),
						);
					}
					for (
						var _b = 0, _c = resolvedType.constructSignatures;
						_b < _c.length;
						_b++
					) {
						var signature = _c[_b];
						if (signature.flags & SignatureFlags.Abstract) continue;
						typeElements.push(
							signatureToSignatureDeclarationHelper(
								signature,
								SyntaxKind.ConstructSignature,
								context,
							),
						);
					}
					for (var _d = 0, _e = resolvedType.indexInfos; _d < _e.length; _d++) {
						var info = _e[_d];
						typeElements.push(
							indexInfoToIndexSignatureDeclarationHelper(
								info,
								context,
								resolvedType.objectFlags & ObjectFlags.ReverseMapped ? createElidedInformationPlaceholder(
									context,
								) : undefined,
							),
						);
					}
					var properties = resolvedType.properties;
					if (!properties) {
						return typeElements;
					}
					var i = 0;
					for (
						var _f = 0, properties_1 = properties;
						_f < properties_1.length;
						_f++
					) {
						var propertySymbol = properties_1[_f];
						i++;
						if (
							context.flags & NodeBuilderFlags.WriteClassExpressionAsTypeLiteral
						) {
							if (propertySymbol.flags & SymbolFlags.Prototype) {
								continue;
							}
							if (
								getDeclarationModifierFlagsFromSymbol(propertySymbol) & (ModifierFlags.Private | ModifierFlags.Protected) && context.tracker.reportPrivateInBaseOfClassExpression
							) {
								context.tracker.reportPrivateInBaseOfClassExpression(
									unescapeLeadingUnderscores(propertySymbol.escapedName),
								);
							}
						}
						if (
							checkTruncationLength(context) && (i + 2 < properties.length - 1)
						) {
							typeElements.push(
								factory.createPropertySignature(
									undefined, /*modifiers*/
									"... ".concat(properties.length - i, " more ..."), /*questionToken*/
									undefined, /*type*/
									undefined,
								),
							);
							addPropertyToElementList(
								properties[properties.length - 1],
								context,
								typeElements,
							);
							break;
						}
						addPropertyToElementList(propertySymbol, context, typeElements);
					}
					return typeElements.length ? typeElements : undefined;
				}
			}
			function createElidedInformationPlaceholder(context) {
				context.approximateLength += 3;
				if (!(context.flags & NodeBuilderFlags.NoTruncation)) {
					return factory.createTypeReferenceNode(
						factory.createIdentifier("..."), /*typeArguments*/
						undefined,
					);
				}
				return factory.createKeywordTypeNode(SyntaxKind.AnyKeyword);
			}
			function shouldUsePlaceholderForProperty(propertySymbol, context) {
				var _a;
				// Use placeholders for reverse mapped types we've either already descended into, or which
				// are nested reverse mappings within a mapping over a non-anonymous type. The later is a restriction mostly just to
				// reduce the blowup in printback size from doing, eg, a deep reverse mapping over `Window`.
				// Since anonymous types usually come from expressions, this allows us to preserve the output
				// for deep mappings which likely come from expressions, while truncating those parts which
				// come from mappings over library functions.
				return !!(getCheckFlags(propertySymbol) & CheckFlags.ReverseMapped) && (contains(
					context.reverseMappedStack,
					propertySymbol,
				) || (((_a = context.reverseMappedStack) === null || _a === void 0 ? void 0 : _a[0]) && !(getObjectFlags(
					last(context.reverseMappedStack).propertyType,
				) & ObjectFlags.Anonymous)));
			}
			function addPropertyToElementList(propertySymbol, context, typeElements) {
				var _a, _b;
				var propertyIsReverseMapped = !!(getCheckFlags(propertySymbol) & CheckFlags.ReverseMapped);
				var propertyType = shouldUsePlaceholderForProperty(
					propertySymbol,
					context,
				) ? anyType : getNonMissingTypeOfSymbol(propertySymbol);
				var saveEnclosingDeclaration = context.enclosingDeclaration;
				context.enclosingDeclaration = undefined;
				if (
					context.tracker.trackSymbol && getCheckFlags(propertySymbol) & CheckFlags.Late && isLateBoundName(
						propertySymbol.escapedName,
					)
				) {
					if (propertySymbol.declarations) {
						var decl = first(propertySymbol.declarations);
						if (hasLateBindableName(decl)) {
							if (isBinaryExpression(decl)) {
								var name_4 = getNameOfDeclaration(decl);
								if (
									name_4 && isElementAccessExpression(name_4) && isPropertyAccessEntityNameExpression(
										name_4.argumentExpression,
									)
								) {
									trackComputedName(
										name_4.argumentExpression,
										saveEnclosingDeclaration,
										context,
									);
								}
							} else {
								trackComputedName(
									decl.name.expression,
									saveEnclosingDeclaration,
									context,
								);
							}
						}
					} else if (
						(_a = context.tracker) === null || _a === void 0 ? void 0 : _a.reportNonSerializableProperty
					) {
						context.tracker.reportNonSerializableProperty(
							symbolToString(propertySymbol),
						);
					}
				}
				context.enclosingDeclaration = propertySymbol.valueDeclaration || ((_b = propertySymbol.declarations) === null || _b === void 0 ? void 0 : _b[0]) || saveEnclosingDeclaration;
				var propertyName = getPropertyNameNodeForSymbol(propertySymbol, context);
				context.enclosingDeclaration = saveEnclosingDeclaration;
				context.approximateLength += (symbolName(propertySymbol).length + 1);
				var optionalToken = propertySymbol.flags & SymbolFlags.Optional ? factory.createToken(
					SyntaxKind.QuestionToken,
				) : undefined;
				if (
					propertySymbol.flags & (SymbolFlags.Function | SymbolFlags.Method) && !getPropertiesOfObjectType(
						propertyType,
					).length && !isReadonlySymbol(propertySymbol)
				) {
					var signatures = getSignaturesOfType(
						filterType(
							propertyType,
							function (t) {
								return !(t.flags & TypeFlags.Undefined);
							},
						),
						SignatureKind.Call,
					);
					for (
						var _i = 0, signatures_1 = signatures;
						_i < signatures_1.length;
						_i++
					) {
						var signature = signatures_1[_i];
						var methodDeclaration = signatureToSignatureDeclarationHelper(
							signature,
							SyntaxKind.MethodSignature,
							context,
							{ name: propertyName, questionToken: optionalToken },
						);
						typeElements.push(preserveCommentsOn(methodDeclaration));
					}
				} else {
					var propertyTypeNode = void 0;
					if (shouldUsePlaceholderForProperty(propertySymbol, context)) {
						propertyTypeNode = createElidedInformationPlaceholder(context);
					} else {
						if (propertyIsReverseMapped) {
							context.reverseMappedStack || (context.reverseMappedStack = []);
							context.reverseMappedStack.push(propertySymbol);
						}
						propertyTypeNode = propertyType ? serializeTypeForDeclaration(
							context,
							propertyType,
							propertySymbol,
							saveEnclosingDeclaration,
						) : factory.createKeywordTypeNode(SyntaxKind.AnyKeyword);
						if (propertyIsReverseMapped) {
							context.reverseMappedStack.pop();
						}
					}
					var modifiers = isReadonlySymbol(propertySymbol) ? [
						factory.createToken(SyntaxKind.ReadonlyKeyword),
					] : undefined;
					if (modifiers) {
						context.approximateLength += 9;
					}
					var propertySignature = factory.createPropertySignature(
						modifiers,
						propertyName,
						optionalToken,
						propertyTypeNode,
					);
					typeElements.push(preserveCommentsOn(propertySignature));
				}
				function preserveCommentsOn(node) {
					var _a;
					if (
						some(
							propertySymbol.declarations,
							function (d) {
								return d.kind === SyntaxKind.JSDocPropertyTag;
							},
						)
					) {
						var d = (_a = propertySymbol.declarations) === null || _a === void 0 ? void 0 : _a.find(
							function (d) {
								return d.kind === SyntaxKind.JSDocPropertyTag;
							},
						);
						var commentText = getTextOfJSDocComment(d.comment);
						if (commentText) {
							setSyntheticLeadingComments(node, [{ kind: SyntaxKind.MultiLineCommentTrivia, text: "*\n * " + commentText.replace(/\n/g, "\n * ") + "\n ", pos: -1, end: -1, hasTrailingNewLine: true }]);
						}
					} else if (propertySymbol.valueDeclaration) {
						// Copy comments to node for declaration emit
						setCommentRange(node, propertySymbol.valueDeclaration);
					}
					return node;
				}
			}
			function mapToTypeNodes(types, context, isBareList) {
				if (some(types)) {
					if (checkTruncationLength(context)) {
						if (!isBareList) {
							return [
								factory.createTypeReferenceNode(
									"...", /*typeArguments*/
									undefined,
								),
							];
						} else if (types.length > 2) {
							return [
								typeToTypeNodeHelper(types[0], context),
								factory.createTypeReferenceNode(
									"... ".concat(types.length - 2, " more ..."), /*typeArguments*/
									undefined,
								),
								typeToTypeNodeHelper(types[types.length - 1], context),
							];
						}
					}
					var mayHaveNameCollisions = !(context.flags & NodeBuilderFlags.UseFullyQualifiedType);
					/** Map from type reference identifier text to [type, index in `result` where the type node is] */
					var seenNames = mayHaveNameCollisions ? createUnderscoreEscapedMultiMap() : undefined;
					var result_1 = [];
					var i = 0;
					for (var _i = 0, types_2 = types; _i < types_2.length; _i++) {
						var type = types_2[_i];
						i++;
						if (checkTruncationLength(context) && (i + 2 < types.length - 1)) {
							result_1.push(
								factory.createTypeReferenceNode(
									"... ".concat(types.length - i, " more ..."), /*typeArguments*/
									undefined,
								),
							);
							var typeNode_1 = typeToTypeNodeHelper(
								types[types.length - 1],
								context,
							);
							if (typeNode_1) {
								result_1.push(typeNode_1);
							}
							break;
						}
						context.approximateLength += 2; // Account for whitespace + separator
						var typeNode = typeToTypeNodeHelper(type, context);
						if (typeNode) {
							result_1.push(typeNode);
							if (seenNames && isIdentifierTypeReference(typeNode)) {
								seenNames.add(
									typeNode.typeName.escapedText,
									[type, result_1.length - 1],
								);
							}
						}
					}
					if (seenNames) {
						// To avoid printing types like `[Foo, Foo]` or `Bar & Bar` where
						// occurrences of the same name actually come from different
						// namespaces, go through the single-identifier type reference nodes
						// we just generated, and see if any names were generated more than
						// once while referring to different types. If so, regenerate the
						// type node for each entry by that name with the
						// `UseFullyQualifiedType` flag enabled.
						var saveContextFlags = context.flags;
						context.flags |= NodeBuilderFlags.UseFullyQualifiedType;
						seenNames.forEach(
							function (types) {
								if (
									!arrayIsHomogeneous(
										types,
										function (_a, _b) {
											var a = _a[0];
											var b = _b[0];
											return typesAreSameReference(a, b);
										},
									)
								) {
									for (var _i = 0, types_3 = types; _i < types_3.length; _i++) {
										var _a = types_3[_i], type = _a[0], resultIndex = _a[1];
										result_1[resultIndex] = typeToTypeNodeHelper(type, context);
									}
								}
							},
						);
						context.flags = saveContextFlags;
					}
					return result_1;
				}
			}
			function typesAreSameReference(a, b) {
				return a === b || !!a.symbol && a.symbol === b.symbol || !!a.aliasSymbol && a.aliasSymbol === b.aliasSymbol;
			}
			function indexInfoToIndexSignatureDeclarationHelper(
				indexInfo,
				context,
				typeNode,
			) {
				var name = getNameFromIndexInfo(indexInfo) || "x";
				var indexerTypeNode = typeToTypeNodeHelper(indexInfo.keyType, context);
				var indexingParameter = factory.createParameterDeclaration(
					/*decorators*/ undefined,
					/*modifiers*/ undefined,
					/*dotDotDotToken*/ undefined,
					name,
					/*questionToken*/ undefined,
					indexerTypeNode,
					/*initializer*/ undefined,
				);
				if (!typeNode) {
					typeNode = typeToTypeNodeHelper(indexInfo.type || anyType, context);
				}
				if (
					!indexInfo.type && !(context.flags & NodeBuilderFlags.AllowEmptyIndexInfoType)
				) {
					context.encounteredError = true;
				}
				context.approximateLength += (name.length + 4);
				return factory.createIndexSignature(
					/*decorators*/ undefined,
					indexInfo.isReadonly ? [
						factory.createToken(SyntaxKind.ReadonlyKeyword),
					] : undefined,
					[indexingParameter],
					typeNode,
				);
			}
			function signatureToSignatureDeclarationHelper(
				signature,
				kind,
				context,
				options,
			) {
				var _a, _b, _c, _d;
				var suppressAny = context.flags & NodeBuilderFlags.SuppressAnyReturnType;
				if (suppressAny) context.flags &= ~NodeBuilderFlags.SuppressAnyReturnType; // suppress only toplevel `any`s
				context.approximateLength += 3; // Usually a signature contributes a few more characters than this, but 3 is the minimum
				var typeParameters;
				var typeArguments;
				if (
					context.flags & NodeBuilderFlags.WriteTypeArgumentsOfSignature && signature.target && signature.mapper && signature.target.typeParameters
				) {
					typeArguments = signature.target.typeParameters.map(
						function (parameter) {
							return typeToTypeNodeHelper(
								instantiateType(parameter, signature.mapper),
								context,
							);
						},
					);
				} else {
					typeParameters = signature.typeParameters && signature.typeParameters.map(
						function (parameter) {
							return typeParameterToDeclaration(parameter, context);
						},
					);
				}
				var expandedParams = getExpandedParameters(
					signature, /*skipUnionExpanding*/
					true,
				)[0];
				// If the expanded parameter list had a variadic in a non-trailing position, don't expand it
				var parameters = (some(
					expandedParams,
					function (p) {
						return p !== expandedParams[expandedParams.length - 1] && !!(getCheckFlags(
							p,
						) & CheckFlags.RestParameter);
					},
				) ? signature.parameters : expandedParams).map(
					function (parameter) {
						return symbolToParameterDeclaration(
							parameter,
							context,
							kind === SyntaxKind.Constructor,
							options === null || options === void 0 ? void 0 : options.privateSymbolVisitor,
							options === null || options === void 0 ? void 0 : options.bundledImports,
						);
					},
				);
				var thisParameter = tryGetThisParameterDeclaration(signature, context);
				if (thisParameter) {
					parameters.unshift(thisParameter);
				}
				var returnTypeNode;
				var typePredicate = getTypePredicateOfSignature(signature);
				if (typePredicate) {
					var assertsModifier = typePredicate.kind === TypePredicateKind.AssertsThis || typePredicate.kind === TypePredicateKind.AssertsIdentifier ? factory.createToken(
						SyntaxKind.AssertsKeyword,
					) : undefined;
					var parameterName = typePredicate.kind === TypePredicateKind.Identifier || typePredicate.kind === TypePredicateKind.AssertsIdentifier ? setEmitFlags(
						factory.createIdentifier(typePredicate.parameterName),
						EmitFlags.NoAsciiEscaping,
					) : factory.createThisTypeNode();
					var typeNode = typePredicate.type && typeToTypeNodeHelper(
						typePredicate.type,
						context,
					);
					returnTypeNode = factory.createTypePredicateNode(
						assertsModifier,
						parameterName,
						typeNode,
					);
				} else {
					var returnType = getReturnTypeOfSignature(signature);
					if (returnType && !(suppressAny && isTypeAny(returnType))) {
						returnTypeNode = serializeReturnTypeForSignature(
							context,
							returnType,
							signature,
							options === null || options === void 0 ? void 0 : options.privateSymbolVisitor,
							options === null || options === void 0 ? void 0 : options.bundledImports,
						);
					} else if (!suppressAny) {
						returnTypeNode = factory.createKeywordTypeNode(
							SyntaxKind.AnyKeyword,
						);
					}
				}
				var modifiers = options === null || options === void 0 ? void 0 : options.modifiers;
				if (
					(kind === SyntaxKind.ConstructorType) && signature.flags & SignatureFlags.Abstract
				) {
					var flags = modifiersToFlags(modifiers);
					modifiers = factory.createModifiersFromModifierFlags(
						flags | ModifierFlags.Abstract,
					);
				}
				var node = kind === SyntaxKind.CallSignature ? factory.createCallSignature(
					typeParameters,
					parameters,
					returnTypeNode,
				) : kind === SyntaxKind.ConstructSignature ? factory.createConstructSignature(
					typeParameters,
					parameters,
					returnTypeNode,
				) : kind === SyntaxKind.MethodSignature ? factory.createMethodSignature(
					modifiers,
					(_a = options === null || options === void 0 ? void 0 : options.name) !== null && _a !== void 0 ? _a : factory.createIdentifier(
						"",
					),
					options === null || options === void 0 ? void 0 : options.questionToken,
					typeParameters,
					parameters,
					returnTypeNode,
				) : kind === SyntaxKind.MethodDeclaration ? factory.createMethodDeclaration(
					undefined, /*decorators*/
					modifiers, /*asteriskToken*/
					undefined,
					(_b = options === null || options === void 0 ? void 0 : options.name) !== null && _b !== void 0 ? _b : factory.createIdentifier(
						"",
					), /*questionToken*/
					undefined,
					typeParameters,
					parameters,
					returnTypeNode, /*body*/
					undefined,
				) : kind === SyntaxKind.Constructor ? factory.createConstructorDeclaration(
					undefined, /*decorators*/
					modifiers,
					parameters, /*body*/
					undefined,
				) : kind === SyntaxKind.GetAccessor ? factory.createGetAccessorDeclaration(
					undefined, /*decorators*/
					modifiers,
					(_c = options === null || options === void 0 ? void 0 : options.name) !== null && _c !== void 0 ? _c : factory.createIdentifier(
						"",
					),
					parameters,
					returnTypeNode, /*body*/
					undefined,
				) : kind === SyntaxKind.SetAccessor ? factory.createSetAccessorDeclaration(
					undefined, /*decorators*/
					modifiers,
					(_d = options === null || options === void 0 ? void 0 : options.name) !== null && _d !== void 0 ? _d : factory.createIdentifier(
						"",
					),
					parameters, /*body*/
					undefined,
				) : kind === SyntaxKind.IndexSignature ? factory.createIndexSignature(
					undefined, /*decorators*/
					modifiers,
					parameters,
					returnTypeNode,
				) : kind === SyntaxKind.JSDocFunctionType ? factory.createJSDocFunctionType(
					parameters,
					returnTypeNode,
				) : kind === SyntaxKind.FunctionType ? factory.createFunctionTypeNode(
					typeParameters,
					parameters,
					returnTypeNode !== null && returnTypeNode !== void 0 ? returnTypeNode : factory.createTypeReferenceNode(
						factory.createIdentifier(""),
					),
				) : kind === SyntaxKind.ConstructorType ? factory.createConstructorTypeNode(
					modifiers,
					typeParameters,
					parameters,
					returnTypeNode !== null && returnTypeNode !== void 0 ? returnTypeNode : factory.createTypeReferenceNode(
						factory.createIdentifier(""),
					),
				) : kind === SyntaxKind.FunctionDeclaration ? factory.createFunctionDeclaration(
					undefined, /*decorators*/
					modifiers, /*asteriskToken*/
					undefined,
					(options === null || options === void 0 ? void 0 : options.name) ? cast(
						options.name,
						isIdentifier,
					) : factory.createIdentifier(""),
					typeParameters,
					parameters,
					returnTypeNode, /*body*/
					undefined,
				) : kind === SyntaxKind.FunctionExpression ? factory.createFunctionExpression(
					modifiers, /*asteriskToken*/
					undefined,
					(options === null || options === void 0 ? void 0 : options.name) ? cast(
						options.name,
						isIdentifier,
					) : factory.createIdentifier(""),
					typeParameters,
					parameters,
					returnTypeNode,
					factory.createBlock([]),
				) : kind === SyntaxKind.ArrowFunction ? factory.createArrowFunction(
					modifiers,
					typeParameters,
					parameters,
					returnTypeNode, /*equalsGreaterThanToken*/
					undefined,
					factory.createBlock([]),
				) : Debug.assertNever(kind);
				if (typeArguments) {
					node.typeArguments = factory.createNodeArray(typeArguments);
				}
				return node;
			}
			function tryGetThisParameterDeclaration(signature, context) {
				if (signature.thisParameter) {
					return symbolToParameterDeclaration(signature.thisParameter, context);
				}
				if (signature.declaration) {
					var thisTag = getJSDocThisTag(signature.declaration);
					if (thisTag && thisTag.typeExpression) {
						return factory.createParameterDeclaration(
							/* decorators */ undefined,
							/* modifiers */ undefined,
							/* dotDotDotToken */ undefined,
							"this",
							/* questionToken */ undefined,
							typeToTypeNodeHelper(
								getTypeFromTypeNode(thisTag.typeExpression),
								context,
							),
						);
					}
				}
			}
			function typeParameterToDeclarationWithConstraint(
				type,
				context,
				constraintNode,
			) {
				var savedContextFlags = context.flags;
				context.flags &= ~NodeBuilderFlags.WriteTypeParametersInQualifiedName; // Avoids potential infinite loop when building for a claimspace with a generic
				var name = typeParameterToName(type, context);
				var defaultParameter = getDefaultFromTypeParameter(type);
				var defaultParameterNode = defaultParameter && typeToTypeNodeHelper(
					defaultParameter,
					context,
				);
				context.flags = savedContextFlags;
				return factory.createTypeParameterDeclaration(
					name,
					constraintNode,
					defaultParameterNode,
				);
			}
			function typeParameterToDeclaration(type, context, constraint) {
				if (constraint === void 0) {
					constraint = getConstraintOfTypeParameter(type);
				}
				var constraintNode = constraint && typeToTypeNodeHelper(
					constraint,
					context,
				);
				return typeParameterToDeclarationWithConstraint(
					type,
					context,
					constraintNode,
				);
			}
			function symbolToParameterDeclaration(
				parameterSymbol,
				context,
				preserveModifierFlags,
				privateSymbolVisitor,
				bundledImports,
			) {
				var parameterDeclaration = getDeclarationOfKind(
					parameterSymbol,
					SyntaxKind.Parameter,
				);
				if (!parameterDeclaration && !isTransientSymbol(parameterSymbol)) {
					parameterDeclaration = getDeclarationOfKind(
						parameterSymbol,
						SyntaxKind.JSDocParameterTag,
					);
				}
				var parameterType = getTypeOfSymbol(parameterSymbol);
				if (
					parameterDeclaration && isRequiredInitializedParameter(
						parameterDeclaration,
					)
				) {
					parameterType = getOptionalType(parameterType);
				}
				if (
					(context.flags & NodeBuilderFlags.NoUndefinedOptionalParameterType) && parameterDeclaration && !isJSDocParameterTag(
						parameterDeclaration,
					) && isOptionalUninitializedParameter(parameterDeclaration)
				) {
					parameterType = getTypeWithFacts(
						parameterType,
						524288, /* NEUndefined */
					);
				}
				var parameterTypeNode = serializeTypeForDeclaration(
					context,
					parameterType,
					parameterSymbol,
					context.enclosingDeclaration,
					privateSymbolVisitor,
					bundledImports,
				);
				var modifiers = !(context.flags & NodeBuilderFlags.OmitParameterModifiers) && preserveModifierFlags && parameterDeclaration && parameterDeclaration.modifiers ? parameterDeclaration.modifiers.map(
					factory.cloneNode,
				) : undefined;
				var isRest = parameterDeclaration && isRestParameter(
					parameterDeclaration,
				) || getCheckFlags(parameterSymbol) & CheckFlags.RestParameter;
				var dotDotDotToken = isRest ? factory.createToken(
					SyntaxKind.DotDotDotToken,
				) : undefined;
				var name = parameterDeclaration ? parameterDeclaration.name ? parameterDeclaration.name.kind === SyntaxKind.Identifier ? setEmitFlags(
					factory.cloneNode(parameterDeclaration.name),
					EmitFlags.NoAsciiEscaping,
				) : parameterDeclaration.name.kind === SyntaxKind.QualifiedName ? setEmitFlags(
					factory.cloneNode(parameterDeclaration.name.right),
					EmitFlags.NoAsciiEscaping,
				) : cloneBindingName(parameterDeclaration.name) : symbolName(
					parameterSymbol,
				) : symbolName(parameterSymbol);
				var isOptional = parameterDeclaration && isOptionalParameter(
					parameterDeclaration,
				) || getCheckFlags(parameterSymbol) & CheckFlags.OptionalParameter;
				var questionToken = isOptional ? factory.createToken(
					SyntaxKind.QuestionToken,
				) : undefined;
				var parameterNode = factory.createParameterDeclaration(
					/*decorators*/ undefined,
					modifiers,
					dotDotDotToken,
					name,
					questionToken,
					parameterTypeNode,
					/*initializer*/ undefined,
				);
				context.approximateLength += symbolName(parameterSymbol).length + 3;
				return parameterNode;
				function cloneBindingName(node) {
					return elideInitializerAndSetEmitFlags(node);
					function elideInitializerAndSetEmitFlags(node) {
						if (
							context.tracker.trackSymbol && isComputedPropertyName(node) && isLateBindableName(
								node,
							)
						) {
							trackComputedName(
								node.expression,
								context.enclosingDeclaration,
								context,
							);
						}
						var visited = visitEachChild(
							node,
							elideInitializerAndSetEmitFlags,
							nullTransformationContext, /*nodesVisitor*/
							undefined,
							elideInitializerAndSetEmitFlags,
						);
						if (isBindingElement(visited)) {
							visited = factory.updateBindingElement(
								visited,
								visited.dotDotDotToken,
								visited.propertyName,
								visited.name,
								/*initializer*/ undefined,
							);
						}
						if (!nodeIsSynthesized(visited)) {
							visited = factory.cloneNode(visited);
						}
						return setEmitFlags(
							visited,
							EmitFlags.SingleLine | EmitFlags.NoAsciiEscaping,
						);
					}
				}
			}
			function trackComputedName(
				accessExpression,
				enclosingDeclaration,
				context,
			) {
				if (!context.tracker.trackSymbol) return;
				// get symbol of the first identifier of the entityName
				var firstIdentifier = getFirstIdentifier(accessExpression);
				var name = resolveName(
					firstIdentifier,
					firstIdentifier.escapedText,
					SymbolFlags.Value | SymbolFlags.ExportValue, /*nodeNotFoundErrorMessage*/
					undefined, /*nameArg*/
					undefined, /*isUse*/
					true,
				);
				if (name) {
					context.tracker.trackSymbol(
						name,
						enclosingDeclaration,
						SymbolFlags.Value,
					);
				}
			}
			function lookupSymbolChain(symbol, context, meaning, yieldModuleSymbol) {
				context.tracker.trackSymbol(
					symbol,
					context.enclosingDeclaration,
					meaning,
				); // TODO: GH#18217
				return lookupSymbolChainWorker(
					symbol,
					context,
					meaning,
					yieldModuleSymbol,
				);
			}
			function lookupSymbolChainWorker(
				symbol,
				context,
				meaning,
				yieldModuleSymbol,
			) {
				// Try to get qualified name if the symbol is not a type parameter and there is an enclosing declaration.
				var chain;
				var isTypeParameter = symbol.flags & SymbolFlags.TypeParameter;
				if (
					!isTypeParameter && (context.enclosingDeclaration || context.flags & NodeBuilderFlags.UseFullyQualifiedType) && !(context.flags & NodeBuilderFlags.DoNotIncludeSymbolChain)
				) {
					chain = Debug.checkDefined(
						getSymbolChain(symbol, meaning, /*endOfChain*/ true),
					);
					Debug.assert(chain && chain.length > 0);
				} else {
					chain = [symbol];
				}
				return chain;
				/** @param endOfChain Set to false for recursive calls; non-recursive calls should always output something. */
				function getSymbolChain(symbol, meaning, endOfChain) {
					var accessibleSymbolChain = getAccessibleSymbolChain(
						symbol,
						context.enclosingDeclaration,
						meaning,
						!!(context.flags & NodeBuilderFlags.UseOnlyExternalAliasing),
					);
					var parentSpecifiers;
					if (
						!accessibleSymbolChain || needsQualification(
							accessibleSymbolChain[0],
							context.enclosingDeclaration,
							accessibleSymbolChain.length === 1 ? meaning : getQualifiedLeftMeaning(
								meaning,
							),
						)
					) {
						// Go up and add our parent.
						var parents_1 = getContainersOfSymbol(
							accessibleSymbolChain ? accessibleSymbolChain[0] : symbol,
							context.enclosingDeclaration,
							meaning,
						);
						if (length(parents_1)) {
							parentSpecifiers = parents_1.map(
								function (symbol) {
									return some(
										symbol.declarations,
										hasNonGlobalAugmentationExternalModuleSymbol,
									) ? getSpecifierForModuleSymbol(symbol, context) : undefined;
								},
							);
							var indices = parents_1.map(
								function (_, i) {
									return i;
								},
							);
							indices.sort(sortByBestName);
							var sortedParents = indices.map(
								function (i) {
									return parents_1[i];
								},
							);
							for (
								var _i = 0, sortedParents_1 = sortedParents;
								_i < sortedParents_1.length;
								_i++
							) {
								var parent_4 = sortedParents_1[_i];
								var parentChain = getSymbolChain(
									parent_4,
									getQualifiedLeftMeaning(meaning), /*endOfChain*/
									false,
								);
								if (parentChain) {
									if (
										parent_4.exports && parent_4.exports.get(
											InternalSymbolName.ExportEquals,
										) && getSymbolIfSameReference(
											parent_4.exports.get(InternalSymbolName.ExportEquals),
											symbol,
										)
									) {
										// parentChain root _is_ symbol - symbol is a module export=, so it kinda looks like it's own parent
										// No need to lookup an alias for the symbol in itself
										accessibleSymbolChain = parentChain;
										break;
									}
									accessibleSymbolChain = parentChain.concat(
										accessibleSymbolChain || [
											getAliasForSymbolInContainer(parent_4, symbol) || symbol,
										],
									);
									break;
								}
							}
						}
					}
					if (accessibleSymbolChain) {
						return accessibleSymbolChain;
					}
					if (
						// If this is the last part of outputting the symbol, always output. The cases apply only to parent symbols.
						endOfChain || !(symbol.flags & (SymbolFlags.TypeLiteral | SymbolFlags.ObjectLiteral)) // If a parent symbol is an anonymous type, don't write it.
					) {
						// If a parent symbol is an external module, don't write it. (We prefer just `x` vs `"foo/bar".x`.)
						if (
							!endOfChain && !yieldModuleSymbol && !!forEach(
								symbol.declarations,
								hasNonGlobalAugmentationExternalModuleSymbol,
							)
						) {
							return;
						}
						return [symbol];
					}
					function sortByBestName(a, b) {
						var specifierA = parentSpecifiers[a];
						var specifierB = parentSpecifiers[b];
						if (specifierA && specifierB) {
							var isBRelative = pathIsRelative(specifierB);
							if (pathIsRelative(specifierA) === isBRelative) {
								// Both relative or both non-relative, sort by number of parts
								return moduleSpecifiers.countPathComponents(specifierA) - moduleSpecifiers.countPathComponents(
									specifierB,
								);
							}
							if (isBRelative) {
								// A is non-relative, B is relative: prefer A
								return -1;
							}
							// A is relative, B is non-relative: prefer B
							return 1;
						}
						return 0;
					}
				}
			}
			function typeParametersToTypeParameterDeclarations(symbol, context) {
				var typeParameterNodes;
				var targetSymbol = getTargetSymbol(symbol);
				if (
					targetSymbol.flags & (SymbolFlags.Class | SymbolFlags.Interface | SymbolFlags.TypeAlias)
				) {
					typeParameterNodes = factory.createNodeArray(
						map(
							getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol),
							function (tp) {
								return typeParameterToDeclaration(tp, context);
							},
						),
					);
				}
				return typeParameterNodes;
			}
			function lookupTypeParameterNodes(chain, index, context) {
				var _a;
				Debug.assert(chain && 0 <= index && index < chain.length);
				var symbol = chain[index];
				var symbolId = getSymbolId(symbol);
				if (
					(_a = context.typeParameterSymbolList) === null || _a === void 0 ? void 0 : _a.has(
						symbolId,
					)
				) {
					return undefined;
				}
				(context.typeParameterSymbolList || (context.typeParameterSymbolList = new Set())).add(
					symbolId,
				);
				var typeParameterNodes;
				if (
					context.flags & NodeBuilderFlags.WriteTypeParametersInQualifiedName && index < (chain.length - 1)
				) {
					var parentSymbol = symbol;
					var nextSymbol_1 = chain[index + 1];
					if (getCheckFlags(nextSymbol_1) & CheckFlags.Instantiated) {
						var params = getTypeParametersOfClassOrInterface(
							parentSymbol.flags & SymbolFlags.Alias ? resolveAlias(
								parentSymbol,
							) : parentSymbol,
						);
						typeParameterNodes = mapToTypeNodes(
							map(
								params,
								function (t) {
									return getMappedType(t, nextSymbol_1.mapper);
								},
							),
							context,
						);
					} else {
						typeParameterNodes = typeParametersToTypeParameterDeclarations(
							symbol,
							context,
						);
					}
				}
				return typeParameterNodes;
			}
			/**
             * Given A[B][C][D], finds A[B]
             */
			function getTopmostIndexedAccessType(top) {
				if (isIndexedAccessTypeNode(top.objectType)) {
					return getTopmostIndexedAccessType(top.objectType);
				}
				return top;
			}
			function getSpecifierForModuleSymbol(symbol, context) {
				var _a;
				var file = getDeclarationOfKind(symbol, SyntaxKind.SourceFile);
				if (!file) {
					var equivalentFileSymbol = firstDefined(
						symbol.declarations,
						function (d) {
							return getFileSymbolIfFileSymbolExportEqualsContainer(d, symbol);
						},
					);
					if (equivalentFileSymbol) {
						file = getDeclarationOfKind(
							equivalentFileSymbol,
							SyntaxKind.SourceFile,
						);
					}
				}
				if (file && file.moduleName !== undefined) {
					// Use the amd name if it is available
					return file.moduleName;
				}
				if (!file) {
					if (context.tracker.trackReferencedAmbientModule) {
						var ambientDecls = filter(symbol.declarations, isAmbientModule);
						if (length(ambientDecls)) {
							for (var _i = 0, _b = ambientDecls; _i < _b.length; _i++) {
								var decl = _b[_i];
								context.tracker.trackReferencedAmbientModule(decl, symbol);
							}
						}
					}
					if (ambientModuleSymbolRegex.test(symbol.escapedName)) {
						return symbol.escapedName.substring(
							1,
							symbol.escapedName.length - 1,
						);
					}
				}
				if (
					!context.enclosingDeclaration || !context.tracker.moduleResolverHost
				) {
					// If there's no context declaration, we can't lookup a non-ambient specifier, so we just use the symbol name
					if (ambientModuleSymbolRegex.test(symbol.escapedName)) {
						return symbol.escapedName.substring(
							1,
							symbol.escapedName.length - 1,
						);
					}
					return getSourceFileOfNode(getNonAugmentationDeclaration(symbol)).fileName; // A resolver may not be provided for baselines and errors - in those cases we use the fileName in full
				}
				var contextFile = getSourceFileOfNode(
					getOriginalNode(context.enclosingDeclaration),
				);
				var links = getSymbolLinks(symbol);
				var specifier = links.specifierCache && links.specifierCache.get(
					contextFile.path,
				);
				if (!specifier) {
					var isBundle = !!outFile(compilerOptions);
					// For declaration bundles, we need to generate absolute paths relative to the common source dir for imports,
					// just like how the declaration emitter does for the ambient module declarations - we can easily accomplish this
					// using the `baseUrl` compiler option (which we would otherwise never use in declaration emit) and a non-relative
					// specifier preference
					var moduleResolverHost = context.tracker.moduleResolverHost;
					var specifierCompilerOptions = isBundle ? __assign(
						__assign({}, compilerOptions),
						{ baseUrl: moduleResolverHost.getCommonSourceDirectory() },
					) : compilerOptions;
					specifier = first(
						moduleSpecifiers.getModuleSpecifiers(
							symbol,
							checker,
							specifierCompilerOptions,
							contextFile,
							moduleResolverHost,
							{
								importModuleSpecifierPreference: isBundle ? "non-relative" : "project-relative",
								importModuleSpecifierEnding: isBundle ? "minimal" : undefined,
							},
						),
					);
					(_a = links.specifierCache) !== null && _a !== void 0 ? _a : (links.specifierCache = new Map());
					links.specifierCache.set(contextFile.path, specifier);
				}
				return specifier;
			}
			function symbolToEntityNameNode(symbol) {
				var identifier = factory.createIdentifier(
					unescapeLeadingUnderscores(symbol.escapedName),
				);
				return symbol.parent ? factory.createQualifiedName(
					symbolToEntityNameNode(symbol.parent),
					identifier,
				) : identifier;
			}
			function symbolToTypeNode(symbol, context, meaning, overrideTypeArguments) {
				var chain = lookupSymbolChain(
					symbol,
					context,
					meaning,
					!(context.flags & NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope),
				); // If we're using aliases outside the current scope, dont bother with the module
				var isTypeOf = meaning === SymbolFlags.Value;
				if (
					some(
						chain[0].declarations,
						hasNonGlobalAugmentationExternalModuleSymbol,
					)
				) {
					// module is root, must use `ImportTypeNode`
					var nonRootParts = chain.length > 1 ? createAccessFromSymbolChain(
						chain,
						chain.length - 1,
						1,
					) : undefined;
					var typeParameterNodes = overrideTypeArguments || lookupTypeParameterNodes(
						chain,
						0,
						context,
					);
					var specifier = getSpecifierForModuleSymbol(chain[0], context);
					if (
						!(context.flags & NodeBuilderFlags.AllowNodeModulesRelativePaths) && getEmitModuleResolutionKind(
							compilerOptions,
						) !== ModuleResolutionKind.Classic && specifier.indexOf(
							"/node_modules/",
						) >= 0
					) {
						// If ultimately we can only name the symbol with a reference that dives into a `node_modules` folder, we should error
						// since declaration files with these kinds of references are liable to fail when published :(
						context.encounteredError = true;
						if (context.tracker.reportLikelyUnsafeImportRequiredError) {
							context.tracker.reportLikelyUnsafeImportRequiredError(specifier);
						}
					}
					var lit = factory.createLiteralTypeNode(
						factory.createStringLiteral(specifier),
					);
					if (context.tracker.trackExternalModuleSymbolOfImportTypeNode) context.tracker.trackExternalModuleSymbolOfImportTypeNode(
						chain[0],
					);
					context.approximateLength += specifier.length + 10; // specifier + import("")
					if (!nonRootParts || isEntityName(nonRootParts)) {
						if (nonRootParts) {
							var lastId = isIdentifier(nonRootParts) ? nonRootParts : nonRootParts.right;
							lastId.typeArguments = undefined;
						}
						return factory.createImportTypeNode(
							lit,
							nonRootParts,
							typeParameterNodes,
							isTypeOf,
						);
					} else {
						var splitNode = getTopmostIndexedAccessType(nonRootParts);
						var qualifier = splitNode.objectType.typeName;
						return factory.createIndexedAccessTypeNode(
							factory.createImportTypeNode(
								lit,
								qualifier,
								typeParameterNodes,
								isTypeOf,
							),
							splitNode.indexType,
						);
					}
				}
				var entityName = createAccessFromSymbolChain(chain, chain.length - 1, 0);
				if (isIndexedAccessTypeNode(entityName)) {
					return entityName; // Indexed accesses can never be `typeof`
				}
				if (isTypeOf) {
					return factory.createTypeQueryNode(entityName);
				} else {
					var lastId = isIdentifier(entityName) ? entityName : entityName.right;
					var lastTypeArgs = lastId.typeArguments;
					lastId.typeArguments = undefined;
					return factory.createTypeReferenceNode(entityName, lastTypeArgs);
				}
				function createAccessFromSymbolChain(chain, index, stopper) {
					var typeParameterNodes = index === (chain.length - 1) ? overrideTypeArguments : lookupTypeParameterNodes(
						chain,
						index,
						context,
					);
					var symbol = chain[index];
					var parent = chain[index - 1];
					var symbolName;
					if (index === 0) {
						context.flags |= NodeBuilderFlags.InInitialEntityName;
						symbolName = getNameOfSymbolAsWritten(symbol, context);
						context.approximateLength += (symbolName ? symbolName.length : 0) + 1;
						context.flags ^= NodeBuilderFlags.InInitialEntityName;
					} else {
						if (parent && getExportsOfSymbol(parent)) {
							var exports_1 = getExportsOfSymbol(parent);
							forEachEntry(
								exports_1,
								function (ex, name) {
									if (
										getSymbolIfSameReference(ex, symbol) && !isLateBoundName(
											name,
										) && name !== InternalSymbolName.ExportEquals
									) {
										symbolName = unescapeLeadingUnderscores(name);
										return true;
									}
								},
							);
						}
					}
					if (!symbolName) {
						symbolName = getNameOfSymbolAsWritten(symbol, context);
					}
					context.approximateLength += symbolName.length + 1;
					if (
						!(context.flags & NodeBuilderFlags.ForbidIndexedAccessSymbolReferences) && parent && getMembersOfSymbol(
							parent,
						) && getMembersOfSymbol(parent).get(symbol.escapedName) && getSymbolIfSameReference(
							getMembersOfSymbol(parent).get(symbol.escapedName),
							symbol,
						)
					) {
						// Should use an indexed access
						var LHS = createAccessFromSymbolChain(chain, index - 1, stopper);
						if (isIndexedAccessTypeNode(LHS)) {
							return factory.createIndexedAccessTypeNode(
								LHS,
								factory.createLiteralTypeNode(
									factory.createStringLiteral(symbolName),
								),
							);
						} else {
							return factory.createIndexedAccessTypeNode(
								factory.createTypeReferenceNode(LHS, typeParameterNodes),
								factory.createLiteralTypeNode(
									factory.createStringLiteral(symbolName),
								),
							);
						}
					}
					var identifier = setEmitFlags(
						factory.createIdentifier(symbolName, typeParameterNodes),
						EmitFlags.NoAsciiEscaping,
					);
					identifier.symbol = symbol;
					if (index > stopper) {
						var LHS = createAccessFromSymbolChain(chain, index - 1, stopper);
						if (!isEntityName(LHS)) {
							return Debug.fail(
								"Impossible construct - an export of an indexed access cannot be reachable",
							);
						}
						return factory.createQualifiedName(LHS, identifier);
					}
					return identifier;
				}
			}
			function typeParameterShadowsNameInScope(escapedName, context, type) {
				var result = resolveName(
					context.enclosingDeclaration,
					escapedName,
					SymbolFlags.Type, /*nameNotFoundArg*/
					undefined,
					escapedName, /*isUse*/
					false,
				);
				if (result) {
					if (
						result.flags & SymbolFlags.TypeParameter && result === type.symbol
					) {
						return false;
					}
					return true;
				}
				return false;
			}
			function typeParameterToName(type, context) {
				var _a, _b;
				if (
					context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams && context.typeParameterNames
				) {
					var cached = context.typeParameterNames.get(getTypeId(type));
					if (cached) {
						return cached;
					}
				}
				var result = symbolToName(
					type.symbol,
					context,
					SymbolFlags.Type, /*expectsIdentifier*/
					true,
				);
				if (!(result.kind & SyntaxKind.Identifier)) {
					return factory.createIdentifier("(Missing type parameter)");
				}
				if (context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams) {
					var rawtext = result.escapedText;
					var i = ((_a = context.typeParameterNamesByTextNextNameCount) === null || _a === void 0 ? void 0 : _a.get(
						rawtext,
					)) || 0;
					var text = rawtext;
					while (
						((_b = context.typeParameterNamesByText) === null || _b === void 0 ? void 0 : _b.has(
							text,
						)) || typeParameterShadowsNameInScope(text, context, type)
					) {
						i++;
						text = "".concat(rawtext, "_").concat(i);
					}
					if (text !== rawtext) {
						result = factory.createIdentifier(text, result.typeArguments);
					}
					// avoiding iterations of the above loop turns out to be worth it when `i` starts to get large, so we cache the max
					// `i` we've used thus far, to save work later
					(context.typeParameterNamesByTextNextNameCount || (context.typeParameterNamesByTextNextNameCount = new Map())).set(
						rawtext,
						i,
					);
					(context.typeParameterNames || (context.typeParameterNames = new Map())).set(
						getTypeId(type),
						result,
					);
					(context.typeParameterNamesByText || (context.typeParameterNamesByText = new Set())).add(
						rawtext,
					);
				}
				return result;
			}
			function symbolToName(symbol, context, meaning, expectsIdentifier) {
				var chain = lookupSymbolChain(symbol, context, meaning);
				if (
					expectsIdentifier && chain.length !== 1 && !context.encounteredError && !(context.flags & NodeBuilderFlags.AllowQualifiedNameInPlaceOfIdentifier)
				) {
					context.encounteredError = true;
				}
				return createEntityNameFromSymbolChain(chain, chain.length - 1);
				function createEntityNameFromSymbolChain(chain, index) {
					var typeParameterNodes = lookupTypeParameterNodes(
						chain,
						index,
						context,
					);
					var symbol = chain[index];
					if (index === 0) {
						context.flags |= NodeBuilderFlags.InInitialEntityName;
					}
					var symbolName = getNameOfSymbolAsWritten(symbol, context);
					if (index === 0) {
						context.flags ^= NodeBuilderFlags.InInitialEntityName;
					}
					var identifier = setEmitFlags(
						factory.createIdentifier(symbolName, typeParameterNodes),
						EmitFlags.NoAsciiEscaping,
					);
					identifier.symbol = symbol;
					return index > 0 ? factory.createQualifiedName(
						createEntityNameFromSymbolChain(chain, index - 1),
						identifier,
					) : identifier;
				}
			}
			function symbolToExpression(symbol, context, meaning) {
				var chain = lookupSymbolChain(symbol, context, meaning);
				return createExpressionFromSymbolChain(chain, chain.length - 1);
				function createExpressionFromSymbolChain(chain, index) {
					var typeParameterNodes = lookupTypeParameterNodes(
						chain,
						index,
						context,
					);
					var symbol = chain[index];
					if (index === 0) {
						context.flags |= NodeBuilderFlags.InInitialEntityName;
					}
					var symbolName = getNameOfSymbolAsWritten(symbol, context);
					if (index === 0) {
						context.flags ^= NodeBuilderFlags.InInitialEntityName;
					}
					var firstChar = symbolName.charCodeAt(0);
					if (
						isSingleOrDoubleQuote(firstChar) && some(
							symbol.declarations,
							hasNonGlobalAugmentationExternalModuleSymbol,
						)
					) {
						return factory.createStringLiteral(
							getSpecifierForModuleSymbol(symbol, context),
						);
					}
					var canUsePropertyAccess = firstChar === CharacterCodes.hash ? symbolName.length > 1 && isIdentifierStart(
						symbolName.charCodeAt(1),
						languageVersion,
					) : isIdentifierStart(firstChar, languageVersion);
					if (index === 0 || canUsePropertyAccess) {
						var identifier = setEmitFlags(
							factory.createIdentifier(symbolName, typeParameterNodes),
							EmitFlags.NoAsciiEscaping,
						);
						identifier.symbol = symbol;
						return index > 0 ? factory.createPropertyAccessExpression(
							createExpressionFromSymbolChain(chain, index - 1),
							identifier,
						) : identifier;
					} else {
						if (firstChar === CharacterCodes.openBracket) {
							symbolName = symbolName.substring(1, symbolName.length - 1);
							firstChar = symbolName.charCodeAt(0);
						}
						var expression = void 0;
						if (
							isSingleOrDoubleQuote(firstChar) && !(symbol.flags & SymbolFlags.EnumMember)
						) {
							expression = factory.createStringLiteral(stripQuotes(symbolName).replace(/\\./g, function (s) { return s.substring(1); }), firstChar === CharacterCodes.singleQuote);
						} else if (("" + +symbolName) === symbolName) {
							expression = factory.createNumericLiteral(+symbolName);
						}
						if (!expression) {
							expression = setEmitFlags(
								factory.createIdentifier(symbolName, typeParameterNodes),
								EmitFlags.NoAsciiEscaping,
							);
							expression.symbol = symbol;
						}
						return factory.createElementAccessExpression(
							createExpressionFromSymbolChain(chain, index - 1),
							expression,
						);
					}
				}
			}
			function isStringNamed(d) {
				var name = getNameOfDeclaration(d);
				return !!name && isStringLiteral(name);
			}
			function isSingleQuotedStringNamed(d) {
				var name = getNameOfDeclaration(d);
				return !!(name && isStringLiteral(name) && (name.singleQuote || !nodeIsSynthesized(
					name,
				) && startsWith(getTextOfNode(name, /*includeTrivia*/ false), "'")));
			}
			function getPropertyNameNodeForSymbol(symbol, context) {
				var singleQuote = !!length(symbol.declarations) && every(
					symbol.declarations,
					isSingleQuotedStringNamed,
				);
				var fromNameType = getPropertyNameNodeForSymbolFromNameType(
					symbol,
					context,
					singleQuote,
				);
				if (fromNameType) {
					return fromNameType;
				}
				var rawName = unescapeLeadingUnderscores(symbol.escapedName);
				var stringNamed = !!length(symbol.declarations) && every(
					symbol.declarations,
					isStringNamed,
				);
				return createPropertyNameNodeForIdentifierOrLiteral(
					rawName,
					getEmitScriptTarget(compilerOptions),
					singleQuote,
					stringNamed,
				);
			}
			// See getNameForSymbolFromNameType for a stringy equivalent
			function getPropertyNameNodeForSymbolFromNameType(
				symbol,
				context,
				singleQuote,
			) {
				var nameType = getSymbolLinks(symbol).nameType;
				if (nameType) {
					if (nameType.flags & TypeFlags.StringOrNumberLiteral) {
						var name_5 = "" + nameType.value;
						if (
							!isIdentifierText(name_5, getEmitScriptTarget(compilerOptions)) && !isNumericLiteralName(
								name_5,
							)
						) {
							return factory.createStringLiteral(name_5, !!singleQuote);
						}
						if (isNumericLiteralName(name_5) && startsWith(name_5, "-")) {
							return factory.createComputedPropertyName(
								factory.createNumericLiteral(+name_5),
							);
						}
						return createPropertyNameNodeForIdentifierOrLiteral(
							name_5,
							getEmitScriptTarget(compilerOptions),
						);
					}
					if (nameType.flags & TypeFlags.UniqueESSymbol) {
						return factory.createComputedPropertyName(
							symbolToExpression(nameType.symbol, context, SymbolFlags.Value),
						);
					}
				}
			}
			function cloneNodeBuilderContext(context) {
				var initial = __assign({}, context);
				// Make type parameters created within this context not consume the name outside this context
				// The symbol serializer ends up creating many sibling scopes that all need "separate" contexts when
				// it comes to naming things - within a normal `typeToTypeNode` call, the node builder only ever descends
				// through the type tree, so the only cases where we could have used distinct sibling scopes was when there
				// were multiple generic overloads with similar generated type parameter names
				// The effect:
				// When we write out
				// export const x: <T>(x: T) => T
				// export const y: <T>(x: T) => T
				// we write it out like that, rather than as
				// export const x: <T>(x: T) => T
				// export const y: <T_1>(x: T_1) => T_1
				if (initial.typeParameterNames) {
					initial.typeParameterNames = new Map(initial.typeParameterNames);
				}
				if (initial.typeParameterNamesByText) {
					initial.typeParameterNamesByText = new Set(
						initial.typeParameterNamesByText,
					);
				}
				if (initial.typeParameterSymbolList) {
					initial.typeParameterSymbolList = new Set(
						initial.typeParameterSymbolList,
					);
				}
				initial.tracker = wrapSymbolTrackerToReportForContext(
					initial,
					initial.tracker,
				);
				return initial;
			}
			function getDeclarationWithTypeAnnotation(symbol, enclosingDeclaration) {
				return symbol.declarations && find(
					symbol.declarations,
					function (s) {
						return !!getEffectiveTypeAnnotationNode(s) && (!enclosingDeclaration || !!findAncestor(
							s,
							function (n) {
								return n === enclosingDeclaration;
							},
						));
					},
				);
			}
			function existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(
				existing,
				type,
			) {
				return !(getObjectFlags(type) & ObjectFlags.Reference) || !isTypeReferenceNode(
					existing,
				) || length(existing.typeArguments) >= getMinTypeArgumentCount(
					type.target.typeParameters,
				);
			}
			/**
             * Unlike `typeToTypeNodeHelper`, this handles setting up the `AllowUniqueESSymbolType` flag
             * so a `unique symbol` is returned when appropriate for the input symbol, rather than `typeof sym`
             */
			function serializeTypeForDeclaration(
				context,
				type,
				symbol,
				enclosingDeclaration,
				includePrivateSymbol,
				bundled,
			) {
				if (!isErrorType(type) && enclosingDeclaration) {
					var declWithExistingAnnotation = getDeclarationWithTypeAnnotation(
						symbol,
						enclosingDeclaration,
					);
					if (
						declWithExistingAnnotation && !isFunctionLikeDeclaration(
							declWithExistingAnnotation,
						) && !isGetAccessorDeclaration(declWithExistingAnnotation)
					) {
						// try to reuse the existing annotation
						var existing = getEffectiveTypeAnnotationNode(
							declWithExistingAnnotation,
						);
						if (
							getTypeFromTypeNode(existing) === type && existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(
								existing,
								type,
							)
						) {
							var result_2 = serializeExistingTypeNode(
								context,
								existing,
								includePrivateSymbol,
								bundled,
							);
							if (result_2) {
								return result_2;
							}
						}
					}
				}
				var oldFlags = context.flags;
				if (
					type.flags & TypeFlags.UniqueESSymbol && type.symbol === symbol && (!context.enclosingDeclaration || some(
						symbol.declarations,
						function (d) {
							return getSourceFileOfNode(d) === getSourceFileOfNode(
								context.enclosingDeclaration,
							);
						},
					))
				) {
					context.flags |= NodeBuilderFlags.AllowUniqueESSymbolType;
				}
				var result = typeToTypeNodeHelper(type, context);
				context.flags = oldFlags;
				return result;
			}
			function serializeReturnTypeForSignature(
				context,
				type,
				signature,
				includePrivateSymbol,
				bundled,
			) {
				if (!isErrorType(type) && context.enclosingDeclaration) {
					var annotation = signature.declaration && getEffectiveReturnTypeNode(
						signature.declaration,
					);
					if (
						!!findAncestor(
							annotation,
							function (n) {
								return n === context.enclosingDeclaration;
							},
						) && annotation
					) {
						var annotated = getTypeFromTypeNode(annotation);
						var thisInstantiated = annotated.flags & TypeFlags.TypeParameter && annotated.isThisType ? instantiateType(
							annotated,
							signature.mapper,
						) : annotated;
						if (
							thisInstantiated === type && existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(
								annotation,
								type,
							)
						) {
							var result = serializeExistingTypeNode(
								context,
								annotation,
								includePrivateSymbol,
								bundled,
							);
							if (result) {
								return result;
							}
						}
					}
				}
				return typeToTypeNodeHelper(type, context);
			}
			function trackExistingEntityName(node, context, includePrivateSymbol) {
				var _a, _b;
				var introducesError = false;
				var leftmost = getFirstIdentifier(node);
				if (
					isInJSFile(node) && (isExportsIdentifier(leftmost) || isModuleExportsAccessExpression(
						leftmost.parent,
					) || (isQualifiedName(leftmost.parent) && isModuleIdentifier(
						leftmost.parent.left,
					) && isExportsIdentifier(leftmost.parent.right)))
				) {
					introducesError = true;
					return { introducesError: introducesError, node: node };
				}
				var sym = resolveEntityName(
					leftmost,
					SymbolFlags.All, /*ignoreErrors*/
					true, /*dontResolveALias*/
					true,
				);
				if (sym) {
					if (
						isSymbolAccessible(
							sym,
							context.enclosingDeclaration,
							SymbolFlags.All, /*shouldComputeAliasesToMakeVisible*/
							false,
						).accessibility !== SymbolAccessibility.Accessible
					) {
						introducesError = true;
					} else {
						(_b = (_a = context.tracker) === null || _a === void 0 ? void 0 : _a.trackSymbol) === null || _b === void 0 ? void 0 : _b.call(
							_a,
							sym,
							context.enclosingDeclaration,
							SymbolFlags.All,
						);
						includePrivateSymbol === null || includePrivateSymbol === void 0 ? void 0 : includePrivateSymbol(
							sym,
						);
					}
					if (isIdentifier(node)) {
						var name_6 = sym.flags & SymbolFlags.TypeParameter ? typeParameterToName(
							getDeclaredTypeOfSymbol(sym),
							context,
						) : factory.cloneNode(node);
						name_6.symbol = sym; // for quickinfo, which uses identifier symbol information
						return {
							introducesError: introducesError,
							node: setEmitFlags(
								setOriginalNode(name_6, node),
								EmitFlags.NoAsciiEscaping,
							),
						};
					}
				}
				return { introducesError: introducesError, node: node };
			}
			function serializeExistingTypeNode(
				context,
				existing,
				includePrivateSymbol,
				bundled,
			) {
				if (cancellationToken && cancellationToken.throwIfCancellationRequested) {
					cancellationToken.throwIfCancellationRequested();
				}
				var hadError = false;
				var file = getSourceFileOfNode(existing);
				var transformed = visitNode(existing, visitExistingNodeTreeSymbols);
				if (hadError) {
					return undefined;
				}
				return transformed === existing ? setTextRange(
					factory.cloneNode(existing),
					existing,
				) : transformed;
				function visitExistingNodeTreeSymbols(node) {
					// We don't _actually_ support jsdoc namepath types, emit `any` instead
					if (
						isJSDocAllType(node) || node.kind === SyntaxKind.JSDocNamepathType
					) {
						return factory.createKeywordTypeNode(SyntaxKind.AnyKeyword);
					}
					if (isJSDocUnknownType(node)) {
						return factory.createKeywordTypeNode(SyntaxKind.UnknownKeyword);
					}
					if (isJSDocNullableType(node)) {
						return factory.createUnionTypeNode(
							[
								visitNode(node.type, visitExistingNodeTreeSymbols),
								factory.createLiteralTypeNode(factory.createNull()),
							],
						);
					}
					if (isJSDocOptionalType(node)) {
						return factory.createUnionTypeNode(
							[
								visitNode(node.type, visitExistingNodeTreeSymbols),
								factory.createKeywordTypeNode(SyntaxKind.UndefinedKeyword),
							],
						);
					}
					if (isJSDocNonNullableType(node)) {
						return visitNode(node.type, visitExistingNodeTreeSymbols);
					}
					if (isJSDocVariadicType(node)) {
						return factory.createArrayTypeNode(
							visitNode(node.type, visitExistingNodeTreeSymbols),
						);
					}
					if (isJSDocTypeLiteral(node)) {
						return factory.createTypeLiteralNode(
							map(
								node.jsDocPropertyTags,
								function (t) {
									var name = isIdentifier(t.name) ? t.name : t.name.right;
									var typeViaParent = getTypeOfPropertyOfType(
										getTypeFromTypeNode(node),
										name.escapedText,
									);
									var overrideTypeNode = typeViaParent && t.typeExpression && getTypeFromTypeNode(
										t.typeExpression.type,
									) !== typeViaParent ? typeToTypeNodeHelper(
										typeViaParent,
										context,
									) : undefined;
									return factory.createPropertySignature(
										/*modifiers*/ undefined,
										name,
										t.isBracketed || t.typeExpression && isJSDocOptionalType(
											t.typeExpression.type,
										) ? factory.createToken(SyntaxKind.QuestionToken) : undefined,
										overrideTypeNode || (t.typeExpression && visitNode(
											t.typeExpression.type,
											visitExistingNodeTreeSymbols,
										)) || factory.createKeywordTypeNode(SyntaxKind.AnyKeyword),
									);
								},
							),
						);
					}
					if (
						isTypeReferenceNode(node) && isIdentifier(node.typeName) && node.typeName.escapedText === ""
					) {
						return setOriginalNode(
							factory.createKeywordTypeNode(SyntaxKind.AnyKeyword),
							node,
						);
					}
					if (
						(isExpressionWithTypeArguments(node) || isTypeReferenceNode(node)) && isJSDocIndexSignature(
							node,
						)
					) {
						return factory.createTypeLiteralNode(
							[
								factory.createIndexSignature(
									/*decorators*/ undefined,
									/*modifiers*/ undefined,
									[
										factory.createParameterDeclaration(
											/*decorators*/ undefined,
											/*modifiers*/ undefined,
											/*dotdotdotToken*/ undefined,
											"x",
											/*questionToken*/ undefined,
											visitNode(
												node.typeArguments[0],
												visitExistingNodeTreeSymbols,
											),
										),
									],
									visitNode(node.typeArguments[1], visitExistingNodeTreeSymbols),
								),
							],
						);
					}
					if (isJSDocFunctionType(node)) {
						if (isJSDocConstructSignature(node)) {
							var newTypeNode_1;
							return factory.createConstructorTypeNode(
								node.modifiers,
								visitNodes(node.typeParameters, visitExistingNodeTreeSymbols),
								mapDefined(
									node.parameters,
									function (p, i) {
										return p.name && isIdentifier(p.name) && p.name.escapedText === "new" ? (newTypeNode_1 = p.type, undefined) : factory.createParameterDeclaration(
											/*decorators*/ undefined,
											/*modifiers*/ undefined,
											getEffectiveDotDotDotForParameter(p),
											getNameForJSDocFunctionParameter(p, i),
											p.questionToken,
											visitNode(p.type, visitExistingNodeTreeSymbols),
											/*initializer*/ undefined,
										);
									},
								),
								visitNode(
									newTypeNode_1 || node.type,
									visitExistingNodeTreeSymbols,
								) || factory.createKeywordTypeNode(SyntaxKind.AnyKeyword),
							);
						} else {
							return factory.createFunctionTypeNode(
								visitNodes(node.typeParameters, visitExistingNodeTreeSymbols),
								map(
									node.parameters,
									function (p, i) {
										return factory.createParameterDeclaration(
											/*decorators*/ undefined,
											/*modifiers*/ undefined,
											getEffectiveDotDotDotForParameter(p),
											getNameForJSDocFunctionParameter(p, i),
											p.questionToken,
											visitNode(p.type, visitExistingNodeTreeSymbols),
											/*initializer*/ undefined,
										);
									},
								),
								visitNode(node.type, visitExistingNodeTreeSymbols) || factory.createKeywordTypeNode(
									SyntaxKind.AnyKeyword,
								),
							);
						}
					}
					if (
						isTypeReferenceNode(node) && isInJSDoc(node) && (!existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(
							node,
							getTypeFromTypeNode(node),
						) || getIntendedTypeFromJSDocTypeReference(node) || unknownSymbol === resolveTypeReferenceName(
							node,
							SymbolFlags.Type, /*ignoreErrors*/
							true,
						))
					) {
						return setOriginalNode(
							typeToTypeNodeHelper(getTypeFromTypeNode(node), context),
							node,
						);
					}
					if (isLiteralImportTypeNode(node)) {
						var nodeSymbol = getNodeLinks(node).resolvedSymbol;
						if (
							isInJSDoc(node) && nodeSymbol && ((!node.isTypeOf && !(nodeSymbol.flags & SymbolFlags.Type)) || !(length(
								node.typeArguments, // The import type resolved using jsdoc fallback logic // The import type had type arguments autofilled by js fallback logic
							) >= getMinTypeArgumentCount(
								getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(nodeSymbol),
							)))
						) {
							return setOriginalNode(
								typeToTypeNodeHelper(getTypeFromTypeNode(node), context),
								node,
							);
						}
						return factory.updateImportTypeNode(
							node,
							factory.updateLiteralTypeNode(
								node.argument,
								rewriteModuleSpecifier(node, node.argument.literal),
							),
							node.qualifier,
							visitNodes(
								node.typeArguments,
								visitExistingNodeTreeSymbols,
								isTypeNode,
							),
							node.isTypeOf,
						);
					}
					if (isEntityName(node) || isEntityNameExpression(node)) {
						var _a = trackExistingEntityName(
							node,
							context,
							includePrivateSymbol,
						),
							introducesError = _a.introducesError,
							result = _a.node;
						hadError = hadError || introducesError;
						if (result !== node) {
							return result;
						}
					}
					if (
						file && isTupleTypeNode(node) && (getLineAndCharacterOfPosition(
							file,
							node.pos,
						).line === getLineAndCharacterOfPosition(file, node.end).line)
					) {
						setEmitFlags(node, EmitFlags.SingleLine);
					}
					return visitEachChild(
						node,
						visitExistingNodeTreeSymbols,
						nullTransformationContext,
					);
					function getEffectiveDotDotDotForParameter(p) {
						return p.dotDotDotToken || (p.type && isJSDocVariadicType(p.type) ? factory.createToken(
							SyntaxKind.DotDotDotToken,
						) : undefined);
					}
					/** Note that `new:T` parameters are not handled, but should be before calling this function. */
					function getNameForJSDocFunctionParameter(p, index) {
						return p.name && isIdentifier(p.name) && p.name.escapedText === "this" ? "this" : getEffectiveDotDotDotForParameter(
							p,
						) ? "args" : "arg".concat(index);
					}
					function rewriteModuleSpecifier(parent, lit) {
						if (bundled) {
							if (context.tracker && context.tracker.moduleResolverHost) {
								var targetFile = getExternalModuleFileFromDeclaration(parent);
								if (targetFile) {
									var getCanonicalFileName = createGetCanonicalFileName(
										!!host.useCaseSensitiveFileNames,
									);
									var resolverHost = {
										getCanonicalFileName: getCanonicalFileName,
										getCurrentDirectory: function () {
											return context.tracker.moduleResolverHost.getCurrentDirectory();
										},
										getCommonSourceDirectory: function () {
											return context.tracker.moduleResolverHost.getCommonSourceDirectory();
										},
									};
									var newName = getResolvedExternalModuleName(
										resolverHost,
										targetFile,
									);
									return factory.createStringLiteral(newName);
								}
							}
						} else {
							if (
								context.tracker && context.tracker.trackExternalModuleSymbolOfImportTypeNode
							) {
								var moduleSym = resolveExternalModuleNameWorker(
									lit,
									lit, /*moduleNotFoundError*/
									undefined,
								);
								if (moduleSym) {
									context.tracker.trackExternalModuleSymbolOfImportTypeNode(
										moduleSym,
									);
								}
							}
						}
						return lit;
					}
				}
			}
			function symbolTableToDeclarationStatements(symbolTable, context, bundled) {
				var serializePropertySymbolForClass = makeSerializePropertySymbol(
					factory.createPropertyDeclaration,
					SyntaxKind.MethodDeclaration, /*useAcessors*/
					true,
				);
				var serializePropertySymbolForInterfaceWorker = makeSerializePropertySymbol(
					function (_decorators, mods, name, question, type) {
						return factory.createPropertySignature(mods, name, question, type);
					},
					SyntaxKind.MethodSignature, /*useAcessors*/
					false,
				);
				// TODO: Use `setOriginalNode` on original declaration names where possible so these declarations see some kind of
				// declaration mapping
				// We save the enclosing declaration off here so it's not adjusted by well-meaning declaration
				// emit codepaths which want to apply more specific contexts (so we can still refer to the root real declaration
				// we're trying to emit from later on)
				var enclosingDeclaration = context.enclosingDeclaration;
				var results = [];
				var visitedSymbols = new Set();
				var deferredPrivatesStack = [];
				var oldcontext = context;
				context = __assign(
					__assign({}, oldcontext),
					{
						usedSymbolNames: new Set(oldcontext.usedSymbolNames),
						remappedSymbolNames: new Map(),
						tracker: __assign(
							__assign({}, oldcontext.tracker),
							{
								trackSymbol: function (sym, decl, meaning) {
									var accessibleResult = isSymbolAccessible(
										sym,
										decl,
										meaning, /*computeAliases*/
										false,
									);
									if (
										accessibleResult.accessibility === SymbolAccessibility.Accessible
									) {
										// Lookup the root symbol of the chain of refs we'll use to access it and serialize it
										var chain = lookupSymbolChainWorker(sym, context, meaning);
										if (!(sym.flags & SymbolFlags.Property)) {
											includePrivateSymbol(chain[0]);
										}
									} else if (
										oldcontext.tracker && oldcontext.tracker.trackSymbol
									) {
										return oldcontext.tracker.trackSymbol(sym, decl, meaning);
									}
									return false;
								},
							},
						),
					},
				);
				context.tracker = wrapSymbolTrackerToReportForContext(
					context,
					context.tracker,
				);
				forEachEntry(
					symbolTable,
					function (symbol, name) {
						var baseName = unescapeLeadingUnderscores(name);
						void getInternalSymbolName(symbol, baseName); // Called to cache values into `usedSymbolNames` and `remappedSymbolNames`
					},
				);
				var addingDeclare = !bundled;
				var exportEquals = symbolTable.get(InternalSymbolName.ExportEquals);
				if (
					exportEquals && symbolTable.size > 1 && exportEquals.flags & SymbolFlags.Alias
				) {
					symbolTable = createSymbolTable();
					// Remove extraneous elements from root symbol table (they'll be mixed back in when the target of the `export=` is looked up)
					symbolTable.set(InternalSymbolName.ExportEquals, exportEquals);
				}
				visitSymbolTable(symbolTable);
				return mergeRedundantStatements(results);
				function isIdentifierAndNotUndefined(node) {
					return !!node && node.kind === SyntaxKind.Identifier;
				}
				function getNamesOfDeclaration(statement) {
					if (isVariableStatement(statement)) {
						return filter(
							map(statement.declarationList.declarations, getNameOfDeclaration),
							isIdentifierAndNotUndefined,
						);
					}
					return filter(
						[getNameOfDeclaration(statement)],
						isIdentifierAndNotUndefined,
					);
				}
				function flattenExportAssignedNamespace(statements) {
					var exportAssignment = find(statements, isExportAssignment);
					var nsIndex = findIndex(statements, isModuleDeclaration);
					var ns = nsIndex !== -1 ? statements[nsIndex] : undefined;
					if (
						ns && exportAssignment && exportAssignment.isExportEquals && isIdentifier(
							exportAssignment.expression,
						) && isIdentifier(ns.name) && idText(ns.name) === idText(
							exportAssignment.expression,
						) && ns.body && isModuleBlock(ns.body)
					) {
						// Pass 0: Correct situations where a module has both an `export = ns` and multiple top-level exports by stripping the export modifiers from
						//  the top-level exports and exporting them in the targeted ns, as can occur when a js file has both typedefs and `module.export` assignments
						var excessExports = filter(
							statements,
							function (s) {
								return !!(getEffectiveModifierFlags(s) & ModifierFlags.Export);
							},
						);
						var name_7 = ns.name;
						var body = ns.body;
						if (length(excessExports)) {
							ns = factory.updateModuleDeclaration(
								ns,
								ns.decorators,
								ns.modifiers,
								ns.name,
								body = factory.updateModuleBlock(
									body,
									factory.createNodeArray(
										__spreadArray(
											__spreadArray([], ns.body.statements, true),
											[
												factory.createExportDeclaration(
													/*decorators*/ undefined,
													/*modifiers*/ undefined,
													/*isTypeOnly*/ false,
													factory.createNamedExports(
														map(
															flatMap(
																excessExports,
																function (e) {
																	return getNamesOfDeclaration(e);
																},
															),
															function (id) {
																return factory.createExportSpecifier(
																	false, /*isTypeOnly*/ /*alias*/
																	undefined,
																	id,
																);
															},
														),
													),
													/*moduleSpecifier*/ undefined,
												),
											],
											false,
										),
									),
								),
							);
							statements = __spreadArray(
								__spreadArray(
									__spreadArray([], statements.slice(0, nsIndex), true),
									[ns],
									false,
								),
								statements.slice(nsIndex + 1),
								true,
							);
						}
						// Pass 1: Flatten `export namespace _exports {} export = _exports;` so long as the `export=` only points at a single namespace declaration
						if (
							!find(
								statements,
								function (s) {
									return s !== ns && nodeHasName(s, name_7);
								},
							)
						) {
							results = [];
							// If the namespace contains no export assignments or declarations, and no declarations flagged with `export`, then _everything_ is exported -
							// to respect this as the top level, we need to add an `export` modifier to everything
							var mixinExportFlag_1 = !some(
								body.statements,
								function (s) {
									return hasSyntacticModifier(s, ModifierFlags.Export) || isExportAssignment(
										s,
									) || isExportDeclaration(s);
								},
							);
							forEach(
								body.statements,
								function (s) {
									addResult(
										s,
										mixinExportFlag_1 ? ModifierFlags.Export : ModifierFlags.None,
									); // Recalculates the ambient (and export, if applicable from above) flag
								},
							);
							statements = __spreadArray(
								__spreadArray(
									[],
									filter(
										statements,
										function (s) {
											return s !== ns && s !== exportAssignment;
										},
									),
									true,
								),
								results,
								true,
							);
						}
					}
					return statements;
				}
				function mergeExportDeclarations(statements) {
					// Pass 2: Combine all `export {}` declarations
					var exports = filter(
						statements,
						function (d) {
							return isExportDeclaration(d) && !d.moduleSpecifier && !!d.exportClause && isNamedExports(
								d.exportClause,
							);
						},
					);
					if (length(exports) > 1) {
						var nonExports = filter(
							statements,
							function (d) {
								return !isExportDeclaration(d) || !!d.moduleSpecifier || !d.exportClause;
							},
						);
						statements = __spreadArray(
							__spreadArray([], nonExports, true),
							[
								factory.createExportDeclaration(
									/*decorators*/ undefined,
									/*modifiers*/ undefined,
									/*isTypeOnly*/ false,
									factory.createNamedExports(
										flatMap(
											exports,
											function (e) {
												return cast(e.exportClause, isNamedExports).elements;
											},
										),
									),
									/*moduleSpecifier*/ undefined,
								),
							],
							false,
						);
					}
					// Pass 2b: Also combine all `export {} from "..."` declarations as needed
					var reexports = filter(
						statements,
						function (d) {
							return isExportDeclaration(d) && !!d.moduleSpecifier && !!d.exportClause && isNamedExports(
								d.exportClause,
							);
						},
					);
					if (length(reexports) > 1) {
						var groups = group(
							reexports,
							function (decl) {
								return isStringLiteral(decl.moduleSpecifier) ? ">" + decl.moduleSpecifier.text : ">";
							},
						);
						if (groups.length !== reexports.length) {
							var _loop_3 = function (group) {
								if (group.length > 1) {
									// remove group members from statements and then merge group members and add back to statements
									statements = __spreadArray(
										__spreadArray(
											[],
											filter(
												statements,
												function (s) {
													return group.indexOf(s) === -1;
												},
											),
											true,
										),
										[
											factory.createExportDeclaration(
												/*decorators*/ undefined,
												/*modifiers*/ undefined,
												/*isTypeOnly*/ false,
												factory.createNamedExports(
													flatMap(
														group,
														function (e) {
															return cast(e.exportClause, isNamedExports).elements;
														},
													),
												),
												group[0].moduleSpecifier,
											),
										],
										false,
									);
								}
							};
							for (var _i = 0, groups_1 = groups; _i < groups_1.length; _i++) {
								var group = groups_1[_i];
								_loop_3(group);
							}
						}
					}
					return statements;
				}
				function inlineExportModifiers(statements) {
					// Pass 3: Move all `export {}`'s to `export` modifiers where possible
					var index = findIndex(
						statements,
						function (d) {
							return isExportDeclaration(d) && !d.moduleSpecifier && !d.assertClause && !!d.exportClause && isNamedExports(
								d.exportClause,
							);
						},
					);
					if (index >= 0) {
						var exportDecl = statements[index];
						var replacements = mapDefined(
							exportDecl.exportClause.elements,
							function (e) {
								if (!e.propertyName) {
									// export {name} - look thru `statements` for `name`, and if all results can take an `export` modifier, do so and filter it
									var indices = indicesOf(statements);
									var associatedIndices = filter(
										indices,
										function (i) {
											return nodeHasName(statements[i], e.name);
										},
									);
									if (
										length(associatedIndices) && every(
											associatedIndices,
											function (i) {
												return canHaveExportModifier(statements[i]);
											},
										)
									) {
										for (
											var _i = 0, associatedIndices_1 = associatedIndices;
											_i < associatedIndices_1.length;
											_i++
										) {
											var index_1 = associatedIndices_1[_i];
											statements[index_1] = addExportModifier(
												statements[index_1],
											);
										}
										return undefined;
									}
								}
								return e;
							},
						);
						if (!length(replacements)) {
							// all clauses removed, remove the export declaration
							orderedRemoveItemAt(statements, index);
						} else {
							// some items filtered, others not - update the export declaration
							statements[index] = factory.updateExportDeclaration(
								exportDecl,
								exportDecl.decorators,
								exportDecl.modifiers,
								exportDecl.isTypeOnly,
								factory.updateNamedExports(
									exportDecl.exportClause,
									replacements,
								),
								exportDecl.moduleSpecifier,
								exportDecl.assertClause,
							);
						}
					}
					return statements;
				}
				function mergeRedundantStatements(statements) {
					statements = flattenExportAssignedNamespace(statements);
					statements = mergeExportDeclarations(statements);
					statements = inlineExportModifiers(statements);
					// Not a cleanup, but as a final step: If there is a mix of `export` and non-`export` declarations, but no `export =` or `export {}` add a `export {};` so
					// declaration privacy is respected.
					if (
						enclosingDeclaration && ((isSourceFile(enclosingDeclaration) && isExternalOrCommonJsModule(
							enclosingDeclaration,
						)) || isModuleDeclaration(enclosingDeclaration)) && (!some(
							statements,
							isExternalModuleIndicator,
						) || (!hasScopeMarker(statements) && some(
							statements,
							needsScopeMarker,
						)))
					) {
						statements.push(createEmptyExports(factory));
					}
					return statements;
				}
				function canHaveExportModifier(node) {
					return isEnumDeclaration(node) || isVariableStatement(node) || isFunctionDeclaration(
						node,
					) || isClassDeclaration(node) || (isModuleDeclaration(node) && !isExternalModuleAugmentation(
						node,
					) && !isGlobalScopeAugmentation(node)) || isInterfaceDeclaration(node) || isTypeDeclaration(
						node,
					);
				}
				function addExportModifier(node) {
					var flags = (getEffectiveModifierFlags(node) | ModifierFlags.Export) & ~ModifierFlags.Ambient;
					return factory.updateModifiers(node, flags);
				}
				function removeExportModifier(node) {
					var flags = getEffectiveModifierFlags(node) & ~ModifierFlags.Export;
					return factory.updateModifiers(node, flags);
				}
				function visitSymbolTable(
					symbolTable,
					suppressNewPrivateContext,
					propertyAsAlias,
				) {
					if (!suppressNewPrivateContext) {
						deferredPrivatesStack.push(new Map());
					}
					symbolTable.forEach(
						function (symbol) {
							serializeSymbol(symbol, /*isPrivate*/ false, !!propertyAsAlias);
						},
					);
					if (!suppressNewPrivateContext) {
						// deferredPrivates will be filled up by visiting the symbol table
						// And will continue to iterate as elements are added while visited `deferredPrivates`
						// (As that's how a map iterator is defined to work)
						deferredPrivatesStack[deferredPrivatesStack.length - 1].forEach(
							function (symbol) {
								serializeSymbol(symbol, /*isPrivate*/ true, !!propertyAsAlias);
							},
						);
						deferredPrivatesStack.pop();
					}
				}
				function serializeSymbol(symbol, isPrivate, propertyAsAlias) {
					// cache visited list based on merged symbol, since we want to use the unmerged top-level symbol, but
					// still skip reserializing it if we encounter the merged product later on
					var visitedSym = getMergedSymbol(symbol);
					if (visitedSymbols.has(getSymbolId(visitedSym))) {
						return; // Already printed
					}
					visitedSymbols.add(getSymbolId(visitedSym));
					// Only actually serialize symbols within the correct enclosing declaration, otherwise do nothing with the out-of-context symbol
					var skipMembershipCheck = !isPrivate; // We only call this on exported symbols when we know they're in the correct scope
					if (
						skipMembershipCheck || (!!length(symbol.declarations) && some(
							symbol.declarations,
							function (d) {
								return !!findAncestor(
									d,
									function (n) {
										return n === enclosingDeclaration;
									},
								);
							},
						))
					) {
						var oldContext = context;
						context = cloneNodeBuilderContext(context);
						var result = serializeSymbolWorker(
							symbol,
							isPrivate,
							propertyAsAlias,
						);
						if (context.reportedDiagnostic) {
							oldcontext.reportedDiagnostic = context.reportedDiagnostic; // hoist diagnostic result into outer context
						}
						context = oldContext;
						return result;
					}
				}
				// Synthesize declarations for a symbol - might be an Interface, a Class, a Namespace, a Type, a Variable (const, let, or var), an Alias
				// or a merge of some number of those.
				// An interesting challenge is ensuring that when classes merge with namespaces and interfaces, is keeping
				// each symbol in only one of the representations
				// Also, synthesizing a default export of some kind
				// If it's an alias: emit `export default ref`
				// If it's a property: emit `export default _default` with a `_default` prop
				// If it's a class/interface/function: emit a class/interface/function with a `default` modifier
				// These forms can merge, eg (`export default 12; export default interface A {}`)
				function serializeSymbolWorker(symbol, isPrivate, propertyAsAlias) {
					var _a, _b;
					var symbolName = unescapeLeadingUnderscores(symbol.escapedName);
					var isDefault = symbol.escapedName === InternalSymbolName.Default;
					if (
						isPrivate && !(context.flags & NodeBuilderFlags.AllowAnonymousIdentifier) && isStringANonContextualKeyword(
							symbolName,
						) && !isDefault
					) {
						// Oh no. We cannot use this symbol's name as it's name... It's likely some jsdoc had an invalid name like `export` or `default` :(
						context.encounteredError = true;
						// TODO: Issue error via symbol tracker?
						return; // If we need to emit a private with a keyword name, we're done for, since something else will try to refer to it by that name
					}
					var needsPostExportDefault = isDefault && !!(symbol.flags & SymbolFlags.ExportDoesNotSupportDefaultModifier || (symbol.flags & SymbolFlags.Function && length(
						getPropertiesOfType(getTypeOfSymbol(symbol)),
					))) && !(symbol.flags & SymbolFlags.Alias); // An alias symbol should preclude needing to make an alias ourselves
					var needsExportDeclaration = !needsPostExportDefault && !isPrivate && isStringANonContextualKeyword(
						symbolName,
					) && !isDefault;
					// `serializeVariableOrProperty` will handle adding the export declaration if it is run (since `getInternalSymbolName` will create the name mapping), so we need to ensuer we unset `needsExportDeclaration` if it is
					if (needsPostExportDefault || needsExportDeclaration) {
						isPrivate = true;
					}
					var modifierFlags = (!isPrivate ? ModifierFlags.Export : 0) | (isDefault && !needsPostExportDefault ? ModifierFlags.Default : 0);
					var isConstMergedWithNS = symbol.flags & SymbolFlags.Module && symbol.flags & (SymbolFlags.BlockScopedVariable | SymbolFlags.FunctionScopedVariable | SymbolFlags.Property) && symbol.escapedName !== InternalSymbolName.ExportEquals;
					var isConstMergedWithNSPrintableAsSignatureMerge = isConstMergedWithNS && isTypeRepresentableAsFunctionNamespaceMerge(
						getTypeOfSymbol(symbol),
						symbol,
					);
					if (
						symbol.flags & (SymbolFlags.Function | SymbolFlags.Method) || isConstMergedWithNSPrintableAsSignatureMerge
					) {
						serializeAsFunctionNamespaceMerge(
							getTypeOfSymbol(symbol),
							symbol,
							getInternalSymbolName(symbol, symbolName),
							modifierFlags,
						);
					}
					if (symbol.flags & SymbolFlags.TypeAlias) {
						serializeTypeAlias(symbol, symbolName, modifierFlags);
					}
					// Need to skip over export= symbols below - json source files get a single `Property` flagged
					// symbol of name `export=` which needs to be handled like an alias. It's not great, but it is what it is.
					if (
						symbol.flags & (SymbolFlags.BlockScopedVariable | SymbolFlags.FunctionScopedVariable | SymbolFlags.Property) && symbol.escapedName !== InternalSymbolName.ExportEquals && !(symbol.flags & SymbolFlags.Prototype) && !(symbol.flags & SymbolFlags.Class) && !isConstMergedWithNSPrintableAsSignatureMerge
					) {
						if (propertyAsAlias) {
							var createdExport = serializeMaybeAliasAssignment(symbol);
							if (createdExport) {
								needsExportDeclaration = false;
								needsPostExportDefault = false;
							}
						} else {
							var type = getTypeOfSymbol(symbol);
							var localName = getInternalSymbolName(symbol, symbolName);
							if (
								!(symbol.flags & SymbolFlags.Function) && isTypeRepresentableAsFunctionNamespaceMerge(
									type,
									symbol,
								)
							) {
								// If the type looks like a function declaration + ns could represent it, and it's type is sourced locally, rewrite it into a function declaration + ns
								serializeAsFunctionNamespaceMerge(
									type,
									symbol,
									localName,
									modifierFlags,
								);
							} else {
								// A Class + Property merge is made for a `module.exports.Member = class {}`, and it doesn't serialize well as either a class _or_ a property symbol - in fact, _it behaves like an alias!_
								// `var` is `FunctionScopedVariable`, `const` and `let` are `BlockScopedVariable`, and `module.exports.thing =` is `Property`
								var flags = !(symbol.flags & SymbolFlags.BlockScopedVariable) ? undefined : isConstVariable(
									symbol,
								) ? NodeFlags.Const : NodeFlags.Let;
								var name_8 = (needsPostExportDefault || !(symbol.flags & SymbolFlags.Property)) ? localName : getUnusedName(
									localName,
									symbol,
								);
								var textRange = symbol.declarations && find(
									symbol.declarations,
									function (d) {
										return isVariableDeclaration(d);
									},
								);
								if (
									textRange && isVariableDeclarationList(textRange.parent) && textRange.parent.declarations.length === 1
								) {
									textRange = textRange.parent.parent;
								}
								var propertyAccessRequire = (_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.find(
									isPropertyAccessExpression,
								);
								if (
									propertyAccessRequire && isBinaryExpression(
										propertyAccessRequire.parent,
									) && isIdentifier(propertyAccessRequire.parent.right) && ((_b = type.symbol) === null || _b === void 0 ? void 0 : _b.valueDeclaration) && isSourceFile(
										type.symbol.valueDeclaration,
									)
								) {
									var alias = localName === propertyAccessRequire.parent.right.escapedText ? undefined : propertyAccessRequire.parent.right;
									addResult(
										factory.createExportDeclaration(
											/*decorators*/ undefined,
											/*modifiers*/ undefined,
											/*isTypeOnly*/ false,
											factory.createNamedExports(
												[
													factory.createExportSpecifier(
														false, /*isTypeOnly*/
														alias,
														localName,
													),
												],
											),
										),
										ModifierFlags.None,
									);
									context.tracker.trackSymbol(
										type.symbol,
										context.enclosingDeclaration,
										SymbolFlags.Value,
									);
								} else {
									var statement = setTextRange(
										factory.createVariableStatement(
											undefined, /*modifiers*/
											factory.createVariableDeclarationList(
												[
													factory.createVariableDeclaration(
														name_8, /*exclamationToken*/
														undefined,
														serializeTypeForDeclaration(
															context,
															type,
															symbol,
															enclosingDeclaration,
															includePrivateSymbol,
															bundled,
														),
													),
												],
												flags,
											),
										),
										textRange,
									);
									addResult(
										statement,
										name_8 !== localName ? modifierFlags & ~ModifierFlags.Export : modifierFlags,
									);
									if (name_8 !== localName && !isPrivate) {
										// We rename the variable declaration we generate for Property symbols since they may have a name which
										// conflicts with a local declaration. For example, given input:
										// ```
										// function g() {}
										// module.exports.g = g
										// ```
										// In such a situation, we have a local variable named `g`, and a separate exported variable named `g`.
										// Naively, we would emit
										// ```
										// function g() {}
										// export const g: typeof g;
										// ```
										// That's obviously incorrect - the `g` in the type annotation needs to refer to the local `g`, but
										// the export declaration shadows it.
										// To work around that, we instead write
										// ```
										// function g() {}
										// const g_1: typeof g;
										// export { g_1 as g };
										// ```
										// To create an export named `g` that does _not_ shadow the local `g`
										addResult(
											factory.createExportDeclaration(
												/*decorators*/ undefined,
												/*modifiers*/ undefined,
												/*isTypeOnly*/ false,
												factory.createNamedExports(
													[
														factory.createExportSpecifier(
															false, /*isTypeOnly*/
															name_8,
															localName,
														),
													],
												),
											),
											ModifierFlags.None,
										);
										needsExportDeclaration = false;
										needsPostExportDefault = false;
									}
								}
							}
						}
					}
					if (symbol.flags & SymbolFlags.Enum) {
						serializeEnum(symbol, symbolName, modifierFlags);
					}
					if (symbol.flags & SymbolFlags.Class) {
						if (
							symbol.flags & SymbolFlags.Property && symbol.valueDeclaration && isBinaryExpression(
								symbol.valueDeclaration.parent,
							) && isClassExpression(symbol.valueDeclaration.parent.right)
						) {
							// Looks like a `module.exports.Sub = class {}` - if we serialize `symbol` as a class, the result will have no members,
							// since the classiness is actually from the target of the effective alias the symbol is. yes. A BlockScopedVariable|Class|Property
							// _really_ acts like an Alias, and none of a BlockScopedVariable, Class, or Property. This is the travesty of JS binding today.
							serializeAsAlias(
								symbol,
								getInternalSymbolName(symbol, symbolName),
								modifierFlags,
							);
						} else {
							serializeAsClass(
								symbol,
								getInternalSymbolName(symbol, symbolName),
								modifierFlags,
							);
						}
					}
					if (
						(symbol.flags & (SymbolFlags.ValueModule | SymbolFlags.NamespaceModule) && (!isConstMergedWithNS || isTypeOnlyNamespace(
							symbol,
						))) || isConstMergedWithNSPrintableAsSignatureMerge
					) {
						serializeModule(symbol, symbolName, modifierFlags);
					}
					// The class meaning serialization should handle serializing all interface members
					if (
						symbol.flags & SymbolFlags.Interface && !(symbol.flags & SymbolFlags.Class)
					) {
						serializeInterface(symbol, symbolName, modifierFlags);
					}
					if (symbol.flags & SymbolFlags.Alias) {
						serializeAsAlias(
							symbol,
							getInternalSymbolName(symbol, symbolName),
							modifierFlags,
						);
					}
					if (
						symbol.flags & SymbolFlags.Property && symbol.escapedName === InternalSymbolName.ExportEquals
					) {
						serializeMaybeAliasAssignment(symbol);
					}
					if (symbol.flags & SymbolFlags.ExportStar) {
						// synthesize export * from "moduleReference"
						// Straightforward - only one thing to do - make an export declaration
						if (symbol.declarations) {
							for (var _i = 0, _c = symbol.declarations; _i < _c.length; _i++) {
								var node = _c[_i];
								var resolvedModule = resolveExternalModuleName(
									node,
									node.moduleSpecifier,
								);
								if (!resolvedModule) continue;
								addResult(
									factory.createExportDeclaration(
										undefined, /*decorators*/ /*modifiers*/
										undefined, /*isTypeOnly*/
										false, /*exportClause*/
										undefined,
										factory.createStringLiteral(
											getSpecifierForModuleSymbol(resolvedModule, context),
										),
									),
									ModifierFlags.None,
								);
							}
						}
					}
					if (needsPostExportDefault) {
						addResult(
							factory.createExportAssignment(
								undefined, /*decorators*/ /*modifiers*/
								undefined, /*isExportAssignment*/
								false,
								factory.createIdentifier(
									getInternalSymbolName(symbol, symbolName),
								),
							),
							ModifierFlags.None,
						);
					} else if (needsExportDeclaration) {
						addResult(
							factory.createExportDeclaration(
								/*decorators*/ undefined,
								/*modifiers*/ undefined,
								/*isTypeOnly*/ false,
								factory.createNamedExports(
									[
										factory.createExportSpecifier(
											false, /*isTypeOnly*/
											getInternalSymbolName(symbol, symbolName),
											symbolName,
										),
									],
								),
							),
							ModifierFlags.None,
						);
					}
				}
				function includePrivateSymbol(symbol) {
					if (some(symbol.declarations, isParameterDeclaration)) return;
					Debug.assertIsDefined(
						deferredPrivatesStack[deferredPrivatesStack.length - 1],
					);
					getUnusedName(unescapeLeadingUnderscores(symbol.escapedName), symbol); // Call to cache unique name for symbol
					// Blanket moving (import) aliases into the root private context should work, since imports are not valid within namespaces
					// (so they must have been in the root to begin with if they were real imports) cjs `require` aliases (an upcoming feature)
					// will throw a wrench in this, since those may have been nested, but we'll need to synthesize them in the outer scope
					// anyway, as that's the only place the import they translate to is valid. In such a case, we might need to use a unique name
					// for the moved import; which hopefully the above `getUnusedName` call should produce.
					var isExternalImportAlias = !!(symbol.flags & SymbolFlags.Alias) && !some(
						symbol.declarations,
						function (d) {
							return !!findAncestor(d, isExportDeclaration) || isNamespaceExport(
								d,
							) || (isImportEqualsDeclaration(d) && !isExternalModuleReference(
								d.moduleReference,
							));
						},
					);
					deferredPrivatesStack[isExternalImportAlias ? 0 : (deferredPrivatesStack.length - 1)].set(
						getSymbolId(symbol),
						symbol,
					);
				}
				function isExportingScope(enclosingDeclaration) {
					return ((isSourceFile(enclosingDeclaration) && (isExternalOrCommonJsModule(
						enclosingDeclaration,
					) || isJsonSourceFile(enclosingDeclaration))) || (isAmbientModule(
						enclosingDeclaration,
					) && !isGlobalScopeAugmentation(enclosingDeclaration)));
				}
				// Prepends a `declare` and/or `export` modifier if the context requires it, and then adds `node` to `result` and returns `node`
				function addResult(node, additionalModifierFlags) {
					if (canHaveModifiers(node)) {
						var newModifierFlags = ModifierFlags.None;
						var enclosingDeclaration_1 = context.enclosingDeclaration && (isJSDocTypeAlias(
							context.enclosingDeclaration,
						) ? getSourceFileOfNode(context.enclosingDeclaration) : context.enclosingDeclaration);
						if (
							additionalModifierFlags & ModifierFlags.Export && enclosingDeclaration_1 && (isExportingScope(
								enclosingDeclaration_1,
							) || isModuleDeclaration(enclosingDeclaration_1)) && canHaveExportModifier(
								node,
							)
						) {
							// Classes, namespaces, variables, functions, interfaces, and types should all be `export`ed in a module context if not private
							newModifierFlags |= ModifierFlags.Export;
						}
						if (
							addingDeclare && !(newModifierFlags & ModifierFlags.Export) && (!enclosingDeclaration_1 || !(enclosingDeclaration_1.flags & NodeFlags.Ambient)) && (isEnumDeclaration(
								node,
							) || isVariableStatement(node) || isFunctionDeclaration(node) || isClassDeclaration(
								node,
							) || isModuleDeclaration(node))
						) {
							// Classes, namespaces, variables, enums, and functions all need `declare` modifiers to be valid in a declaration file top-level scope
							newModifierFlags |= ModifierFlags.Ambient;
						}
						if (
							(additionalModifierFlags & ModifierFlags.Default) && (isClassDeclaration(
								node,
							) || isInterfaceDeclaration(node) || isFunctionDeclaration(node))
						) {
							newModifierFlags |= ModifierFlags.Default;
						}
						if (newModifierFlags) {
							node = factory.updateModifiers(
								node,
								newModifierFlags | getEffectiveModifierFlags(node),
							);
						}
					}
					results.push(node);
				}
				function serializeTypeAlias(symbol, symbolName, modifierFlags) {
					var _a;
					var aliasType = getDeclaredTypeOfTypeAlias(symbol);
					var typeParams = getSymbolLinks(symbol).typeParameters;
					var typeParamDecls = map(
						typeParams,
						function (p) {
							return typeParameterToDeclaration(p, context);
						},
					);
					var jsdocAliasDecl = (_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.find(
						isJSDocTypeAlias,
					);
					var commentText = getTextOfJSDocComment(
						jsdocAliasDecl ? jsdocAliasDecl.comment || jsdocAliasDecl.parent.comment : undefined,
					);
					var oldFlags = context.flags;
					context.flags |= NodeBuilderFlags.InTypeAlias;
					var oldEnclosingDecl = context.enclosingDeclaration;
					context.enclosingDeclaration = jsdocAliasDecl;
					var typeNode = jsdocAliasDecl && jsdocAliasDecl.typeExpression && isJSDocTypeExpression(
						jsdocAliasDecl.typeExpression,
					) && serializeExistingTypeNode(
						context,
						jsdocAliasDecl.typeExpression.type,
						includePrivateSymbol,
						bundled,
					) || typeToTypeNodeHelper(aliasType, context);
					addResult(setSyntheticLeadingComments(factory.createTypeAliasDeclaration(/*decorators*/ undefined, /*modifiers*/ undefined, getInternalSymbolName(symbol, symbolName), typeParamDecls, typeNode), !commentText ? [] : [{ kind: SyntaxKind.MultiLineCommentTrivia, text: "*\n * " + commentText.replace(/\n/g, "\n * ") + "\n ", pos: -1, end: -1, hasTrailingNewLine: true }]), modifierFlags);
					context.flags = oldFlags;
					context.enclosingDeclaration = oldEnclosingDecl;
				}
				function serializeInterface(symbol, symbolName, modifierFlags) {
					var interfaceType = getDeclaredTypeOfClassOrInterface(symbol);
					var localParams = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(
						symbol,
					);
					var typeParamDecls = map(
						localParams,
						function (p) {
							return typeParameterToDeclaration(p, context);
						},
					);
					var baseTypes = getBaseTypes(interfaceType);
					var baseType = length(baseTypes) ? getIntersectionType(baseTypes) : undefined;
					var members = flatMap(
						getPropertiesOfType(interfaceType),
						function (p) {
							return serializePropertySymbolForInterface(p, baseType);
						},
					);
					var callSignatures = serializeSignatures(
						SignatureKind.Call,
						interfaceType,
						baseType,
						SyntaxKind.CallSignature,
					);
					var constructSignatures = serializeSignatures(
						SignatureKind.Construct,
						interfaceType,
						baseType,
						SyntaxKind.ConstructSignature,
					);
					var indexSignatures = serializeIndexSignatures(
						interfaceType,
						baseType,
					);
					var heritageClauses = !length(baseTypes) ? undefined : [
						factory.createHeritageClause(
							SyntaxKind.ExtendsKeyword,
							mapDefined(
								baseTypes,
								function (b) {
									return trySerializeAsTypeReference(b, SymbolFlags.Value);
								},
							),
						),
					];
					addResult(
						factory.createInterfaceDeclaration(
							/*decorators*/ undefined,
							/*modifiers*/ undefined,
							getInternalSymbolName(symbol, symbolName),
							typeParamDecls,
							heritageClauses,
							__spreadArray(
								__spreadArray(
									__spreadArray(
										__spreadArray([], indexSignatures, true),
										constructSignatures,
										true,
									),
									callSignatures,
									true,
								),
								members,
								true,
							),
						),
						modifierFlags,
					);
				}
				function getNamespaceMembersForSerialization(symbol) {
					return !symbol.exports ? [] : filter(
						arrayFrom(symbol.exports.values()),
						isNamespaceMember,
					);
				}
				function isTypeOnlyNamespace(symbol) {
					return every(
						getNamespaceMembersForSerialization(symbol),
						function (m) {
							return !(resolveSymbol(m).flags & SymbolFlags.Value);
						},
					);
				}
				function serializeModule(symbol, symbolName, modifierFlags) {
					var members = getNamespaceMembersForSerialization(symbol);
					// Split NS members up by declaration - members whose parent symbol is the ns symbol vs those whose is not (but were added in later via merging)
					var locationMap = arrayToMultiMap(
						members,
						function (m) {
							return m.parent && m.parent === symbol ? "real" : "merged";
						},
					);
					var realMembers = locationMap.get("real") || emptyArray;
					var mergedMembers = locationMap.get("merged") || emptyArray;
					// TODO: `suppressNewPrivateContext` is questionable -we need to simply be emitting privates in whatever scope they were declared in, rather
					// than whatever scope we traverse to them in. That's a bit of a complex rewrite, since we're not _actually_ tracking privates at all in advance,
					// so we don't even have placeholders to fill in.
					if (length(realMembers)) {
						var localName = getInternalSymbolName(symbol, symbolName);
						serializeAsNamespaceDeclaration(
							realMembers,
							localName,
							modifierFlags,
							!!(symbol.flags & (SymbolFlags.Function | SymbolFlags.Assignment)),
						);
					}
					if (length(mergedMembers)) {
						var containingFile_1 = getSourceFileOfNode(
							context.enclosingDeclaration,
						);
						var localName = getInternalSymbolName(symbol, symbolName);
						var nsBody = factory.createModuleBlock(
							[
								factory.createExportDeclaration(
									/*decorators*/ undefined,
									/*modifiers*/ undefined,
									/*isTypeOnly*/ false,
									factory.createNamedExports(
										mapDefined(
											filter(
												mergedMembers,
												function (n) {
													return n.escapedName !== InternalSymbolName.ExportEquals;
												},
											),
											function (s) {
												var _a, _b;
												var name = unescapeLeadingUnderscores(s.escapedName);
												var localName = getInternalSymbolName(s, name);
												var aliasDecl = s.declarations && getDeclarationOfAliasSymbol(
													s,
												);
												if (
													containingFile_1 && (aliasDecl ? containingFile_1 !== getSourceFileOfNode(
														aliasDecl,
													) : !some(
														s.declarations,
														function (d) {
															return getSourceFileOfNode(d) === containingFile_1;
														},
													))
												) {
													(_b = (_a = context.tracker) === null || _a === void 0 ? void 0 : _a.reportNonlocalAugmentation) === null || _b === void 0 ? void 0 : _b.call(
														_a,
														containingFile_1,
														symbol,
														s,
													);
													return undefined;
												}
												var target = aliasDecl && getTargetOfAliasDeclaration(
													aliasDecl, /*dontRecursivelyResolve*/
													true,
												);
												includePrivateSymbol(target || s);
												var targetName = target ? getInternalSymbolName(
													target,
													unescapeLeadingUnderscores(target.escapedName),
												) : localName;
												return factory.createExportSpecifier(
													false, /*isTypeOnly*/
													name === targetName ? undefined : targetName,
													name,
												);
											},
										),
									),
								),
							],
						);
						addResult(
							factory.createModuleDeclaration(
								/*decorators*/ undefined,
								/*modifiers*/ undefined,
								factory.createIdentifier(localName),
								nsBody,
								NodeFlags.Namespace,
							),
							ModifierFlags.None,
						);
					}
				}
				function serializeEnum(symbol, symbolName, modifierFlags) {
					addResult(
						factory.createEnumDeclaration(
							/*decorators*/ undefined,
							factory.createModifiersFromModifierFlags(
								isConstEnumSymbol(symbol) ? ModifierFlags.Const : 0,
							),
							getInternalSymbolName(symbol, symbolName),
							map(
								filter(
									getPropertiesOfType(getTypeOfSymbol(symbol)),
									function (p) {
										return !!(p.flags & SymbolFlags.EnumMember);
									},
								),
								function (p) {
									// TODO: Handle computed names
									// I hate that to get the initialized value we need to walk back to the declarations here; but there's no
									// other way to get the possible const value of an enum member that I'm aware of, as the value is cached
									// _on the declaration_, not on the declaration's symbol...
									var initializedValue = p.declarations && p.declarations[0] && isEnumMember(
										p.declarations[0],
									) ? getConstantValue(p.declarations[0]) : undefined;
									return factory.createEnumMember(
										unescapeLeadingUnderscores(p.escapedName),
										initializedValue === undefined ? undefined : typeof initializedValue === "string" ? factory.createStringLiteral(
											initializedValue,
										) : factory.createNumericLiteral(initializedValue),
									);
								},
							),
						),
						modifierFlags,
					);
				}
				function serializeAsFunctionNamespaceMerge(
					type,
					symbol,
					localName,
					modifierFlags,
				) {
					var signatures = getSignaturesOfType(type, SignatureKind.Call);
					for (
						var _i = 0, signatures_2 = signatures;
						_i < signatures_2.length;
						_i++
					) {
						var sig = signatures_2[_i];
						// Each overload becomes a separate function declaration, in order
						var decl = signatureToSignatureDeclarationHelper(
							sig,
							SyntaxKind.FunctionDeclaration,
							context,
							{
								name: factory.createIdentifier(localName),
								privateSymbolVisitor: includePrivateSymbol,
								bundledImports: bundled,
							},
						);
						addResult(
							setTextRange(decl, getSignatureTextRangeLocation(sig)),
							modifierFlags,
						);
					}
					// Module symbol emit will take care of module-y members, provided it has exports
					if (
						!(symbol.flags & (SymbolFlags.ValueModule | SymbolFlags.NamespaceModule) && !!symbol.exports && !!symbol.exports.size)
					) {
						var props = filter(getPropertiesOfType(type), isNamespaceMember);
						serializeAsNamespaceDeclaration(
							props,
							localName,
							modifierFlags, /*suppressNewPrivateContext*/
							true,
						);
					}
				}
				function getSignatureTextRangeLocation(signature) {
					if (signature.declaration && signature.declaration.parent) {
						if (
							isBinaryExpression(signature.declaration.parent) && getAssignmentDeclarationKind(
								signature.declaration.parent,
							) === AssignmentDeclarationKind.Property
						) {
							return signature.declaration.parent;
						}
						// for expressions assigned to `var`s, use the `var` as the text range
						if (
							isVariableDeclaration(signature.declaration.parent) && signature.declaration.parent.parent
						) {
							return signature.declaration.parent.parent;
						}
					}
					return signature.declaration;
				}
				function serializeAsNamespaceDeclaration(
					props,
					localName,
					modifierFlags,
					suppressNewPrivateContext,
				) {
					if (length(props)) {
						var localVsRemoteMap = arrayToMultiMap(
							props,
							function (p) {
								return !length(p.declarations) || some(
									p.declarations,
									function (d) {
										return getSourceFileOfNode(d) === getSourceFileOfNode(
											context.enclosingDeclaration,
										);
									},
								) ? "local" : "remote";
							},
						);
						var localProps = localVsRemoteMap.get("local") || emptyArray;
						// handle remote props first - we need to make an `import` declaration that points at the module containing each remote
						// prop in the outermost scope (TODO: a namespace within a namespace would need to be appropriately handled by this)
						// Example:
						// import Foo_1 = require("./exporter");
						// export namespace ns {
						//     import Foo = Foo_1.Foo;
						//     export { Foo };
						//     export const c: number;
						// }
						// This is needed because in JS, statements like `const x = require("./f")` support both type and value lookup, even if they're
						// normally just value lookup (so it functions kinda like an alias even when it's not an alias)
						// _Usually_, we'll simply print the top-level as an alias instead of a `var` in such situations, however is is theoretically
						// possible to encounter a situation where a type has members from both the current file and other files - in those situations,
						// emit akin to the above would be needed.
						// Add a namespace
						// Create namespace as non-synthetic so it is usable as an enclosing declaration
						var fakespace = parseNodeFactory.createModuleDeclaration(
							undefined, /*decorators*/ /*modifiers*/
							undefined,
							factory.createIdentifier(localName),
							factory.createModuleBlock([]),
							NodeFlags.Namespace,
						);
						setParent(fakespace, enclosingDeclaration);
						fakespace.locals = createSymbolTable(props);
						fakespace.symbol = props[0].parent;
						var oldResults = results;
						results = [];
						var oldAddingDeclare = addingDeclare;
						addingDeclare = false;
						var subcontext = __assign(
							__assign({}, context),
							{ enclosingDeclaration: fakespace },
						);
						var oldContext = context;
						context = subcontext;
						// TODO: implement handling for the localVsRemoteMap.get("remote") - should be difficult to trigger (see comment above), as only interesting cross-file js merges should make this possible
						visitSymbolTable(
							createSymbolTable(localProps),
							suppressNewPrivateContext, /*propertyAsAlias*/
							true,
						);
						context = oldContext;
						addingDeclare = oldAddingDeclare;
						var declarations = results;
						results = oldResults;
						// replace namespace with synthetic version
						var defaultReplaced = map(
							declarations,
							function (d) {
								return isExportAssignment(d) && !d.isExportEquals && isIdentifier(
									d.expression,
								) ? factory.createExportDeclaration(
									/*decorators*/ undefined,
									/*modifiers*/ undefined,
									/*isTypeOnly*/ false,
									factory.createNamedExports(
										[
											factory.createExportSpecifier(
												false, /*isTypeOnly*/
												d.expression,
												factory.createIdentifier(InternalSymbolName.Default),
											),
										],
									),
								) : d;
							},
						);
						var exportModifierStripped = every(
							defaultReplaced,
							function (d) {
								return hasSyntacticModifier(d, ModifierFlags.Export);
							},
						) ? map(defaultReplaced, removeExportModifier) : defaultReplaced;
						fakespace = factory.updateModuleDeclaration(
							fakespace,
							fakespace.decorators,
							fakespace.modifiers,
							fakespace.name,
							factory.createModuleBlock(exportModifierStripped),
						);
						addResult(fakespace, modifierFlags); // namespaces can never be default exported
					}
				}
				function isNamespaceMember(p) {
					return !!(p.flags & (SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias)) || !(p.flags & SymbolFlags.Prototype || p.escapedName === "prototype" || p.valueDeclaration && isStatic(
						p.valueDeclaration,
					) && isClassLike(p.valueDeclaration.parent));
				}
				function sanitizeJSDocImplements(clauses) {
					var result = mapDefined(
						clauses,
						function (e) {
							var _a;
							var oldEnclosing = context.enclosingDeclaration;
							context.enclosingDeclaration = e;
							var expr = e.expression;
							if (isEntityNameExpression(expr)) {
								if (isIdentifier(expr) && idText(expr) === "") {
									return cleanup( /*result*/ undefined); // Empty heritage clause, should be an error, but prefer emitting no heritage clauses to reemitting the empty one
								}
								var introducesError = void 0;
								(_a = trackExistingEntityName(expr, context, includePrivateSymbol), introducesError = _a.introducesError, expr = _a.node);
								if (introducesError) {
									return cleanup( /*result*/ undefined);
								}
							}
							return cleanup(
								factory.createExpressionWithTypeArguments(
									expr,
									map(
										e.typeArguments,
										function (a) {
											return serializeExistingTypeNode(
												context,
												a,
												includePrivateSymbol,
												bundled,
											) || typeToTypeNodeHelper(getTypeFromTypeNode(a), context);
										},
									),
								),
							);
							function cleanup(result) {
								context.enclosingDeclaration = oldEnclosing;
								return result;
							}
						},
					);
					if (result.length === clauses.length) {
						return result;
					}
					return undefined;
				}
				function serializeAsClass(symbol, localName, modifierFlags) {
					var _a, _b;
					var originalDecl = (_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.find(
						isClassLike,
					);
					var oldEnclosing = context.enclosingDeclaration;
					context.enclosingDeclaration = originalDecl || oldEnclosing;
					var localParams = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(
						symbol,
					);
					var typeParamDecls = map(
						localParams,
						function (p) {
							return typeParameterToDeclaration(p, context);
						},
					);
					var classType = getDeclaredTypeOfClassOrInterface(symbol);
					var baseTypes = getBaseTypes(classType);
					var originalImplements = originalDecl && getEffectiveImplementsTypeNodes(
						originalDecl,
					);
					var implementsExpressions = originalImplements && sanitizeJSDocImplements(
						originalImplements,
					) || mapDefined(
						getImplementsTypes(classType),
						serializeImplementedType,
					);
					var staticType = getTypeOfSymbol(symbol);
					var isClass = !!((_b = staticType.symbol) === null || _b === void 0 ? void 0 : _b.valueDeclaration) && isClassLike(
						staticType.symbol.valueDeclaration,
					);
					var staticBaseType = isClass ? getBaseConstructorTypeOfClass(
						staticType,
					) : anyType;
					var heritageClauses = __spreadArray(
						__spreadArray(
							[],
							!length(baseTypes) ? [] : [
								factory.createHeritageClause(
									SyntaxKind.ExtendsKeyword,
									map(
										baseTypes,
										function (b) {
											return serializeBaseType(b, staticBaseType, localName);
										},
									),
								),
							],
							true,
						),
						!length(implementsExpressions) ? [] : [
							factory.createHeritageClause(
								SyntaxKind.ImplementsKeyword,
								implementsExpressions,
							),
						],
						true,
					);
					var symbolProps = getNonInterhitedProperties(
						classType,
						baseTypes,
						getPropertiesOfType(classType),
					);
					var publicSymbolProps = filter(
						symbolProps,
						function (s) {
							// `valueDeclaration` could be undefined if inherited from
							// a union/intersection base type, but inherited properties
							// don't matter here.
							var valueDecl = s.valueDeclaration;
							return !!valueDecl && !(isNamedDeclaration(valueDecl) && isPrivateIdentifier(
								valueDecl.name,
							));
						},
					);
					var hasPrivateIdentifier = some(
						symbolProps,
						function (s) {
							// `valueDeclaration` could be undefined if inherited from
							// a union/intersection base type, but inherited properties
							// don't matter here.
							var valueDecl = s.valueDeclaration;
							return !!valueDecl && isNamedDeclaration(valueDecl) && isPrivateIdentifier(
								valueDecl.name,
							);
						},
					);
					// Boil down all private properties into a single one.
					var privateProperties = hasPrivateIdentifier ? [
						factory.createPropertyDeclaration(
							/*decorators*/ undefined,
							/*modifiers*/ undefined,
							factory.createPrivateIdentifier("#private"),
							/*questionOrExclamationToken*/ undefined,
							/*type*/ undefined,
							/*initializer*/ undefined,
						),
					] : emptyArray;
					var publicProperties = flatMap(
						publicSymbolProps,
						function (p) {
							return serializePropertySymbolForClass(
								p, /*isStatic*/
								false,
								baseTypes[0],
							);
						},
					);
					// Consider static members empty if symbol also has function or module meaning - function namespacey emit will handle statics
					var staticMembers = flatMap(
						filter(
							getPropertiesOfType(staticType),
							function (p) {
								return !(p.flags & SymbolFlags.Prototype) && p.escapedName !== "prototype" && !isNamespaceMember(
									p,
								);
							},
						),
						function (p) {
							return serializePropertySymbolForClass(
								p, /*isStatic*/
								true,
								staticBaseType,
							);
						},
					);
					// When we encounter an `X.prototype.y` assignment in a JS file, we bind `X` as a class regardless as to whether
					// the value is ever initialized with a class or function-like value. For cases where `X` could never be
					// created via `new`, we will inject a `private constructor()` declaration to indicate it is not createable.
					var isNonConstructableClassLikeInJsFile = !isClass && !!symbol.valueDeclaration && isInJSFile(
						symbol.valueDeclaration,
					) && !some(getSignaturesOfType(staticType, SignatureKind.Construct));
					var constructors = isNonConstructableClassLikeInJsFile ? [
						factory.createConstructorDeclaration(
							undefined, /*decorators*/
							factory.createModifiersFromModifierFlags(ModifierFlags.Private),
							[], /*body*/
							undefined,
						),
					] : serializeSignatures(
						SignatureKind.Construct,
						staticType,
						staticBaseType,
						SyntaxKind.Constructor,
					);
					var indexSignatures = serializeIndexSignatures(
						classType,
						baseTypes[0],
					);
					context.enclosingDeclaration = oldEnclosing;
					addResult(
						setTextRange(
							factory.createClassDeclaration(
								/*decorators*/ undefined,
								/*modifiers*/ undefined,
								localName,
								typeParamDecls,
								heritageClauses,
								__spreadArray(
									__spreadArray(
										__spreadArray(
											__spreadArray(
												__spreadArray([], indexSignatures, true),
												staticMembers,
												true,
											),
											constructors,
											true,
										),
										publicProperties,
										true,
									),
									privateProperties,
									true,
								),
							),
							symbol.declarations && filter(
								symbol.declarations,
								function (d) {
									return isClassDeclaration(d) || isClassExpression(d);
								},
							)[0],
						),
						modifierFlags,
					);
				}
				function getSomeTargetNameFromDeclarations(declarations) {
					return firstDefined(
						declarations,
						function (d) {
							if (isImportSpecifier(d) || isExportSpecifier(d)) {
								return idText(d.propertyName || d.name);
							}
							if (isBinaryExpression(d) || isExportAssignment(d)) {
								var expression = isExportAssignment(d) ? d.expression : d.right;
								if (isPropertyAccessExpression(expression)) {
									return idText(expression.name);
								}
							}
							if (isAliasSymbolDeclaration(d)) {
								// This is... heuristic, at best. But it's probably better than always printing the name of the shorthand ambient module.
								var name_9 = getNameOfDeclaration(d);
								if (name_9 && isIdentifier(name_9)) {
									return idText(name_9);
								}
							}
							return undefined;
						},
					);
				}
				function serializeAsAlias(symbol, localName, modifierFlags) {
					var _a, _b, _c, _d, _e;
					// synthesize an alias, eg `export { symbolName as Name }`
					// need to mark the alias `symbol` points at
					// as something we need to serialize as a private declaration as well
					var node = getDeclarationOfAliasSymbol(symbol);
					if (!node) return Debug.fail();
					var target = getMergedSymbol(
						getTargetOfAliasDeclaration(node, /*dontRecursivelyResolve*/ true),
					);
					if (!target) {
						return;
					}
					// If `target` refers to a shorthand module symbol, the name we're trying to pull out isn;t recoverable from the target symbol
					// In such a scenario, we must fall back to looking for an alias declaration on `symbol` and pulling the target name from that
					var verbatimTargetName = isShorthandAmbientModuleSymbol(target) && getSomeTargetNameFromDeclarations(
						symbol.declarations,
					) || unescapeLeadingUnderscores(target.escapedName);
					if (
						verbatimTargetName === InternalSymbolName.ExportEquals && (getESModuleInterop(
							compilerOptions,
						) || compilerOptions.allowSyntheticDefaultImports)
					) {
						// target refers to an `export=` symbol that was hoisted into a synthetic default - rename here to match
						verbatimTargetName = InternalSymbolName.Default;
					}
					var targetName = getInternalSymbolName(target, verbatimTargetName);
					includePrivateSymbol(target); // the target may be within the same scope - attempt to serialize it first
					switch (node.kind) {
						case SyntaxKind.BindingElement:
							if (
								((_b = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.kind) === SyntaxKind.VariableDeclaration
							) {
								// const { SomeClass } = require('./lib');
								var specifier_1 = getSpecifierForModuleSymbol(
									target.parent || target,
									context,
								); // './lib'
								var propertyName = node.propertyName;
								addResult(
									factory.createImportDeclaration(
										/*decorators*/ undefined,
										/*modifiers*/ undefined,
										factory.createImportClause(
											false, /*isTypeOnly*/ /*name*/
											undefined,
											factory.createNamedImports(
												[
													factory.createImportSpecifier(
														/*isTypeOnly*/ false,
														propertyName && isIdentifier(propertyName) ? factory.createIdentifier(
															idText(propertyName),
														) : undefined,
														factory.createIdentifier(localName),
													),
												],
											),
										),
										factory.createStringLiteral(specifier_1),
										/*importClause*/ undefined,
									),
									ModifierFlags.None,
								);
								break;
							}
							// We don't know how to serialize this (nested?) binding element
							Debug.failBadSyntaxKind(
								((_c = node.parent) === null || _c === void 0 ? void 0 : _c.parent) || node,
								"Unhandled binding element grandparent kind in declaration serialization",
							);
							break;
						case SyntaxKind.ShorthandPropertyAssignment:
							if (
								((_e = (_d = node.parent) === null || _d === void 0 ? void 0 : _d.parent) === null || _e === void 0 ? void 0 : _e.kind) === SyntaxKind.BinaryExpression
							) {
								// module.exports = { SomeClass }
								serializeExportSpecifier(
									unescapeLeadingUnderscores(symbol.escapedName),
									targetName,
								);
							}
							break;
						case SyntaxKind.VariableDeclaration:
							// commonjs require: const x = require('y')
							if (isPropertyAccessExpression(node.initializer)) {
								// const x = require('y').z
								var initializer = node.initializer; // require('y').z
								var uniqueName = factory.createUniqueName(localName); // _x
								var specifier_2 = getSpecifierForModuleSymbol(
									target.parent || target,
									context,
								); // 'y'
								// import _x = require('y');
								addResult(
									factory.createImportEqualsDeclaration(
										/*decorators*/ undefined,
										/*modifiers*/ undefined,
										/*isTypeOnly*/ false,
										uniqueName,
										factory.createExternalModuleReference(
											factory.createStringLiteral(specifier_2),
										),
									),
									ModifierFlags.None,
								);
								// import x = _x.z
								addResult(
									factory.createImportEqualsDeclaration(
										/*decorators*/ undefined,
										/*modifiers*/ undefined,
										/*isTypeOnly*/ false,
										factory.createIdentifier(localName),
										factory.createQualifiedName(uniqueName, initializer.name),
									),
									modifierFlags,
								);
								break;
							}
						// else fall through and treat commonjs require just like import=
						case SyntaxKind.ImportEqualsDeclaration:
							// This _specifically_ only exists to handle json declarations - where we make aliases, but since
							// we emit no declarations for the json document, must not refer to it in the declarations
							if (
								target.escapedName === InternalSymbolName.ExportEquals && some(
									target.declarations,
									isJsonSourceFile,
								)
							) {
								serializeMaybeAliasAssignment(symbol);
								break;
							}
							// Could be a local `import localName = ns.member` or
							// an external `import localName = require("whatever")`
							var isLocalImport = !(target.flags & SymbolFlags.ValueModule) && !isVariableDeclaration(
								node,
							);
							addResult(
								factory.createImportEqualsDeclaration(
									/*decorators*/ undefined,
									/*modifiers*/ undefined,
									/*isTypeOnly*/ false,
									factory.createIdentifier(localName),
									isLocalImport ? symbolToName(
										target,
										context,
										SymbolFlags.All, /*expectsIdentifier*/
										false,
									) : factory.createExternalModuleReference(
										factory.createStringLiteral(
											getSpecifierForModuleSymbol(target, context),
										),
									),
								),
								isLocalImport ? modifierFlags : ModifierFlags.None,
							);
							break;
						case SyntaxKind.NamespaceExportDeclaration:
							// export as namespace foo
							// TODO: Not part of a file's local or export symbol tables
							// Is bound into file.symbol.globalExports instead, which we don't currently traverse
							addResult(
								factory.createNamespaceExportDeclaration(idText(node.name)),
								ModifierFlags.None,
							);
							break;
						case SyntaxKind.ImportClause:
							addResult(
								factory.createImportDeclaration(
									/*decorators*/ undefined,
									/*modifiers*/ undefined,
									factory.createImportClause(
										false, /*isTypeOnly*/
										factory.createIdentifier(localName), /*namedBindings*/
										undefined,
									),
									// We use `target.parent || target` below as `target.parent` is unset when the target is a module which has been export assigned
									// And then made into a default by the `esModuleInterop` or `allowSyntheticDefaultImports` flag
									// In such cases, the `target` refers to the module itself already
									factory.createStringLiteral(
										getSpecifierForModuleSymbol(
											target.parent || target,
											context,
										),
									),
									/*assertClause*/ undefined,
								),
								ModifierFlags.None,
							);
							break;
						case SyntaxKind.NamespaceImport:
							addResult(
								factory.createImportDeclaration(
									/*decorators*/ undefined,
									/*modifiers*/ undefined,
									factory.createImportClause(
										false, /*isTypeOnly*/ /*importClause*/
										undefined,
										factory.createNamespaceImport(
											factory.createIdentifier(localName),
										),
									),
									factory.createStringLiteral(
										getSpecifierForModuleSymbol(target, context),
									),
									/*assertClause*/ undefined,
								),
								ModifierFlags.None,
							);
							break;
						case SyntaxKind.NamespaceExport:
							addResult(
								factory.createExportDeclaration(
									/*decorators*/ undefined,
									/*modifiers*/ undefined,
									/*isTypeOnly*/ false,
									factory.createNamespaceExport(
										factory.createIdentifier(localName),
									),
									factory.createStringLiteral(
										getSpecifierForModuleSymbol(target, context),
									),
								),
								ModifierFlags.None,
							);
							break;
						case SyntaxKind.ImportSpecifier:
							addResult(
								factory.createImportDeclaration(
									/*decorators*/ undefined,
									/*modifiers*/ undefined,
									factory.createImportClause(
										/*isTypeOnly*/ false,
										/*importClause*/ undefined,
										factory.createNamedImports(
											[
												factory.createImportSpecifier(
													/*isTypeOnly*/ false,
													localName !== verbatimTargetName ? factory.createIdentifier(
														verbatimTargetName,
													) : undefined,
													factory.createIdentifier(localName),
												),
											],
										),
									),
									factory.createStringLiteral(
										getSpecifierForModuleSymbol(
											target.parent || target,
											context,
										),
									),
									/*assertClause*/ undefined,
								),
								ModifierFlags.None,
							);
							break;
						case SyntaxKind.ExportSpecifier:
							// does not use localName because the symbol name in this case refers to the name in the exports table,
							// which we must exactly preserve
							var specifier = node.parent.parent.moduleSpecifier;
							// targetName is only used when the target is local, as otherwise the target is an alias that points at
							// another file
							serializeExportSpecifier(
								unescapeLeadingUnderscores(symbol.escapedName),
								specifier ? verbatimTargetName : targetName,
								specifier && isStringLiteralLike(specifier) ? factory.createStringLiteral(
									specifier.text,
								) : undefined,
							);
							break;
						case SyntaxKind.ExportAssignment:
							serializeMaybeAliasAssignment(symbol);
							break;
						case SyntaxKind.BinaryExpression:
						case SyntaxKind.PropertyAccessExpression:
						case SyntaxKind.ElementAccessExpression:
							// Could be best encoded as though an export specifier or as though an export assignment
							// If name is default or export=, do an export assignment
							// Otherwise do an export specifier
							if (
								symbol.escapedName === InternalSymbolName.Default || symbol.escapedName === InternalSymbolName.ExportEquals
							) {
								serializeMaybeAliasAssignment(symbol);
							} else {
								serializeExportSpecifier(localName, targetName);
							}
							break;
						default:
							return Debug.failBadSyntaxKind(
								node,
								"Unhandled alias declaration kind in symbol serializer!",
							);
					}
				}
				function serializeExportSpecifier(localName, targetName, specifier) {
					addResult(
						factory.createExportDeclaration(
							/*decorators*/ undefined,
							/*modifiers*/ undefined,
							/*isTypeOnly*/ false,
							factory.createNamedExports(
								[
									factory.createExportSpecifier(
										false, /*isTypeOnly*/
										localName !== targetName ? targetName : undefined,
										localName,
									),
								],
							),
							specifier,
						),
						ModifierFlags.None,
					);
				}
				/**
                 * Returns `true` if an export assignment or declaration was produced for the symbol
                 */
				function serializeMaybeAliasAssignment(symbol) {
					if (symbol.flags & SymbolFlags.Prototype) {
						return false;
					}
					var name = unescapeLeadingUnderscores(symbol.escapedName);
					var isExportEquals = name === InternalSymbolName.ExportEquals;
					var isDefault = name === InternalSymbolName.Default;
					var isExportAssignmentCompatibleSymbolName = isExportEquals || isDefault;
					// synthesize export = ref
					// ref should refer to either be a locally scoped symbol which we need to emit, or
					// a reference to another namespace/module which we may need to emit an `import` statement for
					var aliasDecl = symbol.declarations && getDeclarationOfAliasSymbol(
						symbol,
					);
					// serialize what the alias points to, preserve the declaration's initializer
					var target = aliasDecl && getTargetOfAliasDeclaration(
						aliasDecl, /*dontRecursivelyResolve*/
						true,
					);
					// If the target resolves and resolves to a thing defined in this file, emit as an alias, otherwise emit as a const
					if (
						target && length(target.declarations) && some(
							target.declarations,
							function (d) {
								return getSourceFileOfNode(d) === getSourceFileOfNode(
									enclosingDeclaration,
								);
							},
						)
					) {
						// In case `target` refers to a namespace member, look at the declaration and serialize the leftmost symbol in it
						// eg, `namespace A { export class B {} }; exports = A.B;`
						// Technically, this is all that's required in the case where the assignment is an entity name expression
						var expr = aliasDecl && ((isExportAssignment(aliasDecl) || isBinaryExpression(
							aliasDecl,
						)) ? getExportAssignmentExpression(aliasDecl) : getPropertyAssignmentAliasLikeExpression(
							aliasDecl,
						));
						var first = expr && isEntityNameExpression(expr) ? getFirstNonModuleExportsIdentifier(
							expr,
						) : undefined;
						var referenced = first && resolveEntityName(
							first,
							SymbolFlags.All, /*ignoreErrors*/
							true, /*dontResolveAlias*/
							true,
							enclosingDeclaration,
						);
						if (referenced || target) {
							includePrivateSymbol(referenced || target);
						}
						// We disable the context's symbol tracker for the duration of this name serialization
						// as, by virtue of being here, the name is required to print something, and we don't want to
						// issue a visibility error on it. Only anonymous classes that an alias points at _would_ issue
						// a visibility error here (as they're not visible within any scope), but we want to hoist them
						// into the containing scope anyway, so we want to skip the visibility checks.
						var oldTrack = context.tracker.trackSymbol;
						context.tracker.trackSymbol = function () {
							return false;
						};
						if (isExportAssignmentCompatibleSymbolName) {
							results.push(
								factory.createExportAssignment(
									/*decorators*/ undefined,
									/*modifiers*/ undefined,
									isExportEquals,
									symbolToExpression(target, context, SymbolFlags.All),
								),
							);
						} else {
							if (first === expr && first) {
								// serialize as `export {target as name}`
								serializeExportSpecifier(name, idText(first));
							} else if (expr && isClassExpression(expr)) {
								serializeExportSpecifier(
									name,
									getInternalSymbolName(target, symbolName(target)),
								);
							} else {
								// serialize as `import _Ref = t.arg.et; export { _Ref as name }`
								var varName = getUnusedName(name, symbol);
								addResult(
									factory.createImportEqualsDeclaration(
										/*decorators*/ undefined,
										/*modifiers*/ undefined,
										/*isTypeOnly*/ false,
										factory.createIdentifier(varName),
										symbolToName(
											target,
											context,
											SymbolFlags.All, /*expectsIdentifier*/
											false,
										),
									),
									ModifierFlags.None,
								);
								serializeExportSpecifier(name, varName);
							}
						}
						context.tracker.trackSymbol = oldTrack;
						return true;
					} else {
						// serialize as an anonymous property declaration
						var varName = getUnusedName(name, symbol);
						// We have to use `getWidenedType` here since the object within a json file is unwidened within the file
						// (Unwidened types can only exist in expression contexts and should never be serialized)
						var typeToSerialize = getWidenedType(
							getTypeOfSymbol(getMergedSymbol(symbol)),
						);
						if (
							isTypeRepresentableAsFunctionNamespaceMerge(
								typeToSerialize,
								symbol,
							)
						) {
							// If there are no index signatures and `typeToSerialize` is an object type, emit as a namespace instead of a const
							serializeAsFunctionNamespaceMerge(
								typeToSerialize,
								symbol,
								varName,
								isExportAssignmentCompatibleSymbolName ? ModifierFlags.None : ModifierFlags.Export,
							);
						} else {
							var statement = factory.createVariableStatement(
								undefined, /*modifiers*/
								factory.createVariableDeclarationList(
									[
										factory.createVariableDeclaration(
											varName, /*exclamationToken*/
											undefined,
											serializeTypeForDeclaration(
												context,
												typeToSerialize,
												symbol,
												enclosingDeclaration,
												includePrivateSymbol,
												bundled,
											),
										),
									],
									NodeFlags.Const,
								),
							);
							// Inlined JSON types exported with [module.]exports= will already emit an export=, so should use `declare`.
							// Otherwise, the type itself should be exported.
							addResult(
								statement,
								target && target.flags & SymbolFlags.Property && target.escapedName === InternalSymbolName.ExportEquals ? ModifierFlags.Ambient : name === varName ? ModifierFlags.Export : ModifierFlags.None,
							);
						}
						if (isExportAssignmentCompatibleSymbolName) {
							results.push(
								factory.createExportAssignment(
									/*decorators*/ undefined,
									/*modifiers*/ undefined,
									isExportEquals,
									factory.createIdentifier(varName),
								),
							);
							return true;
						} else if (name !== varName) {
							serializeExportSpecifier(name, varName);
							return true;
						}
						return false;
					}
				}
				function isTypeRepresentableAsFunctionNamespaceMerge(
					typeToSerialize,
					hostSymbol,
				) {
					// Only object types which are not constructable, or indexable, whose members all come from the
					// context source file, and whose property names are all valid identifiers and not late-bound, _and_
					// whose input is not type annotated (if the input symbol has an annotation we can reuse, we should prefer it)
					var ctxSrc = getSourceFileOfNode(context.enclosingDeclaration);
					return getObjectFlags(typeToSerialize) & (ObjectFlags.Anonymous | ObjectFlags.Mapped) && !length(
						getIndexInfosOfType(typeToSerialize),
					) && !isClassInstanceSide(typeToSerialize) && !!(length(
						filter(getPropertiesOfType(typeToSerialize), isNamespaceMember), // While a class instance is potentially representable as a NS, prefer printing a reference to the instance type and serializing the class
					) || length(getSignaturesOfType(typeToSerialize, SignatureKind.Call))) && !length(
						getSignaturesOfType(typeToSerialize, SignatureKind.Construct),
					) && !getDeclarationWithTypeAnnotation(
						hostSymbol, // TODO: could probably serialize as function + ns + class, now that that's OK
						enclosingDeclaration,
					) && !(typeToSerialize.symbol && some(
						typeToSerialize.symbol.declarations,
						function (d) {
							return getSourceFileOfNode(d) !== ctxSrc;
						},
					)) && !some(
						getPropertiesOfType(typeToSerialize),
						function (p) {
							return isLateBoundName(p.escapedName);
						},
					) && !some(
						getPropertiesOfType(typeToSerialize),
						function (p) {
							return some(
								p.declarations,
								function (d) {
									return getSourceFileOfNode(d) !== ctxSrc;
								},
							);
						},
					) && every(
						getPropertiesOfType(typeToSerialize),
						function (p) {
							return isIdentifierText(symbolName(p), languageVersion);
						},
					);
				}
				function makeSerializePropertySymbol(
					createProperty,
					methodKind,
					useAccessors,
				) {
					return function serializePropertySymbol(p, isStatic, baseType) {
						var _a, _b, _c, _d, _e;
						var modifierFlags = getDeclarationModifierFlagsFromSymbol(p);
						var isPrivate = !!(modifierFlags & ModifierFlags.Private);
						if (
							isStatic && (p.flags & (SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias))
						) {
							// Only value-only-meaning symbols can be correctly encoded as class statics, type/namespace/alias meaning symbols
							// need to be merged namespace members
							return [];
						}
						if (
							p.flags & SymbolFlags.Prototype || (baseType && getPropertyOfType(
								baseType,
								p.escapedName,
							) && isReadonlySymbol(getPropertyOfType(baseType, p.escapedName)) === isReadonlySymbol(
								p,
							) && (p.flags & SymbolFlags.Optional) === (getPropertyOfType(
								baseType,
								p.escapedName,
							).flags & SymbolFlags.Optional) && isTypeIdenticalTo(
								getTypeOfSymbol(p),
								getTypeOfPropertyOfType(baseType, p.escapedName),
							))
						) {
							return [];
						}
						var flag = (modifierFlags & ~ModifierFlags.Async) | (isStatic ? ModifierFlags.Static : 0);
						var name = getPropertyNameNodeForSymbol(p, context);
						var firstPropertyLikeDecl = (_a = p.declarations) === null || _a === void 0 ? void 0 : _a.find(
							or(
								isPropertyDeclaration,
								isAccessor,
								isVariableDeclaration,
								isPropertySignature,
								isBinaryExpression,
								isPropertyAccessExpression,
							),
						);
						if (p.flags & SymbolFlags.Accessor && useAccessors) {
							var result = [];
							if (p.flags & SymbolFlags.SetAccessor) {
								result.push(
									setTextRange(
										factory.createSetAccessorDeclaration(
											/*decorators*/ undefined,
											factory.createModifiersFromModifierFlags(flag),
											name,
											[
												factory.createParameterDeclaration(
													/*decorators*/ undefined,
													/*modifiers*/ undefined,
													/*dotDotDotToken*/ undefined,
													"arg",
													/*questionToken*/ undefined,
													isPrivate ? undefined : serializeTypeForDeclaration(
														context,
														getTypeOfSymbol(p),
														p,
														enclosingDeclaration,
														includePrivateSymbol,
														bundled,
													),
												),
											],
											/*body*/ undefined,
										),
										((_b = p.declarations) === null || _b === void 0 ? void 0 : _b.find(
											isSetAccessor,
										)) || firstPropertyLikeDecl,
									),
								);
							}
							if (p.flags & SymbolFlags.GetAccessor) {
								var isPrivate_1 = modifierFlags & ModifierFlags.Private;
								result.push(
									setTextRange(
										factory.createGetAccessorDeclaration(
											/*decorators*/ undefined,
											factory.createModifiersFromModifierFlags(flag),
											name,
											[],
											isPrivate_1 ? undefined : serializeTypeForDeclaration(
												context,
												getTypeOfSymbol(p),
												p,
												enclosingDeclaration,
												includePrivateSymbol,
												bundled,
											),
											/*body*/ undefined,
										),
										((_c = p.declarations) === null || _c === void 0 ? void 0 : _c.find(
											isGetAccessor,
										)) || firstPropertyLikeDecl,
									),
								);
							}
							return result;
						} else if ( // If this happens, we assume the accessor takes priority, as it imposes more constraints // This is an else/if as accessors and properties can't merge in TS, but might in JS
							p.flags & (SymbolFlags.Property | SymbolFlags.Variable | SymbolFlags.Accessor)
						) {
							return setTextRange(
								createProperty(
									/*decorators*/ undefined,
									factory.createModifiersFromModifierFlags(
										(isReadonlySymbol(p) ? ModifierFlags.Readonly : 0) | flag,
									),
									name,
									p.flags & SymbolFlags.Optional ? factory.createToken(
										SyntaxKind.QuestionToken,
									) : undefined,
									isPrivate ? undefined : serializeTypeForDeclaration(
										context,
										getTypeOfSymbol(p),
										p,
										enclosingDeclaration,
										includePrivateSymbol,
										bundled,
									),
									// TODO: https://github.com/microsoft/TypeScript/pull/32372#discussion_r328386357
									// interface members can't have initializers, however class members _can_
									/*initializer*/ undefined,
								),
								((_d = p.declarations) === null || _d === void 0 ? void 0 : _d.find(
									or(isPropertyDeclaration, isVariableDeclaration),
								)) || firstPropertyLikeDecl,
							);
						}
						if (p.flags & (SymbolFlags.Method | SymbolFlags.Function)) {
							var type = getTypeOfSymbol(p);
							var signatures = getSignaturesOfType(type, SignatureKind.Call);
							if (flag & ModifierFlags.Private) {
								return setTextRange(
									createProperty(
										/*decorators*/ undefined,
										factory.createModifiersFromModifierFlags(
											(isReadonlySymbol(p) ? ModifierFlags.Readonly : 0) | flag,
										),
										name,
										p.flags & SymbolFlags.Optional ? factory.createToken(
											SyntaxKind.QuestionToken,
										) : undefined,
										/*type*/ undefined,
										/*initializer*/ undefined,
									),
									((_e = p.declarations) === null || _e === void 0 ? void 0 : _e.find(
										isFunctionLikeDeclaration,
									)) || signatures[0] && signatures[0].declaration || p.declarations && p.declarations[0],
								);
							}
							var results_1 = [];
							for (
								var _i = 0, signatures_3 = signatures;
								_i < signatures_3.length;
								_i++
							) {
								var sig = signatures_3[_i];
								// Each overload becomes a separate method declaration, in order
								var decl = signatureToSignatureDeclarationHelper(
									sig,
									methodKind,
									context,
									{
										name: name,
										questionToken: p.flags & SymbolFlags.Optional ? factory.createToken(
											SyntaxKind.QuestionToken,
										) : undefined,
										modifiers: flag ? factory.createModifiersFromModifierFlags(
											flag,
										) : undefined,
									},
								);
								var location_2 = sig.declaration && isPrototypePropertyAssignment(
									sig.declaration.parent,
								) ? sig.declaration.parent : sig.declaration;
								results_1.push(setTextRange(decl, location_2));
							}
							return results_1;
						}
						// The `Constructor`'s symbol isn't in the class's properties lists, obviously, since it's a signature on the static
						return Debug.fail(
							"Unhandled class member kind! ".concat(p.__debugFlags || p.flags),
						);
					};
				}
				function serializePropertySymbolForInterface(p, baseType) {
					return serializePropertySymbolForInterfaceWorker(
						p, /*isStatic*/
						false,
						baseType,
					);
				}
				function serializeSignatures(kind, input, baseType, outputKind) {
					var signatures = getSignaturesOfType(input, kind);
					if (kind === SignatureKind.Construct) {
						if (
							!baseType && every(
								signatures,
								function (s) {
									return length(s.parameters) === 0;
								},
							)
						) {
							return []; // No base type, every constructor is empty - elide the extraneous `constructor()`
						}
						if (baseType) {
							// If there is a base type, if every signature in the class is identical to a signature in the baseType, elide all the declarations
							var baseSigs = getSignaturesOfType(
								baseType,
								SignatureKind.Construct,
							);
							if (
								!length(baseSigs) && every(
									signatures,
									function (s) {
										return length(s.parameters) === 0;
									},
								)
							) {
								return []; // Base had no explicit signatures, if all our signatures are also implicit, return an empty list
							}
							if (baseSigs.length === signatures.length) {
								var failed = false;
								for (var i = 0; i < baseSigs.length; i++) {
									if (
										!compareSignaturesIdentical(
											signatures[i],
											baseSigs[i], /*partialMatch*/
											false, /*ignoreThisTypes*/
											false, /*ignoreReturnTypes*/
											true,
											compareTypesIdentical,
										)
									) {
										failed = true;
										break;
									}
								}
								if (!failed) {
									return []; // Every signature was identical - elide constructor list as it is inherited
								}
							}
						}
						var privateProtected = 0;
						for (
							var _i = 0, signatures_4 = signatures;
							_i < signatures_4.length;
							_i++
						) {
							var s = signatures_4[_i];
							if (s.declaration) {
								privateProtected |= getSelectedEffectiveModifierFlags(
									s.declaration,
									ModifierFlags.Private | ModifierFlags.Protected,
								);
							}
						}
						if (privateProtected) {
							return [
								setTextRange(
									factory.createConstructorDeclaration(
										/*decorators*/ undefined,
										factory.createModifiersFromModifierFlags(privateProtected),
										/*parameters*/ [],
										/*body*/ undefined,
									),
									signatures[0].declaration,
								),
							];
						}
					}
					var results = [];
					for (
						var _a = 0, signatures_5 = signatures;
						_a < signatures_5.length;
						_a++
					) {
						var sig = signatures_5[_a];
						// Each overload becomes a separate constructor declaration, in order
						var decl = signatureToSignatureDeclarationHelper(
							sig,
							outputKind,
							context,
						);
						results.push(setTextRange(decl, sig.declaration));
					}
					return results;
				}
				function serializeIndexSignatures(input, baseType) {
					var results = [];
					for (var _i = 0, _a = getIndexInfosOfType(input); _i < _a.length; _i++) {
						var info = _a[_i];
						if (baseType) {
							var baseInfo = getIndexInfoOfType(baseType, info.keyType);
							if (baseInfo) {
								if (isTypeIdenticalTo(info.type, baseInfo.type)) {
									continue; // elide identical index signatures
								}
							}
						}
						results.push(
							indexInfoToIndexSignatureDeclarationHelper(
								info,
								context, /*typeNode*/
								undefined,
							),
						);
					}
					return results;
				}
				function serializeBaseType(t, staticType, rootName) {
					var ref = trySerializeAsTypeReference(t, SymbolFlags.Value);
					if (ref) {
						return ref;
					}
					var tempName = getUnusedName("".concat(rootName, "_base"));
					var statement = factory.createVariableStatement(
						undefined, /*modifiers*/
						factory.createVariableDeclarationList(
							[
								factory.createVariableDeclaration(
									tempName, /*exclamationToken*/
									undefined,
									typeToTypeNodeHelper(staticType, context),
								),
							],
							NodeFlags.Const,
						),
					);
					addResult(statement, ModifierFlags.None);
					return factory.createExpressionWithTypeArguments(
						factory.createIdentifier(tempName), /*typeArgs*/
						undefined,
					);
				}
				function trySerializeAsTypeReference(t, flags) {
					var typeArgs;
					var reference;
					// We don't use `isValueSymbolAccessible` below. since that considers alternative containers (like modules)
					// which we can't write out in a syntactically valid way as an expression
					if (
						t.target && isSymbolAccessibleByFlags(
							t.target.symbol,
							enclosingDeclaration,
							flags,
						)
					) {
						typeArgs = map(
							getTypeArguments(t),
							function (t) {
								return typeToTypeNodeHelper(t, context);
							},
						);
						reference = symbolToExpression(
							t.target.symbol,
							context,
							SymbolFlags.Type,
						);
					} else if (
						t.symbol && isSymbolAccessibleByFlags(
							t.symbol,
							enclosingDeclaration,
							flags,
						)
					) {
						reference = symbolToExpression(t.symbol, context, SymbolFlags.Type);
					}
					if (reference) {
						return factory.createExpressionWithTypeArguments(
							reference,
							typeArgs,
						);
					}
				}
				function serializeImplementedType(t) {
					var ref = trySerializeAsTypeReference(t, SymbolFlags.Type);
					if (ref) {
						return ref;
					}
					if (t.symbol) {
						return factory.createExpressionWithTypeArguments(
							symbolToExpression(t.symbol, context, SymbolFlags.Type), /*typeArgs*/
							undefined,
						);
					}
				}
				function getUnusedName(input, symbol) {
					var _a, _b;
					var id = symbol ? getSymbolId(symbol) : undefined;
					if (id) {
						if (context.remappedSymbolNames.has(id)) {
							return context.remappedSymbolNames.get(id);
						}
					}
					if (symbol) {
						input = getNameCandidateWorker(symbol, input);
					}
					var i = 0;
					var original = input;
					while (
						(_a = context.usedSymbolNames) === null || _a === void 0 ? void 0 : _a.has(
							input,
						)
					) {
						i++;
						input = "".concat(original, "_").concat(i);
					}
					(_b = context.usedSymbolNames) === null || _b === void 0 ? void 0 : _b.add(
						input,
					);
					if (id) {
						context.remappedSymbolNames.set(id, input);
					}
					return input;
				}
				function getNameCandidateWorker(symbol, localName) {
					if (
						localName === InternalSymbolName.Default || localName === InternalSymbolName.Class || localName === InternalSymbolName.Function
					) {
						var flags = context.flags;
						context.flags |= NodeBuilderFlags.InInitialEntityName;
						var nameCandidate = getNameOfSymbolAsWritten(symbol, context);
						context.flags = flags;
						localName = nameCandidate.length > 0 && isSingleOrDoubleQuote(
							nameCandidate.charCodeAt(0),
						) ? stripQuotes(nameCandidate) : nameCandidate;
					}
					if (localName === InternalSymbolName.Default) {
						localName = "_default";
					} else if (localName === InternalSymbolName.ExportEquals) {
						localName = "_exports";
					}
					localName = isIdentifierText(localName, languageVersion) && !isStringANonContextualKeyword(localName) ? localName : "_" + localName.replace(/[^a-zA-Z0-9]/g, "_");
					return localName;
				}
				function getInternalSymbolName(symbol, localName) {
					var id = getSymbolId(symbol);
					if (context.remappedSymbolNames.has(id)) {
						return context.remappedSymbolNames.get(id);
					}
					localName = getNameCandidateWorker(symbol, localName);
					// The result of this is going to be used as the symbol's name - lock it in, so `getUnusedName` will also pick it up
					context.remappedSymbolNames.set(id, localName);
					return localName;
				}
			}
		}
		function typePredicateToString(
			typePredicate,
			enclosingDeclaration,
			flags,
			writer,
		) {
			if (flags === void 0) {
				flags = TypeFormatFlags.UseAliasDefinedOutsideCurrentScope;
			}
			return writer ? typePredicateToStringWorker(writer).getText() : usingSingleLineStringWriter(
				typePredicateToStringWorker,
			);
			function typePredicateToStringWorker(writer) {
				var predicate = factory.createTypePredicateNode(
					typePredicate.kind === TypePredicateKind.AssertsThis || typePredicate.kind === TypePredicateKind.AssertsIdentifier ? factory.createToken(
						SyntaxKind.AssertsKeyword,
					) : undefined,
					typePredicate.kind === TypePredicateKind.Identifier || typePredicate.kind === TypePredicateKind.AssertsIdentifier ? factory.createIdentifier(
						typePredicate.parameterName,
					) : factory.createThisTypeNode(),
					typePredicate.type && nodeBuilder.typeToTypeNode(
						typePredicate.type,
						enclosingDeclaration,
						toNodeBuilderFlags(flags) | NodeBuilderFlags.IgnoreErrors | NodeBuilderFlags.WriteTypeParametersInQualifiedName,
					), // TODO: GH#18217
				);
				var printer = createPrinter({ removeComments: true });
				var sourceFile = enclosingDeclaration && getSourceFileOfNode(
					enclosingDeclaration,
				);
				printer.writeNode(
					EmitHint.Unspecified,
					predicate, /*sourceFile*/
					sourceFile,
					writer,
				);
				return writer;
			}
		}
		function formatUnionTypes(types) {
			var result = [];
			var flags = 0;
			for (var i = 0; i < types.length; i++) {
				var t = types[i];
				flags |= t.flags;
				if (!(t.flags & TypeFlags.Nullable)) {
					if (t.flags & (TypeFlags.BooleanLiteral | TypeFlags.EnumLiteral)) {
						var baseType = t.flags & TypeFlags.BooleanLiteral ? booleanType : getBaseTypeOfEnumLiteralType(
							t,
						);
						if (baseType.flags & TypeFlags.Union) {
							var count = baseType.types.length;
							if (
								i + count <= types.length && getRegularTypeOfLiteralType(
									types[i + count - 1],
								) === getRegularTypeOfLiteralType(baseType.types[count - 1])
							) {
								result.push(baseType);
								i += count - 1;
								continue;
							}
						}
					}
					result.push(t);
				}
			}
			if (flags & TypeFlags.Null) result.push(nullType);
			if (flags & TypeFlags.Undefined) result.push(undefinedType);
			return result || types;
		}
		function visibilityToString(flags) {
			if (flags === ModifierFlags.Private) {
				return "private";
			}
			if (flags === ModifierFlags.Protected) {
				return "protected";
			}
			return "public";
		}
		function getTypeAliasForTypeLiteral(type) {
			if (
				type.symbol && type.symbol.flags & SymbolFlags.TypeLiteral && type.symbol.declarations
			) {
				var node = walkUpParenthesizedTypes(type.symbol.declarations[0].parent);
				if (node.kind === SyntaxKind.TypeAliasDeclaration) {
					return getSymbolOfNode(node);
				}
			}
			return undefined;
		}
		function isTopLevelInExternalModuleAugmentation(node) {
			return node && node.parent && node.parent.kind === SyntaxKind.ModuleBlock && isExternalModuleAugmentation(
				node.parent.parent,
			);
		}
		function isDefaultBindingContext(location) {
			return location.kind === SyntaxKind.SourceFile || isAmbientModule(
				location,
			);
		}
		function getNameOfSymbolFromNameType(symbol, context) {
			var nameType = getSymbolLinks(symbol).nameType;
			if (nameType) {
				if (nameType.flags & TypeFlags.StringOrNumberLiteral) {
					var name_10 = "" + nameType.value;
					if (
						!isIdentifierText(name_10, getEmitScriptTarget(compilerOptions)) && !isNumericLiteralName(
							name_10,
						)
					) {
						return "\"".concat(
							escapeString(name_10, CharacterCodes.doubleQuote),
							"\"",
						);
					}
					if (isNumericLiteralName(name_10) && startsWith(name_10, "-")) {
						return "[".concat(name_10, "]");
					}
					return name_10;
				}
				if (nameType.flags & TypeFlags.UniqueESSymbol) {
					return "[".concat(
						getNameOfSymbolAsWritten(nameType.symbol, context),
						"]",
					);
				}
			}
		}
		/**
         * Gets a human-readable name for a symbol.
         * Should *not* be used for the right-hand side of a `.` -- use `symbolName(symbol)` for that instead.
         *
         * Unlike `symbolName(symbol)`, this will include quotes if the name is from a string literal.
         * It will also use a representation of a number as written instead of a decimal form, e.g. `0o11` instead of `9`.
         */
		function getNameOfSymbolAsWritten(symbol, context) {
			if (
				context && symbol.escapedName === InternalSymbolName.Default && !(context.flags & NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope) && (!(context.flags & NodeBuilderFlags.InInitialEntityName) || !symbol.declarations || (context.enclosingDeclaration && findAncestor(
					symbol.declarations[0], // If it's not the first part of an entity name, it must print as `default` // if the symbol is synthesized, it will only be referenced externally it must print as `default` // if not in the same binding context (source file, module declaration), it must print as `default`
					isDefaultBindingContext,
				) !== findAncestor(
					context.enclosingDeclaration,
					isDefaultBindingContext,
				)))
			) {
				return "default";
			}
			if (symbol.declarations && symbol.declarations.length) {
				var declaration = firstDefined(
					symbol.declarations,
					function (d) {
						return getNameOfDeclaration(d) ? d : undefined;
					},
				); // Try using a declaration with a name, first
				var name_11 = declaration && getNameOfDeclaration(declaration);
				if (declaration && name_11) {
					if (
						isCallExpression(declaration) && isBindableObjectDefinePropertyCall(
							declaration,
						)
					) {
						return symbolName(symbol);
					}
					if (
						isComputedPropertyName(name_11) && !(getCheckFlags(symbol) & CheckFlags.Late)
					) {
						var nameType = getSymbolLinks(symbol).nameType;
						if (nameType && nameType.flags & TypeFlags.StringOrNumberLiteral) {
							// Computed property name isn't late bound, but has a well-known name type - use name type to generate a symbol name
							var result = getNameOfSymbolFromNameType(symbol, context);
							if (result !== undefined) {
								return result;
							}
						}
					}
					return declarationNameToString(name_11);
				}
				if (!declaration) {
					declaration = symbol.declarations[0]; // Declaration may be nameless, but we'll try anyway
				}
				if (
					declaration.parent && declaration.parent.kind === SyntaxKind.VariableDeclaration
				) {
					return declarationNameToString(declaration.parent.name);
				}
				switch (declaration.kind) {
					case SyntaxKind.ClassExpression:
					case SyntaxKind.FunctionExpression:
					case SyntaxKind.ArrowFunction:
						if (
							context && !context.encounteredError && !(context.flags & NodeBuilderFlags.AllowAnonymousIdentifier)
						) {
							context.encounteredError = true;
						}
						return declaration.kind === SyntaxKind.ClassExpression ? "(Anonymous class)" : "(Anonymous function)";
				}
			}
			var name = getNameOfSymbolFromNameType(symbol, context);
			return name !== undefined ? name : symbolName(symbol);
		}
		function isDeclarationVisible(node) {
			if (node) {
				var links = getNodeLinks(node);
				if (links.isVisible === undefined) {
					links.isVisible = !!determineIfDeclarationIsVisible();
				}
				return links.isVisible;
			}
			return false;
			function determineIfDeclarationIsVisible() {
				switch (node.kind) {
					case SyntaxKind.JSDocCallbackTag:
					case SyntaxKind.JSDocTypedefTag:
					case SyntaxKind.JSDocEnumTag:
						// Top-level jsdoc type aliases are considered exported
						// First parent is comment node, second is hosting declaration or token; we only care about those tokens or declarations whose parent is a source file
						return !!(node.parent && node.parent.parent && node.parent.parent.parent && isSourceFile(
							node.parent.parent.parent,
						));
					case SyntaxKind.BindingElement:
						return isDeclarationVisible(node.parent.parent);
					case SyntaxKind.VariableDeclaration:
						if (isBindingPattern(node.name) && !node.name.elements.length) {
							// If the binding pattern is empty, this variable declaration is not visible
							return false;
						}
					// falls through
					case SyntaxKind.ModuleDeclaration:
					case SyntaxKind.ClassDeclaration:
					case SyntaxKind.InterfaceDeclaration:
					case SyntaxKind.TypeAliasDeclaration:
					case SyntaxKind.FunctionDeclaration:
					case SyntaxKind.EnumDeclaration:
					case SyntaxKind.ImportEqualsDeclaration:
						// external module augmentation is always visible
						if (isExternalModuleAugmentation(node)) {
							return true;
						}
						var parent_5 = getDeclarationContainer(node);
						// If the node is not exported or it is not ambient module element (except import declaration)
						if (
							!(getCombinedModifierFlags(node) & ModifierFlags.Export) && !(node.kind !== SyntaxKind.ImportEqualsDeclaration && parent_5.kind !== SyntaxKind.SourceFile && parent_5.flags & NodeFlags.Ambient)
						) {
							return isGlobalSourceFile(parent_5);
						}
						// Exported members/ambient module elements (exception import declaration) are visible if parent is visible
						return isDeclarationVisible(parent_5);
					case SyntaxKind.PropertyDeclaration:
					case SyntaxKind.PropertySignature:
					case SyntaxKind.GetAccessor:
					case SyntaxKind.SetAccessor:
					case SyntaxKind.MethodDeclaration:
					case SyntaxKind.MethodSignature:
						if (
							hasEffectiveModifier(
								node,
								ModifierFlags.Private | ModifierFlags.Protected,
							)
						) {
							// Private/protected properties/methods are not visible
							return false;
						}
					// Public properties/methods are visible if its parents are visible, so:
					// falls through
					case SyntaxKind.Constructor:
					case SyntaxKind.ConstructSignature:
					case SyntaxKind.CallSignature:
					case SyntaxKind.IndexSignature:
					case SyntaxKind.Parameter:
					case SyntaxKind.ModuleBlock:
					case SyntaxKind.FunctionType:
					case SyntaxKind.ConstructorType:
					case SyntaxKind.TypeLiteral:
					case SyntaxKind.TypeReference:
					case SyntaxKind.ArrayType:
					case SyntaxKind.TupleType:
					case SyntaxKind.UnionType:
					case SyntaxKind.IntersectionType:
					case SyntaxKind.ParenthesizedType:
					case SyntaxKind.NamedTupleMember:
						return isDeclarationVisible(node.parent);
					// Default binding, import specifier and namespace import is visible
					// only on demand so by default it is not visible
					case SyntaxKind.ImportClause:
					case SyntaxKind.NamespaceImport:
					case SyntaxKind.ImportSpecifier:
						return false;
					// Type parameters are always visible
					case SyntaxKind.TypeParameter:
					// Source file and namespace export are always visible
					// falls through
					case SyntaxKind.SourceFile:
					case SyntaxKind.NamespaceExportDeclaration:
						return true;
					// Export assignments do not create name bindings outside the module
					case SyntaxKind.ExportAssignment:
						return false;
					default:
						return false;
				}
			}
		}
		function collectLinkedAliases(node, setVisibility) {
			var exportSymbol;
			if (node.parent && node.parent.kind === SyntaxKind.ExportAssignment) {
				exportSymbol = resolveName(
					node,
					node.escapedText,
					SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias, /*nameNotFoundMessage*/
					undefined,
					node, /*isUse*/
					false,
				);
			} else if (node.parent.kind === SyntaxKind.ExportSpecifier) {
				exportSymbol = getTargetOfExportSpecifier(
					node.parent,
					SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias,
				);
			}
			var result;
			var visited;
			if (exportSymbol) {
				visited = new Set();
				visited.add(getSymbolId(exportSymbol));
				buildVisibleNodeList(exportSymbol.declarations);
			}
			return result;
			function buildVisibleNodeList(declarations) {
				forEach(
					declarations,
					function (declaration) {
						var resultNode = getAnyImportSyntax(declaration) || declaration;
						if (setVisibility) {
							getNodeLinks(declaration).isVisible = true;
						} else {
							result = result || [];
							pushIfUnique(result, resultNode);
						}
						if (isInternalModuleImportEqualsDeclaration(declaration)) {
							// Add the referenced top container visible
							var internalModuleReference = declaration.moduleReference;
							var firstIdentifier = getFirstIdentifier(internalModuleReference);
							var importSymbol = resolveName(
								declaration,
								firstIdentifier.escapedText,
								SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace,
								undefined,
								undefined, /*isUse*/
								false,
							);
							if (importSymbol && visited) {
								if (tryAddToSet(visited, getSymbolId(importSymbol))) {
									buildVisibleNodeList(importSymbol.declarations);
								}
							}
						}
					},
				);
			}
		}
		/**
         * Push an entry on the type resolution stack. If an entry with the given target and the given property name
         * is already on the stack, and no entries in between already have a type, then a circularity has occurred.
         * In this case, the result values of the existing entry and all entries pushed after it are changed to false,
         * and the value false is returned. Otherwise, the new entry is just pushed onto the stack, and true is returned.
         * In order to see if the same query has already been done before, the target object and the propertyName both
         * must match the one passed in.
         *
         * @param target The symbol, type, or signature whose type is being queried
         * @param propertyName The property name that should be used to query the target for its type
         */
		function pushTypeResolution(target, propertyName) {
			var resolutionCycleStartIndex = findResolutionCycleStartIndex(
				target,
				propertyName,
			);
			if (resolutionCycleStartIndex >= 0) {
				// A cycle was found
				var length_2 = resolutionTargets.length;
				for (var i = resolutionCycleStartIndex; i < length_2; i++) {
					resolutionResults[i] = false;
				}
				return false;
			}
			resolutionTargets.push(target);
			resolutionResults.push( /*items*/ true);
			resolutionPropertyNames.push(propertyName);
			return true;
		}
		function findResolutionCycleStartIndex(target, propertyName) {
			for (var i = resolutionTargets.length - 1; i >= 0; i--) {
				if (hasType(resolutionTargets[i], resolutionPropertyNames[i])) {
					return -1;
				}
				if (
					resolutionTargets[i] === target && resolutionPropertyNames[i] === propertyName
				) {
					return i;
				}
			}
			return -1;
		}
		function hasType(target, propertyName) {
			switch (propertyName) {
				case 0: /* Type */
					return !!getSymbolLinks(target).type;
				case 5: /* EnumTagType */
					return !!(getNodeLinks(target).resolvedEnumType);
				case 2: /* DeclaredType */
					return !!getSymbolLinks(target).declaredType;
				case 1: /* ResolvedBaseConstructorType */
					return !!target.resolvedBaseConstructorType;
				case 3: /* ResolvedReturnType */
					return !!target.resolvedReturnType;
				case 4: /* ImmediateBaseConstraint */
					return !!target.immediateBaseConstraint;
				case 6: /* ResolvedTypeArguments */
					return !!target.resolvedTypeArguments;
				case 7: /* ResolvedBaseTypes */
					return !!target.baseTypesResolved;
			}
			return Debug.assertNever(propertyName);
		}
		/**
         * Pop an entry from the type resolution stack and return its associated result value. The result value will
         * be true if no circularities were detected, or false if a circularity was found.
         */
		function popTypeResolution() {
			resolutionTargets.pop();
			resolutionPropertyNames.pop();
			return resolutionResults.pop();
		}
		function getDeclarationContainer(node) {
			return findAncestor(
				getRootDeclaration(node),
				function (node) {
					switch (node.kind) {
						case SyntaxKind.VariableDeclaration:
						case SyntaxKind.VariableDeclarationList:
						case SyntaxKind.ImportSpecifier:
						case SyntaxKind.NamedImports:
						case SyntaxKind.NamespaceImport:
						case SyntaxKind.ImportClause:
							return false;
						default:
							return true;
					}
				},
			).parent;
		}
		function getTypeOfPrototypeProperty(prototype) {
			// TypeScript 1.0 spec (April 2014): 8.4
			// Every class automatically contains a static property member named 'prototype',
			// the type of which is an instantiation of the class type with type Any supplied as a type argument for each type parameter.
			// It is an error to explicitly declare a static property member with the name 'prototype'.
			var classType = getDeclaredTypeOfSymbol(getParentOfSymbol(prototype));
			return classType.typeParameters ? createTypeReference(
				classType,
				map(
					classType.typeParameters,
					function (_) {
						return anyType;
					},
				),
			) : classType;
		}
		// Return the type of the given property in the given type, or undefined if no such property exists
		function getTypeOfPropertyOfType(type, name) {
			var prop = getPropertyOfType(type, name);
			return prop ? getTypeOfSymbol(prop) : undefined;
		}
		function getTypeOfPropertyOrIndexSignature(type, name) {
			var _a;
			return getTypeOfPropertyOfType(type, name) || ((_a = getApplicableIndexInfoForName(
				type,
				name,
			)) === null || _a === void 0 ? void 0 : _a.type) || unknownType;
		}
		function isTypeAny(type) {
			return type && (type.flags & TypeFlags.Any) !== 0;
		}
		function isErrorType(type) {
			// The only 'any' types that have alias symbols are those manufactured by getTypeFromTypeAliasReference for
			// a reference to an unresolved symbol. We want those to behave like the errorType.
			return type === errorType || !!(type.flags & TypeFlags.Any && type.aliasSymbol);
		}
		// Return the type of a binding element parent. We check SymbolLinks first to see if a type has been
		// assigned by contextual typing.
		function getTypeForBindingElementParent(node) {
			var symbol = getSymbolOfNode(node);
			return symbol && getSymbolLinks(symbol).type || getTypeForVariableLikeDeclaration(
				node, /*includeOptionality*/
				false,
			);
		}
		function getRestType(source, properties, symbol) {
			source = filterType(
				source,
				function (t) {
					return !(t.flags & TypeFlags.Nullable);
				},
			);
			if (source.flags & TypeFlags.Never) {
				return emptyObjectType;
			}
			if (source.flags & TypeFlags.Union) {
				return mapType(
					source,
					function (t) {
						return getRestType(t, properties, symbol);
					},
				);
			}
			var omitKeyType = getUnionType(
				map(properties, getLiteralTypeFromPropertyName),
			);
			var spreadableProperties = [];
			var unspreadableToRestKeys = [];
			for (var _i = 0, _a = getPropertiesOfType(source); _i < _a.length; _i++) {
				var prop = _a[_i];
				var literalTypeFromProperty = getLiteralTypeFromProperty(
					prop,
					TypeFlags.StringOrNumberLiteralOrUnique,
				);
				if (
					!isTypeAssignableTo(literalTypeFromProperty, omitKeyType) && !(getDeclarationModifierFlagsFromSymbol(
						prop,
					) & (ModifierFlags.Private | ModifierFlags.Protected)) && isSpreadableProperty(
						prop,
					)
				) {
					spreadableProperties.push(prop);
				} else {
					unspreadableToRestKeys.push(literalTypeFromProperty);
				}
			}
			if (isGenericObjectType(source) || isGenericIndexType(omitKeyType)) {
				if (unspreadableToRestKeys.length) {
					// If the type we're spreading from has properties that cannot
					// be spread into the rest type (e.g. getters, methods), ensure
					// they are explicitly omitted, as they would in the non-generic case.
					omitKeyType = getUnionType(
						__spreadArray([omitKeyType], unspreadableToRestKeys, true),
					);
				}
				if (omitKeyType.flags & TypeFlags.Never) {
					return source;
				}
				var omitTypeAlias = getGlobalOmitSymbol();
				if (!omitTypeAlias) {
					return errorType;
				}
				return getTypeAliasInstantiation(omitTypeAlias, [source, omitKeyType]);
			}
			var members = createSymbolTable();
			for (
				var _b = 0, spreadableProperties_1 = spreadableProperties;
				_b < spreadableProperties_1.length;
				_b++
			) {
				var prop = spreadableProperties_1[_b];
				members.set(prop.escapedName, getSpreadSymbol(prop, /*readonly*/ false));
			}
			var result = createAnonymousType(
				symbol,
				members,
				emptyArray,
				emptyArray,
				getIndexInfosOfType(source),
			);
			result.objectFlags |= ObjectFlags.ObjectRestType;
			return result;
		}
		function isGenericTypeWithUndefinedConstraint(type) {
			return !!(type.flags & TypeFlags.Instantiable) && maybeTypeOfKind(
				getBaseConstraintOfType(type) || unknownType,
				TypeFlags.Undefined,
			);
		}
		function getNonUndefinedType(type) {
			var typeOrConstraint = someType(
				type,
				isGenericTypeWithUndefinedConstraint,
			) ? mapType(
				type,
				function (t) {
					return t.flags & TypeFlags.Instantiable ? getBaseConstraintOrType(t) : t;
				},
			) : type;
			return getTypeWithFacts(typeOrConstraint, 524288 /* NEUndefined */ );
		}
		// Determine the control flow type associated with a destructuring declaration or assignment. The following
		// forms of destructuring are possible:
		//   let { x } = obj;  // BindingElement
		//   let [ x ] = obj;  // BindingElement
		//   { x } = obj;      // ShorthandPropertyAssignment
		//   { x: v } = obj;   // PropertyAssignment
		//   [ x ] = obj;      // Expression
		// We construct a synthetic element access expression corresponding to 'obj.x' such that the control
		// flow analyzer doesn't have to handle all the different syntactic forms.
		function getFlowTypeOfDestructuring(node, declaredType) {
			var reference = getSyntheticElementAccess(node);
			return reference ? getFlowTypeOfReference(reference, declaredType) : declaredType;
		}
		function getSyntheticElementAccess(node) {
			var parentAccess = getParentElementAccess(node);
			if (parentAccess && parentAccess.flowNode) {
				var propName = getDestructuringPropertyName(node);
				if (propName) {
					var literal = setTextRange(
						parseNodeFactory.createStringLiteral(propName),
						node,
					);
					var lhsExpr = isLeftHandSideExpression(parentAccess) ? parentAccess : parseNodeFactory.createParenthesizedExpression(
						parentAccess,
					);
					var result = setTextRange(
						parseNodeFactory.createElementAccessExpression(lhsExpr, literal),
						node,
					);
					setParent(literal, result);
					setParent(result, node);
					if (lhsExpr !== parentAccess) {
						setParent(lhsExpr, result);
					}
					result.flowNode = parentAccess.flowNode;
					return result;
				}
			}
		}
		function getParentElementAccess(node) {
			var ancestor = node.parent.parent;
			switch (ancestor.kind) {
				case SyntaxKind.BindingElement:
				case SyntaxKind.PropertyAssignment:
					return getSyntheticElementAccess(ancestor);
				case SyntaxKind.ArrayLiteralExpression:
					return getSyntheticElementAccess(node.parent);
				case SyntaxKind.VariableDeclaration:
					return ancestor.initializer;
				case SyntaxKind.BinaryExpression:
					return ancestor.right;
			}
		}
		function getDestructuringPropertyName(node) {
			var parent = node.parent;
			if (
				node.kind === SyntaxKind.BindingElement && parent.kind === SyntaxKind.ObjectBindingPattern
			) {
				return getLiteralPropertyNameText(node.propertyName || node.name);
			}
			if (
				node.kind === SyntaxKind.PropertyAssignment || node.kind === SyntaxKind.ShorthandPropertyAssignment
			) {
				return getLiteralPropertyNameText(node.name);
			}
			return "" + parent.elements.indexOf(node);
		}
		function getLiteralPropertyNameText(name) {
			var type = getLiteralTypeFromPropertyName(name);
			return type.flags & (TypeFlags.StringLiteral | TypeFlags.NumberLiteral) ? "" + type.value : undefined;
		}
		/** Return the inferred type for a binding element */
		function getTypeForBindingElement(declaration) {
			var parentType = getTypeForBindingElementParent(declaration.parent.parent);
			return parentType && getBindingElementTypeFromParentType(
				declaration,
				parentType,
			);
		}
		function getBindingElementTypeFromParentType(declaration, parentType) {
			// If an any type was inferred for parent, infer that for the binding element
			if (isTypeAny(parentType)) {
				return parentType;
			}
			var pattern = declaration.parent;
			// Relax null check on ambient destructuring parameters, since the parameters have no implementation and are just documentation
			if (
				strictNullChecks && declaration.flags & NodeFlags.Ambient && isParameterDeclaration(
					declaration,
				)
			) {
				parentType = getNonNullableType(parentType);
			} else if (
				strictNullChecks && pattern.parent.initializer && !(getTypeFacts( // Filter `undefined` from the type we check against if the parent has an initializer and that initializer is not possibly `undefined`
					getTypeOfInitializer(pattern.parent.initializer),
				) & 65536) /* EQUndefined */
			) {
				parentType = getTypeWithFacts(parentType, 524288 /* NEUndefined */ );
			}
			var type;
			if (pattern.kind === SyntaxKind.ObjectBindingPattern) {
				if (declaration.dotDotDotToken) {
					parentType = getReducedType(parentType);
					if (
						parentType.flags & TypeFlags.Unknown || !isValidSpreadType(
							parentType,
						)
					) {
						error(
							declaration,
							Diagnostics.Rest_types_may_only_be_created_from_object_types,
						);
						return errorType;
					}
					var literalMembers = [];
					for (var _i = 0, _a = pattern.elements; _i < _a.length; _i++) {
						var element = _a[_i];
						if (!element.dotDotDotToken) {
							literalMembers.push(element.propertyName || element.name);
						}
					}
					type = getRestType(parentType, literalMembers, declaration.symbol);
				} else {
					// Use explicitly specified property name ({ p: xxx } form), or otherwise the implied name ({ p } form)
					var name_12 = declaration.propertyName || declaration.name;
					var indexType = getLiteralTypeFromPropertyName(name_12);
					var declaredType = getIndexedAccessType(
						parentType,
						indexType,
						AccessFlags.ExpressionPosition,
						name_12,
					);
					type = getFlowTypeOfDestructuring(declaration, declaredType);
				}
			} else {
				// This elementType will be used if the specific property corresponding to this index is not
				// present (aka the tuple element property). This call also checks that the parentType is in
				// fact an iterable or array (depending on target language).
				var elementType = checkIteratedTypeOrElementType(
					65 | (declaration.dotDotDotToken ? 0 : 128), /* Destructuring */ /* PossiblyOutOfBounds */
					parentType,
					undefinedType,
					pattern,
				);
				var index_2 = pattern.elements.indexOf(declaration);
				if (declaration.dotDotDotToken) {
					// If the parent is a tuple type, the rest element has a tuple type of the
					// remaining tuple element types. Otherwise, the rest element has an array type with same
					// element type as the parent type.
					type = everyType(parentType, isTupleType) ? mapType(
						parentType,
						function (t) {
							return sliceTupleType(t, index_2);
						},
					) : createArrayType(elementType);
				} else if (isArrayLikeType(parentType)) {
					var indexType = getNumberLiteralType(index_2);
					var accessFlags = AccessFlags.ExpressionPosition | (hasDefaultValue(
						declaration,
					) ? AccessFlags.NoTupleBoundsCheck : 0);
					var declaredType = getIndexedAccessTypeOrUndefined(
						parentType,
						indexType,
						accessFlags,
						declaration.name,
					) || errorType;
					type = getFlowTypeOfDestructuring(declaration, declaredType);
				} else {
					type = elementType;
				}
			}
			if (!declaration.initializer) {
				return type;
			}
			if (
				getEffectiveTypeAnnotationNode(
					walkUpBindingElementsAndPatterns(declaration),
				)
			) {
				// In strict null checking mode, if a default value of a non-undefined type is specified, remove
				// undefined from the final type.
				return strictNullChecks && !(getFalsyFlags(
					checkDeclarationInitializer(declaration),
				) & TypeFlags.Undefined) ? getNonUndefinedType(type) : type;
			}
			return widenTypeInferredFromInitializer(
				declaration,
				getUnionType(
					[getNonUndefinedType(type), checkDeclarationInitializer(declaration)],
					UnionReduction.Subtype,
				),
			);
		}
		function getTypeForDeclarationFromJSDocComment(declaration) {
			var jsdocType = getJSDocType(declaration);
			if (jsdocType) {
				return getTypeFromTypeNode(jsdocType);
			}
			return undefined;
		}
		function isNullOrUndefined(node) {
			var expr = skipParentheses(node, /*excludeJSDocTypeAssertions*/ true);
			return expr.kind === SyntaxKind.NullKeyword || expr.kind === SyntaxKind.Identifier && getResolvedSymbol(
				expr,
			) === undefinedSymbol;
		}
		function isEmptyArrayLiteral(node) {
			var expr = skipParentheses(node, /*excludeJSDocTypeAssertions*/ true);
			return expr.kind === SyntaxKind.ArrayLiteralExpression && expr.elements.length === 0;
		}
		function addOptionality(type, isProperty, isOptional) {
			if (isProperty === void 0) {
				isProperty = false;
			}
			if (isOptional === void 0) {
				isOptional = true;
			}
			return strictNullChecks && isOptional ? getOptionalType(type, isProperty) : type;
		}
		// Return the inferred type for a variable, parameter, or property declaration
		function getTypeForVariableLikeDeclaration(declaration, includeOptionality) {
			// A variable declared in a for..in statement is of type string, or of type keyof T when the
			// right hand expression is of a type parameter type.
			if (
				isVariableDeclaration(declaration) && declaration.parent.parent.kind === SyntaxKind.ForInStatement
			) {
				var indexType = getIndexType(
					getNonNullableTypeIfNeeded(
						checkExpression(declaration.parent.parent.expression),
					),
				);
				return indexType.flags & (TypeFlags.TypeParameter | TypeFlags.Index) ? getExtractStringType(
					indexType,
				) : stringType;
			}
			if (
				isVariableDeclaration(declaration) && declaration.parent.parent.kind === SyntaxKind.ForOfStatement
			) {
				// checkRightHandSideOfForOf will return undefined if the for-of expression type was
				// missing properties/signatures required to get its iteratedType (like
				// [Symbol.iterator] or next). This may be because we accessed properties from anyType,
				// or it may have led to an error inside getElementTypeOfIterable.
				var forOfStatement = declaration.parent.parent;
				return checkRightHandSideOfForOf(forOfStatement) || anyType;
			}
			if (isBindingPattern(declaration.parent)) {
				return getTypeForBindingElement(declaration);
			}
			var isProperty = isPropertyDeclaration(declaration) || isPropertySignature(
				declaration,
			);
			var isOptional = includeOptionality && (isProperty && !!declaration.questionToken || isParameter(
				declaration,
			) && (!!declaration.questionToken || isJSDocOptionalParameter(declaration)) || isOptionalJSDocPropertyLikeTag(
				declaration,
			));
			// Use type from type annotation if one is present
			var declaredType = tryGetTypeFromEffectiveTypeNode(declaration);
			if (declaredType) {
				return addOptionality(declaredType, isProperty, isOptional);
			}
			if (
				(noImplicitAny || isInJSFile(declaration)) && isVariableDeclaration(
					declaration,
				) && !isBindingPattern(declaration.name) && !(getCombinedModifierFlags(
					declaration,
				) & ModifierFlags.Export) && !(declaration.flags & NodeFlags.Ambient)
			) {
				// If --noImplicitAny is on or the declaration is in a Javascript file,
				// use control flow tracked 'any' type for non-ambient, non-exported var or let variables with no
				// initializer or a 'null' or 'undefined' initializer.
				if (
					!(getCombinedNodeFlags(declaration) & NodeFlags.Const) && (!declaration.initializer || isNullOrUndefined(
						declaration.initializer,
					))
				) {
					return autoType;
				}
				// Use control flow tracked 'any[]' type for non-ambient, non-exported variables with an empty array
				// literal initializer.
				if (
					declaration.initializer && isEmptyArrayLiteral(
						declaration.initializer,
					)
				) {
					return autoArrayType;
				}
			}
			if (isParameter(declaration)) {
				var func = declaration.parent;
				// For a parameter of a set accessor, use the type of the get accessor if one is present
				if (func.kind === SyntaxKind.SetAccessor && hasBindableName(func)) {
					var getter = getDeclarationOfKind(
						getSymbolOfNode(declaration.parent),
						SyntaxKind.GetAccessor,
					);
					if (getter) {
						var getterSignature = getSignatureFromDeclaration(getter);
						var thisParameter = getAccessorThisParameter(func);
						if (thisParameter && declaration === thisParameter) {
							// Use the type from the *getter*
							Debug.assert(!thisParameter.type);
							return getTypeOfSymbol(getterSignature.thisParameter);
						}
						return getReturnTypeOfSignature(getterSignature);
					}
				}
				if (isInJSFile(declaration)) {
					var typeTag = getJSDocType(func);
					if (typeTag && isFunctionTypeNode(typeTag)) {
						var signature = getSignatureFromDeclaration(typeTag);
						var pos = func.parameters.indexOf(declaration);
						return declaration.dotDotDotToken ? getRestTypeAtPosition(
							signature,
							pos,
						) : getTypeAtPosition(signature, pos);
					}
				}
				// Use contextual parameter type if one is available
				var type = declaration.symbol.escapedName === InternalSymbolName.This ? getContextualThisParameterType(
					func,
				) : getContextuallyTypedParameterType(declaration);
				if (type) {
					return addOptionality(type, /*isProperty*/ false, isOptional);
				}
			}
			// Use the type of the initializer expression if one is present and the declaration is
			// not a parameter of a contextually typed function
			if (
				hasOnlyExpressionInitializer(declaration) && !!declaration.initializer
			) {
				if (isInJSFile(declaration) && !isParameter(declaration)) {
					var containerObjectType = getJSContainerObjectType(
						declaration,
						getSymbolOfNode(declaration),
						getDeclaredExpandoInitializer(declaration),
					);
					if (containerObjectType) {
						return containerObjectType;
					}
				}
				var type = widenTypeInferredFromInitializer(
					declaration,
					checkDeclarationInitializer(declaration),
				);
				return addOptionality(type, isProperty, isOptional);
			}
			if (
				isPropertyDeclaration(declaration) && (noImplicitAny || isInJSFile(
					declaration,
				))
			) {
				// We have a property declaration with no type annotation or initializer, in noImplicitAny mode or a .js file.
				// Use control flow analysis of this.xxx assignments in the constructor or static block to determine the type of the property.
				if (!hasStaticModifier(declaration)) {
					var constructor = findConstructorDeclaration(declaration.parent);
					var type = constructor ? getFlowTypeInConstructor(
						declaration.symbol,
						constructor,
					) : getEffectiveModifierFlags(declaration) & ModifierFlags.Ambient ? getTypeOfPropertyInBaseClass(
						declaration.symbol,
					) : undefined;
					return type && addOptionality(type, /*isProperty*/ true, isOptional);
				} else {
					var staticBlocks = filter(
						declaration.parent.members,
						isClassStaticBlockDeclaration,
					);
					var type = staticBlocks.length ? getFlowTypeInStaticBlocks(
						declaration.symbol,
						staticBlocks,
					) : getEffectiveModifierFlags(declaration) & ModifierFlags.Ambient ? getTypeOfPropertyInBaseClass(
						declaration.symbol,
					) : undefined;
					return type && addOptionality(type, /*isProperty*/ true, isOptional);
				}
			}
			if (isJsxAttribute(declaration)) {
				// if JSX attribute doesn't have initializer, by default the attribute will have boolean value of true.
				// I.e <Elem attr /> is sugar for <Elem attr={true} />
				return trueType;
			}
			// If the declaration specifies a binding pattern and is not a parameter of a contextually
			// typed function, use the type implied by the binding pattern
			if (isBindingPattern(declaration.name)) {
				return getTypeFromBindingPattern(
					declaration.name, /*includePatternInType*/
					false, /*reportErrors*/
					true,
				);
			}
			// No type specified and nothing can be inferred
			return undefined;
		}
		function isConstructorDeclaredProperty(symbol) {
			// A property is considered a constructor declared property when all declaration sites are this.xxx assignments,
			// when no declaration sites have JSDoc type annotations, and when at least one declaration site is in the body of
			// a class constructor.
			if (
				symbol.valueDeclaration && isBinaryExpression(symbol.valueDeclaration)
			) {
				var links = getSymbolLinks(symbol);
				if (links.isConstructorDeclaredProperty === undefined) {
					links.isConstructorDeclaredProperty = false;
					links.isConstructorDeclaredProperty = !!getDeclaringConstructor(
						symbol,
					) && every(
						symbol.declarations,
						function (declaration) {
							return isBinaryExpression(declaration) && isPossiblyAliasedThisProperty(
								declaration,
							) && (declaration.left.kind !== SyntaxKind.ElementAccessExpression || isStringOrNumericLiteralLike(
								declaration.left.argumentExpression,
							)) && !getAnnotatedTypeForAssignmentDeclaration(
								undefined, /*declaredType*/
								declaration,
								symbol,
								declaration,
							);
						},
					);
				}
				return links.isConstructorDeclaredProperty;
			}
			return false;
		}
		function isAutoTypedProperty(symbol) {
			// A property is auto-typed when its declaration has no type annotation or initializer and we're in
			// noImplicitAny mode or a .js file.
			var declaration = symbol.valueDeclaration;
			return declaration && isPropertyDeclaration(declaration) && !getEffectiveTypeAnnotationNode(
				declaration,
			) && !declaration.initializer && (noImplicitAny || isInJSFile(declaration));
		}
		function getDeclaringConstructor(symbol) {
			if (!symbol.declarations) {
				return;
			}
			for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
				var declaration = _a[_i];
				var container = getThisContainer(
					declaration, /*includeArrowFunctions*/
					false,
				);
				if (
					container && (container.kind === SyntaxKind.Constructor || isJSConstructor(
						container,
					))
				) {
					return container;
				}
			}
		}
		/** Create a synthetic property access flow node after the last statement of the file */
		function getFlowTypeFromCommonJSExport(symbol) {
			var file = getSourceFileOfNode(symbol.declarations[0]);
			var accessName = unescapeLeadingUnderscores(symbol.escapedName);
			var areAllModuleExports = symbol.declarations.every(
				function (d) {
					return isInJSFile(d) && isAccessExpression(d) && isModuleExportsAccessExpression(
						d.expression,
					);
				},
			);
			var reference = areAllModuleExports ? factory.createPropertyAccessExpression(
				factory.createPropertyAccessExpression(
					factory.createIdentifier("module"),
					factory.createIdentifier("exports"),
				),
				accessName,
			) : factory.createPropertyAccessExpression(
				factory.createIdentifier("exports"),
				accessName,
			);
			if (areAllModuleExports) {
				setParent(reference.expression.expression, reference.expression);
			}
			setParent(reference.expression, reference);
			setParent(reference, file);
			reference.flowNode = file.endFlowNode;
			return getFlowTypeOfReference(reference, autoType, undefinedType);
		}
		function getFlowTypeInStaticBlocks(symbol, staticBlocks) {
			var accessName = startsWith(symbol.escapedName, "__#") ? factory.createPrivateIdentifier(
				symbol.escapedName.split("@")[1],
			) : unescapeLeadingUnderscores(symbol.escapedName);
			for (
				var _i = 0, staticBlocks_1 = staticBlocks;
				_i < staticBlocks_1.length;
				_i++
			) {
				var staticBlock = staticBlocks_1[_i];
				var reference = factory.createPropertyAccessExpression(
					factory.createThis(),
					accessName,
				);
				setParent(reference.expression, reference);
				setParent(reference, staticBlock);
				reference.flowNode = staticBlock.returnFlowNode;
				var flowType = getFlowTypeOfProperty(reference, symbol);
				if (
					noImplicitAny && (flowType === autoType || flowType === autoArrayType)
				) {
					error(
						symbol.valueDeclaration,
						Diagnostics.Member_0_implicitly_has_an_1_type,
						symbolToString(symbol),
						typeToString(flowType),
					);
				}
				// We don't infer a type if assignments are only null or undefined.
				if (everyType(flowType, isNullableType)) {
					continue;
				}
				return convertAutoToAny(flowType);
			}
		}
		function getFlowTypeInConstructor(symbol, constructor) {
			var accessName = startsWith(symbol.escapedName, "__#") ? factory.createPrivateIdentifier(
				symbol.escapedName.split("@")[1],
			) : unescapeLeadingUnderscores(symbol.escapedName);
			var reference = factory.createPropertyAccessExpression(
				factory.createThis(),
				accessName,
			);
			setParent(reference.expression, reference);
			setParent(reference, constructor);
			reference.flowNode = constructor.returnFlowNode;
			var flowType = getFlowTypeOfProperty(reference, symbol);
			if (
				noImplicitAny && (flowType === autoType || flowType === autoArrayType)
			) {
				error(
					symbol.valueDeclaration,
					Diagnostics.Member_0_implicitly_has_an_1_type,
					symbolToString(symbol),
					typeToString(flowType),
				);
			}
			// We don't infer a type if assignments are only null or undefined.
			return everyType(flowType, isNullableType) ? undefined : convertAutoToAny(
				flowType,
			);
		}
		function getFlowTypeOfProperty(reference, prop) {
			var initialType = (prop === null || prop === void 0 ? void 0 : prop.valueDeclaration) && (!isAutoTypedProperty(
				prop,
			) || getEffectiveModifierFlags(prop.valueDeclaration) & ModifierFlags.Ambient) && getTypeOfPropertyInBaseClass(
				prop,
			) || undefinedType;
			return getFlowTypeOfReference(reference, autoType, initialType);
		}
		function getWidenedTypeForAssignmentDeclaration(symbol, resolvedSymbol) {
			// function/class/{} initializers are themselves containers, so they won't merge in the same way as other initializers
			var container = getAssignedExpandoInitializer(symbol.valueDeclaration);
			if (container) {
				var tag = getJSDocTypeTag(container);
				if (tag && tag.typeExpression) {
					return getTypeFromTypeNode(tag.typeExpression);
				}
				var containerObjectType = symbol.valueDeclaration && getJSContainerObjectType(
					symbol.valueDeclaration,
					symbol,
					container,
				);
				return containerObjectType || getWidenedLiteralType(
					checkExpressionCached(container),
				);
			}
			var type;
			var definedInConstructor = false;
			var definedInMethod = false;
			// We use control flow analysis to determine the type of the property if the property qualifies as a constructor
			// declared property and the resulting control flow type isn't just undefined or null.
			if (isConstructorDeclaredProperty(symbol)) {
				type = getFlowTypeInConstructor(symbol, getDeclaringConstructor(symbol));
			}
			if (!type) {
				var types = void 0;
				if (symbol.declarations) {
					var jsdocType = void 0;
					for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
						var declaration = _a[_i];
						var expression = (isBinaryExpression(declaration) || isCallExpression(
							declaration,
						)) ? declaration : isAccessExpression(declaration) ? isBinaryExpression(
							declaration.parent,
						) ? declaration.parent : declaration : undefined;
						if (!expression) {
							continue; // Non-assignment declaration merged in (eg, an Identifier to mark the thing as a namespace) - skip over it and pull type info from elsewhere
						}
						var kind = isAccessExpression(expression) ? getAssignmentDeclarationPropertyAccessKind(
							expression,
						) : getAssignmentDeclarationKind(expression);
						if (
							kind === AssignmentDeclarationKind.ThisProperty || isBinaryExpression(
								expression,
							) && isPossiblyAliasedThisProperty(expression, kind)
						) {
							if (isDeclarationInConstructor(expression)) {
								definedInConstructor = true;
							} else {
								definedInMethod = true;
							}
						}
						if (!isCallExpression(expression)) {
							jsdocType = getAnnotatedTypeForAssignmentDeclaration(
								jsdocType,
								expression,
								symbol,
								declaration,
							);
						}
						if (!jsdocType) {
							(types || (types = [])).push(
								(isBinaryExpression(expression) || isCallExpression(expression)) ? getInitializerTypeFromAssignmentDeclaration(
									symbol,
									resolvedSymbol,
									expression,
									kind,
								) : neverType,
							);
						}
					}
					type = jsdocType;
				}
				if (!type) {
					if (!length(types)) {
						return errorType; // No types from any declarations :(
					}
					var constructorTypes = definedInConstructor && symbol.declarations ? getConstructorDefinedThisAssignmentTypes(
						types,
						symbol.declarations,
					) : undefined;
					// use only the constructor types unless they were only assigned null | undefined (including widening variants)
					if (definedInMethod) {
						var propType = getTypeOfPropertyInBaseClass(symbol);
						if (propType) {
							(constructorTypes || (constructorTypes = [])).push(propType);
							definedInConstructor = true;
						}
					}
					var sourceTypes = some(
						constructorTypes,
						function (t) {
							return !!(t.flags & ~TypeFlags.Nullable);
						},
					) ? constructorTypes : types; // TODO: GH#18217
					type = getUnionType(sourceTypes, UnionReduction.Subtype);
				}
			}
			var widened = getWidenedType(
				addOptionality(
					type, /*isProperty*/
					false,
					definedInMethod && !definedInConstructor,
				),
			);
			if (
				symbol.valueDeclaration && filterType(
					widened,
					function (t) {
						return !!(t.flags & ~TypeFlags.Nullable);
					},
				) === neverType
			) {
				reportImplicitAny(symbol.valueDeclaration, anyType);
				return anyType;
			}
			return widened;
		}
		function getJSContainerObjectType(decl, symbol, init) {
			var _a, _b;
			if (
				!isInJSFile(decl) || !init || !isObjectLiteralExpression(init) || init.properties.length
			) {
				return undefined;
			}
			var exports = createSymbolTable();
			while (isBinaryExpression(decl) || isPropertyAccessExpression(decl)) {
				var s_1 = getSymbolOfNode(decl);
				if (
					(_a = s_1 === null || s_1 === void 0 ? void 0 : s_1.exports) === null || _a === void 0 ? void 0 : _a.size
				) {
					mergeSymbolTable(exports, s_1.exports);
				}
				decl = isBinaryExpression(decl) ? decl.parent : decl.parent.parent;
			}
			var s = getSymbolOfNode(decl);
			if (
				(_b = s === null || s === void 0 ? void 0 : s.exports) === null || _b === void 0 ? void 0 : _b.size
			) {
				mergeSymbolTable(exports, s.exports);
			}
			var type = createAnonymousType(
				symbol,
				exports,
				emptyArray,
				emptyArray,
				emptyArray,
			);
			type.objectFlags |= ObjectFlags.JSLiteral;
			return type;
		}
		function getAnnotatedTypeForAssignmentDeclaration(
			declaredType,
			expression,
			symbol,
			declaration,
		) {
			var _a;
			var typeNode = getEffectiveTypeAnnotationNode(expression.parent);
			if (typeNode) {
				var type = getWidenedType(getTypeFromTypeNode(typeNode));
				if (!declaredType) {
					return type;
				} else if (
					!isErrorType(declaredType) && !isErrorType(type) && !isTypeIdenticalTo(
						declaredType,
						type,
					)
				) {
					errorNextVariableOrPropertyDeclarationMustHaveSameType(
						undefined, /*firstDeclaration*/
						declaredType,
						declaration,
						type,
					);
				}
			}
			if (
				(_a = symbol.parent) === null || _a === void 0 ? void 0 : _a.valueDeclaration
			) {
				var typeNode_2 = getEffectiveTypeAnnotationNode(
					symbol.parent.valueDeclaration,
				);
				if (typeNode_2) {
					var annotationSymbol = getPropertyOfType(
						getTypeFromTypeNode(typeNode_2),
						symbol.escapedName,
					);
					if (annotationSymbol) {
						return getNonMissingTypeOfSymbol(annotationSymbol);
					}
				}
			}
			return declaredType;
		}
		/** If we don't have an explicit JSDoc type, get the type from the initializer. */
		function getInitializerTypeFromAssignmentDeclaration(
			symbol,
			resolvedSymbol,
			expression,
			kind,
		) {
			if (isCallExpression(expression)) {
				if (resolvedSymbol) {
					return getTypeOfSymbol(resolvedSymbol); // This shouldn't happen except under some hopefully forbidden merges of export assignments and object define assignments
				}
				var objectLitType = checkExpressionCached(expression.arguments[2]);
				var valueType = getTypeOfPropertyOfType(objectLitType, "value");
				if (valueType) {
					return valueType;
				}
				var getFunc = getTypeOfPropertyOfType(objectLitType, "get");
				if (getFunc) {
					var getSig = getSingleCallSignature(getFunc);
					if (getSig) {
						return getReturnTypeOfSignature(getSig);
					}
				}
				var setFunc = getTypeOfPropertyOfType(objectLitType, "set");
				if (setFunc) {
					var setSig = getSingleCallSignature(setFunc);
					if (setSig) {
						return getTypeOfFirstParameterOfSignature(setSig);
					}
				}
				return anyType;
			}
			if (containsSameNamedThisProperty(expression.left, expression.right)) {
				return anyType;
			}
			var type = resolvedSymbol ? getTypeOfSymbol(resolvedSymbol) : getWidenedLiteralType(
				checkExpressionCached(expression.right),
			);
			if (
				type.flags & TypeFlags.Object && kind === AssignmentDeclarationKind.ModuleExports && symbol.escapedName === InternalSymbolName.ExportEquals
			) {
				var exportedType = resolveStructuredTypeMembers(type);
				var members_2 = createSymbolTable();
				copyEntries(exportedType.members, members_2);
				var initialSize = members_2.size;
				if (resolvedSymbol && !resolvedSymbol.exports) {
					resolvedSymbol.exports = createSymbolTable();
				}
				(resolvedSymbol || symbol).exports.forEach(
					function (s, name) {
						var _a;
						var exportedMember = members_2.get(name);
						if (exportedMember && exportedMember !== s) {
							if (
								s.flags & SymbolFlags.Value && exportedMember.flags & SymbolFlags.Value
							) {
								// If the member has an additional value-like declaration, union the types from the two declarations,
								// but issue an error if they occurred in two different files. The purpose is to support a JS file with
								// a pattern like:
								//
								// module.exports = { a: true };
								// module.exports.a = 3;
								//
								// but we may have a JS file with `module.exports = { a: true }` along with a TypeScript module augmentation
								// declaring an `export const a: number`. In that case, we issue a duplicate identifier error, because
								// it's unclear what that's supposed to mean, so it's probably a mistake.
								if (
									s.valueDeclaration && exportedMember.valueDeclaration && getSourceFileOfNode(
										s.valueDeclaration,
									) !== getSourceFileOfNode(exportedMember.valueDeclaration)
								) {
									var unescapedName = unescapeLeadingUnderscores(s.escapedName);
									var exportedMemberName = ((_a = tryCast(
										exportedMember.valueDeclaration,
										isNamedDeclaration,
									)) === null || _a === void 0 ? void 0 : _a.name) || exportedMember.valueDeclaration;
									addRelatedInfo(
										error(
											s.valueDeclaration,
											Diagnostics.Duplicate_identifier_0,
											unescapedName,
										),
										createDiagnosticForNode(
											exportedMemberName,
											Diagnostics._0_was_also_declared_here,
											unescapedName,
										),
									);
									addRelatedInfo(
										error(
											exportedMemberName,
											Diagnostics.Duplicate_identifier_0,
											unescapedName,
										),
										createDiagnosticForNode(
											s.valueDeclaration,
											Diagnostics._0_was_also_declared_here,
											unescapedName,
										),
									);
								}
								var union = createSymbol(s.flags | exportedMember.flags, name);
								union.type = getUnionType(
									[getTypeOfSymbol(s), getTypeOfSymbol(exportedMember)],
								);
								union.valueDeclaration = exportedMember.valueDeclaration;
								union.declarations = concatenate(
									exportedMember.declarations,
									s.declarations,
								);
								members_2.set(name, union);
							} else {
								members_2.set(name, mergeSymbol(s, exportedMember));
							}
						} else {
							members_2.set(name, s);
						}
					},
				);
				var result = createAnonymousType(
					initialSize !== members_2.size ? undefined : exportedType.symbol, // Only set the type's symbol if it looks to be the same as the original type
					members_2,
					exportedType.callSignatures,
					exportedType.constructSignatures,
					exportedType.indexInfos,
				);
				result.objectFlags |= (getObjectFlags(type) & ObjectFlags.JSLiteral); // Propagate JSLiteral flag
				if (
					result.symbol && result.symbol.flags & SymbolFlags.Class && type === getDeclaredTypeOfClassOrInterface(
						result.symbol,
					)
				) {
					result.objectFlags |= ObjectFlags.IsClassInstanceClone; // Propagate the knowledge that this type is equivalent to the symbol's class instance type
				}
				return result;
			}
			if (isEmptyArrayLiteralType(type)) {
				reportImplicitAny(expression, anyArrayType);
				return anyArrayType;
			}
			return type;
		}
		function containsSameNamedThisProperty(thisProperty, expression) {
			return isPropertyAccessExpression(thisProperty) && thisProperty.expression.kind === SyntaxKind.ThisKeyword && forEachChildRecursively(
				expression,
				function (n) {
					return isMatchingReference(thisProperty, n);
				},
			);
		}
		function isDeclarationInConstructor(expression) {
			var thisContainer = getThisContainer(
				expression, /*includeArrowFunctions*/
				false,
			);
			// Properties defined in a constructor (or base constructor, or javascript constructor function) don't get undefined added.
			// Function expressions that are assigned to the prototype count as methods.
			return thisContainer.kind === SyntaxKind.Constructor || thisContainer.kind === SyntaxKind.FunctionDeclaration || (thisContainer.kind === SyntaxKind.FunctionExpression && !isPrototypePropertyAssignment(
				thisContainer.parent,
			));
		}
		function getConstructorDefinedThisAssignmentTypes(types, declarations) {
			Debug.assert(types.length === declarations.length);
			return types.filter(
				function (_, i) {
					var declaration = declarations[i];
					var expression = isBinaryExpression(declaration) ? declaration : isBinaryExpression(
						declaration.parent,
					) ? declaration.parent : undefined;
					return expression && isDeclarationInConstructor(expression);
				},
			);
		}
		// Return the type implied by a binding pattern element. This is the type of the initializer of the element if
		// one is present. Otherwise, if the element is itself a binding pattern, it is the type implied by the binding
		// pattern. Otherwise, it is the type any.
		function getTypeFromBindingElement(
			element,
			includePatternInType,
			reportErrors,
		) {
			if (element.initializer) {
				// The type implied by a binding pattern is independent of context, so we check the initializer with no
				// contextual type or, if the element itself is a binding pattern, with the type implied by that binding
				// pattern.
				var contextualType = isBindingPattern(element.name) ? getTypeFromBindingPattern(
					element.name, /*includePatternInType*/
					true, /*reportErrors*/
					false,
				) : unknownType;
				return addOptionality(
					widenTypeInferredFromInitializer(
						element,
						checkDeclarationInitializer(element, contextualType),
					),
				);
			}
			if (isBindingPattern(element.name)) {
				return getTypeFromBindingPattern(
					element.name,
					includePatternInType,
					reportErrors,
				);
			}
			if (reportErrors && !declarationBelongsToPrivateAmbientMember(element)) {
				reportImplicitAny(element, anyType);
			}
			// When we're including the pattern in the type (an indication we're obtaining a contextual type), we
			// use the non-inferrable any type. Inference will never directly infer this type, but it is possible
			// to infer a type that contains it, e.g. for a binding pattern like [foo] or { foo }. In such cases,
			// widening of the binding pattern type substitutes a regular any for the non-inferrable any.
			return includePatternInType ? nonInferrableAnyType : anyType;
		}
		// Return the type implied by an object binding pattern
		function getTypeFromObjectBindingPattern(
			pattern,
			includePatternInType,
			reportErrors,
		) {
			var members = createSymbolTable();
			var stringIndexInfo;
			var objectFlags = ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral;
			forEach(
				pattern.elements,
				function (e) {
					var name = e.propertyName || e.name;
					if (e.dotDotDotToken) {
						stringIndexInfo = createIndexInfo(
							stringType,
							anyType, /*isReadonly*/
							false,
						);
						return;
					}
					var exprType = getLiteralTypeFromPropertyName(name);
					if (!isTypeUsableAsPropertyName(exprType)) {
						// do not include computed properties in the implied type
						objectFlags |= ObjectFlags.ObjectLiteralPatternWithComputedProperties;
						return;
					}
					var text = getPropertyNameFromType(exprType);
					var flags = SymbolFlags.Property | (e.initializer ? SymbolFlags.Optional : 0);
					var symbol = createSymbol(flags, text);
					symbol.type = getTypeFromBindingElement(
						e,
						includePatternInType,
						reportErrors,
					);
					symbol.bindingElement = e;
					members.set(symbol.escapedName, symbol);
				},
			);
			var result = createAnonymousType(
				undefined,
				members,
				emptyArray,
				emptyArray,
				stringIndexInfo ? [stringIndexInfo] : emptyArray,
			);
			result.objectFlags |= objectFlags;
			if (includePatternInType) {
				result.pattern = pattern;
				result.objectFlags |= ObjectFlags.ContainsObjectOrArrayLiteral;
			}
			return result;
		}
		// Return the type implied by an array binding pattern
		function getTypeFromArrayBindingPattern(
			pattern,
			includePatternInType,
			reportErrors,
		) {
			var elements = pattern.elements;
			var lastElement = lastOrUndefined(elements);
			var restElement = lastElement && lastElement.kind === SyntaxKind.BindingElement && lastElement.dotDotDotToken ? lastElement : undefined;
			if (elements.length === 0 || elements.length === 1 && restElement) {
				return languageVersion >= ScriptTarget.ES2015 ? createIterableType(
					anyType,
				) : anyArrayType;
			}
			var elementTypes = map(
				elements,
				function (e) {
					return isOmittedExpression(e) ? anyType : getTypeFromBindingElement(
						e,
						includePatternInType,
						reportErrors,
					);
				},
			);
			var minLength = findLastIndex(
				elements,
				function (e) {
					return !(e === restElement || isOmittedExpression(e) || hasDefaultValue(
						e,
					));
				},
				elements.length - 1,
			) + 1;
			var elementFlags = map(
				elements,
				function (e, i) {
					return e === restElement ? ElementFlags.Rest : i >= minLength ? ElementFlags.Optional : ElementFlags.Required;
				},
			);
			var result = createTupleType(elementTypes, elementFlags);
			if (includePatternInType) {
				result = cloneTypeReference(result);
				result.pattern = pattern;
				result.objectFlags |= ObjectFlags.ContainsObjectOrArrayLiteral;
			}
			return result;
		}
		// Return the type implied by a binding pattern. This is the type implied purely by the binding pattern itself
		// and without regard to its context (i.e. without regard any type annotation or initializer associated with the
		// declaration in which the binding pattern is contained). For example, the implied type of [x, y] is [any, any]
		// and the implied type of { x, y: z = 1 } is { x: any; y: number; }. The type implied by a binding pattern is
		// used as the contextual type of an initializer associated with the binding pattern. Also, for a destructuring
		// parameter with no type annotation or initializer, the type implied by the binding pattern becomes the type of
		// the parameter.
		function getTypeFromBindingPattern(
			pattern,
			includePatternInType,
			reportErrors,
		) {
			if (includePatternInType === void 0) {
				includePatternInType = false;
			}
			if (reportErrors === void 0) {
				reportErrors = false;
			}
			return pattern.kind === SyntaxKind.ObjectBindingPattern ? getTypeFromObjectBindingPattern(
				pattern,
				includePatternInType,
				reportErrors,
			) : getTypeFromArrayBindingPattern(
				pattern,
				includePatternInType,
				reportErrors,
			);
		}
		// Return the type associated with a variable, parameter, or property declaration. In the simple case this is the type
		// specified in a type annotation or inferred from an initializer. However, in the case of a destructuring declaration it
		// is a bit more involved. For example:
		//
		//   var [x, s = ""] = [1, "one"];
		//
		// Here, the array literal [1, "one"] is contextually typed by the type [any, string], which is the implied type of the
		// binding pattern [x, s = ""]. Because the contextual type is a tuple type, the resulting type of [1, "one"] is the
		// tuple type [number, string]. Thus, the type inferred for 'x' is number and the type inferred for 's' is string.
		function getWidenedTypeForVariableLikeDeclaration(declaration, reportErrors) {
			return widenTypeForVariableLikeDeclaration(
				getTypeForVariableLikeDeclaration(
					declaration, /*includeOptionality*/
					true,
				),
				declaration,
				reportErrors,
			);
		}
		function isGlobalSymbolConstructor(node) {
			var symbol = getSymbolOfNode(node);
			var globalSymbol = getGlobalESSymbolConstructorTypeSymbol(
				false, /*reportErrors*/
			);
			return globalSymbol && symbol && symbol === globalSymbol;
		}
		function widenTypeForVariableLikeDeclaration(
			type,
			declaration,
			reportErrors,
		) {
			if (type) {
				// TODO: If back compat with pre-3.0/4.0 libs isn't required, remove the following SymbolConstructor special case transforming `symbol` into `unique symbol`
				if (
					type.flags & TypeFlags.ESSymbol && isGlobalSymbolConstructor(
						declaration.parent,
					)
				) {
					type = getESSymbolLikeTypeForNode(declaration);
				}
				if (reportErrors) {
					reportErrorsFromWidening(declaration, type);
				}
				// always widen a 'unique symbol' type if the type was created for a different declaration.
				if (
					type.flags & TypeFlags.UniqueESSymbol && (isBindingElement(
						declaration,
					) || !declaration.type) && type.symbol !== getSymbolOfNode(
						declaration,
					)
				) {
					type = esSymbolType;
				}
				return getWidenedType(type);
			}
			// Rest parameters default to type any[], other parameters default to type any
			type = isParameter(declaration) && declaration.dotDotDotToken ? anyArrayType : anyType;
			// Report implicit any errors unless this is a private property within an ambient declaration
			if (reportErrors) {
				if (!declarationBelongsToPrivateAmbientMember(declaration)) {
					reportImplicitAny(declaration, type);
				}
			}
			return type;
		}
		function declarationBelongsToPrivateAmbientMember(declaration) {
			var root = getRootDeclaration(declaration);
			var memberDeclaration = root.kind === SyntaxKind.Parameter ? root.parent : root;
			return isPrivateWithinAmbient(memberDeclaration);
		}
		function tryGetTypeFromEffectiveTypeNode(declaration) {
			var typeNode = getEffectiveTypeAnnotationNode(declaration);
			if (typeNode) {
				return getTypeFromTypeNode(typeNode);
			}
		}
		function getTypeOfVariableOrParameterOrProperty(symbol) {
			var links = getSymbolLinks(symbol);
			if (!links.type) {
				var type = getTypeOfVariableOrParameterOrPropertyWorker(symbol);
				// For a contextually typed parameter it is possible that a type has already
				// been assigned (in assignTypeToParameterAndFixTypeParameters), and we want
				// to preserve this type.
				if (!links.type) {
					links.type = type;
				}
			}
			return links.type;
		}
		function getTypeOfVariableOrParameterOrPropertyWorker(symbol) {
			// Handle prototype property
			if (symbol.flags & SymbolFlags.Prototype) {
				return getTypeOfPrototypeProperty(symbol);
			}
			// CommonsJS require and module both have type any.
			if (symbol === requireSymbol) {
				return anyType;
			}
			if (symbol.flags & SymbolFlags.ModuleExports && symbol.valueDeclaration) {
				var fileSymbol = getSymbolOfNode(
					getSourceFileOfNode(symbol.valueDeclaration),
				);
				var result = createSymbol(fileSymbol.flags, "exports");
				result.declarations = fileSymbol.declarations ? fileSymbol.declarations.slice() : [];
				result.parent = symbol;
				result.target = fileSymbol;
				if (fileSymbol.valueDeclaration) result.valueDeclaration = fileSymbol.valueDeclaration;
				if (fileSymbol.members) result.members = new Map(fileSymbol.members);
				if (fileSymbol.exports) result.exports = new Map(fileSymbol.exports);
				var members = createSymbolTable();
				members.set("exports", result);
				return createAnonymousType(
					symbol,
					members,
					emptyArray,
					emptyArray,
					emptyArray,
				);
			}
			// Handle catch clause variables
			Debug.assertIsDefined(symbol.valueDeclaration);
			var declaration = symbol.valueDeclaration;
			if (isCatchClauseVariableDeclarationOrBindingElement(declaration)) {
				var typeNode = getEffectiveTypeAnnotationNode(declaration);
				if (typeNode === undefined) {
					return useUnknownInCatchVariables ? unknownType : anyType;
				}
				var type_1 = getTypeOfNode(typeNode);
				// an errorType will make `checkTryStatement` issue an error
				return isTypeAny(type_1) || type_1 === unknownType ? type_1 : errorType;
			}
			// Handle export default expressions
			if (isSourceFile(declaration) && isJsonSourceFile(declaration)) {
				if (!declaration.statements.length) {
					return emptyObjectType;
				}
				return getWidenedType(
					getWidenedLiteralType(
						checkExpression(declaration.statements[0].expression),
					),
				);
			}
			// Handle variable, parameter or property
			if (!pushTypeResolution(symbol, 0 /* Type */ )) {
				// Symbol is property of some kind that is merged with something - should use `getTypeOfFuncClassEnumModule` and not `getTypeOfVariableOrParameterOrProperty`
				if (
					symbol.flags & SymbolFlags.ValueModule && !(symbol.flags & SymbolFlags.Assignment)
				) {
					return getTypeOfFuncClassEnumModule(symbol);
				}
				return reportCircularityError(symbol);
			}
			var type;
			if (declaration.kind === SyntaxKind.ExportAssignment) {
				type = widenTypeForVariableLikeDeclaration(
					tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionCached(
						declaration.expression,
					),
					declaration,
				);
			} else if (
				isBinaryExpression(declaration) || (isInJSFile(declaration) && (isCallExpression(
					declaration,
				) || (isPropertyAccessExpression(declaration) || isBindableStaticElementAccessExpression(
					declaration,
				)) && isBinaryExpression(declaration.parent)))
			) {
				type = getWidenedTypeForAssignmentDeclaration(symbol);
			} else if (
				isPropertyAccessExpression(declaration) || isElementAccessExpression(
					declaration,
				) || isIdentifier(declaration) || isStringLiteralLike(declaration) || isNumericLiteral(
					declaration,
				) || isClassDeclaration(declaration) || isFunctionDeclaration(
					declaration,
				) || (isMethodDeclaration(declaration) && !isObjectLiteralMethod(
					declaration,
				)) || isMethodSignature(declaration) || isSourceFile(declaration)
			) {
				// Symbol is property of some kind that is merged with something - should use `getTypeOfFuncClassEnumModule` and not `getTypeOfVariableOrParameterOrProperty`
				if (
					symbol.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.Enum | SymbolFlags.ValueModule)
				) {
					return getTypeOfFuncClassEnumModule(symbol);
				}
				type = isBinaryExpression(declaration.parent) ? getWidenedTypeForAssignmentDeclaration(
					symbol,
				) : tryGetTypeFromEffectiveTypeNode(declaration) || anyType;
			} else if (isPropertyAssignment(declaration)) {
				type = tryGetTypeFromEffectiveTypeNode(declaration) || checkPropertyAssignment(
					declaration,
				);
			} else if (isJsxAttribute(declaration)) {
				type = tryGetTypeFromEffectiveTypeNode(declaration) || checkJsxAttribute(
					declaration,
				);
			} else if (isShorthandPropertyAssignment(declaration)) {
				type = tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionForMutableLocation(
					declaration.name,
					0, /* Normal */
				);
			} else if (isObjectLiteralMethod(declaration)) {
				type = tryGetTypeFromEffectiveTypeNode(declaration) || checkObjectLiteralMethod(
					declaration,
					0, /* Normal */
				);
			} else if (
				isParameter(declaration) || isPropertyDeclaration(declaration) || isPropertySignature(
					declaration,
				) || isVariableDeclaration(declaration) || isBindingElement(declaration) || isJSDocPropertyLikeTag(
					declaration,
				)
			) {
				type = getWidenedTypeForVariableLikeDeclaration(
					declaration, /*includeOptionality*/
					true,
				);
			} else if (isEnumDeclaration(declaration)) { // Re-dispatch based on valueDeclaration.kind instead. // getTypeOfSymbol dispatches some JS merges incorrectly because their symbol flags are not mutually exclusive.
				type = getTypeOfFuncClassEnumModule(symbol);
			} else if (isEnumMember(declaration)) {
				type = getTypeOfEnumMember(symbol);
			} else if (isAccessor(declaration)) {
				type = resolveTypeOfAccessors(symbol) || Debug.fail(
					"Non-write accessor resolution must always produce a type",
				);
			} else {
				return Debug.fail(
					"Unhandled declaration kind! " + Debug.formatSyntaxKind(
						declaration.kind,
					) + " for " + Debug.formatSymbol(symbol),
				);
			}
			if (!popTypeResolution()) {
				// Symbol is property of some kind that is merged with something - should use `getTypeOfFuncClassEnumModule` and not `getTypeOfVariableOrParameterOrProperty`
				if (
					symbol.flags & SymbolFlags.ValueModule && !(symbol.flags & SymbolFlags.Assignment)
				) {
					return getTypeOfFuncClassEnumModule(symbol);
				}
				return reportCircularityError(symbol);
			}
			return type;
		}
		function getAnnotatedAccessorTypeNode(accessor) {
			if (accessor) {
				if (accessor.kind === SyntaxKind.GetAccessor) {
					var getterTypeAnnotation = getEffectiveReturnTypeNode(accessor);
					return getterTypeAnnotation;
				} else {
					var setterTypeAnnotation = getEffectiveSetAccessorTypeAnnotationNode(
						accessor,
					);
					return setterTypeAnnotation;
				}
			}
			return undefined;
		}
		function getAnnotatedAccessorType(accessor) {
			var node = getAnnotatedAccessorTypeNode(accessor);
			return node && getTypeFromTypeNode(node);
		}
		function getAnnotatedAccessorThisParameter(accessor) {
			var parameter = getAccessorThisParameter(accessor);
			return parameter && parameter.symbol;
		}
		function getThisTypeOfDeclaration(declaration) {
			return getThisTypeOfSignature(getSignatureFromDeclaration(declaration));
		}
		function getTypeOfAccessors(symbol) {
			var links = getSymbolLinks(symbol);
			return links.type || (links.type = getTypeOfAccessorsWorker(symbol) || Debug.fail(
				"Read type of accessor must always produce a type",
			));
		}
		function getTypeOfSetAccessor(symbol) {
			var links = getSymbolLinks(symbol);
			return links.writeType || (links.writeType = getTypeOfAccessorsWorker(
				symbol, /*writing*/
				true,
			));
		}
		function getTypeOfAccessorsWorker(symbol, writing) {
			if (writing === void 0) {
				writing = false;
			}
			if (!pushTypeResolution(symbol, 0 /* Type */ )) {
				return errorType;
			}
			var type = resolveTypeOfAccessors(symbol, writing);
			if (!popTypeResolution()) {
				type = anyType;
				if (noImplicitAny) {
					var getter = getDeclarationOfKind(symbol, SyntaxKind.GetAccessor);
					error(
						getter,
						Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions,
						symbolToString(symbol),
					);
				}
			}
			return type;
		}
		function resolveTypeOfAccessors(symbol, writing) {
			if (writing === void 0) {
				writing = false;
			}
			var getter = getDeclarationOfKind(symbol, SyntaxKind.GetAccessor);
			var setter = getDeclarationOfKind(symbol, SyntaxKind.SetAccessor);
			var setterType = getAnnotatedAccessorType(setter);
			// For write operations, prioritize type annotations on the setter
			if (writing && setterType) {
				return instantiateTypeIfNeeded(setterType, symbol);
			}
			// Else defer to the getter type
			if (getter && isInJSFile(getter)) {
				var jsDocType = getTypeForDeclarationFromJSDocComment(getter);
				if (jsDocType) {
					return instantiateTypeIfNeeded(jsDocType, symbol);
				}
			}
			// Try to see if the user specified a return type on the get-accessor.
			var getterType = getAnnotatedAccessorType(getter);
			if (getterType) {
				return instantiateTypeIfNeeded(getterType, symbol);
			}
			// If the user didn't specify a return type, try to use the set-accessor's parameter type.
			if (setterType) {
				return setterType;
			}
			// If there are no specified types, try to infer it from the body of the get accessor if it exists.
			if (getter && getter.body) {
				var returnTypeFromBody = getReturnTypeFromBody(getter);
				return instantiateTypeIfNeeded(returnTypeFromBody, symbol);
			}
			// Otherwise, fall back to 'any'.
			if (setter) {
				if (!isPrivateWithinAmbient(setter)) {
					errorOrSuggestion(
						noImplicitAny,
						setter,
						Diagnostics.Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation,
						symbolToString(symbol),
					);
				}
				return anyType;
			} else if (getter) {
				Debug.assert(
					!!getter,
					"there must exist a getter as we are current checking either setter or getter in this function",
				);
				if (!isPrivateWithinAmbient(getter)) {
					errorOrSuggestion(
						noImplicitAny,
						getter,
						Diagnostics.Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation,
						symbolToString(symbol),
					);
				}
				return anyType;
			}
			return undefined;
			function instantiateTypeIfNeeded(type, symbol) {
				if (getCheckFlags(symbol) & CheckFlags.Instantiated) {
					var links = getSymbolLinks(symbol);
					return instantiateType(type, links.mapper);
				}
				return type;
			}
		}
		function getBaseTypeVariableOfClass(symbol) {
			var baseConstructorType = getBaseConstructorTypeOfClass(
				getDeclaredTypeOfClassOrInterface(symbol),
			);
			return baseConstructorType.flags & TypeFlags.TypeVariable ? baseConstructorType : baseConstructorType.flags & TypeFlags.Intersection ? find(
				baseConstructorType.types,
				function (t) {
					return !!(t.flags & TypeFlags.TypeVariable);
				},
			) : undefined;
		}
		function getTypeOfFuncClassEnumModule(symbol) {
			var links = getSymbolLinks(symbol);
			var originalLinks = links;
			if (!links.type) {
				var expando = symbol.valueDeclaration && getSymbolOfExpando(
					symbol.valueDeclaration, /*allowDeclaration*/
					false,
				);
				if (expando) {
					var merged = mergeJSSymbols(symbol, expando);
					if (merged) {
						// note:we overwrite links because we just cloned the symbol
						symbol = links = merged;
					}
				}
				originalLinks.type = links.type = getTypeOfFuncClassEnumModuleWorker(
					symbol,
				);
			}
			return links.type;
		}
		function getTypeOfFuncClassEnumModuleWorker(symbol) {
			var declaration = symbol.valueDeclaration;
			if (
				symbol.flags & SymbolFlags.Module && isShorthandAmbientModuleSymbol(
					symbol,
				)
			) {
				return anyType;
			} else if (
				declaration && (declaration.kind === SyntaxKind.BinaryExpression || isAccessExpression(
					declaration,
				) && declaration.parent.kind === SyntaxKind.BinaryExpression)
			) {
				return getWidenedTypeForAssignmentDeclaration(symbol);
			} else if (
				symbol.flags & SymbolFlags.ValueModule && declaration && isSourceFile(
					declaration,
				) && declaration.commonJsModuleIndicator
			) {
				var resolvedModule = resolveExternalModuleSymbol(symbol);
				if (resolvedModule !== symbol) {
					if (!pushTypeResolution(symbol, 0 /* Type */ )) {
						return errorType;
					}
					var exportEquals = getMergedSymbol(
						symbol.exports.get(InternalSymbolName.ExportEquals),
					);
					var type_2 = getWidenedTypeForAssignmentDeclaration(
						exportEquals,
						exportEquals === resolvedModule ? undefined : resolvedModule,
					);
					if (!popTypeResolution()) {
						return reportCircularityError(symbol);
					}
					return type_2;
				}
			}
			var type = createObjectType(ObjectFlags.Anonymous, symbol);
			if (symbol.flags & SymbolFlags.Class) {
				var baseTypeVariable = getBaseTypeVariableOfClass(symbol);
				return baseTypeVariable ? getIntersectionType([type, baseTypeVariable]) : type;
			} else {
				return strictNullChecks && symbol.flags & SymbolFlags.Optional ? getOptionalType(
					type,
				) : type;
			}
		}
		function getTypeOfEnumMember(symbol) {
			var links = getSymbolLinks(symbol);
			return links.type || (links.type = getDeclaredTypeOfEnumMember(symbol));
		}
		function getTypeOfAlias(symbol) {
			var links = getSymbolLinks(symbol);
			if (!links.type) {
				var targetSymbol = resolveAlias(symbol);
				var exportSymbol = symbol.declarations && getTargetOfAliasDeclaration(
					getDeclarationOfAliasSymbol(symbol), /*dontResolveAlias*/
					true,
				);
				var declaredType = firstDefined(
					exportSymbol === null || exportSymbol === void 0 ? void 0 : exportSymbol.declarations,
					function (d) {
						return isExportAssignment(d) ? tryGetTypeFromEffectiveTypeNode(d) : undefined;
					},
				);
				// It only makes sense to get the type of a value symbol. If the result of resolving
				// the alias is not a value, then it has no type. To get the type associated with a
				// type symbol, call getDeclaredTypeOfSymbol.
				// This check is important because without it, a call to getTypeOfSymbol could end
				// up recursively calling getTypeOfAlias, causing a stack overflow.
				links.type = (exportSymbol === null || exportSymbol === void 0 ? void 0 : exportSymbol.declarations) && isDuplicatedCommonJSExport(
					exportSymbol.declarations,
				) && symbol.declarations.length ? getFlowTypeFromCommonJSExport(
					exportSymbol,
				) : isDuplicatedCommonJSExport(symbol.declarations) ? autoType : declaredType ? declaredType : targetSymbol.flags & SymbolFlags.Value ? getTypeOfSymbol(
					targetSymbol,
				) : errorType;
			}
			return links.type;
		}
		function getTypeOfInstantiatedSymbol(symbol) {
			var links = getSymbolLinks(symbol);
			if (!links.type) {
				if (!pushTypeResolution(symbol, 0 /* Type */ )) {
					return links.type = errorType;
				}
				var type = instantiateType(getTypeOfSymbol(links.target), links.mapper);
				if (!popTypeResolution()) {
					type = reportCircularityError(symbol);
				}
				links.type = type;
			}
			return links.type;
		}
		function reportCircularityError(symbol) {
			var declaration = symbol.valueDeclaration;
			// Check if variable has type annotation that circularly references the variable itself
			if (getEffectiveTypeAnnotationNode(declaration)) {
				error(
					symbol.valueDeclaration,
					Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation,
					symbolToString(symbol),
				);
				return errorType;
			}
			// Check if variable has initializer that circularly references the variable itself
			if (
				noImplicitAny && (declaration.kind !== SyntaxKind.Parameter || declaration.initializer)
			) {
				error(
					symbol.valueDeclaration,
					Diagnostics._0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer,
					symbolToString(symbol),
				);
			}
			// Circularities could also result from parameters in function expressions that end up
			// having themselves as contextual types following type argument inference. In those cases
			// we have already reported an implicit any error so we don't report anything here.
			return anyType;
		}
		function getTypeOfSymbolWithDeferredType(symbol) {
			var links = getSymbolLinks(symbol);
			if (!links.type) {
				Debug.assertIsDefined(links.deferralParent);
				Debug.assertIsDefined(links.deferralConstituents);
				links.type = links.deferralParent.flags & TypeFlags.Union ? getUnionType(
					links.deferralConstituents,
				) : getIntersectionType(links.deferralConstituents);
			}
			return links.type;
		}
		function getSetAccessorTypeOfSymbol(symbol) {
			if (symbol.flags & SymbolFlags.Accessor) {
				var type = getTypeOfSetAccessor(symbol);
				if (type) {
					return type;
				}
			}
			return getTypeOfSymbol(symbol);
		}
		function getTypeOfSymbol(symbol) {
			var checkFlags = getCheckFlags(symbol);
			if (checkFlags & CheckFlags.DeferredType) {
				return getTypeOfSymbolWithDeferredType(symbol);
			}
			if (checkFlags & CheckFlags.Instantiated) {
				return getTypeOfInstantiatedSymbol(symbol);
			}
			if (checkFlags & CheckFlags.Mapped) {
				return getTypeOfMappedSymbol(symbol);
			}
			if (checkFlags & CheckFlags.ReverseMapped) {
				return getTypeOfReverseMappedSymbol(symbol);
			}
			if (symbol.flags & (SymbolFlags.Variable | SymbolFlags.Property)) {
				return getTypeOfVariableOrParameterOrProperty(symbol);
			}
			if (
				symbol.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.Enum | SymbolFlags.ValueModule)
			) {
				return getTypeOfFuncClassEnumModule(symbol);
			}
			if (symbol.flags & SymbolFlags.EnumMember) {
				return getTypeOfEnumMember(symbol);
			}
			if (symbol.flags & SymbolFlags.Accessor) {
				return getTypeOfAccessors(symbol);
			}
			if (symbol.flags & SymbolFlags.Alias) {
				return getTypeOfAlias(symbol);
			}
			return errorType;
		}
		function getNonMissingTypeOfSymbol(symbol) {
			return removeMissingType(
				getTypeOfSymbol(symbol),
				!!(symbol.flags & SymbolFlags.Optional),
			);
		}
		function isReferenceToType(type, target) {
			return type !== undefined && target !== undefined && (getObjectFlags(type) & ObjectFlags.Reference) !== 0 && type.target === target;
		}
		function getTargetType(type) {
			return getObjectFlags(type) & ObjectFlags.Reference ? type.target : type;
		}
		// TODO: GH#18217 If `checkBase` is undefined, we should not call this because this will always return false.
		function hasBaseType(type, checkBase) {
			return check(type);
			function check(type) {
				if (
					getObjectFlags(type) & (ObjectFlags.ClassOrInterface | ObjectFlags.Reference)
				) {
					var target = getTargetType(type);
					return target === checkBase || some(getBaseTypes(target), check);
				} else if (type.flags & TypeFlags.Intersection) {
					return some(type.types, check);
				}
				return false;
			}
		}
		// Appends the type parameters given by a list of declarations to a set of type parameters and returns the resulting set.
		// The function allocates a new array if the input type parameter set is undefined, but otherwise it modifies the set
		// in-place and returns the same array.
		function appendTypeParameters(typeParameters, declarations) {
			for (
				var _i = 0, declarations_1 = declarations;
				_i < declarations_1.length;
				_i++
			) {
				var declaration = declarations_1[_i];
				typeParameters = appendIfUnique(
					typeParameters,
					getDeclaredTypeOfTypeParameter(getSymbolOfNode(declaration)),
				);
			}
			return typeParameters;
		}
		// Return the outer type parameters of a node or undefined if the node has no outer type parameters.
		function getOuterTypeParameters(node, includeThisTypes) {
			while (true) {
				node = node.parent; // TODO: GH#18217 Use SourceFile kind check instead
				if (node && isBinaryExpression(node)) {
					// prototype assignments get the outer type parameters of their constructor function
					var assignmentKind = getAssignmentDeclarationKind(node);
					if (
						assignmentKind === AssignmentDeclarationKind.Prototype || assignmentKind === AssignmentDeclarationKind.PrototypeProperty
					) {
						var symbol = getSymbolOfNode(node.left);
						if (
							symbol && symbol.parent && !findAncestor(
								symbol.parent.valueDeclaration,
								function (d) {
									return node === d;
								},
							)
						) {
							node = symbol.parent.valueDeclaration;
						}
					}
				}
				if (!node) {
					return undefined;
				}
				switch (node.kind) {
					case SyntaxKind.ClassDeclaration:
					case SyntaxKind.ClassExpression:
					case SyntaxKind.InterfaceDeclaration:
					case SyntaxKind.CallSignature:
					case SyntaxKind.ConstructSignature:
					case SyntaxKind.MethodSignature:
					case SyntaxKind.FunctionType:
					case SyntaxKind.ConstructorType:
					case SyntaxKind.JSDocFunctionType:
					case SyntaxKind.FunctionDeclaration:
					case SyntaxKind.MethodDeclaration:
					case SyntaxKind.FunctionExpression:
					case SyntaxKind.ArrowFunction:
					case SyntaxKind.TypeAliasDeclaration:
					case SyntaxKind.JSDocTemplateTag:
					case SyntaxKind.JSDocTypedefTag:
					case SyntaxKind.JSDocEnumTag:
					case SyntaxKind.JSDocCallbackTag:
					case SyntaxKind.MappedType:
					case SyntaxKind.ConditionalType:
						{
							var outerTypeParameters = getOuterTypeParameters(
								node,
								includeThisTypes,
							);
							if (node.kind === SyntaxKind.MappedType) {
								return append(
									outerTypeParameters,
									getDeclaredTypeOfTypeParameter(
										getSymbolOfNode(node.typeParameter),
									),
								);
							} else if (node.kind === SyntaxKind.ConditionalType) {
								return concatenate(
									outerTypeParameters,
									getInferTypeParameters(node),
								);
							}
							var outerAndOwnTypeParameters = appendTypeParameters(
								outerTypeParameters,
								getEffectiveTypeParameterDeclarations(node),
							);
							var thisType = includeThisTypes && (node.kind === SyntaxKind.ClassDeclaration || node.kind === SyntaxKind.ClassExpression || node.kind === SyntaxKind.InterfaceDeclaration || isJSConstructor(
								node,
							)) && getDeclaredTypeOfClassOrInterface(getSymbolOfNode(node)).thisType;
							return thisType ? append(outerAndOwnTypeParameters, thisType) : outerAndOwnTypeParameters;
						}
					case SyntaxKind.JSDocParameterTag:
						var paramSymbol = getParameterSymbolFromJSDoc(node);
						if (paramSymbol) {
							node = paramSymbol.valueDeclaration;
						}
						break;
					case SyntaxKind.JSDocComment:
						{
							var outerTypeParameters = getOuterTypeParameters(
								node,
								includeThisTypes,
							);
							return node.tags ? appendTypeParameters(
								outerTypeParameters,
								flatMap(
									node.tags,
									function (t) {
										return isJSDocTemplateTag(t) ? t.typeParameters : undefined;
									},
								),
							) : outerTypeParameters;
						}
				}
			}
		}
		// The outer type parameters are those defined by enclosing generic classes, methods, or functions.
		function getOuterTypeParametersOfClassOrInterface(symbol) {
			var declaration = symbol.flags & SymbolFlags.Class ? symbol.valueDeclaration : getDeclarationOfKind(
				symbol,
				SyntaxKind.InterfaceDeclaration,
			);
			Debug.assert(
				!!declaration,
				"Class was missing valueDeclaration -OR- non-class had no interface declarations",
			);
			return getOuterTypeParameters(declaration);
		}
		// The local type parameters are the combined set of type parameters from all declarations of the class,
		// interface, or type alias.
		function getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol) {
			if (!symbol.declarations) {
				return;
			}
			var result;
			for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
				var node = _a[_i];
				if (
					node.kind === SyntaxKind.InterfaceDeclaration || node.kind === SyntaxKind.ClassDeclaration || node.kind === SyntaxKind.ClassExpression || isJSConstructor(
						node,
					) || isTypeAlias(node)
				) {
					var declaration = node;
					result = appendTypeParameters(
						result,
						getEffectiveTypeParameterDeclarations(declaration),
					);
				}
			}
			return result;
		}
		// The full set of type parameters for a generic class or interface type consists of its outer type parameters plus
		// its locally declared type parameters.
		function getTypeParametersOfClassOrInterface(symbol) {
			return concatenate(
				getOuterTypeParametersOfClassOrInterface(symbol),
				getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol),
			);
		}
		// A type is a mixin constructor if it has a single construct signature taking no type parameters and a single
		// rest parameter of type any[].
		function isMixinConstructorType(type) {
			var signatures = getSignaturesOfType(type, SignatureKind.Construct);
			if (signatures.length === 1) {
				var s = signatures[0];
				if (
					!s.typeParameters && s.parameters.length === 1 && signatureHasRestParameter(
						s,
					)
				) {
					var paramType = getTypeOfParameter(s.parameters[0]);
					return isTypeAny(paramType) || getElementTypeOfArrayType(paramType) === anyType;
				}
			}
			return false;
		}
		function isConstructorType(type) {
			if (getSignaturesOfType(type, SignatureKind.Construct).length > 0) {
				return true;
			}
			if (type.flags & TypeFlags.TypeVariable) {
				var constraint = getBaseConstraintOfType(type);
				return !!constraint && isMixinConstructorType(constraint);
			}
			return false;
		}
		function getBaseTypeNodeOfClass(type) {
			var decl = getClassLikeDeclarationOfSymbol(type.symbol);
			return decl && getEffectiveBaseTypeNode(decl);
		}
		function getConstructorsForTypeArguments(type, typeArgumentNodes, location) {
			var typeArgCount = length(typeArgumentNodes);
			var isJavascript = isInJSFile(location);
			return filter(
				getSignaturesOfType(type, SignatureKind.Construct),
				function (sig) {
					return (isJavascript || typeArgCount >= getMinTypeArgumentCount(
						sig.typeParameters,
					)) && typeArgCount <= length(sig.typeParameters);
				},
			);
		}
		function getInstantiatedConstructorsForTypeArguments(
			type,
			typeArgumentNodes,
			location,
		) {
			var signatures = getConstructorsForTypeArguments(
				type,
				typeArgumentNodes,
				location,
			);
			var typeArguments = map(typeArgumentNodes, getTypeFromTypeNode);
			return sameMap(
				signatures,
				function (sig) {
					return some(sig.typeParameters) ? getSignatureInstantiation(
						sig,
						typeArguments,
						isInJSFile(location),
					) : sig;
				},
			);
		}
		/**
         * The base constructor of a class can resolve to
         * * undefinedType if the class has no extends clause,
         * * unknownType if an error occurred during resolution of the extends expression,
         * * nullType if the extends expression is the null value,
         * * anyType if the extends expression has type any, or
         * * an object type with at least one construct signature.
         */
		function getBaseConstructorTypeOfClass(type) {
			if (!type.resolvedBaseConstructorType) {
				var decl = getClassLikeDeclarationOfSymbol(type.symbol);
				var extended = decl && getEffectiveBaseTypeNode(decl);
				var baseTypeNode = getBaseTypeNodeOfClass(type);
				if (!baseTypeNode) {
					return type.resolvedBaseConstructorType = undefinedType;
				}
				if (!pushTypeResolution(type, 1 /* ResolvedBaseConstructorType */ )) {
					return errorType;
				}
				var baseConstructorType = checkExpression(baseTypeNode.expression);
				if (extended && baseTypeNode !== extended) {
					Debug.assert(!extended.typeArguments); // Because this is in a JS file, and baseTypeNode is in an @extends tag
					checkExpression(extended.expression);
				}
				if (
					baseConstructorType.flags & (TypeFlags.Object | TypeFlags.Intersection)
				) {
					// Resolving the members of a class requires us to resolve the base class of that class.
					// We force resolution here such that we catch circularities now.
					resolveStructuredTypeMembers(baseConstructorType);
				}
				if (!popTypeResolution()) {
					error(
						type.symbol.valueDeclaration,
						Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,
						symbolToString(type.symbol),
					);
					return type.resolvedBaseConstructorType = errorType;
				}
				if (
					!(baseConstructorType.flags & TypeFlags.Any) && baseConstructorType !== nullWideningType && !isConstructorType(
						baseConstructorType,
					)
				) {
					var err = error(
						baseTypeNode.expression,
						Diagnostics.Type_0_is_not_a_constructor_function_type,
						typeToString(baseConstructorType),
					);
					if (baseConstructorType.flags & TypeFlags.TypeParameter) {
						var constraint = getConstraintFromTypeParameter(baseConstructorType);
						var ctorReturn = unknownType;
						if (constraint) {
							var ctorSig = getSignaturesOfType(
								constraint,
								SignatureKind.Construct,
							);
							if (ctorSig[0]) {
								ctorReturn = getReturnTypeOfSignature(ctorSig[0]);
							}
						}
						if (baseConstructorType.symbol.declarations) {
							addRelatedInfo(
								err,
								createDiagnosticForNode(
									baseConstructorType.symbol.declarations[0],
									Diagnostics.Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1,
									symbolToString(baseConstructorType.symbol),
									typeToString(ctorReturn),
								),
							);
						}
					}
					return type.resolvedBaseConstructorType = errorType;
				}
				type.resolvedBaseConstructorType = baseConstructorType;
			}
			return type.resolvedBaseConstructorType;
		}
		function getImplementsTypes(type) {
			var resolvedImplementsTypes = emptyArray;
			if (type.symbol.declarations) {
				for (var _i = 0, _a = type.symbol.declarations; _i < _a.length; _i++) {
					var declaration = _a[_i];
					var implementsTypeNodes = getEffectiveImplementsTypeNodes(declaration);
					if (!implementsTypeNodes) continue;
					for (
						var _b = 0, implementsTypeNodes_1 = implementsTypeNodes;
						_b < implementsTypeNodes_1.length;
						_b++
					) {
						var node = implementsTypeNodes_1[_b];
						var implementsType = getTypeFromTypeNode(node);
						if (!isErrorType(implementsType)) {
							if (resolvedImplementsTypes === emptyArray) {
								resolvedImplementsTypes = [implementsType];
							} else {
								resolvedImplementsTypes.push(implementsType);
							}
						}
					}
				}
			}
			return resolvedImplementsTypes;
		}
		function reportCircularBaseType(node, type) {
			error(
				node,
				Diagnostics.Type_0_recursively_references_itself_as_a_base_type,
				typeToString(
					type, /*enclosingDeclaration*/
					undefined,
					TypeFormatFlags.WriteArrayAsGenericType,
				),
			);
		}
		function getBaseTypes(type) {
			if (!type.baseTypesResolved) {
				if (pushTypeResolution(type, 7 /* ResolvedBaseTypes */ )) {
					if (type.objectFlags & ObjectFlags.Tuple) {
						type.resolvedBaseTypes = [getTupleBaseType(type)];
					} else if (
						type.symbol.flags & (SymbolFlags.Class | SymbolFlags.Interface)
					) {
						if (type.symbol.flags & SymbolFlags.Class) {
							resolveBaseTypesOfClass(type);
						}
						if (type.symbol.flags & SymbolFlags.Interface) {
							resolveBaseTypesOfInterface(type);
						}
					} else {
						Debug.fail("type must be class or interface");
					}
					if (!popTypeResolution() && type.symbol.declarations) {
						for (var _i = 0, _a = type.symbol.declarations; _i < _a.length; _i++) {
							var declaration = _a[_i];
							if (
								declaration.kind === SyntaxKind.ClassDeclaration || declaration.kind === SyntaxKind.InterfaceDeclaration
							) {
								reportCircularBaseType(declaration, type);
							}
						}
					}
				}
				type.baseTypesResolved = true;
			}
			return type.resolvedBaseTypes;
		}
		function getTupleBaseType(type) {
			var elementTypes = sameMap(
				type.typeParameters,
				function (t, i) {
					return type.elementFlags[i] & ElementFlags.Variadic ? getIndexedAccessType(
						t,
						numberType,
					) : t;
				},
			);
			return createArrayType(
				getUnionType(elementTypes || emptyArray),
				type.readonly,
			);
		}
		function resolveBaseTypesOfClass(type) {
			type.resolvedBaseTypes = resolvingEmptyArray;
			var baseConstructorType = getApparentType(
				getBaseConstructorTypeOfClass(type),
			);
			if (
				!(baseConstructorType.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.Any))
			) {
				return type.resolvedBaseTypes = emptyArray;
			}
			var baseTypeNode = getBaseTypeNodeOfClass(type);
			var baseType;
			var originalBaseType = baseConstructorType.symbol ? getDeclaredTypeOfSymbol(
				baseConstructorType.symbol,
			) : undefined;
			if (
				baseConstructorType.symbol && baseConstructorType.symbol.flags & SymbolFlags.Class && areAllOuterTypeParametersApplied(
					originalBaseType,
				)
			) {
				// When base constructor type is a class with no captured type arguments we know that the constructors all have the same type parameters as the
				// class and all return the instance type of the class. There is no need for further checks and we can apply the
				// type arguments in the same manner as a type reference to get the same error reporting experience.
				baseType = getTypeFromClassOrInterfaceReference(
					baseTypeNode,
					baseConstructorType.symbol,
				);
			} else if (baseConstructorType.flags & TypeFlags.Any) {
				baseType = baseConstructorType;
			} else {
				// The class derives from a "class-like" constructor function, check that we have at least one construct signature
				// with a matching number of type parameters and use the return type of the first instantiated signature. Elsewhere
				// we check that all instantiated signatures return the same type.
				var constructors = getInstantiatedConstructorsForTypeArguments(
					baseConstructorType,
					baseTypeNode.typeArguments,
					baseTypeNode,
				);
				if (!constructors.length) {
					error(
						baseTypeNode.expression,
						Diagnostics.No_base_constructor_has_the_specified_number_of_type_arguments,
					);
					return type.resolvedBaseTypes = emptyArray;
				}
				baseType = getReturnTypeOfSignature(constructors[0]);
			}
			if (isErrorType(baseType)) {
				return type.resolvedBaseTypes = emptyArray;
			}
			var reducedBaseType = getReducedType(baseType);
			if (!isValidBaseType(reducedBaseType)) {
				var elaboration = elaborateNeverIntersection(
					undefined, /*errorInfo*/
					baseType,
				);
				var diagnostic = chainDiagnosticMessages(
					elaboration,
					Diagnostics.Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_known_members,
					typeToString(reducedBaseType),
				);
				diagnostics.add(
					createDiagnosticForNodeFromMessageChain(
						baseTypeNode.expression,
						diagnostic,
					),
				);
				return type.resolvedBaseTypes = emptyArray;
			}
			if (type === reducedBaseType || hasBaseType(reducedBaseType, type)) {
				error(
					type.symbol.valueDeclaration,
					Diagnostics.Type_0_recursively_references_itself_as_a_base_type,
					typeToString(
						type, /*enclosingDeclaration*/
						undefined,
						TypeFormatFlags.WriteArrayAsGenericType,
					),
				);
				return type.resolvedBaseTypes = emptyArray;
			}
			if (type.resolvedBaseTypes === resolvingEmptyArray) {
				// Circular reference, likely through instantiation of default parameters
				// (otherwise there'd be an error from hasBaseType) - this is fine, but `.members` should be reset
				// as `getIndexedAccessType` via `instantiateType` via `getTypeFromClassOrInterfaceReference` forces a
				// partial instantiation of the members without the base types fully resolved
				type.members = undefined;
			}
			return type.resolvedBaseTypes = [reducedBaseType];
		}
		function areAllOuterTypeParametersApplied(type) {
			// An unapplied type parameter has its symbol still the same as the matching argument symbol.
			// Since parameters are applied outer-to-inner, only the last outer parameter needs to be checked.
			var outerTypeParameters = type.outerTypeParameters;
			if (outerTypeParameters) {
				var last = outerTypeParameters.length - 1;
				var typeArguments = getTypeArguments(type);
				return outerTypeParameters[last].symbol !== typeArguments[last].symbol;
			}
			return true;
		}
		// A valid base type is `any`, an object type or intersection of object types.
		function isValidBaseType(type) {
			if (type.flags & TypeFlags.TypeParameter) {
				var constraint = getBaseConstraintOfType(type);
				if (constraint) {
					return isValidBaseType(constraint);
				}
			}
			// TODO: Given that we allow type parmeters here now, is this `!isGenericMappedType(type)` check really needed?
			// There's no reason a `T` should be allowed while a `Readonly<T>` should not.
			return !!(type.flags & (TypeFlags.Object | TypeFlags.NonPrimitive | TypeFlags.Any) && !isGenericMappedType(
				type,
			) || type.flags & TypeFlags.Intersection && every(
				type.types,
				isValidBaseType,
			));
		}
		function resolveBaseTypesOfInterface(type) {
			type.resolvedBaseTypes = type.resolvedBaseTypes || emptyArray;
			if (type.symbol.declarations) {
				for (var _i = 0, _a = type.symbol.declarations; _i < _a.length; _i++) {
					var declaration = _a[_i];
					if (
						declaration.kind === SyntaxKind.InterfaceDeclaration && getInterfaceBaseTypeNodes(
							declaration,
						)
					) {
						for (
							var _b = 0, _c = getInterfaceBaseTypeNodes(declaration);
							_b < _c.length;
							_b++
						) {
							var node = _c[_b];
							var baseType = getReducedType(getTypeFromTypeNode(node));
							if (!isErrorType(baseType)) {
								if (isValidBaseType(baseType)) {
									if (type !== baseType && !hasBaseType(baseType, type)) {
										if (type.resolvedBaseTypes === emptyArray) {
											type.resolvedBaseTypes = [baseType];
										} else {
											type.resolvedBaseTypes.push(baseType);
										}
									} else {
										reportCircularBaseType(declaration, type);
									}
								} else {
									error(
										node,
										Diagnostics.An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_members,
									);
								}
							}
						}
					}
				}
			}
		}
		/**
         * Returns true if the interface given by the symbol is free of "this" references.
         *
         * Specifically, the result is true if the interface itself contains no references
         * to "this" in its body, if all base types are interfaces,
         * and if none of the base interfaces have a "this" type.
         */
		function isThislessInterface(symbol) {
			if (!symbol.declarations) {
				return true;
			}
			for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
				var declaration = _a[_i];
				if (declaration.kind === SyntaxKind.InterfaceDeclaration) {
					if (declaration.flags & NodeFlags.ContainsThis) {
						return false;
					}
					var baseTypeNodes = getInterfaceBaseTypeNodes(declaration);
					if (baseTypeNodes) {
						for (
							var _b = 0, baseTypeNodes_1 = baseTypeNodes;
							_b < baseTypeNodes_1.length;
							_b++
						) {
							var node = baseTypeNodes_1[_b];
							if (isEntityNameExpression(node.expression)) {
								var baseSymbol = resolveEntityName(
									node.expression,
									SymbolFlags.Type, /*ignoreErrors*/
									true,
								);
								if (
									!baseSymbol || !(baseSymbol.flags & SymbolFlags.Interface) || getDeclaredTypeOfClassOrInterface(
										baseSymbol,
									).thisType
								) {
									return false;
								}
							}
						}
					}
				}
			}
			return true;
		}
		function getDeclaredTypeOfClassOrInterface(symbol) {
			var links = getSymbolLinks(symbol);
			var originalLinks = links;
			if (!links.declaredType) {
				var kind = symbol.flags & SymbolFlags.Class ? ObjectFlags.Class : ObjectFlags.Interface;
				var merged = mergeJSSymbols(
					symbol,
					symbol.valueDeclaration && getAssignedClassSymbol(
						symbol.valueDeclaration,
					),
				);
				if (merged) {
					// note:we overwrite links because we just cloned the symbol
					symbol = links = merged;
				}
				var type = originalLinks.declaredType = links.declaredType = createObjectType(
					kind,
					symbol,
				);
				var outerTypeParameters = getOuterTypeParametersOfClassOrInterface(
					symbol,
				);
				var localTypeParameters = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(
					symbol,
				);
				// A class or interface is generic if it has type parameters or a "this" type. We always give classes a "this" type
				// because it is not feasible to analyze all members to determine if the "this" type escapes the class (in particular,
				// property types inferred from initializers and method return types inferred from return statements are very hard
				// to exhaustively analyze). We give interfaces a "this" type if we can't definitely determine that they are free of
				// "this" references.
				if (
					outerTypeParameters || localTypeParameters || kind === ObjectFlags.Class || !isThislessInterface(
						symbol,
					)
				) {
					type.objectFlags |= ObjectFlags.Reference;
					type.typeParameters = concatenate(
						outerTypeParameters,
						localTypeParameters,
					);
					type.outerTypeParameters = outerTypeParameters;
					type.localTypeParameters = localTypeParameters;
					type.instantiations = new Map();
					type.instantiations.set(getTypeListId(type.typeParameters), type);
					type.target = type;
					type.resolvedTypeArguments = type.typeParameters;
					type.thisType = createTypeParameter(symbol);
					type.thisType.isThisType = true;
					type.thisType.constraint = type;
				}
			}
			return links.declaredType;
		}
		function getDeclaredTypeOfTypeAlias(symbol) {
			var _a;
			var links = getSymbolLinks(symbol);
			if (!links.declaredType) {
				// Note that we use the links object as the target here because the symbol object is used as the unique
				// identity for resolution of the 'type' property in SymbolLinks.
				if (!pushTypeResolution(symbol, 2 /* DeclaredType */ )) {
					return errorType;
				}
				var declaration = Debug.checkDefined(
					(_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.find(
						isTypeAlias,
					),
					"Type alias symbol with no valid declaration found",
				);
				var typeNode = isJSDocTypeAlias(declaration) ? declaration.typeExpression : declaration.type;
				// If typeNode is missing, we will error in checkJSDocTypedefTag.
				var type = typeNode ? getTypeFromTypeNode(typeNode) : errorType;
				if (popTypeResolution()) {
					var typeParameters = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(
						symbol,
					);
					if (typeParameters) {
						// Initialize the instantiation cache for generic type aliases. The declared type corresponds to
						// an instantiation of the type alias with the type parameters supplied as type arguments.
						links.typeParameters = typeParameters;
						links.instantiations = new Map();
						links.instantiations.set(getTypeListId(typeParameters), type);
					}
				} else {
					type = errorType;
					if (declaration.kind === SyntaxKind.JSDocEnumTag) {
						error(
							declaration.typeExpression.type,
							Diagnostics.Type_alias_0_circularly_references_itself,
							symbolToString(symbol),
						);
					} else {
						error(
							isNamedDeclaration(declaration) ? declaration.name : declaration || declaration,
							Diagnostics.Type_alias_0_circularly_references_itself,
							symbolToString(symbol),
						);
					}
				}
				links.declaredType = type;
			}
			return links.declaredType;
		}
		function isStringConcatExpression(expr) {
			if (isStringLiteralLike(expr)) {
				return true;
			} else if (expr.kind === SyntaxKind.BinaryExpression) {
				return isStringConcatExpression(expr.left) && isStringConcatExpression(
					expr.right,
				);
			}
			return false;
		}
		function isLiteralEnumMember(member) {
			var expr = member.initializer;
			if (!expr) {
				return !(member.flags & NodeFlags.Ambient);
			}
			switch (expr.kind) {
				case SyntaxKind.StringLiteral:
				case SyntaxKind.NumericLiteral:
				case SyntaxKind.NoSubstitutionTemplateLiteral:
					return true;
				case SyntaxKind.PrefixUnaryExpression:
					return expr.operator === SyntaxKind.MinusToken && expr.operand.kind === SyntaxKind.NumericLiteral;
				case SyntaxKind.Identifier:
					return nodeIsMissing(expr) || !!getSymbolOfNode(member.parent).exports.get(
						expr.escapedText,
					);
				case SyntaxKind.BinaryExpression:
					return isStringConcatExpression(expr);
				default:
					return false;
			}
		}
		function getEnumKind(symbol) {
			var links = getSymbolLinks(symbol);
			if (links.enumKind !== undefined) {
				return links.enumKind;
			}
			var hasNonLiteralMember = false;
			if (symbol.declarations) {
				for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
					var declaration = _a[_i];
					if (declaration.kind === SyntaxKind.EnumDeclaration) {
						for (var _b = 0, _c = declaration.members; _b < _c.length; _b++) {
							var member = _c[_b];
							if (member.initializer && isStringLiteralLike(member.initializer)) {
								return links.enumKind = EnumKind.Literal;
							}
							if (!isLiteralEnumMember(member)) {
								hasNonLiteralMember = true;
							}
						}
					}
				}
			}
			return links.enumKind = hasNonLiteralMember ? EnumKind.Numeric : EnumKind.Literal;
		}
		function getBaseTypeOfEnumLiteralType(type) {
			return type.flags & TypeFlags.EnumLiteral && !(type.flags & TypeFlags.Union) ? getDeclaredTypeOfSymbol(
				getParentOfSymbol(type.symbol),
			) : type;
		}
		function getDeclaredTypeOfEnum(symbol) {
			var links = getSymbolLinks(symbol);
			if (links.declaredType) {
				return links.declaredType;
			}
			if (getEnumKind(symbol) === EnumKind.Literal) {
				enumCount++;
				var memberTypeList = [];
				if (symbol.declarations) {
					for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
						var declaration = _a[_i];
						if (declaration.kind === SyntaxKind.EnumDeclaration) {
							for (var _b = 0, _c = declaration.members; _b < _c.length; _b++) {
								var member = _c[_b];
								var value = getEnumMemberValue(member);
								var memberType = getFreshTypeOfLiteralType(
									getEnumLiteralType(
										value !== undefined ? value : 0,
										enumCount,
										getSymbolOfNode(member),
									),
								);
								getSymbolLinks(getSymbolOfNode(member)).declaredType = memberType;
								memberTypeList.push(getRegularTypeOfLiteralType(memberType));
							}
						}
					}
				}
				if (memberTypeList.length) {
					var enumType_1 = getUnionType(
						memberTypeList,
						UnionReduction.Literal,
						symbol, /*aliasTypeArguments*/
						undefined,
					);
					if (enumType_1.flags & TypeFlags.Union) {
						enumType_1.flags |= TypeFlags.EnumLiteral;
						enumType_1.symbol = symbol;
					}
					return links.declaredType = enumType_1;
				}
			}
			var enumType = createType(TypeFlags.Enum);
			enumType.symbol = symbol;
			return links.declaredType = enumType;
		}
		function getDeclaredTypeOfEnumMember(symbol) {
			var links = getSymbolLinks(symbol);
			if (!links.declaredType) {
				var enumType = getDeclaredTypeOfEnum(getParentOfSymbol(symbol));
				if (!links.declaredType) {
					links.declaredType = enumType;
				}
			}
			return links.declaredType;
		}
		function getDeclaredTypeOfTypeParameter(symbol) {
			var links = getSymbolLinks(symbol);
			return links.declaredType || (links.declaredType = createTypeParameter(
				symbol,
			));
		}
		function getDeclaredTypeOfAlias(symbol) {
			var links = getSymbolLinks(symbol);
			return links.declaredType || (links.declaredType = getDeclaredTypeOfSymbol(
				resolveAlias(symbol),
			));
		}
		function getDeclaredTypeOfSymbol(symbol) {
			return tryGetDeclaredTypeOfSymbol(symbol) || errorType;
		}
		function tryGetDeclaredTypeOfSymbol(symbol) {
			if (symbol.flags & (SymbolFlags.Class | SymbolFlags.Interface)) {
				return getDeclaredTypeOfClassOrInterface(symbol);
			}
			if (symbol.flags & SymbolFlags.TypeAlias) {
				return getDeclaredTypeOfTypeAlias(symbol);
			}
			if (symbol.flags & SymbolFlags.TypeParameter) {
				return getDeclaredTypeOfTypeParameter(symbol);
			}
			if (symbol.flags & SymbolFlags.Enum) {
				return getDeclaredTypeOfEnum(symbol);
			}
			if (symbol.flags & SymbolFlags.EnumMember) {
				return getDeclaredTypeOfEnumMember(symbol);
			}
			if (symbol.flags & SymbolFlags.Alias) {
				return getDeclaredTypeOfAlias(symbol);
			}
			return undefined;
		}
		/**
         * A type is free of this references if it's the any, string, number, boolean, symbol, or void keyword, a string
         * literal type, an array with an element type that is free of this references, or a type reference that is
         * free of this references.
         */
		function isThislessType(node) {
			switch (node.kind) {
				case SyntaxKind.AnyKeyword:
				case SyntaxKind.UnknownKeyword:
				case SyntaxKind.StringKeyword:
				case SyntaxKind.NumberKeyword:
				case SyntaxKind.BigIntKeyword:
				case SyntaxKind.BooleanKeyword:
				case SyntaxKind.SymbolKeyword:
				case SyntaxKind.ObjectKeyword:
				case SyntaxKind.VoidKeyword:
				case SyntaxKind.UndefinedKeyword:
				case SyntaxKind.NeverKeyword:
				case SyntaxKind.LiteralType:
					return true;
				case SyntaxKind.ArrayType:
					return isThislessType(node.elementType);
				case SyntaxKind.TypeReference:
					return !node.typeArguments || node.typeArguments.every(isThislessType);
			}
			return false;
		}
		/** A type parameter is thisless if its constraint is thisless, or if it has no constraint. */
		function isThislessTypeParameter(node) {
			var constraint = getEffectiveConstraintOfTypeParameter(node);
			return !constraint || isThislessType(constraint);
		}
		/**
         * A variable-like declaration is free of this references if it has a type annotation
         * that is thisless, or if it has no type annotation and no initializer (and is thus of type any).
         */
		function isThislessVariableLikeDeclaration(node) {
			var typeNode = getEffectiveTypeAnnotationNode(node);
			return typeNode ? isThislessType(typeNode) : !hasInitializer(node);
		}
		/**
         * A function-like declaration is considered free of `this` references if it has a return type
         * annotation that is free of this references and if each parameter is thisless and if
         * each type parameter (if present) is thisless.
         */
		function isThislessFunctionLikeDeclaration(node) {
			var returnType = getEffectiveReturnTypeNode(node);
			var typeParameters = getEffectiveTypeParameterDeclarations(node);
			return (node.kind === SyntaxKind.Constructor || (!!returnType && isThislessType(
				returnType,
			))) && node.parameters.every(isThislessVariableLikeDeclaration) && typeParameters.every(
				isThislessTypeParameter,
			);
		}
		/**
         * Returns true if the class or interface member given by the symbol is free of "this" references. The
         * function may return false for symbols that are actually free of "this" references because it is not
         * feasible to perform a complete analysis in all cases. In particular, property members with types
         * inferred from their initializers and function members with inferred return types are conservatively
         * assumed not to be free of "this" references.
         */
		function isThisless(symbol) {
			if (symbol.declarations && symbol.declarations.length === 1) {
				var declaration = symbol.declarations[0];
				if (declaration) {
					switch (declaration.kind) {
						case SyntaxKind.PropertyDeclaration:
						case SyntaxKind.PropertySignature:
							return isThislessVariableLikeDeclaration(declaration);
						case SyntaxKind.MethodDeclaration:
						case SyntaxKind.MethodSignature:
						case SyntaxKind.Constructor:
						case SyntaxKind.GetAccessor:
						case SyntaxKind.SetAccessor:
							return isThislessFunctionLikeDeclaration(declaration);
					}
				}
			}
			return false;
		}
		// The mappingThisOnly flag indicates that the only type parameter being mapped is "this". When the flag is true,
		// we check symbols to see if we can quickly conclude they are free of "this" references, thus needing no instantiation.
		function createInstantiatedSymbolTable(symbols, mapper, mappingThisOnly) {
			var result = createSymbolTable();
			for (var _i = 0, symbols_1 = symbols; _i < symbols_1.length; _i++) {
				var symbol = symbols_1[_i];
				result.set(
					symbol.escapedName,
					mappingThisOnly && isThisless(symbol) ? symbol : instantiateSymbol(
						symbol,
						mapper,
					),
				);
			}
			return result;
		}
		function addInheritedMembers(symbols, baseSymbols) {
			for (
				var _i = 0, baseSymbols_1 = baseSymbols;
				_i < baseSymbols_1.length;
				_i++
			) {
				var s = baseSymbols_1[_i];
				if (
					!symbols.has(s.escapedName) && !isStaticPrivateIdentifierProperty(s)
				) {
					symbols.set(s.escapedName, s);
				}
			}
		}
		function isStaticPrivateIdentifierProperty(s) {
			return !!s.valueDeclaration && isPrivateIdentifierClassElementDeclaration(
				s.valueDeclaration,
			) && isStatic(s.valueDeclaration);
		}
		function resolveDeclaredMembers(type) {
			if (!type.declaredProperties) {
				var symbol = type.symbol;
				var members = getMembersOfSymbol(symbol);
				type.declaredProperties = getNamedMembers(members);
				// Start with signatures at empty array in case of recursive types
				type.declaredCallSignatures = emptyArray;
				type.declaredConstructSignatures = emptyArray;
				type.declaredIndexInfos = emptyArray;
				type.declaredCallSignatures = getSignaturesOfSymbol(
					members.get(InternalSymbolName.Call),
				);
				type.declaredConstructSignatures = getSignaturesOfSymbol(
					members.get(InternalSymbolName.New),
				);
				type.declaredIndexInfos = getIndexInfosOfSymbol(symbol);
			}
			return type;
		}
		/**
         * Indicates whether a type can be used as a property name.
         */
		function isTypeUsableAsPropertyName(type) {
			return !!(type.flags & TypeFlags.StringOrNumberLiteralOrUnique);
		}
		/**
         * Indicates whether a declaration name is definitely late-bindable.
         * A declaration name is only late-bindable if:
         * - It is a `ComputedPropertyName`.
         * - Its expression is an `Identifier` or either a `PropertyAccessExpression` an
         * `ElementAccessExpression` consisting only of these same three types of nodes.
         * - The type of its expression is a string or numeric literal type, or is a `unique symbol` type.
         */
		function isLateBindableName(node) {
			if (!isComputedPropertyName(node) && !isElementAccessExpression(node)) {
				return false;
			}
			var expr = isComputedPropertyName(node) ? node.expression : node.argumentExpression;
			return isEntityNameExpression(expr) && isTypeUsableAsPropertyName(
				isComputedPropertyName(node) ? checkComputedPropertyName(node) : checkExpressionCached(
					expr,
				),
			);
		}
		function isLateBoundName(name) {
			return name.charCodeAt(0) === CharacterCodes._ && name.charCodeAt(1) === CharacterCodes._ && name.charCodeAt(
				2,
			) === CharacterCodes.at;
		}
		/**
         * Indicates whether a declaration has a late-bindable dynamic name.
         */
		function hasLateBindableName(node) {
			var name = getNameOfDeclaration(node);
			return !!name && isLateBindableName(name);
		}
		/**
         * Indicates whether a declaration has an early-bound name or a dynamic name that can be late-bound.
         */
		function hasBindableName(node) {
			return !hasDynamicName(node) || hasLateBindableName(node);
		}
		/**
         * Indicates whether a declaration name is a dynamic name that cannot be late-bound.
         */
		function isNonBindableDynamicName(node) {
			return isDynamicName(node) && !isLateBindableName(node);
		}
		/**
         * Gets the symbolic name for a member from its type.
         */
		function getPropertyNameFromType(type) {
			if (type.flags & TypeFlags.UniqueESSymbol) {
				return type.escapedName;
			}
			if (type.flags & (TypeFlags.StringLiteral | TypeFlags.NumberLiteral)) {
				return escapeLeadingUnderscores("" + type.value);
			}
			return Debug.fail();
		}
		/**
         * Adds a declaration to a late-bound dynamic member. This performs the same function for
         * late-bound members that `addDeclarationToSymbol` in binder.ts performs for early-bound
         * members.
         */
		function addDeclarationToLateBoundSymbol(symbol, member, symbolFlags) {
			Debug.assert(
				!!(getCheckFlags(symbol) & CheckFlags.Late),
				"Expected a late-bound symbol.",
			);
			symbol.flags |= symbolFlags;
			getSymbolLinks(member.symbol).lateSymbol = symbol;
			if (!symbol.declarations) {
				symbol.declarations = [member];
			} else if (!member.symbol.isReplaceableByMethod) {
				symbol.declarations.push(member);
			}
			if (symbolFlags & SymbolFlags.Value) {
				if (
					!symbol.valueDeclaration || symbol.valueDeclaration.kind !== member.kind
				) {
					symbol.valueDeclaration = member;
				}
			}
		}
		/**
         * Performs late-binding of a dynamic member. This performs the same function for
         * late-bound members that `declareSymbol` in binder.ts performs for early-bound
         * members.
         *
         * If a symbol is a dynamic name from a computed property, we perform an additional "late"
         * binding phase to attempt to resolve the name for the symbol from the type of the computed
         * property's expression. If the type of the expression is a string-literal, numeric-literal,
         * or unique symbol type, we can use that type as the name of the symbol.
         *
         * For example, given:
         *
         *   const x = Symbol();
         *
         *   interface I {
         *     [x]: number;
         *   }
         *
         * The binder gives the property `[x]: number` a special symbol with the name "__computed".
         * In the late-binding phase we can type-check the expression `x` and see that it has a
         * unique symbol type which we can then use as the name of the member. This allows users
         * to define custom symbols that can be used in the members of an object type.
         *
         * @param parent The containing symbol for the member.
         * @param earlySymbols The early-bound symbols of the parent.
         * @param lateSymbols The late-bound symbols of the parent.
         * @param decl The member to bind.
         */
		function lateBindMember(parent, earlySymbols, lateSymbols, decl) {
			Debug.assert(!!decl.symbol, "The member is expected to have a symbol.");
			var links = getNodeLinks(decl);
			if (!links.resolvedSymbol) {
				// In the event we attempt to resolve the late-bound name of this member recursively,
				// fall back to the early-bound name of this member.
				links.resolvedSymbol = decl.symbol;
				var declName = isBinaryExpression(decl) ? decl.left : decl.name;
				var type = isElementAccessExpression(declName) ? checkExpressionCached(
					declName.argumentExpression,
				) : checkComputedPropertyName(declName);
				if (isTypeUsableAsPropertyName(type)) {
					var memberName = getPropertyNameFromType(type);
					var symbolFlags = decl.symbol.flags;
					// Get or add a late-bound symbol for the member. This allows us to merge late-bound accessor declarations.
					var lateSymbol = lateSymbols.get(memberName);
					if (!lateSymbol) lateSymbols.set(
						memberName,
						lateSymbol = createSymbol(
							SymbolFlags.None,
							memberName,
							CheckFlags.Late,
						),
					);
					// Report an error if a late-bound member has the same name as an early-bound member,
					// or if we have another early-bound symbol declaration with the same name and
					// conflicting flags.
					var earlySymbol = earlySymbols && earlySymbols.get(memberName);
					if (
						lateSymbol.flags & getExcludedSymbolFlags(symbolFlags) || earlySymbol
					) {
						// If we have an existing early-bound member, combine its declarations so that we can
						// report an error at each declaration.
						var declarations = earlySymbol ? concatenate(
							earlySymbol.declarations,
							lateSymbol.declarations,
						) : lateSymbol.declarations;
						var name_13 = !(type.flags & TypeFlags.UniqueESSymbol) && unescapeLeadingUnderscores(
							memberName,
						) || declarationNameToString(declName);
						forEach(
							declarations,
							function (declaration) {
								return error(
									getNameOfDeclaration(declaration) || declaration,
									Diagnostics.Property_0_was_also_declared_here,
									name_13,
								);
							},
						);
						error(declName || decl, Diagnostics.Duplicate_property_0, name_13);
						lateSymbol = createSymbol(
							SymbolFlags.None,
							memberName,
							CheckFlags.Late,
						);
					}
					lateSymbol.nameType = type;
					addDeclarationToLateBoundSymbol(lateSymbol, decl, symbolFlags);
					if (lateSymbol.parent) {
						Debug.assert(
							lateSymbol.parent === parent,
							"Existing symbol parent should match new one",
						);
					} else {
						lateSymbol.parent = parent;
					}
					return links.resolvedSymbol = lateSymbol;
				}
			}
			return links.resolvedSymbol;
		}
		function getResolvedMembersOrExportsOfSymbol(symbol, resolutionKind) {
			var links = getSymbolLinks(symbol);
			if (!links[resolutionKind]) {
				var isStatic = resolutionKind === "resolvedExports"; /* resolvedExports */
				var earlySymbols = !isStatic ? symbol.members : symbol.flags & SymbolFlags.Module ? getExportsOfModuleWorker(
					symbol,
				) : symbol.exports;
				// In the event we recursively resolve the members/exports of the symbol, we
				// set the initial value of resolvedMembers/resolvedExports to the early-bound
				// members/exports of the symbol.
				links[resolutionKind] = earlySymbols || emptySymbols;
				// fill in any as-yet-unresolved late-bound members.
				var lateSymbols = createSymbolTable();
				for (
					var _i = 0, _a = symbol.declarations || emptyArray;
					_i < _a.length;
					_i++
				) {
					var decl = _a[_i];
					var members = getMembersOfDeclaration(decl);
					if (members) {
						for (var _b = 0, members_3 = members; _b < members_3.length; _b++) {
							var member = members_3[_b];
							if (
								isStatic === hasStaticModifier(member) && hasLateBindableName(
									member,
								)
							) {
								lateBindMember(symbol, earlySymbols, lateSymbols, member);
							}
						}
					}
				}
				var assignments = symbol.assignmentDeclarationMembers;
				if (assignments) {
					var decls = arrayFrom(assignments.values());
					for (var _c = 0, decls_1 = decls; _c < decls_1.length; _c++) {
						var member = decls_1[_c];
						var assignmentKind = getAssignmentDeclarationKind(member);
						var isInstanceMember = assignmentKind === AssignmentDeclarationKind.PrototypeProperty || isBinaryExpression(
							member,
						) && isPossiblyAliasedThisProperty(member, assignmentKind) || assignmentKind === AssignmentDeclarationKind.ObjectDefinePrototypeProperty || assignmentKind === AssignmentDeclarationKind.Prototype; // A straight `Prototype` assignment probably can never have a computed name
						if (isStatic === !isInstanceMember && hasLateBindableName(member)) {
							lateBindMember(symbol, earlySymbols, lateSymbols, member);
						}
					}
				}
				links[resolutionKind] = combineSymbolTables(earlySymbols, lateSymbols) || emptySymbols;
			}
			return links[resolutionKind];
		}
		/**
         * Gets a SymbolTable containing both the early- and late-bound members of a symbol.
         *
         * For a description of late-binding, see `lateBindMember`.
         */
		function getMembersOfSymbol(symbol) {
			return symbol.flags & SymbolFlags.LateBindingContainer ? getResolvedMembersOrExportsOfSymbol(
				symbol,
				"resolvedMembers", /* resolvedMembers */
			) : symbol.members || emptySymbols;
		}
		/**
         * If a symbol is the dynamic name of the member of an object type, get the late-bound
         * symbol of the member.
         *
         * For a description of late-binding, see `lateBindMember`.
         */
		function getLateBoundSymbol(symbol) {
			if (
				symbol.flags & SymbolFlags.ClassMember && symbol.escapedName === InternalSymbolName.Computed
			) {
				var links = getSymbolLinks(symbol);
				if (!links.lateSymbol && some(symbol.declarations, hasLateBindableName)) {
					// force late binding of members/exports. This will set the late-bound symbol
					var parent_6 = getMergedSymbol(symbol.parent);
					if (some(symbol.declarations, hasStaticModifier)) {
						getExportsOfSymbol(parent_6);
					} else {
						getMembersOfSymbol(parent_6);
					}
				}
				return links.lateSymbol || (links.lateSymbol = symbol);
			}
			return symbol;
		}
		function getTypeWithThisArgument(type, thisArgument, needApparentType) {
			if (getObjectFlags(type) & ObjectFlags.Reference) {
				var target = type.target;
				var typeArguments = getTypeArguments(type);
				if (length(target.typeParameters) === length(typeArguments)) {
					var ref = createTypeReference(
						target,
						concatenate(typeArguments, [thisArgument || target.thisType]),
					);
					return needApparentType ? getApparentType(ref) : ref;
				}
			} else if (type.flags & TypeFlags.Intersection) {
				var types = sameMap(
					type.types,
					function (t) {
						return getTypeWithThisArgument(t, thisArgument, needApparentType);
					},
				);
				return types !== type.types ? getIntersectionType(types) : type;
			}
			return needApparentType ? getApparentType(type) : type;
		}
		function resolveObjectTypeMembers(
			type,
			source,
			typeParameters,
			typeArguments,
		) {
			var mapper;
			var members;
			var callSignatures;
			var constructSignatures;
			var indexInfos;
			if (rangeEquals(typeParameters, typeArguments, 0, typeParameters.length)) {
				members = source.symbol ? getMembersOfSymbol(source.symbol) : createSymbolTable(
					source.declaredProperties,
				);
				callSignatures = source.declaredCallSignatures;
				constructSignatures = source.declaredConstructSignatures;
				indexInfos = source.declaredIndexInfos;
			} else {
				mapper = createTypeMapper(typeParameters, typeArguments);
				members = createInstantiatedSymbolTable(
					source.declaredProperties,
					mapper, /*mappingThisOnly*/
					typeParameters.length === 1,
				);
				callSignatures = instantiateSignatures(
					source.declaredCallSignatures,
					mapper,
				);
				constructSignatures = instantiateSignatures(
					source.declaredConstructSignatures,
					mapper,
				);
				indexInfos = instantiateIndexInfos(source.declaredIndexInfos, mapper);
			}
			var baseTypes = getBaseTypes(source);
			if (baseTypes.length) {
				if (source.symbol && members === getMembersOfSymbol(source.symbol)) {
					members = createSymbolTable(source.declaredProperties);
				}
				setStructuredTypeMembers(
					type,
					members,
					callSignatures,
					constructSignatures,
					indexInfos,
				);
				var thisArgument = lastOrUndefined(typeArguments);
				for (var _i = 0, baseTypes_1 = baseTypes; _i < baseTypes_1.length; _i++) {
					var baseType = baseTypes_1[_i];
					var instantiatedBaseType = thisArgument ? getTypeWithThisArgument(
						instantiateType(baseType, mapper),
						thisArgument,
					) : baseType;
					addInheritedMembers(
						members,
						getPropertiesOfType(instantiatedBaseType),
					);
					callSignatures = concatenate(
						callSignatures,
						getSignaturesOfType(instantiatedBaseType, SignatureKind.Call),
					);
					constructSignatures = concatenate(
						constructSignatures,
						getSignaturesOfType(instantiatedBaseType, SignatureKind.Construct),
					);
					var inheritedIndexInfos = instantiatedBaseType !== anyType ? getIndexInfosOfType(
						instantiatedBaseType,
					) : [createIndexInfo(stringType, anyType, /*isReadonly*/ false)];
					indexInfos = concatenate(
						indexInfos,
						filter(
							inheritedIndexInfos,
							function (info) {
								return !findIndexInfo(indexInfos, info.keyType);
							},
						),
					);
				}
			}
			setStructuredTypeMembers(
				type,
				members,
				callSignatures,
				constructSignatures,
				indexInfos,
			);
		}
		function resolveClassOrInterfaceMembers(type) {
			resolveObjectTypeMembers(
				type,
				resolveDeclaredMembers(type),
				emptyArray,
				emptyArray,
			);
		}
		function resolveTypeReferenceMembers(type) {
			var source = resolveDeclaredMembers(type.target);
			var typeParameters = concatenate(source.typeParameters, [source.thisType]);
			var typeArguments = getTypeArguments(type);
			var paddedTypeArguments = typeArguments.length === typeParameters.length ? typeArguments : concatenate(
				typeArguments,
				[type],
			);
			resolveObjectTypeMembers(
				type,
				source,
				typeParameters,
				paddedTypeArguments,
			);
		}
		function createSignature(
			declaration,
			typeParameters,
			thisParameter,
			parameters,
			resolvedReturnType,
			resolvedTypePredicate,
			minArgumentCount,
			flags,
		) {
			var sig = new Signature(checker, flags);
			sig.declaration = declaration;
			sig.typeParameters = typeParameters;
			sig.parameters = parameters;
			sig.thisParameter = thisParameter;
			sig.resolvedReturnType = resolvedReturnType;
			sig.resolvedTypePredicate = resolvedTypePredicate;
			sig.minArgumentCount = minArgumentCount;
			sig.resolvedMinArgumentCount = undefined;
			sig.target = undefined;
			sig.mapper = undefined;
			sig.compositeSignatures = undefined;
			sig.compositeKind = undefined;
			return sig;
		}
		function cloneSignature(sig) {
			var result = createSignature(
				sig.declaration,
				sig.typeParameters,
				sig.thisParameter,
				sig.parameters, /*resolvedReturnType*/
				undefined,
				/*resolvedTypePredicate*/ undefined,
				sig.minArgumentCount,
				sig.flags & SignatureFlags.PropagatingFlags,
			);
			result.target = sig.target;
			result.mapper = sig.mapper;
			result.compositeSignatures = sig.compositeSignatures;
			result.compositeKind = sig.compositeKind;
			return result;
		}
		function createUnionSignature(signature, unionSignatures) {
			var result = cloneSignature(signature);
			result.compositeSignatures = unionSignatures;
			result.compositeKind = TypeFlags.Union;
			result.target = undefined;
			result.mapper = undefined;
			return result;
		}
		function getOptionalCallSignature(signature, callChainFlags) {
			if ((signature.flags & SignatureFlags.CallChainFlags) === callChainFlags) {
				return signature;
			}
			if (!signature.optionalCallSignatureCache) {
				signature.optionalCallSignatureCache = {};
			}
			var key = callChainFlags === SignatureFlags.IsInnerCallChain ? "inner" : "outer";
			return signature.optionalCallSignatureCache[key] || (signature.optionalCallSignatureCache[key] = createOptionalCallSignature(
				signature,
				callChainFlags,
			));
		}
		function createOptionalCallSignature(signature, callChainFlags) {
			Debug.assert(
				callChainFlags === SignatureFlags.IsInnerCallChain || callChainFlags === SignatureFlags.IsOuterCallChain,
				"An optional call signature can either be for an inner call chain or an outer call chain, but not both.",
			);
			var result = cloneSignature(signature);
			result.flags |= callChainFlags;
			return result;
		}
		function getExpandedParameters(sig, skipUnionExpanding) {
			if (signatureHasRestParameter(sig)) {
				var restIndex_1 = sig.parameters.length - 1;
				var restType = getTypeOfSymbol(sig.parameters[restIndex_1]);
				if (isTupleType(restType)) {
					return [
						expandSignatureParametersWithTupleMembers(restType, restIndex_1),
					];
				} else if (
					!skipUnionExpanding && restType.flags & TypeFlags.Union && every(
						restType.types,
						isTupleType,
					)
				) {
					return map(
						restType.types,
						function (t) {
							return expandSignatureParametersWithTupleMembers(t, restIndex_1);
						},
					);
				}
			}
			return [sig.parameters];
			function expandSignatureParametersWithTupleMembers(restType, restIndex) {
				var elementTypes = getTypeArguments(restType);
				var associatedNames = restType.target.labeledElementDeclarations;
				var restParams = map(
					elementTypes,
					function (t, i) {
						// Lookup the label from the individual tuple passed in before falling back to the signature `rest` parameter name
						var tupleLabelName = !!associatedNames && getTupleElementLabel(
							associatedNames[i],
						);
						var name = tupleLabelName || getParameterNameAtPosition(
							sig,
							restIndex + i,
							restType,
						);
						var flags = restType.target.elementFlags[i];
						var checkFlags = flags & ElementFlags.Variable ? CheckFlags.RestParameter : flags & ElementFlags.Optional ? CheckFlags.OptionalParameter : 0;
						var symbol = createSymbol(
							SymbolFlags.FunctionScopedVariable,
							name,
							checkFlags,
						);
						symbol.type = flags & ElementFlags.Rest ? createArrayType(t) : t;
						return symbol;
					},
				);
				return concatenate(sig.parameters.slice(0, restIndex), restParams);
			}
		}
		function getDefaultConstructSignatures(classType) {
			var baseConstructorType = getBaseConstructorTypeOfClass(classType);
			var baseSignatures = getSignaturesOfType(
				baseConstructorType,
				SignatureKind.Construct,
			);
			var declaration = getClassLikeDeclarationOfSymbol(classType.symbol);
			var isAbstract = !!declaration && hasSyntacticModifier(
				declaration,
				ModifierFlags.Abstract,
			);
			if (baseSignatures.length === 0) {
				return [
					createSignature(
						undefined,
						classType.localTypeParameters,
						undefined,
						emptyArray,
						classType, /*resolvedTypePredicate*/
						undefined,
						0,
						isAbstract ? SignatureFlags.Abstract : SignatureFlags.None,
					),
				];
			}
			var baseTypeNode = getBaseTypeNodeOfClass(classType);
			var isJavaScript = isInJSFile(baseTypeNode);
			var typeArguments = typeArgumentsFromTypeReferenceNode(baseTypeNode);
			var typeArgCount = length(typeArguments);
			var result = [];
			for (
				var _i = 0, baseSignatures_1 = baseSignatures;
				_i < baseSignatures_1.length;
				_i++
			) {
				var baseSig = baseSignatures_1[_i];
				var minTypeArgumentCount = getMinTypeArgumentCount(
					baseSig.typeParameters,
				);
				var typeParamCount = length(baseSig.typeParameters);
				if (
					isJavaScript || typeArgCount >= minTypeArgumentCount && typeArgCount <= typeParamCount
				) {
					var sig = typeParamCount ? createSignatureInstantiation(
						baseSig,
						fillMissingTypeArguments(
							typeArguments,
							baseSig.typeParameters,
							minTypeArgumentCount,
							isJavaScript,
						),
					) : cloneSignature(baseSig);
					sig.typeParameters = classType.localTypeParameters;
					sig.resolvedReturnType = classType;
					sig.flags = isAbstract ? sig.flags | SignatureFlags.Abstract : sig.flags & ~SignatureFlags.Abstract;
					result.push(sig);
				}
			}
			return result;
		}
		function findMatchingSignature(
			signatureList,
			signature,
			partialMatch,
			ignoreThisTypes,
			ignoreReturnTypes,
		) {
			for (
				var _i = 0, signatureList_1 = signatureList;
				_i < signatureList_1.length;
				_i++
			) {
				var s = signatureList_1[_i];
				if (
					compareSignaturesIdentical(
						s,
						signature,
						partialMatch,
						ignoreThisTypes,
						ignoreReturnTypes,
						partialMatch ? compareTypesSubtypeOf : compareTypesIdentical,
					)
				) {
					return s;
				}
			}
		}
		function findMatchingSignatures(signatureLists, signature, listIndex) {
			if (signature.typeParameters) {
				// We require an exact match for generic signatures, so we only return signatures from the first
				// signature list and only if they have exact matches in the other signature lists.
				if (listIndex > 0) {
					return undefined;
				}
				for (var i = 1; i < signatureLists.length; i++) {
					if (
						!findMatchingSignature(
							signatureLists[i],
							signature, /*partialMatch*/
							false, /*ignoreThisTypes*/
							false, /*ignoreReturnTypes*/
							false,
						)
					) {
						return undefined;
					}
				}
				return [signature];
			}
			var result;
			for (var i = 0; i < signatureLists.length; i++) {
				// Allow matching non-generic signatures to have excess parameters and different return types.
				// Prefer matching this types if possible.
				var match = i === listIndex ? signature : findMatchingSignature(
					signatureLists[i],
					signature, /*partialMatch*/
					true, /*ignoreThisTypes*/
					false, /*ignoreReturnTypes*/
					true,
				);
				if (!match) {
					return undefined;
				}
				result = appendIfUnique(result, match);
			}
			return result;
		}
		// The signatures of a union type are those signatures that are present in each of the constituent types.
		// Generic signatures must match exactly, but non-generic signatures are allowed to have extra optional
		// parameters and may differ in return types. When signatures differ in return types, the resulting return
		// type is the union of the constituent return types.
		function getUnionSignatures(signatureLists) {
			var result;
			var indexWithLengthOverOne;
			for (var i = 0; i < signatureLists.length; i++) {
				if (signatureLists[i].length === 0) return emptyArray;
				if (signatureLists[i].length > 1) {
					indexWithLengthOverOne = indexWithLengthOverOne === undefined ? i : -1; // -1 is a signal there are multiple overload sets
				}
				for (var _i = 0, _a = signatureLists[i]; _i < _a.length; _i++) {
					var signature = _a[_i];
					// Only process signatures with parameter lists that aren't already in the result list
					if (
						!result || !findMatchingSignature(
							result,
							signature, /*partialMatch*/
							false, /*ignoreThisTypes*/
							false, /*ignoreReturnTypes*/
							true,
						)
					) {
						var unionSignatures = findMatchingSignatures(
							signatureLists,
							signature,
							i,
						);
						if (unionSignatures) {
							var s = signature;
							// Union the result types when more than one signature matches
							if (unionSignatures.length > 1) {
								var thisParameter = signature.thisParameter;
								var firstThisParameterOfUnionSignatures = forEach(
									unionSignatures,
									function (sig) {
										return sig.thisParameter;
									},
								);
								if (firstThisParameterOfUnionSignatures) {
									var thisType = getIntersectionType(
										mapDefined(
											unionSignatures,
											function (sig) {
												return sig.thisParameter && getTypeOfSymbol(
													sig.thisParameter,
												);
											},
										),
									);
									thisParameter = createSymbolWithType(
										firstThisParameterOfUnionSignatures,
										thisType,
									);
								}
								s = createUnionSignature(signature, unionSignatures);
								s.thisParameter = thisParameter;
							}
							(result || (result = [])).push(s);
						}
					}
				}
			}
			if (!length(result) && indexWithLengthOverOne !== -1) {
				// No sufficiently similar signature existed to subsume all the other signatures in the union - time to see if we can make a single
				// signature that handles all over them. We only do this when there are overloads in only one constituent.
				// (Overloads are conditional in nature and having overloads in multiple constituents would necessitate making a power set of
				// signatures from the type, whose ordering would be non-obvious)
				var masterList = signatureLists[indexWithLengthOverOne !== undefined ? indexWithLengthOverOne : 0];
				var results = masterList.slice();
				var _loop_4 = function (signatures) {
					if (signatures !== masterList) {
						var signature_1 = signatures[0];
						Debug.assert(
							!!signature_1,
							"getUnionSignatures bails early on empty signature lists and should not have empty lists on second pass",
						);
						results = !!signature_1.typeParameters && some(
							results,
							function (s) {
								return !!s.typeParameters && !compareTypeParametersIdentical(
									signature_1.typeParameters,
									s.typeParameters,
								);
							},
						) ? undefined : map(
							results,
							function (sig) {
								return combineSignaturesOfUnionMembers(sig, signature_1);
							},
						);
						if (!results) {
							return "break";
						}
					}
				};
				for (
					var _b = 0, signatureLists_1 = signatureLists;
					_b < signatureLists_1.length;
					_b++
				) {
					var signatures = signatureLists_1[_b];
					var state_2 = _loop_4(signatures);
					if (state_2 === "break") break;
				}
				result = results;
			}
			return result || emptyArray;
		}
		function compareTypeParametersIdentical(sourceParams, targetParams) {
			if (length(sourceParams) !== length(targetParams)) {
				return false;
			}
			if (!sourceParams || !targetParams) {
				return true;
			}
			var mapper = createTypeMapper(targetParams, sourceParams);
			for (var i = 0; i < sourceParams.length; i++) {
				var source = sourceParams[i];
				var target = targetParams[i];
				if (source === target) continue;
				// We instantiate the target type parameter constraints into the source types so we can recognize `<T, U extends T>` as the same as `<A, B extends A>`
				if (
					!isTypeIdenticalTo(
						getConstraintFromTypeParameter(source) || unknownType,
						instantiateType(
							getConstraintFromTypeParameter(target) || unknownType,
							mapper,
						),
					)
				) return false;// if the parameter is used covariantly or contravariantly (so we intersect if it's used like a parameter or union if used like a return type) // It might make sense to combine these defaults in the future, but doing so intelligently requires knowing // We don't compare defaults - we just use the type parameter defaults from the first signature that seems to match.
				// and, since it's just an inference _default_, just picking one arbitrarily works OK.
			}
			return true;
		}
		function combineUnionThisParam(left, right, mapper) {
			if (!left || !right) {
				return left || right;
			}
			// A signature `this` type might be a read or a write position... It's very possible that it should be invariant
			// and we should refuse to merge signatures if there are `this` types and they do not match. However, so as to be
			// permissive when calling, for now, we'll intersect the `this` types just like we do for param types in union signatures.
			var thisType = getIntersectionType(
				[getTypeOfSymbol(left), instantiateType(getTypeOfSymbol(right), mapper)],
			);
			return createSymbolWithType(left, thisType);
		}
		function combineUnionParameters(left, right, mapper) {
			var leftCount = getParameterCount(left);
			var rightCount = getParameterCount(right);
			var longest = leftCount >= rightCount ? left : right;
			var shorter = longest === left ? right : left;
			var longestCount = longest === left ? leftCount : rightCount;
			var eitherHasEffectiveRest = (hasEffectiveRestParameter(left) || hasEffectiveRestParameter(
				right,
			));
			var needsExtraRestElement = eitherHasEffectiveRest && !hasEffectiveRestParameter(
				longest,
			);
			var params = new Array(longestCount + (needsExtraRestElement ? 1 : 0));
			for (var i = 0; i < longestCount; i++) {
				var longestParamType = tryGetTypeAtPosition(longest, i);
				if (longest === right) {
					longestParamType = instantiateType(longestParamType, mapper);
				}
				var shorterParamType = tryGetTypeAtPosition(shorter, i) || unknownType;
				if (shorter === right) {
					shorterParamType = instantiateType(shorterParamType, mapper);
				}
				var unionParamType = getIntersectionType(
					[longestParamType, shorterParamType],
				);
				var isRestParam = eitherHasEffectiveRest && !needsExtraRestElement && i === (longestCount - 1);
				var isOptional = i >= getMinArgumentCount(longest) && i >= getMinArgumentCount(
					shorter,
				);
				var leftName = i >= leftCount ? undefined : getParameterNameAtPosition(
					left,
					i,
				);
				var rightName = i >= rightCount ? undefined : getParameterNameAtPosition(
					right,
					i,
				);
				var paramName = leftName === rightName ? leftName : !leftName ? rightName : !rightName ? leftName : undefined;
				var paramSymbol = createSymbol(
					SymbolFlags.FunctionScopedVariable | (isOptional && !isRestParam ? SymbolFlags.Optional : 0),
					paramName || "arg".concat(i),
				);
				paramSymbol.type = isRestParam ? createArrayType(unionParamType) : unionParamType;
				params[i] = paramSymbol;
			}
			if (needsExtraRestElement) {
				var restParamSymbol = createSymbol(
					SymbolFlags.FunctionScopedVariable,
					"args",
				);
				restParamSymbol.type = createArrayType(
					getTypeAtPosition(shorter, longestCount),
				);
				if (shorter === right) {
					restParamSymbol.type = instantiateType(restParamSymbol.type, mapper);
				}
				params[longestCount] = restParamSymbol;
			}
			return params;
		}
		function combineSignaturesOfUnionMembers(left, right) {
			var typeParams = left.typeParameters || right.typeParameters;
			var paramMapper;
			if (left.typeParameters && right.typeParameters) {
				paramMapper = createTypeMapper(
					right.typeParameters,
					left.typeParameters,
				); // We just use the type parameter defaults from the first signature
			}
			var declaration = left.declaration;
			var params = combineUnionParameters(left, right, paramMapper);
			var thisParam = combineUnionThisParam(
				left.thisParameter,
				right.thisParameter,
				paramMapper,
			);
			var minArgCount = Math.max(left.minArgumentCount, right.minArgumentCount);
			var result = createSignature(
				declaration,
				typeParams,
				thisParam,
				params,
				/*resolvedReturnType*/ undefined,
				/*resolvedTypePredicate*/ undefined,
				minArgCount,
				(left.flags | right.flags) & SignatureFlags.PropagatingFlags,
			);
			result.compositeKind = TypeFlags.Union;
			result.compositeSignatures = concatenate(
				left.compositeKind !== TypeFlags.Intersection && left.compositeSignatures || [
					left,
				],
				[right],
			);
			if (paramMapper) {
				result.mapper = left.compositeKind !== TypeFlags.Intersection && left.mapper && left.compositeSignatures ? combineTypeMappers(
					left.mapper,
					paramMapper,
				) : paramMapper;
			}
			return result;
		}
		function getUnionIndexInfos(types) {
			var sourceInfos = getIndexInfosOfType(types[0]);
			if (sourceInfos) {
				var result = [];
				var _loop_5 = function (info) {
					var indexType = info.keyType;
					if (
						every(
							types,
							function (t) {
								return !!getIndexInfoOfType(t, indexType);
							},
						)
					) {
						result.push(
							createIndexInfo(
								indexType,
								getUnionType(
									map(
										types,
										function (t) {
											return getIndexTypeOfType(t, indexType);
										},
									),
								),
								some(
									types,
									function (t) {
										return getIndexInfoOfType(t, indexType).isReadonly;
									},
								),
							),
						);
					}
				};
				for (
					var _i = 0, sourceInfos_1 = sourceInfos;
					_i < sourceInfos_1.length;
					_i++
				) {
					var info = sourceInfos_1[_i];
					_loop_5(info);
				}
				return result;
			}
			return emptyArray;
		}
		function resolveUnionTypeMembers(type) {
			// The members and properties collections are empty for union types. To get all properties of a union
			// type use getPropertiesOfType (only the language service uses this).
			var callSignatures = getUnionSignatures(
				map(
					type.types,
					function (t) {
						return t === globalFunctionType ? [unknownSignature] : getSignaturesOfType(
							t,
							SignatureKind.Call,
						);
					},
				),
			);
			var constructSignatures = getUnionSignatures(
				map(
					type.types,
					function (t) {
						return getSignaturesOfType(t, SignatureKind.Construct);
					},
				),
			);
			var indexInfos = getUnionIndexInfos(type.types);
			setStructuredTypeMembers(
				type,
				emptySymbols,
				callSignatures,
				constructSignatures,
				indexInfos,
			);
		}
		function intersectTypes(type1, type2) {
			return !type1 ? type2 : !type2 ? type1 : getIntersectionType(
				[type1, type2],
			);
		}
		function findMixins(types) {
			var constructorTypeCount = countWhere(
				types,
				function (t) {
					return getSignaturesOfType(t, SignatureKind.Construct).length > 0;
				},
			);
			var mixinFlags = map(types, isMixinConstructorType);
			if (
				constructorTypeCount > 0 && constructorTypeCount === countWhere(
					mixinFlags,
					function (b) {
						return b;
					},
				)
			) {
				var firstMixinIndex = mixinFlags.indexOf( /*searchElement*/ true);
				mixinFlags[firstMixinIndex] = false;
			}
			return mixinFlags;
		}
		function includeMixinType(type, types, mixinFlags, index) {
			var mixedTypes = [];
			for (var i = 0; i < types.length; i++) {
				if (i === index) {
					mixedTypes.push(type);
				} else if (mixinFlags[i]) {
					mixedTypes.push(
						getReturnTypeOfSignature(
							getSignaturesOfType(types[i], SignatureKind.Construct)[0],
						),
					);
				}
			}
			return getIntersectionType(mixedTypes);
		}
		function resolveIntersectionTypeMembers(type) {
			// The members and properties collections are empty for intersection types. To get all properties of an
			// intersection type use getPropertiesOfType (only the language service uses this).
			var callSignatures;
			var constructSignatures;
			var indexInfos;
			var types = type.types;
			var mixinFlags = findMixins(types);
			var mixinCount = countWhere(
				mixinFlags,
				function (b) {
					return b;
				},
			);
			var _loop_6 = function (i) {
				var t = type.types[i];
				// When an intersection type contains mixin constructor types, the construct signatures from
				// those types are discarded and their return types are mixed into the return types of all
				// other construct signatures in the intersection type. For example, the intersection type
				// '{ new(...args: any[]) => A } & { new(s: string) => B }' has a single construct signature
				// 'new(s: string) => A & B'.
				if (!mixinFlags[i]) {
					var signatures = getSignaturesOfType(t, SignatureKind.Construct);
					if (signatures.length && mixinCount > 0) {
						signatures = map(
							signatures,
							function (s) {
								var clone = cloneSignature(s);
								clone.resolvedReturnType = includeMixinType(
									getReturnTypeOfSignature(s),
									types,
									mixinFlags,
									i,
								);
								return clone;
							},
						);
					}
					constructSignatures = appendSignatures(
						constructSignatures,
						signatures,
					);
				}
				callSignatures = appendSignatures(
					callSignatures,
					getSignaturesOfType(t, SignatureKind.Call),
				);
				indexInfos = reduceLeft(
					getIndexInfosOfType(t),
					function (infos, newInfo) {
						return appendIndexInfo(infos, newInfo, /*union*/ false);
					},
					indexInfos,
				);
			};
			for (var i = 0; i < types.length; i++) {
				_loop_6(i);
			}
			setStructuredTypeMembers(
				type,
				emptySymbols,
				callSignatures || emptyArray,
				constructSignatures || emptyArray,
				indexInfos || emptyArray,
			);
		}
		function appendSignatures(signatures, newSignatures) {
			var _loop_7 = function (sig) {
				if (
					!signatures || every(
						signatures,
						function (s) {
							return !compareSignaturesIdentical(
								s,
								sig, /*partialMatch*/
								false, /*ignoreThisTypes*/
								false, /*ignoreReturnTypes*/
								false,
								compareTypesIdentical,
							);
						},
					)
				) {
					signatures = append(signatures, sig);
				}
			};
			for (
				var _i = 0, newSignatures_1 = newSignatures;
				_i < newSignatures_1.length;
				_i++
			) {
				var sig = newSignatures_1[_i];
				_loop_7(sig);
			}
			return signatures;
		}
		function appendIndexInfo(indexInfos, newInfo, union) {
			if (indexInfos) {
				for (var i = 0; i < indexInfos.length; i++) {
					var info = indexInfos[i];
					if (info.keyType === newInfo.keyType) {
						indexInfos[i] = createIndexInfo(
							info.keyType,
							union ? getUnionType([info.type, newInfo.type]) : getIntersectionType(
								[info.type, newInfo.type],
							),
							union ? info.isReadonly || newInfo.isReadonly : info.isReadonly && newInfo.isReadonly,
						);
						return indexInfos;
					}
				}
			}
			return append(indexInfos, newInfo);
		}
		/**
         * Converts an AnonymousType to a ResolvedType.
         */
		function resolveAnonymousTypeMembers(type) {
			var symbol = getMergedSymbol(type.symbol);
			if (type.target) {
				setStructuredTypeMembers(
					type,
					emptySymbols,
					emptyArray,
					emptyArray,
					emptyArray,
				);
				var members = createInstantiatedSymbolTable(
					getPropertiesOfObjectType(type.target),
					type.mapper, /*mappingThisOnly*/
					false,
				);
				var callSignatures = instantiateSignatures(
					getSignaturesOfType(type.target, SignatureKind.Call),
					type.mapper,
				);
				var constructSignatures = instantiateSignatures(
					getSignaturesOfType(type.target, SignatureKind.Construct),
					type.mapper,
				);
				var indexInfos = instantiateIndexInfos(
					getIndexInfosOfType(type.target),
					type.mapper,
				);
				setStructuredTypeMembers(
					type,
					members,
					callSignatures,
					constructSignatures,
					indexInfos,
				);
			} else if (symbol.flags & SymbolFlags.TypeLiteral) {
				setStructuredTypeMembers(
					type,
					emptySymbols,
					emptyArray,
					emptyArray,
					emptyArray,
				);
				var members = getMembersOfSymbol(symbol);
				var callSignatures = getSignaturesOfSymbol(
					members.get(InternalSymbolName.Call),
				);
				var constructSignatures = getSignaturesOfSymbol(
					members.get(InternalSymbolName.New),
				);
				var indexInfos = getIndexInfosOfSymbol(symbol);
				setStructuredTypeMembers(
					type,
					members,
					callSignatures,
					constructSignatures,
					indexInfos,
				);
			} else {
				// Combinations of function, class, enum and module
				var members = emptySymbols;
				var indexInfos = void 0;
				if (symbol.exports) {
					members = getExportsOfSymbol(symbol);
					if (symbol === globalThisSymbol) {
						var varsOnly_1 = new Map();
						members.forEach(
							function (p) {
								if (!(p.flags & SymbolFlags.BlockScoped)) {
									varsOnly_1.set(p.escapedName, p);
								}
							},
						);
						members = varsOnly_1;
					}
				}
				var baseConstructorIndexInfo = void 0;
				setStructuredTypeMembers(
					type,
					members,
					emptyArray,
					emptyArray,
					emptyArray,
				);
				if (symbol.flags & SymbolFlags.Class) {
					var classType = getDeclaredTypeOfClassOrInterface(symbol);
					var baseConstructorType = getBaseConstructorTypeOfClass(classType);
					if (
						baseConstructorType.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.TypeVariable)
					) {
						members = createSymbolTable(
							getNamedOrIndexSignatureMembers(members),
						);
						addInheritedMembers(
							members,
							getPropertiesOfType(baseConstructorType),
						);
					} else if (baseConstructorType === anyType) {
						baseConstructorIndexInfo = createIndexInfo(
							stringType,
							anyType, /*isReadonly*/
							false,
						);
					}
				}
				var indexSymbol = getIndexSymbolFromSymbolTable(members);
				if (indexSymbol) {
					indexInfos = getIndexInfosOfIndexSymbol(indexSymbol);
				} else {
					if (baseConstructorIndexInfo) {
						indexInfos = append(indexInfos, baseConstructorIndexInfo);
					}
					if (
						symbol.flags & SymbolFlags.Enum && (getDeclaredTypeOfSymbol(symbol).flags & TypeFlags.Enum || some(
							type.properties,
							function (prop) {
								return !!(getTypeOfSymbol(prop).flags & TypeFlags.NumberLike);
							},
						))
					) {
						indexInfos = append(indexInfos, enumNumberIndexInfo);
					}
				}
				setStructuredTypeMembers(
					type,
					members,
					emptyArray,
					emptyArray,
					indexInfos || emptyArray,
				);
				// We resolve the members before computing the signatures because a signature may use
				// typeof with a qualified name expression that circularly references the type we are
				// in the process of resolving (see issue #6072). The temporarily empty signature list
				// will never be observed because a qualified name can't reference signatures.
				if (symbol.flags & (SymbolFlags.Function | SymbolFlags.Method)) {
					type.callSignatures = getSignaturesOfSymbol(symbol);
				}
				// And likewise for construct signatures for classes
				if (symbol.flags & SymbolFlags.Class) {
					var classType_1 = getDeclaredTypeOfClassOrInterface(symbol);
					var constructSignatures = symbol.members ? getSignaturesOfSymbol(
						symbol.members.get(InternalSymbolName.Constructor),
					) : emptyArray;
					if (symbol.flags & SymbolFlags.Function) {
						constructSignatures = addRange(
							constructSignatures.slice(),
							mapDefined(
								type.callSignatures,
								function (sig) {
									return isJSConstructor(sig.declaration) ? createSignature(
										sig.declaration,
										sig.typeParameters,
										sig.thisParameter,
										sig.parameters,
										classType_1, /*resolvedTypePredicate*/
										undefined,
										sig.minArgumentCount,
										sig.flags & SignatureFlags.PropagatingFlags,
									) : undefined;
								},
							),
						);
					}
					if (!constructSignatures.length) {
						constructSignatures = getDefaultConstructSignatures(classType_1);
					}
					type.constructSignatures = constructSignatures;
				}
			}
		}
		function replaceIndexedAccess(instantiable, type, replacement) {
			// map type.indexType to 0
			// map type.objectType to `[TReplacement]`
			// thus making the indexed access `[TReplacement][0]` or `TReplacement`
			return instantiateType(
				instantiable,
				createTypeMapper(
					[type.indexType, type.objectType],
					[getNumberLiteralType(0), createTupleType([replacement])],
				),
			);
		}
		function resolveReverseMappedTypeMembers(type) {
			var indexInfo = getIndexInfoOfType(type.source, stringType);
			var modifiers = getMappedTypeModifiers(type.mappedType);
			var readonlyMask = modifiers & 1 /* IncludeReadonly */ ? false : true;
			var optionalMask = modifiers & 4 ? 0 : SymbolFlags.Optional; /* IncludeOptional */
			var indexInfos = indexInfo ? [
				createIndexInfo(
					stringType,
					inferReverseMappedType(
						indexInfo.type,
						type.mappedType,
						type.constraintType,
					),
					readonlyMask && indexInfo.isReadonly,
				),
			] : emptyArray;
			var members = createSymbolTable();
			for (
				var _i = 0, _a = getPropertiesOfType(type.source);
				_i < _a.length;
				_i++
			) {
				var prop = _a[_i];
				var checkFlags = CheckFlags.ReverseMapped | (readonlyMask && isReadonlySymbol(
					prop,
				) ? CheckFlags.Readonly : 0);
				var inferredProp = createSymbol(
					SymbolFlags.Property | prop.flags & optionalMask,
					prop.escapedName,
					checkFlags,
				);
				inferredProp.declarations = prop.declarations;
				inferredProp.nameType = getSymbolLinks(prop).nameType;
				inferredProp.propertyType = getTypeOfSymbol(prop);
				if (
					type.constraintType.type.flags & TypeFlags.IndexedAccess && type.constraintType.type.objectType.flags & TypeFlags.TypeParameter && type.constraintType.type.indexType.flags & TypeFlags.TypeParameter
				) {
					// A reverse mapping of `{[K in keyof T[K_1]]: T[K_1]}` is the same as that of `{[K in keyof T]: T}`, since all we care about is
					// inferring to the "type parameter" (or indexed access) shared by the constraint and template. So, to reduce the number of
					// type identities produced, we simplify such indexed access occurences
					var newTypeParam = type.constraintType.type.objectType;
					var newMappedType = replaceIndexedAccess(
						type.mappedType,
						type.constraintType.type,
						newTypeParam,
					);
					inferredProp.mappedType = newMappedType;
					inferredProp.constraintType = getIndexType(newTypeParam);
				} else {
					inferredProp.mappedType = type.mappedType;
					inferredProp.constraintType = type.constraintType;
				}
				members.set(prop.escapedName, inferredProp);
			}
			setStructuredTypeMembers(
				type,
				members,
				emptyArray,
				emptyArray,
				indexInfos,
			);
		}
		// Return the lower bound of the key type in a mapped type. Intuitively, the lower
		// bound includes those keys that are known to always be present, for example because
		// because of constraints on type parameters (e.g. 'keyof T' for a constrained T).
		function getLowerBoundOfKeyType(type) {
			if (type.flags & TypeFlags.Index) {
				var t = getApparentType(type.type);
				return isGenericTupleType(t) ? getKnownKeysOfTupleType(t) : getIndexType(
					t,
				);
			}
			if (type.flags & TypeFlags.Conditional) {
				if (type.root.isDistributive) {
					var checkType = type.checkType;
					var constraint = getLowerBoundOfKeyType(checkType);
					if (constraint !== checkType) {
						return getConditionalTypeInstantiation(
							type,
							prependTypeMapping(type.root.checkType, constraint, type.mapper),
						);
					}
				}
				return type;
			}
			if (type.flags & TypeFlags.Union) {
				return mapType(type, getLowerBoundOfKeyType);
			}
			if (type.flags & TypeFlags.Intersection) {
				return getIntersectionType(sameMap(type.types, getLowerBoundOfKeyType));
			}
			return type;
		}
		function getIsLateCheckFlag(s) {
			return getCheckFlags(s) & CheckFlags.Late;
		}
		function forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(
			type,
			include,
			stringsOnly,
			cb,
		) {
			for (var _i = 0, _a = getPropertiesOfType(type); _i < _a.length; _i++) {
				var prop = _a[_i];
				cb(getLiteralTypeFromProperty(prop, include));
			}
			if (type.flags & TypeFlags.Any) {
				cb(stringType);
			} else {
				for (var _b = 0, _c = getIndexInfosOfType(type); _b < _c.length; _b++) {
					var info = _c[_b];
					if (
						!stringsOnly || info.keyType.flags & (TypeFlags.String | TypeFlags.TemplateLiteral)
					) {
						cb(info.keyType);
					}
				}
			}
		}
		/** Resolve the members of a mapped type { [P in K]: T } */
		function resolveMappedTypeMembers(type) {
			var members = createSymbolTable();
			var indexInfos;
			// Resolve upfront such that recursive references see an empty object type.
			setStructuredTypeMembers(
				type,
				emptySymbols,
				emptyArray,
				emptyArray,
				emptyArray,
			);
			// In { [P in K]: T }, we refer to P as the type parameter type, K as the constraint type,
			// and T as the template type.
			var typeParameter = getTypeParameterFromMappedType(type);
			var constraintType = getConstraintTypeFromMappedType(type);
			var nameType = getNameTypeFromMappedType(type.target || type);
			var templateType = getTemplateTypeFromMappedType(type.target || type);
			var modifiersType = getApparentType(getModifiersTypeFromMappedType(type)); // The 'T' in 'keyof T'
			var templateModifiers = getMappedTypeModifiers(type);
			var include = keyofStringsOnly ? TypeFlags.StringLiteral : TypeFlags.StringOrNumberLiteralOrUnique;
			if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
				// We have a { [P in keyof T]: X }
				forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(
					modifiersType,
					include,
					keyofStringsOnly,
					addMemberForKeyType,
				);
			} else {
				forEachType(getLowerBoundOfKeyType(constraintType), addMemberForKeyType);
			}
			setStructuredTypeMembers(
				type,
				members,
				emptyArray,
				emptyArray,
				indexInfos || emptyArray,
			);
			function addMemberForKeyType(keyType) {
				var propNameType = nameType ? instantiateType(
					nameType,
					appendTypeMapping(type.mapper, typeParameter, keyType),
				) : keyType;
				forEachType(
					propNameType,
					function (t) {
						return addMemberForKeyTypeWorker(keyType, t);
					},
				);
			}
			function addMemberForKeyTypeWorker(keyType, propNameType) {
				// If the current iteration type constituent is a string literal type, create a property.
				// Otherwise, for type string create a string index signature.
				if (isTypeUsableAsPropertyName(propNameType)) {
					var propName = getPropertyNameFromType(propNameType);
					// String enum members from separate enums with identical values
					// are distinct types with the same property name. Make the resulting
					// property symbol's name type be the union of those enum member types.
					var existingProp = members.get(propName);
					if (existingProp) {
						existingProp.nameType = getUnionType(
							[existingProp.nameType, propNameType],
						);
						existingProp.keyType = getUnionType([existingProp.keyType, keyType]);
					} else {
						var modifiersProp = isTypeUsableAsPropertyName(keyType) ? getPropertyOfType(
							modifiersType,
							getPropertyNameFromType(keyType),
						) : undefined;
						var isOptional = !!(templateModifiers & 4 || !(templateModifiers & 8) && modifiersProp && modifiersProp.flags & SymbolFlags.Optional); /* IncludeOptional */ /* ExcludeOptional */
						var isReadonly = !!(templateModifiers & 1 || !(templateModifiers & 2) && modifiersProp && isReadonlySymbol(
							modifiersProp, /* IncludeReadonly */ /* ExcludeReadonly */
						));
						var stripOptional = strictNullChecks && !isOptional && modifiersProp && modifiersProp.flags & SymbolFlags.Optional;
						var lateFlag = modifiersProp ? getIsLateCheckFlag(modifiersProp) : 0;
						var prop = createSymbol(
							SymbolFlags.Property | (isOptional ? SymbolFlags.Optional : 0),
							propName,
							lateFlag | CheckFlags.Mapped | (isReadonly ? CheckFlags.Readonly : 0) | (stripOptional ? CheckFlags.StripOptional : 0),
						);
						prop.mappedType = type;
						prop.nameType = propNameType;
						prop.keyType = keyType;
						if (modifiersProp) {
							prop.syntheticOrigin = modifiersProp;
							// If the mapped type has an `as XXX` clause, the property name likely won't match the declaration name and
							// multiple properties may map to the same name. Thus, we attach no declarations to the symbol.
							prop.declarations = nameType ? undefined : modifiersProp.declarations;
						}
						members.set(propName, prop);
					}
				} else if (
					isValidIndexKeyType(propNameType) || propNameType.flags & (TypeFlags.Any | TypeFlags.Enum)
				) {
					var indexKeyType = propNameType.flags & (TypeFlags.Any | TypeFlags.String) ? stringType : propNameType.flags & (TypeFlags.Number | TypeFlags.Enum) ? numberType : propNameType;
					var propType = instantiateType(
						templateType,
						appendTypeMapping(type.mapper, typeParameter, keyType),
					);
					var indexInfo = createIndexInfo(
						indexKeyType,
						propType,
						!!(templateModifiers & 1), /* IncludeReadonly */
					);
					indexInfos = appendIndexInfo(indexInfos, indexInfo, /*union*/ true);
				}
			}
		}
		function getTypeOfMappedSymbol(symbol) {
			if (!symbol.type) {
				var mappedType = symbol.mappedType;
				if (!pushTypeResolution(symbol, 0 /* Type */ )) {
					mappedType.containsError = true;
					return errorType;
				}
				var templateType = getTemplateTypeFromMappedType(
					mappedType.target || mappedType,
				);
				var mapper = appendTypeMapping(
					mappedType.mapper,
					getTypeParameterFromMappedType(mappedType),
					symbol.keyType,
				);
				var propType = instantiateType(templateType, mapper);
				// When creating an optional property in strictNullChecks mode, if 'undefined' isn't assignable to the
				// type, we include 'undefined' in the type. Similarly, when creating a non-optional property in strictNullChecks
				// mode, if the underlying property is optional we remove 'undefined' from the type.
				var type = strictNullChecks && symbol.flags & SymbolFlags.Optional && !maybeTypeOfKind(
					propType,
					TypeFlags.Undefined | TypeFlags.Void,
				) ? getOptionalType(propType, /*isProperty*/ true) : symbol.checkFlags & CheckFlags.StripOptional ? removeMissingOrUndefinedType(
					propType,
				) : propType;
				if (!popTypeResolution()) {
					error(
						currentNode,
						Diagnostics.Type_of_property_0_circularly_references_itself_in_mapped_type_1,
						symbolToString(symbol),
						typeToString(mappedType),
					);
					type = errorType;
				}
				symbol.type = type;
			}
			return symbol.type;
		}
		function getTypeParameterFromMappedType(type) {
			return type.typeParameter || (type.typeParameter = getDeclaredTypeOfTypeParameter(
				getSymbolOfNode(type.declaration.typeParameter),
			));
		}
		function getConstraintTypeFromMappedType(type) {
			return type.constraintType || (type.constraintType = getConstraintOfTypeParameter(
				getTypeParameterFromMappedType(type),
			) || errorType);
		}
		function getNameTypeFromMappedType(type) {
			return type.declaration.nameType ? type.nameType || (type.nameType = instantiateType(
				getTypeFromTypeNode(type.declaration.nameType),
				type.mapper,
			)) : undefined;
		}
		function getTemplateTypeFromMappedType(type) {
			return type.templateType || (type.templateType = type.declaration.type ? instantiateType(
				addOptionality(
					getTypeFromTypeNode(type.declaration.type), /*isProperty*/
					true,
					!!(getMappedTypeModifiers(type) & 4), /* IncludeOptional */
				),
				type.mapper,
			) : errorType);
		}
		function getConstraintDeclarationForMappedType(type) {
			return getEffectiveConstraintOfTypeParameter(
				type.declaration.typeParameter,
			);
		}
		function isMappedTypeWithKeyofConstraintDeclaration(type) {
			var constraintDeclaration = getConstraintDeclarationForMappedType(type); // TODO: GH#18217
			return constraintDeclaration.kind === SyntaxKind.TypeOperator && constraintDeclaration.operator === SyntaxKind.KeyOfKeyword;
		}
		function getModifiersTypeFromMappedType(type) {
			if (!type.modifiersType) {
				if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
					// If the constraint declaration is a 'keyof T' node, the modifiers type is T. We check
					// AST nodes here because, when T is a non-generic type, the logic below eagerly resolves
					// 'keyof T' to a literal union type and we can't recover T from that type.
					type.modifiersType = instantiateType(
						getTypeFromTypeNode(
							getConstraintDeclarationForMappedType(type).type,
						),
						type.mapper,
					);
				} else {
					// Otherwise, get the declared constraint type, and if the constraint type is a type parameter,
					// get the constraint of that type parameter. If the resulting type is an indexed type 'keyof T',
					// the modifiers type is T. Otherwise, the modifiers type is unknown.
					var declaredType = getTypeFromMappedTypeNode(type.declaration);
					var constraint = getConstraintTypeFromMappedType(declaredType);
					var extendedConstraint = constraint && constraint.flags & TypeFlags.TypeParameter ? getConstraintOfTypeParameter(
						constraint,
					) : constraint;
					type.modifiersType = extendedConstraint && extendedConstraint.flags & TypeFlags.Index ? instantiateType(
						extendedConstraint.type,
						type.mapper,
					) : unknownType;
				}
			}
			return type.modifiersType;
		}
		function getMappedTypeModifiers(type) {
			var declaration = type.declaration;
			return (declaration.readonlyToken ? declaration.readonlyToken.kind === SyntaxKind.MinusToken ? 2 : 1 : 0) | (declaration.questionToken ? declaration.questionToken.kind === SyntaxKind.MinusToken ? 8 : 4 : 0); /* ExcludeReadonly */ /* IncludeReadonly */ /* ExcludeOptional */ /* IncludeOptional */
		}
		function getMappedTypeOptionality(type) {
			var modifiers = getMappedTypeModifiers(type);
			return modifiers & 8 ? -1 : modifiers & 4 ? 1 : 0; /* ExcludeOptional */ /* IncludeOptional */
		}
		function getCombinedMappedTypeOptionality(type) {
			var optionality = getMappedTypeOptionality(type);
			var modifiersType = getModifiersTypeFromMappedType(type);
			return optionality || (isGenericMappedType(modifiersType) ? getMappedTypeOptionality(
				modifiersType,
			) : 0);
		}
		function isPartialMappedType(type) {
			return !!(getObjectFlags(type) & ObjectFlags.Mapped && getMappedTypeModifiers(
				type,
			) & 4); /* IncludeOptional */
		}
		function isGenericMappedType(type) {
			return !!(getObjectFlags(type) & ObjectFlags.Mapped) && isGenericIndexType(
				getConstraintTypeFromMappedType(type),
			);
		}
		function resolveStructuredTypeMembers(type) {
			if (!type.members) {
				if (type.flags & TypeFlags.Object) {
					if (type.objectFlags & ObjectFlags.Reference) {
						resolveTypeReferenceMembers(type);
					} else if (type.objectFlags & ObjectFlags.ClassOrInterface) {
						resolveClassOrInterfaceMembers(type);
					} else if (type.objectFlags & ObjectFlags.ReverseMapped) {
						resolveReverseMappedTypeMembers(type);
					} else if (type.objectFlags & ObjectFlags.Anonymous) {
						resolveAnonymousTypeMembers(type);
					} else if (type.objectFlags & ObjectFlags.Mapped) {
						resolveMappedTypeMembers(type);
					}
				} else if (type.flags & TypeFlags.Union) {
					resolveUnionTypeMembers(type);
				} else if (type.flags & TypeFlags.Intersection) {
					resolveIntersectionTypeMembers(type);
				}
			}
			return type;
		}
		/** Return properties of an object type or an empty array for other types */
		function getPropertiesOfObjectType(type) {
			if (type.flags & TypeFlags.Object) {
				return resolveStructuredTypeMembers(type).properties;
			}
			return emptyArray;
		}
		/** If the given type is an object type and that type has a property by the given name,
         * return the symbol for that property. Otherwise return undefined.
         */
		function getPropertyOfObjectType(type, name) {
			if (type.flags & TypeFlags.Object) {
				var resolved = resolveStructuredTypeMembers(type);
				var symbol = resolved.members.get(name);
				if (symbol && symbolIsValue(symbol)) {
					return symbol;
				}
			}
		}
		function getPropertiesOfUnionOrIntersectionType(type) {
			if (!type.resolvedProperties) {
				var members = createSymbolTable();
				for (var _i = 0, _a = type.types; _i < _a.length; _i++) {
					var current = _a[_i];
					for (
						var _b = 0, _c = getPropertiesOfType(current);
						_b < _c.length;
						_b++
					) {
						var prop = _c[_b];
						if (!members.has(prop.escapedName)) {
							var combinedProp = getPropertyOfUnionOrIntersectionType(
								type,
								prop.escapedName,
							);
							if (combinedProp) {
								members.set(prop.escapedName, combinedProp);
							}
						}
					}
					// The properties of a union type are those that are present in all constituent types, so
					// we only need to check the properties of the first type without index signature
					if (
						type.flags & TypeFlags.Union && getIndexInfosOfType(current).length === 0
					) {
						break;
					}
				}
				type.resolvedProperties = getNamedMembers(members);
			}
			return type.resolvedProperties;
		}
		function getPropertiesOfType(type) {
			type = getReducedApparentType(type);
			return type.flags & TypeFlags.UnionOrIntersection ? getPropertiesOfUnionOrIntersectionType(
				type,
			) : getPropertiesOfObjectType(type);
		}
		function forEachPropertyOfType(type, action) {
			type = getReducedApparentType(type);
			if (type.flags & TypeFlags.StructuredType) {
				resolveStructuredTypeMembers(type).members.forEach(
					function (symbol, escapedName) {
						if (isNamedMember(symbol, escapedName)) {
							action(symbol, escapedName);
						}
					},
				);
			}
		}
		function isTypeInvalidDueToUnionDiscriminant(contextualType, obj) {
			var list = obj.properties;
			return list.some(
				function (property) {
					var nameType = property.name && getLiteralTypeFromPropertyName(
						property.name,
					);
					var name = nameType && isTypeUsableAsPropertyName(nameType) ? getPropertyNameFromType(
						nameType,
					) : undefined;
					var expected = name === undefined ? undefined : getTypeOfPropertyOfType(
						contextualType,
						name,
					);
					return !!expected && isLiteralType(expected) && !isTypeAssignableTo(
						getTypeOfNode(property),
						expected,
					);
				},
			);
		}
		function getAllPossiblePropertiesOfTypes(types) {
			var unionType = getUnionType(types);
			if (!(unionType.flags & TypeFlags.Union)) {
				return getAugmentedPropertiesOfType(unionType);
			}
			var props = createSymbolTable();
			for (var _i = 0, types_4 = types; _i < types_4.length; _i++) {
				var memberType = types_4[_i];
				for (
					var _a = 0, _b = getAugmentedPropertiesOfType(memberType);
					_a < _b.length;
					_a++
				) {
					var escapedName = _b[_a].escapedName;
					if (!props.has(escapedName)) {
						var prop = createUnionOrIntersectionProperty(unionType, escapedName);
						// May be undefined if the property is private
						if (prop) props.set(escapedName, prop);
					}
				}
			}
			return arrayFrom(props.values());
		}
		function getConstraintOfType(type) {
			return type.flags & TypeFlags.TypeParameter ? getConstraintOfTypeParameter(
				type,
			) : type.flags & TypeFlags.IndexedAccess ? getConstraintOfIndexedAccess(
				type,
			) : type.flags & TypeFlags.Conditional ? getConstraintOfConditionalType(
				type,
			) : getBaseConstraintOfType(type);
		}
		function getConstraintOfTypeParameter(typeParameter) {
			return hasNonCircularBaseConstraint(typeParameter) ? getConstraintFromTypeParameter(
				typeParameter,
			) : undefined;
		}
		function getConstraintOfIndexedAccess(type) {
			return hasNonCircularBaseConstraint(type) ? getConstraintFromIndexedAccess(
				type,
			) : undefined;
		}
		function getSimplifiedTypeOrConstraint(type) {
			var simplified = getSimplifiedType(type, /*writing*/ false);
			return simplified !== type ? simplified : getConstraintOfType(type);
		}
		function getConstraintFromIndexedAccess(type) {
			if (isMappedTypeGenericIndexedAccess(type)) {
				// For indexed access types of the form { [P in K]: E }[X], where K is non-generic and X is generic,
				// we substitute an instantiation of E where P is replaced with X.
				return substituteIndexedMappedType(type.objectType, type.indexType);
			}
			var indexConstraint = getSimplifiedTypeOrConstraint(type.indexType);
			if (indexConstraint && indexConstraint !== type.indexType) {
				var indexedAccess = getIndexedAccessTypeOrUndefined(
					type.objectType,
					indexConstraint,
					type.accessFlags,
				);
				if (indexedAccess) {
					return indexedAccess;
				}
			}
			var objectConstraint = getSimplifiedTypeOrConstraint(type.objectType);
			if (objectConstraint && objectConstraint !== type.objectType) {
				return getIndexedAccessTypeOrUndefined(
					objectConstraint,
					type.indexType,
					type.accessFlags,
				);
			}
			return undefined;
		}
		function getDefaultConstraintOfConditionalType(type) {
			if (!type.resolvedDefaultConstraint) {
				// An `any` branch of a conditional type would normally be viral - specifically, without special handling here,
				// a conditional type with a single branch of type `any` would be assignable to anything, since it's constraint would simplify to
				// just `any`. This result is _usually_ unwanted - so instead here we elide an `any` branch from the constraint type,
				// in effect treating `any` like `never` rather than `unknown` in this location.
				var trueConstraint = getInferredTrueTypeFromConditionalType(type);
				var falseConstraint = getFalseTypeFromConditionalType(type);
				type.resolvedDefaultConstraint = isTypeAny(trueConstraint) ? falseConstraint : isTypeAny(
					falseConstraint,
				) ? trueConstraint : getUnionType([trueConstraint, falseConstraint]);
			}
			return type.resolvedDefaultConstraint;
		}
		function getConstraintOfDistributiveConditionalType(type) {
			// Check if we have a conditional type of the form 'T extends U ? X : Y', where T is a constrained
			// type parameter. If so, create an instantiation of the conditional type where T is replaced
			// with its constraint. We do this because if the constraint is a union type it will be distributed
			// over the conditional type and possibly reduced. For example, 'T extends undefined ? never : T'
			// removes 'undefined' from T.
			// We skip returning a distributive constraint for a restrictive instantiation of a conditional type
			// as the constraint for all type params (check type included) have been replace with `unknown`, which
			// is going to produce even more false positive/negative results than the distribute constraint already does.
			// Please note: the distributive constraint is a kludge for emulating what a negated type could to do filter
			// a union - once negated types exist and are applied to the conditional false branch, this "constraint"
			// likely doesn't need to exist.
			if (type.root.isDistributive && type.restrictiveInstantiation !== type) {
				var simplified = getSimplifiedType(type.checkType, /*writing*/ false);
				var constraint = simplified === type.checkType ? getConstraintOfType(
					simplified,
				) : simplified;
				if (constraint && constraint !== type.checkType) {
					var instantiated = getConditionalTypeInstantiation(
						type,
						prependTypeMapping(type.root.checkType, constraint, type.mapper),
					);
					if (!(instantiated.flags & TypeFlags.Never)) {
						return instantiated;
					}
				}
			}
			return undefined;
		}
		function getConstraintFromConditionalType(type) {
			return getConstraintOfDistributiveConditionalType(type) || getDefaultConstraintOfConditionalType(
				type,
			);
		}
		function getConstraintOfConditionalType(type) {
			return hasNonCircularBaseConstraint(type) ? getConstraintFromConditionalType(
				type,
			) : undefined;
		}
		function getEffectiveConstraintOfIntersection(types, targetIsUnion) {
			var constraints;
			var hasDisjointDomainType = false;
			for (var _i = 0, types_5 = types; _i < types_5.length; _i++) {
				var t = types_5[_i];
				if (t.flags & TypeFlags.Instantiable) {
					// We keep following constraints as long as we have an instantiable type that is known
					// not to be circular or infinite (hence we stop on index access types).
					var constraint = getConstraintOfType(t);
					while (
						constraint && constraint.flags & (TypeFlags.TypeParameter | TypeFlags.Index | TypeFlags.Conditional)
					) {
						constraint = getConstraintOfType(constraint);
					}
					if (constraint) {
						constraints = append(constraints, constraint);
						if (targetIsUnion) {
							constraints = append(constraints, t);
						}
					}
				} else if (t.flags & TypeFlags.DisjointDomains) {
					hasDisjointDomainType = true;
				}
			}
			// If the target is a union type or if we are intersecting with types belonging to one of the
			// disjoint domains, we may end up producing a constraint that hasn't been examined before.
			if (constraints && (targetIsUnion || hasDisjointDomainType)) {
				if (hasDisjointDomainType) {
					// We add any types belong to one of the disjoint domains because they might cause the final
					// intersection operation to reduce the union constraints.
					for (var _a = 0, types_6 = types; _a < types_6.length; _a++) {
						var t = types_6[_a];
						if (t.flags & TypeFlags.DisjointDomains) {
							constraints = append(constraints, t);
						}
					}
				}
				return getIntersectionType(constraints);
			}
			return undefined;
		}
		function getBaseConstraintOfType(type) {
			if (
				type.flags & (TypeFlags.InstantiableNonPrimitive | TypeFlags.UnionOrIntersection | TypeFlags.TemplateLiteral | TypeFlags.StringMapping)
			) {
				var constraint = getResolvedBaseConstraint(type);
				return constraint !== noConstraintType && constraint !== circularConstraintType ? constraint : undefined;
			}
			return type.flags & TypeFlags.Index ? keyofConstraintType : undefined;
		}
		/**
         * This is similar to `getBaseConstraintOfType` except it returns the input type if there's no base constraint, instead of `undefined`
         * It also doesn't map indexes to `string`, as where this is used this would be unneeded (and likely undesirable)
         */
		function getBaseConstraintOrType(type) {
			return getBaseConstraintOfType(type) || type;
		}
		function hasNonCircularBaseConstraint(type) {
			return getResolvedBaseConstraint(type) !== circularConstraintType;
		}
		/**
         * Return the resolved base constraint of a type variable. The noConstraintType singleton is returned if the
         * type variable has no constraint, and the circularConstraintType singleton is returned if the constraint
         * circularly references the type variable.
         */
		function getResolvedBaseConstraint(type) {
			if (type.resolvedBaseConstraint) {
				return type.resolvedBaseConstraint;
			}
			var stack = [];
			return type.resolvedBaseConstraint = getTypeWithThisArgument(
				getImmediateBaseConstraint(type),
				type,
			);
			function getImmediateBaseConstraint(t) {
				if (!t.immediateBaseConstraint) {
					if (!pushTypeResolution(t, 4 /* ImmediateBaseConstraint */ )) {
						return circularConstraintType;
					}
					var result = void 0;
					// We always explore at least 10 levels of nested constraints. Thereafter, we continue to explore
					// up to 50 levels of nested constraints provided there are no "deeply nested" types on the stack
					// (i.e. no types for which five instantiations have been recorded on the stack). If we reach 50
					// levels of nesting, we are presumably exploring a repeating pattern with a long cycle that hasn't
					// yet triggered the deeply nested limiter. We have no test cases that actually get to 50 levels of
					// nesting, so it is effectively just a safety stop.
					if (
						stack.length < 10 || stack.length < 50 && !isDeeplyNestedType(
							t,
							stack,
							stack.length,
						)
					) {
						stack.push(t);
						result = computeBaseConstraint(
							getSimplifiedType(t, /*writing*/ false),
						);
						stack.pop();
					}
					if (!popTypeResolution()) {
						if (t.flags & TypeFlags.TypeParameter) {
							var errorNode = getConstraintDeclaration(t);
							if (errorNode) {
								var diagnostic = error(
									errorNode,
									Diagnostics.Type_parameter_0_has_a_circular_constraint,
									typeToString(t),
								);
								if (
									currentNode && !isNodeDescendantOf(errorNode, currentNode) && !isNodeDescendantOf(
										currentNode,
										errorNode,
									)
								) {
									addRelatedInfo(
										diagnostic,
										createDiagnosticForNode(
											currentNode,
											Diagnostics.Circularity_originates_in_type_at_this_location,
										),
									);
								}
							}
						}
						result = circularConstraintType;
					}
					t.immediateBaseConstraint = result || noConstraintType;
				}
				return t.immediateBaseConstraint;
			}
			function getBaseConstraint(t) {
				var c = getImmediateBaseConstraint(t);
				return c !== noConstraintType && c !== circularConstraintType ? c : undefined;
			}
			function computeBaseConstraint(t) {
				if (t.flags & TypeFlags.TypeParameter) {
					var constraint = getConstraintFromTypeParameter(t);
					return t.isThisType || !constraint ? constraint : getBaseConstraint(
						constraint,
					);
				}
				if (t.flags & TypeFlags.UnionOrIntersection) {
					var types = t.types;
					var baseTypes = [];
					var different = false;
					for (var _i = 0, types_7 = types; _i < types_7.length; _i++) {
						var type_3 = types_7[_i];
						var baseType = getBaseConstraint(type_3);
						if (baseType) {
							if (baseType !== type_3) {
								different = true;
							}
							baseTypes.push(baseType);
						} else {
							different = true;
						}
					}
					if (!different) {
						return t;
					}
					return t.flags & TypeFlags.Union && baseTypes.length === types.length ? getUnionType(
						baseTypes,
					) : t.flags & TypeFlags.Intersection && baseTypes.length ? getIntersectionType(
						baseTypes,
					) : undefined;
				}
				if (t.flags & TypeFlags.Index) {
					return keyofConstraintType;
				}
				if (t.flags & TypeFlags.TemplateLiteral) {
					var types = t.types;
					var constraints = mapDefined(types, getBaseConstraint);
					return constraints.length === types.length ? getTemplateLiteralType(
						t.texts,
						constraints,
					) : stringType;
				}
				if (t.flags & TypeFlags.StringMapping) {
					var constraint = getBaseConstraint(t.type);
					return constraint ? getStringMappingType(t.symbol, constraint) : stringType;
				}
				if (t.flags & TypeFlags.IndexedAccess) {
					if (isMappedTypeGenericIndexedAccess(t)) {
						// For indexed access types of the form { [P in K]: E }[X], where K is non-generic and X is generic,
						// we substitute an instantiation of E where P is replaced with X.
						return getBaseConstraint(
							substituteIndexedMappedType(t.objectType, t.indexType),
						);
					}
					var baseObjectType = getBaseConstraint(t.objectType);
					var baseIndexType = getBaseConstraint(t.indexType);
					var baseIndexedAccess = baseObjectType && baseIndexType && getIndexedAccessTypeOrUndefined(
						baseObjectType,
						baseIndexType,
						t.accessFlags,
					);
					return baseIndexedAccess && getBaseConstraint(baseIndexedAccess);
				}
				if (t.flags & TypeFlags.Conditional) {
					var constraint = getConstraintFromConditionalType(t);
					return constraint && getBaseConstraint(constraint);
				}
				if (t.flags & TypeFlags.Substitution) {
					return getBaseConstraint(t.substitute);
				}
				return t;
			}
		}
		function getApparentTypeOfIntersectionType(type) {
			return type.resolvedApparentType || (type.resolvedApparentType = getTypeWithThisArgument(
				type,
				type, /*apparentType*/
				true,
			));
		}
		function getResolvedTypeParameterDefault(typeParameter) {
			if (!typeParameter["default"]) {
				if (typeParameter.target) {
					var targetDefault = getResolvedTypeParameterDefault(
						typeParameter.target,
					);
					typeParameter["default"] = targetDefault ? instantiateType(
						targetDefault,
						typeParameter.mapper,
					) : noConstraintType;
				} else {
					// To block recursion, set the initial value to the resolvingDefaultType.
					typeParameter["default"] = resolvingDefaultType;
					var defaultDeclaration = typeParameter.symbol && forEach(
						typeParameter.symbol.declarations,
						function (decl) {
							return isTypeParameterDeclaration(decl) && decl["default"];
						},
					);
					var defaultType = defaultDeclaration ? getTypeFromTypeNode(
						defaultDeclaration,
					) : noConstraintType;
					if (typeParameter["default"] === resolvingDefaultType) {
						// If we have not been called recursively, set the correct default type.
						typeParameter["default"] = defaultType;
					}
				}
			} else if (typeParameter["default"] === resolvingDefaultType) {
				// If we are called recursively for this type parameter, mark the default as circular.
				typeParameter["default"] = circularConstraintType;
			}
			return typeParameter["default"];
		}
		/**
         * Gets the default type for a type parameter.
         *
         * If the type parameter is the result of an instantiation, this gets the instantiated
         * default type of its target. If the type parameter has no default type or the default is
         * circular, `undefined` is returned.
         */
		function getDefaultFromTypeParameter(typeParameter) {
			var defaultType = getResolvedTypeParameterDefault(typeParameter);
			return defaultType !== noConstraintType && defaultType !== circularConstraintType ? defaultType : undefined;
		}
		function hasNonCircularTypeParameterDefault(typeParameter) {
			return getResolvedTypeParameterDefault(typeParameter) !== circularConstraintType;
		}
		/**
         * Indicates whether the declaration of a typeParameter has a default type.
         */
		function hasTypeParameterDefault(typeParameter) {
			return !!(typeParameter.symbol && forEach(
				typeParameter.symbol.declarations,
				function (decl) {
					return isTypeParameterDeclaration(decl) && decl["default"];
				},
			));
		}
		function getApparentTypeOfMappedType(type) {
			return type.resolvedApparentType || (type.resolvedApparentType = getResolvedApparentTypeOfMappedType(
				type,
			));
		}
		function getResolvedApparentTypeOfMappedType(type) {
			var typeVariable = getHomomorphicTypeVariable(type);
			if (typeVariable && !type.declaration.nameType) {
				var constraint = getConstraintOfTypeParameter(typeVariable);
				if (constraint && (isArrayType(constraint) || isTupleType(constraint))) {
					return instantiateType(
						type,
						prependTypeMapping(typeVariable, constraint, type.mapper),
					);
				}
			}
			return type;
		}
		function isMappedTypeGenericIndexedAccess(type) {
			return type.flags & TypeFlags.IndexedAccess && getObjectFlags(
				type.objectType,
			) & ObjectFlags.Mapped && !isGenericMappedType(type.objectType) && isGenericIndexType(
				type.indexType,
			);
		}
		/**
         * For a type parameter, return the base constraint of the type parameter. For the string, number,
         * boolean, and symbol primitive types, return the corresponding object types. Otherwise return the
         * type itself.
         */
		function getApparentType(type) {
			var t = !(type.flags & TypeFlags.Instantiable) ? type : getBaseConstraintOfType(
				type,
			) || unknownType;
			return getObjectFlags(t) & ObjectFlags.Mapped ? getApparentTypeOfMappedType(
				t,
			) : t.flags & TypeFlags.Intersection ? getApparentTypeOfIntersectionType(
				t,
			) : t.flags & TypeFlags.StringLike ? globalStringType : t.flags & TypeFlags.NumberLike ? globalNumberType : t.flags & TypeFlags.BigIntLike ? getGlobalBigIntType(
				languageVersion >= ScriptTarget.ES2020, /*reportErrors*/
			) : t.flags & TypeFlags.BooleanLike ? globalBooleanType : t.flags & TypeFlags.ESSymbolLike ? getGlobalESSymbolType(
				languageVersion >= ScriptTarget.ES2015, /*reportErrors*/
			) : t.flags & TypeFlags.NonPrimitive ? emptyObjectType : t.flags & TypeFlags.Index ? keyofConstraintType : t.flags & TypeFlags.Unknown && !strictNullChecks ? emptyObjectType : t;
		}
		function getReducedApparentType(type) {
			// Since getApparentType may return a non-reduced union or intersection type, we need to perform
			// type reduction both before and after obtaining the apparent type. For example, given a type parameter
			// 'T extends A | B', the type 'T & X' becomes 'A & X | B & X' after obtaining the apparent type, and
			// that type may need further reduction to remove empty intersections.
			return getReducedType(getApparentType(getReducedType(type)));
		}
		function createUnionOrIntersectionProperty(
			containingType,
			name,
			skipObjectFunctionPropertyAugment,
		) {
			var _a, _b;
			var singleProp;
			var propSet;
			var indexTypes;
			var isUnion = containingType.flags & TypeFlags.Union;
			// Flags we want to propagate to the result if they exist in all source symbols
			var optionalFlag = isUnion ? SymbolFlags.None : SymbolFlags.Optional;
			var syntheticFlag = CheckFlags.SyntheticMethod;
			var checkFlags = isUnion ? 0 : CheckFlags.Readonly;
			var mergedInstantiations = false;
			for (var _i = 0, _c = containingType.types; _i < _c.length; _i++) {
				var current = _c[_i];
				var type = getApparentType(current);
				if (!(isErrorType(type) || type.flags & TypeFlags.Never)) {
					var prop = getPropertyOfType(
						type,
						name,
						skipObjectFunctionPropertyAugment,
					);
					var modifiers = prop ? getDeclarationModifierFlagsFromSymbol(prop) : 0;
					if (prop) {
						if (isUnion) {
							optionalFlag |= (prop.flags & SymbolFlags.Optional);
						} else {
							optionalFlag &= prop.flags;
						}
						if (!singleProp) {
							singleProp = prop;
						} else if (prop !== singleProp) {
							var isInstantiation = (getTargetSymbol(prop) || prop) === (getTargetSymbol(
								singleProp,
							) || singleProp);
							// If the symbols are instances of one another with identical types - consider the symbols
							// equivalent and just use the first one, which thus allows us to avoid eliding private
							// members when intersecting a (this-)instantiations of a class with it's raw base or another instance
							if (
								isInstantiation && compareProperties(
									singleProp,
									prop,
									function (a, b) {
										return a === b ? Ternary.True : Ternary.False;
									},
								) === Ternary.True
							) {
								// If we merged instantiations of a generic type, we replicate the symbol parent resetting behavior we used
								// to do when we recorded multiple distinct symbols so that we still get, eg, `Array<T>.length` printed
								// back and not `Array<string>.length` when we're looking at a `.length` access on a `string[] | number[]`
								mergedInstantiations = !!singleProp.parent && !!length(
									getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(
										singleProp.parent,
									),
								);
							} else {
								if (!propSet) {
									propSet = new Map();
									propSet.set(getSymbolId(singleProp), singleProp);
								}
								var id = getSymbolId(prop);
								if (!propSet.has(id)) {
									propSet.set(id, prop);
								}
							}
						}
						if (isUnion && isReadonlySymbol(prop)) {
							checkFlags |= CheckFlags.Readonly;
						} else if (!isUnion && !isReadonlySymbol(prop)) {
							checkFlags &= ~CheckFlags.Readonly;
						}
						checkFlags |= (!(modifiers & ModifierFlags.NonPublicAccessibilityModifier) ? CheckFlags.ContainsPublic : 0) | (modifiers & ModifierFlags.Protected ? CheckFlags.ContainsProtected : 0) | (modifiers & ModifierFlags.Private ? CheckFlags.ContainsPrivate : 0) | (modifiers & ModifierFlags.Static ? CheckFlags.ContainsStatic : 0);
						if (!isPrototypeProperty(prop)) {
							syntheticFlag = CheckFlags.SyntheticProperty;
						}
					} else if (isUnion) {
						var indexInfo = !isLateBoundName(name) && getApplicableIndexInfoForName(
							type,
							name,
						);
						if (indexInfo) {
							checkFlags |= CheckFlags.WritePartial | (indexInfo.isReadonly ? CheckFlags.Readonly : 0);
							indexTypes = append(
								indexTypes,
								isTupleType(type) ? getRestTypeOfTupleType(type) || undefinedType : indexInfo.type,
							);
						} else if (
							isObjectLiteralType(type) && !(getObjectFlags(type) & ObjectFlags.ContainsSpread)
						) {
							checkFlags |= CheckFlags.WritePartial;
							indexTypes = append(indexTypes, undefinedType);
						} else {
							checkFlags |= CheckFlags.ReadPartial;
						}
					}
				}
			}
			if (
				!singleProp || isUnion && (propSet || checkFlags & CheckFlags.Partial) && checkFlags & (CheckFlags.ContainsPrivate | CheckFlags.ContainsProtected)
			) {
				// No property was found, or, in a union, a property has a private or protected declaration in one
				// constituent, but is missing or has a different declaration in another constituent.
				return undefined;
			}
			if (!propSet && !(checkFlags & CheckFlags.ReadPartial) && !indexTypes) {
				if (mergedInstantiations) {
					// No symbol from a union/intersection should have a `.parent` set (since unions/intersections don't act as symbol parents)
					// Unless that parent is "reconstituted" from the "first value declaration" on the symbol (which is likely different than its instantiated parent!)
					// They also have a `.containingType` set, which affects some services endpoints behavior, like `getRootSymbol`
					var clone = createSymbolWithType(singleProp, singleProp.type);
					clone.parent = (_b = (_a = singleProp.valueDeclaration) === null || _a === void 0 ? void 0 : _a.symbol) === null || _b === void 0 ? void 0 : _b.parent;
					clone.containingType = containingType;
					clone.mapper = singleProp.mapper;
					return clone;
				} else {
					return singleProp;
				}
			}
			var props = propSet ? arrayFrom(propSet.values()) : [singleProp];
			var declarations;
			var firstType;
			var nameType;
			var propTypes = [];
			var firstValueDeclaration;
			var hasNonUniformValueDeclaration = false;
			for (var _d = 0, props_1 = props; _d < props_1.length; _d++) {
				var prop = props_1[_d];
				if (!firstValueDeclaration) {
					firstValueDeclaration = prop.valueDeclaration;
				} else if (
					prop.valueDeclaration && prop.valueDeclaration !== firstValueDeclaration
				) {
					hasNonUniformValueDeclaration = true;
				}
				declarations = addRange(declarations, prop.declarations);
				var type = getTypeOfSymbol(prop);
				if (!firstType) {
					firstType = type;
					nameType = getSymbolLinks(prop).nameType;
				} else if (type !== firstType) {
					checkFlags |= CheckFlags.HasNonUniformType;
				}
				if (isLiteralType(type) || isPatternLiteralType(type)) {
					checkFlags |= CheckFlags.HasLiteralType;
				}
				if (type.flags & TypeFlags.Never) {
					checkFlags |= CheckFlags.HasNeverType;
				}
				propTypes.push(type);
			}
			addRange(propTypes, indexTypes);
			var result = createSymbol(
				SymbolFlags.Property | optionalFlag,
				name,
				syntheticFlag | checkFlags,
			);
			result.containingType = containingType;
			if (!hasNonUniformValueDeclaration && firstValueDeclaration) {
				result.valueDeclaration = firstValueDeclaration;
				// Inherit information about parent type.
				if (firstValueDeclaration.symbol.parent) {
					result.parent = firstValueDeclaration.symbol.parent;
				}
			}
			result.declarations = declarations;
			result.nameType = nameType;
			if (propTypes.length > 2) {
				// When `propTypes` has the potential to explode in size when normalized, defer normalization until absolutely needed
				result.checkFlags |= CheckFlags.DeferredType;
				result.deferralParent = containingType;
				result.deferralConstituents = propTypes;
			} else {
				result.type = isUnion ? getUnionType(propTypes) : getIntersectionType(
					propTypes,
				);
			}
			return result;
		}
		// Return the symbol for a given property in a union or intersection type, or undefined if the property
		// does not exist in any constituent type. Note that the returned property may only be present in some
		// constituents, in which case the isPartial flag is set when the containing type is union type. We need
		// these partial properties when identifying discriminant properties, but otherwise they are filtered out
		// and do not appear to be present in the union type.
		function getUnionOrIntersectionProperty(
			type,
			name,
			skipObjectFunctionPropertyAugment,
		) {
			var _a, _b;
			var property = ((_a = type.propertyCacheWithoutObjectFunctionPropertyAugment) === null || _a === void 0 ? void 0 : _a.get(
				name,
			)) || !skipObjectFunctionPropertyAugment ? (_b = type.propertyCache) === null || _b === void 0 ? void 0 : _b.get(
				name,
			) : undefined;
			if (!property) {
				property = createUnionOrIntersectionProperty(
					type,
					name,
					skipObjectFunctionPropertyAugment,
				);
				if (property) {
					var properties = skipObjectFunctionPropertyAugment ? type.propertyCacheWithoutObjectFunctionPropertyAugment || (type.propertyCacheWithoutObjectFunctionPropertyAugment = createSymbolTable()) : type.propertyCache || (type.propertyCache = createSymbolTable());
					properties.set(name, property);
				}
			}
			return property;
		}
		function getPropertyOfUnionOrIntersectionType(
			type,
			name,
			skipObjectFunctionPropertyAugment,
		) {
			var property = getUnionOrIntersectionProperty(
				type,
				name,
				skipObjectFunctionPropertyAugment,
			);
			// We need to filter out partial properties in union types
			return property && !(getCheckFlags(property) & CheckFlags.ReadPartial) ? property : undefined;
		}
		/**
         * Return the reduced form of the given type. For a union type, it is a union of the normalized constituent types.
         * For an intersection of types containing one or more mututally exclusive discriminant properties, it is 'never'.
         * For all other types, it is simply the type itself. Discriminant properties are considered mutually exclusive when
         * no constituent property has type 'never', but the intersection of the constituent property types is 'never'.
         */
		function getReducedType(type) {
			if (
				type.flags & TypeFlags.Union && type.objectFlags & ObjectFlags.ContainsIntersections
			) {
				return type.resolvedReducedType || (type.resolvedReducedType = getReducedUnionType(
					type,
				));
			} else if (type.flags & TypeFlags.Intersection) {
				if (!(type.objectFlags & ObjectFlags.IsNeverIntersectionComputed)) {
					type.objectFlags |= ObjectFlags.IsNeverIntersectionComputed | (some(
						getPropertiesOfUnionOrIntersectionType(type),
						isNeverReducedProperty,
					) ? ObjectFlags.IsNeverIntersection : 0);
				}
				return type.objectFlags & ObjectFlags.IsNeverIntersection ? neverType : type;
			}
			return type;
		}
		function getReducedUnionType(unionType) {
			var reducedTypes = sameMap(unionType.types, getReducedType);
			if (reducedTypes === unionType.types) {
				return unionType;
			}
			var reduced = getUnionType(reducedTypes);
			if (reduced.flags & TypeFlags.Union) {
				reduced.resolvedReducedType = reduced;
			}
			return reduced;
		}
		function isNeverReducedProperty(prop) {
			return isDiscriminantWithNeverType(prop) || isConflictingPrivateProperty(
				prop,
			);
		}
		function isDiscriminantWithNeverType(prop) {
			// Return true for a synthetic non-optional property with non-uniform types, where at least one is
			// a literal type and none is never, that reduces to never.
			return !(prop.flags & SymbolFlags.Optional) && (getCheckFlags(prop) & (CheckFlags.Discriminant | CheckFlags.HasNeverType)) === CheckFlags.Discriminant && !!(getTypeOfSymbol(
				prop,
			).flags & TypeFlags.Never);
		}
		function isConflictingPrivateProperty(prop) {
			// Return true for a synthetic property with multiple declarations, at least one of which is private.
			return !prop.valueDeclaration && !!(getCheckFlags(prop) & CheckFlags.ContainsPrivate);
		}
		function elaborateNeverIntersection(errorInfo, type) {
			if (
				type.flags & TypeFlags.Intersection && getObjectFlags(type) & ObjectFlags.IsNeverIntersection
			) {
				var neverProp = find(
					getPropertiesOfUnionOrIntersectionType(type),
					isDiscriminantWithNeverType,
				);
				if (neverProp) {
					return chainDiagnosticMessages(
						errorInfo,
						Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituents,
						typeToString(
							type, /*enclosingDeclaration*/
							undefined,
							TypeFormatFlags.NoTypeReduction,
						),
						symbolToString(neverProp),
					);
				}
				var privateProp = find(
					getPropertiesOfUnionOrIntersectionType(type),
					isConflictingPrivateProperty,
				);
				if (privateProp) {
					return chainDiagnosticMessages(
						errorInfo,
						Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_private_in_some,
						typeToString(
							type, /*enclosingDeclaration*/
							undefined,
							TypeFormatFlags.NoTypeReduction,
						),
						symbolToString(privateProp),
					);
				}
			}
			return errorInfo;
		}
		/**
         * Return the symbol for the property with the given name in the given type. Creates synthetic union properties when
         * necessary, maps primitive types and type parameters are to their apparent types, and augments with properties from
         * Object and Function as appropriate.
         *
         * @param type a type to look up property from
         * @param name a name of property to look up in a given type
         */
		function getPropertyOfType(type, name, skipObjectFunctionPropertyAugment) {
			type = getReducedApparentType(type);
			if (type.flags & TypeFlags.Object) {
				var resolved = resolveStructuredTypeMembers(type);
				var symbol = resolved.members.get(name);
				if (symbol && symbolIsValue(symbol)) {
					return symbol;
				}
				if (skipObjectFunctionPropertyAugment) return undefined;
				var functionType = resolved === anyFunctionType ? globalFunctionType : resolved.callSignatures.length ? globalCallableFunctionType : resolved.constructSignatures.length ? globalNewableFunctionType : undefined;
				if (functionType) {
					var symbol_1 = getPropertyOfObjectType(functionType, name);
					if (symbol_1) {
						return symbol_1;
					}
				}
				return getPropertyOfObjectType(globalObjectType, name);
			}
			if (type.flags & TypeFlags.UnionOrIntersection) {
				return getPropertyOfUnionOrIntersectionType(
					type,
					name,
					skipObjectFunctionPropertyAugment,
				);
			}
			return undefined;
		}
		function getSignaturesOfStructuredType(type, kind) {
			if (type.flags & TypeFlags.StructuredType) {
				var resolved = resolveStructuredTypeMembers(type);
				return kind === SignatureKind.Call ? resolved.callSignatures : resolved.constructSignatures;
			}
			return emptyArray;
		}
		/**
         * Return the signatures of the given kind in the given type. Creates synthetic union signatures when necessary and
         * maps primitive types and type parameters are to their apparent types.
         */
		function getSignaturesOfType(type, kind) {
			return getSignaturesOfStructuredType(getReducedApparentType(type), kind);
		}
		function findIndexInfo(indexInfos, keyType) {
			return find(
				indexInfos,
				function (info) {
					return info.keyType === keyType;
				},
			);
		}
		function findApplicableIndexInfo(indexInfos, keyType) {
			// Index signatures for type 'string' are considered only when no other index signatures apply.
			var stringIndexInfo;
			var applicableInfo;
			var applicableInfos;
			for (var _i = 0, indexInfos_1 = indexInfos; _i < indexInfos_1.length; _i++) {
				var info = indexInfos_1[_i];
				if (info.keyType === stringType) {
					stringIndexInfo = info;
				} else if (isApplicableIndexType(keyType, info.keyType)) {
					if (!applicableInfo) {
						applicableInfo = info;
					} else {
						(applicableInfos || (applicableInfos = [applicableInfo])).push(info);
					}
				}
			}
			// When more than one index signature is applicable we create a synthetic IndexInfo. Instead of computing
			// the intersected key type, we just use unknownType for the key type as nothing actually depends on the
			// keyType property of the returned IndexInfo.
			return applicableInfos ? createIndexInfo(
				unknownType,
				getIntersectionType(
					map(
						applicableInfos,
						function (info) {
							return info.type;
						},
					),
				),
				reduceLeft(
					applicableInfos,
					function (isReadonly, info) {
						return isReadonly && info.isReadonly;
					}, /*initial*/
					true,
				),
			) : applicableInfo ? applicableInfo : stringIndexInfo && isApplicableIndexType(
				keyType,
				stringType,
			) ? stringIndexInfo : undefined;
		}
		function isApplicableIndexType(source, target) {
			// A 'string' index signature applies to types assignable to 'string' or 'number', and a 'number' index
			// signature applies to types assignable to 'number' and numeric string literal types.
			return isTypeAssignableTo(source, target) || target === stringType && isTypeAssignableTo(
				source,
				numberType,
			) || target === numberType && !!(source.flags & TypeFlags.StringLiteral) && isNumericLiteralName(
				source.value,
			);
		}
		function getIndexInfosOfStructuredType(type) {
			if (type.flags & TypeFlags.StructuredType) {
				var resolved = resolveStructuredTypeMembers(type);
				return resolved.indexInfos;
			}
			return emptyArray;
		}
		function getIndexInfosOfType(type) {
			return getIndexInfosOfStructuredType(getReducedApparentType(type));
		}
		// Return the indexing info of the given kind in the given type. Creates synthetic union index types when necessary and
		// maps primitive types and type parameters are to their apparent types.
		function getIndexInfoOfType(type, keyType) {
			return findIndexInfo(getIndexInfosOfType(type), keyType);
		}
		// Return the index type of the given kind in the given type. Creates synthetic union index types when necessary and
		// maps primitive types and type parameters are to their apparent types.
		function getIndexTypeOfType(type, keyType) {
			var _a;
			return (_a = getIndexInfoOfType(type, keyType)) === null || _a === void 0 ? void 0 : _a.type;
		}
		function getApplicableIndexInfos(type, keyType) {
			return getIndexInfosOfType(type).filter(
				function (info) {
					return isApplicableIndexType(keyType, info.keyType);
				},
			);
		}
		function getApplicableIndexInfo(type, keyType) {
			return findApplicableIndexInfo(getIndexInfosOfType(type), keyType);
		}
		function getApplicableIndexInfoForName(type, name) {
			return getApplicableIndexInfo(
				type,
				isLateBoundName(name) ? esSymbolType : getStringLiteralType(
					unescapeLeadingUnderscores(name),
				),
			);
		}
		// Return list of type parameters with duplicates removed (duplicate identifier errors are generated in the actual
		// type checking functions).
		function getTypeParametersFromDeclaration(declaration) {
			var result;
			for (
				var _i = 0, _a = getEffectiveTypeParameterDeclarations(declaration);
				_i < _a.length;
				_i++
			) {
				var node = _a[_i];
				result = appendIfUnique(
					result,
					getDeclaredTypeOfTypeParameter(node.symbol),
				);
			}
			return result;
		}
		function symbolsToArray(symbols) {
			var result = [];
			symbols.forEach(
				function (symbol, id) {
					if (!isReservedMemberName(id)) {
						result.push(symbol);
					}
				},
			);
			return result;
		}
		function isJSDocOptionalParameter(node) {
			return isInJSFile(node) && (node.type && node.type.kind === SyntaxKind.JSDocOptionalType || getJSDocParameterTags(
				node, // node.type should only be a JSDocOptionalType when node is a parameter of a JSDocFunctionType
			).some(
				function (_a) {
					var isBracketed = _a.isBracketed, typeExpression = _a.typeExpression;
					return isBracketed || !!typeExpression && typeExpression.type.kind === SyntaxKind.JSDocOptionalType;
				},
			));
		}
		function tryFindAmbientModule(moduleName, withAugmentations) {
			if (isExternalModuleNameRelative(moduleName)) {
				return undefined;
			}
			var symbol = getSymbol(
				globals,
				""
			" + moduleName + ";
			"",
				SymbolFlags.ValueModule,
			
			
			)
			// merged symbol is module declaration symbol combined with all augmentations
			return symbol && withAugmentations ? getMergedSymbol(symbol) : symbol;
		}
		function isOptionalParameter(node) {
			if (
				hasQuestionToken(node) || isOptionalJSDocPropertyLikeTag(node) || isJSDocOptionalParameter(
					node,
				)
			) {
				return true;
			}
			if (node.initializer) {
				var signature = getSignatureFromDeclaration(node.parent);
				var parameterIndex = node.parent.parameters.indexOf(node);
				Debug.assert(parameterIndex >= 0);
				// Only consider syntactic or instantiated parameters as optional, not `void` parameters as this function is used
				// in grammar checks and checking for `void` too early results in parameter types widening too early
				// and causes some noImplicitAny errors to be lost.
				return parameterIndex >= getMinArgumentCount(
					signature,
					1 | 2, /* StrongArityForUntypedJS */ /* VoidIsNonOptional */
				);
			}
			var iife = getImmediatelyInvokedFunctionExpression(node.parent);
			if (iife) {
				return !node.type && !node.dotDotDotToken && node.parent.parameters.indexOf(
					node,
				) >= iife.arguments.length;
			}
			return false;
		}
		function isOptionalPropertyDeclaration(node) {
			return isPropertyDeclaration(node) && node.questionToken;
		}
		function isOptionalJSDocPropertyLikeTag(node) {
			if (!isJSDocPropertyLikeTag(node)) {
				return false;
			}
			var isBracketed = node.isBracketed, typeExpression = node.typeExpression;
			return isBracketed || !!typeExpression && typeExpression.type.kind === SyntaxKind.JSDocOptionalType;
		}
		function createTypePredicate(kind, parameterName, parameterIndex, type) {
			return {
				kind: kind,
				parameterName: parameterName,
				parameterIndex: parameterIndex,
				type: type,
			};
		}
		/**
         * Gets the minimum number of type arguments needed to satisfy all non-optional type
         * parameters.
         */
		function getMinTypeArgumentCount(typeParameters) {
			var minTypeArgumentCount = 0;
			if (typeParameters) {
				for (var i = 0; i < typeParameters.length; i++) {
					if (!hasTypeParameterDefault(typeParameters[i])) {
						minTypeArgumentCount = i + 1;
					}
				}
			}
			return minTypeArgumentCount;
		}
		function fillMissingTypeArguments(
			typeArguments,
			typeParameters,
			minTypeArgumentCount,
			isJavaScriptImplicitAny,
		) {
			var numTypeParameters = length(typeParameters);
			if (!numTypeParameters) {
				return [];
			}
			var numTypeArguments = length(typeArguments);
			if (
				isJavaScriptImplicitAny || (numTypeArguments >= minTypeArgumentCount && numTypeArguments <= numTypeParameters)
			) {
				var result = typeArguments ? typeArguments.slice() : [];
				// Map invalid forward references in default types to the error type
				for (var i = numTypeArguments; i < numTypeParameters; i++) {
					result[i] = errorType;
				}
				var baseDefaultType = getDefaultTypeArgumentType(
					isJavaScriptImplicitAny,
				);
				for (var i = numTypeArguments; i < numTypeParameters; i++) {
					var defaultType = getDefaultFromTypeParameter(typeParameters[i]);
					if (
						isJavaScriptImplicitAny && defaultType && (isTypeIdenticalTo(
							defaultType,
							unknownType,
						) || isTypeIdenticalTo(defaultType, emptyObjectType))
					) {
						defaultType = anyType;
					}
					result[i] = defaultType ? instantiateType(
						defaultType,
						createTypeMapper(typeParameters, result),
					) : baseDefaultType;
				}
				result.length = typeParameters.length;
				return result;
			}
			return typeArguments && typeArguments.slice();
		}
		function getSignatureFromDeclaration(declaration) {
			var links = getNodeLinks(declaration);
			if (!links.resolvedSignature) {
				var parameters = [];
				var flags = SignatureFlags.None;
				var minArgumentCount = 0;
				var thisParameter = void 0;
				var hasThisParameter = false;
				var iife = getImmediatelyInvokedFunctionExpression(declaration);
				var isJSConstructSignature = isJSDocConstructSignature(declaration);
				var isUntypedSignatureInJSFile = !iife && isInJSFile(declaration) && isValueSignatureDeclaration(
					declaration,
				) && !hasJSDocParameterTags(declaration) && !getJSDocType(declaration);
				if (isUntypedSignatureInJSFile) {
					flags |= SignatureFlags.IsUntypedSignatureInJSFile;
				}
				// If this is a JSDoc construct signature, then skip the first parameter in the
				// parameter list.  The first parameter represents the return type of the construct
				// signature.
				for (
					var i = isJSConstructSignature ? 1 : 0;
					i < declaration.parameters.length;
					i++
				) {
					var param = declaration.parameters[i];
					var paramSymbol = param.symbol;
					var type = isJSDocParameterTag(param) ? (param.typeExpression && param.typeExpression.type) : param.type;
					// Include parameter symbol instead of property symbol in the signature
					if (
						paramSymbol && !!(paramSymbol.flags & SymbolFlags.Property) && !isBindingPattern(
							param.name,
						)
					) {
						var resolvedSymbol = resolveName(
							param,
							paramSymbol.escapedName,
							SymbolFlags.Value,
							undefined,
							undefined, /*isUse*/
							false,
						);
						paramSymbol = resolvedSymbol;
					}
					if (i === 0 && paramSymbol.escapedName === InternalSymbolName.This) {
						hasThisParameter = true;
						thisParameter = param.symbol;
					} else {
						parameters.push(paramSymbol);
					}
					if (type && type.kind === SyntaxKind.LiteralType) {
						flags |= SignatureFlags.HasLiteralTypes;
					}
					// Record a new minimum argument count if this is not an optional parameter
					var isOptionalParameter_1 = isOptionalJSDocPropertyLikeTag(param) || param.initializer || param.questionToken || isRestParameter(
						param,
					) || iife && parameters.length > iife.arguments.length && !type || isJSDocOptionalParameter(
						param,
					);
					if (!isOptionalParameter_1) {
						minArgumentCount = parameters.length;
					}
				}
				// If only one accessor includes a this-type annotation, the other behaves as if it had the same type annotation
				if (
					(declaration.kind === SyntaxKind.GetAccessor || declaration.kind === SyntaxKind.SetAccessor) && hasBindableName(
						declaration,
					) && (!hasThisParameter || !thisParameter)
				) {
					var otherKind = declaration.kind === SyntaxKind.GetAccessor ? SyntaxKind.SetAccessor : SyntaxKind.GetAccessor;
					var other = getDeclarationOfKind(
						getSymbolOfNode(declaration),
						otherKind,
					);
					if (other) {
						thisParameter = getAnnotatedAccessorThisParameter(other);
					}
				}
				var classType = declaration.kind === SyntaxKind.Constructor ? getDeclaredTypeOfClassOrInterface(
					getMergedSymbol(declaration.parent.symbol),
				) : undefined;
				var typeParameters = classType ? classType.localTypeParameters : getTypeParametersFromDeclaration(
					declaration,
				);
				if (
					hasRestParameter(declaration) || isInJSFile(declaration) && maybeAddJsSyntheticRestParameter(
						declaration,
						parameters,
					)
				) {
					flags |= SignatureFlags.HasRestParameter;
				}
				if (
					isConstructorTypeNode(declaration) && hasSyntacticModifier(
						declaration,
						ModifierFlags.Abstract,
					) || isConstructorDeclaration(declaration) && hasSyntacticModifier(
						declaration.parent,
						ModifierFlags.Abstract,
					)
				) {
					flags |= SignatureFlags.Abstract;
				}
				links.resolvedSignature = createSignature(
					declaration,
					typeParameters,
					thisParameter,
					parameters,
					/*resolvedReturnType*/ undefined, /*resolvedTypePredicate*/
					undefined,
					minArgumentCount,
					flags,
				);
			}
			return links.resolvedSignature;
		}
		/**
         * A JS function gets a synthetic rest parameter if it references `arguments` AND:
         * 1. It has no parameters but at least one `@param` with a type that starts with `...`
         * OR
         * 2. It has at least one parameter, and the last parameter has a matching `@param` with a type that starts with `...`
         */
		function maybeAddJsSyntheticRestParameter(declaration, parameters) {
			if (
				isJSDocSignature(declaration) || !containsArgumentsReference(
					declaration,
				)
			) {
				return false;
			}
			var lastParam = lastOrUndefined(declaration.parameters);
			var lastParamTags = lastParam ? getJSDocParameterTags(lastParam) : getJSDocTags(
				declaration,
			).filter(isJSDocParameterTag);
			var lastParamVariadicType = firstDefined(
				lastParamTags,
				function (p) {
					return p.typeExpression && isJSDocVariadicType(p.typeExpression.type) ? p.typeExpression.type : undefined;
				},
			);
			var syntheticArgsSymbol = createSymbol(
				SymbolFlags.Variable,
				"args",
				CheckFlags.RestParameter,
			);
			syntheticArgsSymbol.type = lastParamVariadicType ? createArrayType(
				getTypeFromTypeNode(lastParamVariadicType.type),
			) : anyArrayType;
			if (lastParamVariadicType) {
				// Replace the last parameter with a rest parameter.
				parameters.pop();
			}
			parameters.push(syntheticArgsSymbol);
			return true;
		}
		function getSignatureOfTypeTag(node) {
			// should be attached to a function declaration or expression
			if (!(isInJSFile(node) && isFunctionLikeDeclaration(node))) return undefined;
			var typeTag = getJSDocTypeTag(node);
			return (typeTag === null || typeTag === void 0 ? void 0 : typeTag.typeExpression) && getSingleCallSignature(
				getTypeFromTypeNode(typeTag.typeExpression),
			);
		}
		function getReturnTypeOfTypeTag(node) {
			var signature = getSignatureOfTypeTag(node);
			return signature && getReturnTypeOfSignature(signature);
		}
		function containsArgumentsReference(declaration) {
			var links = getNodeLinks(declaration);
			if (links.containsArgumentsReference === undefined) {
				if (links.flags & NodeCheckFlags.CaptureArguments) {
					links.containsArgumentsReference = true;
				} else {
					links.containsArgumentsReference = traverse(declaration.body);
				}
			}
			return links.containsArgumentsReference;
			function traverse(node) {
				if (!node) return false;
				switch (node.kind) {
					case SyntaxKind.Identifier:
						return node.escapedText === argumentsSymbol.escapedName && getReferencedValueSymbol(
							node,
						) === argumentsSymbol;
					case SyntaxKind.PropertyDeclaration:
					case SyntaxKind.MethodDeclaration:
					case SyntaxKind.GetAccessor:
					case SyntaxKind.SetAccessor:
						return node.name.kind === SyntaxKind.ComputedPropertyName && traverse(
							node.name,
						);
					case SyntaxKind.PropertyAccessExpression:
					case SyntaxKind.ElementAccessExpression:
						return traverse(node.expression);
					case SyntaxKind.PropertyAssignment:
						return traverse(node.initializer);
					default:
						return !nodeStartsNewLexicalEnvironment(node) && !isPartOfTypeNode(
							node,
						) && !!forEachChild(node, traverse);
				}
			}
		}
		function getSignaturesOfSymbol(symbol) {
			if (!symbol || !symbol.declarations) return emptyArray;
			var result = [];
			for (var i = 0; i < symbol.declarations.length; i++) {
				var decl = symbol.declarations[i];
				if (!isFunctionLike(decl)) continue;
				// Don't include signature if node is the implementation of an overloaded function. A node is considered
				// an implementation node if it has a body and the previous node is of the same kind and immediately
				// precedes the implementation node (i.e. has the same parent and ends where the implementation starts).
				if (i > 0 && decl.body) {
					var previous = symbol.declarations[i - 1];
					if (
						decl.parent === previous.parent && decl.kind === previous.kind && decl.pos === previous.end
					) {
						continue;
					}
				}
				result.push(getSignatureFromDeclaration(decl));
			}
			return result;
		}
		function resolveExternalModuleTypeByLiteral(name) {
			var moduleSym = resolveExternalModuleName(name, name);
			if (moduleSym) {
				var resolvedModuleSymbol = resolveExternalModuleSymbol(moduleSym);
				if (resolvedModuleSymbol) {
					return getTypeOfSymbol(resolvedModuleSymbol);
				}
			}
			return anyType;
		}
		function getThisTypeOfSignature(signature) {
			if (signature.thisParameter) {
				return getTypeOfSymbol(signature.thisParameter);
			}
		}
		function getTypePredicateOfSignature(signature) {
			if (!signature.resolvedTypePredicate) {
				if (signature.target) {
					var targetTypePredicate = getTypePredicateOfSignature(
						signature.target,
					);
					signature.resolvedTypePredicate = targetTypePredicate ? instantiateTypePredicate(
						targetTypePredicate,
						signature.mapper,
					) : noTypePredicate;
				} else if (signature.compositeSignatures) {
					signature.resolvedTypePredicate = getUnionOrIntersectionTypePredicate(
						signature.compositeSignatures,
						signature.compositeKind,
					) || noTypePredicate;
				} else {
					var type = signature.declaration && getEffectiveReturnTypeNode(
						signature.declaration,
					);
					var jsdocPredicate = void 0;
					if (!type && isInJSFile(signature.declaration)) {
						var jsdocSignature = getSignatureOfTypeTag(signature.declaration);
						if (jsdocSignature && signature !== jsdocSignature) {
							jsdocPredicate = getTypePredicateOfSignature(jsdocSignature);
						}
					}
					signature.resolvedTypePredicate = type && isTypePredicateNode(type) ? createTypePredicateFromTypePredicateNode(
						type,
						signature,
					) : jsdocPredicate || noTypePredicate;
				}
				Debug.assert(!!signature.resolvedTypePredicate);
			}
			return signature.resolvedTypePredicate === noTypePredicate ? undefined : signature.resolvedTypePredicate;
		}
		function createTypePredicateFromTypePredicateNode(node, signature) {
			var parameterName = node.parameterName;
			var type = node.type && getTypeFromTypeNode(node.type);
			return parameterName.kind === SyntaxKind.ThisType ? createTypePredicate(
				node.assertsModifier ? TypePredicateKind.AssertsThis : TypePredicateKind.This, /*parameterName*/
				undefined, /*parameterIndex*/
				undefined,
				type,
			) : createTypePredicate(
				node.assertsModifier ? TypePredicateKind.AssertsIdentifier : TypePredicateKind.Identifier,
				parameterName.escapedText,
				findIndex(
					signature.parameters,
					function (p) {
						return p.escapedName === parameterName.escapedText;
					},
				),
				type,
			);
		}
		function getUnionOrIntersectionType(types, kind, unionReduction) {
			return kind !== TypeFlags.Intersection ? getUnionType(
				types,
				unionReduction,
			) : getIntersectionType(types);
		}
		function getReturnTypeOfSignature(signature) {
			if (!signature.resolvedReturnType) {
				if (!pushTypeResolution(signature, 3 /* ResolvedReturnType */ )) {
					return errorType;
				}
				var type = signature.target ? instantiateType(
					getReturnTypeOfSignature(signature.target),
					signature.mapper,
				) : signature.compositeSignatures ? instantiateType(
					getUnionOrIntersectionType(
						map(signature.compositeSignatures, getReturnTypeOfSignature),
						signature.compositeKind,
						UnionReduction.Subtype,
					),
					signature.mapper,
				) : getReturnTypeFromAnnotation(signature.declaration) || (nodeIsMissing(
					signature.declaration.body,
				) ? anyType : getReturnTypeFromBody(signature.declaration));
				if (signature.flags & SignatureFlags.IsInnerCallChain) {
					type = addOptionalTypeMarker(type);
				} else if (signature.flags & SignatureFlags.IsOuterCallChain) {
					type = getOptionalType(type);
				}
				if (!popTypeResolution()) {
					if (signature.declaration) {
						var typeNode = getEffectiveReturnTypeNode(signature.declaration);
						if (typeNode) {
							error(
								typeNode,
								Diagnostics.Return_type_annotation_circularly_references_itself,
							);
						} else if (noImplicitAny) {
							var declaration = signature.declaration;
							var name_14 = getNameOfDeclaration(declaration);
							if (name_14) {
								error(
									name_14,
									Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions,
									declarationNameToString(name_14),
								);
							} else {
								error(
									declaration,
									Diagnostics.Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions,
								);
							}
						}
					}
					type = anyType;
				}
				signature.resolvedReturnType = type;
			}
			return signature.resolvedReturnType;
		}
		function getReturnTypeFromAnnotation(declaration) {
			if (declaration.kind === SyntaxKind.Constructor) {
				return getDeclaredTypeOfClassOrInterface(
					getMergedSymbol(declaration.parent.symbol),
				);
			}
			if (isJSDocConstructSignature(declaration)) {
				return getTypeFromTypeNode(declaration.parameters[0].type); // TODO: GH#18217
			}
			var typeNode = getEffectiveReturnTypeNode(declaration);
			if (typeNode) {
				return getTypeFromTypeNode(typeNode);
			}
			if (
				declaration.kind === SyntaxKind.GetAccessor && hasBindableName(
					declaration,
				)
			) {
				var jsDocType = isInJSFile(declaration) && getTypeForDeclarationFromJSDocComment(
					declaration,
				);
				if (jsDocType) {
					return jsDocType;
				}
				var setter = getDeclarationOfKind(
					getSymbolOfNode(declaration),
					SyntaxKind.SetAccessor,
				);
				var setterType = getAnnotatedAccessorType(setter);
				if (setterType) {
					return setterType;
				}
			}
			return getReturnTypeOfTypeTag(declaration);
		}
		function isResolvingReturnTypeOfSignature(signature) {
			return !signature.resolvedReturnType && findResolutionCycleStartIndex(
				signature,
				3, /* ResolvedReturnType */
			) >= 0;
		}
		function getRestTypeOfSignature(signature) {
			return tryGetRestTypeOfSignature(signature) || anyType;
		}
		function tryGetRestTypeOfSignature(signature) {
			if (signatureHasRestParameter(signature)) {
				var sigRestType = getTypeOfSymbol(
					signature.parameters[signature.parameters.length - 1],
				);
				var restType = isTupleType(sigRestType) ? getRestTypeOfTupleType(
					sigRestType,
				) : sigRestType;
				return restType && getIndexTypeOfType(restType, numberType);
			}
			return undefined;
		}
		function getSignatureInstantiation(
			signature,
			typeArguments,
			isJavascript,
			inferredTypeParameters,
		) {
			var instantiatedSignature = getSignatureInstantiationWithoutFillingInTypeArguments(
				signature,
				fillMissingTypeArguments(
					typeArguments,
					signature.typeParameters,
					getMinTypeArgumentCount(signature.typeParameters),
					isJavascript,
				),
			);
			if (inferredTypeParameters) {
				var returnSignature = getSingleCallOrConstructSignature(
					getReturnTypeOfSignature(instantiatedSignature),
				);
				if (returnSignature) {
					var newReturnSignature = cloneSignature(returnSignature);
					newReturnSignature.typeParameters = inferredTypeParameters;
					var newInstantiatedSignature = cloneSignature(instantiatedSignature);
					newInstantiatedSignature.resolvedReturnType = getOrCreateTypeFromSignature(
						newReturnSignature,
					);
					return newInstantiatedSignature;
				}
			}
			return instantiatedSignature;
		}
		function getSignatureInstantiationWithoutFillingInTypeArguments(
			signature,
			typeArguments,
		) {
			var instantiations = signature.instantiations || (signature.instantiations = new Map());
			var id = getTypeListId(typeArguments);
			var instantiation = instantiations.get(id);
			if (!instantiation) {
				instantiations.set(
					id,
					instantiation = createSignatureInstantiation(signature, typeArguments),
				);
			}
			return instantiation;
		}
		function createSignatureInstantiation(signature, typeArguments) {
			return instantiateSignature(
				signature,
				createSignatureTypeMapper(signature, typeArguments), /*eraseTypeParameters*/
				true,
			);
		}
		function createSignatureTypeMapper(signature, typeArguments) {
			return createTypeMapper(signature.typeParameters, typeArguments);
		}
		function getErasedSignature(signature) {
			return signature.typeParameters ? signature.erasedSignatureCache || (signature.erasedSignatureCache = createErasedSignature(
				signature,
			)) : signature;
		}
		function createErasedSignature(signature) {
			// Create an instantiation of the signature where all type arguments are the any type.
			return instantiateSignature(
				signature,
				createTypeEraser(signature.typeParameters), /*eraseTypeParameters*/
				true,
			);
		}
		function getCanonicalSignature(signature) {
			return signature.typeParameters ? signature.canonicalSignatureCache || (signature.canonicalSignatureCache = createCanonicalSignature(
				signature,
			)) : signature;
		}
		function createCanonicalSignature(signature) {
			// Create an instantiation of the signature where each unconstrained type parameter is replaced with
			// its original. When a generic class or interface is instantiated, each generic method in the class or
			// interface is instantiated with a fresh set of cloned type parameters (which we need to handle scenarios
			// where different generations of the same type parameter are in scope). This leads to a lot of new type
			// identities, and potentially a lot of work comparing those identities, so here we create an instantiation
			// that uses the original type identities for all unconstrained type parameters.
			return getSignatureInstantiation(
				signature,
				map(
					signature.typeParameters,
					function (tp) {
						return tp.target && !getConstraintOfTypeParameter(tp.target) ? tp.target : tp;
					},
				),
				isInJSFile(signature.declaration),
			);
		}
		function getBaseSignature(signature) {
			var typeParameters = signature.typeParameters;
			if (typeParameters) {
				if (signature.baseSignatureCache) {
					return signature.baseSignatureCache;
				}
				var typeEraser = createTypeEraser(typeParameters);
				var baseConstraintMapper_1 = createTypeMapper(
					typeParameters,
					map(
						typeParameters,
						function (tp) {
							return getConstraintOfTypeParameter(tp) || unknownType;
						},
					),
				);
				var baseConstraints = map(
					typeParameters,
					function (tp) {
						return instantiateType(tp, baseConstraintMapper_1) || unknownType;
					},
				);
				// Run N type params thru the immediate constraint mapper up to N times
				// This way any noncircular interdependent type parameters are definitely resolved to their external dependencies
				for (var i = 0; i < typeParameters.length - 1; i++) {
					baseConstraints = instantiateTypes(
						baseConstraints,
						baseConstraintMapper_1,
					);
				}
				// and then apply a type eraser to remove any remaining circularly dependent type parameters
				baseConstraints = instantiateTypes(baseConstraints, typeEraser);
				return signature.baseSignatureCache = instantiateSignature(
					signature,
					createTypeMapper(typeParameters, baseConstraints), /*eraseTypeParameters*/
					true,
				);
			}
			return signature;
		}
		function getOrCreateTypeFromSignature(signature) {
			// There are two ways to declare a construct signature, one is by declaring a class constructor
			// using the constructor keyword, and the other is declaring a bare construct signature in an
			// object type literal or interface (using the new keyword). Each way of declaring a constructor
			// will result in a different declaration kind.
			if (!signature.isolatedSignatureType) {
				var kind = signature.declaration ? signature.declaration.kind : SyntaxKind.Unknown;
				var isConstructor = kind === SyntaxKind.Constructor || kind === SyntaxKind.ConstructSignature || kind === SyntaxKind.ConstructorType;
				var type = createObjectType(ObjectFlags.Anonymous);
				type.members = emptySymbols;
				type.properties = emptyArray;
				type.callSignatures = !isConstructor ? [signature] : emptyArray;
				type.constructSignatures = isConstructor ? [signature] : emptyArray;
				type.indexInfos = emptyArray;
				signature.isolatedSignatureType = type;
			}
			return signature.isolatedSignatureType;
		}
		function getIndexSymbol(symbol) {
			return symbol.members ? getIndexSymbolFromSymbolTable(symbol.members) : undefined;
		}
		function getIndexSymbolFromSymbolTable(symbolTable) {
			return symbolTable.get(InternalSymbolName.Index);
		}
		function createIndexInfo(keyType, type, isReadonly, declaration) {
			return {
				keyType: keyType,
				type: type,
				isReadonly: isReadonly,
				declaration: declaration,
			};
		}
		function getIndexInfosOfSymbol(symbol) {
			var indexSymbol = getIndexSymbol(symbol);
			return indexSymbol ? getIndexInfosOfIndexSymbol(indexSymbol) : emptyArray;
		}
		function getIndexInfosOfIndexSymbol(indexSymbol) {
			if (indexSymbol.declarations) {
				var indexInfos_2 = [];
				var _loop_8 = function (declaration) {
					if (declaration.parameters.length === 1) {
						var parameter = declaration.parameters[0];
						if (parameter.type) {
							forEachType(
								getTypeFromTypeNode(parameter.type),
								function (keyType) {
									if (
										isValidIndexKeyType(keyType) && !findIndexInfo(
											indexInfos_2,
											keyType,
										)
									) {
										indexInfos_2.push(
											createIndexInfo(
												keyType,
												declaration.type ? getTypeFromTypeNode(declaration.type) : anyType,
												hasEffectiveModifier(
													declaration,
													ModifierFlags.Readonly,
												),
												declaration,
											),
										);
									}
								},
							);
						}
					}
				};
				for (var _i = 0, _a = indexSymbol.declarations; _i < _a.length; _i++) {
					var declaration = _a[_i];
					_loop_8(declaration);
				}
				return indexInfos_2;
			}
			return emptyArray;
		}
		function isValidIndexKeyType(type) {
			return !!(type.flags & (TypeFlags.String | TypeFlags.Number | TypeFlags.ESSymbol)) || isPatternLiteralType(
				type,
			) || !!(type.flags & TypeFlags.Intersection) && !isGenericType(type) && some(
				type.types,
				isValidIndexKeyType,
			);
		}
		function getConstraintDeclaration(type) {
			return mapDefined(
				filter(
					type.symbol && type.symbol.declarations,
					isTypeParameterDeclaration,
				),
				getEffectiveConstraintOfTypeParameter,
			)[0];
		}
		function getInferredTypeParameterConstraint(typeParameter) {
			var _a;
			var inferences;
			if (
				(_a = typeParameter.symbol) === null || _a === void 0 ? void 0 : _a.declarations
			) {
				for (
					var _i = 0, _b = typeParameter.symbol.declarations;
					_i < _b.length;
					_i++
				) {
					var declaration = _b[_i];
					if (declaration.parent.kind === SyntaxKind.InferType) {
						// When an 'infer T' declaration is immediately contained in a type reference node
						// (such as 'Foo<infer T>'), T's constraint is inferred from the constraint of the
						// corresponding type parameter in 'Foo'. When multiple 'infer T' declarations are
						// present, we form an intersection of the inferred constraint types.
						var _c = walkUpParenthesizedTypesAndGetParentAndChild(
							declaration.parent.parent,
						),
							_d = _c[0],
							childTypeParameter = _d === void 0 ? declaration.parent : _d,
							grandParent = _c[1];
						if (grandParent.kind === SyntaxKind.TypeReference) {
							var typeReference = grandParent;
							var typeParameters = getTypeParametersForTypeReference(
								typeReference,
							);
							if (typeParameters) {
								var index = typeReference.typeArguments.indexOf(
									childTypeParameter,
								);
								if (index < typeParameters.length) {
									var declaredConstraint = getConstraintOfTypeParameter(
										typeParameters[index],
									);
									if (declaredConstraint) {
										// Type parameter constraints can reference other type parameters so
										// constraints need to be instantiated. If instantiation produces the
										// type parameter itself, we discard that inference. For example, in
										//   type Foo<T extends string, U extends T> = [T, U];
										//   type Bar<T> = T extends Foo<infer X, infer X> ? Foo<X, X> : T;
										// the instantiated constraint for U is X, so we discard that inference.
										var mapper = createTypeMapper(
											typeParameters,
											getEffectiveTypeArguments(typeReference, typeParameters),
										);
										var constraint = instantiateType(declaredConstraint, mapper);
										if (constraint !== typeParameter) {
											inferences = append(inferences, constraint);
										}
									}
								}
							}
						} else if ( // or a named rest tuple element, we infer an 'unknown[]' constraint. // When an 'infer T' declaration is immediately contained in a rest parameter declaration, a rest type
							grandParent.kind === SyntaxKind.Parameter && grandParent.dotDotDotToken || grandParent.kind === SyntaxKind.RestType || grandParent.kind === SyntaxKind.NamedTupleMember && grandParent.dotDotDotToken
						) {
							inferences = append(inferences, createArrayType(unknownType));
						} else if (grandParent.kind === SyntaxKind.TemplateLiteralTypeSpan) { // constraint. // When an 'infer T' declaration is immediately contained in a string template type, we infer a 'string'
							inferences = append(inferences, stringType);
						} else if ( // constraint. // When an 'infer T' declaration is in the constraint position of a mapped type, we infer a 'keyof any'
							grandParent.kind === SyntaxKind.TypeParameter && grandParent.parent.kind === SyntaxKind.MappedType
						) {
							inferences = append(inferences, keyofConstraintType);
						} // of the check type's mapped type // clause of a conditional whose check type is also a mapped type, give it a constraint equal to the template // When an 'infer T' declaration is the template of a mapped type, and that mapped type is the extends
						else if (
							grandParent.kind === SyntaxKind.MappedType && grandParent.type && skipParentheses(
								grandParent.type,
							) === declaration.parent && grandParent.parent.kind === SyntaxKind.ConditionalType && grandParent.parent.extendsType === grandParent && grandParent.parent.checkType.kind === SyntaxKind.MappedType && grandParent.parent.checkType.type
						) {
							var checkMappedType_1 = grandParent.parent.checkType;
							var nodeType = getTypeFromTypeNode(checkMappedType_1.type);
							inferences = append(
								inferences,
								instantiateType(
									nodeType,
									makeUnaryTypeMapper(
										getDeclaredTypeOfTypeParameter(
											getSymbolOfNode(checkMappedType_1.typeParameter),
										),
										checkMappedType_1.typeParameter.constraint ? getTypeFromTypeNode(
											checkMappedType_1.typeParameter.constraint,
										) : keyofConstraintType,
									),
								),
							);
						}
					}
				}
			}
			return inferences && getIntersectionType(inferences);
		}
		/** This is a worker function. Use getConstraintOfTypeParameter which guards against circular constraints. */
		function getConstraintFromTypeParameter(typeParameter) {
			if (!typeParameter.constraint) {
				if (typeParameter.target) {
					var targetConstraint = getConstraintOfTypeParameter(
						typeParameter.target,
					);
					typeParameter.constraint = targetConstraint ? instantiateType(
						targetConstraint,
						typeParameter.mapper,
					) : noConstraintType;
				} else {
					var constraintDeclaration = getConstraintDeclaration(typeParameter);
					if (!constraintDeclaration) {
						typeParameter.constraint = getInferredTypeParameterConstraint(
							typeParameter,
						) || noConstraintType;
					} else {
						var type = getTypeFromTypeNode(constraintDeclaration);
						if (type.flags & TypeFlags.Any && !isErrorType(type)) {
							// use keyofConstraintType as the base constraint for mapped type key constraints (unknown isn;t assignable to that, but `any` was), // Allow errorType to propegate to keep downstream errors suppressed
							// use unknown otherwise
							type = constraintDeclaration.parent.parent.kind === SyntaxKind.MappedType ? keyofConstraintType : unknownType;
						}
						typeParameter.constraint = type;
					}
				}
			}
			return typeParameter.constraint === noConstraintType ? undefined : typeParameter.constraint;
		}
		function getParentSymbolOfTypeParameter(typeParameter) {
			var tp = getDeclarationOfKind(
				typeParameter.symbol,
				SyntaxKind.TypeParameter,
			);
			var host = isJSDocTemplateTag(tp.parent) ? getEffectiveContainerForJSDocTemplateTag(
				tp.parent,
			) : tp.parent;
			return host && getSymbolOfNode(host);
		}
		function getTypeListId(types) {
			var result = "";
			if (types) {
				var length_3 = types.length;
				var i = 0;
				while (i < length_3) {
					var startId = types[i].id;
					var count = 1;
					while (
						i + count < length_3 && types[i + count].id === startId + count
					) {
						count++;
					}
					if (result.length) {
						result += ",";
					}
					result += startId;
					if (count > 1) {
						result += ":" + count;
					}
					i += count;
				}
			}
			return result;
		}
		function getAliasId(aliasSymbol, aliasTypeArguments) {
			return aliasSymbol ? "@".concat(getSymbolId(aliasSymbol)) + (aliasTypeArguments ? ":".concat(
				getTypeListId(aliasTypeArguments),
			) : "") : "";
		}
		// This function is used to propagate certain flags when creating new object type references and union types.
		// It is only necessary to do so if a constituent type might be the undefined type, the null type, the type
		// of an object literal or the anyFunctionType. This is because there are operations in the type checker
		// that care about the presence of such types at arbitrary depth in a containing type.
		function getPropagatingFlagsOfTypes(types, excludeKinds) {
			var result = 0;
			for (var _i = 0, types_8 = types; _i < types_8.length; _i++) {
				var type = types_8[_i];
				if (!(type.flags & excludeKinds)) {
					result |= getObjectFlags(type);
				}
			}
			return result & ObjectFlags.PropagatingFlags;
		}
		function createTypeReference(target, typeArguments) {
			var id = getTypeListId(typeArguments);
			var type = target.instantiations.get(id);
			if (!type) {
				type = createObjectType(ObjectFlags.Reference, target.symbol);
				target.instantiations.set(id, type);
				type.objectFlags |= typeArguments ? getPropagatingFlagsOfTypes(
					typeArguments, /*excludeKinds*/
					0,
				) : 0;
				type.target = target;
				type.resolvedTypeArguments = typeArguments;
			}
			return type;
		}
		function cloneTypeReference(source) {
			var type = createType(source.flags);
			type.symbol = source.symbol;
			type.objectFlags = source.objectFlags;
			type.target = source.target;
			type.resolvedTypeArguments = source.resolvedTypeArguments;
			return type;
		}
		function createDeferredTypeReference(
			target,
			node,
			mapper,
			aliasSymbol,
			aliasTypeArguments,
		) {
			if (!aliasSymbol) {
				aliasSymbol = getAliasSymbolForTypeNode(node);
				var localAliasTypeArguments = getTypeArgumentsForAliasSymbol(
					aliasSymbol,
				);
				aliasTypeArguments = mapper ? instantiateTypes(
					localAliasTypeArguments,
					mapper,
				) : localAliasTypeArguments;
			}
			var type = createObjectType(ObjectFlags.Reference, target.symbol);
			type.target = target;
			type.node = node;
			type.mapper = mapper;
			type.aliasSymbol = aliasSymbol;
			type.aliasTypeArguments = aliasTypeArguments;
			return type;
		}
		function getTypeArguments(type) {
			var _a, _b;
			if (!type.resolvedTypeArguments) {
				if (!pushTypeResolution(type, 6 /* ResolvedTypeArguments */ )) {
					return ((_a = type.target.localTypeParameters) === null || _a === void 0 ? void 0 : _a.map(
						function () {
							return errorType;
						},
					)) || emptyArray;
				}
				var node = type.node;
				var typeArguments = !node ? emptyArray : node.kind === SyntaxKind.TypeReference ? concatenate(
					type.target.outerTypeParameters,
					getEffectiveTypeArguments(node, type.target.localTypeParameters),
				) : node.kind === SyntaxKind.ArrayType ? [
					getTypeFromTypeNode(node.elementType),
				] : map(node.elements, getTypeFromTypeNode);
				if (popTypeResolution()) {
					type.resolvedTypeArguments = type.mapper ? instantiateTypes(
						typeArguments,
						type.mapper,
					) : typeArguments;
				} else {
					type.resolvedTypeArguments = ((_b = type.target.localTypeParameters) === null || _b === void 0 ? void 0 : _b.map(
						function () {
							return errorType;
						},
					)) || emptyArray;
					error(
						type.node || currentNode,
						type.target.symbol ? Diagnostics.Type_arguments_for_0_circularly_reference_themselves : Diagnostics.Tuple_type_arguments_circularly_reference_themselves,
						type.target.symbol && symbolToString(type.target.symbol),
					);
				}
			}
			return type.resolvedTypeArguments;
		}
		function getTypeReferenceArity(type) {
			return length(type.target.typeParameters);
		}
		/**
         * Get type from type-reference that reference to class or interface
         */
		function getTypeFromClassOrInterfaceReference(node, symbol) {
			var type = getDeclaredTypeOfSymbol(getMergedSymbol(symbol));
			var typeParameters = type.localTypeParameters;
			if (typeParameters) {
				var numTypeArguments = length(node.typeArguments);
				var minTypeArgumentCount = getMinTypeArgumentCount(typeParameters);
				var isJs = isInJSFile(node);
				var isJsImplicitAny = !noImplicitAny && isJs;
				if (
					!isJsImplicitAny && (numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length)
				) {
					var missingAugmentsTag = isJs && isExpressionWithTypeArguments(node) && !isJSDocAugmentsTag(
						node.parent,
					);
					var diag = minTypeArgumentCount === typeParameters.length ? missingAugmentsTag ? Diagnostics.Expected_0_type_arguments_provide_these_with_an_extends_tag : Diagnostics.Generic_type_0_requires_1_type_argument_s : missingAugmentsTag ? Diagnostics.Expected_0_1_type_arguments_provide_these_with_an_extends_tag : Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments;
					var typeStr = typeToString(
						type, /*enclosingDeclaration*/
						undefined,
						TypeFormatFlags.WriteArrayAsGenericType,
					);
					error(
						node,
						diag,
						typeStr,
						minTypeArgumentCount,
						typeParameters.length,
					);
					if (!isJs) {
						// TODO: Adopt same permissive behavior in TS as in JS to reduce follow-on editing experience failures (requires editing fillMissingTypeArguments)
						return errorType;
					}
				}
				if (
					node.kind === SyntaxKind.TypeReference && isDeferredTypeReferenceNode(
						node,
						length(node.typeArguments) !== typeParameters.length,
					)
				) {
					return createDeferredTypeReference(type, node, /*mapper*/ undefined);
				}
				// In a type reference, the outer type parameters of the referenced class or interface are automatically
				// supplied as type arguments and the type reference only specifies arguments for the local type parameters
				// of the class or interface.
				var typeArguments = concatenate(
					type.outerTypeParameters,
					fillMissingTypeArguments(
						typeArgumentsFromTypeReferenceNode(node),
						typeParameters,
						minTypeArgumentCount,
						isJs,
					),
				);
				return createTypeReference(type, typeArguments);
			}
			return checkNoTypeArguments(node, symbol) ? type : errorType;
		}
		function getTypeAliasInstantiation(
			symbol,
			typeArguments,
			aliasSymbol,
			aliasTypeArguments,
		) {
			var type = getDeclaredTypeOfSymbol(symbol);
			if (
				type === intrinsicMarkerType && intrinsicTypeKinds.has(
					symbol.escapedName,
				) && typeArguments && typeArguments.length === 1
			) {
				return getStringMappingType(symbol, typeArguments[0]);
			}
			var links = getSymbolLinks(symbol);
			var typeParameters = links.typeParameters;
			var id = getTypeListId(typeArguments) + getAliasId(
				aliasSymbol,
				aliasTypeArguments,
			);
			var instantiation = links.instantiations.get(id);
			if (!instantiation) {
				links.instantiations.set(
					id,
					instantiation = instantiateTypeWithAlias(
						type,
						createTypeMapper(
							typeParameters,
							fillMissingTypeArguments(
								typeArguments,
								typeParameters,
								getMinTypeArgumentCount(typeParameters),
								isInJSFile(symbol.valueDeclaration),
							),
						),
						aliasSymbol,
						aliasTypeArguments,
					),
				);
			}
			return instantiation;
		}
		/**
         * Get type from reference to type alias. When a type alias is generic, the declared type of the type alias may include
         * references to the type parameters of the alias. We replace those with the actual type arguments by instantiating the
         * declared type. Instantiations are cached using the type identities of the type arguments as the key.
         */
		function getTypeFromTypeAliasReference(node, symbol) {
			if (getCheckFlags(symbol) & CheckFlags.Unresolved) {
				var typeArguments = typeArgumentsFromTypeReferenceNode(node);
				var id = getAliasId(symbol, typeArguments);
				var errorType_1 = errorTypes.get(id);
				if (!errorType_1) {
					errorType_1 = createIntrinsicType(TypeFlags.Any, "error");
					errorType_1.aliasSymbol = symbol;
					errorType_1.aliasTypeArguments = typeArguments;
					errorTypes.set(id, errorType_1);
				}
				return errorType_1;
			}
			var type = getDeclaredTypeOfSymbol(symbol);
			var typeParameters = getSymbolLinks(symbol).typeParameters;
			if (typeParameters) {
				var numTypeArguments = length(node.typeArguments);
				var minTypeArgumentCount = getMinTypeArgumentCount(typeParameters);
				if (
					numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length
				) {
					error(
						node,
						minTypeArgumentCount === typeParameters.length ? Diagnostics.Generic_type_0_requires_1_type_argument_s : Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments,
						symbolToString(symbol),
						minTypeArgumentCount,
						typeParameters.length,
					);
					return errorType;
				}
				// We refrain from associating a local type alias with an instantiation of a top-level type alias
				// because the local alias may end up being referenced in an inferred return type where it is not
				// accessible--which in turn may lead to a large structural expansion of the type when generating
				// a .d.ts file. See #43622 for an example.
				var aliasSymbol = getAliasSymbolForTypeNode(node);
				var newAliasSymbol = aliasSymbol && (isLocalTypeAlias(symbol) || !isLocalTypeAlias(
					aliasSymbol,
				)) ? aliasSymbol : undefined;
				return getTypeAliasInstantiation(
					symbol,
					typeArgumentsFromTypeReferenceNode(node),
					newAliasSymbol,
					getTypeArgumentsForAliasSymbol(newAliasSymbol),
				);
			}
			return checkNoTypeArguments(node, symbol) ? type : errorType;
		}
		function isLocalTypeAlias(symbol) {
			var _a;
			var declaration = (_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.find(
				isTypeAlias,
			);
			return !!(declaration && getContainingFunction(declaration));
		}
		function getTypeReferenceName(node) {
			switch (node.kind) {
				case SyntaxKind.TypeReference:
					return node.typeName;
				case SyntaxKind.ExpressionWithTypeArguments:
					// We only support expressions that are simple qualified names. For other
					// expressions this produces undefined.
					var expr = node.expression;
					if (isEntityNameExpression(expr)) {
						return expr;
					} // fall through;
			}
			return undefined;
		}
		function getSymbolPath(symbol) {
			return symbol.parent ? "".concat(getSymbolPath(symbol.parent), ".").concat(
				symbol.escapedName,
			) : symbol.escapedName;
		}
		function getUnresolvedSymbolForEntityName(name) {
			var identifier = name.kind === SyntaxKind.QualifiedName ? name.right : name.kind === SyntaxKind.PropertyAccessExpression ? name.name : name;
			var text = identifier.escapedText;
			if (text) {
				var parentSymbol = name.kind === SyntaxKind.QualifiedName ? getUnresolvedSymbolForEntityName(
					name.left,
				) : name.kind === SyntaxKind.PropertyAccessExpression ? getUnresolvedSymbolForEntityName(
					name.expression,
				) : undefined;
				var path = parentSymbol ? "".concat(getSymbolPath(parentSymbol), ".").concat(
					text,
				) : text;
				var result = unresolvedSymbols.get(path);
				if (!result) {
					unresolvedSymbols.set(
						path,
						result = createSymbol(
							SymbolFlags.TypeAlias,
							text,
							CheckFlags.Unresolved,
						),
					);
					result.parent = parentSymbol;
					result.declaredType = unresolvedType;
				}
				return result;
			}
			return unknownSymbol;
		}
		function resolveTypeReferenceName(typeReference, meaning, ignoreErrors) {
			var name = getTypeReferenceName(typeReference);
			if (!name) {
				return unknownSymbol;
			}
			var symbol = resolveEntityName(name, meaning, ignoreErrors);
			return symbol && symbol !== unknownSymbol ? symbol : ignoreErrors ? unknownSymbol : getUnresolvedSymbolForEntityName(
				name,
			);
		}
		function getTypeReferenceType(node, symbol) {
			if (symbol === unknownSymbol) {
				return errorType;
			}
			symbol = getExpandoSymbol(symbol) || symbol;
			if (symbol.flags & (SymbolFlags.Class | SymbolFlags.Interface)) {
				return getTypeFromClassOrInterfaceReference(node, symbol);
			}
			if (symbol.flags & SymbolFlags.TypeAlias) {
				return getTypeFromTypeAliasReference(node, symbol);
			}
			// Get type from reference to named type that cannot be generic (enum or type parameter)
			var res = tryGetDeclaredTypeOfSymbol(symbol);
			if (res) {
				return checkNoTypeArguments(node, symbol) ? getRegularTypeOfLiteralType(
					res,
				) : errorType;
			}
			if (symbol.flags & SymbolFlags.Value && isJSDocTypeReference(node)) {
				var jsdocType = getTypeFromJSDocValueReference(node, symbol);
				if (jsdocType) {
					return jsdocType;
				} else {
					// Resolve the type reference as a Type for the purpose of reporting errors.
					resolveTypeReferenceName(node, SymbolFlags.Type);
					return getTypeOfSymbol(symbol);
				}
			}
			return errorType;
		}
		/**
         * A JSdoc TypeReference may be to a value, but resolve it as a type anyway.
         * Example: import('./b').ConstructorFunction
         */
		function getTypeFromJSDocValueReference(node, symbol) {
			var links = getNodeLinks(node);
			if (!links.resolvedJSDocType) {
				var valueType = getTypeOfSymbol(symbol);
				var typeType = valueType;
				if (symbol.valueDeclaration) {
					var isImportTypeWithQualifier = node.kind === SyntaxKind.ImportType && node.qualifier;
					// valueType might not have a symbol, eg, {import('./b').STRING_LITERAL}
					if (
						valueType.symbol && valueType.symbol !== symbol && isImportTypeWithQualifier
					) {
						typeType = getTypeReferenceType(node, valueType.symbol);
					}
				}
				links.resolvedJSDocType = typeType;
			}
			return links.resolvedJSDocType;
		}
		function getSubstitutionType(baseType, substitute) {
			if (substitute.flags & TypeFlags.AnyOrUnknown || substitute === baseType) {
				return baseType;
			}
			var id = "".concat(getTypeId(baseType), ">").concat(getTypeId(substitute));
			var cached = substitutionTypes.get(id);
			if (cached) {
				return cached;
			}
			var result = createType(TypeFlags.Substitution);
			result.baseType = baseType;
			result.substitute = substitute;
			substitutionTypes.set(id, result);
			return result;
		}
		function isUnaryTupleTypeNode(node) {
			return node.kind === SyntaxKind.TupleType && node.elements.length === 1;
		}
		function getImpliedConstraint(type, checkNode, extendsNode) {
			return isUnaryTupleTypeNode(checkNode) && isUnaryTupleTypeNode(
				extendsNode,
			) ? getImpliedConstraint(
				type,
				checkNode.elements[0],
				extendsNode.elements[0],
			) : getActualTypeVariable(getTypeFromTypeNode(checkNode)) === type ? getTypeFromTypeNode(
				extendsNode,
			) : undefined;
		}
		function getConditionalFlowTypeOfType(type, node) {
			var constraints;
			var covariant = true;
			while (
				node && !isStatement(node) && node.kind !== SyntaxKind.JSDocComment
			) {
				var parent_7 = node.parent;
				// only consider variance flipped by parameter locations - `keyof` types would usually be considered variance inverting, but
				// often get used in indexed accesses where they behave sortof invariantly, but our checking is lax
				if (parent_7.kind === SyntaxKind.Parameter) {
					covariant = !covariant;
				}
				// Always substitute on type parameters, regardless of variance, since even
				// in contravariant positions, they may rely on substituted constraints to be valid
				if (
					(covariant || type.flags & TypeFlags.TypeVariable) && parent_7.kind === SyntaxKind.ConditionalType && node === parent_7.trueType
				) {
					var constraint = getImpliedConstraint(
						type,
						parent_7.checkType,
						parent_7.extendsType,
					);
					if (constraint) {
						constraints = append(constraints, constraint);
					}
				}
				node = parent_7;
			}
			return constraints ? getSubstitutionType(
				type,
				getIntersectionType(append(constraints, type)),
			) : type;
		}
		function isJSDocTypeReference(node) {
			return !!(node.flags & NodeFlags.JSDoc) && (node.kind === SyntaxKind.TypeReference || node.kind === SyntaxKind.ImportType);
		}
		function checkNoTypeArguments(node, symbol) {
			if (node.typeArguments) {
				error(
					node,
					Diagnostics.Type_0_is_not_generic,
					symbol ? symbolToString(symbol) : node.typeName ? declarationNameToString(
						node.typeName,
					) : anon,
				);
				return false;
			}
			return true;
		}
		function getIntendedTypeFromJSDocTypeReference(node) {
			if (isIdentifier(node.typeName)) {
				var typeArgs = node.typeArguments;
				switch (node.typeName.escapedText) {
					case "String":
						checkNoTypeArguments(node);
						return stringType;
					case "Number":
						checkNoTypeArguments(node);
						return numberType;
					case "Boolean":
						checkNoTypeArguments(node);
						return booleanType;
					case "Void":
						checkNoTypeArguments(node);
						return voidType;
					case "Undefined":
						checkNoTypeArguments(node);
						return undefinedType;
					case "Null":
						checkNoTypeArguments(node);
						return nullType;
					case "Function":
					case "function":
						checkNoTypeArguments(node);
						return globalFunctionType;
					case "array":
						return (!typeArgs || !typeArgs.length) && !noImplicitAny ? anyArrayType : undefined;
					case "promise":
						return (!typeArgs || !typeArgs.length) && !noImplicitAny ? createPromiseType(
							anyType,
						) : undefined;
					case "Object":
						if (typeArgs && typeArgs.length === 2) {
							if (isJSDocIndexSignature(node)) {
								var indexed = getTypeFromTypeNode(typeArgs[0]);
								var target = getTypeFromTypeNode(typeArgs[1]);
								var indexInfo = indexed === stringType || indexed === numberType ? [
									createIndexInfo(indexed, target, /*isReadonly*/ false),
								] : emptyArray;
								return createAnonymousType(
									undefined,
									emptySymbols,
									emptyArray,
									emptyArray,
									indexInfo,
								);
							}
							return anyType;
						}
						checkNoTypeArguments(node);
						return !noImplicitAny ? anyType : undefined;
				}
			}
		}
		function getTypeFromJSDocNullableTypeNode(node) {
			var type = getTypeFromTypeNode(node.type);
			return strictNullChecks ? getNullableType(type, TypeFlags.Null) : type;
		}
		function getTypeFromTypeReference(node) {
			var links = getNodeLinks(node);
			if (!links.resolvedType) {
				// handle LS queries on the `const` in `x as const` by resolving to the type of `x`
				if (isConstTypeReference(node) && isAssertionExpression(node.parent)) {
					links.resolvedSymbol = unknownSymbol;
					return links.resolvedType = checkExpressionCached(
						node.parent.expression,
					);
				}
				var symbol = void 0;
				var type = void 0;
				var meaning = SymbolFlags.Type;
				if (isJSDocTypeReference(node)) {
					type = getIntendedTypeFromJSDocTypeReference(node);
					if (!type) {
						symbol = resolveTypeReferenceName(
							node,
							meaning, /*ignoreErrors*/
							true,
						);
						if (symbol === unknownSymbol) {
							symbol = resolveTypeReferenceName(
								node,
								meaning | SymbolFlags.Value,
							);
						} else {
							resolveTypeReferenceName(node, meaning); // Resolve again to mark errors, if any
						}
						type = getTypeReferenceType(node, symbol);
					}
				}
				if (!type) {
					symbol = resolveTypeReferenceName(node, meaning);
					type = getTypeReferenceType(node, symbol);
				}
				// Cache both the resolved symbol and the resolved type. The resolved symbol is needed when we check the
				// type reference in checkTypeReferenceNode.
				links.resolvedSymbol = symbol;
				links.resolvedType = type;
			}
			return links.resolvedType;
		}
		function typeArgumentsFromTypeReferenceNode(node) {
			return map(node.typeArguments, getTypeFromTypeNode);
		}
		function getTypeFromTypeQueryNode(node) {
			var links = getNodeLinks(node);
			if (!links.resolvedType) {
				// TypeScript 1.0 spec (April 2014): 3.6.3
				// The expression is processed as an identifier expression (section 4.3)
				// or property access expression(section 4.10),
				// the widened type(section 3.9) of which becomes the result.
				var type = isThisIdentifier(node.exprName) ? checkThisExpression(
					node.exprName,
				) : checkExpression(node.exprName);
				links.resolvedType = getRegularTypeOfLiteralType(getWidenedType(type));
			}
			return links.resolvedType;
		}
		function getTypeOfGlobalSymbol(symbol, arity) {
			function getTypeDeclaration(symbol) {
				var declarations = symbol.declarations;
				if (declarations) {
					for (
						var _i = 0, declarations_2 = declarations;
						_i < declarations_2.length;
						_i++
					) {
						var declaration = declarations_2[_i];
						switch (declaration.kind) {
							case SyntaxKind.ClassDeclaration:
							case SyntaxKind.InterfaceDeclaration:
							case SyntaxKind.EnumDeclaration:
								return declaration;
						}
					}
				}
			}
			if (!symbol) {
				return arity ? emptyGenericType : emptyObjectType;
			}
			var type = getDeclaredTypeOfSymbol(symbol);
			if (!(type.flags & TypeFlags.Object)) {
				error(
					getTypeDeclaration(symbol),
					Diagnostics.Global_type_0_must_be_a_class_or_interface_type,
					symbolName(symbol),
				);
				return arity ? emptyGenericType : emptyObjectType;
			}
			if (length(type.typeParameters) !== arity) {
				error(
					getTypeDeclaration(symbol),
					Diagnostics.Global_type_0_must_have_1_type_parameter_s,
					symbolName(symbol),
					arity,
				);
				return arity ? emptyGenericType : emptyObjectType;
			}
			return type;
		}
		function getGlobalValueSymbol(name, reportErrors) {
			return getGlobalSymbol(
				name,
				SymbolFlags.Value,
				reportErrors ? Diagnostics.Cannot_find_global_value_0 : undefined,
			);
		}
		function getGlobalTypeSymbol(name, reportErrors) {
			return getGlobalSymbol(
				name,
				SymbolFlags.Type,
				reportErrors ? Diagnostics.Cannot_find_global_type_0 : undefined,
			);
		}
		function getGlobalTypeAliasSymbol(name, arity, reportErrors) {
			var symbol = getGlobalSymbol(
				name,
				SymbolFlags.Type,
				reportErrors ? Diagnostics.Cannot_find_global_type_0 : undefined,
			);
			if (symbol) {
				// Resolve the declared type of the symbol. This resolves type parameters for the type
				// alias so that we can check arity.
				getDeclaredTypeOfSymbol(symbol);
				if (length(getSymbolLinks(symbol).typeParameters) !== arity) {
					var decl = symbol.declarations && find(
						symbol.declarations,
						isTypeAliasDeclaration,
					);
					error(
						decl,
						Diagnostics.Global_type_0_must_have_1_type_parameter_s,
						symbolName(symbol),
						arity,
					);
					return undefined;
				}
			}
			return symbol;
		}
		function getGlobalSymbol(name, meaning, diagnostic) {
			// Don't track references for global symbols anyway, so value if `isReference` is arbitrary
			return resolveName(
				undefined,
				name,
				meaning,
				diagnostic,
				name, /*isUse*/
				false, /*excludeGlobals*/
				false, /*getSpellingSuggestions*/
				false,
			);
		}
		function getGlobalType(name, arity, reportErrors) {
			var symbol = getGlobalTypeSymbol(name, reportErrors);
			return symbol || reportErrors ? getTypeOfGlobalSymbol(symbol, arity) : undefined;
		}
		function getGlobalTypedPropertyDescriptorType() {
			// We always report an error, so store a result in the event we could not resolve the symbol to prevent reporting it multiple times
			return deferredGlobalTypedPropertyDescriptorType || (deferredGlobalTypedPropertyDescriptorType = getGlobalType(
				"TypedPropertyDescriptor", /*arity*/
				1, /*reportErrors*/
				true,
			) || emptyGenericType);
		}
		function getGlobalTemplateStringsArrayType() {
			// We always report an error, so store a result in the event we could not resolve the symbol to prevent reporting it multiple times
			return deferredGlobalTemplateStringsArrayType || (deferredGlobalTemplateStringsArrayType = getGlobalType(
				"TemplateStringsArray", /*arity*/
				0, /*reportErrors*/
				true,
			) || emptyObjectType);
		}
		function getGlobalImportMetaType() {
			// We always report an error, so store a result in the event we could not resolve the symbol to prevent reporting it multiple times
			return deferredGlobalImportMetaType || (deferredGlobalImportMetaType = getGlobalType(
				"ImportMeta", /*arity*/
				0, /*reportErrors*/
				true,
			) || emptyObjectType);
		}
		function getGlobalImportMetaExpressionType() {
			if (!deferredGlobalImportMetaExpressionType) {
				// Create a synthetic type `ImportMetaExpression { meta: MetaProperty }`
				var symbol = createSymbol(SymbolFlags.None, "ImportMetaExpression");
				var importMetaType = getGlobalImportMetaType();
				var metaPropertySymbol = createSymbol(
					SymbolFlags.Property,
					"meta",
					CheckFlags.Readonly,
				);
				metaPropertySymbol.parent = symbol;
				metaPropertySymbol.type = importMetaType;
				var members = createSymbolTable([metaPropertySymbol]);
				symbol.members = members;
				deferredGlobalImportMetaExpressionType = createAnonymousType(
					symbol,
					members,
					emptyArray,
					emptyArray,
					emptyArray,
				);
			}
			return deferredGlobalImportMetaExpressionType;
		}
		function getGlobalImportCallOptionsType(reportErrors) {
			return (deferredGlobalImportCallOptionsType || (deferredGlobalImportCallOptionsType = getGlobalType(
				"ImportCallOptions", /*arity*/
				0,
				reportErrors,
			))) || emptyObjectType;
		}
		function getGlobalESSymbolConstructorSymbol(reportErrors) {
			return deferredGlobalESSymbolConstructorSymbol || (deferredGlobalESSymbolConstructorSymbol = getGlobalValueSymbol(
				"Symbol",
				reportErrors,
			));
		}
		function getGlobalESSymbolConstructorTypeSymbol(reportErrors) {
			return deferredGlobalESSymbolConstructorTypeSymbol || (deferredGlobalESSymbolConstructorTypeSymbol = getGlobalTypeSymbol(
				"SymbolConstructor",
				reportErrors,
			));
		}
		function getGlobalESSymbolType(reportErrors) {
			return (deferredGlobalESSymbolType || (deferredGlobalESSymbolType = getGlobalType(
				"Symbol", /*arity*/
				0,
				reportErrors,
			))) || emptyObjectType;
		}
		function getGlobalPromiseType(reportErrors) {
			return (deferredGlobalPromiseType || (deferredGlobalPromiseType = getGlobalType(
				"Promise", /*arity*/
				1,
				reportErrors,
			))) || emptyGenericType;
		}
		function getGlobalPromiseLikeType(reportErrors) {
			return (deferredGlobalPromiseLikeType || (deferredGlobalPromiseLikeType = getGlobalType(
				"PromiseLike", /*arity*/
				1,
				reportErrors,
			))) || emptyGenericType;
		}
		function getGlobalPromiseConstructorSymbol(reportErrors) {
			return deferredGlobalPromiseConstructorSymbol || (deferredGlobalPromiseConstructorSymbol = getGlobalValueSymbol(
				"Promise",
				reportErrors,
			));
		}
		function getGlobalPromiseConstructorLikeType(reportErrors) {
			return (deferredGlobalPromiseConstructorLikeType || (deferredGlobalPromiseConstructorLikeType = getGlobalType(
				"PromiseConstructorLike", /*arity*/
				0,
				reportErrors,
			))) || emptyObjectType;
		}
		function getGlobalAsyncIterableType(reportErrors) {
			return (deferredGlobalAsyncIterableType || (deferredGlobalAsyncIterableType = getGlobalType(
				"AsyncIterable", /*arity*/
				1,
				reportErrors,
			))) || emptyGenericType;
		}
		function getGlobalAsyncIteratorType(reportErrors) {
			return (deferredGlobalAsyncIteratorType || (deferredGlobalAsyncIteratorType = getGlobalType(
				"AsyncIterator", /*arity*/
				3,
				reportErrors,
			))) || emptyGenericType;
		}
		function getGlobalAsyncIterableIteratorType(reportErrors) {
			return (deferredGlobalAsyncIterableIteratorType || (deferredGlobalAsyncIterableIteratorType = getGlobalType(
				"AsyncIterableIterator", /*arity*/
				1,
				reportErrors,
			))) || emptyGenericType;
		}
		function getGlobalAsyncGeneratorType(reportErrors) {
			return (deferredGlobalAsyncGeneratorType || (deferredGlobalAsyncGeneratorType = getGlobalType(
				"AsyncGenerator", /*arity*/
				3,
				reportErrors,
			))) || emptyGenericType;
		}
		function getGlobalIterableType(reportErrors) {
			return (deferredGlobalIterableType || (deferredGlobalIterableType = getGlobalType(
				"Iterable", /*arity*/
				1,
				reportErrors,
			))) || emptyGenericType;
		}
		function getGlobalIteratorType(reportErrors) {
			return (deferredGlobalIteratorType || (deferredGlobalIteratorType = getGlobalType(
				"Iterator", /*arity*/
				3,
				reportErrors,
			))) || emptyGenericType;
		}
		function getGlobalIterableIteratorType(reportErrors) {
			return (deferredGlobalIterableIteratorType || (deferredGlobalIterableIteratorType = getGlobalType(
				"IterableIterator", /*arity*/
				1,
				reportErrors,
			))) || emptyGenericType;
		}
		function getGlobalGeneratorType(reportErrors) {
			return (deferredGlobalGeneratorType || (deferredGlobalGeneratorType = getGlobalType(
				"Generator", /*arity*/
				3,
				reportErrors,
			))) || emptyGenericType;
		}
		function getGlobalIteratorYieldResultType(reportErrors) {
			return (deferredGlobalIteratorYieldResultType || (deferredGlobalIteratorYieldResultType = getGlobalType(
				"IteratorYieldResult", /*arity*/
				1,
				reportErrors,
			))) || emptyGenericType;
		}
		function getGlobalIteratorReturnResultType(reportErrors) {
			return (deferredGlobalIteratorReturnResultType || (deferredGlobalIteratorReturnResultType = getGlobalType(
				"IteratorReturnResult", /*arity*/
				1,
				reportErrors,
			))) || emptyGenericType;
		}
		function getGlobalTypeOrUndefined(name, arity) {
			if (arity === void 0) {
				arity = 0;
			}
			var symbol = getGlobalSymbol(
				name,
				SymbolFlags.Type, /*diagnostic*/
				undefined,
			);
			return symbol && getTypeOfGlobalSymbol(symbol, arity);
		}
		function getGlobalExtractSymbol() {
			// We always report an error, so cache a result in the event we could not resolve the symbol to prevent reporting it multiple times
			deferredGlobalExtractSymbol || (deferredGlobalExtractSymbol = getGlobalTypeAliasSymbol(
				"Extract", /*arity*/
				2, /*reportErrors*/
				true,
			) || unknownSymbol);
			return deferredGlobalExtractSymbol === unknownSymbol ? undefined : deferredGlobalExtractSymbol;
		}
		function getGlobalOmitSymbol() {
			// We always report an error, so cache a result in the event we could not resolve the symbol to prevent reporting it multiple times
			deferredGlobalOmitSymbol || (deferredGlobalOmitSymbol = getGlobalTypeAliasSymbol(
				"Omit", /*arity*/
				2, /*reportErrors*/
				true,
			) || unknownSymbol);
			return deferredGlobalOmitSymbol === unknownSymbol ? undefined : deferredGlobalOmitSymbol;
		}
		function getGlobalAwaitedSymbol(reportErrors) {
			// Only cache `unknownSymbol` if we are reporting errors so that we don't report the error more than once.
			deferredGlobalAwaitedSymbol || (deferredGlobalAwaitedSymbol = getGlobalTypeAliasSymbol(
				"Awaited", /*arity*/
				1,
				reportErrors,
			) || (reportErrors ? unknownSymbol : undefined));
			return deferredGlobalAwaitedSymbol === unknownSymbol ? undefined : deferredGlobalAwaitedSymbol;
		}
		function getGlobalBigIntType(reportErrors) {
			return (deferredGlobalBigIntType || (deferredGlobalBigIntType = getGlobalType(
				"BigInt", /*arity*/
				0,
				reportErrors,
			))) || emptyObjectType;
		}
		/**
         * Instantiates a global type that is generic with some element type, and returns that instantiation.
         */
		function createTypeFromGenericGlobalType(genericGlobalType, typeArguments) {
			return genericGlobalType !== emptyGenericType ? createTypeReference(
				genericGlobalType,
				typeArguments,
			) : emptyObjectType;
		}
		function createTypedPropertyDescriptorType(propertyType) {
			return createTypeFromGenericGlobalType(
				getGlobalTypedPropertyDescriptorType(),
				[propertyType],
			);
		}
		function createIterableType(iteratedType) {
			return createTypeFromGenericGlobalType(
				getGlobalIterableType( /*reportErrors*/ true),
				[iteratedType],
			);
		}
		function createArrayType(elementType, readonly) {
			return createTypeFromGenericGlobalType(
				readonly ? globalReadonlyArrayType : globalArrayType,
				[elementType],
			);
		}
		function getTupleElementFlags(node) {
			switch (node.kind) {
				case SyntaxKind.OptionalType:
					return ElementFlags.Optional;
				case SyntaxKind.RestType:
					return getRestTypeElementFlags(node);
				case SyntaxKind.NamedTupleMember:
					return node.questionToken ? ElementFlags.Optional : node.dotDotDotToken ? getRestTypeElementFlags(
						node,
					) : ElementFlags.Required;
				default:
					return ElementFlags.Required;
			}
		}
		function getRestTypeElementFlags(node) {
			return getArrayElementTypeNode(node.type) ? ElementFlags.Rest : ElementFlags.Variadic;
		}
		function getArrayOrTupleTargetType(node) {
			var readonly = isReadonlyTypeOperator(node.parent);
			var elementType = getArrayElementTypeNode(node);
			if (elementType) {
				return readonly ? globalReadonlyArrayType : globalArrayType;
			}
			var elementFlags = map(node.elements, getTupleElementFlags);
			var missingName = some(
				node.elements,
				function (e) {
					return e.kind !== SyntaxKind.NamedTupleMember;
				},
			);
			return getTupleTargetType(
				elementFlags,
				readonly, /*associatedNames*/
				missingName ? undefined : node.elements,
			);
		}
		// Return true if the given type reference node is directly aliased or if it needs to be deferred
		// because it is possibly contained in a circular chain of eagerly resolved types.
		function isDeferredTypeReferenceNode(node, hasDefaultTypeArguments) {
			return !!getAliasSymbolForTypeNode(node) || isResolvedByTypeAlias(node) && (node.kind === SyntaxKind.ArrayType ? mayResolveTypeAlias(
				node.elementType,
			) : node.kind === SyntaxKind.TupleType ? some(
				node.elements,
				mayResolveTypeAlias,
			) : hasDefaultTypeArguments || some(
				node.typeArguments,
				mayResolveTypeAlias,
			));
		}
		// Return true when the given node is transitively contained in type constructs that eagerly
		// resolve their constituent types. We include SyntaxKind.TypeReference because type arguments
		// of type aliases are eagerly resolved.
		function isResolvedByTypeAlias(node) {
			var parent = node.parent;
			switch (parent.kind) {
				case SyntaxKind.ParenthesizedType:
				case SyntaxKind.NamedTupleMember:
				case SyntaxKind.TypeReference:
				case SyntaxKind.UnionType:
				case SyntaxKind.IntersectionType:
				case SyntaxKind.IndexedAccessType:
				case SyntaxKind.ConditionalType:
				case SyntaxKind.TypeOperator:
				case SyntaxKind.ArrayType:
				case SyntaxKind.TupleType:
					return isResolvedByTypeAlias(parent);
				case SyntaxKind.TypeAliasDeclaration:
					return true;
			}
			return false;
		}
		// Return true if resolving the given node (i.e. getTypeFromTypeNode) possibly causes resolution
		// of a type alias.
		function mayResolveTypeAlias(node) {
			switch (node.kind) {
				case SyntaxKind.TypeReference:
					return isJSDocTypeReference(node) || !!(resolveTypeReferenceName(
						node,
						SymbolFlags.Type,
					).flags & SymbolFlags.TypeAlias);
				case SyntaxKind.TypeQuery:
					return true;
				case SyntaxKind.TypeOperator:
					return node.operator !== SyntaxKind.UniqueKeyword && mayResolveTypeAlias(
						node.type,
					);
				case SyntaxKind.ParenthesizedType:
				case SyntaxKind.OptionalType:
				case SyntaxKind.NamedTupleMember:
				case SyntaxKind.JSDocOptionalType:
				case SyntaxKind.JSDocNullableType:
				case SyntaxKind.JSDocNonNullableType:
				case SyntaxKind.JSDocTypeExpression:
					return mayResolveTypeAlias(node.type);
				case SyntaxKind.RestType:
					return node.type.kind !== SyntaxKind.ArrayType || mayResolveTypeAlias(
						node.type.elementType,
					);
				case SyntaxKind.UnionType:
				case SyntaxKind.IntersectionType:
					return some(node.types, mayResolveTypeAlias);
				case SyntaxKind.IndexedAccessType:
					return mayResolveTypeAlias(node.objectType) || mayResolveTypeAlias(
						node.indexType,
					);
				case SyntaxKind.ConditionalType:
					return mayResolveTypeAlias(node.checkType) || mayResolveTypeAlias(
						node.extendsType,
					) || mayResolveTypeAlias(node.trueType) || mayResolveTypeAlias(
						node.falseType,
					);
			}
			return false;
		}
		function getTypeFromArrayOrTupleTypeNode(node) {
			var links = getNodeLinks(node);
			if (!links.resolvedType) {
				var target = getArrayOrTupleTargetType(node);
				if (target === emptyGenericType) {
					links.resolvedType = emptyObjectType;
				} else if (
					!(node.kind === SyntaxKind.TupleType && some(
						node.elements,
						function (e) {
							return !!(getTupleElementFlags(e) & ElementFlags.Variadic);
						},
					)) && isDeferredTypeReferenceNode(node)
				) {
					links.resolvedType = node.kind === SyntaxKind.TupleType && node.elements.length === 0 ? target : createDeferredTypeReference(
						target,
						node, /*mapper*/
						undefined,
					);
				} else {
					var elementTypes = node.kind === SyntaxKind.ArrayType ? [
						getTypeFromTypeNode(node.elementType),
					] : map(node.elements, getTypeFromTypeNode);
					links.resolvedType = createNormalizedTypeReference(
						target,
						elementTypes,
					);
				}
			}
			return links.resolvedType;
		}
		function isReadonlyTypeOperator(node) {
			return isTypeOperatorNode(node) && node.operator === SyntaxKind.ReadonlyKeyword;
		}
		function createTupleType(
			elementTypes,
			elementFlags,
			readonly,
			namedMemberDeclarations,
		) {
			if (readonly === void 0) {
				readonly = false;
			}
			var tupleTarget = getTupleTargetType(
				elementFlags || map(
					elementTypes,
					function (_) {
						return ElementFlags.Required;
					},
				),
				readonly,
				namedMemberDeclarations,
			);
			return tupleTarget === emptyGenericType ? emptyObjectType : elementTypes.length ? createNormalizedTypeReference(
				tupleTarget,
				elementTypes,
			) : tupleTarget;
		}
		function getTupleTargetType(elementFlags, readonly, namedMemberDeclarations) {
			if (elementFlags.length === 1 && elementFlags[0] & ElementFlags.Rest) {
				// [...X[]] is equivalent to just X[]
				return readonly ? globalReadonlyArrayType : globalArrayType;
			}
			var key = map(
				elementFlags,
				function (f) {
					return f & ElementFlags.Required ? "#" : f & ElementFlags.Optional ? "?" : f & ElementFlags.Rest ? "." : "*";
				},
			).join() + (readonly ? "R" : "") + (namedMemberDeclarations && namedMemberDeclarations.length ? "," + map(
				namedMemberDeclarations,
				getNodeId,
			).join(",") : "");
			var type = tupleTypes.get(key);
			if (!type) {
				tupleTypes.set(
					key,
					type = createTupleTargetType(
						elementFlags,
						readonly,
						namedMemberDeclarations,
					),
				);
			}
			return type;
		}
		// We represent tuple types as type references to synthesized generic interface types created by
		// this function. The types are of the form:
		//
		//   interface Tuple<T0, T1, T2, ...> extends Array<T0 | T1 | T2 | ...> { 0: T0, 1: T1, 2: T2, ... }
		//
		// Note that the generic type created by this function has no symbol associated with it. The same
		// is true for each of the synthesized type parameters.
		function createTupleTargetType(
			elementFlags,
			readonly,
			namedMemberDeclarations,
		) {
			var arity = elementFlags.length;
			var minLength = countWhere(
				elementFlags,
				function (f) {
					return !!(f & (ElementFlags.Required | ElementFlags.Variadic));
				},
			);
			var typeParameters;
			var properties = [];
			var combinedFlags = 0;
			if (arity) {
				typeParameters = new Array(arity);
				for (var i = 0; i < arity; i++) {
					var typeParameter = typeParameters[i] = createTypeParameter();
					var flags = elementFlags[i];
					combinedFlags |= flags;
					if (!(combinedFlags & ElementFlags.Variable)) {
						var property = createSymbol(
							SymbolFlags.Property | (flags & ElementFlags.Optional ? SymbolFlags.Optional : 0),
							"" + i,
							readonly ? CheckFlags.Readonly : 0,
						);
						property.tupleLabelDeclaration = namedMemberDeclarations === null || namedMemberDeclarations === void 0 ? void 0 : namedMemberDeclarations[i];
						property.type = typeParameter;
						properties.push(property);
					}
				}
			}
			var fixedLength = properties.length;
			var lengthSymbol = createSymbol(SymbolFlags.Property, "length");
			if (combinedFlags & ElementFlags.Variable) {
				lengthSymbol.type = numberType;
			} else {
				var literalTypes = [];
				for (var i = minLength; i <= arity; i++) literalTypes.push(
					getNumberLiteralType(i),
				);
				lengthSymbol.type = getUnionType(literalTypes);
			}
			properties.push(lengthSymbol);
			var type = createObjectType(ObjectFlags.Tuple | ObjectFlags.Reference);
			type.typeParameters = typeParameters;
			type.outerTypeParameters = undefined;
			type.localTypeParameters = typeParameters;
			type.instantiations = new Map();
			type.instantiations.set(getTypeListId(type.typeParameters), type);
			type.target = type;
			type.resolvedTypeArguments = type.typeParameters;
			type.thisType = createTypeParameter();
			type.thisType.isThisType = true;
			type.thisType.constraint = type;
			type.declaredProperties = properties;
			type.declaredCallSignatures = emptyArray;
			type.declaredConstructSignatures = emptyArray;
			type.declaredIndexInfos = emptyArray;
			type.elementFlags = elementFlags;
			type.minLength = minLength;
			type.fixedLength = fixedLength;
			type.hasRestElement = !!(combinedFlags & ElementFlags.Variable);
			type.combinedFlags = combinedFlags;
			type.readonly = readonly;
			type.labeledElementDeclarations = namedMemberDeclarations;
			return type;
		}
		function createNormalizedTypeReference(target, typeArguments) {
			return target.objectFlags & ObjectFlags.Tuple ? createNormalizedTupleType(
				target,
				typeArguments,
			) : createTypeReference(target, typeArguments);
		}
		function createNormalizedTupleType(target, elementTypes) {
			var _a, _b, _c;
			if (!(target.combinedFlags & ElementFlags.NonRequired)) {
				// No need to normalize when we only have regular required elements
				return createTypeReference(target, elementTypes);
			}
			if (target.combinedFlags & ElementFlags.Variadic) {
				// Transform [A, ...(X | Y | Z)] into [A, ...X] | [A, ...Y] | [A, ...Z]
				var unionIndex_1 = findIndex(
					elementTypes,
					function (t, i) {
						return !!(target.elementFlags[i] & ElementFlags.Variadic && t.flags & (TypeFlags.Never | TypeFlags.Union));
					},
				);
				if (unionIndex_1 >= 0) {
					return checkCrossProductUnion(
						map(
							elementTypes,
							function (t, i) {
								return target.elementFlags[i] & ElementFlags.Variadic ? t : unknownType;
							},
						),
					) ? mapType(
						elementTypes[unionIndex_1],
						function (t) {
							return createNormalizedTupleType(
								target,
								replaceElement(elementTypes, unionIndex_1, t),
							);
						},
					) : errorType;
				}
			}
			// We have optional, rest, or variadic elements that may need normalizing. Normalization ensures that all variadic
			// elements are generic and that the tuple type has one of the following layouts, disregarding variadic elements:
			// (1) Zero or more required elements, followed by zero or more optional elements, followed by zero or one rest element.
			// (2) Zero or more required elements, followed by a rest element, followed by zero or more required elements.
			// In either layout, zero or more generic variadic elements may be present at any location.
			var expandedTypes = [];
			var expandedFlags = [];
			var expandedDeclarations = [];
			var lastRequiredIndex = -1;
			var firstRestIndex = -1;
			var lastOptionalOrRestIndex = -1;
			var _loop_9 = function (i) {
				var type = elementTypes[i];
				var flags = target.elementFlags[i];
				if (flags & ElementFlags.Variadic) {
					if (
						type.flags & TypeFlags.InstantiableNonPrimitive || isGenericMappedType(
							type,
						)
					) {
						// Generic variadic elements stay as they are.
						addElement(
							type,
							ElementFlags.Variadic,
							(_a = target.labeledElementDeclarations) === null || _a === void 0 ? void 0 : _a[i],
						);
					} else if (isTupleType(type)) {
						var elements = getTypeArguments(type);
						if (elements.length + expandedTypes.length >= 10000) {
							error(
								currentNode,
								isPartOfTypeNode(currentNode) ? Diagnostics.Type_produces_a_tuple_type_that_is_too_large_to_represent : Diagnostics.Expression_produces_a_tuple_type_that_is_too_large_to_represent,
							);
							return { value: errorType };
						}
						// Spread variadic elements with tuple types into the resulting tuple.
						forEach(
							elements,
							function (t, n) {
								var _a;
								return addElement(
									t,
									type.target.elementFlags[n],
									(_a = type.target.labeledElementDeclarations) === null || _a === void 0 ? void 0 : _a[n],
								);
							},
						);
					} else {
						// Treat everything else as an array type and create a rest element.
						addElement(
							isArrayLikeType(type) && getIndexTypeOfType(type, numberType) || errorType,
							ElementFlags.Rest,
							(_b = target.labeledElementDeclarations) === null || _b === void 0 ? void 0 : _b[i],
						);
					}
				} else {
					// Copy other element kinds with no change.
					addElement(
						type,
						flags,
						(_c = target.labeledElementDeclarations) === null || _c === void 0 ? void 0 : _c[i],
					);
				}
			};
			for (var i = 0; i < elementTypes.length; i++) {
				var state_3 = _loop_9(i);
				if (typeof state_3 === "object") return state_3.value;
			}
			// Turn optional elements preceding the last required element into required elements
			for (var i = 0; i < lastRequiredIndex; i++) {
				if (expandedFlags[i] & ElementFlags.Optional) expandedFlags[i] = ElementFlags.Required;
			}
			if (firstRestIndex >= 0 && firstRestIndex < lastOptionalOrRestIndex) {
				// Turn elements between first rest and last optional/rest into a single rest element
				expandedTypes[firstRestIndex] = getUnionType(
					sameMap(
						expandedTypes.slice(firstRestIndex, lastOptionalOrRestIndex + 1),
						function (t, i) {
							return expandedFlags[firstRestIndex + i] & ElementFlags.Variadic ? getIndexedAccessType(
								t,
								numberType,
							) : t;
						},
					),
				);
				expandedTypes.splice(
					firstRestIndex + 1,
					lastOptionalOrRestIndex - firstRestIndex,
				);
				expandedFlags.splice(
					firstRestIndex + 1,
					lastOptionalOrRestIndex - firstRestIndex,
				);
				expandedDeclarations === null || expandedDeclarations === void 0 ? void 0 : expandedDeclarations.splice(
					firstRestIndex + 1,
					lastOptionalOrRestIndex - firstRestIndex,
				);
			}
			var tupleTarget = getTupleTargetType(
				expandedFlags,
				target.readonly,
				expandedDeclarations,
			);
			return tupleTarget === emptyGenericType ? emptyObjectType : expandedFlags.length ? createTypeReference(
				tupleTarget,
				expandedTypes,
			) : tupleTarget;
			function addElement(type, flags, declaration) {
				if (flags & ElementFlags.Required) {
					lastRequiredIndex = expandedFlags.length;
				}
				if (flags & ElementFlags.Rest && firstRestIndex < 0) {
					firstRestIndex = expandedFlags.length;
				}
				if (flags & (ElementFlags.Optional | ElementFlags.Rest)) {
					lastOptionalOrRestIndex = expandedFlags.length;
				}
				expandedTypes.push(type);
				expandedFlags.push(flags);
				if (expandedDeclarations && declaration) {
					expandedDeclarations.push(declaration);
				} else {
					expandedDeclarations = undefined;
				}
			}
		}
		function sliceTupleType(type, index, endSkipCount) {
			if (endSkipCount === void 0) {
				endSkipCount = 0;
			}
			var target = type.target;
			var endIndex = getTypeReferenceArity(type) - endSkipCount;
			return index > target.fixedLength ? getRestArrayTypeOfTupleType(type) || createTupleType(
				emptyArray,
			) : createTupleType(
				getTypeArguments(type).slice(index, endIndex),
				target.elementFlags.slice(index, endIndex),
				/*readonly*/ false,
				target.labeledElementDeclarations && target.labeledElementDeclarations.slice(
					index,
					endIndex,
				),
			);
		}
		function getKnownKeysOfTupleType(type) {
			return getUnionType(
				append(
					arrayOf(
						type.target.fixedLength,
						function (i) {
							return getStringLiteralType("" + i);
						},
					),
					getIndexType(
						type.target.readonly ? globalReadonlyArrayType : globalArrayType,
					),
				),
			);
		}
		// Return count of starting consecutive tuple elements of the given kind(s)
		function getStartElementCount(type, flags) {
			var index = findIndex(
				type.elementFlags,
				function (f) {
					return !(f & flags);
				},
			);
			return index >= 0 ? index : type.elementFlags.length;
		}
		// Return count of ending consecutive tuple elements of the given kind(s)
		function getEndElementCount(type, flags) {
			return type.elementFlags.length - findLastIndex(
				type.elementFlags,
				function (f) {
					return !(f & flags);
				},
			) - 1;
		}
		function getTypeFromOptionalTypeNode(node) {
			return addOptionality(getTypeFromTypeNode(node.type), /*isProperty*/ true);
		}
		function getTypeId(type) {
			return type.id;
		}
		function containsType(types, type) {
			return binarySearch(types, type, getTypeId, compareValues) >= 0;
		}
		function insertType(types, type) {
			var index = binarySearch(types, type, getTypeId, compareValues);
			if (index < 0) {
				types.splice(~index, 0, type);
				return true;
			}
			return false;
		}
		function addTypeToUnion(typeSet, includes, type) {
			var flags = type.flags;
			if (flags & TypeFlags.Union) {
				return addTypesToUnion(
					typeSet,
					includes | (isNamedUnionType(type) ? TypeFlags.Union : 0),
					type.types,
				);
			}
			// We ignore 'never' types in unions
			if (!(flags & TypeFlags.Never)) {
				includes |= flags & TypeFlags.IncludesMask;
				if (flags & TypeFlags.Instantiable) includes |= TypeFlags.IncludesInstantiable;
				if (type === wildcardType) includes |= TypeFlags.IncludesWildcard;
				if (!strictNullChecks && flags & TypeFlags.Nullable) {
					if (!(getObjectFlags(type) & ObjectFlags.ContainsWideningType)) includes |= TypeFlags.IncludesNonWideningType;
				} else {
					var len = typeSet.length;
					var index = len && type.id > typeSet[len - 1].id ? ~len : binarySearch(
						typeSet,
						type,
						getTypeId,
						compareValues,
					);
					if (index < 0) {
						typeSet.splice(~index, 0, type);
					}
				}
			}
			return includes;
		}
		// Add the given types to the given type set. Order is preserved, duplicates are removed,
		// and nested types of the given kind are flattened into the set.
		function addTypesToUnion(typeSet, includes, types) {
			for (var _i = 0, types_9 = types; _i < types_9.length; _i++) {
				var type = types_9[_i];
				includes = addTypeToUnion(typeSet, includes, type);
			}
			return includes;
		}
		function removeSubtypes(types, hasObjectTypes) {
			var id = getTypeListId(types);
			var match = subtypeReductionCache.get(id);
			if (match) {
				return match;
			}
			// We assume that redundant primitive types have already been removed from the types array and that there
			// are no any and unknown types in the array. Thus, the only possible supertypes for primitive types are empty
			// object types, and if none of those are present we can exclude primitive types from the subtype check.
			var hasEmptyObject = hasObjectTypes && some(
				types,
				function (t) {
					return !!(t.flags & TypeFlags.Object) && !isGenericMappedType(t) && isEmptyResolvedType(
						resolveStructuredTypeMembers(t),
					);
				},
			);
			var len = types.length;
			var i = len;
			var count = 0;
			while (i > 0) {
				i--;
				var source = types[i];
				if (hasEmptyObject || source.flags & TypeFlags.StructuredOrInstantiable) {
					// Find the first property with a unit type, if any. When constituents have a property by the same name
					// but of a different unit type, we can quickly disqualify them from subtype checks. This helps subtype
					// reduction of large discriminated union types.
					var keyProperty = source.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.InstantiableNonPrimitive) ? find(
						getPropertiesOfType(source),
						function (p) {
							return isUnitType(getTypeOfSymbol(p));
						},
					) : undefined;
					var keyPropertyType = keyProperty && getRegularTypeOfLiteralType(
						getTypeOfSymbol(keyProperty),
					);
					for (var _i = 0, types_10 = types; _i < types_10.length; _i++) {
						var target = types_10[_i];
						if (source !== target) {
							if (count === 100000) {
								// After 100000 subtype checks we estimate the remaining amount of work by assuming the
								// same ratio of checks per element. If the estimated number of remaining type checks is
								// greater than 1M we deem the union type too complex to represent. This for example
								// caps union types at 1000 unique object types.
								var estimatedCount = (count / (len - i)) * len;
								if (estimatedCount > 1000000) {
									tracing === null || tracing === void 0 ? void 0 : tracing.instant(
										tracing.Phase.CheckTypes,
										"removeSubtypes_DepthLimit",
										{
											typeIds: types.map(
												function (t) {
													return t.id;
												},
											),
										},
									);
									error(
										currentNode,
										Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent,
									);
									return undefined;
								}
							}
							count++;
							if (
								keyProperty && target.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.InstantiableNonPrimitive)
							) {
								var t = getTypeOfPropertyOfType(target, keyProperty.escapedName);
								if (
									t && isUnitType(t) && getRegularTypeOfLiteralType(t) !== keyPropertyType
								) {
									continue;
								}
							}
							if (
								isTypeRelatedTo(source, target, strictSubtypeRelation) && (!(getObjectFlags(
									getTargetType(source),
								) & ObjectFlags.Class) || !(getObjectFlags(
									getTargetType(target),
								) & ObjectFlags.Class) || isTypeDerivedFrom(source, target))
							) {
								orderedRemoveItemAt(types, i);
								break;
							}
						}
					}
				}
			}
			subtypeReductionCache.set(id, types);
			return types;
		}
		function removeRedundantLiteralTypes(types, includes, reduceVoidUndefined) {
			var i = types.length;
			while (i > 0) {
				i--;
				var t = types[i];
				var flags = t.flags;
				var remove = flags & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) && includes & TypeFlags.String || flags & TypeFlags.NumberLiteral && includes & TypeFlags.Number || flags & TypeFlags.BigIntLiteral && includes & TypeFlags.BigInt || flags & TypeFlags.UniqueESSymbol && includes & TypeFlags.ESSymbol || reduceVoidUndefined && flags & TypeFlags.Undefined && includes & TypeFlags.Void || isFreshLiteralType(
					t,
				) && containsType(types, t.regularType);
				if (remove) {
					orderedRemoveItemAt(types, i);
				}
			}
		}
		function removeStringLiteralsMatchedByTemplateLiterals(types) {
			var templates = filter(types, isPatternLiteralType);
			if (templates.length) {
				var i = types.length;
				var _loop_10 = function () {
					i--;
					var t = types[i];
					if (
						t.flags & TypeFlags.StringLiteral && some(
							templates,
							function (template) {
								return isTypeMatchedByTemplateLiteralType(t, template);
							},
						)
					) {
						orderedRemoveItemAt(types, i);
					}
				};
				while (i > 0) {
					_loop_10();
				}
			}
		}
		function isNamedUnionType(type) {
			return !!(type.flags & TypeFlags.Union && (type.aliasSymbol || type.origin));
		}
		function addNamedUnions(namedUnions, types) {
			for (var _i = 0, types_11 = types; _i < types_11.length; _i++) {
				var t = types_11[_i];
				if (t.flags & TypeFlags.Union) {
					var origin_1 = t.origin;
					if (t.aliasSymbol || origin_1 && !(origin_1.flags & TypeFlags.Union)) {
						pushIfUnique(namedUnions, t);
					} else if (origin_1 && origin_1.flags & TypeFlags.Union) {
						addNamedUnions(namedUnions, origin_1.types);
					}
				}
			}
		}
		function createOriginUnionOrIntersectionType(flags, types) {
			var result = createOriginType(flags);
			result.types = types;
			return result;
		}
		// We sort and deduplicate the constituent types based on object identity. If the subtypeReduction
		// flag is specified we also reduce the constituent type set to only include types that aren't subtypes
		// of other types. Subtype reduction is expensive for large union types and is possible only when union
		// types are known not to circularly reference themselves (as is the case with union types created by
		// expression constructs such as array literals and the || and ?: operators). Named types can
		// circularly reference themselves and therefore cannot be subtype reduced during their declaration.
		// For example, "type Item = string | (() => Item" is a named type that circularly references itself.
		function getUnionType(
			types,
			unionReduction,
			aliasSymbol,
			aliasTypeArguments,
			origin,
		) {
			if (unionReduction === void 0) {
				unionReduction = UnionReduction.Literal;
			}
			if (types.length === 0) {
				return neverType;
			}
			if (types.length === 1) {
				return types[0];
			}
			var typeSet = [];
			var includes = addTypesToUnion(typeSet, 0, types);
			if (unionReduction !== UnionReduction.None) {
				if (includes & TypeFlags.AnyOrUnknown) {
					return includes & TypeFlags.Any ? includes & TypeFlags.IncludesWildcard ? wildcardType : anyType : includes & TypeFlags.Null || containsType(
						typeSet,
						unknownType,
					) ? unknownType : nonNullUnknownType;
				}
				if (exactOptionalPropertyTypes && includes & TypeFlags.Undefined) {
					var missingIndex = binarySearch(
						typeSet,
						missingType,
						getTypeId,
						compareValues,
					);
					if (missingIndex >= 0 && containsType(typeSet, undefinedType)) {
						orderedRemoveItemAt(typeSet, missingIndex);
					}
				}
				if (
					includes & (TypeFlags.Literal | TypeFlags.UniqueESSymbol | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) || includes & TypeFlags.Void && includes & TypeFlags.Undefined
				) {
					removeRedundantLiteralTypes(
						typeSet,
						includes,
						!!(unionReduction & UnionReduction.Subtype),
					);
				}
				if (
					includes & TypeFlags.StringLiteral && includes & TypeFlags.TemplateLiteral
				) {
					removeStringLiteralsMatchedByTemplateLiterals(typeSet);
				}
				if (unionReduction === UnionReduction.Subtype) {
					typeSet = removeSubtypes(typeSet, !!(includes & TypeFlags.Object));
					if (!typeSet) {
						return errorType;
					}
				}
				if (typeSet.length === 0) {
					return includes & TypeFlags.Null ? includes & TypeFlags.IncludesNonWideningType ? nullType : nullWideningType : includes & TypeFlags.Undefined ? includes & TypeFlags.IncludesNonWideningType ? undefinedType : undefinedWideningType : neverType;
				}
			}
			if (!origin && includes & TypeFlags.Union) {
				var namedUnions = [];
				addNamedUnions(namedUnions, types);
				var reducedTypes = [];
				var _loop_11 = function (t) {
					if (
						!some(
							namedUnions,
							function (union) {
								return containsType(union.types, t);
							},
						)
					) {
						reducedTypes.push(t);
					}
				};
				for (var _i = 0, typeSet_1 = typeSet; _i < typeSet_1.length; _i++) {
					var t = typeSet_1[_i];
					_loop_11(t);
				}
				if (
					!aliasSymbol && namedUnions.length === 1 && reducedTypes.length === 0
				) {
					return namedUnions[0];
				}
				// We create a denormalized origin type only when the union was created from one or more named unions
				// (unions with alias symbols or origins) and when there is no overlap between those named unions.
				var namedTypesCount = reduceLeft(
					namedUnions,
					function (sum, union) {
						return sum + union.types.length;
					},
					0,
				);
				if (namedTypesCount + reducedTypes.length === typeSet.length) {
					for (
						var _a = 0, namedUnions_1 = namedUnions;
						_a < namedUnions_1.length;
						_a++
					) {
						var t = namedUnions_1[_a];
						insertType(reducedTypes, t);
					}
					origin = createOriginUnionOrIntersectionType(
						TypeFlags.Union,
						reducedTypes,
					);
				}
			}
			var objectFlags = (includes & TypeFlags.NotPrimitiveUnion ? 0 : ObjectFlags.PrimitiveUnion) | (includes & TypeFlags.Intersection ? ObjectFlags.ContainsIntersections : 0);
			return getUnionTypeFromSortedList(
				typeSet,
				objectFlags,
				aliasSymbol,
				aliasTypeArguments,
				origin,
			);
		}
		function getUnionOrIntersectionTypePredicate(signatures, kind) {
			var first;
			var types = [];
			for (var _i = 0, signatures_6 = signatures; _i < signatures_6.length; _i++) {
				var sig = signatures_6[_i];
				var pred = getTypePredicateOfSignature(sig);
				if (
					!pred || pred.kind === TypePredicateKind.AssertsThis || pred.kind === TypePredicateKind.AssertsIdentifier
				) {
					if (kind !== TypeFlags.Intersection) {
						continue;
					} else {
						return; // intersections demand all members be type predicates for the result to have a predicate
					}
				}
				if (first) {
					if (!typePredicateKindsMatch(first, pred)) {
						// No common type predicate.
						return undefined;
					}
				} else {
					first = pred;
				}
				types.push(pred.type);
			}
			if (!first) {
				// No signatures had a type predicate.
				return undefined;
			}
			var compositeType = getUnionOrIntersectionType(types, kind);
			return createTypePredicate(
				first.kind,
				first.parameterName,
				first.parameterIndex,
				compositeType,
			);
		}
		function typePredicateKindsMatch(a, b) {
			return a.kind === b.kind && a.parameterIndex === b.parameterIndex;
		}
		// This function assumes the constituent type list is sorted and deduplicated.
		function getUnionTypeFromSortedList(
			types,
			objectFlags,
			aliasSymbol,
			aliasTypeArguments,
			origin,
		) {
			if (types.length === 0) {
				return neverType;
			}
			if (types.length === 1) {
				return types[0];
			}
			var typeKey = !origin ? getTypeListId(types) : origin.flags & TypeFlags.Union ? "|".concat(
				getTypeListId(origin.types),
			) : origin.flags & TypeFlags.Intersection ? "&".concat(
				getTypeListId(origin.types),
			) : "#".concat(origin.type.id, "|").concat(getTypeListId(types)); // origin type id alone is insufficient, as `keyof x` may resolve to multiple WIP values while `x` is still resolving
			var id = typeKey + getAliasId(aliasSymbol, aliasTypeArguments);
			var type = unionTypes.get(id);
			if (!type) {
				type = createType(TypeFlags.Union);
				type.objectFlags = objectFlags | getPropagatingFlagsOfTypes(
					types, /*excludeKinds*/
					TypeFlags.Nullable,
				);
				type.types = types;
				type.origin = origin;
				type.aliasSymbol = aliasSymbol;
				type.aliasTypeArguments = aliasTypeArguments;
				if (
					types.length === 2 && types[0].flags & TypeFlags.BooleanLiteral && types[1].flags & TypeFlags.BooleanLiteral
				) {
					type.flags |= TypeFlags.Boolean;
					type.intrinsicName = "boolean";
				}
				unionTypes.set(id, type);
			}
			return type;
		}
		function getTypeFromUnionTypeNode(node) {
			var links = getNodeLinks(node);
			if (!links.resolvedType) {
				var aliasSymbol = getAliasSymbolForTypeNode(node);
				links.resolvedType = getUnionType(
					map(node.types, getTypeFromTypeNode),
					UnionReduction.Literal,
					aliasSymbol,
					getTypeArgumentsForAliasSymbol(aliasSymbol),
				);
			}
			return links.resolvedType;
		}
		function addTypeToIntersection(typeSet, includes, type) {
			var flags = type.flags;
			if (flags & TypeFlags.Intersection) {
				return addTypesToIntersection(typeSet, includes, type.types);
			}
			if (isEmptyAnonymousObjectType(type)) {
				if (!(includes & TypeFlags.IncludesEmptyObject)) {
					includes |= TypeFlags.IncludesEmptyObject;
					typeSet.set(type.id.toString(), type);
				}
			} else {
				if (flags & TypeFlags.AnyOrUnknown) {
					if (type === wildcardType) includes |= TypeFlags.IncludesWildcard;
				} else if (strictNullChecks || !(flags & TypeFlags.Nullable)) {
					if (exactOptionalPropertyTypes && type === missingType) {
						includes |= TypeFlags.IncludesMissingType;
						type = undefinedType;
					}
					if (!typeSet.has(type.id.toString())) {
						if (type.flags & TypeFlags.Unit && includes & TypeFlags.Unit) {
							// We have seen two distinct unit types which means we should reduce to an
							// empty intersection. Adding TypeFlags.NonPrimitive causes that to happen.
							includes |= TypeFlags.NonPrimitive;
						}
						typeSet.set(type.id.toString(), type);
					}
				}
				includes |= flags & TypeFlags.IncludesMask;
			}
			return includes;
		}
		// Add the given types to the given type set. Order is preserved, freshness is removed from literal
		// types, duplicates are removed, and nested types of the given kind are flattened into the set.
		function addTypesToIntersection(typeSet, includes, types) {
			for (var _i = 0, types_12 = types; _i < types_12.length; _i++) {
				var type = types_12[_i];
				includes = addTypeToIntersection(
					typeSet,
					includes,
					getRegularTypeOfLiteralType(type),
				);
			}
			return includes;
		}
		function removeRedundantPrimitiveTypes(types, includes) {
			var i = types.length;
			while (i > 0) {
				i--;
				var t = types[i];
				var remove = t.flags & TypeFlags.String && includes & TypeFlags.StringLiteral || t.flags & TypeFlags.Number && includes & TypeFlags.NumberLiteral || t.flags & TypeFlags.BigInt && includes & TypeFlags.BigIntLiteral || t.flags & TypeFlags.ESSymbol && includes & TypeFlags.UniqueESSymbol;
				if (remove) {
					orderedRemoveItemAt(types, i);
				}
			}
		}
		// Check that the given type has a match in every union. A given type is matched by
		// an identical type, and a literal type is additionally matched by its corresponding
		// primitive type.
		function eachUnionContains(unionTypes, type) {
			for (var _i = 0, unionTypes_1 = unionTypes; _i < unionTypes_1.length; _i++) {
				var u = unionTypes_1[_i];
				if (!containsType(u.types, type)) {
					var primitive = type.flags & TypeFlags.StringLiteral ? stringType : type.flags & TypeFlags.NumberLiteral ? numberType : type.flags & TypeFlags.BigIntLiteral ? bigintType : type.flags & TypeFlags.UniqueESSymbol ? esSymbolType : undefined;
					if (!primitive || !containsType(u.types, primitive)) {
						return false;
					}
				}
			}
			return true;
		}
		/**
         * Returns `true` if the intersection of the template literals and string literals is the empty set, eg `get${string}` & "setX", and should reduce to `never`
         */
		function extractRedundantTemplateLiterals(types) {
			var i = types.length;
			var literals = filter(
				types,
				function (t) {
					return !!(t.flags & TypeFlags.StringLiteral);
				},
			);
			while (i > 0) {
				i--;
				var t = types[i];
				if (!(t.flags & TypeFlags.TemplateLiteral)) continue;
				for (var _i = 0, literals_1 = literals; _i < literals_1.length; _i++) {
					var t2 = literals_1[_i];
					if (isTypeSubtypeOf(t2, t)) {
						// eg, ``get${T}` & "getX"` is just `"getX"`
						orderedRemoveItemAt(types, i);
						break;
					} else if (isPatternLiteralType(t)) {
						return true;
					}
				}
			}
			return false;
		}
		function eachIsUnionContaining(types, flag) {
			return every(
				types,
				function (t) {
					return !!(t.flags & TypeFlags.Union) && some(
						t.types,
						function (tt) {
							return !!(tt.flags & flag);
						},
					);
				},
			);
		}
		function removeFromEach(types, flag) {
			for (var i = 0; i < types.length; i++) {
				types[i] = filterType(
					types[i],
					function (t) {
						return !(t.flags & flag);
					},
				);
			}
		}
		// If the given list of types contains more than one union of primitive types, replace the
		// first with a union containing an intersection of those primitive types, then remove the
		// other unions and return true. Otherwise, do nothing and return false.
		function intersectUnionsOfPrimitiveTypes(types) {
			var unionTypes;
			var index = findIndex(
				types,
				function (t) {
					return !!(getObjectFlags(t) & ObjectFlags.PrimitiveUnion);
				},
			);
			if (index < 0) {
				return false;
			}
			var i = index + 1;
			// Remove all but the first union of primitive types and collect them in
			// the unionTypes array.
			while (i < types.length) {
				var t = types[i];
				if (getObjectFlags(t) & ObjectFlags.PrimitiveUnion) {
					(unionTypes || (unionTypes = [types[index]])).push(t);
					orderedRemoveItemAt(types, i);
				} else {
					i++;
				}
			}
			// Return false if there was only one union of primitive types
			if (!unionTypes) {
				return false;
			}
			// We have more than one union of primitive types, now intersect them. For each
			// type in each union we check if the type is matched in every union and if so
			// we include it in the result.
			var checked = [];
			var result = [];
			for (var _i = 0, unionTypes_2 = unionTypes; _i < unionTypes_2.length; _i++) {
				var u = unionTypes_2[_i];
				for (var _a = 0, _b = u.types; _a < _b.length; _a++) {
					var t = _b[_a];
					if (insertType(checked, t)) {
						if (eachUnionContains(unionTypes, t)) {
							insertType(result, t);
						}
					}
				}
			}
			// Finally replace the first union with the result
			types[index] = getUnionTypeFromSortedList(
				result,
				ObjectFlags.PrimitiveUnion,
			);
			return true;
		}
		function createIntersectionType(types, aliasSymbol, aliasTypeArguments) {
			var result = createType(TypeFlags.Intersection);
			result.objectFlags = getPropagatingFlagsOfTypes(
				types, /*excludeKinds*/
				TypeFlags.Nullable,
			);
			result.types = types;
			result.aliasSymbol = aliasSymbol;
			result.aliasTypeArguments = aliasTypeArguments;
			return result;
		}
		// We normalize combinations of intersection and union types based on the distributive property of the '&'
		// operator. Specifically, because X & (A | B) is equivalent to X & A | X & B, we can transform intersection
		// types with union type constituents into equivalent union types with intersection type constituents and
		// effectively ensure that union types are always at the top level in type representations.
		//
		// We do not perform structural deduplication on intersection types. Intersection types are created only by the &
		// type operator and we can't reduce those because we want to support recursive intersection types. For example,
		// a type alias of the form "type List<T> = T & { next: List<T> }" cannot be reduced during its declaration.
		// Also, unlike union types, the order of the constituent types is preserved in order that overload resolution
		// for intersections of types with signatures can be deterministic.
		function getIntersectionType(types, aliasSymbol, aliasTypeArguments) {
			var typeMembershipMap = new Map();
			var includes = addTypesToIntersection(typeMembershipMap, 0, types);
			var typeSet = arrayFrom(typeMembershipMap.values());
			// An intersection type is considered empty if it contains
			// the type never, or
			// more than one unit type or,
			// an object type and a nullable type (null or undefined), or
			// a string-like type and a type known to be non-string-like, or
			// a number-like type and a type known to be non-number-like, or
			// a symbol-like type and a type known to be non-symbol-like, or
			// a void-like type and a type known to be non-void-like, or
			// a non-primitive type and a type known to be primitive.
			if (includes & TypeFlags.Never) {
				return contains(typeSet, silentNeverType) ? silentNeverType : neverType;
			}
			if (
				strictNullChecks && includes & TypeFlags.Nullable && includes & (TypeFlags.Object | TypeFlags.NonPrimitive | TypeFlags.IncludesEmptyObject) || includes & TypeFlags.NonPrimitive && includes & (TypeFlags.DisjointDomains & ~TypeFlags.NonPrimitive) || includes & TypeFlags.StringLike && includes & (TypeFlags.DisjointDomains & ~TypeFlags.StringLike) || includes & TypeFlags.NumberLike && includes & (TypeFlags.DisjointDomains & ~TypeFlags.NumberLike) || includes & TypeFlags.BigIntLike && includes & (TypeFlags.DisjointDomains & ~TypeFlags.BigIntLike) || includes & TypeFlags.ESSymbolLike && includes & (TypeFlags.DisjointDomains & ~TypeFlags.ESSymbolLike) || includes & TypeFlags.VoidLike && includes & (TypeFlags.DisjointDomains & ~TypeFlags.VoidLike)
			) {
				return neverType;
			}
			if (
				includes & TypeFlags.TemplateLiteral && includes & TypeFlags.StringLiteral && extractRedundantTemplateLiterals(
					typeSet,
				)
			) {
				return neverType;
			}
			if (includes & TypeFlags.Any) {
				return includes & TypeFlags.IncludesWildcard ? wildcardType : anyType;
			}
			if (!strictNullChecks && includes & TypeFlags.Nullable) {
				return includes & TypeFlags.Undefined ? undefinedType : nullType;
			}
			if (
				includes & TypeFlags.String && includes & TypeFlags.StringLiteral || includes & TypeFlags.Number && includes & TypeFlags.NumberLiteral || includes & TypeFlags.BigInt && includes & TypeFlags.BigIntLiteral || includes & TypeFlags.ESSymbol && includes & TypeFlags.UniqueESSymbol
			) {
				removeRedundantPrimitiveTypes(typeSet, includes);
			}
			if (
				includes & TypeFlags.IncludesEmptyObject && includes & TypeFlags.Object
			) {
				orderedRemoveItemAt(
					typeSet,
					findIndex(typeSet, isEmptyAnonymousObjectType),
				);
			}
			if (includes & TypeFlags.IncludesMissingType) {
				typeSet[typeSet.indexOf(undefinedType)] = missingType;
			}
			if (typeSet.length === 0) {
				return unknownType;
			}
			if (typeSet.length === 1) {
				return typeSet[0];
			}
			var id = getTypeListId(typeSet) + getAliasId(
				aliasSymbol,
				aliasTypeArguments,
			);
			var result = intersectionTypes.get(id);
			if (!result) {
				if (includes & TypeFlags.Union) {
					if (intersectUnionsOfPrimitiveTypes(typeSet)) {
						// When the intersection creates a reduced set (which might mean that *all* union types have
						// disappeared), we restart the operation to get a new set of combined flags. Once we have
						// reduced we'll never reduce again, so this occurs at most once.
						result = getIntersectionType(
							typeSet,
							aliasSymbol,
							aliasTypeArguments,
						);
					} else if (eachIsUnionContaining(typeSet, TypeFlags.Undefined)) {
						var undefinedOrMissingType = exactOptionalPropertyTypes && some(
							typeSet,
							function (t) {
								return containsType(t.types, missingType);
							},
						) ? missingType : undefinedType;
						removeFromEach(typeSet, TypeFlags.Undefined);
						result = getUnionType(
							[getIntersectionType(typeSet), undefinedOrMissingType],
							UnionReduction.Literal,
							aliasSymbol,
							aliasTypeArguments,
						);
					} else if (eachIsUnionContaining(typeSet, TypeFlags.Null)) {
						removeFromEach(typeSet, TypeFlags.Null);
						result = getUnionType(
							[getIntersectionType(typeSet), nullType],
							UnionReduction.Literal,
							aliasSymbol,
							aliasTypeArguments,
						);
					} else {
						// We are attempting to construct a type of the form X & (A | B) & (C | D). Transform this into a type of
						// the form X & A & C | X & A & D | X & B & C | X & B & D. If the estimated size of the resulting union type
						// exceeds 100000 constituents, report an error.
						if (!checkCrossProductUnion(typeSet)) {
							return errorType;
						}
						var constituents = getCrossProductIntersections(typeSet);
						// We attach a denormalized origin type when at least one constituent of the cross-product union is an
						// intersection (i.e. when the intersection didn't just reduce one or more unions to smaller unions).
						var origin_2 = some(
							constituents,
							function (t) {
								return !!(t.flags & TypeFlags.Intersection);
							},
						) ? createOriginUnionOrIntersectionType(
							TypeFlags.Intersection,
							typeSet,
						) : undefined;
						result = getUnionType(
							constituents,
							UnionReduction.Literal,
							aliasSymbol,
							aliasTypeArguments,
							origin_2,
						);
					}
				} else {
					result = createIntersectionType(
						typeSet,
						aliasSymbol,
						aliasTypeArguments,
					);
				}
				intersectionTypes.set(id, result);
			}
			return result;
		}
		function getCrossProductUnionSize(types) {
			return reduceLeft(
				types,
				function (n, t) {
					return t.flags & TypeFlags.Union ? n * t.types.length : t.flags & TypeFlags.Never ? 0 : n;
				},
				1,
			);
		}
		function checkCrossProductUnion(types) {
			var size = getCrossProductUnionSize(types);
			if (size >= 100000) {
				tracing === null || tracing === void 0 ? void 0 : tracing.instant(
					tracing.Phase.CheckTypes,
					"checkCrossProductUnion_DepthLimit",
					{
						typeIds: types.map(
							function (t) {
								return t.id;
							},
						),
						size: size,
					},
				);
				error(
					currentNode,
					Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent,
				);
				return false;
			}
			return true;
		}
		function getCrossProductIntersections(types) {
			var count = getCrossProductUnionSize(types);
			var intersections = [];
			for (var i = 0; i < count; i++) {
				var constituents = types.slice();
				var n = i;
				for (var j = types.length - 1; j >= 0; j--) {
					if (types[j].flags & TypeFlags.Union) {
						var sourceTypes = types[j].types;
						var length_4 = sourceTypes.length;
						constituents[j] = sourceTypes[n % length_4];
						n = Math.floor(n / length_4);
					}
				}
				var t = getIntersectionType(constituents);
				if (!(t.flags & TypeFlags.Never)) intersections.push(t);
			}
			return intersections;
		}
		function getTypeFromIntersectionTypeNode(node) {
			var links = getNodeLinks(node);
			if (!links.resolvedType) {
				var aliasSymbol = getAliasSymbolForTypeNode(node);
				links.resolvedType = getIntersectionType(
					map(node.types, getTypeFromTypeNode),
					aliasSymbol,
					getTypeArgumentsForAliasSymbol(aliasSymbol),
				);
			}
			return links.resolvedType;
		}
		function createIndexType(type, stringsOnly) {
			var result = createType(TypeFlags.Index);
			result.type = type;
			result.stringsOnly = stringsOnly;
			return result;
		}
		function createOriginIndexType(type) {
			var result = createOriginType(TypeFlags.Index);
			result.type = type;
			return result;
		}
		function getIndexTypeForGenericType(type, stringsOnly) {
			return stringsOnly ? type.resolvedStringIndexType || (type.resolvedStringIndexType = createIndexType(
				type, /*stringsOnly*/
				true,
			)) : type.resolvedIndexType || (type.resolvedIndexType = createIndexType(
				type, /*stringsOnly*/
				false,
			));
		}
		/**
         * This roughly mirrors `resolveMappedTypeMembers` in the nongeneric case, except only reports a union of the keys calculated,
         * rather than manufacturing the properties. We can't just fetch the `constraintType` since that would ignore mappings
         * and mapping the `constraintType` directly ignores how mapped types map _properties_ and not keys (thus ignoring subtype
         * reduction in the constraintType) when possible.
         * @param noIndexSignatures Indicates if _string_ index signatures should be elided. (other index signatures are always reported)
         */
		function getIndexTypeForMappedType(type, stringsOnly, noIndexSignatures) {
			var typeParameter = getTypeParameterFromMappedType(type);
			var constraintType = getConstraintTypeFromMappedType(type);
			var nameType = getNameTypeFromMappedType(type.target || type);
			if (!nameType && !noIndexSignatures) {
				// no mapping and no filtering required, just quickly bail to returning the constraint in the common case
				return constraintType;
			}
			var keyTypes = [];
			if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
				// We have a { [P in keyof T]: X }
				// `getApparentType` on the T in a generic mapped type can trigger a circularity
				// (conditionals and `infer` types create a circular dependency in the constraint resolution)
				// so we only eagerly manifest the keys if the constraint is nongeneric
				if (!isGenericIndexType(constraintType)) {
					var modifiersType = getApparentType(
						getModifiersTypeFromMappedType(type),
					); // The 'T' in 'keyof T'
					forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(
						modifiersType,
						TypeFlags.StringOrNumberLiteralOrUnique,
						stringsOnly,
						addMemberForKeyType,
					);
				} else {
					// we have a generic index and a homomorphic mapping (but a distributive key remapping) - we need to defer the whole `keyof whatever` for later
					// since it's not safe to resolve the shape of modifier type
					return getIndexTypeForGenericType(type, stringsOnly);
				}
			} else {
				forEachType(getLowerBoundOfKeyType(constraintType), addMemberForKeyType);
			}
			if (isGenericIndexType(constraintType)) {
				forEachType(constraintType, addMemberForKeyType); // include the generic component in the resulting type
			}
			// we had to pick apart the constraintType to potentially map/filter it - compare the final resulting list with the original constraintType,
			// so we can return the union that preserves aliases/origin data if possible
			var result = noIndexSignatures ? filterType(
				getUnionType(keyTypes),
				function (t) {
					return !(t.flags & (TypeFlags.Any | TypeFlags.String));
				},
			) : getUnionType(keyTypes);
			if (
				result.flags & TypeFlags.Union && constraintType.flags & TypeFlags.Union && getTypeListId(
					result.types,
				) === getTypeListId(constraintType.types)
			) {
				return constraintType;
			}
			return result;
			function addMemberForKeyType(keyType) {
				var propNameType = nameType ? instantiateType(
					nameType,
					appendTypeMapping(type.mapper, typeParameter, keyType),
				) : keyType;
				// `keyof` currently always returns `string | number` for concrete `string` index signatures - the below ternary keeps that behavior for mapped types
				// See `getLiteralTypeFromProperties` where there's a similar ternary to cause the same behavior.
				keyTypes.push(
					propNameType === stringType ? stringOrNumberType : propNameType,
				);
			}
		}
		// Ordinarily we reduce a keyof M, where M is a mapped type { [P in K as N<P>]: X }, to simply N<K>. This however presumes
		// that N distributes over union types, i.e. that N<A | B | C> is equivalent to N<A> | N<B> | N<C>. Specifically, we only
		// want to perform the reduction when the name type of a mapped type is distributive with respect to the type variable
		// introduced by the 'in' clause of the mapped type. Note that non-generic types are considered to be distributive because
		// they're the same type regardless of what's being distributed over.
		function hasDistributiveNameType(mappedType) {
			var typeVariable = getTypeParameterFromMappedType(mappedType);
			return isDistributive(
				getNameTypeFromMappedType(mappedType) || typeVariable,
			);
			function isDistributive(type) {
				return type.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Primitive | TypeFlags.Never | TypeFlags.TypeParameter | TypeFlags.Object | TypeFlags.NonPrimitive) ? true : type.flags & TypeFlags.Conditional ? type.root.isDistributive && type.checkType === typeVariable : type.flags & (TypeFlags.UnionOrIntersection | TypeFlags.TemplateLiteral) ? every(
					type.types,
					isDistributive,
				) : type.flags & TypeFlags.IndexedAccess ? isDistributive(
					type.objectType,
				) && isDistributive(type.indexType) : type.flags & TypeFlags.Substitution ? isDistributive(
					type.substitute,
				) : type.flags & TypeFlags.StringMapping ? isDistributive(type.type) : false;
			}
		}
		function getLiteralTypeFromPropertyName(name) {
			if (isPrivateIdentifier(name)) {
				return neverType;
			}
			return isIdentifier(name) ? getStringLiteralType(
				unescapeLeadingUnderscores(name.escapedText),
			) : getRegularTypeOfLiteralType(
				isComputedPropertyName(name) ? checkComputedPropertyName(name) : checkExpression(
					name,
				),
			);
		}
		function getLiteralTypeFromProperty(prop, include, includeNonPublic) {
			if (
				includeNonPublic || !(getDeclarationModifierFlagsFromSymbol(prop) & ModifierFlags.NonPublicAccessibilityModifier)
			) {
				var type = getSymbolLinks(getLateBoundSymbol(prop)).nameType;
				if (!type) {
					var name_15 = getNameOfDeclaration(prop.valueDeclaration);
					type = prop.escapedName === InternalSymbolName.Default ? getStringLiteralType(
						"default",
					) : name_15 && getLiteralTypeFromPropertyName(name_15) || (!isKnownSymbol(
						prop,
					) ? getStringLiteralType(symbolName(prop)) : undefined);
				}
				if (type && type.flags & include) {
					return type;
				}
			}
			return neverType;
		}
		function isKeyTypeIncluded(keyType, include) {
			return !!(keyType.flags & include || keyType.flags & TypeFlags.Intersection && some(
				keyType.types,
				function (t) {
					return isKeyTypeIncluded(t, include);
				},
			));
		}
		function getLiteralTypeFromProperties(type, include, includeOrigin) {
			var origin = includeOrigin && (getObjectFlags(type) & (ObjectFlags.ClassOrInterface | ObjectFlags.Reference) || type.aliasSymbol) ? createOriginIndexType(
				type,
			) : undefined;
			var propertyTypes = map(
				getPropertiesOfType(type),
				function (prop) {
					return getLiteralTypeFromProperty(prop, include);
				},
			);
			var indexKeyTypes = map(
				getIndexInfosOfType(type),
				function (info) {
					return info !== enumNumberIndexInfo && isKeyTypeIncluded(
						info.keyType,
						include,
					) ? info.keyType === stringType && include & TypeFlags.Number ? stringOrNumberType : info.keyType : neverType;
				},
			);
			return getUnionType(
				concatenate(propertyTypes, indexKeyTypes),
				UnionReduction.Literal,
				/*aliasSymbol*/ undefined, /*aliasTypeArguments*/
				undefined,
				origin,
			);
		}
		function getIndexType(type, stringsOnly, noIndexSignatures) {
			if (stringsOnly === void 0) {
				stringsOnly = keyofStringsOnly;
			}
			type = getReducedType(type);
			return type.flags & TypeFlags.Union ? getIntersectionType(
				map(
					type.types,
					function (t) {
						return getIndexType(t, stringsOnly, noIndexSignatures);
					},
				),
			) : type.flags & TypeFlags.Intersection ? getUnionType(
				map(
					type.types,
					function (t) {
						return getIndexType(t, stringsOnly, noIndexSignatures);
					},
				),
			) : type.flags & TypeFlags.InstantiableNonPrimitive || isGenericTupleType(
				type,
			) || isGenericMappedType(type) && !hasDistributiveNameType(type) ? getIndexTypeForGenericType(
				type,
				stringsOnly,
			) : getObjectFlags(type) & ObjectFlags.Mapped ? getIndexTypeForMappedType(
				type,
				stringsOnly,
				noIndexSignatures,
			) : type === wildcardType ? wildcardType : type.flags & TypeFlags.Unknown ? neverType : type.flags & (TypeFlags.Any | TypeFlags.Never) ? keyofConstraintType : getLiteralTypeFromProperties(
				type,
				(noIndexSignatures ? TypeFlags.StringLiteral : TypeFlags.StringLike) | (stringsOnly ? 0 : TypeFlags.NumberLike | TypeFlags.ESSymbolLike),
				stringsOnly === keyofStringsOnly && !noIndexSignatures,
			);
		}
		function getExtractStringType(type) {
			if (keyofStringsOnly) {
				return type;
			}
			var extractTypeAlias = getGlobalExtractSymbol();
			return extractTypeAlias ? getTypeAliasInstantiation(
				extractTypeAlias,
				[type, stringType],
			) : stringType;
		}
		function getIndexTypeOrString(type) {
			var indexType = getExtractStringType(getIndexType(type));
			return indexType.flags & TypeFlags.Never ? stringType : indexType;
		}
		function getTypeFromTypeOperatorNode(node) {
			var links = getNodeLinks(node);
			if (!links.resolvedType) {
				switch (node.operator) {
					case SyntaxKind.KeyOfKeyword:
						links.resolvedType = getIndexType(getTypeFromTypeNode(node.type));
						break;
					case SyntaxKind.UniqueKeyword:
						links.resolvedType = node.type.kind === SyntaxKind.SymbolKeyword ? getESSymbolLikeTypeForNode(
							walkUpParenthesizedTypes(node.parent),
						) : errorType;
						break;
					case SyntaxKind.ReadonlyKeyword:
						links.resolvedType = getTypeFromTypeNode(node.type);
						break;
					default:
						throw Debug.assertNever(node.operator);
				}
			}
			return links.resolvedType;
		}
		function getTypeFromTemplateTypeNode(node) {
			var links = getNodeLinks(node);
			if (!links.resolvedType) {
				links.resolvedType = getTemplateLiteralType(
					__spreadArray(
						[node.head.text],
						map(
							node.templateSpans,
							function (span) {
								return span.literal.text;
							},
						),
						true,
					),
					map(
						node.templateSpans,
						function (span) {
							return getTypeFromTypeNode(span.type);
						},
					),
				);
			}
			return links.resolvedType;
		}
		function getTemplateLiteralType(texts, types) {
			var unionIndex = findIndex(
				types,
				function (t) {
					return !!(t.flags & (TypeFlags.Never | TypeFlags.Union));
				},
			);
			if (unionIndex >= 0) {
				return checkCrossProductUnion(types) ? mapType(
					types[unionIndex],
					function (t) {
						return getTemplateLiteralType(
							texts,
							replaceElement(types, unionIndex, t),
						);
					},
				) : errorType;
			}
			if (contains(types, wildcardType)) {
				return wildcardType;
			}
			var newTypes = [];
			var newTexts = [];
			var text = texts[0];
			if (!addSpans(texts, types)) {
				return stringType;
			}
			if (newTypes.length === 0) {
				return getStringLiteralType(text);
			}
			newTexts.push(text);
			if (
				every(
					newTexts,
					function (t) {
						return t === "";
					},
				) && every(
					newTypes,
					function (t) {
						return !!(t.flags & TypeFlags.String);
					},
				)
			) {
				return stringType;
			}
			var id = "".concat(getTypeListId(newTypes), "|").concat(
				map(
					newTexts,
					function (t) {
						return t.length;
					},
				).join(","),
				"|",
			).concat(newTexts.join(""));
			var type = templateLiteralTypes.get(id);
			if (!type) {
				templateLiteralTypes.set(
					id,
					type = createTemplateLiteralType(newTexts, newTypes),
				);
			}
			return type;
			function addSpans(texts, types) {
				for (var i = 0; i < types.length; i++) {
					var t = types[i];
					if (
						t.flags & (TypeFlags.Literal | TypeFlags.Null | TypeFlags.Undefined)
					) {
						text += getTemplateStringForType(t) || "";
						text += texts[i + 1];
					} else if (t.flags & TypeFlags.TemplateLiteral) {
						text += t.texts[0];
						if (!addSpans(t.texts, t.types)) return false;
						text += texts[i + 1];
					} else if (
						isGenericIndexType(t) || isPatternLiteralPlaceholderType(t)
					) {
						newTypes.push(t);
						newTexts.push(text);
						text = texts[i + 1];
					} else {
						return false;
					}
				}
				return true;
			}
		}
		function getTemplateStringForType(type) {
			return type.flags & TypeFlags.StringLiteral ? type.value : type.flags & TypeFlags.NumberLiteral ? "" + type.value : type.flags & TypeFlags.BigIntLiteral ? pseudoBigIntToString(
				type.value,
			) : type.flags & (TypeFlags.BooleanLiteral | TypeFlags.Nullable) ? type.intrinsicName : undefined;
		}
		function createTemplateLiteralType(texts, types) {
			var type = createType(TypeFlags.TemplateLiteral);
			type.texts = texts;
			type.types = types;
			return type;
		}
		function getStringMappingType(symbol, type) {
			return type.flags & (TypeFlags.Union | TypeFlags.Never) ? mapType(
				type,
				function (t) {
					return getStringMappingType(symbol, t);
				},
			) : isGenericIndexType(type) ? getStringMappingTypeForGenericType(
				symbol,
				type,
			) : type.flags & TypeFlags.StringLiteral ? getStringLiteralType(
				applyStringMapping(symbol, type.value),
			) : type;
		}
		function applyStringMapping(symbol, str) {
			switch (intrinsicTypeKinds.get(symbol.escapedName)) {
				case 0: /* Uppercase */
					return str.toUpperCase();
				case 1: /* Lowercase */
					return str.toLowerCase();
				case 2: /* Capitalize */
					return str.charAt(0).toUpperCase() + str.slice(1);
				case 3: /* Uncapitalize */
					return str.charAt(0).toLowerCase() + str.slice(1);
			}
			return str;
		}
		function getStringMappingTypeForGenericType(symbol, type) {
			var id = "".concat(getSymbolId(symbol), ",").concat(getTypeId(type));
			var result = stringMappingTypes.get(id);
			if (!result) {
				stringMappingTypes.set(
					id,
					result = createStringMappingType(symbol, type),
				);
			}
			return result;
		}
		function createStringMappingType(symbol, type) {
			var result = createType(TypeFlags.StringMapping);
			result.symbol = symbol;
			result.type = type;
			return result;
		}
		function createIndexedAccessType(
			objectType,
			indexType,
			accessFlags,
			aliasSymbol,
			aliasTypeArguments,
		) {
			var type = createType(TypeFlags.IndexedAccess);
			type.objectType = objectType;
			type.indexType = indexType;
			type.accessFlags = accessFlags;
			type.aliasSymbol = aliasSymbol;
			type.aliasTypeArguments = aliasTypeArguments;
			return type;
		}
		/**
         * Returns if a type is or consists of a JSLiteral object type
         * In addition to objects which are directly literals,
         * * unions where every element is a jsliteral
         * * intersections where at least one element is a jsliteral
         * * and instantiable types constrained to a jsliteral
         * Should all count as literals and not print errors on access or assignment of possibly existing properties.
         * This mirrors the behavior of the index signature propagation, to which this behaves similarly (but doesn't affect assignability or inference).
         */
		function isJSLiteralType(type) {
			if (noImplicitAny) {
				return false; // Flag is meaningless under `noImplicitAny` mode
			}
			if (getObjectFlags(type) & ObjectFlags.JSLiteral) {
				return true;
			}
			if (type.flags & TypeFlags.Union) {
				return every(type.types, isJSLiteralType);
			}
			if (type.flags & TypeFlags.Intersection) {
				return some(type.types, isJSLiteralType);
			}
			if (type.flags & TypeFlags.Instantiable) {
				var constraint = getResolvedBaseConstraint(type);
				return constraint !== type && isJSLiteralType(constraint);
			}
			return false;
		}
		function getPropertyNameFromIndex(indexType, accessNode) {
			return isTypeUsableAsPropertyName(indexType) ? getPropertyNameFromType(
				indexType,
			) : accessNode && isPropertyName(accessNode) ? getPropertyNameForPropertyNameNode(
				accessNode, // late bound names are handled in the first branch, so here we only need to handle normal names
			) : undefined;
		}
		function isUncalledFunctionReference(node, symbol) {
			if (symbol.flags & (SymbolFlags.Function | SymbolFlags.Method)) {
				var parent_8 = findAncestor(
					node.parent,
					function (n) {
						return !isAccessExpression(n);
					},
				) || node.parent;
				if (isCallLikeExpression(parent_8)) {
					return isCallOrNewExpression(parent_8) && isIdentifier(node) && hasMatchingArgument(
						parent_8,
						node,
					);
				}
				return every(
					symbol.declarations,
					function (d) {
						return !isFunctionLike(d) || !!(getCombinedNodeFlags(d) & NodeFlags.Deprecated);
					},
				);
			}
			return true;
		}
		function getPropertyTypeForIndexType(
			originalObjectType,
			objectType,
			indexType,
			fullIndexType,
			accessNode,
			accessFlags,
		) {
			var _a;
			var accessExpression = accessNode && accessNode.kind === SyntaxKind.ElementAccessExpression ? accessNode : undefined;
			var propName = accessNode && isPrivateIdentifier(accessNode) ? undefined : getPropertyNameFromIndex(
				indexType,
				accessNode,
			);
			if (propName !== undefined) {
				if (accessFlags & AccessFlags.Contextual) {
					return getTypeOfPropertyOfContextualType(objectType, propName) || anyType;
				}
				var prop = getPropertyOfType(objectType, propName);
				if (prop) {
					if (
						accessFlags & AccessFlags.ReportDeprecated && accessNode && prop.declarations && getDeclarationNodeFlagsFromSymbol(
							prop,
						) & NodeFlags.Deprecated && isUncalledFunctionReference(
							accessNode,
							prop,
						)
					) {
						var deprecatedNode = (_a = accessExpression === null || accessExpression === void 0 ? void 0 : accessExpression.argumentExpression) !== null && _a !== void 0 ? _a : (isIndexedAccessTypeNode(
							accessNode,
						) ? accessNode.indexType : accessNode);
						addDeprecatedSuggestion(deprecatedNode, prop.declarations, propName);
					}
					if (accessExpression) {
						markPropertyAsReferenced(
							prop,
							accessExpression,
							isSelfTypeAccess(accessExpression.expression, objectType.symbol),
						);
						if (
							isAssignmentToReadonlyEntity(
								accessExpression,
								prop,
								getAssignmentTargetKind(accessExpression),
							)
						) {
							error(
								accessExpression.argumentExpression,
								Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property,
								symbolToString(prop),
							);
							return undefined;
						}
						if (accessFlags & AccessFlags.CacheSymbol) {
							getNodeLinks(accessNode).resolvedSymbol = prop;
						}
						if (isThisPropertyAccessInConstructor(accessExpression, prop)) {
							return autoType;
						}
					}
					var propType = getTypeOfSymbol(prop);
					return accessExpression && getAssignmentTargetKind(accessExpression) !== AssignmentKind.Definite ? getFlowTypeOfReference(
						accessExpression,
						propType,
					) : propType;
				}
				if (
					everyType(objectType, isTupleType) && isNumericLiteralName(propName) && +propName >= 0
				) {
					if (
						accessNode && everyType(
							objectType,
							function (t) {
								return !t.target.hasRestElement;
							},
						) && !(accessFlags & AccessFlags.NoTupleBoundsCheck)
					) {
						var indexNode = getIndexNodeForAccessExpression(accessNode);
						if (isTupleType(objectType)) {
							error(
								indexNode,
								Diagnostics.Tuple_type_0_of_length_1_has_no_element_at_index_2,
								typeToString(objectType),
								getTypeReferenceArity(objectType),
								unescapeLeadingUnderscores(propName),
							);
						} else {
							error(
								indexNode,
								Diagnostics.Property_0_does_not_exist_on_type_1,
								unescapeLeadingUnderscores(propName),
								typeToString(objectType),
							);
						}
					}
					errorIfWritingToReadonlyIndex(
						getIndexInfoOfType(objectType, numberType),
					);
					return mapType(
						objectType,
						function (t) {
							var restType = getRestTypeOfTupleType(t) || undefinedType;
							return accessFlags & AccessFlags.IncludeUndefined ? getUnionType(
								[restType, undefinedType],
							) : restType;
						},
					);
				}
			}
			if (
				!(indexType.flags & TypeFlags.Nullable) && isTypeAssignableToKind(
					indexType,
					TypeFlags.StringLike | TypeFlags.NumberLike | TypeFlags.ESSymbolLike,
				)
			) {
				if (objectType.flags & (TypeFlags.Any | TypeFlags.Never)) {
					return objectType;
				}
				// If no index signature is applicable, we default to the string index signature. In effect, this means the string
				// index signature applies even when accessing with a symbol-like type.
				var indexInfo = getApplicableIndexInfo(objectType, indexType) || getIndexInfoOfType(
					objectType,
					stringType,
				);
				if (indexInfo) {
					if (
						accessFlags & AccessFlags.NoIndexSignatures && indexInfo.keyType !== numberType
					) {
						if (accessExpression) {
							error(
								accessExpression,
								Diagnostics.Type_0_cannot_be_used_to_index_type_1,
								typeToString(indexType),
								typeToString(originalObjectType),
							);
						}
						return undefined;
					}
					if (
						accessNode && indexInfo.keyType === stringType && !isTypeAssignableToKind(
							indexType,
							TypeFlags.String | TypeFlags.Number,
						)
					) {
						var indexNode = getIndexNodeForAccessExpression(accessNode);
						error(
							indexNode,
							Diagnostics.Type_0_cannot_be_used_as_an_index_type,
							typeToString(indexType),
						);
						return accessFlags & AccessFlags.IncludeUndefined ? getUnionType(
							[indexInfo.type, undefinedType],
						) : indexInfo.type;
					}
					errorIfWritingToReadonlyIndex(indexInfo);
					return accessFlags & AccessFlags.IncludeUndefined ? getUnionType(
						[indexInfo.type, undefinedType],
					) : indexInfo.type;
				}
				if (indexType.flags & TypeFlags.Never) {
					return neverType;
				}
				if (isJSLiteralType(objectType)) {
					return anyType;
				}
				if (accessExpression && !isConstEnumObjectType(objectType)) {
					if (isObjectLiteralType(objectType)) {
						if (
							noImplicitAny && indexType.flags & (TypeFlags.StringLiteral | TypeFlags.NumberLiteral)
						) {
							diagnostics.add(
								createDiagnosticForNode(
									accessExpression,
									Diagnostics.Property_0_does_not_exist_on_type_1,
									indexType.value,
									typeToString(objectType),
								),
							);
							return undefinedType;
						} else if (indexType.flags & (TypeFlags.Number | TypeFlags.String)) {
							var types = map(
								objectType.properties,
								function (property) {
									return getTypeOfSymbol(property);
								},
							);
							return getUnionType(append(types, undefinedType));
						}
					}
					if (
						objectType.symbol === globalThisSymbol && propName !== undefined && globalThisSymbol.exports.has(
							propName,
						) && (globalThisSymbol.exports.get(propName).flags & SymbolFlags.BlockScoped)
					) {
						error(
							accessExpression,
							Diagnostics.Property_0_does_not_exist_on_type_1,
							unescapeLeadingUnderscores(propName),
							typeToString(objectType),
						);
					} else if (
						noImplicitAny && !compilerOptions.suppressImplicitAnyIndexErrors && !(accessFlags & AccessFlags.SuppressNoImplicitAnyError)
					) {
						if (
							propName !== undefined && typeHasStaticProperty(
								propName,
								objectType,
							)
						) {
							var typeName = typeToString(objectType);
							error(
								accessExpression,
								Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead,
								propName,
								typeName,
								typeName + "[" + getTextOfNode(
									accessExpression.argumentExpression,
								) + "]",
							);
						} else if (getIndexTypeOfType(objectType, numberType)) {
							error(
								accessExpression.argumentExpression,
								Diagnostics.Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number,
							);
						} else {
							var suggestion = void 0;
							if (
								propName !== undefined && (suggestion = getSuggestionForNonexistentProperty(
									propName,
									objectType,
								))
							) {
								if (suggestion !== undefined) {
									error(
										accessExpression.argumentExpression,
										Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2,
										propName,
										typeToString(objectType),
										suggestion,
									);
								}
							} else {
								var suggestion_1 = getSuggestionForNonexistentIndexSignature(
									objectType,
									accessExpression,
									indexType,
								);
								if (suggestion_1 !== undefined) {
									error(
										accessExpression,
										Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1,
										typeToString(objectType),
										suggestion_1,
									);
								} else {
									var errorInfo = void 0;
									if (indexType.flags & TypeFlags.EnumLiteral) {
										errorInfo = chainDiagnosticMessages(
											undefined, /* details */
											Diagnostics.Property_0_does_not_exist_on_type_1,
											"[" + typeToString(indexType) + "]",
											typeToString(objectType),
										);
									} else if (indexType.flags & TypeFlags.UniqueESSymbol) {
										var symbolName = getFullyQualifiedName(
											indexType.symbol,
											accessExpression,
										);
										errorInfo = chainDiagnosticMessages(
											undefined, /* details */
											Diagnostics.Property_0_does_not_exist_on_type_1,
											"[" + symbolName + "]",
											typeToString(objectType),
										);
									} else if (indexType.flags & TypeFlags.StringLiteral) {
										errorInfo = chainDiagnosticMessages(
											undefined, /* details */
											Diagnostics.Property_0_does_not_exist_on_type_1,
											indexType.value,
											typeToString(objectType),
										);
									} else if (indexType.flags & TypeFlags.NumberLiteral) {
										errorInfo = chainDiagnosticMessages(
											undefined, /* details */
											Diagnostics.Property_0_does_not_exist_on_type_1,
											indexType.value,
											typeToString(objectType),
										);
									} else if (
										indexType.flags & (TypeFlags.Number | TypeFlags.String)
									) {
										errorInfo = chainDiagnosticMessages(
											undefined, /* details */
											Diagnostics.No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1,
											typeToString(indexType),
											typeToString(objectType),
										);
									}
									errorInfo = chainDiagnosticMessages(
										errorInfo,
										Diagnostics.Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1,
										typeToString(fullIndexType),
										typeToString(objectType),
									);
									diagnostics.add(
										createDiagnosticForNodeFromMessageChain(
											accessExpression,
											errorInfo,
										),
									);
								}
							}
						}
					}
					return undefined;
				}
			}
			if (isJSLiteralType(objectType)) {
				return anyType;
			}
			if (accessNode) {
				var indexNode = getIndexNodeForAccessExpression(accessNode);
				if (
					indexType.flags & (TypeFlags.StringLiteral | TypeFlags.NumberLiteral)
				) {
					error(
						indexNode,
						Diagnostics.Property_0_does_not_exist_on_type_1,
						"" + indexType.value,
						typeToString(objectType),
					);
				} else if (indexType.flags & (TypeFlags.String | TypeFlags.Number)) {
					error(
						indexNode,
						Diagnostics.Type_0_has_no_matching_index_signature_for_type_1,
						typeToString(objectType),
						typeToString(indexType),
					);
				} else {
					error(
						indexNode,
						Diagnostics.Type_0_cannot_be_used_as_an_index_type,
						typeToString(indexType),
					);
				}
			}
			if (isTypeAny(indexType)) {
				return indexType;
			}
			return undefined;
			function errorIfWritingToReadonlyIndex(indexInfo) {
				if (
					indexInfo && indexInfo.isReadonly && accessExpression && (isAssignmentTarget(
						accessExpression,
					) || isDeleteTarget(accessExpression))
				) {
					error(
						accessExpression,
						Diagnostics.Index_signature_in_type_0_only_permits_reading,
						typeToString(objectType),
					);
				}
			}
		}
		function getIndexNodeForAccessExpression(accessNode) {
			return accessNode.kind === SyntaxKind.ElementAccessExpression ? accessNode.argumentExpression : accessNode.kind === SyntaxKind.IndexedAccessType ? accessNode.indexType : accessNode.kind === SyntaxKind.ComputedPropertyName ? accessNode.expression : accessNode;
		}
		function isPatternLiteralPlaceholderType(type) {
			return !!(type.flags & (TypeFlags.Any | TypeFlags.String | TypeFlags.Number | TypeFlags.BigInt));
		}
		function isPatternLiteralType(type) {
			return !!(type.flags & TypeFlags.TemplateLiteral) && every(
				type.types,
				isPatternLiteralPlaceholderType,
			);
		}
		function isGenericType(type) {
			return !!getGenericObjectFlags(type);
		}
		function isGenericObjectType(type) {
			return !!(getGenericObjectFlags(type) & ObjectFlags.IsGenericObjectType);
		}
		function isGenericIndexType(type) {
			return !!(getGenericObjectFlags(type) & ObjectFlags.IsGenericIndexType);
		}
		function getGenericObjectFlags(type) {
			if (type.flags & TypeFlags.UnionOrIntersection) {
				if (!(type.objectFlags & ObjectFlags.IsGenericTypeComputed)) {
					type.objectFlags |= ObjectFlags.IsGenericTypeComputed | reduceLeft(
						type.types,
						function (flags, t) {
							return flags | getGenericObjectFlags(t);
						},
						0,
					);
				}
				return type.objectFlags & ObjectFlags.IsGenericType;
			}
			if (type.flags & TypeFlags.Substitution) {
				if (!(type.objectFlags & ObjectFlags.IsGenericTypeComputed)) {
					type.objectFlags |= ObjectFlags.IsGenericTypeComputed | getGenericObjectFlags(
						type.substitute,
					) | getGenericObjectFlags(type.baseType);
				}
				return type.objectFlags & ObjectFlags.IsGenericType;
			}
			return (type.flags & TypeFlags.InstantiableNonPrimitive || isGenericMappedType(
				type,
			) || isGenericTupleType(type) ? ObjectFlags.IsGenericObjectType : 0) | (type.flags & (TypeFlags.InstantiableNonPrimitive | TypeFlags.Index | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) && !isPatternLiteralType(
				type,
			) ? ObjectFlags.IsGenericIndexType : 0);
		}
		function getSimplifiedType(type, writing) {
			return type.flags & TypeFlags.IndexedAccess ? getSimplifiedIndexedAccessType(
				type,
				writing,
			) : type.flags & TypeFlags.Conditional ? getSimplifiedConditionalType(
				type,
				writing,
			) : type;
		}
		function distributeIndexOverObjectType(objectType, indexType, writing) {
			// (T | U)[K] -> T[K] | U[K] (reading)
			// (T | U)[K] -> T[K] & U[K] (writing)
			// (T & U)[K] -> T[K] & U[K]
			if (objectType.flags & TypeFlags.UnionOrIntersection) {
				var types = map(
					objectType.types,
					function (t) {
						return getSimplifiedType(
							getIndexedAccessType(t, indexType),
							writing,
						);
					},
				);
				return objectType.flags & TypeFlags.Intersection || writing ? getIntersectionType(
					types,
				) : getUnionType(types);
			}
		}
		function distributeObjectOverIndexType(objectType, indexType, writing) {
			// T[A | B] -> T[A] | T[B] (reading)
			// T[A | B] -> T[A] & T[B] (writing)
			if (indexType.flags & TypeFlags.Union) {
				var types = map(
					indexType.types,
					function (t) {
						return getSimplifiedType(
							getIndexedAccessType(objectType, t),
							writing,
						);
					},
				);
				return writing ? getIntersectionType(types) : getUnionType(types);
			}
		}
		// Transform an indexed access to a simpler form, if possible. Return the simpler form, or return
		// the type itself if no transformation is possible. The writing flag indicates that the type is
		// the target of an assignment.
		function getSimplifiedIndexedAccessType(type, writing) {
			var cache = writing ? "simplifiedForWriting" : "simplifiedForReading";
			if (type[cache]) {
				return type[cache] === circularConstraintType ? type : type[cache];
			}
			type[cache] = circularConstraintType;
			// We recursively simplify the object type as it may in turn be an indexed access type. For example, with
			// '{ [P in T]: { [Q in U]: number } }[T][U]' we want to first simplify the inner indexed access type.
			var objectType = getSimplifiedType(type.objectType, writing);
			var indexType = getSimplifiedType(type.indexType, writing);
			// T[A | B] -> T[A] | T[B] (reading)
			// T[A | B] -> T[A] & T[B] (writing)
			var distributedOverIndex = distributeObjectOverIndexType(
				objectType,
				indexType,
				writing,
			);
			if (distributedOverIndex) {
				return type[cache] = distributedOverIndex;
			}
			// Only do the inner distributions if the index can no longer be instantiated to cause index distribution again
			if (!(indexType.flags & TypeFlags.Instantiable)) {
				// (T | U)[K] -> T[K] | U[K] (reading)
				// (T | U)[K] -> T[K] & U[K] (writing)
				// (T & U)[K] -> T[K] & U[K]
				var distributedOverObject = distributeIndexOverObjectType(
					objectType,
					indexType,
					writing,
				);
				if (distributedOverObject) {
					return type[cache] = distributedOverObject;
				}
			}
			// So ultimately (reading):
			// ((A & B) | C)[K1 | K2] -> ((A & B) | C)[K1] | ((A & B) | C)[K2] -> (A & B)[K1] | C[K1] | (A & B)[K2] | C[K2] -> (A[K1] & B[K1]) | C[K1] | (A[K2] & B[K2]) | C[K2]
			// A generic tuple type indexed by a number exists only when the index type doesn't select a
			// fixed element. We simplify to either the combined type of all elements (when the index type
			// the actual number type) or to the combined type of all non-fixed elements.
			if (
				isGenericTupleType(objectType) && indexType.flags & TypeFlags.NumberLike
			) {
				var elementType = getElementTypeOfSliceOfTupleType(
					objectType,
					indexType.flags & TypeFlags.Number ? 0 : objectType.target.fixedLength, /*endSkipCount*/
					0,
					writing,
				);
				if (elementType) {
					return type[cache] = elementType;
				}
			}
			// If the object type is a mapped type { [P in K]: E }, where K is generic, instantiate E using a mapper
			// that substitutes the index type for P. For example, for an index access { [P in K]: Box<T[P]> }[X], we
			// construct the type Box<T[X]>.
			if (isGenericMappedType(objectType)) {
				return type[cache] = mapType(
					substituteIndexedMappedType(objectType, type.indexType),
					function (t) {
						return getSimplifiedType(t, writing);
					},
				);
			}
			return type[cache] = type;
		}
		function getSimplifiedConditionalType(type, writing) {
			var checkType = type.checkType;
			var extendsType = type.extendsType;
			var trueType = getTrueTypeFromConditionalType(type);
			var falseType = getFalseTypeFromConditionalType(type);
			// Simplifications for types of the form `T extends U ? T : never` and `T extends U ? never : T`.
			if (
				falseType.flags & TypeFlags.Never && getActualTypeVariable(trueType) === getActualTypeVariable(
					checkType,
				)
			) {
				if (
					checkType.flags & TypeFlags.Any || isTypeAssignableTo(
						getRestrictiveInstantiation(checkType),
						getRestrictiveInstantiation(extendsType),
					)
				) {
					return getSimplifiedType(trueType, writing); // Always true
				} else if (isIntersectionEmpty(checkType, extendsType)) {
					return neverType; // Always false
				}
			} else if (
				trueType.flags & TypeFlags.Never && getActualTypeVariable(falseType) === getActualTypeVariable(
					checkType,
				)
			) {
				if (
					!(checkType.flags & TypeFlags.Any) && isTypeAssignableTo(
						getRestrictiveInstantiation(checkType),
						getRestrictiveInstantiation(extendsType),
					)
				) {
					return neverType; // Always true
				} else if (
					checkType.flags & TypeFlags.Any || isIntersectionEmpty(
						checkType,
						extendsType,
					)
				) {
					return getSimplifiedType(falseType, writing); // Always false
				}
			}
			return type;
		}
		/**
         * Invokes union simplification logic to determine if an intersection is considered empty as a union constituent
         */
		function isIntersectionEmpty(type1, type2) {
			return !!(getUnionType([intersectTypes(type1, type2), neverType]).flags & TypeFlags.Never);
		}
		function substituteIndexedMappedType(objectType, index) {
			var mapper = createTypeMapper(
				[getTypeParameterFromMappedType(objectType)],
				[index],
			);
			var templateMapper = combineTypeMappers(objectType.mapper, mapper);
			return instantiateType(
				getTemplateTypeFromMappedType(objectType),
				templateMapper,
			);
		}
		function getIndexedAccessType(
			objectType,
			indexType,
			accessFlags,
			accessNode,
			aliasSymbol,
			aliasTypeArguments,
		) {
			if (accessFlags === void 0) {
				accessFlags = AccessFlags.None;
			}
			return getIndexedAccessTypeOrUndefined(
				objectType,
				indexType,
				accessFlags,
				accessNode,
				aliasSymbol,
				aliasTypeArguments,
			) || (accessNode ? errorType : unknownType);
		}
		function indexTypeLessThan(indexType, limit) {
			return everyType(
				indexType,
				function (t) {
					if (t.flags & TypeFlags.StringOrNumberLiteral) {
						var propName = getPropertyNameFromType(t);
						if (isNumericLiteralName(propName)) {
							var index = +propName;
							return index >= 0 && index < limit;
						}
					}
					return false;
				},
			);
		}
		function getIndexedAccessTypeOrUndefined(
			objectType,
			indexType,
			accessFlags,
			accessNode,
			aliasSymbol,
			aliasTypeArguments,
		) {
			if (accessFlags === void 0) {
				accessFlags = AccessFlags.None;
			}
			if (objectType === wildcardType || indexType === wildcardType) {
				return wildcardType;
			}
			// If the object type has a string index signature and no other members we know that the result will
			// always be the type of that index signature and we can simplify accordingly.
			if (
				isStringIndexSignatureOnlyType(objectType) && !(indexType.flags & TypeFlags.Nullable) && isTypeAssignableToKind(
					indexType,
					TypeFlags.String | TypeFlags.Number,
				)
			) {
				indexType = stringType;
			}
			// In noUncheckedIndexedAccess mode, indexed access operations that occur in an expression in a read position and resolve to
			// an index signature have 'undefined' included in their type.
			if (
				compilerOptions.noUncheckedIndexedAccess && accessFlags & AccessFlags.ExpressionPosition
			) accessFlags |= AccessFlags.IncludeUndefined;
			// If the index type is generic, or if the object type is generic and doesn't originate in an expression and
			// the operation isn't exclusively indexing the fixed (non-variadic) portion of a tuple type, we are performing
			// a higher-order index access where we cannot meaningfully access the properties of the object type. Note that
			// for a generic T and a non-generic K, we eagerly resolve T[K] if it originates in an expression. This is to
			// preserve backwards compatibility. For example, an element access 'this["foo"]' has always been resolved
			// eagerly using the constraint type of 'this' at the given location.
			if (
				isGenericIndexType(indexType) || (accessNode && accessNode.kind !== SyntaxKind.IndexedAccessType ? isGenericTupleType(
					objectType,
				) && !indexTypeLessThan(indexType, objectType.target.fixedLength) : isGenericObjectType(
					objectType,
				) && !(isTupleType(objectType) && indexTypeLessThan(
					indexType,
					objectType.target.fixedLength,
				)))
			) {
				if (objectType.flags & TypeFlags.AnyOrUnknown) {
					return objectType;
				}
				// Defer the operation by creating an indexed access type.
				var persistentAccessFlags = accessFlags & AccessFlags.Persistent;
				var id = objectType.id + "," + indexType.id + "," + persistentAccessFlags + getAliasId(
					aliasSymbol,
					aliasTypeArguments,
				);
				var type = indexedAccessTypes.get(id);
				if (!type) {
					indexedAccessTypes.set(
						id,
						type = createIndexedAccessType(
							objectType,
							indexType,
							persistentAccessFlags,
							aliasSymbol,
							aliasTypeArguments,
						),
					);
				}
				return type;
			}
			// In the following we resolve T[K] to the type of the property in T selected by K.
			// We treat boolean as different from other unions to improve errors;
			// skipping straight to getPropertyTypeForIndexType gives errors with 'boolean' instead of 'true'.
			var apparentObjectType = getReducedApparentType(objectType);
			if (
				indexType.flags & TypeFlags.Union && !(indexType.flags & TypeFlags.Boolean)
			) {
				var propTypes = [];
				var wasMissingProp = false;
				for (var _i = 0, _a = indexType.types; _i < _a.length; _i++) {
					var t = _a[_i];
					var propType = getPropertyTypeForIndexType(
						objectType,
						apparentObjectType,
						t,
						indexType,
						accessNode,
						accessFlags | (wasMissingProp ? AccessFlags.SuppressNoImplicitAnyError : 0),
					);
					if (propType) {
						propTypes.push(propType);
					} else if (!accessNode) {
						// If there's no error node, we can immeditely stop, since error reporting is off
						return undefined;
					} else {
						// Otherwise we set a flag and return at the end of the loop so we still mark all errors
						wasMissingProp = true;
					}
				}
				if (wasMissingProp) {
					return undefined;
				}
				return accessFlags & AccessFlags.Writing ? getIntersectionType(
					propTypes,
					aliasSymbol,
					aliasTypeArguments,
				) : getUnionType(
					propTypes,
					UnionReduction.Literal,
					aliasSymbol,
					aliasTypeArguments,
				);
			}
			return getPropertyTypeForIndexType(
				objectType,
				apparentObjectType,
				indexType,
				indexType,
				accessNode,
				accessFlags | AccessFlags.CacheSymbol | AccessFlags.ReportDeprecated,
			);
		}
		function getTypeFromIndexedAccessTypeNode(node) {
			var links = getNodeLinks(node);
			if (!links.resolvedType) {
				var objectType = getTypeFromTypeNode(node.objectType);
				var indexType = getTypeFromTypeNode(node.indexType);
				var potentialAlias = getAliasSymbolForTypeNode(node);
				var resolved = getIndexedAccessType(
					objectType,
					indexType,
					AccessFlags.None,
					node,
					potentialAlias,
					getTypeArgumentsForAliasSymbol(potentialAlias),
				);
				links.resolvedType = resolved.flags & TypeFlags.IndexedAccess && resolved.objectType === objectType && resolved.indexType === indexType ? getConditionalFlowTypeOfType(
					resolved,
					node,
				) : resolved;
			}
			return links.resolvedType;
		}
		function getTypeFromMappedTypeNode(node) {
			var links = getNodeLinks(node);
			if (!links.resolvedType) {
				var type = createObjectType(ObjectFlags.Mapped, node.symbol);
				type.declaration = node;
				type.aliasSymbol = getAliasSymbolForTypeNode(node);
				type.aliasTypeArguments = getTypeArgumentsForAliasSymbol(
					type.aliasSymbol,
				);
				links.resolvedType = type;
				// Eagerly resolve the constraint type which forces an error if the constraint type circularly
				// references itself through one or more type aliases.
				getConstraintTypeFromMappedType(type);
			}
			return links.resolvedType;
		}
		function getActualTypeVariable(type) {
			if (type.flags & TypeFlags.Substitution) {
				return type.baseType;
			}
			if (
				type.flags & TypeFlags.IndexedAccess && (type.objectType.flags & TypeFlags.Substitution || type.indexType.flags & TypeFlags.Substitution)
			) {
				return getIndexedAccessType(
					getActualTypeVariable(type.objectType),
					getActualTypeVariable(type.indexType),
				);
			}
			return type;
		}
		function isTypicalNondistributiveConditional(root) {
			return !root.isDistributive && isSingletonTupleType(root.node.checkType) && isSingletonTupleType(
				root.node.extendsType,
			);
		}
		function isSingletonTupleType(node) {
			return isTupleTypeNode(node) && length(node.elements) === 1 && !isOptionalTypeNode(
				node.elements[0],
			) && !isRestTypeNode(node.elements[0]);
		}
		/**
         * We syntactually check for common nondistributive conditional shapes and unwrap them into
         * the intended comparison - we do this so we can check if the unwrapped types are generic or
         * not and appropriately defer condition calculation
         */
		function unwrapNondistributiveConditionalTuple(root, type) {
			return isTypicalNondistributiveConditional(root) && isTupleType(type) ? getTypeArguments(
				type,
			)[0] : type;
		}
		function getConditionalType(root, mapper, aliasSymbol, aliasTypeArguments) {
			var result;
			var extraTypes;
			var tailCount = 0;
			// We loop here for an immediately nested conditional type in the false position, effectively treating
			// types of the form 'A extends B ? X : C extends D ? Y : E extends F ? Z : ...' as a single construct for
			// purposes of resolution. We also loop here when resolution of a conditional type ends in resolution of
			// another (or, through recursion, possibly the same) conditional type. In the potentially tail-recursive
			// cases we increment the tail recursion counter and stop after 1000 iterations.
			while (true) {
				if (tailCount === 1000) {
					error(
						currentNode,
						Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite,
					);
					result = errorType;
					break;
				}
				var isUnwrapped = isTypicalNondistributiveConditional(root);
				var checkType = instantiateType(
					unwrapNondistributiveConditionalTuple(
						root,
						getActualTypeVariable(root.checkType),
					),
					mapper,
				);
				var checkTypeInstantiable = isGenericType(checkType);
				var extendsType = instantiateType(
					unwrapNondistributiveConditionalTuple(root, root.extendsType),
					mapper,
				);
				if (checkType === wildcardType || extendsType === wildcardType) {
					return wildcardType;
				}
				var combinedMapper = void 0;
				if (root.inferTypeParameters) {
					var context = createInferenceContext(
						root.inferTypeParameters, /*signature*/
						undefined,
						InferenceFlags.None,
					);
					if (!checkTypeInstantiable) {
						// We don't want inferences from constraints as they may cause us to eagerly resolve the
						// conditional type instead of deferring resolution. Also, we always want strict function
						// types rules (i.e. proper contravariance) for inferences.
						inferTypes(
							context.inferences,
							checkType,
							extendsType,
							InferencePriority.NoConstraints | InferencePriority.AlwaysStrict,
						);
					}
					// It's possible for 'infer T' type paramteters to be given uninstantiated constraints when the
					// those type parameters are used in type references (see getInferredTypeParameterConstraint). For
					// that reason we need context.mapper to be first in the combined mapper. See #42636 for examples.
					combinedMapper = mapper ? combineTypeMappers(context.mapper, mapper) : context.mapper;
				}
				// Instantiate the extends type including inferences for 'infer T' type parameters
				var inferredExtendsType = combinedMapper ? instantiateType(
					unwrapNondistributiveConditionalTuple(root, root.extendsType),
					combinedMapper,
				) : extendsType;
				// We attempt to resolve the conditional type only when the check and extends types are non-generic
				if (!checkTypeInstantiable && !isGenericType(inferredExtendsType)) {
					// Return falseType for a definitely false extends check. We check an instantiations of the two
					// types with type parameters mapped to the wildcard type, the most permissive instantiations
					// possible (the wildcard type is assignable to and from all types). If those are not related,
					// then no instantiations will be and we can just return the false branch type.
					if (
						!(inferredExtendsType.flags & TypeFlags.AnyOrUnknown) && ((checkType.flags & TypeFlags.Any && !isUnwrapped) || !isTypeAssignableTo(
							getPermissiveInstantiation(checkType),
							getPermissiveInstantiation(inferredExtendsType),
						))
					) {
						// Return union of trueType and falseType for 'any' since it matches anything
						if (checkType.flags & TypeFlags.Any && !isUnwrapped) {
							(extraTypes || (extraTypes = [])).push(
								instantiateType(
									getTypeFromTypeNode(root.node.trueType),
									combinedMapper || mapper,
								),
							);
						}
						// If falseType is an immediately nested conditional type that isn't distributive or has an
						// identical checkType, switch to that type and loop.
						var falseType_1 = getTypeFromTypeNode(root.node.falseType);
						if (falseType_1.flags & TypeFlags.Conditional) {
							var newRoot = falseType_1.root;
							if (
								newRoot.node.parent === root.node && (!newRoot.isDistributive || newRoot.checkType === root.checkType)
							) {
								root = newRoot;
								continue;
							}
							if (canTailRecurse(falseType_1, mapper)) {
								continue;
							}
						}
						result = instantiateType(falseType_1, mapper);
						break;
					}
					// Return trueType for a definitely true extends check. We check instantiations of the two
					// types with type parameters mapped to their restrictive form, i.e. a form of the type parameter
					// that has no constraint. This ensures that, for example, the type
					//   type Foo<T extends { x: any }> = T extends { x: string } ? string : number
					// doesn't immediately resolve to 'string' instead of being deferred.
					if (
						inferredExtendsType.flags & TypeFlags.AnyOrUnknown || isTypeAssignableTo(
							getRestrictiveInstantiation(checkType),
							getRestrictiveInstantiation(inferredExtendsType),
						)
					) {
						var trueType_1 = getTypeFromTypeNode(root.node.trueType);
						var trueMapper = combinedMapper || mapper;
						if (canTailRecurse(trueType_1, trueMapper)) {
							continue;
						}
						result = instantiateType(trueType_1, trueMapper);
						break;
					}
				}
				// Return a deferred type for a check that is neither definitely true nor definitely false
				result = createType(TypeFlags.Conditional);
				result.root = root;
				result.checkType = instantiateType(root.checkType, mapper);
				result.extendsType = instantiateType(root.extendsType, mapper);
				result.mapper = mapper;
				result.combinedMapper = combinedMapper;
				result.aliasSymbol = aliasSymbol || root.aliasSymbol;
				result.aliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(
					root.aliasTypeArguments,
					mapper,
				); // TODO: GH#18217
				break;
			}
			return extraTypes ? getUnionType(append(extraTypes, result)) : result;
			// We tail-recurse for generic conditional types that (a) have not already been evaluated and cached, and
			// (b) are non distributive, have a check type that is unaffected by instantiation, or have a non-union check
			// type. Note that recursion is possible only through aliased conditional types, so we only increment the tail
			// recursion counter for those.
			function canTailRecurse(newType, newMapper) {
				if (newType.flags & TypeFlags.Conditional && newMapper) {
					var newRoot = newType.root;
					if (newRoot.outerTypeParameters) {
						var typeParamMapper_1 = combineTypeMappers(
							newType.mapper,
							newMapper,
						);
						var typeArguments = map(
							newRoot.outerTypeParameters,
							function (t) {
								return getMappedType(t, typeParamMapper_1);
							},
						);
						var newRootMapper = createTypeMapper(
							newRoot.outerTypeParameters,
							typeArguments,
						);
						var newCheckType = newRoot.isDistributive ? getMappedType(
							newRoot.checkType,
							newRootMapper,
						) : undefined;
						if (
							!newCheckType || newCheckType === newRoot.checkType || !(newCheckType.flags & (TypeFlags.Union | TypeFlags.Never))
						) {
							root = newRoot;
							mapper = newRootMapper;
							aliasSymbol = undefined;
							aliasTypeArguments = undefined;
							if (newRoot.aliasSymbol) {
								tailCount++;
							}
							return true;
						}
					}
				}
				return false;
			}
		}
		function getTrueTypeFromConditionalType(type) {
			return type.resolvedTrueType || (type.resolvedTrueType = instantiateType(
				getTypeFromTypeNode(type.root.node.trueType),
				type.mapper,
			));
		}
		function getFalseTypeFromConditionalType(type) {
			return type.resolvedFalseType || (type.resolvedFalseType = instantiateType(
				getTypeFromTypeNode(type.root.node.falseType),
				type.mapper,
			));
		}
		function getInferredTrueTypeFromConditionalType(type) {
			return type.resolvedInferredTrueType || (type.resolvedInferredTrueType = type.combinedMapper ? instantiateType(
				getTypeFromTypeNode(type.root.node.trueType),
				type.combinedMapper,
			) : getTrueTypeFromConditionalType(type));
		}
		function getInferTypeParameters(node) {
			var result;
			if (node.locals) {
				node.locals.forEach(
					function (symbol) {
						if (symbol.flags & SymbolFlags.TypeParameter) {
							result = append(result, getDeclaredTypeOfSymbol(symbol));
						}
					},
				);
			}
			return result;
		}
		function isDistributionDependent(root) {
			return root.isDistributive && (isTypeParameterPossiblyReferenced(
				root.checkType,
				root.node.trueType,
			) || isTypeParameterPossiblyReferenced(
				root.checkType,
				root.node.falseType,
			));
		}
		function getTypeFromConditionalTypeNode(node) {
			var links = getNodeLinks(node);
			if (!links.resolvedType) {
				var checkType = getTypeFromTypeNode(node.checkType);
				var aliasSymbol = getAliasSymbolForTypeNode(node);
				var aliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol);
				var allOuterTypeParameters = getOuterTypeParameters(
					node, /*includeThisTypes*/
					true,
				);
				var outerTypeParameters = aliasTypeArguments ? allOuterTypeParameters : filter(
					allOuterTypeParameters,
					function (tp) {
						return isTypeParameterPossiblyReferenced(tp, node);
					},
				);
				var root = {
					node: node,
					checkType: checkType,
					extendsType: getTypeFromTypeNode(node.extendsType),
					isDistributive: !!(checkType.flags & TypeFlags.TypeParameter),
					inferTypeParameters: getInferTypeParameters(node),
					outerTypeParameters: outerTypeParameters,
					instantiations: undefined,
					aliasSymbol: aliasSymbol,
					aliasTypeArguments: aliasTypeArguments,
				};
				links.resolvedType = getConditionalType(root, /*mapper*/ undefined);
				if (outerTypeParameters) {
					root.instantiations = new Map();
					root.instantiations.set(
						getTypeListId(outerTypeParameters),
						links.resolvedType,
					);
				}
			}
			return links.resolvedType;
		}
		function getTypeFromInferTypeNode(node) {
			var links = getNodeLinks(node);
			if (!links.resolvedType) {
				links.resolvedType = getDeclaredTypeOfTypeParameter(
					getSymbolOfNode(node.typeParameter),
				);
			}
			return links.resolvedType;
		}
		function getIdentifierChain(node) {
			if (isIdentifier(node)) {
				return [node];
			} else {
				return append(getIdentifierChain(node.left), node.right);
			}
		}
		function getTypeFromImportTypeNode(node) {
			var links = getNodeLinks(node);
			if (!links.resolvedType) {
				if (node.isTypeOf && node.typeArguments) {
					error(node, Diagnostics.Type_arguments_cannot_be_used_here); // Only the non-typeof form can make use of type arguments
					links.resolvedSymbol = unknownSymbol;
					return links.resolvedType = errorType;
				}
				if (!isLiteralImportTypeNode(node)) {
					error(node.argument, Diagnostics.String_literal_expected);
					links.resolvedSymbol = unknownSymbol;
					return links.resolvedType = errorType;
				}
				var targetMeaning = node.isTypeOf ? SymbolFlags.Value : node.flags & NodeFlags.JSDoc ? SymbolFlags.Value | SymbolFlags.Type : SymbolFlags.Type;
				// TODO: Future work: support unions/generics/whatever via a deferred import-type
				var innerModuleSymbol = resolveExternalModuleName(
					node,
					node.argument.literal,
				);
				if (!innerModuleSymbol) {
					links.resolvedSymbol = unknownSymbol;
					return links.resolvedType = errorType;
				}
				var moduleSymbol = resolveExternalModuleSymbol(
					innerModuleSymbol, /*dontResolveAlias*/
					false,
				);
				if (!nodeIsMissing(node.qualifier)) {
					var nameStack = getIdentifierChain(node.qualifier);
					var currentNamespace = moduleSymbol;
					var current = void 0;
					while (current = nameStack.shift()) {
						var meaning = nameStack.length ? SymbolFlags.Namespace : targetMeaning;
						// typeof a.b.c is normally resolved using `checkExpression` which in turn defers to `checkQualifiedName`
						// That, in turn, ultimately uses `getPropertyOfType` on the type of the symbol, which differs slightly from
						// the `exports` lookup process that only looks up namespace members which is used for most type references
						var mergedResolvedSymbol = getMergedSymbol(
							resolveSymbol(currentNamespace),
						);
						var next = node.isTypeOf ? getPropertyOfType(
							getTypeOfSymbol(mergedResolvedSymbol),
							current.escapedText,
						) : getSymbol(
							getExportsOfSymbol(mergedResolvedSymbol),
							current.escapedText,
							meaning,
						);
						if (!next) {
							error(
								current,
								Diagnostics.Namespace_0_has_no_exported_member_1,
								getFullyQualifiedName(currentNamespace),
								declarationNameToString(current),
							);
							return links.resolvedType = errorType;
						}
						getNodeLinks(current).resolvedSymbol = next;
						getNodeLinks(current.parent).resolvedSymbol = next;
						currentNamespace = next;
					}
					links.resolvedType = resolveImportSymbolType(
						node,
						links,
						currentNamespace,
						targetMeaning,
					);
				} else {
					if (moduleSymbol.flags & targetMeaning) {
						links.resolvedType = resolveImportSymbolType(
							node,
							links,
							moduleSymbol,
							targetMeaning,
						);
					} else {
						var errorMessage = targetMeaning === SymbolFlags.Value ? Diagnostics.Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here : Diagnostics.Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0;
						error(node, errorMessage, node.argument.literal.text);
						links.resolvedSymbol = unknownSymbol;
						links.resolvedType = errorType;
					}
				}
			}
			return links.resolvedType;
		}
		function resolveImportSymbolType(node, links, symbol, meaning) {
			var resolvedSymbol = resolveSymbol(symbol);
			links.resolvedSymbol = resolvedSymbol;
			if (meaning === SymbolFlags.Value) {
				return getTypeOfSymbol(symbol); // intentionally doesn't use resolved symbol so type is cached as expected on the alias
			} else {
				return getTypeReferenceType(node, resolvedSymbol); // getTypeReferenceType doesn't handle aliases - it must get the resolved symbol
			}
		}
		function getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node) {
			var links = getNodeLinks(node);
			if (!links.resolvedType) {
				// Deferred resolution of members is handled by resolveObjectTypeMembers
				var aliasSymbol = getAliasSymbolForTypeNode(node);
				if (getMembersOfSymbol(node.symbol).size === 0 && !aliasSymbol) {
					links.resolvedType = emptyTypeLiteralType;
				} else {
					var type = createObjectType(ObjectFlags.Anonymous, node.symbol);
					type.aliasSymbol = aliasSymbol;
					type.aliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol);
					if (isJSDocTypeLiteral(node) && node.isArrayType) {
						type = createArrayType(type);
					}
					links.resolvedType = type;
				}
			}
			return links.resolvedType;
		}
		function getAliasSymbolForTypeNode(node) {
			var host = node.parent;
			while (
				isParenthesizedTypeNode(host) || isJSDocTypeExpression(host) || isTypeOperatorNode(
					host,
				) && host.operator === SyntaxKind.ReadonlyKeyword
			) {
				host = host.parent;
			}
			return isTypeAlias(host) ? getSymbolOfNode(host) : undefined;
		}
		function getTypeArgumentsForAliasSymbol(symbol) {
			return symbol ? getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(
				symbol,
			) : undefined;
		}
		function isNonGenericObjectType(type) {
			return !!(type.flags & TypeFlags.Object) && !isGenericMappedType(type);
		}
		function isEmptyObjectTypeOrSpreadsIntoEmptyObject(type) {
			return isEmptyObjectType(type) || !!(type.flags & (TypeFlags.Null | TypeFlags.Undefined | TypeFlags.BooleanLike | TypeFlags.NumberLike | TypeFlags.BigIntLike | TypeFlags.StringLike | TypeFlags.EnumLike | TypeFlags.NonPrimitive | TypeFlags.Index));
		}
		function tryMergeUnionOfObjectTypeAndEmptyObject(type, readonly) {
			if (!(type.flags & TypeFlags.Union)) {
				return type;
			}
			if (every(type.types, isEmptyObjectTypeOrSpreadsIntoEmptyObject)) {
				return find(type.types, isEmptyObjectType) || emptyObjectType;
			}
			var firstType = find(
				type.types,
				function (t) {
					return !isEmptyObjectTypeOrSpreadsIntoEmptyObject(t);
				},
			);
			if (!firstType) {
				return type;
			}
			var secondType = find(
				type.types,
				function (t) {
					return t !== firstType && !isEmptyObjectTypeOrSpreadsIntoEmptyObject(
						t,
					);
				},
			);
			if (secondType) {
				return type;
			}
			return getAnonymousPartialType(firstType);
			function getAnonymousPartialType(type) {
				// gets the type as if it had been spread, but where everything in the spread is made optional
				var members = createSymbolTable();
				for (var _i = 0, _a = getPropertiesOfType(type); _i < _a.length; _i++) {
					var prop = _a[_i];
					if (
						getDeclarationModifierFlagsFromSymbol(prop) & (ModifierFlags.Private | ModifierFlags.Protected)
					) {
					// do nothing, skip privates
					} else if (isSpreadableProperty(prop)) {
						var isSetonlyAccessor = prop.flags & SymbolFlags.SetAccessor && !(prop.flags & SymbolFlags.GetAccessor);
						var flags = SymbolFlags.Property | SymbolFlags.Optional;
						var result = createSymbol(
							flags,
							prop.escapedName,
							getIsLateCheckFlag(prop) | (readonly ? CheckFlags.Readonly : 0),
						);
						result.type = isSetonlyAccessor ? undefinedType : addOptionality(
							getTypeOfSymbol(prop), /*isProperty*/
							true,
						);
						result.declarations = prop.declarations;
						result.nameType = getSymbolLinks(prop).nameType;
						result.syntheticOrigin = prop;
						members.set(prop.escapedName, result);
					}
				}
				var spread = createAnonymousType(
					type.symbol,
					members,
					emptyArray,
					emptyArray,
					getIndexInfosOfType(type),
				);
				spread.objectFlags |= ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral;
				return spread;
			}
		}
		/**
         * Since the source of spread types are object literals, which are not binary,
         * this function should be called in a left folding style, with left = previous result of getSpreadType
         * and right = the new element to be spread.
         */
		function getSpreadType(left, right, symbol, objectFlags, readonly) {
			if (left.flags & TypeFlags.Any || right.flags & TypeFlags.Any) {
				return anyType;
			}
			if (left.flags & TypeFlags.Unknown || right.flags & TypeFlags.Unknown) {
				return unknownType;
			}
			if (left.flags & TypeFlags.Never) {
				return right;
			}
			if (right.flags & TypeFlags.Never) {
				return left;
			}
			left = tryMergeUnionOfObjectTypeAndEmptyObject(left, readonly);
			if (left.flags & TypeFlags.Union) {
				return checkCrossProductUnion([left, right]) ? mapType(
					left,
					function (t) {
						return getSpreadType(t, right, symbol, objectFlags, readonly);
					},
				) : errorType;
			}
			right = tryMergeUnionOfObjectTypeAndEmptyObject(right, readonly);
			if (right.flags & TypeFlags.Union) {
				return checkCrossProductUnion([left, right]) ? mapType(
					right,
					function (t) {
						return getSpreadType(left, t, symbol, objectFlags, readonly);
					},
				) : errorType;
			}
			if (
				right.flags & (TypeFlags.BooleanLike | TypeFlags.NumberLike | TypeFlags.BigIntLike | TypeFlags.StringLike | TypeFlags.EnumLike | TypeFlags.NonPrimitive | TypeFlags.Index)
			) {
				return left;
			}
			if (isGenericObjectType(left) || isGenericObjectType(right)) {
				if (isEmptyObjectType(left)) {
					return right;
				}
				// When the left type is an intersection, we may need to merge the last constituent of the
				// intersection with the right type. For example when the left type is 'T & { a: string }'
				// and the right type is '{ b: string }' we produce 'T & { a: string, b: string }'.
				if (left.flags & TypeFlags.Intersection) {
					var types = left.types;
					var lastLeft = types[types.length - 1];
					if (isNonGenericObjectType(lastLeft) && isNonGenericObjectType(right)) {
						return getIntersectionType(
							concatenate(
								types.slice(0, types.length - 1),
								[getSpreadType(lastLeft, right, symbol, objectFlags, readonly)],
							),
						);
					}
				}
				return getIntersectionType([left, right]);
			}
			var members = createSymbolTable();
			var skippedPrivateMembers = new Set();
			var indexInfos = left === emptyObjectType ? getIndexInfosOfType(right) : getUnionIndexInfos(
				[left, right],
			);
			for (var _i = 0, _a = getPropertiesOfType(right); _i < _a.length; _i++) {
				var rightProp = _a[_i];
				if (
					getDeclarationModifierFlagsFromSymbol(rightProp) & (ModifierFlags.Private | ModifierFlags.Protected)
				) {
					skippedPrivateMembers.add(rightProp.escapedName);
				} else if (isSpreadableProperty(rightProp)) {
					members.set(
						rightProp.escapedName,
						getSpreadSymbol(rightProp, readonly),
					);
				}
			}
			for (var _b = 0, _c = getPropertiesOfType(left); _b < _c.length; _b++) {
				var leftProp = _c[_b];
				if (
					skippedPrivateMembers.has(leftProp.escapedName) || !isSpreadableProperty(
						leftProp,
					)
				) {
					continue;
				}
				if (members.has(leftProp.escapedName)) {
					var rightProp = members.get(leftProp.escapedName);
					var rightType = getTypeOfSymbol(rightProp);
					if (rightProp.flags & SymbolFlags.Optional) {
						var declarations = concatenate(
							leftProp.declarations,
							rightProp.declarations,
						);
						var flags = SymbolFlags.Property | (leftProp.flags & SymbolFlags.Optional);
						var result = createSymbol(flags, leftProp.escapedName);
						result.type = getUnionType(
							[
								getTypeOfSymbol(leftProp),
								removeMissingOrUndefinedType(rightType),
							],
							UnionReduction.Subtype,
						);
						result.leftSpread = leftProp;
						result.rightSpread = rightProp;
						result.declarations = declarations;
						result.nameType = getSymbolLinks(leftProp).nameType;
						members.set(leftProp.escapedName, result);
					}
				} else {
					members.set(leftProp.escapedName, getSpreadSymbol(leftProp, readonly));
				}
			}
			var spread = createAnonymousType(
				symbol,
				members,
				emptyArray,
				emptyArray,
				sameMap(
					indexInfos,
					function (info) {
						return getIndexInfoWithReadonly(info, readonly);
					},
				),
			);
			spread.objectFlags |= ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral | ObjectFlags.ContainsSpread | objectFlags;
			return spread;
		}
		/** We approximate own properties as non-methods plus methods that are inside the object literal */
		function isSpreadableProperty(prop) {
			var _a;
			return !some(
				prop.declarations,
				isPrivateIdentifierClassElementDeclaration,
			) && (!(prop.flags & (SymbolFlags.Method | SymbolFlags.GetAccessor | SymbolFlags.SetAccessor)) || !((_a = prop.declarations) === null || _a === void 0 ? void 0 : _a.some(
				function (decl) {
					return isClassLike(decl.parent);
				},
			)));
		}
		function getSpreadSymbol(prop, readonly) {
			var isSetonlyAccessor = prop.flags & SymbolFlags.SetAccessor && !(prop.flags & SymbolFlags.GetAccessor);
			if (!isSetonlyAccessor && readonly === isReadonlySymbol(prop)) {
				return prop;
			}
			var flags = SymbolFlags.Property | (prop.flags & SymbolFlags.Optional);
			var result = createSymbol(
				flags,
				prop.escapedName,
				getIsLateCheckFlag(prop) | (readonly ? CheckFlags.Readonly : 0),
			);
			result.type = isSetonlyAccessor ? undefinedType : getTypeOfSymbol(prop);
			result.declarations = prop.declarations;
			result.nameType = getSymbolLinks(prop).nameType;
			result.syntheticOrigin = prop;
			return result;
		}
		function getIndexInfoWithReadonly(info, readonly) {
			return info.isReadonly !== readonly ? createIndexInfo(
				info.keyType,
				info.type,
				readonly,
				info.declaration,
			) : info;
		}
		function createLiteralType(flags, value, symbol, regularType) {
			var type = createType(flags);
			type.symbol = symbol;
			type.value = value;
			type.regularType = regularType || type;
			return type;
		}
		function getFreshTypeOfLiteralType(type) {
			if (type.flags & TypeFlags.Literal) {
				if (!type.freshType) {
					var freshType = createLiteralType(
						type.flags,
						type.value,
						type.symbol,
						type,
					);
					freshType.freshType = freshType;
					type.freshType = freshType;
				}
				return type.freshType;
			}
			return type;
		}
		function getRegularTypeOfLiteralType(type) {
			return type.flags & TypeFlags.Literal ? type.regularType : type.flags & TypeFlags.Union ? (type.regularType || (type.regularType = mapType(
				type,
				getRegularTypeOfLiteralType,
			))) : type;
		}
		function isFreshLiteralType(type) {
			return !!(type.flags & TypeFlags.Literal) && type.freshType === type;
		}
		function getStringLiteralType(value) {
			var type;
			return stringLiteralTypes.get(value) || (stringLiteralTypes.set(
				value,
				type = createLiteralType(TypeFlags.StringLiteral, value),
			), type);
		}
		function getNumberLiteralType(value) {
			var type;
			return numberLiteralTypes.get(value) || (numberLiteralTypes.set(
				value,
				type = createLiteralType(TypeFlags.NumberLiteral, value),
			), type);
		}
		function getBigIntLiteralType(value) {
			var type;
			var key = pseudoBigIntToString(value);
			return bigIntLiteralTypes.get(key) || (bigIntLiteralTypes.set(
				key,
				type = createLiteralType(TypeFlags.BigIntLiteral, value),
			), type);
		}
		function getEnumLiteralType(value, enumId, symbol) {
			var type;
			var qualifier = typeof value === "string" ? "@" : "#";
			var key = enumId + qualifier + value;
			var flags = TypeFlags.EnumLiteral | (typeof value === "string" ? TypeFlags.StringLiteral : TypeFlags.NumberLiteral);
			return enumLiteralTypes.get(key) || (enumLiteralTypes.set(
				key,
				type = createLiteralType(flags, value, symbol),
			), type);
		}
		function getTypeFromLiteralTypeNode(node) {
			if (node.literal.kind === SyntaxKind.NullKeyword) {
				return nullType;
			}
			var links = getNodeLinks(node);
			if (!links.resolvedType) {
				links.resolvedType = getRegularTypeOfLiteralType(
					checkExpression(node.literal),
				);
			}
			return links.resolvedType;
		}
		function createUniqueESSymbolType(symbol) {
			var type = createType(TypeFlags.UniqueESSymbol);
			type.symbol = symbol;
			type.escapedName = "__@".concat(type.symbol.escapedName, "@").concat(
				getSymbolId(type.symbol),
			);
			return type;
		}
		function getESSymbolLikeTypeForNode(node) {
			if (isValidESSymbolDeclaration(node)) {
				var symbol = getSymbolOfNode(node);
				var links = getSymbolLinks(symbol);
				return links.uniqueESSymbolType || (links.uniqueESSymbolType = createUniqueESSymbolType(
					symbol,
				));
			}
			return esSymbolType;
		}
		function getThisType(node) {
			var container = getThisContainer(node, /*includeArrowFunctions*/ false);
			var parent = container && container.parent;
			if (
				parent && (isClassLike(parent) || parent.kind === SyntaxKind.InterfaceDeclaration)
			) {
				if (
					!isStatic(container) && (!isConstructorDeclaration(container) || isNodeDescendantOf(
						node,
						container.body,
					))
				) {
					return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(parent)).thisType;
				}
			}
			// inside x.prototype = { ... }
			if (
				parent && isObjectLiteralExpression(parent) && isBinaryExpression(
					parent.parent,
				) && getAssignmentDeclarationKind(parent.parent) === AssignmentDeclarationKind.Prototype
			) {
				return getDeclaredTypeOfClassOrInterface(
					getSymbolOfNode(parent.parent.left).parent,
				).thisType;
			}
			// /** @return {this} */
			// x.prototype.m = function() { ... }
			var host = node.flags & NodeFlags.JSDoc ? getHostSignatureFromJSDoc(node) : undefined;
			if (
				host && isFunctionExpression(host) && isBinaryExpression(host.parent) && getAssignmentDeclarationKind(
					host.parent,
				) === AssignmentDeclarationKind.PrototypeProperty
			) {
				return getDeclaredTypeOfClassOrInterface(
					getSymbolOfNode(host.parent.left).parent,
				).thisType;
			}
			// inside constructor function C() { ... }
			if (
				isJSConstructor(container) && isNodeDescendantOf(node, container.body)
			) {
				return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(container)).thisType;
			}
			error(
				node,
				Diagnostics.A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface,
			);
			return errorType;
		}
		function getTypeFromThisTypeNode(node) {
			var links = getNodeLinks(node);
			if (!links.resolvedType) {
				links.resolvedType = getThisType(node);
			}
			return links.resolvedType;
		}
		function getTypeFromRestTypeNode(node) {
			return getTypeFromTypeNode(
				getArrayElementTypeNode(node.type) || node.type,
			);
		}
		function getArrayElementTypeNode(node) {
			switch (node.kind) {
				case SyntaxKind.ParenthesizedType:
					return getArrayElementTypeNode(node.type);
				case SyntaxKind.TupleType:
					if (node.elements.length === 1) {
						node = node.elements[0];
						if (
							node.kind === SyntaxKind.RestType || node.kind === SyntaxKind.NamedTupleMember && node.dotDotDotToken
						) {
							return getArrayElementTypeNode(node.type);
						}
					}
					break;
				case SyntaxKind.ArrayType:
					return node.elementType;
			}
			return undefined;
		}
		function getTypeFromNamedTupleTypeNode(node) {
			var links = getNodeLinks(node);
			return links.resolvedType || (links.resolvedType = node.dotDotDotToken ? getTypeFromRestTypeNode(
				node,
			) : addOptionality(
				getTypeFromTypeNode(node.type), /*isProperty*/
				true,
				!!node.questionToken,
			));
		}
		function getTypeFromTypeNode(node) {
			return getConditionalFlowTypeOfType(getTypeFromTypeNodeWorker(node), node);
		}
		function getTypeFromTypeNodeWorker(node) {
			switch (node.kind) {
				case SyntaxKind.AnyKeyword:
				case SyntaxKind.JSDocAllType:
				case SyntaxKind.JSDocUnknownType:
					return anyType;
				case SyntaxKind.UnknownKeyword:
					return unknownType;
				case SyntaxKind.StringKeyword:
					return stringType;
				case SyntaxKind.NumberKeyword:
					return numberType;
				case SyntaxKind.BigIntKeyword:
					return bigintType;
				case SyntaxKind.BooleanKeyword:
					return booleanType;
				case SyntaxKind.SymbolKeyword:
					return esSymbolType;
				case SyntaxKind.VoidKeyword:
					return voidType;
				case SyntaxKind.UndefinedKeyword:
					return undefinedType;
				case SyntaxKind.NullKeyword:
					// TODO(rbuckton): `NullKeyword` is no longer a `TypeNode`, but we defensively allow it here because of incorrect casts in the Language Service.
					return nullType;
				case SyntaxKind.NeverKeyword:
					return neverType;
				case SyntaxKind.ObjectKeyword:
					return node.flags & NodeFlags.JavaScriptFile && !noImplicitAny ? anyType : nonPrimitiveType;
				case SyntaxKind.IntrinsicKeyword:
					return intrinsicMarkerType;
				case SyntaxKind.ThisType:
				case SyntaxKind.ThisKeyword:
					// TODO(rbuckton): `ThisKeyword` is no longer a `TypeNode`, but we defensively allow it here because of incorrect casts in the Language Service and because of `isPartOfTypeNode`.
					return getTypeFromThisTypeNode(node);
				case SyntaxKind.LiteralType:
					return getTypeFromLiteralTypeNode(node);
				case SyntaxKind.TypeReference:
					return getTypeFromTypeReference(node);
				case SyntaxKind.TypePredicate:
					return node.assertsModifier ? voidType : booleanType;
				case SyntaxKind.ExpressionWithTypeArguments:
					return getTypeFromTypeReference(node);
				case SyntaxKind.TypeQuery:
					return getTypeFromTypeQueryNode(node);
				case SyntaxKind.ArrayType:
				case SyntaxKind.TupleType:
					return getTypeFromArrayOrTupleTypeNode(node);
				case SyntaxKind.OptionalType:
					return getTypeFromOptionalTypeNode(node);
				case SyntaxKind.UnionType:
					return getTypeFromUnionTypeNode(node);
				case SyntaxKind.IntersectionType:
					return getTypeFromIntersectionTypeNode(node);
				case SyntaxKind.JSDocNullableType:
					return getTypeFromJSDocNullableTypeNode(node);
				case SyntaxKind.JSDocOptionalType:
					return addOptionality(getTypeFromTypeNode(node.type));
				case SyntaxKind.NamedTupleMember:
					return getTypeFromNamedTupleTypeNode(node);
				case SyntaxKind.ParenthesizedType:
				case SyntaxKind.JSDocNonNullableType:
				case SyntaxKind.JSDocTypeExpression:
					return getTypeFromTypeNode(node.type);
				case SyntaxKind.RestType:
					return getTypeFromRestTypeNode(node);
				case SyntaxKind.JSDocVariadicType:
					return getTypeFromJSDocVariadicType(node);
				case SyntaxKind.FunctionType:
				case SyntaxKind.ConstructorType:
				case SyntaxKind.TypeLiteral:
				case SyntaxKind.JSDocTypeLiteral:
				case SyntaxKind.JSDocFunctionType:
				case SyntaxKind.JSDocSignature:
					return getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node);
				case SyntaxKind.TypeOperator:
					return getTypeFromTypeOperatorNode(node);
				case SyntaxKind.IndexedAccessType:
					return getTypeFromIndexedAccessTypeNode(node);
				case SyntaxKind.MappedType:
					return getTypeFromMappedTypeNode(node);
				case SyntaxKind.ConditionalType:
					return getTypeFromConditionalTypeNode(node);
				case SyntaxKind.InferType:
					return getTypeFromInferTypeNode(node);
				case SyntaxKind.TemplateLiteralType:
					return getTypeFromTemplateTypeNode(node);
				case SyntaxKind.ImportType:
					return getTypeFromImportTypeNode(node);
				// This function assumes that an identifier, qualified name, or property access expression is a type expression
				// Callers should first ensure this by calling `isPartOfTypeNode`
				// TODO(rbuckton): These aren't valid TypeNodes, but we treat them as such because of `isPartOfTypeNode`, which returns `true` for things that aren't `TypeNode`s.
				case SyntaxKind.Identifier:
				case SyntaxKind.QualifiedName:
				case SyntaxKind.PropertyAccessExpression:
					var symbol = getSymbolAtLocation(node);
					return symbol ? getDeclaredTypeOfSymbol(symbol) : errorType;
				default:
					return errorType;
			}
		}
		function instantiateList(items, mapper, instantiator) {
			if (items && items.length) {
				for (var i = 0; i < items.length; i++) {
					var item = items[i];
					var mapped = instantiator(item, mapper);
					if (item !== mapped) {
						var result = i === 0 ? [] : items.slice(0, i);
						result.push(mapped);
						for (i++; i < items.length; i++) {
							result.push(instantiator(items[i], mapper));
						}
						return result;
					}
				}
			}
			return items;
		}
		function instantiateTypes(types, mapper) {
			return instantiateList(types, mapper, instantiateType);
		}
		function instantiateSignatures(signatures, mapper) {
			return instantiateList(signatures, mapper, instantiateSignature);
		}
		function instantiateIndexInfos(indexInfos, mapper) {
			return instantiateList(indexInfos, mapper, instantiateIndexInfo);
		}
		function createTypeMapper(sources, targets) {
			return sources.length === 1 ? makeUnaryTypeMapper(
				sources[0],
				targets ? targets[0] : anyType,
			) : makeArrayTypeMapper(sources, targets);
		}
		function getMappedType(type, mapper) {
			switch (mapper.kind) {
				case TypeMapKind.Simple:
					return type === mapper.source ? mapper.target : type;
				case TypeMapKind.Array:
					var sources = mapper.sources;
					var targets = mapper.targets;
					for (var i = 0; i < sources.length; i++) {
						if (type === sources[i]) {
							return targets ? targets[i] : anyType;
						}
					}
					return type;
				case TypeMapKind.Function:
					return mapper.func(type);
				case TypeMapKind.Composite:
				case TypeMapKind.Merged:
					var t1 = getMappedType(type, mapper.mapper1);
					return t1 !== type && mapper.kind === TypeMapKind.Composite ? instantiateType(
						t1,
						mapper.mapper2,
					) : getMappedType(t1, mapper.mapper2);
			}
		}
		function makeUnaryTypeMapper(source, target) {
			return { kind: TypeMapKind.Simple, source: source, target: target };
		}
		function makeArrayTypeMapper(sources, targets) {
			return { kind: TypeMapKind.Array, sources: sources, targets: targets };
		}
		function makeFunctionTypeMapper(func) {
			return { kind: TypeMapKind.Function, func: func };
		}
		function makeCompositeTypeMapper(kind, mapper1, mapper2) {
			return { kind: kind, mapper1: mapper1, mapper2: mapper2 };
		}
		function createTypeEraser(sources) {
			return createTypeMapper(sources, /*targets*/ undefined);
		}
		/**
         * Maps forward-references to later types parameters to the empty object type.
         * This is used during inference when instantiating type parameter defaults.
         */
		function createBackreferenceMapper(context, index) {
			return makeFunctionTypeMapper(
				function (t) {
					return findIndex(
						context.inferences,
						function (info) {
							return info.typeParameter === t;
						},
					) >= index ? unknownType : t;
				},
			);
		}
		function combineTypeMappers(mapper1, mapper2) {
			return mapper1 ? makeCompositeTypeMapper(
				TypeMapKind.Composite,
				mapper1,
				mapper2,
			) : mapper2;
		}
		function mergeTypeMappers(mapper1, mapper2) {
			return mapper1 ? makeCompositeTypeMapper(
				TypeMapKind.Merged,
				mapper1,
				mapper2,
			) : mapper2;
		}
		function prependTypeMapping(source, target, mapper) {
			return !mapper ? makeUnaryTypeMapper(source, target) : makeCompositeTypeMapper(
				TypeMapKind.Merged,
				makeUnaryTypeMapper(source, target),
				mapper,
			);
		}
		function appendTypeMapping(mapper, source, target) {
			return !mapper ? makeUnaryTypeMapper(source, target) : makeCompositeTypeMapper(
				TypeMapKind.Merged,
				mapper,
				makeUnaryTypeMapper(source, target),
			);
		}
		function getRestrictiveTypeParameter(tp) {
			return tp.constraint === unknownType ? tp : tp.restrictiveInstantiation || (tp.restrictiveInstantiation = createTypeParameter(tp.symbol),
                tp.restrictiveInstantiation.constraint = unknownType,
                tp.restrictiveInstantiation);
		}
		function cloneTypeParameter(typeParameter) {
			var result = createTypeParameter(typeParameter.symbol);
			result.target = typeParameter;
			return result;
		}
		function instantiateTypePredicate(predicate, mapper) {
			return createTypePredicate(
				predicate.kind,
				predicate.parameterName,
				predicate.parameterIndex,
				instantiateType(predicate.type, mapper),
			);
		}
		function instantiateSignature(signature, mapper, eraseTypeParameters) {
			var freshTypeParameters;
			if (signature.typeParameters && !eraseTypeParameters) {
				// First create a fresh set of type parameters, then include a mapping from the old to the
				// new type parameters in the mapper function. Finally store this mapper in the new type
				// parameters such that we can use it when instantiating constraints.
				freshTypeParameters = map(signature.typeParameters, cloneTypeParameter);
				mapper = combineTypeMappers(
					createTypeMapper(signature.typeParameters, freshTypeParameters),
					mapper,
				);
				for (
					var _i = 0, freshTypeParameters_1 = freshTypeParameters;
					_i < freshTypeParameters_1.length;
					_i++
				) {
					var tp = freshTypeParameters_1[_i];
					tp.mapper = mapper;
				}
			}
			// Don't compute resolvedReturnType and resolvedTypePredicate now,
			// because using `mapper` now could trigger inferences to become fixed. (See `createInferenceContext`.)
			// See GH#17600.
			var result = createSignature(
				signature.declaration,
				freshTypeParameters,
				signature.thisParameter && instantiateSymbol(
					signature.thisParameter,
					mapper,
				),
				instantiateList(signature.parameters, mapper, instantiateSymbol),
				/*resolvedReturnType*/ undefined,
				/*resolvedTypePredicate*/ undefined,
				signature.minArgumentCount,
				signature.flags & SignatureFlags.PropagatingFlags,
			);
			result.target = signature;
			result.mapper = mapper;
			return result;
		}
		function instantiateSymbol(symbol, mapper) {
			var links = getSymbolLinks(symbol);
			if (links.type && !couldContainTypeVariables(links.type)) {
				// If the type of the symbol is already resolved, and if that type could not possibly
				// be affected by instantiation, simply return the symbol itself.
				return symbol;
			}
			if (getCheckFlags(symbol) & CheckFlags.Instantiated) {
				// If symbol being instantiated is itself a instantiation, fetch the original target and combine the
				// type mappers. This ensures that original type identities are properly preserved and that aliases
				// always reference a non-aliases.
				symbol = links.target;
				mapper = combineTypeMappers(links.mapper, mapper);
			}
			// Keep the flags from the symbol we're instantiating.  Mark that is instantiated, and
			// also transient so that we can just store data on it directly.
			var result = createSymbol(
				symbol.flags,
				symbol.escapedName,
				CheckFlags.Instantiated | getCheckFlags(symbol) & (CheckFlags.Readonly | CheckFlags.Late | CheckFlags.OptionalParameter | CheckFlags.RestParameter),
			);
			result.declarations = symbol.declarations;
			result.parent = symbol.parent;
			result.target = symbol;
			result.mapper = mapper;
			if (symbol.valueDeclaration) {
				result.valueDeclaration = symbol.valueDeclaration;
			}
			if (links.nameType) {
				result.nameType = links.nameType;
			}
			return result;
		}
		function getObjectTypeInstantiation(
			type,
			mapper,
			aliasSymbol,
			aliasTypeArguments,
		) {
			var declaration = type.objectFlags & ObjectFlags.Reference ? type.node : type.symbol.declarations[0];
			var links = getNodeLinks(declaration);
			var target = type.objectFlags & ObjectFlags.Reference ? links.resolvedType : type.objectFlags & ObjectFlags.Instantiated ? type.target : type;
			var typeParameters = links.outerTypeParameters;
			if (!typeParameters) {
				// The first time an anonymous type is instantiated we compute and store a list of the type
				// parameters that are in scope (and therefore potentially referenced). For type literals that
				// aren't the right hand side of a generic type alias declaration we optimize by reducing the
				// set of type parameters to those that are possibly referenced in the literal.
				var outerTypeParameters = getOuterTypeParameters(
					declaration, /*includeThisTypes*/
					true,
				);
				if (isJSConstructor(declaration)) {
					var templateTagParameters = getTypeParametersFromDeclaration(
						declaration,
					);
					outerTypeParameters = addRange(
						outerTypeParameters,
						templateTagParameters,
					);
				}
				typeParameters = outerTypeParameters || emptyArray;
				var allDeclarations_1 = type.objectFlags & ObjectFlags.Reference ? [
					declaration,
				] : type.symbol.declarations;
				typeParameters = (target.objectFlags & ObjectFlags.Reference || target.symbol.flags & SymbolFlags.Method || target.symbol.flags & SymbolFlags.TypeLiteral) && !target.aliasTypeArguments ? filter(
					typeParameters,
					function (tp) {
						return some(
							allDeclarations_1,
							function (d) {
								return isTypeParameterPossiblyReferenced(tp, d);
							},
						);
					},
				) : typeParameters;
				links.outerTypeParameters = typeParameters;
			}
			if (typeParameters.length) {
				// We are instantiating an anonymous type that has one or more type parameters in scope. Apply the
				// mapper to the type parameters to produce the effective list of type arguments, and compute the
				// instantiation cache key from the type IDs of the type arguments.
				var combinedMapper_1 = combineTypeMappers(type.mapper, mapper);
				var typeArguments = map(
					typeParameters,
					function (t) {
						return getMappedType(t, combinedMapper_1);
					},
				);
				var newAliasSymbol = aliasSymbol || type.aliasSymbol;
				var newAliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(
					type.aliasTypeArguments,
					mapper,
				);
				var id = getTypeListId(typeArguments) + getAliasId(
					newAliasSymbol,
					newAliasTypeArguments,
				);
				if (!target.instantiations) {
					target.instantiations = new Map();
					target.instantiations.set(
						getTypeListId(typeParameters) + getAliasId(
							target.aliasSymbol,
							target.aliasTypeArguments,
						),
						target,
					);
				}
				var result = target.instantiations.get(id);
				if (!result) {
					var newMapper = createTypeMapper(typeParameters, typeArguments);
					result = target.objectFlags & ObjectFlags.Reference ? createDeferredTypeReference(
						type.target,
						type.node,
						newMapper,
						newAliasSymbol,
						newAliasTypeArguments,
					) : target.objectFlags & ObjectFlags.Mapped ? instantiateMappedType(
						target,
						newMapper,
						newAliasSymbol,
						newAliasTypeArguments,
					) : instantiateAnonymousType(
						target,
						newMapper,
						newAliasSymbol,
						newAliasTypeArguments,
					);
					target.instantiations.set(id, result);
				}
				return result;
			}
			return type;
		}
		function maybeTypeParameterReference(node) {
			return !(node.parent.kind === SyntaxKind.TypeReference && node.parent.typeArguments && node === node.parent.typeName || node.parent.kind === SyntaxKind.ImportType && node.parent.typeArguments && node === node.parent.qualifier);
		}
		function isTypeParameterPossiblyReferenced(tp, node) {
			// If the type parameter doesn't have exactly one declaration, if there are invening statement blocks
			// between the node and the type parameter declaration, if the node contains actual references to the
			// type parameter, or if the node contains type queries, we consider the type parameter possibly referenced.
			if (
				tp.symbol && tp.symbol.declarations && tp.symbol.declarations.length === 1
			) {
				var container = tp.symbol.declarations[0].parent;
				for (var n = node; n !== container; n = n.parent) {
					if (
						!n || n.kind === SyntaxKind.Block || n.kind === SyntaxKind.ConditionalType && forEachChild(
							n.extendsType,
							containsReference,
						)
					) {
						return true;
					}
				}
				return containsReference(node);
			}
			return true;
			function containsReference(node) {
				switch (node.kind) {
					case SyntaxKind.ThisType:
						return !!tp.isThisType;
					case SyntaxKind.Identifier:
						return !tp.isThisType && isPartOfTypeNode(node) && maybeTypeParameterReference(
							node,
						) && getTypeFromTypeNodeWorker(node) === tp; // use worker because we're looking for === equality
					case SyntaxKind.TypeQuery:
						return true;
					case SyntaxKind.MethodDeclaration:
					case SyntaxKind.MethodSignature:
						return !node.type && !!node.body || some(
							node.typeParameters,
							containsReference,
						) || some(node.parameters, containsReference) || !!node.type && containsReference(
							node.type,
						);
				}
				return !!forEachChild(node, containsReference);
			}
		}
		function getHomomorphicTypeVariable(type) {
			var constraintType = getConstraintTypeFromMappedType(type);
			if (constraintType.flags & TypeFlags.Index) {
				var typeVariable = getActualTypeVariable(constraintType.type);
				if (typeVariable.flags & TypeFlags.TypeParameter) {
					return typeVariable;
				}
			}
			return undefined;
		}
		function instantiateMappedType(
			type,
			mapper,
			aliasSymbol,
			aliasTypeArguments,
		) {
			// For a homomorphic mapped type { [P in keyof T]: X }, where T is some type variable, the mapping
			// operation depends on T as follows:
			// * If T is a primitive type no mapping is performed and the result is simply T.
			// * If T is a union type we distribute the mapped type over the union.
			// * If T is an array we map to an array where the element type has been transformed.
			// * If T is a tuple we map to a tuple where the element types have been transformed.
			// * Otherwise we map to an object type where the type of each property has been transformed.
			// For example, when T is instantiated to a union type A | B, we produce { [P in keyof A]: X } |
			// { [P in keyof B]: X }, and when when T is instantiated to a union type A | undefined, we produce
			// { [P in keyof A]: X } | undefined.
			var typeVariable = getHomomorphicTypeVariable(type);
			if (typeVariable) {
				var mappedTypeVariable = instantiateType(typeVariable, mapper);
				if (typeVariable !== mappedTypeVariable) {
					return mapTypeWithAlias(
						getReducedType(mappedTypeVariable),
						function (t) {
							if (
								t.flags & (TypeFlags.AnyOrUnknown | TypeFlags.InstantiableNonPrimitive | TypeFlags.Object | TypeFlags.Intersection) && t !== wildcardType && !isErrorType(
									t,
								)
							) {
								if (!type.declaration.nameType) {
									var constraint = void 0;
									if (
										isArrayType(t) || t.flags & TypeFlags.Any && findResolutionCycleStartIndex(
											typeVariable,
											4, /* ImmediateBaseConstraint */
										) < 0 && (constraint = getConstraintOfTypeParameter(
											typeVariable,
										)) && everyType(constraint, or(isArrayType, isTupleType))
									) {
										return instantiateMappedArrayType(
											t,
											type,
											prependTypeMapping(typeVariable, t, mapper),
										);
									}
									if (isGenericTupleType(t)) {
										return instantiateMappedGenericTupleType(
											t,
											type,
											typeVariable,
											mapper,
										);
									}
									if (isTupleType(t)) {
										return instantiateMappedTupleType(
											t,
											type,
											prependTypeMapping(typeVariable, t, mapper),
										);
									}
								}
								return instantiateAnonymousType(
									type,
									prependTypeMapping(typeVariable, t, mapper),
								);
							}
							return t;
						},
						aliasSymbol,
						aliasTypeArguments,
					);
				}
			}
			// If the constraint type of the instantiation is the wildcard type, return the wildcard type.
			return instantiateType(getConstraintTypeFromMappedType(type), mapper) === wildcardType ? wildcardType : instantiateAnonymousType(
				type,
				mapper,
				aliasSymbol,
				aliasTypeArguments,
			);
		}
		function getModifiedReadonlyState(state, modifiers) {
			return modifiers & 1 ? true : modifiers & 2 ? false : state; /* IncludeReadonly */ /* ExcludeReadonly */
		}
		function instantiateMappedGenericTupleType(
			tupleType,
			mappedType,
			typeVariable,
			mapper,
		) {
			// When a tuple type is generic (i.e. when it contains variadic elements), we want to eagerly map the
			// non-generic elements and defer mapping the generic elements. In order to facilitate this, we transform
			// M<[A, B?, ...T, ...C[]] into [...M<[A]>, ...M<[B?]>, ...M<T>, ...M<C[]>] and then rely on tuple type
			// normalization to resolve the non-generic parts of the resulting tuple.
			var elementFlags = tupleType.target.elementFlags;
			var elementTypes = map(
				getTypeArguments(tupleType),
				function (t, i) {
					var singleton = elementFlags[i] & ElementFlags.Variadic ? t : elementFlags[i] & ElementFlags.Rest ? createArrayType(
						t,
					) : createTupleType([t], [elementFlags[i]]);
					// The singleton is never a generic tuple type, so it is safe to recurse here.
					return instantiateMappedType(
						mappedType,
						prependTypeMapping(typeVariable, singleton, mapper),
					);
				},
			);
			var newReadonly = getModifiedReadonlyState(
				tupleType.target.readonly,
				getMappedTypeModifiers(mappedType),
			);
			return createTupleType(
				elementTypes,
				map(
					elementTypes,
					function (_) {
						return ElementFlags.Variadic;
					},
				),
				newReadonly,
			);
		}
		function instantiateMappedArrayType(arrayType, mappedType, mapper) {
			var elementType = instantiateMappedTypeTemplate(
				mappedType,
				numberType, /*isOptional*/
				true,
				mapper,
			);
			return isErrorType(elementType) ? errorType : createArrayType(
				elementType,
				getModifiedReadonlyState(
					isReadonlyArrayType(arrayType),
					getMappedTypeModifiers(mappedType),
				),
			);
		}
		function instantiateMappedTupleType(tupleType, mappedType, mapper) {
			var elementFlags = tupleType.target.elementFlags;
			var elementTypes = map(
				getTypeArguments(tupleType),
				function (_, i) {
					return instantiateMappedTypeTemplate(
						mappedType,
						getStringLiteralType("" + i),
						!!(elementFlags[i] & ElementFlags.Optional),
						mapper,
					);
				},
			);
			var modifiers = getMappedTypeModifiers(mappedType);
			var newTupleModifiers = modifiers & 4 ? map(
				elementFlags, /* IncludeOptional */
				function (f) {
					return f & ElementFlags.Required ? ElementFlags.Optional : f;
				},
			) : modifiers & 8 ? map(
				elementFlags, /* ExcludeOptional */
				function (f) {
					return f & ElementFlags.Optional ? ElementFlags.Required : f;
				},
			) : elementFlags;
			var newReadonly = getModifiedReadonlyState(
				tupleType.target.readonly,
				modifiers,
			);
			return contains(elementTypes, errorType) ? errorType : createTupleType(
				elementTypes,
				newTupleModifiers,
				newReadonly,
				tupleType.target.labeledElementDeclarations,
			);
		}
		function instantiateMappedTypeTemplate(type, key, isOptional, mapper) {
			var templateMapper = appendTypeMapping(
				mapper,
				getTypeParameterFromMappedType(type),
				key,
			);
			var propType = instantiateType(
				getTemplateTypeFromMappedType(type.target || type),
				templateMapper,
			);
			var modifiers = getMappedTypeModifiers(type);
			return strictNullChecks && modifiers & 4 && !maybeTypeOfKind(
				propType, /* IncludeOptional */
				TypeFlags.Undefined | TypeFlags.Void,
			) ? getOptionalType(propType, /*isProperty*/ true) : strictNullChecks && modifiers & 8 && isOptional ? getTypeWithFacts(
				propType, /* ExcludeOptional */
				524288, /* NEUndefined */
			) : propType;
		}
		function instantiateAnonymousType(
			type,
			mapper,
			aliasSymbol,
			aliasTypeArguments,
		) {
			var result = createObjectType(
				type.objectFlags | ObjectFlags.Instantiated,
				type.symbol,
			);
			if (type.objectFlags & ObjectFlags.Mapped) {
				result.declaration = type.declaration;
				// C.f. instantiateSignature
				var origTypeParameter = getTypeParameterFromMappedType(type);
				var freshTypeParameter = cloneTypeParameter(origTypeParameter);
				result.typeParameter = freshTypeParameter;
				mapper = combineTypeMappers(
					makeUnaryTypeMapper(origTypeParameter, freshTypeParameter),
					mapper,
				);
				freshTypeParameter.mapper = mapper;
			}
			result.target = type;
			result.mapper = mapper;
			result.aliasSymbol = aliasSymbol || type.aliasSymbol;
			result.aliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(
				type.aliasTypeArguments,
				mapper,
			);
			return result;
		}
		function getConditionalTypeInstantiation(
			type,
			mapper,
			aliasSymbol,
			aliasTypeArguments,
		) {
			var root = type.root;
			if (root.outerTypeParameters) {
				// We are instantiating a conditional type that has one or more type parameters in scope. Apply the
				// mapper to the type parameters to produce the effective list of type arguments, and compute the
				// instantiation cache key from the type IDs of the type arguments.
				var typeArguments = map(
					root.outerTypeParameters,
					function (t) {
						return getMappedType(t, mapper);
					},
				);
				var id = getTypeListId(typeArguments) + getAliasId(
					aliasSymbol,
					aliasTypeArguments,
				);
				var result = root.instantiations.get(id);
				if (!result) {
					var newMapper_1 = createTypeMapper(
						root.outerTypeParameters,
						typeArguments,
					);
					var checkType_1 = root.checkType;
					var distributionType = root.isDistributive ? getMappedType(
						checkType_1,
						newMapper_1,
					) : undefined;
					// Distributive conditional types are distributed over union types. For example, when the
					// distributive conditional type T extends U ? X : Y is instantiated with A | B for T, the
					// result is (A extends U ? X : Y) | (B extends U ? X : Y).
					result = distributionType && checkType_1 !== distributionType && distributionType.flags & (TypeFlags.Union | TypeFlags.Never) ? mapTypeWithAlias(
						distributionType,
						function (t) {
							return getConditionalType(
								root,
								prependTypeMapping(checkType_1, t, newMapper_1),
							);
						},
						aliasSymbol,
						aliasTypeArguments,
					) : getConditionalType(
						root,
						newMapper_1,
						aliasSymbol,
						aliasTypeArguments,
					);
					root.instantiations.set(id, result);
				}
				return result;
			}
			return type;
		}
		function instantiateType(type, mapper) {
			return type && mapper ? instantiateTypeWithAlias(
				type,
				mapper, /*aliasSymbol*/
				undefined, /*aliasTypeArguments*/
				undefined,
			) : type;
		}
		function instantiateTypeWithAlias(
			type,
			mapper,
			aliasSymbol,
			aliasTypeArguments,
		) {
			if (!couldContainTypeVariables(type)) {
				return type;
			}
			if (instantiationDepth === 100 || instantiationCount >= 5000000) {
				// We have reached 100 recursive type instantiations, or 5M type instantiations caused by the same statement
				// or expression. There is a very high likelyhood we're dealing with a combination of infinite generic types
				// that perpetually generate new type identities, so we stop the recursion here by yielding the error type.
				tracing === null || tracing === void 0 ? void 0 : tracing.instant(
					tracing.Phase.CheckTypes,
					"instantiateType_DepthLimit",
					{
						typeId: type.id,
						instantiationDepth: instantiationDepth,
						instantiationCount: instantiationCount,
					},
				);
				error(
					currentNode,
					Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite,
				);
				return errorType;
			}
			totalInstantiationCount++;
			instantiationCount++;
			instantiationDepth++;
			var result = instantiateTypeWorker(
				type,
				mapper,
				aliasSymbol,
				aliasTypeArguments,
			);
			instantiationDepth--;
			return result;
		}
		function instantiateTypeWorker(
			type,
			mapper,
			aliasSymbol,
			aliasTypeArguments,
		) {
			var flags = type.flags;
			if (flags & TypeFlags.TypeParameter) {
				return getMappedType(type, mapper);
			}
			if (flags & TypeFlags.Object) {
				var objectFlags = type.objectFlags;
				if (
					objectFlags & (ObjectFlags.Reference | ObjectFlags.Anonymous | ObjectFlags.Mapped)
				) {
					if (objectFlags & ObjectFlags.Reference && !type.node) {
						var resolvedTypeArguments = type.resolvedTypeArguments;
						var newTypeArguments = instantiateTypes(
							resolvedTypeArguments,
							mapper,
						);
						return newTypeArguments !== resolvedTypeArguments ? createNormalizedTypeReference(
							type.target,
							newTypeArguments,
						) : type;
					}
					if (objectFlags & ObjectFlags.ReverseMapped) {
						return instantiateReverseMappedType(type, mapper);
					}
					return getObjectTypeInstantiation(
						type,
						mapper,
						aliasSymbol,
						aliasTypeArguments,
					);
				}
				return type;
			}
			if (flags & TypeFlags.UnionOrIntersection) {
				var origin_3 = type.flags & TypeFlags.Union ? type.origin : undefined;
				var types = origin_3 && origin_3.flags & TypeFlags.UnionOrIntersection ? origin_3.types : type.types;
				var newTypes = instantiateTypes(types, mapper);
				if (newTypes === types && aliasSymbol === type.aliasSymbol) {
					return type;
				}
				var newAliasSymbol = aliasSymbol || type.aliasSymbol;
				var newAliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(
					type.aliasTypeArguments,
					mapper,
				);
				return flags & TypeFlags.Intersection || origin_3 && origin_3.flags & TypeFlags.Intersection ? getIntersectionType(
					newTypes,
					newAliasSymbol,
					newAliasTypeArguments,
				) : getUnionType(
					newTypes,
					UnionReduction.Literal,
					newAliasSymbol,
					newAliasTypeArguments,
				);
			}
			if (flags & TypeFlags.Index) {
				return getIndexType(instantiateType(type.type, mapper));
			}
			if (flags & TypeFlags.TemplateLiteral) {
				return getTemplateLiteralType(
					type.texts,
					instantiateTypes(type.types, mapper),
				);
			}
			if (flags & TypeFlags.StringMapping) {
				return getStringMappingType(
					type.symbol,
					instantiateType(type.type, mapper),
				);
			}
			if (flags & TypeFlags.IndexedAccess) {
				var newAliasSymbol = aliasSymbol || type.aliasSymbol;
				var newAliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(
					type.aliasTypeArguments,
					mapper,
				);
				return getIndexedAccessType(
					instantiateType(type.objectType, mapper),
					instantiateType(type.indexType, mapper),
					type.accessFlags, /*accessNode*/
					undefined,
					newAliasSymbol,
					newAliasTypeArguments,
				);
			}
			if (flags & TypeFlags.Conditional) {
				return getConditionalTypeInstantiation(
					type,
					combineTypeMappers(type.mapper, mapper),
					aliasSymbol,
					aliasTypeArguments,
				);
			}
			if (flags & TypeFlags.Substitution) {
				var maybeVariable = instantiateType(type.baseType, mapper);
				if (maybeVariable.flags & TypeFlags.TypeVariable) {
					return getSubstitutionType(
						maybeVariable,
						instantiateType(type.substitute, mapper),
					);
				} else {
					var sub = instantiateType(type.substitute, mapper);
					if (
						sub.flags & TypeFlags.AnyOrUnknown || isTypeAssignableTo(
							getRestrictiveInstantiation(maybeVariable),
							getRestrictiveInstantiation(sub),
						)
					) {
						return maybeVariable;
					}
					return sub;
				}
			}
			return type;
		}
		function instantiateReverseMappedType(type, mapper) {
			var innerMappedType = instantiateType(type.mappedType, mapper);
			if (!(getObjectFlags(innerMappedType) & ObjectFlags.Mapped)) {
				return type;
			}
			var innerIndexType = instantiateType(type.constraintType, mapper);
			if (!(innerIndexType.flags & TypeFlags.Index)) {
				return type;
			}
			var instantiated = inferTypeForHomomorphicMappedType(
				instantiateType(type.source, mapper),
				innerMappedType,
				innerIndexType,
			);
			if (instantiated) {
				return instantiated;
			}
			return type; // Nested invocation of `inferTypeForHomomorphicMappedType` or the `source` instantiated into something unmappable
		}
		function getPermissiveInstantiation(type) {
			return type.flags & (TypeFlags.Primitive | TypeFlags.AnyOrUnknown | TypeFlags.Never) ? type : type.permissiveInstantiation || (type.permissiveInstantiation = instantiateType(
				type,
				permissiveMapper,
			));
		}
		function getRestrictiveInstantiation(type) {
			if (
				type.flags & (TypeFlags.Primitive | TypeFlags.AnyOrUnknown | TypeFlags.Never)
			) {
				return type;
			}
			if (type.restrictiveInstantiation) {
				return type.restrictiveInstantiation;
			}
			type.restrictiveInstantiation = instantiateType(type, restrictiveMapper);
			// We set the following so we don't attempt to set the restrictive instance of a restrictive instance
			// which is redundant - we'll produce new type identities, but all type params have already been mapped.
			// This also gives us a way to detect restrictive instances upon comparisons and _disable_ the "distributeive constraint"
			// assignability check for them, which is distinctly unsafe, as once you have a restrctive instance, all the type parameters
			// are constrained to `unknown` and produce tons of false positives/negatives!
			type.restrictiveInstantiation.restrictiveInstantiation = type.restrictiveInstantiation;
			return type.restrictiveInstantiation;
		}
		function instantiateIndexInfo(info, mapper) {
			return createIndexInfo(
				info.keyType,
				instantiateType(info.type, mapper),
				info.isReadonly,
				info.declaration,
			);
		}
		// Returns true if the given expression contains (at any level of nesting) a function or arrow expression
		// that is subject to contextual typing.
		function isContextSensitive(node) {
			Debug.assert(
				node.kind !== SyntaxKind.MethodDeclaration || isObjectLiteralMethod(
					node,
				),
			);
			switch (node.kind) {
				case SyntaxKind.FunctionExpression:
				case SyntaxKind.ArrowFunction:
				case SyntaxKind.MethodDeclaration:
				case SyntaxKind.FunctionDeclaration: // Function declarations can have context when annotated with a jsdoc @type
					return isContextSensitiveFunctionLikeDeclaration(node);
				case SyntaxKind.ObjectLiteralExpression:
					return some(node.properties, isContextSensitive);
				case SyntaxKind.ArrayLiteralExpression:
					return some(node.elements, isContextSensitive);
				case SyntaxKind.ConditionalExpression:
					return isContextSensitive(node.whenTrue) || isContextSensitive(
						node.whenFalse,
					);
				case SyntaxKind.BinaryExpression:
					return (node.operatorToken.kind === SyntaxKind.BarBarToken || node.operatorToken.kind === SyntaxKind.QuestionQuestionToken) && (isContextSensitive(
						node.left,
					) || isContextSensitive(node.right));
				case SyntaxKind.PropertyAssignment:
					return isContextSensitive(node.initializer);
				case SyntaxKind.ParenthesizedExpression:
					return isContextSensitive(node.expression);
				case SyntaxKind.JsxAttributes:
					return some(node.properties, isContextSensitive) || isJsxOpeningElement(
						node.parent,
					) && some(node.parent.parent.children, isContextSensitive);
				case SyntaxKind.JsxAttribute:
					{
						// If there is no initializer, JSX attribute has a boolean value of true which is not context sensitive.
						var initializer = node.initializer;
						return !!initializer && isContextSensitive(initializer);
					}
				case SyntaxKind.JsxExpression:
					{
						// It is possible to that node.expression is undefined (e.g <div x={} />)
						var expression = node.expression;
						return !!expression && isContextSensitive(expression);
					}
			}
			return false;
		}
		function isContextSensitiveFunctionLikeDeclaration(node) {
			return (!isFunctionDeclaration(node) || isInJSFile(node) && !!getTypeForDeclarationFromJSDocComment(
				node,
			)) && (hasContextSensitiveParameters(node) || hasContextSensitiveReturnExpression(
				node,
			));
		}
		function hasContextSensitiveReturnExpression(node) {
			// TODO(anhans): A block should be context-sensitive if it has a context-sensitive return value.
			return !node.typeParameters && !getEffectiveReturnTypeNode(node) && !!node.body && node.body.kind !== SyntaxKind.Block && isContextSensitive(
				node.body,
			);
		}
		function isContextSensitiveFunctionOrObjectLiteralMethod(func) {
			return (isInJSFile(func) && isFunctionDeclaration(func) || isFunctionExpressionOrArrowFunction(
				func,
			) || isObjectLiteralMethod(func)) && isContextSensitiveFunctionLikeDeclaration(
				func,
			);
		}
		function getTypeWithoutSignatures(type) {
			if (type.flags & TypeFlags.Object) {
				var resolved = resolveStructuredTypeMembers(type);
				if (
					resolved.constructSignatures.length || resolved.callSignatures.length
				) {
					var result = createObjectType(ObjectFlags.Anonymous, type.symbol);
					result.members = resolved.members;
					result.properties = resolved.properties;
					result.callSignatures = emptyArray;
					result.constructSignatures = emptyArray;
					result.indexInfos = emptyArray;
					return result;
				}
			} else if (type.flags & TypeFlags.Intersection) {
				return getIntersectionType(map(type.types, getTypeWithoutSignatures));
			}
			return type;
		}
		// TYPE CHECKING
		function isTypeIdenticalTo(source, target) {
			return isTypeRelatedTo(source, target, identityRelation);
		}
		function compareTypesIdentical(source, target) {
			return isTypeRelatedTo(source, target, identityRelation) ? Ternary.True : Ternary.False;
		}
		function compareTypesAssignable(source, target) {
			return isTypeRelatedTo(source, target, assignableRelation) ? Ternary.True : Ternary.False;
		}
		function compareTypesSubtypeOf(source, target) {
			return isTypeRelatedTo(source, target, subtypeRelation) ? Ternary.True : Ternary.False;
		}
		function isTypeSubtypeOf(source, target) {
			return isTypeRelatedTo(source, target, subtypeRelation);
		}
		function isTypeAssignableTo(source, target) {
			return isTypeRelatedTo(source, target, assignableRelation);
		}
		// An object type S is considered to be derived from an object type T if
		// S is a union type and every constituent of S is derived from T,
		// T is a union type and S is derived from at least one constituent of T, or
		// S is a type variable with a base constraint that is derived from T,
		// T is one of the global types Object and Function and S is a subtype of T, or
		// T occurs directly or indirectly in an 'extends' clause of S.
		// Note that this check ignores type parameters and only considers the
		// inheritance hierarchy.
		function isTypeDerivedFrom(source, target) {
			return source.flags & TypeFlags.Union ? every(
				source.types,
				function (t) {
					return isTypeDerivedFrom(t, target);
				},
			) : target.flags & TypeFlags.Union ? some(
				target.types,
				function (t) {
					return isTypeDerivedFrom(source, t);
				},
			) : source.flags & TypeFlags.InstantiableNonPrimitive ? isTypeDerivedFrom(
				getBaseConstraintOfType(source) || unknownType,
				target,
			) : target === globalObjectType ? !!(source.flags & (TypeFlags.Object | TypeFlags.NonPrimitive)) : target === globalFunctionType ? !!(source.flags & TypeFlags.Object) && isFunctionObjectType(
				source,
			) : hasBaseType(source, getTargetType(target)) || (isArrayType(target) && !isReadonlyArrayType(
				target,
			) && isTypeDerivedFrom(source, globalReadonlyArrayType));
		}
		/**
         * This is *not* a bi-directional relationship.
         * If one needs to check both directions for comparability, use a second call to this function or 'checkTypeComparableTo'.
         *
         * A type S is comparable to a type T if some (but not necessarily all) of the possible values of S are also possible values of T.
         * It is used to check following cases:
         *   - the types of the left and right sides of equality/inequality operators (`===`, `!==`, `==`, `!=`).
         *   - the types of `case` clause expressions and their respective `switch` expressions.
         *   - the type of an expression in a type assertion with the type being asserted.
         */
		function isTypeComparableTo(source, target) {
			return isTypeRelatedTo(source, target, comparableRelation);
		}
		function areTypesComparable(type1, type2) {
			return isTypeComparableTo(type1, type2) || isTypeComparableTo(
				type2,
				type1,
			);
		}
		function checkTypeAssignableTo(
			source,
			target,
			errorNode,
			headMessage,
			containingMessageChain,
			errorOutputObject,
		) {
			return checkTypeRelatedTo(
				source,
				target,
				assignableRelation,
				errorNode,
				headMessage,
				containingMessageChain,
				errorOutputObject,
			);
		}
		/**
         * Like `checkTypeAssignableTo`, but if it would issue an error, instead performs structural comparisons of the types using the given expression node to
         * attempt to issue more specific errors on, for example, specific object literal properties or tuple members.
         */
		function checkTypeAssignableToAndOptionallyElaborate(
			source,
			target,
			errorNode,
			expr,
			headMessage,
			containingMessageChain,
		) {
			return checkTypeRelatedToAndOptionallyElaborate(
				source,
				target,
				assignableRelation,
				errorNode,
				expr,
				headMessage,
				containingMessageChain, /*errorOutputContainer*/
				undefined,
			);
		}
		function checkTypeRelatedToAndOptionallyElaborate(
			source,
			target,
			relation,
			errorNode,
			expr,
			headMessage,
			containingMessageChain,
			errorOutputContainer,
		) {
			if (isTypeRelatedTo(source, target, relation)) return true;
			if (
				!errorNode || !elaborateError(
					expr,
					source,
					target,
					relation,
					headMessage,
					containingMessageChain,
					errorOutputContainer,
				)
			) {
				return checkTypeRelatedTo(
					source,
					target,
					relation,
					errorNode,
					headMessage,
					containingMessageChain,
					errorOutputContainer,
				);
			}
			return false;
		}
		function isOrHasGenericConditional(type) {
			return !!(type.flags & TypeFlags.Conditional || (type.flags & TypeFlags.Intersection && some(
				type.types,
				isOrHasGenericConditional,
			)));
		}
		function elaborateError(
			node,
			source,
			target,
			relation,
			headMessage,
			containingMessageChain,
			errorOutputContainer,
		) {
			if (!node || isOrHasGenericConditional(target)) return false;
			if (
				!checkTypeRelatedTo(source, target, relation, /*errorNode*/ undefined) && elaborateDidYouMeanToCallOrConstruct(
					node,
					source,
					target,
					relation,
					headMessage,
					containingMessageChain,
					errorOutputContainer,
				)
			) {
				return true;
			}
			switch (node.kind) {
				case SyntaxKind.JsxExpression:
				case SyntaxKind.ParenthesizedExpression:
					return elaborateError(
						node.expression,
						source,
						target,
						relation,
						headMessage,
						containingMessageChain,
						errorOutputContainer,
					);
				case SyntaxKind.BinaryExpression:
					switch (node.operatorToken.kind) {
						case SyntaxKind.EqualsToken:
						case SyntaxKind.CommaToken:
							return elaborateError(
								node.right,
								source,
								target,
								relation,
								headMessage,
								containingMessageChain,
								errorOutputContainer,
							);
					}
					break;
				case SyntaxKind.ObjectLiteralExpression:
					return elaborateObjectLiteral(
						node,
						source,
						target,
						relation,
						containingMessageChain,
						errorOutputContainer,
					);
				case SyntaxKind.ArrayLiteralExpression:
					return elaborateArrayLiteral(
						node,
						source,
						target,
						relation,
						containingMessageChain,
						errorOutputContainer,
					);
				case SyntaxKind.JsxAttributes:
					return elaborateJsxComponents(
						node,
						source,
						target,
						relation,
						containingMessageChain,
						errorOutputContainer,
					);
				case SyntaxKind.ArrowFunction:
					return elaborateArrowFunction(
						node,
						source,
						target,
						relation,
						containingMessageChain,
						errorOutputContainer,
					);
			}
			return false;
		}
		function elaborateDidYouMeanToCallOrConstruct(
			node,
			source,
			target,
			relation,
			headMessage,
			containingMessageChain,
			errorOutputContainer,
		) {
			var callSignatures = getSignaturesOfType(source, SignatureKind.Call);
			var constructSignatures = getSignaturesOfType(
				source,
				SignatureKind.Construct,
			);
			for (
				var _i = 0, _a = [constructSignatures, callSignatures];
				_i < _a.length;
				_i++
			) {
				var signatures = _a[_i];
				if (
					some(
						signatures,
						function (s) {
							var returnType = getReturnTypeOfSignature(s);
							return !(returnType.flags & (TypeFlags.Any | TypeFlags.Never)) && checkTypeRelatedTo(
								returnType,
								target,
								relation, /*errorNode*/
								undefined,
							);
						},
					)
				) {
					var resultObj = errorOutputContainer || {};
					checkTypeAssignableTo(
						source,
						target,
						node,
						headMessage,
						containingMessageChain,
						resultObj,
					);
					var diagnostic = resultObj.errors[resultObj.errors.length - 1];
					addRelatedInfo(
						diagnostic,
						createDiagnosticForNode(
							node,
							signatures === constructSignatures ? Diagnostics.Did_you_mean_to_use_new_with_this_expression : Diagnostics.Did_you_mean_to_call_this_expression,
						),
					);
					return true;
				}
			}
			return false;
		}
		function elaborateArrowFunction(
			node,
			source,
			target,
			relation,
			containingMessageChain,
			errorOutputContainer,
		) {
			// Don't elaborate blocks
			if (isBlock(node.body)) {
				return false;
			}
			// Or functions with annotated parameter types
			if (some(node.parameters, ts.hasType)) {
				return false;
			}
			var sourceSig = getSingleCallSignature(source);
			if (!sourceSig) {
				return false;
			}
			var targetSignatures = getSignaturesOfType(target, SignatureKind.Call);
			if (!length(targetSignatures)) {
				return false;
			}
			var returnExpression = node.body;
			var sourceReturn = getReturnTypeOfSignature(sourceSig);
			var targetReturn = getUnionType(
				map(targetSignatures, getReturnTypeOfSignature),
			);
			if (
				!checkTypeRelatedTo(
					sourceReturn,
					targetReturn,
					relation, /*errorNode*/
					undefined,
				)
			) {
				var elaborated = returnExpression && elaborateError(
					returnExpression,
					sourceReturn,
					targetReturn,
					relation, /*headMessage*/
					undefined,
					containingMessageChain,
					errorOutputContainer,
				);
				if (elaborated) {
					return elaborated;
				}
				var resultObj = errorOutputContainer || {};
				checkTypeRelatedTo(
					sourceReturn,
					targetReturn,
					relation,
					returnExpression, /*message*/
					undefined,
					containingMessageChain,
					resultObj,
				);
				if (resultObj.errors) {
					if (target.symbol && length(target.symbol.declarations)) {
						addRelatedInfo(
							resultObj.errors[resultObj.errors.length - 1],
							createDiagnosticForNode(
								target.symbol.declarations[0],
								Diagnostics.The_expected_type_comes_from_the_return_type_of_this_signature,
							),
						);
					}
					if (
						(getFunctionFlags(node) & FunctionFlags.Async) === 0 && !getTypeOfPropertyOfType( // an IPromise and a Promise that are slightly different // exclude cases where source itself is promisy - this way we don't make a suggestion when relating
							sourceReturn,
							"then",
						) && checkTypeRelatedTo(
							createPromiseType(sourceReturn),
							targetReturn,
							relation, /*errorNode*/
							undefined,
						)
					) {
						addRelatedInfo(
							resultObj.errors[resultObj.errors.length - 1],
							createDiagnosticForNode(
								node,
								Diagnostics.Did_you_mean_to_mark_this_function_as_async,
							),
						);
					}
					return true;
				}
			}
			return false;
		}
		function getBestMatchIndexedAccessTypeOrUndefined(source, target, nameType) {
			var idx = getIndexedAccessTypeOrUndefined(target, nameType);
			if (idx) {
				return idx;
			}
			if (target.flags & TypeFlags.Union) {
				var best = getBestMatchingType(source, target);
				if (best) {
					return getIndexedAccessTypeOrUndefined(best, nameType);
				}
			}
		}
		function checkExpressionForMutableLocationWithContextualType(
			next,
			sourcePropType,
		) {
			next.contextualType = sourcePropType;
			try {
				return checkExpressionForMutableLocation(
					next,
					1, /* Contextual */
					sourcePropType,
				);
			} finally {
				next.contextualType = undefined;
			}
		}
		/**
         * For every element returned from the iterator, checks that element to issue an error on a property of that element's type
         * If that element would issue an error, we first attempt to dive into that element's inner expression and issue a more specific error by recuring into `elaborateError`
         * Otherwise, we issue an error on _every_ element which fail the assignability check
         */
		function elaborateElementwise(
			iterator,
			source,
			target,
			relation,
			containingMessageChain,
			errorOutputContainer,
		) {
			// Assignability failure - check each prop individually, and if that fails, fall back on the bad error span
			var reportedError = false;
			for (
				var status_1 = iterator.next();
				!status_1.done;
				status_1 = iterator.next()
			) {
				var _a = status_1.value,
					prop = _a.errorNode,
					next = _a.innerExpression,
					nameType = _a.nameType,
					errorMessage = _a.errorMessage;
				var targetPropType = getBestMatchIndexedAccessTypeOrUndefined(
					source,
					target,
					nameType,
				);
				if (!targetPropType || targetPropType.flags & TypeFlags.IndexedAccess) continue; // Don't elaborate on indexes on generic variables
				var sourcePropType = getIndexedAccessTypeOrUndefined(source, nameType);
				if (!sourcePropType) continue;
				var propName = getPropertyNameFromIndex(
					nameType, /*accessNode*/
					undefined,
				);
				if (
					!checkTypeRelatedTo(
						sourcePropType,
						targetPropType,
						relation, /*errorNode*/
						undefined,
					)
				) {
					var elaborated = next && elaborateError(
						next,
						sourcePropType,
						targetPropType,
						relation, /*headMessage*/
						undefined,
						containingMessageChain,
						errorOutputContainer,
					);
					reportedError = true;
					if (!elaborated) {
						// Issue error on the prop itself, since the prop couldn't elaborate the error
						var resultObj = errorOutputContainer || {};
						// Use the expression type, if available
						var specificSource = next ? checkExpressionForMutableLocationWithContextualType(
							next,
							sourcePropType,
						) : sourcePropType;
						if (
							exactOptionalPropertyTypes && isExactOptionalPropertyMismatch(
								specificSource,
								targetPropType,
							)
						) {
							var diag = createDiagnosticForNode(
								prop,
								Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target,
								typeToString(specificSource),
								typeToString(targetPropType),
							);
							diagnostics.add(diag);
							resultObj.errors = [diag];
						} else {
							var targetIsOptional = !!(propName && (getPropertyOfType(
								target,
								propName,
							) || unknownSymbol).flags & SymbolFlags.Optional);
							var sourceIsOptional = !!(propName && (getPropertyOfType(
								source,
								propName,
							) || unknownSymbol).flags & SymbolFlags.Optional);
							targetPropType = removeMissingType(
								targetPropType,
								targetIsOptional,
							);
							sourcePropType = removeMissingType(
								sourcePropType,
								targetIsOptional && sourceIsOptional,
							);
							var result = checkTypeRelatedTo(
								specificSource,
								targetPropType,
								relation,
								prop,
								errorMessage,
								containingMessageChain,
								resultObj,
							);
							if (result && specificSource !== sourcePropType) {
								// If for whatever reason the expression type doesn't yield an error, make sure we still issue an error on the sourcePropType
								checkTypeRelatedTo(
									sourcePropType,
									targetPropType,
									relation,
									prop,
									errorMessage,
									containingMessageChain,
									resultObj,
								);
							}
						}
						if (resultObj.errors) {
							var reportedDiag = resultObj.errors[resultObj.errors.length - 1];
							var propertyName = isTypeUsableAsPropertyName(nameType) ? getPropertyNameFromType(
								nameType,
							) : undefined;
							var targetProp = propertyName !== undefined ? getPropertyOfType(
								target,
								propertyName,
							) : undefined;
							var issuedElaboration = false;
							if (!targetProp) {
								var indexInfo = getApplicableIndexInfo(target, nameType);
								if (
									indexInfo && indexInfo.declaration && !getSourceFileOfNode(
										indexInfo.declaration,
									).hasNoDefaultLib
								) {
									issuedElaboration = true;
									addRelatedInfo(
										reportedDiag,
										createDiagnosticForNode(
											indexInfo.declaration,
											Diagnostics.The_expected_type_comes_from_this_index_signature,
										),
									);
								}
							}
							if (
								!issuedElaboration && (targetProp && length(
									targetProp.declarations,
								) || target.symbol && length(target.symbol.declarations))
							) {
								var targetNode = targetProp && length(targetProp.declarations) ? targetProp.declarations[0] : target.symbol.declarations[0];
								if (!getSourceFileOfNode(targetNode).hasNoDefaultLib) {
									addRelatedInfo(
										reportedDiag,
										createDiagnosticForNode(
											targetNode,
											Diagnostics.The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1,
											propertyName && !(nameType.flags & TypeFlags.UniqueESSymbol) ? unescapeLeadingUnderscores(
												propertyName,
											) : typeToString(nameType),
											typeToString(target),
										),
									);
								}
							}
						}
					}
				}
			}
			return reportedError;
		}
		function generateJsxAttributes(node) {
			var _i, _a, prop;
			return __generator(
				this,
				function (_b) {
					switch (_b.label) {
						case 0:
							if (!length(node.properties)) return [2 /*return*/ ];
							_i = 0, _a = node.properties;
							_b.label = 1;
						case 1:
							if (!(_i < _a.length)) return [3 /*break*/ , 4];
							prop = _a[_i];
							if (
								isJsxSpreadAttribute(prop) || isHyphenatedJsxName(
									idText(prop.name),
								)
							) return [3 /*break*/ , 3];
							return [
								4, /*yield*/
								{
									errorNode: prop.name,
									innerExpression: prop.initializer,
									nameType: getStringLiteralType(idText(prop.name)),
								},
							];
						case 2:
							_b.sent();
							_b.label = 3;
						case 3:
							_i++;
							return [3 /*break*/ , 1];
						case 4:
							return [2 /*return*/ ];
					}
				},
			);
		}
		function generateJsxChildren(node, getInvalidTextDiagnostic) {
			var memberOffset, i, child, nameType, elem;
			return __generator(
				this,
				function (_a) {
					switch (_a.label) {
						case 0:
							if (!length(node.children)) return [2 /*return*/ ];
							memberOffset = 0;
							i = 0;
							_a.label = 1;
						case 1:
							if (!(i < node.children.length)) return [3 /*break*/ , 5];
							child = node.children[i];
							nameType = getNumberLiteralType(i - memberOffset);
							elem = getElaborationElementForJsxChild(
								child,
								nameType,
								getInvalidTextDiagnostic,
							);
							if (!elem) return [3 /*break*/ , 3];
							return [4 /*yield*/ , elem];
						case 2:
							_a.sent();
							return [3 /*break*/ , 4];
						case 3:
							memberOffset++;
							_a.label = 4;
						case 4:
							i++;
							return [3 /*break*/ , 1];
						case 5:
							return [2 /*return*/ ];
					}
				},
			);
		}
		function getElaborationElementForJsxChild(
			child,
			nameType,
			getInvalidTextDiagnostic,
		) {
			switch (child.kind) {
				case SyntaxKind.JsxExpression:
					// child is of the type of the expression
					return {
						errorNode: child,
						innerExpression: child.expression,
						nameType: nameType,
					};
				case SyntaxKind.JsxText:
					if (child.containsOnlyTriviaWhiteSpaces) {
						break; // Whitespace only jsx text isn't real jsx text
					}
					// child is a string
					return {
						errorNode: child,
						innerExpression: undefined,
						nameType: nameType,
						errorMessage: getInvalidTextDiagnostic(),
					};
				case SyntaxKind.JsxElement:
				case SyntaxKind.JsxSelfClosingElement:
				case SyntaxKind.JsxFragment:
					// child is of type JSX.Element
					return {
						errorNode: child,
						innerExpression: child,
						nameType: nameType,
					};
				default:
					return Debug.assertNever(child, "Found invalid jsx child");
			}
		}
		function elaborateJsxComponents(
			node,
			source,
			target,
			relation,
			containingMessageChain,
			errorOutputContainer,
		) {
			var result = elaborateElementwise(
				generateJsxAttributes(node),
				source,
				target,
				relation,
				containingMessageChain,
				errorOutputContainer,
			);
			var invalidTextDiagnostic;
			if (isJsxOpeningElement(node.parent) && isJsxElement(node.parent.parent)) {
				var containingElement = node.parent.parent;
				var childPropName = getJsxElementChildrenPropertyName(
					getJsxNamespaceAt(node),
				);
				var childrenPropName = childPropName === undefined ? "children" : unescapeLeadingUnderscores(
					childPropName,
				);
				var childrenNameType = getStringLiteralType(childrenPropName);
				var childrenTargetType = getIndexedAccessType(target, childrenNameType);
				var validChildren = getSemanticJsxChildren(containingElement.children);
				if (!length(validChildren)) {
					return result;
				}
				var moreThanOneRealChildren = length(validChildren) > 1;
				var arrayLikeTargetParts = filterType(
					childrenTargetType,
					isArrayOrTupleLikeType,
				);
				var nonArrayLikeTargetParts = filterType(
					childrenTargetType,
					function (t) {
						return !isArrayOrTupleLikeType(t);
					},
				);
				if (moreThanOneRealChildren) {
					if (arrayLikeTargetParts !== neverType) {
						var realSource = createTupleType(
							checkJsxChildren(containingElement, 0 /* Normal */ ),
						);
						var children = generateJsxChildren(
							containingElement,
							getInvalidTextualChildDiagnostic,
						);
						result = elaborateElementwise(
							children,
							realSource,
							arrayLikeTargetParts,
							relation,
							containingMessageChain,
							errorOutputContainer,
						) || result;
					} else if (
						!isTypeRelatedTo(
							getIndexedAccessType(source, childrenNameType),
							childrenTargetType,
							relation,
						)
					) {
						// arity mismatch
						result = true;
						var diag = error(
							containingElement.openingElement.tagName,
							Diagnostics.This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided,
							childrenPropName,
							typeToString(childrenTargetType),
						);
						if (errorOutputContainer && errorOutputContainer.skipLogging) {
							(errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(
								diag,
							);
						}
					}
				} else {
					if (nonArrayLikeTargetParts !== neverType) {
						var child = validChildren[0];
						var elem_1 = getElaborationElementForJsxChild(
							child,
							childrenNameType,
							getInvalidTextualChildDiagnostic,
						);
						if (elem_1) {
							result = elaborateElementwise(
								(function () {
									return __generator(
										this,
										function (_a) {
											switch (_a.label) {
												case 0:
													return [4 /*yield*/ , elem_1];
												case 1:
													_a.sent();
													return [2 /*return*/ ];
											}
										},
									);
								})(),
								source,
								target,
								relation,
								containingMessageChain,
								errorOutputContainer,
							) || result;
						}
					} else if (
						!isTypeRelatedTo(
							getIndexedAccessType(source, childrenNameType),
							childrenTargetType,
							relation,
						)
					) {
						// arity mismatch
						result = true;
						var diag = error(
							containingElement.openingElement.tagName,
							Diagnostics.This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_provided,
							childrenPropName,
							typeToString(childrenTargetType),
						);
						if (errorOutputContainer && errorOutputContainer.skipLogging) {
							(errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(
								diag,
							);
						}
					}
				}
			}
			return result;
			function getInvalidTextualChildDiagnostic() {
				if (!invalidTextDiagnostic) {
					var tagNameText = getTextOfNode(node.parent.tagName);
					var childPropName = getJsxElementChildrenPropertyName(
						getJsxNamespaceAt(node),
					);
					var childrenPropName = childPropName === undefined ? "children" : unescapeLeadingUnderscores(
						childPropName,
					);
					var childrenTargetType = getIndexedAccessType(
						target,
						getStringLiteralType(childrenPropName),
					);
					var diagnostic = Diagnostics._0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_type_of_1_is_2;
					invalidTextDiagnostic = __assign(
						__assign({}, diagnostic),
						{
							key: "!!ALREADY FORMATTED!!",
							message: formatMessage(
								undefined, /*_dummy*/
								diagnostic,
								tagNameText,
								childrenPropName,
								typeToString(childrenTargetType),
							),
						},
					);
				}
				return invalidTextDiagnostic;
			}
		}
		function generateLimitedTupleElements(node, target) {
			var len, i, elem, nameType;
			return __generator(
				this,
				function (_a) {
					switch (_a.label) {
						case 0:
							len = length(node.elements);
							if (!len) return [2 /*return*/ ];
							i = 0;
							_a.label = 1;
						case 1:
							if (!(i < len)) return [3 /*break*/ , 4];
							// Skip elements which do not exist in the target - a length error on the tuple overall is likely better than an error on a mismatched index signature
							if (
								isTupleLikeType(target) && !getPropertyOfType(target, ("" + i))
							) return [3 /*break*/ , 3];
							elem = node.elements[i];
							if (isOmittedExpression(elem)) return [3 /*break*/ , 3];
							nameType = getNumberLiteralType(i);
							return [
								4, /*yield*/
								{ errorNode: elem, innerExpression: elem, nameType: nameType },
							];
						case 2:
							_a.sent();
							_a.label = 3;
						case 3:
							i++;
							return [3 /*break*/ , 1];
						case 4:
							return [2 /*return*/ ];
					}
				},
			);
		}
		function elaborateArrayLiteral(
			node,
			source,
			target,
			relation,
			containingMessageChain,
			errorOutputContainer,
		) {
			if (target.flags & TypeFlags.Primitive) return false;
			if (isTupleLikeType(source)) {
				return elaborateElementwise(
					generateLimitedTupleElements(node, target),
					source,
					target,
					relation,
					containingMessageChain,
					errorOutputContainer,
				);
			}
			// recreate a tuple from the elements, if possible
			// Since we're re-doing the expression type, we need to reapply the contextual type
			var oldContext = node.contextualType;
			node.contextualType = target;
			try {
				var tupleizedType = checkArrayLiteral(
					node,
					1, /* Contextual */ /*forceTuple*/
					true,
				);
				node.contextualType = oldContext;
				if (isTupleLikeType(tupleizedType)) {
					return elaborateElementwise(
						generateLimitedTupleElements(node, target),
						tupleizedType,
						target,
						relation,
						containingMessageChain,
						errorOutputContainer,
					);
				}
				return false;
			} finally {
				node.contextualType = oldContext;
			}
		}
		function generateObjectLiteralElements(node) {
			var _i, _a, prop, type, _b;
			return __generator(
				this,
				function (_c) {
					switch (_c.label) {
						case 0:
							if (!length(node.properties)) return [2 /*return*/ ];
							_i = 0, _a = node.properties;
							_c.label = 1;
						case 1:
							if (!(_i < _a.length)) return [3 /*break*/ , 8];
							prop = _a[_i];
							if (isSpreadAssignment(prop)) return [3 /*break*/ , 7];
							type = getLiteralTypeFromProperty(
								getSymbolOfNode(prop),
								TypeFlags.StringOrNumberLiteralOrUnique,
							);
							if (!type || (type.flags & TypeFlags.Never)) {
								return [3 /*break*/ , 7];
							}
							_b = prop.kind;
							switch (_b) {
								case SyntaxKind.SetAccessor:
									return [3 /*break*/ , 2];
								case SyntaxKind.GetAccessor:
									return [3 /*break*/ , 2];
								case SyntaxKind.MethodDeclaration:
									return [3 /*break*/ , 2];
								case SyntaxKind.ShorthandPropertyAssignment:
									return [3 /*break*/ , 2];
								case SyntaxKind.PropertyAssignment:
									return [3 /*break*/ , 4];
							}
							return [3 /*break*/ , 6];
						case 2:
							return [
								4, /*yield*/
								{
									errorNode: prop.name,
									innerExpression: undefined,
									nameType: type,
								},
							];
						case 3:
							_c.sent();
							return [3 /*break*/ , 7];
						case 4:
							return [
								4, /*yield*/
								{
									errorNode: prop.name,
									innerExpression: prop.initializer,
									nameType: type,
									errorMessage: isComputedNonLiteralName(prop.name) ? Diagnostics.Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1 : undefined,
								},
							];
						case 5:
							_c.sent();
							return [3 /*break*/ , 7];
						case 6:
							Debug.assertNever(prop);
							_c.label = 7;
						case 7:
							_i++;
							return [3 /*break*/ , 1];
						case 8:
							return [2 /*return*/ ];
					}
				},
			);
		}
		function elaborateObjectLiteral(
			node,
			source,
			target,
			relation,
			containingMessageChain,
			errorOutputContainer,
		) {
			if (target.flags & TypeFlags.Primitive) return false;
			return elaborateElementwise(
				generateObjectLiteralElements(node),
				source,
				target,
				relation,
				containingMessageChain,
				errorOutputContainer,
			);
		}
		/**
         * This is *not* a bi-directional relationship.
         * If one needs to check both directions for comparability, use a second call to this function or 'isTypeComparableTo'.
         */
		function checkTypeComparableTo(
			source,
			target,
			errorNode,
			headMessage,
			containingMessageChain,
		) {
			return checkTypeRelatedTo(
				source,
				target,
				comparableRelation,
				errorNode,
				headMessage,
				containingMessageChain,
			);
		}
		function isSignatureAssignableTo(source, target, ignoreReturnTypes) {
			return compareSignaturesRelated(
				source,
				target,
				ignoreReturnTypes ? 4 : 0, /* IgnoreReturnTypes */ /*reportErrors*/
				false,
				/*errorReporter*/ undefined, /*errorReporter*/
				undefined,
				compareTypesAssignable, /*reportUnreliableMarkers*/
				undefined,
			) !== Ternary.False;
		}
		/**
         * Returns true if `s` is `(...args: any[]) => any` or `(this: any, ...args: any[]) => any`
         */
		function isAnySignature(s) {
			return !s.typeParameters && (!s.thisParameter || isTypeAny(
				getTypeOfParameter(s.thisParameter),
			)) && s.parameters.length === 1 && signatureHasRestParameter(s) && (getTypeOfParameter(
				s.parameters[0],
			) === anyArrayType || isTypeAny(getTypeOfParameter(s.parameters[0]))) && isTypeAny(
				getReturnTypeOfSignature(s),
			);
		}
		/**
         * See signatureRelatedTo, compareSignaturesIdentical
         */
		function compareSignaturesRelated(
			source,
			target,
			checkMode,
			reportErrors,
			errorReporter,
			incompatibleErrorReporter,
			compareTypes,
			reportUnreliableMarkers,
		) {
			// TODO (drosen): De-duplicate code between related functions.
			if (source === target) {
				return Ternary.True;
			}
			if (isAnySignature(target)) {
				return Ternary.True;
			}
			var targetCount = getParameterCount(target);
			var sourceHasMoreParameters = !hasEffectiveRestParameter(target) && (checkMode & 8 ? hasEffectiveRestParameter(
				source, /* StrictArity */
			) || getParameterCount(source) > targetCount : getMinArgumentCount(source) > targetCount);
			if (sourceHasMoreParameters) {
				return Ternary.False;
			}
			if (
				source.typeParameters && source.typeParameters !== target.typeParameters
			) {
				target = getCanonicalSignature(target);
				source = instantiateSignatureInContextOf(
					source,
					target, /*inferenceContext*/
					undefined,
					compareTypes,
				);
			}
			var sourceCount = getParameterCount(source);
			var sourceRestType = getNonArrayRestType(source);
			var targetRestType = getNonArrayRestType(target);
			if (sourceRestType || targetRestType) {
				void instantiateType(
					sourceRestType || targetRestType,
					reportUnreliableMarkers,
				);
			}
			if (sourceRestType && targetRestType && sourceCount !== targetCount) {
				// We're not able to relate misaligned complex rest parameters
				return Ternary.False;
			}
			var kind = target.declaration ? target.declaration.kind : SyntaxKind.Unknown;
			var strictVariance = !(checkMode & 3) && strictFunctionTypes && kind !== SyntaxKind.MethodDeclaration && kind !== SyntaxKind.MethodSignature && kind !== SyntaxKind.Constructor; /* Callback */
			var result = Ternary.True;
			var sourceThisType = getThisTypeOfSignature(source);
			if (sourceThisType && sourceThisType !== voidType) {
				var targetThisType = getThisTypeOfSignature(target);
				if (targetThisType) {
					// void sources are assignable to anything.
					var related = !strictVariance && compareTypes(
						sourceThisType,
						targetThisType, /*reportErrors*/
						false,
					) || compareTypes(targetThisType, sourceThisType, reportErrors);
					if (!related) {
						if (reportErrors) {
							errorReporter(
								Diagnostics.The_this_types_of_each_signature_are_incompatible,
							);
						}
						return Ternary.False;
					}
					result &= related;
				}
			}
			var paramCount = sourceRestType || targetRestType ? Math.min(
				sourceCount,
				targetCount,
			) : Math.max(sourceCount, targetCount);
			var restIndex = sourceRestType || targetRestType ? paramCount - 1 : -1;
			for (var i = 0; i < paramCount; i++) {
				var sourceType = i === restIndex ? getRestTypeAtPosition(source, i) : tryGetTypeAtPosition(
					source,
					i,
				);
				var targetType = i === restIndex ? getRestTypeAtPosition(target, i) : tryGetTypeAtPosition(
					target,
					i,
				);
				if (sourceType && targetType) {
					// In order to ensure that any generic type Foo<T> is at least co-variant with respect to T no matter
					// how Foo uses T, we need to relate parameters bi-variantly (given that parameters are input positions,
					// they naturally relate only contra-variantly). However, if the source and target parameters both have
					// function types with a single call signature, we know we are relating two callback parameters. In
					// that case it is sufficient to only relate the parameters of the signatures co-variantly because,
					// similar to return values, callback parameters are output positions. This means that a Promise<T>,
					// where T is used only in callback parameter positions, will be co-variant (as opposed to bi-variant)
					// with respect to T.
					var sourceSig = checkMode & 3 ? undefined : getSingleCallSignature(
						getNonNullableType(sourceType), /* Callback */
					);
					var targetSig = checkMode & 3 ? undefined : getSingleCallSignature(
						getNonNullableType(targetType), /* Callback */
					);
					var callbacks = sourceSig && targetSig && !getTypePredicateOfSignature(
						sourceSig,
					) && !getTypePredicateOfSignature(targetSig) && (getFalsyFlags(
						sourceType,
					) & TypeFlags.Nullable) === (getFalsyFlags(targetType) & TypeFlags.Nullable);
					var related = callbacks ? compareSignaturesRelated(
						targetSig,
						sourceSig,
						(checkMode & 8) | (strictVariance ? 2 : 1), /* StrictArity */ /* StrictCallback */ /* BivariantCallback */
						reportErrors,
						errorReporter,
						incompatibleErrorReporter,
						compareTypes,
						reportUnreliableMarkers,
					) : !(checkMode & 3) && !strictVariance && compareTypes(
						sourceType, /* Callback */
						targetType, /*reportErrors*/
						false,
					) || compareTypes(targetType, sourceType, reportErrors);
					// With strict arity, (x: number | undefined) => void is a subtype of (x?: number | undefined) => void
					if (
						related && checkMode & 8 && i >= getMinArgumentCount(source) && i < getMinArgumentCount(
							target, /* StrictArity */
						) && compareTypes(sourceType, targetType, /*reportErrors*/ false)
					) {
						related = Ternary.False;
					}
					if (!related) {
						if (reportErrors) {
							errorReporter(
								Diagnostics.Types_of_parameters_0_and_1_are_incompatible,
								unescapeLeadingUnderscores(
									getParameterNameAtPosition(source, i),
								),
								unescapeLeadingUnderscores(
									getParameterNameAtPosition(target, i),
								),
							);
						}
						return Ternary.False;
					}
					result &= related;
				}
			}
			if (!(checkMode & 4 /* IgnoreReturnTypes */ )) {
				// If a signature resolution is already in-flight, skip issuing a circularity error
				// here and just use the `any` type directly
				var targetReturnType = isResolvingReturnTypeOfSignature(target) ? anyType : target.declaration && isJSConstructor(
					target.declaration,
				) ? getDeclaredTypeOfClassOrInterface(
					getMergedSymbol(target.declaration.symbol),
				) : getReturnTypeOfSignature(target);
				if (targetReturnType === voidType) {
					return result;
				}
				var sourceReturnType = isResolvingReturnTypeOfSignature(source) ? anyType : source.declaration && isJSConstructor(
					source.declaration,
				) ? getDeclaredTypeOfClassOrInterface(
					getMergedSymbol(source.declaration.symbol),
				) : getReturnTypeOfSignature(source);
				// The following block preserves behavior forbidding boolean returning functions from being assignable to type guard returning functions
				var targetTypePredicate = getTypePredicateOfSignature(target);
				if (targetTypePredicate) {
					var sourceTypePredicate = getTypePredicateOfSignature(source);
					if (sourceTypePredicate) {
						result &= compareTypePredicateRelatedTo(
							sourceTypePredicate,
							targetTypePredicate,
							reportErrors,
							errorReporter,
							compareTypes,
						);
					} else if (isIdentifierTypePredicate(targetTypePredicate)) {
						if (reportErrors) {
							errorReporter(
								Diagnostics.Signature_0_must_be_a_type_predicate,
								signatureToString(source),
							);
						}
						return Ternary.False;
					}
				} else {
					// When relating callback signatures, we still need to relate return types bi-variantly as otherwise
					// the containing type wouldn't be co-variant. For example, interface Foo<T> { add(cb: () => T): void }
					// wouldn't be co-variant for T without this rule.
					result &= checkMode & 1 && compareTypes(
						targetReturnType, /* BivariantCallback */
						sourceReturnType, /*reportErrors*/
						false,
					) || compareTypes(sourceReturnType, targetReturnType, reportErrors);
					if (!result && reportErrors && incompatibleErrorReporter) {
						incompatibleErrorReporter(sourceReturnType, targetReturnType);
					}
				}
			}
			return result;
		}
		function compareTypePredicateRelatedTo(
			source,
			target,
			reportErrors,
			errorReporter,
			compareTypes,
		) {
			if (source.kind !== target.kind) {
				if (reportErrors) {
					errorReporter(
						Diagnostics.A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard,
					);
					errorReporter(
						Diagnostics.Type_predicate_0_is_not_assignable_to_1,
						typePredicateToString(source),
						typePredicateToString(target),
					);
				}
				return Ternary.False;
			}
			if (
				source.kind === TypePredicateKind.Identifier || source.kind === TypePredicateKind.AssertsIdentifier
			) {
				if (source.parameterIndex !== target.parameterIndex) {
					if (reportErrors) {
						errorReporter(
							Diagnostics.Parameter_0_is_not_in_the_same_position_as_parameter_1,
							source.parameterName,
							target.parameterName,
						);
						errorReporter(
							Diagnostics.Type_predicate_0_is_not_assignable_to_1,
							typePredicateToString(source),
							typePredicateToString(target),
						);
					}
					return Ternary.False;
				}
			}
			var related = source.type === target.type ? Ternary.True : source.type && target.type ? compareTypes(
				source.type,
				target.type,
				reportErrors,
			) : Ternary.False;
			if (related === Ternary.False && reportErrors) {
				errorReporter(
					Diagnostics.Type_predicate_0_is_not_assignable_to_1,
					typePredicateToString(source),
					typePredicateToString(target),
				);
			}
			return related;
		}
		function isImplementationCompatibleWithOverload(implementation, overload) {
			var erasedSource = getErasedSignature(implementation);
			var erasedTarget = getErasedSignature(overload);
			// First see if the return types are compatible in either direction.
			var sourceReturnType = getReturnTypeOfSignature(erasedSource);
			var targetReturnType = getReturnTypeOfSignature(erasedTarget);
			if (
				targetReturnType === voidType || isTypeRelatedTo(
					targetReturnType,
					sourceReturnType,
					assignableRelation,
				) || isTypeRelatedTo(
					sourceReturnType,
					targetReturnType,
					assignableRelation,
				)
			) {
				return isSignatureAssignableTo(
					erasedSource,
					erasedTarget, /*ignoreReturnTypes*/
					true,
				);
			}
			return false;
		}
		function isEmptyResolvedType(t) {
			return t !== anyFunctionType && t.properties.length === 0 && t.callSignatures.length === 0 && t.constructSignatures.length === 0 && t.indexInfos.length === 0;
		}
		function isEmptyObjectType(type) {
			return type.flags & TypeFlags.Object ? !isGenericMappedType(type) && isEmptyResolvedType(
				resolveStructuredTypeMembers(type),
			) : type.flags & TypeFlags.NonPrimitive ? true : type.flags & TypeFlags.Union ? some(
				type.types,
				isEmptyObjectType,
			) : type.flags & TypeFlags.Intersection ? every(
				type.types,
				isEmptyObjectType,
			) : false;
		}
		function isEmptyAnonymousObjectType(type) {
			return !!(getObjectFlags(type) & ObjectFlags.Anonymous && (type.members && isEmptyResolvedType(
				type,
			) || type.symbol && type.symbol.flags & SymbolFlags.TypeLiteral && getMembersOfSymbol(
				type.symbol,
			).size === 0));
		}
		function isStringIndexSignatureOnlyType(type) {
			return type.flags & TypeFlags.Object && !isGenericMappedType(type) && getPropertiesOfType(
				type,
			).length === 0 && getIndexInfosOfType(type).length === 1 && !!getIndexInfoOfType(
				type,
				stringType,
			) || type.flags & TypeFlags.UnionOrIntersection && every(
				type.types,
				isStringIndexSignatureOnlyType,
			) || false;
		}
		function isEnumTypeRelatedTo(sourceSymbol, targetSymbol, errorReporter) {
			if (sourceSymbol === targetSymbol) {
				return true;
			}
			var id = getSymbolId(sourceSymbol) + "," + getSymbolId(targetSymbol);
			var entry = enumRelation.get(id);
			if (
				entry !== undefined && !(!(entry & RelationComparisonResult.Reported) && entry & RelationComparisonResult.Failed && errorReporter)
			) {
				return !!(entry & RelationComparisonResult.Succeeded);
			}
			if (
				sourceSymbol.escapedName !== targetSymbol.escapedName || !(sourceSymbol.flags & SymbolFlags.RegularEnum) || !(targetSymbol.flags & SymbolFlags.RegularEnum)
			) {
				enumRelation.set(
					id,
					RelationComparisonResult.Failed | RelationComparisonResult.Reported,
				);
				return false;
			}
			var targetEnumType = getTypeOfSymbol(targetSymbol);
			for (
				var _i = 0, _a = getPropertiesOfType(getTypeOfSymbol(sourceSymbol));
				_i < _a.length;
				_i++
			) {
				var property = _a[_i];
				if (property.flags & SymbolFlags.EnumMember) {
					var targetProperty = getPropertyOfType(
						targetEnumType,
						property.escapedName,
					);
					if (
						!targetProperty || !(targetProperty.flags & SymbolFlags.EnumMember)
					) {
						if (errorReporter) {
							errorReporter(
								Diagnostics.Property_0_is_missing_in_type_1,
								symbolName(property),
								typeToString(
									getDeclaredTypeOfSymbol(targetSymbol), /*enclosingDeclaration*/
									undefined,
									TypeFormatFlags.UseFullyQualifiedType,
								),
							);
							enumRelation.set(
								id,
								RelationComparisonResult.Failed | RelationComparisonResult.Reported,
							);
						} else {
							enumRelation.set(id, RelationComparisonResult.Failed);
						}
						return false;
					}
				}
			}
			enumRelation.set(id, RelationComparisonResult.Succeeded);
			return true;
		}
		function isSimpleTypeRelatedTo(source, target, relation, errorReporter) {
			var s = source.flags;
			var t = target.flags;
			if (
				t & TypeFlags.AnyOrUnknown || s & TypeFlags.Never || source === wildcardType
			) return true;
			if (t & TypeFlags.Never) return false;
			if (s & TypeFlags.StringLike && t & TypeFlags.String) return true;
			if (
				s & TypeFlags.StringLiteral && s & TypeFlags.EnumLiteral && t & TypeFlags.StringLiteral && !(t & TypeFlags.EnumLiteral) && source.value === target.value
			) return true;
			if (s & TypeFlags.NumberLike && t & TypeFlags.Number) return true;
			if (
				s & TypeFlags.NumberLiteral && s & TypeFlags.EnumLiteral && t & TypeFlags.NumberLiteral && !(t & TypeFlags.EnumLiteral) && source.value === target.value
			) return true;
			if (s & TypeFlags.BigIntLike && t & TypeFlags.BigInt) return true;
			if (s & TypeFlags.BooleanLike && t & TypeFlags.Boolean) return true;
			if (s & TypeFlags.ESSymbolLike && t & TypeFlags.ESSymbol) return true;
			if (
				s & TypeFlags.Enum && t & TypeFlags.Enum && isEnumTypeRelatedTo(
					source.symbol,
					target.symbol,
					errorReporter,
				)
			) return true;
			if (s & TypeFlags.EnumLiteral && t & TypeFlags.EnumLiteral) {
				if (
					s & TypeFlags.Union && t & TypeFlags.Union && isEnumTypeRelatedTo(
						source.symbol,
						target.symbol,
						errorReporter,
					)
				) return true;
				if (
					s & TypeFlags.Literal && t & TypeFlags.Literal && source.value === target.value && isEnumTypeRelatedTo(
						getParentOfSymbol(source.symbol),
						getParentOfSymbol(target.symbol),
						errorReporter,
					)
				) return true;
			}
			if (
				s & TypeFlags.Undefined && (!strictNullChecks || t & (TypeFlags.Undefined | TypeFlags.Void))
			) return true;
			if (s & TypeFlags.Null && (!strictNullChecks || t & TypeFlags.Null)) return true;
			if (s & TypeFlags.Object && t & TypeFlags.NonPrimitive) return true;
			if (relation === assignableRelation || relation === comparableRelation) {
				if (s & TypeFlags.Any) return true;
				// Type number or any numeric literal type is assignable to any numeric enum type or any
				// numeric enum literal type. This rule exists for backwards compatibility reasons because
				// bit-flag enum types sometimes look like literal enum types with numeric literal values.
				if (
					s & (TypeFlags.Number | TypeFlags.NumberLiteral) && !(s & TypeFlags.EnumLiteral) && (t & TypeFlags.Enum || relation === assignableRelation && t & TypeFlags.NumberLiteral && t & TypeFlags.EnumLiteral)
				) return true;
			}
			return false;
		}
		function isTypeRelatedTo(source, target, relation) {
			if (isFreshLiteralType(source)) {
				source = source.regularType;
			}
			if (isFreshLiteralType(target)) {
				target = target.regularType;
			}
			if (source === target) {
				return true;
			}
			if (relation !== identityRelation) {
				if (
					relation === comparableRelation && !(target.flags & TypeFlags.Never) && isSimpleTypeRelatedTo(
						target,
						source,
						relation,
					) || isSimpleTypeRelatedTo(source, target, relation)
				) {
					return true;
				}
			} else {
				if (source.flags !== target.flags) return false;
				if (source.flags & TypeFlags.Singleton) return true;
			}
			if (source.flags & TypeFlags.Object && target.flags & TypeFlags.Object) {
				var related = relation.get(
					getRelationKey(
						source,
						target,
						0, /* None */
						relation, /*ignoreConstraints*/
						false,
					),
				);
				if (related !== undefined) {
					return !!(related & RelationComparisonResult.Succeeded);
				}
			}
			if (
				source.flags & TypeFlags.StructuredOrInstantiable || target.flags & TypeFlags.StructuredOrInstantiable
			) {
				return checkTypeRelatedTo(
					source,
					target,
					relation, /*errorNode*/
					undefined,
				);
			}
			return false;
		}
		function isIgnoredJsxProperty(source, sourceProp) {
			return getObjectFlags(source) & ObjectFlags.JsxAttributes && isHyphenatedJsxName(
				sourceProp.escapedName,
			);
		}
		function getNormalizedType(type, writing) {
			while (true) {
				var t = isFreshLiteralType(type) ? type.regularType : getObjectFlags(
					type,
				) & ObjectFlags.Reference && type.node ? createTypeReference(
					type.target,
					getTypeArguments(type),
				) : type.flags & TypeFlags.UnionOrIntersection ? getReducedType(type) : type.flags & TypeFlags.Substitution ? writing ? type.baseType : type.substitute : type.flags & TypeFlags.Simplifiable ? getSimplifiedType(
					type,
					writing,
				) : type;
				t = getSingleBaseForNonAugmentingSubtype(t) || t;
				if (t === type) break;
				type = t;
			}
			return type;
		}
		/**
         * Checks if 'source' is related to 'target' (e.g.: is a assignable to).
         * @param source The left-hand-side of the relation.
         * @param target The right-hand-side of the relation.
         * @param relation The relation considered. One of 'identityRelation', 'subtypeRelation', 'assignableRelation', or 'comparableRelation'.
         * Used as both to determine which checks are performed and as a cache of previously computed results.
         * @param errorNode The suggested node upon which all errors will be reported, if defined. This may or may not be the actual node used.
         * @param headMessage If the error chain should be prepended by a head message, then headMessage will be used.
         * @param containingMessageChain A chain of errors to prepend any new errors found.
         * @param errorOutputContainer Return the diagnostic. Do not log if 'skipLogging' is truthy.
         */
		function checkTypeRelatedTo(
			source,
			target,
			relation,
			errorNode,
			headMessage,
			containingMessageChain,
			errorOutputContainer,
		) {
			var errorInfo;
			var relatedInfo;
			var maybeKeys;
			var sourceStack;
			var targetStack;
			var maybeCount = 0;
			var sourceDepth = 0;
			var targetDepth = 0;
			var expandingFlags = 0 /* None */ ;
			var overflow = false;
			var overrideNextErrorInfo = 0; // How many `reportRelationError` calls should be skipped in the elaboration pyramid
			var lastSkippedInfo;
			var incompatibleStack = [];
			var inPropertyCheck = false;
			Debug.assert(
				relation !== identityRelation || !errorNode,
				"no error reporting in identity checking",
			);
			var result = isRelatedTo(
				source,
				target,
				3, /* Both */ /*reportErrors*/
				!!errorNode,
				headMessage,
			);
			if (incompatibleStack.length) {
				reportIncompatibleStack();
			}
			if (overflow) {
				tracing === null || tracing === void 0 ? void 0 : tracing.instant(
					tracing.Phase.CheckTypes,
					"checkTypeRelatedTo_DepthLimit",
					{
						sourceId: source.id,
						targetId: target.id,
						depth: sourceDepth,
						targetDepth: targetDepth,
					},
				);
				var diag = error(
					errorNode || currentNode,
					Diagnostics.Excessive_stack_depth_comparing_types_0_and_1,
					typeToString(source),
					typeToString(target),
				);
				if (errorOutputContainer) {
					(errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(
						diag,
					);
				}
			} else if (errorInfo) {
				if (containingMessageChain) {
					var chain = containingMessageChain();
					if (chain) {
						concatenateDiagnosticMessageChains(chain, errorInfo);
						errorInfo = chain;
					}
				}
				var relatedInformation = void 0;
				// Check if we should issue an extra diagnostic to produce a quickfix for a slightly incorrect import statement
				if (headMessage && errorNode && !result && source.symbol) {
					var links = getSymbolLinks(source.symbol);
					if (links.originatingImport && !isImportCall(links.originatingImport)) {
						var helpfulRetry = checkTypeRelatedTo(
							getTypeOfSymbol(links.target),
							target,
							relation, /*errorNode*/
							undefined,
						);
						if (helpfulRetry) {
							// Likely an incorrect import. Issue a helpful diagnostic to produce a quickfix to change the import
							var diag_1 = createDiagnosticForNode(
								links.originatingImport,
								Diagnostics.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead,
							);
							relatedInformation = append(relatedInformation, diag_1); // Cause the error to appear with the error that triggered it
						}
					}
				}
				var diag = createDiagnosticForNodeFromMessageChain(
					errorNode,
					errorInfo,
					relatedInformation,
				);
				if (relatedInfo) {
					addRelatedInfo.apply(
						void 0,
						__spreadArray([diag], relatedInfo, false),
					);
				}
				if (errorOutputContainer) {
					(errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(
						diag,
					);
				}
				if (!errorOutputContainer || !errorOutputContainer.skipLogging) {
					diagnostics.add(diag);
				}
			}
			if (
				errorNode && errorOutputContainer && errorOutputContainer.skipLogging && result === Ternary.False
			) {
				Debug.assert(
					!!errorOutputContainer.errors,
					"missed opportunity to interact with error.",
				);
			}
			return result !== Ternary.False;
			function resetErrorInfo(saved) {
				errorInfo = saved.errorInfo;
				lastSkippedInfo = saved.lastSkippedInfo;
				incompatibleStack = saved.incompatibleStack;
				overrideNextErrorInfo = saved.overrideNextErrorInfo;
				relatedInfo = saved.relatedInfo;
			}
			function captureErrorCalculationState() {
				return {
					errorInfo: errorInfo,
					lastSkippedInfo: lastSkippedInfo,
					incompatibleStack: incompatibleStack.slice(),
					overrideNextErrorInfo: overrideNextErrorInfo,
					relatedInfo: !relatedInfo ? undefined : relatedInfo.slice(),
				};
			}
			function reportIncompatibleError(message, arg0, arg1, arg2, arg3) {
				overrideNextErrorInfo++; // Suppress the next relation error
				lastSkippedInfo = undefined; // Reset skipped info cache
				incompatibleStack.push([message, arg0, arg1, arg2, arg3]);
			}
			function reportIncompatibleStack() {
				var stack = incompatibleStack;
				incompatibleStack = [];
				var info = lastSkippedInfo;
				lastSkippedInfo = undefined;
				if (stack.length === 1) {
					reportError.apply(void 0, stack[0]);
					if (info) {
						// Actually do the last relation error
						reportRelationError.apply(
							void 0,
							__spreadArray([ /*headMessage*/ undefined], info, false),
						);
					}
					return;
				}
				// The first error will be the innermost, while the last will be the outermost - so by popping off the end,
				// we can build from left to right
				var path = "";
				var secondaryRootErrors = [];
				while (stack.length) {
					var _a = stack.pop(), msg = _a[0], args = _a.slice(1);
					switch (msg.code) {
						case Diagnostics.Types_of_property_0_are_incompatible.code:
							{
								// Parenthesize a `new` if there is one
								if (path.indexOf("new ") === 0) {
									path = "(".concat(path, ")");
								}
								var str = "" + args[0];
								// If leading, just print back the arg (irrespective of if it's a valid identifier)
								if (path.length === 0) {
									path = "".concat(str);
								} else if (
									isIdentifierText(str, getEmitScriptTarget(compilerOptions)) // Otherwise write a dotted name if possible
								) {
									path = "".concat(path, ".").concat(str);
								} else if (str[0] === "[" && str[str.length - 1] === "]") {
									path = "".concat(path).concat(str); // Failing that, check if the name is already a computed name
								} else {
									path = "".concat(path, "[").concat(str, "]"); // And finally write out a computed name as a last resort
								}
								break;
							}
						case Diagnostics.Call_signature_return_types_0_and_1_are_incompatible.code:
						case Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible.code:
						case Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code:
						case Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code:
							{
								if (path.length === 0) {
									// Don't flatten signature compatability errors at the start of a chain - instead prefer
									// to unify (the with no arguments bit is excessive for printback) and print them back
									var mappedMsg = msg;
									if (
										msg.code === Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code
									) {
										mappedMsg = Diagnostics.Call_signature_return_types_0_and_1_are_incompatible;
									} else if (
										msg.code === Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code
									) {
										mappedMsg = Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible;
									}
									secondaryRootErrors.unshift([mappedMsg, args[0], args[1]]);
								} else {
									var prefix = (msg.code === Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible.code || msg.code === Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code) ? "new " : "";
									var params = (msg.code === Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code || msg.code === Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code) ? "" : "...";
									path = "".concat(prefix).concat(path, "(").concat(params, ")");
								}
								break;
							}
						case Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target.code:
							{
								secondaryRootErrors.unshift(
									[
										Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target,
										args[0],
										args[1],
									],
								);
								break;
							}
						case Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target.code:
							{
								secondaryRootErrors.unshift(
									[
										Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target,
										args[0],
										args[1],
										args[2],
									],
								);
								break;
							}
						default:
							return Debug.fail("Unhandled Diagnostic: ".concat(msg.code));
					}
				}
				if (path) {
					reportError(
						path[path.length - 1] === ")" ? Diagnostics.The_types_returned_by_0_are_incompatible_between_these_types : Diagnostics.The_types_of_0_are_incompatible_between_these_types,
						path,
					);
				} else {
					// Remove the innermost secondary error as it will duplicate the error already reported by `reportRelationError` on entry
					secondaryRootErrors.shift();
				}
				for (
					var _i = 0, secondaryRootErrors_1 = secondaryRootErrors;
					_i < secondaryRootErrors_1.length;
					_i++
				) {
					var _b = secondaryRootErrors_1[_i], msg = _b[0], args = _b.slice(1);
					var originalValue = msg.elidedInCompatabilityPyramid;
					msg.elidedInCompatabilityPyramid = false; // Temporarily override elision to ensure error is reported
					reportError.apply(void 0, __spreadArray([msg], args, false));
					msg.elidedInCompatabilityPyramid = originalValue;
				}
				if (info) {
					// Actually do the last relation error
					reportRelationError.apply(
						void 0,
						__spreadArray([ /*headMessage*/ undefined], info, false),
					);
				}
			}
			function reportError(message, arg0, arg1, arg2, arg3) {
				Debug.assert(!!errorNode);
				if (incompatibleStack.length) reportIncompatibleStack();
				if (message.elidedInCompatabilityPyramid) return;
				errorInfo = chainDiagnosticMessages(
					errorInfo,
					message,
					arg0,
					arg1,
					arg2,
					arg3,
				);
			}
			function associateRelatedInfo(info) {
				Debug.assert(!!errorInfo);
				if (!relatedInfo) {
					relatedInfo = [info];
				} else {
					relatedInfo.push(info);
				}
			}
			function reportRelationError(message, source, target) {
				if (incompatibleStack.length) reportIncompatibleStack();
				var _a = getTypeNamesForErrorDisplay(source, target),
					sourceType = _a[0],
					targetType = _a[1];
				var generalizedSource = source;
				var generalizedSourceType = sourceType;
				if (
					isLiteralType(source) && !typeCouldHaveTopLevelSingletonTypes(target)
				) {
					generalizedSource = getBaseTypeOfLiteralType(source);
					Debug.assert(
						!isTypeAssignableTo(generalizedSource, target),
						"generalized source shouldn't be assignable",
					);
					generalizedSourceType = getTypeNameForErrorDisplay(generalizedSource);
				}
				if (target.flags & TypeFlags.TypeParameter) {
					var constraint = getBaseConstraintOfType(target);
					var needsOriginalSource = void 0;
					if (
						constraint && (isTypeAssignableTo(generalizedSource, constraint) || (needsOriginalSource = isTypeAssignableTo(
							source,
							constraint,
						)))
					) {
						reportError(
							Diagnostics._0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_constraint_2,
							needsOriginalSource ? sourceType : generalizedSourceType,
							targetType,
							typeToString(constraint),
						);
					} else {
						errorInfo = undefined;
						reportError(
							Diagnostics._0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1,
							targetType,
							generalizedSourceType,
						);
					}
				}
				if (!message) {
					if (relation === comparableRelation) {
						message = Diagnostics.Type_0_is_not_comparable_to_type_1;
					} else if (sourceType === targetType) {
						message = Diagnostics.Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated;
					} else if (
						exactOptionalPropertyTypes && getExactOptionalUnassignableProperties(
							source,
							target,
						).length
					) {
						message = Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties;
					} else {
						if (
							source.flags & TypeFlags.StringLiteral && target.flags & TypeFlags.Union
						) {
							var suggestedType = getSuggestedTypeForNonexistentStringLiteralType(
								source,
								target,
							);
							if (suggestedType) {
								reportError(
									Diagnostics.Type_0_is_not_assignable_to_type_1_Did_you_mean_2,
									generalizedSourceType,
									targetType,
									typeToString(suggestedType),
								);
								return;
							}
						}
						message = Diagnostics.Type_0_is_not_assignable_to_type_1;
					}
				} else if (
					message === Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1 && exactOptionalPropertyTypes && getExactOptionalUnassignableProperties(
						source,
						target,
					).length
				) {
					message = Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties;
				}
				reportError(message, generalizedSourceType, targetType);
			}
			function tryElaborateErrorsForPrimitivesAndObjects(source, target) {
				var sourceType = symbolValueDeclarationIsContextSensitive(source.symbol) ? typeToString(
					source,
					source.symbol.valueDeclaration,
				) : typeToString(source);
				var targetType = symbolValueDeclarationIsContextSensitive(target.symbol) ? typeToString(
					target,
					target.symbol.valueDeclaration,
				) : typeToString(target);
				if (
					(globalStringType === source && stringType === target) || (globalNumberType === source && numberType === target) || (globalBooleanType === source && booleanType === target) || (getGlobalESSymbolType(
						false, /*reportErrors*/
					) === source && esSymbolType === target)
				) {
					reportError(
						Diagnostics._0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible,
						targetType,
						sourceType,
					);
				}
			}
			/**
             * Try and elaborate array and tuple errors. Returns false
             * if we have found an elaboration, or we should ignore
             * any other elaborations when relating the `source` and
             * `target` types.
             */
			function tryElaborateArrayLikeErrors(source, target, reportErrors) {
				/**
                 * The spec for elaboration is:
                 * - If the source is a readonly tuple and the target is a mutable array or tuple, elaborate on mutability and skip property elaborations.
                 * - If the source is a tuple then skip property elaborations if the target is an array or tuple.
                 * - If the source is a readonly array and the target is a mutable array or tuple, elaborate on mutability and skip property elaborations.
                 * - If the source an array then skip property elaborations if the target is a tuple.
                 */
				if (isTupleType(source)) {
					if (source.target.readonly && isMutableArrayOrTuple(target)) {
						if (reportErrors) {
							reportError(
								Diagnostics.The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1,
								typeToString(source),
								typeToString(target),
							);
						}
						return false;
					}
					return isTupleType(target) || isArrayType(target);
				}
				if (isReadonlyArrayType(source) && isMutableArrayOrTuple(target)) {
					if (reportErrors) {
						reportError(
							Diagnostics.The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1,
							typeToString(source),
							typeToString(target),
						);
					}
					return false;
				}
				if (isTupleType(target)) {
					return isArrayType(source);
				}
				return true;
			}
			function isRelatedToWorker(source, target, reportErrors) {
				return isRelatedTo(source, target, 3 /* Both */ , reportErrors);
			}
			/**
             * Compare two types and return
             * * Ternary.True if they are related with no assumptions,
             * * Ternary.Maybe if they are related with assumptions of other relationships, or
             * * Ternary.False if they are not related.
             */
			function isRelatedTo(
				originalSource,
				originalTarget,
				recursionFlags,
				reportErrors,
				headMessage,
				intersectionState,
			) {
				if (recursionFlags === void 0) {
					recursionFlags = 3; /* Both */
				}
				if (reportErrors === void 0) {
					reportErrors = false;
				}
				if (intersectionState === void 0) {
					intersectionState = 0; /* None */
				}
				// Before normalization: if `source` is type an object type, and `target` is primitive,
				// skip all the checks we don't need and just return `isSimpleTypeRelatedTo` result
				if (
					originalSource.flags & TypeFlags.Object && originalTarget.flags & TypeFlags.Primitive
				) {
					if (
						isSimpleTypeRelatedTo(
							originalSource,
							originalTarget,
							relation,
							reportErrors ? reportError : undefined,
						)
					) {
						return Ternary.True;
					}
					reportErrorResults(
						originalSource,
						originalTarget,
						Ternary.False,
						!!(getObjectFlags(originalSource) & ObjectFlags.JsxAttributes),
					);
					return Ternary.False;
				}
				// Normalize the source and target types: Turn fresh literal types into regular literal types,
				// turn deferred type references into regular type references, simplify indexed access and
				// conditional types, and resolve substitution types to either the substitution (on the source
				// side) or the type variable (on the target side).
				var source = getNormalizedType(originalSource, /*writing*/ false);
				var target = getNormalizedType(originalTarget, /*writing*/ true);
				if (source === target) return Ternary.True;
				if (relation === identityRelation) {
					return isIdenticalTo(source, target, recursionFlags);
				}
				// We fastpath comparing a type parameter to exactly its constraint, as this is _super_ common,
				// and otherwise, for type parameters in large unions, causes us to need to compare the union to itself,
				// as we break down the _target_ union first, _then_ get the source constraint - so for every
				// member of the target, we attempt to find a match in the source. This avoids that in cases where
				// the target is exactly the constraint.
				if (
					source.flags & TypeFlags.TypeParameter && getConstraintOfType(source) === target
				) {
					return Ternary.True;
				}
				// Try to see if we're relating something like `Foo` -> `Bar | null | undefined`.
				// If so, reporting the `null` and `undefined` in the type is hardly useful.
				// First, see if we're even relating an object type to a union.
				// Then see if the target is stripped down to a single non-union type.
				// Note
				//  * We actually want to remove null and undefined naively here (rather than using getNonNullableType),
				//    since we don't want to end up with a worse error like "`Foo` is not assignable to `NonNullable<T>`"
				//    when dealing with generics.
				//  * We also don't deal with primitive source types, since we already halt elaboration below.
				if (
					target.flags & TypeFlags.Union && source.flags & TypeFlags.Object && target.types.length <= 3 && maybeTypeOfKind(
						target,
						TypeFlags.Nullable,
					)
				) {
					var nullStrippedTarget = extractTypesOfKind(
						target,
						~TypeFlags.Nullable,
					);
					if (!(nullStrippedTarget.flags & (TypeFlags.Union | TypeFlags.Never))) {
						target = getNormalizedType(nullStrippedTarget, /*writing*/ true);
					}
					if (source === nullStrippedTarget) return Ternary.True;
				}
				if (
					relation === comparableRelation && !(target.flags & TypeFlags.Never) && isSimpleTypeRelatedTo(
						target,
						source,
						relation,
					) || isSimpleTypeRelatedTo(
						source,
						target,
						relation,
						reportErrors ? reportError : undefined,
					)
				) return Ternary.True;
				var isComparingJsxAttributes = !!(getObjectFlags(source) & ObjectFlags.JsxAttributes);
				var isPerformingExcessPropertyChecks = !(intersectionState & 2) && (isObjectLiteralType(
					source, /* Target */
				) && getObjectFlags(source) & ObjectFlags.FreshLiteral);
				if (isPerformingExcessPropertyChecks) {
					if (hasExcessProperties(source, target, reportErrors)) {
						if (reportErrors) {
							reportRelationError(
								headMessage,
								source,
								originalTarget.aliasSymbol ? originalTarget : target,
							);
						}
						return Ternary.False;
					}
				}
				var isPerformingCommonPropertyChecks = relation !== comparableRelation && !(intersectionState & 2) && source.flags & (TypeFlags.Primitive | TypeFlags.Object | TypeFlags.Intersection) && source !== globalObjectType && target.flags & (TypeFlags.Object | TypeFlags.Intersection) && isWeakType(
					target, /* Target */
				) && (getPropertiesOfType(source).length > 0 || typeHasCallOrConstructSignatures(
					source,
				));
				if (
					isPerformingCommonPropertyChecks && !hasCommonProperties(
						source,
						target,
						isComparingJsxAttributes,
					)
				) {
					if (reportErrors) {
						var sourceString = typeToString(
							originalSource.aliasSymbol ? originalSource : source,
						);
						var targetString = typeToString(
							originalTarget.aliasSymbol ? originalTarget : target,
						);
						var calls = getSignaturesOfType(source, SignatureKind.Call);
						var constructs = getSignaturesOfType(
							source,
							SignatureKind.Construct,
						);
						if (
							calls.length > 0 && isRelatedTo(
								getReturnTypeOfSignature(calls[0]),
								target,
								1, /* Source */ /*reportErrors*/
								false,
							) || constructs.length > 0 && isRelatedTo(
								getReturnTypeOfSignature(constructs[0]),
								target,
								1, /* Source */ /*reportErrors*/
								false,
							)
						) {
							reportError(
								Diagnostics.Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it,
								sourceString,
								targetString,
							);
						} else {
							reportError(
								Diagnostics.Type_0_has_no_properties_in_common_with_type_1,
								sourceString,
								targetString,
							);
						}
					}
					return Ternary.False;
				}
				traceUnionsOrIntersectionsTooLarge(source, target);
				var result = Ternary.False;
				var saveErrorInfo = captureErrorCalculationState();
				if (
					(source.flags & TypeFlags.Union || target.flags & TypeFlags.Union) && getConstituentCount(
						source,
					) * getConstituentCount(target) < 4
				) {
					// We skip caching when source or target is a union with no more than three constituents.
					result = structuredTypeRelatedTo(
						source,
						target,
						reportErrors,
						intersectionState | 8, /* UnionIntersectionCheck */
					);
				} else if (
					source.flags & TypeFlags.UnionOrIntersection || target.flags & TypeFlags.UnionOrIntersection
				) {
					result = recursiveTypeRelatedTo(
						source,
						target,
						reportErrors,
						intersectionState | 8, /* UnionIntersectionCheck */
						recursionFlags,
					);
				}
				if (
					!result && !(source.flags & TypeFlags.Union) && (source.flags & (TypeFlags.StructuredOrInstantiable) || target.flags & TypeFlags.StructuredOrInstantiable)
				) {
					if (
						result = recursiveTypeRelatedTo(
							source,
							target,
							reportErrors,
							intersectionState,
							recursionFlags,
						)
					) {
						resetErrorInfo(saveErrorInfo);
					}
				}
				if (
					!result && source.flags & (TypeFlags.Intersection | TypeFlags.TypeParameter)
				) {
					// The combined constraint of an intersection type is the intersection of the constraints of
					// the constituents. When an intersection type contains instantiable types with union type
					// constraints, there are situations where we need to examine the combined constraint. One is
					// when the target is a union type. Another is when the intersection contains types belonging
					// to one of the disjoint domains. For example, given type variables T and U, each with the
					// constraint 'string | number', the combined constraint of 'T & U' is 'string | number' and
					// we need to check this constraint against a union on the target side. Also, given a type
					// variable V constrained to 'string | number', 'V & number' has a combined constraint of
					// 'string & number | number & number' which reduces to just 'number'.
					// This also handles type parameters, as a type parameter with a union constraint compared against a union
					// needs to have its constraint hoisted into an intersection with said type parameter, this way
					// the type param can be compared with itself in the target (with the influence of its constraint to match other parts)
					// For example, if `T extends 1 | 2` and `U extends 2 | 3` and we compare `T & U` to `T & U & (1 | 2 | 3)`
					var constraint = getEffectiveConstraintOfIntersection(
						source.flags & TypeFlags.Intersection ? source.types : [source],
						!!(target.flags & TypeFlags.Union),
					);
					if (
						constraint && (source.flags & TypeFlags.Intersection || target.flags & TypeFlags.Union)
					) {
						if (
							everyType(
								constraint,
								function (c) {
									return c !== source;
								},
							)
						) {
							// TODO: Stack errors so we get a pyramid for the "normal" comparison above, _and_ a second for this // Skip comparison if expansion contains the source itself
							if (
								result = isRelatedTo(
									constraint,
									target,
									1, /* Source */ /*reportErrors*/
									false, /*headMessage*/
									undefined,
									intersectionState,
								)
							) {
								resetErrorInfo(saveErrorInfo);
							}
						}
					}
				}
				// For certain combinations involving intersections and optional, excess, or mismatched properties we need
				// an extra property check where the intersection is viewed as a single object. The following are motivating
				// examples that all should be errors, but aren't without this extra property check:
				//
				//   let obj: { a: { x: string } } & { c: number } = { a: { x: 'hello', y: 2 }, c: 5 };  // Nested excess property
				//
				//   declare let wrong: { a: { y: string } };
				//   let weak: { a?: { x?: number } } & { c?: string } = wrong;  // Nested weak object type
				//
				//   function foo<T extends object>(x: { a?: string }, y: T & { a: boolean }) {
				//     x = y;  // Mismatched property in source intersection
				//   }
				//
				// We suppress recursive intersection property checks because they can generate lots of work when relating
				// recursive intersections that are structurally similar but not exactly identical. See #37854.
				if (
					result && !inPropertyCheck && (target.flags & TypeFlags.Intersection && (isPerformingExcessPropertyChecks || isPerformingCommonPropertyChecks) || isNonGenericObjectType(
						target,
					) && !isArrayType(target) && !isTupleType(target) && source.flags & TypeFlags.Intersection && getApparentType(
						source,
					).flags & TypeFlags.StructuredType && !some(
						source.types,
						function (t) {
							return !!(getObjectFlags(t) & ObjectFlags.NonInferrableType);
						},
					))
				) {
					inPropertyCheck = true;
					result &= recursiveTypeRelatedTo(
						source,
						target,
						reportErrors,
						4, /* PropertyCheck */
						recursionFlags,
					);
					inPropertyCheck = false;
				}
				reportErrorResults(source, target, result, isComparingJsxAttributes);
				return result;
				function reportErrorResults(
					source,
					target,
					result,
					isComparingJsxAttributes,
				) {
					if (!result && reportErrors) {
						var sourceHasBase = !!getSingleBaseForNonAugmentingSubtype(
							originalSource,
						);
						var targetHasBase = !!getSingleBaseForNonAugmentingSubtype(
							originalTarget,
						);
						source = (originalSource.aliasSymbol || sourceHasBase) ? originalSource : source;
						target = (originalTarget.aliasSymbol || targetHasBase) ? originalTarget : target;
						var maybeSuppress = overrideNextErrorInfo > 0;
						if (maybeSuppress) {
							overrideNextErrorInfo--;
						}
						if (
							source.flags & TypeFlags.Object && target.flags & TypeFlags.Object
						) {
							var currentError = errorInfo;
							tryElaborateArrayLikeErrors(source, target, reportErrors);
							if (errorInfo !== currentError) {
								maybeSuppress = !!errorInfo;
							}
						}
						if (
							source.flags & TypeFlags.Object && target.flags & TypeFlags.Primitive
						) {
							tryElaborateErrorsForPrimitivesAndObjects(source, target);
						} else if (
							source.symbol && source.flags & TypeFlags.Object && globalObjectType === source
						) {
							reportError(
								Diagnostics.The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead,
							);
						} else if (
							isComparingJsxAttributes && target.flags & TypeFlags.Intersection
						) {
							var targetTypes = target.types;
							var intrinsicAttributes = getJsxType(
								JsxNames.IntrinsicAttributes,
								errorNode,
							);
							var intrinsicClassAttributes = getJsxType(
								JsxNames.IntrinsicClassAttributes,
								errorNode,
							);
							if (
								!isErrorType(intrinsicAttributes) && !isErrorType(
									intrinsicClassAttributes,
								) && (contains(targetTypes, intrinsicAttributes) || contains(
									targetTypes,
									intrinsicClassAttributes,
								))
							) {
								// do not report top error
								return result;
							}
						} else {
							errorInfo = elaborateNeverIntersection(errorInfo, originalTarget);
						}
						if (!headMessage && maybeSuppress) {
							lastSkippedInfo = [source, target];
							// Used by, eg, missing property checking to replace the top-level message with a more informative one
							return result;
						}
						reportRelationError(headMessage, source, target);
					}
				}
			}
			function traceUnionsOrIntersectionsTooLarge(source, target) {
				if (!tracing) {
					return;
				}
				if (
					(source.flags & TypeFlags.UnionOrIntersection) && (target.flags & TypeFlags.UnionOrIntersection)
				) {
					var sourceUnionOrIntersection = source;
					var targetUnionOrIntersection = target;
					if (
						sourceUnionOrIntersection.objectFlags & targetUnionOrIntersection.objectFlags & ObjectFlags.PrimitiveUnion
					) {
						// There's a fast path for comparing primitive unions
						return;
					}
					var sourceSize = sourceUnionOrIntersection.types.length;
					var targetSize = targetUnionOrIntersection.types.length;
					if (sourceSize * targetSize > 1E6) {
						tracing.instant(
							tracing.Phase.CheckTypes,
							"traceUnionsOrIntersectionsTooLarge_DepthLimit",
							{
								sourceId: source.id,
								sourceSize: sourceSize,
								targetId: target.id,
								targetSize: targetSize,
								pos: errorNode === null || errorNode === void 0 ? void 0 : errorNode.pos,
								end: errorNode === null || errorNode === void 0 ? void 0 : errorNode.end,
							},
						);
					}
				}
			}
			function isIdenticalTo(source, target, recursionFlags) {
				if (source.flags !== target.flags) return Ternary.False;
				if (source.flags & TypeFlags.Singleton) return Ternary.True;
				traceUnionsOrIntersectionsTooLarge(source, target);
				if (source.flags & TypeFlags.UnionOrIntersection) {
					var result_3 = eachTypeRelatedToSomeType(source, target);
					if (result_3) {
						result_3 &= eachTypeRelatedToSomeType(target, source);
					}
					return result_3;
				}
				return recursiveTypeRelatedTo(
					source,
					target, /*reportErrors*/
					false,
					0, /* None */
					recursionFlags,
				);
			}
			function getTypeOfPropertyInTypes(types, name) {
				var appendPropType = function (propTypes, type) {
					var _a;
					type = getApparentType(type);
					var prop = type.flags & TypeFlags.UnionOrIntersection ? getPropertyOfUnionOrIntersectionType(
						type,
						name,
					) : getPropertyOfObjectType(type, name);
					var propType = prop && getTypeOfSymbol(prop) || ((_a = getApplicableIndexInfoForName(
						type,
						name,
					)) === null || _a === void 0 ? void 0 : _a.type) || undefinedType;
					return append(propTypes, propType);
				};
				return getUnionType(
					reduceLeft(types, appendPropType, /*initial*/ undefined) || emptyArray,
				);
			}
			function hasExcessProperties(source, target, reportErrors) {
				var _a;
				if (
					!isExcessPropertyCheckTarget(target) || !noImplicitAny && getObjectFlags(
						target,
					) & ObjectFlags.JSLiteral
				) {
					return false; // Disable excess property checks on JS literals to simulate having an implicit "index signature" - but only outside of noImplicitAny
				}
				var isComparingJsxAttributes = !!(getObjectFlags(source) & ObjectFlags.JsxAttributes);
				if (
					(relation === assignableRelation || relation === comparableRelation) && (isTypeSubsetOf(
						globalObjectType,
						target,
					) || (!isComparingJsxAttributes && isEmptyObjectType(target)))
				) {
					return false;
				}
				var reducedTarget = target;
				var checkTypes;
				if (target.flags & TypeFlags.Union) {
					reducedTarget = findMatchingDiscriminantType(
						source,
						target,
						isRelatedTo,
					) || filterPrimitivesIfContainsNonPrimitive(target);
					checkTypes = reducedTarget.flags & TypeFlags.Union ? reducedTarget.types : [
						reducedTarget,
					];
				}
				var _loop_12 = function (prop) {
					if (
						shouldCheckAsExcessProperty(prop, source.symbol) && !isIgnoredJsxProperty(
							source,
							prop,
						)
					) {
						if (
							!isKnownProperty(
								reducedTarget,
								prop.escapedName,
								isComparingJsxAttributes,
							)
						) {
							if (reportErrors) {
								// Report error in terms of object types in the target as those are the only ones
								// we check in isKnownProperty.
								var errorTarget = filterType(
									reducedTarget,
									isExcessPropertyCheckTarget,
								);
								// We know *exactly* where things went wrong when comparing the types.
								// Use this property as the error node as this will be more helpful in
								// reasoning about what went wrong.
								if (!errorNode) return { value: Debug.fail() };
								if (
									isJsxAttributes(errorNode) || isJsxOpeningLikeElement(
										errorNode,
									) || isJsxOpeningLikeElement(errorNode.parent)
								) {
									// JsxAttributes has an object-literal flag and undergo same type-assignablity check as normal object-literal.
									// However, using an object-literal error message will be very confusing to the users so we give different a message.
									if (
										prop.valueDeclaration && isJsxAttribute(
											prop.valueDeclaration,
										) && getSourceFileOfNode(errorNode) === getSourceFileOfNode(
											prop.valueDeclaration.name,
										)
									) {
										// Note that extraneous children (as in `<NoChild>extra</NoChild>`) don't pass this check,
										// since `children` is a SyntaxKind.PropertySignature instead of a SyntaxKind.JsxAttribute.
										errorNode = prop.valueDeclaration.name;
									}
									var propName = symbolToString(prop);
									var suggestionSymbol = getSuggestedSymbolForNonexistentJSXAttribute(
										propName,
										errorTarget,
									);
									var suggestion = suggestionSymbol ? symbolToString(
										suggestionSymbol,
									) : undefined;
									if (suggestion) {
										reportError(
											Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2,
											propName,
											typeToString(errorTarget),
											suggestion,
										);
									} else {
										reportError(
											Diagnostics.Property_0_does_not_exist_on_type_1,
											propName,
											typeToString(errorTarget),
										);
									}
								} else {
									// use the property's value declaration if the property is assigned inside the literal itself
									var objectLiteralDeclaration_1 = ((_a = source.symbol) === null || _a === void 0 ? void 0 : _a.declarations) && firstOrUndefined(
										source.symbol.declarations,
									);
									var suggestion = void 0;
									if (
										prop.valueDeclaration && findAncestor(
											prop.valueDeclaration,
											function (d) {
												return d === objectLiteralDeclaration_1;
											},
										) && getSourceFileOfNode(objectLiteralDeclaration_1) === getSourceFileOfNode(
											errorNode,
										)
									) {
										var propDeclaration = prop.valueDeclaration;
										Debug.assertNode(
											propDeclaration,
											isObjectLiteralElementLike,
										);
										errorNode = propDeclaration;
										var name_16 = propDeclaration.name;
										if (isIdentifier(name_16)) {
											suggestion = getSuggestionForNonexistentProperty(
												name_16,
												errorTarget,
											);
										}
									}
									if (suggestion !== undefined) {
										reportError(
											Diagnostics.Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_write_2,
											symbolToString(prop),
											typeToString(errorTarget),
											suggestion,
										);
									} else {
										reportError(
											Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1,
											symbolToString(prop),
											typeToString(errorTarget),
										);
									}
								}
							}
							return { value: true };
						}
						if (
							checkTypes && !isRelatedTo(
								getTypeOfSymbol(prop),
								getTypeOfPropertyInTypes(checkTypes, prop.escapedName),
								3, /* Both */
								reportErrors,
							)
						) {
							if (reportErrors) {
								reportIncompatibleError(
									Diagnostics.Types_of_property_0_are_incompatible,
									symbolToString(prop),
								);
							}
							return { value: true };
						}
					}
				};
				for (var _i = 0, _b = getPropertiesOfType(source); _i < _b.length; _i++) {
					var prop = _b[_i];
					var state_4 = _loop_12(prop);
					if (typeof state_4 === "object") return state_4.value;
				}
				return false;
			}
			function shouldCheckAsExcessProperty(prop, container) {
				return prop.valueDeclaration && container.valueDeclaration && prop.valueDeclaration.parent === container.valueDeclaration;
			}
			function eachTypeRelatedToSomeType(source, target) {
				var result = Ternary.True;
				var sourceTypes = source.types;
				for (
					var _i = 0, sourceTypes_1 = sourceTypes;
					_i < sourceTypes_1.length;
					_i++
				) {
					var sourceType = sourceTypes_1[_i];
					var related = typeRelatedToSomeType(
						sourceType,
						target, /*reportErrors*/
						false,
					);
					if (!related) {
						return Ternary.False;
					}
					result &= related;
				}
				return result;
			}
			function typeRelatedToSomeType(source, target, reportErrors) {
				var targetTypes = target.types;
				if (target.flags & TypeFlags.Union) {
					if (containsType(targetTypes, source)) {
						return Ternary.True;
					}
					var match = getMatchingUnionConstituentForType(target, source);
					if (match) {
						var related = isRelatedTo(
							source,
							match,
							2, /* Target */ /*reportErrors*/
							false,
						);
						if (related) {
							return related;
						}
					}
				}
				for (
					var _i = 0, targetTypes_1 = targetTypes;
					_i < targetTypes_1.length;
					_i++
				) {
					var type = targetTypes_1[_i];
					var related = isRelatedTo(
						source,
						type,
						2, /* Target */ /*reportErrors*/
						false,
					);
					if (related) {
						return related;
					}
				}
				if (reportErrors) {
					var bestMatchingType = getBestMatchingType(
						source,
						target,
						isRelatedTo,
					);
					isRelatedTo(
						source,
						bestMatchingType || targetTypes[targetTypes.length - 1],
						2, /* Target */ /*reportErrors*/
						true,
					);
				}
				return Ternary.False;
			}
			function typeRelatedToEachType(
				source,
				target,
				reportErrors,
				intersectionState,
			) {
				var result = Ternary.True;
				var targetTypes = target.types;
				for (
					var _i = 0, targetTypes_2 = targetTypes;
					_i < targetTypes_2.length;
					_i++
				) {
					var targetType = targetTypes_2[_i];
					var related = isRelatedTo(
						source,
						targetType,
						2, /* Target */
						reportErrors, /*headMessage*/
						undefined,
						intersectionState,
					);
					if (!related) {
						return Ternary.False;
					}
					result &= related;
				}
				return result;
			}
			function someTypeRelatedToType(
				source,
				target,
				reportErrors,
				intersectionState,
			) {
				var sourceTypes = source.types;
				if (source.flags & TypeFlags.Union && containsType(sourceTypes, target)) {
					return Ternary.True;
				}
				var len = sourceTypes.length;
				for (var i = 0; i < len; i++) {
					var related = isRelatedTo(
						sourceTypes[i],
						target,
						1, /* Source */
						reportErrors && i === len - 1, /*headMessage*/
						undefined,
						intersectionState,
					);
					if (related) {
						return related;
					}
				}
				return Ternary.False;
			}
			function getUndefinedStrippedTargetIfNeeded(source, target) {
				// As a builtin type, `undefined` is a very low type ID - making it almsot always first, making this a very fast check to see
				// if we need to strip `undefined` from the target
				if (
					source.flags & TypeFlags.Union && target.flags & TypeFlags.Union && !(source.types[0].flags & TypeFlags.Undefined) && target.types[0].flags & TypeFlags.Undefined
				) {
					return extractTypesOfKind(target, ~TypeFlags.Undefined);
				}
				return target;
			}
			function eachTypeRelatedToType(
				source,
				target,
				reportErrors,
				intersectionState,
			) {
				var result = Ternary.True;
				var sourceTypes = source.types;
				// We strip `undefined` from the target if the `source` trivially doesn't contain it for our correspondence-checking fastpath
				// since `undefined` is frequently added by optionality and would otherwise spoil a potentially useful correspondence
				var undefinedStrippedTarget = getUndefinedStrippedTargetIfNeeded(
					source,
					target,
				);
				for (var i = 0; i < sourceTypes.length; i++) {
					var sourceType = sourceTypes[i];
					if (
						undefinedStrippedTarget.flags & TypeFlags.Union && sourceTypes.length >= undefinedStrippedTarget.types.length && sourceTypes.length % undefinedStrippedTarget.types.length === 0
					) {
						// many unions are mappings of one another; in such cases, simply comparing members at the same index can shortcut the comparison
						// such unions will have identical lengths, and their corresponding elements will match up. Another common scenario is where a large
						// union has a union of objects intersected with it. In such cases, if the input was, eg `("a" | "b" | "c") & (string | boolean | {} | {whatever})`,
						// the result will have the structure `"a" | "b" | "c" | "a" & {} | "b" & {} | "c" & {} | "a" & {whatever} | "b" & {whatever} | "c" & {whatever}`
						// - the resulting union has a length which is a multiple of the original union, and the elements correspond modulo the length of the original union
						var related_1 = isRelatedTo(
							sourceType,
							undefinedStrippedTarget.types[i % undefinedStrippedTarget.types.length],
							3, /* Both */ /*reportErrors*/
							false, /*headMessage*/
							undefined,
							intersectionState,
						);
						if (related_1) {
							result &= related_1;
							continue;
						}
					}
					var related = isRelatedTo(
						sourceType,
						target,
						1, /* Source */
						reportErrors, /*headMessage*/
						undefined,
						intersectionState,
					);
					if (!related) {
						return Ternary.False;
					}
					result &= related;
				}
				return result;
			}
			function typeArgumentsRelatedTo(
				sources,
				targets,
				variances,
				reportErrors,
				intersectionState,
			) {
				if (sources === void 0) {
					sources = emptyArray;
				}
				if (targets === void 0) {
					targets = emptyArray;
				}
				if (variances === void 0) {
					variances = emptyArray;
				}
				if (sources.length !== targets.length && relation === identityRelation) {
					return Ternary.False;
				}
				var length = sources.length <= targets.length ? sources.length : targets.length;
				var result = Ternary.True;
				for (var i = 0; i < length; i++) {
					// When variance information isn't available we default to covariance. This happens
					// in the process of computing variance information for recursive types and when
					// comparing 'this' type arguments.
					var varianceFlags = i < variances.length ? variances[i] : VarianceFlags.Covariant;
					var variance = varianceFlags & VarianceFlags.VarianceMask;
					// We ignore arguments for independent type parameters (because they're never witnessed).
					if (variance !== VarianceFlags.Independent) {
						var s = sources[i];
						var t = targets[i];
						var related = Ternary.True;
						if (varianceFlags & VarianceFlags.Unmeasurable) {
							// Even an `Unmeasurable` variance works out without a structural check if the source and target are _identical_.
							// We can't simply assume invariance, because `Unmeasurable` marks nonlinear relations, for example, a relation tained by
							// the `-?` modifier in a mapped type (where, no matter how the inputs are related, the outputs still might not be)
							related = relation === identityRelation ? isRelatedTo(
								s,
								t,
								3, /* Both */ /*reportErrors*/
								false,
							) : compareTypesIdentical(s, t);
						} else if (variance === VarianceFlags.Covariant) {
							related = isRelatedTo(
								s,
								t,
								3, /* Both */
								reportErrors, /*headMessage*/
								undefined,
								intersectionState,
							);
						} else if (variance === VarianceFlags.Contravariant) {
							related = isRelatedTo(
								t,
								s,
								3, /* Both */
								reportErrors, /*headMessage*/
								undefined,
								intersectionState,
							);
						} else if (variance === VarianceFlags.Bivariant) {
							// In the bivariant case we first compare contravariantly without reporting
							// errors. Then, if that doesn't succeed, we compare covariantly with error
							// reporting. Thus, error elaboration will be based on the the covariant check,
							// which is generally easier to reason about.
							related = isRelatedTo(t, s, 3 /* Both */ , /*reportErrors*/ false);
							if (!related) {
								related = isRelatedTo(
									s,
									t,
									3, /* Both */
									reportErrors, /*headMessage*/
									undefined,
									intersectionState,
								);
							}
						} else {
							// In the invariant case we first compare covariantly, and only when that
							// succeeds do we proceed to compare contravariantly. Thus, error elaboration
							// will typically be based on the covariant check.
							related = isRelatedTo(
								s,
								t,
								3, /* Both */
								reportErrors, /*headMessage*/
								undefined,
								intersectionState,
							);
							if (related) {
								related &= isRelatedTo(
									t,
									s,
									3, /* Both */
									reportErrors, /*headMessage*/
									undefined,
									intersectionState,
								);
							}
						}
						if (!related) {
							return Ternary.False;
						}
						result &= related;
					}
				}
				return result;
			}
			// Determine if possibly recursive types are related. First, check if the result is already available in the global cache.
			// Second, check if we have already started a comparison of the given two types in which case we assume the result to be true.
			// Third, check if both types are part of deeply nested chains of generic type instantiations and if so assume the types are
			// equal and infinitely expanding. Fourth, if we have reached a depth of 100 nested comparisons, assume we have runaway recursion
			// and issue an error. Otherwise, actually compare the structure of the two types.
			function recursiveTypeRelatedTo(
				source,
				target,
				reportErrors,
				intersectionState,
				recursionFlags,
			) {
				if (overflow) {
					return Ternary.False;
				}
				var keyIntersectionState = intersectionState | (inPropertyCheck ? 16 : 0); /* InPropertyCheck */
				var id = getRelationKey(
					source,
					target,
					keyIntersectionState,
					relation, /*ingnoreConstraints*/
					false,
				);
				var entry = relation.get(id);
				if (entry !== undefined) {
					if (
						reportErrors && entry & RelationComparisonResult.Failed && !(entry & RelationComparisonResult.Reported)
					) {
					// We are elaborating errors and the cached result is an unreported failure. The result will be reported
					// as a failure, and should be updated as a reported failure by the bottom of this function.
					} else {
						if (outofbandVarianceMarkerHandler) {
							// We're in the middle of variance checking - integrate any unmeasurable/unreliable flags from this cached component
							var saved = entry & RelationComparisonResult.ReportsMask;
							if (saved & RelationComparisonResult.ReportsUnmeasurable) {
								instantiateType(
									source,
									makeFunctionTypeMapper(reportUnmeasurableMarkers),
								);
							}
							if (saved & RelationComparisonResult.ReportsUnreliable) {
								instantiateType(
									source,
									makeFunctionTypeMapper(reportUnreliableMarkers),
								);
							}
						}
						return entry & RelationComparisonResult.Succeeded ? Ternary.True : Ternary.False;
					}
				}
				if (!maybeKeys) {
					maybeKeys = [];
					sourceStack = [];
					targetStack = [];
				} else {
					// A key that starts with "*" is an indication that we have type references that reference constrained
					// type parameters. For such keys we also check against the key we would have gotten if all type parameters
					// were unconstrained.
					var broadestEquivalentId = id.startsWith("*") ? getRelationKey(
						source,
						target,
						keyIntersectionState,
						relation, /*ignoreConstraints*/
						true,
					) : undefined;
					for (var i = 0; i < maybeCount; i++) {
						// If source and target are already being compared, consider them related with assumptions
						if (
							id === maybeKeys[i] || broadestEquivalentId && broadestEquivalentId === maybeKeys[i]
						) {
							return Ternary.Maybe;
						}
					}
					if (sourceDepth === 100 || targetDepth === 100) {
						overflow = true;
						return Ternary.False;
					}
				}
				var maybeStart = maybeCount;
				maybeKeys[maybeCount] = id;
				maybeCount++;
				var saveExpandingFlags = expandingFlags;
				if (recursionFlags & 1 /* Source */ ) {
					sourceStack[sourceDepth] = source;
					sourceDepth++;
					if (
						!(expandingFlags & 1) && isDeeplyNestedType(
							source, /* Source */
							sourceStack,
							sourceDepth,
						)
					) expandingFlags |= 1; /* Source */
				}
				if (recursionFlags & 2 /* Target */ ) {
					targetStack[targetDepth] = target;
					targetDepth++;
					if (
						!(expandingFlags & 2) && isDeeplyNestedType(
							target, /* Target */
							targetStack,
							targetDepth,
						)
					) expandingFlags |= 2; /* Target */
				}
				var originalHandler;
				var propagatingVarianceFlags = 0;
				if (outofbandVarianceMarkerHandler) {
					originalHandler = outofbandVarianceMarkerHandler;
					outofbandVarianceMarkerHandler = function (onlyUnreliable) {
						propagatingVarianceFlags |= onlyUnreliable ? RelationComparisonResult.ReportsUnreliable : RelationComparisonResult.ReportsUnmeasurable;
						return originalHandler(onlyUnreliable);
					};
				}
				if (expandingFlags === 3 /* Both */ ) {
					tracing === null || tracing === void 0 ? void 0 : tracing.instant(
						tracing.Phase.CheckTypes,
						"recursiveTypeRelatedTo_DepthLimit",
						{
							sourceId: source.id,
							sourceIdStack: sourceStack.map(
								function (t) {
									return t.id;
								},
							),
							targetId: target.id,
							targetIdStack: targetStack.map(
								function (t) {
									return t.id;
								},
							),
							depth: sourceDepth,
							targetDepth: targetDepth,
						},
					);
				}
				var result = expandingFlags !== 3 ? structuredTypeRelatedTo(
					source, /* Both */
					target,
					reportErrors,
					intersectionState,
				) : Ternary.Maybe;
				if (outofbandVarianceMarkerHandler) {
					outofbandVarianceMarkerHandler = originalHandler;
				}
				if (recursionFlags & 1 /* Source */ ) {
					sourceDepth--;
				}
				if (recursionFlags & 2 /* Target */ ) {
					targetDepth--;
				}
				expandingFlags = saveExpandingFlags;
				if (result) {
					if (
						result === Ternary.True || (sourceDepth === 0 && targetDepth === 0)
					) {
						if (result === Ternary.True || result === Ternary.Maybe) {
							// If result is definitely true, record all maybe keys as having succeeded. Also, record Ternary.Maybe
							// results as having succeeded once we reach depth 0, but never record Ternary.Unknown results.
							for (var i = maybeStart; i < maybeCount; i++) {
								relation.set(
									maybeKeys[i],
									RelationComparisonResult.Succeeded | propagatingVarianceFlags,
								);
							}
						}
						maybeCount = maybeStart;
					}
				} else {
					// A false result goes straight into global cache (when something is false under
					// assumptions it will also be false without assumptions)
					relation.set(
						id,
						(reportErrors ? RelationComparisonResult.Reported : 0) | RelationComparisonResult.Failed | propagatingVarianceFlags,
					);
					maybeCount = maybeStart;
				}
				return result;
			}
			function structuredTypeRelatedTo(
				source,
				target,
				reportErrors,
				intersectionState,
			) {
				tracing === null || tracing === void 0 ? void 0 : tracing.push(
					tracing.Phase.CheckTypes,
					"structuredTypeRelatedTo",
					{ sourceId: source.id, targetId: target.id },
				);
				var result = structuredTypeRelatedToWorker(
					source,
					target,
					reportErrors,
					intersectionState,
				);
				tracing === null || tracing === void 0 ? void 0 : tracing.pop();
				return result;
			}
			function structuredTypeRelatedToWorker(
				source,
				target,
				reportErrors,
				intersectionState,
			) {
				if (intersectionState & 4 /* PropertyCheck */ ) {
					return propertiesRelatedTo(
						source,
						target,
						reportErrors, /*excludedProperties*/
						undefined,
						0, /* None */
					);
				}
				if (intersectionState & 8 /* UnionIntersectionCheck */ ) {
					// Note that these checks are specifically ordered to produce correct results. In particular,
					// we need to deconstruct unions before intersections (because unions are always at the top),
					// and we need to handle "each" relations before "some" relations for the same kind of type.
					if (source.flags & TypeFlags.Union) {
						return relation === comparableRelation ? someTypeRelatedToType(
							source,
							target,
							reportErrors && !(source.flags & TypeFlags.Primitive),
							intersectionState & ~8, /* UnionIntersectionCheck */
						) : eachTypeRelatedToType(
							source,
							target,
							reportErrors && !(source.flags & TypeFlags.Primitive),
							intersectionState & ~8, /* UnionIntersectionCheck */
						);
					}
					if (target.flags & TypeFlags.Union) {
						return typeRelatedToSomeType(
							getRegularTypeOfObjectLiteral(source),
							target,
							reportErrors && !(source.flags & TypeFlags.Primitive) && !(target.flags & TypeFlags.Primitive),
						);
					}
					if (target.flags & TypeFlags.Intersection) {
						return typeRelatedToEachType(
							getRegularTypeOfObjectLiteral(source),
							target,
							reportErrors,
							2, /* Target */
						);
					}
					// Source is an intersection. For the comparable relation, if the target is a primitive type we hoist the
					// constraints of all non-primitive types in the source into a new intersection. We do this because the
					// intersection may further constrain the constraints of the non-primitive types. For example, given a type
					// parameter 'T extends 1 | 2', the intersection 'T & 1' should be reduced to '1' such that it doesn't
					// appear to be comparable to '2'.
					if (
						relation === comparableRelation && target.flags & TypeFlags.Primitive
					) {
						var constraints = sameMap(source.types, getBaseConstraintOrType);
						if (constraints !== source.types) {
							source = getIntersectionType(constraints);
							if (!(source.flags & TypeFlags.Intersection)) {
								return isRelatedTo(
									source,
									target,
									1, /* Source */ /*reportErrors*/
									false,
								);
							}
						}
					}
					// Check to see if any constituents of the intersection are immediately related to the target.
					//
					// Don't report errors though. Checking whether a constituent is related to the source is not actually
					// useful and leads to some confusing error messages. Instead it is better to let the below checks
					// take care of this, or to not elaborate at all. For instance,
					//
					//    - For an object type (such as 'C = A & B'), users are usually more interested in structural errors.
					//
					//    - For a union type (such as '(A | B) = (C & D)'), it's better to hold onto the whole intersection
					//          than to report that 'D' is not assignable to 'A' or 'B'.
					//
					//    - For a primitive type or type parameter (such as 'number = A & B') there is no point in
					//          breaking the intersection apart.
					return someTypeRelatedToType(
						source,
						target, /*reportErrors*/
						false,
						1, /* Source */
					);
				}
				var flags = source.flags & target.flags;
				if (relation === identityRelation && !(flags & TypeFlags.Object)) {
					if (flags & TypeFlags.Index) {
						return isRelatedTo(
							source.type,
							target.type,
							3, /* Both */ /*reportErrors*/
							false,
						);
					}
					var result_4 = Ternary.False;
					if (flags & TypeFlags.IndexedAccess) {
						if (
							result_4 = isRelatedTo(
								source.objectType,
								target.objectType,
								3, /* Both */ /*reportErrors*/
								false,
							)
						) {
							if (
								result_4 &= isRelatedTo(
									source.indexType,
									target.indexType,
									3, /* Both */ /*reportErrors*/
									false,
								)
							) {
								return result_4;
							}
						}
					}
					if (flags & TypeFlags.Conditional) {
						if (source.root.isDistributive === target.root.isDistributive) {
							if (
								result_4 = isRelatedTo(
									source.checkType,
									target.checkType,
									3, /* Both */ /*reportErrors*/
									false,
								)
							) {
								if (
									result_4 &= isRelatedTo(
										source.extendsType,
										target.extendsType,
										3, /* Both */ /*reportErrors*/
										false,
									)
								) {
									if (
										result_4 &= isRelatedTo(
											getTrueTypeFromConditionalType(source),
											getTrueTypeFromConditionalType(target),
											3, /* Both */ /*reportErrors*/
											false,
										)
									) {
										if (
											result_4 &= isRelatedTo(
												getFalseTypeFromConditionalType(source),
												getFalseTypeFromConditionalType(target),
												3, /* Both */ /*reportErrors*/
												false,
											)
										) {
											return result_4;
										}
									}
								}
							}
						}
					}
					if (flags & TypeFlags.Substitution) {
						return isRelatedTo(
							source.substitute,
							target.substitute,
							3, /* Both */ /*reportErrors*/
							false,
						);
					}
					return Ternary.False;
				}
				var result;
				var originalErrorInfo;
				var varianceCheckFailed = false;
				var saveErrorInfo = captureErrorCalculationState();
				// We limit alias variance probing to only object and conditional types since their alias behavior
				// is more predictable than other, interned types, which may or may not have an alias depending on
				// the order in which things were checked.
				if (
					source.flags & (TypeFlags.Object | TypeFlags.Conditional) && source.aliasSymbol && source.aliasTypeArguments && source.aliasSymbol === target.aliasSymbol && !(source.aliasTypeArgumentsContainsMarker || target.aliasTypeArgumentsContainsMarker)
				) {
					var variances = getAliasVariances(source.aliasSymbol);
					if (variances === emptyArray) {
						return Ternary.Unknown;
					}
					var varianceResult = relateVariances(
						source.aliasTypeArguments,
						target.aliasTypeArguments,
						variances,
						intersectionState,
					);
					if (varianceResult !== undefined) {
						return varianceResult;
					}
				}
				// For a generic type T and a type U that is assignable to T, [...U] is assignable to T, U is assignable to readonly [...T],
				// and U is assignable to [...T] when U is constrained to a mutable array or tuple type.
				if (
					isSingleElementGenericTupleType(source) && !source.target.readonly && (result = isRelatedTo(
						getTypeArguments(source)[0],
						target,
						1, /* Source */
					)) || isSingleElementGenericTupleType(target) && (target.target.readonly || isMutableArrayOrTuple(
						getBaseConstraintOfType(source) || source,
					)) && (result = isRelatedTo(
						source,
						getTypeArguments(target)[0],
						2, /* Target */
					))
				) {
					return result;
				}
				if (target.flags & TypeFlags.TypeParameter) {
					// A source type { [P in Q]: X } is related to a target type T if keyof T is related to Q and X is related to T[Q].
					if (
						getObjectFlags(source) & ObjectFlags.Mapped && !source.declaration.nameType && isRelatedTo(
							getIndexType(target),
							getConstraintTypeFromMappedType(source),
							3, /* Both */
						)
					) {
						if (!(getMappedTypeModifiers(source) & 4 /* IncludeOptional */ )) {
							var templateType = getTemplateTypeFromMappedType(source);
							var indexedAccessType = getIndexedAccessType(
								target,
								getTypeParameterFromMappedType(source),
							);
							if (
								result = isRelatedTo(
									templateType,
									indexedAccessType,
									3, /* Both */
									reportErrors,
								)
							) {
								return result;
							}
						}
					}
				} else if (target.flags & TypeFlags.Index) {
					var targetType_1 = target.type;
					// A keyof S is related to a keyof T if T is related to S.
					if (source.flags & TypeFlags.Index) {
						if (
							result = isRelatedTo(
								targetType_1,
								source.type,
								3, /* Both */ /*reportErrors*/
								false,
							)
						) {
							return result;
						}
					}
					if (isTupleType(targetType_1)) {
						// An index type can have a tuple type target when the tuple type contains variadic elements.
						// Check if the source is related to the known keys of the tuple type.
						if (
							result = isRelatedTo(
								source,
								getKnownKeysOfTupleType(targetType_1),
								2, /* Target */
								reportErrors,
							)
						) {
							return result;
						}
					} else {
						// A type S is assignable to keyof T if S is assignable to keyof C, where C is the
						// simplified form of T or, if T doesn't simplify, the constraint of T.
						var constraint = getSimplifiedTypeOrConstraint(targetType_1);
						if (constraint) {
							// We require Ternary.True here such that circular constraints don't cause
							// false positives. For example, given 'T extends { [K in keyof T]: string }',
							// 'keyof T' has itself as its constraint and produces a Ternary.Maybe when
							// related to other types.
							if (
								isRelatedTo(
									source,
									getIndexType(constraint, target.stringsOnly),
									2, /* Target */
									reportErrors,
								) === Ternary.True
							) {
								return Ternary.True;
							}
						} else if (isGenericMappedType(targetType_1)) {
							// generic mapped types that don't simplify or have a constraint still have a very simple set of keys we can compare against
							// - their nameType or constraintType.
							// In many ways, this comparison is a deferred version of what `getIndexTypeForMappedType` does to actually resolve the keys for _non_-generic types
							var nameType_1 = getNameTypeFromMappedType(targetType_1);
							var constraintType = getConstraintTypeFromMappedType(targetType_1);
							var targetKeys = void 0;
							if (
								nameType_1 && isMappedTypeWithKeyofConstraintDeclaration(
									targetType_1,
								)
							) {
								// we need to get the apparent mappings and union them with the generic mappings, since some properties may be
								// missing from the `constraintType` which will otherwise be mapped in the object
								var modifiersType = getApparentType(
									getModifiersTypeFromMappedType(targetType_1),
								);
								var mappedKeys_1 = [];
								forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(
									modifiersType,
									TypeFlags.StringOrNumberLiteralOrUnique,
									/*stringsOnly*/ false,
									function (t) {
										return void mappedKeys_1.push(
											instantiateType(
												nameType_1,
												appendTypeMapping(
													targetType_1.mapper,
													getTypeParameterFromMappedType(targetType_1),
													t,
												),
											),
										);
									},
								);
								// We still need to include the non-apparent (and thus still generic) keys in the target side of the comparison (in case they're in the source side)
								targetKeys = getUnionType(
									__spreadArray(
										__spreadArray([], mappedKeys_1, true),
										[nameType_1],
										false,
									),
								);
							} else {
								targetKeys = nameType_1 || constraintType;
							}
							if (
								isRelatedTo(source, targetKeys, 2 /* Target */ , reportErrors) === Ternary.True
							) {
								return Ternary.True;
							}
						}
					}
				} else if (target.flags & TypeFlags.IndexedAccess) {
					if (source.flags & TypeFlags.IndexedAccess) {
						// Relate components directly before falling back to constraint relationships
						// A type S[K] is related to a type T[J] if S is related to T and K is related to J.
						if (
							result = isRelatedTo(
								source.objectType,
								target.objectType,
								3, /* Both */
								reportErrors,
							)
						) {
							result &= isRelatedTo(
								source.indexType,
								target.indexType,
								3, /* Both */
								reportErrors,
							);
						}
						if (result) {
							resetErrorInfo(saveErrorInfo);
							return result;
						}
						if (reportErrors) {
							originalErrorInfo = errorInfo;
						}
					}
					// A type S is related to a type T[K] if S is related to C, where C is the base
					// constraint of T[K] for writing.
					if (
						relation === assignableRelation || relation === comparableRelation
					) {
						var objectType = target.objectType;
						var indexType = target.indexType;
						var baseObjectType = getBaseConstraintOfType(objectType) || objectType;
						var baseIndexType = getBaseConstraintOfType(indexType) || indexType;
						if (
							!isGenericObjectType(baseObjectType) && !isGenericIndexType(
								baseIndexType,
							)
						) {
							var accessFlags = AccessFlags.Writing | (baseObjectType !== objectType ? AccessFlags.NoIndexSignatures : 0);
							var constraint = getIndexedAccessTypeOrUndefined(
								baseObjectType,
								baseIndexType,
								accessFlags,
							);
							if (constraint) {
								if (reportErrors && originalErrorInfo) {
									// create a new chain for the constraint error
									resetErrorInfo(saveErrorInfo);
								}
								if (
									result = isRelatedTo(
										source,
										constraint,
										2, /* Target */
										reportErrors,
									)
								) {
									return result;
								}
								// prefer the shorter chain of the constraint comparison chain, and the direct comparison chain
								if (reportErrors && originalErrorInfo && errorInfo) {
									errorInfo = countMessageChainBreadth([originalErrorInfo]) <= countMessageChainBreadth(
										[errorInfo],
									) ? originalErrorInfo : errorInfo;
								}
							}
						}
					}
					if (reportErrors) {
						originalErrorInfo = undefined;
					}
				} else if (isGenericMappedType(target) && relation !== identityRelation) {
					// Check if source type `S` is related to target type `{ [P in Q]: T }` or `{ [P in Q as R]: T}`.
					var keysRemapped = !!target.declaration.nameType;
					var templateType = getTemplateTypeFromMappedType(target);
					var modifiers = getMappedTypeModifiers(target);
					if (!(modifiers & 8 /* ExcludeOptional */ )) {
						// If the mapped type has shape `{ [P in Q]: T[P] }`,
						// source `S` is related to target if `T` = `S`, i.e. `S` is related to `{ [P in Q]: S[P] }`.
						if (
							!keysRemapped && templateType.flags & TypeFlags.IndexedAccess && templateType.objectType === source && templateType.indexType === getTypeParameterFromMappedType(
								target,
							)
						) {
							return Ternary.True;
						}
						if (!isGenericMappedType(source)) {
							// If target has shape `{ [P in Q as R]: T}`, then its keys have type `R`.
							// If target has shape `{ [P in Q]: T }`, then its keys have type `Q`.
							var targetKeys = keysRemapped ? getNameTypeFromMappedType(target) : getConstraintTypeFromMappedType(
								target,
							);
							// Type of the keys of source type `S`, i.e. `keyof S`.
							var sourceKeys = getIndexType(
								source, /*stringsOnly*/
								undefined, /*noIndexSignatures*/
								true,
							);
							var includeOptional = modifiers & 4 /* IncludeOptional */ ;
							var filteredByApplicability = includeOptional ? intersectTypes(
								targetKeys,
								sourceKeys,
							) : undefined;
							// A source type `S` is related to a target type `{ [P in Q]: T }` if `Q` is related to `keyof S` and `S[Q]` is related to `T`.
							// A source type `S` is related to a target type `{ [P in Q as R]: T }` if `R` is related to `keyof S` and `S[R]` is related to `T.
							// A source type `S` is related to a target type `{ [P in Q]?: T }` if some constituent `Q'` of `Q` is related to `keyof S` and `S[Q']` is related to `T`.
							// A source type `S` is related to a target type `{ [P in Q as R]?: T }` if some constituent `R'` of `R` is related to `keyof S` and `S[R']` is related to `T`.
							if (
								includeOptional ? !(filteredByApplicability.flags & TypeFlags.Never) : isRelatedTo(
									targetKeys,
									sourceKeys,
									3, /* Both */
								)
							) {
								var templateType_1 = getTemplateTypeFromMappedType(target);
								var typeParameter = getTypeParameterFromMappedType(target);
								// Fastpath: When the template type has the form `Obj[P]` where `P` is the mapped type parameter, directly compare source `S` with `Obj`
								// to avoid creating the (potentially very large) number of new intermediate types made by manufacturing `S[P]`.
								var nonNullComponent = extractTypesOfKind(
									templateType_1,
									~TypeFlags.Nullable,
								);
								if (
									!keysRemapped && nonNullComponent.flags & TypeFlags.IndexedAccess && nonNullComponent.indexType === typeParameter
								) {
									if (
										result = isRelatedTo(
											source,
											nonNullComponent.objectType,
											2, /* Target */
											reportErrors,
										)
									) {
										return result;
									}
								} else {
									// We need to compare the type of a property on the source type `S` to the type of the same property on the target type,
									// so we need to construct an indexing type representing a property, and then use indexing type to index the source type for comparison.
									// If the target type has shape `{ [P in Q]: T }`, then a property of the target has type `P`.
									// If the target type has shape `{ [P in Q]?: T }`, then a property of the target has type `P`,
									// but the property is optional, so we only want to compare properties `P` that are common between `keyof S` and `Q`.
									// If the target type has shape `{ [P in Q as R]: T }`, then a property of the target has type `R`.
									// If the target type has shape `{ [P in Q as R]?: T }`, then a property of the target has type `R`,
									// but the property is optional, so we only want to compare properties `R` that are common between `keyof S` and `R`.
									var indexingType = keysRemapped ? (filteredByApplicability || targetKeys) : filteredByApplicability ? getIntersectionType(
										[filteredByApplicability, typeParameter],
									) : typeParameter;
									var indexedAccessType = getIndexedAccessType(
										source,
										indexingType,
									);
									// Compare `S[indexingType]` to `T`, where `T` is the type of a property of the target type.
									if (
										result = isRelatedTo(
											indexedAccessType,
											templateType_1,
											3, /* Both */
											reportErrors,
										)
									) {
										return result;
									}
								}
							}
							originalErrorInfo = errorInfo;
							resetErrorInfo(saveErrorInfo);
						}
					}
				} else if (target.flags & TypeFlags.Conditional) {
					// If we reach 10 levels of nesting for the same conditional type, assume it is an infinitely expanding recursive
					// conditional type and bail out with a Ternary.Maybe result.
					if (isDeeplyNestedType(target, targetStack, targetDepth, 10)) {
						resetErrorInfo(saveErrorInfo);
						return Ternary.Maybe;
					}
					var c = target;
					// We check for a relationship to a conditional type target only when the conditional type has no
					// 'infer' positions and is not distributive or is distributive but doesn't reference the check type
					// parameter in either of the result types.
					if (!c.root.inferTypeParameters && !isDistributionDependent(c.root)) {
						// Check if the conditional is always true or always false but still deferred for distribution purposes.
						var skipTrue = !isTypeAssignableTo(
							getPermissiveInstantiation(c.checkType),
							getPermissiveInstantiation(c.extendsType),
						);
						var skipFalse = !skipTrue && isTypeAssignableTo(
							getRestrictiveInstantiation(c.checkType),
							getRestrictiveInstantiation(c.extendsType),
						);
						// TODO: Find a nice way to include potential conditional type breakdowns in error output, if they seem good (they usually don't)
						if (
							result = skipTrue ? Ternary.True : isRelatedTo(
								source,
								getTrueTypeFromConditionalType(c),
								2, /* Target */ /*reportErrors*/
								false,
							)
						) {
							result &= skipFalse ? Ternary.True : isRelatedTo(
								source,
								getFalseTypeFromConditionalType(c),
								2, /* Target */ /*reportErrors*/
								false,
							);
							if (result) {
								resetErrorInfo(saveErrorInfo);
								return result;
							}
						}
					}
				} else if (target.flags & TypeFlags.TemplateLiteral) {
					if (source.flags & TypeFlags.TemplateLiteral) {
						if (relation === comparableRelation) {
							return templateLiteralTypesDefinitelyUnrelated(source, target) ? Ternary.False : Ternary.True;
						}
						// Report unreliable variance for type variables referenced in template literal type placeholders.
						// For example, `foo-${number}` is related to `foo-${string}` even though number isn't related to string.
						instantiateType(
							source,
							makeFunctionTypeMapper(reportUnreliableMarkers),
						);
					}
					if (isTypeMatchedByTemplateLiteralType(source, target)) {
						return Ternary.True;
					}
				}
				if (source.flags & TypeFlags.TypeVariable) {
					// IndexedAccess comparisons are handled above in the `target.flags & TypeFlage.IndexedAccess` branch
					if (
						!(source.flags & TypeFlags.IndexedAccess && target.flags & TypeFlags.IndexedAccess)
					) {
						var constraint = getConstraintOfType(source);
						if (
							!constraint || (source.flags & TypeFlags.TypeParameter && constraint.flags & TypeFlags.Any)
						) {
							// A type variable with no constraint is not related to the non-primitive object type.
							if (
								result = isRelatedTo(
									emptyObjectType,
									extractTypesOfKind(target, ~TypeFlags.NonPrimitive),
									3, /* Both */
								)
							) {
								resetErrorInfo(saveErrorInfo);
								return result;
							}
						} else if (
							result = isRelatedTo( // hi-speed no-this-instantiation check (less accurate, but avoids costly `this`-instantiation when the constraint will suffice), see #28231 for report on why this is needed
								constraint,
								target,
								1, /* Source */ /*reportErrors*/
								false, /*headMessage*/
								undefined,
								intersectionState,
							)
						) {
							resetErrorInfo(saveErrorInfo);
							return result;
						} else if (
							result = isRelatedTo( // slower, fuller, this-instantiated check (necessary when comparing raw `this` types from base classes), see `subclassWithPolymorphicThisIsAssignable.ts` test for example
								getTypeWithThisArgument(constraint, source),
								target,
								1, /* Source */
								reportErrors && !(target.flags & source.flags & TypeFlags.TypeParameter), /*headMessage*/
								undefined,
								intersectionState,
							)
						) {
							resetErrorInfo(saveErrorInfo);
							return result;
						}
						if (isMappedTypeGenericIndexedAccess(source)) {
							// For an indexed access type { [P in K]: E}[X], above we have already explored an instantiation of E with X
							// substituted for P. We also want to explore type { [P in K]: E }[C], where C is the constraint of X.
							var indexConstraint = getConstraintOfType(source.indexType);
							if (indexConstraint) {
								if (
									result = isRelatedTo(
										getIndexedAccessType(source.objectType, indexConstraint),
										target,
										1, /* Source */
										reportErrors,
									)
								) {
									resetErrorInfo(saveErrorInfo);
									return result;
								}
							}
						}
					}
				} else if (source.flags & TypeFlags.Index) {
					if (
						result = isRelatedTo(
							keyofConstraintType,
							target,
							1, /* Source */
							reportErrors,
						)
					) {
						resetErrorInfo(saveErrorInfo);
						return result;
					}
				} else if (
					source.flags & TypeFlags.TemplateLiteral && !(target.flags & TypeFlags.Object)
				) {
					if (!(target.flags & TypeFlags.TemplateLiteral)) {
						var constraint = getBaseConstraintOfType(source);
						if (
							constraint && constraint !== source && (result = isRelatedTo(
								constraint,
								target,
								1, /* Source */
								reportErrors,
							))
						) {
							resetErrorInfo(saveErrorInfo);
							return result;
						}
					}
				} else if (source.flags & TypeFlags.StringMapping) {
					if (
						target.flags & TypeFlags.StringMapping && source.symbol === target.symbol
					) {
						if (
							result = isRelatedTo(
								source.type,
								target.type,
								3, /* Both */
								reportErrors,
							)
						) {
							resetErrorInfo(saveErrorInfo);
							return result;
						}
					} else {
						var constraint = getBaseConstraintOfType(source);
						if (
							constraint && (result = isRelatedTo(
								constraint,
								target,
								1, /* Source */
								reportErrors,
							))
						) {
							resetErrorInfo(saveErrorInfo);
							return result;
						}
					}
				} else if (source.flags & TypeFlags.Conditional) {
					// If we reach 10 levels of nesting for the same conditional type, assume it is an infinitely expanding recursive
					// conditional type and bail out with a Ternary.Maybe result.
					if (isDeeplyNestedType(source, sourceStack, sourceDepth, 10)) {
						resetErrorInfo(saveErrorInfo);
						return Ternary.Maybe;
					}
					if (target.flags & TypeFlags.Conditional) {
						// Two conditional types 'T1 extends U1 ? X1 : Y1' and 'T2 extends U2 ? X2 : Y2' are related if
						// one of T1 and T2 is related to the other, U1 and U2 are identical types, X1 is related to X2,
						// and Y1 is related to Y2.
						var sourceParams = source.root.inferTypeParameters;
						var sourceExtends = source.extendsType;
						var mapper = void 0;
						if (sourceParams) {
							// If the source has infer type parameters, we instantiate them in the context of the target
							var ctx = createInferenceContext(
								sourceParams, /*signature*/
								undefined,
								InferenceFlags.None,
								isRelatedToWorker,
							);
							inferTypes(
								ctx.inferences,
								target.extendsType,
								sourceExtends,
								InferencePriority.NoConstraints | InferencePriority.AlwaysStrict,
							);
							sourceExtends = instantiateType(sourceExtends, ctx.mapper);
							mapper = ctx.mapper;
						}
						if (
							isTypeIdenticalTo(sourceExtends, target.extendsType) && (isRelatedTo(
								source.checkType,
								target.checkType,
								3, /* Both */
							) || isRelatedTo(
								target.checkType,
								source.checkType,
								3, /* Both */
							))
						) {
							if (
								result = isRelatedTo(
									instantiateType(
										getTrueTypeFromConditionalType(source),
										mapper,
									),
									getTrueTypeFromConditionalType(target),
									3, /* Both */
									reportErrors,
								)
							) {
								result &= isRelatedTo(
									getFalseTypeFromConditionalType(source),
									getFalseTypeFromConditionalType(target),
									3, /* Both */
									reportErrors,
								);
							}
							if (result) {
								resetErrorInfo(saveErrorInfo);
								return result;
							}
						}
					} else {
						// conditionals aren't related to one another via distributive constraint as it is much too inaccurate and allows way
						// more assignments than are desirable (since it maps the source check type to its constraint, it loses information)
						var distributiveConstraint = hasNonCircularBaseConstraint(source) ? getConstraintOfDistributiveConditionalType(
							source,
						) : undefined;
						if (distributiveConstraint) {
							if (
								result = isRelatedTo(
									distributiveConstraint,
									target,
									1, /* Source */
									reportErrors,
								)
							) {
								resetErrorInfo(saveErrorInfo);
								return result;
							}
						}
					}
					// conditionals _can_ be related to one another via normal constraint, as, eg, `A extends B ? O : never` should be assignable to `O`
					// when `O` is a conditional (`never` is trivially assignable to `O`, as is `O`!).
					var defaultConstraint = getDefaultConstraintOfConditionalType(source);
					if (defaultConstraint) {
						if (
							result = isRelatedTo(
								defaultConstraint,
								target,
								1, /* Source */
								reportErrors,
							)
						) {
							resetErrorInfo(saveErrorInfo);
							return result;
						}
					}
				} else {
					// An empty object type is related to any mapped type that includes a '?' modifier.
					if (
						relation !== subtypeRelation && relation !== strictSubtypeRelation && isPartialMappedType(
							target,
						) && isEmptyObjectType(source)
					) {
						return Ternary.True;
					}
					if (isGenericMappedType(target)) {
						if (isGenericMappedType(source)) {
							if (result = mappedTypeRelatedTo(source, target, reportErrors)) {
								resetErrorInfo(saveErrorInfo);
								return result;
							}
						}
						return Ternary.False;
					}
					var sourceIsPrimitive = !!(source.flags & TypeFlags.Primitive);
					if (relation !== identityRelation) {
						source = getApparentType(source);
					} else if (isGenericMappedType(source)) {
						return Ternary.False;
					}
					if (
						getObjectFlags(source) & ObjectFlags.Reference && getObjectFlags(
							target,
						) & ObjectFlags.Reference && source.target === target.target && !isTupleType(
							source,
						) && !(getObjectFlags(source) & ObjectFlags.MarkerType || getObjectFlags(
							target,
						) & ObjectFlags.MarkerType)
					) {
						// We have type references to the same generic type, and the type references are not marker
						// type references (which are intended by be compared structurally). Obtain the variance
						// information for the type parameters and relate the type arguments accordingly.
						var variances = getVariances(source.target);
						// We return Ternary.Maybe for a recursive invocation of getVariances (signalled by emptyArray). This
						// effectively means we measure variance only from type parameter occurrences that aren't nested in
						// recursive instantiations of the generic type.
						if (variances === emptyArray) {
							return Ternary.Unknown;
						}
						var varianceResult = relateVariances(
							getTypeArguments(source),
							getTypeArguments(target),
							variances,
							intersectionState,
						);
						if (varianceResult !== undefined) {
							return varianceResult;
						}
					} else if (
						isReadonlyArrayType(target) ? isArrayType(source) || isTupleType(
							source,
						) : isArrayType(target) && isTupleType(source) && !source.target.readonly
					) {
						if (relation !== identityRelation) {
							return isRelatedTo(
								getIndexTypeOfType(source, numberType) || anyType,
								getIndexTypeOfType(target, numberType) || anyType,
								3, /* Both */
								reportErrors,
							);
						} else {
							// By flags alone, we know that the `target` is a readonly array while the source is a normal array or tuple
							// or `target` is an array and source is a tuple - in both cases the types cannot be identical, by construction
							return Ternary.False;
						}
					} else if ( // and not `{} <- fresh({}) <- {[idx: string]: any}` // Consider a fresh empty object literal type "closed" under the subtype relationship - this way `{} <- {[idx: string]: any} <- fresh({})`
						(relation === subtypeRelation || relation === strictSubtypeRelation) && isEmptyObjectType(
							target,
						) && getObjectFlags(target) & ObjectFlags.FreshLiteral && !isEmptyObjectType(
							source,
						)
					) {
						return Ternary.False;
					}
					// Even if relationship doesn't hold for unions, intersections, or generic type references,
					// it may hold in a structural comparison.
					// In a check of the form X = A & B, we will have previously checked if A relates to X or B relates
					// to X. Failing both of those we want to check if the aggregation of A and B's members structurally
					// relates to X. Thus, we include intersection types on the source side here.
					if (
						source.flags & (TypeFlags.Object | TypeFlags.Intersection) && target.flags & TypeFlags.Object
					) {
						// Report structural errors only if we haven't reported any errors yet
						var reportStructuralErrors = reportErrors && errorInfo === saveErrorInfo.errorInfo && !sourceIsPrimitive;
						result = propertiesRelatedTo(
							source,
							target,
							reportStructuralErrors, /*excludedProperties*/
							undefined,
							intersectionState,
						);
						if (result) {
							result &= signaturesRelatedTo(
								source,
								target,
								SignatureKind.Call,
								reportStructuralErrors,
							);
							if (result) {
								result &= signaturesRelatedTo(
									source,
									target,
									SignatureKind.Construct,
									reportStructuralErrors,
								);
								if (result) {
									result &= indexSignaturesRelatedTo(
										source,
										target,
										sourceIsPrimitive,
										reportStructuralErrors,
										intersectionState,
									);
								}
							}
						}
						if (varianceCheckFailed && result) {
							errorInfo = originalErrorInfo || errorInfo || saveErrorInfo.errorInfo; // Use variance error (there is no structural one) and return false
						} else if (result) {
							return result;
						}
					}
					// If S is an object type and T is a discriminated union, S may be related to T if
					// there exists a constituent of T for every combination of the discriminants of S
					// with respect to T. We do not report errors here, as we will use the existing
					// error result from checking each constituent of the union.
					if (
						source.flags & (TypeFlags.Object | TypeFlags.Intersection) && target.flags & TypeFlags.Union
					) {
						var objectOnlyTarget = extractTypesOfKind(
							target,
							TypeFlags.Object | TypeFlags.Intersection | TypeFlags.Substitution,
						);
						if (objectOnlyTarget.flags & TypeFlags.Union) {
							var result_5 = typeRelatedToDiscriminatedType(
								source,
								objectOnlyTarget,
							);
							if (result_5) {
								return result_5;
							}
						}
					}
				}
				return Ternary.False;
				function countMessageChainBreadth(info) {
					if (!info) return 0;
					return reduceLeft(
						info,
						function (value, chain) {
							return value + 1 + countMessageChainBreadth(chain.next);
						},
						0,
					);
				}
				function relateVariances(
					sourceTypeArguments,
					targetTypeArguments,
					variances,
					intersectionState,
				) {
					if (
						result = typeArgumentsRelatedTo(
							sourceTypeArguments,
							targetTypeArguments,
							variances,
							reportErrors,
							intersectionState,
						)
					) {
						return result;
					}
					if (
						some(
							variances,
							function (v) {
								return !!(v & VarianceFlags.AllowsStructuralFallback);
							},
						)
					) {
						// If some type parameter was `Unmeasurable` or `Unreliable`, and we couldn't pass by assuming it was identical, then we
						// have to allow a structural fallback check
						// We elide the variance-based error elaborations, since those might not be too helpful, since we'll potentially
						// be assuming identity of the type parameter.
						originalErrorInfo = undefined;
						resetErrorInfo(saveErrorInfo);
						return undefined;
					}
					var allowStructuralFallback = targetTypeArguments && hasCovariantVoidArgument(
						targetTypeArguments,
						variances,
					);
					varianceCheckFailed = !allowStructuralFallback;
					// The type arguments did not relate appropriately, but it may be because we have no variance
					// information (in which case typeArgumentsRelatedTo defaulted to covariance for all type
					// arguments). It might also be the case that the target type has a 'void' type argument for
					// a covariant type parameter that is only used in return positions within the generic type
					// (in which case any type argument is permitted on the source side). In those cases we proceed
					// with a structural comparison. Otherwise, we know for certain the instantiations aren't
					// related and we can return here.
					if (variances !== emptyArray && !allowStructuralFallback) {
						// In some cases generic types that are covariant in regular type checking mode become
						// invariant in --strictFunctionTypes mode because one or more type parameters are used in
						// both co- and contravariant positions. In order to make it easier to diagnose *why* such
						// types are invariant, if any of the type parameters are invariant we reset the reported
						// errors and instead force a structural comparison (which will include elaborations that
						// reveal the reason).
						// We can switch on `reportErrors` here, since varianceCheckFailed guarantees we return `False`,
						// we can return `False` early here to skip calculating the structural error message we don't need.
						if (
							varianceCheckFailed && !(reportErrors && some(
								variances,
								function (v) {
									return (v & VarianceFlags.VarianceMask) === VarianceFlags.Invariant;
								},
							))
						) {
							return Ternary.False;
						}
						// We remember the original error information so we can restore it in case the structural
						// comparison unexpectedly succeeds. This can happen when the structural comparison result
						// is a Ternary.Maybe for example caused by the recursion depth limiter.
						originalErrorInfo = errorInfo;
						resetErrorInfo(saveErrorInfo);
					}
				}
			}
			function reportUnmeasurableMarkers(p) {
				if (
					outofbandVarianceMarkerHandler && (p === markerSuperType || p === markerSubType || p === markerOtherType)
				) {
					outofbandVarianceMarkerHandler( /*onlyUnreliable*/ false);
				}
				return p;
			}
			function reportUnreliableMarkers(p) {
				if (
					outofbandVarianceMarkerHandler && (p === markerSuperType || p === markerSubType || p === markerOtherType)
				) {
					outofbandVarianceMarkerHandler( /*onlyUnreliable*/ true);
				}
				return p;
			}
			// A type [P in S]: X is related to a type [Q in T]: Y if T is related to S and X' is
			// related to Y, where X' is an instantiation of X in which P is replaced with Q. Notice
			// that S and T are contra-variant whereas X and Y are co-variant.
			function mappedTypeRelatedTo(source, target, reportErrors) {
				var modifiersRelated = relation === comparableRelation || (relation === identityRelation ? getMappedTypeModifiers(
					source,
				) === getMappedTypeModifiers(target) : getCombinedMappedTypeOptionality(
					source,
				) <= getCombinedMappedTypeOptionality(target));
				if (modifiersRelated) {
					var result_6;
					var targetConstraint = getConstraintTypeFromMappedType(target);
					var sourceConstraint = instantiateType(
						getConstraintTypeFromMappedType(source),
						makeFunctionTypeMapper(
							getCombinedMappedTypeOptionality(source) < 0 ? reportUnmeasurableMarkers : reportUnreliableMarkers,
						),
					);
					if (
						result_6 = isRelatedTo(
							targetConstraint,
							sourceConstraint,
							3, /* Both */
							reportErrors,
						)
					) {
						var mapper = createTypeMapper(
							[getTypeParameterFromMappedType(source)],
							[getTypeParameterFromMappedType(target)],
						);
						if (
							instantiateType(getNameTypeFromMappedType(source), mapper) === instantiateType(
								getNameTypeFromMappedType(target),
								mapper,
							)
						) {
							return result_6 & isRelatedTo(
								instantiateType(getTemplateTypeFromMappedType(source), mapper),
								getTemplateTypeFromMappedType(target),
								3, /* Both */
								reportErrors,
							);
						}
					}
				}
				return Ternary.False;
			}
			function typeRelatedToDiscriminatedType(source, target) {
				// 1. Generate the combinations of discriminant properties & types 'source' can satisfy.
				//    a. If the number of combinations is above a set limit, the comparison is too complex.
				// 2. Filter 'target' to the subset of types whose discriminants exist in the matrix.
				//    a. If 'target' does not satisfy all discriminants in the matrix, 'source' is not related.
				// 3. For each type in the filtered 'target', determine if all non-discriminant properties of
				//    'target' are related to a property in 'source'.
				//
				// NOTE: See ~/tests/cases/conformance/types/typeRelationships/assignmentCompatibility/assignmentCompatWithDiscriminatedUnion.ts
				//       for examples.
				var sourceProperties = getPropertiesOfType(source);
				var sourcePropertiesFiltered = findDiscriminantProperties(
					sourceProperties,
					target,
				);
				if (!sourcePropertiesFiltered) return Ternary.False;
				// Though we could compute the number of combinations as we generate
				// the matrix, this would incur additional memory overhead due to
				// array allocations. To reduce this overhead, we first compute
				// the number of combinations to ensure we will not surpass our
				// fixed limit before incurring the cost of any allocations:
				var numCombinations = 1;
				for (
					var _i = 0, sourcePropertiesFiltered_1 = sourcePropertiesFiltered;
					_i < sourcePropertiesFiltered_1.length;
					_i++
				) {
					var sourceProperty = sourcePropertiesFiltered_1[_i];
					numCombinations *= countTypes(
						getNonMissingTypeOfSymbol(sourceProperty),
					);
					if (numCombinations > 25) {
						// We've reached the complexity limit.
						tracing === null || tracing === void 0 ? void 0 : tracing.instant(
							tracing.Phase.CheckTypes,
							"typeRelatedToDiscriminatedType_DepthLimit",
							{
								sourceId: source.id,
								targetId: target.id,
								numCombinations: numCombinations,
							},
						);
						return Ternary.False;
					}
				}
				// Compute the set of types for each discriminant property.
				var sourceDiscriminantTypes = new Array(sourcePropertiesFiltered.length);
				var excludedProperties = new Set();
				for (var i = 0; i < sourcePropertiesFiltered.length; i++) {
					var sourceProperty = sourcePropertiesFiltered[i];
					var sourcePropertyType = getNonMissingTypeOfSymbol(sourceProperty);
					sourceDiscriminantTypes[i] = sourcePropertyType.flags & TypeFlags.Union ? sourcePropertyType.types : [
						sourcePropertyType,
					];
					excludedProperties.add(sourceProperty.escapedName);
				}
				// Match each combination of the cartesian product of discriminant properties to one or more
				// constituents of 'target'. If any combination does not have a match then 'source' is not relatable.
				var discriminantCombinations = cartesianProduct(sourceDiscriminantTypes);
				var matchingTypes = [];
				var _loop_13 = function (combination) {
					var hasMatch = false;
					outer: for (var _c = 0, _d = target.types; _c < _d.length; _c++) {
						var type = _d[_c];
						var _loop_14 = function (i) {
							var sourceProperty = sourcePropertiesFiltered[i];
							var targetProperty = getPropertyOfType(
								type,
								sourceProperty.escapedName,
							);
							if (!targetProperty) return "continue-outer";
							if (sourceProperty === targetProperty) return "continue";
							// We compare the source property to the target in the context of a single discriminant type.
							var related = propertyRelatedTo(
								source,
								target,
								sourceProperty,
								targetProperty,
								function (_) {
									return combination[i];
								}, /*reportErrors*/
								false,
								0, /* None */ /*skipOptional*/
								strictNullChecks || relation === comparableRelation,
							);
							// If the target property could not be found, or if the properties were not related,
							// then this constituent is not a match.
							if (!related) {
								return "continue-outer";
							}
						};
						for (var i = 0; i < sourcePropertiesFiltered.length; i++) {
							var state_6 = _loop_14(i);
							switch (state_6) {
								case "continue-outer":
									continue outer;
							}
						}
						pushIfUnique(matchingTypes, type, equateValues);
						hasMatch = true;
					}
					if (!hasMatch) {
						return { value: Ternary.False };
					}
				};
				for (
					var _a = 0, discriminantCombinations_1 = discriminantCombinations;
					_a < discriminantCombinations_1.length;
					_a++
				) {
					var combination = discriminantCombinations_1[_a];
					var state_5 = _loop_13(combination);
					if (typeof state_5 === "object") return state_5.value;
				}
				// Compare the remaining non-discriminant properties of each match.
				var result = Ternary.True;
				for (
					var _b = 0, matchingTypes_1 = matchingTypes;
					_b < matchingTypes_1.length;
					_b++
				) {
					var type = matchingTypes_1[_b];
					result &= propertiesRelatedTo(
						source,
						type, /*reportErrors*/
						false,
						excludedProperties,
						0, /* None */
					);
					if (result) {
						result &= signaturesRelatedTo(
							source,
							type,
							SignatureKind.Call, /*reportStructuralErrors*/
							false,
						);
						if (result) {
							result &= signaturesRelatedTo(
								source,
								type,
								SignatureKind.Construct, /*reportStructuralErrors*/
								false,
							);
							if (result && !(isTupleType(source) && isTupleType(type))) {
								// Comparing numeric index types when both `source` and `type` are tuples is unnecessary as the
								// element types should be sufficiently covered by `propertiesRelatedTo`. It also causes problems
								// with index type assignability as the types for the excluded discriminants are still included
								// in the index type.
								result &= indexSignaturesRelatedTo(
									source,
									type, /*sourceIsPrimitive*/
									false, /*reportStructuralErrors*/
									false,
									0, /* None */
								);
							}
						}
					}
					if (!result) {
						return result;
					}
				}
				return result;
			}
			function excludeProperties(properties, excludedProperties) {
				if (!excludedProperties || properties.length === 0) return properties;
				var result;
				for (var i = 0; i < properties.length; i++) {
					if (!excludedProperties.has(properties[i].escapedName)) {
						if (result) {
							result.push(properties[i]);
						}
					} else if (!result) {
						result = properties.slice(0, i);
					}
				}
				return result || properties;
			}
			function isPropertySymbolTypeRelated(
				sourceProp,
				targetProp,
				getTypeOfSourceProperty,
				reportErrors,
				intersectionState,
			) {
				var targetIsOptional = strictNullChecks && !!(getCheckFlags(targetProp) & CheckFlags.Partial);
				var effectiveTarget = addOptionality(
					getNonMissingTypeOfSymbol(targetProp), /*isProperty*/
					false,
					targetIsOptional,
				);
				var effectiveSource = getTypeOfSourceProperty(sourceProp);
				return isRelatedTo(
					effectiveSource,
					effectiveTarget,
					3, /* Both */
					reportErrors, /*headMessage*/
					undefined,
					intersectionState,
				);
			}
			function propertyRelatedTo(
				source,
				target,
				sourceProp,
				targetProp,
				getTypeOfSourceProperty,
				reportErrors,
				intersectionState,
				skipOptional,
			) {
				var sourcePropFlags = getDeclarationModifierFlagsFromSymbol(sourceProp);
				var targetPropFlags = getDeclarationModifierFlagsFromSymbol(targetProp);
				if (
					sourcePropFlags & ModifierFlags.Private || targetPropFlags & ModifierFlags.Private
				) {
					if (sourceProp.valueDeclaration !== targetProp.valueDeclaration) {
						if (reportErrors) {
							if (
								sourcePropFlags & ModifierFlags.Private && targetPropFlags & ModifierFlags.Private
							) {
								reportError(
									Diagnostics.Types_have_separate_declarations_of_a_private_property_0,
									symbolToString(targetProp),
								);
							} else {
								reportError(
									Diagnostics.Property_0_is_private_in_type_1_but_not_in_type_2,
									symbolToString(targetProp),
									typeToString(
										sourcePropFlags & ModifierFlags.Private ? source : target,
									),
									typeToString(
										sourcePropFlags & ModifierFlags.Private ? target : source,
									),
								);
							}
						}
						return Ternary.False;
					}
				} else if (targetPropFlags & ModifierFlags.Protected) {
					if (!isValidOverrideOf(sourceProp, targetProp)) {
						if (reportErrors) {
							reportError(
								Diagnostics.Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2,
								symbolToString(targetProp),
								typeToString(getDeclaringClass(sourceProp) || source),
								typeToString(getDeclaringClass(targetProp) || target),
							);
						}
						return Ternary.False;
					}
				} else if (sourcePropFlags & ModifierFlags.Protected) {
					if (reportErrors) {
						reportError(
							Diagnostics.Property_0_is_protected_in_type_1_but_public_in_type_2,
							symbolToString(targetProp),
							typeToString(source),
							typeToString(target),
						);
					}
					return Ternary.False;
				}
				// If the target comes from a partial union prop, allow `undefined` in the target type
				var related = isPropertySymbolTypeRelated(
					sourceProp,
					targetProp,
					getTypeOfSourceProperty,
					reportErrors,
					intersectionState,
				);
				if (!related) {
					if (reportErrors) {
						reportIncompatibleError(
							Diagnostics.Types_of_property_0_are_incompatible,
							symbolToString(targetProp),
						);
					}
					return Ternary.False;
				}
				// When checking for comparability, be more lenient with optional properties.
				if (
					!skipOptional && sourceProp.flags & SymbolFlags.Optional && !(targetProp.flags & SymbolFlags.Optional)
				) {
					// TypeScript 1.0 spec (April 2014): 3.8.3
					// S is a subtype of a type T, and T is a supertype of S if ...
					// S' and T are object types and, for each member M in T..
					// M is a property and S' contains a property N where
					// if M is a required property, N is also a required property
					// (M - property in T)
					// (N - property in S)
					if (reportErrors) {
						reportError(
							Diagnostics.Property_0_is_optional_in_type_1_but_required_in_type_2,
							symbolToString(targetProp),
							typeToString(source),
							typeToString(target),
						);
					}
					return Ternary.False;
				}
				return related;
			}
			function reportUnmatchedProperty(
				source,
				target,
				unmatchedProperty,
				requireOptionalProperties,
			) {
				var shouldSkipElaboration = false;
				// give specific error in case where private names have the same description
				if (
					unmatchedProperty.valueDeclaration && isNamedDeclaration(
						unmatchedProperty.valueDeclaration,
					) && isPrivateIdentifier(unmatchedProperty.valueDeclaration.name) && source.symbol && source.symbol.flags & SymbolFlags.Class
				) {
					var privateIdentifierDescription = unmatchedProperty.valueDeclaration.name.escapedText;
					var symbolTableKey = getSymbolNameForPrivateIdentifier(
						source.symbol,
						privateIdentifierDescription,
					);
					if (symbolTableKey && getPropertyOfType(source, symbolTableKey)) {
						var sourceName = factory.getDeclarationName(
							source.symbol.valueDeclaration,
						);
						var targetName = factory.getDeclarationName(
							target.symbol.valueDeclaration,
						);
						reportError(
							Diagnostics.Property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2,
							diagnosticName(privateIdentifierDescription),
							diagnosticName(sourceName.escapedText === "" ? anon : sourceName),
							diagnosticName(targetName.escapedText === "" ? anon : targetName),
						);
						return;
					}
				}
				var props = arrayFrom(
					getUnmatchedProperties(
						source,
						target,
						requireOptionalProperties, /*matchDiscriminantProperties*/
						false,
					),
				);
				if (
					!headMessage || (headMessage.code !== Diagnostics.Class_0_incorrectly_implements_interface_1.code && headMessage.code !== Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass.code)
				) {
					shouldSkipElaboration = true; // Retain top-level error for interface implementing issues, otherwise omit it
				}
				if (props.length === 1) {
					var propName = symbolToString(unmatchedProperty);
					reportError.apply(
						void 0,
						__spreadArray(
							[
								Diagnostics.Property_0_is_missing_in_type_1_but_required_in_type_2,
								propName,
							],
							getTypeNamesForErrorDisplay(source, target),
							false,
						),
					);
					if (length(unmatchedProperty.declarations)) {
						associateRelatedInfo(
							createDiagnosticForNode(
								unmatchedProperty.declarations[0],
								Diagnostics._0_is_declared_here,
								propName,
							),
						);
					}
					if (shouldSkipElaboration && errorInfo) {
						overrideNextErrorInfo++;
					}
				} else if (
					tryElaborateArrayLikeErrors(source, target, /*reportErrors*/ false)
				) {
					if (props.length > 5) {
						reportError(
							Diagnostics.Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more, // arbitrary cutoff for too-long list form
							typeToString(source),
							typeToString(target),
							map(
								props.slice(0, 4),
								function (p) {
									return symbolToString(p);
								},
							).join(", "),
							props.length - 4,
						);
					} else {
						reportError(
							Diagnostics.Type_0_is_missing_the_following_properties_from_type_1_Colon_2,
							typeToString(source),
							typeToString(target),
							map(
								props,
								function (p) {
									return symbolToString(p);
								},
							).join(", "),
						);
					}
					if (shouldSkipElaboration && errorInfo) {
						overrideNextErrorInfo++;
					}
				} // No array like or unmatched property error - just issue top level error (errorInfo = undefined)
			}
			function propertiesRelatedTo(
				source,
				target,
				reportErrors,
				excludedProperties,
				intersectionState,
			) {
				if (relation === identityRelation) {
					return propertiesIdenticalTo(source, target, excludedProperties);
				}
				var result = Ternary.True;
				if (isTupleType(target)) {
					if (isArrayType(source) || isTupleType(source)) {
						if (
							!target.target.readonly && (isReadonlyArrayType(source) || isTupleType(
								source,
							) && source.target.readonly)
						) {
							return Ternary.False;
						}
						var sourceArity = getTypeReferenceArity(source);
						var targetArity = getTypeReferenceArity(target);
						var sourceRestFlag = isTupleType(source) ? source.target.combinedFlags & ElementFlags.Rest : ElementFlags.Rest;
						var targetRestFlag = target.target.combinedFlags & ElementFlags.Rest;
						var sourceMinLength = isTupleType(source) ? source.target.minLength : 0;
						var targetMinLength = target.target.minLength;
						if (!sourceRestFlag && sourceArity < targetMinLength) {
							if (reportErrors) {
								reportError(
									Diagnostics.Source_has_0_element_s_but_target_requires_1,
									sourceArity,
									targetMinLength,
								);
							}
							return Ternary.False;
						}
						if (!targetRestFlag && targetArity < sourceMinLength) {
							if (reportErrors) {
								reportError(
									Diagnostics.Source_has_0_element_s_but_target_allows_only_1,
									sourceMinLength,
									targetArity,
								);
							}
							return Ternary.False;
						}
						if (
							!targetRestFlag && (sourceRestFlag || targetArity < sourceArity)
						) {
							if (reportErrors) {
								if (sourceMinLength < targetMinLength) {
									reportError(
										Diagnostics.Target_requires_0_element_s_but_source_may_have_fewer,
										targetMinLength,
									);
								} else {
									reportError(
										Diagnostics.Target_allows_only_0_element_s_but_source_may_have_more,
										targetArity,
									);
								}
							}
							return Ternary.False;
						}
						var sourceTypeArguments = getTypeArguments(source);
						var targetTypeArguments = getTypeArguments(target);
						var startCount = Math.min(
							isTupleType(source) ? getStartElementCount(
								source.target,
								ElementFlags.NonRest,
							) : 0,
							getStartElementCount(target.target, ElementFlags.NonRest),
						);
						var endCount = Math.min(
							isTupleType(source) ? getEndElementCount(
								source.target,
								ElementFlags.NonRest,
							) : 0,
							targetRestFlag ? getEndElementCount(
								target.target,
								ElementFlags.NonRest,
							) : 0,
						);
						var canExcludeDiscriminants = !!excludedProperties;
						for (var i = 0; i < targetArity; i++) {
							var sourceIndex = i < targetArity - endCount ? i : i + sourceArity - targetArity;
							var sourceFlags = isTupleType(source) && (i < startCount || i >= targetArity - endCount) ? source.target.elementFlags[sourceIndex] : ElementFlags.Rest;
							var targetFlags = target.target.elementFlags[i];
							if (
								targetFlags & ElementFlags.Variadic && !(sourceFlags & ElementFlags.Variadic)
							) {
								if (reportErrors) {
									reportError(
										Diagnostics.Source_provides_no_match_for_variadic_element_at_position_0_in_target,
										i,
									);
								}
								return Ternary.False;
							}
							if (
								sourceFlags & ElementFlags.Variadic && !(targetFlags & ElementFlags.Variable)
							) {
								if (reportErrors) {
									reportError(
										Diagnostics.Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target,
										sourceIndex,
										i,
									);
								}
								return Ternary.False;
							}
							if (
								targetFlags & ElementFlags.Required && !(sourceFlags & ElementFlags.Required)
							) {
								if (reportErrors) {
									reportError(
										Diagnostics.Source_provides_no_match_for_required_element_at_position_0_in_target,
										i,
									);
								}
								return Ternary.False;
							}
							// We can only exclude discriminant properties if we have not yet encountered a variable-length element.
							if (canExcludeDiscriminants) {
								if (
									sourceFlags & ElementFlags.Variable || targetFlags & ElementFlags.Variable
								) {
									canExcludeDiscriminants = false;
								}
								if (
									canExcludeDiscriminants && (excludedProperties === null || excludedProperties === void 0 ? void 0 : excludedProperties.has(
										("" + i),
									))
								) {
									continue;
								}
							}
							var sourceType = !isTupleType(source) ? sourceTypeArguments[0] : i < startCount || i >= targetArity - endCount ? removeMissingType(
								sourceTypeArguments[sourceIndex],
								!!(sourceFlags & targetFlags & ElementFlags.Optional),
							) : getElementTypeOfSliceOfTupleType(source, startCount, endCount) || neverType;
							var targetType = targetTypeArguments[i];
							var targetCheckType = sourceFlags & ElementFlags.Variadic && targetFlags & ElementFlags.Rest ? createArrayType(
								targetType,
							) : removeMissingType(
								targetType,
								!!(targetFlags & ElementFlags.Optional),
							);
							var related = isRelatedTo(
								sourceType,
								targetCheckType,
								3, /* Both */
								reportErrors, /*headMessage*/
								undefined,
								intersectionState,
							);
							if (!related) {
								if (reportErrors && (targetArity > 1 || sourceArity > 1)) {
									if (
										i < startCount || i >= targetArity - endCount || sourceArity - startCount - endCount === 1
									) {
										reportIncompatibleError(
											Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target,
											sourceIndex,
											i,
										);
									} else {
										reportIncompatibleError(
											Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target,
											startCount,
											sourceArity - endCount - 1,
											i,
										);
									}
								}
								return Ternary.False;
							}
							result &= related;
						}
						return result;
					}
					if (target.target.combinedFlags & ElementFlags.Variable) {
						return Ternary.False;
					}
				}
				var requireOptionalProperties = (relation === subtypeRelation || relation === strictSubtypeRelation) && !isObjectLiteralType(
					source,
				) && !isEmptyArrayLiteralType(source) && !isTupleType(source);
				var unmatchedProperty = getUnmatchedProperty(
					source,
					target,
					requireOptionalProperties, /*matchDiscriminantProperties*/
					false,
				);
				if (unmatchedProperty) {
					if (reportErrors) {
						reportUnmatchedProperty(
							source,
							target,
							unmatchedProperty,
							requireOptionalProperties,
						);
					}
					return Ternary.False;
				}
				if (isObjectLiteralType(target)) {
					for (
						var _i = 0,
							_a = excludeProperties(
								getPropertiesOfType(source),
								excludedProperties,
							);
						_i < _a.length;
						_i++
					) {
						var sourceProp = _a[_i];
						if (!getPropertyOfObjectType(target, sourceProp.escapedName)) {
							var sourceType = getTypeOfSymbol(sourceProp);
							if (!(sourceType.flags & TypeFlags.Undefined)) {
								if (reportErrors) {
									reportError(
										Diagnostics.Property_0_does_not_exist_on_type_1,
										symbolToString(sourceProp),
										typeToString(target),
									);
								}
								return Ternary.False;
							}
						}
					}
				}
				// We only call this for union target types when we're attempting to do excess property checking - in those cases, we want to get _all possible props_
				// from the target union, across all members
				var properties = getPropertiesOfType(target);
				var numericNamesOnly = isTupleType(source) && isTupleType(target);
				for (
					var _b = 0, _c = excludeProperties(properties, excludedProperties);
					_b < _c.length;
					_b++
				) {
					var targetProp = _c[_b];
					var name_17 = targetProp.escapedName;
					if (
						!(targetProp.flags & SymbolFlags.Prototype) && (!numericNamesOnly || isNumericLiteralName(
							name_17,
						) || name_17 === "length")
					) {
						var sourceProp = getPropertyOfType(source, name_17);
						if (sourceProp && sourceProp !== targetProp) {
							var related = propertyRelatedTo(
								source,
								target,
								sourceProp,
								targetProp,
								getNonMissingTypeOfSymbol,
								reportErrors,
								intersectionState,
								relation === comparableRelation,
							);
							if (!related) {
								return Ternary.False;
							}
							result &= related;
						}
					}
				}
				return result;
			}
			function propertiesIdenticalTo(source, target, excludedProperties) {
				if (
					!(source.flags & TypeFlags.Object && target.flags & TypeFlags.Object)
				) {
					return Ternary.False;
				}
				var sourceProperties = excludeProperties(
					getPropertiesOfObjectType(source),
					excludedProperties,
				);
				var targetProperties = excludeProperties(
					getPropertiesOfObjectType(target),
					excludedProperties,
				);
				if (sourceProperties.length !== targetProperties.length) {
					return Ternary.False;
				}
				var result = Ternary.True;
				for (
					var _i = 0, sourceProperties_1 = sourceProperties;
					_i < sourceProperties_1.length;
					_i++
				) {
					var sourceProp = sourceProperties_1[_i];
					var targetProp = getPropertyOfObjectType(
						target,
						sourceProp.escapedName,
					);
					if (!targetProp) {
						return Ternary.False;
					}
					var related = compareProperties(sourceProp, targetProp, isRelatedTo);
					if (!related) {
						return Ternary.False;
					}
					result &= related;
				}
				return result;
			}
			function signaturesRelatedTo(source, target, kind, reportErrors) {
				var _a, _b;
				if (relation === identityRelation) {
					return signaturesIdenticalTo(source, target, kind);
				}
				if (target === anyFunctionType || source === anyFunctionType) {
					return Ternary.True;
				}
				var sourceIsJSConstructor = source.symbol && isJSConstructor(
					source.symbol.valueDeclaration,
				);
				var targetIsJSConstructor = target.symbol && isJSConstructor(
					target.symbol.valueDeclaration,
				);
				var sourceSignatures = getSignaturesOfType(
					source,
					(sourceIsJSConstructor && kind === SignatureKind.Construct) ? SignatureKind.Call : kind,
				);
				var targetSignatures = getSignaturesOfType(
					target,
					(targetIsJSConstructor && kind === SignatureKind.Construct) ? SignatureKind.Call : kind,
				);
				if (
					kind === SignatureKind.Construct && sourceSignatures.length && targetSignatures.length
				) {
					var sourceIsAbstract = !!(sourceSignatures[0].flags & SignatureFlags.Abstract);
					var targetIsAbstract = !!(targetSignatures[0].flags & SignatureFlags.Abstract);
					if (sourceIsAbstract && !targetIsAbstract) {
						// An abstract constructor type is not assignable to a non-abstract constructor type
						// as it would otherwise be possible to new an abstract class. Note that the assignability
						// check we perform for an extends clause excludes construct signatures from the target,
						// so this check never proceeds.
						if (reportErrors) {
							reportError(
								Diagnostics.Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type,
							);
						}
						return Ternary.False;
					}
					if (
						!constructorVisibilitiesAreCompatible(
							sourceSignatures[0],
							targetSignatures[0],
							reportErrors,
						)
					) {
						return Ternary.False;
					}
				}
				var result = Ternary.True;
				var saveErrorInfo = captureErrorCalculationState();
				var incompatibleReporter = kind === SignatureKind.Construct ? reportIncompatibleConstructSignatureReturn : reportIncompatibleCallSignatureReturn;
				var sourceObjectFlags = getObjectFlags(source);
				var targetObjectFlags = getObjectFlags(target);
				if (
					sourceObjectFlags & ObjectFlags.Instantiated && targetObjectFlags & ObjectFlags.Instantiated && source.symbol === target.symbol || sourceObjectFlags & ObjectFlags.Reference && targetObjectFlags & ObjectFlags.Reference && source.target === target.target
				) {
					// We have instantiations of the same anonymous type (which typically will be the type of a
					// method). Simply do a pairwise comparison of the signatures in the two signature lists instead
					// of the much more expensive N * M comparison matrix we explore below. We erase type parameters
					// as they are known to always be the same.
					for (var i = 0; i < targetSignatures.length; i++) {
						var related = signatureRelatedTo(
							sourceSignatures[i],
							targetSignatures[i], /*erase*/
							true,
							reportErrors,
							incompatibleReporter(sourceSignatures[i], targetSignatures[i]),
						);
						if (!related) {
							return Ternary.False;
						}
						result &= related;
					}
				} else if (
					sourceSignatures.length === 1 && targetSignatures.length === 1
				) {
					// For simple functions (functions with a single signature) we only erase type parameters for
					// the comparable relation. Otherwise, if the source signature is generic, we instantiate it
					// in the context of the target signature before checking the relationship. Ideally we'd do
					// this regardless of the number of signatures, but the potential costs are prohibitive due
					// to the quadratic nature of the logic below.
					var eraseGenerics = relation === comparableRelation || !!compilerOptions.noStrictGenericChecks;
					var sourceSignature = first(sourceSignatures);
					var targetSignature = first(targetSignatures);
					result = signatureRelatedTo(
						sourceSignature,
						targetSignature,
						eraseGenerics,
						reportErrors,
						incompatibleReporter(sourceSignature, targetSignature),
					);
					if (
						!result && reportErrors && kind === SignatureKind.Construct && (sourceObjectFlags & targetObjectFlags) && (((_a = targetSignature.declaration) === null || _a === void 0 ? void 0 : _a.kind) === SyntaxKind.Constructor || ((_b = sourceSignature.declaration) === null || _b === void 0 ? void 0 : _b.kind) === SyntaxKind.Constructor)
					) {
						var constructSignatureToString = function (signature) {
							return signatureToString(
								signature, /*enclosingDeclaration*/
								undefined,
								TypeFormatFlags.WriteArrowStyleSignature,
								kind,
							);
						};
						reportError(
							Diagnostics.Type_0_is_not_assignable_to_type_1,
							constructSignatureToString(sourceSignature),
							constructSignatureToString(targetSignature),
						);
						reportError(
							Diagnostics.Types_of_construct_signatures_are_incompatible,
						);
						return result;
					}
				} else {
					outer: for (
						var _i = 0, targetSignatures_1 = targetSignatures;
						_i < targetSignatures_1.length;
						_i++
					) {
						var t = targetSignatures_1[_i];
						// Only elaborate errors from the first failure
						var shouldElaborateErrors = reportErrors;
						for (
							var _c = 0, sourceSignatures_1 = sourceSignatures;
							_c < sourceSignatures_1.length;
							_c++
						) {
							var s = sourceSignatures_1[_c];
							var related = signatureRelatedTo(
								s,
								t, /*erase*/
								true,
								shouldElaborateErrors,
								incompatibleReporter(s, t),
							);
							if (related) {
								result &= related;
								resetErrorInfo(saveErrorInfo);
								continue outer;
							}
							shouldElaborateErrors = false;
						}
						if (shouldElaborateErrors) {
							reportError(
								Diagnostics.Type_0_provides_no_match_for_the_signature_1,
								typeToString(source),
								signatureToString(
									t, /*enclosingDeclaration*/
									undefined, /*flags*/
									undefined,
									kind,
								),
							);
						}
						return Ternary.False;
					}
				}
				return result;
			}
			function reportIncompatibleCallSignatureReturn(siga, sigb) {
				if (siga.parameters.length === 0 && sigb.parameters.length === 0) {
					return function (source, target) {
						return reportIncompatibleError(
							Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1,
							typeToString(source),
							typeToString(target),
						);
					};
				}
				return function (source, target) {
					return reportIncompatibleError(
						Diagnostics.Call_signature_return_types_0_and_1_are_incompatible,
						typeToString(source),
						typeToString(target),
					);
				};
			}
			function reportIncompatibleConstructSignatureReturn(siga, sigb) {
				if (siga.parameters.length === 0 && sigb.parameters.length === 0) {
					return function (source, target) {
						return reportIncompatibleError(
							Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1,
							typeToString(source),
							typeToString(target),
						);
					};
				}
				return function (source, target) {
					return reportIncompatibleError(
						Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible,
						typeToString(source),
						typeToString(target),
					);
				};
			}
			/**
             * See signatureAssignableTo, compareSignaturesIdentical
             */
			function signatureRelatedTo(
				source,
				target,
				erase,
				reportErrors,
				incompatibleReporter,
			) {
				return compareSignaturesRelated(
					erase ? getErasedSignature(source) : source,
					erase ? getErasedSignature(target) : target,
					relation === strictSubtypeRelation ? 8 : 0, /* StrictArity */
					reportErrors,
					reportError,
					incompatibleReporter,
					isRelatedToWorker,
					makeFunctionTypeMapper(reportUnreliableMarkers),
				);
			}
			function signaturesIdenticalTo(source, target, kind) {
				var sourceSignatures = getSignaturesOfType(source, kind);
				var targetSignatures = getSignaturesOfType(target, kind);
				if (sourceSignatures.length !== targetSignatures.length) {
					return Ternary.False;
				}
				var result = Ternary.True;
				for (var i = 0; i < sourceSignatures.length; i++) {
					var related = compareSignaturesIdentical(
						sourceSignatures[i],
						targetSignatures[i], /*partialMatch*/
						false, /*ignoreThisTypes*/
						false, /*ignoreReturnTypes*/
						false,
						isRelatedTo,
					);
					if (!related) {
						return Ternary.False;
					}
					result &= related;
				}
				return result;
			}
			function membersRelatedToIndexInfo(source, targetInfo, reportErrors) {
				var result = Ternary.True;
				var keyType = targetInfo.keyType;
				var props = source.flags & TypeFlags.Intersection ? getPropertiesOfUnionOrIntersectionType(
					source,
				) : getPropertiesOfObjectType(source);
				for (var _i = 0, props_2 = props; _i < props_2.length; _i++) {
					var prop = props_2[_i];
					// Skip over ignored JSX and symbol-named members
					if (isIgnoredJsxProperty(source, prop)) {
						continue;
					}
					if (
						isApplicableIndexType(
							getLiteralTypeFromProperty(
								prop,
								TypeFlags.StringOrNumberLiteralOrUnique,
							),
							keyType,
						)
					) {
						var propType = getNonMissingTypeOfSymbol(prop);
						var type = exactOptionalPropertyTypes || propType.flags & TypeFlags.Undefined || keyType === numberType || !(prop.flags & SymbolFlags.Optional) ? propType : getTypeWithFacts(
							propType,
							524288, /* NEUndefined */
						);
						var related = isRelatedTo(
							type,
							targetInfo.type,
							3, /* Both */
							reportErrors,
						);
						if (!related) {
							if (reportErrors) {
								reportError(
									Diagnostics.Property_0_is_incompatible_with_index_signature,
									symbolToString(prop),
								);
							}
							return Ternary.False;
						}
						result &= related;
					}
				}
				for (var _a = 0, _b = getIndexInfosOfType(source); _a < _b.length; _a++) {
					var info = _b[_a];
					if (isApplicableIndexType(info.keyType, keyType)) {
						var related = indexInfoRelatedTo(info, targetInfo, reportErrors);
						if (!related) {
							return Ternary.False;
						}
						result &= related;
					}
				}
				return result;
			}
			function indexInfoRelatedTo(sourceInfo, targetInfo, reportErrors) {
				var related = isRelatedTo(
					sourceInfo.type,
					targetInfo.type,
					3, /* Both */
					reportErrors,
				);
				if (!related && reportErrors) {
					if (sourceInfo.keyType === targetInfo.keyType) {
						reportError(
							Diagnostics._0_index_signatures_are_incompatible,
							typeToString(sourceInfo.keyType),
						);
					} else {
						reportError(
							Diagnostics._0_and_1_index_signatures_are_incompatible,
							typeToString(sourceInfo.keyType),
							typeToString(targetInfo.keyType),
						);
					}
				}
				return related;
			}
			function indexSignaturesRelatedTo(
				source,
				target,
				sourceIsPrimitive,
				reportErrors,
				intersectionState,
			) {
				if (relation === identityRelation) {
					return indexSignaturesIdenticalTo(source, target);
				}
				var indexInfos = getIndexInfosOfType(target);
				var targetHasStringIndex = some(
					indexInfos,
					function (info) {
						return info.keyType === stringType;
					},
				);
				var result = Ternary.True;
				for (
					var _i = 0, indexInfos_3 = indexInfos;
					_i < indexInfos_3.length;
					_i++
				) {
					var targetInfo = indexInfos_3[_i];
					var related = !sourceIsPrimitive && targetHasStringIndex && targetInfo.type.flags & TypeFlags.Any ? Ternary.True : isGenericMappedType(
						source,
					) && targetHasStringIndex ? isRelatedTo(
						getTemplateTypeFromMappedType(source),
						targetInfo.type,
						3, /* Both */
						reportErrors,
					) : typeRelatedToIndexInfo(
						source,
						targetInfo,
						reportErrors,
						intersectionState,
					);
					if (!related) {
						return Ternary.False;
					}
					result &= related;
				}
				return result;
			}
			function typeRelatedToIndexInfo(
				source,
				targetInfo,
				reportErrors,
				intersectionState,
			) {
				var sourceInfo = getApplicableIndexInfo(source, targetInfo.keyType);
				if (sourceInfo) {
					return indexInfoRelatedTo(sourceInfo, targetInfo, reportErrors);
				}
				if (
					!(intersectionState & 1) && isObjectTypeWithInferableIndex(
						source,
					) /* Source */
				) {
					// Intersection constituents are never considered to have an inferred index signature
					return membersRelatedToIndexInfo(source, targetInfo, reportErrors);
				}
				if (reportErrors) {
					reportError(
						Diagnostics.Index_signature_for_type_0_is_missing_in_type_1,
						typeToString(targetInfo.keyType),
						typeToString(source),
					);
				}
				return Ternary.False;
			}
			function indexSignaturesIdenticalTo(source, target) {
				var sourceInfos = getIndexInfosOfType(source);
				var targetInfos = getIndexInfosOfType(target);
				if (sourceInfos.length !== targetInfos.length) {
					return Ternary.False;
				}
				for (
					var _i = 0, targetInfos_1 = targetInfos;
					_i < targetInfos_1.length;
					_i++
				) {
					var targetInfo = targetInfos_1[_i];
					var sourceInfo = getIndexInfoOfType(source, targetInfo.keyType);
					if (
						!(sourceInfo && isRelatedTo(
							sourceInfo.type,
							targetInfo.type,
							3, /* Both */
						) && sourceInfo.isReadonly === targetInfo.isReadonly)
					) {
						return Ternary.False;
					}
				}
				return Ternary.True;
			}
			function constructorVisibilitiesAreCompatible(
				sourceSignature,
				targetSignature,
				reportErrors,
			) {
				if (!sourceSignature.declaration || !targetSignature.declaration) {
					return true;
				}
				var sourceAccessibility = getSelectedEffectiveModifierFlags(
					sourceSignature.declaration,
					ModifierFlags.NonPublicAccessibilityModifier,
				);
				var targetAccessibility = getSelectedEffectiveModifierFlags(
					targetSignature.declaration,
					ModifierFlags.NonPublicAccessibilityModifier,
				);
				// A public, protected and private signature is assignable to a private signature.
				if (targetAccessibility === ModifierFlags.Private) {
					return true;
				}
				// A public and protected signature is assignable to a protected signature.
				if (
					targetAccessibility === ModifierFlags.Protected && sourceAccessibility !== ModifierFlags.Private
				) {
					return true;
				}
				// Only a public signature is assignable to public signature.
				if (
					targetAccessibility !== ModifierFlags.Protected && !sourceAccessibility
				) {
					return true;
				}
				if (reportErrors) {
					reportError(
						Diagnostics.Cannot_assign_a_0_constructor_type_to_a_1_constructor_type,
						visibilityToString(sourceAccessibility),
						visibilityToString(targetAccessibility),
					);
				}
				return false;
			}
		}
		function typeCouldHaveTopLevelSingletonTypes(type) {
			// Okay, yes, 'boolean' is a union of 'true | false', but that's not useful
			// in error reporting scenarios. If you need to use this function but that detail matters,
			// feel free to add a flag.
			if (type.flags & TypeFlags.Boolean) {
				return false;
			}
			if (type.flags & TypeFlags.UnionOrIntersection) {
				return !!forEach(type.types, typeCouldHaveTopLevelSingletonTypes);
			}
			if (type.flags & TypeFlags.Instantiable) {
				var constraint = getConstraintOfType(type);
				if (constraint && constraint !== type) {
					return typeCouldHaveTopLevelSingletonTypes(constraint);
				}
			}
			return isUnitType(type) || !!(type.flags & TypeFlags.TemplateLiteral);
		}
		function getExactOptionalUnassignableProperties(source, target) {
			if (isTupleType(source) && isTupleType(target)) return emptyArray;
			return getPropertiesOfType(target).filter(
				function (targetProp) {
					return isExactOptionalPropertyMismatch(
						getTypeOfPropertyOfType(source, targetProp.escapedName),
						getTypeOfSymbol(targetProp),
					);
				},
			);
		}
		function isExactOptionalPropertyMismatch(source, target) {
			return !!source && !!target && maybeTypeOfKind(
				source,
				TypeFlags.Undefined,
			) && !!containsMissingType(target);
		}
		function getExactOptionalProperties(type) {
			return getPropertiesOfType(type).filter(
				function (targetProp) {
					return containsMissingType(getTypeOfSymbol(targetProp));
				},
			);
		}
		function getBestMatchingType(source, target, isRelatedTo) {
			if (isRelatedTo === void 0) {
				isRelatedTo = compareTypesAssignable;
			}
			return findMatchingDiscriminantType(
				source,
				target,
				isRelatedTo, /*skipPartial*/
				true,
			) || findMatchingTypeReferenceOrTypeAliasReference(source, target) || findBestTypeForObjectLiteral(
				source,
				target,
			) || findBestTypeForInvokable(source, target) || findMostOverlappyType(
				source,
				target,
			);
		}
		function discriminateTypeByDiscriminableItems(
			target,
			discriminators,
			related,
			defaultValue,
			skipPartial,
		) {
			// undefined=unknown, true=discriminated, false=not discriminated
			// The state of each type progresses from left to right. Discriminated types stop at 'true'.
			var discriminable = target.types.map(
				function (_) {
					return undefined;
				},
			);
			for (
				var _i = 0, discriminators_1 = discriminators;
				_i < discriminators_1.length;
				_i++
			) {
				var _a = discriminators_1[_i],
					getDiscriminatingType = _a[0],
					propertyName = _a[1];
				var targetProp = getUnionOrIntersectionProperty(target, propertyName);
				if (
					skipPartial && targetProp && getCheckFlags(targetProp) & CheckFlags.ReadPartial
				) {
					continue;
				}
				var i = 0;
				for (var _b = 0, _c = target.types; _b < _c.length; _b++) {
					var type = _c[_b];
					var targetType = getTypeOfPropertyOfType(type, propertyName);
					if (targetType && related(getDiscriminatingType(), targetType)) {
						discriminable[i] = discriminable[i] === undefined ? true : discriminable[i];
					} else {
						discriminable[i] = false;
					}
					i++;
				}
			}
			var match = discriminable.indexOf( /*searchElement*/ true);
			if (match === -1) {
				return defaultValue;
			}
			// make sure exactly 1 matches before returning it
			var nextMatch = discriminable.indexOf( /*searchElement*/ true, match + 1);
			while (nextMatch !== -1) {
				if (!isTypeIdenticalTo(target.types[match], target.types[nextMatch])) {
					return defaultValue;
				}
				nextMatch = discriminable.indexOf(true, /*searchElement*/ nextMatch + 1);
			}
			return target.types[match];
		}
		/**
         * A type is 'weak' if it is an object type with at least one optional property
         * and no required properties, call/construct signatures or index signatures
         */
		function isWeakType(type) {
			if (type.flags & TypeFlags.Object) {
				var resolved = resolveStructuredTypeMembers(type);
				return resolved.callSignatures.length === 0 && resolved.constructSignatures.length === 0 && resolved.indexInfos.length === 0 && resolved.properties.length > 0 && every(
					resolved.properties,
					function (p) {
						return !!(p.flags & SymbolFlags.Optional);
					},
				);
			}
			if (type.flags & TypeFlags.Intersection) {
				return every(type.types, isWeakType);
			}
			return false;
		}
		function hasCommonProperties(source, target, isComparingJsxAttributes) {
			for (var _i = 0, _a = getPropertiesOfType(source); _i < _a.length; _i++) {
				var prop = _a[_i];
				if (isKnownProperty(target, prop.escapedName, isComparingJsxAttributes)) {
					return true;
				}
			}
			return false;
		}
		// Return a type reference where the source type parameter is replaced with the target marker
		// type, and flag the result as a marker type reference.
		function getMarkerTypeReference(type, source, target) {
			var result = createTypeReference(
				type,
				map(
					type.typeParameters,
					function (t) {
						return t === source ? target : t;
					},
				),
			);
			result.objectFlags |= ObjectFlags.MarkerType;
			return result;
		}
		function getAliasVariances(symbol) {
			var links = getSymbolLinks(symbol);
			return getVariancesWorker(
				links.typeParameters,
				links,
				function (_links, param, marker) {
					var type = getTypeAliasInstantiation(
						symbol,
						instantiateTypes(
							links.typeParameters,
							makeUnaryTypeMapper(param, marker),
						),
					);
					type.aliasTypeArgumentsContainsMarker = true;
					return type;
				},
			);
		}
		// Return an array containing the variance of each type parameter. The variance is effectively
		// a digest of the type comparisons that occur for each type argument when instantiations of the
		// generic type are structurally compared. We infer the variance information by comparing
		// instantiations of the generic type for type arguments with known relations. The function
		// returns the emptyArray singleton when invoked recursively for the given generic type.
		function getVariancesWorker(typeParameters, cache, createMarkerType) {
			var _a, _b, _c;
			if (typeParameters === void 0) {
				typeParameters = emptyArray;
			}
			var variances = cache.variances;
			if (!variances) {
				tracing === null || tracing === void 0 ? void 0 : tracing.push(
					tracing.Phase.CheckTypes,
					"getVariancesWorker",
					{
						arity: typeParameters.length,
						id: (_c = (_a = cache.id) !== null && _a !== void 0 ? _a : (_b = cache.declaredType) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : -1,
					},
				);
				// The emptyArray singleton is used to signal a recursive invocation.
				cache.variances = emptyArray;
				variances = [];
				var _loop_15 = function (tp) {
					var unmeasurable = false;
					var unreliable = false;
					var oldHandler = outofbandVarianceMarkerHandler;
					outofbandVarianceMarkerHandler = function (onlyUnreliable) {
						return onlyUnreliable ? unreliable = true : unmeasurable = true;
					};
					// We first compare instantiations where the type parameter is replaced with
					// marker types that have a known subtype relationship. From this we can infer
					// invariance, covariance, contravariance or bivariance.
					var typeWithSuper = createMarkerType(cache, tp, markerSuperType);
					var typeWithSub = createMarkerType(cache, tp, markerSubType);
					var variance = (isTypeAssignableTo(typeWithSub, typeWithSuper) ? VarianceFlags.Covariant : 0) | (isTypeAssignableTo(
						typeWithSuper,
						typeWithSub,
					) ? VarianceFlags.Contravariant : 0);
					// If the instantiations appear to be related bivariantly it may be because the
					// type parameter is independent (i.e. it isn't witnessed anywhere in the generic
					// type). To determine this we compare instantiations where the type parameter is
					// replaced with marker types that are known to be unrelated.
					if (
						variance === VarianceFlags.Bivariant && isTypeAssignableTo(
							createMarkerType(cache, tp, markerOtherType),
							typeWithSuper,
						)
					) {
						variance = VarianceFlags.Independent;
					}
					outofbandVarianceMarkerHandler = oldHandler;
					if (unmeasurable || unreliable) {
						if (unmeasurable) {
							variance |= VarianceFlags.Unmeasurable;
						}
						if (unreliable) {
							variance |= VarianceFlags.Unreliable;
						}
					}
					variances.push(variance);
				};
				for (
					var _i = 0, typeParameters_1 = typeParameters;
					_i < typeParameters_1.length;
					_i++
				) {
					var tp = typeParameters_1[_i];
					_loop_15(tp);
				}
				cache.variances = variances;
				tracing === null || tracing === void 0 ? void 0 : tracing.pop();
			}
			return variances;
		}
		function getVariances(type) {
			// Arrays and tuples are known to be covariant, no need to spend time computing this.
			if (
				type === globalArrayType || type === globalReadonlyArrayType || type.objectFlags & ObjectFlags.Tuple
			) {
				return arrayVariances;
			}
			return getVariancesWorker(
				type.typeParameters,
				type,
				getMarkerTypeReference,
			);
		}
		// Return true if the given type reference has a 'void' type argument for a covariant type parameter.
		// See comment at call in recursiveTypeRelatedTo for when this case matters.
		function hasCovariantVoidArgument(typeArguments, variances) {
			for (var i = 0; i < variances.length; i++) {
				if (
					(variances[i] & VarianceFlags.VarianceMask) === VarianceFlags.Covariant && typeArguments[i].flags & TypeFlags.Void
				) {
					return true;
				}
			}
			return false;
		}
		function isUnconstrainedTypeParameter(type) {
			return type.flags & TypeFlags.TypeParameter && !getConstraintOfTypeParameter(
				type,
			);
		}
		function isNonDeferredTypeReference(type) {
			return !!(getObjectFlags(type) & ObjectFlags.Reference) && !type.node;
		}
		function isTypeReferenceWithGenericArguments(type) {
			return isNonDeferredTypeReference(type) && some(
				getTypeArguments(type),
				function (t) {
					return !!(t.flags & TypeFlags.TypeParameter) || isTypeReferenceWithGenericArguments(
						t,
					);
				},
			);
		}
		function getGenericTypeReferenceRelationKey(
			source,
			target,
			postFix,
			ignoreConstraints,
		) {
			var typeParameters = [];
			var constraintMarker = "";
			var sourceId = getTypeReferenceId(source, 0);
			var targetId = getTypeReferenceId(target, 0);
			return "".concat(constraintMarker).concat(sourceId, ",").concat(targetId).concat(
				postFix,
			);
			// getTypeReferenceId(A<T, number, U>) returns "111=0-12=1"
			// where A.id=111 and number.id=12
			function getTypeReferenceId(type, depth) {
				if (depth === void 0) {
					depth = 0;
				}
				var result = "" + type.target.id;
				for (var _i = 0, _a = getTypeArguments(type); _i < _a.length; _i++) {
					var t = _a[_i];
					if (t.flags & TypeFlags.TypeParameter) {
						if (ignoreConstraints || isUnconstrainedTypeParameter(t)) {
							var index = typeParameters.indexOf(t);
							if (index < 0) {
								index = typeParameters.length;
								typeParameters.push(t);
							}
							result += "=" + index;
							continue;
						}
						// We mark type references that reference constrained type parameters such that we know to obtain
						// and look for a "broadest equivalent key" in the cache.
						constraintMarker = "*";
					} else if (depth < 4 && isTypeReferenceWithGenericArguments(t)) {
						result += "<" + getTypeReferenceId(t, depth + 1) + ">";
						continue;
					}
					result += "-" + t.id;
				}
				return result;
			}
		}
		/**
         * To improve caching, the relation key for two generic types uses the target's id plus ids of the type parameters.
         * For other cases, the types ids are used.
         */
		function getRelationKey(
			source,
			target,
			intersectionState,
			relation,
			ignoreConstraints,
		) {
			if (relation === identityRelation && source.id > target.id) {
				var temp = source;
				source = target;
				target = temp;
			}
			var postFix = intersectionState ? ":" + intersectionState : "";
			return isTypeReferenceWithGenericArguments(source) && isTypeReferenceWithGenericArguments(
				target,
			) ? getGenericTypeReferenceRelationKey(
				source,
				target,
				postFix,
				ignoreConstraints,
			) : "".concat(source.id, ",").concat(target.id).concat(postFix);
		}
		// Invoke the callback for each underlying property symbol of the given symbol and return the first
		// value that isn't undefined.
		function forEachProperty(prop, callback) {
			if (getCheckFlags(prop) & CheckFlags.Synthetic) {
				for (var _i = 0, _a = prop.containingType.types; _i < _a.length; _i++) {
					var t = _a[_i];
					var p = getPropertyOfType(t, prop.escapedName);
					var result = p && forEachProperty(p, callback);
					if (result) {
						return result;
					}
				}
				return undefined;
			}
			return callback(prop);
		}
		// Return the declaring class type of a property or undefined if property not declared in class
		function getDeclaringClass(prop) {
			return prop.parent && prop.parent.flags & SymbolFlags.Class ? getDeclaredTypeOfSymbol(
				getParentOfSymbol(prop),
			) : undefined;
		}
		// Return the inherited type of the given property or undefined if property doesn't exist in a base class.
		function getTypeOfPropertyInBaseClass(property) {
			var classType = getDeclaringClass(property);
			var baseClassType = classType && getBaseTypes(classType)[0];
			return baseClassType && getTypeOfPropertyOfType(
				baseClassType,
				property.escapedName,
			);
		}
		// Return true if some underlying source property is declared in a class that derives
		// from the given base class.
		function isPropertyInClassDerivedFrom(prop, baseClass) {
			return forEachProperty(
				prop,
				function (sp) {
					var sourceClass = getDeclaringClass(sp);
					return sourceClass ? hasBaseType(sourceClass, baseClass) : false;
				},
			);
		}
		// Return true if source property is a valid override of protected parts of target property.
		function isValidOverrideOf(sourceProp, targetProp) {
			return !forEachProperty(
				targetProp,
				function (tp) {
					return getDeclarationModifierFlagsFromSymbol(tp) & ModifierFlags.Protected ? !isPropertyInClassDerivedFrom(
						sourceProp,
						getDeclaringClass(tp),
					) : false;
				},
			);
		}
		// Return true if the given class derives from each of the declaring classes of the protected
		// constituents of the given property.
		function isClassDerivedFromDeclaringClasses(checkClass, prop, writing) {
			return forEachProperty(
				prop,
				function (p) {
					return getDeclarationModifierFlagsFromSymbol(p, writing) & ModifierFlags.Protected ? !hasBaseType(
						checkClass,
						getDeclaringClass(p),
					) : false;
				},
			) ? undefined : checkClass;
		}
		// Return true if the given type is deeply nested. We consider this to be the case when structural type comparisons
		// for maxDepth or more occurrences or instantiations of the type have been recorded on the given stack. It is possible,
		// though highly unlikely, for this test to be true in a situation where a chain of instantiations is not infinitely
		// expanding. Effectively, we will generate a false positive when two types are structurally equal to at least maxDepth
		// levels, but unequal at some level beyond that.
		// In addition, this will also detect when an indexed access has been chained off of maxDepth more times (which is
		// essentially the dual of the structural comparison), and likewise mark the type as deeply nested, potentially adding
		// false positives for finite but deeply expanding indexed accesses (eg, for `Q[P1][P2][P3][P4][P5]`).
		// It also detects when a recursive type reference has expanded maxDepth or more times, e.g. if the true branch of
		// `type A<T> = null extends T ? [A<NonNullable<T>>] : [T]`
		// has expanded into `[A<NonNullable<NonNullable<NonNullable<NonNullable<NonNullable<T>>>>>>]`. In such cases we need
		// to terminate the expansion, and we do so here.
		function isDeeplyNestedType(type, stack, depth, maxDepth) {
			if (maxDepth === void 0) {
				maxDepth = 3;
			}
			if (depth >= maxDepth) {
				var identity = getRecursionIdentity(type);
				var count = 0;
				var lastTypeId = 0;
				for (var i = 0; i < depth; i++) {
					var t = stack[i];
					if (getRecursionIdentity(t) === identity) {
						// We only count occurrences with a higher type id than the previous occurrence, since higher
						// type ids are an indicator of newer instantiations caused by recursion.
						if (t.id >= lastTypeId) {
							count++;
							if (count >= maxDepth) {
								return true;
							}
						}
						lastTypeId = t.id;
					}
				}
			}
			return false;
		}
		// The recursion identity of a type is an object identity that is shared among multiple instantiations of the type.
		// We track recursion identities in order to identify deeply nested and possibly infinite type instantiations with
		// the same origin. For example, when type parameters are in scope in an object type such as { x: T }, all
		// instantiations of that type have the same recursion identity. The default recursion identity is the object
		// identity of the type, meaning that every type is unique. Generally, types with constituents that could circularly
		// reference the type have a recursion identity that differs from the object identity.
		function getRecursionIdentity(type) {
			// Object and array literals are known not to contain recursive references and don't need a recursion identity.
			if (type.flags & TypeFlags.Object && !isObjectOrArrayLiteralType(type)) {
				if (getObjectFlags(type) && ObjectFlags.Reference && type.node) {
					// Deferred type references are tracked through their associated AST node. This gives us finer
					// granularity than using their associated target because each manifest type reference has a
					// unique AST node.
					return type.node;
				}
				if (
					type.symbol && !(getObjectFlags(type) & ObjectFlags.Anonymous && type.symbol.flags & SymbolFlags.Class)
				) {
					// We track all object types that have an associated symbol (representing the origin of the type), but
					// exclude the static side of classes from this check since it shares its symbol with the instance side.
					return type.symbol;
				}
				if (isTupleType(type)) {
					// Tuple types are tracked through their target type
					return type.target;
				}
			}
			if (type.flags & TypeFlags.TypeParameter) {
				return type.symbol;
			}
			if (type.flags & TypeFlags.IndexedAccess) {
				// Identity is the leftmost object type in a chain of indexed accesses, eg, in A[P][Q] it is A
				do {
					type = type.objectType;
				} while (type.flags & TypeFlags.IndexedAccess);
				return type;
			}
			if (type.flags & TypeFlags.Conditional) {
				// The root object represents the origin of the conditional type
				return type.root;
			}
			return type;
		}
		function isPropertyIdenticalTo(sourceProp, targetProp) {
			return compareProperties(sourceProp, targetProp, compareTypesIdentical) !== Ternary.False;
		}
		function compareProperties(sourceProp, targetProp, compareTypes) {
			// Two members are considered identical when
			// - they are public properties with identical names, optionality, and types,
			// - they are private or protected properties originating in the same declaration and having identical types
			if (sourceProp === targetProp) {
				return Ternary.True;
			}
			var sourcePropAccessibility = getDeclarationModifierFlagsFromSymbol(
				sourceProp,
			) & ModifierFlags.NonPublicAccessibilityModifier;
			var targetPropAccessibility = getDeclarationModifierFlagsFromSymbol(
				targetProp,
			) & ModifierFlags.NonPublicAccessibilityModifier;
			if (sourcePropAccessibility !== targetPropAccessibility) {
				return Ternary.False;
			}
			if (sourcePropAccessibility) {
				if (getTargetSymbol(sourceProp) !== getTargetSymbol(targetProp)) {
					return Ternary.False;
				}
			} else {
				if (
					(sourceProp.flags & SymbolFlags.Optional) !== (targetProp.flags & SymbolFlags.Optional)
				) {
					return Ternary.False;
				}
			}
			if (isReadonlySymbol(sourceProp) !== isReadonlySymbol(targetProp)) {
				return Ternary.False;
			}
			return compareTypes(
				getTypeOfSymbol(sourceProp),
				getTypeOfSymbol(targetProp),
			);
		}
		function isMatchingSignature(source, target, partialMatch) {
			var sourceParameterCount = getParameterCount(source);
			var targetParameterCount = getParameterCount(target);
			var sourceMinArgumentCount = getMinArgumentCount(source);
			var targetMinArgumentCount = getMinArgumentCount(target);
			var sourceHasRestParameter = hasEffectiveRestParameter(source);
			var targetHasRestParameter = hasEffectiveRestParameter(target);
			// A source signature matches a target signature if the two signatures have the same number of required,
			// optional, and rest parameters.
			if (
				sourceParameterCount === targetParameterCount && sourceMinArgumentCount === targetMinArgumentCount && sourceHasRestParameter === targetHasRestParameter
			) {
				return true;
			}
			// A source signature partially matches a target signature if the target signature has no fewer required
			// parameters
			if (partialMatch && sourceMinArgumentCount <= targetMinArgumentCount) {
				return true;
			}
			return false;
		}
		/**
         * See signatureRelatedTo, compareSignaturesIdentical
         */
		function compareSignaturesIdentical(
			source,
			target,
			partialMatch,
			ignoreThisTypes,
			ignoreReturnTypes,
			compareTypes,
		) {
			// TODO (drosen): De-duplicate code between related functions.
			if (source === target) {
				return Ternary.True;
			}
			if (!(isMatchingSignature(source, target, partialMatch))) {
				return Ternary.False;
			}
			// Check that the two signatures have the same number of type parameters.
			if (length(source.typeParameters) !== length(target.typeParameters)) {
				return Ternary.False;
			}
			// Check that type parameter constraints and defaults match. If they do, instantiate the source
			// signature with the type parameters of the target signature and continue the comparison.
			if (target.typeParameters) {
				var mapper = createTypeMapper(
					source.typeParameters,
					target.typeParameters,
				);
				for (var i = 0; i < target.typeParameters.length; i++) {
					var s = source.typeParameters[i];
					var t = target.typeParameters[i];
					if (
						!(s === t || compareTypes(
							instantiateType(getConstraintFromTypeParameter(s), mapper) || unknownType,
							getConstraintFromTypeParameter(t) || unknownType,
						) && compareTypes(
							instantiateType(getDefaultFromTypeParameter(s), mapper) || unknownType,
							getDefaultFromTypeParameter(t) || unknownType,
						))
					) {
						return Ternary.False;
					}
				}
				source = instantiateSignature(
					source,
					mapper, /*eraseTypeParameters*/
					true,
				);
			}
			var result = Ternary.True;
			if (!ignoreThisTypes) {
				var sourceThisType = getThisTypeOfSignature(source);
				if (sourceThisType) {
					var targetThisType = getThisTypeOfSignature(target);
					if (targetThisType) {
						var related = compareTypes(sourceThisType, targetThisType);
						if (!related) {
							return Ternary.False;
						}
						result &= related;
					}
				}
			}
			var targetLen = getParameterCount(target);
			for (var i = 0; i < targetLen; i++) {
				var s = getTypeAtPosition(source, i);
				var t = getTypeAtPosition(target, i);
				var related = compareTypes(t, s);
				if (!related) {
					return Ternary.False;
				}
				result &= related;
			}
			if (!ignoreReturnTypes) {
				var sourceTypePredicate = getTypePredicateOfSignature(source);
				var targetTypePredicate = getTypePredicateOfSignature(target);
				result &= sourceTypePredicate || targetTypePredicate ? compareTypePredicatesIdentical(
					sourceTypePredicate,
					targetTypePredicate,
					compareTypes,
				) : compareTypes(
					getReturnTypeOfSignature(source),
					getReturnTypeOfSignature(target),
				);
			}
			return result;
		}
		function compareTypePredicatesIdentical(source, target, compareTypes) {
			return !(source && target && typePredicateKindsMatch(source, target)) ? Ternary.False : source.type === target.type ? Ternary.True : source.type && target.type ? compareTypes(
				source.type,
				target.type,
			) : Ternary.False;
		}
		function literalTypesWithSameBaseType(types) {
			var commonBaseType;
			for (var _i = 0, types_13 = types; _i < types_13.length; _i++) {
				var t = types_13[_i];
				var baseType = getBaseTypeOfLiteralType(t);
				if (!commonBaseType) {
					commonBaseType = baseType;
				}
				if (baseType === t || baseType !== commonBaseType) {
					return false;
				}
			}
			return true;
		}
		// When the candidate types are all literal types with the same base type, return a union
		// of those literal types. Otherwise, return the leftmost type for which no type to the
		// right is a supertype.
		function getSupertypeOrUnion(types) {
			if (types.length === 1) {
				return types[0];
			}
			return literalTypesWithSameBaseType(types) ? getUnionType(types) : reduceLeft(
				types,
				function (s, t) {
					return isTypeSubtypeOf(s, t) ? t : s;
				},
			);
		}
		function getCommonSupertype(types) {
			if (!strictNullChecks) {
				return getSupertypeOrUnion(types);
			}
			var primaryTypes = filter(
				types,
				function (t) {
					return !(t.flags & TypeFlags.Nullable);
				},
			);
			return primaryTypes.length ? getNullableType(
				getSupertypeOrUnion(primaryTypes),
				getFalsyFlagsOfTypes(types) & TypeFlags.Nullable,
			) : getUnionType(types, UnionReduction.Subtype);
		}
		// Return the leftmost type for which no type to the right is a subtype.
		function getCommonSubtype(types) {
			return reduceLeft(
				types,
				function (s, t) {
					return isTypeSubtypeOf(t, s) ? t : s;
				},
			);
		}
		function isArrayType(type) {
			return !!(getObjectFlags(type) & ObjectFlags.Reference) && (type.target === globalArrayType || type.target === globalReadonlyArrayType);
		}
		function isReadonlyArrayType(type) {
			return !!(getObjectFlags(type) & ObjectFlags.Reference) && type.target === globalReadonlyArrayType;
		}
		function isMutableArrayOrTuple(type) {
			return isArrayType(type) && !isReadonlyArrayType(type) || isTupleType(
				type,
			) && !type.target.readonly;
		}
		function getElementTypeOfArrayType(type) {
			return isArrayType(type) ? getTypeArguments(type)[0] : undefined;
		}
		function isArrayLikeType(type) {
			// A type is array-like if it is a reference to the global Array or global ReadonlyArray type,
			// or if it is not the undefined or null type and if it is assignable to ReadonlyArray<any>
			return isArrayType(type) || !(type.flags & TypeFlags.Nullable) && isTypeAssignableTo(
				type,
				anyReadonlyArrayType,
			);
		}
		function getSingleBaseForNonAugmentingSubtype(type) {
			if (
				!(getObjectFlags(type) & ObjectFlags.Reference) || !(getObjectFlags(
					type.target,
				) & ObjectFlags.ClassOrInterface)
			) {
				return undefined;
			}
			if (getObjectFlags(type) & ObjectFlags.IdenticalBaseTypeCalculated) {
				return getObjectFlags(type) & ObjectFlags.IdenticalBaseTypeExists ? type.cachedEquivalentBaseType : undefined;
			}
			type.objectFlags |= ObjectFlags.IdenticalBaseTypeCalculated;
			var target = type.target;
			if (getObjectFlags(target) & ObjectFlags.Class) {
				var baseTypeNode = getBaseTypeNodeOfClass(target);
				// A base type expression may circularly reference the class itself (e.g. as an argument to function call), so we only
				// check for base types specified as simple qualified names.
				if (
					baseTypeNode && baseTypeNode.expression.kind !== SyntaxKind.Identifier && baseTypeNode.expression.kind !== SyntaxKind.PropertyAccessExpression
				) {
					return undefined;
				}
			}
			var bases = getBaseTypes(target);
			if (bases.length !== 1) {
				return undefined;
			}
			if (getMembersOfSymbol(type.symbol).size) {
				return undefined; // If the interface has any members, they may subtype members in the base, so we should do a full structural comparison
			}
			var instantiatedBase = !length(target.typeParameters) ? bases[0] : instantiateType(
				bases[0],
				createTypeMapper(
					target.typeParameters,
					getTypeArguments(type).slice(0, target.typeParameters.length),
				),
			);
			if (length(getTypeArguments(type)) > length(target.typeParameters)) {
				instantiatedBase = getTypeWithThisArgument(
					instantiatedBase,
					last(getTypeArguments(type)),
				);
			}
			type.objectFlags |= ObjectFlags.IdenticalBaseTypeExists;
			return type.cachedEquivalentBaseType = instantiatedBase;
		}
		function isEmptyLiteralType(type) {
			return strictNullChecks ? type === implicitNeverType : type === undefinedWideningType;
		}
		function isEmptyArrayLiteralType(type) {
			var elementType = getElementTypeOfArrayType(type);
			return !!elementType && isEmptyLiteralType(elementType);
		}
		function isTupleLikeType(type) {
			return isTupleType(type) || !!getPropertyOfType(type, "0");
		}
		function isArrayOrTupleLikeType(type) {
			return isArrayLikeType(type) || isTupleLikeType(type);
		}
		function getTupleElementType(type, index) {
			var propType = getTypeOfPropertyOfType(type, "" + index);
			if (propType) {
				return propType;
			}
			if (everyType(type, isTupleType)) {
				return mapType(
					type,
					function (t) {
						return getRestTypeOfTupleType(t) || undefinedType;
					},
				);
			}
			return undefined;
		}
		function isNeitherUnitTypeNorNever(type) {
			return !(type.flags & (TypeFlags.Unit | TypeFlags.Never));
		}
		function isUnitType(type) {
			return !!(type.flags & TypeFlags.Unit);
		}
		function isUnitLikeType(type) {
			return type.flags & TypeFlags.Intersection ? some(type.types, isUnitType) : !!(type.flags & TypeFlags.Unit);
		}
		function extractUnitType(type) {
			return type.flags & TypeFlags.Intersection ? find(type.types, isUnitType) || type : type;
		}
		function isLiteralType(type) {
			return type.flags & TypeFlags.Boolean ? true : type.flags & TypeFlags.Union ? type.flags & TypeFlags.EnumLiteral ? true : every(
				type.types,
				isUnitType,
			) : isUnitType(type);
		}
		function getBaseTypeOfLiteralType(type) {
			return type.flags & TypeFlags.EnumLiteral ? getBaseTypeOfEnumLiteralType(
				type,
			) : type.flags & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ? stringType : type.flags & TypeFlags.NumberLiteral ? numberType : type.flags & TypeFlags.BigIntLiteral ? bigintType : type.flags & TypeFlags.BooleanLiteral ? booleanType : type.flags & TypeFlags.Union ? mapType(
				type,
				getBaseTypeOfLiteralType,
			) : type;
		}
		function getWidenedLiteralType(type) {
			return type.flags & TypeFlags.EnumLiteral && isFreshLiteralType(type) ? getBaseTypeOfEnumLiteralType(
				type,
			) : type.flags & TypeFlags.StringLiteral && isFreshLiteralType(type) ? stringType : type.flags & TypeFlags.NumberLiteral && isFreshLiteralType(
				type,
			) ? numberType : type.flags & TypeFlags.BigIntLiteral && isFreshLiteralType(
				type,
			) ? bigintType : type.flags & TypeFlags.BooleanLiteral && isFreshLiteralType(
				type,
			) ? booleanType : type.flags & TypeFlags.Union ? mapType(
				type,
				getWidenedLiteralType,
			) : type;
		}
		function getWidenedUniqueESSymbolType(type) {
			return type.flags & TypeFlags.UniqueESSymbol ? esSymbolType : type.flags & TypeFlags.Union ? mapType(
				type,
				getWidenedUniqueESSymbolType,
			) : type;
		}
		function getWidenedLiteralLikeTypeForContextualType(type, contextualType) {
			if (!isLiteralOfContextualType(type, contextualType)) {
				type = getWidenedUniqueESSymbolType(getWidenedLiteralType(type));
			}
			return type;
		}
		function getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded(
			type,
			contextualSignatureReturnType,
			isAsync,
		) {
			if (type && isUnitType(type)) {
				var contextualType = !contextualSignatureReturnType ? undefined : isAsync ? getPromisedTypeOfPromise(
					contextualSignatureReturnType,
				) : contextualSignatureReturnType;
				type = getWidenedLiteralLikeTypeForContextualType(type, contextualType);
			}
			return type;
		}
		function getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(
			type,
			contextualSignatureReturnType,
			kind,
			isAsyncGenerator,
		) {
			if (type && isUnitType(type)) {
				var contextualType = !contextualSignatureReturnType ? undefined : getIterationTypeOfGeneratorFunctionReturnType(
					kind,
					contextualSignatureReturnType,
					isAsyncGenerator,
				);
				type = getWidenedLiteralLikeTypeForContextualType(type, contextualType);
			}
			return type;
		}
		/**
         * Check if a Type was written as a tuple type literal.
         * Prefer using isTupleLikeType() unless the use of `elementTypes`/`getTypeArguments` is required.
         */
		function isTupleType(type) {
			return !!(getObjectFlags(type) & ObjectFlags.Reference && type.target.objectFlags & ObjectFlags.Tuple);
		}
		function isGenericTupleType(type) {
			return isTupleType(type) && !!(type.target.combinedFlags & ElementFlags.Variadic);
		}
		function isSingleElementGenericTupleType(type) {
			return isGenericTupleType(type) && type.target.elementFlags.length === 1;
		}
		function getRestTypeOfTupleType(type) {
			return getElementTypeOfSliceOfTupleType(type, type.target.fixedLength);
		}
		function getRestArrayTypeOfTupleType(type) {
			var restType = getRestTypeOfTupleType(type);
			return restType && createArrayType(restType);
		}
		function getElementTypeOfSliceOfTupleType(
			type,
			index,
			endSkipCount,
			writing,
		) {
			if (endSkipCount === void 0) {
				endSkipCount = 0;
			}
			if (writing === void 0) {
				writing = false;
			}
			var length = getTypeReferenceArity(type) - endSkipCount;
			if (index < length) {
				var typeArguments = getTypeArguments(type);
				var elementTypes = [];
				for (var i = index; i < length; i++) {
					var t = typeArguments[i];
					elementTypes.push(
						type.target.elementFlags[i] & ElementFlags.Variadic ? getIndexedAccessType(
							t,
							numberType,
						) : t,
					);
				}
				return writing ? getIntersectionType(elementTypes) : getUnionType(
					elementTypes,
				);
			}
			return undefined;
		}
		function isTupleTypeStructureMatching(t1, t2) {
			return getTypeReferenceArity(t1) === getTypeReferenceArity(t2) && every(
				t1.target.elementFlags,
				function (f, i) {
					return (f & ElementFlags.Variable) === (t2.target.elementFlags[i] & ElementFlags.Variable);
				},
			);
		}
		function isZeroBigInt(_a) {
			var value = _a.value;
			return value.base10Value === "0";
		}
		function getFalsyFlagsOfTypes(types) {
			var result = 0;
			for (var _i = 0, types_14 = types; _i < types_14.length; _i++) {
				var t = types_14[_i];
				result |= getFalsyFlags(t);
			}
			return result;
		}
		// Returns the String, Number, Boolean, StringLiteral, NumberLiteral, BooleanLiteral, Void, Undefined, or Null
		// flags for the string, number, boolean, "", 0, false, void, undefined, or null types respectively. Returns
		// no flags for all other types (including non-falsy literal types).
		function getFalsyFlags(type) {
			return type.flags & TypeFlags.Union ? getFalsyFlagsOfTypes(type.types) : type.flags & TypeFlags.StringLiteral ? type.value === "" ? TypeFlags.StringLiteral : 0 : type.flags & TypeFlags.NumberLiteral ? type.value === 0 ? TypeFlags.NumberLiteral : 0 : type.flags & TypeFlags.BigIntLiteral ? isZeroBigInt(
				type,
			) ? TypeFlags.BigIntLiteral : 0 : type.flags & TypeFlags.BooleanLiteral ? (type === falseType || type === regularFalseType) ? TypeFlags.BooleanLiteral : 0 : type.flags & TypeFlags.PossiblyFalsy;
		}
		function removeDefinitelyFalsyTypes(type) {
			return getFalsyFlags(type) & TypeFlags.DefinitelyFalsy ? filterType(
				type,
				function (t) {
					return !(getFalsyFlags(t) & TypeFlags.DefinitelyFalsy);
				},
			) : type;
		}
		function extractDefinitelyFalsyTypes(type) {
			return mapType(type, getDefinitelyFalsyPartOfType);
		}
		function getDefinitelyFalsyPartOfType(type) {
			return type.flags & TypeFlags.String ? emptyStringType : type.flags & TypeFlags.Number ? zeroType : type.flags & TypeFlags.BigInt ? zeroBigIntType : type === regularFalseType || type === falseType || type.flags & (TypeFlags.Void | TypeFlags.Undefined | TypeFlags.Null | TypeFlags.AnyOrUnknown) || type.flags & TypeFlags.StringLiteral && type.value === "" || type.flags & TypeFlags.NumberLiteral && type.value === 0 || type.flags & TypeFlags.BigIntLiteral && isZeroBigInt(
				type,
			) ? type : neverType;
		}
		/**
         * Add undefined or null or both to a type if they are missing.
         * @param type - type to add undefined and/or null to if not present
         * @param flags - Either TypeFlags.Undefined or TypeFlags.Null, or both
         */
		function getNullableType(type, flags) {
			var missing = (flags & ~type.flags) & (TypeFlags.Undefined | TypeFlags.Null);
			return missing === 0 ? type : missing === TypeFlags.Undefined ? getUnionType(
				[type, undefinedType],
			) : missing === TypeFlags.Null ? getUnionType([type, nullType]) : getUnionType(
				[type, undefinedType, nullType],
			);
		}
		function getOptionalType(type, isProperty) {
			if (isProperty === void 0) {
				isProperty = false;
			}
			Debug.assert(strictNullChecks);
			return type.flags & TypeFlags.Undefined ? type : getUnionType(
				[type, isProperty ? missingType : undefinedType],
			);
		}
		function getGlobalNonNullableTypeInstantiation(type) {
			// First reduce away any constituents that are assignable to 'undefined' or 'null'. This not only eliminates
			// 'undefined' and 'null', but also higher-order types such as a type parameter 'U extends undefined | null'
			// that isn't eliminated by a NonNullable<T> instantiation.
			var reducedType = getTypeWithFacts(type, 2097152 /* NEUndefinedOrNull */ );
			if (!deferredGlobalNonNullableTypeAlias) {
				deferredGlobalNonNullableTypeAlias = getGlobalSymbol(
					"NonNullable",
					SymbolFlags.TypeAlias, /*diagnostic*/
					undefined,
				) || unknownSymbol;
			}
			// If the NonNullable<T> type is available, return an instantiation. Otherwise just return the reduced type.
			return deferredGlobalNonNullableTypeAlias !== unknownSymbol ? getTypeAliasInstantiation(
				deferredGlobalNonNullableTypeAlias,
				[reducedType],
			) : reducedType;
		}
		function getNonNullableType(type) {
			return strictNullChecks ? getGlobalNonNullableTypeInstantiation(type) : type;
		}
		function addOptionalTypeMarker(type) {
			return strictNullChecks ? getUnionType([type, optionalType]) : type;
		}
		function removeOptionalTypeMarker(type) {
			return strictNullChecks ? removeType(type, optionalType) : type;
		}
		function propagateOptionalTypeMarker(type, node, wasOptional) {
			return wasOptional ? isOutermostOptionalChain(node) ? getOptionalType(
				type,
			) : addOptionalTypeMarker(type) : type;
		}
		function getOptionalExpressionType(exprType, expression) {
			return isExpressionOfOptionalChainRoot(expression) ? getNonNullableType(
				exprType,
			) : isOptionalChain(expression) ? removeOptionalTypeMarker(exprType) : exprType;
		}
		function removeMissingType(type, isOptional) {
			return exactOptionalPropertyTypes && isOptional ? removeType(
				type,
				missingType,
			) : type;
		}
		function containsMissingType(type) {
			return exactOptionalPropertyTypes && (type === missingType || type.flags & TypeFlags.Union && containsType(
				type.types,
				missingType,
			));
		}
		function removeMissingOrUndefinedType(type) {
			return exactOptionalPropertyTypes ? removeType(type, missingType) : getTypeWithFacts(
				type,
				524288, /* NEUndefined */
			);
		}
		/**
         * Is source potentially coercible to target type under `==`.
         * Assumes that `source` is a constituent of a union, hence
         * the boolean literal flag on the LHS, but not on the RHS.
         *
         * This does not fully replicate the semantics of `==`. The
         * intention is to catch cases that are clearly not right.
         *
         * Comparing (string | number) to number should not remove the
         * string element.
         *
         * Comparing (string | number) to 1 will remove the string
         * element, though this is not sound. This is a pragmatic
         * choice.
         *
         * @see narrowTypeByEquality
         *
         * @param source
         * @param target
         */
		function isCoercibleUnderDoubleEquals(source, target) {
			return ((source.flags & (TypeFlags.Number | TypeFlags.String | TypeFlags.BooleanLiteral)) !== 0) && ((target.flags & (TypeFlags.Number | TypeFlags.String | TypeFlags.Boolean)) !== 0);
		}
		/**
         * Return true if type was inferred from an object literal, written as an object type literal, or is the shape of a module
         * with no call or construct signatures.
         */
		function isObjectTypeWithInferableIndex(type) {
			return type.flags & TypeFlags.Intersection ? every(
				type.types,
				isObjectTypeWithInferableIndex,
			) : !!(type.symbol && (type.symbol.flags & (SymbolFlags.ObjectLiteral | SymbolFlags.TypeLiteral | SymbolFlags.Enum | SymbolFlags.ValueModule)) !== 0 && !(type.symbol.flags & SymbolFlags.Class) && !typeHasCallOrConstructSignatures(
				type,
			)) || !!(getObjectFlags(type) & ObjectFlags.ReverseMapped && isObjectTypeWithInferableIndex(
				type.source,
			));
		}
		function createSymbolWithType(source, type) {
			var symbol = createSymbol(
				source.flags,
				source.escapedName,
				getCheckFlags(source) & CheckFlags.Readonly,
			);
			symbol.declarations = source.declarations;
			symbol.parent = source.parent;
			symbol.type = type;
			symbol.target = source;
			if (source.valueDeclaration) {
				symbol.valueDeclaration = source.valueDeclaration;
			}
			var nameType = getSymbolLinks(source).nameType;
			if (nameType) {
				symbol.nameType = nameType;
			}
			return symbol;
		}
		function transformTypeOfMembers(type, f) {
			var members = createSymbolTable();
			for (
				var _i = 0, _a = getPropertiesOfObjectType(type);
				_i < _a.length;
				_i++
			) {
				var property = _a[_i];
				var original = getTypeOfSymbol(property);
				var updated = f(original);
				members.set(
					property.escapedName,
					updated === original ? property : createSymbolWithType(
						property,
						updated,
					),
				);
			}
			return members;
		}
		/**
         * If the the provided object literal is subject to the excess properties check,
         * create a new that is exempt. Recursively mark object literal members as exempt.
         * Leave signatures alone since they are not subject to the check.
         */
		function getRegularTypeOfObjectLiteral(type) {
			if (
				!(isObjectLiteralType(type) && getObjectFlags(type) & ObjectFlags.FreshLiteral)
			) {
				return type;
			}
			var regularType = type.regularType;
			if (regularType) {
				return regularType;
			}
			var resolved = type;
			var members = transformTypeOfMembers(type, getRegularTypeOfObjectLiteral);
			var regularNew = createAnonymousType(
				resolved.symbol,
				members,
				resolved.callSignatures,
				resolved.constructSignatures,
				resolved.indexInfos,
			);
			regularNew.flags = resolved.flags;
			regularNew.objectFlags |= resolved.objectFlags & ~ObjectFlags.FreshLiteral;
			type.regularType = regularNew;
			return regularNew;
		}
		function createWideningContext(parent, propertyName, siblings) {
			return {
				parent: parent,
				propertyName: propertyName,
				siblings: siblings,
				resolvedProperties: undefined,
			};
		}
		function getSiblingsOfContext(context) {
			if (!context.siblings) {
				var siblings_1 = [];
				for (
					var _i = 0, _a = getSiblingsOfContext(context.parent);
					_i < _a.length;
					_i++
				) {
					var type = _a[_i];
					if (isObjectLiteralType(type)) {
						var prop = getPropertyOfObjectType(type, context.propertyName);
						if (prop) {
							forEachType(
								getTypeOfSymbol(prop),
								function (t) {
									siblings_1.push(t);
								},
							);
						}
					}
				}
				context.siblings = siblings_1;
			}
			return context.siblings;
		}
		function getPropertiesOfContext(context) {
			if (!context.resolvedProperties) {
				var names = new Map();
				for (
					var _i = 0, _a = getSiblingsOfContext(context);
					_i < _a.length;
					_i++
				) {
					var t = _a[_i];
					if (
						isObjectLiteralType(t) && !(getObjectFlags(t) & ObjectFlags.ContainsSpread)
					) {
						for (var _b = 0, _c = getPropertiesOfType(t); _b < _c.length; _b++) {
							var prop = _c[_b];
							names.set(prop.escapedName, prop);
						}
					}
				}
				context.resolvedProperties = arrayFrom(names.values());
			}
			return context.resolvedProperties;
		}
		function getWidenedProperty(prop, context) {
			if (!(prop.flags & SymbolFlags.Property)) {
				// Since get accessors already widen their return value there is no need to
				// widen accessor based properties here.
				return prop;
			}
			var original = getTypeOfSymbol(prop);
			var propContext = context && createWideningContext(
				context,
				prop.escapedName, /*siblings*/
				undefined,
			);
			var widened = getWidenedTypeWithContext(original, propContext);
			return widened === original ? prop : createSymbolWithType(prop, widened);
		}
		function getUndefinedProperty(prop) {
			var cached = undefinedProperties.get(prop.escapedName);
			if (cached) {
				return cached;
			}
			var result = createSymbolWithType(prop, missingType);
			result.flags |= SymbolFlags.Optional;
			undefinedProperties.set(prop.escapedName, result);
			return result;
		}
		function getWidenedTypeOfObjectLiteral(type, context) {
			var members = createSymbolTable();
			for (
				var _i = 0, _a = getPropertiesOfObjectType(type);
				_i < _a.length;
				_i++
			) {
				var prop = _a[_i];
				members.set(prop.escapedName, getWidenedProperty(prop, context));
			}
			if (context) {
				for (
					var _b = 0, _c = getPropertiesOfContext(context);
					_b < _c.length;
					_b++
				) {
					var prop = _c[_b];
					if (!members.has(prop.escapedName)) {
						members.set(prop.escapedName, getUndefinedProperty(prop));
					}
				}
			}
			var result = createAnonymousType(
				type.symbol,
				members,
				emptyArray,
				emptyArray,
				sameMap(
					getIndexInfosOfType(type),
					function (info) {
						return createIndexInfo(
							info.keyType,
							getWidenedType(info.type),
							info.isReadonly,
						);
					},
				),
			);
			result.objectFlags |= (getObjectFlags(type) & (ObjectFlags.JSLiteral | ObjectFlags.NonInferrableType)); // Retain js literal flag through widening
			return result;
		}
		function getWidenedType(type) {
			return getWidenedTypeWithContext(type, /*context*/ undefined);
		}
		function getWidenedTypeWithContext(type, context) {
			if (getObjectFlags(type) & ObjectFlags.RequiresWidening) {
				if (context === undefined && type.widened) {
					return type.widened;
				}
				var result = void 0;
				if (type.flags & (TypeFlags.Any | TypeFlags.Nullable)) {
					result = anyType;
				} else if (isObjectLiteralType(type)) {
					result = getWidenedTypeOfObjectLiteral(type, context);
				} else if (type.flags & TypeFlags.Union) {
					var unionContext_1 = context || createWideningContext(
						undefined, /*parent*/ /*propertyName*/
						undefined,
						type.types,
					);
					var widenedTypes = sameMap(
						type.types,
						function (t) {
							return t.flags & TypeFlags.Nullable ? t : getWidenedTypeWithContext(
								t,
								unionContext_1,
							);
						},
					);
					// Widening an empty object literal transitions from a highly restrictive type to
					// a highly inclusive one. For that reason we perform subtype reduction here if the
					// union includes empty object types (e.g. reducing {} | string to just {}).
					result = getUnionType(
						widenedTypes,
						some(widenedTypes, isEmptyObjectType) ? UnionReduction.Subtype : UnionReduction.Literal,
					);
				} else if (type.flags & TypeFlags.Intersection) {
					result = getIntersectionType(sameMap(type.types, getWidenedType));
				} else if (isArrayType(type) || isTupleType(type)) {
					result = createTypeReference(
						type.target,
						sameMap(getTypeArguments(type), getWidenedType),
					);
				}
				if (result && context === undefined) {
					type.widened = result;
				}
				return result || type;
			}
			return type;
		}
		/**
         * Reports implicit any errors that occur as a result of widening 'null' and 'undefined'
         * to 'any'. A call to reportWideningErrorsInType is normally accompanied by a call to
         * getWidenedType. But in some cases getWidenedType is called without reporting errors
         * (type argument inference is an example).
         *
         * The return value indicates whether an error was in fact reported. The particular circumstances
         * are on a best effort basis. Currently, if the null or undefined that causes widening is inside
         * an object literal property (arbitrarily deeply), this function reports an error. If no error is
         * reported, reportImplicitAnyError is a suitable fallback to report a general error.
         */
		function reportWideningErrorsInType(type) {
			var errorReported = false;
			if (getObjectFlags(type) & ObjectFlags.ContainsWideningType) {
				if (type.flags & TypeFlags.Union) {
					if (some(type.types, isEmptyObjectType)) {
						errorReported = true;
					} else {
						for (var _i = 0, _a = type.types; _i < _a.length; _i++) {
							var t = _a[_i];
							if (reportWideningErrorsInType(t)) {
								errorReported = true;
							}
						}
					}
				}
				if (isArrayType(type) || isTupleType(type)) {
					for (var _b = 0, _c = getTypeArguments(type); _b < _c.length; _b++) {
						var t = _c[_b];
						if (reportWideningErrorsInType(t)) {
							errorReported = true;
						}
					}
				}
				if (isObjectLiteralType(type)) {
					for (
						var _d = 0, _e = getPropertiesOfObjectType(type);
						_d < _e.length;
						_d++
					) {
						var p = _e[_d];
						var t = getTypeOfSymbol(p);
						if (getObjectFlags(t) & ObjectFlags.ContainsWideningType) {
							if (!reportWideningErrorsInType(t)) {
								error(
									p.valueDeclaration,
									Diagnostics.Object_literal_s_property_0_implicitly_has_an_1_type,
									symbolToString(p),
									typeToString(getWidenedType(t)),
								);
							}
							errorReported = true;
						}
					}
				}
			}
			return errorReported;
		}
		function reportImplicitAny(declaration, type, wideningKind) {
			var typeAsString = typeToString(getWidenedType(type));
			if (
				isInJSFile(declaration) && !isCheckJsEnabledForFile(
					getSourceFileOfNode(declaration),
					compilerOptions,
				)
			) {
				// Only report implicit any errors/suggestions in TS and ts-check JS files
				return;
			}
			var diagnostic;
			switch (declaration.kind) {
				case SyntaxKind.BinaryExpression:
				case SyntaxKind.PropertyDeclaration:
				case SyntaxKind.PropertySignature:
					diagnostic = noImplicitAny ? Diagnostics.Member_0_implicitly_has_an_1_type : Diagnostics.Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;
					break;
				case SyntaxKind.Parameter:
					var param = declaration;
					if (
						isIdentifier(param.name) && (isCallSignatureDeclaration(
							param.parent,
						) || isMethodSignature(param.parent) || isFunctionTypeNode(
							param.parent,
						)) && param.parent.parameters.indexOf(param) > -1 && (resolveName(
							param,
							param.name.escapedText,
							SymbolFlags.Type,
							undefined,
							param.name.escapedText, /*isUse*/
							true,
						) || param.name.originalKeywordKind && isTypeNodeKind(
							param.name.originalKeywordKind,
						))
					) {
						var newName = "arg" + param.parent.parameters.indexOf(param);
						var typeName = declarationNameToString(param.name) + (param.dotDotDotToken ? "[]" : "");
						errorOrSuggestion(
							noImplicitAny,
							declaration,
							Diagnostics.Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1,
							newName,
							typeName,
						);
						return;
					}
					diagnostic = declaration.dotDotDotToken ? noImplicitAny ? Diagnostics.Rest_parameter_0_implicitly_has_an_any_type : Diagnostics.Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage : noImplicitAny ? Diagnostics.Parameter_0_implicitly_has_an_1_type : Diagnostics.Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;
					break;
				case SyntaxKind.BindingElement:
					diagnostic = Diagnostics.Binding_element_0_implicitly_has_an_1_type;
					if (!noImplicitAny) {
						// Don't issue a suggestion for binding elements since the codefix doesn't yet support them.
						return;
					}
					break;
				case SyntaxKind.JSDocFunctionType:
					error(
						declaration,
						Diagnostics.Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type,
						typeAsString,
					);
					return;
				case SyntaxKind.FunctionDeclaration:
				case SyntaxKind.MethodDeclaration:
				case SyntaxKind.MethodSignature:
				case SyntaxKind.GetAccessor:
				case SyntaxKind.SetAccessor:
				case SyntaxKind.FunctionExpression:
				case SyntaxKind.ArrowFunction:
					if (noImplicitAny && !declaration.name) {
						if (wideningKind === 3 /* GeneratorYield */ ) {
							error(
								declaration,
								Diagnostics.Generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_type_annotation,
								typeAsString,
							);
						} else {
							error(
								declaration,
								Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type,
								typeAsString,
							);
						}
						return;
					}
					diagnostic = !noImplicitAny ? Diagnostics._0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage : wideningKind === 3 ? Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type : Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type; /* GeneratorYield */
					break;
				case SyntaxKind.MappedType:
					if (noImplicitAny) {
						error(
							declaration,
							Diagnostics.Mapped_object_type_implicitly_has_an_any_template_type,
						);
					}
					return;
				default:
					diagnostic = noImplicitAny ? Diagnostics.Variable_0_implicitly_has_an_1_type : Diagnostics.Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;
			}
			errorOrSuggestion(
				noImplicitAny,
				declaration,
				diagnostic,
				declarationNameToString(getNameOfDeclaration(declaration)),
				typeAsString,
			);
		}
		function reportErrorsFromWidening(declaration, type, wideningKind) {
			if (
				produceDiagnostics && noImplicitAny && getObjectFlags(type) & ObjectFlags.ContainsWideningType && (!wideningKind || !getContextualSignatureForFunctionLikeDeclaration(
					declaration,
				))
			) {
				// Report implicit any error within type if possible, otherwise report error on declaration
				if (!reportWideningErrorsInType(type)) {
					reportImplicitAny(declaration, type, wideningKind);
				}
			}
		}
		function applyToParameterTypes(source, target, callback) {
			var sourceCount = getParameterCount(source);
			var targetCount = getParameterCount(target);
			var sourceRestType = getEffectiveRestType(source);
			var targetRestType = getEffectiveRestType(target);
			var targetNonRestCount = targetRestType ? targetCount - 1 : targetCount;
			var paramCount = sourceRestType ? targetNonRestCount : Math.min(
				sourceCount,
				targetNonRestCount,
			);
			var sourceThisType = getThisTypeOfSignature(source);
			if (sourceThisType) {
				var targetThisType = getThisTypeOfSignature(target);
				if (targetThisType) {
					callback(sourceThisType, targetThisType);
				}
			}
			for (var i = 0; i < paramCount; i++) {
				callback(getTypeAtPosition(source, i), getTypeAtPosition(target, i));
			}
			if (targetRestType) {
				callback(getRestTypeAtPosition(source, paramCount), targetRestType);
			}
		}
		function applyToReturnTypes(source, target, callback) {
			var sourceTypePredicate = getTypePredicateOfSignature(source);
			var targetTypePredicate = getTypePredicateOfSignature(target);
			if (
				sourceTypePredicate && targetTypePredicate && typePredicateKindsMatch(
					sourceTypePredicate,
					targetTypePredicate,
				) && sourceTypePredicate.type && targetTypePredicate.type
			) {
				callback(sourceTypePredicate.type, targetTypePredicate.type);
			} else {
				callback(
					getReturnTypeOfSignature(source),
					getReturnTypeOfSignature(target),
				);
			}
		}
		function createInferenceContext(
			typeParameters,
			signature,
			flags,
			compareTypes,
		) {
			return createInferenceContextWorker(
				typeParameters.map(createInferenceInfo),
				signature,
				flags,
				compareTypes || compareTypesAssignable,
			);
		}
		function cloneInferenceContext(context, extraFlags) {
			if (extraFlags === void 0) {
				extraFlags = 0;
			}
			return context && createInferenceContextWorker(
				map(context.inferences, cloneInferenceInfo),
				context.signature,
				context.flags | extraFlags,
				context.compareTypes,
			);
		}
		function createInferenceContextWorker(
			inferences,
			signature,
			flags,
			compareTypes,
		) {
			var context = {
				inferences: inferences,
				signature: signature,
				flags: flags,
				compareTypes: compareTypes,
				mapper: makeFunctionTypeMapper(
					function (t) {
						return mapToInferredType(context, t, /*fix*/ true);
					},
				),
				nonFixingMapper: makeFunctionTypeMapper(
					function (t) {
						return mapToInferredType(context, t, /*fix*/ false);
					},
				),
			};
			return context;
		}
		function mapToInferredType(context, t, fix) {
			var inferences = context.inferences;
			for (var i = 0; i < inferences.length; i++) {
				var inference = inferences[i];
				if (t === inference.typeParameter) {
					if (fix && !inference.isFixed) {
						clearCachedInferences(inferences);
						inference.isFixed = true;
					}
					return getInferredType(context, i);
				}
			}
			return t;
		}
		function clearCachedInferences(inferences) {
			for (var _i = 0, inferences_1 = inferences; _i < inferences_1.length; _i++) {
				var inference = inferences_1[_i];
				if (!inference.isFixed) {
					inference.inferredType = undefined;
				}
			}
		}
		function createInferenceInfo(typeParameter) {
			return {
				typeParameter: typeParameter,
				candidates: undefined,
				contraCandidates: undefined,
				inferredType: undefined,
				priority: undefined,
				topLevel: true,
				isFixed: false,
				impliedArity: undefined,
			};
		}
		function cloneInferenceInfo(inference) {
			return {
				typeParameter: inference.typeParameter,
				candidates: inference.candidates && inference.candidates.slice(),
				contraCandidates: inference.contraCandidates && inference.contraCandidates.slice(),
				inferredType: inference.inferredType,
				priority: inference.priority,
				topLevel: inference.topLevel,
				isFixed: inference.isFixed,
				impliedArity: inference.impliedArity,
			};
		}
		function cloneInferredPartOfContext(context) {
			var inferences = filter(context.inferences, hasInferenceCandidates);
			return inferences.length ? createInferenceContextWorker(
				map(inferences, cloneInferenceInfo),
				context.signature,
				context.flags,
				context.compareTypes,
			) : undefined;
		}
		function getMapperFromContext(context) {
			return context && context.mapper;
		}
		// Return true if the given type could possibly reference a type parameter for which
		// we perform type inference (i.e. a type parameter of a generic function). We cache
		// results for union and intersection types for performance reasons.
		function couldContainTypeVariables(type) {
			var objectFlags = getObjectFlags(type);
			if (objectFlags & ObjectFlags.CouldContainTypeVariablesComputed) {
				return !!(objectFlags & ObjectFlags.CouldContainTypeVariables);
			}
			var result = !!(type.flags & TypeFlags.Instantiable || type.flags & TypeFlags.Object && !isNonGenericTopLevelType(
				type,
			) && (objectFlags & ObjectFlags.Reference && (type.node || forEach(
				getTypeArguments(type),
				couldContainTypeVariables,
			)) || objectFlags & ObjectFlags.Anonymous && type.symbol && type.symbol.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.TypeLiteral | SymbolFlags.ObjectLiteral) && type.symbol.declarations || objectFlags & (ObjectFlags.Mapped | ObjectFlags.ReverseMapped | ObjectFlags.ObjectRestType)) || type.flags & TypeFlags.UnionOrIntersection && !(type.flags & TypeFlags.EnumLiteral) && !isNonGenericTopLevelType(
				type,
			) && some(type.types, couldContainTypeVariables));
			if (type.flags & TypeFlags.ObjectFlagsType) {
				type.objectFlags |= ObjectFlags.CouldContainTypeVariablesComputed | (result ? ObjectFlags.CouldContainTypeVariables : 0);
			}
			return result;
		}
		function isNonGenericTopLevelType(type) {
			if (type.aliasSymbol && !type.aliasTypeArguments) {
				var declaration = getDeclarationOfKind(
					type.aliasSymbol,
					SyntaxKind.TypeAliasDeclaration,
				);
				return !!(declaration && findAncestor(
					declaration.parent,
					function (n) {
						return n.kind === SyntaxKind.SourceFile ? true : n.kind === SyntaxKind.ModuleDeclaration ? false : "quit";
					},
				));
			}
			return false;
		}
		function isTypeParameterAtTopLevel(type, typeParameter) {
			return !!(type === typeParameter || type.flags & TypeFlags.UnionOrIntersection && some(
				type.types,
				function (t) {
					return isTypeParameterAtTopLevel(t, typeParameter);
				},
			) || type.flags & TypeFlags.Conditional && (getTrueTypeFromConditionalType(
				type,
			) === typeParameter || getFalseTypeFromConditionalType(type) === typeParameter));
		}
		/** Create an object with properties named in the string literal type. Every property has type `any` */
		function createEmptyObjectTypeFromStringLiteral(type) {
			var members = createSymbolTable();
			forEachType(
				type,
				function (t) {
					if (!(t.flags & TypeFlags.StringLiteral)) {
						return;
					}
					var name = escapeLeadingUnderscores(t.value);
					var literalProp = createSymbol(SymbolFlags.Property, name);
					literalProp.type = anyType;
					if (t.symbol) {
						literalProp.declarations = t.symbol.declarations;
						literalProp.valueDeclaration = t.symbol.valueDeclaration;
					}
					members.set(name, literalProp);
				},
			);
			var indexInfos = type.flags & TypeFlags.String ? [
				createIndexInfo(stringType, emptyObjectType, /*isReadonly*/ false),
			] : emptyArray;
			return createAnonymousType(
				undefined,
				members,
				emptyArray,
				emptyArray,
				indexInfos,
			);
		}
		/**
         * Infer a suitable input type for a homomorphic mapped type { [P in keyof T]: X }. We construct
         * an object type with the same set of properties as the source type, where the type of each
         * property is computed by inferring from the source property type to X for the type
         * variable T[P] (i.e. we treat the type T[P] as the type variable we're inferring for).
         */
		function inferTypeForHomomorphicMappedType(source, target, constraint) {
			if (inInferTypeForHomomorphicMappedType) {
				return undefined;
			}
			var key = source.id + "," + target.id + "," + constraint.id;
			if (reverseMappedCache.has(key)) {
				return reverseMappedCache.get(key);
			}
			inInferTypeForHomomorphicMappedType = true;
			var type = createReverseMappedType(source, target, constraint);
			inInferTypeForHomomorphicMappedType = false;
			reverseMappedCache.set(key, type);
			return type;
		}
		// We consider a type to be partially inferable if it isn't marked non-inferable or if it is
		// an object literal type with at least one property of an inferable type. For example, an object
		// literal { a: 123, b: x => true } is marked non-inferable because it contains a context sensitive
		// arrow function, but is considered partially inferable because property 'a' has an inferable type.
		function isPartiallyInferableType(type) {
			return !(getObjectFlags(type) & ObjectFlags.NonInferrableType) || isObjectLiteralType(
				type,
			) && some(
				getPropertiesOfType(type),
				function (prop) {
					return isPartiallyInferableType(getTypeOfSymbol(prop));
				},
			) || isTupleType(type) && some(
				getTypeArguments(type),
				isPartiallyInferableType,
			);
		}
		function createReverseMappedType(source, target, constraint) {
			// We consider a source type reverse mappable if it has a string index signature or if
			// it has one or more properties and is of a partially inferable type.
			if (
				!(getIndexInfoOfType(source, stringType) || getPropertiesOfType(source).length !== 0 && isPartiallyInferableType(
					source,
				))
			) {
				return undefined;
			}
			// For arrays and tuples we infer new arrays and tuples where the reverse mapping has been
			// applied to the element type(s).
			if (isArrayType(source)) {
				return createArrayType(
					inferReverseMappedType(
						getTypeArguments(source)[0],
						target,
						constraint,
					),
					isReadonlyArrayType(source),
				);
			}
			if (isTupleType(source)) {
				var elementTypes = map(
					getTypeArguments(source),
					function (t) {
						return inferReverseMappedType(t, target, constraint);
					},
				);
				var elementFlags = getMappedTypeModifiers(target) & 4 ? sameMap(
					source.target.elementFlags, /* IncludeOptional */
					function (f) {
						return f & ElementFlags.Optional ? ElementFlags.Required : f;
					},
				) : source.target.elementFlags;
				return createTupleType(
					elementTypes,
					elementFlags,
					source.target.readonly,
					source.target.labeledElementDeclarations,
				);
			}
			// For all other object types we infer a new object type where the reverse mapping has been
			// applied to the type of each property.
			var reversed = createObjectType(
				ObjectFlags.ReverseMapped | ObjectFlags.Anonymous, /*symbol*/
				undefined,
			);
			reversed.source = source;
			reversed.mappedType = target;
			reversed.constraintType = constraint;
			return reversed;
		}
		function getTypeOfReverseMappedSymbol(symbol) {
			var links = getSymbolLinks(symbol);
			if (!links.type) {
				links.type = inferReverseMappedType(
					symbol.propertyType,
					symbol.mappedType,
					symbol.constraintType,
				);
			}
			return links.type;
		}
		function inferReverseMappedType(sourceType, target, constraint) {
			var typeParameter = getIndexedAccessType(
				constraint.type,
				getTypeParameterFromMappedType(target),
			);
			var templateType = getTemplateTypeFromMappedType(target);
			var inference = createInferenceInfo(typeParameter);
			inferTypes([inference], sourceType, templateType);
			return getTypeFromInference(inference) || unknownType;
		}
		function getUnmatchedProperties(
			source,
			target,
			requireOptionalProperties,
			matchDiscriminantProperties,
		) {
			var properties,
				_i,
				properties_2,
				targetProp,
				sourceProp,
				targetType,
				sourceType;
			return __generator(
				this,
				function (_a) {
					switch (_a.label) {
						case 0:
							properties = getPropertiesOfType(target);
							_i = 0, properties_2 = properties;
							_a.label = 1;
						case 1:
							if (!(_i < properties_2.length)) return [3 /*break*/ , 6];
							targetProp = properties_2[_i];
							// TODO: remove this when we support static private identifier fields and find other solutions to get privateNamesAndStaticFields test to pass
							if (isStaticPrivateIdentifierProperty(targetProp)) {
								return [3 /*break*/ , 5];
							}
							if (
								!(requireOptionalProperties || !(targetProp.flags & SymbolFlags.Optional || getCheckFlags(
									targetProp,
								) & CheckFlags.Partial))
							) return [3 /*break*/ , 5];
							sourceProp = getPropertyOfType(source, targetProp.escapedName);
							if (!!sourceProp) return [3 /*break*/ , 3];
							return [4 /*yield*/ , targetProp];
						case 2:
							_a.sent();
							return [3 /*break*/ , 5];
						case 3:
							if (!matchDiscriminantProperties) return [3 /*break*/ , 5];
							targetType = getTypeOfSymbol(targetProp);
							if (!(targetType.flags & TypeFlags.Unit)) return [3 /*break*/ , 5];
							sourceType = getTypeOfSymbol(sourceProp);
							if (
								!!(sourceType.flags & TypeFlags.Any || getRegularTypeOfLiteralType(
									sourceType,
								) === getRegularTypeOfLiteralType(targetType))
							) return [3 /*break*/ , 5];
							return [4 /*yield*/ , targetProp];
						case 4:
							_a.sent();
							_a.label = 5;
						case 5:
							_i++;
							return [3 /*break*/ , 1];
						case 6:
							return [2 /*return*/ ];
					}
				},
			);
		}
		function getUnmatchedProperty(
			source,
			target,
			requireOptionalProperties,
			matchDiscriminantProperties,
		) {
			var result = getUnmatchedProperties(
				source,
				target,
				requireOptionalProperties,
				matchDiscriminantProperties,
			).next();
			if (!result.done) return result.value;
		}
		function tupleTypesDefinitelyUnrelated(source, target) {
			return !(target.target.combinedFlags & ElementFlags.Variadic) && target.target.minLength > source.target.minLength || !target.target.hasRestElement && (source.target.hasRestElement || target.target.fixedLength < source.target.fixedLength);
		}
		function typesDefinitelyUnrelated(source, target) {
			// Two tuple types with incompatible arities are definitely unrelated.
			// Two object types that each have a property that is unmatched in the other are definitely unrelated.
			return isTupleType(source) && isTupleType(target) ? tupleTypesDefinitelyUnrelated(
				source,
				target,
			) : !!getUnmatchedProperty(
				source,
				target, /*requireOptionalProperties*/
				false, /*matchDiscriminantProperties*/
				true,
			) && !!getUnmatchedProperty(
				target,
				source, /*requireOptionalProperties*/
				false, /*matchDiscriminantProperties*/
				false,
			);
		}
		function getTypeFromInference(inference) {
			return inference.candidates ? getUnionType(
				inference.candidates,
				UnionReduction.Subtype,
			) : inference.contraCandidates ? getIntersectionType(
				inference.contraCandidates,
			) : undefined;
		}
		function hasSkipDirectInferenceFlag(node) {
			return !!getNodeLinks(node).skipDirectInference;
		}
		function isFromInferenceBlockedSource(type) {
			return !!(type.symbol && some(
				type.symbol.declarations,
				hasSkipDirectInferenceFlag,
			));
		}
		function templateLiteralTypesDefinitelyUnrelated(source, target) {
			// Two template literal types with diffences in their starting or ending text spans are definitely unrelated.
			var sourceStart = source.texts[0];
			var targetStart = target.texts[0];
			var sourceEnd = source.texts[source.texts.length - 1];
			var targetEnd = target.texts[target.texts.length - 1];
			var startLen = Math.min(sourceStart.length, targetStart.length);
			var endLen = Math.min(sourceEnd.length, targetEnd.length);
			return sourceStart.slice(0, startLen) !== targetStart.slice(0, startLen) || sourceEnd.slice(
				sourceEnd.length - endLen,
			) !== targetEnd.slice(targetEnd.length - endLen);
		}
		function isValidBigIntString(s) {
			var scanner = createScanner(ScriptTarget.ESNext, /*skipTrivia*/ false);
			var success = true;
			scanner.setOnError(
				function () {
					return success = false;
				},
			);
			scanner.setText(s + "n");
			var result = scanner.scan();
			if (result === SyntaxKind.MinusToken) {
				result = scanner.scan();
			}
			var flags = scanner.getTokenFlags();
			// validate that
			// * scanning proceeded without error
			// * a bigint can be scanned, and that when it is scanned, it is
			// * the full length of the input string (so the scanner is one character beyond the augmented input length)
			// * it does not contain a numeric seperator (the `BigInt` constructor does not accept a numeric seperator in its input)
			return success && result === SyntaxKind.BigIntLiteral && scanner.getTextPos() === (s.length + 1) && !(flags & TokenFlags.ContainsSeparator);
		}
		function isValidTypeForTemplateLiteralPlaceholder(source, target) {
			if (
				source === target || target.flags & (TypeFlags.Any | TypeFlags.String)
			) {
				return true;
			}
			if (source.flags & TypeFlags.StringLiteral) {
				var value = source.value;
				return !!(target.flags & TypeFlags.Number && value !== "" && isFinite(
					+value,
				) || target.flags & TypeFlags.BigInt && value !== "" && isValidBigIntString(
					value,
				) || target.flags & (TypeFlags.BooleanLiteral | TypeFlags.Nullable) && value === target.intrinsicName);
			}
			if (source.flags & TypeFlags.TemplateLiteral) {
				var texts = source.texts;
				return texts.length === 2 && texts[0] === "" && texts[1] === "" && isTypeAssignableTo(
					source.types[0],
					target,
				);
			}
			return isTypeAssignableTo(source, target);
		}
		function inferTypesFromTemplateLiteralType(source, target) {
			return source.flags & TypeFlags.StringLiteral ? inferFromLiteralPartsToTemplateLiteral(
				[source.value],
				emptyArray,
				target,
			) : source.flags & TypeFlags.TemplateLiteral ? arraysEqual(
				source.texts,
				target.texts,
			) ? map(source.types, getStringLikeTypeForType) : inferFromLiteralPartsToTemplateLiteral(
				source.texts,
				source.types,
				target,
			) : undefined;
		}
		function isTypeMatchedByTemplateLiteralType(source, target) {
			var inferences = inferTypesFromTemplateLiteralType(source, target);
			return !!inferences && every(
				inferences,
				function (r, i) {
					return isValidTypeForTemplateLiteralPlaceholder(r, target.types[i]);
				},
			);
		}
		function getStringLikeTypeForType(type) {
			return type.flags & (TypeFlags.Any | TypeFlags.StringLike) ? type : getTemplateLiteralType(
				["", ""],
				[type],
			);
		}
		// This function infers from the text parts and type parts of a source literal to a target template literal. The number
		// of text parts is always one more than the number of type parts, and a source string literal is treated as a source
		// with one text part and zero type parts. The function returns an array of inferred string or template literal types
		// corresponding to the placeholders in the target template literal, or undefined if the source doesn't match the target.
		//
		// We first check that the starting source text part matches the starting target text part, and that the ending source
		// text part ends matches the ending target text part. We then iterate through the remaining target text parts, finding
		// a match for each in the source and inferring string or template literal types created from the segments of the source
		// that occur between the matches. During this iteration, seg holds the index of the current text part in the sourceTexts
		// array and pos holds the current character position in the current text part.
		//
		// Consider inference from type `<<${string}>.<${number}-${number}>>` to type `<${string}.${string}>`, i.e.
		//   sourceTexts = ['<<', '>.<', '-', '>>']
		//   sourceTypes = [string, number, number]
		//   target.texts = ['<', '.', '>']
		// We first match '<' in the target to the start of '<<' in the source and '>' in the target to the end of '>>' in
		// the source. The first match for the '.' in target occurs at character 1 in the source text part at index 1, and thus
		// the first inference is the template literal type `<${string}>`. The remainder of the source makes up the second
		// inference, the template literal type `<${number}-${number}>`.
		function inferFromLiteralPartsToTemplateLiteral(
			sourceTexts,
			sourceTypes,
			target,
		) {
			var lastSourceIndex = sourceTexts.length - 1;
			var sourceStartText = sourceTexts[0];
			var sourceEndText = sourceTexts[lastSourceIndex];
			var targetTexts = target.texts;
			var lastTargetIndex = targetTexts.length - 1;
			var targetStartText = targetTexts[0];
			var targetEndText = targetTexts[lastTargetIndex];
			if (
				lastSourceIndex === 0 && sourceStartText.length < targetStartText.length + targetEndText.length || !sourceStartText.startsWith(
					targetStartText,
				) || !sourceEndText.endsWith(targetEndText)
			) return undefined;
			var remainingEndText = sourceEndText.slice(
				0,
				sourceEndText.length - targetEndText.length,
			);
			var matches = [];
			var seg = 0;
			var pos = targetStartText.length;
			for (var i = 1; i < lastTargetIndex; i++) {
				var delim = targetTexts[i];
				if (delim.length > 0) {
					var s = seg;
					var p = pos;
					while (true) {
						p = getSourceText(s).indexOf(delim, p);
						if (p >= 0) break;
						s++;
						if (s === sourceTexts.length) return undefined;
						p = 0;
					}
					addMatch(s, p);
					pos += delim.length;
				} else if (pos < getSourceText(seg).length) {
					addMatch(seg, pos + 1);
				} else if (seg < lastSourceIndex) {
					addMatch(seg + 1, 0);
				} else {
					return undefined;
				}
			}
			addMatch(lastSourceIndex, getSourceText(lastSourceIndex).length);
			return matches;
			function getSourceText(index) {
				return index < lastSourceIndex ? sourceTexts[index] : remainingEndText;
			}
			function addMatch(s, p) {
				var matchType = s === seg ? getStringLiteralType(
					getSourceText(s).slice(pos, p),
				) : getTemplateLiteralType(
					__spreadArray(
						__spreadArray(
							[sourceTexts[seg].slice(pos)],
							sourceTexts.slice(seg + 1, s),
							true,
						),
						[getSourceText(s).slice(0, p)],
						false,
					),
					sourceTypes.slice(seg, s),
				);
				matches.push(matchType);
				seg = s;
				pos = p;
			}
		}
		function inferTypes(
			inferences,
			originalSource,
			originalTarget,
			priority,
			contravariant,
		) {
			if (priority === void 0) {
				priority = 0;
			}
			if (contravariant === void 0) {
				contravariant = false;
			}
			var bivariant = false;
			var propagationType;
			var inferencePriority = InferencePriority.MaxValue;
			var allowComplexConstraintInference = true;
			var visited;
			var sourceStack;
			var targetStack;
			var expandingFlags = 0 /* None */ ;
			inferFromTypes(originalSource, originalTarget);
			function inferFromTypes(source, target) {
				if (!couldContainTypeVariables(target)) {
					return;
				}
				if (source === wildcardType) {
					// We are inferring from an 'any' type. We want to infer this type for every type parameter
					// referenced in the target type, so we record it as the propagation type and infer from the
					// target to itself. Then, as we find candidates we substitute the propagation type.
					var savePropagationType = propagationType;
					propagationType = source;
					inferFromTypes(target, target);
					propagationType = savePropagationType;
					return;
				}
				if (
					source.aliasSymbol && source.aliasTypeArguments && source.aliasSymbol === target.aliasSymbol
				) {
					// Source and target are types originating in the same generic type alias declaration.
					// Simply infer from source type arguments to target type arguments.
					inferFromTypeArguments(
						source.aliasTypeArguments,
						target.aliasTypeArguments,
						getAliasVariances(source.aliasSymbol),
					);
					return;
				}
				if (source === target && source.flags & TypeFlags.UnionOrIntersection) {
					// When source and target are the same union or intersection type, just relate each constituent
					// type to itself.
					for (var _i = 0, _a = source.types; _i < _a.length; _i++) {
						var t = _a[_i];
						inferFromTypes(t, t);
					}
					return;
				}
				if (target.flags & TypeFlags.Union) {
					// First, infer between identically matching source and target constituents and remove the
					// matching types.
					var _b = inferFromMatchingTypes(
						source.flags & TypeFlags.Union ? source.types : [source],
						target.types,
						isTypeOrBaseIdenticalTo,
					),
						tempSources = _b[0],
						tempTargets = _b[1];
					// Next, infer between closely matching source and target constituents and remove
					// the matching types. Types closely match when they are instantiations of the same
					// object type or instantiations of the same type alias.
					var _c = inferFromMatchingTypes(
						tempSources,
						tempTargets,
						isTypeCloselyMatchedBy,
					),
						sources = _c[0],
						targets = _c[1];
					if (targets.length === 0) {
						return;
					}
					target = getUnionType(targets);
					if (sources.length === 0) {
						// All source constituents have been matched and there is nothing further to infer from.
						// However, simply making no inferences is undesirable because it could ultimately mean
						// inferring a type parameter constraint. Instead, make a lower priority inference from
						// the full source to whatever remains in the target. For example, when inferring from
						// string to 'string | T', make a lower priority inference of string for T.
						inferWithPriority(
							source,
							target,
							InferencePriority.NakedTypeVariable,
						);
						return;
					}
					source = getUnionType(sources);
				} else if (
					target.flags & TypeFlags.Intersection && some(
						target.types,
						function (t) {
							return !!getInferenceInfoForType(t) || (isGenericMappedType(t) && !!getInferenceInfoForType(
								getHomomorphicTypeVariable(t) || neverType,
							));
						},
					)
				) {
					// We reduce intersection types only when they contain naked type parameters. For example, when
					// inferring from 'string[] & { extra: any }' to 'string[] & T' we want to remove string[] and
					// infer { extra: any } for T. But when inferring to 'string[] & Iterable<T>' we want to keep the
					// string[] on the source side and infer string for T.
					// Likewise, we consider a homomorphic mapped type constrainted to the target type parameter as similar to a "naked type variable"
					// in such scenarios.
					if (!(source.flags & TypeFlags.Union)) {
						// Infer between identically matching source and target constituents and remove the matching types.
						var _d = inferFromMatchingTypes(
							source.flags & TypeFlags.Intersection ? source.types : [source],
							target.types,
							isTypeIdenticalTo,
						),
							sources = _d[0],
							targets = _d[1];
						if (sources.length === 0 || targets.length === 0) {
							return;
						}
						source = getIntersectionType(sources);
						target = getIntersectionType(targets);
					}
				} else if (
					target.flags & (TypeFlags.IndexedAccess | TypeFlags.Substitution)
				) {
					target = getActualTypeVariable(target);
				}
				if (target.flags & TypeFlags.TypeVariable) {
					// If target is a type parameter, make an inference, unless the source type contains
					// the anyFunctionType (the wildcard type that's used to avoid contextually typing functions).
					// Because the anyFunctionType is internal, it should not be exposed to the user by adding
					// it as an inference candidate. Hopefully, a better candidate will come along that does
					// not contain anyFunctionType when we come back to this argument for its second round
					// of inference. Also, we exclude inferences for silentNeverType (which is used as a wildcard
					// when constructing types from type parameters that had no inference candidates).
					if (
						source === nonInferrableAnyType || source === silentNeverType || (priority & InferencePriority.ReturnType && (source === autoType || source === autoArrayType)) || isFromInferenceBlockedSource(
							source,
						)
					) {
						return;
					}
					var inference = getInferenceInfoForType(target);
					if (inference) {
						if (getObjectFlags(source) & ObjectFlags.NonInferrableType) {
							return;
						}
						if (!inference.isFixed) {
							if (
								inference.priority === undefined || priority < inference.priority
							) {
								inference.candidates = undefined;
								inference.contraCandidates = undefined;
								inference.topLevel = true;
								inference.priority = priority;
							}
							if (priority === inference.priority) {
								var candidate = propagationType || source;
								// We make contravariant inferences only if we are in a pure contravariant position,
								// i.e. only if we have not descended into a bivariant position.
								if (contravariant && !bivariant) {
									if (!contains(inference.contraCandidates, candidate)) {
										inference.contraCandidates = append(
											inference.contraCandidates,
											candidate,
										);
										clearCachedInferences(inferences);
									}
								} else if (!contains(inference.candidates, candidate)) {
									inference.candidates = append(inference.candidates, candidate);
									clearCachedInferences(inferences);
								}
							}
							if (
								!(priority & InferencePriority.ReturnType) && target.flags & TypeFlags.TypeParameter && inference.topLevel && !isTypeParameterAtTopLevel(
									originalTarget,
									target,
								)
							) {
								inference.topLevel = false;
								clearCachedInferences(inferences);
							}
						}
						inferencePriority = Math.min(inferencePriority, priority);
						return;
					}
					// Infer to the simplified version of an indexed access, if possible, to (hopefully) expose more bare type parameters to the inference engine
					var simplified = getSimplifiedType(target, /*writing*/ false);
					if (simplified !== target) {
						inferFromTypes(source, simplified);
					} else if (target.flags & TypeFlags.IndexedAccess) {
						var indexType = getSimplifiedType(
							target.indexType, /*writing*/
							false,
						);
						// Generally simplifications of instantiable indexes are avoided to keep relationship checking correct, however if our target is an access, we can consider
						// that key of that access to be "instantiated", since we're looking to find the infernce goal in any way we can.
						if (indexType.flags & TypeFlags.Instantiable) {
							var simplified_1 = distributeIndexOverObjectType(
								getSimplifiedType(target.objectType, /*writing*/ false),
								indexType, /*writing*/
								false,
							);
							if (simplified_1 && simplified_1 !== target) {
								inferFromTypes(source, simplified_1);
							}
						}
					}
				}
				if (
					getObjectFlags(source) & ObjectFlags.Reference && getObjectFlags(
						target,
					) & ObjectFlags.Reference && (source.target === target.target || isArrayType(
						source,
					) && isArrayType(target)) && !(source.node && target.node)
				) {
					// If source and target are references to the same generic type, infer from type arguments
					inferFromTypeArguments(
						getTypeArguments(source),
						getTypeArguments(target),
						getVariances(source.target),
					);
				} else if (
					source.flags & TypeFlags.Index && target.flags & TypeFlags.Index
				) {
					contravariant = !contravariant;
					inferFromTypes(source.type, target.type);
					contravariant = !contravariant;
				} else if (
					(isLiteralType(source) || source.flags & TypeFlags.String) && target.flags & TypeFlags.Index
				) {
					var empty = createEmptyObjectTypeFromStringLiteral(source);
					contravariant = !contravariant;
					inferWithPriority(empty, target.type, InferencePriority.LiteralKeyof);
					contravariant = !contravariant;
				} else if (
					source.flags & TypeFlags.IndexedAccess && target.flags & TypeFlags.IndexedAccess
				) {
					inferFromTypes(source.objectType, target.objectType);
					inferFromTypes(source.indexType, target.indexType);
				} else if (
					source.flags & TypeFlags.StringMapping && target.flags & TypeFlags.StringMapping
				) {
					if (source.symbol === target.symbol) {
						inferFromTypes(source.type, target.type);
					}
				} else if (source.flags & TypeFlags.Substitution) {
					inferFromTypes(source.baseType, target);
					var oldPriority = priority;
					priority |= InferencePriority.SubstituteSource;
					inferFromTypes(source.substitute, target); // Make substitute inference at a lower priority
					priority = oldPriority;
				} else if (target.flags & TypeFlags.Conditional) {
					invokeOnce(source, target, inferToConditionalType);
				} else if (target.flags & TypeFlags.UnionOrIntersection) {
					inferToMultipleTypes(source, target.types, target.flags);
				} else if (source.flags & TypeFlags.Union) {
					// Source is a union or intersection type, infer from each constituent type
					var sourceTypes = source.types;
					for (
						var _e = 0, sourceTypes_2 = sourceTypes;
						_e < sourceTypes_2.length;
						_e++
					) {
						var sourceType = sourceTypes_2[_e];
						inferFromTypes(sourceType, target);
					}
				} else if (target.flags & TypeFlags.TemplateLiteral) {
					inferToTemplateLiteralType(source, target);
				} else {
					source = getReducedType(source);
					if (
						!(priority & InferencePriority.NoConstraints && source.flags & (TypeFlags.Intersection | TypeFlags.Instantiable))
					) {
						var apparentSource = getApparentType(source);
						// getApparentType can return _any_ type, since an indexed access or conditional may simplify to any other type.
						// If that occurs and it doesn't simplify to an object or intersection, we'll need to restart `inferFromTypes`
						// with the simplified source.
						if (
							apparentSource !== source && allowComplexConstraintInference && !(apparentSource.flags & (TypeFlags.Object | TypeFlags.Intersection))
						) {
							// TODO: The `allowComplexConstraintInference` flag is a hack! This forbids inference from complex constraints within constraints!
							// This isn't required algorithmically, but rather is used to lower the memory burden caused by performing inference
							// that is _too good_ in projects with complicated constraints (eg, fp-ts). In such cases, if we did not limit ourselves
							// here, we might produce more valid inferences for types, causing us to do more checks and perform more instantiations
							// (in addition to the extra stack depth here) which, in turn, can push the already close process over its limit.
							// TL;DR: If we ever become generally more memory efficient (or our resource budget ever increases), we should just
							// remove this `allowComplexConstraintInference` flag.
							allowComplexConstraintInference = false;
							return inferFromTypes(apparentSource, target);
						}
						source = apparentSource;
					}
					if (source.flags & (TypeFlags.Object | TypeFlags.Intersection)) {
						invokeOnce(source, target, inferFromObjectTypes);
					}
				}
			}
			function inferWithPriority(source, target, newPriority) {
				var savePriority = priority;
				priority |= newPriority;
				inferFromTypes(source, target);
				priority = savePriority;
			}
			function invokeOnce(source, target, action) {
				var key = source.id + "," + target.id;
				var status = visited && visited.get(key);
				if (status !== undefined) {
					inferencePriority = Math.min(inferencePriority, status);
					return;
				}
				(visited || (visited = new Map())).set(
					key,
					InferencePriority.Circularity,
				);
				var saveInferencePriority = inferencePriority;
				inferencePriority = InferencePriority.MaxValue;
				// We stop inferring and report a circularity if we encounter duplicate recursion identities on both
				// the source side and the target side.
				var saveExpandingFlags = expandingFlags;
				var sourceIdentity = getRecursionIdentity(source);
				var targetIdentity = getRecursionIdentity(target);
				if (contains(sourceStack, sourceIdentity)) expandingFlags |= 1; /* Source */
				if (contains(targetStack, targetIdentity)) expandingFlags |= 2; /* Target */
				if (expandingFlags !== 3 /* Both */ ) {
					(sourceStack || (sourceStack = [])).push(sourceIdentity);
					(targetStack || (targetStack = [])).push(targetIdentity);
					action(source, target);
					targetStack.pop();
					sourceStack.pop();
				} else {
					inferencePriority = InferencePriority.Circularity;
				}
				expandingFlags = saveExpandingFlags;
				visited.set(key, inferencePriority);
				inferencePriority = Math.min(inferencePriority, saveInferencePriority);
			}
			function inferFromMatchingTypes(sources, targets, matches) {
				var matchedSources;
				var matchedTargets;
				for (var _i = 0, targets_1 = targets; _i < targets_1.length; _i++) {
					var t = targets_1[_i];
					for (var _a = 0, sources_1 = sources; _a < sources_1.length; _a++) {
						var s = sources_1[_a];
						if (matches(s, t)) {
							inferFromTypes(s, t);
							matchedSources = appendIfUnique(matchedSources, s);
							matchedTargets = appendIfUnique(matchedTargets, t);
						}
					}
				}
				return [
					matchedSources ? filter(
						sources,
						function (t) {
							return !contains(matchedSources, t);
						},
					) : sources,
					matchedTargets ? filter(
						targets,
						function (t) {
							return !contains(matchedTargets, t);
						},
					) : targets,
				];
			}
			function inferFromTypeArguments(sourceTypes, targetTypes, variances) {
				var count = sourceTypes.length < targetTypes.length ? sourceTypes.length : targetTypes.length;
				for (var i = 0; i < count; i++) {
					if (
						i < variances.length && (variances[i] & VarianceFlags.VarianceMask) === VarianceFlags.Contravariant
					) {
						inferFromContravariantTypes(sourceTypes[i], targetTypes[i]);
					} else {
						inferFromTypes(sourceTypes[i], targetTypes[i]);
					}
				}
			}
			function inferFromContravariantTypes(source, target) {
				if (strictFunctionTypes || priority & InferencePriority.AlwaysStrict) {
					contravariant = !contravariant;
					inferFromTypes(source, target);
					contravariant = !contravariant;
				} else {
					inferFromTypes(source, target);
				}
			}
			function getInferenceInfoForType(type) {
				if (type.flags & TypeFlags.TypeVariable) {
					for (
						var _i = 0, inferences_2 = inferences;
						_i < inferences_2.length;
						_i++
					) {
						var inference = inferences_2[_i];
						if (type === inference.typeParameter) {
							return inference;
						}
					}
				}
				return undefined;
			}
			function getSingleTypeVariableFromIntersectionTypes(types) {
				var typeVariable;
				for (var _i = 0, types_15 = types; _i < types_15.length; _i++) {
					var type = types_15[_i];
					var t = type.flags & TypeFlags.Intersection && find(
						type.types,
						function (t) {
							return !!getInferenceInfoForType(t);
						},
					);
					if (!t || typeVariable && t !== typeVariable) {
						return undefined;
					}
					typeVariable = t;
				}
				return typeVariable;
			}
			function inferToMultipleTypes(source, targets, targetFlags) {
				var typeVariableCount = 0;
				if (targetFlags & TypeFlags.Union) {
					var nakedTypeVariable = void 0;
					var sources = source.flags & TypeFlags.Union ? source.types : [source];
					var matched_1 = new Array(sources.length);
					var inferenceCircularity = false;
					// First infer to types that are not naked type variables. For each source type we
					// track whether inferences were made from that particular type to some target with
					// equal priority (i.e. of equal quality) to what we would infer for a naked type
					// parameter.
					for (var _i = 0, targets_2 = targets; _i < targets_2.length; _i++) {
						var t = targets_2[_i];
						if (getInferenceInfoForType(t)) {
							nakedTypeVariable = t;
							typeVariableCount++;
						} else {
							for (var i = 0; i < sources.length; i++) {
								var saveInferencePriority = inferencePriority;
								inferencePriority = InferencePriority.MaxValue;
								inferFromTypes(sources[i], t);
								if (inferencePriority === priority) matched_1[i] = true;
								inferenceCircularity = inferenceCircularity || inferencePriority === InferencePriority.Circularity;
								inferencePriority = Math.min(
									inferencePriority,
									saveInferencePriority,
								);
							}
						}
					}
					if (typeVariableCount === 0) {
						// If every target is an intersection of types containing a single naked type variable,
						// make a lower priority inference to that type variable. This handles inferring from
						// 'A | B' to 'T & (X | Y)' where we want to infer 'A | B' for T.
						var intersectionTypeVariable = getSingleTypeVariableFromIntersectionTypes(
							targets,
						);
						if (intersectionTypeVariable) {
							inferWithPriority(
								source,
								intersectionTypeVariable,
								InferencePriority.NakedTypeVariable,
							);
						}
						return;
					}
					// If the target has a single naked type variable and no inference circularities were
					// encountered above (meaning we explored the types fully), create a union of the source
					// types from which no inferences have been made so far and infer from that union to the
					// naked type variable.
					if (typeVariableCount === 1 && !inferenceCircularity) {
						var unmatched = flatMap(
							sources,
							function (s, i) {
								return matched_1[i] ? undefined : s;
							},
						);
						if (unmatched.length) {
							inferFromTypes(getUnionType(unmatched), nakedTypeVariable);
							return;
						}
					}
				} else {
					// We infer from types that are not naked type variables first so that inferences we
					// make from nested naked type variables and given slightly higher priority by virtue
					// of being first in the candidates array.
					for (var _a = 0, targets_3 = targets; _a < targets_3.length; _a++) {
						var t = targets_3[_a];
						if (getInferenceInfoForType(t)) {
							typeVariableCount++;
						} else {
							inferFromTypes(source, t);
						}
					}
				}
				// Inferences directly to naked type variables are given lower priority as they are
				// less specific. For example, when inferring from Promise<string> to T | Promise<T>,
				// we want to infer string for T, not Promise<string> | string. For intersection types
				// we only infer to single naked type variables.
				if (
					targetFlags & TypeFlags.Intersection ? typeVariableCount === 1 : typeVariableCount > 0
				) {
					for (var _b = 0, targets_4 = targets; _b < targets_4.length; _b++) {
						var t = targets_4[_b];
						if (getInferenceInfoForType(t)) {
							inferWithPriority(source, t, InferencePriority.NakedTypeVariable);
						}
					}
				}
			}
			function inferToMappedType(source, target, constraintType) {
				if (constraintType.flags & TypeFlags.Union) {
					var result = false;
					for (var _i = 0, _a = constraintType.types; _i < _a.length; _i++) {
						var type = _a[_i];
						result = inferToMappedType(source, target, type) || result;
					}
					return result;
				}
				if (constraintType.flags & TypeFlags.Index) {
					// We're inferring from some source type S to a homomorphic mapped type { [P in keyof T]: X },
					// where T is a type variable. Use inferTypeForHomomorphicMappedType to infer a suitable source
					// type and then make a secondary inference from that type to T. We make a secondary inference
					// such that direct inferences to T get priority over inferences to Partial<T>, for example.
					var inference = getInferenceInfoForType(constraintType.type);
					if (
						inference && !inference.isFixed && !isFromInferenceBlockedSource(
							source,
						)
					) {
						var inferredType = inferTypeForHomomorphicMappedType(
							source,
							target,
							constraintType,
						);
						if (inferredType) {
							// We assign a lower priority to inferences made from types containing non-inferrable
							// types because we may only have a partial result (i.e. we may have failed to make
							// reverse inferences for some properties).
							inferWithPriority(
								inferredType,
								inference.typeParameter,
								getObjectFlags(source) & ObjectFlags.NonInferrableType ? InferencePriority.PartialHomomorphicMappedType : InferencePriority.HomomorphicMappedType,
							);
						}
					}
					return true;
				}
				if (constraintType.flags & TypeFlags.TypeParameter) {
					// We're inferring from some source type S to a mapped type { [P in K]: X }, where K is a type
					// parameter. First infer from 'keyof S' to K.
					inferWithPriority(
						getIndexType(source),
						constraintType,
						InferencePriority.MappedTypeConstraint,
					);
					// If K is constrained to a type C, also infer to C. Thus, for a mapped type { [P in K]: X },
					// where K extends keyof T, we make the same inferences as for a homomorphic mapped type
					// { [P in keyof T]: X }. This enables us to make meaningful inferences when the target is a
					// Pick<T, K>.
					var extendedConstraint = getConstraintOfType(constraintType);
					if (
						extendedConstraint && inferToMappedType(
							source,
							target,
							extendedConstraint,
						)
					) {
						return true;
					}
					// If no inferences can be made to K's constraint, infer from a union of the property types
					// in the source to the template type X.
					var propTypes = map(getPropertiesOfType(source), getTypeOfSymbol);
					var indexTypes = map(
						getIndexInfosOfType(source),
						function (info) {
							return info !== enumNumberIndexInfo ? info.type : neverType;
						},
					);
					inferFromTypes(
						getUnionType(concatenate(propTypes, indexTypes)),
						getTemplateTypeFromMappedType(target),
					);
					return true;
				}
				return false;
			}
			function inferToConditionalType(source, target) {
				if (source.flags & TypeFlags.Conditional) {
					inferFromTypes(source.checkType, target.checkType);
					inferFromTypes(source.extendsType, target.extendsType);
					inferFromTypes(
						getTrueTypeFromConditionalType(source),
						getTrueTypeFromConditionalType(target),
					);
					inferFromTypes(
						getFalseTypeFromConditionalType(source),
						getFalseTypeFromConditionalType(target),
					);
				} else {
					var savePriority = priority;
					priority |= contravariant ? InferencePriority.ContravariantConditional : 0;
					var targetTypes = [
						getTrueTypeFromConditionalType(target),
						getFalseTypeFromConditionalType(target),
					];
					inferToMultipleTypes(source, targetTypes, target.flags);
					priority = savePriority;
				}
			}
			function inferToTemplateLiteralType(source, target) {
				var matches = inferTypesFromTemplateLiteralType(source, target);
				var types = target.types;
				// When the target template literal contains only placeholders (meaning that inference is intended to extract
				// single characters and remainder strings) and inference fails to produce matches, we want to infer 'never' for
				// each placeholder such that instantiation with the inferred value(s) produces 'never', a type for which an
				// assignment check will fail. If we make no inferences, we'll likely end up with the constraint 'string' which,
				// upon instantiation, would collapse all the placeholders to just 'string', and an assignment check might
				// succeed. That would be a pointless and confusing outcome.
				if (
					matches || every(
						target.texts,
						function (s) {
							return s.length === 0;
						},
					)
				) {
					for (var i = 0; i < types.length; i++) {
						inferFromTypes(matches ? matches[i] : neverType, types[i]);
					}
				}
			}
			function inferFromObjectTypes(source, target) {
				if (
					getObjectFlags(source) & ObjectFlags.Reference && getObjectFlags(
						target,
					) & ObjectFlags.Reference && (source.target === target.target || isArrayType(
						source,
					) && isArrayType(target))
				) {
					// If source and target are references to the same generic type, infer from type arguments
					inferFromTypeArguments(
						getTypeArguments(source),
						getTypeArguments(target),
						getVariances(source.target),
					);
					return;
				}
				if (isGenericMappedType(source) && isGenericMappedType(target)) {
					// The source and target types are generic types { [P in S]: X } and { [P in T]: Y }, so we infer
					// from S to T and from X to Y.
					inferFromTypes(
						getConstraintTypeFromMappedType(source),
						getConstraintTypeFromMappedType(target),
					);
					inferFromTypes(
						getTemplateTypeFromMappedType(source),
						getTemplateTypeFromMappedType(target),
					);
					var sourceNameType = getNameTypeFromMappedType(source);
					var targetNameType = getNameTypeFromMappedType(target);
					if (sourceNameType && targetNameType) inferFromTypes(
						sourceNameType,
						targetNameType,
					);
				}
				if (
					getObjectFlags(target) & ObjectFlags.Mapped && !target.declaration.nameType
				) {
					var constraintType = getConstraintTypeFromMappedType(target);
					if (inferToMappedType(source, target, constraintType)) {
						return;
					}
				}
				// Infer from the members of source and target only if the two types are possibly related
				if (!typesDefinitelyUnrelated(source, target)) {
					if (isArrayType(source) || isTupleType(source)) {
						if (isTupleType(target)) {
							var sourceArity = getTypeReferenceArity(source);
							var targetArity = getTypeReferenceArity(target);
							var elementTypes = getTypeArguments(target);
							var elementFlags = target.target.elementFlags;
							// When source and target are tuple types with the same structure (fixed, variadic, and rest are matched
							// to the same kind in each position), simply infer between the element types.
							if (
								isTupleType(source) && isTupleTypeStructureMatching(
									source,
									target,
								)
							) {
								for (var i = 0; i < targetArity; i++) {
									inferFromTypes(getTypeArguments(source)[i], elementTypes[i]);
								}
								return;
							}
							var startLength = isTupleType(source) ? Math.min(
								source.target.fixedLength,
								target.target.fixedLength,
							) : 0;
							var endLength = Math.min(
								isTupleType(source) ? getEndElementCount(
									source.target,
									ElementFlags.Fixed,
								) : 0,
								target.target.hasRestElement ? getEndElementCount(
									target.target,
									ElementFlags.Fixed,
								) : 0,
							);
							// Infer between starting fixed elements.
							for (var i = 0; i < startLength; i++) {
								inferFromTypes(getTypeArguments(source)[i], elementTypes[i]);
							}
							if (
								!isTupleType(source) || sourceArity - startLength - endLength === 1 && source.target.elementFlags[startLength] & ElementFlags.Rest
							) {
								// Single rest element remains in source, infer from that to every element in target
								var restType = getTypeArguments(source)[startLength];
								for (var i = startLength; i < targetArity - endLength; i++) {
									inferFromTypes(
										elementFlags[i] & ElementFlags.Variadic ? createArrayType(
											restType,
										) : restType,
										elementTypes[i],
									);
								}
							} else {
								var middleLength = targetArity - startLength - endLength;
								if (
									middleLength === 2 && elementFlags[startLength] & elementFlags[startLength + 1] & ElementFlags.Variadic && isTupleType(
										source,
									)
								) {
									// Middle of target is [...T, ...U] and source is tuple type
									var targetInfo = getInferenceInfoForType(
										elementTypes[startLength],
									);
									if (targetInfo && targetInfo.impliedArity !== undefined) {
										// Infer slices from source based on implied arity of T.
										inferFromTypes(
											sliceTupleType(
												source,
												startLength,
												endLength + sourceArity - targetInfo.impliedArity,
											),
											elementTypes[startLength],
										);
										inferFromTypes(
											sliceTupleType(
												source,
												startLength + targetInfo.impliedArity,
												endLength,
											),
											elementTypes[startLength + 1],
										);
									}
								} else if (
									middleLength === 1 && elementFlags[startLength] & ElementFlags.Variadic
								) {
									// Middle of target is exactly one variadic element. Infer the slice between the fixed parts in the source.
									// If target ends in optional element(s), make a lower priority a speculative inference.
									var endsInOptional = target.target.elementFlags[targetArity - 1] & ElementFlags.Optional;
									var sourceSlice = isTupleType(source) ? sliceTupleType(
										source,
										startLength,
										endLength,
									) : createArrayType(getTypeArguments(source)[0]);
									inferWithPriority(
										sourceSlice,
										elementTypes[startLength],
										endsInOptional ? InferencePriority.SpeculativeTuple : 0,
									);
								} else if (
									middleLength === 1 && elementFlags[startLength] & ElementFlags.Rest
								) {
									// Middle of target is exactly one rest element. If middle of source is not empty, infer union of middle element types.
									var restType = isTupleType(source) ? getElementTypeOfSliceOfTupleType(
										source,
										startLength,
										endLength,
									) : getTypeArguments(source)[0];
									if (restType) {
										inferFromTypes(restType, elementTypes[startLength]);
									}
								}
							}
							// Infer between ending fixed elements
							for (var i = 0; i < endLength; i++) {
								inferFromTypes(
									getTypeArguments(source)[sourceArity - i - 1],
									elementTypes[targetArity - i - 1],
								);
							}
							return;
						}
						if (isArrayType(target)) {
							inferFromIndexTypes(source, target);
							return;
						}
					}
					inferFromProperties(source, target);
					inferFromSignatures(source, target, SignatureKind.Call);
					inferFromSignatures(source, target, SignatureKind.Construct);
					inferFromIndexTypes(source, target);
				}
			}
			function inferFromProperties(source, target) {
				var properties = getPropertiesOfObjectType(target);
				for (
					var _i = 0, properties_3 = properties;
					_i < properties_3.length;
					_i++
				) {
					var targetProp = properties_3[_i];
					var sourceProp = getPropertyOfType(source, targetProp.escapedName);
					if (sourceProp) {
						inferFromTypes(
							getTypeOfSymbol(sourceProp),
							getTypeOfSymbol(targetProp),
						);
					}
				}
			}
			function inferFromSignatures(source, target, kind) {
				var sourceSignatures = getSignaturesOfType(source, kind);
				var targetSignatures = getSignaturesOfType(target, kind);
				var sourceLen = sourceSignatures.length;
				var targetLen = targetSignatures.length;
				var len = sourceLen < targetLen ? sourceLen : targetLen;
				var skipParameters = !!(getObjectFlags(source) & ObjectFlags.NonInferrableType);
				for (var i = 0; i < len; i++) {
					inferFromSignature(
						getBaseSignature(sourceSignatures[sourceLen - len + i]),
						getErasedSignature(targetSignatures[targetLen - len + i]),
						skipParameters,
					);
				}
			}
			function inferFromSignature(source, target, skipParameters) {
				if (!skipParameters) {
					var saveBivariant = bivariant;
					var kind = target.declaration ? target.declaration.kind : SyntaxKind.Unknown;
					// Once we descend into a bivariant signature we remain bivariant for all nested inferences
					bivariant = bivariant || kind === SyntaxKind.MethodDeclaration || kind === SyntaxKind.MethodSignature || kind === SyntaxKind.Constructor;
					applyToParameterTypes(source, target, inferFromContravariantTypes);
					bivariant = saveBivariant;
				}
				applyToReturnTypes(source, target, inferFromTypes);
			}
			function inferFromIndexTypes(source, target) {
				// Inferences across mapped type index signatures are pretty much the same a inferences to homomorphic variables
				var priority = (getObjectFlags(source) & getObjectFlags(target) & ObjectFlags.Mapped) ? InferencePriority.HomomorphicMappedType : 0;
				var indexInfos = getIndexInfosOfType(target);
				if (isObjectTypeWithInferableIndex(source)) {
					for (
						var _i = 0, indexInfos_4 = indexInfos;
						_i < indexInfos_4.length;
						_i++
					) {
						var targetInfo = indexInfos_4[_i];
						var propTypes = [];
						for (
							var _a = 0, _b = getPropertiesOfType(source);
							_a < _b.length;
							_a++
						) {
							var prop = _b[_a];
							if (
								isApplicableIndexType(
									getLiteralTypeFromProperty(
										prop,
										TypeFlags.StringOrNumberLiteralOrUnique,
									),
									targetInfo.keyType,
								)
							) {
								var propType = getTypeOfSymbol(prop);
								propTypes.push(
									prop.flags & SymbolFlags.Optional ? removeMissingOrUndefinedType(
										propType,
									) : propType,
								);
							}
						}
						for (
							var _c = 0, _d = getIndexInfosOfType(source);
							_c < _d.length;
							_c++
						) {
							var info = _d[_c];
							if (isApplicableIndexType(info.keyType, targetInfo.keyType)) {
								propTypes.push(info.type);
							}
						}
						if (propTypes.length) {
							inferWithPriority(
								getUnionType(propTypes),
								targetInfo.type,
								priority,
							);
						}
					}
				}
				for (
					var _e = 0, indexInfos_5 = indexInfos;
					_e < indexInfos_5.length;
					_e++
				) {
					var targetInfo = indexInfos_5[_e];
					var sourceInfo = getApplicableIndexInfo(source, targetInfo.keyType);
					if (sourceInfo) {
						inferWithPriority(sourceInfo.type, targetInfo.type, priority);
					}
				}
			}
		}
		function isTypeOrBaseIdenticalTo(s, t) {
			return exactOptionalPropertyTypes && t === missingType ? s === t : (isTypeIdenticalTo(
				s,
				t,
			) || !!(t.flags & TypeFlags.String && s.flags & TypeFlags.StringLiteral || t.flags & TypeFlags.Number && s.flags & TypeFlags.NumberLiteral));
		}
		function isTypeCloselyMatchedBy(s, t) {
			return !!(s.flags & TypeFlags.Object && t.flags & TypeFlags.Object && s.symbol && s.symbol === t.symbol || s.aliasSymbol && s.aliasTypeArguments && s.aliasSymbol === t.aliasSymbol);
		}
		function hasPrimitiveConstraint(type) {
			var constraint = getConstraintOfTypeParameter(type);
			return !!constraint && maybeTypeOfKind(
				constraint.flags & TypeFlags.Conditional ? getDefaultConstraintOfConditionalType(
					constraint,
				) : constraint,
				TypeFlags.Primitive | TypeFlags.Index | TypeFlags.TemplateLiteral | TypeFlags.StringMapping,
			);
		}
		function isObjectLiteralType(type) {
			return !!(getObjectFlags(type) & ObjectFlags.ObjectLiteral);
		}
		function isObjectOrArrayLiteralType(type) {
			return !!(getObjectFlags(type) & (ObjectFlags.ObjectLiteral | ObjectFlags.ArrayLiteral));
		}
		function unionObjectAndArrayLiteralCandidates(candidates) {
			if (candidates.length > 1) {
				var objectLiterals = filter(candidates, isObjectOrArrayLiteralType);
				if (objectLiterals.length) {
					var literalsType = getUnionType(
						objectLiterals,
						UnionReduction.Subtype,
					);
					return concatenate(
						filter(
							candidates,
							function (t) {
								return !isObjectOrArrayLiteralType(t);
							},
						),
						[literalsType],
					);
				}
			}
			return candidates;
		}
		function getContravariantInference(inference) {
			return inference.priority & InferencePriority.PriorityImpliesCombination ? getIntersectionType(
				inference.contraCandidates,
			) : getCommonSubtype(inference.contraCandidates);
		}
		function getCovariantInference(inference, signature) {
			// Extract all object and array literal types and replace them with a single widened and normalized type.
			var candidates = unionObjectAndArrayLiteralCandidates(
				inference.candidates,
			);
			// We widen inferred literal types if
			// all inferences were made to top-level occurrences of the type parameter, and
			// the type parameter has no constraint or its constraint includes no primitive or literal types, and
			// the type parameter was fixed during inference or does not occur at top-level in the return type.
			var primitiveConstraint = hasPrimitiveConstraint(inference.typeParameter);
			var widenLiteralTypes = !primitiveConstraint && inference.topLevel && (inference.isFixed || !isTypeParameterAtTopLevel(
				getReturnTypeOfSignature(signature),
				inference.typeParameter,
			));
			var baseCandidates = primitiveConstraint ? sameMap(
				candidates,
				getRegularTypeOfLiteralType,
			) : widenLiteralTypes ? sameMap(candidates, getWidenedLiteralType) : candidates;
			// If all inferences were made from a position that implies a combined result, infer a union type.
			// Otherwise, infer a common supertype.
			var unwidenedType = inference.priority & InferencePriority.PriorityImpliesCombination ? getUnionType(
				baseCandidates,
				UnionReduction.Subtype,
			) : getCommonSupertype(baseCandidates);
			return getWidenedType(unwidenedType);
		}
		function getInferredType(context, index) {
			var inference = context.inferences[index];
			if (!inference.inferredType) {
				var inferredType = void 0;
				var signature = context.signature;
				if (signature) {
					var inferredCovariantType_1 = inference.candidates ? getCovariantInference(
						inference,
						signature,
					) : undefined;
					if (inference.contraCandidates) {
						// If we have both co- and contra-variant inferences, we prefer the contra-variant inference
						// unless the co-variant inference is a subtype of some contra-variant inference and not 'never'.
						inferredType = inferredCovariantType_1 && !(inferredCovariantType_1.flags & TypeFlags.Never) && some(
							inference.contraCandidates,
							function (t) {
								return isTypeSubtypeOf(inferredCovariantType_1, t);
							},
						) ? inferredCovariantType_1 : getContravariantInference(inference);
					} else if (inferredCovariantType_1) {
						inferredType = inferredCovariantType_1;
					} else if (context.flags & InferenceFlags.NoDefault) {
						// We use silentNeverType as the wildcard that signals no inferences.
						inferredType = silentNeverType;
					} else {
						// Infer either the default or the empty object type when no inferences were
						// made. It is important to remember that in this case, inference still
						// succeeds, meaning there is no error for not having inference candidates. An
						// inference error only occurs when there are *conflicting* candidates, i.e.
						// candidates with no common supertype.
						var defaultType = getDefaultFromTypeParameter(
							inference.typeParameter,
						);
						if (defaultType) {
							// Instantiate the default type. Any forward reference to a type
							// parameter should be instantiated to the empty object type.
							inferredType = instantiateType(
								defaultType,
								mergeTypeMappers(
									createBackreferenceMapper(context, index),
									context.nonFixingMapper,
								),
							);
						}
					}
				} else {
					inferredType = getTypeFromInference(inference);
				}
				inference.inferredType = inferredType || getDefaultTypeArgumentType(
					!!(context.flags & InferenceFlags.AnyDefault),
				);
				var constraint = getConstraintOfTypeParameter(inference.typeParameter);
				if (constraint) {
					var instantiatedConstraint = instantiateType(
						constraint,
						context.nonFixingMapper,
					);
					if (
						!inferredType || !context.compareTypes(
							inferredType,
							getTypeWithThisArgument(instantiatedConstraint, inferredType),
						)
					) {
						inference.inferredType = inferredType = instantiatedConstraint;
					}
				}
			}
			return inference.inferredType;
		}
		function getDefaultTypeArgumentType(isInJavaScriptFile) {
			return isInJavaScriptFile ? anyType : unknownType;
		}
		function getInferredTypes(context) {
			var result = [];
			for (var i = 0; i < context.inferences.length; i++) {
				result.push(getInferredType(context, i));
			}
			return result;
		}
		// EXPRESSION TYPE CHECKING
		function getCannotFindNameDiagnosticForName(node) {
			switch (node.escapedText) {
				case "document":
				case "console":
					return Diagnostics.Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_include_dom;
				case "$":
					return compilerOptions.types ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery_and_then_add_jquery_to_the_types_field_in_your_tsconfig : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery;
				case "describe":
				case "suite":
				case "it":
				case "test":
					return compilerOptions.types ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha_and_then_add_jest_or_mocha_to_the_types_field_in_your_tsconfig : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha;
				case "process":
				case "require":
				case "Buffer":
				case "module":
					return compilerOptions.types ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode_and_then_add_node_to_the_types_field_in_your_tsconfig : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode;
				case "Map":
				case "Set":
				case "Promise":
				case "Symbol":
				case "WeakMap":
				case "WeakSet":
				case "Iterator":
				case "AsyncIterator":
				case "SharedArrayBuffer":
				case "Atomics":
				case "AsyncIterable":
				case "AsyncIterableIterator":
				case "AsyncGenerator":
				case "AsyncGeneratorFunction":
				case "BigInt":
				case "Reflect":
				case "BigInt64Array":
				case "BigUint64Array":
					return Diagnostics.Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_1_or_later;
				case "await":
					if (isCallExpression(node.parent)) {
						return Diagnostics.Cannot_find_name_0_Did_you_mean_to_write_this_in_an_async_function;
					}
				// falls through
				default:
					if (node.parent.kind === SyntaxKind.ShorthandPropertyAssignment) {
						return Diagnostics.No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer;
					} else {
						return Diagnostics.Cannot_find_name_0;
					}
			}
		}
		function getResolvedSymbol(node) {
			var links = getNodeLinks(node);
			if (!links.resolvedSymbol) {
				links.resolvedSymbol = !nodeIsMissing(node) && resolveName(
					node,
					node.escapedText,
					SymbolFlags.Value | SymbolFlags.ExportValue,
					getCannotFindNameDiagnosticForName(node),
					node,
					!isWriteOnlyAccess(node),
					/*excludeGlobals*/ false,
				) || unknownSymbol;
			}
			return links.resolvedSymbol;
		}
		function isInTypeQuery(node) {
			// TypeScript 1.0 spec (April 2014): 3.6.3
			// A type query consists of the keyword typeof followed by an expression.
			// The expression is restricted to a single identifier or a sequence of identifiers separated by periods
			return !!findAncestor(
				node,
				function (n) {
					return n.kind === SyntaxKind.TypeQuery ? true : n.kind === SyntaxKind.Identifier || n.kind === SyntaxKind.QualifiedName ? false : "quit";
				},
			);
		}
		// Return the flow cache key for a "dotted name" (i.e. a sequence of identifiers
		// separated by dots). The key consists of the id of the symbol referenced by the
		// leftmost identifier followed by zero or more property names separated by dots.
		// The result is undefined if the reference isn't a dotted name.
		function getFlowCacheKey(node, declaredType, initialType, flowContainer) {
			switch (node.kind) {
				case SyntaxKind.Identifier:
					if (!isThisInTypeQuery(node)) {
						var symbol = getResolvedSymbol(node);
						return symbol !== unknownSymbol ? "".concat(
							flowContainer ? getNodeId(flowContainer) : "-1",
							"|",
						).concat(getTypeId(declaredType), "|").concat(
							getTypeId(initialType),
							"|",
						).concat(getSymbolId(symbol)) : undefined;
					}
				// falls through
				case SyntaxKind.ThisKeyword:
					return "0|".concat(
						flowContainer ? getNodeId(flowContainer) : "-1",
						"|",
					).concat(getTypeId(declaredType), "|").concat(getTypeId(initialType));
				case SyntaxKind.NonNullExpression:
				case SyntaxKind.ParenthesizedExpression:
					return getFlowCacheKey(
						node.expression,
						declaredType,
						initialType,
						flowContainer,
					);
				case SyntaxKind.QualifiedName:
					var left = getFlowCacheKey(
						node.left,
						declaredType,
						initialType,
						flowContainer,
					);
					return left && left + "." + node.right.escapedText;
				case SyntaxKind.PropertyAccessExpression:
				case SyntaxKind.ElementAccessExpression:
					var propName = getAccessedPropertyName(node);
					if (propName !== undefined) {
						var key = getFlowCacheKey(
							node.expression,
							declaredType,
							initialType,
							flowContainer,
						);
						return key && key + "." + propName;
					}
			}
			return undefined;
		}
		function isMatchingReference(source, target) {
			switch (target.kind) {
				case SyntaxKind.ParenthesizedExpression:
				case SyntaxKind.NonNullExpression:
					return isMatchingReference(source, target.expression);
				case SyntaxKind.BinaryExpression:
					return (isAssignmentExpression(target) && isMatchingReference(
						source,
						target.left,
					)) || (isBinaryExpression(target) && target.operatorToken.kind === SyntaxKind.CommaToken && isMatchingReference(
						source,
						target.right,
					));
			}
			switch (source.kind) {
				case SyntaxKind.MetaProperty:
					return target.kind === SyntaxKind.MetaProperty && source.keywordToken === target.keywordToken && source.name.escapedText === target.name.escapedText;
				case SyntaxKind.Identifier:
				case SyntaxKind.PrivateIdentifier:
					return isThisInTypeQuery(source) ? target.kind === SyntaxKind.ThisKeyword : target.kind === SyntaxKind.Identifier && getResolvedSymbol(
						source,
					) === getResolvedSymbol(target) || (target.kind === SyntaxKind.VariableDeclaration || target.kind === SyntaxKind.BindingElement) && getExportSymbolOfValueSymbolIfExported(
						getResolvedSymbol(source),
					) === getSymbolOfNode(target);
				case SyntaxKind.ThisKeyword:
					return target.kind === SyntaxKind.ThisKeyword;
				case SyntaxKind.SuperKeyword:
					return target.kind === SyntaxKind.SuperKeyword;
				case SyntaxKind.NonNullExpression:
				case SyntaxKind.ParenthesizedExpression:
					return isMatchingReference(source.expression, target);
				case SyntaxKind.PropertyAccessExpression:
				case SyntaxKind.ElementAccessExpression:
					return isAccessExpression(target) && getAccessedPropertyName(source) === getAccessedPropertyName(
						target,
					) && isMatchingReference(source.expression, target.expression);
				case SyntaxKind.QualifiedName:
					return isAccessExpression(target) && source.right.escapedText === getAccessedPropertyName(
						target,
					) && isMatchingReference(source.left, target.expression);
				case SyntaxKind.BinaryExpression:
					return (isBinaryExpression(source) && source.operatorToken.kind === SyntaxKind.CommaToken && isMatchingReference(
						source.right,
						target,
					));
			}
			return false;
		}
		function getAccessedPropertyName(access) {
			var propertyName;
			return access.kind === SyntaxKind.PropertyAccessExpression ? access.name.escapedText : access.kind === SyntaxKind.ElementAccessExpression && isStringOrNumericLiteralLike(
				access.argumentExpression,
			) ? escapeLeadingUnderscores(access.argumentExpression.text) : access.kind === SyntaxKind.BindingElement && (propertyName = getDestructuringPropertyName(
				access,
			)) ? escapeLeadingUnderscores(propertyName) : access.kind === SyntaxKind.Parameter ? ("" + access.parent.parameters.indexOf(
				access,
			)) : undefined;
		}
		function containsMatchingReference(source, target) {
			while (isAccessExpression(source)) {
				source = source.expression;
				if (isMatchingReference(source, target)) {
					return true;
				}
			}
			return false;
		}
		function optionalChainContainsReference(source, target) {
			while (isOptionalChain(source)) {
				source = source.expression;
				if (isMatchingReference(source, target)) {
					return true;
				}
			}
			return false;
		}
		function isDiscriminantProperty(type, name) {
			if (type && type.flags & TypeFlags.Union) {
				var prop = getUnionOrIntersectionProperty(type, name);
				if (prop && getCheckFlags(prop) & CheckFlags.SyntheticProperty) {
					if (prop.isDiscriminantProperty === undefined) {
						prop.isDiscriminantProperty = (prop.checkFlags & CheckFlags.Discriminant) === CheckFlags.Discriminant && !isGenericType(
							getTypeOfSymbol(prop),
						);
					}
					return !!prop.isDiscriminantProperty;
				}
			}
			return false;
		}
		function findDiscriminantProperties(sourceProperties, target) {
			var result;
			for (
				var _i = 0, sourceProperties_2 = sourceProperties;
				_i < sourceProperties_2.length;
				_i++
			) {
				var sourceProperty = sourceProperties_2[_i];
				if (isDiscriminantProperty(target, sourceProperty.escapedName)) {
					if (result) {
						result.push(sourceProperty);
						continue;
					}
					result = [sourceProperty];
				}
			}
			return result;
		}
		// Given a set of constituent types and a property name, create and return a map keyed by the literal
		// types of the property by that name in each constituent type. No map is returned if some key property
		// has a non-literal type or if less than 10 or less than 50% of the constituents have a unique key.
		// Entries with duplicate keys have unknownType as the value.
		function mapTypesByKeyProperty(types, name) {
			var map = new Map();
			var count = 0;
			var _loop_16 = function (type) {
				if (
					type.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.InstantiableNonPrimitive)
				) {
					var discriminant = getTypeOfPropertyOfType(type, name);
					if (discriminant) {
						if (!isLiteralType(discriminant)) {
							return { value: undefined };
						}
						var duplicate_1 = false;
						forEachType(
							discriminant,
							function (t) {
								var id = getTypeId(getRegularTypeOfLiteralType(t));
								var existing = map.get(id);
								if (!existing) {
									map.set(id, type);
								} else if (existing !== unknownType) {
									map.set(id, unknownType);
									duplicate_1 = true;
								}
							},
						);
						if (!duplicate_1) count++;
					}
				}
			};
			for (var _i = 0, types_16 = types; _i < types_16.length; _i++) {
				var type = types_16[_i];
				var state_7 = _loop_16(type);
				if (typeof state_7 === "object") return state_7.value;
			}
			return count >= 10 && count * 2 >= types.length ? map : undefined;
		}
		// Return the name of a discriminant property for which it was possible and feasible to construct a map of
		// constituent types keyed by the literal types of the property by that name in each constituent type.
		function getKeyPropertyName(unionType) {
			var types = unionType.types;
			// We only construct maps for unions with many non-primitive constituents.
			if (
				types.length < 10 || getObjectFlags(unionType) & ObjectFlags.PrimitiveUnion || countWhere(
					types,
					function (t) {
						return !!(t.flags & (TypeFlags.Object | TypeFlags.InstantiableNonPrimitive));
					},
				) < 10
			) {
				return undefined;
			}
			if (unionType.keyPropertyName === undefined) {
				// The candidate key property name is the name of the first property with a unit type in one of the
				// constituent types.
				var keyPropertyName = forEach(
					types,
					function (t) {
						return t.flags & (TypeFlags.Object | TypeFlags.InstantiableNonPrimitive) ? forEach(
							getPropertiesOfType(t),
							function (p) {
								return isUnitType(getTypeOfSymbol(p)) ? p.escapedName : undefined;
							},
						) : undefined;
					},
				);
				var mapByKeyProperty = keyPropertyName && mapTypesByKeyProperty(
					types,
					keyPropertyName,
				);
				unionType.keyPropertyName = mapByKeyProperty ? keyPropertyName : "";
				unionType.constituentMap = mapByKeyProperty;
			}
			return unionType.keyPropertyName.length ? unionType.keyPropertyName : undefined;
		}
		// Given a union type for which getKeyPropertyName returned a non-undefined result, return the constituent
		// that corresponds to the given key type for that property name.
		function getConstituentTypeForKeyType(unionType, keyType) {
			var _a;
			var result = (_a = unionType.constituentMap) === null || _a === void 0 ? void 0 : _a.get(
				getTypeId(getRegularTypeOfLiteralType(keyType)),
			);
			return result !== unknownType ? result : undefined;
		}
		function getMatchingUnionConstituentForType(unionType, type) {
			var keyPropertyName = getKeyPropertyName(unionType);
			var propType = keyPropertyName && getTypeOfPropertyOfType(
				type,
				keyPropertyName,
			);
			return propType && getConstituentTypeForKeyType(unionType, propType);
		}
		function getMatchingUnionConstituentForObjectLiteral(unionType, node) {
			var keyPropertyName = getKeyPropertyName(unionType);
			var propNode = keyPropertyName && find(
				node.properties,
				function (p) {
					return p.symbol && p.kind === SyntaxKind.PropertyAssignment && p.symbol.escapedName === keyPropertyName && isPossiblyDiscriminantValue(
						p.initializer,
					);
				},
			);
			var propType = propNode && getContextFreeTypeOfExpression(
				propNode.initializer,
			);
			return propType && getConstituentTypeForKeyType(unionType, propType);
		}
		function isOrContainsMatchingReference(source, target) {
			return isMatchingReference(source, target) || containsMatchingReference(
				source,
				target,
			);
		}
		function hasMatchingArgument(expression, reference) {
			if (expression.arguments) {
				for (var _i = 0, _a = expression.arguments; _i < _a.length; _i++) {
					var argument = _a[_i];
					if (isOrContainsMatchingReference(reference, argument)) {
						return true;
					}
				}
			}
			if (
				expression.expression.kind === SyntaxKind.PropertyAccessExpression && isOrContainsMatchingReference(
					reference,
					expression.expression.expression,
				)
			) {
				return true;
			}
			return false;
		}
		function getFlowNodeId(flow) {
			if (!flow.id || flow.id < 0) {
				flow.id = nextFlowId;
				nextFlowId++;
			}
			return flow.id;
		}
		function typeMaybeAssignableTo(source, target) {
			if (!(source.flags & TypeFlags.Union)) {
				return isTypeAssignableTo(source, target);
			}
			for (var _i = 0, _a = source.types; _i < _a.length; _i++) {
				var t = _a[_i];
				if (isTypeAssignableTo(t, target)) {
					return true;
				}
			}
			return false;
		}
		// Remove those constituent types of declaredType to which no constituent type of assignedType is assignable.
		// For example, when a variable of type number | string | boolean is assigned a value of type number | boolean,
		// we remove type string.
		function getAssignmentReducedType(declaredType, assignedType) {
			if (declaredType !== assignedType) {
				if (assignedType.flags & TypeFlags.Never) {
					return assignedType;
				}
				var reducedType = filterType(
					declaredType,
					function (t) {
						return typeMaybeAssignableTo(assignedType, t);
					},
				);
				if (
					assignedType.flags & TypeFlags.BooleanLiteral && isFreshLiteralType(
						assignedType,
					)
				) {
					reducedType = mapType(reducedType, getFreshTypeOfLiteralType); // Ensure that if the assignment is a fresh type, that we narrow to fresh types
				}
				// Our crude heuristic produces an invalid result in some cases: see GH#26130.
				// For now, when that happens, we give up and don't narrow at all.  (This also
				// means we'll never narrow for erroneous assignments where the assigned type
				// is not assignable to the declared type.)
				if (isTypeAssignableTo(assignedType, reducedType)) {
					return reducedType;
				}
			}
			return declaredType;
		}
		function isFunctionObjectType(type) {
			// We do a quick check for a "bind" property before performing the more expensive subtype
			// check. This gives us a quicker out in the common case where an object type is not a function.
			var resolved = resolveStructuredTypeMembers(type);
			return !!(resolved.callSignatures.length || resolved.constructSignatures.length || resolved.members.get(
				"bind",
			) && isTypeSubtypeOf(type, globalFunctionType));
		}
		function getTypeFacts(type, ignoreObjects) {
			if (ignoreObjects === void 0) {
				ignoreObjects = false;
			}
			var flags = type.flags;
			if (flags & TypeFlags.String) {
				return strictNullChecks ? 16317953 : 16776705; /* StringStrictFacts */ /* StringFacts */
			}
			if (flags & TypeFlags.StringLiteral) {
				var isEmpty = type.value === "";
				return strictNullChecks ? isEmpty ? 12123649 : 7929345 : isEmpty ? 12582401 : 16776705; /* EmptyStringStrictFacts */ /* NonEmptyStringStrictFacts */ /* EmptyStringFacts */ /* NonEmptyStringFacts */
			}
			if (flags & (TypeFlags.Number | TypeFlags.Enum)) {
				return strictNullChecks ? 16317698 : 16776450; /* NumberStrictFacts */ /* NumberFacts */
			}
			if (flags & TypeFlags.NumberLiteral) {
				var isZero = type.value === 0;
				return strictNullChecks ? isZero ? 12123394 : 7929090 : isZero ? 12582146 : 16776450; /* ZeroNumberStrictFacts */ /* NonZeroNumberStrictFacts */ /* ZeroNumberFacts */ /* NonZeroNumberFacts */
			}
			if (flags & TypeFlags.BigInt) {
				return strictNullChecks ? 16317188 : 16775940; /* BigIntStrictFacts */ /* BigIntFacts */
			}
			if (flags & TypeFlags.BigIntLiteral) {
				var isZero = isZeroBigInt(type);
				return strictNullChecks ? isZero ? 12122884 : 7928580 : isZero ? 12581636 : 16775940; /* ZeroBigIntStrictFacts */ /* NonZeroBigIntStrictFacts */ /* ZeroBigIntFacts */ /* NonZeroBigIntFacts */
			}
			if (flags & TypeFlags.Boolean) {
				return strictNullChecks ? 16316168 : 16774920; /* BooleanStrictFacts */ /* BooleanFacts */
			}
			if (flags & TypeFlags.BooleanLike) {
				return strictNullChecks ? (type === falseType || type === regularFalseType) ? 12121864 : 7927560 : (type === falseType || type === regularFalseType) ? 12580616 : 16774920; /* FalseStrictFacts */ /* TrueStrictFacts */ /* FalseFacts */ /* TrueFacts */
			}
			if (flags & TypeFlags.Object && !ignoreObjects) {
				return getObjectFlags(type) & ObjectFlags.Anonymous && isEmptyObjectType(
					type,
				) ? strictNullChecks ? 16318463 : 16777215 : isFunctionObjectType(type) ? strictNullChecks ? 7880640 : 16728000 : strictNullChecks ? 7888800 : 16736160; /* EmptyObjectStrictFacts */ /* EmptyObjectFacts */ /* FunctionStrictFacts */ /* FunctionFacts */ /* ObjectStrictFacts */ /* ObjectFacts */
			}
			if (flags & (TypeFlags.Void | TypeFlags.Undefined)) {
				return 9830144; /* UndefinedFacts */
			}
			if (flags & TypeFlags.Null) {
				return 9363232; /* NullFacts */
			}
			if (flags & TypeFlags.ESSymbolLike) {
				return strictNullChecks ? 7925520 : 16772880; /* SymbolStrictFacts */ /* SymbolFacts */
			}
			if (flags & TypeFlags.NonPrimitive) {
				return strictNullChecks ? 7888800 : 16736160; /* ObjectStrictFacts */ /* ObjectFacts */
			}
			if (flags & TypeFlags.Never) {
				return 0; /* None */
			}
			if (flags & TypeFlags.Instantiable) {
				return !isPatternLiteralType(type) ? getTypeFacts(
					getBaseConstraintOfType(type) || unknownType,
					ignoreObjects,
				) : strictNullChecks ? 7929345 : 16776705; /* NonEmptyStringStrictFacts */ /* NonEmptyStringFacts */
			}
			if (flags & TypeFlags.Union) {
				return reduceLeft(
					type.types,
					function (facts, t) {
						return facts | getTypeFacts(t, ignoreObjects);
					},
					0, /* None */
				);
			}
			if (flags & TypeFlags.Intersection) {
				// When an intersection contains a primitive type we ignore object type constituents as they are
				// presumably type tags. For example, in string & { __kind__: "name" } we ignore the object type.
				ignoreObjects || (ignoreObjects = maybeTypeOfKind(
					type,
					TypeFlags.Primitive,
				));
				return reduceLeft(
					type.types,
					function (facts, t) {
						return facts & getTypeFacts(t, ignoreObjects);
					},
					16777215, /* All */
				);
			}
			return 16777215; /* All */
		}
		function getTypeWithFacts(type, include) {
			return filterType(
				type,
				function (t) {
					return (getTypeFacts(t) & include) !== 0;
				},
			);
		}
		function getTypeWithDefault(type, defaultExpression) {
			return defaultExpression ? getUnionType(
				[getNonUndefinedType(type), getTypeOfExpression(defaultExpression)],
			) : type;
		}
		function getTypeOfDestructuredProperty(type, name) {
			var _a;
			var nameType = getLiteralTypeFromPropertyName(name);
			if (!isTypeUsableAsPropertyName(nameType)) return errorType;
			var text = getPropertyNameFromType(nameType);
			return getTypeOfPropertyOfType(type, text) || includeUndefinedInIndexSignature(
				(_a = getApplicableIndexInfoForName(type, text)) === null || _a === void 0 ? void 0 : _a.type,
			) || errorType;
		}
		function getTypeOfDestructuredArrayElement(type, index) {
			return everyType(type, isTupleLikeType) && getTupleElementType(
				type,
				index,
			) || includeUndefinedInIndexSignature(
				checkIteratedTypeOrElementType(
					65, /* Destructuring */
					type,
					undefinedType, /*errorNode*/
					undefined,
				),
			) || errorType;
		}
		function includeUndefinedInIndexSignature(type) {
			if (!type) return type;
			return compilerOptions.noUncheckedIndexedAccess ? getUnionType(
				[type, undefinedType],
			) : type;
		}
		function getTypeOfDestructuredSpreadExpression(type) {
			return createArrayType(
				checkIteratedTypeOrElementType(
					65, /* Destructuring */
					type,
					undefinedType, /*errorNode*/
					undefined,
				) || errorType,
			);
		}
		function getAssignedTypeOfBinaryExpression(node) {
			var isDestructuringDefaultAssignment = node.parent.kind === SyntaxKind.ArrayLiteralExpression && isDestructuringAssignmentTarget(
				node.parent,
			) || node.parent.kind === SyntaxKind.PropertyAssignment && isDestructuringAssignmentTarget(
				node.parent.parent,
			);
			return isDestructuringDefaultAssignment ? getTypeWithDefault(
				getAssignedType(node),
				node.right,
			) : getTypeOfExpression(node.right);
		}
		function isDestructuringAssignmentTarget(parent) {
			return parent.parent.kind === SyntaxKind.BinaryExpression && parent.parent.left === parent || parent.parent.kind === SyntaxKind.ForOfStatement && parent.parent.initializer === parent;
		}
		function getAssignedTypeOfArrayLiteralElement(node, element) {
			return getTypeOfDestructuredArrayElement(
				getAssignedType(node),
				node.elements.indexOf(element),
			);
		}
		function getAssignedTypeOfSpreadExpression(node) {
			return getTypeOfDestructuredSpreadExpression(getAssignedType(node.parent));
		}
		function getAssignedTypeOfPropertyAssignment(node) {
			return getTypeOfDestructuredProperty(
				getAssignedType(node.parent),
				node.name,
			);
		}
		function getAssignedTypeOfShorthandPropertyAssignment(node) {
			return getTypeWithDefault(
				getAssignedTypeOfPropertyAssignment(node),
				node.objectAssignmentInitializer,
			);
		}
		function getAssignedType(node) {
			var parent = node.parent;
			switch (parent.kind) {
				case SyntaxKind.ForInStatement:
					return stringType;
				case SyntaxKind.ForOfStatement:
					return checkRightHandSideOfForOf(parent) || errorType;
				case SyntaxKind.BinaryExpression:
					return getAssignedTypeOfBinaryExpression(parent);
				case SyntaxKind.DeleteExpression:
					return undefinedType;
				case SyntaxKind.ArrayLiteralExpression:
					return getAssignedTypeOfArrayLiteralElement(parent, node);
				case SyntaxKind.SpreadElement:
					return getAssignedTypeOfSpreadExpression(parent);
				case SyntaxKind.PropertyAssignment:
					return getAssignedTypeOfPropertyAssignment(parent);
				case SyntaxKind.ShorthandPropertyAssignment:
					return getAssignedTypeOfShorthandPropertyAssignment(parent);
			}
			return errorType;
		}
		function getInitialTypeOfBindingElement(node) {
			var pattern = node.parent;
			var parentType = getInitialType(pattern.parent);
			var type = pattern.kind === SyntaxKind.ObjectBindingPattern ? getTypeOfDestructuredProperty(
				parentType,
				node.propertyName || node.name,
			) : !node.dotDotDotToken ? getTypeOfDestructuredArrayElement(
				parentType,
				pattern.elements.indexOf(node),
			) : getTypeOfDestructuredSpreadExpression(parentType);
			return getTypeWithDefault(type, node.initializer);
		}
		function getTypeOfInitializer(node) {
			// Return the cached type if one is available. If the type of the variable was inferred
			// from its initializer, we'll already have cached the type. Otherwise we compute it now
			// without caching such that transient types are reflected.
			var links = getNodeLinks(node);
			return links.resolvedType || getTypeOfExpression(node);
		}
		function getInitialTypeOfVariableDeclaration(node) {
			if (node.initializer) {
				return getTypeOfInitializer(node.initializer);
			}
			if (node.parent.parent.kind === SyntaxKind.ForInStatement) {
				return stringType;
			}
			if (node.parent.parent.kind === SyntaxKind.ForOfStatement) {
				return checkRightHandSideOfForOf(node.parent.parent) || errorType;
			}
			return errorType;
		}
		function getInitialType(node) {
			return node.kind === SyntaxKind.VariableDeclaration ? getInitialTypeOfVariableDeclaration(
				node,
			) : getInitialTypeOfBindingElement(node);
		}
		function isEmptyArrayAssignment(node) {
			return node.kind === SyntaxKind.VariableDeclaration && node.initializer && isEmptyArrayLiteral(
				node.initializer,
			) || node.kind !== SyntaxKind.BindingElement && node.parent.kind === SyntaxKind.BinaryExpression && isEmptyArrayLiteral(
				node.parent.right,
			);
		}
		function getReferenceCandidate(node) {
			switch (node.kind) {
				case SyntaxKind.ParenthesizedExpression:
					return getReferenceCandidate(node.expression);
				case SyntaxKind.BinaryExpression:
					switch (node.operatorToken.kind) {
						case SyntaxKind.EqualsToken:
						case SyntaxKind.BarBarEqualsToken:
						case SyntaxKind.AmpersandAmpersandEqualsToken:
						case SyntaxKind.QuestionQuestionEqualsToken:
							return getReferenceCandidate(node.left);
						case SyntaxKind.CommaToken:
							return getReferenceCandidate(node.right);
					}
			}
			return node;
		}
		function getReferenceRoot(node) {
			var parent = node.parent;
			return parent.kind === SyntaxKind.ParenthesizedExpression || parent.kind === SyntaxKind.BinaryExpression && parent.operatorToken.kind === SyntaxKind.EqualsToken && parent.left === node || parent.kind === SyntaxKind.BinaryExpression && parent.operatorToken.kind === SyntaxKind.CommaToken && parent.right === node ? getReferenceRoot(
				parent,
			) : node;
		}
		function getTypeOfSwitchClause(clause) {
			if (clause.kind === SyntaxKind.CaseClause) {
				return getRegularTypeOfLiteralType(
					getTypeOfExpression(clause.expression),
				);
			}
			return neverType;
		}
		function getSwitchClauseTypes(switchStatement) {
			var links = getNodeLinks(switchStatement);
			if (!links.switchTypes) {
				links.switchTypes = [];
				for (
					var _i = 0, _a = switchStatement.caseBlock.clauses;
					_i < _a.length;
					_i++
				) {
					var clause = _a[_i];
					links.switchTypes.push(getTypeOfSwitchClause(clause));
				}
			}
			return links.switchTypes;
		}
		function getSwitchClauseTypeOfWitnesses(switchStatement, retainDefault) {
			var witnesses = [];
			for (
				var _i = 0, _a = switchStatement.caseBlock.clauses;
				_i < _a.length;
				_i++
			) {
				var clause = _a[_i];
				if (clause.kind === SyntaxKind.CaseClause) {
					if (isStringLiteralLike(clause.expression)) {
						witnesses.push(clause.expression.text);
						continue;
					}
					return emptyArray;
				}
				if (retainDefault) witnesses.push(
					undefined, /*explicitDefaultStatement*/
				);
			}
			return witnesses;
		}
		function eachTypeContainedIn(source, types) {
			return source.flags & TypeFlags.Union ? !forEach(
				source.types,
				function (t) {
					return !contains(types, t);
				},
			) : contains(types, source);
		}
		function isTypeSubsetOf(source, target) {
			return source === target || target.flags & TypeFlags.Union && isTypeSubsetOfUnion(
				source,
				target,
			);
		}
		function isTypeSubsetOfUnion(source, target) {
			if (source.flags & TypeFlags.Union) {
				for (var _i = 0, _a = source.types; _i < _a.length; _i++) {
					var t = _a[_i];
					if (!containsType(target.types, t)) {
						return false;
					}
				}
				return true;
			}
			if (
				source.flags & TypeFlags.EnumLiteral && getBaseTypeOfEnumLiteralType(
					source,
				) === target
			) {
				return true;
			}
			return containsType(target.types, source);
		}
		function forEachType(type, f) {
			return type.flags & TypeFlags.Union ? forEach(type.types, f) : f(type);
		}
		function someType(type, f) {
			return type.flags & TypeFlags.Union ? some(type.types, f) : f(type);
		}
		function everyType(type, f) {
			return type.flags & TypeFlags.Union ? every(type.types, f) : f(type);
		}
		function everyContainedType(type, f) {
			return type.flags & TypeFlags.UnionOrIntersection ? every(type.types, f) : f(
				type,
			);
		}
		function filterType(type, f) {
			if (type.flags & TypeFlags.Union) {
				var types = type.types;
				var filtered = filter(types, f);
				if (filtered === types) {
					return type;
				}
				var origin_4 = type.origin;
				var newOrigin = void 0;
				if (origin_4 && origin_4.flags & TypeFlags.Union) {
					// If the origin type is a (denormalized) union type, filter its non-union constituents. If that ends
					// up removing a smaller number of types than in the normalized constituent set (meaning some of the
					// filtered types are within nested unions in the origin), then we can't construct a new origin type.
					// Otherwise, if we have exactly one type left in the origin set, return that as the filtered type.
					// Otherwise, construct a new filtered origin type.
					var originTypes = origin_4.types;
					var originFiltered = filter(
						originTypes,
						function (t) {
							return !!(t.flags & TypeFlags.Union) || f(t);
						},
					);
					if (
						originTypes.length - originFiltered.length === types.length - filtered.length
					) {
						if (originFiltered.length === 1) {
							return originFiltered[0];
						}
						newOrigin = createOriginUnionOrIntersectionType(
							TypeFlags.Union,
							originFiltered,
						);
					}
				}
				return getUnionTypeFromSortedList(
					filtered,
					type.objectFlags, /*aliasSymbol*/
					undefined, /*aliasTypeArguments*/
					undefined,
					newOrigin,
				);
			}
			return type.flags & TypeFlags.Never || f(type) ? type : neverType;
		}
		function removeType(type, targetType) {
			return filterType(
				type,
				function (t) {
					return t !== targetType;
				},
			);
		}
		function countTypes(type) {
			return type.flags & TypeFlags.Union ? type.types.length : 1;
		}
		function mapType(type, mapper, noReductions) {
			if (type.flags & TypeFlags.Never) {
				return type;
			}
			if (!(type.flags & TypeFlags.Union)) {
				return mapper(type);
			}
			var origin = type.origin;
			var types = origin && origin.flags & TypeFlags.Union ? origin.types : type.types;
			var mappedTypes;
			var changed = false;
			for (var _i = 0, types_17 = types; _i < types_17.length; _i++) {
				var t = types_17[_i];
				var mapped = t.flags & TypeFlags.Union ? mapType(
					t,
					mapper,
					noReductions,
				) : mapper(t);
				changed || (changed = t !== mapped);
				if (mapped) {
					if (!mappedTypes) {
						mappedTypes = [mapped];
					} else {
						mappedTypes.push(mapped);
					}
				}
			}
			return changed ? mappedTypes && getUnionType(
				mappedTypes,
				noReductions ? UnionReduction.None : UnionReduction.Literal,
			) : type;
		}
		function mapTypeWithAlias(type, mapper, aliasSymbol, aliasTypeArguments) {
			return type.flags & TypeFlags.Union && aliasSymbol ? getUnionType(
				map(type.types, mapper),
				UnionReduction.Literal,
				aliasSymbol,
				aliasTypeArguments,
			) : mapType(type, mapper);
		}
		function getConstituentCount(type) {
			return type.flags & TypeFlags.Union ? type.types.length : 1;
		}
		function extractTypesOfKind(type, kind) {
			return filterType(
				type,
				function (t) {
					return (t.flags & kind) !== 0;
				},
			);
		}
		// Return a new type in which occurrences of the string, number and bigint primitives and placeholder template
		// literal types in typeWithPrimitives have been replaced with occurrences of compatible and more specific types
		// from typeWithLiterals. This is essentially a limited form of intersection between the two types. We avoid a
		// true intersection because it is more costly and, when applied to union types, generates a large number of
		// types we don't actually care about.
		function replacePrimitivesWithLiterals(typeWithPrimitives, typeWithLiterals) {
			if (
				maybeTypeOfKind(
					typeWithPrimitives,
					TypeFlags.String | TypeFlags.TemplateLiteral | TypeFlags.Number | TypeFlags.BigInt,
				) && maybeTypeOfKind(
					typeWithLiterals,
					TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping | TypeFlags.NumberLiteral | TypeFlags.BigIntLiteral,
				)
			) {
				return mapType(
					typeWithPrimitives,
					function (t) {
						return t.flags & TypeFlags.String ? extractTypesOfKind(
							typeWithLiterals,
							TypeFlags.String | TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping,
						) : isPatternLiteralType(t) && !maybeTypeOfKind(
							typeWithLiterals,
							TypeFlags.String | TypeFlags.TemplateLiteral | TypeFlags.StringMapping,
						) ? extractTypesOfKind(typeWithLiterals, TypeFlags.StringLiteral) : t.flags & TypeFlags.Number ? extractTypesOfKind(
							typeWithLiterals,
							TypeFlags.Number | TypeFlags.NumberLiteral,
						) : t.flags & TypeFlags.BigInt ? extractTypesOfKind(
							typeWithLiterals,
							TypeFlags.BigInt | TypeFlags.BigIntLiteral,
						) : t;
					},
				);
			}
			return typeWithPrimitives;
		}
		function isIncomplete(flowType) {
			return flowType.flags === 0;
		}
		function getTypeFromFlowType(flowType) {
			return flowType.flags === 0 ? flowType.type : flowType;
		}
		function createFlowType(type, incomplete) {
			return incomplete ? {
				flags: 0,
				type: type.flags & TypeFlags.Never ? silentNeverType : type,
			} : type;
		}
		// An evolving array type tracks the element types that have so far been seen in an
		// 'x.push(value)' or 'x[n] = value' operation along the control flow graph. Evolving
		// array types are ultimately converted into manifest array types (using getFinalArrayType)
		// and never escape the getFlowTypeOfReference function.
		function createEvolvingArrayType(elementType) {
			var result = createObjectType(ObjectFlags.EvolvingArray);
			result.elementType = elementType;
			return result;
		}
		function getEvolvingArrayType(elementType) {
			return evolvingArrayTypes[elementType.id] || (evolvingArrayTypes[elementType.id] = createEvolvingArrayType(
				elementType,
			));
		}
		// When adding evolving array element types we do not perform subtype reduction. Instead,
		// we defer subtype reduction until the evolving array type is finalized into a manifest
		// array type.
		function addEvolvingArrayElementType(evolvingArrayType, node) {
			var elementType = getRegularTypeOfObjectLiteral(
				getBaseTypeOfLiteralType(getContextFreeTypeOfExpression(node)),
			);
			return isTypeSubsetOf(elementType, evolvingArrayType.elementType) ? evolvingArrayType : getEvolvingArrayType(
				getUnionType([evolvingArrayType.elementType, elementType]),
			);
		}
		function createFinalArrayType(elementType) {
			return elementType.flags & TypeFlags.Never ? autoArrayType : createArrayType(
				elementType.flags & TypeFlags.Union ? getUnionType(
					elementType.types,
					UnionReduction.Subtype,
				) : elementType,
			);
		}
		// We perform subtype reduction upon obtaining the final array type from an evolving array type.
		function getFinalArrayType(evolvingArrayType) {
			return evolvingArrayType.finalArrayType || (evolvingArrayType.finalArrayType = createFinalArrayType(
				evolvingArrayType.elementType,
			));
		}
		function finalizeEvolvingArrayType(type) {
			return getObjectFlags(type) & ObjectFlags.EvolvingArray ? getFinalArrayType(
				type,
			) : type;
		}
		function getElementTypeOfEvolvingArrayType(type) {
			return getObjectFlags(type) & ObjectFlags.EvolvingArray ? type.elementType : neverType;
		}
		function isEvolvingArrayTypeList(types) {
			var hasEvolvingArrayType = false;
			for (var _i = 0, types_18 = types; _i < types_18.length; _i++) {
				var t = types_18[_i];
				if (!(t.flags & TypeFlags.Never)) {
					if (!(getObjectFlags(t) & ObjectFlags.EvolvingArray)) {
						return false;
					}
					hasEvolvingArrayType = true;
				}
			}
			return hasEvolvingArrayType;
		}
		// Return true if the given node is 'x' in an 'x.length', x.push(value)', 'x.unshift(value)' or
		// 'x[n] = value' operation, where 'n' is an expression of type any, undefined, or a number-like type.
		function isEvolvingArrayOperationTarget(node) {
			var root = getReferenceRoot(node);
			var parent = root.parent;
			var isLengthPushOrUnshift = isPropertyAccessExpression(parent) && (parent.name.escapedText === "length" || parent.parent.kind === SyntaxKind.CallExpression && isIdentifier(
				parent.name,
			) && isPushOrUnshiftIdentifier(parent.name));
			var isElementAssignment = parent.kind === SyntaxKind.ElementAccessExpression && parent.expression === root && parent.parent.kind === SyntaxKind.BinaryExpression && parent.parent.operatorToken.kind === SyntaxKind.EqualsToken && parent.parent.left === parent && !isAssignmentTarget(
				parent.parent,
			) && isTypeAssignableToKind(
				getTypeOfExpression(parent.argumentExpression),
				TypeFlags.NumberLike,
			);
			return isLengthPushOrUnshift || isElementAssignment;
		}
		function isDeclarationWithExplicitTypeAnnotation(node) {
			return (isVariableDeclaration(node) || isPropertyDeclaration(node) || isPropertySignature(
				node,
			) || isParameter(node)) && !!(getEffectiveTypeAnnotationNode(node) || isInJSFile(
				node,
			) && hasInitializer(node) && node.initializer && isFunctionExpressionOrArrowFunction(
				node.initializer,
			) && getEffectiveReturnTypeNode(node.initializer));
		}
		function getExplicitTypeOfSymbol(symbol, diagnostic) {
			if (
				symbol.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.ValueModule)
			) {
				return getTypeOfSymbol(symbol);
			}
			if (symbol.flags & (SymbolFlags.Variable | SymbolFlags.Property)) {
				if (getCheckFlags(symbol) & CheckFlags.Mapped) {
					var origin_5 = symbol.syntheticOrigin;
					if (origin_5 && getExplicitTypeOfSymbol(origin_5)) {
						return getTypeOfSymbol(symbol);
					}
				}
				var declaration = symbol.valueDeclaration;
				if (declaration) {
					if (isDeclarationWithExplicitTypeAnnotation(declaration)) {
						return getTypeOfSymbol(symbol);
					}
					if (
						isVariableDeclaration(declaration) && declaration.parent.parent.kind === SyntaxKind.ForOfStatement
					) {
						var statement = declaration.parent.parent;
						var expressionType = getTypeOfDottedName(
							statement.expression, /*diagnostic*/
							undefined,
						);
						if (expressionType) {
							var use = statement.awaitModifier ? 15 : 13; /* ForAwaitOf */ /* ForOf */
							return checkIteratedTypeOrElementType(
								use,
								expressionType,
								undefinedType, /*errorNode*/
								undefined,
							);
						}
					}
					if (diagnostic) {
						addRelatedInfo(
							diagnostic,
							createDiagnosticForNode(
								declaration,
								Diagnostics._0_needs_an_explicit_type_annotation,
								symbolToString(symbol),
							),
						);
					}
				}
			}
		}
		// We require the dotted function name in an assertion expression to be comprised of identifiers
		// that reference function, method, class or value module symbols; or variable, property or
		// parameter symbols with declarations that have explicit type annotations. Such references are
		// resolvable with no possibility of triggering circularities in control flow analysis.
		function getTypeOfDottedName(node, diagnostic) {
			if (!(node.flags & NodeFlags.InWithStatement)) {
				switch (node.kind) {
					case SyntaxKind.Identifier:
						var symbol = getExportSymbolOfValueSymbolIfExported(
							getResolvedSymbol(node),
						);
						return getExplicitTypeOfSymbol(
							symbol.flags & SymbolFlags.Alias ? resolveAlias(symbol) : symbol,
							diagnostic,
						);
					case SyntaxKind.ThisKeyword:
						return getExplicitThisType(node);
					case SyntaxKind.SuperKeyword:
						return checkSuperExpression(node);
					case SyntaxKind.PropertyAccessExpression:
						{
							var type = getTypeOfDottedName(node.expression, diagnostic);
							if (type) {
								var name_18 = node.name;
								var prop = void 0;
								if (isPrivateIdentifier(name_18)) {
									if (!type.symbol) {
										return undefined;
									}
									prop = getPropertyOfType(
										type,
										getSymbolNameForPrivateIdentifier(
											type.symbol,
											name_18.escapedText,
										),
									);
								} else {
									prop = getPropertyOfType(type, name_18.escapedText);
								}
								return prop && getExplicitTypeOfSymbol(prop, diagnostic);
							}
							return undefined;
						}
					case SyntaxKind.ParenthesizedExpression:
						return getTypeOfDottedName(node.expression, diagnostic);
				}
			}
		}
		function getEffectsSignature(node) {
			var links = getNodeLinks(node);
			var signature = links.effectsSignature;
			if (signature === undefined) {
				// A call expression parented by an expression statement is a potential assertion. Other call
				// expressions are potential type predicate function calls. In order to avoid triggering
				// circularities in control flow analysis, we use getTypeOfDottedName when resolving the call
				// target expression of an assertion.
				var funcType = void 0;
				if (node.parent.kind === SyntaxKind.ExpressionStatement) {
					funcType = getTypeOfDottedName(
						node.expression, /*diagnostic*/
						undefined,
					);
				} else if (node.expression.kind !== SyntaxKind.SuperKeyword) {
					if (isOptionalChain(node)) {
						funcType = checkNonNullType(
							getOptionalExpressionType(
								checkExpression(node.expression),
								node.expression,
							),
							node.expression,
						);
					} else {
						funcType = checkNonNullExpression(node.expression);
					}
				}
				var signatures = getSignaturesOfType(
					funcType && getApparentType(funcType) || unknownType,
					SignatureKind.Call,
				);
				var candidate = signatures.length === 1 && !signatures[0].typeParameters ? signatures[0] : some(
					signatures,
					hasTypePredicateOrNeverReturnType,
				) ? getResolvedSignature(node) : undefined;
				signature = links.effectsSignature = candidate && hasTypePredicateOrNeverReturnType(
					candidate,
				) ? candidate : unknownSignature;
			}
			return signature === unknownSignature ? undefined : signature;
		}
		function hasTypePredicateOrNeverReturnType(signature) {
			return !!(getTypePredicateOfSignature(signature) || signature.declaration && (getReturnTypeFromAnnotation(
				signature.declaration,
			) || unknownType).flags & TypeFlags.Never);
		}
		function getTypePredicateArgument(predicate, callExpression) {
			if (
				predicate.kind === TypePredicateKind.Identifier || predicate.kind === TypePredicateKind.AssertsIdentifier
			) {
				return callExpression.arguments[predicate.parameterIndex];
			}
			var invokedExpression = skipParentheses(callExpression.expression);
			return isAccessExpression(invokedExpression) ? skipParentheses(
				invokedExpression.expression,
			) : undefined;
		}
		function reportFlowControlError(node) {
			var block = findAncestor(node, isFunctionOrModuleBlock);
			var sourceFile = getSourceFileOfNode(node);
			var span = getSpanOfTokenAtPosition(sourceFile, block.statements.pos);
			diagnostics.add(
				createFileDiagnostic(
					sourceFile,
					span.start,
					span.length,
					Diagnostics.The_containing_function_or_module_body_is_too_large_for_control_flow_analysis,
				),
			);
		}
		function isReachableFlowNode(flow) {
			var result = isReachableFlowNodeWorker(flow, /*noCacheCheck*/ false);
			lastFlowNode = flow;
			lastFlowNodeReachable = result;
			return result;
		}
		function isFalseExpression(expr) {
			var node = skipParentheses(expr, /*excludeJSDocTypeAssertions*/ true);
			return node.kind === SyntaxKind.FalseKeyword || node.kind === SyntaxKind.BinaryExpression && (node.operatorToken.kind === SyntaxKind.AmpersandAmpersandToken && (isFalseExpression(
				node.left,
			) || isFalseExpression(node.right)) || node.operatorToken.kind === SyntaxKind.BarBarToken && isFalseExpression(
				node.left,
			) && isFalseExpression(node.right));
		}
		function isReachableFlowNodeWorker(flow, noCacheCheck) {
			while (true) {
				if (flow === lastFlowNode) {
					return lastFlowNodeReachable;
				}
				var flags = flow.flags;
				if (flags & FlowFlags.Shared) {
					if (!noCacheCheck) {
						var id = getFlowNodeId(flow);
						var reachable = flowNodeReachable[id];
						return reachable !== undefined ? reachable : (flowNodeReachable[id] = isReachableFlowNodeWorker(
							flow, /*noCacheCheck*/
							true,
						));
					}
					noCacheCheck = false;
				}
				if (
					flags & (FlowFlags.Assignment | FlowFlags.Condition | FlowFlags.ArrayMutation)
				) {
					flow = flow.antecedent;
				} else if (flags & FlowFlags.Call) {
					var signature = getEffectsSignature(flow.node);
					if (signature) {
						var predicate = getTypePredicateOfSignature(signature);
						if (
							predicate && predicate.kind === TypePredicateKind.AssertsIdentifier && !predicate.type
						) {
							var predicateArgument = flow.node.arguments[predicate.parameterIndex];
							if (predicateArgument && isFalseExpression(predicateArgument)) {
								return false;
							}
						}
						if (getReturnTypeOfSignature(signature).flags & TypeFlags.Never) {
							return false;
						}
					}
					flow = flow.antecedent;
				} else if (flags & FlowFlags.BranchLabel) {
					// A branching point is reachable if any branch is reachable.
					return some(
						flow.antecedents,
						function (f) {
							return isReachableFlowNodeWorker(f, /*noCacheCheck*/ false);
						},
					);
				} else if (flags & FlowFlags.LoopLabel) {
					var antecedents = flow.antecedents;
					if (antecedents === undefined || antecedents.length === 0) {
						return false;
					}
					// A loop is reachable if the control flow path that leads to the top is reachable.
					flow = antecedents[0];
				} else if (flags & FlowFlags.SwitchClause) {
					// The control flow path representing an unmatched value in a switch statement with
					// no default clause is unreachable if the switch statement is exhaustive.
					if (
						flow.clauseStart === flow.clauseEnd && isExhaustiveSwitchStatement(
							flow.switchStatement,
						)
					) {
						return false;
					}
					flow = flow.antecedent;
				} else if (flags & FlowFlags.ReduceLabel) {
					// Cache is unreliable once we start adjusting labels
					lastFlowNode = undefined;
					var target = flow.target;
					var saveAntecedents = target.antecedents;
					target.antecedents = flow.antecedents;
					var result = isReachableFlowNodeWorker(
						flow.antecedent, /*noCacheCheck*/
						false,
					);
					target.antecedents = saveAntecedents;
					return result;
				} else {
					return !(flags & FlowFlags.Unreachable);
				}
			}
		}
		// Return true if the given flow node is preceded by a 'super(...)' call in every possible code path
		// leading to the node.
		function isPostSuperFlowNode(flow, noCacheCheck) {
			while (true) {
				var flags = flow.flags;
				if (flags & FlowFlags.Shared) {
					if (!noCacheCheck) {
						var id = getFlowNodeId(flow);
						var postSuper = flowNodePostSuper[id];
						return postSuper !== undefined ? postSuper : (flowNodePostSuper[id] = isPostSuperFlowNode(
							flow, /*noCacheCheck*/
							true,
						));
					}
					noCacheCheck = false;
				}
				if (
					flags & (FlowFlags.Assignment | FlowFlags.Condition | FlowFlags.ArrayMutation | FlowFlags.SwitchClause)
				) {
					flow = flow.antecedent;
				} else if (flags & FlowFlags.Call) {
					if (flow.node.expression.kind === SyntaxKind.SuperKeyword) {
						return true;
					}
					flow = flow.antecedent;
				} else if (flags & FlowFlags.BranchLabel) {
					// A branching point is post-super if every branch is post-super.
					return every(
						flow.antecedents,
						function (f) {
							return isPostSuperFlowNode(f, /*noCacheCheck*/ false);
						},
					);
				} else if (flags & FlowFlags.LoopLabel) {
					// A loop is post-super if the control flow path that leads to the top is post-super.
					flow = flow.antecedents[0];
				} else if (flags & FlowFlags.ReduceLabel) {
					var target = flow.target;
					var saveAntecedents = target.antecedents;
					target.antecedents = flow.antecedents;
					var result = isPostSuperFlowNode(
						flow.antecedent, /*noCacheCheck*/
						false,
					);
					target.antecedents = saveAntecedents;
					return result;
				} else {
					// Unreachable nodes are considered post-super to silence errors
					return !!(flags & FlowFlags.Unreachable);
				}
			}
		}
		function isConstantReference(node) {
			switch (node.kind) {
				case SyntaxKind.Identifier:
					{
						var symbol = getResolvedSymbol(node);
						return isConstVariable(symbol) || isParameterOrCatchClauseVariable(
							symbol,
						) && !isSymbolAssigned(symbol);
					}
				case SyntaxKind.PropertyAccessExpression:
				case SyntaxKind.ElementAccessExpression:
					// The resolvedSymbol property is initialized by checkPropertyAccess or checkElementAccess before we get here.
					return isConstantReference(node.expression) && isReadonlySymbol(
						getNodeLinks(node).resolvedSymbol || unknownSymbol,
					);
			}
			return false;
		}
		function getFlowTypeOfReference(
			reference,
			declaredType,
			initialType,
			flowContainer,
			flowNode,
		) {
			if (initialType === void 0) {
				initialType = declaredType;
			}
			if (flowNode === void 0) {
				flowNode = reference.flowNode;
			}
			var key;
			var isKeySet = false;
			var flowDepth = 0;
			if (flowAnalysisDisabled) {
				return errorType;
			}
			if (!flowNode) {
				return declaredType;
			}
			flowInvocationCount++;
			var sharedFlowStart = sharedFlowCount;
			var evolvedType = getTypeFromFlowType(getTypeAtFlowNode(flowNode));
			sharedFlowCount = sharedFlowStart;
			// When the reference is 'x' in an 'x.length', 'x.push(value)', 'x.unshift(value)' or x[n] = value' operation,
			// we give type 'any[]' to 'x' instead of using the type determined by control flow analysis such that operations
			// on empty arrays are possible without implicit any errors and new element types can be inferred without
			// type mismatch errors.
			var resultType = getObjectFlags(evolvedType) & ObjectFlags.EvolvingArray && isEvolvingArrayOperationTarget(
				reference,
			) ? autoArrayType : finalizeEvolvingArrayType(evolvedType);
			if (
				resultType === unreachableNeverType || reference.parent && reference.parent.kind === SyntaxKind.NonNullExpression && !(resultType.flags & TypeFlags.Never) && getTypeWithFacts(
					resultType,
					2097152, /* NEUndefinedOrNull */
				).flags & TypeFlags.Never
			) {
				return declaredType;
			}
			// The non-null unknown type should never escape control flow analysis.
			return resultType === nonNullUnknownType ? unknownType : resultType;
			function getOrSetCacheKey() {
				if (isKeySet) {
					return key;
				}
				isKeySet = true;
				return key = getFlowCacheKey(
					reference,
					declaredType,
					initialType,
					flowContainer,
				);
			}
			function getTypeAtFlowNode(flow) {
				if (flowDepth === 2000) {
					// We have made 2000 recursive invocations. To avoid overflowing the call stack we report an error
					// and disable further control flow analysis in the containing function or module body.
					tracing === null || tracing === void 0 ? void 0 : tracing.instant(
						tracing.Phase.CheckTypes,
						"getTypeAtFlowNode_DepthLimit",
						{ flowId: flow.id },
					);
					flowAnalysisDisabled = true;
					reportFlowControlError(reference);
					return errorType;
				}
				flowDepth++;
				var sharedFlow;
				while (true) {
					var flags = flow.flags;
					if (flags & FlowFlags.Shared) {
						// We cache results of flow type resolution for shared nodes that were previously visited in
						// the same getFlowTypeOfReference invocation. A node is considered shared when it is the
						// antecedent of more than one node.
						for (var i = sharedFlowStart; i < sharedFlowCount; i++) {
							if (sharedFlowNodes[i] === flow) {
								flowDepth--;
								return sharedFlowTypes[i];
							}
						}
						sharedFlow = flow;
					}
					var type = void 0;
					if (flags & FlowFlags.Assignment) {
						type = getTypeAtFlowAssignment(flow);
						if (!type) {
							flow = flow.antecedent;
							continue;
						}
					} else if (flags & FlowFlags.Call) {
						type = getTypeAtFlowCall(flow);
						if (!type) {
							flow = flow.antecedent;
							continue;
						}
					} else if (flags & FlowFlags.Condition) {
						type = getTypeAtFlowCondition(flow);
					} else if (flags & FlowFlags.SwitchClause) {
						type = getTypeAtSwitchClause(flow);
					} else if (flags & FlowFlags.Label) {
						if (flow.antecedents.length === 1) {
							flow = flow.antecedents[0];
							continue;
						}
						type = flags & FlowFlags.BranchLabel ? getTypeAtFlowBranchLabel(
							flow,
						) : getTypeAtFlowLoopLabel(flow);
					} else if (flags & FlowFlags.ArrayMutation) {
						type = getTypeAtFlowArrayMutation(flow);
						if (!type) {
							flow = flow.antecedent;
							continue;
						}
					} else if (flags & FlowFlags.ReduceLabel) {
						var target = flow.target;
						var saveAntecedents = target.antecedents;
						target.antecedents = flow.antecedents;
						type = getTypeAtFlowNode(flow.antecedent);
						target.antecedents = saveAntecedents;
					} else if (flags & FlowFlags.Start) {
						// Check if we should continue with the control flow of the containing function.
						var container = flow.node;
						if (
							container && container !== flowContainer && reference.kind !== SyntaxKind.PropertyAccessExpression && reference.kind !== SyntaxKind.ElementAccessExpression && reference.kind !== SyntaxKind.ThisKeyword
						) {
							flow = container.flowNode;
							continue;
						}
						// At the top of the flow we have the initial type.
						type = initialType;
					} else {
						// Unreachable code errors are reported in the binding phase. Here we
						// simply return the non-auto declared type to reduce follow-on errors.
						type = convertAutoToAny(declaredType);
					}
					if (sharedFlow) {
						// Record visited node and the associated type in the cache.
						sharedFlowNodes[sharedFlowCount] = sharedFlow;
						sharedFlowTypes[sharedFlowCount] = type;
						sharedFlowCount++;
					}
					flowDepth--;
					return type;
				}
			}
			function getInitialOrAssignedType(flow) {
				var node = flow.node;
				return getNarrowableTypeForReference(
					node.kind === SyntaxKind.VariableDeclaration || node.kind === SyntaxKind.BindingElement ? getInitialType(
						node,
					) : getAssignedType(node),
					reference,
				);
			}
			function getTypeAtFlowAssignment(flow) {
				var node = flow.node;
				// Assignments only narrow the computed type if the declared type is a union type. Thus, we
				// only need to evaluate the assigned type if the declared type is a union type.
				if (isMatchingReference(reference, node)) {
					if (!isReachableFlowNode(flow)) {
						return unreachableNeverType;
					}
					if (getAssignmentTargetKind(node) === AssignmentKind.Compound) {
						var flowType = getTypeAtFlowNode(flow.antecedent);
						return createFlowType(
							getBaseTypeOfLiteralType(getTypeFromFlowType(flowType)),
							isIncomplete(flowType),
						);
					}
					if (declaredType === autoType || declaredType === autoArrayType) {
						if (isEmptyArrayAssignment(node)) {
							return getEvolvingArrayType(neverType);
						}
						var assignedType = getWidenedLiteralType(
							getInitialOrAssignedType(flow),
						);
						return isTypeAssignableTo(assignedType, declaredType) ? assignedType : anyArrayType;
					}
					if (declaredType.flags & TypeFlags.Union) {
						return getAssignmentReducedType(
							declaredType,
							getInitialOrAssignedType(flow),
						);
					}
					return declaredType;
				}
				// We didn't have a direct match. However, if the reference is a dotted name, this
				// may be an assignment to a left hand part of the reference. For example, for a
				// reference 'x.y.z', we may be at an assignment to 'x.y' or 'x'. In that case,
				// return the declared type.
				if (containsMatchingReference(reference, node)) {
					if (!isReachableFlowNode(flow)) {
						return unreachableNeverType;
					}
					// A matching dotted name might also be an expando property on a function *expression*,
					// in which case we continue control flow analysis back to the function's declaration
					if (
						isVariableDeclaration(node) && (isInJSFile(node) || isVarConst(node))
					) {
						var init = getDeclaredExpandoInitializer(node);
						if (
							init && (init.kind === SyntaxKind.FunctionExpression || init.kind === SyntaxKind.ArrowFunction)
						) {
							return getTypeAtFlowNode(flow.antecedent);
						}
					}
					return declaredType;
				}
				// for (const _ in ref) acts as a nonnull on ref
				if (
					isVariableDeclaration(node) && node.parent.parent.kind === SyntaxKind.ForInStatement && isMatchingReference(
						reference,
						node.parent.parent.expression,
					)
				) {
					return getNonNullableTypeIfNeeded(
						getTypeFromFlowType(getTypeAtFlowNode(flow.antecedent)),
					);
				}
				// Assignment doesn't affect reference
				return undefined;
			}
			function narrowTypeByAssertion(type, expr) {
				var node = skipParentheses(expr, /*excludeJSDocTypeAssertions*/ true);
				if (node.kind === SyntaxKind.FalseKeyword) {
					return unreachableNeverType;
				}
				if (node.kind === SyntaxKind.BinaryExpression) {
					if (node.operatorToken.kind === SyntaxKind.AmpersandAmpersandToken) {
						return narrowTypeByAssertion(
							narrowTypeByAssertion(type, node.left),
							node.right,
						);
					}
					if (node.operatorToken.kind === SyntaxKind.BarBarToken) {
						return getUnionType(
							[
								narrowTypeByAssertion(type, node.left),
								narrowTypeByAssertion(type, node.right),
							],
						);
					}
				}
				return narrowType(type, node, /*assumeTrue*/ true);
			}
			function getTypeAtFlowCall(flow) {
				var signature = getEffectsSignature(flow.node);
				if (signature) {
					var predicate = getTypePredicateOfSignature(signature);
					if (
						predicate && (predicate.kind === TypePredicateKind.AssertsThis || predicate.kind === TypePredicateKind.AssertsIdentifier)
					) {
						var flowType = getTypeAtFlowNode(flow.antecedent);
						var type = finalizeEvolvingArrayType(getTypeFromFlowType(flowType));
						var narrowedType = predicate.type ? narrowTypeByTypePredicate(
							type,
							predicate,
							flow.node, /*assumeTrue*/
							true,
						) : predicate.kind === TypePredicateKind.AssertsIdentifier && predicate.parameterIndex >= 0 && predicate.parameterIndex < flow.node.arguments.length ? narrowTypeByAssertion(
							type,
							flow.node.arguments[predicate.parameterIndex],
						) : type;
						return narrowedType === type ? flowType : createFlowType(
							narrowedType,
							isIncomplete(flowType),
						);
					}
					if (getReturnTypeOfSignature(signature).flags & TypeFlags.Never) {
						return unreachableNeverType;
					}
				}
				return undefined;
			}
			function getTypeAtFlowArrayMutation(flow) {
				if (declaredType === autoType || declaredType === autoArrayType) {
					var node = flow.node;
					var expr = node.kind === SyntaxKind.CallExpression ? node.expression.expression : node.left.expression;
					if (isMatchingReference(reference, getReferenceCandidate(expr))) {
						var flowType = getTypeAtFlowNode(flow.antecedent);
						var type = getTypeFromFlowType(flowType);
						if (getObjectFlags(type) & ObjectFlags.EvolvingArray) {
							var evolvedType_1 = type;
							if (node.kind === SyntaxKind.CallExpression) {
								for (var _i = 0, _a = node.arguments; _i < _a.length; _i++) {
									var arg = _a[_i];
									evolvedType_1 = addEvolvingArrayElementType(
										evolvedType_1,
										arg,
									);
								}
							} else {
								// We must get the context free expression type so as to not recur in an uncached fashion on the LHS (which causes exponential blowup in compile time)
								var indexType = getContextFreeTypeOfExpression(
									node.left.argumentExpression,
								);
								if (isTypeAssignableToKind(indexType, TypeFlags.NumberLike)) {
									evolvedType_1 = addEvolvingArrayElementType(
										evolvedType_1,
										node.right,
									);
								}
							}
							return evolvedType_1 === type ? flowType : createFlowType(
								evolvedType_1,
								isIncomplete(flowType),
							);
						}
						return flowType;
					}
				}
				return undefined;
			}
			function getTypeAtFlowCondition(flow) {
				var flowType = getTypeAtFlowNode(flow.antecedent);
				var type = getTypeFromFlowType(flowType);
				if (type.flags & TypeFlags.Never) {
					return flowType;
				}
				// If we have an antecedent type (meaning we're reachable in some way), we first
				// attempt to narrow the antecedent type. If that produces the never type, and if
				// the antecedent type is incomplete (i.e. a transient type in a loop), then we
				// take the type guard as an indication that control *could* reach here once we
				// have the complete type. We proceed by switching to the silent never type which
				// doesn't report errors when operators are applied to it. Note that this is the
				// *only* place a silent never type is ever generated.
				var assumeTrue = (flow.flags & FlowFlags.TrueCondition) !== 0;
				var nonEvolvingType = finalizeEvolvingArrayType(type);
				var narrowedType = narrowType(nonEvolvingType, flow.node, assumeTrue);
				if (narrowedType === nonEvolvingType) {
					return flowType;
				}
				return createFlowType(narrowedType, isIncomplete(flowType));
			}
			function getTypeAtSwitchClause(flow) {
				var expr = flow.switchStatement.expression;
				var flowType = getTypeAtFlowNode(flow.antecedent);
				var type = getTypeFromFlowType(flowType);
				if (isMatchingReference(reference, expr)) {
					type = narrowTypeBySwitchOnDiscriminant(
						type,
						flow.switchStatement,
						flow.clauseStart,
						flow.clauseEnd,
					);
				} else if (
					expr.kind === SyntaxKind.TypeOfExpression && isMatchingReference(
						reference,
						expr.expression,
					)
				) {
					type = narrowBySwitchOnTypeOf(
						type,
						flow.switchStatement,
						flow.clauseStart,
						flow.clauseEnd,
					);
				} else {
					if (strictNullChecks) {
						if (optionalChainContainsReference(expr, reference)) {
							type = narrowTypeBySwitchOptionalChainContainment(
								type,
								flow.switchStatement,
								flow.clauseStart,
								flow.clauseEnd,
								function (t) {
									return !(t.flags & (TypeFlags.Undefined | TypeFlags.Never));
								},
							);
						} else if (
							expr.kind === SyntaxKind.TypeOfExpression && optionalChainContainsReference(
								expr.expression,
								reference,
							)
						) {
							type = narrowTypeBySwitchOptionalChainContainment(
								type,
								flow.switchStatement,
								flow.clauseStart,
								flow.clauseEnd,
								function (t) {
									return !(t.flags & TypeFlags.Never || t.flags & TypeFlags.StringLiteral && t.value === "undefined");
								},
							);
						}
					}
					var access = getDiscriminantPropertyAccess(expr, type);
					if (access) {
						type = narrowTypeBySwitchOnDiscriminantProperty(
							type,
							access,
							flow.switchStatement,
							flow.clauseStart,
							flow.clauseEnd,
						);
					}
				}
				return createFlowType(type, isIncomplete(flowType));
			}
			function getTypeAtFlowBranchLabel(flow) {
				var antecedentTypes = [];
				var subtypeReduction = false;
				var seenIncomplete = false;
				var bypassFlow;
				for (var _i = 0, _a = flow.antecedents; _i < _a.length; _i++) {
					var antecedent = _a[_i];
					if (
						!bypassFlow && antecedent.flags & FlowFlags.SwitchClause && antecedent.clauseStart === antecedent.clauseEnd
					) {
						// The antecedent is the bypass branch of a potentially exhaustive switch statement.
						bypassFlow = antecedent;
						continue;
					}
					var flowType = getTypeAtFlowNode(antecedent);
					var type = getTypeFromFlowType(flowType);
					// If the type at a particular antecedent path is the declared type and the
					// reference is known to always be assigned (i.e. when declared and initial types
					// are the same), there is no reason to process more antecedents since the only
					// possible outcome is subtypes that will be removed in the final union type anyway.
					if (type === declaredType && declaredType === initialType) {
						return type;
					}
					pushIfUnique(antecedentTypes, type);
					// If an antecedent type is not a subset of the declared type, we need to perform
					// subtype reduction. This happens when a "foreign" type is injected into the control
					// flow using the instanceof operator or a user defined type predicate.
					if (!isTypeSubsetOf(type, declaredType)) {
						subtypeReduction = true;
					}
					if (isIncomplete(flowType)) {
						seenIncomplete = true;
					}
				}
				if (bypassFlow) {
					var flowType = getTypeAtFlowNode(bypassFlow);
					var type = getTypeFromFlowType(flowType);
					// If the bypass flow contributes a type we haven't seen yet and the switch statement
					// isn't exhaustive, process the bypass flow type. Since exhaustiveness checks increase
					// the risk of circularities, we only want to perform them when they make a difference.
					if (
						!contains(antecedentTypes, type) && !isExhaustiveSwitchStatement(
							bypassFlow.switchStatement,
						)
					) {
						if (type === declaredType && declaredType === initialType) {
							return type;
						}
						antecedentTypes.push(type);
						if (!isTypeSubsetOf(type, declaredType)) {
							subtypeReduction = true;
						}
						if (isIncomplete(flowType)) {
							seenIncomplete = true;
						}
					}
				}
				return createFlowType(
					getUnionOrEvolvingArrayType(
						antecedentTypes,
						subtypeReduction ? UnionReduction.Subtype : UnionReduction.Literal,
					),
					seenIncomplete,
				);
			}
			function getTypeAtFlowLoopLabel(flow) {
				// If we have previously computed the control flow type for the reference at
				// this flow loop junction, return the cached type.
				var id = getFlowNodeId(flow);
				var cache = flowLoopCaches[id] || (flowLoopCaches[id] = new Map());
				var key = getOrSetCacheKey();
				if (!key) {
					// No cache key is generated when binding patterns are in unnarrowable situations
					return declaredType;
				}
				var cached = cache.get(key);
				if (cached) {
					return cached;
				}
				// If this flow loop junction and reference are already being processed, return
				// the union of the types computed for each branch so far, marked as incomplete.
				// It is possible to see an empty array in cases where loops are nested and the
				// back edge of the outer loop reaches an inner loop that is already being analyzed.
				// In such cases we restart the analysis of the inner loop, which will then see
				// a non-empty in-process array for the outer loop and eventually terminate because
				// the first antecedent of a loop junction is always the non-looping control flow
				// path that leads to the top.
				for (var i = flowLoopStart; i < flowLoopCount; i++) {
					if (
						flowLoopNodes[i] === flow && flowLoopKeys[i] === key && flowLoopTypes[i].length
					) {
						return createFlowType(
							getUnionOrEvolvingArrayType(
								flowLoopTypes[i],
								UnionReduction.Literal,
							), /*incomplete*/
							true,
						);
					}
				}
				// Add the flow loop junction and reference to the in-process stack and analyze
				// each antecedent code path.
				var antecedentTypes = [];
				var subtypeReduction = false;
				var firstAntecedentType;
				for (var _i = 0, _a = flow.antecedents; _i < _a.length; _i++) {
					var antecedent = _a[_i];
					var flowType = void 0;
					if (!firstAntecedentType) {
						// The first antecedent of a loop junction is always the non-looping control
						// flow path that leads to the top.
						flowType = firstAntecedentType = getTypeAtFlowNode(antecedent);
					} else {
						// All but the first antecedent are the looping control flow paths that lead
						// back to the loop junction. We track these on the flow loop stack.
						flowLoopNodes[flowLoopCount] = flow;
						flowLoopKeys[flowLoopCount] = key;
						flowLoopTypes[flowLoopCount] = antecedentTypes;
						flowLoopCount++;
						var saveFlowTypeCache = flowTypeCache;
						flowTypeCache = undefined;
						flowType = getTypeAtFlowNode(antecedent);
						flowTypeCache = saveFlowTypeCache;
						flowLoopCount--;
						// If we see a value appear in the cache it is a sign that control flow analysis
						// was restarted and completed by checkExpressionCached. We can simply pick up
						// the resulting type and bail out.
						var cached_1 = cache.get(key);
						if (cached_1) {
							return cached_1;
						}
					}
					var type = getTypeFromFlowType(flowType);
					pushIfUnique(antecedentTypes, type);
					// If an antecedent type is not a subset of the declared type, we need to perform
					// subtype reduction. This happens when a "foreign" type is injected into the control
					// flow using the instanceof operator or a user defined type predicate.
					if (!isTypeSubsetOf(type, declaredType)) {
						subtypeReduction = true;
					}
					// If the type at a particular antecedent path is the declared type there is no
					// reason to process more antecedents since the only possible outcome is subtypes
					// that will be removed in the final union type anyway.
					if (type === declaredType) {
						break;
					}
				}
				// The result is incomplete if the first antecedent (the non-looping control flow path)
				// is incomplete.
				var result = getUnionOrEvolvingArrayType(
					antecedentTypes,
					subtypeReduction ? UnionReduction.Subtype : UnionReduction.Literal,
				);
				if (isIncomplete(firstAntecedentType)) {
					return createFlowType(result, /*incomplete*/ true);
				}
				cache.set(key, result);
				return result;
			}
			// At flow control branch or loop junctions, if the type along every antecedent code path
			// is an evolving array type, we construct a combined evolving array type. Otherwise we
			// finalize all evolving array types.
			function getUnionOrEvolvingArrayType(types, subtypeReduction) {
				if (isEvolvingArrayTypeList(types)) {
					return getEvolvingArrayType(
						getUnionType(map(types, getElementTypeOfEvolvingArrayType)),
					);
				}
				var result = getUnionType(
					sameMap(types, finalizeEvolvingArrayType),
					subtypeReduction,
				);
				if (
					result !== declaredType && result.flags & declaredType.flags & TypeFlags.Union && arraysEqual(
						result.types,
						declaredType.types,
					)
				) {
					return declaredType;
				}
				return result;
			}
			function getCandidateDiscriminantPropertyAccess(expr) {
				if (
					isBindingPattern(reference) || isFunctionExpressionOrArrowFunction(
						reference,
					)
				) {
					// When the reference is a binding pattern or function or arrow expression, we are narrowing a pesudo-reference in
					// getNarrowedTypeOfSymbol. An identifier for a destructuring variable declared in the same binding pattern or
					// parameter declared in the same parameter list is a candidate.
					if (isIdentifier(expr)) {
						var symbol = getResolvedSymbol(expr);
						var declaration = symbol.valueDeclaration;
						if (
							declaration && (isBindingElement(declaration) || isParameter(
								declaration,
							)) && reference === declaration.parent && !declaration.initializer && !declaration.dotDotDotToken
						) {
							return declaration;
						}
					}
				} else if (isAccessExpression(expr)) {
					// An access expression is a candidate if the reference matches the left hand expression.
					if (isMatchingReference(reference, expr.expression)) {
						return expr;
					}
				} else if (isIdentifier(expr)) {
					var symbol = getResolvedSymbol(expr);
					if (isConstVariable(symbol)) {
						var declaration = symbol.valueDeclaration;
						// Given 'const x = obj.kind', allow 'x' as an alias for 'obj.kind'
						if (
							isVariableDeclaration(declaration) && !declaration.type && declaration.initializer && isAccessExpression(
								declaration.initializer,
							) && isMatchingReference(
								reference,
								declaration.initializer.expression,
							)
						) {
							return declaration.initializer;
						}
						// Given 'const { kind: x } = obj', allow 'x' as an alias for 'obj.kind'
						if (isBindingElement(declaration) && !declaration.initializer) {
							var parent_9 = declaration.parent.parent;
							if (
								isVariableDeclaration(parent_9) && !parent_9.type && parent_9.initializer && (isIdentifier(
									parent_9.initializer,
								) || isAccessExpression(parent_9.initializer)) && isMatchingReference(
									reference,
									parent_9.initializer,
								)
							) {
								return declaration;
							}
						}
					}
				}
				return undefined;
			}
			function getDiscriminantPropertyAccess(expr, computedType) {
				var type = declaredType.flags & TypeFlags.Union ? declaredType : computedType;
				if (type.flags & TypeFlags.Union) {
					var access = getCandidateDiscriminantPropertyAccess(expr);
					if (access) {
						var name_19 = getAccessedPropertyName(access);
						if (name_19 && isDiscriminantProperty(type, name_19)) {
							return access;
						}
					}
				}
				return undefined;
			}
			function narrowTypeByDiscriminant(type, access, narrowType) {
				var propName = getAccessedPropertyName(access);
				if (propName === undefined) {
					return type;
				}
				var removeNullable = strictNullChecks && isOptionalChain(access) && maybeTypeOfKind(
					type,
					TypeFlags.Nullable,
				);
				var propType = getTypeOfPropertyOfType(
					removeNullable ? getTypeWithFacts(
						type,
						2097152, /* NEUndefinedOrNull */
					) : type,
					propName,
				);
				if (!propType) {
					return type;
				}
				propType = removeNullable ? getOptionalType(propType) : propType;
				var narrowedPropType = narrowType(propType);
				return filterType(
					type,
					function (t) {
						var discriminantType = getTypeOfPropertyOrIndexSignature(
							t,
							propName,
						);
						return !(narrowedPropType.flags & TypeFlags.Never) && isTypeComparableTo(
							narrowedPropType,
							discriminantType,
						);
					},
				);
			}
			function narrowTypeByDiscriminantProperty(
				type,
				access,
				operator,
				value,
				assumeTrue,
			) {
				if (
					(operator === SyntaxKind.EqualsEqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsEqualsToken) && type.flags & TypeFlags.Union
				) {
					var keyPropertyName = getKeyPropertyName(type);
					if (
						keyPropertyName && keyPropertyName === getAccessedPropertyName(
							access,
						)
					) {
						var candidate = getConstituentTypeForKeyType(
							type,
							getTypeOfExpression(value),
						);
						if (candidate) {
							return operator === (assumeTrue ? SyntaxKind.EqualsEqualsEqualsToken : SyntaxKind.ExclamationEqualsEqualsToken) ? candidate : isUnitType(
								getTypeOfPropertyOfType(candidate, keyPropertyName) || unknownType,
							) ? removeType(type, candidate) : type;
						}
					}
				}
				return narrowTypeByDiscriminant(
					type,
					access,
					function (t) {
						return narrowTypeByEquality(t, operator, value, assumeTrue);
					},
				);
			}
			function narrowTypeBySwitchOnDiscriminantProperty(
				type,
				access,
				switchStatement,
				clauseStart,
				clauseEnd,
			) {
				if (
					clauseStart < clauseEnd && type.flags & TypeFlags.Union && getKeyPropertyName(
						type,
					) === getAccessedPropertyName(access)
				) {
					var clauseTypes = getSwitchClauseTypes(switchStatement).slice(
						clauseStart,
						clauseEnd,
					);
					var candidate = getUnionType(
						map(
							clauseTypes,
							function (t) {
								return getConstituentTypeForKeyType(type, t) || unknownType;
							},
						),
					);
					if (candidate !== unknownType) {
						return candidate;
					}
				}
				return narrowTypeByDiscriminant(
					type,
					access,
					function (t) {
						return narrowTypeBySwitchOnDiscriminant(
							t,
							switchStatement,
							clauseStart,
							clauseEnd,
						);
					},
				);
			}
			function narrowTypeByTruthiness(type, expr, assumeTrue) {
				if (isMatchingReference(reference, expr)) {
					return type.flags & TypeFlags.Unknown && assumeTrue ? nonNullUnknownType : getTypeWithFacts(
						type,
						assumeTrue ? 4194304 : 8388608, /* Truthy */ /* Falsy */
					);
				}
				if (
					strictNullChecks && assumeTrue && optionalChainContainsReference(
						expr,
						reference,
					)
				) {
					type = getTypeWithFacts(type, 2097152 /* NEUndefinedOrNull */ );
				}
				var access = getDiscriminantPropertyAccess(expr, type);
				if (access) {
					return narrowTypeByDiscriminant(
						type,
						access,
						function (t) {
							return getTypeWithFacts(
								t,
								assumeTrue ? 4194304 : 8388608, /* Truthy */ /* Falsy */
							);
						},
					);
				}
				return type;
			}
			function isTypePresencePossible(type, propName, assumeTrue) {
				var prop = getPropertyOfType(type, propName);
				if (prop) {
					return prop.flags & SymbolFlags.Optional ? true : assumeTrue;
				}
				return getApplicableIndexInfoForName(type, propName) ? true : !assumeTrue;
			}
			function narrowByInKeyword(type, name, assumeTrue) {
				if (
					type.flags & TypeFlags.Union || type.flags & TypeFlags.Object && declaredType !== type || isThisTypeParameter(
						type,
					) || type.flags & TypeFlags.Intersection && every(
						type.types,
						function (t) {
							return t.symbol !== globalThisSymbol;
						},
					)
				) {
					return filterType(
						type,
						function (t) {
							return isTypePresencePossible(t, name, assumeTrue);
						},
					);
				}
				return type;
			}
			function narrowTypeByBinaryExpression(type, expr, assumeTrue) {
				switch (expr.operatorToken.kind) {
					case SyntaxKind.EqualsToken:
					case SyntaxKind.BarBarEqualsToken:
					case SyntaxKind.AmpersandAmpersandEqualsToken:
					case SyntaxKind.QuestionQuestionEqualsToken:
						return narrowTypeByTruthiness(
							narrowType(type, expr.right, assumeTrue),
							expr.left,
							assumeTrue,
						);
					case SyntaxKind.EqualsEqualsToken:
					case SyntaxKind.ExclamationEqualsToken:
					case SyntaxKind.EqualsEqualsEqualsToken:
					case SyntaxKind.ExclamationEqualsEqualsToken:
						var operator = expr.operatorToken.kind;
						var left = getReferenceCandidate(expr.left);
						var right = getReferenceCandidate(expr.right);
						if (
							left.kind === SyntaxKind.TypeOfExpression && isStringLiteralLike(
								right,
							)
						) {
							return narrowTypeByTypeof(type, left, operator, right, assumeTrue);
						}
						if (
							right.kind === SyntaxKind.TypeOfExpression && isStringLiteralLike(
								left,
							)
						) {
							return narrowTypeByTypeof(type, right, operator, left, assumeTrue);
						}
						if (isMatchingReference(reference, left)) {
							return narrowTypeByEquality(type, operator, right, assumeTrue);
						}
						if (isMatchingReference(reference, right)) {
							return narrowTypeByEquality(type, operator, left, assumeTrue);
						}
						if (strictNullChecks) {
							if (optionalChainContainsReference(left, reference)) {
								type = narrowTypeByOptionalChainContainment(
									type,
									operator,
									right,
									assumeTrue,
								);
							} else if (optionalChainContainsReference(right, reference)) {
								type = narrowTypeByOptionalChainContainment(
									type,
									operator,
									left,
									assumeTrue,
								);
							}
						}
						var leftAccess = getDiscriminantPropertyAccess(left, type);
						if (leftAccess) {
							return narrowTypeByDiscriminantProperty(
								type,
								leftAccess,
								operator,
								right,
								assumeTrue,
							);
						}
						var rightAccess = getDiscriminantPropertyAccess(right, type);
						if (rightAccess) {
							return narrowTypeByDiscriminantProperty(
								type,
								rightAccess,
								operator,
								left,
								assumeTrue,
							);
						}
						if (isMatchingConstructorReference(left)) {
							return narrowTypeByConstructor(type, operator, right, assumeTrue);
						}
						if (isMatchingConstructorReference(right)) {
							return narrowTypeByConstructor(type, operator, left, assumeTrue);
						}
						break;
					case SyntaxKind.InstanceOfKeyword:
						return narrowTypeByInstanceof(type, expr, assumeTrue);
					case SyntaxKind.InKeyword:
						if (isPrivateIdentifier(expr.left)) {
							return narrowTypeByPrivateIdentifierInInExpression(
								type,
								expr,
								assumeTrue,
							);
						}
						var target = getReferenceCandidate(expr.right);
						var leftType = getTypeOfNode(expr.left);
						if (leftType.flags & TypeFlags.StringLiteral) {
							var name_20 = escapeLeadingUnderscores(leftType.value);
							if (
								containsMissingType(type) && isAccessExpression(reference) && isMatchingReference(
									reference.expression,
									target,
								) && getAccessedPropertyName(reference) === name_20
							) {
								return getTypeWithFacts(
									type,
									assumeTrue ? 524288 : 65536, /* NEUndefined */ /* EQUndefined */
								);
							}
							if (isMatchingReference(reference, target)) {
								return narrowByInKeyword(type, name_20, assumeTrue);
							}
						}
						break;
					case SyntaxKind.CommaToken:
						return narrowType(type, expr.right, assumeTrue);
					// Ordinarily we won't see && and || expressions in control flow analysis because the Binder breaks those
					// expressions down to individual conditional control flows. However, we may encounter them when analyzing
					// aliased conditional expressions.
					case SyntaxKind.AmpersandAmpersandToken:
						return assumeTrue ? narrowType(
							narrowType(type, expr.left, /*assumeTrue*/ true),
							expr.right, /*assumeTrue*/
							true,
						) : getUnionType(
							[
								narrowType(type, expr.left, /*assumeTrue*/ false),
								narrowType(type, expr.right, /*assumeTrue*/ false),
							],
						);
					case SyntaxKind.BarBarToken:
						return assumeTrue ? getUnionType(
							[
								narrowType(type, expr.left, /*assumeTrue*/ true),
								narrowType(type, expr.right, /*assumeTrue*/ true),
							],
						) : narrowType(
							narrowType(type, expr.left, /*assumeTrue*/ false),
							expr.right, /*assumeTrue*/
							false,
						);
				}
				return type;
			}
			function narrowTypeByPrivateIdentifierInInExpression(
				type,
				expr,
				assumeTrue,
			) {
				var target = getReferenceCandidate(expr.right);
				if (!isMatchingReference(reference, target)) {
					return type;
				}
				Debug.assertNode(expr.left, isPrivateIdentifier);
				var symbol = getSymbolForPrivateIdentifierExpression(expr.left);
				if (symbol === undefined) {
					return type;
				}
				var classSymbol = symbol.parent;
				var targetType = hasStaticModifier(
					Debug.checkDefined(
						symbol.valueDeclaration,
						"should always have a declaration",
					),
				) ? getTypeOfSymbol(classSymbol) : getDeclaredTypeOfSymbol(classSymbol);
				return getNarrowedType(type, targetType, assumeTrue, isTypeDerivedFrom);
			}
			function narrowTypeByOptionalChainContainment(
				type,
				operator,
				value,
				assumeTrue,
			) {
				// We are in a branch of obj?.foo === value (or any one of the other equality operators). We narrow obj as follows:
				// When operator is === and type of value excludes undefined, null and undefined is removed from type of obj in true branch.
				// When operator is !== and type of value excludes undefined, null and undefined is removed from type of obj in false branch.
				// When operator is == and type of value excludes null and undefined, null and undefined is removed from type of obj in true branch.
				// When operator is != and type of value excludes null and undefined, null and undefined is removed from type of obj in false branch.
				// When operator is === and type of value is undefined, null and undefined is removed from type of obj in false branch.
				// When operator is !== and type of value is undefined, null and undefined is removed from type of obj in true branch.
				// When operator is == and type of value is null or undefined, null and undefined is removed from type of obj in false branch.
				// When operator is != and type of value is null or undefined, null and undefined is removed from type of obj in true branch.
				var equalsOperator = operator === SyntaxKind.EqualsEqualsToken || operator === SyntaxKind.EqualsEqualsEqualsToken;
				var nullableFlags = operator === SyntaxKind.EqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsToken ? TypeFlags.Nullable : TypeFlags.Undefined;
				var valueType = getTypeOfExpression(value);
				// Note that we include any and unknown in the exclusion test because their domain includes null and undefined.
				var removeNullable = equalsOperator !== assumeTrue && everyType(
					valueType,
					function (t) {
						return !!(t.flags & nullableFlags);
					},
				) || equalsOperator === assumeTrue && everyType(
					valueType,
					function (t) {
						return !(t.flags & (TypeFlags.AnyOrUnknown | nullableFlags));
					},
				);
				return removeNullable ? getTypeWithFacts(
					type,
					2097152, /* NEUndefinedOrNull */
				) : type;
			}
			function narrowTypeByEquality(type, operator, value, assumeTrue) {
				if (type.flags & TypeFlags.Any) {
					return type;
				}
				if (
					operator === SyntaxKind.ExclamationEqualsToken || operator === SyntaxKind.ExclamationEqualsEqualsToken
				) {
					assumeTrue = !assumeTrue;
				}
				var valueType = getTypeOfExpression(value);
				if (
					assumeTrue && (type.flags & TypeFlags.Unknown) && (operator === SyntaxKind.EqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsToken) && (valueType.flags & TypeFlags.Null)
				) {
					return getUnionType([nullType, undefinedType]);
				}
				if (
					(type.flags & TypeFlags.Unknown) && assumeTrue && (operator === SyntaxKind.EqualsEqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsEqualsToken)
				) {
					if (valueType.flags & (TypeFlags.Primitive | TypeFlags.NonPrimitive)) {
						return valueType;
					}
					if (valueType.flags & TypeFlags.Object) {
						return nonPrimitiveType;
					}
					return type;
				}
				if (valueType.flags & TypeFlags.Nullable) {
					if (!strictNullChecks) {
						return type;
					}
					var doubleEquals = operator === SyntaxKind.EqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsToken;
					var facts = doubleEquals ? assumeTrue ? 262144 : 2097152 : valueType.flags & TypeFlags.Null ? assumeTrue ? 131072 : 1048576 : assumeTrue ? 65536 : 524288; /* EQUndefinedOrNull */ /* NEUndefinedOrNull */ /* EQNull */ /* NENull */ /* EQUndefined */ /* NEUndefined */
					return type.flags & TypeFlags.Unknown && facts & (1048576 | 2097152) ? nonNullUnknownType : getTypeWithFacts(
						type, /* NENull */ /* NEUndefinedOrNull */
						facts,
					);
				}
				if (assumeTrue) {
					var filterFn = operator === SyntaxKind.EqualsEqualsToken ? function (
						t,
					) {
						return areTypesComparable(t, valueType) || isCoercibleUnderDoubleEquals(
							t,
							valueType,
						);
					} : function (t) {
						return areTypesComparable(t, valueType);
					};
					return replacePrimitivesWithLiterals(
						filterType(type, filterFn),
						valueType,
					);
				}
				if (isUnitType(valueType)) {
					return filterType(
						type,
						function (t) {
							return !(isUnitLikeType(t) && areTypesComparable(t, valueType));
						},
					);
				}
				return type;
			}
			function narrowTypeByTypeof(
				type,
				typeOfExpr,
				operator,
				literal,
				assumeTrue,
			) {
				// We have '==', '!=', '===', or !==' operator with 'typeof xxx' and string literal operands
				if (
					operator === SyntaxKind.ExclamationEqualsToken || operator === SyntaxKind.ExclamationEqualsEqualsToken
				) {
					assumeTrue = !assumeTrue;
				}
				var target = getReferenceCandidate(typeOfExpr.expression);
				if (!isMatchingReference(reference, target)) {
					if (
						strictNullChecks && optionalChainContainsReference(
							target,
							reference,
						) && assumeTrue === (literal.text !== "undefined")
					) {
						return getTypeWithFacts(type, 2097152 /* NEUndefinedOrNull */ );
					}
					return type;
				}
				if (type.flags & TypeFlags.Any && literal.text === "function") {
					return type;
				}
				if (
					assumeTrue && type.flags & TypeFlags.Unknown && literal.text === "object"
				) {
					// The non-null unknown type is used to track whether a previous narrowing operation has removed the null type
					// from the unknown type. For example, the expression `x && typeof x === 'object'` first narrows x to the non-null
					// unknown type, and then narrows that to the non-primitive type.
					return type === nonNullUnknownType ? nonPrimitiveType : getUnionType(
						[nonPrimitiveType, nullType],
					);
				}
				var facts = assumeTrue ? typeofEQFacts.get(literal.text) || 128 : typeofNEFacts.get(
					literal.text, /* TypeofEQHostObject */
				) || 32768; /* TypeofNEHostObject */
				var impliedType = getImpliedTypeFromTypeofGuard(type, literal.text);
				return getTypeWithFacts(
					assumeTrue && impliedType ? mapType(
						type,
						narrowUnionMemberByTypeof(impliedType),
					) : type,
					facts,
				);
			}
			function narrowTypeBySwitchOptionalChainContainment(
				type,
				switchStatement,
				clauseStart,
				clauseEnd,
				clauseCheck,
			) {
				var everyClauseChecks = clauseStart !== clauseEnd && every(
					getSwitchClauseTypes(switchStatement).slice(clauseStart, clauseEnd),
					clauseCheck,
				);
				return everyClauseChecks ? getTypeWithFacts(
					type,
					2097152, /* NEUndefinedOrNull */
				) : type;
			}
			function narrowTypeBySwitchOnDiscriminant(
				type,
				switchStatement,
				clauseStart,
				clauseEnd,
			) {
				// We only narrow if all case expressions specify
				// values with unit types, except for the case where
				// `type` is unknown. In this instance we map object
				// types to the nonPrimitive type and narrow with that.
				var switchTypes = getSwitchClauseTypes(switchStatement);
				if (!switchTypes.length) {
					return type;
				}
				var clauseTypes = switchTypes.slice(clauseStart, clauseEnd);
				var hasDefaultClause = clauseStart === clauseEnd || contains(
					clauseTypes,
					neverType,
				);
				if ((type.flags & TypeFlags.Unknown) && !hasDefaultClause) {
					var groundClauseTypes = void 0;
					for (var i = 0; i < clauseTypes.length; i += 1) {
						var t = clauseTypes[i];
						if (t.flags & (TypeFlags.Primitive | TypeFlags.NonPrimitive)) {
							if (groundClauseTypes !== undefined) {
								groundClauseTypes.push(t);
							}
						} else if (t.flags & TypeFlags.Object) {
							if (groundClauseTypes === undefined) {
								groundClauseTypes = clauseTypes.slice(0, i);
							}
							groundClauseTypes.push(nonPrimitiveType);
						} else {
							return type;
						}
					}
					return getUnionType(
						groundClauseTypes === undefined ? clauseTypes : groundClauseTypes,
					);
				}
				var discriminantType = getUnionType(clauseTypes);
				var caseType = discriminantType.flags & TypeFlags.Never ? neverType : replacePrimitivesWithLiterals(
					filterType(
						type,
						function (t) {
							return areTypesComparable(discriminantType, t);
						},
					),
					discriminantType,
				);
				if (!hasDefaultClause) {
					return caseType;
				}
				var defaultType = filterType(
					type,
					function (t) {
						return !(isUnitLikeType(t) && contains(
							switchTypes,
							getRegularTypeOfLiteralType(extractUnitType(t)),
						));
					},
				);
				return caseType.flags & TypeFlags.Never ? defaultType : getUnionType(
					[caseType, defaultType],
				);
			}
			function getImpliedTypeFromTypeofGuard(type, text) {
				switch (text) {
					case "function":
						return type.flags & TypeFlags.Any ? type : globalFunctionType;
					case "object":
						return type.flags & TypeFlags.Unknown ? getUnionType(
							[nonPrimitiveType, nullType],
						) : type;
					default:
						return typeofTypesByName.get(text);
				}
			}
			// When narrowing a union type by a `typeof` guard using type-facts alone, constituent types that are
			// super-types of the implied guard will be retained in the final type: this is because type-facts only
			// filter. Instead, we would like to replace those union constituents with the more precise type implied by
			// the guard. For example: narrowing `{} | undefined` by `"boolean"` should produce the type `boolean`, not
			// the filtered type `{}`. For this reason we narrow constituents of the union individually, in addition to
			// filtering by type-facts.
			function narrowUnionMemberByTypeof(candidate) {
				return function (type) {
					if (isTypeSubtypeOf(type, candidate)) {
						return type;
					}
					if (isTypeSubtypeOf(candidate, type)) {
						return candidate;
					}
					if (type.flags & TypeFlags.Instantiable) {
						var constraint = getBaseConstraintOfType(type) || anyType;
						if (isTypeSubtypeOf(candidate, constraint)) {
							return getIntersectionType([type, candidate]);
						}
					}
					return type;
				};
			}
			function narrowBySwitchOnTypeOf(
				type,
				switchStatement,
				clauseStart,
				clauseEnd,
			) {
				var switchWitnesses = getSwitchClauseTypeOfWitnesses(
					switchStatement, /*retainDefault*/
					true,
				);
				if (!switchWitnesses.length) {
					return type;
				}
				//  Equal start and end denotes implicit fallthrough; undefined marks explicit default clause
				var defaultCaseLocation = findIndex(
					switchWitnesses,
					function (elem) {
						return elem === undefined;
					},
				);
				var hasDefaultClause = clauseStart === clauseEnd || (defaultCaseLocation >= clauseStart && defaultCaseLocation < clauseEnd);
				var clauseWitnesses;
				var switchFacts;
				if (defaultCaseLocation > -1) {
					// We no longer need the undefined denoting an explicit default case. Remove the undefined and
					// fix-up clauseStart and clauseEnd.  This means that we don't have to worry about undefined in the
					// witness array.
					var witnesses = switchWitnesses.filter(
						function (witness) {
							return witness !== undefined;
						},
					);
					// The adjusted clause start and end after removing the `default` statement.
					var fixedClauseStart = defaultCaseLocation < clauseStart ? clauseStart - 1 : clauseStart;
					var fixedClauseEnd = defaultCaseLocation < clauseEnd ? clauseEnd - 1 : clauseEnd;
					clauseWitnesses = witnesses.slice(fixedClauseStart, fixedClauseEnd);
					switchFacts = getFactsFromTypeofSwitch(
						fixedClauseStart,
						fixedClauseEnd,
						witnesses,
						hasDefaultClause,
					);
				} else {
					clauseWitnesses = switchWitnesses.slice(clauseStart, clauseEnd);
					switchFacts = getFactsFromTypeofSwitch(
						clauseStart,
						clauseEnd,
						switchWitnesses,
						hasDefaultClause,
					);
				}
				if (hasDefaultClause) {
					return filterType(
						type,
						function (t) {
							return (getTypeFacts(t) & switchFacts) === switchFacts;
						},
					);
				}
				/*
                  The implied type is the raw type suggested by a
                  value being caught in this clause.

                  When the clause contains a default case we ignore
                  the implied type and try to narrow using any facts
                  we can learn: see `switchFacts`.

                  Example:
                  switch (typeof x) {
                      case 'number':
                      case 'string': break;
                      default: break;
                      case 'number':
                      case 'boolean': break
                  }

                  In the first clause (case `number` and `string`) the
                  implied type is number | string.

                  In the default clause we de not compute an implied type.

                  In the third clause (case `number` and `boolean`)
                  the naive implied type is number | boolean, however
                  we use the type facts to narrow the implied type to
                  boolean. We know that number cannot be selected
                  because it is caught in the first clause.
                */
				var impliedType = getTypeWithFacts(
					getUnionType(
						clauseWitnesses.map(
							function (text) {
								return getImpliedTypeFromTypeofGuard(type, text) || type;
							},
						),
					),
					switchFacts,
				);
				return getTypeWithFacts(
					mapType(type, narrowUnionMemberByTypeof(impliedType)),
					switchFacts,
				);
			}
			function isMatchingConstructorReference(expr) {
				return (isPropertyAccessExpression(expr) && idText(expr.name) === "constructor" || isElementAccessExpression(
					expr,
				) && isStringLiteralLike(expr.argumentExpression) && expr.argumentExpression.text === "constructor") && isMatchingReference(
					reference,
					expr.expression,
				);
			}
			function narrowTypeByConstructor(type, operator, identifier, assumeTrue) {
				// Do not narrow when checking inequality.
				if (
					assumeTrue ? (operator !== SyntaxKind.EqualsEqualsToken && operator !== SyntaxKind.EqualsEqualsEqualsToken) : (operator !== SyntaxKind.ExclamationEqualsToken && operator !== SyntaxKind.ExclamationEqualsEqualsToken)
				) {
					return type;
				}
				// Get the type of the constructor identifier expression, if it is not a function then do not narrow.
				var identifierType = getTypeOfExpression(identifier);
				if (
					!isFunctionType(identifierType) && !isConstructorType(identifierType)
				) {
					return type;
				}
				// Get the prototype property of the type identifier so we can find out its type.
				var prototypeProperty = getPropertyOfType(identifierType, "prototype");
				if (!prototypeProperty) {
					return type;
				}
				// Get the type of the prototype, if it is undefined, or the global `Object` or `Function` types then do not narrow.
				var prototypeType = getTypeOfSymbol(prototypeProperty);
				var candidate = !isTypeAny(prototypeType) ? prototypeType : undefined;
				if (
					!candidate || candidate === globalObjectType || candidate === globalFunctionType
				) {
					return type;
				}
				// If the type that is being narrowed is `any` then just return the `candidate` type since every type is a subtype of `any`.
				if (isTypeAny(type)) {
					return candidate;
				}
				// Filter out types that are not considered to be "constructed by" the `candidate` type.
				return filterType(
					type,
					function (t) {
						return isConstructedBy(t, candidate);
					},
				);
				function isConstructedBy(source, target) {
					// If either the source or target type are a class type then we need to check that they are the same exact type.
					// This is because you may have a class `A` that defines some set of properties, and another class `B`
					// that defines the same set of properties as class `A`, in that case they are structurally the same
					// type, but when you do something like `instanceOfA.constructor === B` it will return false.
					if (
						source.flags & TypeFlags.Object && getObjectFlags(source) & ObjectFlags.Class || target.flags & TypeFlags.Object && getObjectFlags(
							target,
						) & ObjectFlags.Class
					) {
						return source.symbol === target.symbol;
					}
					// For all other types just check that the `source` type is a subtype of the `target` type.
					return isTypeSubtypeOf(source, target);
				}
			}
			function narrowTypeByInstanceof(type, expr, assumeTrue) {
				var left = getReferenceCandidate(expr.left);
				if (!isMatchingReference(reference, left)) {
					if (
						assumeTrue && strictNullChecks && optionalChainContainsReference(
							left,
							reference,
						)
					) {
						return getTypeWithFacts(type, 2097152 /* NEUndefinedOrNull */ );
					}
					return type;
				}
				// Check that right operand is a function type with a prototype property
				var rightType = getTypeOfExpression(expr.right);
				if (!isTypeDerivedFrom(rightType, globalFunctionType)) {
					return type;
				}
				var targetType;
				var prototypeProperty = getPropertyOfType(rightType, "prototype");
				if (prototypeProperty) {
					// Target type is type of the prototype property
					var prototypePropertyType = getTypeOfSymbol(prototypeProperty);
					if (!isTypeAny(prototypePropertyType)) {
						targetType = prototypePropertyType;
					}
				}
				// Don't narrow from 'any' if the target type is exactly 'Object' or 'Function'
				if (
					isTypeAny(type) && (targetType === globalObjectType || targetType === globalFunctionType)
				) {
					return type;
				}
				if (!targetType) {
					var constructSignatures = getSignaturesOfType(
						rightType,
						SignatureKind.Construct,
					);
					targetType = constructSignatures.length ? getUnionType(
						map(
							constructSignatures,
							function (signature) {
								return getReturnTypeOfSignature(getErasedSignature(signature));
							},
						),
					) : emptyObjectType;
				}
				// We can't narrow a union based off instanceof without negated types see #31576 for more info
				if (!assumeTrue && rightType.flags & TypeFlags.Union) {
					var nonConstructorTypeInUnion = find(
						rightType.types,
						function (t) {
							return !isConstructorType(t);
						},
					);
					if (!nonConstructorTypeInUnion) return type;
				}
				return getNarrowedType(type, targetType, assumeTrue, isTypeDerivedFrom);
			}
			function getNarrowedType(type, candidate, assumeTrue, isRelated) {
				if (!assumeTrue) {
					return filterType(
						type,
						function (t) {
							return !isRelated(t, candidate);
						},
					);
				}
				// If the current type is a union type, remove all constituents that couldn't be instances of
				// the candidate type. If one or more constituents remain, return a union of those.
				if (type.flags & TypeFlags.Union) {
					var assignableType = filterType(
						type,
						function (t) {
							return isRelated(t, candidate);
						},
					);
					if (!(assignableType.flags & TypeFlags.Never)) {
						return assignableType;
					}
				}
				// If the candidate type is a subtype of the target type, narrow to the candidate type.
				// Otherwise, if the target type is assignable to the candidate type, keep the target type.
				// Otherwise, if the candidate type is assignable to the target type, narrow to the candidate
				// type. Otherwise, the types are completely unrelated, so narrow to an intersection of the
				// two types.
				return isTypeSubtypeOf(candidate, type) ? candidate : isTypeAssignableTo(
					type,
					candidate,
				) ? type : isTypeAssignableTo(candidate, type) ? candidate : getIntersectionType(
					[type, candidate],
				);
			}
			function narrowTypeByCallExpression(type, callExpression, assumeTrue) {
				if (hasMatchingArgument(callExpression, reference)) {
					var signature = assumeTrue || !isCallChain(callExpression) ? getEffectsSignature(
						callExpression,
					) : undefined;
					var predicate = signature && getTypePredicateOfSignature(signature);
					if (
						predicate && (predicate.kind === TypePredicateKind.This || predicate.kind === TypePredicateKind.Identifier)
					) {
						return narrowTypeByTypePredicate(
							type,
							predicate,
							callExpression,
							assumeTrue,
						);
					}
				}
				if (
					containsMissingType(type) && isAccessExpression(reference) && isPropertyAccessExpression(
						callExpression.expression,
					)
				) {
					var callAccess = callExpression.expression;
					if (
						isMatchingReference(
							reference.expression,
							getReferenceCandidate(callAccess.expression),
						) && isIdentifier(callAccess.name) && callAccess.name.escapedText === "hasOwnProperty" && callExpression.arguments.length === 1
					) {
						var argument = callExpression.arguments[0];
						if (
							isStringLiteralLike(argument) && getAccessedPropertyName(
								reference,
							) === escapeLeadingUnderscores(argument.text)
						) {
							return getTypeWithFacts(
								type,
								assumeTrue ? 524288 : 65536, /* NEUndefined */ /* EQUndefined */
							);
						}
					}
				}
				return type;
			}
			function narrowTypeByTypePredicate(
				type,
				predicate,
				callExpression,
				assumeTrue,
			) {
				// Don't narrow from 'any' if the predicate type is exactly 'Object' or 'Function'
				if (
					predicate.type && !(isTypeAny(type) && (predicate.type === globalObjectType || predicate.type === globalFunctionType))
				) {
					var predicateArgument = getTypePredicateArgument(
						predicate,
						callExpression,
					);
					if (predicateArgument) {
						if (isMatchingReference(reference, predicateArgument)) {
							return getNarrowedType(
								type,
								predicate.type,
								assumeTrue,
								isTypeSubtypeOf,
							);
						}
						if (
							strictNullChecks && assumeTrue && optionalChainContainsReference(
								predicateArgument,
								reference,
							) && !(getTypeFacts(predicate.type) & 65536) /* EQUndefined */
						) {
							type = getTypeWithFacts(type, 2097152 /* NEUndefinedOrNull */ );
						}
						var access = getDiscriminantPropertyAccess(predicateArgument, type);
						if (access) {
							return narrowTypeByDiscriminant(
								type,
								access,
								function (t) {
									return getNarrowedType(
										t,
										predicate.type,
										assumeTrue,
										isTypeSubtypeOf,
									);
								},
							);
						}
					}
				}
				return type;
			}
			// Narrow the given type based on the given expression having the assumed boolean value. The returned type
			// will be a subtype or the same type as the argument.
			function narrowType(type, expr, assumeTrue) {
				// for `a?.b`, we emulate a synthetic `a !== null && a !== undefined` condition for `a`
				if (
					isExpressionOfOptionalChainRoot(expr) || isBinaryExpression(
						expr.parent,
					) && expr.parent.operatorToken.kind === SyntaxKind.QuestionQuestionToken && expr.parent.left === expr
				) {
					return narrowTypeByOptionality(type, expr, assumeTrue);
				}
				switch (expr.kind) {
					case SyntaxKind.Identifier:
						// When narrowing a reference to a const variable, non-assigned parameter, or readonly property, we inline
						// up to five levels of aliased conditional expressions that are themselves declared as const variables.
						if (!isMatchingReference(reference, expr) && inlineLevel < 5) {
							var symbol = getResolvedSymbol(expr);
							if (isConstVariable(symbol)) {
								var declaration = symbol.valueDeclaration;
								if (
									declaration && isVariableDeclaration(declaration) && !declaration.type && declaration.initializer && isConstantReference(
										reference,
									)
								) {
									inlineLevel++;
									var result = narrowType(
										type,
										declaration.initializer,
										assumeTrue,
									);
									inlineLevel--;
									return result;
								}
							}
						}
					// falls through
					case SyntaxKind.ThisKeyword:
					case SyntaxKind.SuperKeyword:
					case SyntaxKind.PropertyAccessExpression:
					case SyntaxKind.ElementAccessExpression:
						return narrowTypeByTruthiness(type, expr, assumeTrue);
					case SyntaxKind.CallExpression:
						return narrowTypeByCallExpression(type, expr, assumeTrue);
					case SyntaxKind.ParenthesizedExpression:
					case SyntaxKind.NonNullExpression:
						return narrowType(type, expr.expression, assumeTrue);
					case SyntaxKind.BinaryExpression:
						return narrowTypeByBinaryExpression(type, expr, assumeTrue);
					case SyntaxKind.PrefixUnaryExpression:
						if (expr.operator === SyntaxKind.ExclamationToken) {
							return narrowType(type, expr.operand, !assumeTrue);
						}
						break;
				}
				return type;
			}
			function narrowTypeByOptionality(type, expr, assumePresent) {
				if (isMatchingReference(reference, expr)) {
					return getTypeWithFacts(
						type,
						assumePresent ? 2097152 : 262144, /* NEUndefinedOrNull */ /* EQUndefinedOrNull */
					);
				}
				var access = getDiscriminantPropertyAccess(expr, type);
				if (access) {
					return narrowTypeByDiscriminant(
						type,
						access,
						function (t) {
							return getTypeWithFacts(
								t,
								assumePresent ? 2097152 : 262144, /* NEUndefinedOrNull */ /* EQUndefinedOrNull */
							);
						},
					);
				}
				return type;
			}
		}
		function getTypeOfSymbolAtLocation(symbol, location) {
			symbol = symbol.exportSymbol || symbol;
			// If we have an identifier or a property access at the given location, if the location is
			// an dotted name expression, and if the location is not an assignment target, obtain the type
			// of the expression (which will reflect control flow analysis). If the expression indeed
			// resolved to the given symbol, return the narrowed type.
			if (
				location.kind === SyntaxKind.Identifier || location.kind === SyntaxKind.PrivateIdentifier
			) {
				if (isRightSideOfQualifiedNameOrPropertyAccess(location)) {
					location = location.parent;
				}
				if (
					isExpressionNode(location) && (!isAssignmentTarget(location) || isWriteAccess(
						location,
					))
				) {
					var type = getTypeOfExpression(location);
					if (
						getExportSymbolOfValueSymbolIfExported(
							getNodeLinks(location).resolvedSymbol,
						) === symbol
					) {
						return type;
					}
				}
			}
			if (
				isDeclarationName(location) && isSetAccessor(location.parent) && getAnnotatedAccessorTypeNode(
					location.parent,
				)
			) {
				return resolveTypeOfAccessors(location.parent.symbol, /*writing*/ true);
			}
			// The location isn't a reference to the given symbol, meaning we're being asked
			// a hypothetical question of what type the symbol would have if there was a reference
			// to it at the given location. Since we have no control flow information for the
			// hypothetical reference (control flow information is created and attached by the
			// binder), we simply return the declared type of the symbol.
			return getNonMissingTypeOfSymbol(symbol);
		}
		function getControlFlowContainer(node) {
			return findAncestor(
				node.parent,
				function (node) {
					return isFunctionLike(node) && !getImmediatelyInvokedFunctionExpression(
						node,
					) || node.kind === SyntaxKind.ModuleBlock || node.kind === SyntaxKind.SourceFile || node.kind === SyntaxKind.PropertyDeclaration;
				},
			);
		}
		// Check if a parameter or catch variable is assigned anywhere
		function isSymbolAssigned(symbol) {
			if (!symbol.valueDeclaration) {
				return false;
			}
			var parent = getRootDeclaration(symbol.valueDeclaration).parent;
			var links = getNodeLinks(parent);
			if (!(links.flags & NodeCheckFlags.AssignmentsMarked)) {
				links.flags |= NodeCheckFlags.AssignmentsMarked;
				if (!hasParentWithAssignmentsMarked(parent)) {
					markNodeAssignments(parent);
				}
			}
			return symbol.isAssigned || false;
		}
		function hasParentWithAssignmentsMarked(node) {
			return !!findAncestor(
				node.parent,
				function (node) {
					return (isFunctionLike(node) || isCatchClause(node)) && !!(getNodeLinks(
						node,
					).flags & NodeCheckFlags.AssignmentsMarked);
				},
			);
		}
		function markNodeAssignments(node) {
			if (node.kind === SyntaxKind.Identifier) {
				if (isAssignmentTarget(node)) {
					var symbol = getResolvedSymbol(node);
					if (isParameterOrCatchClauseVariable(symbol)) {
						symbol.isAssigned = true;
					}
				}
			} else {
				forEachChild(node, markNodeAssignments);
			}
		}
		function isConstVariable(symbol) {
			return symbol.flags & SymbolFlags.Variable && (getDeclarationNodeFlagsFromSymbol(
				symbol,
			) & NodeFlags.Const) !== 0;
		}
		/** remove undefined from the annotated type of a parameter when there is an initializer (that doesn't include undefined) */
		function removeOptionalityFromDeclaredType(declaredType, declaration) {
			if (pushTypeResolution(declaration.symbol, 2 /* DeclaredType */ )) {
				var annotationIncludesUndefined = strictNullChecks && declaration.kind === SyntaxKind.Parameter && declaration.initializer && getFalsyFlags(
					declaredType,
				) & TypeFlags.Undefined && !(getFalsyFlags(
					checkExpression(declaration.initializer),
				) & TypeFlags.Undefined);
				popTypeResolution();
				return annotationIncludesUndefined ? getTypeWithFacts(
					declaredType,
					524288, /* NEUndefined */
				) : declaredType;
			} else {
				reportCircularityError(declaration.symbol);
				return declaredType;
			}
		}
		function isConstraintPosition(type, node) {
			var parent = node.parent;
			// In an element access obj[x], we consider obj to be in a constraint position, except when obj is of
			// a generic type without a nullable constraint and x is a generic type. This is because when both obj
			// and x are of generic types T and K, we want the resulting type to be T[K].
			return parent.kind === SyntaxKind.PropertyAccessExpression || parent.kind === SyntaxKind.CallExpression && parent.expression === node || parent.kind === SyntaxKind.ElementAccessExpression && parent.expression === node && !(someType(
				type,
				isGenericTypeWithoutNullableConstraint,
			) && isGenericIndexType(getTypeOfExpression(parent.argumentExpression)));
		}
		function isGenericTypeWithUnionConstraint(type) {
			return !!(type.flags & TypeFlags.Instantiable && getBaseConstraintOrType(
				type,
			).flags & (TypeFlags.Nullable | TypeFlags.Union));
		}
		function isGenericTypeWithoutNullableConstraint(type) {
			return !!(type.flags & TypeFlags.Instantiable && !maybeTypeOfKind(
				getBaseConstraintOrType(type),
				TypeFlags.Nullable,
			));
		}
		function hasNonBindingPatternContextualTypeWithNoGenericTypes(node) {
			// Computing the contextual type for a child of a JSX element involves resolving the type of the
			// element's tag name, so we exclude that here to avoid circularities.
			var contextualType = (isIdentifier(node) || isPropertyAccessExpression(
				node,
			) || isElementAccessExpression(node)) && !((isJsxOpeningElement(
				node.parent,
			) || isJsxSelfClosingElement(node.parent)) && node.parent.tagName === node) && getContextualType(
				node,
				ContextFlags.SkipBindingPatterns,
			);
			return contextualType && !isGenericType(contextualType);
		}
		function getNarrowableTypeForReference(type, reference, checkMode) {
			// When the type of a reference is or contains an instantiable type with a union type constraint, and
			// when the reference is in a constraint position (where it is known we'll obtain the apparent type) or
			// has a contextual type containing no top-level instantiables (meaning constraints will determine
			// assignability), we substitute constraints for all instantiables in the type of the reference to give
			// control flow analysis an opportunity to narrow it further. For example, for a reference of a type
			// parameter type 'T extends string | undefined' with a contextual type 'string', we substitute
			// 'string | undefined' to give control flow analysis the opportunity to narrow to type 'string'.
			var substituteConstraints = !(checkMode && checkMode & 2) && someType(
				type, /* Inferential */
				isGenericTypeWithUnionConstraint,
			) && (isConstraintPosition(type, reference) || hasNonBindingPatternContextualTypeWithNoGenericTypes(
				reference,
			));
			return substituteConstraints ? mapType(
				type,
				function (t) {
					return t.flags & TypeFlags.Instantiable && !isMappedTypeGenericIndexedAccess(
						t,
					) ? getBaseConstraintOrType(t) : t;
				},
			) : type;
		}
		function isExportOrExportExpression(location) {
			return !!findAncestor(
				location,
				function (n) {
					var parent = n.parent;
					if (parent === undefined) {
						return "quit";
					}
					if (isExportAssignment(parent)) {
						return parent.expression === n && isEntityNameExpression(n);
					}
					if (isExportSpecifier(parent)) {
						return parent.name === n || parent.propertyName === n;
					}
					return false;
				},
			);
		}
		function markAliasReferenced(symbol, location) {
			if (
				isNonLocalAlias(symbol, /*excludes*/ SymbolFlags.Value) && !isInTypeQuery(
					location,
				) && !getTypeOnlyAliasDeclaration(symbol)
			) {
				var target = resolveAlias(symbol);
				if (target.flags & SymbolFlags.Value) {
					// An alias resolving to a const enum cannot be elided if (1) 'isolatedModules' is enabled
					// (because the const enum value will not be inlined), or if (2) the alias is an export
					// of a const enum declaration that will be preserved.
					if (
						compilerOptions.isolatedModules || shouldPreserveConstEnums(
							compilerOptions,
						) && isExportOrExportExpression(location) || !isConstEnumOrConstEnumOnlyModule(
							target,
						)
					) {
						markAliasSymbolAsReferenced(symbol);
					} else {
						markConstEnumAliasAsReferenced(symbol);
					}
				}
			}
		}
		function getNarrowedTypeOfSymbol(symbol, location) {
			var declaration = symbol.valueDeclaration;
			if (declaration) {
				// If we have a non-rest binding element with no initializer declared as a const variable or a const-like
				// parameter (a parameter for which there are no assignments in the function body), and if the parent type
				// for the destructuring is a union type, one or more of the binding elements may represent discriminant
				// properties, and we want the effects of conditional checks on such discriminants to affect the types of
				// other binding elements from the same destructuring. Consider:
				//
				//   type Action =
				//       | { kind: 'A', payload: number }
				//       | { kind: 'B', payload: string };
				//
				//   function f({ kind, payload }: Action) {
				//       if (kind === 'A') {
				//           payload.toFixed();
				//       }
				//       if (kind === 'B') {
				//           payload.toUpperCase();
				//       }
				//   }
				//
				// Above, we want the conditional checks on 'kind' to affect the type of 'payload'. To facilitate this, we use
				// the binding pattern AST instance for '{ kind, payload }' as a pseudo-reference and narrow this reference
				// as if it occurred in the specified location. We then recompute the narrowed binding element type by
				// destructuring from the narrowed parent type.
				if (
					isBindingElement(declaration) && !declaration.initializer && !declaration.dotDotDotToken && declaration.parent.elements.length >= 2
				) {
					var parent_10 = declaration.parent.parent;
					if (
						parent_10.kind === SyntaxKind.VariableDeclaration && getCombinedNodeFlags(
							declaration,
						) & NodeFlags.Const || parent_10.kind === SyntaxKind.Parameter
					) {
						var links = getNodeLinks(location);
						if (!(links.flags & NodeCheckFlags.InCheckIdentifier)) {
							links.flags |= NodeCheckFlags.InCheckIdentifier;
							var parentType = getTypeForBindingElementParent(parent_10);
							links.flags &= ~NodeCheckFlags.InCheckIdentifier;
							if (
								parentType && parentType.flags & TypeFlags.Union && !(parent_10.kind === SyntaxKind.Parameter && isSymbolAssigned(
									symbol,
								))
							) {
								var pattern = declaration.parent;
								var narrowedType = getFlowTypeOfReference(
									pattern,
									parentType,
									parentType, /*flowContainer*/
									undefined,
									location.flowNode,
								);
								return getBindingElementTypeFromParentType(
									declaration,
									narrowedType,
								);
							}
						}
					}
				}
				// If we have a const-like parameter with no type annotation or initializer, and if the parameter is contextually
				// typed by a signature with a single rest parameter of a union of tuple types, one or more of the parameters may
				// represent discriminant tuple elements, and we want the effects of conditional checks on such discriminants to
				// affect the types of other parameters in the same parameter list. Consider:
				//
				//   type Action = [kind: 'A', payload: number] | [kind: 'B', payload: string];
				//
				//   const f: (...args: Action) => void = (kind, payload) => {
				//       if (kind === 'A') {
				//           payload.toFixed();
				//       }
				//       if (kind === 'B') {
				//           payload.toUpperCase();
				//       }
				//   }
				//
				// Above, we want the conditional checks on 'kind' to affect the type of 'payload'. To facilitate this, we use
				// the arrow function AST node for '(kind, payload) => ...' as a pseudo-reference and narrow this reference as
				// if it occurred in the specified location. We then recompute the narrowed parameter type by indexing into the
				// narrowed tuple type.
				if (
					isParameter(declaration) && !declaration.type && !declaration.initializer && !declaration.dotDotDotToken
				) {
					var func = declaration.parent;
					if (
						func.parameters.length >= 2 && isContextSensitiveFunctionOrObjectLiteralMethod(
							func,
						)
					) {
						var contextualSignature = getContextualSignature(func);
						if (
							contextualSignature && contextualSignature.parameters.length === 1 && signatureHasRestParameter(
								contextualSignature,
							)
						) {
							var restType = getTypeOfSymbol(contextualSignature.parameters[0]);
							if (
								restType.flags & TypeFlags.Union && everyType(
									restType,
									isTupleType,
								) && !isSymbolAssigned(symbol)
							) {
								var narrowedType = getFlowTypeOfReference(
									func,
									restType,
									restType, /*flowContainer*/
									undefined,
									location.flowNode,
								);
								var index = func.parameters.indexOf(declaration) - (getThisParameter(
									func,
								) ? 1 : 0);
								return getIndexedAccessType(
									narrowedType,
									getNumberLiteralType(index),
								);
							}
						}
					}
				}
			}
			return getTypeOfSymbol(symbol);
		}
		function checkIdentifier(node, checkMode) {
			var symbol = getResolvedSymbol(node);
			if (symbol === unknownSymbol) {
				return errorType;
			}
			// As noted in ECMAScript 6 language spec, arrow functions never have an arguments objects.
			// Although in down-level emit of arrow function, we emit it using function expression which means that
			// arguments objects will be bound to the inner object; emitting arrow function natively in ES6, arguments objects
			// will be bound to non-arrow function that contain this arrow function. This results in inconsistent behavior.
			// To avoid that we will give an error to users if they use arguments objects in arrow function so that they
			// can explicitly bound arguments objects
			if (symbol === argumentsSymbol) {
				if (isInPropertyInitializerOrClassStaticBlock(node)) {
					error(
						node,
						Diagnostics.arguments_cannot_be_referenced_in_property_initializers,
					);
					return errorType;
				}
				var container = getContainingFunction(node);
				if (languageVersion < ScriptTarget.ES2015) {
					if (container.kind === SyntaxKind.ArrowFunction) {
						error(
							node,
							Diagnostics.The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES3_and_ES5_Consider_using_a_standard_function_expression,
						);
					} else if (hasSyntacticModifier(container, ModifierFlags.Async)) {
						error(
							node,
							Diagnostics.The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES3_and_ES5_Consider_using_a_standard_function_or_method,
						);
					}
				}
				getNodeLinks(container).flags |= NodeCheckFlags.CaptureArguments;
				return getTypeOfSymbol(symbol);
			}
			// We should only mark aliases as referenced if there isn't a local value declaration
			// for the symbol. Also, don't mark any property access expression LHS - checkPropertyAccessExpression will handle that
			if (
				!(node.parent && isPropertyAccessExpression(node.parent) && node.parent.expression === node)
			) {
				markAliasReferenced(symbol, node);
			}
			var localOrExportSymbol = getExportSymbolOfValueSymbolIfExported(symbol);
			var sourceSymbol = localOrExportSymbol.flags & SymbolFlags.Alias ? resolveAlias(
				localOrExportSymbol,
			) : localOrExportSymbol;
			if (
				sourceSymbol.declarations && getDeclarationNodeFlagsFromSymbol(
					sourceSymbol,
				) & NodeFlags.Deprecated && isUncalledFunctionReference(
					node,
					sourceSymbol,
				)
			) {
				addDeprecatedSuggestion(
					node,
					sourceSymbol.declarations,
					node.escapedText,
				);
			}
			var declaration = localOrExportSymbol.valueDeclaration;
			if (declaration && localOrExportSymbol.flags & SymbolFlags.Class) {
				// Due to the emit for class decorators, any reference to the class from inside of the class body
				// must instead be rewritten to point to a temporary variable to avoid issues with the double-bind
				// behavior of class names in ES6.
				if (
					declaration.kind === SyntaxKind.ClassDeclaration && nodeIsDecorated(
						declaration,
					)
				) {
					var container = getContainingClass(node);
					while (container !== undefined) {
						if (container === declaration && container.name !== node) {
							getNodeLinks(declaration).flags |= NodeCheckFlags.ClassWithConstructorReference;
							getNodeLinks(node).flags |= NodeCheckFlags.ConstructorReferenceInClass;
							break;
						}
						container = getContainingClass(container);
					}
				} else if (declaration.kind === SyntaxKind.ClassExpression) {
					// When we emit a class expression with static members that contain a reference
					// to the constructor in the initializer, we will need to substitute that
					// binding with an alias as the class name is not in scope.
					var container = getThisContainer(
						node, /*includeArrowFunctions*/
						false,
					);
					while (container.kind !== SyntaxKind.SourceFile) {
						if (container.parent === declaration) {
							if (
								isPropertyDeclaration(container) && isStatic(container) || isClassStaticBlockDeclaration(
									container,
								)
							) {
								getNodeLinks(declaration).flags |= NodeCheckFlags.ClassWithConstructorReference;
								getNodeLinks(node).flags |= NodeCheckFlags.ConstructorReferenceInClass;
							}
							break;
						}
						container = getThisContainer(
							container, /*includeArrowFunctions*/
							false,
						);
					}
				}
			}
			checkNestedBlockScopedBinding(node, symbol);
			var type = getNarrowedTypeOfSymbol(localOrExportSymbol, node);
			var assignmentKind = getAssignmentTargetKind(node);
			if (assignmentKind) {
				if (
					!(localOrExportSymbol.flags & SymbolFlags.Variable) && !(isInJSFile(
						node,
					) && localOrExportSymbol.flags & SymbolFlags.ValueModule)
				) {
					var assignmentError = localOrExportSymbol.flags & SymbolFlags.Enum ? Diagnostics.Cannot_assign_to_0_because_it_is_an_enum : localOrExportSymbol.flags & SymbolFlags.Class ? Diagnostics.Cannot_assign_to_0_because_it_is_a_class : localOrExportSymbol.flags & SymbolFlags.Module ? Diagnostics.Cannot_assign_to_0_because_it_is_a_namespace : localOrExportSymbol.flags & SymbolFlags.Function ? Diagnostics.Cannot_assign_to_0_because_it_is_a_function : localOrExportSymbol.flags & SymbolFlags.Alias ? Diagnostics.Cannot_assign_to_0_because_it_is_an_import : Diagnostics.Cannot_assign_to_0_because_it_is_not_a_variable;
					error(node, assignmentError, symbolToString(symbol));
					return errorType;
				}
				if (isReadonlySymbol(localOrExportSymbol)) {
					if (localOrExportSymbol.flags & SymbolFlags.Variable) {
						error(
							node,
							Diagnostics.Cannot_assign_to_0_because_it_is_a_constant,
							symbolToString(symbol),
						);
					} else {
						error(
							node,
							Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property,
							symbolToString(symbol),
						);
					}
					return errorType;
				}
			}
			var isAlias = localOrExportSymbol.flags & SymbolFlags.Alias;
			// We only narrow variables and parameters occurring in a non-assignment position. For all other
			// entities we simply return the declared type.
			if (localOrExportSymbol.flags & SymbolFlags.Variable) {
				if (assignmentKind === AssignmentKind.Definite) {
					return type;
				}
			} else if (isAlias) {
				declaration = getDeclarationOfAliasSymbol(symbol);
			} else {
				return type;
			}
			if (!declaration) {
				return type;
			}
			type = getNarrowableTypeForReference(type, node, checkMode);
			// The declaration container is the innermost function that encloses the declaration of the variable
			// or parameter. The flow container is the innermost function starting with which we analyze the control
			// flow graph to determine the control flow based type.
			var isParameter = getRootDeclaration(declaration).kind === SyntaxKind.Parameter;
			var declarationContainer = getControlFlowContainer(declaration);
			var flowContainer = getControlFlowContainer(node);
			var isOuterVariable = flowContainer !== declarationContainer;
			var isSpreadDestructuringAssignmentTarget = node.parent && node.parent.parent && isSpreadAssignment(
				node.parent,
			) && isDestructuringAssignmentTarget(node.parent.parent);
			var isModuleExports = symbol.flags & SymbolFlags.ModuleExports;
			// When the control flow originates in a function expression or arrow function and we are referencing
			// a const variable or parameter from an outer function, we extend the origin of the control flow
			// analysis to include the immediately enclosing function.
			while (
				flowContainer !== declarationContainer && (flowContainer.kind === SyntaxKind.FunctionExpression || flowContainer.kind === SyntaxKind.ArrowFunction || isObjectLiteralOrClassExpressionMethodOrAccessor(
					flowContainer,
				)) && (isConstVariable(localOrExportSymbol) && type !== autoArrayType || isParameter && !isSymbolAssigned(
					localOrExportSymbol,
				))
			) {
				flowContainer = getControlFlowContainer(flowContainer);
			}
			// We only look for uninitialized variables in strict null checking mode, and only when we can analyze
			// the entire control flow graph from the variable's declaration (i.e. when the flow container and
			// declaration container are the same).
			var assumeInitialized = isParameter || isAlias || isOuterVariable || isSpreadDestructuringAssignmentTarget || isModuleExports || isBindingElement(
				declaration,
			) || type !== autoType && type !== autoArrayType && (!strictNullChecks || (type.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Void)) !== 0 || isInTypeQuery(
				node,
			) || node.parent.kind === SyntaxKind.ExportSpecifier) || node.parent.kind === SyntaxKind.NonNullExpression || declaration.kind === SyntaxKind.VariableDeclaration && declaration.exclamationToken || declaration.flags & NodeFlags.Ambient;
			var initialType = assumeInitialized ? (isParameter ? removeOptionalityFromDeclaredType(
				type,
				declaration,
			) : type) : type === autoType || type === autoArrayType ? undefinedType : getOptionalType(
				type,
			);
			var flowType = getFlowTypeOfReference(
				node,
				type,
				initialType,
				flowContainer,
			);
			// A variable is considered uninitialized when it is possible to analyze the entire control flow graph
			// from declaration to use, and when the variable's declared type doesn't include undefined but the
			// control flow based type does include undefined.
			if (
				!isEvolvingArrayOperationTarget(node) && (type === autoType || type === autoArrayType)
			) {
				if (flowType === autoType || flowType === autoArrayType) {
					if (noImplicitAny) {
						error(
							getNameOfDeclaration(declaration),
							Diagnostics.Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined,
							symbolToString(symbol),
							typeToString(flowType),
						);
						error(
							node,
							Diagnostics.Variable_0_implicitly_has_an_1_type,
							symbolToString(symbol),
							typeToString(flowType),
						);
					}
					return convertAutoToAny(flowType);
				}
			} else if (
				!assumeInitialized && !(getFalsyFlags(type) & TypeFlags.Undefined) && getFalsyFlags(
					flowType,
				) & TypeFlags.Undefined
			) {
				error(
					node,
					Diagnostics.Variable_0_is_used_before_being_assigned,
					symbolToString(symbol),
				);
				// Return the declared type to reduce follow-on errors
				return type;
			}
			return assignmentKind ? getBaseTypeOfLiteralType(flowType) : flowType;
		}
		function isInsideFunctionOrInstancePropertyInitializer(node, threshold) {
			return !!findAncestor(
				node,
				function (n) {
					return n === threshold ? "quit" : isFunctionLike(n) || (n.parent && isPropertyDeclaration(
						n.parent,
					) && !hasStaticModifier(n.parent) && n.parent.initializer === n);
				},
			);
		}
		function getPartOfForStatementContainingNode(node, container) {
			return findAncestor(
				node,
				function (n) {
					return n === container ? "quit" : n === container.initializer || n === container.condition || n === container.incrementor || n === container.statement;
				},
			);
		}
		function getEnclosingIterationStatement(node) {
			return findAncestor(
				node,
				function (n) {
					return (!n || nodeStartsNewLexicalEnvironment(n)) ? "quit" : isIterationStatement(
						n, /*lookInLabeledStatements*/
						false,
					);
				},
			);
		}
		function checkNestedBlockScopedBinding(node, symbol) {
			if (
				languageVersion >= ScriptTarget.ES2015 || (symbol.flags & (SymbolFlags.BlockScopedVariable | SymbolFlags.Class)) === 0 || !symbol.valueDeclaration || isSourceFile(
					symbol.valueDeclaration,
				) || symbol.valueDeclaration.parent.kind === SyntaxKind.CatchClause
			) {
				return;
			}
			// 1. walk from the use site up to the declaration and check
			// if there is anything function like between declaration and use-site (is binding/class is captured in function).
			// 2. walk from the declaration up to the boundary of lexical environment and check
			// if there is an iteration statement in between declaration and boundary (is binding/class declared inside iteration statement)
			var container = getEnclosingBlockScopeContainer(symbol.valueDeclaration);
			var isCaptured = isInsideFunctionOrInstancePropertyInitializer(
				node,
				container,
			);
			var enclosingIterationStatement = getEnclosingIterationStatement(
				container,
			);
			if (enclosingIterationStatement) {
				if (isCaptured) {
					// mark iteration statement as containing block-scoped binding captured in some function
					var capturesBlockScopeBindingInLoopBody = true;
					if (isForStatement(container)) {
						var varDeclList = getAncestor(
							symbol.valueDeclaration,
							SyntaxKind.VariableDeclarationList,
						);
						if (varDeclList && varDeclList.parent === container) {
							var part = getPartOfForStatementContainingNode(
								node.parent,
								container,
							);
							if (part) {
								var links = getNodeLinks(part);
								links.flags |= NodeCheckFlags.ContainsCapturedBlockScopeBinding;
								var capturedBindings = links.capturedBlockScopeBindings || (links.capturedBlockScopeBindings = []);
								pushIfUnique(capturedBindings, symbol);
								if (part === container.initializer) {
									capturesBlockScopeBindingInLoopBody = false; // Initializer is outside of loop body
								}
							}
						}
					}
					if (capturesBlockScopeBindingInLoopBody) {
						getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlags.LoopWithCapturedBlockScopedBinding;
					}
				}
				// mark variables that are declared in loop initializer and reassigned inside the body of ForStatement.
				// if body of ForStatement will be converted to function then we'll need a extra machinery to propagate reassigned values back.
				if (isForStatement(container)) {
					var varDeclList = getAncestor(
						symbol.valueDeclaration,
						SyntaxKind.VariableDeclarationList,
					);
					if (
						varDeclList && varDeclList.parent === container && isAssignedInBodyOfForStatement(
							node,
							container,
						)
					) {
						getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlags.NeedsLoopOutParameter;
					}
				}
				// set 'declared inside loop' bit on the block-scoped binding
				getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlags.BlockScopedBindingInLoop;
			}
			if (isCaptured) {
				getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlags.CapturedBlockScopedBinding;
			}
		}
		function isBindingCapturedByNode(node, decl) {
			var links = getNodeLinks(node);
			return !!links && contains(
				links.capturedBlockScopeBindings,
				getSymbolOfNode(decl),
			);
		}
		function isAssignedInBodyOfForStatement(node, container) {
			// skip parenthesized nodes
			var current = node;
			while (current.parent.kind === SyntaxKind.ParenthesizedExpression) {
				current = current.parent;
			}
			// check if node is used as LHS in some assignment expression
			var isAssigned = false;
			if (isAssignmentTarget(current)) {
				isAssigned = true;
			} else if (
				(current.parent.kind === SyntaxKind.PrefixUnaryExpression || current.parent.kind === SyntaxKind.PostfixUnaryExpression)
			) {
				var expr = current.parent;
				isAssigned = expr.operator === SyntaxKind.PlusPlusToken || expr.operator === SyntaxKind.MinusMinusToken;
			}
			if (!isAssigned) {
				return false;
			}
			// at this point we know that node is the target of assignment
			// now check that modification happens inside the statement part of the ForStatement
			return !!findAncestor(
				current,
				function (n) {
					return n === container ? "quit" : n === container.statement;
				},
			);
		}
		function captureLexicalThis(node, container) {
			getNodeLinks(node).flags |= NodeCheckFlags.LexicalThis;
			if (
				container.kind === SyntaxKind.PropertyDeclaration || container.kind === SyntaxKind.Constructor
			) {
				var classNode = container.parent;
				getNodeLinks(classNode).flags |= NodeCheckFlags.CaptureThis;
			} else {
				getNodeLinks(container).flags |= NodeCheckFlags.CaptureThis;
			}
		}
		function findFirstSuperCall(node) {
			return isSuperCall(node) ? node : isFunctionLike(node) ? undefined : forEachChild(
				node,
				findFirstSuperCall,
			);
		}
		/**
         * Check if the given class-declaration extends null then return true.
         * Otherwise, return false
         * @param classDecl a class declaration to check if it extends null
         */
		function classDeclarationExtendsNull(classDecl) {
			var classSymbol = getSymbolOfNode(classDecl);
			var classInstanceType = getDeclaredTypeOfSymbol(classSymbol);
			var baseConstructorType = getBaseConstructorTypeOfClass(classInstanceType);
			return baseConstructorType === nullWideningType;
		}
		function checkThisBeforeSuper(node, container, diagnosticMessage) {
			var containingClassDecl = container.parent;
			var baseTypeNode = getClassExtendsHeritageElement(containingClassDecl);
			// If a containing class does not have extends clause or the class extends null
			// skip checking whether super statement is called before "this" accessing.
			if (baseTypeNode && !classDeclarationExtendsNull(containingClassDecl)) {
				if (
					node.flowNode && !isPostSuperFlowNode(
						node.flowNode, /*noCacheCheck*/
						false,
					)
				) {
					error(node, diagnosticMessage);
				}
			}
		}
		function checkThisInStaticClassFieldInitializerInDecoratedClass(
			thisExpression,
			container,
		) {
			if (
				isPropertyDeclaration(container) && hasStaticModifier(container) && container.initializer && textRangeContainsPositionInclusive(
					container.initializer,
					thisExpression.pos,
				) && length(container.parent.decorators)
			) {
				error(
					thisExpression,
					Diagnostics.Cannot_use_this_in_a_static_property_initializer_of_a_decorated_class,
				);
			}
		}
		function checkThisExpression(node) {
			var isNodeInTypeQuery = isInTypeQuery(node);
			// Stop at the first arrow function so that we can
			// tell whether 'this' needs to be captured.
			var container = getThisContainer(node, /* includeArrowFunctions */ true);
			var capturedByArrowFunction = false;
			if (container.kind === SyntaxKind.Constructor) {
				checkThisBeforeSuper(
					node,
					container,
					Diagnostics.super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class,
				);
			}
			// Now skip arrow functions to get the "real" owner of 'this'.
			if (container.kind === SyntaxKind.ArrowFunction) {
				container = getThisContainer(
					container, /* includeArrowFunctions */
					false,
				);
				capturedByArrowFunction = true;
			}
			checkThisInStaticClassFieldInitializerInDecoratedClass(node, container);
			switch (container.kind) {
				case SyntaxKind.ModuleDeclaration:
					error(
						node,
						Diagnostics.this_cannot_be_referenced_in_a_module_or_namespace_body,
					);
					// do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks
					break;
				case SyntaxKind.EnumDeclaration:
					error(node, Diagnostics.this_cannot_be_referenced_in_current_location);
					// do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks
					break;
				case SyntaxKind.Constructor:
					if (isInConstructorArgumentInitializer(node, container)) {
						error(
							node,
							Diagnostics.this_cannot_be_referenced_in_constructor_arguments,
						); // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks
					}
					break;
				case SyntaxKind.ComputedPropertyName:
					error(
						node,
						Diagnostics.this_cannot_be_referenced_in_a_computed_property_name,
					);
					break;
			}
			// When targeting es6, mark that we'll need to capture `this` in its lexically bound scope.
			if (
				!isNodeInTypeQuery && capturedByArrowFunction && languageVersion < ScriptTarget.ES2015
			) {
				captureLexicalThis(node, container);
			}
			var type = tryGetThisTypeAt(node, /*includeGlobalThis*/ true, container);
			if (noImplicitThis) {
				var globalThisType_1 = getTypeOfSymbol(globalThisSymbol);
				if (type === globalThisType_1 && capturedByArrowFunction) {
					error(
						node,
						Diagnostics.The_containing_arrow_function_captures_the_global_value_of_this,
					);
				} else if (!type) {
					// With noImplicitThis, functions may not reference 'this' if it has type 'any'
					var diag = error(
						node,
						Diagnostics.this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation,
					);
					if (!isSourceFile(container)) {
						var outsideThis = tryGetThisTypeAt(container);
						if (outsideThis && outsideThis !== globalThisType_1) {
							addRelatedInfo(
								diag,
								createDiagnosticForNode(
									container,
									Diagnostics.An_outer_value_of_this_is_shadowed_by_this_container,
								),
							);
						}
					}
				}
			}
			return type || anyType;
		}
		function tryGetThisTypeAt(node, includeGlobalThis, container) {
			if (includeGlobalThis === void 0) {
				includeGlobalThis = true;
			}
			if (container === void 0) {
				container = getThisContainer(node, /*includeArrowFunctions*/ false);
			}
			var isInJS = isInJSFile(node);
			if (
				isFunctionLike(container) && (!isInParameterInitializerBeforeContainingFunction(
					node,
				) || getThisParameter(container))
			) {
				var thisType = getThisTypeOfDeclaration(container) || isInJS && getTypeForThisExpressionFromJSDoc(
					container,
				);
				// Note: a parameter initializer should refer to class-this unless function-this is explicitly annotated.
				// If this is a function in a JS file, it might be a class method.
				if (!thisType) {
					var className = getClassNameFromPrototypeMethod(container);
					if (isInJS && className) {
						var classSymbol = checkExpression(className).symbol;
						if (
							classSymbol && classSymbol.members && (classSymbol.flags & SymbolFlags.Function)
						) {
							thisType = getDeclaredTypeOfSymbol(classSymbol).thisType;
						}
					} else if (isJSConstructor(container)) {
						thisType = getDeclaredTypeOfSymbol(
							getMergedSymbol(container.symbol),
						).thisType;
					}
					thisType || (thisType = getContextualThisParameterType(container));
				}
				if (thisType) {
					return getFlowTypeOfReference(node, thisType);
				}
			}
			if (isClassLike(container.parent)) {
				var symbol = getSymbolOfNode(container.parent);
				var type = isStatic(container) ? getTypeOfSymbol(symbol) : getDeclaredTypeOfSymbol(
					symbol,
				).thisType;
				return getFlowTypeOfReference(node, type);
			}
			if (isSourceFile(container)) {
				// look up in the source file's locals or exports
				if (container.commonJsModuleIndicator) {
					var fileSymbol = getSymbolOfNode(container);
					return fileSymbol && getTypeOfSymbol(fileSymbol);
				} else if (container.externalModuleIndicator) {
					// TODO: Maybe issue a better error than 'object is possibly undefined'
					return undefinedType;
				} else if (includeGlobalThis) {
					return getTypeOfSymbol(globalThisSymbol);
				}
			}
		}
		function getExplicitThisType(node) {
			var container = getThisContainer(node, /*includeArrowFunctions*/ false);
			if (isFunctionLike(container)) {
				var signature = getSignatureFromDeclaration(container);
				if (signature.thisParameter) {
					return getExplicitTypeOfSymbol(signature.thisParameter);
				}
			}
			if (isClassLike(container.parent)) {
				var symbol = getSymbolOfNode(container.parent);
				return isStatic(container) ? getTypeOfSymbol(symbol) : getDeclaredTypeOfSymbol(
					symbol,
				).thisType;
			}
		}
		function getClassNameFromPrototypeMethod(container) {
			// Check if it's the RHS of a x.prototype.y = function [name]() { .... }
			if (
				container.kind === SyntaxKind.FunctionExpression && isBinaryExpression(
					container.parent,
				) && getAssignmentDeclarationKind(container.parent) === AssignmentDeclarationKind.PrototypeProperty
			) {
				// Get the 'x' of 'x.prototype.y = container'
				return container.parent.left.expression.expression; // x.prototype.y = container // x.prototype.y // x.prototype // x
			} else if (
				container.kind === SyntaxKind.MethodDeclaration && container.parent.kind === SyntaxKind.ObjectLiteralExpression && isBinaryExpression( // x.prototype = { method() { } }
					container.parent.parent,
				) && getAssignmentDeclarationKind(container.parent.parent) === AssignmentDeclarationKind.Prototype
			) {
				return container.parent.parent.left.expression;
			} else if (
				container.kind === SyntaxKind.FunctionExpression && container.parent.kind === SyntaxKind.PropertyAssignment && container.parent.parent.kind === SyntaxKind.ObjectLiteralExpression && isBinaryExpression( // x.prototype = { method: function() { } }
					container.parent.parent.parent,
				) && getAssignmentDeclarationKind(container.parent.parent.parent) === AssignmentDeclarationKind.Prototype
			) {
				return container.parent.parent.parent.left.expression;
			} // Object.defineProperty(x, "method", { get: () => function() { }) }); // Object.defineProperty(x, "method", { set: (x: () => void) => void }); // Object.defineProperty(x, "method", { value: function() { } });
			else if (
				container.kind === SyntaxKind.FunctionExpression && isPropertyAssignment(
					container.parent,
				) && isIdentifier(container.parent.name) && (container.parent.name.escapedText === "value" || container.parent.name.escapedText === "get" || container.parent.name.escapedText === "set") && isObjectLiteralExpression(
					container.parent.parent,
				) && isCallExpression(container.parent.parent.parent) && container.parent.parent.parent.arguments[2] === container.parent.parent && getAssignmentDeclarationKind(
					container.parent.parent.parent,
				) === AssignmentDeclarationKind.ObjectDefinePrototypeProperty
			) {
				return container.parent.parent.parent.arguments[0].expression;
			} // Object.defineProperty(x, "method", { get() { return () => {} } }); // Object.defineProperty(x, "method", { set(x: () => void) {} }); // Object.defineProperty(x, "method", { value() { } });
			else if (
				isMethodDeclaration(container) && isIdentifier(container.name) && (container.name.escapedText === "value" || container.name.escapedText === "get" || container.name.escapedText === "set") && isObjectLiteralExpression(
					container.parent,
				) && isCallExpression(container.parent.parent) && container.parent.parent.arguments[2] === container.parent && getAssignmentDeclarationKind(
					container.parent.parent,
				) === AssignmentDeclarationKind.ObjectDefinePrototypeProperty
			) {
				return container.parent.parent.arguments[0].expression;
			}
		}
		function getTypeForThisExpressionFromJSDoc(node) {
			var jsdocType = getJSDocType(node);
			if (jsdocType && jsdocType.kind === SyntaxKind.JSDocFunctionType) {
				var jsDocFunctionType = jsdocType;
				if (
					jsDocFunctionType.parameters.length > 0 && jsDocFunctionType.parameters[0].name && jsDocFunctionType.parameters[0].name.escapedText === InternalSymbolName.This
				) {
					return getTypeFromTypeNode(jsDocFunctionType.parameters[0].type);
				}
			}
			var thisTag = getJSDocThisTag(node);
			if (thisTag && thisTag.typeExpression) {
				return getTypeFromTypeNode(thisTag.typeExpression);
			}
		}
		function isInConstructorArgumentInitializer(node, constructorDecl) {
			return !!findAncestor(
				node,
				function (n) {
					return isFunctionLikeDeclaration(n) ? "quit" : n.kind === SyntaxKind.Parameter && n.parent === constructorDecl;
				},
			);
		}
		function checkSuperExpression(node) {
			var isCallExpression = node.parent.kind === SyntaxKind.CallExpression && node.parent.expression === node;
			var immediateContainer = getSuperContainer(node, /*stopOnFunctions*/ true);
			var container = immediateContainer;
			var needToCaptureLexicalThis = false;
			// adjust the container reference in case if super is used inside arrow functions with arbitrarily deep nesting
			if (!isCallExpression) {
				while (container && container.kind === SyntaxKind.ArrowFunction) {
					container = getSuperContainer(container, /*stopOnFunctions*/ true);
					needToCaptureLexicalThis = languageVersion < ScriptTarget.ES2015;
				}
			}
			var canUseSuperExpression = isLegalUsageOfSuperExpression(container);
			var nodeCheckFlag = 0;
			if (!canUseSuperExpression) {
				// issue more specific error if super is used in computed property name
				// class A { foo() { return "1" }}
				// class B {
				//     [super.foo()]() {}
				// }
				var current = findAncestor(
					node,
					function (n) {
						return n === container ? "quit" : n.kind === SyntaxKind.ComputedPropertyName;
					},
				);
				if (current && current.kind === SyntaxKind.ComputedPropertyName) {
					error(
						node,
						Diagnostics.super_cannot_be_referenced_in_a_computed_property_name,
					);
				} else if (isCallExpression) {
					error(
						node,
						Diagnostics.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors,
					);
				} else if (
					!container || !container.parent || !(isClassLike(container.parent) || container.parent.kind === SyntaxKind.ObjectLiteralExpression)
				) {
					error(
						node,
						Diagnostics.super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions,
					);
				} else {
					error(
						node,
						Diagnostics.super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class,
					);
				}
				return errorType;
			}
			if (
				!isCallExpression && immediateContainer.kind === SyntaxKind.Constructor
			) {
				checkThisBeforeSuper(
					node,
					container,
					Diagnostics.super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class,
				);
			}
			if (isStatic(container) || isCallExpression) {
				nodeCheckFlag = NodeCheckFlags.SuperStatic;
				if (
					!isCallExpression && languageVersion >= ScriptTarget.ES2015 && languageVersion <= ScriptTarget.ES2021 && (isPropertyDeclaration(
						container,
					) || isClassStaticBlockDeclaration(container))
				) {
					// for `super.x` or `super[x]` in a static initializer, mark all enclosing
					// block scope containers so that we can report potential collisions with
					// `Reflect`.
					forEachEnclosingBlockScopeContainer(
						node.parent,
						function (current) {
							if (!isSourceFile(current) || isExternalOrCommonJsModule(current)) {
								getNodeLinks(current).flags |= NodeCheckFlags.ContainsSuperPropertyInStaticInitializer;
							}
						},
					);
				}
			} else {
				nodeCheckFlag = NodeCheckFlags.SuperInstance;
			}
			getNodeLinks(node).flags |= nodeCheckFlag;
			// Due to how we emit async functions, we need to specialize the emit for an async method that contains a `super` reference.
			// This is due to the fact that we emit the body of an async function inside of a generator function. As generator
			// functions cannot reference `super`, we emit a helper inside of the method body, but outside of the generator. This helper
			// uses an arrow function, which is permitted to reference `super`.
			//
			// There are two primary ways we can access `super` from within an async method. The first is getting the value of a property
			// or indexed access on super, either as part of a right-hand-side expression or call expression. The second is when setting the value
			// of a property or indexed access, either as part of an assignment expression or destructuring assignment.
			//
			// The simplest case is reading a value, in which case we will emit something like the following:
			//
			//  // ts
			//  ...
			//  async asyncMethod() {
			//    let x = await super.asyncMethod();
			//    return x;
			//  }
			//  ...
			//
			//  // js
			//  ...
			//  asyncMethod() {
			//      const _super = Object.create(null, {
			//        asyncMethod: { get: () => super.asyncMethod },
			//      });
			//      return __awaiter(this, arguments, Promise, function *() {
			//          let x = yield _super.asyncMethod.call(this);
			//          return x;
			//      });
			//  }
			//  ...
			//
			// The more complex case is when we wish to assign a value, especially as part of a destructuring assignment. As both cases
			// are legal in ES6, but also likely less frequent, we only emit setters if there is an assignment:
			//
			//  // ts
			//  ...
			//  async asyncMethod(ar: Promise<any[]>) {
			//      [super.a, super.b] = await ar;
			//  }
			//  ...
			//
			//  // js
			//  ...
			//  asyncMethod(ar) {
			//      const _super = Object.create(null, {
			//        a: { get: () => super.a, set: (v) => super.a = v },
			//        b: { get: () => super.b, set: (v) => super.b = v }
			//      };
			//      return __awaiter(this, arguments, Promise, function *() {
			//          [_super.a, _super.b] = yield ar;
			//      });
			//  }
			//  ...
			//
			// Creating an object that has getter and setters instead of just an accessor function is required for destructuring assignments
			// as a call expression cannot be used as the target of a destructuring assignment while a property access can.
			//
			// For element access expressions (`super[x]`), we emit a generic helper that forwards the element access in both situations.
			if (
				container.kind === SyntaxKind.MethodDeclaration && hasSyntacticModifier(
					container,
					ModifierFlags.Async,
				)
			) {
				if (isSuperProperty(node.parent) && isAssignmentTarget(node.parent)) {
					getNodeLinks(container).flags |= NodeCheckFlags.AsyncMethodWithSuperBinding;
				} else {
					getNodeLinks(container).flags |= NodeCheckFlags.AsyncMethodWithSuper;
				}
			}
			if (needToCaptureLexicalThis) {
				// call expressions are allowed only in constructors so they should always capture correct 'this'
				// super property access expressions can also appear in arrow functions -
				// in this case they should also use correct lexical this
				captureLexicalThis(node.parent, container);
			}
			if (container.parent.kind === SyntaxKind.ObjectLiteralExpression) {
				if (languageVersion < ScriptTarget.ES2015) {
					error(
						node,
						Diagnostics.super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_higher,
					);
					return errorType;
				} else {
					// for object literal assume that type of 'super' is 'any'
					return anyType;
				}
			}
			// at this point the only legal case for parent is ClassLikeDeclaration
			var classLikeDeclaration = container.parent;
			if (!getClassExtendsHeritageElement(classLikeDeclaration)) {
				error(node, Diagnostics.super_can_only_be_referenced_in_a_derived_class);
				return errorType;
			}
			var classType = getDeclaredTypeOfSymbol(
				getSymbolOfNode(classLikeDeclaration),
			);
			var baseClassType = classType && getBaseTypes(classType)[0];
			if (!baseClassType) {
				return errorType;
			}
			if (
				container.kind === SyntaxKind.Constructor && isInConstructorArgumentInitializer(
					node,
					container,
				)
			) {
				// issue custom error message for super property access in constructor arguments (to be aligned with old compiler)
				error(
					node,
					Diagnostics.super_cannot_be_referenced_in_constructor_arguments,
				);
				return errorType;
			}
			return nodeCheckFlag === NodeCheckFlags.SuperStatic ? getBaseConstructorTypeOfClass(
				classType,
			) : getTypeWithThisArgument(baseClassType, classType.thisType);
			function isLegalUsageOfSuperExpression(container) {
				if (!container) {
					return false;
				}
				if (isCallExpression) {
					// TS 1.0 SPEC (April 2014): 4.8.1
					// Super calls are only permitted in constructors of derived classes
					return container.kind === SyntaxKind.Constructor;
				} else {
					// TS 1.0 SPEC (April 2014)
					// 'super' property access is allowed
					// - In a constructor, instance member function, instance member accessor, or instance member variable initializer where this references a derived class instance
					// - In a static member function or static member accessor
					// topmost container must be something that is directly nested in the class declaration\object literal expression
					if (
						isClassLike(container.parent) || container.parent.kind === SyntaxKind.ObjectLiteralExpression
					) {
						if (isStatic(container)) {
							return container.kind === SyntaxKind.MethodDeclaration || container.kind === SyntaxKind.MethodSignature || container.kind === SyntaxKind.GetAccessor || container.kind === SyntaxKind.SetAccessor || container.kind === SyntaxKind.PropertyDeclaration || container.kind === SyntaxKind.ClassStaticBlockDeclaration;
						} else {
							return container.kind === SyntaxKind.MethodDeclaration || container.kind === SyntaxKind.MethodSignature || container.kind === SyntaxKind.GetAccessor || container.kind === SyntaxKind.SetAccessor || container.kind === SyntaxKind.PropertyDeclaration || container.kind === SyntaxKind.PropertySignature || container.kind === SyntaxKind.Constructor;
						}
					}
				}
				return false;
			}
		}
		function getContainingObjectLiteral(func) {
			return (func.kind === SyntaxKind.MethodDeclaration || func.kind === SyntaxKind.GetAccessor || func.kind === SyntaxKind.SetAccessor) && func.parent.kind === SyntaxKind.ObjectLiteralExpression ? func.parent : func.kind === SyntaxKind.FunctionExpression && func.parent.kind === SyntaxKind.PropertyAssignment ? func.parent.parent : undefined;
		}
		function getThisTypeArgument(type) {
			return getObjectFlags(type) & ObjectFlags.Reference && type.target === globalThisType ? getTypeArguments(
				type,
			)[0] : undefined;
		}
		function getThisTypeFromContextualType(type) {
			return mapType(
				type,
				function (t) {
					return t.flags & TypeFlags.Intersection ? forEach(
						t.types,
						getThisTypeArgument,
					) : getThisTypeArgument(t);
				},
			);
		}
		function getContextualThisParameterType(func) {
			if (func.kind === SyntaxKind.ArrowFunction) {
				return undefined;
			}
			if (isContextSensitiveFunctionOrObjectLiteralMethod(func)) {
				var contextualSignature = getContextualSignature(func);
				if (contextualSignature) {
					var thisParameter = contextualSignature.thisParameter;
					if (thisParameter) {
						return getTypeOfSymbol(thisParameter);
					}
				}
			}
			var inJs = isInJSFile(func);
			if (noImplicitThis || inJs) {
				var containingLiteral = getContainingObjectLiteral(func);
				if (containingLiteral) {
					// We have an object literal method. Check if the containing object literal has a contextual type
					// that includes a ThisType<T>. If so, T is the contextual type for 'this'. We continue looking in
					// any directly enclosing object literals.
					var contextualType = getApparentTypeOfContextualType(
						containingLiteral,
					);
					var literal = containingLiteral;
					var type = contextualType;
					while (type) {
						var thisType = getThisTypeFromContextualType(type);
						if (thisType) {
							return instantiateType(
								thisType,
								getMapperFromContext(getInferenceContext(containingLiteral)),
							);
						}
						if (literal.parent.kind !== SyntaxKind.PropertyAssignment) {
							break;
						}
						literal = literal.parent.parent;
						type = getApparentTypeOfContextualType(literal);
					}
					// There was no contextual ThisType<T> for the containing object literal, so the contextual type
					// for 'this' is the non-null form of the contextual type for the containing object literal or
					// the type of the object literal itself.
					return getWidenedType(
						contextualType ? getNonNullableType(contextualType) : checkExpressionCached(
							containingLiteral,
						),
					);
				}
				// In an assignment of the form 'obj.xxx = function(...)' or 'obj[xxx] = function(...)', the
				// contextual type for 'this' is 'obj'.
				var parent_11 = walkUpParenthesizedExpressions(func.parent);
				if (
					parent_11.kind === SyntaxKind.BinaryExpression && parent_11.operatorToken.kind === SyntaxKind.EqualsToken
				) {
					var target = parent_11.left;
					if (isAccessExpression(target)) {
						var expression = target.expression;
						// Don't contextually type `this` as `exports` in `exports.Point = function(x, y) { this.x = x; this.y = y; }`
						if (inJs && isIdentifier(expression)) {
							var sourceFile = getSourceFileOfNode(parent_11);
							if (
								sourceFile.commonJsModuleIndicator && getResolvedSymbol(
									expression,
								) === sourceFile.symbol
							) {
								return undefined;
							}
						}
						return getWidenedType(checkExpressionCached(expression));
					}
				}
			}
			return undefined;
		}
		// Return contextual type of parameter or undefined if no contextual type is available
		function getContextuallyTypedParameterType(parameter) {
			var func = parameter.parent;
			if (!isContextSensitiveFunctionOrObjectLiteralMethod(func)) {
				return undefined;
			}
			var iife = getImmediatelyInvokedFunctionExpression(func);
			if (iife && iife.arguments) {
				var args = getEffectiveCallArguments(iife);
				var indexOfParameter = func.parameters.indexOf(parameter);
				if (parameter.dotDotDotToken) {
					return getSpreadArgumentType(
						args,
						indexOfParameter,
						args.length,
						anyType, /*context*/
						undefined,
						0, /* Normal */
					);
				}
				var links = getNodeLinks(iife);
				var cached = links.resolvedSignature;
				links.resolvedSignature = anySignature;
				var type = indexOfParameter < args.length ? getWidenedLiteralType(
					checkExpression(args[indexOfParameter]),
				) : parameter.initializer ? undefined : undefinedWideningType;
				links.resolvedSignature = cached;
				return type;
			}
			var contextualSignature = getContextualSignature(func);
			if (contextualSignature) {
				var index = func.parameters.indexOf(parameter) - (getThisParameter(func) ? 1 : 0);
				return parameter.dotDotDotToken && lastOrUndefined(func.parameters) === parameter ? getRestTypeAtPosition(
					contextualSignature,
					index,
				) : tryGetTypeAtPosition(contextualSignature, index);
			}
		}
		function getContextualTypeForVariableLikeDeclaration(declaration) {
			var typeNode = getEffectiveTypeAnnotationNode(declaration);
			if (typeNode) {
				return getTypeFromTypeNode(typeNode);
			}
			switch (declaration.kind) {
				case SyntaxKind.Parameter:
					return getContextuallyTypedParameterType(declaration);
				case SyntaxKind.BindingElement:
					return getContextualTypeForBindingElement(declaration);
				case SyntaxKind.PropertyDeclaration:
					if (isStatic(declaration)) {
						return getContextualTypeForStaticPropertyDeclaration(declaration);
					} // By default, do nothing and return undefined - only the above cases have context implied by a parent
			}
		}
		function getContextualTypeForBindingElement(declaration) {
			var parent = declaration.parent.parent;
			var name = declaration.propertyName || declaration.name;
			var parentType = getContextualTypeForVariableLikeDeclaration(parent) || parent.kind !== SyntaxKind.BindingElement && parent.initializer && checkDeclarationInitializer(
				parent,
			);
			if (
				!parentType || isBindingPattern(name) || isComputedNonLiteralName(name)
			) return undefined;
			if (parent.name.kind === SyntaxKind.ArrayBindingPattern) {
				var index = indexOfNode(declaration.parent.elements, declaration);
				if (index < 0) return undefined;
				return getContextualTypeForElementExpression(parentType, index);
			}
			var nameType = getLiteralTypeFromPropertyName(name);
			if (isTypeUsableAsPropertyName(nameType)) {
				var text = getPropertyNameFromType(nameType);
				return getTypeOfPropertyOfType(parentType, text);
			}
		}
		function getContextualTypeForStaticPropertyDeclaration(declaration) {
			var parentType = isExpression(declaration.parent) && getContextualType(
				declaration.parent,
			);
			if (!parentType) return undefined;
			return getTypeOfPropertyOfContextualType(
				parentType,
				getSymbolOfNode(declaration).escapedName,
			);
		}
		// In a variable, parameter or property declaration with a type annotation,
		//   the contextual type of an initializer expression is the type of the variable, parameter or property.
		// Otherwise, in a parameter declaration of a contextually typed function expression,
		//   the contextual type of an initializer expression is the contextual type of the parameter.
		// Otherwise, in a variable or parameter declaration with a binding pattern name,
		//   the contextual type of an initializer expression is the type implied by the binding pattern.
		// Otherwise, in a binding pattern inside a variable or parameter declaration,
		//   the contextual type of an initializer expression is the type annotation of the containing declaration, if present.
		function getContextualTypeForInitializerExpression(node, contextFlags) {
			var declaration = node.parent;
			if (hasInitializer(declaration) && node === declaration.initializer) {
				var result = getContextualTypeForVariableLikeDeclaration(declaration);
				if (result) {
					return result;
				}
				if (
					!(contextFlags & ContextFlags.SkipBindingPatterns) && isBindingPattern(
						declaration.name,
					)
				) {
					return getTypeFromBindingPattern(
						declaration.name, // This is less a contextual type and more an implied shape - in some cases, this may be undesirable /*includePatternInType*/
						true, /*reportErrors*/
						false,
					);
				}
			}
			return undefined;
		}
		function getContextualTypeForReturnExpression(node) {
			var func = getContainingFunction(node);
			if (func) {
				var contextualReturnType = getContextualReturnType(func);
				if (contextualReturnType) {
					var functionFlags = getFunctionFlags(func);
					if (functionFlags & FunctionFlags.Generator) {
						var use = functionFlags & FunctionFlags.Async ? 2 : 1; // Generator or AsyncGenerator function /* AsyncGeneratorReturnType */ /* GeneratorReturnType */
						var iterationTypes = getIterationTypesOfIterable(
							contextualReturnType,
							use, /*errorNode*/
							undefined,
						);
						if (!iterationTypes) {
							return undefined;
						}
						contextualReturnType = iterationTypes.returnType; // falls through to unwrap Promise for AsyncGenerators
					}
					if (functionFlags & FunctionFlags.Async) {
						// Get the awaited type without the `Awaited<T>` alias // Async function or AsyncGenerator function
						var contextualAwaitedType = mapType(
							contextualReturnType,
							getAwaitedTypeNoAlias,
						);
						return contextualAwaitedType && getUnionType(
							[
								contextualAwaitedType,
								createPromiseLikeType(contextualAwaitedType),
							],
						);
					}
					return contextualReturnType; // Regular function or Generator function
				}
			}
			return undefined;
		}
		function getContextualTypeForAwaitOperand(node, contextFlags) {
			var contextualType = getContextualType(node, contextFlags);
			if (contextualType) {
				var contextualAwaitedType = getAwaitedTypeNoAlias(contextualType);
				return contextualAwaitedType && getUnionType(
					[contextualAwaitedType, createPromiseLikeType(contextualAwaitedType)],
				);
			}
			return undefined;
		}
		function getContextualTypeForYieldOperand(node) {
			var func = getContainingFunction(node);
			if (func) {
				var functionFlags = getFunctionFlags(func);
				var contextualReturnType = getContextualReturnType(func);
				if (contextualReturnType) {
					return node.asteriskToken ? contextualReturnType : getIterationTypeOfGeneratorFunctionReturnType(
						0, /* Yield */
						contextualReturnType,
						(functionFlags & FunctionFlags.Async) !== 0,
					);
				}
			}
			return undefined;
		}
		function isInParameterInitializerBeforeContainingFunction(node) {
			var inBindingInitializer = false;
			while (node.parent && !isFunctionLike(node.parent)) {
				if (
					isParameter(node.parent) && (inBindingInitializer || node.parent.initializer === node)
				) {
					return true;
				}
				if (isBindingElement(node.parent) && node.parent.initializer === node) {
					inBindingInitializer = true;
				}
				node = node.parent;
			}
			return false;
		}
		function getContextualIterationType(kind, functionDecl) {
			var isAsync = !!(getFunctionFlags(functionDecl) & FunctionFlags.Async);
			var contextualReturnType = getContextualReturnType(functionDecl);
			if (contextualReturnType) {
				return getIterationTypeOfGeneratorFunctionReturnType(
					kind,
					contextualReturnType,
					isAsync,
				) || undefined;
			}
			return undefined;
		}
		function getContextualReturnType(functionDecl) {
			// If the containing function has a return type annotation, is a constructor, or is a get accessor whose
			// corresponding set accessor has a type annotation, return statements in the function are contextually typed
			var returnType = getReturnTypeFromAnnotation(functionDecl);
			if (returnType) {
				return returnType;
			}
			// Otherwise, if the containing function is contextually typed by a function type with exactly one call signature
			// and that call signature is non-generic, return statements are contextually typed by the return type of the signature
			var signature = getContextualSignatureForFunctionLikeDeclaration(
				functionDecl,
			);
			if (signature && !isResolvingReturnTypeOfSignature(signature)) {
				return getReturnTypeOfSignature(signature);
			}
			var iife = getImmediatelyInvokedFunctionExpression(functionDecl);
			if (iife) {
				return getContextualType(iife);
			}
			return undefined;
		}
		// In a typed function call, an argument or substitution expression is contextually typed by the type of the corresponding parameter.
		function getContextualTypeForArgument(callTarget, arg) {
			var args = getEffectiveCallArguments(callTarget);
			var argIndex = args.indexOf(arg); // -1 for e.g. the expression of a CallExpression, or the tag of a TaggedTemplateExpression
			return argIndex === -1 ? undefined : getContextualTypeForArgumentAtIndex(
				callTarget,
				argIndex,
			);
		}
		function getContextualTypeForArgumentAtIndex(callTarget, argIndex) {
			if (isImportCall(callTarget)) {
				return argIndex === 0 ? stringType : argIndex === 1 ? getGlobalImportCallOptionsType(
					false, /*reportErrors*/
				) : anyType;
			}
			// If we're already in the process of resolving the given signature, don't resolve again as
			// that could cause infinite recursion. Instead, return anySignature.
			var signature = getNodeLinks(callTarget).resolvedSignature === resolvingSignature ? resolvingSignature : getResolvedSignature(
				callTarget,
			);
			if (isJsxOpeningLikeElement(callTarget) && argIndex === 0) {
				return getEffectiveFirstArgumentForJsxSignature(signature, callTarget);
			}
			var restIndex = signature.parameters.length - 1;
			return signatureHasRestParameter(signature) && argIndex >= restIndex ? getIndexedAccessType(
				getTypeOfSymbol(signature.parameters[restIndex]),
				getNumberLiteralType(argIndex - restIndex),
				AccessFlags.Contextual,
			) : getTypeAtPosition(signature, argIndex);
		}
		function getContextualTypeForSubstitutionExpression(
			template,
			substitutionExpression,
		) {
			if (template.parent.kind === SyntaxKind.TaggedTemplateExpression) {
				return getContextualTypeForArgument(
					template.parent,
					substitutionExpression,
				);
			}
			return undefined;
		}
		function getContextualTypeForBinaryOperand(node, contextFlags) {
			var binaryExpression = node.parent;
			var left = binaryExpression.left,
				operatorToken = binaryExpression.operatorToken,
				right = binaryExpression.right;
			switch (operatorToken.kind) {
				case SyntaxKind.EqualsToken:
				case SyntaxKind.AmpersandAmpersandEqualsToken:
				case SyntaxKind.BarBarEqualsToken:
				case SyntaxKind.QuestionQuestionEqualsToken:
					return node === right ? getContextualTypeForAssignmentDeclaration(
						binaryExpression,
					) : undefined;
				case SyntaxKind.BarBarToken:
				case SyntaxKind.QuestionQuestionToken:
					// When an || expression has a contextual type, the operands are contextually typed by that type, except
					// when that type originates in a binding pattern, the right operand is contextually typed by the type of
					// the left operand. When an || expression has no contextual type, the right operand is contextually typed
					// by the type of the left operand, except for the special case of Javascript declarations of the form
					// `namespace.prop = namespace.prop || {}`.
					var type = getContextualType(binaryExpression, contextFlags);
					return node === right && (type && type.pattern || !type && !isDefaultedExpandoInitializer(
						binaryExpression,
					)) ? getTypeOfExpression(left) : type;
				case SyntaxKind.AmpersandAmpersandToken:
				case SyntaxKind.CommaToken:
					return node === right ? getContextualType(
						binaryExpression,
						contextFlags,
					) : undefined;
				default:
					return undefined;
			}
		}
		/**
         * Try to find a resolved symbol for an expression without also resolving its type, as
         * getSymbolAtLocation would (as that could be reentrant into contextual typing)
         */
		function getSymbolForExpression(e) {
			if (e.symbol) {
				return e.symbol;
			}
			if (isIdentifier(e)) {
				return getResolvedSymbol(e);
			}
			if (isPropertyAccessExpression(e)) {
				var lhsType = getTypeOfExpression(e.expression);
				return isPrivateIdentifier(e.name) ? tryGetPrivateIdentifierPropertyOfType(
					lhsType,
					e.name,
				) : getPropertyOfType(lhsType, e.name.escapedText);
			}
			return undefined;
			function tryGetPrivateIdentifierPropertyOfType(type, id) {
				var lexicallyScopedSymbol = lookupSymbolForPrivateIdentifierDeclaration(
					id.escapedText,
					id,
				);
				return lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(
					type,
					lexicallyScopedSymbol,
				);
			}
		}
		// In an assignment expression, the right operand is contextually typed by the type of the left operand.
		// Don't do this for assignment declarations unless there is a type tag on the assignment, to avoid circularity from checking the right operand.
		function getContextualTypeForAssignmentDeclaration(binaryExpression) {
			var _a, _b;
			var kind = getAssignmentDeclarationKind(binaryExpression);
			switch (kind) {
				case AssignmentDeclarationKind.None:
				case AssignmentDeclarationKind.ThisProperty:
					var lhsSymbol = getSymbolForExpression(binaryExpression.left);
					var decl = lhsSymbol && lhsSymbol.valueDeclaration;
					// Unannotated, uninitialized property declarations have a type implied by their usage in the constructor.
					// We avoid calling back into `getTypeOfExpression` and reentering contextual typing to avoid a bogus circularity error in that case.
					if (
						decl && (isPropertyDeclaration(decl) || isPropertySignature(decl))
					) {
						var overallAnnotation = getEffectiveTypeAnnotationNode(decl);
						return (overallAnnotation && instantiateType(
							getTypeFromTypeNode(overallAnnotation),
							getSymbolLinks(lhsSymbol).mapper,
						)) || (decl.initializer && getTypeOfExpression(
							binaryExpression.left,
						));
					}
					if (kind === AssignmentDeclarationKind.None) {
						return getTypeOfExpression(binaryExpression.left);
					}
					return getContextualTypeForThisPropertyAssignment(binaryExpression);
				case AssignmentDeclarationKind.Property:
					if (isPossiblyAliasedThisProperty(binaryExpression, kind)) {
						return getContextualTypeForThisPropertyAssignment(binaryExpression);
					} else if (!binaryExpression.left.symbol) { // See `bindStaticPropertyAssignment` in `binder.ts`. // If `binaryExpression.left` was assigned a symbol, then this is a new declaration; otherwise it is an assignment to an existing declaration.
						return getTypeOfExpression(binaryExpression.left);
					} else {
						var decl_1 = binaryExpression.left.symbol.valueDeclaration;
						if (!decl_1) {
							return undefined;
						}
						var lhs = cast(binaryExpression.left, isAccessExpression);
						var overallAnnotation = getEffectiveTypeAnnotationNode(decl_1);
						if (overallAnnotation) {
							return getTypeFromTypeNode(overallAnnotation);
						} else if (isIdentifier(lhs.expression)) {
							var id = lhs.expression;
							var parentSymbol = resolveName(
								id,
								id.escapedText,
								SymbolFlags.Value,
								undefined,
								id.escapedText, /*isUse*/
								true,
							);
							if (parentSymbol) {
								var annotated_1 = parentSymbol.valueDeclaration && getEffectiveTypeAnnotationNode(
									parentSymbol.valueDeclaration,
								);
								if (annotated_1) {
									var nameStr = getElementOrPropertyAccessName(lhs);
									if (nameStr !== undefined) {
										return getTypeOfPropertyOfContextualType(
											getTypeFromTypeNode(annotated_1),
											nameStr,
										);
									}
								}
								return undefined;
							}
						}
						return isInJSFile(decl_1) ? undefined : getTypeOfExpression(
							binaryExpression.left,
						);
					}
				case AssignmentDeclarationKind.ExportsProperty:
				case AssignmentDeclarationKind.Prototype:
				case AssignmentDeclarationKind.PrototypeProperty:
					var valueDeclaration = (_a = binaryExpression.left.symbol) === null || _a === void 0 ? void 0 : _a.valueDeclaration;
				// falls through
				case AssignmentDeclarationKind.ModuleExports:
					valueDeclaration || (valueDeclaration = (_b = binaryExpression.symbol) === null || _b === void 0 ? void 0 : _b.valueDeclaration);
					var annotated = valueDeclaration && getEffectiveTypeAnnotationNode(
						valueDeclaration,
					);
					return annotated ? getTypeFromTypeNode(annotated) : undefined;
				case AssignmentDeclarationKind.ObjectDefinePropertyValue:
				case AssignmentDeclarationKind.ObjectDefinePropertyExports:
				case AssignmentDeclarationKind.ObjectDefinePrototypeProperty:
					return Debug.fail("Does not apply");
				default:
					return Debug.assertNever(kind);
			}
		}
		function isPossiblyAliasedThisProperty(declaration, kind) {
			if (kind === void 0) {
				kind = getAssignmentDeclarationKind(declaration);
			}
			if (kind === AssignmentDeclarationKind.ThisProperty) {
				return true;
			}
			if (
				!isInJSFile(declaration) || kind !== AssignmentDeclarationKind.Property || !isIdentifier(
					declaration.left.expression,
				)
			) {
				return false;
			}
			var name = declaration.left.expression.escapedText;
			var symbol = resolveName(
				declaration.left,
				name,
				SymbolFlags.Value,
				undefined,
				undefined, /*isUse*/
				true, /*excludeGlobals*/
				true,
			);
			return isThisInitializedDeclaration(
				symbol === null || symbol === void 0 ? void 0 : symbol.valueDeclaration,
			);
		}
		function getContextualTypeForThisPropertyAssignment(binaryExpression) {
			if (!binaryExpression.symbol) return getTypeOfExpression(
				binaryExpression.left,
			);
			if (binaryExpression.symbol.valueDeclaration) {
				var annotated = getEffectiveTypeAnnotationNode(
					binaryExpression.symbol.valueDeclaration,
				);
				if (annotated) {
					var type = getTypeFromTypeNode(annotated);
					if (type) {
						return type;
					}
				}
			}
			var thisAccess = cast(binaryExpression.left, isAccessExpression);
			if (
				!isObjectLiteralMethod(
					getThisContainer(
						thisAccess.expression, /*includeArrowFunctions*/
						false,
					),
				)
			) {
				return undefined;
			}
			var thisType = checkThisExpression(thisAccess.expression);
			var nameStr = getElementOrPropertyAccessName(thisAccess);
			return nameStr !== undefined && getTypeOfPropertyOfContextualType(
				thisType,
				nameStr,
			) || undefined;
		}
		function isCircularMappedProperty(symbol) {
			return !!(getCheckFlags(symbol) & CheckFlags.Mapped && !symbol.type && findResolutionCycleStartIndex(
				symbol,
				0, /* Type */
			) >= 0);
		}
		function getTypeOfPropertyOfContextualType(type, name, nameType) {
			return mapType(
				type,
				function (t) {
					var _a;
					if (isGenericMappedType(t)) {
						var constraint = getConstraintTypeFromMappedType(t);
						var constraintOfConstraint = getBaseConstraintOfType(constraint) || constraint;
						var propertyNameType = nameType || getStringLiteralType(
							unescapeLeadingUnderscores(name),
						);
						if (isTypeAssignableTo(propertyNameType, constraintOfConstraint)) {
							return substituteIndexedMappedType(t, propertyNameType);
						}
					} else if (t.flags & TypeFlags.StructuredType) {
						var prop = getPropertyOfType(t, name);
						if (prop) {
							return isCircularMappedProperty(prop) ? undefined : getTypeOfSymbol(
								prop,
							);
						}
						if (isTupleType(t)) {
							var restType = getRestTypeOfTupleType(t);
							if (restType && isNumericLiteralName(name) && +name >= 0) {
								return restType;
							}
						}
						return (_a = findApplicableIndexInfo(
							getIndexInfosOfStructuredType(t),
							nameType || getStringLiteralType(unescapeLeadingUnderscores(name)),
						)) === null || _a === void 0 ? void 0 : _a.type;
					}
					return undefined;
				}, /*noReductions*/
				true,
			);
		}
		// In an object literal contextually typed by a type T, the contextual type of a property assignment is the type of
		// the matching property in T, if one exists. Otherwise, it is the type of the numeric index signature in T, if one
		// exists. Otherwise, it is the type of the string index signature in T, if one exists.
		function getContextualTypeForObjectLiteralMethod(node, contextFlags) {
			Debug.assert(isObjectLiteralMethod(node));
			if (node.flags & NodeFlags.InWithStatement) {
				// We cannot answer semantic questions within a with block, do not proceed any further
				return undefined;
			}
			return getContextualTypeForObjectLiteralElement(node, contextFlags);
		}
		function getContextualTypeForObjectLiteralElement(element, contextFlags) {
			var objectLiteral = element.parent;
			var propertyAssignmentType = isPropertyAssignment(element) && getContextualTypeForVariableLikeDeclaration(
				element,
			);
			if (propertyAssignmentType) {
				return propertyAssignmentType;
			}
			var type = getApparentTypeOfContextualType(objectLiteral, contextFlags);
			if (type) {
				if (hasBindableName(element)) {
					// For a (non-symbol) computed property, there is no reason to look up the name
					// in the type. It will just be "__computed", which does not appear in any
					// SymbolTable.
					var symbol = getSymbolOfNode(element);
					return getTypeOfPropertyOfContextualType(
						type,
						symbol.escapedName,
						getSymbolLinks(symbol).nameType,
					);
				}
				if (element.name) {
					var nameType_2 = getLiteralTypeFromPropertyName(element.name);
					// We avoid calling getApplicableIndexInfo here because it performs potentially expensive intersection reduction.
					return mapType(
						type,
						function (t) {
							var _a;
							return (_a = findApplicableIndexInfo(
								getIndexInfosOfStructuredType(t),
								nameType_2,
							)) === null || _a === void 0 ? void 0 : _a.type;
						}, /*noReductions*/
						true,
					);
				}
			}
			return undefined;
		}
		// In an array literal contextually typed by a type T, the contextual type of an element expression at index N is
		// the type of the property with the numeric name N in T, if one exists. Otherwise, if T has a numeric index signature,
		// it is the type of the numeric index signature in T. Otherwise, in ES6 and higher, the contextual type is the iterated
		// type of T.
		function getContextualTypeForElementExpression(arrayContextualType, index) {
			return arrayContextualType && (getTypeOfPropertyOfContextualType(
				arrayContextualType,
				"" + index,
			) || mapType(
				arrayContextualType,
				function (t) {
					return getIteratedTypeOrElementType(
						1, /* Element */
						t,
						undefinedType, /*errorNode*/
						undefined, /*checkAssignability*/
						false,
					);
				},
				/*noReductions*/ true,
			));
		}
		// In a contextually typed conditional expression, the true/false expressions are contextually typed by the same type.
		function getContextualTypeForConditionalOperand(node, contextFlags) {
			var conditional = node.parent;
			return node === conditional.whenTrue || node === conditional.whenFalse ? getContextualType(
				conditional,
				contextFlags,
			) : undefined;
		}
		function getContextualTypeForChildJsxExpression(node, child) {
			var attributesType = getApparentTypeOfContextualType(
				node.openingElement.tagName,
			);
			// JSX expression is in children of JSX Element, we will look for an "children" attribute (we get the name from JSX.ElementAttributesProperty)
			var jsxChildrenPropertyName = getJsxElementChildrenPropertyName(
				getJsxNamespaceAt(node),
			);
			if (
				!(attributesType && !isTypeAny(attributesType) && jsxChildrenPropertyName && jsxChildrenPropertyName !== "")
			) {
				return undefined;
			}
			var realChildren = getSemanticJsxChildren(node.children);
			var childIndex = realChildren.indexOf(child);
			var childFieldType = getTypeOfPropertyOfContextualType(
				attributesType,
				jsxChildrenPropertyName,
			);
			return childFieldType && (realChildren.length === 1 ? childFieldType : mapType(
				childFieldType,
				function (t) {
					if (isArrayLikeType(t)) {
						return getIndexedAccessType(t, getNumberLiteralType(childIndex));
					} else {
						return t;
					}
				}, /*noReductions*/
				true,
			));
		}
		function getContextualTypeForJsxExpression(node) {
			var exprParent = node.parent;
			return isJsxAttributeLike(exprParent) ? getContextualType(node) : isJsxElement(
				exprParent,
			) ? getContextualTypeForChildJsxExpression(exprParent, node) : undefined;
		}
		function getContextualTypeForJsxAttribute(attribute) {
			// When we trying to resolve JsxOpeningLikeElement as a stateless function element, we will already give its attributes a contextual type
			// which is a type of the parameter of the signature we are trying out.
			// If there is no contextual type (e.g. we are trying to resolve stateful component), get attributes type from resolving element's tagName
			if (isJsxAttribute(attribute)) {
				var attributesType = getApparentTypeOfContextualType(attribute.parent);
				if (!attributesType || isTypeAny(attributesType)) {
					return undefined;
				}
				return getTypeOfPropertyOfContextualType(
					attributesType,
					attribute.name.escapedText,
				);
			} else {
				return getContextualType(attribute.parent);
			}
		}
		// Return true if the given expression is possibly a discriminant value. We limit the kinds of
		// expressions we check to those that don't depend on their contextual type in order not to cause
		// recursive (and possibly infinite) invocations of getContextualType.
		function isPossiblyDiscriminantValue(node) {
			switch (node.kind) {
				case SyntaxKind.StringLiteral:
				case SyntaxKind.NumericLiteral:
				case SyntaxKind.BigIntLiteral:
				case SyntaxKind.NoSubstitutionTemplateLiteral:
				case SyntaxKind.TrueKeyword:
				case SyntaxKind.FalseKeyword:
				case SyntaxKind.NullKeyword:
				case SyntaxKind.Identifier:
				case SyntaxKind.UndefinedKeyword:
					return true;
				case SyntaxKind.PropertyAccessExpression:
				case SyntaxKind.ParenthesizedExpression:
					return isPossiblyDiscriminantValue(node.expression);
				case SyntaxKind.JsxExpression:
					return !node.expression || isPossiblyDiscriminantValue(
						node.expression,
					);
			}
			return false;
		}
		function discriminateContextualTypeByObjectMembers(node, contextualType) {
			return getMatchingUnionConstituentForObjectLiteral(contextualType, node) || discriminateTypeByDiscriminableItems(
				contextualType,
				concatenate(
					map(
						filter(
							node.properties,
							function (p) {
								return !!p.symbol && p.kind === SyntaxKind.PropertyAssignment && isPossiblyDiscriminantValue(
									p.initializer,
								) && isDiscriminantProperty(
									contextualType,
									p.symbol.escapedName,
								);
							},
						),
						function (prop) {
							return [
								function () {
									return getContextFreeTypeOfExpression(prop.initializer);
								},
								prop.symbol.escapedName,
							];
						},
					),
					map(
						filter(
							getPropertiesOfType(contextualType),
							function (s) {
								var _a;
								return !!(s.flags & SymbolFlags.Optional) && !!((_a = node === null || node === void 0 ? void 0 : node.symbol) === null || _a === void 0 ? void 0 : _a.members) && !node.symbol.members.has(
									s.escapedName,
								) && isDiscriminantProperty(contextualType, s.escapedName);
							},
						),
						function (s) {
							return [
								function () {
									return undefinedType;
								},
								s.escapedName,
							];
						},
					),
				),
				isTypeAssignableTo,
				contextualType,
			);
		}
		function discriminateContextualTypeByJSXAttributes(node, contextualType) {
			return discriminateTypeByDiscriminableItems(
				contextualType,
				concatenate(
					map(
						filter(
							node.properties,
							function (p) {
								return !!p.symbol && p.kind === SyntaxKind.JsxAttribute && isDiscriminantProperty(
									contextualType,
									p.symbol.escapedName,
								) && (!p.initializer || isPossiblyDiscriminantValue(
									p.initializer,
								));
							},
						),
						function (prop) {
							return [
								!prop.initializer ? (function () {
									return trueType;
								}) : (function () {
									return getContextFreeTypeOfExpression(prop.initializer);
								}),
								prop.symbol.escapedName,
							];
						},
					),
					map(
						filter(
							getPropertiesOfType(contextualType),
							function (s) {
								var _a;
								return !!(s.flags & SymbolFlags.Optional) && !!((_a = node === null || node === void 0 ? void 0 : node.symbol) === null || _a === void 0 ? void 0 : _a.members) && !node.symbol.members.has(
									s.escapedName,
								) && isDiscriminantProperty(contextualType, s.escapedName);
							},
						),
						function (s) {
							return [
								function () {
									return undefinedType;
								},
								s.escapedName,
							];
						},
					),
				),
				isTypeAssignableTo,
				contextualType,
			);
		}
		// Return the contextual type for a given expression node. During overload resolution, a contextual type may temporarily
		// be "pushed" onto a node using the contextualType property.
		function getApparentTypeOfContextualType(node, contextFlags) {
			var contextualType = isObjectLiteralMethod(node) ? getContextualTypeForObjectLiteralMethod(
				node,
				contextFlags,
			) : getContextualType(node, contextFlags);
			var instantiatedType = instantiateContextualType(
				contextualType,
				node,
				contextFlags,
			);
			if (
				instantiatedType && !(contextFlags && contextFlags & ContextFlags.NoConstraints && instantiatedType.flags & TypeFlags.TypeVariable)
			) {
				var apparentType = mapType(
					instantiatedType,
					getApparentType, /*noReductions*/
					true,
				);
				return apparentType.flags & TypeFlags.Union && isObjectLiteralExpression(
					node,
				) ? discriminateContextualTypeByObjectMembers(node, apparentType) : apparentType.flags & TypeFlags.Union && isJsxAttributes(
					node,
				) ? discriminateContextualTypeByJSXAttributes(node, apparentType) : apparentType;
			}
		}
		// If the given contextual type contains instantiable types and if a mapper representing
		// return type inferences is available, instantiate those types using that mapper.
		function instantiateContextualType(contextualType, node, contextFlags) {
			if (
				contextualType && maybeTypeOfKind(
					contextualType,
					TypeFlags.Instantiable,
				)
			) {
				var inferenceContext = getInferenceContext(node);
				// If no inferences have been made, nothing is gained from instantiating as type parameters
				// would just be replaced with their defaults similar to the apparent type.
				if (
					inferenceContext && some(
						inferenceContext.inferences,
						hasInferenceCandidates,
					)
				) {
					// For contextual signatures we incorporate all inferences made so far, e.g. from return
					// types as well as arguments to the left in a function call.
					if (contextFlags && contextFlags & ContextFlags.Signature) {
						return instantiateInstantiableTypes(
							contextualType,
							inferenceContext.nonFixingMapper,
						);
					}
					// For other purposes (e.g. determining whether to produce literal types) we only
					// incorporate inferences made from the return type in a function call.
					if (inferenceContext.returnMapper) {
						return instantiateInstantiableTypes(
							contextualType,
							inferenceContext.returnMapper,
						);
					}
				}
			}
			return contextualType;
		}
		// This function is similar to instantiateType, except that (a) it only instantiates types that
		// are classified as instantiable (i.e. it doesn't instantiate object types), and (b) it performs
		// no reductions on instantiated union types.
		function instantiateInstantiableTypes(type, mapper) {
			if (type.flags & TypeFlags.Instantiable) {
				return instantiateType(type, mapper);
			}
			if (type.flags & TypeFlags.Union) {
				return getUnionType(
					map(
						type.types,
						function (t) {
							return instantiateInstantiableTypes(t, mapper);
						},
					),
					UnionReduction.None,
				);
			}
			if (type.flags & TypeFlags.Intersection) {
				return getIntersectionType(
					map(
						type.types,
						function (t) {
							return instantiateInstantiableTypes(t, mapper);
						},
					),
				);
			}
			return type;
		}
		/**
         * Whoa! Do you really want to use this function?
         *
         * Unless you're trying to get the *non-apparent* type for a
         * value-literal type or you're authoring relevant portions of this algorithm,
         * you probably meant to use 'getApparentTypeOfContextualType'.
         * Otherwise this may not be very useful.
         *
         * In cases where you *are* working on this function, you should understand
         * when it is appropriate to use 'getContextualType' and 'getApparentTypeOfContextualType'.
         *
         *   - Use 'getContextualType' when you are simply going to propagate the result to the expression.
         *   - Use 'getApparentTypeOfContextualType' when you're going to need the members of the type.
         *
         * @param node the expression whose contextual type will be returned.
         * @returns the contextual type of an expression.
         */
		function getContextualType(node, contextFlags) {
			if (node.flags & NodeFlags.InWithStatement) {
				// We cannot answer semantic questions within a with block, do not proceed any further
				return undefined;
			}
			if (node.contextualType) {
				return node.contextualType;
			}
			var parent = node.parent;
			switch (parent.kind) {
				case SyntaxKind.VariableDeclaration:
				case SyntaxKind.Parameter:
				case SyntaxKind.PropertyDeclaration:
				case SyntaxKind.PropertySignature:
				case SyntaxKind.BindingElement:
					return getContextualTypeForInitializerExpression(node, contextFlags);
				case SyntaxKind.ArrowFunction:
				case SyntaxKind.ReturnStatement:
					return getContextualTypeForReturnExpression(node);
				case SyntaxKind.YieldExpression:
					return getContextualTypeForYieldOperand(parent);
				case SyntaxKind.AwaitExpression:
					return getContextualTypeForAwaitOperand(parent, contextFlags);
				case SyntaxKind.CallExpression:
				case SyntaxKind.NewExpression:
					return getContextualTypeForArgument(parent, node);
				case SyntaxKind.TypeAssertionExpression:
				case SyntaxKind.AsExpression:
					return isConstTypeReference(parent.type) ? tryFindWhenConstTypeReference(
						parent,
					) : getTypeFromTypeNode(parent.type);
				case SyntaxKind.BinaryExpression:
					return getContextualTypeForBinaryOperand(node, contextFlags);
				case SyntaxKind.PropertyAssignment:
				case SyntaxKind.ShorthandPropertyAssignment:
					return getContextualTypeForObjectLiteralElement(parent, contextFlags);
				case SyntaxKind.SpreadAssignment:
					return getContextualType(parent.parent, contextFlags);
				case SyntaxKind.ArrayLiteralExpression:
					{
						var arrayLiteral = parent;
						var type = getApparentTypeOfContextualType(
							arrayLiteral,
							contextFlags,
						);
						return getContextualTypeForElementExpression(
							type,
							indexOfNode(arrayLiteral.elements, node),
						);
					}
				case SyntaxKind.ConditionalExpression:
					return getContextualTypeForConditionalOperand(node, contextFlags);
				case SyntaxKind.TemplateSpan:
					Debug.assert(parent.parent.kind === SyntaxKind.TemplateExpression);
					return getContextualTypeForSubstitutionExpression(parent.parent, node);
				case SyntaxKind.ParenthesizedExpression:
					{
						// Like in `checkParenthesizedExpression`, an `/** @type {xyz} */` comment before a parenthesized expression acts as a type cast.
						var tag = isInJSFile(parent) ? getJSDocTypeTag(parent) : undefined;
						return !tag ? getContextualType(parent, contextFlags) : isJSDocTypeTag(
							tag,
						) && isConstTypeReference(tag.typeExpression.type) ? tryFindWhenConstTypeReference(
							parent,
						) : getTypeFromTypeNode(tag.typeExpression.type);
					}
				case SyntaxKind.NonNullExpression:
					return getContextualType(parent, contextFlags);
				case SyntaxKind.JsxExpression:
					return getContextualTypeForJsxExpression(parent);
				case SyntaxKind.JsxAttribute:
				case SyntaxKind.JsxSpreadAttribute:
					return getContextualTypeForJsxAttribute(parent);
				case SyntaxKind.JsxOpeningElement:
				case SyntaxKind.JsxSelfClosingElement:
					return getContextualJsxElementAttributesType(parent, contextFlags);
			}
			return undefined;
			function tryFindWhenConstTypeReference(node) {
				return getContextualType(node);
			}
		}
		function getInferenceContext(node) {
			var ancestor = findAncestor(
				node,
				function (n) {
					return !!n.inferenceContext;
				},
			);
			return ancestor && ancestor.inferenceContext;
		}
		function getContextualJsxElementAttributesType(node, contextFlags) {
			if (
				isJsxOpeningElement(node) && node.parent.contextualType && contextFlags !== ContextFlags.Completions
			) {
				// Contextually applied type is moved from attributes up to the outer jsx attributes so when walking up from the children they get hit
				// _However_ to hit them from the _attributes_ we must look for them here; otherwise we'll used the declared type
				// (as below) instead!
				return node.parent.contextualType;
			}
			return getContextualTypeForArgumentAtIndex(node, 0);
		}
		function getEffectiveFirstArgumentForJsxSignature(signature, node) {
			return getJsxReferenceKind(node) !== JsxReferenceKind.Component ? getJsxPropsTypeFromCallSignature(
				signature,
				node,
			) : getJsxPropsTypeFromClassType(signature, node);
		}
		function getJsxPropsTypeFromCallSignature(sig, context) {
			var propsType = getTypeOfFirstParameterOfSignatureWithFallback(
				sig,
				unknownType,
			);
			propsType = getJsxManagedAttributesFromLocatedAttributes(
				context,
				getJsxNamespaceAt(context),
				propsType,
			);
			var intrinsicAttribs = getJsxType(JsxNames.IntrinsicAttributes, context);
			if (!isErrorType(intrinsicAttribs)) {
				propsType = intersectTypes(intrinsicAttribs, propsType);
			}
			return propsType;
		}
		function getJsxPropsTypeForSignatureFromMember(sig, forcedLookupLocation) {
			if (sig.compositeSignatures) {
				// JSX Elements using the legacy `props`-field based lookup (eg, react class components) need to treat the `props` member as an input
				// instead of an output position when resolving the signature. We need to go back to the input signatures of the composite signature,
				// get the type of `props` on each return type individually, and then _intersect them_, rather than union them (as would normally occur
				// for a union signature). It's an unfortunate quirk of looking in the output of the signature for the type we want to use for the input.
				// The default behavior of `getTypeOfFirstParameterOfSignatureWithFallback` when no `props` member name is defined is much more sane.
				var results = [];
				for (var _i = 0, _a = sig.compositeSignatures; _i < _a.length; _i++) {
					var signature = _a[_i];
					var instance = getReturnTypeOfSignature(signature);
					if (isTypeAny(instance)) {
						return instance;
					}
					var propType = getTypeOfPropertyOfType(instance, forcedLookupLocation);
					if (!propType) {
						return;
					}
					results.push(propType);
				}
				return getIntersectionType(results); // Same result for both union and intersection signatures
			}
			var instanceType = getReturnTypeOfSignature(sig);
			return isTypeAny(instanceType) ? instanceType : getTypeOfPropertyOfType(
				instanceType,
				forcedLookupLocation,
			);
		}
		function getStaticTypeOfReferencedJsxConstructor(context) {
			if (isJsxIntrinsicIdentifier(context.tagName)) {
				var result = getIntrinsicAttributesTypeFromJsxOpeningLikeElement(
					context,
				);
				var fakeSignature = createSignatureForJSXIntrinsic(context, result);
				return getOrCreateTypeFromSignature(fakeSignature);
			}
			var tagType = checkExpressionCached(context.tagName);
			if (tagType.flags & TypeFlags.StringLiteral) {
				var result = getIntrinsicAttributesTypeFromStringLiteralType(
					tagType,
					context,
				);
				if (!result) {
					return errorType;
				}
				var fakeSignature = createSignatureForJSXIntrinsic(context, result);
				return getOrCreateTypeFromSignature(fakeSignature);
			}
			return tagType;
		}
		function getJsxManagedAttributesFromLocatedAttributes(
			context,
			ns,
			attributesType,
		) {
			var managedSym = getJsxLibraryManagedAttributes(ns);
			if (managedSym) {
				var declaredManagedType = getDeclaredTypeOfSymbol(managedSym); // fetches interface type, or initializes symbol links type parmaeters
				var ctorType = getStaticTypeOfReferencedJsxConstructor(context);
				if (managedSym.flags & SymbolFlags.TypeAlias) {
					var params = getSymbolLinks(managedSym).typeParameters;
					if (length(params) >= 2) {
						var args = fillMissingTypeArguments(
							[ctorType, attributesType],
							params,
							2,
							isInJSFile(context),
						);
						return getTypeAliasInstantiation(managedSym, args);
					}
				}
				if (length(declaredManagedType.typeParameters) >= 2) {
					var args = fillMissingTypeArguments(
						[ctorType, attributesType],
						declaredManagedType.typeParameters,
						2,
						isInJSFile(context),
					);
					return createTypeReference(declaredManagedType, args);
				}
			}
			return attributesType;
		}
		function getJsxPropsTypeFromClassType(sig, context) {
			var ns = getJsxNamespaceAt(context);
			var forcedLookupLocation = getJsxElementPropertiesName(ns);
			var attributesType = forcedLookupLocation === undefined ? getTypeOfFirstParameterOfSignatureWithFallback(
				sig, // If there is no type ElementAttributesProperty, return the type of the first parameter of the signature, which should be the props type
				unknownType,
			) : forcedLookupLocation === "" ? getReturnTypeOfSignature(
				sig, // If there is no e.g. 'props' member in ElementAttributesProperty, use the element class type instead
			) : getJsxPropsTypeForSignatureFromMember(sig, forcedLookupLocation); // Otherwise get the type of the property on the signature return type
			if (!attributesType) {
				// There is no property named 'props' on this instance type
				if (!!forcedLookupLocation && !!length(context.attributes.properties)) {
					error(
						context,
						Diagnostics.JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property,
						unescapeLeadingUnderscores(forcedLookupLocation),
					);
				}
				return unknownType;
			}
			attributesType = getJsxManagedAttributesFromLocatedAttributes(
				context,
				ns,
				attributesType,
			);
			if (isTypeAny(attributesType)) {
				// Props is of type 'any' or unknown
				return attributesType;
			} else {
				// Normal case -- add in IntrinsicClassElements<T> and IntrinsicElements
				var apparentAttributesType = attributesType;
				var intrinsicClassAttribs = getJsxType(
					JsxNames.IntrinsicClassAttributes,
					context,
				);
				if (!isErrorType(intrinsicClassAttribs)) {
					var typeParams = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(
						intrinsicClassAttribs.symbol,
					);
					var hostClassType = getReturnTypeOfSignature(sig);
					apparentAttributesType = intersectTypes(
						typeParams ? createTypeReference(
							intrinsicClassAttribs,
							fillMissingTypeArguments(
								[hostClassType],
								typeParams,
								getMinTypeArgumentCount(typeParams),
								isInJSFile(context),
							),
						) : intrinsicClassAttribs,
						apparentAttributesType,
					);
				}
				var intrinsicAttribs = getJsxType(JsxNames.IntrinsicAttributes, context);
				if (!isErrorType(intrinsicAttribs)) {
					apparentAttributesType = intersectTypes(
						intrinsicAttribs,
						apparentAttributesType,
					);
				}
				return apparentAttributesType;
			}
		}
		function getIntersectedSignatures(signatures) {
			return getStrictOptionValue(compilerOptions, "noImplicitAny") ? reduceLeft(
				signatures,
				function (left, right) {
					return left === right || !left ? left : compareTypeParametersIdentical(
						left.typeParameters,
						right.typeParameters,
					) ? combineSignaturesOfIntersectionMembers(left, right) : undefined;
				},
			) : undefined;
		}
		function combineIntersectionThisParam(left, right, mapper) {
			if (!left || !right) {
				return left || right;
			}
			// A signature `this` type might be a read or a write position... It's very possible that it should be invariant
			// and we should refuse to merge signatures if there are `this` types and they do not match. However, so as to be
			// pessimistic when contextual typing, for now, we'll union the `this` types.
			var thisType = getUnionType(
				[getTypeOfSymbol(left), instantiateType(getTypeOfSymbol(right), mapper)],
			);
			return createSymbolWithType(left, thisType);
		}
		function combineIntersectionParameters(left, right, mapper) {
			var leftCount = getParameterCount(left);
			var rightCount = getParameterCount(right);
			var longest = leftCount >= rightCount ? left : right;
			var shorter = longest === left ? right : left;
			var longestCount = longest === left ? leftCount : rightCount;
			var eitherHasEffectiveRest = (hasEffectiveRestParameter(left) || hasEffectiveRestParameter(
				right,
			));
			var needsExtraRestElement = eitherHasEffectiveRest && !hasEffectiveRestParameter(
				longest,
			);
			var params = new Array(longestCount + (needsExtraRestElement ? 1 : 0));
			for (var i = 0; i < longestCount; i++) {
				var longestParamType = tryGetTypeAtPosition(longest, i);
				if (longest === right) {
					longestParamType = instantiateType(longestParamType, mapper);
				}
				var shorterParamType = tryGetTypeAtPosition(shorter, i) || unknownType;
				if (shorter === right) {
					shorterParamType = instantiateType(shorterParamType, mapper);
				}
				var unionParamType = getUnionType([longestParamType, shorterParamType]);
				var isRestParam = eitherHasEffectiveRest && !needsExtraRestElement && i === (longestCount - 1);
				var isOptional = i >= getMinArgumentCount(longest) && i >= getMinArgumentCount(
					shorter,
				);
				var leftName = i >= leftCount ? undefined : getParameterNameAtPosition(
					left,
					i,
				);
				var rightName = i >= rightCount ? undefined : getParameterNameAtPosition(
					right,
					i,
				);
				var paramName = leftName === rightName ? leftName : !leftName ? rightName : !rightName ? leftName : undefined;
				var paramSymbol = createSymbol(
					SymbolFlags.FunctionScopedVariable | (isOptional && !isRestParam ? SymbolFlags.Optional : 0),
					paramName || "arg".concat(i),
				);
				paramSymbol.type = isRestParam ? createArrayType(unionParamType) : unionParamType;
				params[i] = paramSymbol;
			}
			if (needsExtraRestElement) {
				var restParamSymbol = createSymbol(
					SymbolFlags.FunctionScopedVariable,
					"args",
				);
				restParamSymbol.type = createArrayType(
					getTypeAtPosition(shorter, longestCount),
				);
				if (shorter === right) {
					restParamSymbol.type = instantiateType(restParamSymbol.type, mapper);
				}
				params[longestCount] = restParamSymbol;
			}
			return params;
		}
		function combineSignaturesOfIntersectionMembers(left, right) {
			var typeParams = left.typeParameters || right.typeParameters;
			var paramMapper;
			if (left.typeParameters && right.typeParameters) {
				paramMapper = createTypeMapper(
					right.typeParameters,
					left.typeParameters,
				); // We just use the type parameter defaults from the first signature
			}
			var declaration = left.declaration;
			var params = combineIntersectionParameters(left, right, paramMapper);
			var thisParam = combineIntersectionThisParam(
				left.thisParameter,
				right.thisParameter,
				paramMapper,
			);
			var minArgCount = Math.max(left.minArgumentCount, right.minArgumentCount);
			var result = createSignature(
				declaration,
				typeParams,
				thisParam,
				params,
				/*resolvedReturnType*/ undefined,
				/*resolvedTypePredicate*/ undefined,
				minArgCount,
				(left.flags | right.flags) & SignatureFlags.PropagatingFlags,
			);
			result.compositeKind = TypeFlags.Intersection;
			result.compositeSignatures = concatenate(
				left.compositeKind === TypeFlags.Intersection && left.compositeSignatures || [
					left,
				],
				[right],
			);
			if (paramMapper) {
				result.mapper = left.compositeKind === TypeFlags.Intersection && left.mapper && left.compositeSignatures ? combineTypeMappers(
					left.mapper,
					paramMapper,
				) : paramMapper;
			}
			return result;
		}
		// If the given type is an object or union type with a single signature, and if that signature has at
		// least as many parameters as the given function, return the signature. Otherwise return undefined.
		function getContextualCallSignature(type, node) {
			var signatures = getSignaturesOfType(type, SignatureKind.Call);
			var applicableByArity = filter(
				signatures,
				function (s) {
					return !isAritySmaller(s, node);
				},
			);
			return applicableByArity.length === 1 ? applicableByArity[0] : getIntersectedSignatures(
				applicableByArity,
			);
		}
		/** If the contextual signature has fewer parameters than the function expression, do not use it */
		function isAritySmaller(signature, target) {
			var targetParameterCount = 0;
			for (
				;
				targetParameterCount < target.parameters.length;
				targetParameterCount++
			) {
				var param = target.parameters[targetParameterCount];
				if (
					param.initializer || param.questionToken || param.dotDotDotToken || isJSDocOptionalParameter(
						param,
					)
				) {
					break;
				}
			}
			if (
				target.parameters.length && parameterIsThisKeyword(target.parameters[0])
			) {
				targetParameterCount--;
			}
			return !hasEffectiveRestParameter(signature) && getParameterCount(
				signature,
			) < targetParameterCount;
		}
		function getContextualSignatureForFunctionLikeDeclaration(node) {
			// Only function expressions, arrow functions, and object literal methods are contextually typed.
			return isFunctionExpressionOrArrowFunction(node) || isObjectLiteralMethod(
				node,
			) ? getContextualSignature(node) : undefined;
		}
		// Return the contextual signature for a given expression node. A contextual type provides a
		// contextual signature if it has a single call signature and if that call signature is non-generic.
		// If the contextual type is a union type, get the signature from each type possible and if they are
		// all identical ignoring their return type, the result is same signature but with return type as
		// union type of return types from these signatures
		function getContextualSignature(node) {
			Debug.assert(
				node.kind !== SyntaxKind.MethodDeclaration || isObjectLiteralMethod(
					node,
				),
			);
			var typeTagSignature = getSignatureOfTypeTag(node);
			if (typeTagSignature) {
				return typeTagSignature;
			}
			var type = getApparentTypeOfContextualType(node, ContextFlags.Signature);
			if (!type) {
				return undefined;
			}
			if (!(type.flags & TypeFlags.Union)) {
				return getContextualCallSignature(type, node);
			}
			var signatureList;
			var types = type.types;
			for (var _i = 0, types_19 = types; _i < types_19.length; _i++) {
				var current = types_19[_i];
				var signature = getContextualCallSignature(current, node);
				if (signature) {
					if (!signatureList) {
						// This signature will contribute to contextual union signature
						signatureList = [signature];
					} else if (
						!compareSignaturesIdentical(
							signatureList[0],
							signature, /*partialMatch*/
							false, /*ignoreThisTypes*/
							true, /*ignoreReturnTypes*/
							true,
							compareTypesIdentical,
						)
					) {
						// Signatures aren't identical, do not use
						return undefined;
					} else {
						// Use this signature for contextual union signature
						signatureList.push(signature);
					}
				}
			}
			// Result is union of signatures collected (return type is union of return types of this signature set)
			if (signatureList) {
				return signatureList.length === 1 ? signatureList[0] : createUnionSignature(
					signatureList[0],
					signatureList,
				);
			}
		}
		function checkSpreadExpression(node, checkMode) {
			if (languageVersion < ScriptTarget.ES2015) {
				checkExternalEmitHelpers(
					node,
					compilerOptions.downlevelIteration ? ExternalEmitHelpers.SpreadIncludes : ExternalEmitHelpers.SpreadArray,
				);
			}
			var arrayOrIterableType = checkExpression(node.expression, checkMode);
			return checkIteratedTypeOrElementType(
				33, /* Spread */
				arrayOrIterableType,
				undefinedType,
				node.expression,
			);
		}
		function checkSyntheticExpression(node) {
			return node.isSpread ? getIndexedAccessType(node.type, numberType) : node.type;
		}
		function hasDefaultValue(node) {
			return (node.kind === SyntaxKind.BindingElement && !!node.initializer) || (node.kind === SyntaxKind.BinaryExpression && node.operatorToken.kind === SyntaxKind.EqualsToken);
		}
		function checkArrayLiteral(node, checkMode, forceTuple) {
			var elements = node.elements;
			var elementCount = elements.length;
			var elementTypes = [];
			var elementFlags = [];
			var contextualType = getApparentTypeOfContextualType(node);
			var inDestructuringPattern = isAssignmentTarget(node);
			var inConstContext = isConstContext(node);
			var hasOmittedExpression = false;
			for (var i = 0; i < elementCount; i++) {
				var e = elements[i];
				if (e.kind === SyntaxKind.SpreadElement) {
					if (languageVersion < ScriptTarget.ES2015) {
						checkExternalEmitHelpers(
							e,
							compilerOptions.downlevelIteration ? ExternalEmitHelpers.SpreadIncludes : ExternalEmitHelpers.SpreadArray,
						);
					}
					var spreadType = checkExpression(e.expression, checkMode, forceTuple);
					if (isArrayLikeType(spreadType)) {
						elementTypes.push(spreadType);
						elementFlags.push(ElementFlags.Variadic);
					} else if (inDestructuringPattern) {
						// Given the following situation:
						//    var c: {};
						//    [...c] = ["", 0];
						//
						// c is represented in the tree as a spread element in an array literal.
						// But c really functions as a rest element, and its purpose is to provide
						// a contextual type for the right hand side of the assignment. Therefore,
						// instead of calling checkExpression on "...c", which will give an error
						// if c is not iterable/array-like, we need to act as if we are trying to
						// get the contextual element type from it. So we do something similar to
						// getContextualTypeForElementExpression, which will crucially not error
						// if there is no index type / iterated type.
						var restElementType = getIndexTypeOfType(spreadType, numberType) || getIteratedTypeOrElementType(
							65, /* Destructuring */
							spreadType,
							undefinedType, /*errorNode*/
							undefined, /*checkAssignability*/
							false,
						) || unknownType;
						elementTypes.push(restElementType);
						elementFlags.push(ElementFlags.Rest);
					} else {
						elementTypes.push(
							checkIteratedTypeOrElementType(
								33, /* Spread */
								spreadType,
								undefinedType,
								e.expression,
							),
						);
						elementFlags.push(ElementFlags.Rest);
					}
				} else if (
					exactOptionalPropertyTypes && e.kind === SyntaxKind.OmittedExpression
				) {
					hasOmittedExpression = true;
					elementTypes.push(missingType);
					elementFlags.push(ElementFlags.Optional);
				} else {
					var elementContextualType = getContextualTypeForElementExpression(
						contextualType,
						elementTypes.length,
					);
					var type = checkExpressionForMutableLocation(
						e,
						checkMode,
						elementContextualType,
						forceTuple,
					);
					elementTypes.push(
						addOptionality(type, /*isProperty*/ true, hasOmittedExpression),
					);
					elementFlags.push(
						hasOmittedExpression ? ElementFlags.Optional : ElementFlags.Required,
					);
				}
			}
			if (inDestructuringPattern) {
				return createTupleType(elementTypes, elementFlags);
			}
			if (
				forceTuple || inConstContext || contextualType && someType(
					contextualType,
					isTupleLikeType,
				)
			) {
				return createArrayLiteralType(
					createTupleType(
						elementTypes,
						elementFlags, /*readonly*/
						inConstContext,
					),
				);
			}
			return createArrayLiteralType(
				createArrayType(
					elementTypes.length ? getUnionType(
						sameMap(
							elementTypes,
							function (t, i) {
								return elementFlags[i] & ElementFlags.Variadic ? getIndexedAccessTypeOrUndefined(
									t,
									numberType,
								) || anyType : t;
							},
						),
						UnionReduction.Subtype,
					) : strictNullChecks ? implicitNeverType : undefinedWideningType,
					inConstContext,
				),
			);
		}
		function createArrayLiteralType(type) {
			if (!(getObjectFlags(type) & ObjectFlags.Reference)) {
				return type;
			}
			var literalType = type.literalType;
			if (!literalType) {
				literalType = type.literalType = cloneTypeReference(type);
				literalType.objectFlags |= ObjectFlags.ArrayLiteral | ObjectFlags.ContainsObjectOrArrayLiteral;
			}
			return literalType;
		}
		function isNumericName(name) {
			switch (name.kind) {
				case SyntaxKind.ComputedPropertyName:
					return isNumericComputedName(name);
				case SyntaxKind.Identifier:
					return isNumericLiteralName(name.escapedText);
				case SyntaxKind.NumericLiteral:
				case SyntaxKind.StringLiteral:
					return isNumericLiteralName(name.text);
				default:
					return false;
			}
		}
		function isNumericComputedName(name) {
			// It seems odd to consider an expression of type Any to result in a numeric name,
			// but this behavior is consistent with checkIndexedAccess
			return isTypeAssignableToKind(
				checkComputedPropertyName(name),
				TypeFlags.NumberLike,
			);
		}
		function checkComputedPropertyName(node) {
			var links = getNodeLinks(node.expression);
			if (!links.resolvedType) {
				if (
					(isTypeLiteralNode(node.parent.parent) || isClassLike(
						node.parent.parent,
					) || isInterfaceDeclaration(node.parent.parent)) && isBinaryExpression(
						node.expression,
					) && node.expression.operatorToken.kind === SyntaxKind.InKeyword
				) {
					return links.resolvedType = errorType;
				}
				links.resolvedType = checkExpression(node.expression);
				// The computed property name of a non-static class field within a loop must be stored in a block-scoped binding.
				// (It needs to be bound at class evaluation time.)
				if (
					isPropertyDeclaration(node.parent) && !hasStaticModifier(node.parent) && isClassExpression(
						node.parent.parent,
					)
				) {
					var container = getEnclosingBlockScopeContainer(node.parent.parent);
					var enclosingIterationStatement = getEnclosingIterationStatement(
						container,
					);
					if (enclosingIterationStatement) {
						// The computed field name will use a block scoped binding which can be unique for each iteration of the loop.
						getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlags.LoopWithCapturedBlockScopedBinding;
						// The generated variable which stores the computed field name must be block-scoped.
						getNodeLinks(node).flags |= NodeCheckFlags.BlockScopedBindingInLoop;
						// The generated variable which stores the class must be block-scoped.
						getNodeLinks(node.parent.parent).flags |= NodeCheckFlags.BlockScopedBindingInLoop;
					}
				}
				// This will allow types number, string, symbol or any. It will also allow enums, the unknown
				// type, and any union of these types (like string | number).
				if (
					links.resolvedType.flags & TypeFlags.Nullable || !isTypeAssignableToKind(
						links.resolvedType,
						TypeFlags.StringLike | TypeFlags.NumberLike | TypeFlags.ESSymbolLike,
					) && !isTypeAssignableTo(links.resolvedType, stringNumberSymbolType)
				) {
					error(
						node,
						Diagnostics.A_computed_property_name_must_be_of_type_string_number_symbol_or_any,
					);
				}
			}
			return links.resolvedType;
		}
		function isSymbolWithNumericName(symbol) {
			var _a;
			var firstDecl = (_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a[0];
			return isNumericLiteralName(symbol.escapedName) || (firstDecl && isNamedDeclaration(
				firstDecl,
			) && isNumericName(firstDecl.name));
		}
		function isSymbolWithSymbolName(symbol) {
			var _a;
			var firstDecl = (_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a[0];
			return isKnownSymbol(symbol) || (firstDecl && isNamedDeclaration(
				firstDecl,
			) && isComputedPropertyName(firstDecl.name) && isTypeAssignableToKind(
				checkComputedPropertyName(firstDecl.name),
				TypeFlags.ESSymbol,
			));
		}
		function getObjectLiteralIndexInfo(node, offset, properties, keyType) {
			var propTypes = [];
			for (var i = offset; i < properties.length; i++) {
				var prop = properties[i];
				if (
					keyType === stringType && !isSymbolWithSymbolName(prop) || keyType === numberType && isSymbolWithNumericName(
						prop,
					) || keyType === esSymbolType && isSymbolWithSymbolName(prop)
				) {
					propTypes.push(getTypeOfSymbol(properties[i]));
				}
			}
			var unionType = propTypes.length ? getUnionType(
				propTypes,
				UnionReduction.Subtype,
			) : undefinedType;
			return createIndexInfo(keyType, unionType, isConstContext(node));
		}
		function getImmediateAliasedSymbol(symbol) {
			Debug.assert(
				(symbol.flags & SymbolFlags.Alias) !== 0,
				"Should only get Alias here.",
			);
			var links = getSymbolLinks(symbol);
			if (!links.immediateTarget) {
				var node = getDeclarationOfAliasSymbol(symbol);
				if (!node) return Debug.fail();
				links.immediateTarget = getTargetOfAliasDeclaration(
					node, /*dontRecursivelyResolve*/
					true,
				);
			}
			return links.immediateTarget;
		}
		function checkObjectLiteral(node, checkMode) {
			var inDestructuringPattern = isAssignmentTarget(node);
			// Grammar checking
			checkGrammarObjectLiteralExpression(node, inDestructuringPattern);
			var allPropertiesTable = strictNullChecks ? createSymbolTable() : undefined;
			var propertiesTable = createSymbolTable();
			var propertiesArray = [];
			var spread = emptyObjectType;
			var contextualType = getApparentTypeOfContextualType(node);
			var contextualTypeHasPattern = contextualType && contextualType.pattern && (contextualType.pattern.kind === SyntaxKind.ObjectBindingPattern || contextualType.pattern.kind === SyntaxKind.ObjectLiteralExpression);
			var inConstContext = isConstContext(node);
			var checkFlags = inConstContext ? CheckFlags.Readonly : 0;
			var isInJavascript = isInJSFile(node) && !isInJsonFile(node);
			var enumTag = getJSDocEnumTag(node);
			var isJSObjectLiteral = !contextualType && isInJavascript && !enumTag;
			var objectFlags = freshObjectLiteralFlag;
			var patternWithComputedProperties = false;
			var hasComputedStringProperty = false;
			var hasComputedNumberProperty = false;
			var hasComputedSymbolProperty = false;
			// Spreads may cause an early bail; ensure computed names are always checked (this is cached)
			// As otherwise they may not be checked until exports for the type at this position are retrieved,
			// which may never occur.
			for (var _i = 0, _a = node.properties; _i < _a.length; _i++) {
				var elem = _a[_i];
				if (elem.name && isComputedPropertyName(elem.name)) {
					checkComputedPropertyName(elem.name);
				}
			}
			var offset = 0;
			for (var _b = 0, _c = node.properties; _b < _c.length; _b++) {
				var memberDecl = _c[_b];
				var member = getSymbolOfNode(memberDecl);
				var computedNameType = memberDecl.name && memberDecl.name.kind === SyntaxKind.ComputedPropertyName ? checkComputedPropertyName(
					memberDecl.name,
				) : undefined;
				if (
					memberDecl.kind === SyntaxKind.PropertyAssignment || memberDecl.kind === SyntaxKind.ShorthandPropertyAssignment || isObjectLiteralMethod(
						memberDecl,
					)
				) {
					var type = memberDecl.kind === SyntaxKind.PropertyAssignment ? checkPropertyAssignment(
						memberDecl,
						checkMode,
					) : // we don't want to say "could not find 'a'". // for error recovery purposes. For example, if a user wrote `{ a = 100 }` instead of `{ a: 100 }`. // avoid resolving the left side of the ShorthandPropertyAssignment outside of the destructuring
					memberDecl.kind === SyntaxKind.ShorthandPropertyAssignment ? checkExpressionForMutableLocation(
						!inDestructuringPattern && memberDecl.objectAssignmentInitializer ? memberDecl.objectAssignmentInitializer : memberDecl.name,
						checkMode,
					) : checkObjectLiteralMethod(memberDecl, checkMode);
					if (isInJavascript) {
						var jsDocType = getTypeForDeclarationFromJSDocComment(memberDecl);
						if (jsDocType) {
							checkTypeAssignableTo(type, jsDocType, memberDecl);
							type = jsDocType;
						} else if (enumTag && enumTag.typeExpression) {
							checkTypeAssignableTo(
								type,
								getTypeFromTypeNode(enumTag.typeExpression),
								memberDecl,
							);
						}
					}
					objectFlags |= getObjectFlags(type) & ObjectFlags.PropagatingFlags;
					var nameType = computedNameType && isTypeUsableAsPropertyName(
						computedNameType,
					) ? computedNameType : undefined;
					var prop = nameType ? createSymbol(
						SymbolFlags.Property | member.flags,
						getPropertyNameFromType(nameType),
						checkFlags | CheckFlags.Late,
					) : createSymbol(
						SymbolFlags.Property | member.flags,
						member.escapedName,
						checkFlags,
					);
					if (nameType) {
						prop.nameType = nameType;
					}
					if (inDestructuringPattern) {
						// If object literal is an assignment pattern and if the assignment pattern specifies a default value
						// for the property, make the property optional.
						var isOptional = (memberDecl.kind === SyntaxKind.PropertyAssignment && hasDefaultValue(
							memberDecl.initializer,
						)) || (memberDecl.kind === SyntaxKind.ShorthandPropertyAssignment && memberDecl.objectAssignmentInitializer);
						if (isOptional) {
							prop.flags |= SymbolFlags.Optional;
						}
					} else if (
						contextualTypeHasPattern && !(getObjectFlags(contextualType) & ObjectFlags.ObjectLiteralPatternWithComputedProperties)
					) {
						// If object literal is contextually typed by the implied type of a binding pattern, and if the
						// binding pattern specifies a default value for the property, make the property optional.
						var impliedProp = getPropertyOfType(
							contextualType,
							member.escapedName,
						);
						if (impliedProp) {
							prop.flags |= impliedProp.flags & SymbolFlags.Optional;
						} else if (
							!compilerOptions.suppressExcessPropertyErrors && !getIndexInfoOfType(
								contextualType,
								stringType,
							)
						) {
							error(
								memberDecl.name,
								Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1,
								symbolToString(member),
								typeToString(contextualType),
							);
						}
					}
					prop.declarations = member.declarations;
					prop.parent = member.parent;
					if (member.valueDeclaration) {
						prop.valueDeclaration = member.valueDeclaration;
					}
					prop.type = type;
					prop.target = member;
					member = prop;
					allPropertiesTable === null || allPropertiesTable === void 0 ? void 0 : allPropertiesTable.set(
						prop.escapedName,
						prop,
					);
				} else if (memberDecl.kind === SyntaxKind.SpreadAssignment) {
					if (languageVersion < ScriptTarget.ES2015) {
						checkExternalEmitHelpers(memberDecl, ExternalEmitHelpers.Assign);
					}
					if (propertiesArray.length > 0) {
						spread = getSpreadType(
							spread,
							createObjectLiteralType(),
							node.symbol,
							objectFlags,
							inConstContext,
						);
						propertiesArray = [];
						propertiesTable = createSymbolTable();
						hasComputedStringProperty = false;
						hasComputedNumberProperty = false;
						hasComputedSymbolProperty = false;
					}
					var type = getReducedType(checkExpression(memberDecl.expression));
					if (isValidSpreadType(type)) {
						var mergedType = tryMergeUnionOfObjectTypeAndEmptyObject(
							type,
							inConstContext,
						);
						if (allPropertiesTable) {
							checkSpreadPropOverrides(
								mergedType,
								allPropertiesTable,
								memberDecl,
							);
						}
						offset = propertiesArray.length;
						if (isErrorType(spread)) {
							continue;
						}
						spread = getSpreadType(
							spread,
							mergedType,
							node.symbol,
							objectFlags,
							inConstContext,
						);
					} else {
						error(
							memberDecl,
							Diagnostics.Spread_types_may_only_be_created_from_object_types,
						);
						spread = errorType;
					}
					continue;
				} else {
					// TypeScript 1.0 spec (April 2014)
					// A get accessor declaration is processed in the same manner as
					// an ordinary function declaration(section 6.1) with no parameters.
					// A set accessor declaration is processed in the same manner
					// as an ordinary function declaration with a single parameter and a Void return type.
					Debug.assert(
						memberDecl.kind === SyntaxKind.GetAccessor || memberDecl.kind === SyntaxKind.SetAccessor,
					);
					checkNodeDeferred(memberDecl);
				}
				if (
					computedNameType && !(computedNameType.flags & TypeFlags.StringOrNumberLiteralOrUnique)
				) {
					if (isTypeAssignableTo(computedNameType, stringNumberSymbolType)) {
						if (isTypeAssignableTo(computedNameType, numberType)) {
							hasComputedNumberProperty = true;
						} else if (isTypeAssignableTo(computedNameType, esSymbolType)) {
							hasComputedSymbolProperty = true;
						} else {
							hasComputedStringProperty = true;
						}
						if (inDestructuringPattern) {
							patternWithComputedProperties = true;
						}
					}
				} else {
					propertiesTable.set(member.escapedName, member);
				}
				propertiesArray.push(member);
			}
			// If object literal is contextually typed by the implied type of a binding pattern, augment the result
			// type with those properties for which the binding pattern specifies a default value.
			// If the object literal is spread into another object literal, skip this step and let the top-level object
			// literal handle it instead.
			if (
				contextualTypeHasPattern && node.parent.kind !== SyntaxKind.SpreadAssignment
			) {
				for (
					var _d = 0, _e = getPropertiesOfType(contextualType);
					_d < _e.length;
					_d++
				) {
					var prop = _e[_d];
					if (
						!propertiesTable.get(prop.escapedName) && !getPropertyOfType(
							spread,
							prop.escapedName,
						)
					) {
						if (!(prop.flags & SymbolFlags.Optional)) {
							error(
								prop.valueDeclaration || prop.bindingElement,
								Diagnostics.Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value,
							);
						}
						propertiesTable.set(prop.escapedName, prop);
						propertiesArray.push(prop);
					}
				}
			}
			if (isErrorType(spread)) {
				return errorType;
			}
			if (spread !== emptyObjectType) {
				if (propertiesArray.length > 0) {
					spread = getSpreadType(
						spread,
						createObjectLiteralType(),
						node.symbol,
						objectFlags,
						inConstContext,
					);
					propertiesArray = [];
					propertiesTable = createSymbolTable();
					hasComputedStringProperty = false;
					hasComputedNumberProperty = false;
				}
				// remap the raw emptyObjectType fed in at the top into a fresh empty object literal type, unique to this use site
				return mapType(
					spread,
					function (t) {
						return t === emptyObjectType ? createObjectLiteralType() : t;
					},
				);
			}
			return createObjectLiteralType();
			function createObjectLiteralType() {
				var indexInfos = [];
				if (hasComputedStringProperty) indexInfos.push(
					getObjectLiteralIndexInfo(node, offset, propertiesArray, stringType),
				);
				if (hasComputedNumberProperty) indexInfos.push(
					getObjectLiteralIndexInfo(node, offset, propertiesArray, numberType),
				);
				if (hasComputedSymbolProperty) indexInfos.push(
					getObjectLiteralIndexInfo(node, offset, propertiesArray, esSymbolType),
				);
				var result = createAnonymousType(
					node.symbol,
					propertiesTable,
					emptyArray,
					emptyArray,
					indexInfos,
				);
				result.objectFlags |= objectFlags | ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral;
				if (isJSObjectLiteral) {
					result.objectFlags |= ObjectFlags.JSLiteral;
				}
				if (patternWithComputedProperties) {
					result.objectFlags |= ObjectFlags.ObjectLiteralPatternWithComputedProperties;
				}
				if (inDestructuringPattern) {
					result.pattern = node;
				}
				return result;
			}
		}
		function isValidSpreadType(type) {
			var t = removeDefinitelyFalsyTypes(mapType(type, getBaseConstraintOrType));
			return !!(t.flags & (TypeFlags.Any | TypeFlags.NonPrimitive | TypeFlags.Object | TypeFlags.InstantiableNonPrimitive) || t.flags & TypeFlags.UnionOrIntersection && every(
				t.types,
				isValidSpreadType,
			));
		}
		function checkJsxSelfClosingElementDeferred(node) {
			checkJsxOpeningLikeElementOrOpeningFragment(node);
		}
		function checkJsxSelfClosingElement(node, _checkMode) {
			checkNodeDeferred(node);
			return getJsxElementTypeAt(node) || anyType;
		}
		function checkJsxElementDeferred(node) {
			// Check attributes
			checkJsxOpeningLikeElementOrOpeningFragment(node.openingElement);
			// Perform resolution on the closing tag so that rename/go to definition/etc work
			if (isJsxIntrinsicIdentifier(node.closingElement.tagName)) {
				getIntrinsicTagSymbol(node.closingElement);
			} else {
				checkExpression(node.closingElement.tagName);
			}
			checkJsxChildren(node);
		}
		function checkJsxElement(node, _checkMode) {
			checkNodeDeferred(node);
			return getJsxElementTypeAt(node) || anyType;
		}
		function checkJsxFragment(node) {
			checkJsxOpeningLikeElementOrOpeningFragment(node.openingFragment);
			// by default, jsx:'react' will use jsxFactory = React.createElement and jsxFragmentFactory = React.Fragment
			// if jsxFactory compiler option is provided, ensure jsxFragmentFactory compiler option or @jsxFrag pragma is provided too
			var nodeSourceFile = getSourceFileOfNode(node);
			if (
				getJSXTransformEnabled(compilerOptions) && (compilerOptions.jsxFactory || nodeSourceFile.pragmas.has(
					"jsx",
				)) && !compilerOptions.jsxFragmentFactory && !nodeSourceFile.pragmas.has(
					"jsxfrag",
				)
			) {
				error(
					node,
					compilerOptions.jsxFactory ? Diagnostics.The_jsxFragmentFactory_compiler_option_must_be_provided_to_use_JSX_fragments_with_the_jsxFactory_compiler_option : Diagnostics.An_jsxFrag_pragma_is_required_when_using_an_jsx_pragma_with_JSX_fragments,
				);
			}
			checkJsxChildren(node);
			return getJsxElementTypeAt(node) || anyType;
		}
		function isHyphenatedJsxName(name) {
			return stringContains(name, "-");
		}
		/**
         * Returns true iff React would emit this tag name as a string rather than an identifier or qualified name
         */
		function isJsxIntrinsicIdentifier(tagName) {
			return tagName.kind === SyntaxKind.Identifier && isIntrinsicJsxName(
				tagName.escapedText,
			);
		}
		function checkJsxAttribute(node, checkMode) {
			return node.initializer ? checkExpressionForMutableLocation(
				node.initializer,
				checkMode,
			) : trueType; // <Elem attr /> is sugar for <Elem attr={true} />
		}
		/**
         * Get attributes type of the JSX opening-like element. The result is from resolving "attributes" property of the opening-like element.
         *
         * @param openingLikeElement a JSX opening-like element
         * @param filter a function to remove attributes that will not participate in checking whether attributes are assignable
         * @return an anonymous type (similar to the one returned by checkObjectLiteral) in which its properties are attributes property.
         * @remarks Because this function calls getSpreadType, it needs to use the same checks as checkObjectLiteral,
         * which also calls getSpreadType.
         */
		function createJsxAttributesTypeFromAttributesProperty(
			openingLikeElement,
			checkMode,
		) {
			var attributes = openingLikeElement.attributes;
			var allAttributesTable = strictNullChecks ? createSymbolTable() : undefined;
			var attributesTable = createSymbolTable();
			var spread = emptyJsxObjectType;
			var hasSpreadAnyType = false;
			var typeToIntersect;
			var explicitlySpecifyChildrenAttribute = false;
			var objectFlags = ObjectFlags.JsxAttributes;
			var jsxChildrenPropertyName = getJsxElementChildrenPropertyName(
				getJsxNamespaceAt(openingLikeElement),
			);
			for (var _i = 0, _a = attributes.properties; _i < _a.length; _i++) {
				var attributeDecl = _a[_i];
				var member = attributeDecl.symbol;
				if (isJsxAttribute(attributeDecl)) {
					var exprType = checkJsxAttribute(attributeDecl, checkMode);
					objectFlags |= getObjectFlags(exprType) & ObjectFlags.PropagatingFlags;
					var attributeSymbol = createSymbol(
						SymbolFlags.Property | member.flags,
						member.escapedName,
					);
					attributeSymbol.declarations = member.declarations;
					attributeSymbol.parent = member.parent;
					if (member.valueDeclaration) {
						attributeSymbol.valueDeclaration = member.valueDeclaration;
					}
					attributeSymbol.type = exprType;
					attributeSymbol.target = member;
					attributesTable.set(attributeSymbol.escapedName, attributeSymbol);
					allAttributesTable === null || allAttributesTable === void 0 ? void 0 : allAttributesTable.set(
						attributeSymbol.escapedName,
						attributeSymbol,
					);
					if (attributeDecl.name.escapedText === jsxChildrenPropertyName) {
						explicitlySpecifyChildrenAttribute = true;
					}
				} else {
					Debug.assert(attributeDecl.kind === SyntaxKind.JsxSpreadAttribute);
					if (attributesTable.size > 0) {
						spread = getSpreadType(
							spread,
							createJsxAttributesType(),
							attributes.symbol,
							objectFlags, /*readonly*/
							false,
						);
						attributesTable = createSymbolTable();
					}
					var exprType = getReducedType(
						checkExpressionCached(attributeDecl.expression, checkMode),
					);
					if (isTypeAny(exprType)) {
						hasSpreadAnyType = true;
					}
					if (isValidSpreadType(exprType)) {
						spread = getSpreadType(
							spread,
							exprType,
							attributes.symbol,
							objectFlags, /*readonly*/
							false,
						);
						if (allAttributesTable) {
							checkSpreadPropOverrides(
								exprType,
								allAttributesTable,
								attributeDecl,
							);
						}
					} else {
						typeToIntersect = typeToIntersect ? getIntersectionType(
							[typeToIntersect, exprType],
						) : exprType;
					}
				}
			}
			if (!hasSpreadAnyType) {
				if (attributesTable.size > 0) {
					spread = getSpreadType(
						spread,
						createJsxAttributesType(),
						attributes.symbol,
						objectFlags, /*readonly*/
						false,
					);
				}
			}
			// Handle children attribute
			var parent = openingLikeElement.parent.kind === SyntaxKind.JsxElement ? openingLikeElement.parent : undefined;
			// We have to check that openingElement of the parent is the one we are visiting as this may not be true for selfClosingElement
			if (
				parent && parent.openingElement === openingLikeElement && parent.children.length > 0
			) {
				var childrenTypes = checkJsxChildren(parent, checkMode);
				if (
					!hasSpreadAnyType && jsxChildrenPropertyName && jsxChildrenPropertyName !== ""
				) {
					// Error if there is a attribute named "children" explicitly specified and children element.
					// This is because children element will overwrite the value from attributes.
					// Note: we will not warn "children" attribute overwritten if "children" attribute is specified in object spread.
					if (explicitlySpecifyChildrenAttribute) {
						error(
							attributes,
							Diagnostics._0_are_specified_twice_The_attribute_named_0_will_be_overwritten,
							unescapeLeadingUnderscores(jsxChildrenPropertyName),
						);
					}
					var contextualType = getApparentTypeOfContextualType(
						openingLikeElement.attributes,
					);
					var childrenContextualType = contextualType && getTypeOfPropertyOfContextualType(
						contextualType,
						jsxChildrenPropertyName,
					);
					// If there are children in the body of JSX element, create dummy attribute "children" with the union of children types so that it will pass the attribute checking process
					var childrenPropSymbol = createSymbol(
						SymbolFlags.Property,
						jsxChildrenPropertyName,
					);
					childrenPropSymbol.type = childrenTypes.length === 1 ? childrenTypes[0] : childrenContextualType && someType(
						childrenContextualType,
						isTupleLikeType,
					) ? createTupleType(childrenTypes) : createArrayType(
						getUnionType(childrenTypes),
					);
					// Fake up a property declaration for the children
					childrenPropSymbol.valueDeclaration = factory.createPropertySignature(
						undefined, /*modifiers*/
						unescapeLeadingUnderscores(jsxChildrenPropertyName), /*questionToken*/
						undefined, /*type*/
						undefined,
					);
					setParent(childrenPropSymbol.valueDeclaration, attributes);
					childrenPropSymbol.valueDeclaration.symbol = childrenPropSymbol;
					var childPropMap = createSymbolTable();
					childPropMap.set(jsxChildrenPropertyName, childrenPropSymbol);
					spread = getSpreadType(
						spread,
						createAnonymousType(
							attributes.symbol,
							childPropMap,
							emptyArray,
							emptyArray,
							emptyArray,
						),
						attributes.symbol,
						objectFlags, /*readonly*/
						false,
					);
				}
			}
			if (hasSpreadAnyType) {
				return anyType;
			}
			if (typeToIntersect && spread !== emptyJsxObjectType) {
				return getIntersectionType([typeToIntersect, spread]);
			}
			return typeToIntersect || (spread === emptyJsxObjectType ? createJsxAttributesType() : spread);
			/**
             * Create anonymous type from given attributes symbol table.
             * @param symbol a symbol of JsxAttributes containing attributes corresponding to attributesTable
             * @param attributesTable a symbol table of attributes property
             */
			function createJsxAttributesType() {
				objectFlags |= freshObjectLiteralFlag;
				var result = createAnonymousType(
					attributes.symbol,
					attributesTable,
					emptyArray,
					emptyArray,
					emptyArray,
				);
				result.objectFlags |= objectFlags | ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral;
				return result;
			}
		}
		function checkJsxChildren(node, checkMode) {
			var childrenTypes = [];
			for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
				var child = _a[_i];
				// In React, JSX text that contains only whitespaces will be ignored so we don't want to type-check that
				// because then type of children property will have constituent of string type.
				if (child.kind === SyntaxKind.JsxText) {
					if (!child.containsOnlyTriviaWhiteSpaces) {
						childrenTypes.push(stringType);
					}
				} else if (child.kind === SyntaxKind.JsxExpression && !child.expression) {
					continue; // empty jsx expressions don't *really* count as present children
				} else {
					childrenTypes.push(
						checkExpressionForMutableLocation(child, checkMode),
					);
				}
			}
			return childrenTypes;
		}
		function checkSpreadPropOverrides(type, props, spread) {
			for (var _i = 0, _a = getPropertiesOfType(type); _i < _a.length; _i++) {
				var right = _a[_i];
				if (!(right.flags & SymbolFlags.Optional)) {
					var left = props.get(right.escapedName);
					if (left) {
						var diagnostic = error(
							left.valueDeclaration,
							Diagnostics._0_is_specified_more_than_once_so_this_usage_will_be_overwritten,
							unescapeLeadingUnderscores(left.escapedName),
						);
						addRelatedInfo(
							diagnostic,
							createDiagnosticForNode(
								spread,
								Diagnostics.This_spread_always_overwrites_this_property,
							),
						);
					}
				}
			}
		}
		/**
         * Check attributes property of opening-like element. This function is called during chooseOverload to get call signature of a JSX opening-like element.
         * (See "checkApplicableSignatureForJsxOpeningLikeElement" for how the function is used)
         * @param node a JSXAttributes to be resolved of its type
         */
		function checkJsxAttributes(node, checkMode) {
			return createJsxAttributesTypeFromAttributesProperty(
				node.parent,
				checkMode,
			);
		}
		function getJsxType(name, location) {
			var namespace = getJsxNamespaceAt(location);
			var exports = namespace && getExportsOfSymbol(namespace);
			var typeSymbol = exports && getSymbol(exports, name, SymbolFlags.Type);
			return typeSymbol ? getDeclaredTypeOfSymbol(typeSymbol) : errorType;
		}
		/**
         * Looks up an intrinsic tag name and returns a symbol that either points to an intrinsic
         * property (in which case nodeLinks.jsxFlags will be IntrinsicNamedElement) or an intrinsic
         * string index signature (in which case nodeLinks.jsxFlags will be IntrinsicIndexedElement).
         * May also return unknownSymbol if both of these lookups fail.
         */
		function getIntrinsicTagSymbol(node) {
			var links = getNodeLinks(node);
			if (!links.resolvedSymbol) {
				var intrinsicElementsType = getJsxType(JsxNames.IntrinsicElements, node);
				if (!isErrorType(intrinsicElementsType)) {
					// Property case
					if (!isIdentifier(node.tagName)) return Debug.fail();
					var intrinsicProp = getPropertyOfType(
						intrinsicElementsType,
						node.tagName.escapedText,
					);
					if (intrinsicProp) {
						links.jsxFlags |= JsxFlags.IntrinsicNamedElement;
						return links.resolvedSymbol = intrinsicProp;
					}
					// Intrinsic string indexer case
					var indexSignatureType = getIndexTypeOfType(
						intrinsicElementsType,
						stringType,
					);
					if (indexSignatureType) {
						links.jsxFlags |= JsxFlags.IntrinsicIndexedElement;
						return links.resolvedSymbol = intrinsicElementsType.symbol;
					}
					// Wasn't found
					error(
						node,
						Diagnostics.Property_0_does_not_exist_on_type_1,
						idText(node.tagName),
						"JSX." + JsxNames.IntrinsicElements,
					);
					return links.resolvedSymbol = unknownSymbol;
				} else {
					if (noImplicitAny) {
						error(
							node,
							Diagnostics.JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists,
							unescapeLeadingUnderscores(JsxNames.IntrinsicElements),
						);
					}
					return links.resolvedSymbol = unknownSymbol;
				}
			}
			return links.resolvedSymbol;
		}
		function getJsxNamespaceContainerForImplicitImport(location) {
			var file = location && getSourceFileOfNode(location);
			var links = file && getNodeLinks(file);
			if (links && links.jsxImplicitImportContainer === false) {
				return undefined;
			}
			if (links && links.jsxImplicitImportContainer) {
				return links.jsxImplicitImportContainer;
			}
			var runtimeImportSpecifier = getJSXRuntimeImport(
				getJSXImplicitImportBase(compilerOptions, file),
				compilerOptions,
			);
			if (!runtimeImportSpecifier) {
				return undefined;
			}
			var isClassic = getEmitModuleResolutionKind(compilerOptions) === ModuleResolutionKind.Classic;
			var errorMessage = isClassic ? Diagnostics.Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_node_or_to_add_aliases_to_the_paths_option : Diagnostics.Cannot_find_module_0_or_its_corresponding_type_declarations;
			var mod = resolveExternalModule(
				location,
				runtimeImportSpecifier,
				errorMessage,
				location,
			);
			var result = mod && mod !== unknownSymbol ? getMergedSymbol(
				resolveSymbol(mod),
			) : undefined;
			if (links) {
				links.jsxImplicitImportContainer = result || false;
			}
			return result;
		}
		function getJsxNamespaceAt(location) {
			var links = location && getNodeLinks(location);
			if (links && links.jsxNamespace) {
				return links.jsxNamespace;
			}
			if (!links || links.jsxNamespace !== false) {
				var resolvedNamespace = getJsxNamespaceContainerForImplicitImport(
					location,
				);
				if (!resolvedNamespace || resolvedNamespace === unknownSymbol) {
					var namespaceName = getJsxNamespace(location);
					resolvedNamespace = resolveName(
						location,
						namespaceName,
						SymbolFlags.Namespace, /*diagnosticMessage*/
						undefined,
						namespaceName, /*isUse*/
						false,
					);
				}
				if (resolvedNamespace) {
					var candidate = resolveSymbol(
						getSymbol(
							getExportsOfSymbol(resolveSymbol(resolvedNamespace)),
							JsxNames.JSX,
							SymbolFlags.Namespace,
						),
					);
					if (candidate && candidate !== unknownSymbol) {
						if (links) {
							links.jsxNamespace = candidate;
						}
						return candidate;
					}
				}
				if (links) {
					links.jsxNamespace = false;
				}
			}
			// JSX global fallback
			var s = resolveSymbol(
				getGlobalSymbol(
					JsxNames.JSX,
					SymbolFlags.Namespace, /*diagnosticMessage*/
					undefined,
				),
			);
			if (s === unknownSymbol) {
				return undefined; // TODO: GH#18217
			}
			return s; // TODO: GH#18217
		}
		/**
         * Look into JSX namespace and then look for container with matching name as nameOfAttribPropContainer.
         * Get a single property from that container if existed. Report an error if there are more than one property.
         *
         * @param nameOfAttribPropContainer a string of value JsxNames.ElementAttributesPropertyNameContainer or JsxNames.ElementChildrenAttributeNameContainer
         *          if other string is given or the container doesn't exist, return undefined.
         */
		function getNameFromJsxElementAttributesContainer(
			nameOfAttribPropContainer,
			jsxNamespace,
		) {
			// JSX.ElementAttributesProperty | JSX.ElementChildrenAttribute [symbol]
			var jsxElementAttribPropInterfaceSym = jsxNamespace && getSymbol(
				jsxNamespace.exports,
				nameOfAttribPropContainer,
				SymbolFlags.Type,
			);
			// JSX.ElementAttributesProperty | JSX.ElementChildrenAttribute [type]
			var jsxElementAttribPropInterfaceType = jsxElementAttribPropInterfaceSym && getDeclaredTypeOfSymbol(
				jsxElementAttribPropInterfaceSym,
			);
			// The properties of JSX.ElementAttributesProperty | JSX.ElementChildrenAttribute
			var propertiesOfJsxElementAttribPropInterface = jsxElementAttribPropInterfaceType && getPropertiesOfType(
				jsxElementAttribPropInterfaceType,
			);
			if (propertiesOfJsxElementAttribPropInterface) {
				// Element Attributes has zero properties, so the element attributes type will be the class instance type
				if (propertiesOfJsxElementAttribPropInterface.length === 0) {
					return "";
				} else if (propertiesOfJsxElementAttribPropInterface.length === 1) { // property of the class instance type // Element Attributes has one property, so the element attributes type will be the type of the corresponding
					return propertiesOfJsxElementAttribPropInterface[0].escapedName;
				} else if (
					propertiesOfJsxElementAttribPropInterface.length > 1 && jsxElementAttribPropInterfaceSym.declarations
				) {
					// More than one property on ElementAttributesProperty is an error
					error(
						jsxElementAttribPropInterfaceSym.declarations[0],
						Diagnostics.The_global_type_JSX_0_may_not_have_more_than_one_property,
						unescapeLeadingUnderscores(nameOfAttribPropContainer),
					);
				}
			}
			return undefined;
		}
		function getJsxLibraryManagedAttributes(jsxNamespace) {
			// JSX.LibraryManagedAttributes [symbol]
			return jsxNamespace && getSymbol(
				jsxNamespace.exports,
				JsxNames.LibraryManagedAttributes,
				SymbolFlags.Type,
			);
		}
		/// e.g. "props" for React.d.ts,
		/// or 'undefined' if ElementAttributesProperty doesn't exist (which means all
		///     non-intrinsic elements' attributes type is 'any'),
		/// or '' if it has 0 properties (which means every
		///     non-intrinsic elements' attributes type is the element instance type)
		function getJsxElementPropertiesName(jsxNamespace) {
			return getNameFromJsxElementAttributesContainer(
				JsxNames.ElementAttributesPropertyNameContainer,
				jsxNamespace,
			);
		}
		function getJsxElementChildrenPropertyName(jsxNamespace) {
			return getNameFromJsxElementAttributesContainer(
				JsxNames.ElementChildrenAttributeNameContainer,
				jsxNamespace,
			);
		}
		function getUninstantiatedJsxSignaturesOfType(elementType, caller) {
			if (elementType.flags & TypeFlags.String) {
				return [anySignature];
			} else if (elementType.flags & TypeFlags.StringLiteral) {
				var intrinsicType = getIntrinsicAttributesTypeFromStringLiteralType(
					elementType,
					caller,
				);
				if (!intrinsicType) {
					error(
						caller,
						Diagnostics.Property_0_does_not_exist_on_type_1,
						elementType.value,
						"JSX." + JsxNames.IntrinsicElements,
					);
					return emptyArray;
				} else {
					var fakeSignature = createSignatureForJSXIntrinsic(
						caller,
						intrinsicType,
					);
					return [fakeSignature];
				}
			}
			var apparentElemType = getApparentType(elementType);
			// Resolve the signatures, preferring constructor
			var signatures = getSignaturesOfType(
				apparentElemType,
				SignatureKind.Construct,
			);
			if (signatures.length === 0) {
				// No construct signatures, try call signatures
				signatures = getSignaturesOfType(apparentElemType, SignatureKind.Call);
			}
			if (signatures.length === 0 && apparentElemType.flags & TypeFlags.Union) {
				// If each member has some combination of new/call signatures; make a union signature list for those
				signatures = getUnionSignatures(
					map(
						apparentElemType.types,
						function (t) {
							return getUninstantiatedJsxSignaturesOfType(t, caller);
						},
					),
				);
			}
			return signatures;
		}
		function getIntrinsicAttributesTypeFromStringLiteralType(type, location) {
			// If the elemType is a stringLiteral type, we can then provide a check to make sure that the string literal type is one of the Jsx intrinsic element type
			// For example:
			//      var CustomTag: "h1" = "h1";
			//      <CustomTag> Hello World </CustomTag>
			var intrinsicElementsType = getJsxType(
				JsxNames.IntrinsicElements,
				location,
			);
			if (!isErrorType(intrinsicElementsType)) {
				var stringLiteralTypeName = type.value;
				var intrinsicProp = getPropertyOfType(
					intrinsicElementsType,
					escapeLeadingUnderscores(stringLiteralTypeName),
				);
				if (intrinsicProp) {
					return getTypeOfSymbol(intrinsicProp);
				}
				var indexSignatureType = getIndexTypeOfType(
					intrinsicElementsType,
					stringType,
				);
				if (indexSignatureType) {
					return indexSignatureType;
				}
				return undefined;
			}
			// If we need to report an error, we already done so here. So just return any to prevent any more error downstream
			return anyType;
		}
		function checkJsxReturnAssignableToAppropriateBound(
			refKind,
			elemInstanceType,
			openingLikeElement,
		) {
			if (refKind === JsxReferenceKind.Function) {
				var sfcReturnConstraint = getJsxStatelessElementTypeAt(
					openingLikeElement,
				);
				if (sfcReturnConstraint) {
					checkTypeRelatedTo(
						elemInstanceType,
						sfcReturnConstraint,
						assignableRelation,
						openingLikeElement.tagName,
						Diagnostics.Its_return_type_0_is_not_a_valid_JSX_element,
						generateInitialErrorChain,
					);
				}
			} else if (refKind === JsxReferenceKind.Component) {
				var classConstraint = getJsxElementClassTypeAt(openingLikeElement);
				if (classConstraint) {
					// Issue an error if this return type isn't assignable to JSX.ElementClass, failing that
					checkTypeRelatedTo(
						elemInstanceType,
						classConstraint,
						assignableRelation,
						openingLikeElement.tagName,
						Diagnostics.Its_instance_type_0_is_not_a_valid_JSX_element,
						generateInitialErrorChain,
					);
				}
			} else {
				var sfcReturnConstraint = getJsxStatelessElementTypeAt(
					openingLikeElement, // Mixed
				);
				var classConstraint = getJsxElementClassTypeAt(openingLikeElement);
				if (!sfcReturnConstraint || !classConstraint) {
					return;
				}
				var combined = getUnionType([sfcReturnConstraint, classConstraint]);
				checkTypeRelatedTo(
					elemInstanceType,
					combined,
					assignableRelation,
					openingLikeElement.tagName,
					Diagnostics.Its_element_type_0_is_not_a_valid_JSX_element,
					generateInitialErrorChain,
				);
			}
			function generateInitialErrorChain() {
				var componentName = getTextOfNode(openingLikeElement.tagName);
				return chainDiagnosticMessages(
					undefined, /* details */
					Diagnostics._0_cannot_be_used_as_a_JSX_component,
					componentName,
				);
			}
		}
		/**
         * Get attributes type of the given intrinsic opening-like Jsx element by resolving the tag name.
         * The function is intended to be called from a function which has checked that the opening element is an intrinsic element.
         * @param node an intrinsic JSX opening-like element
         */
		function getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node) {
			Debug.assert(isJsxIntrinsicIdentifier(node.tagName));
			var links = getNodeLinks(node);
			if (!links.resolvedJsxElementAttributesType) {
				var symbol = getIntrinsicTagSymbol(node);
				if (links.jsxFlags & JsxFlags.IntrinsicNamedElement) {
					return links.resolvedJsxElementAttributesType = getTypeOfSymbol(
						symbol,
					) || errorType;
				} else if (links.jsxFlags & JsxFlags.IntrinsicIndexedElement) {
					return links.resolvedJsxElementAttributesType = getIndexTypeOfType(
						getJsxType(JsxNames.IntrinsicElements, node),
						stringType,
					) || errorType;
				} else {
					return links.resolvedJsxElementAttributesType = errorType;
				}
			}
			return links.resolvedJsxElementAttributesType;
		}
		function getJsxElementClassTypeAt(location) {
			var type = getJsxType(JsxNames.ElementClass, location);
			if (isErrorType(type)) return undefined;
			return type;
		}
		function getJsxElementTypeAt(location) {
			return getJsxType(JsxNames.Element, location);
		}
		function getJsxStatelessElementTypeAt(location) {
			var jsxElementType = getJsxElementTypeAt(location);
			if (jsxElementType) {
				return getUnionType([jsxElementType, nullType]);
			}
		}
		/**
         * Returns all the properties of the Jsx.IntrinsicElements interface
         */
		function getJsxIntrinsicTagNamesAt(location) {
			var intrinsics = getJsxType(JsxNames.IntrinsicElements, location);
			return intrinsics ? getPropertiesOfType(intrinsics) : emptyArray;
		}
		function checkJsxPreconditions(errorNode) {
			// Preconditions for using JSX
			if ((compilerOptions.jsx || JsxEmit.None) === JsxEmit.None) {
				error(
					errorNode,
					Diagnostics.Cannot_use_JSX_unless_the_jsx_flag_is_provided,
				);
			}
			if (getJsxElementTypeAt(errorNode) === undefined) {
				if (noImplicitAny) {
					error(
						errorNode,
						Diagnostics.JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist,
					);
				}
			}
		}
		function checkJsxOpeningLikeElementOrOpeningFragment(node) {
			var isNodeOpeningLikeElement = isJsxOpeningLikeElement(node);
			if (isNodeOpeningLikeElement) {
				checkGrammarJsxElement(node);
			}
			checkJsxPreconditions(node);
			if (!getJsxNamespaceContainerForImplicitImport(node)) {
				// The reactNamespace/jsxFactory's root symbol should be marked as 'used' so we don't incorrectly elide its import.
				// And if there is no reactNamespace/jsxFactory's symbol in scope when targeting React emit, we should issue an error.
				var jsxFactoryRefErr = diagnostics && compilerOptions.jsx === JsxEmit.React ? Diagnostics.Cannot_find_name_0 : undefined;
				var jsxFactoryNamespace = getJsxNamespace(node);
				var jsxFactoryLocation = isNodeOpeningLikeElement ? node.tagName : node;
				// allow null as jsxFragmentFactory
				var jsxFactorySym = void 0;
				if (!(isJsxOpeningFragment(node) && jsxFactoryNamespace === "null")) {
					jsxFactorySym = resolveName(
						jsxFactoryLocation,
						jsxFactoryNamespace,
						SymbolFlags.Value,
						jsxFactoryRefErr,
						jsxFactoryNamespace, /*isUse*/
						true,
					);
				}
				if (jsxFactorySym) {
					// Mark local symbol as referenced here because it might not have been marked
					// if jsx emit was not jsxFactory as there wont be error being emitted
					jsxFactorySym.isReferenced = SymbolFlags.All;
					// If react/jsxFactory symbol is alias, mark it as refereced
					if (
						jsxFactorySym.flags & SymbolFlags.Alias && !getTypeOnlyAliasDeclaration(
							jsxFactorySym,
						)
					) {
						markAliasSymbolAsReferenced(jsxFactorySym);
					}
				}
				// For JsxFragment, mark jsx pragma as referenced via resolveName
				if (isJsxOpeningFragment(node)) {
					var file = getSourceFileOfNode(node);
					var localJsxNamespace = getLocalJsxNamespace(file);
					if (localJsxNamespace) {
						resolveName(
							jsxFactoryLocation,
							localJsxNamespace,
							SymbolFlags.Value,
							jsxFactoryRefErr,
							localJsxNamespace, /*isUse*/
							true,
						);
					}
				}
			}
			if (isNodeOpeningLikeElement) {
				var jsxOpeningLikeNode = node;
				var sig = getResolvedSignature(jsxOpeningLikeNode);
				checkDeprecatedSignature(sig, node);
				checkJsxReturnAssignableToAppropriateBound(
					getJsxReferenceKind(jsxOpeningLikeNode),
					getReturnTypeOfSignature(sig),
					jsxOpeningLikeNode,
				);
			}
		}
		/**
         * Check if a property with the given name is known anywhere in the given type. In an object type, a property
         * is considered known if
         * 1. the object type is empty and the check is for assignability, or
         * 2. if the object type has index signatures, or
         * 3. if the property is actually declared in the object type
         *    (this means that 'toString', for example, is not usually a known property).
         * 4. In a union or intersection type,
         *    a property is considered known if it is known in any constituent type.
         * @param targetType a type to search a given name in
         * @param name a property name to search
         * @param isComparingJsxAttributes a boolean flag indicating whether we are searching in JsxAttributesType
         */
		function isKnownProperty(targetType, name, isComparingJsxAttributes) {
			if (targetType.flags & TypeFlags.Object) {
				// For backwards compatibility a symbol-named property is satisfied by a string index signature. This
				// is incorrect and inconsistent with element access expressions, where it is an error, so eventually
				// we should remove this exception.
				if (
					getPropertyOfObjectType(targetType, name) || getApplicableIndexInfoForName(
						targetType,
						name,
					) || isLateBoundName(name) && getIndexInfoOfType(
						targetType,
						stringType,
					) || isComparingJsxAttributes && isHyphenatedJsxName(name)
				) {
					// For JSXAttributes, if the attribute has a hyphenated name, consider that the attribute to be known.
					return true;
				}
			} else if (
				targetType.flags & TypeFlags.UnionOrIntersection && isExcessPropertyCheckTarget(
					targetType,
				)
			) {
				for (var _i = 0, _a = targetType.types; _i < _a.length; _i++) {
					var t = _a[_i];
					if (isKnownProperty(t, name, isComparingJsxAttributes)) {
						return true;
					}
				}
			}
			return false;
		}
		function isExcessPropertyCheckTarget(type) {
			return !!(type.flags & TypeFlags.Object && !(getObjectFlags(type) & ObjectFlags.ObjectLiteralPatternWithComputedProperties) || type.flags & TypeFlags.NonPrimitive || type.flags & TypeFlags.Union && some(
				type.types,
				isExcessPropertyCheckTarget,
			) || type.flags & TypeFlags.Intersection && every(
				type.types,
				isExcessPropertyCheckTarget,
			));
		}
		function checkJsxExpression(node, checkMode) {
			checkGrammarJsxExpression(node);
			if (node.expression) {
				var type = checkExpression(node.expression, checkMode);
				if (node.dotDotDotToken && type !== anyType && !isArrayType(type)) {
					error(node, Diagnostics.JSX_spread_child_must_be_an_array_type);
				}
				return type;
			} else {
				return errorType;
			}
		}
		function getDeclarationNodeFlagsFromSymbol(s) {
			return s.valueDeclaration ? getCombinedNodeFlags(s.valueDeclaration) : 0;
		}
		/**
         * Return whether this symbol is a member of a prototype somewhere
         * Note that this is not tracked well within the compiler, so the answer may be incorrect.
         */
		function isPrototypeProperty(symbol) {
			if (
				symbol.flags & SymbolFlags.Method || getCheckFlags(symbol) & CheckFlags.SyntheticMethod
			) {
				return true;
			}
			if (isInJSFile(symbol.valueDeclaration)) {
				var parent_12 = symbol.valueDeclaration.parent;
				return parent_12 && isBinaryExpression(parent_12) && getAssignmentDeclarationKind(
					parent_12,
				) === AssignmentDeclarationKind.PrototypeProperty;
			}
		}
		/**
         * Check whether the requested property access is valid.
         * Returns true if node is a valid property access, and false otherwise.
         * @param node The node to be checked.
         * @param isSuper True if the access is from `super.`.
         * @param type The type of the object whose property is being accessed. (Not the type of the property.)
         * @param prop The symbol for the property being accessed.
         */
		function checkPropertyAccessibility(
			node,
			isSuper,
			writing,
			type,
			prop,
			reportError,
		) {
			if (reportError === void 0) {
				reportError = true;
			}
			var errorNode = !reportError ? undefined : node.kind === SyntaxKind.QualifiedName ? node.right : node.kind === SyntaxKind.ImportType ? node : node.kind === SyntaxKind.BindingElement && node.propertyName ? node.propertyName : node.name;
			return checkPropertyAccessibilityAtLocation(
				node,
				isSuper,
				writing,
				type,
				prop,
				errorNode,
			);
		}
		/**
         * Check whether the requested property can be accessed at the requested location.
         * Returns true if node is a valid property access, and false otherwise.
         * @param location The location node where we want to check if the property is accessible.
         * @param isSuper True if the access is from `super.`.
         * @param writing True if this is a write property access, false if it is a read property access.
         * @param containingType The type of the object whose property is being accessed. (Not the type of the property.)
         * @param prop The symbol for the property being accessed.
         * @param errorNode The node where we should report an invalid property access error, or undefined if we should not report errors.
         */
		function checkPropertyAccessibilityAtLocation(
			location,
			isSuper,
			writing,
			containingType,
			prop,
			errorNode,
		) {
			var flags = getDeclarationModifierFlagsFromSymbol(prop, writing);
			if (isSuper) {
				// TS 1.0 spec (April 2014): 4.8.2
				// - In a constructor, instance member function, instance member accessor, or
				//   instance member variable initializer where this references a derived class instance,
				//   a super property access is permitted and must specify a public instance member function of the base class.
				// - In a static member function or static member accessor
				//   where this references the constructor function object of a derived class,
				//   a super property access is permitted and must specify a public static member function of the base class.
				if (languageVersion < ScriptTarget.ES2015) {
					if (symbolHasNonMethodDeclaration(prop)) {
						if (errorNode) {
							error(
								errorNode,
								Diagnostics.Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword,
							);
						}
						return false;
					}
				}
				if (flags & ModifierFlags.Abstract) {
					// A method cannot be accessed in a super property access if the method is abstract.
					// This error could mask a private property access error. But, a member
					// cannot simultaneously be private and abstract, so this will trigger an
					// additional error elsewhere.
					if (errorNode) {
						error(
							errorNode,
							Diagnostics.Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression,
							symbolToString(prop),
							typeToString(getDeclaringClass(prop)),
						);
					}
					return false;
				}
			}
			// Referencing abstract properties within their own constructors is not allowed
			if (
				(flags & ModifierFlags.Abstract) && symbolHasNonMethodDeclaration(prop) && (isThisProperty(
					location,
				) || isThisInitializedObjectBindingExpression(location) || isObjectBindingPattern(
					location.parent,
				) && isThisInitializedDeclaration(location.parent.parent))
			) {
				var declaringClassDeclaration = getClassLikeDeclarationOfSymbol(
					getParentOfSymbol(prop),
				);
				if (
					declaringClassDeclaration && isNodeUsedDuringClassInitialization(
						location,
					)
				) {
					if (errorNode) {
						error(
							errorNode,
							Diagnostics.Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor,
							symbolToString(prop),
							getTextOfIdentifierOrLiteral(declaringClassDeclaration.name),
						);
					}
					return false;
				}
			}
			// Public properties are otherwise accessible.
			if (!(flags & ModifierFlags.NonPublicAccessibilityModifier)) {
				return true;
			}
			// Property is known to be private or protected at this point
			// Private property is accessible if the property is within the declaring class
			if (flags & ModifierFlags.Private) {
				var declaringClassDeclaration = getClassLikeDeclarationOfSymbol(
					getParentOfSymbol(prop),
				);
				if (!isNodeWithinClass(location, declaringClassDeclaration)) {
					if (errorNode) {
						error(
							errorNode,
							Diagnostics.Property_0_is_private_and_only_accessible_within_class_1,
							symbolToString(prop),
							typeToString(getDeclaringClass(prop)),
						);
					}
					return false;
				}
				return true;
			}
			// Property is known to be protected at this point
			// All protected properties of a supertype are accessible in a super access
			if (isSuper) {
				return true;
			}
			// Find the first enclosing class that has the declaring classes of the protected constituents
			// of the property as base classes
			var enclosingClass = forEachEnclosingClass(
				location,
				function (enclosingDeclaration) {
					var enclosingClass = getDeclaredTypeOfSymbol(
						getSymbolOfNode(enclosingDeclaration),
					);
					return isClassDerivedFromDeclaringClasses(
						enclosingClass,
						prop,
						writing,
					) ? enclosingClass : undefined;
				},
			);
			// A protected property is accessible if the property is within the declaring class or classes derived from it
			if (!enclosingClass) {
				// allow PropertyAccessibility if context is in function with this parameter
				// static member access is disallow
				var thisParameter = void 0;
				if (
					flags & ModifierFlags.Static || !(thisParameter = getThisParameterFromNodeContext(
						location,
					)) || !thisParameter.type
				) {
					if (errorNode) {
						error(
							errorNode,
							Diagnostics.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses,
							symbolToString(prop),
							typeToString(getDeclaringClass(prop) || containingType),
						);
					}
					return false;
				}
				var thisType = getTypeFromTypeNode(thisParameter.type);
				enclosingClass = ((thisType.flags & TypeFlags.TypeParameter) ? getConstraintOfTypeParameter(
					thisType,
				) : thisType).target;
			}
			// No further restrictions for static properties
			if (flags & ModifierFlags.Static) {
				return true;
			}
			if (containingType.flags & TypeFlags.TypeParameter) {
				// get the original type -- represented as the type constraint of the 'this' type
				containingType = containingType.isThisType ? getConstraintOfTypeParameter(
					containingType,
				) : getBaseConstraintOfType(containingType); // TODO: GH#18217 Use a different variable that's allowed to be undefined
			}
			if (!containingType || !hasBaseType(containingType, enclosingClass)) {
				if (errorNode) {
					error(
						errorNode,
						Diagnostics.Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_This_is_an_instance_of_class_2,
						symbolToString(prop),
						typeToString(enclosingClass),
						typeToString(containingType),
					);
				}
				return false;
			}
			return true;
		}
		function getThisParameterFromNodeContext(node) {
			var thisContainer = getThisContainer(
				node, /* includeArrowFunctions */
				false,
			);
			return thisContainer && isFunctionLike(thisContainer) ? getThisParameter(
				thisContainer,
			) : undefined;
		}
		function symbolHasNonMethodDeclaration(symbol) {
			return !!forEachProperty(
				symbol,
				function (prop) {
					return !(prop.flags & SymbolFlags.Method);
				},
			);
		}
		function checkNonNullExpression(node) {
			return checkNonNullType(checkExpression(node), node);
		}
		function isNullableType(type) {
			return !!((strictNullChecks ? getFalsyFlags(type) : type.flags) & TypeFlags.Nullable);
		}
		function getNonNullableTypeIfNeeded(type) {
			return isNullableType(type) ? getNonNullableType(type) : type;
		}
		function reportObjectPossiblyNullOrUndefinedError(node, flags) {
			error(
				node,
				flags & TypeFlags.Undefined ? flags & TypeFlags.Null ? Diagnostics.Object_is_possibly_null_or_undefined : Diagnostics.Object_is_possibly_undefined : Diagnostics.Object_is_possibly_null,
			);
		}
		function reportCannotInvokePossiblyNullOrUndefinedError(node, flags) {
			error(
				node,
				flags & TypeFlags.Undefined ? flags & TypeFlags.Null ? Diagnostics.Cannot_invoke_an_object_which_is_possibly_null_or_undefined : Diagnostics.Cannot_invoke_an_object_which_is_possibly_undefined : Diagnostics.Cannot_invoke_an_object_which_is_possibly_null,
			);
		}
		function checkNonNullTypeWithReporter(type, node, reportError) {
			if (strictNullChecks && type.flags & TypeFlags.Unknown) {
				error(node, Diagnostics.Object_is_of_type_unknown);
				return errorType;
			}
			var kind = (strictNullChecks ? getFalsyFlags(type) : type.flags) & TypeFlags.Nullable;
			if (kind) {
				reportError(node, kind);
				var t = getNonNullableType(type);
				return t.flags & (TypeFlags.Nullable | TypeFlags.Never) ? errorType : t;
			}
			return type;
		}
		function checkNonNullType(type, node) {
			return checkNonNullTypeWithReporter(
				type,
				node,
				reportObjectPossiblyNullOrUndefinedError,
			);
		}
		function checkNonNullNonVoidType(type, node) {
			var nonNullType = checkNonNullType(type, node);
			if (nonNullType.flags & TypeFlags.Void) {
				error(node, Diagnostics.Object_is_possibly_undefined);
			}
			return nonNullType;
		}
		function checkPropertyAccessExpression(node, checkMode) {
			return node.flags & NodeFlags.OptionalChain ? checkPropertyAccessChain(
				node,
				checkMode,
			) : checkPropertyAccessExpressionOrQualifiedName(
				node,
				node.expression,
				checkNonNullExpression(node.expression),
				node.name,
				checkMode,
			);
		}
		function checkPropertyAccessChain(node, checkMode) {
			var leftType = checkExpression(node.expression);
			var nonOptionalType = getOptionalExpressionType(leftType, node.expression);
			return propagateOptionalTypeMarker(
				checkPropertyAccessExpressionOrQualifiedName(
					node,
					node.expression,
					checkNonNullType(nonOptionalType, node.expression),
					node.name,
					checkMode,
				),
				node,
				nonOptionalType !== leftType,
			);
		}
		function checkQualifiedName(node, checkMode) {
			var leftType = isPartOfTypeQuery(node) && isThisIdentifier(node.left) ? checkNonNullType(
				checkThisExpression(node.left),
				node.left,
			) : checkNonNullExpression(node.left);
			return checkPropertyAccessExpressionOrQualifiedName(
				node,
				node.left,
				leftType,
				node.right,
				checkMode,
			);
		}
		function isMethodAccessForCall(node) {
			while (node.parent.kind === SyntaxKind.ParenthesizedExpression) {
				node = node.parent;
			}
			return isCallOrNewExpression(node.parent) && node.parent.expression === node;
		}
		// Lookup the private identifier lexically.
		function lookupSymbolForPrivateIdentifierDeclaration(propName, location) {
			for (
				var containingClass = getContainingClass(location);
				!!containingClass;
				containingClass = getContainingClass(containingClass)
			) {
				var symbol = containingClass.symbol;
				var name_21 = getSymbolNameForPrivateIdentifier(symbol, propName);
				var prop = (symbol.members && symbol.members.get(name_21)) || (symbol.exports && symbol.exports.get(
					name_21,
				));
				if (prop) {
					return prop;
				}
			}
		}
		function checkGrammarPrivateIdentifierExpression(privId) {
			if (!getContainingClass(privId)) {
				return grammarErrorOnNode(
					privId,
					Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies,
				);
			}
			if (!isForInStatement(privId.parent)) {
				if (!isExpressionNode(privId)) {
					return grammarErrorOnNode(
						privId,
						Diagnostics.Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member_declaration_property_access_or_on_the_left_hand_side_of_an_in_expression,
					);
				}
				var isInOperation = isBinaryExpression(privId.parent) && privId.parent.operatorToken.kind === SyntaxKind.InKeyword;
				if (!getSymbolForPrivateIdentifierExpression(privId) && !isInOperation) {
					return grammarErrorOnNode(
						privId,
						Diagnostics.Cannot_find_name_0,
						idText(privId),
					);
				}
			}
			return false;
		}
		function checkPrivateIdentifierExpression(privId) {
			checkGrammarPrivateIdentifierExpression(privId);
			var symbol = getSymbolForPrivateIdentifierExpression(privId);
			if (symbol) {
				markPropertyAsReferenced(
					symbol, /* nodeForCheckWriteOnly: */
					undefined, /* isThisAccess: */
					false,
				);
			}
			return anyType;
		}
		function getSymbolForPrivateIdentifierExpression(privId) {
			if (!isExpressionNode(privId)) {
				return undefined;
			}
			var links = getNodeLinks(privId);
			if (links.resolvedSymbol === undefined) {
				links.resolvedSymbol = lookupSymbolForPrivateIdentifierDeclaration(
					privId.escapedText,
					privId,
				);
			}
			return links.resolvedSymbol;
		}
		function getPrivateIdentifierPropertyOfType(
			leftType,
			lexicallyScopedIdentifier,
		) {
			return getPropertyOfType(leftType, lexicallyScopedIdentifier.escapedName);
		}
		function checkPrivateIdentifierPropertyAccess(
			leftType,
			right,
			lexicallyScopedIdentifier,
		) {
			// Either the identifier could not be looked up in the lexical scope OR the lexically scoped identifier did not exist on the type.
			// Find a private identifier with the same description on the type.
			var propertyOnType;
			var properties = getPropertiesOfType(leftType);
			if (properties) {
				forEach(
					properties,
					function (symbol) {
						var decl = symbol.valueDeclaration;
						if (
							decl && isNamedDeclaration(decl) && isPrivateIdentifier(decl.name) && decl.name.escapedText === right.escapedText
						) {
							propertyOnType = symbol;
							return true;
						}
					},
				);
			}
			var diagName = diagnosticName(right);
			if (propertyOnType) {
				var typeValueDecl = Debug.checkDefined(propertyOnType.valueDeclaration);
				var typeClass_1 = Debug.checkDefined(getContainingClass(typeValueDecl));
				// We found a private identifier property with the same description.
				// Either:
				// - There is a lexically scoped private identifier AND it shadows the one we found on the type.
				// - It is an attempt to access the private identifier outside of the class.
				if (
					lexicallyScopedIdentifier === null || lexicallyScopedIdentifier === void 0 ? void 0 : lexicallyScopedIdentifier.valueDeclaration
				) {
					var lexicalValueDecl = lexicallyScopedIdentifier.valueDeclaration;
					var lexicalClass = getContainingClass(lexicalValueDecl);
					Debug.assert(!!lexicalClass);
					if (
						findAncestor(
							lexicalClass,
							function (n) {
								return typeClass_1 === n;
							},
						)
					) {
						var diagnostic = error(
							right,
							Diagnostics.The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_private_identifier_with_the_same_spelling,
							diagName,
							typeToString(leftType),
						);
						addRelatedInfo(
							diagnostic,
							createDiagnosticForNode(
								lexicalValueDecl,
								Diagnostics.The_shadowing_declaration_of_0_is_defined_here,
								diagName,
							),
							createDiagnosticForNode(
								typeValueDecl,
								Diagnostics.The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here,
								diagName,
							),
						);
						return true;
					}
				}
				error(
					right,
					Diagnostics.Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier,
					diagName,
					diagnosticName(typeClass_1.name || anon),
				);
				return true;
			}
			return false;
		}
		function isThisPropertyAccessInConstructor(node, prop) {
			return (isConstructorDeclaredProperty(prop) || isThisProperty(node) && isAutoTypedProperty(
				prop,
			)) && getThisContainer(node, /*includeArrowFunctions*/ true) === getDeclaringConstructor(
				prop,
			);
		}
		function checkPropertyAccessExpressionOrQualifiedName(
			node,
			left,
			leftType,
			right,
			checkMode,
		) {
			var parentSymbol = getNodeLinks(left).resolvedSymbol;
			var assignmentKind = getAssignmentTargetKind(node);
			var apparentType = getApparentType(
				assignmentKind !== AssignmentKind.None || isMethodAccessForCall(node) ? getWidenedType(
					leftType,
				) : leftType,
			);
			var isAnyLike = isTypeAny(apparentType) || apparentType === silentNeverType;
			var prop;
			if (isPrivateIdentifier(right)) {
				if (languageVersion < ScriptTarget.ESNext) {
					if (assignmentKind !== AssignmentKind.None) {
						checkExternalEmitHelpers(
							node,
							ExternalEmitHelpers.ClassPrivateFieldSet,
						);
					}
					if (assignmentKind !== AssignmentKind.Definite) {
						checkExternalEmitHelpers(
							node,
							ExternalEmitHelpers.ClassPrivateFieldGet,
						);
					}
				}
				var lexicallyScopedSymbol = lookupSymbolForPrivateIdentifierDeclaration(
					right.escapedText,
					right,
				);
				if (
					assignmentKind && lexicallyScopedSymbol && lexicallyScopedSymbol.valueDeclaration && isMethodDeclaration(
						lexicallyScopedSymbol.valueDeclaration,
					)
				) {
					grammarErrorOnNode(
						right,
						Diagnostics.Cannot_assign_to_private_method_0_Private_methods_are_not_writable,
						idText(right),
					);
				}
				if (
					(lexicallyScopedSymbol === null || lexicallyScopedSymbol === void 0 ? void 0 : lexicallyScopedSymbol.valueDeclaration) && (getEmitScriptTarget(
						compilerOptions,
					) === ScriptTarget.ESNext && !useDefineForClassFields)
				) {
					var lexicalClass_1 = getContainingClass(
						lexicallyScopedSymbol.valueDeclaration,
					);
					var parentStaticFieldInitializer = findAncestor(
						node,
						function (n) {
							if (n === lexicalClass_1) return "quit";
							if (
								isPropertyDeclaration(n.parent) && hasStaticModifier(n.parent) && n.parent.initializer === n && n.parent.parent === lexicalClass_1
							) {
								return true;
							}
							return false;
						},
					);
					if (parentStaticFieldInitializer) {
						var parentStaticFieldInitializerSymbol = getSymbolOfNode(
							parentStaticFieldInitializer.parent,
						);
						Debug.assert(
							parentStaticFieldInitializerSymbol,
							"Initializer without declaration symbol",
						);
						var diagnostic = error(
							node,
							Diagnostics.Property_0_may_not_be_used_in_a_static_property_s_initializer_in_the_same_class_when_target_is_esnext_and_useDefineForClassFields_is_false,
							symbolName(lexicallyScopedSymbol),
						);
						addRelatedInfo(
							diagnostic,
							createDiagnosticForNode(
								parentStaticFieldInitializer.parent,
								Diagnostics.Initializer_for_property_0,
								symbolName(parentStaticFieldInitializerSymbol),
							),
						);
					}
				}
				if (isAnyLike) {
					if (lexicallyScopedSymbol) {
						return isErrorType(apparentType) ? errorType : apparentType;
					}
					if (!getContainingClass(right)) {
						grammarErrorOnNode(
							right,
							Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies,
						);
						return anyType;
					}
				}
				prop = lexicallyScopedSymbol ? getPrivateIdentifierPropertyOfType(
					leftType,
					lexicallyScopedSymbol,
				) : undefined;
				// Check for private-identifier-specific shadowing and lexical-scoping errors.
				if (
					!prop && checkPrivateIdentifierPropertyAccess(
						leftType,
						right,
						lexicallyScopedSymbol,
					)
				) {
					return errorType;
				} else {
					var isSetonlyAccessor = prop && prop.flags & SymbolFlags.SetAccessor && !(prop.flags & SymbolFlags.GetAccessor);
					if (isSetonlyAccessor && assignmentKind !== AssignmentKind.Definite) {
						error(
							node,
							Diagnostics.Private_accessor_was_defined_without_a_getter,
						);
					}
				}
			} else {
				if (isAnyLike) {
					if (isIdentifier(left) && parentSymbol) {
						markAliasReferenced(parentSymbol, node);
					}
					return isErrorType(apparentType) ? errorType : apparentType;
				}
				prop = getPropertyOfType(apparentType, right.escapedText);
			}
			// In `Foo.Bar.Baz`, 'Foo' is not referenced if 'Bar' is a const enum or a module containing only const enums.
			// The exceptions are:
			//   1. if 'isolatedModules' is enabled, because the const enum value will not be inlined, and
			//   2. if 'preserveConstEnums' is enabled and the expression is itself an export, e.g. `export = Foo.Bar.Baz`.
			if (
				isIdentifier(left) && parentSymbol && (compilerOptions.isolatedModules || !(prop && isConstEnumOrConstEnumOnlyModule(
					prop,
				)) || shouldPreserveConstEnums(compilerOptions) && isExportOrExportExpression(
					node,
				))
			) {
				markAliasReferenced(parentSymbol, node);
			}
			var propType;
			if (!prop) {
				var indexInfo = !isPrivateIdentifier(right) && (assignmentKind === AssignmentKind.None || !isGenericObjectType(
					leftType,
				) || isThisTypeParameter(leftType)) ? getApplicableIndexInfoForName(
					apparentType,
					right.escapedText,
				) : undefined;
				if (!(indexInfo && indexInfo.type)) {
					var isUncheckedJS = isUncheckedJSSuggestion(
						node,
						leftType.symbol, /*excludeClasses*/
						true,
					);
					if (!isUncheckedJS && isJSLiteralType(leftType)) {
						return anyType;
					}
					if (leftType.symbol === globalThisSymbol) {
						if (
							globalThisSymbol.exports.has(right.escapedText) && (globalThisSymbol.exports.get(
								right.escapedText,
							).flags & SymbolFlags.BlockScoped)
						) {
							error(
								right,
								Diagnostics.Property_0_does_not_exist_on_type_1,
								unescapeLeadingUnderscores(right.escapedText),
								typeToString(leftType),
							);
						} else if (noImplicitAny) {
							error(
								right,
								Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature,
								typeToString(leftType),
							);
						}
						return anyType;
					}
					if (
						right.escapedText && !checkAndReportErrorForExtendingInterface(node)
					) {
						reportNonexistentProperty(
							right,
							isThisTypeParameter(leftType) ? apparentType : leftType,
							isUncheckedJS,
						);
					}
					return errorType;
				}
				if (
					indexInfo.isReadonly && (isAssignmentTarget(node) || isDeleteTarget(
						node,
					))
				) {
					error(
						node,
						Diagnostics.Index_signature_in_type_0_only_permits_reading,
						typeToString(apparentType),
					);
				}
				propType = (compilerOptions.noUncheckedIndexedAccess && !isAssignmentTarget(
					node,
				)) ? getUnionType([indexInfo.type, undefinedType]) : indexInfo.type;
				if (
					compilerOptions.noPropertyAccessFromIndexSignature && isPropertyAccessExpression(
						node,
					)
				) {
					error(
						right,
						Diagnostics.Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0,
						unescapeLeadingUnderscores(right.escapedText),
					);
				}
			} else {
				if (
					prop.declarations && getDeclarationNodeFlagsFromSymbol(prop) & NodeFlags.Deprecated && isUncalledFunctionReference(
						node,
						prop,
					)
				) {
					addDeprecatedSuggestion(right, prop.declarations, right.escapedText);
				}
				checkPropertyNotUsedBeforeDeclaration(prop, node, right);
				markPropertyAsReferenced(
					prop,
					node,
					isSelfTypeAccess(left, parentSymbol),
				);
				getNodeLinks(node).resolvedSymbol = prop;
				var writing = isWriteAccess(node);
				checkPropertyAccessibility(
					node,
					left.kind === SyntaxKind.SuperKeyword,
					writing,
					apparentType,
					prop,
				);
				if (isAssignmentToReadonlyEntity(node, prop, assignmentKind)) {
					error(
						right,
						Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property,
						idText(right),
					);
					return errorType;
				}
				propType = isThisPropertyAccessInConstructor(node, prop) ? autoType : writing ? getSetAccessorTypeOfSymbol(
					prop,
				) : getTypeOfSymbol(prop);
			}
			return getFlowTypeOfAccessExpression(
				node,
				prop,
				propType,
				right,
				checkMode,
			);
		}
		/**
         * Determines whether a did-you-mean error should be a suggestion in an unchecked JS file.
         * Only applies to unchecked JS files without checkJS, // @ts-check or // @ts-nocheck
         * It does not suggest when the suggestion:
         * - Is from a global file that is different from the reference file, or
         * - (optionally) Is a class, or is a this.x property access expression
         */
		function isUncheckedJSSuggestion(node, suggestion, excludeClasses) {
			var file = getSourceFileOfNode(node);
			if (file) {
				if (
					compilerOptions.checkJs === undefined && file.checkJsDirective === undefined && (file.scriptKind === ScriptKind.JS || file.scriptKind === ScriptKind.JSX)
				) {
					var declarationFile = forEach(
						suggestion === null || suggestion === void 0 ? void 0 : suggestion.declarations,
						getSourceFileOfNode,
					);
					return !(file !== declarationFile && !!declarationFile && isGlobalSourceFile(
						declarationFile,
					)) && !(excludeClasses && suggestion && suggestion.flags & SymbolFlags.Class) && !(!!node && excludeClasses && isPropertyAccessExpression(
						node,
					) && node.expression.kind === SyntaxKind.ThisKeyword);
				}
			}
			return false;
		}
		function getFlowTypeOfAccessExpression(
			node,
			prop,
			propType,
			errorNode,
			checkMode,
		) {
			// Only compute control flow type if this is a property access expression that isn't an
			// assignment target, and the referenced property was declared as a variable, property,
			// accessor, or optional method.
			var assignmentKind = getAssignmentTargetKind(node);
			if (assignmentKind === AssignmentKind.Definite) {
				return removeMissingType(
					propType,
					!!(prop && prop.flags & SymbolFlags.Optional),
				);
			}
			if (
				prop && !(prop.flags & (SymbolFlags.Variable | SymbolFlags.Property | SymbolFlags.Accessor)) && !(prop.flags & SymbolFlags.Method && propType.flags & TypeFlags.Union) && !isDuplicatedCommonJSExport(
					prop.declarations,
				)
			) {
				return propType;
			}
			if (propType === autoType) {
				return getFlowTypeOfProperty(node, prop);
			}
			propType = getNarrowableTypeForReference(propType, node, checkMode);
			// If strict null checks and strict property initialization checks are enabled, if we have
			// a this.xxx property access, if the property is an instance property without an initializer,
			// and if we are in a constructor of the same class as the property declaration, assume that
			// the property is uninitialized at the top of the control flow.
			var assumeUninitialized = false;
			if (
				strictNullChecks && strictPropertyInitialization && isAccessExpression(
					node,
				) && node.expression.kind === SyntaxKind.ThisKeyword
			) {
				var declaration = prop && prop.valueDeclaration;
				if (declaration && isPropertyWithoutInitializer(declaration)) {
					if (!isStatic(declaration)) {
						var flowContainer = getControlFlowContainer(node);
						if (
							flowContainer.kind === SyntaxKind.Constructor && flowContainer.parent === declaration.parent && !(declaration.flags & NodeFlags.Ambient)
						) {
							assumeUninitialized = true;
						}
					}
				}
			} else if (
				strictNullChecks && prop && prop.valueDeclaration && isPropertyAccessExpression(
					prop.valueDeclaration,
				) && getAssignmentDeclarationPropertyAccessKind(prop.valueDeclaration) && getControlFlowContainer(
					node,
				) === getControlFlowContainer(prop.valueDeclaration)
			) {
				assumeUninitialized = true;
			}
			var flowType = getFlowTypeOfReference(
				node,
				propType,
				assumeUninitialized ? getOptionalType(propType) : propType,
			);
			if (
				assumeUninitialized && !(getFalsyFlags(propType) & TypeFlags.Undefined) && getFalsyFlags(
					flowType,
				) & TypeFlags.Undefined
			) {
				error(
					errorNode,
					Diagnostics.Property_0_is_used_before_being_assigned,
					symbolToString(prop),
				); // TODO: GH#18217
				// Return the declared type to reduce follow-on errors
				return propType;
			}
			return assignmentKind ? getBaseTypeOfLiteralType(flowType) : flowType;
		}
		function checkPropertyNotUsedBeforeDeclaration(prop, node, right) {
			var valueDeclaration = prop.valueDeclaration;
			if (!valueDeclaration || getSourceFileOfNode(node).isDeclarationFile) {
				return;
			}
			var diagnosticMessage;
			var declarationName = idText(right);
			if (
				isInPropertyInitializerOrClassStaticBlock(node) && !isOptionalPropertyDeclaration(
					valueDeclaration,
				) && !(isAccessExpression(node) && isAccessExpression(node.expression)) && !isBlockScopedNameDeclaredBeforeUse(
					valueDeclaration,
					right,
				) && (compilerOptions.useDefineForClassFields || !isPropertyDeclaredInAncestorClass(
					prop,
				))
			) {
				diagnosticMessage = error(
					right,
					Diagnostics.Property_0_is_used_before_its_initialization,
					declarationName,
				);
			} else if (
				valueDeclaration.kind === SyntaxKind.ClassDeclaration && node.parent.kind !== SyntaxKind.TypeReference && !(valueDeclaration.flags & NodeFlags.Ambient) && !isBlockScopedNameDeclaredBeforeUse(
					valueDeclaration,
					right,
				)
			) {
				diagnosticMessage = error(
					right,
					Diagnostics.Class_0_used_before_its_declaration,
					declarationName,
				);
			}
			if (diagnosticMessage) {
				addRelatedInfo(
					diagnosticMessage,
					createDiagnosticForNode(
						valueDeclaration,
						Diagnostics._0_is_declared_here,
						declarationName,
					),
				);
			}
		}
		function isInPropertyInitializerOrClassStaticBlock(node) {
			return !!findAncestor(
				node,
				function (node) {
					switch (node.kind) {
						case SyntaxKind.PropertyDeclaration:
							return true;
						case SyntaxKind.PropertyAssignment:
						case SyntaxKind.MethodDeclaration:
						case SyntaxKind.GetAccessor:
						case SyntaxKind.SetAccessor:
						case SyntaxKind.SpreadAssignment:
						case SyntaxKind.ComputedPropertyName:
						case SyntaxKind.TemplateSpan:
						case SyntaxKind.JsxExpression:
						case SyntaxKind.JsxAttribute:
						case SyntaxKind.JsxAttributes:
						case SyntaxKind.JsxSpreadAttribute:
						case SyntaxKind.JsxOpeningElement:
						case SyntaxKind.ExpressionWithTypeArguments:
						case SyntaxKind.HeritageClause:
							return false;
						case SyntaxKind.ArrowFunction:
						case SyntaxKind.ExpressionStatement:
							return isBlock(node.parent) && isClassStaticBlockDeclaration(
								node.parent.parent,
							) ? true : "quit";
						default:
							return isExpressionNode(node) ? false : "quit";
					}
				},
			);
		}
		/**
         * It's possible that "prop.valueDeclaration" is a local declaration, but the property was also declared in a superclass.
         * In that case we won't consider it used before its declaration, because it gets its value from the superclass' declaration.
         */
		function isPropertyDeclaredInAncestorClass(prop) {
			if (!(prop.parent.flags & SymbolFlags.Class)) {
				return false;
			}
			var classType = getTypeOfSymbol(prop.parent);
			while (true) {
				classType = classType.symbol && getSuperClass(classType);
				if (!classType) {
					return false;
				}
				var superProperty = getPropertyOfType(classType, prop.escapedName);
				if (superProperty && superProperty.valueDeclaration) {
					return true;
				}
			}
		}
		function getSuperClass(classType) {
			var x = getBaseTypes(classType);
			if (x.length === 0) {
				return undefined;
			}
			return getIntersectionType(x);
		}
		function reportNonexistentProperty(propNode, containingType, isUncheckedJS) {
			var errorInfo;
			var relatedInfo;
			if (
				!isPrivateIdentifier(propNode) && containingType.flags & TypeFlags.Union && !(containingType.flags & TypeFlags.Primitive)
			) {
				for (var _i = 0, _a = containingType.types; _i < _a.length; _i++) {
					var subtype = _a[_i];
					if (
						!getPropertyOfType(subtype, propNode.escapedText) && !getApplicableIndexInfoForName(
							subtype,
							propNode.escapedText,
						)
					) {
						errorInfo = chainDiagnosticMessages(
							errorInfo,
							Diagnostics.Property_0_does_not_exist_on_type_1,
							declarationNameToString(propNode),
							typeToString(subtype),
						);
						break;
					}
				}
			}
			if (typeHasStaticProperty(propNode.escapedText, containingType)) {
				var propName = declarationNameToString(propNode);
				var typeName = typeToString(containingType);
				errorInfo = chainDiagnosticMessages(
					errorInfo,
					Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead,
					propName,
					typeName,
					typeName + "." + propName,
				);
			} else {
				var promisedType = getPromisedTypeOfPromise(containingType);
				if (
					promisedType && getPropertyOfType(promisedType, propNode.escapedText)
				) {
					errorInfo = chainDiagnosticMessages(
						errorInfo,
						Diagnostics.Property_0_does_not_exist_on_type_1,
						declarationNameToString(propNode),
						typeToString(containingType),
					);
					relatedInfo = createDiagnosticForNode(
						propNode,
						Diagnostics.Did_you_forget_to_use_await,
					);
				} else {
					var missingProperty = declarationNameToString(propNode);
					var container = typeToString(containingType);
					var libSuggestion = getSuggestedLibForNonExistentProperty(
						missingProperty,
						containingType,
					);
					if (libSuggestion !== undefined) {
						errorInfo = chainDiagnosticMessages(
							errorInfo,
							Diagnostics.Property_0_does_not_exist_on_type_1_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2_or_later,
							missingProperty,
							container,
							libSuggestion,
						);
					} else {
						var suggestion = getSuggestedSymbolForNonexistentProperty(
							propNode,
							containingType,
						);
						if (suggestion !== undefined) {
							var suggestedName = symbolName(suggestion);
							var message = isUncheckedJS ? Diagnostics.Property_0_may_not_exist_on_type_1_Did_you_mean_2 : Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2;
							errorInfo = chainDiagnosticMessages(
								errorInfo,
								message,
								missingProperty,
								container,
								suggestedName,
							);
							relatedInfo = suggestion.valueDeclaration && createDiagnosticForNode(
								suggestion.valueDeclaration,
								Diagnostics._0_is_declared_here,
								suggestedName,
							);
						} else {
							var diagnostic = containerSeemsToBeEmptyDomElement(containingType) ? Diagnostics.Property_0_does_not_exist_on_type_1_Try_changing_the_lib_compiler_option_to_include_dom : Diagnostics.Property_0_does_not_exist_on_type_1;
							errorInfo = chainDiagnosticMessages(
								elaborateNeverIntersection(errorInfo, containingType),
								diagnostic,
								missingProperty,
								container,
							);
						}
					}
				}
			}
			var resultDiagnostic = createDiagnosticForNodeFromMessageChain(
				propNode,
				errorInfo,
			);
			if (relatedInfo) {
				addRelatedInfo(resultDiagnostic, relatedInfo);
			}
			addErrorOrSuggestion(
				!isUncheckedJS || errorInfo.code !== Diagnostics.Property_0_may_not_exist_on_type_1_Did_you_mean_2.code,
				resultDiagnostic,
			);
		}
		function containerSeemsToBeEmptyDomElement(containingType) {
			return (compilerOptions.lib && !compilerOptions.lib.includes("dom")) && everyContainedType(
				containingType,
				function (type) {
					return type.symbol && /^(EventTarget|Node|((HTML[a-zA-Z]*)?Element))$/.test(unescapeLeadingUnderscores(type.symbol.escapedName));
				},
			) && isEmptyObjectType(containingType);
		}
		function typeHasStaticProperty(propName, containingType) {
			var prop = containingType.symbol && getPropertyOfType(
				getTypeOfSymbol(containingType.symbol),
				propName,
			);
			return prop !== undefined && !!prop.valueDeclaration && isStatic(
				prop.valueDeclaration,
			);
		}
		function getSuggestedLibForNonExistentName(name) {
			var missingName = diagnosticName(name);
			var allFeatures = getScriptTargetFeatures();
			var libTargets = getOwnKeys(allFeatures);
			for (var _i = 0, libTargets_1 = libTargets; _i < libTargets_1.length; _i++) {
				var libTarget = libTargets_1[_i];
				var containingTypes = getOwnKeys(allFeatures[libTarget]);
				if (
					containingTypes !== undefined && contains(
						containingTypes,
						missingName,
					)
				) {
					return libTarget;
				}
			}
		}
		function getSuggestedLibForNonExistentProperty(
			missingProperty,
			containingType,
		) {
			var container = getApparentType(containingType).symbol;
			if (!container) {
				return undefined;
			}
			var allFeatures = getScriptTargetFeatures();
			var libTargets = getOwnKeys(allFeatures);
			for (var _i = 0, libTargets_2 = libTargets; _i < libTargets_2.length; _i++) {
				var libTarget = libTargets_2[_i];
				var featuresOfLib = allFeatures[libTarget];
				var featuresOfContainingType = featuresOfLib[symbolName(container)];
				if (
					featuresOfContainingType !== undefined && contains(
						featuresOfContainingType,
						missingProperty,
					)
				) {
					return libTarget;
				}
			}
		}
		function getSuggestedSymbolForNonexistentClassMember(name, baseType) {
			return getSpellingSuggestionForName(
				name,
				getPropertiesOfType(baseType),
				SymbolFlags.ClassMember,
			);
		}
		function getSuggestedSymbolForNonexistentProperty(name, containingType) {
			var props = getPropertiesOfType(containingType);
			if (typeof name !== "string") {
				var parent_13 = name.parent;
				if (isPropertyAccessExpression(parent_13)) {
					props = filter(
						props,
						function (prop) {
							return isValidPropertyAccessForCompletions(
								parent_13,
								containingType,
								prop,
							);
						},
					);
				}
				name = idText(name);
			}
			return getSpellingSuggestionForName(name, props, SymbolFlags.Value);
		}
		function getSuggestedSymbolForNonexistentJSXAttribute(name, containingType) {
			var strName = isString(name) ? name : idText(name);
			var properties = getPropertiesOfType(containingType);
			var jsxSpecific = strName === "for" ? find(
				properties,
				function (x) {
					return symbolName(x) === "htmlFor";
				},
			) : strName === "class" ? find(
				properties,
				function (x) {
					return symbolName(x) === "className";
				},
			) : undefined;
			return jsxSpecific !== null && jsxSpecific !== void 0 ? jsxSpecific : getSpellingSuggestionForName(
				strName,
				properties,
				SymbolFlags.Value,
			);
		}
		function getSuggestionForNonexistentProperty(name, containingType) {
			var suggestion = getSuggestedSymbolForNonexistentProperty(
				name,
				containingType,
			);
			return suggestion && symbolName(suggestion);
		}
		function getSuggestedSymbolForNonexistentSymbol(
			location,
			outerName,
			meaning,
		) {
			Debug.assert(
				outerName !== undefined,
				"outername should always be defined",
			);
			var result = resolveNameHelper(
				location,
				outerName,
				meaning, /*nameNotFoundMessage*/
				undefined,
				outerName, /*isUse*/
				false, /*excludeGlobals*/
				false, /*getSpellingSuggestions*/
				true,
				function (symbols, name, meaning) {
					Debug.assertEqual(outerName, name, "name should equal outerName");
					var symbol = getSymbol(symbols, name, meaning);
					// Sometimes the symbol is found when location is a return type of a function: `typeof x` and `x` is declared in the body of the function
					// So the table *contains* `x` but `x` isn't actually in scope.
					// However, resolveNameHelper will continue and call this callback again, so we'll eventually get a correct suggestion.
					if (symbol) return symbol;
					var candidates;
					if (symbols === globals) {
						var primitives = mapDefined(
							["string", "number", "boolean", "object", "bigint", "symbol"],
							function (s) {
								return symbols.has((s.charAt(0).toUpperCase() + s.slice(1))) ? createSymbol(
									SymbolFlags.TypeAlias,
									s,
								) : undefined;
							},
						);
						candidates = primitives.concat(arrayFrom(symbols.values()));
					} else {
						candidates = arrayFrom(symbols.values());
					}
					return getSpellingSuggestionForName(
						unescapeLeadingUnderscores(name),
						candidates,
						meaning,
					);
				},
			);
			return result;
		}
		function getSuggestionForNonexistentSymbol(location, outerName, meaning) {
			var symbolResult = getSuggestedSymbolForNonexistentSymbol(
				location,
				outerName,
				meaning,
			);
			return symbolResult && symbolName(symbolResult);
		}
		function getSuggestedSymbolForNonexistentModule(name, targetModule) {
			return targetModule.exports && getSpellingSuggestionForName(
				idText(name),
				getExportsOfModuleAsArray(targetModule),
				SymbolFlags.ModuleMember,
			);
		}
		function getSuggestionForNonexistentExport(name, targetModule) {
			var suggestion = getSuggestedSymbolForNonexistentModule(
				name,
				targetModule,
			);
			return suggestion && symbolName(suggestion);
		}
		function getSuggestionForNonexistentIndexSignature(
			objectType,
			expr,
			keyedType,
		) {
			// check if object type has setter or getter
			function hasProp(name) {
				var prop = getPropertyOfObjectType(objectType, name);
				if (prop) {
					var s = getSingleCallSignature(getTypeOfSymbol(prop));
					return !!s && getMinArgumentCount(s) >= 1 && isTypeAssignableTo(
						keyedType,
						getTypeAtPosition(s, 0),
					);
				}
				return false;
			}
			var suggestedMethod = isAssignmentTarget(expr) ? "set" : "get";
			if (!hasProp(suggestedMethod)) {
				return undefined;
			}
			var suggestion = tryGetPropertyAccessOrIdentifierToString(expr.expression);
			if (suggestion === undefined) {
				suggestion = suggestedMethod;
			} else {
				suggestion += "." + suggestedMethod;
			}
			return suggestion;
		}
		function getSuggestedTypeForNonexistentStringLiteralType(source, target) {
			var candidates = target.types.filter(
				function (type) {
					return !!(type.flags & TypeFlags.StringLiteral);
				},
			);
			return getSpellingSuggestion(
				source.value,
				candidates,
				function (type) {
					return type.value;
				},
			);
		}
		/**
         * Given a name and a list of symbols whose names are *not* equal to the name, return a spelling suggestion if there is one that is close enough.
         * Names less than length 3 only check for case-insensitive equality, not levenshtein distance.
         *
         * If there is a candidate that's the same except for case, return that.
         * If there is a candidate that's within one edit of the name, return that.
         * Otherwise, return the candidate with the smallest Levenshtein distance,
         *    except for candidates:
         *      * With no name
         *      * Whose meaning doesn't match the `meaning` parameter.
         *      * Whose length differs from the target name by more than 0.34 of the length of the name.
         *      * Whose levenshtein distance is more than 0.4 of the length of the name
         *        (0.4 allows 1 substitution/transposition for every 5 characters,
         *         and 1 insertion/deletion at 3 characters)
         */
		function getSpellingSuggestionForName(name, symbols, meaning) {
			return getSpellingSuggestion(name, symbols, getCandidateName);
			function getCandidateName(candidate) {
				var candidateName = symbolName(candidate);
				if (startsWith(candidateName, "\"")) {
					return undefined;
				}
				if (candidate.flags & meaning) {
					return candidateName;
				}
				if (candidate.flags & SymbolFlags.Alias) {
					var alias = tryResolveAlias(candidate);
					if (alias && alias.flags & meaning) {
						return candidateName;
					}
				}
				return undefined;
			}
		}
		function markPropertyAsReferenced(
			prop,
			nodeForCheckWriteOnly,
			isSelfTypeAccess,
		) {
			var valueDeclaration = prop && (prop.flags & SymbolFlags.ClassMember) && prop.valueDeclaration;
			if (!valueDeclaration) {
				return;
			}
			var hasPrivateModifier = hasEffectiveModifier(
				valueDeclaration,
				ModifierFlags.Private,
			);
			var hasPrivateIdentifier = prop.valueDeclaration && isNamedDeclaration(
				prop.valueDeclaration,
			) && isPrivateIdentifier(prop.valueDeclaration.name);
			if (!hasPrivateModifier && !hasPrivateIdentifier) {
				return;
			}
			if (
				nodeForCheckWriteOnly && isWriteOnlyAccess(nodeForCheckWriteOnly) && !(prop.flags & SymbolFlags.SetAccessor)
			) {
				return;
			}
			if (isSelfTypeAccess) {
				// Find any FunctionLikeDeclaration because those create a new 'this' binding. But this should only matter for methods (or getters/setters).
				var containingMethod = findAncestor(
					nodeForCheckWriteOnly,
					isFunctionLikeDeclaration,
				);
				if (containingMethod && containingMethod.symbol === prop) {
					return;
				}
			}
			(getCheckFlags(prop) & CheckFlags.Instantiated ? getSymbolLinks(prop).target : prop).isReferenced = SymbolFlags.All;
		}
		function isSelfTypeAccess(name, parent) {
			return name.kind === SyntaxKind.ThisKeyword || !!parent && isEntityNameExpression(
				name,
			) && parent === getResolvedSymbol(getFirstIdentifier(name));
		}
		function isValidPropertyAccess(node, propertyName) {
			switch (node.kind) {
				case SyntaxKind.PropertyAccessExpression:
					return isValidPropertyAccessWithType(
						node,
						node.expression.kind === SyntaxKind.SuperKeyword,
						propertyName,
						getWidenedType(checkExpression(node.expression)),
					);
				case SyntaxKind.QualifiedName:
					return isValidPropertyAccessWithType(
						node, /*isSuper*/
						false,
						propertyName,
						getWidenedType(checkExpression(node.left)),
					);
				case SyntaxKind.ImportType:
					return isValidPropertyAccessWithType(
						node, /*isSuper*/
						false,
						propertyName,
						getTypeFromTypeNode(node),
					);
			}
		}
		/**
         * Checks if an existing property access is valid for completions purposes.
         * @param node a property access-like node where we want to check if we can access a property.
         * This node does not need to be an access of the property we are checking.
         * e.g. in completions, this node will often be an incomplete property access node, as in `foo.`.
         * Besides providing a location (i.e. scope) used to check property accessibility, we use this node for
         * computing whether this is a `super` property access.
         * @param type the type whose property we are checking.
         * @param property the accessed property's symbol.
         */
		function isValidPropertyAccessForCompletions(node, type, property) {
			return isPropertyAccessible(
				node,
				node.kind === SyntaxKind.PropertyAccessExpression && node.expression.kind === SyntaxKind.SuperKeyword,
				/* isWrite */ false,
				type,
				property,
			); // Previously we validated the 'this' type of methods but this adversely affected performance. See #31377 for more context.
		}
		function isValidPropertyAccessWithType(node, isSuper, propertyName, type) {
			// Short-circuiting for improved performance.
			if (isTypeAny(type)) {
				return true;
			}
			var prop = getPropertyOfType(type, propertyName);
			return !!prop && isPropertyAccessible(
				node,
				isSuper, /* isWrite */
				false,
				type,
				prop,
			);
		}
		/**
         * Checks if a property can be accessed in a location.
         * The location is given by the `node` parameter.
         * The node does not need to be a property access.
         * @param node location where to check property accessibility
         * @param isSuper whether to consider this a `super` property access, e.g. `super.foo`.
         * @param isWrite whether this is a write access, e.g. `++foo.x`.
         * @param containingType type where the property comes from.
         * @param property property symbol.
         */
		function isPropertyAccessible(
			node,
			isSuper,
			isWrite,
			containingType,
			property,
		) {
			// Short-circuiting for improved performance.
			if (isTypeAny(containingType)) {
				return true;
			}
			// A #private property access in an optional chain is an error dealt with by the parser.
			// The checker does not check for it, so we need to do our own check here.
			if (
				property.valueDeclaration && isPrivateIdentifierClassElementDeclaration(
					property.valueDeclaration,
				)
			) {
				var declClass_1 = getContainingClass(property.valueDeclaration);
				return !isOptionalChain(node) && !!findAncestor(
					node,
					function (parent) {
						return parent === declClass_1;
					},
				);
			}
			return checkPropertyAccessibilityAtLocation(
				node,
				isSuper,
				isWrite,
				containingType,
				property,
			);
		}
		/**
         * Return the symbol of the for-in variable declared or referenced by the given for-in statement.
         */
		function getForInVariableSymbol(node) {
			var initializer = node.initializer;
			if (initializer.kind === SyntaxKind.VariableDeclarationList) {
				var variable = initializer.declarations[0];
				if (variable && !isBindingPattern(variable.name)) {
					return getSymbolOfNode(variable);
				}
			} else if (initializer.kind === SyntaxKind.Identifier) {
				return getResolvedSymbol(initializer);
			}
			return undefined;
		}
		/**
         * Return true if the given type is considered to have numeric property names.
         */
		function hasNumericPropertyNames(type) {
			return getIndexInfosOfType(type).length === 1 && !!getIndexInfoOfType(
				type,
				numberType,
			);
		}
		/**
         * Return true if given node is an expression consisting of an identifier (possibly parenthesized)
         * that references a for-in variable for an object with numeric property names.
         */
		function isForInVariableForNumericPropertyNames(expr) {
			var e = skipParentheses(expr);
			if (e.kind === SyntaxKind.Identifier) {
				var symbol = getResolvedSymbol(e);
				if (symbol.flags & SymbolFlags.Variable) {
					var child = expr;
					var node = expr.parent;
					while (node) {
						if (
							node.kind === SyntaxKind.ForInStatement && child === node.statement && getForInVariableSymbol(
								node,
							) === symbol && hasNumericPropertyNames(
								getTypeOfExpression(node.expression),
							)
						) {
							return true;
						}
						child = node;
						node = node.parent;
					}
				}
			}
			return false;
		}
		function checkIndexedAccess(node, checkMode) {
			return node.flags & NodeFlags.OptionalChain ? checkElementAccessChain(
				node,
				checkMode,
			) : checkElementAccessExpression(
				node,
				checkNonNullExpression(node.expression),
				checkMode,
			);
		}
		function checkElementAccessChain(node, checkMode) {
			var exprType = checkExpression(node.expression);
			var nonOptionalType = getOptionalExpressionType(exprType, node.expression);
			return propagateOptionalTypeMarker(
				checkElementAccessExpression(
					node,
					checkNonNullType(nonOptionalType, node.expression),
					checkMode,
				),
				node,
				nonOptionalType !== exprType,
			);
		}
		function checkElementAccessExpression(node, exprType, checkMode) {
			var objectType = getAssignmentTargetKind(node) !== AssignmentKind.None || isMethodAccessForCall(
				node,
			) ? getWidenedType(exprType) : exprType;
			var indexExpression = node.argumentExpression;
			var indexType = checkExpression(indexExpression);
			if (isErrorType(objectType) || objectType === silentNeverType) {
				return objectType;
			}
			if (
				isConstEnumObjectType(objectType) && !isStringLiteralLike(
					indexExpression,
				)
			) {
				error(
					indexExpression,
					Diagnostics.A_const_enum_member_can_only_be_accessed_using_a_string_literal,
				);
				return errorType;
			}
			var effectiveIndexType = isForInVariableForNumericPropertyNames(
				indexExpression,
			) ? numberType : indexType;
			var accessFlags = isAssignmentTarget(node) ? AccessFlags.Writing | (isGenericObjectType(
				objectType,
			) && !isThisTypeParameter(objectType) ? AccessFlags.NoIndexSignatures : 0) : AccessFlags.ExpressionPosition;
			var indexedAccessType = getIndexedAccessTypeOrUndefined(
				objectType,
				effectiveIndexType,
				accessFlags,
				node,
			) || errorType;
			return checkIndexedAccessIndexType(
				getFlowTypeOfAccessExpression(
					node,
					getNodeLinks(node).resolvedSymbol,
					indexedAccessType,
					indexExpression,
					checkMode,
				),
				node,
			);
		}
		function callLikeExpressionMayHaveTypeArguments(node) {
			return isCallOrNewExpression(node) || isTaggedTemplateExpression(node) || isJsxOpeningLikeElement(
				node,
			);
		}
		function resolveUntypedCall(node) {
			if (callLikeExpressionMayHaveTypeArguments(node)) {
				// Check type arguments even though we will give an error that untyped calls may not accept type arguments.
				// This gets us diagnostics for the type arguments and marks them as referenced.
				forEach(node.typeArguments, checkSourceElement);
			}
			if (node.kind === SyntaxKind.TaggedTemplateExpression) {
				checkExpression(node.template);
			} else if (isJsxOpeningLikeElement(node)) {
				checkExpression(node.attributes);
			} else if (node.kind !== SyntaxKind.Decorator) {
				forEach(
					node.arguments,
					function (argument) {
						checkExpression(argument);
					},
				);
			}
			return anySignature;
		}
		function resolveErrorCall(node) {
			resolveUntypedCall(node);
			return unknownSignature;
		}
		// Re-order candidate signatures into the result array. Assumes the result array to be empty.
		// The candidate list orders groups in reverse, but within a group signatures are kept in declaration order
		// A nit here is that we reorder only signatures that belong to the same symbol,
		// so order how inherited signatures are processed is still preserved.
		// interface A { (x: string): void }
		// interface B extends A { (x: 'foo'): string }
		// const b: B;
		// b('foo') // <- here overloads should be processed as [(x:'foo'): string, (x: string): void]
		function reorderCandidates(signatures, result, callChainFlags) {
			var lastParent;
			var lastSymbol;
			var cutoffIndex = 0;
			var index;
			var specializedIndex = -1;
			var spliceIndex;
			Debug.assert(!result.length);
			for (var _i = 0, signatures_7 = signatures; _i < signatures_7.length; _i++) {
				var signature = signatures_7[_i];
				var symbol = signature.declaration && getSymbolOfNode(
					signature.declaration,
				);
				var parent_14 = signature.declaration && signature.declaration.parent;
				if (!lastSymbol || symbol === lastSymbol) {
					if (lastParent && parent_14 === lastParent) {
						index = index + 1;
					} else {
						lastParent = parent_14;
						index = cutoffIndex;
					}
				} else {
					// current declaration belongs to a different symbol
					// set cutoffIndex so re-orderings in the future won't change result set from 0 to cutoffIndex
					index = cutoffIndex = result.length;
					lastParent = parent_14;
				}
				lastSymbol = symbol;
				// specialized signatures always need to be placed before non-specialized signatures regardless
				// of the cutoff position; see GH#1133
				if (signatureHasLiteralTypes(signature)) {
					specializedIndex++;
					spliceIndex = specializedIndex;
					// The cutoff index always needs to be greater than or equal to the specialized signature index
					// in order to prevent non-specialized signatures from being added before a specialized
					// signature.
					cutoffIndex++;
				} else {
					spliceIndex = index;
				}
				result.splice(
					spliceIndex,
					0,
					callChainFlags ? getOptionalCallSignature(signature, callChainFlags) : signature,
				);
			}
		}
		function isSpreadArgument(arg) {
			return !!arg && (arg.kind === SyntaxKind.SpreadElement || arg.kind === SyntaxKind.SyntheticExpression && arg.isSpread);
		}
		function getSpreadArgumentIndex(args) {
			return findIndex(args, isSpreadArgument);
		}
		function acceptsVoid(t) {
			return !!(t.flags & TypeFlags.Void);
		}
		function acceptsVoidUndefinedUnknownOrAny(t) {
			return !!(t.flags & (TypeFlags.Void | TypeFlags.Undefined | TypeFlags.Unknown | TypeFlags.Any));
		}
		function hasCorrectArity(node, args, signature, signatureHelpTrailingComma) {
			if (signatureHelpTrailingComma === void 0) {
				signatureHelpTrailingComma = false;
			}
			var argCount;
			var callIsIncomplete = false; // In incomplete call we want to be lenient when we have too few arguments
			var effectiveParameterCount = getParameterCount(signature);
			var effectiveMinimumArguments = getMinArgumentCount(signature);
			if (node.kind === SyntaxKind.TaggedTemplateExpression) {
				argCount = args.length;
				if (node.template.kind === SyntaxKind.TemplateExpression) {
					// If a tagged template expression lacks a tail literal, the call is incomplete.
					// Specifically, a template only can end in a TemplateTail or a Missing literal.
					var lastSpan = last(node.template.templateSpans); // we should always have at least one span.
					callIsIncomplete = nodeIsMissing(lastSpan.literal) || !!lastSpan.literal.isUnterminated;
				} else {
					// If the template didn't end in a backtick, or its beginning occurred right prior to EOF,
					// then this might actually turn out to be a TemplateHead in the future;
					// so we consider the call to be incomplete.
					var templateLiteral = node.template;
					Debug.assert(
						templateLiteral.kind === SyntaxKind.NoSubstitutionTemplateLiteral,
					);
					callIsIncomplete = !!templateLiteral.isUnterminated;
				}
			} else if (node.kind === SyntaxKind.Decorator) {
				argCount = getDecoratorArgumentCount(node, signature);
			} else if (isJsxOpeningLikeElement(node)) {
				callIsIncomplete = node.attributes.end === node.end;
				if (callIsIncomplete) {
					return true;
				}
				argCount = effectiveMinimumArguments === 0 ? args.length : 1;
				effectiveParameterCount = args.length === 0 ? effectiveParameterCount : 1; // class may have argumentless ctor functions - still resolve ctor and compare vs props member type
				effectiveMinimumArguments = Math.min(effectiveMinimumArguments, 1); // sfc may specify context argument - handled by framework and not typechecked
			} else if (!node.arguments) {
				// This only happens when we have something of the form: 'new C'
				Debug.assert(node.kind === SyntaxKind.NewExpression);
				return getMinArgumentCount(signature) === 0;
			} else {
				argCount = signatureHelpTrailingComma ? args.length + 1 : args.length;
				// If we are missing the close parenthesis, the call is incomplete.
				callIsIncomplete = node.arguments.end === node.end;
				// If a spread argument is present, check that it corresponds to a rest parameter or at least that it's in the valid range.
				var spreadArgIndex = getSpreadArgumentIndex(args);
				if (spreadArgIndex >= 0) {
					return spreadArgIndex >= getMinArgumentCount(signature) && (hasEffectiveRestParameter(
						signature,
					) || spreadArgIndex < getParameterCount(signature));
				}
			}
			// Too many arguments implies incorrect arity.
			if (
				!hasEffectiveRestParameter(signature) && argCount > effectiveParameterCount
			) {
				return false;
			}
			// If the call is incomplete, we should skip the lower bound check.
			// JSX signatures can have extra parameters provided by the library which we don't check
			if (callIsIncomplete || argCount >= effectiveMinimumArguments) {
				return true;
			}
			for (var i = argCount; i < effectiveMinimumArguments; i++) {
				var type = getTypeAtPosition(signature, i);
				if (
					filterType(
						type,
						isInJSFile(node) && !strictNullChecks ? acceptsVoidUndefinedUnknownOrAny : acceptsVoid,
					).flags & TypeFlags.Never
				) {
					return false;
				}
			}
			return true;
		}
		function hasCorrectTypeArgumentArity(signature, typeArguments) {
			// If the user supplied type arguments, but the number of type arguments does not match
			// the declared number of type parameters, the call has an incorrect arity.
			var numTypeParameters = length(signature.typeParameters);
			var minTypeArgumentCount = getMinTypeArgumentCount(
				signature.typeParameters,
			);
			return !some(typeArguments) || (typeArguments.length >= minTypeArgumentCount && typeArguments.length <= numTypeParameters);
		}
		// If type has a single call signature and no other members, return that signature. Otherwise, return undefined.
		function getSingleCallSignature(type) {
			return getSingleSignature(
				type,
				SignatureKind.Call, /*allowMembers*/
				false,
			);
		}
		function getSingleCallOrConstructSignature(type) {
			return getSingleSignature(
				type,
				SignatureKind.Call, /*allowMembers*/
				false,
			) || getSingleSignature(
				type,
				SignatureKind.Construct, /*allowMembers*/
				false,
			);
		}
		function getSingleSignature(type, kind, allowMembers) {
			if (type.flags & TypeFlags.Object) {
				var resolved = resolveStructuredTypeMembers(type);
				if (
					allowMembers || resolved.properties.length === 0 && resolved.indexInfos.length === 0
				) {
					if (
						kind === SignatureKind.Call && resolved.callSignatures.length === 1 && resolved.constructSignatures.length === 0
					) {
						return resolved.callSignatures[0];
					}
					if (
						kind === SignatureKind.Construct && resolved.constructSignatures.length === 1 && resolved.callSignatures.length === 0
					) {
						return resolved.constructSignatures[0];
					}
				}
			}
			return undefined;
		}
		// Instantiate a generic signature in the context of a non-generic signature (section 3.8.5 in TypeScript spec)
		function instantiateSignatureInContextOf(
			signature,
			contextualSignature,
			inferenceContext,
			compareTypes,
		) {
			var context = createInferenceContext(
				signature.typeParameters,
				signature,
				InferenceFlags.None,
				compareTypes,
			);
			// We clone the inferenceContext to avoid fixing. For example, when the source signature is <T>(x: T) => T[] and
			// the contextual signature is (...args: A) => B, we want to infer the element type of A's constraint (say 'any')
			// for T but leave it possible to later infer '[any]' back to A.
			var restType = getEffectiveRestType(contextualSignature);
			var mapper = inferenceContext && (restType && restType.flags & TypeFlags.TypeParameter ? inferenceContext.nonFixingMapper : inferenceContext.mapper);
			var sourceSignature = mapper ? instantiateSignature(
				contextualSignature,
				mapper,
			) : contextualSignature;
			applyToParameterTypes(
				sourceSignature,
				signature,
				function (source, target) {
					// Type parameters from outer context referenced by source type are fixed by instantiation of the source type
					inferTypes(context.inferences, source, target);
				},
			);
			if (!inferenceContext) {
				applyToReturnTypes(
					contextualSignature,
					signature,
					function (source, target) {
						inferTypes(
							context.inferences,
							source,
							target,
							InferencePriority.ReturnType,
						);
					},
				);
			}
			return getSignatureInstantiation(
				signature,
				getInferredTypes(context),
				isInJSFile(contextualSignature.declaration),
			);
		}
		function inferJsxTypeArguments(node, signature, checkMode, context) {
			var paramType = getEffectiveFirstArgumentForJsxSignature(signature, node);
			var checkAttrType = checkExpressionWithContextualType(
				node.attributes,
				paramType,
				context,
				checkMode,
			);
			inferTypes(context.inferences, checkAttrType, paramType);
			return getInferredTypes(context);
		}
		function getThisArgumentType(thisArgumentNode) {
			if (!thisArgumentNode) {
				return voidType;
			}
			var thisArgumentType = checkExpression(thisArgumentNode);
			return isOptionalChainRoot(thisArgumentNode.parent) ? getNonNullableType(
				thisArgumentType,
			) : isOptionalChain(thisArgumentNode.parent) ? removeOptionalTypeMarker(
				thisArgumentType,
			) : thisArgumentType;
		}
		function inferTypeArguments(node, signature, args, checkMode, context) {
			if (isJsxOpeningLikeElement(node)) {
				return inferJsxTypeArguments(node, signature, checkMode, context);
			}
			// If a contextual type is available, infer from that type to the return type of the call expression. For
			// example, given a 'function wrap<T, U>(cb: (x: T) => U): (x: T) => U' and a call expression
			// 'let f: (x: string) => number = wrap(s => s.length)', we infer from the declared type of 'f' to the
			// return type of 'wrap'.
			if (node.kind !== SyntaxKind.Decorator) {
				var contextualType = getContextualType(
					node,
					every(
						signature.typeParameters,
						function (p) {
							return !!getDefaultFromTypeParameter(p);
						},
					) ? ContextFlags.SkipBindingPatterns : ContextFlags.None,
				);
				if (contextualType) {
					// We clone the inference context to avoid disturbing a resolution in progress for an
					// outer call expression. Effectively we just want a snapshot of whatever has been
					// inferred for any outer call expression so far.
					var outerContext = getInferenceContext(node);
					var outerMapper = getMapperFromContext(
						cloneInferenceContext(outerContext, InferenceFlags.NoDefault),
					);
					var instantiatedType = instantiateType(contextualType, outerMapper);
					// If the contextual type is a generic function type with a single call signature, we
					// instantiate the type with its own type parameters and type arguments. This ensures that
					// the type parameters are not erased to type any during type inference such that they can
					// be inferred as actual types from the contextual type. For example:
					//   declare function arrayMap<T, U>(f: (x: T) => U): (a: T[]) => U[];
					//   const boxElements: <A>(a: A[]) => { value: A }[] = arrayMap(value => ({ value }));
					// Above, the type of the 'value' parameter is inferred to be 'A'.
					var contextualSignature = getSingleCallSignature(instantiatedType);
					var inferenceSourceType = contextualSignature && contextualSignature.typeParameters ? getOrCreateTypeFromSignature(
						getSignatureInstantiationWithoutFillingInTypeArguments(
							contextualSignature,
							contextualSignature.typeParameters,
						),
					) : instantiatedType;
					var inferenceTargetType = getReturnTypeOfSignature(signature);
					// Inferences made from return types have lower priority than all other inferences.
					inferTypes(
						context.inferences,
						inferenceSourceType,
						inferenceTargetType,
						InferencePriority.ReturnType,
					);
					// Create a type mapper for instantiating generic contextual types using the inferences made
					// from the return type. We need a separate inference pass here because (a) instantiation of
					// the source type uses the outer context's return mapper (which excludes inferences made from
					// outer arguments), and (b) we don't want any further inferences going into this context.
					var returnContext = createInferenceContext(
						signature.typeParameters,
						signature,
						context.flags,
					);
					var returnSourceType = instantiateType(
						contextualType,
						outerContext && outerContext.returnMapper,
					);
					inferTypes(
						returnContext.inferences,
						returnSourceType,
						inferenceTargetType,
					);
					context.returnMapper = some(
						returnContext.inferences,
						hasInferenceCandidates,
					) ? getMapperFromContext(cloneInferredPartOfContext(returnContext)) : undefined;
				}
			}
			var restType = getNonArrayRestType(signature);
			var argCount = restType ? Math.min(
				getParameterCount(signature) - 1,
				args.length,
			) : args.length;
			if (restType && restType.flags & TypeFlags.TypeParameter) {
				var info = find(
					context.inferences,
					function (info) {
						return info.typeParameter === restType;
					},
				);
				if (info) {
					info.impliedArity = findIndex(args, isSpreadArgument, argCount) < 0 ? args.length - argCount : undefined;
				}
			}
			var thisType = getThisTypeOfSignature(signature);
			if (thisType) {
				var thisArgumentNode = getThisArgumentOfCall(node);
				inferTypes(
					context.inferences,
					getThisArgumentType(thisArgumentNode),
					thisType,
				);
			}
			for (var i = 0; i < argCount; i++) {
				var arg = args[i];
				if (arg.kind !== SyntaxKind.OmittedExpression) {
					var paramType = getTypeAtPosition(signature, i);
					var argType = checkExpressionWithContextualType(
						arg,
						paramType,
						context,
						checkMode,
					);
					inferTypes(context.inferences, argType, paramType);
				}
			}
			if (restType) {
				var spreadType = getSpreadArgumentType(
					args,
					argCount,
					args.length,
					restType,
					context,
					checkMode,
				);
				inferTypes(context.inferences, spreadType, restType);
			}
			return getInferredTypes(context);
		}
		function getMutableArrayOrTupleType(type) {
			return type.flags & TypeFlags.Union ? mapType(
				type,
				getMutableArrayOrTupleType,
			) : type.flags & TypeFlags.Any || isMutableArrayOrTuple(
				getBaseConstraintOfType(type) || type,
			) ? type : isTupleType(type) ? createTupleType(
				getTypeArguments(type),
				type.target.elementFlags, /*readonly*/
				false,
				type.target.labeledElementDeclarations,
			) : createTupleType([type], [ElementFlags.Variadic]);
		}
		function getSpreadArgumentType(
			args,
			index,
			argCount,
			restType,
			context,
			checkMode,
		) {
			if (index >= argCount - 1) {
				var arg = args[argCount - 1];
				if (isSpreadArgument(arg)) {
					// We are inferring from a spread expression in the last argument position, i.e. both the parameter
					// and the argument are ...x forms.
					return getMutableArrayOrTupleType(
						arg.kind === SyntaxKind.SyntheticExpression ? arg.type : checkExpressionWithContextualType(
							arg.expression,
							restType,
							context,
							checkMode,
						),
					);
				}
			}
			var types = [];
			var flags = [];
			var names = [];
			for (var i = index; i < argCount; i++) {
				var arg = args[i];
				if (isSpreadArgument(arg)) {
					var spreadType = arg.kind === SyntaxKind.SyntheticExpression ? arg.type : checkExpression(
						arg.expression,
					);
					if (isArrayLikeType(spreadType)) {
						types.push(spreadType);
						flags.push(ElementFlags.Variadic);
					} else {
						types.push(
							checkIteratedTypeOrElementType(
								33, /* Spread */
								spreadType,
								undefinedType,
								arg.kind === SyntaxKind.SpreadElement ? arg.expression : arg,
							),
						);
						flags.push(ElementFlags.Rest);
					}
				} else {
					var contextualType = getIndexedAccessType(
						restType,
						getNumberLiteralType(i - index),
						AccessFlags.Contextual,
					);
					var argType = checkExpressionWithContextualType(
						arg,
						contextualType,
						context,
						checkMode,
					);
					var hasPrimitiveContextualType = maybeTypeOfKind(
						contextualType,
						TypeFlags.Primitive | TypeFlags.Index | TypeFlags.TemplateLiteral | TypeFlags.StringMapping,
					);
					types.push(
						hasPrimitiveContextualType ? getRegularTypeOfLiteralType(argType) : getWidenedLiteralType(
							argType,
						),
					);
					flags.push(ElementFlags.Required);
				}
				if (arg.kind === SyntaxKind.SyntheticExpression && arg.tupleNameSource) {
					names.push(arg.tupleNameSource);
				}
			}
			return createTupleType(
				types,
				flags, /*readonly*/
				false,
				length(names) === length(types) ? names : undefined,
			);
		}
		function checkTypeArguments(
			signature,
			typeArgumentNodes,
			reportErrors,
			headMessage,
		) {
			var isJavascript = isInJSFile(signature.declaration);
			var typeParameters = signature.typeParameters;
			var typeArgumentTypes = fillMissingTypeArguments(
				map(typeArgumentNodes, getTypeFromTypeNode),
				typeParameters,
				getMinTypeArgumentCount(typeParameters),
				isJavascript,
			);
			var mapper;
			for (var i = 0; i < typeArgumentNodes.length; i++) {
				Debug.assert(
					typeParameters[i] !== undefined,
					"Should not call checkTypeArguments with too many type arguments",
				);
				var constraint = getConstraintOfTypeParameter(typeParameters[i]);
				if (constraint) {
					var errorInfo = reportErrors && headMessage ? (function () {
						return chainDiagnosticMessages(
							undefined, /*details*/
							Diagnostics.Type_0_does_not_satisfy_the_constraint_1,
						);
					}) : undefined;
					var typeArgumentHeadMessage = headMessage || Diagnostics.Type_0_does_not_satisfy_the_constraint_1;
					if (!mapper) {
						mapper = createTypeMapper(typeParameters, typeArgumentTypes);
					}
					var typeArgument = typeArgumentTypes[i];
					if (
						!checkTypeAssignableTo(
							typeArgument,
							getTypeWithThisArgument(
								instantiateType(constraint, mapper),
								typeArgument,
							),
							reportErrors ? typeArgumentNodes[i] : undefined,
							typeArgumentHeadMessage,
							errorInfo,
						)
					) {
						return undefined;
					}
				}
			}
			return typeArgumentTypes;
		}
		function getJsxReferenceKind(node) {
			if (isJsxIntrinsicIdentifier(node.tagName)) {
				return JsxReferenceKind.Mixed;
			}
			var tagType = getApparentType(checkExpression(node.tagName));
			if (length(getSignaturesOfType(tagType, SignatureKind.Construct))) {
				return JsxReferenceKind.Component;
			}
			if (length(getSignaturesOfType(tagType, SignatureKind.Call))) {
				return JsxReferenceKind.Function;
			}
			return JsxReferenceKind.Mixed;
		}
		/**
         * Check if the given signature can possibly be a signature called by the JSX opening-like element.
         * @param node a JSX opening-like element we are trying to figure its call signature
         * @param signature a candidate signature we are trying whether it is a call signature
         * @param relation a relationship to check parameter and argument type
         */
		function checkApplicableSignatureForJsxOpeningLikeElement(
			node,
			signature,
			relation,
			checkMode,
			reportErrors,
			containingMessageChain,
			errorOutputContainer,
		) {
			// Stateless function components can have maximum of three arguments: "props", "context", and "updater".
			// However "context" and "updater" are implicit and can't be specify by users. Only the first parameter, props,
			// can be specified by users through attributes property.
			var paramType = getEffectiveFirstArgumentForJsxSignature(signature, node);
			var attributesType = checkExpressionWithContextualType(
				node.attributes,
				paramType, /*inferenceContext*/
				undefined,
				checkMode,
			);
			return checkTagNameDoesNotExpectTooManyArguments() && checkTypeRelatedToAndOptionallyElaborate(
				attributesType,
				paramType,
				relation,
				reportErrors ? node.tagName : undefined,
				node.attributes,
				/*headMessage*/ undefined,
				containingMessageChain,
				errorOutputContainer,
			);
			function checkTagNameDoesNotExpectTooManyArguments() {
				var _a;
				if (getJsxNamespaceContainerForImplicitImport(node)) {
					return true; // factory is implicitly jsx/jsxdev - assume it fits the bill, since we don't strongly look for the jsx/jsxs/jsxDEV factory APIs anywhere else (at least not yet)
				}
				var tagType = isJsxOpeningElement(node) || isJsxSelfClosingElement(node) && !isJsxIntrinsicIdentifier(
					node.tagName,
				) ? checkExpression(node.tagName) : undefined;
				if (!tagType) {
					return true;
				}
				var tagCallSignatures = getSignaturesOfType(tagType, SignatureKind.Call);
				if (!length(tagCallSignatures)) {
					return true;
				}
				var factory = getJsxFactoryEntity(node);
				if (!factory) {
					return true;
				}
				var factorySymbol = resolveEntityName(
					factory,
					SymbolFlags.Value, /*ignoreErrors*/
					true, /*dontResolveAlias*/
					false,
					node,
				);
				if (!factorySymbol) {
					return true;
				}
				var factoryType = getTypeOfSymbol(factorySymbol);
				var callSignatures = getSignaturesOfType(
					factoryType,
					SignatureKind.Call,
				);
				if (!length(callSignatures)) {
					return true;
				}
				var hasFirstParamSignatures = false;
				var maxParamCount = 0;
				// Check that _some_ first parameter expects a FC-like thing, and that some overload of the SFC expects an acceptable number of arguments
				for (
					var _i = 0, callSignatures_1 = callSignatures;
					_i < callSignatures_1.length;
					_i++
				) {
					var sig = callSignatures_1[_i];
					var firstparam = getTypeAtPosition(sig, 0);
					var signaturesOfParam = getSignaturesOfType(
						firstparam,
						SignatureKind.Call,
					);
					if (!length(signaturesOfParam)) continue;
					for (
						var _b = 0, signaturesOfParam_1 = signaturesOfParam;
						_b < signaturesOfParam_1.length;
						_b++
					) {
						var paramSig = signaturesOfParam_1[_b];
						hasFirstParamSignatures = true;
						if (hasEffectiveRestParameter(paramSig)) {
							return true; // some signature has a rest param, so function components can have an arbitrary number of arguments
						}
						var paramCount = getParameterCount(paramSig);
						if (paramCount > maxParamCount) {
							maxParamCount = paramCount;
						}
					}
				}
				if (!hasFirstParamSignatures) {
					// Not a single signature had a first parameter which expected a signature - for back compat, and
					// to guard against generic factories which won't have signatures directly, do not error
					return true;
				}
				var absoluteMinArgCount = Infinity;
				for (
					var _c = 0, tagCallSignatures_1 = tagCallSignatures;
					_c < tagCallSignatures_1.length;
					_c++
				) {
					var tagSig = tagCallSignatures_1[_c];
					var tagRequiredArgCount = getMinArgumentCount(tagSig);
					if (tagRequiredArgCount < absoluteMinArgCount) {
						absoluteMinArgCount = tagRequiredArgCount;
					}
				}
				if (absoluteMinArgCount <= maxParamCount) {
					return true; // some signature accepts the number of arguments the function component provides
				}
				if (reportErrors) {
					var diag = createDiagnosticForNode(
						node.tagName,
						Diagnostics.Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3,
						entityNameToString(node.tagName),
						absoluteMinArgCount,
						entityNameToString(factory),
						maxParamCount,
					);
					var tagNameDeclaration = (_a = getSymbolAtLocation(node.tagName)) === null || _a === void 0 ? void 0 : _a.valueDeclaration;
					if (tagNameDeclaration) {
						addRelatedInfo(
							diag,
							createDiagnosticForNode(
								tagNameDeclaration,
								Diagnostics._0_is_declared_here,
								entityNameToString(node.tagName),
							),
						);
					}
					if (errorOutputContainer && errorOutputContainer.skipLogging) {
						(errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(
							diag,
						);
					}
					if (!errorOutputContainer.skipLogging) {
						diagnostics.add(diag);
					}
				}
				return false;
			}
		}
		function getSignatureApplicabilityError(
			node,
			args,
			signature,
			relation,
			checkMode,
			reportErrors,
			containingMessageChain,
		) {
			var errorOutputContainer = { errors: undefined, skipLogging: true };
			if (isJsxOpeningLikeElement(node)) {
				if (
					!checkApplicableSignatureForJsxOpeningLikeElement(
						node,
						signature,
						relation,
						checkMode,
						reportErrors,
						containingMessageChain,
						errorOutputContainer,
					)
				) {
					Debug.assert(
						!reportErrors || !!errorOutputContainer.errors,
						"jsx should have errors when reporting errors",
					);
					return errorOutputContainer.errors || emptyArray;
				}
				return undefined;
			}
			var thisType = getThisTypeOfSignature(signature);
			if (
				thisType && thisType !== voidType && node.kind !== SyntaxKind.NewExpression
			) {
				// If the called expression is not of the form `x.f` or `x["f"]`, then sourceType = voidType
				// If the signature's 'this' type is voidType, then the check is skipped -- anything is compatible.
				// If the expression is a new expression, then the check is skipped.
				var thisArgumentNode = getThisArgumentOfCall(node);
				var thisArgumentType = getThisArgumentType(thisArgumentNode);
				var errorNode = reportErrors ? (thisArgumentNode || node) : undefined;
				var headMessage_1 = Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1;
				if (
					!checkTypeRelatedTo(
						thisArgumentType,
						thisType,
						relation,
						errorNode,
						headMessage_1,
						containingMessageChain,
						errorOutputContainer,
					)
				) {
					Debug.assert(
						!reportErrors || !!errorOutputContainer.errors,
						"this parameter should have errors when reporting errors",
					);
					return errorOutputContainer.errors || emptyArray;
				}
			}
			var headMessage = Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1;
			var restType = getNonArrayRestType(signature);
			var argCount = restType ? Math.min(
				getParameterCount(signature) - 1,
				args.length,
			) : args.length;
			for (var i = 0; i < argCount; i++) {
				var arg = args[i];
				if (arg.kind !== SyntaxKind.OmittedExpression) {
					var paramType = getTypeAtPosition(signature, i);
					var argType = checkExpressionWithContextualType(
						arg,
						paramType, /*inferenceContext*/
						undefined,
						checkMode,
					);
					// If one or more arguments are still excluded (as indicated by CheckMode.SkipContextSensitive),
					// we obtain the regular type of any object literal arguments because we may not have inferred complete
					// parameter types yet and therefore excess property checks may yield false positives (see #17041).
					var checkArgType = checkMode & 4 ? getRegularTypeOfObjectLiteral(
						argType, /* SkipContextSensitive */
					) : argType;
					if (
						!checkTypeRelatedToAndOptionallyElaborate(
							checkArgType,
							paramType,
							relation,
							reportErrors ? arg : undefined,
							arg,
							headMessage,
							containingMessageChain,
							errorOutputContainer,
						)
					) {
						Debug.assert(
							!reportErrors || !!errorOutputContainer.errors,
							"parameter should have errors when reporting errors",
						);
						maybeAddMissingAwaitInfo(arg, checkArgType, paramType);
						return errorOutputContainer.errors || emptyArray;
					}
				}
			}
			if (restType) {
				var spreadType = getSpreadArgumentType(
					args,
					argCount,
					args.length,
					restType, /*context*/
					undefined,
					checkMode,
				);
				var restArgCount = args.length - argCount;
				var errorNode = !reportErrors ? undefined : restArgCount === 0 ? node : restArgCount === 1 ? args[argCount] : setTextRangePosEnd(
					createSyntheticExpression(node, spreadType),
					args[argCount].pos,
					args[args.length - 1].end,
				);
				if (
					!checkTypeRelatedTo(
						spreadType,
						restType,
						relation,
						errorNode,
						headMessage, /*containingMessageChain*/
						undefined,
						errorOutputContainer,
					)
				) {
					Debug.assert(
						!reportErrors || !!errorOutputContainer.errors,
						"rest parameter should have errors when reporting errors",
					);
					maybeAddMissingAwaitInfo(errorNode, spreadType, restType);
					return errorOutputContainer.errors || emptyArray;
				}
			}
			return undefined;
			function maybeAddMissingAwaitInfo(errorNode, source, target) {
				if (
					errorNode && reportErrors && errorOutputContainer.errors && errorOutputContainer.errors.length
				) {
					// Bail if target is Promise-like---something else is wrong
					if (getAwaitedTypeOfPromise(target)) {
						return;
					}
					var awaitedTypeOfSource = getAwaitedTypeOfPromise(source);
					if (
						awaitedTypeOfSource && isTypeRelatedTo(
							awaitedTypeOfSource,
							target,
							relation,
						)
					) {
						addRelatedInfo(
							errorOutputContainer.errors[0],
							createDiagnosticForNode(
								errorNode,
								Diagnostics.Did_you_forget_to_use_await,
							),
						);
					}
				}
			}
		}
		/**
         * Returns the this argument in calls like x.f(...) and x[f](...). Undefined otherwise.
         */
		function getThisArgumentOfCall(node) {
			var expression = node.kind === SyntaxKind.CallExpression ? node.expression : node.kind === SyntaxKind.TaggedTemplateExpression ? node.tag : undefined;
			if (expression) {
				var callee = skipOuterExpressions(expression);
				if (isAccessExpression(callee)) {
					return callee.expression;
				}
			}
		}
		function createSyntheticExpression(parent, type, isSpread, tupleNameSource) {
			var result = parseNodeFactory.createSyntheticExpression(
				type,
				isSpread,
				tupleNameSource,
			);
			setTextRange(result, parent);
			setParent(result, parent);
			return result;
		}
		/**
         * Returns the effective arguments for an expression that works like a function invocation.
         */
		function getEffectiveCallArguments(node) {
			if (node.kind === SyntaxKind.TaggedTemplateExpression) {
				var template = node.template;
				var args_1 = [
					createSyntheticExpression(
						template,
						getGlobalTemplateStringsArrayType(),
					),
				];
				if (template.kind === SyntaxKind.TemplateExpression) {
					forEach(
						template.templateSpans,
						function (span) {
							args_1.push(span.expression);
						},
					);
				}
				return args_1;
			}
			if (node.kind === SyntaxKind.Decorator) {
				return getEffectiveDecoratorArguments(node);
			}
			if (isJsxOpeningLikeElement(node)) {
				return node.attributes.properties.length > 0 || (isJsxOpeningElement(
					node,
				) && node.parent.children.length > 0) ? [node.attributes] : emptyArray;
			}
			var args = node.arguments || emptyArray;
			var spreadIndex = getSpreadArgumentIndex(args);
			if (spreadIndex >= 0) {
				// Create synthetic arguments from spreads of tuple types.
				var effectiveArgs_1 = args.slice(0, spreadIndex);
				var _loop_17 = function (i) {
					var arg = args[i];
					// We can call checkExpressionCached because spread expressions never have a contextual type.
					var spreadType = arg.kind === SyntaxKind.SpreadElement && (flowLoopCount ? checkExpression(
						arg.expression,
					) : checkExpressionCached(arg.expression));
					if (spreadType && isTupleType(spreadType)) {
						forEach(
							getTypeArguments(spreadType),
							function (t, i) {
								var _a;
								var flags = spreadType.target.elementFlags[i];
								var syntheticArg = createSyntheticExpression(
									arg,
									flags & ElementFlags.Rest ? createArrayType(t) : t,
									!!(flags & ElementFlags.Variable),
									(_a = spreadType.target.labeledElementDeclarations) === null || _a === void 0 ? void 0 : _a[i],
								);
								effectiveArgs_1.push(syntheticArg);
							},
						);
					} else {
						effectiveArgs_1.push(arg);
					}
				};
				for (var i = spreadIndex; i < args.length; i++) {
					_loop_17(i);
				}
				return effectiveArgs_1;
			}
			return args;
		}
		/**
         * Returns the synthetic argument list for a decorator invocation.
         */
		function getEffectiveDecoratorArguments(node) {
			var parent = node.parent;
			var expr = node.expression;
			switch (parent.kind) {
				case SyntaxKind.ClassDeclaration:
				case SyntaxKind.ClassExpression:
					// For a class decorator, the `target` is the type of the class (e.g. the
					// "static" or "constructor" side of the class).
					return [
						createSyntheticExpression(
							expr,
							getTypeOfSymbol(getSymbolOfNode(parent)),
						),
					];
				case SyntaxKind.Parameter:
					// A parameter declaration decorator will have three arguments (see
					// `ParameterDecorator` in core.d.ts).
					var func = parent.parent;
					return [
						createSyntheticExpression(
							expr,
							parent.parent.kind === SyntaxKind.Constructor ? getTypeOfSymbol(
								getSymbolOfNode(func),
							) : errorType,
						),
						createSyntheticExpression(expr, anyType),
						createSyntheticExpression(expr, numberType),
					];
				case SyntaxKind.PropertyDeclaration:
				case SyntaxKind.MethodDeclaration:
				case SyntaxKind.GetAccessor:
				case SyntaxKind.SetAccessor:
					// A method or accessor declaration decorator will have two or three arguments (see
					// `PropertyDecorator` and `MethodDecorator` in core.d.ts). If we are emitting decorators
					// for ES3, we will only pass two arguments.
					var hasPropDesc = parent.kind !== SyntaxKind.PropertyDeclaration && languageVersion !== ScriptTarget.ES3;
					return [
						createSyntheticExpression(expr, getParentTypeOfClassElement(parent)),
						createSyntheticExpression(
							expr,
							getClassElementPropertyKeyType(parent),
						),
						createSyntheticExpression(
							expr,
							hasPropDesc ? createTypedPropertyDescriptorType(
								getTypeOfNode(parent),
							) : anyType,
						),
					];
			}
			return Debug.fail();
		}
		/**
         * Returns the argument count for a decorator node that works like a function invocation.
         */
		function getDecoratorArgumentCount(node, signature) {
			switch (node.parent.kind) {
				case SyntaxKind.ClassDeclaration:
				case SyntaxKind.ClassExpression:
					return 1;
				case SyntaxKind.PropertyDeclaration:
					return 2;
				case SyntaxKind.MethodDeclaration:
				case SyntaxKind.GetAccessor:
				case SyntaxKind.SetAccessor:
					// For ES3 or decorators with only two parameters we supply only two arguments
					return languageVersion === ScriptTarget.ES3 || signature.parameters.length <= 2 ? 2 : 3;
				case SyntaxKind.Parameter:
					return 3;
				default:
					return Debug.fail();
			}
		}
		function getDiagnosticSpanForCallNode(node, doNotIncludeArguments) {
			var start;
			var length;
			var sourceFile = getSourceFileOfNode(node);
			if (isPropertyAccessExpression(node.expression)) {
				var nameSpan = getErrorSpanForNode(sourceFile, node.expression.name);
				start = nameSpan.start;
				length = doNotIncludeArguments ? nameSpan.length : node.end - start;
			} else {
				var expressionSpan = getErrorSpanForNode(sourceFile, node.expression);
				start = expressionSpan.start;
				length = doNotIncludeArguments ? expressionSpan.length : node.end - start;
			}
			return { start: start, length: length, sourceFile: sourceFile };
		}
		function getDiagnosticForCallNode(node, message, arg0, arg1, arg2, arg3) {
			if (isCallExpression(node)) {
				var _a = getDiagnosticSpanForCallNode(node),
					sourceFile = _a.sourceFile,
					start = _a.start,
					length_5 = _a.length;
				return createFileDiagnostic(
					sourceFile,
					start,
					length_5,
					message,
					arg0,
					arg1,
					arg2,
					arg3,
				);
			} else {
				return createDiagnosticForNode(node, message, arg0, arg1, arg2, arg3);
			}
		}
		function isPromiseResolveArityError(node) {
			if (!isCallExpression(node) || !isIdentifier(node.expression)) return false;
			var symbol = resolveName(
				node.expression,
				node.expression.escapedText,
				SymbolFlags.Value,
				undefined,
				undefined,
				false,
			);
			var decl = symbol === null || symbol === void 0 ? void 0 : symbol.valueDeclaration;
			if (
				!decl || !isParameter(decl) || !isFunctionExpressionOrArrowFunction(
					decl.parent,
				) || !isNewExpression(decl.parent.parent) || !isIdentifier(
					decl.parent.parent.expression,
				)
			) {
				return false;
			}
			var globalPromiseSymbol = getGlobalPromiseConstructorSymbol(
				false, /*reportErrors*/
			);
			if (!globalPromiseSymbol) return false;
			var constructorSymbol = getSymbolAtLocation(
				decl.parent.parent.expression, /*ignoreErrors*/
				true,
			);
			return constructorSymbol === globalPromiseSymbol;
		}
		function getArgumentArityError(node, signatures, args) {
			var _a;
			var spreadIndex = getSpreadArgumentIndex(args);
			if (spreadIndex > -1) {
				return createDiagnosticForNode(
					args[spreadIndex],
					Diagnostics.A_spread_argument_must_either_have_a_tuple_type_or_be_passed_to_a_rest_parameter,
				);
			}
			var min = Number.POSITIVE_INFINITY; // smallest parameter count
			var max = Number.NEGATIVE_INFINITY; // largest parameter count
			var maxBelow = Number.NEGATIVE_INFINITY; // largest parameter count that is smaller than the number of arguments
			var minAbove = Number.POSITIVE_INFINITY; // smallest parameter count that is larger than the number of arguments
			var closestSignature;
			for (var _i = 0, signatures_8 = signatures; _i < signatures_8.length; _i++) {
				var sig = signatures_8[_i];
				var minParameter = getMinArgumentCount(sig);
				var maxParameter = getParameterCount(sig);
				// smallest/largest parameter counts
				if (minParameter < min) {
					min = minParameter;
					closestSignature = sig;
				}
				max = Math.max(max, maxParameter);
				// shortest parameter count *longer than the call*/longest parameter count *shorter than the call*
				if (minParameter < args.length && minParameter > maxBelow) maxBelow = minParameter;
				if (args.length < maxParameter && maxParameter < minAbove) minAbove = maxParameter;
			}
			var hasRestParameter = some(signatures, hasEffectiveRestParameter);
			var parameterRange = hasRestParameter ? min : min < max ? min + "-" + max : min;
			var error = hasRestParameter ? Diagnostics.Expected_at_least_0_arguments_but_got_1 : parameterRange === 1 && args.length === 0 && isPromiseResolveArityError(
				node,
			) ? Diagnostics.Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise : Diagnostics.Expected_0_arguments_but_got_1;
			if (min < args.length && args.length < max) {
				// between min and max, but with no matching overload
				return getDiagnosticForCallNode(
					node,
					Diagnostics.No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments,
					args.length,
					maxBelow,
					minAbove,
				);
			} else if (args.length < min) {
				// too short: put the error span on the call expression, not any of the args
				var diagnostic = getDiagnosticForCallNode(
					node,
					error,
					parameterRange,
					args.length,
				);
				var parameter = (_a = closestSignature === null || closestSignature === void 0 ? void 0 : closestSignature.declaration) === null || _a === void 0 ? void 0 : _a.parameters[closestSignature.thisParameter ? args.length + 1 : args.length];
				if (parameter) {
					var parameterError = createDiagnosticForNode(
						parameter,
						isBindingPattern(parameter.name) ? Diagnostics.An_argument_matching_this_binding_pattern_was_not_provided : isRestParameter(
							parameter,
						) ? Diagnostics.Arguments_for_the_rest_parameter_0_were_not_provided : Diagnostics.An_argument_for_0_was_not_provided,
						!parameter.name ? args.length : !isBindingPattern(parameter.name) ? idText(
							getFirstIdentifier(parameter.name),
						) : undefined,
					);
					return addRelatedInfo(diagnostic, parameterError);
				}
				return diagnostic;
			} else {
				// too long; error goes on the excess parameters
				var errorSpan = factory.createNodeArray(args.slice(max));
				var pos = first(errorSpan).pos;
				var end = last(errorSpan).end;
				if (end === pos) {
					end++;
				}
				setTextRangePosEnd(errorSpan, pos, end);
				return createDiagnosticForNodeArray(
					getSourceFileOfNode(node),
					errorSpan,
					error,
					parameterRange,
					args.length,
				);
			}
		}
		function getTypeArgumentArityError(node, signatures, typeArguments) {
			var argCount = typeArguments.length;
			// No overloads exist
			if (signatures.length === 1) {
				var sig = signatures[0];
				var min = getMinTypeArgumentCount(sig.typeParameters);
				var max = length(sig.typeParameters);
				return createDiagnosticForNodeArray(
					getSourceFileOfNode(node),
					typeArguments,
					Diagnostics.Expected_0_type_arguments_but_got_1,
					min < max ? min + "-" + max : min,
					argCount,
				);
			}
			// Overloads exist
			var belowArgCount = -Infinity;
			var aboveArgCount = Infinity;
			for (var _i = 0, signatures_9 = signatures; _i < signatures_9.length; _i++) {
				var sig = signatures_9[_i];
				var min = getMinTypeArgumentCount(sig.typeParameters);
				var max = length(sig.typeParameters);
				if (min > argCount) {
					aboveArgCount = Math.min(aboveArgCount, min);
				} else if (max < argCount) {
					belowArgCount = Math.max(belowArgCount, max);
				}
			}
			if (belowArgCount !== -Infinity && aboveArgCount !== Infinity) {
				return createDiagnosticForNodeArray(
					getSourceFileOfNode(node),
					typeArguments,
					Diagnostics.No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments,
					argCount,
					belowArgCount,
					aboveArgCount,
				);
			}
			return createDiagnosticForNodeArray(
				getSourceFileOfNode(node),
				typeArguments,
				Diagnostics.Expected_0_type_arguments_but_got_1,
				belowArgCount === -Infinity ? aboveArgCount : belowArgCount,
				argCount,
			);
		}
		function resolveCall(
			node,
			signatures,
			candidatesOutArray,
			checkMode,
			callChainFlags,
			fallbackError,
		) {
			var isTaggedTemplate = node.kind === SyntaxKind.TaggedTemplateExpression;
			var isDecorator = node.kind === SyntaxKind.Decorator;
			var isJsxOpeningOrSelfClosingElement = isJsxOpeningLikeElement(node);
			var reportErrors = !candidatesOutArray && produceDiagnostics;
			var typeArguments;
			if (!isDecorator) {
				typeArguments = node.typeArguments;
				// We already perform checking on the type arguments on the class declaration itself.
				if (
					isTaggedTemplate || isJsxOpeningOrSelfClosingElement || node.expression.kind !== SyntaxKind.SuperKeyword
				) {
					forEach(typeArguments, checkSourceElement);
				}
			}
			var candidates = candidatesOutArray || [];
			// reorderCandidates fills up the candidates array directly
			reorderCandidates(signatures, candidates, callChainFlags);
			if (!candidates.length) {
				if (reportErrors) {
					diagnostics.add(
						getDiagnosticForCallNode(
							node,
							Diagnostics.Call_target_does_not_contain_any_signatures,
						),
					);
				}
				return resolveErrorCall(node);
			}
			var args = getEffectiveCallArguments(node);
			// The excludeArgument array contains true for each context sensitive argument (an argument
			// is context sensitive it is susceptible to a one-time permanent contextual typing).
			//
			// The idea is that we will perform type argument inference & assignability checking once
			// without using the susceptible parameters that are functions, and once more for those
			// parameters, contextually typing each as we go along.
			//
			// For a tagged template, then the first argument be 'undefined' if necessary because it
			// represents a TemplateStringsArray.
			//
			// For a decorator, no arguments are susceptible to contextual typing due to the fact
			// decorators are applied to a declaration by the emitter, and not to an expression.
			var isSingleNonGenericCandidate = candidates.length === 1 && !candidates[0].typeParameters;
			var argCheckMode = !isDecorator && !isSingleNonGenericCandidate && some(
				args,
				isContextSensitive,
			) ? 4 : 0; /* SkipContextSensitive */ /* Normal */
			// The following variables are captured and modified by calls to chooseOverload.
			// If overload resolution or type argument inference fails, we want to report the
			// best error possible. The best error is one which says that an argument was not
			// assignable to a parameter. This implies that everything else about the overload
			// was fine. So if there is any overload that is only incorrect because of an
			// argument, we will report an error on that one.
			//
			//     function foo(s: string): void;
			//     function foo(n: number): void; // Report argument error on this overload
			//     function foo(): void;
			//     foo(true);
			//
			// If none of the overloads even made it that far, there are two possibilities.
			// There was a problem with type arguments for some overload, in which case
			// report an error on that. Or none of the overloads even had correct arity,
			// in which case give an arity error.
			//
			//     function foo<T extends string>(x: T): void; // Report type argument error
			//     function foo(): void;
			//     foo<number>(0);
			//
			var candidatesForArgumentError;
			var candidateForArgumentArityError;
			var candidateForTypeArgumentError;
			var result;
			// If we are in signature help, a trailing comma indicates that we intend to provide another argument,
			// so we will only accept overloads with arity at least 1 higher than the current number of provided arguments.
			var signatureHelpTrailingComma = !!(checkMode & 16) && node.kind === SyntaxKind.CallExpression && node.arguments.hasTrailingComma; /* IsForSignatureHelp */
			// Section 4.12.1:
			// if the candidate list contains one or more signatures for which the type of each argument
			// expression is a subtype of each corresponding parameter type, the return type of the first
			// of those signatures becomes the return type of the function call.
			// Otherwise, the return type of the first signature in the candidate list becomes the return
			// type of the function call.
			//
			// Whether the call is an error is determined by assignability of the arguments. The subtype pass
			// is just important for choosing the best signature. So in the case where there is only one
			// signature, the subtype pass is useless. So skipping it is an optimization.
			if (candidates.length > 1) {
				result = chooseOverload(
					candidates,
					subtypeRelation,
					isSingleNonGenericCandidate,
					signatureHelpTrailingComma,
				);
			}
			if (!result) {
				result = chooseOverload(
					candidates,
					assignableRelation,
					isSingleNonGenericCandidate,
					signatureHelpTrailingComma,
				);
			}
			if (result) {
				return result;
			}
			// No signatures were applicable. Now report errors based on the last applicable signature with
			// no arguments excluded from assignability checks.
			// If candidate is undefined, it means that no candidates had a suitable arity. In that case,
			// skip the checkApplicableSignature check.
			if (reportErrors) {
				if (candidatesForArgumentError) {
					if (
						candidatesForArgumentError.length === 1 || candidatesForArgumentError.length > 3
					) {
						var last = candidatesForArgumentError[candidatesForArgumentError.length - 1];
						var chain_1;
						if (candidatesForArgumentError.length > 3) {
							chain_1 = chainDiagnosticMessages(
								chain_1,
								Diagnostics.The_last_overload_gave_the_following_error,
							);
							chain_1 = chainDiagnosticMessages(
								chain_1,
								Diagnostics.No_overload_matches_this_call,
							);
						}
						var diags = getSignatureApplicabilityError(
							node,
							args,
							last,
							assignableRelation,
							0, /* Normal */ /*reportErrors*/
							true,
							function () {
								return chain_1;
							},
						);
						if (diags) {
							for (var _i = 0, diags_1 = diags; _i < diags_1.length; _i++) {
								var d = diags_1[_i];
								if (last.declaration && candidatesForArgumentError.length > 3) {
									addRelatedInfo(
										d,
										createDiagnosticForNode(
											last.declaration,
											Diagnostics.The_last_overload_is_declared_here,
										),
									);
								}
								addImplementationSuccessElaboration(last, d);
								diagnostics.add(d);
							}
						} else {
							Debug.fail("No error for last overload signature");
						}
					} else {
						var allDiagnostics = [];
						var max = 0;
						var min = Number.MAX_VALUE;
						var minIndex = 0;
						var i_1 = 0;
						var _loop_18 = function (c) {
							var chain_2 = function () {
								return chainDiagnosticMessages(
									undefined, /*details*/
									Diagnostics.Overload_0_of_1_2_gave_the_following_error,
									i_1 + 1,
									candidates.length,
									signatureToString(c),
								);
							};
							var diags_2 = getSignatureApplicabilityError(
								node,
								args,
								c,
								assignableRelation,
								0, /* Normal */ /*reportErrors*/
								true,
								chain_2,
							);
							if (diags_2) {
								if (diags_2.length <= min) {
									min = diags_2.length;
									minIndex = i_1;
								}
								max = Math.max(max, diags_2.length);
								allDiagnostics.push(diags_2);
							} else {
								Debug.fail("No error for 3 or fewer overload signatures");
							}
							i_1++;
						};
						for (
							var _a = 0,
								candidatesForArgumentError_1 = candidatesForArgumentError;
							_a < candidatesForArgumentError_1.length;
							_a++
						) {
							var c = candidatesForArgumentError_1[_a];
							_loop_18(c);
						}
						var diags_3 = max > 1 ? allDiagnostics[minIndex] : flatten(
							allDiagnostics,
						);
						Debug.assert(
							diags_3.length > 0,
							"No errors reported for 3 or fewer overload signatures",
						);
						var chain = chainDiagnosticMessages(
							map(
								diags_3,
								function (d) {
									return typeof d.messageText === "string" ? d : d.messageText;
								},
							),
							Diagnostics.No_overload_matches_this_call,
						);
						// The below is a spread to guarantee we get a new (mutable) array - our `flatMap` helper tries to do "smart" optimizations where it reuses input
						// arrays and the emptyArray singleton where possible, which is decidedly not what we want while we're still constructing this diagnostic
						var related = __spreadArray(
							[],
							flatMap(
								diags_3,
								function (d) {
									return d.relatedInformation;
								},
							),
							true,
						);
						var diag = void 0;
						if (
							every(
								diags_3,
								function (d) {
									return d.start === diags_3[0].start && d.length === diags_3[0].length && d.file === diags_3[0].file;
								},
							)
						) {
							var _b = diags_3[0],
								file = _b.file,
								start = _b.start,
								length_6 = _b.length;
							diag = {
								file: file,
								start: start,
								length: length_6,
								code: chain.code,
								category: chain.category,
								messageText: chain,
								relatedInformation: related,
							};
						} else {
							diag = createDiagnosticForNodeFromMessageChain(
								node,
								chain,
								related,
							);
						}
						addImplementationSuccessElaboration(
							candidatesForArgumentError[0],
							diag,
						);
						diagnostics.add(diag);
					}
				} else if (candidateForArgumentArityError) {
					diagnostics.add(
						getArgumentArityError(node, [candidateForArgumentArityError], args),
					);
				} else if (candidateForTypeArgumentError) {
					checkTypeArguments(
						candidateForTypeArgumentError,
						node.typeArguments, /*reportErrors*/
						true,
						fallbackError,
					);
				} else {
					var signaturesWithCorrectTypeArgumentArity = filter(
						signatures,
						function (s) {
							return hasCorrectTypeArgumentArity(s, typeArguments);
						},
					);
					if (signaturesWithCorrectTypeArgumentArity.length === 0) {
						diagnostics.add(
							getTypeArgumentArityError(node, signatures, typeArguments),
						);
					} else if (!isDecorator) {
						diagnostics.add(
							getArgumentArityError(
								node,
								signaturesWithCorrectTypeArgumentArity,
								args,
							),
						);
					} else if (fallbackError) {
						diagnostics.add(getDiagnosticForCallNode(node, fallbackError));
					}
				}
			}
			return getCandidateForOverloadFailure(
				node,
				candidates,
				args,
				!!candidatesOutArray,
			);
			function addImplementationSuccessElaboration(failed, diagnostic) {
				var _a, _b;
				var oldCandidatesForArgumentError = candidatesForArgumentError;
				var oldCandidateForArgumentArityError = candidateForArgumentArityError;
				var oldCandidateForTypeArgumentError = candidateForTypeArgumentError;
				var failedSignatureDeclarations = ((_b = (_a = failed.declaration) === null || _a === void 0 ? void 0 : _a.symbol) === null || _b === void 0 ? void 0 : _b.declarations) || emptyArray;
				var isOverload = failedSignatureDeclarations.length > 1;
				var implDecl = isOverload ? find(
					failedSignatureDeclarations,
					function (d) {
						return isFunctionLikeDeclaration(d) && nodeIsPresent(d.body);
					},
				) : undefined;
				if (implDecl) {
					var candidate = getSignatureFromDeclaration(implDecl);
					var isSingleNonGenericCandidate_1 = !candidate.typeParameters;
					if (
						chooseOverload(
							[candidate],
							assignableRelation,
							isSingleNonGenericCandidate_1,
						)
					) {
						addRelatedInfo(
							diagnostic,
							createDiagnosticForNode(
								implDecl,
								Diagnostics.The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_are_not_externally_visible,
							),
						);
					}
				}
				candidatesForArgumentError = oldCandidatesForArgumentError;
				candidateForArgumentArityError = oldCandidateForArgumentArityError;
				candidateForTypeArgumentError = oldCandidateForTypeArgumentError;
			}
			function chooseOverload(
				candidates,
				relation,
				isSingleNonGenericCandidate,
				signatureHelpTrailingComma,
			) {
				if (signatureHelpTrailingComma === void 0) {
					signatureHelpTrailingComma = false;
				}
				candidatesForArgumentError = undefined;
				candidateForArgumentArityError = undefined;
				candidateForTypeArgumentError = undefined;
				if (isSingleNonGenericCandidate) {
					var candidate = candidates[0];
					if (
						some(typeArguments) || !hasCorrectArity(
							node,
							args,
							candidate,
							signatureHelpTrailingComma,
						)
					) {
						return undefined;
					}
					if (
						getSignatureApplicabilityError(
							node,
							args,
							candidate,
							relation,
							0, /* Normal */ /*reportErrors*/
							false, /*containingMessageChain*/
							undefined,
						)
					) {
						candidatesForArgumentError = [candidate];
						return undefined;
					}
					return candidate;
				}
				for (
					var candidateIndex = 0;
					candidateIndex < candidates.length;
					candidateIndex++
				) {
					var candidate = candidates[candidateIndex];
					if (
						!hasCorrectTypeArgumentArity(candidate, typeArguments) || !hasCorrectArity(
							node,
							args,
							candidate,
							signatureHelpTrailingComma,
						)
					) {
						continue;
					}
					var checkCandidate = void 0;
					var inferenceContext = void 0;
					if (candidate.typeParameters) {
						var typeArgumentTypes = void 0;
						if (some(typeArguments)) {
							typeArgumentTypes = checkTypeArguments(
								candidate,
								typeArguments, /*reportErrors*/
								false,
							);
							if (!typeArgumentTypes) {
								candidateForTypeArgumentError = candidate;
								continue;
							}
						} else {
							inferenceContext = createInferenceContext(
								candidate.typeParameters,
								candidate, /*flags*/
								isInJSFile(node) ? InferenceFlags.AnyDefault : InferenceFlags.None,
							);
							typeArgumentTypes = inferTypeArguments(
								node,
								candidate,
								args,
								argCheckMode | 8, /* SkipGenericFunctions */
								inferenceContext,
							);
							argCheckMode |= inferenceContext.flags & InferenceFlags.SkippedGenericFunction ? 8 : 0; /* SkipGenericFunctions */ /* Normal */
						}
						checkCandidate = getSignatureInstantiation(
							candidate,
							typeArgumentTypes,
							isInJSFile(candidate.declaration),
							inferenceContext && inferenceContext.inferredTypeParameters,
						);
						// If the original signature has a generic rest type, instantiation may produce a
						// signature with different arity and we need to perform another arity check.
						if (
							getNonArrayRestType(candidate) && !hasCorrectArity(
								node,
								args,
								checkCandidate,
								signatureHelpTrailingComma,
							)
						) {
							candidateForArgumentArityError = checkCandidate;
							continue;
						}
					} else {
						checkCandidate = candidate;
					}
					if (
						getSignatureApplicabilityError(
							node,
							args,
							checkCandidate,
							relation,
							argCheckMode, /*reportErrors*/
							false, /*containingMessageChain*/
							undefined,
						)
					) {
						// Give preference to error candidates that have no rest parameters (as they are more specific)
						(candidatesForArgumentError || (candidatesForArgumentError = [])).push(
							checkCandidate,
						);
						continue;
					}
					if (argCheckMode) {
						// If one or more context sensitive arguments were excluded, we start including
						// them now (and keeping do so for any subsequent candidates) and perform a second
						// round of type inference and applicability checking for this particular candidate.
						argCheckMode = 0; /* Normal */
						if (inferenceContext) {
							var typeArgumentTypes = inferTypeArguments(
								node,
								candidate,
								args,
								argCheckMode,
								inferenceContext,
							);
							checkCandidate = getSignatureInstantiation(
								candidate,
								typeArgumentTypes,
								isInJSFile(candidate.declaration),
								inferenceContext && inferenceContext.inferredTypeParameters,
							);
							// If the original signature has a generic rest type, instantiation may produce a
							// signature with different arity and we need to perform another arity check.
							if (
								getNonArrayRestType(candidate) && !hasCorrectArity(
									node,
									args,
									checkCandidate,
									signatureHelpTrailingComma,
								)
							) {
								candidateForArgumentArityError = checkCandidate;
								continue;
							}
						}
						if (
							getSignatureApplicabilityError(
								node,
								args,
								checkCandidate,
								relation,
								argCheckMode, /*reportErrors*/
								false, /*containingMessageChain*/
								undefined,
							)
						) {
							// Give preference to error candidates that have no rest parameters (as they are more specific)
							(candidatesForArgumentError || (candidatesForArgumentError = [])).push(
								checkCandidate,
							);
							continue;
						}
					}
					candidates[candidateIndex] = checkCandidate;
					return checkCandidate;
				}
				return undefined;
			}
		}
		// No signature was applicable. We have already reported the errors for the invalid signature.
		function getCandidateForOverloadFailure(
			node,
			candidates,
			args,
			hasCandidatesOutArray,
		) {
			Debug.assert(candidates.length > 0); // Else should not have called this.
			checkNodeDeferred(node);
			// Normally we will combine overloads. Skip this if they have type parameters since that's hard to combine.
			// Don't do this if there is a `candidatesOutArray`,
			// because then we want the chosen best candidate to be one of the overloads, not a combination.
			return hasCandidatesOutArray || candidates.length === 1 || candidates.some(
				function (c) {
					return !!c.typeParameters;
				},
			) ? pickLongestCandidateSignature(node, candidates, args) : createUnionOfSignaturesForOverloadFailure(
				candidates,
			);
		}
		function createUnionOfSignaturesForOverloadFailure(candidates) {
			var thisParameters = mapDefined(
				candidates,
				function (c) {
					return c.thisParameter;
				},
			);
			var thisParameter;
			if (thisParameters.length) {
				thisParameter = createCombinedSymbolFromTypes(
					thisParameters,
					thisParameters.map(getTypeOfParameter),
				);
			}
			var _a = minAndMax(candidates, getNumNonRestParameters),
				minArgumentCount = _a.min,
				maxNonRestParam = _a.max;
			var parameters = [];
			var _loop_19 = function (i) {
				var symbols = mapDefined(
					candidates,
					function (s) {
						return signatureHasRestParameter(s) ? i < s.parameters.length - 1 ? s.parameters[i] : last(
							s.parameters,
						) : i < s.parameters.length ? s.parameters[i] : undefined;
					},
				);
				Debug.assert(symbols.length !== 0);
				parameters.push(
					createCombinedSymbolFromTypes(
						symbols,
						mapDefined(
							candidates,
							function (candidate) {
								return tryGetTypeAtPosition(candidate, i);
							},
						),
					),
				);
			};
			for (var i = 0; i < maxNonRestParam; i++) {
				_loop_19(i);
			}
			var restParameterSymbols = mapDefined(
				candidates,
				function (c) {
					return signatureHasRestParameter(c) ? last(c.parameters) : undefined;
				},
			);
			var flags = SignatureFlags.None;
			if (restParameterSymbols.length !== 0) {
				var type = createArrayType(
					getUnionType(
						mapDefined(candidates, tryGetRestTypeOfSignature),
						UnionReduction.Subtype,
					),
				);
				parameters.push(
					createCombinedSymbolForOverloadFailure(restParameterSymbols, type),
				);
				flags |= SignatureFlags.HasRestParameter;
			}
			if (candidates.some(signatureHasLiteralTypes)) {
				flags |= SignatureFlags.HasLiteralTypes;
			}
			return createSignature(
				candidates[0].declaration,
				/*typeParameters*/ undefined, // Before calling this we tested for `!candidates.some(c => !!c.typeParameters)`.
				thisParameter,
				parameters,
				/*resolvedReturnType*/ getIntersectionType(
					candidates.map(getReturnTypeOfSignature),
				),
				/*typePredicate*/ undefined,
				minArgumentCount,
				flags,
			);
		}
		function getNumNonRestParameters(signature) {
			var numParams = signature.parameters.length;
			return signatureHasRestParameter(signature) ? numParams - 1 : numParams;
		}
		function createCombinedSymbolFromTypes(sources, types) {
			return createCombinedSymbolForOverloadFailure(
				sources,
				getUnionType(types, UnionReduction.Subtype),
			);
		}
		function createCombinedSymbolForOverloadFailure(sources, type) {
			// This function is currently only used for erroneous overloads, so it's good enough to just use the first source.
			return createSymbolWithType(first(sources), type);
		}
		function pickLongestCandidateSignature(node, candidates, args) {
			// Pick the longest signature. This way we can get a contextual type for cases like:
			//     declare function f(a: { xa: number; xb: number; }, b: number);
			//     f({ |
			// Also, use explicitly-supplied type arguments if they are provided, so we can get a contextual signature in cases like:
			//     declare function f<T>(k: keyof T);
			//     f<Foo>("
			var bestIndex = getLongestCandidateIndex(
				candidates,
				apparentArgumentCount === undefined ? args.length : apparentArgumentCount,
			);
			var candidate = candidates[bestIndex];
			var typeParameters = candidate.typeParameters;
			if (!typeParameters) {
				return candidate;
			}
			var typeArgumentNodes = callLikeExpressionMayHaveTypeArguments(node) ? node.typeArguments : undefined;
			var instantiated = typeArgumentNodes ? createSignatureInstantiation(
				candidate,
				getTypeArgumentsFromNodes(
					typeArgumentNodes,
					typeParameters,
					isInJSFile(node),
				),
			) : inferSignatureInstantiationForOverloadFailure(
				node,
				typeParameters,
				candidate,
				args,
			);
			candidates[bestIndex] = instantiated;
			return instantiated;
		}
		function getTypeArgumentsFromNodes(typeArgumentNodes, typeParameters, isJs) {
			var typeArguments = typeArgumentNodes.map(getTypeOfNode);
			while (typeArguments.length > typeParameters.length) {
				typeArguments.pop();
			}
			while (typeArguments.length < typeParameters.length) {
				typeArguments.push(
					getDefaultFromTypeParameter(typeParameters[typeArguments.length]) || getConstraintOfTypeParameter(
						typeParameters[typeArguments.length],
					) || getDefaultTypeArgumentType(isJs),
				);
			}
			return typeArguments;
		}
		function inferSignatureInstantiationForOverloadFailure(
			node,
			typeParameters,
			candidate,
			args,
		) {
			var inferenceContext = createInferenceContext(
				typeParameters,
				candidate, /*flags*/
				isInJSFile(node) ? InferenceFlags.AnyDefault : InferenceFlags.None,
			);
			var typeArgumentTypes = inferTypeArguments(
				node,
				candidate,
				args,
				4 | 8, /* SkipContextSensitive */ /* SkipGenericFunctions */
				inferenceContext,
			);
			return createSignatureInstantiation(candidate, typeArgumentTypes);
		}
		function getLongestCandidateIndex(candidates, argsCount) {
			var maxParamsIndex = -1;
			var maxParams = -1;
			for (var i = 0; i < candidates.length; i++) {
				var candidate = candidates[i];
				var paramCount = getParameterCount(candidate);
				if (hasEffectiveRestParameter(candidate) || paramCount >= argsCount) {
					return i;
				}
				if (paramCount > maxParams) {
					maxParams = paramCount;
					maxParamsIndex = i;
				}
			}
			return maxParamsIndex;
		}
		function resolveCallExpression(node, candidatesOutArray, checkMode) {
			if (node.expression.kind === SyntaxKind.SuperKeyword) {
				var superType = checkSuperExpression(node.expression);
				if (isTypeAny(superType)) {
					for (var _i = 0, _a = node.arguments; _i < _a.length; _i++) {
						var arg = _a[_i];
						checkExpression(arg); // Still visit arguments so they get marked for visibility, etc
					}
					return anySignature;
				}
				if (!isErrorType(superType)) {
					// In super call, the candidate signatures are the matching arity signatures of the base constructor function instantiated
					// with the type arguments specified in the extends clause.
					var baseTypeNode = getEffectiveBaseTypeNode(getContainingClass(node));
					if (baseTypeNode) {
						var baseConstructors = getInstantiatedConstructorsForTypeArguments(
							superType,
							baseTypeNode.typeArguments,
							baseTypeNode,
						);
						return resolveCall(
							node,
							baseConstructors,
							candidatesOutArray,
							checkMode,
							SignatureFlags.None,
						);
					}
				}
				return resolveUntypedCall(node);
			}
			var callChainFlags;
			var funcType = checkExpression(node.expression);
			if (isCallChain(node)) {
				var nonOptionalType = getOptionalExpressionType(
					funcType,
					node.expression,
				);
				callChainFlags = nonOptionalType === funcType ? SignatureFlags.None : isOutermostOptionalChain(
					node,
				) ? SignatureFlags.IsOuterCallChain : SignatureFlags.IsInnerCallChain;
				funcType = nonOptionalType;
			} else {
				callChainFlags = SignatureFlags.None;
			}
			funcType = checkNonNullTypeWithReporter(
				funcType,
				node.expression,
				reportCannotInvokePossiblyNullOrUndefinedError,
			);
			if (funcType === silentNeverType) {
				return silentNeverSignature;
			}
			var apparentType = getApparentType(funcType);
			if (isErrorType(apparentType)) {
				// Another error has already been reported
				return resolveErrorCall(node);
			}
			// Technically, this signatures list may be incomplete. We are taking the apparent type,
			// but we are not including call signatures that may have been added to the Object or
			// Function interface, since they have none by default. This is a bit of a leap of faith
			// that the user will not add any.
			var callSignatures = getSignaturesOfType(apparentType, SignatureKind.Call);
			var numConstructSignatures = getSignaturesOfType(
				apparentType,
				SignatureKind.Construct,
			).length;
			// TS 1.0 Spec: 4.12
			// In an untyped function call no TypeArgs are permitted, Args can be any argument list, no contextual
			// types are provided for the argument expressions, and the result is always of type Any.
			if (
				isUntypedFunctionCall(
					funcType,
					apparentType,
					callSignatures.length,
					numConstructSignatures,
				)
			) {
				// The unknownType indicates that an error already occurred (and was reported).  No
				// need to report another error in this case.
				if (!isErrorType(funcType) && node.typeArguments) {
					error(
						node,
						Diagnostics.Untyped_function_calls_may_not_accept_type_arguments,
					);
				}
				return resolveUntypedCall(node);
			}
			// If FuncExpr's apparent type(section 3.8.1) is a function type, the call is a typed function call.
			// TypeScript employs overload resolution in typed function calls in order to support functions
			// with multiple call signatures.
			if (!callSignatures.length) {
				if (numConstructSignatures) {
					error(
						node,
						Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new,
						typeToString(funcType),
					);
				} else {
					var relatedInformation = void 0;
					if (node.arguments.length === 1) {
						var text = getSourceFileOfNode(node).text;
						if (
							isLineBreak(
								text.charCodeAt(
									skipTrivia(
										text,
										node.expression.end, /* stopAfterLineBreak */
										true,
									) - 1,
								),
							)
						) {
							relatedInformation = createDiagnosticForNode(
								node.expression,
								Diagnostics.Are_you_missing_a_semicolon,
							);
						}
					}
					invocationError(
						node.expression,
						apparentType,
						SignatureKind.Call,
						relatedInformation,
					);
				}
				return resolveErrorCall(node);
			}
			// When a call to a generic function is an argument to an outer call to a generic function for which
			// inference is in process, we have a choice to make. If the inner call relies on inferences made from
			// its contextual type to its return type, deferring the inner call processing allows the best possible
			// contextual type to accumulate. But if the outer call relies on inferences made from the return type of
			// the inner call, the inner call should be processed early. There's no sure way to know which choice is
			// right (only a full unification algorithm can determine that), so we resort to the following heuristic:
			// If no type arguments are specified in the inner call and at least one call signature is generic and
			// returns a function type, we choose to defer processing. This narrowly permits function composition
			// operators to flow inferences through return types, but otherwise processes calls right away. We
			// use the resolvingSignature singleton to indicate that we deferred processing. This result will be
			// propagated out and eventually turned into nonInferrableType (a type that is assignable to anything and
			// from which we never make inferences).
			if (
				checkMode & 8 && !node.typeArguments && callSignatures.some(
					isGenericFunctionReturningFunction, /* SkipGenericFunctions */
				)
			) {
				skippedGenericFunction(node, checkMode);
				return resolvingSignature;
			}
			// If the function is explicitly marked with `@class`, then it must be constructed.
			if (
				callSignatures.some(
					function (sig) {
						return isInJSFile(sig.declaration) && !!getJSDocClassTag(
							sig.declaration,
						);
					},
				)
			) {
				error(
					node,
					Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new,
					typeToString(funcType),
				);
				return resolveErrorCall(node);
			}
			return resolveCall(
				node,
				callSignatures,
				candidatesOutArray,
				checkMode,
				callChainFlags,
			);
		}
		function isGenericFunctionReturningFunction(signature) {
			return !!(signature.typeParameters && isFunctionType(
				getReturnTypeOfSignature(signature),
			));
		}
		/**
         * TS 1.0 spec: 4.12
         * If FuncExpr is of type Any, or of an object type that has no call or construct signatures
         * but is a subtype of the Function interface, the call is an untyped function call.
         */
		function isUntypedFunctionCall(
			funcType,
			apparentFuncType,
			numCallSignatures,
			numConstructSignatures,
		) {
			// We exclude union types because we may have a union of function types that happen to have no common signatures.
			return isTypeAny(funcType) || isTypeAny(apparentFuncType) && !!(funcType.flags & TypeFlags.TypeParameter) || !numCallSignatures && !numConstructSignatures && !(apparentFuncType.flags & TypeFlags.Union) && !(getReducedType(
				apparentFuncType,
			).flags & TypeFlags.Never) && isTypeAssignableTo(
				funcType,
				globalFunctionType,
			);
		}
		function resolveNewExpression(node, candidatesOutArray, checkMode) {
			if (node.arguments && languageVersion < ScriptTarget.ES5) {
				var spreadIndex = getSpreadArgumentIndex(node.arguments);
				if (spreadIndex >= 0) {
					error(
						node.arguments[spreadIndex],
						Diagnostics.Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher,
					);
				}
			}
			var expressionType = checkNonNullExpression(node.expression);
			if (expressionType === silentNeverType) {
				return silentNeverSignature;
			}
			// If expressionType's apparent type(section 3.8.1) is an object type with one or
			// more construct signatures, the expression is processed in the same manner as a
			// function call, but using the construct signatures as the initial set of candidate
			// signatures for overload resolution. The result type of the function call becomes
			// the result type of the operation.
			expressionType = getApparentType(expressionType);
			if (isErrorType(expressionType)) {
				// Another error has already been reported
				return resolveErrorCall(node);
			}
			// TS 1.0 spec: 4.11
			// If expressionType is of type Any, Args can be any argument
			// list and the result of the operation is of type Any.
			if (isTypeAny(expressionType)) {
				if (node.typeArguments) {
					error(
						node,
						Diagnostics.Untyped_function_calls_may_not_accept_type_arguments,
					);
				}
				return resolveUntypedCall(node);
			}
			// Technically, this signatures list may be incomplete. We are taking the apparent type,
			// but we are not including construct signatures that may have been added to the Object or
			// Function interface, since they have none by default. This is a bit of a leap of faith
			// that the user will not add any.
			var constructSignatures = getSignaturesOfType(
				expressionType,
				SignatureKind.Construct,
			);
			if (constructSignatures.length) {
				if (!isConstructorAccessible(node, constructSignatures[0])) {
					return resolveErrorCall(node);
				}
				// If the expression is a class of abstract type, or an abstract construct signature,
				// then it cannot be instantiated.
				// In the case of a merged class-module or class-interface declaration,
				// only the class declaration node will have the Abstract flag set.
				if (
					constructSignatures.some(
						function (signature) {
							return signature.flags & SignatureFlags.Abstract;
						},
					)
				) {
					error(
						node,
						Diagnostics.Cannot_create_an_instance_of_an_abstract_class,
					);
					return resolveErrorCall(node);
				}
				var valueDecl = expressionType.symbol && getClassLikeDeclarationOfSymbol(
					expressionType.symbol,
				);
				if (
					valueDecl && hasSyntacticModifier(valueDecl, ModifierFlags.Abstract)
				) {
					error(
						node,
						Diagnostics.Cannot_create_an_instance_of_an_abstract_class,
					);
					return resolveErrorCall(node);
				}
				return resolveCall(
					node,
					constructSignatures,
					candidatesOutArray,
					checkMode,
					SignatureFlags.None,
				);
			}
			// If expressionType's apparent type is an object type with no construct signatures but
			// one or more call signatures, the expression is processed as a function call. A compile-time
			// error occurs if the result of the function call is not Void. The type of the result of the
			// operation is Any. It is an error to have a Void this type.
			var callSignatures = getSignaturesOfType(
				expressionType,
				SignatureKind.Call,
			);
			if (callSignatures.length) {
				var signature = resolveCall(
					node,
					callSignatures,
					candidatesOutArray,
					checkMode,
					SignatureFlags.None,
				);
				if (!noImplicitAny) {
					if (
						signature.declaration && !isJSConstructor(signature.declaration) && getReturnTypeOfSignature(
							signature,
						) !== voidType
					) {
						error(
							node,
							Diagnostics.Only_a_void_function_can_be_called_with_the_new_keyword,
						);
					}
					if (getThisTypeOfSignature(signature) === voidType) {
						error(
							node,
							Diagnostics.A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void,
						);
					}
				}
				return signature;
			}
			invocationError(node.expression, expressionType, SignatureKind.Construct);
			return resolveErrorCall(node);
		}
		function typeHasProtectedAccessibleBase(target, type) {
			var baseTypes = getBaseTypes(type);
			if (!length(baseTypes)) {
				return false;
			}
			var firstBase = baseTypes[0];
			if (firstBase.flags & TypeFlags.Intersection) {
				var types = firstBase.types;
				var mixinFlags = findMixins(types);
				var i = 0;
				for (var _i = 0, _a = firstBase.types; _i < _a.length; _i++) {
					var intersectionMember = _a[_i];
					// We want to ignore mixin ctors
					if (!mixinFlags[i]) {
						if (
							getObjectFlags(intersectionMember) & (ObjectFlags.Class | ObjectFlags.Interface)
						) {
							if (intersectionMember.symbol === target) {
								return true;
							}
							if (typeHasProtectedAccessibleBase(target, intersectionMember)) {
								return true;
							}
						}
					}
					i++;
				}
				return false;
			}
			if (firstBase.symbol === target) {
				return true;
			}
			return typeHasProtectedAccessibleBase(target, firstBase);
		}
		function isConstructorAccessible(node, signature) {
			if (!signature || !signature.declaration) {
				return true;
			}
			var declaration = signature.declaration;
			var modifiers = getSelectedEffectiveModifierFlags(
				declaration,
				ModifierFlags.NonPublicAccessibilityModifier,
			);
			// (1) Public constructors and (2) constructor functions are always accessible.
			if (!modifiers || declaration.kind !== SyntaxKind.Constructor) {
				return true;
			}
			var declaringClassDeclaration = getClassLikeDeclarationOfSymbol(
				declaration.parent.symbol,
			);
			var declaringClass = getDeclaredTypeOfSymbol(declaration.parent.symbol);
			// A private or protected constructor can only be instantiated within its own class (or a subclass, for protected)
			if (!isNodeWithinClass(node, declaringClassDeclaration)) {
				var containingClass = getContainingClass(node);
				if (containingClass && modifiers & ModifierFlags.Protected) {
					var containingType = getTypeOfNode(containingClass);
					if (
						typeHasProtectedAccessibleBase(
							declaration.parent.symbol,
							containingType,
						)
					) {
						return true;
					}
				}
				if (modifiers & ModifierFlags.Private) {
					error(
						node,
						Diagnostics.Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration,
						typeToString(declaringClass),
					);
				}
				if (modifiers & ModifierFlags.Protected) {
					error(
						node,
						Diagnostics.Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration,
						typeToString(declaringClass),
					);
				}
				return false;
			}
			return true;
		}
		function invocationErrorDetails(errorTarget, apparentType, kind) {
			var errorInfo;
			var isCall = kind === SignatureKind.Call;
			var awaitedType = getAwaitedType(apparentType);
			var maybeMissingAwait = awaitedType && getSignaturesOfType(
				awaitedType,
				kind,
			).length > 0;
			if (apparentType.flags & TypeFlags.Union) {
				var types = apparentType.types;
				var hasSignatures = false;
				for (var _i = 0, types_20 = types; _i < types_20.length; _i++) {
					var constituent = types_20[_i];
					var signatures = getSignaturesOfType(constituent, kind);
					if (signatures.length !== 0) {
						hasSignatures = true;
						if (errorInfo) {
							// Bail early if we already have an error, no chance of "No constituent of type is callable"
							break;
						}
					} else {
						// Error on the first non callable constituent only
						if (!errorInfo) {
							errorInfo = chainDiagnosticMessages(
								errorInfo,
								isCall ? Diagnostics.Type_0_has_no_call_signatures : Diagnostics.Type_0_has_no_construct_signatures,
								typeToString(constituent),
							);
							errorInfo = chainDiagnosticMessages(
								errorInfo,
								isCall ? Diagnostics.Not_all_constituents_of_type_0_are_callable : Diagnostics.Not_all_constituents_of_type_0_are_constructable,
								typeToString(apparentType),
							);
						}
						if (hasSignatures) {
							// Bail early if we already found a siganture, no chance of "No constituent of type is callable"
							break;
						}
					}
				}
				if (!hasSignatures) {
					errorInfo = chainDiagnosticMessages(
						/* detials */ undefined,
						isCall ? Diagnostics.No_constituent_of_type_0_is_callable : Diagnostics.No_constituent_of_type_0_is_constructable,
						typeToString(apparentType),
					);
				}
				if (!errorInfo) {
					errorInfo = chainDiagnosticMessages(
						errorInfo,
						isCall ? Diagnostics.Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_other : Diagnostics.Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_with_each_other,
						typeToString(apparentType),
					);
				}
			} else {
				errorInfo = chainDiagnosticMessages(
					errorInfo,
					isCall ? Diagnostics.Type_0_has_no_call_signatures : Diagnostics.Type_0_has_no_construct_signatures,
					typeToString(apparentType),
				);
			}
			var headMessage = isCall ? Diagnostics.This_expression_is_not_callable : Diagnostics.This_expression_is_not_constructable;
			// Diagnose get accessors incorrectly called as functions
			if (
				isCallExpression(errorTarget.parent) && errorTarget.parent.arguments.length === 0
			) {
				var resolvedSymbol = getNodeLinks(errorTarget).resolvedSymbol;
				if (resolvedSymbol && resolvedSymbol.flags & SymbolFlags.GetAccessor) {
					headMessage = Diagnostics.This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without;
				}
			}
			return {
				messageChain: chainDiagnosticMessages(errorInfo, headMessage),
				relatedMessage: maybeMissingAwait ? Diagnostics.Did_you_forget_to_use_await : undefined,
			};
		}
		function invocationError(
			errorTarget,
			apparentType,
			kind,
			relatedInformation,
		) {
			var _a = invocationErrorDetails(errorTarget, apparentType, kind),
				messageChain = _a.messageChain,
				relatedInfo = _a.relatedMessage;
			var diagnostic = createDiagnosticForNodeFromMessageChain(
				errorTarget,
				messageChain,
			);
			if (relatedInfo) {
				addRelatedInfo(
					diagnostic,
					createDiagnosticForNode(errorTarget, relatedInfo),
				);
			}
			if (isCallExpression(errorTarget.parent)) {
				var _b = getDiagnosticSpanForCallNode(
					errorTarget.parent, /* doNotIncludeArguments */
					true,
				),
					start = _b.start,
					length_7 = _b.length;
				diagnostic.start = start;
				diagnostic.length = length_7;
			}
			diagnostics.add(diagnostic);
			invocationErrorRecovery(
				apparentType,
				kind,
				relatedInformation ? addRelatedInfo(diagnostic, relatedInformation) : diagnostic,
			);
		}
		function invocationErrorRecovery(apparentType, kind, diagnostic) {
			if (!apparentType.symbol) {
				return;
			}
			var importNode = getSymbolLinks(apparentType.symbol).originatingImport;
			// Create a diagnostic on the originating import if possible onto which we can attach a quickfix
			//  An import call expression cannot be rewritten into another form to correct the error - the only solution is to use `.default` at the use-site
			if (importNode && !isImportCall(importNode)) {
				var sigs = getSignaturesOfType(
					getTypeOfSymbol(getSymbolLinks(apparentType.symbol).target),
					kind,
				);
				if (!sigs || !sigs.length) return;
				addRelatedInfo(
					diagnostic,
					createDiagnosticForNode(
						importNode,
						Diagnostics.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead,
					),
				);
			}
		}
		function resolveTaggedTemplateExpression(
			node,
			candidatesOutArray,
			checkMode,
		) {
			var tagType = checkExpression(node.tag);
			var apparentType = getApparentType(tagType);
			if (isErrorType(apparentType)) {
				// Another error has already been reported
				return resolveErrorCall(node);
			}
			var callSignatures = getSignaturesOfType(apparentType, SignatureKind.Call);
			var numConstructSignatures = getSignaturesOfType(
				apparentType,
				SignatureKind.Construct,
			).length;
			if (
				isUntypedFunctionCall(
					tagType,
					apparentType,
					callSignatures.length,
					numConstructSignatures,
				)
			) {
				return resolveUntypedCall(node);
			}
			if (!callSignatures.length) {
				if (isArrayLiteralExpression(node.parent)) {
					var diagnostic = createDiagnosticForNode(
						node.tag,
						Diagnostics.It_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_They_form_a_tagged_template_expression_which_cannot_be_invoked,
					);
					diagnostics.add(diagnostic);
					return resolveErrorCall(node);
				}
				invocationError(node.tag, apparentType, SignatureKind.Call);
				return resolveErrorCall(node);
			}
			return resolveCall(
				node,
				callSignatures,
				candidatesOutArray,
				checkMode,
				SignatureFlags.None,
			);
		}
		/**
         * Gets the localized diagnostic head message to use for errors when resolving a decorator as a call expression.
         */
		function getDiagnosticHeadMessageForDecoratorResolution(node) {
			switch (node.parent.kind) {
				case SyntaxKind.ClassDeclaration:
				case SyntaxKind.ClassExpression:
					return Diagnostics.Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression;
				case SyntaxKind.Parameter:
					return Diagnostics.Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression;
				case SyntaxKind.PropertyDeclaration:
					return Diagnostics.Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression;
				case SyntaxKind.MethodDeclaration:
				case SyntaxKind.GetAccessor:
				case SyntaxKind.SetAccessor:
					return Diagnostics.Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression;
				default:
					return Debug.fail();
			}
		}
		/**
         * Resolves a decorator as if it were a call expression.
         */
		function resolveDecorator(node, candidatesOutArray, checkMode) {
			var funcType = checkExpression(node.expression);
			var apparentType = getApparentType(funcType);
			if (isErrorType(apparentType)) {
				return resolveErrorCall(node);
			}
			var callSignatures = getSignaturesOfType(apparentType, SignatureKind.Call);
			var numConstructSignatures = getSignaturesOfType(
				apparentType,
				SignatureKind.Construct,
			).length;
			if (
				isUntypedFunctionCall(
					funcType,
					apparentType,
					callSignatures.length,
					numConstructSignatures,
				)
			) {
				return resolveUntypedCall(node);
			}
			if (isPotentiallyUncalledDecorator(node, callSignatures)) {
				var nodeStr = getTextOfNode(node.expression, /*includeTrivia*/ false);
				error(
					node,
					Diagnostics._0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0,
					nodeStr,
				);
				return resolveErrorCall(node);
			}
			var headMessage = getDiagnosticHeadMessageForDecoratorResolution(node);
			if (!callSignatures.length) {
				var errorDetails = invocationErrorDetails(
					node.expression,
					apparentType,
					SignatureKind.Call,
				);
				var messageChain = chainDiagnosticMessages(
					errorDetails.messageChain,
					headMessage,
				);
				var diag = createDiagnosticForNodeFromMessageChain(
					node.expression,
					messageChain,
				);
				if (errorDetails.relatedMessage) {
					addRelatedInfo(
						diag,
						createDiagnosticForNode(
							node.expression,
							errorDetails.relatedMessage,
						),
					);
				}
				diagnostics.add(diag);
				invocationErrorRecovery(apparentType, SignatureKind.Call, diag);
				return resolveErrorCall(node);
			}
			return resolveCall(
				node,
				callSignatures,
				candidatesOutArray,
				checkMode,
				SignatureFlags.None,
				headMessage,
			);
		}
		function createSignatureForJSXIntrinsic(node, result) {
			var namespace = getJsxNamespaceAt(node);
			var exports = namespace && getExportsOfSymbol(namespace);
			// We fake up a SFC signature for each intrinsic, however a more specific per-element signature drawn from the JSX declaration
			// file would probably be preferable.
			var typeSymbol = exports && getSymbol(
				exports,
				JsxNames.Element,
				SymbolFlags.Type,
			);
			var returnNode = typeSymbol && nodeBuilder.symbolToEntityName(
				typeSymbol,
				SymbolFlags.Type,
				node,
			);
			var declaration = factory.createFunctionTypeNode(
				undefined, /*typeParameters*/
				[
					factory.createParameterDeclaration(
						undefined, /*decorators*/ /*modifiers*/
						undefined, /*dotdotdot*/
						undefined,
						"props", /*questionMark*/
						undefined,
						nodeBuilder.typeToTypeNode(result, node),
					),
				],
				returnNode ? factory.createTypeReferenceNode(
					returnNode, /*typeArguments*/
					undefined,
				) : factory.createKeywordTypeNode(SyntaxKind.AnyKeyword),
			);
			var parameterSymbol = createSymbol(
				SymbolFlags.FunctionScopedVariable,
				"props",
			);
			parameterSymbol.type = result;
			return createSignature(
				declaration,
				/*typeParameters*/ undefined,
				/*thisParameter*/ undefined,
				[parameterSymbol],
				typeSymbol ? getDeclaredTypeOfSymbol(typeSymbol) : errorType,
				/*returnTypePredicate*/ undefined,
				1,
				SignatureFlags.None,
			);
		}
		function resolveJsxOpeningLikeElement(node, candidatesOutArray, checkMode) {
			if (isJsxIntrinsicIdentifier(node.tagName)) {
				var result = getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node);
				var fakeSignature = createSignatureForJSXIntrinsic(node, result);
				checkTypeAssignableToAndOptionallyElaborate(
					checkExpressionWithContextualType(
						node.attributes,
						getEffectiveFirstArgumentForJsxSignature(fakeSignature, node), /*mapper*/
						undefined,
						0, /* Normal */
					),
					result,
					node.tagName,
					node.attributes,
				);
				if (length(node.typeArguments)) {
					forEach(node.typeArguments, checkSourceElement);
					diagnostics.add(
						createDiagnosticForNodeArray(
							getSourceFileOfNode(node),
							node.typeArguments,
							Diagnostics.Expected_0_type_arguments_but_got_1,
							0,
							length(node.typeArguments),
						),
					);
				}
				return fakeSignature;
			}
			var exprTypes = checkExpression(node.tagName);
			var apparentType = getApparentType(exprTypes);
			if (isErrorType(apparentType)) {
				return resolveErrorCall(node);
			}
			var signatures = getUninstantiatedJsxSignaturesOfType(exprTypes, node);
			if (
				isUntypedFunctionCall(
					exprTypes,
					apparentType,
					signatures.length, /*constructSignatures*/
					0,
				)
			) {
				return resolveUntypedCall(node);
			}
			if (signatures.length === 0) {
				// We found no signatures at all, which is an error
				error(
					node.tagName,
					Diagnostics.JSX_element_type_0_does_not_have_any_construct_or_call_signatures,
					getTextOfNode(node.tagName),
				);
				return resolveErrorCall(node);
			}
			return resolveCall(
				node,
				signatures,
				candidatesOutArray,
				checkMode,
				SignatureFlags.None,
			);
		}
		/**
         * Sometimes, we have a decorator that could accept zero arguments,
         * but is receiving too many arguments as part of the decorator invocation.
         * In those cases, a user may have meant to *call* the expression before using it as a decorator.
         */
		function isPotentiallyUncalledDecorator(decorator, signatures) {
			return signatures.length && every(
				signatures,
				function (signature) {
					return signature.minArgumentCount === 0 && !signatureHasRestParameter(
						signature,
					) && signature.parameters.length < getDecoratorArgumentCount(
						decorator,
						signature,
					);
				},
			);
		}
		function resolveSignature(node, candidatesOutArray, checkMode) {
			switch (node.kind) {
				case SyntaxKind.CallExpression:
					return resolveCallExpression(node, candidatesOutArray, checkMode);
				case SyntaxKind.NewExpression:
					return resolveNewExpression(node, candidatesOutArray, checkMode);
				case SyntaxKind.TaggedTemplateExpression:
					return resolveTaggedTemplateExpression(
						node,
						candidatesOutArray,
						checkMode,
					);
				case SyntaxKind.Decorator:
					return resolveDecorator(node, candidatesOutArray, checkMode);
				case SyntaxKind.JsxOpeningElement:
				case SyntaxKind.JsxSelfClosingElement:
					return resolveJsxOpeningLikeElement(
						node,
						candidatesOutArray,
						checkMode,
					);
			}
			throw Debug.assertNever(
				node,
				"Branch in 'resolveSignature' should be unreachable.",
			);
		}
		/**
         * Resolve a signature of a given call-like expression.
         * @param node a call-like expression to try resolve a signature for
         * @param candidatesOutArray an array of signature to be filled in by the function. It is passed by signature help in the language service;
         *                           the function will fill it up with appropriate candidate signatures
         * @return a signature of the call-like expression or undefined if one can't be found
         */
		function getResolvedSignature(node, candidatesOutArray, checkMode) {
			var links = getNodeLinks(node);
			// If getResolvedSignature has already been called, we will have cached the resolvedSignature.
			// However, it is possible that either candidatesOutArray was not passed in the first time,
			// or that a different candidatesOutArray was passed in. Therefore, we need to redo the work
			// to correctly fill the candidatesOutArray.
			var cached = links.resolvedSignature;
			if (cached && cached !== resolvingSignature && !candidatesOutArray) {
				return cached;
			}
			links.resolvedSignature = resolvingSignature;
			var result = resolveSignature(
				node,
				candidatesOutArray,
				checkMode || 0, /* Normal */
			);
			// When CheckMode.SkipGenericFunctions is set we use resolvingSignature to indicate that call
			// resolution should be deferred.
			if (result !== resolvingSignature) {
				// If signature resolution originated in control flow type analysis (for example to compute the
				// assigned type in a flow assignment) we don't cache the result as it may be based on temporary
				// types from the control flow analysis.
				links.resolvedSignature = flowLoopStart === flowLoopCount ? result : cached;
			}
			return result;
		}
		/**
         * Indicates whether a declaration can be treated as a constructor in a JavaScript
         * file.
         */
		function isJSConstructor(node) {
			var _a;
			if (!node || !isInJSFile(node)) {
				return false;
			}
			var func = isFunctionDeclaration(node) || isFunctionExpression(node) ? node : isVariableDeclaration(
				node,
			) && node.initializer && isFunctionExpression(node.initializer) ? node.initializer : undefined;
			if (func) {
				// If the node has a @class tag, treat it like a constructor.
				if (getJSDocClassTag(node)) return true;
				// If the symbol of the node has members, treat it like a constructor.
				var symbol = getSymbolOfNode(func);
				return !!((_a = symbol === null || symbol === void 0 ? void 0 : symbol.members) === null || _a === void 0 ? void 0 : _a.size);
			}
			return false;
		}
		function mergeJSSymbols(target, source) {
			var _a, _b;
			if (source) {
				var links = getSymbolLinks(source);
				if (
					!links.inferredClassSymbol || !links.inferredClassSymbol.has(
						getSymbolId(target),
					)
				) {
					var inferred = isTransientSymbol(target) ? target : cloneSymbol(
						target,
					);
					inferred.exports = inferred.exports || createSymbolTable();
					inferred.members = inferred.members || createSymbolTable();
					inferred.flags |= source.flags & SymbolFlags.Class;
					if (
						(_a = source.exports) === null || _a === void 0 ? void 0 : _a.size
					) {
						mergeSymbolTable(inferred.exports, source.exports);
					}
					if (
						(_b = source.members) === null || _b === void 0 ? void 0 : _b.size
					) {
						mergeSymbolTable(inferred.members, source.members);
					}
					(links.inferredClassSymbol || (links.inferredClassSymbol = new Map())).set(
						getSymbolId(inferred),
						inferred,
					);
					return inferred;
				}
				return links.inferredClassSymbol.get(getSymbolId(target));
			}
		}
		function getAssignedClassSymbol(decl) {
			var _a;
			var assignmentSymbol = decl && getSymbolOfExpando(
				decl, /*allowDeclaration*/
				true,
			);
			var prototype = (_a = assignmentSymbol === null || assignmentSymbol === void 0 ? void 0 : assignmentSymbol.exports) === null || _a === void 0 ? void 0 : _a.get(
				"prototype",
			);
			var init = (prototype === null || prototype === void 0 ? void 0 : prototype.valueDeclaration) && getAssignedJSPrototype(
				prototype.valueDeclaration,
			);
			return init ? getSymbolOfNode(init) : undefined;
		}
		function getSymbolOfExpando(node, allowDeclaration) {
			if (!node.parent) {
				return undefined;
			}
			var name;
			var decl;
			if (
				isVariableDeclaration(node.parent) && node.parent.initializer === node
			) {
				if (
					!isInJSFile(node) && !(isVarConst(node.parent) && isFunctionLikeDeclaration(
						node,
					))
				) {
					return undefined;
				}
				name = node.parent.name;
				decl = node.parent;
			} else if (isBinaryExpression(node.parent)) {
				var parentNode = node.parent;
				var parentNodeOperator = node.parent.operatorToken.kind;
				if (
					parentNodeOperator === SyntaxKind.EqualsToken && (allowDeclaration || parentNode.right === node)
				) {
					name = parentNode.left;
					decl = name;
				} else if (
					parentNodeOperator === SyntaxKind.BarBarToken || parentNodeOperator === SyntaxKind.QuestionQuestionToken
				) {
					if (
						isVariableDeclaration(parentNode.parent) && parentNode.parent.initializer === parentNode
					) {
						name = parentNode.parent.name;
						decl = parentNode.parent;
					} else if (
						isBinaryExpression(parentNode.parent) && parentNode.parent.operatorToken.kind === SyntaxKind.EqualsToken && (allowDeclaration || parentNode.parent.right === parentNode)
					) {
						name = parentNode.parent.left;
						decl = name;
					}
					if (
						!name || !isBindableStaticNameExpression(name) || !isSameEntityName(
							name,
							parentNode.left,
						)
					) {
						return undefined;
					}
				}
			} else if (allowDeclaration && isFunctionDeclaration(node)) {
				name = node.name;
				decl = node;
			}
			if (
				!decl || !name || (!allowDeclaration && !getExpandoInitializer(
					node,
					isPrototypeAccess(name),
				))
			) {
				return undefined;
			}
			return getSymbolOfNode(decl);
		}
		function getAssignedJSPrototype(node) {
			if (!node.parent) {
				return false;
			}
			var parent = node.parent;
			while (parent && parent.kind === SyntaxKind.PropertyAccessExpression) {
				parent = parent.parent;
			}
			if (
				parent && isBinaryExpression(parent) && isPrototypeAccess(parent.left) && parent.operatorToken.kind === SyntaxKind.EqualsToken
			) {
				var right = getInitializerOfBinaryExpression(parent);
				return isObjectLiteralExpression(right) && right;
			}
		}
		/**
         * Syntactically and semantically checks a call or new expression.
         * @param node The call/new expression to be checked.
         * @returns On success, the expression's signature's return type. On failure, anyType.
         */
		function checkCallExpression(node, checkMode) {
			var _a;
			checkGrammarTypeArguments(node, node.typeArguments);
			var signature = getResolvedSignature(
				node, /*candidatesOutArray*/
				undefined,
				checkMode,
			);
			if (signature === resolvingSignature) {
				// CheckMode.SkipGenericFunctions is enabled and this is a call to a generic function that
				// returns a function type. We defer checking and return nonInferrableType.
				return nonInferrableType;
			}
			checkDeprecatedSignature(signature, node);
			if (node.expression.kind === SyntaxKind.SuperKeyword) {
				return voidType;
			}
			if (node.kind === SyntaxKind.NewExpression) {
				var declaration = signature.declaration;
				if (
					declaration && declaration.kind !== SyntaxKind.Constructor && declaration.kind !== SyntaxKind.ConstructSignature && declaration.kind !== SyntaxKind.ConstructorType && !isJSDocConstructSignature(
						declaration,
					) && !isJSConstructor(declaration)
				) {
					// When resolved signature is a call signature (and not a construct signature) the result type is any
					if (noImplicitAny) {
						error(
							node,
							Diagnostics.new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type,
						);
					}
					return anyType;
				}
			}
			// In JavaScript files, calls to any identifier 'require' are treated as external module imports
			if (isInJSFile(node) && isCommonJsRequire(node)) {
				return resolveExternalModuleTypeByLiteral(node.arguments[0]);
			}
			var returnType = getReturnTypeOfSignature(signature);
			// Treat any call to the global 'Symbol' function that is part of a const variable or readonly property
			// as a fresh unique symbol literal type.
			if (
				returnType.flags & TypeFlags.ESSymbolLike && isSymbolOrSymbolForCall(
					node,
				)
			) {
				return getESSymbolLikeTypeForNode(
					walkUpParenthesizedExpressions(node.parent),
				);
			}
			if (
				node.kind === SyntaxKind.CallExpression && !node.questionDotToken && node.parent.kind === SyntaxKind.ExpressionStatement && returnType.flags & TypeFlags.Void && getTypePredicateOfSignature(
					signature,
				)
			) {
				if (!isDottedName(node.expression)) {
					error(
						node.expression,
						Diagnostics.Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name,
					);
				} else if (!getEffectsSignature(node)) {
					var diagnostic = error(
						node.expression,
						Diagnostics.Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation,
					);
					getTypeOfDottedName(node.expression, diagnostic);
				}
			}
			if (isInJSFile(node)) {
				var jsSymbol = getSymbolOfExpando(node, /*allowDeclaration*/ false);
				if (
					(_a = jsSymbol === null || jsSymbol === void 0 ? void 0 : jsSymbol.exports) === null || _a === void 0 ? void 0 : _a.size
				) {
					var jsAssignmentType = createAnonymousType(
						jsSymbol,
						jsSymbol.exports,
						emptyArray,
						emptyArray,
						emptyArray,
					);
					jsAssignmentType.objectFlags |= ObjectFlags.JSLiteral;
					return getIntersectionType([returnType, jsAssignmentType]);
				}
			}
			return returnType;
		}
		function checkDeprecatedSignature(signature, node) {
			if (
				signature.declaration && signature.declaration.flags & NodeFlags.Deprecated
			) {
				var suggestionNode = getDeprecatedSuggestionNode(node);
				var name_22 = tryGetPropertyAccessOrIdentifierToString(
					getInvokedExpression(node),
				);
				addDeprecatedSuggestionWithSignature(
					suggestionNode,
					signature.declaration,
					name_22,
					signatureToString(signature),
				);
			}
		}
		function getDeprecatedSuggestionNode(node) {
			node = skipParentheses(node);
			switch (node.kind) {
				case SyntaxKind.CallExpression:
				case SyntaxKind.Decorator:
				case SyntaxKind.NewExpression:
					return getDeprecatedSuggestionNode(node.expression);
				case SyntaxKind.TaggedTemplateExpression:
					return getDeprecatedSuggestionNode(node.tag);
				case SyntaxKind.JsxOpeningElement:
				case SyntaxKind.JsxSelfClosingElement:
					return getDeprecatedSuggestionNode(node.tagName);
				case SyntaxKind.ElementAccessExpression:
					return node.argumentExpression;
				case SyntaxKind.PropertyAccessExpression:
					return node.name;
				case SyntaxKind.TypeReference:
					var typeReference = node;
					return isQualifiedName(typeReference.typeName) ? typeReference.typeName.right : typeReference;
				default:
					return node;
			}
		}
		function isSymbolOrSymbolForCall(node) {
			if (!isCallExpression(node)) return false;
			var left = node.expression;
			if (isPropertyAccessExpression(left) && left.name.escapedText === "for") {
				left = left.expression;
			}
			if (!isIdentifier(left) || left.escapedText !== "Symbol") {
				return false;
			}
			// make sure `Symbol` is the global symbol
			var globalESSymbol = getGlobalESSymbolConstructorSymbol(
				false, /*reportErrors*/
			);
			if (!globalESSymbol) {
				return false;
			}
			return globalESSymbol === resolveName(
				left,
				"Symbol",
				SymbolFlags.Value, /*nameNotFoundMessage*/
				undefined, /*nameArg*/
				undefined, /*isUse*/
				false,
			);
		}
		function checkImportCallExpression(node) {
			// Check grammar of dynamic import
			checkGrammarImportCallExpression(node);
			if (node.arguments.length === 0) {
				return createPromiseReturnType(node, anyType);
			}
			var specifier = node.arguments[0];
			var specifierType = checkExpressionCached(specifier);
			var optionsType = node.arguments.length > 1 ? checkExpressionCached(
				node.arguments[1],
			) : undefined;
			// Even though multiple arguments is grammatically incorrect, type-check extra arguments for completion
			for (var i = 2; i < node.arguments.length; ++i) {
				checkExpressionCached(node.arguments[i]);
			}
			if (
				specifierType.flags & TypeFlags.Undefined || specifierType.flags & TypeFlags.Null || !isTypeAssignableTo(
					specifierType,
					stringType,
				)
			) {
				error(
					specifier,
					Diagnostics.Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0,
					typeToString(specifierType),
				);
			}
			if (optionsType) {
				var importCallOptionsType = getGlobalImportCallOptionsType(
					true, /*reportErrors*/
				);
				if (importCallOptionsType !== emptyObjectType) {
					checkTypeAssignableTo(
						optionsType,
						getNullableType(importCallOptionsType, TypeFlags.Undefined),
						node.arguments[1],
					);
				}
			}
			// resolveExternalModuleName will return undefined if the moduleReferenceExpression is not a string literal
			var moduleSymbol = resolveExternalModuleName(node, specifier);
			if (moduleSymbol) {
				var esModuleSymbol = resolveESModuleSymbol(
					moduleSymbol,
					specifier, /*dontRecursivelyResolve*/
					true, /*suppressUsageError*/
					false,
				);
				if (esModuleSymbol) {
					return createPromiseReturnType(
						node,
						getTypeWithSyntheticDefaultOnly(
							getTypeOfSymbol(esModuleSymbol),
							esModuleSymbol,
							moduleSymbol,
							specifier,
						) || getTypeWithSyntheticDefaultImportType(
							getTypeOfSymbol(esModuleSymbol),
							esModuleSymbol,
							moduleSymbol,
							specifier,
						),
					);
				}
			}
			return createPromiseReturnType(node, anyType);
		}
		function createDefaultPropertyWrapperForModule(
			symbol,
			originalSymbol,
			anonymousSymbol,
		) {
			var memberTable = createSymbolTable();
			var newSymbol = createSymbol(
				SymbolFlags.Alias,
				InternalSymbolName.Default,
			);
			newSymbol.parent = originalSymbol;
			newSymbol.nameType = getStringLiteralType("default");
			newSymbol.target = resolveSymbol(symbol);
			memberTable.set(InternalSymbolName.Default, newSymbol);
			return createAnonymousType(
				anonymousSymbol,
				memberTable,
				emptyArray,
				emptyArray,
				emptyArray,
			);
		}
		function getTypeWithSyntheticDefaultOnly(
			type,
			symbol,
			originalSymbol,
			moduleSpecifier,
		) {
			var hasDefaultOnly = isOnlyImportedAsDefault(moduleSpecifier);
			if (hasDefaultOnly && type && !isErrorType(type)) {
				var synthType = type;
				if (!synthType.defaultOnlyType) {
					var type_4 = createDefaultPropertyWrapperForModule(
						symbol,
						originalSymbol,
					);
					synthType.defaultOnlyType = type_4;
				}
				return synthType.defaultOnlyType;
			}
			return undefined;
		}
		function getTypeWithSyntheticDefaultImportType(
			type,
			symbol,
			originalSymbol,
			moduleSpecifier,
		) {
			var _a;
			if (allowSyntheticDefaultImports && type && !isErrorType(type)) {
				var synthType = type;
				if (!synthType.syntheticType) {
					var file = (_a = originalSymbol.declarations) === null || _a === void 0 ? void 0 : _a.find(
						isSourceFile,
					);
					var hasSyntheticDefault = canHaveSyntheticDefault(
						file,
						originalSymbol, /*dontResolveAlias*/
						false,
						moduleSpecifier,
					);
					if (hasSyntheticDefault) {
						var anonymousSymbol = createSymbol(
							SymbolFlags.TypeLiteral,
							InternalSymbolName.Type,
						);
						var defaultContainingObject = createDefaultPropertyWrapperForModule(
							symbol,
							originalSymbol,
							anonymousSymbol,
						);
						anonymousSymbol.type = defaultContainingObject;
						synthType.syntheticType = isValidSpreadType(type) ? getSpreadType(
							type,
							defaultContainingObject,
							anonymousSymbol, /*objectFlags*/
							0, /*readonly*/
							false,
						) : defaultContainingObject;
					} else {
						synthType.syntheticType = type;
					}
				}
				return synthType.syntheticType;
			}
			return type;
		}
		function isCommonJsRequire(node) {
			if (!isRequireCall(node, /*checkArgumentIsStringLiteralLike*/ true)) {
				return false;
			}
			// Make sure require is not a local function
			if (!isIdentifier(node.expression)) return Debug.fail();
			var resolvedRequire = resolveName(
				node.expression,
				node.expression.escapedText,
				SymbolFlags.Value, /*nameNotFoundMessage*/
				undefined, /*nameArg*/
				undefined, /*isUse*/
				true,
			); // TODO: GH#18217
			if (resolvedRequire === requireSymbol) {
				return true;
			}
			// project includes symbol named 'require' - make sure that it is ambient and local non-alias
			if (resolvedRequire.flags & SymbolFlags.Alias) {
				return false;
			}
			var targetDeclarationKind = resolvedRequire.flags & SymbolFlags.Function ? SyntaxKind.FunctionDeclaration : resolvedRequire.flags & SymbolFlags.Variable ? SyntaxKind.VariableDeclaration : SyntaxKind.Unknown;
			if (targetDeclarationKind !== SyntaxKind.Unknown) {
				var decl = getDeclarationOfKind(resolvedRequire, targetDeclarationKind);
				// function/variable declaration should be ambient
				return !!decl && !!(decl.flags & NodeFlags.Ambient);
			}
			return false;
		}
		function checkTaggedTemplateExpression(node) {
			if (!checkGrammarTaggedTemplateChain(node)) checkGrammarTypeArguments(
				node,
				node.typeArguments,
			);
			if (languageVersion < ScriptTarget.ES2015) {
				checkExternalEmitHelpers(node, ExternalEmitHelpers.MakeTemplateObject);
			}
			var signature = getResolvedSignature(node);
			checkDeprecatedSignature(signature, node);
			return getReturnTypeOfSignature(signature);
		}
		function checkAssertion(node) {
			if (node.kind === SyntaxKind.TypeAssertionExpression) {
				var file = getSourceFileOfNode(node);
				if (
					file && fileExtensionIsOneOf(
						file.fileName,
						[Extension.Cts, Extension.Mts],
					)
				) {
					grammarErrorOnNode(
						node,
						Diagnostics.This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Use_an_as_expression_instead,
					);
				}
			}
			return checkAssertionWorker(node, node.type, node.expression);
		}
		function isValidConstAssertionArgument(node) {
			switch (node.kind) {
				case SyntaxKind.StringLiteral:
				case SyntaxKind.NoSubstitutionTemplateLiteral:
				case SyntaxKind.NumericLiteral:
				case SyntaxKind.BigIntLiteral:
				case SyntaxKind.TrueKeyword:
				case SyntaxKind.FalseKeyword:
				case SyntaxKind.ArrayLiteralExpression:
				case SyntaxKind.ObjectLiteralExpression:
				case SyntaxKind.TemplateExpression:
					return true;
				case SyntaxKind.ParenthesizedExpression:
					return isValidConstAssertionArgument(node.expression);
				case SyntaxKind.PrefixUnaryExpression:
					var op = node.operator;
					var arg = node.operand;
					return op === SyntaxKind.MinusToken && (arg.kind === SyntaxKind.NumericLiteral || arg.kind === SyntaxKind.BigIntLiteral) || op === SyntaxKind.PlusToken && arg.kind === SyntaxKind.NumericLiteral;
				case SyntaxKind.PropertyAccessExpression:
				case SyntaxKind.ElementAccessExpression:
					var expr = node.expression;
					var symbol = getTypeOfNode(expr).symbol;
					if (symbol && symbol.flags & SymbolFlags.Alias) {
						symbol = resolveAlias(symbol);
					}
					return !!(symbol && (symbol.flags & SymbolFlags.Enum) && getEnumKind(
						symbol,
					) === EnumKind.Literal);
			}
			return false;
		}
		function checkAssertionWorker(errNode, type, expression, checkMode) {
			var exprType = checkExpression(expression, checkMode);
			if (isConstTypeReference(type)) {
				if (!isValidConstAssertionArgument(expression)) {
					error(
						expression,
						Diagnostics.A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array_or_object_literals,
					);
				}
				return getRegularTypeOfLiteralType(exprType);
			}
			checkSourceElement(type);
			exprType = getRegularTypeOfObjectLiteral(
				getBaseTypeOfLiteralType(exprType),
			);
			var targetType = getTypeFromTypeNode(type);
			if (produceDiagnostics && !isErrorType(targetType)) {
				var widenedType = getWidenedType(exprType);
				if (!isTypeComparableTo(targetType, widenedType)) {
					checkTypeComparableTo(
						exprType,
						targetType,
						errNode,
						Diagnostics.Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the_other_If_this_was_intentional_convert_the_expression_to_unknown_first,
					);
				}
			}
			return targetType;
		}
		function checkNonNullChain(node) {
			var leftType = checkExpression(node.expression);
			var nonOptionalType = getOptionalExpressionType(leftType, node.expression);
			return propagateOptionalTypeMarker(
				getNonNullableType(nonOptionalType),
				node,
				nonOptionalType !== leftType,
			);
		}
		function checkNonNullAssertion(node) {
			return node.flags & NodeFlags.OptionalChain ? checkNonNullChain(node) : getNonNullableType(
				checkExpression(node.expression),
			);
		}
		function checkMetaProperty(node) {
			checkGrammarMetaProperty(node);
			if (node.keywordToken === SyntaxKind.NewKeyword) {
				return checkNewTargetMetaProperty(node);
			}
			if (node.keywordToken === SyntaxKind.ImportKeyword) {
				return checkImportMetaProperty(node);
			}
			return Debug.assertNever(node.keywordToken);
		}
		function checkMetaPropertyKeyword(node) {
			switch (node.keywordToken) {
				case SyntaxKind.ImportKeyword:
					return getGlobalImportMetaExpressionType();
				case SyntaxKind.NewKeyword:
					var type = checkNewTargetMetaProperty(node);
					return isErrorType(type) ? errorType : createNewTargetExpressionType(
						type,
					);
				default:
					Debug.assertNever(node.keywordToken);
			}
		}
		function checkNewTargetMetaProperty(node) {
			var container = getNewTargetContainer(node);
			if (!container) {
				error(
					node,
					Diagnostics.Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constructor,
					"new.target",
				);
				return errorType;
			} else if (container.kind === SyntaxKind.Constructor) {
				var symbol = getSymbolOfNode(container.parent);
				return getTypeOfSymbol(symbol);
			} else {
				var symbol = getSymbolOfNode(container);
				return getTypeOfSymbol(symbol);
			}
		}
		function checkImportMetaProperty(node) {
			if (
				moduleKind === ModuleKind.Node12 || moduleKind === ModuleKind.NodeNext
			) {
				if (getSourceFileOfNode(node).impliedNodeFormat !== ModuleKind.ESNext) {
					error(
						node,
						Diagnostics.The_import_meta_meta_property_is_not_allowed_in_files_which_will_build_into_CommonJS_output,
					);
				}
			} else if (
				moduleKind < ModuleKind.ES2020 && moduleKind !== ModuleKind.System
			) {
				error(
					node,
					Diagnostics.The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_es2022_esnext_system_node12_or_nodenext,
				);
			}
			var file = getSourceFileOfNode(node);
			Debug.assert(
				!!(file.flags & NodeFlags.PossiblyContainsImportMeta),
				"Containing file is missing import meta node flag.",
			);
			return node.name.escapedText === "meta" ? getGlobalImportMetaType() : errorType;
		}
		function getTypeOfParameter(symbol) {
			var type = getTypeOfSymbol(symbol);
			if (strictNullChecks) {
				var declaration = symbol.valueDeclaration;
				if (declaration && hasInitializer(declaration)) {
					return getOptionalType(type);
				}
			}
			return type;
		}
		function getTupleElementLabel(d) {
			Debug.assert(isIdentifier(d.name)); // Parameter declarations could be binding patterns, but we only allow identifier names
			return d.name.escapedText;
		}
		function getParameterNameAtPosition(signature, pos, overrideRestType) {
			var paramCount = signature.parameters.length - (signatureHasRestParameter(
				signature,
			) ? 1 : 0);
			if (pos < paramCount) {
				return signature.parameters[pos].escapedName;
			}
			var restParameter = signature.parameters[paramCount] || unknownSymbol;
			var restType = overrideRestType || getTypeOfSymbol(restParameter);
			if (isTupleType(restType)) {
				var associatedNames = restType.target.labeledElementDeclarations;
				var index = pos - paramCount;
				return associatedNames && getTupleElementLabel(associatedNames[index]) || restParameter.escapedName + "_" + index;
			}
			return restParameter.escapedName;
		}
		function getParameterIdentifierNameAtPosition(signature, pos) {
			var paramCount = signature.parameters.length - (signatureHasRestParameter(
				signature,
			) ? 1 : 0);
			if (pos < paramCount) {
				var param = signature.parameters[pos];
				return isParameterDeclarationWithIdentifierName(param) ? [
					param.escapedName,
					false,
				] : undefined;
			}
			var restParameter = signature.parameters[paramCount] || unknownSymbol;
			if (!isParameterDeclarationWithIdentifierName(restParameter)) {
				return undefined;
			}
			var restType = getTypeOfSymbol(restParameter);
			if (isTupleType(restType)) {
				var associatedNames = restType.target.labeledElementDeclarations;
				var index = pos - paramCount;
				var associatedName = associatedNames === null || associatedNames === void 0 ? void 0 : associatedNames[index];
				var isRestTupleElement = !!(associatedName === null || associatedName === void 0 ? void 0 : associatedName.dotDotDotToken);
				return associatedName ? [
					getTupleElementLabel(associatedName),
					isRestTupleElement,
				] : undefined;
			}
			if (pos === paramCount) {
				return [restParameter.escapedName, true];
			}
			return undefined;
		}
		function isParameterDeclarationWithIdentifierName(symbol) {
			return symbol.valueDeclaration && isParameter(symbol.valueDeclaration) && isIdentifier(
				symbol.valueDeclaration.name,
			);
		}
		function isValidDeclarationForTupleLabel(d) {
			return d.kind === SyntaxKind.NamedTupleMember || (isParameter(d) && d.name && isIdentifier(
				d.name,
			));
		}
		function getNameableDeclarationAtPosition(signature, pos) {
			var paramCount = signature.parameters.length - (signatureHasRestParameter(
				signature,
			) ? 1 : 0);
			if (pos < paramCount) {
				var decl = signature.parameters[pos].valueDeclaration;
				return decl && isValidDeclarationForTupleLabel(decl) ? decl : undefined;
			}
			var restParameter = signature.parameters[paramCount] || unknownSymbol;
			var restType = getTypeOfSymbol(restParameter);
			if (isTupleType(restType)) {
				var associatedNames = restType.target.labeledElementDeclarations;
				var index = pos - paramCount;
				return associatedNames && associatedNames[index];
			}
			return restParameter.valueDeclaration && isValidDeclarationForTupleLabel(
				restParameter.valueDeclaration,
			) ? restParameter.valueDeclaration : undefined;
		}
		function getTypeAtPosition(signature, pos) {
			return tryGetTypeAtPosition(signature, pos) || anyType;
		}
		function tryGetTypeAtPosition(signature, pos) {
			var paramCount = signature.parameters.length - (signatureHasRestParameter(
				signature,
			) ? 1 : 0);
			if (pos < paramCount) {
				return getTypeOfParameter(signature.parameters[pos]);
			}
			if (signatureHasRestParameter(signature)) {
				// We want to return the value undefined for an out of bounds parameter position,
				// so we need to check bounds here before calling getIndexedAccessType (which
				// otherwise would return the type 'undefined').
				var restType = getTypeOfSymbol(signature.parameters[paramCount]);
				var index = pos - paramCount;
				if (
					!isTupleType(restType) || restType.target.hasRestElement || index < restType.target.fixedLength
				) {
					return getIndexedAccessType(restType, getNumberLiteralType(index));
				}
			}
			return undefined;
		}
		function getRestTypeAtPosition(source, pos) {
			var parameterCount = getParameterCount(source);
			var minArgumentCount = getMinArgumentCount(source);
			var restType = getEffectiveRestType(source);
			if (restType && pos >= parameterCount - 1) {
				return pos === parameterCount - 1 ? restType : createArrayType(
					getIndexedAccessType(restType, numberType),
				);
			}
			var types = [];
			var flags = [];
			var names = [];
			for (var i = pos; i < parameterCount; i++) {
				if (!restType || i < parameterCount - 1) {
					types.push(getTypeAtPosition(source, i));
					flags.push(
						i < minArgumentCount ? ElementFlags.Required : ElementFlags.Optional,
					);
				} else {
					types.push(restType);
					flags.push(ElementFlags.Variadic);
				}
				var name_23 = getNameableDeclarationAtPosition(source, i);
				if (name_23) {
					names.push(name_23);
				}
			}
			return createTupleType(
				types,
				flags, /*readonly*/
				false,
				length(names) === length(types) ? names : undefined,
			);
		}
		// Return the number of parameters in a signature. The rest parameter, if present, counts as one
		// parameter. For example, the parameter count of (x: number, y: number, ...z: string[]) is 3 and
		// the parameter count of (x: number, ...args: [number, ...string[], boolean])) is also 3. In the
		// latter example, the effective rest type is [...string[], boolean].
		function getParameterCount(signature) {
			var length = signature.parameters.length;
			if (signatureHasRestParameter(signature)) {
				var restType = getTypeOfSymbol(signature.parameters[length - 1]);
				if (isTupleType(restType)) {
					return length + restType.target.fixedLength - (restType.target.hasRestElement ? 0 : 1);
				}
			}
			return length;
		}
		function getMinArgumentCount(signature, flags) {
			var strongArityForUntypedJS = flags & 1 /* StrongArityForUntypedJS */ ;
			var voidIsNonOptional = flags & 2 /* VoidIsNonOptional */ ;
			if (voidIsNonOptional || signature.resolvedMinArgumentCount === undefined) {
				var minArgumentCount = void 0;
				if (signatureHasRestParameter(signature)) {
					var restType = getTypeOfSymbol(
						signature.parameters[signature.parameters.length - 1],
					);
					if (isTupleType(restType)) {
						var firstOptionalIndex = findIndex(
							restType.target.elementFlags,
							function (f) {
								return !(f & ElementFlags.Required);
							},
						);
						var requiredCount = firstOptionalIndex < 0 ? restType.target.fixedLength : firstOptionalIndex;
						if (requiredCount > 0) {
							minArgumentCount = signature.parameters.length - 1 + requiredCount;
						}
					}
				}
				if (minArgumentCount === undefined) {
					if (
						!strongArityForUntypedJS && signature.flags & SignatureFlags.IsUntypedSignatureInJSFile
					) {
						return 0;
					}
					minArgumentCount = signature.minArgumentCount;
				}
				if (voidIsNonOptional) {
					return minArgumentCount;
				}
				for (var i = minArgumentCount - 1; i >= 0; i--) {
					var type = getTypeAtPosition(signature, i);
					if (filterType(type, acceptsVoid).flags & TypeFlags.Never) {
						break;
					}
					minArgumentCount = i;
				}
				signature.resolvedMinArgumentCount = minArgumentCount;
			}
			return signature.resolvedMinArgumentCount;
		}
		function hasEffectiveRestParameter(signature) {
			if (signatureHasRestParameter(signature)) {
				var restType = getTypeOfSymbol(
					signature.parameters[signature.parameters.length - 1],
				);
				return !isTupleType(restType) || restType.target.hasRestElement;
			}
			return false;
		}
		function getEffectiveRestType(signature) {
			if (signatureHasRestParameter(signature)) {
				var restType = getTypeOfSymbol(
					signature.parameters[signature.parameters.length - 1],
				);
				if (!isTupleType(restType)) {
					return restType;
				}
				if (restType.target.hasRestElement) {
					return sliceTupleType(restType, restType.target.fixedLength);
				}
			}
			return undefined;
		}
		function getNonArrayRestType(signature) {
			var restType = getEffectiveRestType(signature);
			return restType && !isArrayType(restType) && !isTypeAny(restType) && (getReducedType(
				restType,
			).flags & TypeFlags.Never) === 0 ? restType : undefined;
		}
		function getTypeOfFirstParameterOfSignature(signature) {
			return getTypeOfFirstParameterOfSignatureWithFallback(
				signature,
				neverType,
			);
		}
		function getTypeOfFirstParameterOfSignatureWithFallback(
			signature,
			fallbackType,
		) {
			return signature.parameters.length > 0 ? getTypeAtPosition(signature, 0) : fallbackType;
		}
		function inferFromAnnotatedParameters(signature, context, inferenceContext) {
			var len = signature.parameters.length - (signatureHasRestParameter(
				signature,
			) ? 1 : 0);
			for (var i = 0; i < len; i++) {
				var declaration = signature.parameters[i].valueDeclaration;
				if (declaration.type) {
					var typeNode = getEffectiveTypeAnnotationNode(declaration);
					if (typeNode) {
						inferTypes(
							inferenceContext.inferences,
							getTypeFromTypeNode(typeNode),
							getTypeAtPosition(context, i),
						);
					}
				}
			}
			var restType = getEffectiveRestType(context);
			if (restType && restType.flags & TypeFlags.TypeParameter) {
				// The contextual signature has a generic rest parameter. We first instantiate the contextual
				// signature (without fixing type parameters) and assign types to contextually typed parameters.
				var instantiatedContext = instantiateSignature(
					context,
					inferenceContext.nonFixingMapper,
				);
				assignContextualParameterTypes(signature, instantiatedContext);
				// We then infer from a tuple type representing the parameters that correspond to the contextual
				// rest parameter.
				var restPos = getParameterCount(context) - 1;
				inferTypes(
					inferenceContext.inferences,
					getRestTypeAtPosition(signature, restPos),
					restType,
				);
			}
		}
		function assignContextualParameterTypes(signature, context) {
			if (context.typeParameters) {
				if (!signature.typeParameters) {
					signature.typeParameters = context.typeParameters;
				} else {
					return; // This signature has already has a contextual inference performed and cached on it!
				}
			}
			if (context.thisParameter) {
				var parameter = signature.thisParameter;
				if (
					!parameter || parameter.valueDeclaration && !parameter.valueDeclaration.type
				) {
					if (!parameter) {
						signature.thisParameter = createSymbolWithType(
							context.thisParameter, /*type*/
							undefined,
						);
					}
					assignParameterType(
						signature.thisParameter,
						getTypeOfSymbol(context.thisParameter),
					);
				}
			}
			var len = signature.parameters.length - (signatureHasRestParameter(
				signature,
			) ? 1 : 0);
			for (var i = 0; i < len; i++) {
				var parameter = signature.parameters[i];
				if (!getEffectiveTypeAnnotationNode(parameter.valueDeclaration)) {
					var contextualParameterType = tryGetTypeAtPosition(context, i);
					assignParameterType(parameter, contextualParameterType);
				}
			}
			if (signatureHasRestParameter(signature)) {
				// parameter might be a transient symbol generated by use of `arguments` in the function body.
				var parameter = last(signature.parameters);
				if (
					isTransientSymbol(parameter) || !getEffectiveTypeAnnotationNode(
						parameter.valueDeclaration,
					)
				) {
					var contextualParameterType = getRestTypeAtPosition(context, len);
					assignParameterType(parameter, contextualParameterType);
				}
			}
		}
		function assignNonContextualParameterTypes(signature) {
			if (signature.thisParameter) {
				assignParameterType(signature.thisParameter);
			}
			for (var _i = 0, _a = signature.parameters; _i < _a.length; _i++) {
				var parameter = _a[_i];
				assignParameterType(parameter);
			}
		}
		function assignParameterType(parameter, type) {
			var links = getSymbolLinks(parameter);
			if (!links.type) {
				var declaration = parameter.valueDeclaration;
				links.type = type || getWidenedTypeForVariableLikeDeclaration(
					declaration, /*includeOptionality*/
					true,
				);
				if (declaration.name.kind !== SyntaxKind.Identifier) {
					// if inference didn't come up with anything but unknown, fall back to the binding pattern if present.
					if (links.type === unknownType) {
						links.type = getTypeFromBindingPattern(declaration.name);
					}
					assignBindingElementTypes(declaration.name);
				}
			}
		}
		// When contextual typing assigns a type to a parameter that contains a binding pattern, we also need to push
		// the destructured type into the contained binding elements.
		function assignBindingElementTypes(pattern) {
			for (var _i = 0, _a = pattern.elements; _i < _a.length; _i++) {
				var element = _a[_i];
				if (!isOmittedExpression(element)) {
					if (element.name.kind === SyntaxKind.Identifier) {
						getSymbolLinks(getSymbolOfNode(element)).type = getTypeForBindingElement(
							element,
						);
					} else {
						assignBindingElementTypes(element.name);
					}
				}
			}
		}
		function createPromiseType(promisedType) {
			// creates a `Promise<T>` type where `T` is the promisedType argument
			var globalPromiseType = getGlobalPromiseType( /*reportErrors*/ true);
			if (globalPromiseType !== emptyGenericType) {
				// if the promised type is itself a promise, get the underlying type; otherwise, fallback to the promised type
				// Unwrap an `Awaited<T>` to `T` to improve inference.
				promisedType = getAwaitedTypeNoAlias(unwrapAwaitedType(promisedType)) || unknownType;
				return createTypeReference(globalPromiseType, [promisedType]);
			}
			return unknownType;
		}
		function createPromiseLikeType(promisedType) {
			// creates a `PromiseLike<T>` type where `T` is the promisedType argument
			var globalPromiseLikeType = getGlobalPromiseLikeType(
				true, /*reportErrors*/
			);
			if (globalPromiseLikeType !== emptyGenericType) {
				// if the promised type is itself a promise, get the underlying type; otherwise, fallback to the promised type
				// Unwrap an `Awaited<T>` to `T` to improve inference.
				promisedType = getAwaitedTypeNoAlias(unwrapAwaitedType(promisedType)) || unknownType;
				return createTypeReference(globalPromiseLikeType, [promisedType]);
			}
			return unknownType;
		}
		function createPromiseReturnType(func, promisedType) {
			var promiseType = createPromiseType(promisedType);
			if (promiseType === unknownType) {
				error(
					func,
					isImportCall(func) ? Diagnostics.A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option : Diagnostics.An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option,
				);
				return errorType;
			} else if (!getGlobalPromiseConstructorSymbol( /*reportErrors*/ true)) {
				error(
					func,
					isImportCall(func) ? Diagnostics.A_dynamic_import_call_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option : Diagnostics.An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option,
				);
			}
			return promiseType;
		}
		function createNewTargetExpressionType(targetType) {
			// Create a synthetic type `NewTargetExpression { target: TargetType; }`
			var symbol = createSymbol(SymbolFlags.None, "NewTargetExpression");
			var targetPropertySymbol = createSymbol(
				SymbolFlags.Property,
				"target",
				CheckFlags.Readonly,
			);
			targetPropertySymbol.parent = symbol;
			targetPropertySymbol.type = targetType;
			var members = createSymbolTable([targetPropertySymbol]);
			symbol.members = members;
			return createAnonymousType(
				symbol,
				members,
				emptyArray,
				emptyArray,
				emptyArray,
			);
		}
		function getReturnTypeFromBody(func, checkMode) {
			if (!func.body) {
				return errorType;
			}
			var functionFlags = getFunctionFlags(func);
			var isAsync = (functionFlags & FunctionFlags.Async) !== 0;
			var isGenerator = (functionFlags & FunctionFlags.Generator) !== 0;
			var returnType;
			var yieldType;
			var nextType;
			var fallbackReturnType = voidType;
			if (func.body.kind !== SyntaxKind.Block) {
				returnType = checkExpressionCached(
					func.body, // Async or normal arrow function
					checkMode && checkMode & ~8, /* SkipGenericFunctions */
				);
				if (isAsync) {
					// From within an async function you can return either a non-promise value or a promise. Any
					// Promise/A+ compatible implementation will always assimilate any foreign promise, so the
					// return type of the body should be unwrapped to its awaited type, which we will wrap in
					// the native Promise<T> type later in this function.
					returnType = unwrapAwaitedType(
						checkAwaitedType(
							returnType, /*withAlias*/
							false, /*errorNode*/
							func,
							Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member,
						),
					);
				}
			} else if (isGenerator) {
				var returnTypes = checkAndAggregateReturnExpressionTypes(
					func, // Generator or AsyncGenerator function
					checkMode,
				);
				if (!returnTypes) {
					fallbackReturnType = neverType;
				} else if (returnTypes.length > 0) {
					returnType = getUnionType(returnTypes, UnionReduction.Subtype);
				}
				var _a = checkAndAggregateYieldOperandTypes(func, checkMode),
					yieldTypes = _a.yieldTypes,
					nextTypes = _a.nextTypes;
				yieldType = some(yieldTypes) ? getUnionType(
					yieldTypes,
					UnionReduction.Subtype,
				) : undefined;
				nextType = some(nextTypes) ? getIntersectionType(nextTypes) : undefined;
			} else {
				var types = checkAndAggregateReturnExpressionTypes(func, checkMode); // Async or normal function
				if (!types) {
					// For an async function, the return type will not be never, but rather a Promise for never.
					return functionFlags & FunctionFlags.Async ? createPromiseReturnType(
						func,
						neverType,
					) : neverType; // Async function // Normal function
				}
				if (types.length === 0) {
					// For an async function, the return type will not be void, but rather a Promise for void.
					return functionFlags & FunctionFlags.Async ? createPromiseReturnType(
						func,
						voidType,
					) : voidType; // Async function // Normal function
				}
				// Return a union of the return expression types.
				returnType = getUnionType(types, UnionReduction.Subtype);
			}
			if (returnType || yieldType || nextType) {
				if (yieldType) reportErrorsFromWidening(
					func,
					yieldType,
					3, /* GeneratorYield */
				);
				if (returnType) reportErrorsFromWidening(
					func,
					returnType,
					1, /* FunctionReturn */
				);
				if (nextType) reportErrorsFromWidening(
					func,
					nextType,
					2, /* GeneratorNext */
				);
				if (
					returnType && isUnitType(returnType) || yieldType && isUnitType(
						yieldType,
					) || nextType && isUnitType(nextType)
				) {
					var contextualSignature = getContextualSignatureForFunctionLikeDeclaration(
						func,
					);
					var contextualType = !contextualSignature ? undefined : contextualSignature === getSignatureFromDeclaration(
						func,
					) ? isGenerator ? undefined : returnType : instantiateContextualType(
						getReturnTypeOfSignature(contextualSignature),
						func,
					);
					if (isGenerator) {
						yieldType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(
							yieldType,
							contextualType,
							0, /* Yield */
							isAsync,
						);
						returnType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(
							returnType,
							contextualType,
							1, /* Return */
							isAsync,
						);
						nextType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(
							nextType,
							contextualType,
							2, /* Next */
							isAsync,
						);
					} else {
						returnType = getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded(
							returnType,
							contextualType,
							isAsync,
						);
					}
				}
				if (yieldType) yieldType = getWidenedType(yieldType);
				if (returnType) returnType = getWidenedType(returnType);
				if (nextType) nextType = getWidenedType(nextType);
			}
			if (isGenerator) {
				return createGeneratorReturnType(
					yieldType || neverType,
					returnType || fallbackReturnType,
					nextType || getContextualIterationType(2 /* Next */ , func) || unknownType,
					isAsync,
				);
			} else {
				// From within an async function you can return either a non-promise value or a promise. Any
				// Promise/A+ compatible implementation will always assimilate any foreign promise, so the
				// return type of the body is awaited type of the body, wrapped in a native Promise<T> type.
				return isAsync ? createPromiseType(returnType || fallbackReturnType) : returnType || fallbackReturnType;
			}
		}
		function createGeneratorReturnType(
			yieldType,
			returnType,
			nextType,
			isAsyncGenerator,
		) {
			var resolver = isAsyncGenerator ? asyncIterationTypesResolver : syncIterationTypesResolver;
			var globalGeneratorType = resolver.getGlobalGeneratorType(
				false, /*reportErrors*/
			);
			yieldType = resolver.resolveIterationType(
				yieldType, /*errorNode*/
				undefined,
			) || unknownType;
			returnType = resolver.resolveIterationType(
				returnType, /*errorNode*/
				undefined,
			) || unknownType;
			nextType = resolver.resolveIterationType(
				nextType, /*errorNode*/
				undefined,
			) || unknownType;
			if (globalGeneratorType === emptyGenericType) {
				// Fall back to the global IterableIterator if returnType is assignable to the expected return iteration
				// type of IterableIterator, and the expected next iteration type of IterableIterator is assignable to
				// nextType.
				var globalType = resolver.getGlobalIterableIteratorType(
					false, /*reportErrors*/
				);
				var iterationTypes = globalType !== emptyGenericType ? getIterationTypesOfGlobalIterableType(
					globalType,
					resolver,
				) : undefined;
				var iterableIteratorReturnType = iterationTypes ? iterationTypes.returnType : anyType;
				var iterableIteratorNextType = iterationTypes ? iterationTypes.nextType : undefinedType;
				if (
					isTypeAssignableTo(returnType, iterableIteratorReturnType) && isTypeAssignableTo(
						iterableIteratorNextType,
						nextType,
					)
				) {
					if (globalType !== emptyGenericType) {
						return createTypeFromGenericGlobalType(globalType, [yieldType]);
					}
					// The global IterableIterator type doesn't exist, so report an error
					resolver.getGlobalIterableIteratorType( /*reportErrors*/ true);
					return emptyObjectType;
				}
				// The global Generator type doesn't exist, so report an error
				resolver.getGlobalGeneratorType( /*reportErrors*/ true);
				return emptyObjectType;
			}
			return createTypeFromGenericGlobalType(
				globalGeneratorType,
				[yieldType, returnType, nextType],
			);
		}
		function checkAndAggregateYieldOperandTypes(func, checkMode) {
			var yieldTypes = [];
			var nextTypes = [];
			var isAsync = (getFunctionFlags(func) & FunctionFlags.Async) !== 0;
			forEachYieldExpression(
				func.body,
				function (yieldExpression) {
					var yieldExpressionType = yieldExpression.expression ? checkExpression(
						yieldExpression.expression,
						checkMode,
					) : undefinedWideningType;
					pushIfUnique(
						yieldTypes,
						getYieldedTypeOfYieldExpression(
							yieldExpression,
							yieldExpressionType,
							anyType,
							isAsync,
						),
					);
					var nextType;
					if (yieldExpression.asteriskToken) {
						var iterationTypes = getIterationTypesOfIterable(
							yieldExpressionType,
							isAsync ? 19 : 17, /* AsyncYieldStar */ /* YieldStar */
							yieldExpression.expression,
						);
						nextType = iterationTypes && iterationTypes.nextType;
					} else {
						nextType = getContextualType(yieldExpression);
					}
					if (nextType) pushIfUnique(nextTypes, nextType);
				},
			);
			return { yieldTypes: yieldTypes, nextTypes: nextTypes };
		}
		function getYieldedTypeOfYieldExpression(
			node,
			expressionType,
			sentType,
			isAsync,
		) {
			var errorNode = node.expression || node;
			// A `yield*` expression effectively yields everything that its operand yields
			var yieldedType = node.asteriskToken ? checkIteratedTypeOrElementType(
				isAsync ? 19 : 17, /* AsyncYieldStar */ /* YieldStar */
				expressionType,
				sentType,
				errorNode,
			) : expressionType;
			return !isAsync ? yieldedType : getAwaitedType(
				yieldedType,
				errorNode,
				node.asteriskToken ? Diagnostics.Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member : Diagnostics.Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member,
			);
		}
		/**
         * Collect the TypeFacts learned from a typeof switch with
         * total clauses `witnesses`, and the active clause ranging
         * from `start` to `end`. Parameter `hasDefault` denotes
         * whether the active clause contains a default clause.
         */
		function getFactsFromTypeofSwitch(start, end, witnesses, hasDefault) {
			var facts = 0 /* None */ ;
			// When in the default we only collect inequality facts
			// because default is 'in theory' a set of infinite
			// equalities.
			if (hasDefault) {
				// Value is not equal to any types after the active clause.
				for (var i = end; i < witnesses.length; i++) {
					facts |= typeofNEFacts.get(witnesses[i]) || 32768; /* TypeofNEHostObject */
				}
				// Remove inequalities for types that appear in the
				// active clause because they appear before other
				// types collected so far.
				for (var i = start; i < end; i++) {
					facts &= ~(typeofNEFacts.get(witnesses[i]) || 0);
				}
				// Add inequalities for types before the active clause unconditionally.
				for (var i = 0; i < start; i++) {
					facts |= typeofNEFacts.get(witnesses[i]) || 32768; /* TypeofNEHostObject */
				}
			} else { // equalities is finite. // When in an active clause without default the set of
				// Add equalities for all types in the active clause.
				for (var i = start; i < end; i++) {
					facts |= typeofEQFacts.get(witnesses[i]) || 128; /* TypeofEQHostObject */
				}
				// Remove equalities for types that appear before the
				// active clause.
				for (var i = 0; i < start; i++) {
					facts &= ~(typeofEQFacts.get(witnesses[i]) || 0);
				}
			}
			return facts;
		}
		function isExhaustiveSwitchStatement(node) {
			var links = getNodeLinks(node);
			return links.isExhaustive !== undefined ? links.isExhaustive : (links.isExhaustive = computeExhaustiveSwitchStatement(
				node,
			));
		}
		function computeExhaustiveSwitchStatement(node) {
			if (node.expression.kind === SyntaxKind.TypeOfExpression) {
				var operandType = getTypeOfExpression(node.expression.expression);
				var witnesses = getSwitchClauseTypeOfWitnesses(
					node, /*retainDefault*/
					false,
				);
				// notEqualFacts states that the type of the switched value is not equal to every type in the switch.
				var notEqualFacts_1 = getFactsFromTypeofSwitch(
					0,
					0,
					witnesses, /*hasDefault*/
					true,
				);
				var type_5 = getBaseConstraintOfType(operandType) || operandType;
				// Take any/unknown as a special condition. Or maybe we could change `type` to a union containing all primitive types.
				if (type_5.flags & TypeFlags.AnyOrUnknown) {
					return (556800 & notEqualFacts_1) === 556800; /* AllTypeofNE */ /* AllTypeofNE */
				}
				return !!(filterType(
					type_5,
					function (t) {
						return (getTypeFacts(t) & notEqualFacts_1) === notEqualFacts_1;
					},
				).flags & TypeFlags.Never);
			}
			var type = getTypeOfExpression(node.expression);
			if (!isLiteralType(type)) {
				return false;
			}
			var switchTypes = getSwitchClauseTypes(node);
			if (!switchTypes.length || some(switchTypes, isNeitherUnitTypeNorNever)) {
				return false;
			}
			return eachTypeContainedIn(
				mapType(type, getRegularTypeOfLiteralType),
				switchTypes,
			);
		}
		function functionHasImplicitReturn(func) {
			return func.endFlowNode && isReachableFlowNode(func.endFlowNode);
		}
		/** NOTE: Return value of `[]` means a different thing than `undefined`. `[]` means func returns `void`, `undefined` means it returns `never`. */
		function checkAndAggregateReturnExpressionTypes(func, checkMode) {
			var functionFlags = getFunctionFlags(func);
			var aggregatedTypes = [];
			var hasReturnWithNoExpression = functionHasImplicitReturn(func);
			var hasReturnOfTypeNever = false;
			forEachReturnStatement(
				func.body,
				function (returnStatement) {
					var expr = returnStatement.expression;
					if (expr) {
						var type = checkExpressionCached(
							expr,
							checkMode && checkMode & ~8, /* SkipGenericFunctions */
						);
						if (functionFlags & FunctionFlags.Async) {
							// From within an async function you can return either a non-promise value or a promise. Any
							// Promise/A+ compatible implementation will always assimilate any foreign promise, so the
							// return type of the body should be unwrapped to its awaited type, which should be wrapped in
							// the native Promise<T> type by the caller.
							type = unwrapAwaitedType(
								checkAwaitedType(
									type, /*withAlias*/
									false,
									func,
									Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member,
								),
							);
						}
						if (type.flags & TypeFlags.Never) {
							hasReturnOfTypeNever = true;
						}
						pushIfUnique(aggregatedTypes, type);
					} else {
						hasReturnWithNoExpression = true;
					}
				},
			);
			if (
				aggregatedTypes.length === 0 && !hasReturnWithNoExpression && (hasReturnOfTypeNever || mayReturnNever(
					func,
				))
			) {
				return undefined;
			}
			if (
				strictNullChecks && aggregatedTypes.length && hasReturnWithNoExpression && !(isJSConstructor(
					func,
				) && aggregatedTypes.some(
					function (t) {
						return t.symbol === func.symbol;
					},
				))
			) {
				// Javascript "callable constructors", containing eg `if (!(this instanceof A)) return new A()` should not add undefined
				pushIfUnique(aggregatedTypes, undefinedType);
			}
			return aggregatedTypes;
		}
		function mayReturnNever(func) {
			switch (func.kind) {
				case SyntaxKind.FunctionExpression:
				case SyntaxKind.ArrowFunction:
					return true;
				case SyntaxKind.MethodDeclaration:
					return func.parent.kind === SyntaxKind.ObjectLiteralExpression;
				default:
					return false;
			}
		}
		/**
         * TypeScript Specification 1.0 (6.3) - July 2014
         *   An explicitly typed function whose return type isn't the Void type,
         *   the Any type, or a union type containing the Void or Any type as a constituent
         *   must have at least one return statement somewhere in its body.
         *   An exception to this rule is if the function implementation consists of a single 'throw' statement.
         *
         * @param returnType - return type of the function, can be undefined if return type is not explicitly specified
         */
		function checkAllCodePathsInNonVoidFunctionReturnOrThrow(func, returnType) {
			if (!produceDiagnostics) {
				return;
			}
			var functionFlags = getFunctionFlags(func);
			var type = returnType && unwrapReturnType(returnType, functionFlags);
			// Functions with with an explicitly specified 'void' or 'any' return type don't need any return expressions.
			if (type && maybeTypeOfKind(type, TypeFlags.Any | TypeFlags.Void)) {
				return;
			}
			// If all we have is a function signature, or an arrow function with an expression body, then there is nothing to check.
			// also if HasImplicitReturn flag is not set this means that all codepaths in function body end with return or throw
			if (
				func.kind === SyntaxKind.MethodSignature || nodeIsMissing(func.body) || func.body.kind !== SyntaxKind.Block || !functionHasImplicitReturn(
					func,
				)
			) {
				return;
			}
			var hasExplicitReturn = func.flags & NodeFlags.HasExplicitReturn;
			var errorNode = getEffectiveReturnTypeNode(func) || func;
			if (type && type.flags & TypeFlags.Never) {
				error(
					errorNode,
					Diagnostics.A_function_returning_never_cannot_have_a_reachable_end_point,
				);
			} else if (type && !hasExplicitReturn) {
				// minimal check: function has syntactic return type annotation and no explicit return statements in the body
				// this function does not conform to the specification.
				error(
					errorNode,
					Diagnostics.A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value,
				);
			} else if (
				type && strictNullChecks && !isTypeAssignableTo(undefinedType, type)
			) {
				error(
					errorNode,
					Diagnostics.Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined,
				);
			} else if (compilerOptions.noImplicitReturns) {
				if (!type) {
					// If return type annotation is omitted check if function has any explicit return statements.
					// If it does not have any - its inferred return type is void - don't do any checks.
					// Otherwise get inferred return type from function body and report error only if it is not void / anytype
					if (!hasExplicitReturn) {
						return;
					}
					var inferredReturnType = getReturnTypeOfSignature(
						getSignatureFromDeclaration(func),
					);
					if (isUnwrappedReturnTypeVoidOrAny(func, inferredReturnType)) {
						return;
					}
				}
				error(errorNode, Diagnostics.Not_all_code_paths_return_a_value);
			}
		}
		function checkFunctionExpressionOrObjectLiteralMethod(node, checkMode) {
			Debug.assert(
				node.kind !== SyntaxKind.MethodDeclaration || isObjectLiteralMethod(
					node,
				),
			);
			checkNodeDeferred(node);
			if (isFunctionExpression(node)) {
				checkCollisionsForDeclarationName(node, node.name);
			}
			// The identityMapper object is used to indicate that function expressions are wildcards
			if (
				checkMode && checkMode & 4 && isContextSensitive(
					node,
				) /* SkipContextSensitive */
			) {
				// Skip parameters, return signature with return type that retains noncontextual parts so inferences can still be drawn in an early stage
				if (
					!getEffectiveReturnTypeNode(node) && !hasContextSensitiveParameters(
						node,
					)
				) {
					// Return plain anyFunctionType if there is no possibility we'll make inferences from the return type
					var contextualSignature = getContextualSignature(node);
					if (
						contextualSignature && couldContainTypeVariables(
							getReturnTypeOfSignature(contextualSignature),
						)
					) {
						var links = getNodeLinks(node);
						if (links.contextFreeType) {
							return links.contextFreeType;
						}
						var returnType = getReturnTypeFromBody(node, checkMode);
						var returnOnlySignature = createSignature(
							undefined,
							undefined,
							undefined,
							emptyArray,
							returnType, /*resolvedTypePredicate*/
							undefined,
							0,
							SignatureFlags.None,
						);
						var returnOnlyType = createAnonymousType(
							node.symbol,
							emptySymbols,
							[returnOnlySignature],
							emptyArray,
							emptyArray,
						);
						returnOnlyType.objectFlags |= ObjectFlags.NonInferrableType;
						return links.contextFreeType = returnOnlyType;
					}
				}
				return anyFunctionType;
			}
			// Grammar checking
			var hasGrammarError = checkGrammarFunctionLikeDeclaration(node);
			if (!hasGrammarError && node.kind === SyntaxKind.FunctionExpression) {
				checkGrammarForGenerator(node);
			}
			contextuallyCheckFunctionExpressionOrObjectLiteralMethod(node, checkMode);
			return getTypeOfSymbol(getSymbolOfNode(node));
		}
		function contextuallyCheckFunctionExpressionOrObjectLiteralMethod(
			node,
			checkMode,
		) {
			var links = getNodeLinks(node);
			// Check if function expression is contextually typed and assign parameter types if so.
			if (!(links.flags & NodeCheckFlags.ContextChecked)) {
				var contextualSignature = getContextualSignature(node);
				// If a type check is started at a function expression that is an argument of a function call, obtaining the
				// contextual type may recursively get back to here during overload resolution of the call. If so, we will have
				// already assigned contextual types.
				if (!(links.flags & NodeCheckFlags.ContextChecked)) {
					links.flags |= NodeCheckFlags.ContextChecked;
					var signature = firstOrUndefined(
						getSignaturesOfType(
							getTypeOfSymbol(getSymbolOfNode(node)),
							SignatureKind.Call,
						),
					);
					if (!signature) {
						return;
					}
					if (isContextSensitive(node)) {
						if (contextualSignature) {
							var inferenceContext = getInferenceContext(node);
							if (checkMode && checkMode & 2 /* Inferential */ ) {
								inferFromAnnotatedParameters(
									signature,
									contextualSignature,
									inferenceContext,
								);
							}
							var instantiatedContextualSignature = inferenceContext ? instantiateSignature(
								contextualSignature,
								inferenceContext.mapper,
							) : contextualSignature;
							assignContextualParameterTypes(
								signature,
								instantiatedContextualSignature,
							);
						} else {
							// Force resolution of all parameter types such that the absence of a contextual type is consistently reflected.
							assignNonContextualParameterTypes(signature);
						}
					}
					if (
						contextualSignature && !getReturnTypeFromAnnotation(node) && !signature.resolvedReturnType
					) {
						var returnType = getReturnTypeFromBody(node, checkMode);
						if (!signature.resolvedReturnType) {
							signature.resolvedReturnType = returnType;
						}
					}
					checkSignatureDeclaration(node);
				}
			}
		}
		function checkFunctionExpressionOrObjectLiteralMethodDeferred(node) {
			Debug.assert(
				node.kind !== SyntaxKind.MethodDeclaration || isObjectLiteralMethod(
					node,
				),
			);
			var functionFlags = getFunctionFlags(node);
			var returnType = getReturnTypeFromAnnotation(node);
			checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType);
			if (node.body) {
				if (!getEffectiveReturnTypeNode(node)) {
					// There are some checks that are only performed in getReturnTypeFromBody, that may produce errors
					// we need. An example is the noImplicitAny errors resulting from widening the return expression
					// of a function. Because checking of function expression bodies is deferred, there was never an
					// appropriate time to do this during the main walk of the file (see the comment at the top of
					// checkFunctionExpressionBodies). So it must be done now.
					getReturnTypeOfSignature(getSignatureFromDeclaration(node));
				}
				if (node.body.kind === SyntaxKind.Block) {
					checkSourceElement(node.body);
				} else {
					// From within an async function you can return either a non-promise value or a promise. Any
					// Promise/A+ compatible implementation will always assimilate any foreign promise, so we
					// should not be checking assignability of a promise to the return type. Instead, we need to
					// check assignability of the awaited type of the expression body against the promised type of
					// its return type annotation.
					var exprType = checkExpression(node.body);
					var returnOrPromisedType = returnType && unwrapReturnType(
						returnType,
						functionFlags,
					);
					if (returnOrPromisedType) {
						if (
							(functionFlags & FunctionFlags.AsyncGenerator) === FunctionFlags.Async
						) {
							var awaitedType = checkAwaitedType(
								exprType, // Async function /*withAlias*/
								false,
								node.body,
								Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member,
							);
							checkTypeAssignableToAndOptionallyElaborate(
								awaitedType,
								returnOrPromisedType,
								node.body,
								node.body,
							);
						} else {
							checkTypeAssignableToAndOptionallyElaborate(
								exprType, // Normal function
								returnOrPromisedType,
								node.body,
								node.body,
							);
						}
					}
				}
			}
		}
		function checkArithmeticOperandType(operand, type, diagnostic, isAwaitValid) {
			if (isAwaitValid === void 0) {
				isAwaitValid = false;
			}
			if (!isTypeAssignableTo(type, numberOrBigIntType)) {
				var awaitedType = isAwaitValid && getAwaitedTypeOfPromise(type);
				errorAndMaybeSuggestAwait(
					operand,
					!!awaitedType && isTypeAssignableTo(awaitedType, numberOrBigIntType),
					diagnostic,
				);
				return false;
			}
			return true;
		}
		function isReadonlyAssignmentDeclaration(d) {
			if (!isCallExpression(d)) {
				return false;
			}
			if (!isBindableObjectDefinePropertyCall(d)) {
				return false;
			}
			var objectLitType = checkExpressionCached(d.arguments[2]);
			var valueType = getTypeOfPropertyOfType(objectLitType, "value");
			if (valueType) {
				var writableProp = getPropertyOfType(objectLitType, "writable");
				var writableType = writableProp && getTypeOfSymbol(writableProp);
				if (
					!writableType || writableType === falseType || writableType === regularFalseType
				) {
					return true;
				}
				// We include this definition whereupon we walk back and check the type at the declaration because
				// The usual definition of `Object.defineProperty` will _not_ cause literal types to be preserved in the
				// argument types, should the type be contextualized by the call itself.
				if (
					writableProp && writableProp.valueDeclaration && isPropertyAssignment(
						writableProp.valueDeclaration,
					)
				) {
					var initializer = writableProp.valueDeclaration.initializer;
					var rawOriginalType = checkExpression(initializer);
					if (
						rawOriginalType === falseType || rawOriginalType === regularFalseType
					) {
						return true;
					}
				}
				return false;
			}
			var setProp = getPropertyOfType(objectLitType, "set");
			return !setProp;
		}
		function isReadonlySymbol(symbol) {
			// The following symbols are considered read-only:
			// Properties with a 'readonly' modifier
			// Variables declared with 'const'
			// Get accessors without matching set accessors
			// Enum members
			// Object.defineProperty assignments with writable false or no setter
			// Unions and intersections of the above (unions and intersections eagerly set isReadonly on creation)
			return !!(getCheckFlags(symbol) & CheckFlags.Readonly || symbol.flags & SymbolFlags.Property && getDeclarationModifierFlagsFromSymbol(
				symbol,
			) & ModifierFlags.Readonly || symbol.flags & SymbolFlags.Variable && getDeclarationNodeFlagsFromSymbol(
				symbol,
			) & NodeFlags.Const || symbol.flags & SymbolFlags.Accessor && !(symbol.flags & SymbolFlags.SetAccessor) || symbol.flags & SymbolFlags.EnumMember || some(
				symbol.declarations,
				isReadonlyAssignmentDeclaration,
			));
		}
		function isAssignmentToReadonlyEntity(expr, symbol, assignmentKind) {
			var _a, _b;
			if (assignmentKind === AssignmentKind.None) {
				// no assigment means it doesn't matter whether the entity is readonly
				return false;
			}
			if (isReadonlySymbol(symbol)) {
				// Allow assignments to readonly properties within constructors of the same class declaration.
				if (
					symbol.flags & SymbolFlags.Property && isAccessExpression(expr) && expr.expression.kind === SyntaxKind.ThisKeyword
				) {
					// Look for if this is the constructor for the class that `symbol` is a property of.
					var ctor = getContainingFunction(expr);
					if (
						!(ctor && (ctor.kind === SyntaxKind.Constructor || isJSConstructor(
							ctor,
						)))
					) {
						return true;
					}
					if (symbol.valueDeclaration) {
						var isAssignmentDeclaration = isBinaryExpression(
							symbol.valueDeclaration,
						);
						var isLocalPropertyDeclaration = ctor.parent === symbol.valueDeclaration.parent;
						var isLocalParameterProperty = ctor === symbol.valueDeclaration.parent;
						var isLocalThisPropertyAssignment = isAssignmentDeclaration && ((_a = symbol.parent) === null || _a === void 0 ? void 0 : _a.valueDeclaration) === ctor.parent;
						var isLocalThisPropertyAssignmentConstructorFunction = isAssignmentDeclaration && ((_b = symbol.parent) === null || _b === void 0 ? void 0 : _b.valueDeclaration) === ctor;
						var isWriteableSymbol = isLocalPropertyDeclaration || isLocalParameterProperty || isLocalThisPropertyAssignment || isLocalThisPropertyAssignmentConstructorFunction;
						return !isWriteableSymbol;
					}
				}
				return true;
			}
			if (isAccessExpression(expr)) {
				// references through namespace import should be readonly
				var node = skipParentheses(expr.expression);
				if (node.kind === SyntaxKind.Identifier) {
					var symbol_2 = getNodeLinks(node).resolvedSymbol;
					if (symbol_2.flags & SymbolFlags.Alias) {
						var declaration = getDeclarationOfAliasSymbol(symbol_2);
						return !!declaration && declaration.kind === SyntaxKind.NamespaceImport;
					}
				}
			}
			return false;
		}
		function checkReferenceExpression(
			expr,
			invalidReferenceMessage,
			invalidOptionalChainMessage,
		) {
			// References are combinations of identifiers, parentheses, and property accesses.
			var node = skipOuterExpressions(
				expr,
				OuterExpressionKinds.Assertions | OuterExpressionKinds.Parentheses,
			);
			if (node.kind !== SyntaxKind.Identifier && !isAccessExpression(node)) {
				error(expr, invalidReferenceMessage);
				return false;
			}
			if (node.flags & NodeFlags.OptionalChain) {
				error(expr, invalidOptionalChainMessage);
				return false;
			}
			return true;
		}
		function checkDeleteExpression(node) {
			checkExpression(node.expression);
			var expr = skipParentheses(node.expression);
			if (!isAccessExpression(expr)) {
				error(
					expr,
					Diagnostics.The_operand_of_a_delete_operator_must_be_a_property_reference,
				);
				return booleanType;
			}
			if (isPropertyAccessExpression(expr) && isPrivateIdentifier(expr.name)) {
				error(
					expr,
					Diagnostics.The_operand_of_a_delete_operator_cannot_be_a_private_identifier,
				);
			}
			var links = getNodeLinks(expr);
			var symbol = getExportSymbolOfValueSymbolIfExported(links.resolvedSymbol);
			if (symbol) {
				if (isReadonlySymbol(symbol)) {
					error(
						expr,
						Diagnostics.The_operand_of_a_delete_operator_cannot_be_a_read_only_property,
					);
				}
				checkDeleteExpressionMustBeOptional(expr, symbol);
			}
			return booleanType;
		}
		function checkDeleteExpressionMustBeOptional(expr, symbol) {
			var type = getTypeOfSymbol(symbol);
			if (
				strictNullChecks && !(type.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Never)) && !(exactOptionalPropertyTypes ? symbol.flags & SymbolFlags.Optional : getFalsyFlags(
					type,
				) & TypeFlags.Undefined)
			) {
				error(
					expr,
					Diagnostics.The_operand_of_a_delete_operator_must_be_optional,
				);
			}
		}
		function checkTypeOfExpression(node) {
			checkExpression(node.expression);
			return typeofType;
		}
		function checkVoidExpression(node) {
			checkExpression(node.expression);
			return undefinedWideningType;
		}
		function checkAwaitExpression(node) {
			// Grammar checking
			if (produceDiagnostics) {
				var container = getContainingFunctionOrClassStaticBlock(node);
				if (container && isClassStaticBlockDeclaration(container)) {
					error(
						node,
						Diagnostics.Await_expression_cannot_be_used_inside_a_class_static_block,
					);
				} else if (!(node.flags & NodeFlags.AwaitContext)) {
					if (isInTopLevelContext(node)) {
						var sourceFile = getSourceFileOfNode(node);
						if (!hasParseDiagnostics(sourceFile)) {
							var span = void 0;
							if (!isEffectiveExternalModule(sourceFile, compilerOptions)) {
								if (!span) span = getSpanOfTokenAtPosition(sourceFile, node.pos);
								var diagnostic = createFileDiagnostic(
									sourceFile,
									span.start,
									span.length,
									Diagnostics.await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module,
								);
								diagnostics.add(diagnostic);
							}
							if (
								(moduleKind !== ModuleKind.ES2022 && moduleKind !== ModuleKind.ESNext && moduleKind !== ModuleKind.System && !(moduleKind === ModuleKind.NodeNext && getSourceFileOfNode(
									node,
								).impliedNodeFormat === ModuleKind.ESNext)) || languageVersion < ScriptTarget.ES2017
							) {
								span = getSpanOfTokenAtPosition(sourceFile, node.pos);
								var diagnostic = createFileDiagnostic(
									sourceFile,
									span.start,
									span.length,
									Diagnostics.Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_or_nodenext_and_the_target_option_is_set_to_es2017_or_higher,
								);
								diagnostics.add(diagnostic);
							}
						}
					} else {
						// use of 'await' in non-async function
						var sourceFile = getSourceFileOfNode(node);
						if (!hasParseDiagnostics(sourceFile)) {
							var span = getSpanOfTokenAtPosition(sourceFile, node.pos);
							var diagnostic = createFileDiagnostic(
								sourceFile,
								span.start,
								span.length,
								Diagnostics.await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules,
							);
							if (
								container && container.kind !== SyntaxKind.Constructor && (getFunctionFlags(
									container,
								) & FunctionFlags.Async) === 0
							) {
								var relatedInfo = createDiagnosticForNode(
									container,
									Diagnostics.Did_you_mean_to_mark_this_function_as_async,
								);
								addRelatedInfo(diagnostic, relatedInfo);
							}
							diagnostics.add(diagnostic);
						}
					}
				}
				if (isInParameterInitializerBeforeContainingFunction(node)) {
					error(
						node,
						Diagnostics.await_expressions_cannot_be_used_in_a_parameter_initializer,
					);
				}
			}
			var operandType = checkExpression(node.expression);
			var awaitedType = checkAwaitedType(
				operandType, /*withAlias*/
				true,
				node,
				Diagnostics.Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member,
			);
			if (
				awaitedType === operandType && !isErrorType(awaitedType) && !(operandType.flags & TypeFlags.AnyOrUnknown)
			) {
				addErrorOrSuggestion(
					false, /*isError*/
					createDiagnosticForNode(
						node,
						Diagnostics.await_has_no_effect_on_the_type_of_this_expression,
					),
				);
			}
			return awaitedType;
		}
		function checkPrefixUnaryExpression(node) {
			var operandType = checkExpression(node.operand);
			if (operandType === silentNeverType) {
				return silentNeverType;
			}
			switch (node.operand.kind) {
				case SyntaxKind.NumericLiteral:
					switch (node.operator) {
						case SyntaxKind.MinusToken:
							return getFreshTypeOfLiteralType(
								getNumberLiteralType(-node.operand.text),
							);
						case SyntaxKind.PlusToken:
							return getFreshTypeOfLiteralType(
								getNumberLiteralType(+node.operand.text),
							);
					}
					break;
				case SyntaxKind.BigIntLiteral:
					if (node.operator === SyntaxKind.MinusToken) {
						return getFreshTypeOfLiteralType(
							getBigIntLiteralType(
								{
									negative: true,
									base10Value: parsePseudoBigInt(node.operand.text),
								},
							),
						);
					}
			}
			switch (node.operator) {
				case SyntaxKind.PlusToken:
				case SyntaxKind.MinusToken:
				case SyntaxKind.TildeToken:
					checkNonNullType(operandType, node.operand);
					if (maybeTypeOfKind(operandType, TypeFlags.ESSymbolLike)) {
						error(
							node.operand,
							Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol,
							tokenToString(node.operator),
						);
					}
					if (node.operator === SyntaxKind.PlusToken) {
						if (maybeTypeOfKind(operandType, TypeFlags.BigIntLike)) {
							error(
								node.operand,
								Diagnostics.Operator_0_cannot_be_applied_to_type_1,
								tokenToString(node.operator),
								typeToString(getBaseTypeOfLiteralType(operandType)),
							);
						}
						return numberType;
					}
					return getUnaryResultType(operandType);
				case SyntaxKind.ExclamationToken:
					checkTruthinessExpression(node.operand);
					var facts = getTypeFacts(operandType) & (4194304 | 8388608); /* Truthy */ /* Falsy */
					return facts === 4194304 ? falseType : facts === 8388608 ? trueType : booleanType; /* Truthy */ /* Falsy */
				case SyntaxKind.PlusPlusToken:
				case SyntaxKind.MinusMinusToken:
					var ok = checkArithmeticOperandType(
						node.operand,
						checkNonNullType(operandType, node.operand),
						Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type,
					);
					if (ok) {
						// run check only if former checks succeeded to avoid reporting cascading errors
						checkReferenceExpression(
							node.operand,
							Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,
							Diagnostics.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access,
						);
					}
					return getUnaryResultType(operandType);
			}
			return errorType;
		}
		function checkPostfixUnaryExpression(node) {
			var operandType = checkExpression(node.operand);
			if (operandType === silentNeverType) {
				return silentNeverType;
			}
			var ok = checkArithmeticOperandType(
				node.operand,
				checkNonNullType(operandType, node.operand),
				Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type,
			);
			if (ok) {
				// run check only if former checks succeeded to avoid reporting cascading errors
				checkReferenceExpression(
					node.operand,
					Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,
					Diagnostics.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access,
				);
			}
			return getUnaryResultType(operandType);
		}
		function getUnaryResultType(operandType) {
			if (maybeTypeOfKind(operandType, TypeFlags.BigIntLike)) {
				return isTypeAssignableToKind(operandType, TypeFlags.AnyOrUnknown) || maybeTypeOfKind(
					operandType,
					TypeFlags.NumberLike,
				) ? numberOrBigIntType : bigintType;
			}
			// If it's not a bigint type, implicit coercion will result in a number
			return numberType;
		}
		// Return true if type might be of the given kind. A union or intersection type might be of a given
		// kind if at least one constituent type is of the given kind.
		function maybeTypeOfKind(type, kind) {
			if (type.flags & kind) {
				return true;
			}
			if (type.flags & TypeFlags.UnionOrIntersection) {
				var types = type.types;
				for (var _i = 0, types_21 = types; _i < types_21.length; _i++) {
					var t = types_21[_i];
					if (maybeTypeOfKind(t, kind)) {
						return true;
					}
				}
			}
			return false;
		}
		function isTypeAssignableToKind(source, kind, strict) {
			if (source.flags & kind) {
				return true;
			}
			if (
				strict && source.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Void | TypeFlags.Undefined | TypeFlags.Null)
			) {
				return false;
			}
			return !!(kind & TypeFlags.NumberLike) && isTypeAssignableTo(
				source,
				numberType,
			) || !!(kind & TypeFlags.BigIntLike) && isTypeAssignableTo(
				source,
				bigintType,
			) || !!(kind & TypeFlags.StringLike) && isTypeAssignableTo(
				source,
				stringType,
			) || !!(kind & TypeFlags.BooleanLike) && isTypeAssignableTo(
				source,
				booleanType,
			) || !!(kind & TypeFlags.Void) && isTypeAssignableTo(source, voidType) || !!(kind & TypeFlags.Never) && isTypeAssignableTo(
				source,
				neverType,
			) || !!(kind & TypeFlags.Null) && isTypeAssignableTo(source, nullType) || !!(kind & TypeFlags.Undefined) && isTypeAssignableTo(
				source,
				undefinedType,
			) || !!(kind & TypeFlags.ESSymbol) && isTypeAssignableTo(
				source,
				esSymbolType,
			) || !!(kind & TypeFlags.NonPrimitive) && isTypeAssignableTo(
				source,
				nonPrimitiveType,
			);
		}
		function allTypesAssignableToKind(source, kind, strict) {
			return source.flags & TypeFlags.Union ? every(
				source.types,
				function (subType) {
					return allTypesAssignableToKind(subType, kind, strict);
				},
			) : isTypeAssignableToKind(source, kind, strict);
		}
		function isConstEnumObjectType(type) {
			return !!(getObjectFlags(type) & ObjectFlags.Anonymous) && !!type.symbol && isConstEnumSymbol(
				type.symbol,
			);
		}
		function isConstEnumSymbol(symbol) {
			return (symbol.flags & SymbolFlags.ConstEnum) !== 0;
		}
		function checkInstanceOfExpression(left, right, leftType, rightType) {
			if (leftType === silentNeverType || rightType === silentNeverType) {
				return silentNeverType;
			}
			// TypeScript 1.0 spec (April 2014): 4.15.4
			// The instanceof operator requires the left operand to be of type Any, an object type, or a type parameter type,
			// and the right operand to be of type Any, a subtype of the 'Function' interface type, or have a call or construct signature.
			// The result is always of the Boolean primitive type.
			// NOTE: do not raise error if leftType is unknown as related error was already reported
			if (
				!isTypeAny(leftType) && allTypesAssignableToKind(
					leftType,
					TypeFlags.Primitive,
				)
			) {
				error(
					left,
					Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter,
				);
			}
			// NOTE: do not raise error if right is unknown as related error was already reported
			if (
				!(isTypeAny(rightType) || typeHasCallOrConstructSignatures(rightType) || isTypeSubtypeOf(
					rightType,
					globalFunctionType,
				))
			) {
				error(
					right,
					Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type,
				);
			}
			return booleanType;
		}
		function checkInExpression(left, right, leftType, rightType) {
			if (leftType === silentNeverType || rightType === silentNeverType) {
				return silentNeverType;
			}
			if (isPrivateIdentifier(left)) {
				if (languageVersion < ScriptTarget.ESNext) {
					checkExternalEmitHelpers(
						left,
						ExternalEmitHelpers.ClassPrivateFieldIn,
					);
				}
				// Unlike in 'checkPrivateIdentifierExpression' we now have access to the RHS type
				// which provides us with the opportunity to emit more detailed errors
				if (!getNodeLinks(left).resolvedSymbol && getContainingClass(left)) {
					var isUncheckedJS = isUncheckedJSSuggestion(
						left,
						rightType.symbol, /*excludeClasses*/
						true,
					);
					reportNonexistentProperty(left, rightType, isUncheckedJS);
				}
			} else {
				leftType = checkNonNullType(leftType, left);
				// TypeScript 1.0 spec (April 2014): 4.15.5
				// Require the left operand to be of type Any, the String primitive type, or the Number primitive type.
				if (
					!(allTypesAssignableToKind(
						leftType,
						TypeFlags.StringLike | TypeFlags.NumberLike | TypeFlags.ESSymbolLike,
					) || isTypeAssignableToKind(
						leftType,
						TypeFlags.Index | TypeFlags.TemplateLiteral | TypeFlags.StringMapping | TypeFlags.TypeParameter,
					))
				) {
					error(
						left,
						Diagnostics.The_left_hand_side_of_an_in_expression_must_be_a_private_identifier_or_of_type_any_string_number_or_symbol,
					);
				}
			}
			rightType = checkNonNullType(rightType, right);
			// TypeScript 1.0 spec (April 2014): 4.15.5
			// The in operator requires the right operand to be
			//
			//   1. assignable to the non-primitive type,
			//   2. an unconstrained type parameter,
			//   3. a union or intersection including one or more type parameters, whose constituents are all assignable to the
			//      the non-primitive type, or are unconstrainted type parameters, or have constraints assignable to the
			//      non-primitive type, or
			//   4. a type parameter whose constraint is
			//      i. an object type,
			//     ii. the non-primitive type, or
			//    iii. a union or intersection with at least one constituent assignable to an object or non-primitive type.
			//
			// The divergent behavior for type parameters and unions containing type parameters is a workaround for type
			// parameters not being narrowable. If the right operand is a concrete type, we can error if there is any chance
			// it is a primitive. But if the operand is a type parameter, it cannot be narrowed, so we don't issue an error
			// unless *all* instantiations would result in an error.
			//
			// The result is always of the Boolean primitive type.
			var rightTypeConstraint = getConstraintOfType(rightType);
			if (
				!allTypesAssignableToKind(
					rightType,
					TypeFlags.NonPrimitive | TypeFlags.InstantiableNonPrimitive,
				) || rightTypeConstraint && (isTypeAssignableToKind(
					rightType,
					TypeFlags.UnionOrIntersection,
				) && !allTypesAssignableToKind(
					rightTypeConstraint,
					TypeFlags.NonPrimitive | TypeFlags.InstantiableNonPrimitive,
				) || !maybeTypeOfKind(
					rightTypeConstraint,
					TypeFlags.NonPrimitive | TypeFlags.InstantiableNonPrimitive | TypeFlags.Object,
				))
			) {
				error(
					right,
					Diagnostics.The_right_hand_side_of_an_in_expression_must_not_be_a_primitive,
				);
			}
			return booleanType;
		}
		function checkObjectLiteralAssignment(node, sourceType, rightIsThis) {
			var properties = node.properties;
			if (strictNullChecks && properties.length === 0) {
				return checkNonNullType(sourceType, node);
			}
			for (var i = 0; i < properties.length; i++) {
				checkObjectLiteralDestructuringPropertyAssignment(
					node,
					sourceType,
					i,
					properties,
					rightIsThis,
				);
			}
			return sourceType;
		}
		/** Note: If property cannot be a SpreadAssignment, then allProperties does not need to be provided */
		function checkObjectLiteralDestructuringPropertyAssignment(
			node,
			objectLiteralType,
			propertyIndex,
			allProperties,
			rightIsThis,
		) {
			if (rightIsThis === void 0) {
				rightIsThis = false;
			}
			var properties = node.properties;
			var property = properties[propertyIndex];
			if (
				property.kind === SyntaxKind.PropertyAssignment || property.kind === SyntaxKind.ShorthandPropertyAssignment
			) {
				var name_24 = property.name;
				var exprType = getLiteralTypeFromPropertyName(name_24);
				if (isTypeUsableAsPropertyName(exprType)) {
					var text = getPropertyNameFromType(exprType);
					var prop = getPropertyOfType(objectLiteralType, text);
					if (prop) {
						markPropertyAsReferenced(prop, property, rightIsThis);
						checkPropertyAccessibility(
							property, /*isSuper*/
							false, /*writing*/
							true,
							objectLiteralType,
							prop,
						);
					}
				}
				var elementType = getIndexedAccessType(
					objectLiteralType,
					exprType,
					AccessFlags.ExpressionPosition,
					name_24,
				);
				var type = getFlowTypeOfDestructuring(property, elementType);
				return checkDestructuringAssignment(
					property.kind === SyntaxKind.ShorthandPropertyAssignment ? property : property.initializer,
					type,
				);
			} else if (property.kind === SyntaxKind.SpreadAssignment) {
				if (propertyIndex < properties.length - 1) {
					error(
						property,
						Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern,
					);
				} else {
					if (languageVersion < ScriptTarget.ESNext) {
						checkExternalEmitHelpers(property, ExternalEmitHelpers.Rest);
					}
					var nonRestNames = [];
					if (allProperties) {
						for (
							var _i = 0, allProperties_1 = allProperties;
							_i < allProperties_1.length;
							_i++
						) {
							var otherProperty = allProperties_1[_i];
							if (!isSpreadAssignment(otherProperty)) {
								nonRestNames.push(otherProperty.name);
							}
						}
					}
					var type = getRestType(
						objectLiteralType,
						nonRestNames,
						objectLiteralType.symbol,
					);
					checkGrammarForDisallowedTrailingComma(
						allProperties,
						Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma,
					);
					return checkDestructuringAssignment(property.expression, type);
				}
			} else {
				error(property, Diagnostics.Property_assignment_expected);
			}
		}
		function checkArrayLiteralAssignment(node, sourceType, checkMode) {
			var elements = node.elements;
			if (
				languageVersion < ScriptTarget.ES2015 && compilerOptions.downlevelIteration
			) {
				checkExternalEmitHelpers(node, ExternalEmitHelpers.Read);
			}
			// This elementType will be used if the specific property corresponding to this index is not
			// present (aka the tuple element property). This call also checks that the parentType is in
			// fact an iterable or array (depending on target language).
			var possiblyOutOfBoundsType = checkIteratedTypeOrElementType(
				65 | 128, /* Destructuring */ /* PossiblyOutOfBounds */
				sourceType,
				undefinedType,
				node,
			) || errorType;
			var inBoundsType = compilerOptions.noUncheckedIndexedAccess ? undefined : possiblyOutOfBoundsType;
			for (var i = 0; i < elements.length; i++) {
				var type = possiblyOutOfBoundsType;
				if (node.elements[i].kind === SyntaxKind.SpreadElement) {
					type = inBoundsType = inBoundsType !== null && inBoundsType !== void 0 ? inBoundsType : (checkIteratedTypeOrElementType(
						65, /* Destructuring */
						sourceType,
						undefinedType,
						node,
					) || errorType);
				}
				checkArrayLiteralDestructuringElementAssignment(
					node,
					sourceType,
					i,
					type,
					checkMode,
				);
			}
			return sourceType;
		}
		function checkArrayLiteralDestructuringElementAssignment(
			node,
			sourceType,
			elementIndex,
			elementType,
			checkMode,
		) {
			var elements = node.elements;
			var element = elements[elementIndex];
			if (element.kind !== SyntaxKind.OmittedExpression) {
				if (element.kind !== SyntaxKind.SpreadElement) {
					var indexType = getNumberLiteralType(elementIndex);
					if (isArrayLikeType(sourceType)) {
						// We create a synthetic expression so that getIndexedAccessType doesn't get confused
						// when the element is a SyntaxKind.ElementAccessExpression.
						var accessFlags = AccessFlags.ExpressionPosition | (hasDefaultValue(
							element,
						) ? AccessFlags.NoTupleBoundsCheck : 0);
						var elementType_1 = getIndexedAccessTypeOrUndefined(
							sourceType,
							indexType,
							accessFlags,
							createSyntheticExpression(element, indexType),
						) || errorType;
						var assignedType = hasDefaultValue(element) ? getTypeWithFacts(
							elementType_1,
							524288, /* NEUndefined */
						) : elementType_1;
						var type = getFlowTypeOfDestructuring(element, assignedType);
						return checkDestructuringAssignment(element, type, checkMode);
					}
					return checkDestructuringAssignment(element, elementType, checkMode);
				}
				if (elementIndex < elements.length - 1) {
					error(
						element,
						Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern,
					);
				} else {
					var restExpression = element.expression;
					if (
						restExpression.kind === SyntaxKind.BinaryExpression && restExpression.operatorToken.kind === SyntaxKind.EqualsToken
					) {
						error(
							restExpression.operatorToken,
							Diagnostics.A_rest_element_cannot_have_an_initializer,
						);
					} else {
						checkGrammarForDisallowedTrailingComma(
							node.elements,
							Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma,
						);
						var type = everyType(sourceType, isTupleType) ? mapType(
							sourceType,
							function (t) {
								return sliceTupleType(t, elementIndex);
							},
						) : createArrayType(elementType);
						return checkDestructuringAssignment(restExpression, type, checkMode);
					}
				}
			}
			return undefined;
		}
		function checkDestructuringAssignment(
			exprOrAssignment,
			sourceType,
			checkMode,
			rightIsThis,
		) {
			var target;
			if (exprOrAssignment.kind === SyntaxKind.ShorthandPropertyAssignment) {
				var prop = exprOrAssignment;
				if (prop.objectAssignmentInitializer) {
					// In strict null checking mode, if a default value of a non-undefined type is specified, remove
					// undefined from the final type.
					if (
						strictNullChecks && !(getFalsyFlags(
							checkExpression(prop.objectAssignmentInitializer),
						) & TypeFlags.Undefined)
					) {
						sourceType = getTypeWithFacts(sourceType, 524288 /* NEUndefined */ );
					}
					checkBinaryLikeExpression(
						prop.name,
						prop.equalsToken,
						prop.objectAssignmentInitializer,
						checkMode,
					);
				}
				target = exprOrAssignment.name;
			} else {
				target = exprOrAssignment;
			}
			if (
				target.kind === SyntaxKind.BinaryExpression && target.operatorToken.kind === SyntaxKind.EqualsToken
			) {
				checkBinaryExpression(target, checkMode);
				target = target.left;
			}
			if (target.kind === SyntaxKind.ObjectLiteralExpression) {
				return checkObjectLiteralAssignment(target, sourceType, rightIsThis);
			}
			if (target.kind === SyntaxKind.ArrayLiteralExpression) {
				return checkArrayLiteralAssignment(target, sourceType, checkMode);
			}
			return checkReferenceAssignment(target, sourceType, checkMode);
		}
		function checkReferenceAssignment(target, sourceType, checkMode) {
			var targetType = checkExpression(target, checkMode);
			var error = target.parent.kind === SyntaxKind.SpreadAssignment ? Diagnostics.The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access : Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access;
			var optionalError = target.parent.kind === SyntaxKind.SpreadAssignment ? Diagnostics.The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access : Diagnostics.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access;
			if (checkReferenceExpression(target, error, optionalError)) {
				checkTypeAssignableToAndOptionallyElaborate(
					sourceType,
					targetType,
					target,
					target,
				);
			}
			if (isPrivateIdentifierPropertyAccessExpression(target)) {
				checkExternalEmitHelpers(
					target.parent,
					ExternalEmitHelpers.ClassPrivateFieldSet,
				);
			}
			return sourceType;
		}
		/**
         * This is a *shallow* check: An expression is side-effect-free if the
         * evaluation of the expression *itself* cannot produce side effects.
         * For example, x++ / 3 is side-effect free because the / operator
         * does not have side effects.
         * The intent is to "smell test" an expression for correctness in positions where
         * its value is discarded (e.g. the left side of the comma operator).
         */
		function isSideEffectFree(node) {
			node = skipParentheses(node);
			switch (node.kind) {
				case SyntaxKind.Identifier:
				case SyntaxKind.StringLiteral:
				case SyntaxKind.RegularExpressionLiteral:
				case SyntaxKind.TaggedTemplateExpression:
				case SyntaxKind.TemplateExpression:
				case SyntaxKind.NoSubstitutionTemplateLiteral:
				case SyntaxKind.NumericLiteral:
				case SyntaxKind.BigIntLiteral:
				case SyntaxKind.TrueKeyword:
				case SyntaxKind.FalseKeyword:
				case SyntaxKind.NullKeyword:
				case SyntaxKind.UndefinedKeyword:
				case SyntaxKind.FunctionExpression:
				case SyntaxKind.ClassExpression:
				case SyntaxKind.ArrowFunction:
				case SyntaxKind.ArrayLiteralExpression:
				case SyntaxKind.ObjectLiteralExpression:
				case SyntaxKind.TypeOfExpression:
				case SyntaxKind.NonNullExpression:
				case SyntaxKind.JsxSelfClosingElement:
				case SyntaxKind.JsxElement:
					return true;
				case SyntaxKind.ConditionalExpression:
					return isSideEffectFree(node.whenTrue) && isSideEffectFree(
						node.whenFalse,
					);
				case SyntaxKind.BinaryExpression:
					if (isAssignmentOperator(node.operatorToken.kind)) {
						return false;
					}
					return isSideEffectFree(node.left) && isSideEffectFree(node.right);
				case SyntaxKind.PrefixUnaryExpression:
				case SyntaxKind.PostfixUnaryExpression:
					// Unary operators ~, !, +, and - have no side effects.
					// The rest do.
					switch (node.operator) {
						case SyntaxKind.ExclamationToken:
						case SyntaxKind.PlusToken:
						case SyntaxKind.MinusToken:
						case SyntaxKind.TildeToken:
							return true;
					}
					return false;
				// Some forms listed here for clarity
				case SyntaxKind.VoidExpression: // Explicit opt-out
				case SyntaxKind.TypeAssertionExpression: // Not SEF, but can produce useful type warnings
				case SyntaxKind.AsExpression: // Not SEF, but can produce useful type warnings
				default:
					return false;
			}
		}
		function isTypeEqualityComparableTo(source, target) {
			return (target.flags & TypeFlags.Nullable) !== 0 || isTypeComparableTo(
				source,
				target,
			);
		}
		function createCheckBinaryExpression() {
			var trampoline = createBinaryExpressionTrampoline(
				onEnter,
				onLeft,
				onOperator,
				onRight,
				onExit,
				foldState,
			);
			return function (node, checkMode) {
				var result = trampoline(node, checkMode);
				Debug.assertIsDefined(result);
				return result;
			};
			function onEnter(node, state, checkMode) {
				if (state) {
					state.stackIndex++;
					state.skip = false;
					setLeftType(state, /*type*/ undefined);
					setLastResult(state, /*type*/ undefined);
				} else {
					state = {
						checkMode: checkMode,
						skip: false,
						stackIndex: 0,
						typeStack: [undefined, undefined],
					};
				}
				if (isInJSFile(node) && getAssignedExpandoInitializer(node)) {
					state.skip = true;
					setLastResult(state, checkExpression(node.right, checkMode));
					return state;
				}
				checkGrammarNullishCoalesceWithLogicalExpression(node);
				var operator = node.operatorToken.kind;
				if (
					operator === SyntaxKind.EqualsToken && (node.left.kind === SyntaxKind.ObjectLiteralExpression || node.left.kind === SyntaxKind.ArrayLiteralExpression)
				) {
					state.skip = true;
					setLastResult(
						state,
						checkDestructuringAssignment(
							node.left,
							checkExpression(node.right, checkMode),
							checkMode,
							node.right.kind === SyntaxKind.ThisKeyword,
						),
					);
					return state;
				}
				return state;
			}
			function onLeft(left, state, _node) {
				if (!state.skip) {
					return maybeCheckExpression(state, left);
				}
			}
			function onOperator(operatorToken, state, node) {
				if (!state.skip) {
					var leftType = getLastResult(state);
					Debug.assertIsDefined(leftType);
					setLeftType(state, leftType);
					setLastResult(state, /*type*/ undefined);
					var operator = operatorToken.kind;
					if (
						operator === SyntaxKind.AmpersandAmpersandToken || operator === SyntaxKind.BarBarToken || operator === SyntaxKind.QuestionQuestionToken
					) {
						if (operator === SyntaxKind.AmpersandAmpersandToken) {
							var parent_15 = walkUpParenthesizedExpressions(node.parent);
							checkTestingKnownTruthyCallableOrAwaitableType(
								node.left,
								leftType,
								isIfStatement(parent_15) ? parent_15.thenStatement : undefined,
							);
						}
						checkTruthinessOfType(leftType, node.left);
					}
				}
			}
			function onRight(right, state, _node) {
				if (!state.skip) {
					return maybeCheckExpression(state, right);
				}
			}
			function onExit(node, state) {
				var result;
				if (state.skip) {
					result = getLastResult(state);
				} else {
					var leftType = getLeftType(state);
					Debug.assertIsDefined(leftType);
					var rightType = getLastResult(state);
					Debug.assertIsDefined(rightType);
					result = checkBinaryLikeExpressionWorker(
						node.left,
						node.operatorToken,
						node.right,
						leftType,
						rightType,
						node,
					);
				}
				state.skip = false;
				setLeftType(state, /*type*/ undefined);
				setLastResult(state, /*type*/ undefined);
				state.stackIndex--;
				return result;
			}
			function foldState(state, result, _side) {
				setLastResult(state, result);
				return state;
			}
			function maybeCheckExpression(state, node) {
				if (isBinaryExpression(node)) {
					return node;
				}
				setLastResult(state, checkExpression(node, state.checkMode));
			}
			function getLeftType(state) {
				return state.typeStack[state.stackIndex];
			}
			function setLeftType(state, type) {
				state.typeStack[state.stackIndex] = type;
			}
			function getLastResult(state) {
				return state.typeStack[state.stackIndex + 1];
			}
			function setLastResult(state, type) {
				// To reduce overhead, reuse the next stack entry to store the
				// last result. This avoids the overhead of an additional property
				// on `WorkArea` and reuses empty stack entries as we walk back up
				// the stack.
				state.typeStack[state.stackIndex + 1] = type;
			}
		}
		function checkGrammarNullishCoalesceWithLogicalExpression(node) {
			var left = node.left,
				operatorToken = node.operatorToken,
				right = node.right;
			if (operatorToken.kind === SyntaxKind.QuestionQuestionToken) {
				if (
					isBinaryExpression(left) && (left.operatorToken.kind === SyntaxKind.BarBarToken || left.operatorToken.kind === SyntaxKind.AmpersandAmpersandToken)
				) {
					grammarErrorOnNode(
						left,
						Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses,
						tokenToString(left.operatorToken.kind),
						tokenToString(operatorToken.kind),
					);
				}
				if (
					isBinaryExpression(right) && (right.operatorToken.kind === SyntaxKind.BarBarToken || right.operatorToken.kind === SyntaxKind.AmpersandAmpersandToken)
				) {
					grammarErrorOnNode(
						right,
						Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses,
						tokenToString(right.operatorToken.kind),
						tokenToString(operatorToken.kind),
					);
				}
			}
		}
		// Note that this and `checkBinaryExpression` above should behave mostly the same, except this elides some
		// expression-wide checks and does not use a work stack to fold nested binary expressions into the same callstack frame
		function checkBinaryLikeExpression(
			left,
			operatorToken,
			right,
			checkMode,
			errorNode,
		) {
			var operator = operatorToken.kind;
			if (
				operator === SyntaxKind.EqualsToken && (left.kind === SyntaxKind.ObjectLiteralExpression || left.kind === SyntaxKind.ArrayLiteralExpression)
			) {
				return checkDestructuringAssignment(
					left,
					checkExpression(right, checkMode),
					checkMode,
					right.kind === SyntaxKind.ThisKeyword,
				);
			}
			var leftType;
			if (
				operator === SyntaxKind.AmpersandAmpersandToken || operator === SyntaxKind.BarBarToken || operator === SyntaxKind.QuestionQuestionToken
			) {
				leftType = checkTruthinessExpression(left, checkMode);
			} else {
				leftType = checkExpression(left, checkMode);
			}
			var rightType = checkExpression(right, checkMode);
			return checkBinaryLikeExpressionWorker(
				left,
				operatorToken,
				right,
				leftType,
				rightType,
				errorNode,
			);
		}
		function checkBinaryLikeExpressionWorker(
			left,
			operatorToken,
			right,
			leftType,
			rightType,
			errorNode,
		) {
			var operator = operatorToken.kind;
			switch (operator) {
				case SyntaxKind.AsteriskToken:
				case SyntaxKind.AsteriskAsteriskToken:
				case SyntaxKind.AsteriskEqualsToken:
				case SyntaxKind.AsteriskAsteriskEqualsToken:
				case SyntaxKind.SlashToken:
				case SyntaxKind.SlashEqualsToken:
				case SyntaxKind.PercentToken:
				case SyntaxKind.PercentEqualsToken:
				case SyntaxKind.MinusToken:
				case SyntaxKind.MinusEqualsToken:
				case SyntaxKind.LessThanLessThanToken:
				case SyntaxKind.LessThanLessThanEqualsToken:
				case SyntaxKind.GreaterThanGreaterThanToken:
				case SyntaxKind.GreaterThanGreaterThanEqualsToken:
				case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
				case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
				case SyntaxKind.BarToken:
				case SyntaxKind.BarEqualsToken:
				case SyntaxKind.CaretToken:
				case SyntaxKind.CaretEqualsToken:
				case SyntaxKind.AmpersandToken:
				case SyntaxKind.AmpersandEqualsToken:
					if (leftType === silentNeverType || rightType === silentNeverType) {
						return silentNeverType;
					}
					leftType = checkNonNullType(leftType, left);
					rightType = checkNonNullType(rightType, right);
					var suggestedOperator = void 0;
					// if a user tries to apply a bitwise operator to 2 boolean operands
					// try and return them a helpful suggestion
					if (
						(leftType.flags & TypeFlags.BooleanLike) && (rightType.flags & TypeFlags.BooleanLike) && (suggestedOperator = getSuggestedBooleanOperator(
							operatorToken.kind,
						)) !== undefined
					) {
						error(
							errorNode || operatorToken,
							Diagnostics.The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead,
							tokenToString(operatorToken.kind),
							tokenToString(suggestedOperator),
						);
						return numberType;
					} else {
						// otherwise just check each operand separately and report errors as normal
						var leftOk = checkArithmeticOperandType(
							left,
							leftType,
							Diagnostics.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type, /*isAwaitValid*/
							true,
						);
						var rightOk = checkArithmeticOperandType(
							right,
							rightType,
							Diagnostics.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type, /*isAwaitValid*/
							true,
						);
						var resultType_1;
						// If both are any or unknown, allow operation; assume it will resolve to number
						if (
							(isTypeAssignableToKind(leftType, TypeFlags.AnyOrUnknown) && isTypeAssignableToKind(
								rightType,
								TypeFlags.AnyOrUnknown,
							)) || !(maybeTypeOfKind(leftType, TypeFlags.BigIntLike) || maybeTypeOfKind(
								rightType, // Or, if neither could be bigint, implicit coercion results in a number result
								TypeFlags.BigIntLike,
							))
						) {
							resultType_1 = numberType;
						} else if (bothAreBigIntLike(leftType, rightType)) {
							switch (operator) { // At least one is assignable to bigint, so check that both are
								case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
								case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
									reportOperatorError();
									break;
								case SyntaxKind.AsteriskAsteriskToken:
								case SyntaxKind.AsteriskAsteriskEqualsToken:
									if (languageVersion < ScriptTarget.ES2016) {
										error(
											errorNode,
											Diagnostics.Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_later,
										);
									}
							}
							resultType_1 = bigintType;
						} else {
							reportOperatorError(bothAreBigIntLike); // Exactly one of leftType/rightType is assignable to bigint
							resultType_1 = errorType;
						}
						if (leftOk && rightOk) {
							checkAssignmentOperator(resultType_1);
						}
						return resultType_1;
					}
				case SyntaxKind.PlusToken:
				case SyntaxKind.PlusEqualsToken:
					if (leftType === silentNeverType || rightType === silentNeverType) {
						return silentNeverType;
					}
					if (
						!isTypeAssignableToKind(leftType, TypeFlags.StringLike) && !isTypeAssignableToKind(
							rightType,
							TypeFlags.StringLike,
						)
					) {
						leftType = checkNonNullType(leftType, left);
						rightType = checkNonNullType(rightType, right);
					}
					var resultType = void 0;
					if (
						isTypeAssignableToKind(
							leftType,
							TypeFlags.NumberLike, /*strict*/
							true,
						) && isTypeAssignableToKind(
							rightType,
							TypeFlags.NumberLike, /*strict*/
							true,
						)
					) {
						// Operands of an enum type are treated as having the primitive type Number.
						// If both operands are of the Number primitive type, the result is of the Number primitive type.
						resultType = numberType;
					} else if (
						isTypeAssignableToKind(
							leftType,
							TypeFlags.BigIntLike, /*strict*/
							true,
						) && isTypeAssignableToKind(
							rightType,
							TypeFlags.BigIntLike, /*strict*/
							true,
						)
					) {
						// If both operands are of the BigInt primitive type, the result is of the BigInt primitive type.
						resultType = bigintType;
					} else if (
						isTypeAssignableToKind(
							leftType,
							TypeFlags.StringLike, /*strict*/
							true,
						) || isTypeAssignableToKind(
							rightType,
							TypeFlags.StringLike, /*strict*/
							true,
						)
					) {
						// If one or both operands are of the String primitive type, the result is of the String primitive type.
						resultType = stringType;
					} else if (isTypeAny(leftType) || isTypeAny(rightType)) {
						// Otherwise, the result is of type Any.
						// NOTE: unknown type here denotes error type. Old compiler treated this case as any type so do we.
						resultType = isErrorType(leftType) || isErrorType(rightType) ? errorType : anyType;
					}
					// Symbols are not allowed at all in arithmetic expressions
					if (resultType && !checkForDisallowedESSymbolOperand(operator)) {
						return resultType;
					}
					if (!resultType) {
						// Types that have a reasonably good chance of being a valid operand type.
						// If both types have an awaited type of one of these, we'll assume the user
						// might be missing an await without doing an exhaustive check that inserting
						// await(s) will actually be a completely valid binary expression.
						var closeEnoughKind_1 = TypeFlags.NumberLike | TypeFlags.BigIntLike | TypeFlags.StringLike | TypeFlags.AnyOrUnknown;
						reportOperatorError(
							function (left, right) {
								return isTypeAssignableToKind(left, closeEnoughKind_1) && isTypeAssignableToKind(
									right,
									closeEnoughKind_1,
								);
							},
						);
						return anyType;
					}
					if (operator === SyntaxKind.PlusEqualsToken) {
						checkAssignmentOperator(resultType);
					}
					return resultType;
				case SyntaxKind.LessThanToken:
				case SyntaxKind.GreaterThanToken:
				case SyntaxKind.LessThanEqualsToken:
				case SyntaxKind.GreaterThanEqualsToken:
					if (checkForDisallowedESSymbolOperand(operator)) {
						leftType = getBaseTypeOfLiteralType(
							checkNonNullType(leftType, left),
						);
						rightType = getBaseTypeOfLiteralType(
							checkNonNullType(rightType, right),
						);
						reportOperatorErrorUnless(
							function (left, right) {
								return isTypeComparableTo(left, right) || isTypeComparableTo(
									right,
									left,
								) || (isTypeAssignableTo(left, numberOrBigIntType) && isTypeAssignableTo(
									right,
									numberOrBigIntType,
								));
							},
						);
					}
					return booleanType;
				case SyntaxKind.EqualsEqualsToken:
				case SyntaxKind.ExclamationEqualsToken:
				case SyntaxKind.EqualsEqualsEqualsToken:
				case SyntaxKind.ExclamationEqualsEqualsToken:
					reportOperatorErrorUnless(
						function (left, right) {
							return isTypeEqualityComparableTo(left, right) || isTypeEqualityComparableTo(
								right,
								left,
							);
						},
					);
					return booleanType;
				case SyntaxKind.InstanceOfKeyword:
					return checkInstanceOfExpression(left, right, leftType, rightType);
				case SyntaxKind.InKeyword:
					return checkInExpression(left, right, leftType, rightType);
				case SyntaxKind.AmpersandAmpersandToken:
				case SyntaxKind.AmpersandAmpersandEqualsToken:
					{
						var resultType_2 = getTypeFacts(leftType) & 4194304 ? getUnionType(
							[
								extractDefinitelyFalsyTypes( /* Truthy */
									strictNullChecks ? leftType : getBaseTypeOfLiteralType(
										rightType,
									),
								),
								rightType,
							],
						) : leftType;
						if (operator === SyntaxKind.AmpersandAmpersandEqualsToken) {
							checkAssignmentOperator(rightType);
						}
						return resultType_2;
					}
				case SyntaxKind.BarBarToken:
				case SyntaxKind.BarBarEqualsToken:
					{
						var resultType_3 = getTypeFacts(leftType) & 8388608 ? getUnionType(
							[removeDefinitelyFalsyTypes(leftType), rightType], /* Falsy */
							UnionReduction.Subtype,
						) : leftType;
						if (operator === SyntaxKind.BarBarEqualsToken) {
							checkAssignmentOperator(rightType);
						}
						return resultType_3;
					}
				case SyntaxKind.QuestionQuestionToken:
				case SyntaxKind.QuestionQuestionEqualsToken:
					{
						var resultType_4 = getTypeFacts(leftType) & 262144 ? getUnionType(
							[getNonNullableType(leftType), rightType], /* EQUndefinedOrNull */
							UnionReduction.Subtype,
						) : leftType;
						if (operator === SyntaxKind.QuestionQuestionEqualsToken) {
							checkAssignmentOperator(rightType);
						}
						return resultType_4;
					}
				case SyntaxKind.EqualsToken:
					var declKind = isBinaryExpression(left.parent) ? getAssignmentDeclarationKind(
						left.parent,
					) : AssignmentDeclarationKind.None;
					checkAssignmentDeclaration(declKind, rightType);
					if (isAssignmentDeclaration(declKind)) {
						if (
							!(rightType.flags & TypeFlags.Object) || declKind !== AssignmentDeclarationKind.ModuleExports && declKind !== AssignmentDeclarationKind.Prototype && !isEmptyObjectType(
								rightType,
							) && !isFunctionObjectType(rightType) && !(getObjectFlags(
								rightType,
							) & ObjectFlags.Class)
						) {
							// don't check assignability of module.exports=, C.prototype=, or expando types because they will necessarily be incomplete
							checkAssignmentOperator(rightType);
						}
						return leftType;
					} else {
						checkAssignmentOperator(rightType);
						return getRegularTypeOfObjectLiteral(rightType);
					}
				case SyntaxKind.CommaToken:
					if (
						!compilerOptions.allowUnreachableCode && isSideEffectFree(left) && !isEvalNode(
							right,
						)
					) {
						var sf = getSourceFileOfNode(left);
						var sourceText = sf.text;
						var start_1 = skipTrivia(sourceText, left.pos);
						var isInDiag2657 = sf.parseDiagnostics.some(
							function (diag) {
								if (
									diag.code !== Diagnostics.JSX_expressions_must_have_one_parent_element.code
								) return false;
								return textSpanContainsPosition(diag, start_1);
							},
						);
						if (!isInDiag2657) error(
							left,
							Diagnostics.Left_side_of_comma_operator_is_unused_and_has_no_side_effects,
						);
					}
					return rightType;
				default:
					return Debug.fail();
			}
			function bothAreBigIntLike(left, right) {
				return isTypeAssignableToKind(left, TypeFlags.BigIntLike) && isTypeAssignableToKind(
					right,
					TypeFlags.BigIntLike,
				);
			}
			function checkAssignmentDeclaration(kind, rightType) {
				if (kind === AssignmentDeclarationKind.ModuleExports) {
					for (
						var _i = 0, _a = getPropertiesOfObjectType(rightType);
						_i < _a.length;
						_i++
					) {
						var prop = _a[_i];
						var propType = getTypeOfSymbol(prop);
						if (propType.symbol && propType.symbol.flags & SymbolFlags.Class) {
							var name_25 = prop.escapedName;
							var symbol = resolveName(
								prop.valueDeclaration,
								name_25,
								SymbolFlags.Type,
								undefined,
								name_25, /*isUse*/
								false,
							);
							if (
								(symbol === null || symbol === void 0 ? void 0 : symbol.declarations) && symbol.declarations.some(
									isJSDocTypedefTag,
								)
							) {
								addDuplicateDeclarationErrorsForSymbols(
									symbol,
									Diagnostics.Duplicate_identifier_0,
									unescapeLeadingUnderscores(name_25),
									prop,
								);
								addDuplicateDeclarationErrorsForSymbols(
									prop,
									Diagnostics.Duplicate_identifier_0,
									unescapeLeadingUnderscores(name_25),
									symbol,
								);
							}
						}
					}
				}
			}
			function isEvalNode(node) {
				return node.kind === SyntaxKind.Identifier && node.escapedText === "eval";
			}
			// Return true if there was no error, false if there was an error.
			function checkForDisallowedESSymbolOperand(operator) {
				var offendingSymbolOperand = maybeTypeOfKind(
					leftType,
					TypeFlags.ESSymbolLike,
				) ? left : maybeTypeOfKind(rightType, TypeFlags.ESSymbolLike) ? right : undefined;
				if (offendingSymbolOperand) {
					error(
						offendingSymbolOperand,
						Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol,
						tokenToString(operator),
					);
					return false;
				}
				return true;
			}
			function getSuggestedBooleanOperator(operator) {
				switch (operator) {
					case SyntaxKind.BarToken:
					case SyntaxKind.BarEqualsToken:
						return SyntaxKind.BarBarToken;
					case SyntaxKind.CaretToken:
					case SyntaxKind.CaretEqualsToken:
						return SyntaxKind.ExclamationEqualsEqualsToken;
					case SyntaxKind.AmpersandToken:
					case SyntaxKind.AmpersandEqualsToken:
						return SyntaxKind.AmpersandAmpersandToken;
					default:
						return undefined;
				}
			}
			function checkAssignmentOperator(valueType) {
				if (produceDiagnostics && isAssignmentOperator(operator)) {
					// TypeScript 1.0 spec (April 2014): 4.17
					// An assignment of the form
					//    VarExpr = ValueExpr
					// requires VarExpr to be classified as a reference
					// A compound assignment furthermore requires VarExpr to be classified as a reference (section 4.1)
					// and the type of the non-compound operation to be assignable to the type of VarExpr.
					if (
						checkReferenceExpression(
							left,
							Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access,
							Diagnostics.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access,
						) && (!isIdentifier(left) || unescapeLeadingUnderscores(
							left.escapedText,
						) !== "exports")
					) {
						var headMessage = void 0;
						if (
							exactOptionalPropertyTypes && isPropertyAccessExpression(left) && maybeTypeOfKind(
								valueType,
								TypeFlags.Undefined,
							)
						) {
							var target = getTypeOfPropertyOfType(
								getTypeOfExpression(left.expression),
								left.name.escapedText,
							);
							if (isExactOptionalPropertyMismatch(valueType, target)) {
								headMessage = Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target;
							}
						}
						// to avoid cascading errors check assignability only if 'isReference' check succeeded and no errors were reported
						checkTypeAssignableToAndOptionallyElaborate(
							valueType,
							leftType,
							left,
							right,
							headMessage,
						);
					}
				}
			}
			function isAssignmentDeclaration(kind) {
				var _a;
				switch (kind) {
					case AssignmentDeclarationKind.ModuleExports:
						return true;
					case AssignmentDeclarationKind.ExportsProperty:
					case AssignmentDeclarationKind.Property:
					case AssignmentDeclarationKind.Prototype:
					case AssignmentDeclarationKind.PrototypeProperty:
					case AssignmentDeclarationKind.ThisProperty:
						var symbol = getSymbolOfNode(left);
						var init = getAssignedExpandoInitializer(right);
						return !!init && isObjectLiteralExpression(init) && !!((_a = symbol === null || symbol === void 0 ? void 0 : symbol.exports) === null || _a === void 0 ? void 0 : _a.size);
					default:
						return false;
				}
			}
			/**
             * Returns true if an error is reported
             */
			function reportOperatorErrorUnless(typesAreCompatible) {
				if (!typesAreCompatible(leftType, rightType)) {
					reportOperatorError(typesAreCompatible);
					return true;
				}
				return false;
			}
			function reportOperatorError(isRelated) {
				var _a;
				var wouldWorkWithAwait = false;
				var errNode = errorNode || operatorToken;
				if (isRelated) {
					var awaitedLeftType = getAwaitedTypeNoAlias(leftType);
					var awaitedRightType = getAwaitedTypeNoAlias(rightType);
					wouldWorkWithAwait = !(awaitedLeftType === leftType && awaitedRightType === rightType) && !!(awaitedLeftType && awaitedRightType) && isRelated(
						awaitedLeftType,
						awaitedRightType,
					);
				}
				var effectiveLeft = leftType;
				var effectiveRight = rightType;
				if (!wouldWorkWithAwait && isRelated) {
					_a = getBaseTypesIfUnrelated(leftType, rightType, isRelated), effectiveLeft = _a[0], effectiveRight = _a[1];
				}
				var _b = getTypeNamesForErrorDisplay(effectiveLeft, effectiveRight),
					leftStr = _b[0],
					rightStr = _b[1];
				if (
					!tryGiveBetterPrimaryError(
						errNode,
						wouldWorkWithAwait,
						leftStr,
						rightStr,
					)
				) {
					errorAndMaybeSuggestAwait(
						errNode,
						wouldWorkWithAwait,
						Diagnostics.Operator_0_cannot_be_applied_to_types_1_and_2,
						tokenToString(operatorToken.kind),
						leftStr,
						rightStr,
					);
				}
			}
			function tryGiveBetterPrimaryError(
				errNode,
				maybeMissingAwait,
				leftStr,
				rightStr,
			) {
				var typeName;
				switch (operatorToken.kind) {
					case SyntaxKind.EqualsEqualsEqualsToken:
					case SyntaxKind.EqualsEqualsToken:
						typeName = "false";
						break;
					case SyntaxKind.ExclamationEqualsEqualsToken:
					case SyntaxKind.ExclamationEqualsToken:
						typeName = "true";
				}
				if (typeName) {
					return errorAndMaybeSuggestAwait(
						errNode,
						maybeMissingAwait,
						Diagnostics.This_condition_will_always_return_0_since_the_types_1_and_2_have_no_overlap,
						typeName,
						leftStr,
						rightStr,
					);
				}
				return undefined;
			}
		}
		function getBaseTypesIfUnrelated(leftType, rightType, isRelated) {
			var effectiveLeft = leftType;
			var effectiveRight = rightType;
			var leftBase = getBaseTypeOfLiteralType(leftType);
			var rightBase = getBaseTypeOfLiteralType(rightType);
			if (!isRelated(leftBase, rightBase)) {
				effectiveLeft = leftBase;
				effectiveRight = rightBase;
			}
			return [effectiveLeft, effectiveRight];
		}
		function checkYieldExpression(node) {
			// Grammar checking
			if (produceDiagnostics) {
				if (!(node.flags & NodeFlags.YieldContext)) {
					grammarErrorOnFirstToken(
						node,
						Diagnostics.A_yield_expression_is_only_allowed_in_a_generator_body,
					);
				}
				if (isInParameterInitializerBeforeContainingFunction(node)) {
					error(
						node,
						Diagnostics.yield_expressions_cannot_be_used_in_a_parameter_initializer,
					);
				}
			}
			var func = getContainingFunction(node);
			if (!func) return anyType;
			var functionFlags = getFunctionFlags(func);
			if (!(functionFlags & FunctionFlags.Generator)) {
				// If the user's code is syntactically correct, the func should always have a star. After all, we are in a yield context.
				return anyType;
			}
			var isAsync = (functionFlags & FunctionFlags.Async) !== 0;
			if (node.asteriskToken) {
				// Async generator functions prior to ESNext require the __await, __asyncDelegator,
				// and __asyncValues helpers
				if (isAsync && languageVersion < ScriptTarget.ESNext) {
					checkExternalEmitHelpers(
						node,
						ExternalEmitHelpers.AsyncDelegatorIncludes,
					);
				}
				// Generator functions prior to ES2015 require the __values helper
				if (
					!isAsync && languageVersion < ScriptTarget.ES2015 && compilerOptions.downlevelIteration
				) {
					checkExternalEmitHelpers(node, ExternalEmitHelpers.Values);
				}
			}
			// There is no point in doing an assignability check if the function
			// has no explicit return type because the return type is directly computed
			// from the yield expressions.
			var returnType = getReturnTypeFromAnnotation(func);
			var iterationTypes = returnType && getIterationTypesOfGeneratorFunctionReturnType(
				returnType,
				isAsync,
			);
			var signatureYieldType = iterationTypes && iterationTypes.yieldType || anyType;
			var signatureNextType = iterationTypes && iterationTypes.nextType || anyType;
			var resolvedSignatureNextType = isAsync ? getAwaitedType(
				signatureNextType,
			) || anyType : signatureNextType;
			var yieldExpressionType = node.expression ? checkExpression(
				node.expression,
			) : undefinedWideningType;
			var yieldedType = getYieldedTypeOfYieldExpression(
				node,
				yieldExpressionType,
				resolvedSignatureNextType,
				isAsync,
			);
			if (returnType && yieldedType) {
				checkTypeAssignableToAndOptionallyElaborate(
					yieldedType,
					signatureYieldType,
					node.expression || node,
					node.expression,
				);
			}
			if (node.asteriskToken) {
				var use = isAsync ? 19 /* AsyncYieldStar */ : 17 /* YieldStar */ ;
				return getIterationTypeOfIterable(
					use,
					1, /* Return */
					yieldExpressionType,
					node.expression,
				) || anyType;
			} else if (returnType) {
				return getIterationTypeOfGeneratorFunctionReturnType(
					2, /* Next */
					returnType,
					isAsync,
				) || anyType;
			}
			var type = getContextualIterationType(2 /* Next */ , func);
			if (!type) {
				type = anyType;
				if (
					produceDiagnostics && noImplicitAny && !expressionResultIsUnused(node)
				) {
					var contextualType = getContextualType(node);
					if (!contextualType || isTypeAny(contextualType)) {
						error(
							node,
							Diagnostics.yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_type_annotation,
						);
					}
				}
			}
			return type;
		}
		function checkConditionalExpression(node, checkMode) {
			var type = checkTruthinessExpression(node.condition);
			checkTestingKnownTruthyCallableOrAwaitableType(
				node.condition,
				type,
				node.whenTrue,
			);
			var type1 = checkExpression(node.whenTrue, checkMode);
			var type2 = checkExpression(node.whenFalse, checkMode);
			return getUnionType([type1, type2], UnionReduction.Subtype);
		}
		function isTemplateLiteralContext(node) {
			var parent = node.parent;
			return isParenthesizedExpression(parent) && isTemplateLiteralContext(
				parent,
			) || isElementAccessExpression(parent) && parent.argumentExpression === node;
		}
		function checkTemplateExpression(node) {
			var texts = [node.head.text];
			var types = [];
			for (var _i = 0, _a = node.templateSpans; _i < _a.length; _i++) {
				var span = _a[_i];
				var type = checkExpression(span.expression);
				if (maybeTypeOfKind(type, TypeFlags.ESSymbolLike)) {
					error(
						span.expression,
						Diagnostics.Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_in_String,
					);
				}
				texts.push(span.literal.text);
				types.push(
					isTypeAssignableTo(type, templateConstraintType) ? type : stringType,
				);
			}
			return isConstContext(node) || isTemplateLiteralContext(node) || someType(
				getContextualType(node) || unknownType,
				isTemplateLiteralContextualType,
			) ? getTemplateLiteralType(texts, types) : stringType;
		}
		function isTemplateLiteralContextualType(type) {
			return !!(type.flags & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral) || type.flags & TypeFlags.InstantiableNonPrimitive && maybeTypeOfKind(
				getBaseConstraintOfType(type) || unknownType,
				TypeFlags.StringLike,
			));
		}
		function getContextNode(node) {
			if (
				node.kind === SyntaxKind.JsxAttributes && !isJsxSelfClosingElement(
					node.parent,
				)
			) {
				return node.parent.parent; // Needs to be the root JsxElement, so it encompasses the attributes _and_ the children (which are essentially part of the attributes)
			}
			return node;
		}
		function checkExpressionWithContextualType(
			node,
			contextualType,
			inferenceContext,
			checkMode,
		) {
			var context = getContextNode(node);
			var saveContextualType = context.contextualType;
			var saveInferenceContext = context.inferenceContext;
			try {
				context.contextualType = contextualType;
				context.inferenceContext = inferenceContext;
				var type = checkExpression(
					node,
					checkMode | 1 | (inferenceContext ? 2 : 0), /* Contextual */ /* Inferential */
				);
				// We strip literal freshness when an appropriate contextual type is present such that contextually typed
				// literals always preserve their literal types (otherwise they might widen during type inference). An alternative
				// here would be to not mark contextually typed literals as fresh in the first place.
				var result = maybeTypeOfKind(type, TypeFlags.Literal) && isLiteralOfContextualType(
					type,
					instantiateContextualType(contextualType, node),
				) ? getRegularTypeOfLiteralType(type) : type;
				return result;
			} finally {
				// In the event our operation is canceled or some other exception occurs, reset the contextual type
				// so that we do not accidentally hold onto an instance of the checker, as a Type created in the services layer
				// may hold onto the checker that created it.
				context.contextualType = saveContextualType;
				context.inferenceContext = saveInferenceContext;
			}
		}
		function checkExpressionCached(node, checkMode) {
			var links = getNodeLinks(node);
			if (!links.resolvedType) {
				if (checkMode && checkMode !== 0 /* Normal */ ) {
					return checkExpression(node, checkMode);
				}
				// When computing a type that we're going to cache, we need to ignore any ongoing control flow
				// analysis because variables may have transient types in indeterminable states. Moving flowLoopStart
				// to the top of the stack ensures all transient types are computed from a known point.
				var saveFlowLoopStart = flowLoopStart;
				var saveFlowTypeCache = flowTypeCache;
				flowLoopStart = flowLoopCount;
				flowTypeCache = undefined;
				links.resolvedType = checkExpression(node, checkMode);
				flowTypeCache = saveFlowTypeCache;
				flowLoopStart = saveFlowLoopStart;
			}
			return links.resolvedType;
		}
		function isTypeAssertion(node) {
			node = skipParentheses(node, /*excludeJSDocTypeAssertions*/ true);
			return node.kind === SyntaxKind.TypeAssertionExpression || node.kind === SyntaxKind.AsExpression || isJSDocTypeAssertion(
				node,
			);
		}
		function checkDeclarationInitializer(declaration, contextualType) {
			var initializer = getEffectiveInitializer(declaration);
			var type = getQuickTypeOfExpression(initializer) || (contextualType ? checkExpressionWithContextualType(
				initializer,
				contextualType, /*inferenceContext*/
				undefined,
				0, /* Normal */
			) : checkExpressionCached(initializer));
			return isParameter(declaration) && declaration.name.kind === SyntaxKind.ArrayBindingPattern && isTupleType(
				type,
			) && !type.target.hasRestElement && getTypeReferenceArity(type) < declaration.name.elements.length ? padTupleType(
				type,
				declaration.name,
			) : type;
		}
		function padTupleType(type, pattern) {
			var patternElements = pattern.elements;
			var elementTypes = getTypeArguments(type).slice();
			var elementFlags = type.target.elementFlags.slice();
			for (var i = getTypeReferenceArity(type); i < patternElements.length; i++) {
				var e = patternElements[i];
				if (
					i < patternElements.length - 1 || !(e.kind === SyntaxKind.BindingElement && e.dotDotDotToken)
				) {
					elementTypes.push(
						!isOmittedExpression(e) && hasDefaultValue(e) ? getTypeFromBindingElement(
							e, /*includePatternInType*/
							false, /*reportErrors*/
							false,
						) : anyType,
					);
					elementFlags.push(ElementFlags.Optional);
					if (!isOmittedExpression(e) && !hasDefaultValue(e)) {
						reportImplicitAny(e, anyType);
					}
				}
			}
			return createTupleType(elementTypes, elementFlags, type.target.readonly);
		}
		function widenTypeInferredFromInitializer(declaration, type) {
			var widened = getCombinedNodeFlags(declaration) & NodeFlags.Const || isDeclarationReadonly(
				declaration,
			) ? type : getWidenedLiteralType(type);
			if (isInJSFile(declaration)) {
				if (isEmptyLiteralType(widened)) {
					reportImplicitAny(declaration, anyType);
					return anyType;
				} else if (isEmptyArrayLiteralType(widened)) {
					reportImplicitAny(declaration, anyArrayType);
					return anyArrayType;
				}
			}
			return widened;
		}
		function isLiteralOfContextualType(candidateType, contextualType) {
			if (contextualType) {
				if (contextualType.flags & TypeFlags.UnionOrIntersection) {
					var types = contextualType.types;
					return some(
						types,
						function (t) {
							return isLiteralOfContextualType(candidateType, t);
						},
					);
				}
				if (contextualType.flags & TypeFlags.InstantiableNonPrimitive) {
					// If the contextual type is a type variable constrained to a primitive type, consider
					// this a literal context for literals of that primitive type. For example, given a
					// type parameter 'T extends string', infer string literal types for T.
					var constraint = getBaseConstraintOfType(contextualType) || unknownType;
					return maybeTypeOfKind(constraint, TypeFlags.String) && maybeTypeOfKind(
						candidateType,
						TypeFlags.StringLiteral,
					) || maybeTypeOfKind(constraint, TypeFlags.Number) && maybeTypeOfKind(
						candidateType,
						TypeFlags.NumberLiteral,
					) || maybeTypeOfKind(constraint, TypeFlags.BigInt) && maybeTypeOfKind(
						candidateType,
						TypeFlags.BigIntLiteral,
					) || maybeTypeOfKind(constraint, TypeFlags.ESSymbol) && maybeTypeOfKind(
						candidateType,
						TypeFlags.UniqueESSymbol,
					) || isLiteralOfContextualType(candidateType, constraint);
				}
				// If the contextual type is a literal of a particular primitive type, we consider this a
				// literal context for all literals of that primitive type.
				return !!(contextualType.flags & (TypeFlags.StringLiteral | TypeFlags.Index | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) && maybeTypeOfKind(
					candidateType,
					TypeFlags.StringLiteral,
				) || contextualType.flags & TypeFlags.NumberLiteral && maybeTypeOfKind(
					candidateType,
					TypeFlags.NumberLiteral,
				) || contextualType.flags & TypeFlags.BigIntLiteral && maybeTypeOfKind(
					candidateType,
					TypeFlags.BigIntLiteral,
				) || contextualType.flags & TypeFlags.BooleanLiteral && maybeTypeOfKind(
					candidateType,
					TypeFlags.BooleanLiteral,
				) || contextualType.flags & TypeFlags.UniqueESSymbol && maybeTypeOfKind(
					candidateType,
					TypeFlags.UniqueESSymbol,
				));
			}
			return false;
		}
		function isConstContext(node) {
			var parent = node.parent;
			return isAssertionExpression(parent) && isConstTypeReference(parent.type) || isJSDocTypeAssertion(
				parent,
			) && isConstTypeReference(getJSDocTypeAssertionType(parent)) || (isParenthesizedExpression(
				parent,
			) || isArrayLiteralExpression(parent) || isSpreadElement(parent)) && isConstContext(
				parent,
			) || (isPropertyAssignment(parent) || isShorthandPropertyAssignment(
				parent,
			) || isTemplateSpan(parent)) && isConstContext(parent.parent);
		}
		function checkExpressionForMutableLocation(
			node,
			checkMode,
			contextualType,
			forceTuple,
		) {
			var type = checkExpression(node, checkMode, forceTuple);
			return isConstContext(node) ? getRegularTypeOfLiteralType(type) : isTypeAssertion(
				node,
			) ? type : getWidenedLiteralLikeTypeForContextualType(
				type,
				instantiateContextualType(
					arguments.length === 2 ? getContextualType(node) : contextualType,
					node,
				),
			);
		}
		function checkPropertyAssignment(node, checkMode) {
			// Do not use hasDynamicName here, because that returns false for well known symbols.
			// We want to perform checkComputedPropertyName for all computed properties, including
			// well known symbols.
			if (node.name.kind === SyntaxKind.ComputedPropertyName) {
				checkComputedPropertyName(node.name);
			}
			return checkExpressionForMutableLocation(node.initializer, checkMode);
		}
		function checkObjectLiteralMethod(node, checkMode) {
			// Grammar checking
			checkGrammarMethod(node);
			// Do not use hasDynamicName here, because that returns false for well known symbols.
			// We want to perform checkComputedPropertyName for all computed properties, including
			// well known symbols.
			if (node.name.kind === SyntaxKind.ComputedPropertyName) {
				checkComputedPropertyName(node.name);
			}
			var uninstantiatedType = checkFunctionExpressionOrObjectLiteralMethod(
				node,
				checkMode,
			);
			return instantiateTypeWithSingleGenericCallSignature(
				node,
				uninstantiatedType,
				checkMode,
			);
		}
		function instantiateTypeWithSingleGenericCallSignature(
			node,
			type,
			checkMode,
		) {
			if (
				checkMode && checkMode & (2 | 8) /* Inferential */ /* SkipGenericFunctions */
			) {
				var callSignature = getSingleSignature(
					type,
					SignatureKind.Call, /*allowMembers*/
					true,
				);
				var constructSignature = getSingleSignature(
					type,
					SignatureKind.Construct, /*allowMembers*/
					true,
				);
				var signature = callSignature || constructSignature;
				if (signature && signature.typeParameters) {
					var contextualType = getApparentTypeOfContextualType(
						node,
						ContextFlags.NoConstraints,
					);
					if (contextualType) {
						var contextualSignature = getSingleSignature(
							getNonNullableType(contextualType),
							callSignature ? SignatureKind.Call : SignatureKind.Construct, /*allowMembers*/
							false,
						);
						if (contextualSignature && !contextualSignature.typeParameters) {
							if (checkMode & 8 /* SkipGenericFunctions */ ) {
								skippedGenericFunction(node, checkMode);
								return anyFunctionType;
							}
							var context = getInferenceContext(node);
							// We have an expression that is an argument of a generic function for which we are performing
							// type argument inference. The expression is of a function type with a single generic call
							// signature and a contextual function type with a single non-generic call signature. Now check
							// if the outer function returns a function type with a single non-generic call signature and
							// if some of the outer function type parameters have no inferences so far. If so, we can
							// potentially add inferred type parameters to the outer function return type.
							var returnType = context.signature && getReturnTypeOfSignature(
								context.signature,
							);
							var returnSignature = returnType && getSingleCallOrConstructSignature(
								returnType,
							);
							if (
								returnSignature && !returnSignature.typeParameters && !every(
									context.inferences,
									hasInferenceCandidates,
								)
							) {
								// Instantiate the signature with its own type parameters as type arguments, possibly
								// renaming the type parameters to ensure they have unique names.
								var uniqueTypeParameters = getUniqueTypeParameters(
									context,
									signature.typeParameters,
								);
								var instantiatedSignature = getSignatureInstantiationWithoutFillingInTypeArguments(
									signature,
									uniqueTypeParameters,
								);
								// Infer from the parameters of the instantiated signature to the parameters of the
								// contextual signature starting with an empty set of inference candidates.
								var inferences_3 = map(
									context.inferences,
									function (info) {
										return createInferenceInfo(info.typeParameter);
									},
								);
								applyToParameterTypes(
									instantiatedSignature,
									contextualSignature,
									function (source, target) {
										inferTypes(
											inferences_3,
											source,
											target, /*priority*/
											0, /*contravariant*/
											true,
										);
									},
								);
								if (some(inferences_3, hasInferenceCandidates)) {
									// We have inference candidates, indicating that one or more type parameters are referenced
									// in the parameter types of the contextual signature. Now also infer from the return type.
									applyToReturnTypes(
										instantiatedSignature,
										contextualSignature,
										function (source, target) {
											inferTypes(inferences_3, source, target);
										},
									);
									// If the type parameters for which we produced candidates do not have any inferences yet,
									// we adopt the new inference candidates and add the type parameters of the expression type
									// to the set of inferred type parameters for the outer function return type.
									if (
										!hasOverlappingInferences(context.inferences, inferences_3)
									) {
										mergeInferences(context.inferences, inferences_3);
										context.inferredTypeParameters = concatenate(
											context.inferredTypeParameters,
											uniqueTypeParameters,
										);
										return getOrCreateTypeFromSignature(instantiatedSignature);
									}
								}
							}
							return getOrCreateTypeFromSignature(
								instantiateSignatureInContextOf(
									signature,
									contextualSignature,
									context,
								),
							);
						}
					}
				}
			}
			return type;
		}
		function skippedGenericFunction(node, checkMode) {
			if (checkMode & 2 /* Inferential */ ) {
				// We have skipped a generic function during inferential typing. Obtain the inference context and
				// indicate this has occurred such that we know a second pass of inference is be needed.
				var context = getInferenceContext(node);
				context.flags |= InferenceFlags.SkippedGenericFunction;
			}
		}
		function hasInferenceCandidates(info) {
			return !!(info.candidates || info.contraCandidates);
		}
		function hasOverlappingInferences(a, b) {
			for (var i = 0; i < a.length; i++) {
				if (hasInferenceCandidates(a[i]) && hasInferenceCandidates(b[i])) {
					return true;
				}
			}
			return false;
		}
		function mergeInferences(target, source) {
			for (var i = 0; i < target.length; i++) {
				if (
					!hasInferenceCandidates(target[i]) && hasInferenceCandidates(
						source[i],
					)
				) {
					target[i] = source[i];
				}
			}
		}
		function getUniqueTypeParameters(context, typeParameters) {
			var result = [];
			var oldTypeParameters;
			var newTypeParameters;
			for (
				var _i = 0, typeParameters_2 = typeParameters;
				_i < typeParameters_2.length;
				_i++
			) {
				var tp = typeParameters_2[_i];
				var name_26 = tp.symbol.escapedName;
				if (
					hasTypeParameterByName(context.inferredTypeParameters, name_26) || hasTypeParameterByName(
						result,
						name_26,
					)
				) {
					var newName = getUniqueTypeParameterName(
						concatenate(context.inferredTypeParameters, result),
						name_26,
					);
					var symbol = createSymbol(SymbolFlags.TypeParameter, newName);
					var newTypeParameter = createTypeParameter(symbol);
					newTypeParameter.target = tp;
					oldTypeParameters = append(oldTypeParameters, tp);
					newTypeParameters = append(newTypeParameters, newTypeParameter);
					result.push(newTypeParameter);
				} else {
					result.push(tp);
				}
			}
			if (newTypeParameters) {
				var mapper = createTypeMapper(oldTypeParameters, newTypeParameters);
				for (
					var _a = 0, newTypeParameters_1 = newTypeParameters;
					_a < newTypeParameters_1.length;
					_a++
				) {
					var tp = newTypeParameters_1[_a];
					tp.mapper = mapper;
				}
			}
			return result;
		}
		function hasTypeParameterByName(typeParameters, name) {
			return some(
				typeParameters,
				function (tp) {
					return tp.symbol.escapedName === name;
				},
			);
		}
		function getUniqueTypeParameterName(typeParameters, baseName) {
			var len = baseName.length;
			while (
				len > 1 && baseName.charCodeAt(len - 1) >= CharacterCodes._0 && baseName.charCodeAt(
					len - 1,
				) <= CharacterCodes._9
			) len--;
			var s = baseName.slice(0, len);
			for (var index = 1; true; index++) {
				var augmentedName = s + index;
				if (!hasTypeParameterByName(typeParameters, augmentedName)) {
					return augmentedName;
				}
			}
		}
		function getReturnTypeOfSingleNonGenericCallSignature(funcType) {
			var signature = getSingleCallSignature(funcType);
			if (signature && !signature.typeParameters) {
				return getReturnTypeOfSignature(signature);
			}
		}
		function getReturnTypeOfSingleNonGenericSignatureOfCallChain(expr) {
			var funcType = checkExpression(expr.expression);
			var nonOptionalType = getOptionalExpressionType(funcType, expr.expression);
			var returnType = getReturnTypeOfSingleNonGenericCallSignature(funcType);
			return returnType && propagateOptionalTypeMarker(
				returnType,
				expr,
				nonOptionalType !== funcType,
			);
		}
		/**
         * Returns the type of an expression. Unlike checkExpression, this function is simply concerned
         * with computing the type and may not fully check all contained sub-expressions for errors.
         */
		function getTypeOfExpression(node) {
			// Don't bother caching types that require no flow analysis and are quick to compute.
			var quickType = getQuickTypeOfExpression(node);
			if (quickType) {
				return quickType;
			}
			// If a type has been cached for the node, return it.
			if (node.flags & NodeFlags.TypeCached && flowTypeCache) {
				var cachedType = flowTypeCache[getNodeId(node)];
				if (cachedType) {
					return cachedType;
				}
			}
			var startInvocationCount = flowInvocationCount;
			var type = checkExpression(node);
			// If control flow analysis was required to determine the type, it is worth caching.
			if (flowInvocationCount !== startInvocationCount) {
				var cache = flowTypeCache || (flowTypeCache = []);
				cache[getNodeId(node)] = type;
				setNodeFlags(node, node.flags | NodeFlags.TypeCached);
			}
			return type;
		}
		function getQuickTypeOfExpression(node) {
			var expr = skipParentheses(node, /*excludeJSDocTypeAssertions*/ true);
			if (isJSDocTypeAssertion(expr)) {
				var type = getJSDocTypeAssertionType(expr);
				if (!isConstTypeReference(type)) {
					return getTypeFromTypeNode(type);
				}
			}
			expr = skipParentheses(node);
			// Optimize for the common case of a call to a function with a single non-generic call
			// signature where we can just fetch the return type without checking the arguments.
			if (
				isCallExpression(expr) && expr.expression.kind !== SyntaxKind.SuperKeyword && !isRequireCall(
					expr, /*checkArgumentIsStringLiteralLike*/
					true,
				) && !isSymbolOrSymbolForCall(expr)
			) {
				var type = isCallChain(expr) ? getReturnTypeOfSingleNonGenericSignatureOfCallChain(
					expr,
				) : getReturnTypeOfSingleNonGenericCallSignature(
					checkNonNullExpression(expr.expression),
				);
				if (type) {
					return type;
				}
			} else if (
				isAssertionExpression(expr) && !isConstTypeReference(expr.type)
			) {
				return getTypeFromTypeNode(expr.type);
			} else if (
				node.kind === SyntaxKind.NumericLiteral || node.kind === SyntaxKind.StringLiteral || node.kind === SyntaxKind.TrueKeyword || node.kind === SyntaxKind.FalseKeyword
			) {
				return checkExpression(node);
			}
			return undefined;
		}
		/**
         * Returns the type of an expression. Unlike checkExpression, this function is simply concerned
         * with computing the type and may not fully check all contained sub-expressions for errors.
         * It is intended for uses where you know there is no contextual type,
         * and requesting the contextual type might cause a circularity or other bad behaviour.
         * It sets the contextual type of the node to any before calling getTypeOfExpression.
         */
		function getContextFreeTypeOfExpression(node) {
			var links = getNodeLinks(node);
			if (links.contextFreeType) {
				return links.contextFreeType;
			}
			var saveContextualType = node.contextualType;
			node.contextualType = anyType;
			try {
				var type = links.contextFreeType = checkExpression(
					node,
					4, /* SkipContextSensitive */
				);
				return type;
			} finally {
				// In the event our operation is canceled or some other exception occurs, reset the contextual type
				// so that we do not accidentally hold onto an instance of the checker, as a Type created in the services layer
				// may hold onto the checker that created it.
				node.contextualType = saveContextualType;
			}
		}
		function checkExpression(node, checkMode, forceTuple) {
			tracing === null || tracing === void 0 ? void 0 : tracing.push(
				tracing.Phase.Check,
				"checkExpression",
				{ kind: node.kind, pos: node.pos, end: node.end },
			);
			var saveCurrentNode = currentNode;
			currentNode = node;
			instantiationCount = 0;
			var uninstantiatedType = checkExpressionWorker(
				node,
				checkMode,
				forceTuple,
			);
			var type = instantiateTypeWithSingleGenericCallSignature(
				node,
				uninstantiatedType,
				checkMode,
			);
			if (isConstEnumObjectType(type)) {
				checkConstEnumAccess(node, type);
			}
			currentNode = saveCurrentNode;
			tracing === null || tracing === void 0 ? void 0 : tracing.pop();
			return type;
		}
		function checkConstEnumAccess(node, type) {
			// enum object type for const enums are only permitted in:
			// - 'left' in property access
			// - 'object' in indexed access
			// - target in rhs of import statement
			var ok = (node.parent.kind === SyntaxKind.PropertyAccessExpression && node.parent.expression === node) || (node.parent.kind === SyntaxKind.ElementAccessExpression && node.parent.expression === node) || ((node.kind === SyntaxKind.Identifier || node.kind === SyntaxKind.QualifiedName) && isInRightSideOfImportOrExportAssignment(
				node,
			) || (node.parent.kind === SyntaxKind.TypeQuery && node.parent.exprName === node)) || (node.parent.kind === SyntaxKind.ExportSpecifier); // We allow reexporting const enums
			if (!ok) {
				error(
					node,
					Diagnostics.const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment_or_type_query,
				);
			}
			if (compilerOptions.isolatedModules) {
				Debug.assert(!!(type.symbol.flags & SymbolFlags.ConstEnum));
				var constEnumDeclaration = type.symbol.valueDeclaration;
				if (constEnumDeclaration.flags & NodeFlags.Ambient) {
					error(
						node,
						Diagnostics.Cannot_access_ambient_const_enums_when_the_isolatedModules_flag_is_provided,
					);
				}
			}
		}
		function checkParenthesizedExpression(node, checkMode) {
			if (hasJSDocNodes(node) && isJSDocTypeAssertion(node)) {
				var type = getJSDocTypeAssertionType(node);
				return checkAssertionWorker(type, type, node.expression, checkMode);
			}
			return checkExpression(node.expression, checkMode);
		}
		function checkExpressionWorker(node, checkMode, forceTuple) {
			var kind = node.kind;
			if (cancellationToken) {
				// Only bother checking on a few construct kinds.  We don't want to be excessively
				// hitting the cancellation token on every node we check.
				switch (kind) {
					case SyntaxKind.ClassExpression:
					case SyntaxKind.FunctionExpression:
					case SyntaxKind.ArrowFunction:
						cancellationToken.throwIfCancellationRequested();
				}
			}
			switch (kind) {
				case SyntaxKind.Identifier:
					return checkIdentifier(node, checkMode);
				case SyntaxKind.PrivateIdentifier:
					return checkPrivateIdentifierExpression(node);
				case SyntaxKind.ThisKeyword:
					return checkThisExpression(node);
				case SyntaxKind.SuperKeyword:
					return checkSuperExpression(node);
				case SyntaxKind.NullKeyword:
					return nullWideningType;
				case SyntaxKind.NoSubstitutionTemplateLiteral:
				case SyntaxKind.StringLiteral:
					return getFreshTypeOfLiteralType(getStringLiteralType(node.text));
				case SyntaxKind.NumericLiteral:
					checkGrammarNumericLiteral(node);
					return getFreshTypeOfLiteralType(getNumberLiteralType(+node.text));
				case SyntaxKind.BigIntLiteral:
					checkGrammarBigIntLiteral(node);
					return getFreshTypeOfLiteralType(
						getBigIntLiteralType(
							{ negative: false, base10Value: parsePseudoBigInt(node.text) },
						),
					);
				case SyntaxKind.TrueKeyword:
					return trueType;
				case SyntaxKind.FalseKeyword:
					return falseType;
				case SyntaxKind.TemplateExpression:
					return checkTemplateExpression(node);
				case SyntaxKind.RegularExpressionLiteral:
					return globalRegExpType;
				case SyntaxKind.ArrayLiteralExpression:
					return checkArrayLiteral(node, checkMode, forceTuple);
				case SyntaxKind.ObjectLiteralExpression:
					return checkObjectLiteral(node, checkMode);
				case SyntaxKind.PropertyAccessExpression:
					return checkPropertyAccessExpression(node, checkMode);
				case SyntaxKind.QualifiedName:
					return checkQualifiedName(node, checkMode);
				case SyntaxKind.ElementAccessExpression:
					return checkIndexedAccess(node, checkMode);
				case SyntaxKind.CallExpression:
					if (node.expression.kind === SyntaxKind.ImportKeyword) {
						return checkImportCallExpression(node);
					}
				// falls through
				case SyntaxKind.NewExpression:
					return checkCallExpression(node, checkMode);
				case SyntaxKind.TaggedTemplateExpression:
					return checkTaggedTemplateExpression(node);
				case SyntaxKind.ParenthesizedExpression:
					return checkParenthesizedExpression(node, checkMode);
				case SyntaxKind.ClassExpression:
					return checkClassExpression(node);
				case SyntaxKind.FunctionExpression:
				case SyntaxKind.ArrowFunction:
					return checkFunctionExpressionOrObjectLiteralMethod(node, checkMode);
				case SyntaxKind.TypeOfExpression:
					return checkTypeOfExpression(node);
				case SyntaxKind.TypeAssertionExpression:
				case SyntaxKind.AsExpression:
					return checkAssertion(node);
				case SyntaxKind.NonNullExpression:
					return checkNonNullAssertion(node);
				case SyntaxKind.MetaProperty:
					return checkMetaProperty(node);
				case SyntaxKind.DeleteExpression:
					return checkDeleteExpression(node);
				case SyntaxKind.VoidExpression:
					return checkVoidExpression(node);
				case SyntaxKind.AwaitExpression:
					return checkAwaitExpression(node);
				case SyntaxKind.PrefixUnaryExpression:
					return checkPrefixUnaryExpression(node);
				case SyntaxKind.PostfixUnaryExpression:
					return checkPostfixUnaryExpression(node);
				case SyntaxKind.BinaryExpression:
					return checkBinaryExpression(node, checkMode);
				case SyntaxKind.ConditionalExpression:
					return checkConditionalExpression(node, checkMode);
				case SyntaxKind.SpreadElement:
					return checkSpreadExpression(node, checkMode);
				case SyntaxKind.OmittedExpression:
					return undefinedWideningType;
				case SyntaxKind.YieldExpression:
					return checkYieldExpression(node);
				case SyntaxKind.SyntheticExpression:
					return checkSyntheticExpression(node);
				case SyntaxKind.JsxExpression:
					return checkJsxExpression(node, checkMode);
				case SyntaxKind.JsxElement:
					return checkJsxElement(node, checkMode);
				case SyntaxKind.JsxSelfClosingElement:
					return checkJsxSelfClosingElement(node, checkMode);
				case SyntaxKind.JsxFragment:
					return checkJsxFragment(node);
				case SyntaxKind.JsxAttributes:
					return checkJsxAttributes(node, checkMode);
				case SyntaxKind.JsxOpeningElement:
					Debug.fail("Shouldn't ever directly check a JsxOpeningElement");
			}
			return errorType;
		}
		// DECLARATION AND STATEMENT TYPE CHECKING
		function checkTypeParameter(node) {
			// Grammar Checking
			if (node.expression) {
				grammarErrorOnFirstToken(node.expression, Diagnostics.Type_expected);
			}
			checkSourceElement(node.constraint);
			checkSourceElement(node["default"]);
			var typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfNode(node));
			// Resolve base constraint to reveal circularity errors
			getBaseConstraintOfType(typeParameter);
			if (!hasNonCircularTypeParameterDefault(typeParameter)) {
				error(
					node["default"],
					Diagnostics.Type_parameter_0_has_a_circular_default,
					typeToString(typeParameter),
				);
			}
			var constraintType = getConstraintOfTypeParameter(typeParameter);
			var defaultType = getDefaultFromTypeParameter(typeParameter);
			if (constraintType && defaultType) {
				checkTypeAssignableTo(
					defaultType,
					getTypeWithThisArgument(
						instantiateType(
							constraintType,
							makeUnaryTypeMapper(typeParameter, defaultType),
						),
						defaultType,
					),
					node["default"],
					Diagnostics.Type_0_does_not_satisfy_the_constraint_1,
				);
			}
			if (produceDiagnostics) {
				checkTypeNameIsReserved(
					node.name,
					Diagnostics.Type_parameter_name_cannot_be_0,
				);
			}
		}
		function checkParameter(node) {
			// Grammar checking
			// It is a SyntaxError if the Identifier "eval" or the Identifier "arguments" occurs as the
			// Identifier in a PropertySetParameterList of a PropertyAssignment that is contained in strict code
			// or if its FunctionBody is strict code(11.1.5).
			checkGrammarDecoratorsAndModifiers(node);
			checkVariableLikeDeclaration(node);
			var func = getContainingFunction(node);
			if (hasSyntacticModifier(node, ModifierFlags.ParameterPropertyModifier)) {
				if (!(func.kind === SyntaxKind.Constructor && nodeIsPresent(func.body))) {
					error(
						node,
						Diagnostics.A_parameter_property_is_only_allowed_in_a_constructor_implementation,
					);
				}
				if (
					func.kind === SyntaxKind.Constructor && isIdentifier(node.name) && node.name.escapedText === "constructor"
				) {
					error(
						node.name,
						Diagnostics.constructor_cannot_be_used_as_a_parameter_property_name,
					);
				}
			}
			if (node.questionToken && isBindingPattern(node.name) && func.body) {
				error(
					node,
					Diagnostics.A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature,
				);
			}
			if (
				node.name && isIdentifier(node.name) && (node.name.escapedText === "this" || node.name.escapedText === "new")
			) {
				if (func.parameters.indexOf(node) !== 0) {
					error(
						node,
						Diagnostics.A_0_parameter_must_be_the_first_parameter,
						node.name.escapedText,
					);
				}
				if (
					func.kind === SyntaxKind.Constructor || func.kind === SyntaxKind.ConstructSignature || func.kind === SyntaxKind.ConstructorType
				) {
					error(node, Diagnostics.A_constructor_cannot_have_a_this_parameter);
				}
				if (func.kind === SyntaxKind.ArrowFunction) {
					error(
						node,
						Diagnostics.An_arrow_function_cannot_have_a_this_parameter,
					);
				}
				if (
					func.kind === SyntaxKind.GetAccessor || func.kind === SyntaxKind.SetAccessor
				) {
					error(
						node,
						Diagnostics.get_and_set_accessors_cannot_declare_this_parameters,
					);
				}
			}
			// Only check rest parameter type if it's not a binding pattern. Since binding patterns are
			// not allowed in a rest parameter, we already have an error from checkGrammarParameterList.
			if (
				node.dotDotDotToken && !isBindingPattern(node.name) && !isTypeAssignableTo(
					getReducedType(getTypeOfSymbol(node.symbol)),
					anyReadonlyArrayType,
				)
			) {
				error(node, Diagnostics.A_rest_parameter_must_be_of_an_array_type);
			}
		}
		function checkTypePredicate(node) {
			var parent = getTypePredicateParent(node);
			if (!parent) {
				// The parent must not be valid.
				error(
					node,
					Diagnostics.A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods,
				);
				return;
			}
			var signature = getSignatureFromDeclaration(parent);
			var typePredicate = getTypePredicateOfSignature(signature);
			if (!typePredicate) {
				return;
			}
			checkSourceElement(node.type);
			var parameterName = node.parameterName;
			if (
				typePredicate.kind === TypePredicateKind.This || typePredicate.kind === TypePredicateKind.AssertsThis
			) {
				getTypeFromThisTypeNode(parameterName);
			} else {
				if (typePredicate.parameterIndex >= 0) {
					if (
						signatureHasRestParameter(signature) && typePredicate.parameterIndex === signature.parameters.length - 1
					) {
						error(
							parameterName,
							Diagnostics.A_type_predicate_cannot_reference_a_rest_parameter,
						);
					} else {
						if (typePredicate.type) {
							var leadingError = function () {
								return chainDiagnosticMessages(
									undefined, /*details*/
									Diagnostics.A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type,
								);
							};
							checkTypeAssignableTo(
								typePredicate.type,
								getTypeOfSymbol(
									signature.parameters[typePredicate.parameterIndex],
								),
								node.type,
								/*headMessage*/ undefined,
								leadingError,
							);
						}
					}
				} else if (parameterName) {
					var hasReportedError = false;
					for (var _i = 0, _a = parent.parameters; _i < _a.length; _i++) {
						var name_27 = _a[_i].name;
						if (
							isBindingPattern(name_27) && checkIfTypePredicateVariableIsDeclaredInBindingPattern(
								name_27,
								parameterName,
								typePredicate.parameterName,
							)
						) {
							hasReportedError = true;
							break;
						}
					}
					if (!hasReportedError) {
						error(
							node.parameterName,
							Diagnostics.Cannot_find_parameter_0,
							typePredicate.parameterName,
						);
					}
				}
			}
		}
		function getTypePredicateParent(node) {
			switch (node.parent.kind) {
				case SyntaxKind.ArrowFunction:
				case SyntaxKind.CallSignature:
				case SyntaxKind.FunctionDeclaration:
				case SyntaxKind.FunctionExpression:
				case SyntaxKind.FunctionType:
				case SyntaxKind.MethodDeclaration:
				case SyntaxKind.MethodSignature:
					var parent_16 = node.parent;
					if (node === parent_16.type) {
						return parent_16;
					}
			}
		}
		function checkIfTypePredicateVariableIsDeclaredInBindingPattern(
			pattern,
			predicateVariableNode,
			predicateVariableName,
		) {
			for (var _i = 0, _a = pattern.elements; _i < _a.length; _i++) {
				var element = _a[_i];
				if (isOmittedExpression(element)) {
					continue;
				}
				var name_28 = element.name;
				if (
					name_28.kind === SyntaxKind.Identifier && name_28.escapedText === predicateVariableName
				) {
					error(
						predicateVariableNode,
						Diagnostics.A_type_predicate_cannot_reference_element_0_in_a_binding_pattern,
						predicateVariableName,
					);
					return true;
				} else if (
					name_28.kind === SyntaxKind.ArrayBindingPattern || name_28.kind === SyntaxKind.ObjectBindingPattern
				) {
					if (
						checkIfTypePredicateVariableIsDeclaredInBindingPattern(
							name_28,
							predicateVariableNode,
							predicateVariableName,
						)
					) {
						return true;
					}
				}
			}
		}
		function checkSignatureDeclaration(node) {
			// Grammar checking
			if (node.kind === SyntaxKind.IndexSignature) {
				checkGrammarIndexSignature(node);
			} else if (
				node.kind === SyntaxKind.FunctionType || node.kind === SyntaxKind.FunctionDeclaration || node.kind === SyntaxKind.ConstructorType || node.kind === SyntaxKind.CallSignature || node.kind === SyntaxKind.Constructor || node.kind === SyntaxKind.ConstructSignature // TODO (yuisu): Remove this check in else-if when SyntaxKind.Construct is moved and ambient context is handled
			) {
				checkGrammarFunctionLikeDeclaration(node);
			}
			var functionFlags = getFunctionFlags(node);
			if (!(functionFlags & FunctionFlags.Invalid)) {
				// Async generators prior to ESNext require the __await and __asyncGenerator helpers
				if (
					(functionFlags & FunctionFlags.AsyncGenerator) === FunctionFlags.AsyncGenerator && languageVersion < ScriptTarget.ESNext
				) {
					checkExternalEmitHelpers(
						node,
						ExternalEmitHelpers.AsyncGeneratorIncludes,
					);
				}
				// Async functions prior to ES2017 require the __awaiter helper
				if (
					(functionFlags & FunctionFlags.AsyncGenerator) === FunctionFlags.Async && languageVersion < ScriptTarget.ES2017
				) {
					checkExternalEmitHelpers(node, ExternalEmitHelpers.Awaiter);
				}
				// Generator functions, Async functions, and Async Generator functions prior to
				// ES2015 require the __generator helper
				if (
					(functionFlags & FunctionFlags.AsyncGenerator) !== FunctionFlags.Normal && languageVersion < ScriptTarget.ES2015
				) {
					checkExternalEmitHelpers(node, ExternalEmitHelpers.Generator);
				}
			}
			checkTypeParameters(getEffectiveTypeParameterDeclarations(node));
			forEach(node.parameters, checkParameter);
			// TODO(rbuckton): Should we start checking JSDoc types?
			if (node.type) {
				checkSourceElement(node.type);
			}
			if (produceDiagnostics) {
				checkCollisionWithArgumentsInGeneratedCode(node);
				var returnTypeNode = getEffectiveReturnTypeNode(node);
				if (noImplicitAny && !returnTypeNode) {
					switch (node.kind) {
						case SyntaxKind.ConstructSignature:
							error(
								node,
								Diagnostics.Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type,
							);
							break;
						case SyntaxKind.CallSignature:
							error(
								node,
								Diagnostics.Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type,
							);
							break;
					}
				}
				if (returnTypeNode) {
					var functionFlags_1 = getFunctionFlags(node);
					if (
						(functionFlags_1 & (FunctionFlags.Invalid | FunctionFlags.Generator)) === FunctionFlags.Generator
					) {
						var returnType = getTypeFromTypeNode(returnTypeNode);
						if (returnType === voidType) {
							error(
								returnTypeNode,
								Diagnostics.A_generator_cannot_have_a_void_type_annotation,
							);
						} else {
							// Naively, one could check that Generator<any, any, any> is assignable to the return type annotation.
							// However, that would not catch the error in the following case.
							//
							//    interface BadGenerator extends Iterable<number>, Iterator<string> { }
							//    function* g(): BadGenerator { } // Iterable and Iterator have different types!
							//
							var generatorYieldType = getIterationTypeOfGeneratorFunctionReturnType(
								0, /* Yield */
								returnType,
								(functionFlags_1 & FunctionFlags.Async) !== 0,
							) || anyType;
							var generatorReturnType = getIterationTypeOfGeneratorFunctionReturnType(
								1, /* Return */
								returnType,
								(functionFlags_1 & FunctionFlags.Async) !== 0,
							) || generatorYieldType;
							var generatorNextType = getIterationTypeOfGeneratorFunctionReturnType(
								2, /* Next */
								returnType,
								(functionFlags_1 & FunctionFlags.Async) !== 0,
							) || unknownType;
							var generatorInstantiation = createGeneratorReturnType(
								generatorYieldType,
								generatorReturnType,
								generatorNextType,
								!!(functionFlags_1 & FunctionFlags.Async),
							);
							checkTypeAssignableTo(
								generatorInstantiation,
								returnType,
								returnTypeNode,
							);
						}
					} else if (
						(functionFlags_1 & FunctionFlags.AsyncGenerator) === FunctionFlags.Async
					) {
						checkAsyncFunctionReturnType(node, returnTypeNode);
					}
				}
				if (
					node.kind !== SyntaxKind.IndexSignature && node.kind !== SyntaxKind.JSDocFunctionType
				) {
					registerForUnusedIdentifiersCheck(node);
				}
			}
		}
		function checkClassForDuplicateDeclarations(node) {
			var instanceNames = new Map();
			var staticNames = new Map();
			// instance and static private identifiers share the same scope
			var privateIdentifiers = new Map();
			for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
				var member = _a[_i];
				if (member.kind === SyntaxKind.Constructor) {
					for (var _b = 0, _c = member.parameters; _b < _c.length; _b++) {
						var param = _c[_b];
						if (
							isParameterPropertyDeclaration(param, member) && !isBindingPattern(
								param.name,
							)
						) {
							addName(
								instanceNames,
								param.name,
								param.name.escapedText,
								3, /* GetOrSetAccessor */
							);
						}
					}
				} else {
					var isStaticMember = isStatic(member);
					var name_29 = member.name;
					if (!name_29) {
						continue;
					}
					var isPrivate = isPrivateIdentifier(name_29);
					var privateStaticFlags = isPrivate && isStaticMember ? 16 : 0; /* PrivateStatic */
					var names = isPrivate ? privateIdentifiers : isStaticMember ? staticNames : instanceNames;
					var memberName = name_29 && getPropertyNameForPropertyNameNode(
						name_29,
					);
					if (memberName) {
						switch (member.kind) {
							case SyntaxKind.GetAccessor:
								addName(
									names,
									name_29,
									memberName,
									1 | privateStaticFlags, /* GetAccessor */
								);
								break;
							case SyntaxKind.SetAccessor:
								addName(
									names,
									name_29,
									memberName,
									2 | privateStaticFlags, /* SetAccessor */
								);
								break;
							case SyntaxKind.PropertyDeclaration:
								addName(
									names,
									name_29,
									memberName,
									3 | privateStaticFlags, /* GetOrSetAccessor */
								);
								break;
							case SyntaxKind.MethodDeclaration:
								addName(
									names,
									name_29,
									memberName,
									8 | privateStaticFlags, /* Method */
								);
								break;
						}
					}
				}
			}
			function addName(names, location, name, meaning) {
				var prev = names.get(name);
				if (prev) {
					// For private identifiers, do not allow mixing of static and instance members with the same name
					if (
						(prev & 16) !== (meaning & 16) /* PrivateStatic */ /* PrivateStatic */
					) {
						error(
							location,
							Diagnostics.Duplicate_identifier_0_Static_and_instance_elements_cannot_share_the_same_private_name,
							getTextOfNode(location),
						);
					} else {
						var prevIsMethod = !!(prev & 8 /* Method */ );
						var isMethod = !!(meaning & 8 /* Method */ );
						if (prevIsMethod || isMethod) {
							if (prevIsMethod !== isMethod) {
								error(
									location,
									Diagnostics.Duplicate_identifier_0,
									getTextOfNode(location),
								);
							} // If this is a method/method duplication is might be an overload, so this will be handled when overloads are considered
						} else if (prev & meaning & ~16 /* PrivateStatic */ ) {
							error(
								location,
								Diagnostics.Duplicate_identifier_0,
								getTextOfNode(location),
							);
						} else {
							names.set(name, prev | meaning);
						}
					}
				} else {
					names.set(name, meaning);
				}
			}
		}
		/**
         * Static members being set on a constructor function may conflict with built-in properties
         * of Function. Esp. in ECMAScript 5 there are non-configurable and non-writable
         * built-in properties. This check issues a transpile error when a class has a static
         * member with the same name as a non-writable built-in property.
         *
         * @see http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.3
         * @see http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.5
         * @see http://www.ecma-international.org/ecma-262/6.0/#sec-properties-of-the-function-constructor
         * @see http://www.ecma-international.org/ecma-262/6.0/#sec-function-instances
         */
		function checkClassForStaticPropertyNameConflicts(node) {
			for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
				var member = _a[_i];
				var memberNameNode = member.name;
				var isStaticMember = isStatic(member);
				if (isStaticMember && memberNameNode) {
					var memberName = getPropertyNameForPropertyNameNode(memberNameNode);
					switch (memberName) {
						case "name":
						case "length":
						case "caller":
						case "arguments":
						case "prototype":
							var message = Diagnostics.Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1;
							var className = getNameOfSymbolAsWritten(getSymbolOfNode(node));
							error(memberNameNode, message, memberName, className);
							break;
					}
				}
			}
		}
		function checkObjectTypeForDuplicateDeclarations(node) {
			var names = new Map();
			for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
				var member = _a[_i];
				if (member.kind === SyntaxKind.PropertySignature) {
					var memberName = void 0;
					var name_30 = member.name;
					switch (name_30.kind) {
						case SyntaxKind.StringLiteral:
						case SyntaxKind.NumericLiteral:
							memberName = name_30.text;
							break;
						case SyntaxKind.Identifier:
							memberName = idText(name_30);
							break;
						default:
							continue;
					}
					if (names.get(memberName)) {
						error(
							getNameOfDeclaration(member.symbol.valueDeclaration),
							Diagnostics.Duplicate_identifier_0,
							memberName,
						);
						error(member.name, Diagnostics.Duplicate_identifier_0, memberName);
					} else {
						names.set(memberName, true);
					}
				}
			}
		}
		function checkTypeForDuplicateIndexSignatures(node) {
			if (node.kind === SyntaxKind.InterfaceDeclaration) {
				var nodeSymbol = getSymbolOfNode(node);
				// in case of merging interface declaration it is possible that we'll enter this check procedure several times for every declaration
				// to prevent this run check only for the first declaration of a given kind
				if (
					nodeSymbol.declarations && nodeSymbol.declarations.length > 0 && nodeSymbol.declarations[0] !== node
				) {
					return;
				}
			}
			// TypeScript 1.0 spec (April 2014)
			// 3.7.4: An object type can contain at most one string index signature and one numeric index signature.
			// 8.5: A class declaration can have at most one string index member declaration and one numeric index member declaration
			var indexSymbol = getIndexSymbol(getSymbolOfNode(node));
			if (
				indexSymbol === null || indexSymbol === void 0 ? void 0 : indexSymbol.declarations
			) {
				var indexSignatureMap_1 = new Map();
				var _loop_20 = function (declaration) {
					if (
						declaration.parameters.length === 1 && declaration.parameters[0].type
					) {
						forEachType(
							getTypeFromTypeNode(declaration.parameters[0].type),
							function (type) {
								var entry = indexSignatureMap_1.get(getTypeId(type));
								if (entry) {
									entry.declarations.push(declaration);
								} else {
									indexSignatureMap_1.set(
										getTypeId(type),
										{ type: type, declarations: [declaration] },
									);
								}
							},
						);
					}
				};
				for (var _i = 0, _a = indexSymbol.declarations; _i < _a.length; _i++) {
					var declaration = _a[_i];
					_loop_20(declaration);
				}
				indexSignatureMap_1.forEach(
					function (entry) {
						if (entry.declarations.length > 1) {
							for (var _i = 0, _a = entry.declarations; _i < _a.length; _i++) {
								var declaration = _a[_i];
								error(
									declaration,
									Diagnostics.Duplicate_index_signature_for_type_0,
									typeToString(entry.type),
								);
							}
						}
					},
				);
			}
		}
		function checkPropertyDeclaration(node) {
			// Grammar checking
			if (
				!checkGrammarDecoratorsAndModifiers(node) && !checkGrammarProperty(node)
			) checkGrammarComputedPropertyName(node.name);
			checkVariableLikeDeclaration(node);
			setNodeLinksForPrivateIdentifierScope(node);
			if (
				isPrivateIdentifier(node.name) && hasStaticModifier(node) && node.initializer && languageVersion === ScriptTarget.ESNext && !compilerOptions.useDefineForClassFields
			) {
				error(
					node.initializer,
					Diagnostics.Static_fields_with_private_names_can_t_have_initializers_when_the_useDefineForClassFields_flag_is_not_specified_with_a_target_of_esnext_Consider_adding_the_useDefineForClassFields_flag,
				);
			}
			// property signatures already report "initializer not allowed in ambient context" elsewhere
			if (
				hasSyntacticModifier(node, ModifierFlags.Abstract) && node.kind === SyntaxKind.PropertyDeclaration && node.initializer
			) {
				error(
					node,
					Diagnostics.Property_0_cannot_have_an_initializer_because_it_is_marked_abstract,
					declarationNameToString(node.name),
				);
			}
		}
		function checkPropertySignature(node) {
			if (isPrivateIdentifier(node.name)) {
				error(
					node,
					Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies,
				);
			}
			return checkPropertyDeclaration(node);
		}
		function checkMethodDeclaration(node) {
			// Grammar checking
			if (!checkGrammarMethod(node)) checkGrammarComputedPropertyName(node.name);
			// Grammar checking for modifiers is done inside the function checkGrammarFunctionLikeDeclaration
			checkFunctionOrMethodDeclaration(node);
			// method signatures already report "implementation not allowed in ambient context" elsewhere
			if (
				hasSyntacticModifier(node, ModifierFlags.Abstract) && node.kind === SyntaxKind.MethodDeclaration && node.body
			) {
				error(
					node,
					Diagnostics.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract,
					declarationNameToString(node.name),
				);
			}
			// Private named methods are only allowed in class declarations
			if (isPrivateIdentifier(node.name) && !getContainingClass(node)) {
				error(
					node,
					Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies,
				);
			}
			setNodeLinksForPrivateIdentifierScope(node);
		}
		function setNodeLinksForPrivateIdentifierScope(node) {
			if (
				isPrivateIdentifier(node.name) && languageVersion < ScriptTarget.ESNext
			) {
				for (
					var lexicalScope = getEnclosingBlockScopeContainer(node);
					!!lexicalScope;
					lexicalScope = getEnclosingBlockScopeContainer(lexicalScope)
				) {
					getNodeLinks(lexicalScope).flags |= NodeCheckFlags.ContainsClassWithPrivateIdentifiers;
				}
				// If this is a private element in a class expression inside the body of a loop,
				// then we must use a block-scoped binding to store the additional variables required
				// to transform private elements.
				if (isClassExpression(node.parent)) {
					var enclosingIterationStatement = getEnclosingIterationStatement(
						node.parent,
					);
					if (enclosingIterationStatement) {
						getNodeLinks(node.name).flags |= NodeCheckFlags.BlockScopedBindingInLoop;
						getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlags.LoopWithCapturedBlockScopedBinding;
					}
				}
			}
		}
		function checkClassStaticBlockDeclaration(node) {
			checkGrammarDecoratorsAndModifiers(node);
			forEachChild(node, checkSourceElement);
		}
		function checkConstructorDeclaration(node) {
			// Grammar check on signature of constructor and modifier of the constructor is done in checkSignatureDeclaration function.
			checkSignatureDeclaration(node);
			// Grammar check for checking only related to constructorDeclaration
			if (!checkGrammarConstructorTypeParameters(node)) checkGrammarConstructorTypeAnnotation(
				node,
			);
			checkSourceElement(node.body);
			var symbol = getSymbolOfNode(node);
			var firstDeclaration = getDeclarationOfKind(symbol, node.kind);
			// Only type check the symbol once
			if (node === firstDeclaration) {
				checkFunctionOrConstructorSymbol(symbol);
			}
			// exit early in the case of signature - super checks are not relevant to them
			if (nodeIsMissing(node.body)) {
				return;
			}
			if (!produceDiagnostics) {
				return;
			}
			function isInstancePropertyWithInitializerOrPrivateIdentifierProperty(n) {
				if (isPrivateIdentifierClassElementDeclaration(n)) {
					return true;
				}
				return n.kind === SyntaxKind.PropertyDeclaration && !isStatic(n) && !!n.initializer;
			}
			// TS 1.0 spec (April 2014): 8.3.2
			// Constructors of classes with no extends clause may not contain super calls, whereas
			// constructors of derived classes must contain at least one super call somewhere in their function body.
			var containingClassDecl = node.parent;
			if (getClassExtendsHeritageElement(containingClassDecl)) {
				captureLexicalThis(node.parent, containingClassDecl);
				var classExtendsNull = classDeclarationExtendsNull(containingClassDecl);
				var superCall = findFirstSuperCall(node.body);
				if (superCall) {
					if (classExtendsNull) {
						error(
							superCall,
							Diagnostics.A_constructor_cannot_contain_a_super_call_when_its_class_extends_null,
						);
					}
					// The first statement in the body of a constructor (excluding prologue directives) must be a super call
					// if both of the following are true:
					// - The containing class is a derived class.
					// - The constructor declares parameter properties
					//   or the containing class declares instance member variables with initializers.
					var superCallShouldBeFirst = (getEmitScriptTarget(compilerOptions) !== ScriptTarget.ESNext || !useDefineForClassFields) && (some(
						node.parent.members,
						isInstancePropertyWithInitializerOrPrivateIdentifierProperty,
					) || some(
						node.parameters,
						function (p) {
							return hasSyntacticModifier(
								p,
								ModifierFlags.ParameterPropertyModifier,
							);
						},
					));
					// Skip past any prologue directives to find the first statement
					// to ensure that it was a super call.
					if (superCallShouldBeFirst) {
						var statements = node.body.statements;
						var superCallStatement = void 0;
						for (
							var _i = 0, statements_1 = statements;
							_i < statements_1.length;
							_i++
						) {
							var statement = statements_1[_i];
							if (
								statement.kind === SyntaxKind.ExpressionStatement && isSuperCall(
									statement.expression,
								)
							) {
								superCallStatement = statement;
								break;
							}
							if (!isPrologueDirective(statement)) {
								break;
							}
						}
						if (!superCallStatement) {
							error(
								node,
								Diagnostics.A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_parameter_properties_or_private_identifiers,
							);
						}
					}
				} else if (!classExtendsNull) {
					error(
						node,
						Diagnostics.Constructors_for_derived_classes_must_contain_a_super_call,
					);
				}
			}
		}
		function checkAccessorDeclaration(node) {
			if (produceDiagnostics) {
				// Grammar checking accessors
				if (
					!checkGrammarFunctionLikeDeclaration(node) && !checkGrammarAccessor(
						node,
					)
				) checkGrammarComputedPropertyName(node.name);
				checkDecorators(node);
				checkSignatureDeclaration(node);
				if (node.kind === SyntaxKind.GetAccessor) {
					if (
						!(node.flags & NodeFlags.Ambient) && nodeIsPresent(node.body) && (node.flags & NodeFlags.HasImplicitReturn)
					) {
						if (!(node.flags & NodeFlags.HasExplicitReturn)) {
							error(node.name, Diagnostics.A_get_accessor_must_return_a_value);
						}
					}
				}
				// Do not use hasDynamicName here, because that returns false for well known symbols.
				// We want to perform checkComputedPropertyName for all computed properties, including
				// well known symbols.
				if (node.name.kind === SyntaxKind.ComputedPropertyName) {
					checkComputedPropertyName(node.name);
				}
				if (hasBindableName(node)) {
					// TypeScript 1.0 spec (April 2014): 8.4.3
					// Accessors for the same member name must specify the same accessibility.
					var symbol = getSymbolOfNode(node);
					var getter = getDeclarationOfKind(symbol, SyntaxKind.GetAccessor);
					var setter = getDeclarationOfKind(symbol, SyntaxKind.SetAccessor);
					if (
						getter && setter && !(getNodeCheckFlags(getter) & NodeCheckFlags.TypeChecked)
					) {
						getNodeLinks(getter).flags |= NodeCheckFlags.TypeChecked;
						var getterFlags = getEffectiveModifierFlags(getter);
						var setterFlags = getEffectiveModifierFlags(setter);
						if (
							(getterFlags & ModifierFlags.Abstract) !== (setterFlags & ModifierFlags.Abstract)
						) {
							error(
								getter.name,
								Diagnostics.Accessors_must_both_be_abstract_or_non_abstract,
							);
							error(
								setter.name,
								Diagnostics.Accessors_must_both_be_abstract_or_non_abstract,
							);
						}
						if (
							((getterFlags & ModifierFlags.Protected) && !(setterFlags & (ModifierFlags.Protected | ModifierFlags.Private))) || ((getterFlags & ModifierFlags.Private) && !(setterFlags & ModifierFlags.Private))
						) {
							error(
								getter.name,
								Diagnostics.A_get_accessor_must_be_at_least_as_accessible_as_the_setter,
							);
							error(
								setter.name,
								Diagnostics.A_get_accessor_must_be_at_least_as_accessible_as_the_setter,
							);
						}
						var getterType = getAnnotatedAccessorType(getter);
						var setterType = getAnnotatedAccessorType(setter);
						if (getterType && setterType) {
							checkTypeAssignableTo(
								getterType,
								setterType,
								getter,
								Diagnostics.The_return_type_of_a_get_accessor_must_be_assignable_to_its_set_accessor_type,
							);
						}
					}
				}
				var returnType = getTypeOfAccessors(getSymbolOfNode(node));
				if (node.kind === SyntaxKind.GetAccessor) {
					checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType);
				}
			}
			checkSourceElement(node.body);
			setNodeLinksForPrivateIdentifierScope(node);
		}
		function checkMissingDeclaration(node) {
			checkDecorators(node);
		}
		function getEffectiveTypeArguments(node, typeParameters) {
			return fillMissingTypeArguments(
				map(node.typeArguments, getTypeFromTypeNode),
				typeParameters,
				getMinTypeArgumentCount(typeParameters),
				isInJSFile(node),
			);
		}
		function checkTypeArgumentConstraints(node, typeParameters) {
			var typeArguments;
			var mapper;
			var result = true;
			for (var i = 0; i < typeParameters.length; i++) {
				var constraint = getConstraintOfTypeParameter(typeParameters[i]);
				if (constraint) {
					if (!typeArguments) {
						typeArguments = getEffectiveTypeArguments(node, typeParameters);
						mapper = createTypeMapper(typeParameters, typeArguments);
					}
					result = result && checkTypeAssignableTo(
						typeArguments[i],
						instantiateType(constraint, mapper),
						node.typeArguments[i],
						Diagnostics.Type_0_does_not_satisfy_the_constraint_1,
					);
				}
			}
			return result;
		}
		function getTypeParametersForTypeReference(node) {
			var type = getTypeFromTypeReference(node);
			if (!isErrorType(type)) {
				var symbol = getNodeLinks(node).resolvedSymbol;
				if (symbol) {
					return symbol.flags & SymbolFlags.TypeAlias && getSymbolLinks(symbol).typeParameters || (getObjectFlags(
						type,
					) & ObjectFlags.Reference ? type.target.localTypeParameters : undefined);
				}
			}
			return undefined;
		}
		function checkTypeReferenceNode(node) {
			checkGrammarTypeArguments(node, node.typeArguments);
			if (
				node.kind === SyntaxKind.TypeReference && node.typeName.jsdocDotPos !== undefined && !isInJSFile(
					node,
				) && !isInJSDoc(node)
			) {
				grammarErrorAtPos(
					node,
					node.typeName.jsdocDotPos,
					1,
					Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments,
				);
			}
			forEach(node.typeArguments, checkSourceElement);
			var type = getTypeFromTypeReference(node);
			if (!isErrorType(type)) {
				if (node.typeArguments && produceDiagnostics) {
					var typeParameters = getTypeParametersForTypeReference(node);
					if (typeParameters) {
						checkTypeArgumentConstraints(node, typeParameters);
					}
				}
				var symbol = getNodeLinks(node).resolvedSymbol;
				if (symbol) {
					if (
						some(
							symbol.declarations,
							function (d) {
								return isTypeDeclaration(d) && !!(d.flags & NodeFlags.Deprecated);
							},
						)
					) {
						addDeprecatedSuggestion(
							getDeprecatedSuggestionNode(node),
							symbol.declarations,
							symbol.escapedName,
						);
					}
					if (
						type.flags & TypeFlags.Enum && symbol.flags & SymbolFlags.EnumMember
					) {
						error(
							node,
							Diagnostics.Enum_type_0_has_members_with_initializers_that_are_not_literals,
							typeToString(type),
						);
					}
				}
			}
		}
		function getTypeArgumentConstraint(node) {
			var typeReferenceNode = tryCast(node.parent, isTypeReferenceType);
			if (!typeReferenceNode) return undefined;
			var typeParameters = getTypeParametersForTypeReference(typeReferenceNode);
			if (!typeParameters) return undefined;
			var constraint = getConstraintOfTypeParameter(
				typeParameters[typeReferenceNode.typeArguments.indexOf(node)],
			);
			return constraint && instantiateType(
				constraint,
				createTypeMapper(
					typeParameters,
					getEffectiveTypeArguments(typeReferenceNode, typeParameters),
				),
			);
		}
		function checkTypeQuery(node) {
			getTypeFromTypeQueryNode(node);
		}
		function checkTypeLiteral(node) {
			forEach(node.members, checkSourceElement);
			if (produceDiagnostics) {
				var type = getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node);
				checkIndexConstraints(type, type.symbol);
				checkTypeForDuplicateIndexSignatures(node);
				checkObjectTypeForDuplicateDeclarations(node);
			}
		}
		function checkArrayType(node) {
			checkSourceElement(node.elementType);
		}
		function checkTupleType(node) {
			var elementTypes = node.elements;
			var seenOptionalElement = false;
			var seenRestElement = false;
			var hasNamedElement = some(elementTypes, isNamedTupleMember);
			for (
				var _i = 0, elementTypes_1 = elementTypes;
				_i < elementTypes_1.length;
				_i++
			) {
				var e = elementTypes_1[_i];
				if (e.kind !== SyntaxKind.NamedTupleMember && hasNamedElement) {
					grammarErrorOnNode(
						e,
						Diagnostics.Tuple_members_must_all_have_names_or_all_not_have_names,
					);
					break;
				}
				var flags = getTupleElementFlags(e);
				if (flags & ElementFlags.Variadic) {
					var type = getTypeFromTypeNode(e.type);
					if (!isArrayLikeType(type)) {
						error(e, Diagnostics.A_rest_element_type_must_be_an_array_type);
						break;
					}
					if (
						isArrayType(type) || isTupleType(type) && type.target.combinedFlags & ElementFlags.Rest
					) {
						seenRestElement = true;
					}
				} else if (flags & ElementFlags.Rest) {
					if (seenRestElement) {
						grammarErrorOnNode(
							e,
							Diagnostics.A_rest_element_cannot_follow_another_rest_element,
						);
						break;
					}
					seenRestElement = true;
				} else if (flags & ElementFlags.Optional) {
					if (seenRestElement) {
						grammarErrorOnNode(
							e,
							Diagnostics.An_optional_element_cannot_follow_a_rest_element,
						);
						break;
					}
					seenOptionalElement = true;
				} else if (seenOptionalElement) {
					grammarErrorOnNode(
						e,
						Diagnostics.A_required_element_cannot_follow_an_optional_element,
					);
					break;
				}
			}
			forEach(node.elements, checkSourceElement);
			getTypeFromTypeNode(node);
		}
		function checkUnionOrIntersectionType(node) {
			forEach(node.types, checkSourceElement);
			getTypeFromTypeNode(node);
		}
		function checkIndexedAccessIndexType(type, accessNode) {
			if (!(type.flags & TypeFlags.IndexedAccess)) {
				return type;
			}
			// Check if the index type is assignable to 'keyof T' for the object type.
			var objectType = type.objectType;
			var indexType = type.indexType;
			if (
				isTypeAssignableTo(
					indexType,
					getIndexType(objectType, /*stringsOnly*/ false),
				)
			) {
				if (
					accessNode.kind === SyntaxKind.ElementAccessExpression && isAssignmentTarget(
						accessNode,
					) && getObjectFlags(objectType) & ObjectFlags.Mapped && getMappedTypeModifiers(
						objectType,
					) & 1 /* IncludeReadonly */
				) {
					error(
						accessNode,
						Diagnostics.Index_signature_in_type_0_only_permits_reading,
						typeToString(objectType),
					);
				}
				return type;
			}
			// Check if we're indexing with a numeric type and if either object or index types
			// is a generic type with a constraint that has a numeric index signature.
			var apparentObjectType = getApparentType(objectType);
			if (
				getIndexInfoOfType(apparentObjectType, numberType) && isTypeAssignableToKind(
					indexType,
					TypeFlags.NumberLike,
				)
			) {
				return type;
			}
			if (isGenericObjectType(objectType)) {
				var propertyName_1 = getPropertyNameFromIndex(indexType, accessNode);
				if (propertyName_1) {
					var propertySymbol = forEachType(
						apparentObjectType,
						function (t) {
							return getPropertyOfType(t, propertyName_1);
						},
					);
					if (
						propertySymbol && getDeclarationModifierFlagsFromSymbol(
							propertySymbol,
						) & ModifierFlags.NonPublicAccessibilityModifier
					) {
						error(
							accessNode,
							Diagnostics.Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter,
							unescapeLeadingUnderscores(propertyName_1),
						);
						return errorType;
					}
				}
			}
			error(
				accessNode,
				Diagnostics.Type_0_cannot_be_used_to_index_type_1,
				typeToString(indexType),
				typeToString(objectType),
			);
			return errorType;
		}
		function checkIndexedAccessType(node) {
			checkSourceElement(node.objectType);
			checkSourceElement(node.indexType);
			checkIndexedAccessIndexType(getTypeFromIndexedAccessTypeNode(node), node);
		}
		function checkMappedType(node) {
			checkGrammarMappedType(node);
			checkSourceElement(node.typeParameter);
			checkSourceElement(node.nameType);
			checkSourceElement(node.type);
			if (!node.type) {
				reportImplicitAny(node, anyType);
			}
			var type = getTypeFromMappedTypeNode(node);
			var nameType = getNameTypeFromMappedType(type);
			if (nameType) {
				checkTypeAssignableTo(nameType, keyofConstraintType, node.nameType);
			} else {
				var constraintType = getConstraintTypeFromMappedType(type);
				checkTypeAssignableTo(
					constraintType,
					keyofConstraintType,
					getEffectiveConstraintOfTypeParameter(node.typeParameter),
				);
			}
		}
		function checkGrammarMappedType(node) {
			var _a;
			if ((_a = node.members) === null || _a === void 0 ? void 0 : _a.length) {
				return grammarErrorOnNode(
					node.members[0],
					Diagnostics.A_mapped_type_may_not_declare_properties_or_methods,
				);
			}
		}
		function checkThisType(node) {
			getTypeFromThisTypeNode(node);
		}
		function checkTypeOperator(node) {
			checkGrammarTypeOperatorNode(node);
			checkSourceElement(node.type);
		}
		function checkConditionalType(node) {
			forEachChild(node, checkSourceElement);
		}
		function checkInferType(node) {
			if (
				!findAncestor(
					node,
					function (n) {
						return n.parent && n.parent.kind === SyntaxKind.ConditionalType && n.parent.extendsType === n;
					},
				)
			) {
				grammarErrorOnNode(
					node,
					Diagnostics.infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type,
				);
			}
			checkSourceElement(node.typeParameter);
			registerForUnusedIdentifiersCheck(node);
		}
		function checkTemplateLiteralType(node) {
			for (var _i = 0, _a = node.templateSpans; _i < _a.length; _i++) {
				var span = _a[_i];
				checkSourceElement(span.type);
				var type = getTypeFromTypeNode(span.type);
				checkTypeAssignableTo(type, templateConstraintType, span.type);
			}
			getTypeFromTypeNode(node);
		}
		function checkImportType(node) {
			checkSourceElement(node.argument);
			getTypeFromTypeNode(node);
		}
		function checkNamedTupleMember(node) {
			if (node.dotDotDotToken && node.questionToken) {
				grammarErrorOnNode(
					node,
					Diagnostics.A_tuple_member_cannot_be_both_optional_and_rest,
				);
			}
			if (node.type.kind === SyntaxKind.OptionalType) {
				grammarErrorOnNode(
					node.type,
					Diagnostics.A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_colon_rather_than_after_the_type,
				);
			}
			if (node.type.kind === SyntaxKind.RestType) {
				grammarErrorOnNode(
					node.type,
					Diagnostics.A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type,
				);
			}
			checkSourceElement(node.type);
			getTypeFromTypeNode(node);
		}
		function isPrivateWithinAmbient(node) {
			return (hasEffectiveModifier(node, ModifierFlags.Private) || isPrivateIdentifierClassElementDeclaration(
				node,
			)) && !!(node.flags & NodeFlags.Ambient);
		}
		function getEffectiveDeclarationFlags(n, flagsToCheck) {
			var flags = getCombinedModifierFlags(n);
			// children of classes (even ambient classes) should not be marked as ambient or export
			// because those flags have no useful semantics there.
			if (
				n.parent.kind !== SyntaxKind.InterfaceDeclaration && n.parent.kind !== SyntaxKind.ClassDeclaration && n.parent.kind !== SyntaxKind.ClassExpression && n.flags & NodeFlags.Ambient
			) {
				if (
					!(flags & ModifierFlags.Ambient) && !(isModuleBlock(n.parent) && isModuleDeclaration(
						n.parent.parent,
					) && isGlobalScopeAugmentation(n.parent.parent))
				) {
					// It is nested in an ambient context, which means it is automatically exported
					flags |= ModifierFlags.Export;
				}
				flags |= ModifierFlags.Ambient;
			}
			return flags & flagsToCheck;
		}
		function checkFunctionOrConstructorSymbol(symbol) {
			if (!produceDiagnostics) {
				return;
			}
			function getCanonicalOverload(overloads, implementation) {
				// Consider the canonical set of flags to be the flags of the bodyDeclaration or the first declaration
				// Error on all deviations from this canonical set of flags
				// The caveat is that if some overloads are defined in lib.d.ts, we don't want to
				// report the errors on those. To achieve this, we will say that the implementation is
				// the canonical signature only if it is in the same container as the first overload
				var implementationSharesContainerWithFirstOverload = implementation !== undefined && implementation.parent === overloads[0].parent;
				return implementationSharesContainerWithFirstOverload ? implementation : overloads[0];
			}
			function checkFlagAgreementBetweenOverloads(
				overloads,
				implementation,
				flagsToCheck,
				someOverloadFlags,
				allOverloadFlags,
			) {
				// Error if some overloads have a flag that is not shared by all overloads. To find the
				// deviations, we XOR someOverloadFlags with allOverloadFlags
				var someButNotAllOverloadFlags = someOverloadFlags ^ allOverloadFlags;
				if (someButNotAllOverloadFlags !== 0) {
					var canonicalFlags_1 = getEffectiveDeclarationFlags(
						getCanonicalOverload(overloads, implementation),
						flagsToCheck,
					);
					forEach(
						overloads,
						function (o) {
							var deviation = getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlags_1;
							if (deviation & ModifierFlags.Export) {
								error(
									getNameOfDeclaration(o),
									Diagnostics.Overload_signatures_must_all_be_exported_or_non_exported,
								);
							} else if (deviation & ModifierFlags.Ambient) {
								error(
									getNameOfDeclaration(o),
									Diagnostics.Overload_signatures_must_all_be_ambient_or_non_ambient,
								);
							} else if (
								deviation & (ModifierFlags.Private | ModifierFlags.Protected)
							) {
								error(
									getNameOfDeclaration(o) || o,
									Diagnostics.Overload_signatures_must_all_be_public_private_or_protected,
								);
							} else if (deviation & ModifierFlags.Abstract) {
								error(
									getNameOfDeclaration(o),
									Diagnostics.Overload_signatures_must_all_be_abstract_or_non_abstract,
								);
							}
						},
					);
				}
			}
			function checkQuestionTokenAgreementBetweenOverloads(
				overloads,
				implementation,
				someHaveQuestionToken,
				allHaveQuestionToken,
			) {
				if (someHaveQuestionToken !== allHaveQuestionToken) {
					var canonicalHasQuestionToken_1 = hasQuestionToken(
						getCanonicalOverload(overloads, implementation),
					);
					forEach(
						overloads,
						function (o) {
							var deviation = hasQuestionToken(o) !== canonicalHasQuestionToken_1;
							if (deviation) {
								error(
									getNameOfDeclaration(o),
									Diagnostics.Overload_signatures_must_all_be_optional_or_required,
								);
							}
						},
					);
				}
			}
			var flagsToCheck = ModifierFlags.Export | ModifierFlags.Ambient | ModifierFlags.Private | ModifierFlags.Protected | ModifierFlags.Abstract;
			var someNodeFlags = ModifierFlags.None;
			var allNodeFlags = flagsToCheck;
			var someHaveQuestionToken = false;
			var allHaveQuestionToken = true;
			var hasOverloads = false;
			var bodyDeclaration;
			var lastSeenNonAmbientDeclaration;
			var previousDeclaration;
			var declarations = symbol.declarations;
			var isConstructor = (symbol.flags & SymbolFlags.Constructor) !== 0;
			function reportImplementationExpectedError(node) {
				if (node.name && nodeIsMissing(node.name)) {
					return;
				}
				var seen = false;
				var subsequentNode = forEachChild(
					node.parent,
					function (c) {
						if (seen) {
							return c;
						} else {
							seen = c === node;
						}
					},
				);
				// We may be here because of some extra nodes between overloads that could not be parsed into a valid node.
				// In this case the subsequent node is not really consecutive (.pos !== node.end), and we must ignore it here.
				if (subsequentNode && subsequentNode.pos === node.end) {
					if (subsequentNode.kind === node.kind) {
						var errorNode_1 = subsequentNode.name || subsequentNode;
						var subsequentName = subsequentNode.name;
						if (
							node.name && subsequentName && (isPrivateIdentifier(node.name) && isPrivateIdentifier(
								subsequentName, // both are private identifiers
							) && node.name.escapedText === subsequentName.escapedText || isComputedPropertyName( // TODO: GH#17345: These are methods, so handle computed name case. (`Always allowing computed property names is *not* the correct behavior!) // Both are computed property names
								node.name,
							) && isComputedPropertyName(subsequentName) || isPropertyNameLiteral(
								node.name,
							) && isPropertyNameLiteral(
								subsequentName, // Both are literal property names that are the same.
							) && getEscapedTextOfIdentifierOrLiteral(node.name) === getEscapedTextOfIdentifierOrLiteral(
								subsequentName,
							))
						) {
							var reportError = (node.kind === SyntaxKind.MethodDeclaration || node.kind === SyntaxKind.MethodSignature) && isStatic(
								node,
							) !== isStatic(subsequentNode);
							// we can get here in two cases
							// 1. mixed static and instance class members
							// 2. something with the same name was defined before the set of overloads that prevents them from merging
							// here we'll report error only for the first case since for second we should already report error in binder
							if (reportError) {
								var diagnostic = isStatic(node) ? Diagnostics.Function_overload_must_be_static : Diagnostics.Function_overload_must_not_be_static;
								error(errorNode_1, diagnostic);
							}
							return;
						}
						if (nodeIsPresent(subsequentNode.body)) {
							error(
								errorNode_1,
								Diagnostics.Function_implementation_name_must_be_0,
								declarationNameToString(node.name),
							);
							return;
						}
					}
				}
				var errorNode = node.name || node;
				if (isConstructor) {
					error(errorNode, Diagnostics.Constructor_implementation_is_missing);
				} else {
					// Report different errors regarding non-consecutive blocks of declarations depending on whether
					// the node in question is abstract.
					if (hasSyntacticModifier(node, ModifierFlags.Abstract)) {
						error(
							errorNode,
							Diagnostics.All_declarations_of_an_abstract_method_must_be_consecutive,
						);
					} else {
						error(
							errorNode,
							Diagnostics.Function_implementation_is_missing_or_not_immediately_following_the_declaration,
						);
					}
				}
			}
			var duplicateFunctionDeclaration = false;
			var multipleConstructorImplementation = false;
			var hasNonAmbientClass = false;
			var functionDeclarations = [];
			if (declarations) {
				for (
					var _i = 0, declarations_3 = declarations;
					_i < declarations_3.length;
					_i++
				) {
					var current = declarations_3[_i];
					var node = current;
					var inAmbientContext = node.flags & NodeFlags.Ambient;
					var inAmbientContextOrInterface = node.parent && (node.parent.kind === SyntaxKind.InterfaceDeclaration || node.parent.kind === SyntaxKind.TypeLiteral) || inAmbientContext;
					if (inAmbientContextOrInterface) {
						// check if declarations are consecutive only if they are non-ambient
						// 1. ambient declarations can be interleaved
						// i.e. this is legal
						//     declare function foo();
						//     declare function bar();
						//     declare function foo();
						// 2. mixing ambient and non-ambient declarations is a separate error that will be reported - do not want to report an extra one
						previousDeclaration = undefined;
					}
					if (
						(node.kind === SyntaxKind.ClassDeclaration || node.kind === SyntaxKind.ClassExpression) && !inAmbientContext
					) {
						hasNonAmbientClass = true;
					}
					if (
						node.kind === SyntaxKind.FunctionDeclaration || node.kind === SyntaxKind.MethodDeclaration || node.kind === SyntaxKind.MethodSignature || node.kind === SyntaxKind.Constructor
					) {
						functionDeclarations.push(node);
						var currentNodeFlags = getEffectiveDeclarationFlags(
							node,
							flagsToCheck,
						);
						someNodeFlags |= currentNodeFlags;
						allNodeFlags &= currentNodeFlags;
						someHaveQuestionToken = someHaveQuestionToken || hasQuestionToken(
							node,
						);
						allHaveQuestionToken = allHaveQuestionToken && hasQuestionToken(
							node,
						);
						var bodyIsPresent = nodeIsPresent(node.body);
						if (bodyIsPresent && bodyDeclaration) {
							if (isConstructor) {
								multipleConstructorImplementation = true;
							} else {
								duplicateFunctionDeclaration = true;
							}
						} else if (
							(previousDeclaration === null || previousDeclaration === void 0 ? void 0 : previousDeclaration.parent) === node.parent && previousDeclaration.end !== node.pos
						) {
							reportImplementationExpectedError(previousDeclaration);
						}
						if (bodyIsPresent) {
							if (!bodyDeclaration) {
								bodyDeclaration = node;
							}
						} else {
							hasOverloads = true;
						}
						previousDeclaration = node;
						if (!inAmbientContextOrInterface) {
							lastSeenNonAmbientDeclaration = node;
						}
					}
				}
			}
			if (multipleConstructorImplementation) {
				forEach(
					functionDeclarations,
					function (declaration) {
						error(
							declaration,
							Diagnostics.Multiple_constructor_implementations_are_not_allowed,
						);
					},
				);
			}
			if (duplicateFunctionDeclaration) {
				forEach(
					functionDeclarations,
					function (declaration) {
						error(
							getNameOfDeclaration(declaration) || declaration,
							Diagnostics.Duplicate_function_implementation,
						);
					},
				);
			}
			if (
				hasNonAmbientClass && !isConstructor && symbol.flags & SymbolFlags.Function && declarations
			) {
				var relatedDiagnostics_1 = filter(
					declarations,
					function (d) {
						return d.kind === SyntaxKind.ClassDeclaration;
					},
				).map(
					function (d) {
						return createDiagnosticForNode(
							d,
							Diagnostics.Consider_adding_a_declare_modifier_to_this_class,
						);
					},
				);
				forEach(
					declarations,
					function (declaration) {
						var diagnostic = declaration.kind === SyntaxKind.ClassDeclaration ? Diagnostics.Class_declaration_cannot_implement_overload_list_for_0 : declaration.kind === SyntaxKind.FunctionDeclaration ? Diagnostics.Function_with_bodies_can_only_merge_with_classes_that_are_ambient : undefined;
						if (diagnostic) {
							addRelatedInfo.apply(
								void 0,
								__spreadArray(
									[
										error(
											getNameOfDeclaration(declaration) || declaration,
											diagnostic,
											symbolName(symbol),
										),
									],
									relatedDiagnostics_1,
									false,
								),
							);
						}
					},
				);
			}
			// Abstract methods can't have an implementation -- in particular, they don't need one.
			if (
				lastSeenNonAmbientDeclaration && !lastSeenNonAmbientDeclaration.body && !hasSyntacticModifier(
					lastSeenNonAmbientDeclaration,
					ModifierFlags.Abstract,
				) && !lastSeenNonAmbientDeclaration.questionToken
			) {
				reportImplementationExpectedError(lastSeenNonAmbientDeclaration);
			}
			if (hasOverloads) {
				if (declarations) {
					checkFlagAgreementBetweenOverloads(
						declarations,
						bodyDeclaration,
						flagsToCheck,
						someNodeFlags,
						allNodeFlags,
					);
					checkQuestionTokenAgreementBetweenOverloads(
						declarations,
						bodyDeclaration,
						someHaveQuestionToken,
						allHaveQuestionToken,
					);
				}
				if (bodyDeclaration) {
					var signatures = getSignaturesOfSymbol(symbol);
					var bodySignature = getSignatureFromDeclaration(bodyDeclaration);
					for (
						var _a = 0, signatures_10 = signatures;
						_a < signatures_10.length;
						_a++
					) {
						var signature = signatures_10[_a];
						if (
							!isImplementationCompatibleWithOverload(bodySignature, signature)
						) {
							addRelatedInfo(
								error(
									signature.declaration,
									Diagnostics.This_overload_signature_is_not_compatible_with_its_implementation_signature,
								),
								createDiagnosticForNode(
									bodyDeclaration,
									Diagnostics.The_implementation_signature_is_declared_here,
								),
							);
							break;
						}
					}
				}
			}
		}
		function checkExportsOnMergedDeclarations(node) {
			if (!produceDiagnostics) {
				return;
			}
			// if localSymbol is defined on node then node itself is exported - check is required
			var symbol = node.localSymbol;
			if (!symbol) {
				// local symbol is undefined => this declaration is non-exported.
				// however symbol might contain other declarations that are exported
				symbol = getSymbolOfNode(node);
				if (!symbol.exportSymbol) {
					// this is a pure local symbol (all declarations are non-exported) - no need to check anything
					return;
				}
			}
			// run the check only for the first declaration in the list
			if (getDeclarationOfKind(symbol, node.kind) !== node) {
				return;
			}
			var exportedDeclarationSpaces = 0 /* None */ ;
			var nonExportedDeclarationSpaces = 0 /* None */ ;
			var defaultExportedDeclarationSpaces = 0 /* None */ ;
			for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
				var d = _a[_i];
				var declarationSpaces = getDeclarationSpaces(d);
				var effectiveDeclarationFlags = getEffectiveDeclarationFlags(
					d,
					ModifierFlags.Export | ModifierFlags.Default,
				);
				if (effectiveDeclarationFlags & ModifierFlags.Export) {
					if (effectiveDeclarationFlags & ModifierFlags.Default) {
						defaultExportedDeclarationSpaces |= declarationSpaces;
					} else {
						exportedDeclarationSpaces |= declarationSpaces;
					}
				} else {
					nonExportedDeclarationSpaces |= declarationSpaces;
				}
			}
			// Spaces for anything not declared a 'default export'.
			var nonDefaultExportedDeclarationSpaces = exportedDeclarationSpaces | nonExportedDeclarationSpaces;
			var commonDeclarationSpacesForExportsAndLocals = exportedDeclarationSpaces & nonExportedDeclarationSpaces;
			var commonDeclarationSpacesForDefaultAndNonDefault = defaultExportedDeclarationSpaces & nonDefaultExportedDeclarationSpaces;
			if (
				commonDeclarationSpacesForExportsAndLocals || commonDeclarationSpacesForDefaultAndNonDefault
			) {
				// declaration spaces for exported and non-exported declarations intersect
				for (var _b = 0, _c = symbol.declarations; _b < _c.length; _b++) {
					var d = _c[_b];
					var declarationSpaces = getDeclarationSpaces(d);
					var name_31 = getNameOfDeclaration(d);
					// Only error on the declarations that contributed to the intersecting spaces.
					if (
						declarationSpaces & commonDeclarationSpacesForDefaultAndNonDefault
					) {
						error(
							name_31,
							Diagnostics.Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_default_0_declaration_instead,
							declarationNameToString(name_31),
						);
					} else if (
						declarationSpaces & commonDeclarationSpacesForExportsAndLocals
					) {
						error(
							name_31,
							Diagnostics.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local,
							declarationNameToString(name_31),
						);
					}
				}
			}
			function getDeclarationSpaces(decl) {
				var d = decl;
				switch (d.kind) {
					case SyntaxKind.InterfaceDeclaration:
					case SyntaxKind.TypeAliasDeclaration:
					// A jsdoc typedef and callback are, by definition, type aliases.
					// falls through
					case SyntaxKind.JSDocTypedefTag:
					case SyntaxKind.JSDocCallbackTag:
					case SyntaxKind.JSDocEnumTag:
						return 2; /* ExportType */
					case SyntaxKind.ModuleDeclaration:
						return isAmbientModule(d) || getModuleInstanceState(d) !== ModuleInstanceState.NonInstantiated ? 4 | 1 : 4; /* ExportNamespace */ /* ExportValue */ /* ExportNamespace */
					case SyntaxKind.ClassDeclaration:
					case SyntaxKind.EnumDeclaration:
					case SyntaxKind.EnumMember:
						return 2 | 1; /* ExportType */ /* ExportValue */
					case SyntaxKind.SourceFile:
						return 2 | 1 | 4; /* ExportType */ /* ExportValue */ /* ExportNamespace */
					case SyntaxKind.ExportAssignment:
					case SyntaxKind.BinaryExpression:
						var node_1 = d;
						var expression = isExportAssignment(node_1) ? node_1.expression : node_1.right;
						// Export assigned entity name expressions act as aliases and should fall through, otherwise they export values
						if (!isEntityNameExpression(expression)) {
							return 1; /* ExportValue */
						}
						d = expression;
					// The below options all declare an Alias, which is allowed to merge with other values within the importing module.
					// falls through
					case SyntaxKind.ImportEqualsDeclaration:
					case SyntaxKind.NamespaceImport:
					case SyntaxKind.ImportClause:
						var result_7 = 0 /* None */ ;
						var target = resolveAlias(getSymbolOfNode(d));
						forEach(
							target.declarations,
							function (d) {
								result_7 |= getDeclarationSpaces(d);
							},
						);
						return result_7;
					case SyntaxKind.VariableDeclaration:
					case SyntaxKind.BindingElement:
					case SyntaxKind.FunctionDeclaration:
					case SyntaxKind.ImportSpecifier: // https://github.com/Microsoft/TypeScript/pull/7591
					case SyntaxKind.Identifier: // https://github.com/microsoft/TypeScript/issues/36098
						// Identifiers are used as declarations of assignment declarations whose parents may be
						// SyntaxKind.CallExpression - `Object.defineProperty(thing, "aField", {value: 42});`
						// SyntaxKind.ElementAccessExpression - `thing["aField"] = 42;` or `thing["aField"];` (with a doc comment on it)
						// or SyntaxKind.PropertyAccessExpression - `thing.aField = 42;`
						// all of which are pretty much always values, or at least imply a value meaning.
						// It may be apprpriate to treat these as aliases in the future.
						return 1; /* ExportValue */
					default:
						return Debug.failBadSyntaxKind(d);
				}
			}
		}
		function getAwaitedTypeOfPromise(type, errorNode, diagnosticMessage, arg0) {
			var promisedType = getPromisedTypeOfPromise(type, errorNode);
			return promisedType && getAwaitedType(
				promisedType,
				errorNode,
				diagnosticMessage,
				arg0,
			);
		}
		/**
         * Gets the "promised type" of a promise.
         * @param type The type of the promise.
         * @remarks The "promised type" of a type is the type of the "value" parameter of the "onfulfilled" callback.
         */
		function getPromisedTypeOfPromise(type, errorNode) {
			//
			//  { // type
			//      then( // thenFunction
			//          onfulfilled: ( // onfulfilledParameterType
			//              value: T // valueParameterType
			//          ) => any
			//      ): any;
			//  }
			//
			if (isTypeAny(type)) {
				return undefined;
			}
			var typeAsPromise = type;
			if (typeAsPromise.promisedTypeOfPromise) {
				return typeAsPromise.promisedTypeOfPromise;
			}
			if (
				isReferenceToType(type, getGlobalPromiseType( /*reportErrors*/ false))
			) {
				return typeAsPromise.promisedTypeOfPromise = getTypeArguments(type)[0];
			}
			// primitives with a `{ then() }` won't be unwrapped/adopted.
			if (allTypesAssignableToKind(type, TypeFlags.Primitive | TypeFlags.Never)) {
				return undefined;
			}
			var thenFunction = getTypeOfPropertyOfType(type, "then"); // TODO: GH#18217
			if (isTypeAny(thenFunction)) {
				return undefined;
			}
			var thenSignatures = thenFunction ? getSignaturesOfType(
				thenFunction,
				SignatureKind.Call,
			) : emptyArray;
			if (thenSignatures.length === 0) {
				if (errorNode) {
					error(errorNode, Diagnostics.A_promise_must_have_a_then_method);
				}
				return undefined;
			}
			var onfulfilledParameterType = getTypeWithFacts(
				getUnionType(map(thenSignatures, getTypeOfFirstParameterOfSignature)),
				2097152, /* NEUndefinedOrNull */
			);
			if (isTypeAny(onfulfilledParameterType)) {
				return undefined;
			}
			var onfulfilledParameterSignatures = getSignaturesOfType(
				onfulfilledParameterType,
				SignatureKind.Call,
			);
			if (onfulfilledParameterSignatures.length === 0) {
				if (errorNode) {
					error(
						errorNode,
						Diagnostics.The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback,
					);
				}
				return undefined;
			}
			return typeAsPromise.promisedTypeOfPromise = getUnionType(
				map(onfulfilledParameterSignatures, getTypeOfFirstParameterOfSignature),
				UnionReduction.Subtype,
			);
		}
		/**
         * Gets the "awaited type" of a type.
         * @param type The type to await.
         * @param withAlias When `true`, wraps the "awaited type" in `Awaited<T>` if needed.
         * @remarks The "awaited type" of an expression is its "promised type" if the expression is a
         * Promise-like type; otherwise, it is the type of the expression. This is used to reflect
         * The runtime behavior of the `await` keyword.
         */
		function checkAwaitedType(
			type,
			withAlias,
			errorNode,
			diagnosticMessage,
			arg0,
		) {
			var awaitedType = withAlias ? getAwaitedType(
				type,
				errorNode,
				diagnosticMessage,
				arg0,
			) : getAwaitedTypeNoAlias(type, errorNode, diagnosticMessage, arg0);
			return awaitedType || errorType;
		}
		/**
         * Determines whether a type is an object with a callable `then` member.
         */
		function isThenableType(type) {
			if (allTypesAssignableToKind(type, TypeFlags.Primitive | TypeFlags.Never)) {
				// primitive types cannot be considered "thenable" since they are not objects.
				return false;
			}
			var thenFunction = getTypeOfPropertyOfType(type, "then");
			return !!thenFunction && getSignaturesOfType(
				getTypeWithFacts(thenFunction, 2097152 /* NEUndefinedOrNull */ ),
				SignatureKind.Call,
			).length > 0;
		}
		function isAwaitedTypeInstantiation(type) {
			var _a;
			if (type.flags & TypeFlags.Conditional) {
				var awaitedSymbol = getGlobalAwaitedSymbol( /*reportErrors*/ false);
				return !!awaitedSymbol && type.aliasSymbol === awaitedSymbol && ((_a = type.aliasTypeArguments) === null || _a === void 0 ? void 0 : _a.length) === 1;
			}
			return false;
		}
		/**
         * For a generic `Awaited<T>`, gets `T`.
         */
		function unwrapAwaitedType(type) {
			return type.flags & TypeFlags.Union ? mapType(type, unwrapAwaitedType) : isAwaitedTypeInstantiation(
				type,
			) ? type.aliasTypeArguments[0] : type;
		}
		function createAwaitedTypeIfNeeded(type) {
			// We wrap type `T` in `Awaited<T>` based on the following conditions:
			// - `T` is not already an `Awaited<U>`, and
			// - `T` is generic, and
			// - One of the following applies:
			//   - `T` has no base constraint, or
			//   - The base constraint of `T` is `any`, `unknown`, `object`, or `{}`, or
			//   - The base constraint of `T` is an object type with a callable `then` method.
			if (isTypeAny(type)) {
				return type;
			}
			// If this is already an `Awaited<T>`, just return it. This helps to avoid `Awaited<Awaited<T>>` in higher-order.
			if (isAwaitedTypeInstantiation(type)) {
				return type;
			}
			// Only instantiate `Awaited<T>` if `T` contains possibly non-primitive types.
			if (isGenericObjectType(type)) {
				var baseConstraint = getBaseConstraintOfType(type);
				// Only instantiate `Awaited<T>` if `T` has no base constraint, or the base constraint of `T` is `any`, `unknown`, `{}`, `object`,
				// or is promise-like.
				if (
					!baseConstraint || (baseConstraint.flags & TypeFlags.AnyOrUnknown) || isEmptyObjectType(
						baseConstraint,
					) || isThenableType(baseConstraint)
				) {
					// Nothing to do if `Awaited<T>` doesn't exist
					var awaitedSymbol = getGlobalAwaitedSymbol( /*reportErrors*/ true);
					if (awaitedSymbol) {
						// Unwrap unions that may contain `Awaited<T>`, otherwise its possible to manufacture an `Awaited<Awaited<T> | U>` where
						// an `Awaited<T | U>` would suffice.
						return getTypeAliasInstantiation(
							awaitedSymbol,
							[unwrapAwaitedType(type)],
						);
					}
				}
			}
			Debug.assert(
				getPromisedTypeOfPromise(type) === undefined,
				"type provided should not be a non-generic 'promise'-like.",
			);
			return type;
		}
		/**
         * Gets the "awaited type" of a type.
         *
         * The "awaited type" of an expression is its "promised type" if the expression is a
         * Promise-like type; otherwise, it is the type of the expression. If the "promised
         * type" is itself a Promise-like, the "promised type" is recursively unwrapped until a
         * non-promise type is found.
         *
         * This is used to reflect the runtime behavior of the `await` keyword.
         */
		function getAwaitedType(type, errorNode, diagnosticMessage, arg0) {
			var awaitedType = getAwaitedTypeNoAlias(
				type,
				errorNode,
				diagnosticMessage,
				arg0,
			);
			return awaitedType && createAwaitedTypeIfNeeded(awaitedType);
		}
		/**
         * Gets the "awaited type" of a type without introducing an `Awaited<T>` wrapper.
         *
         * @see {@link getAwaitedType}
         */
		function getAwaitedTypeNoAlias(type, errorNode, diagnosticMessage, arg0) {
			if (isTypeAny(type)) {
				return type;
			}
			// If this is already an `Awaited<T>`, just return it. This avoids `Awaited<Awaited<T>>` in higher-order
			if (isAwaitedTypeInstantiation(type)) {
				return type;
			}
			// If we've already cached an awaited type, return a possible `Awaited<T>` for it.
			var typeAsAwaitable = type;
			if (typeAsAwaitable.awaitedTypeOfType) {
				return typeAsAwaitable.awaitedTypeOfType;
			}
			// For a union, get a union of the awaited types of each constituent.
			if (type.flags & TypeFlags.Union) {
				var mapper = errorNode ? function (constituentType) {
					return getAwaitedTypeNoAlias(
						constituentType,
						errorNode,
						diagnosticMessage,
						arg0,
					);
				} : getAwaitedTypeNoAlias;
				return typeAsAwaitable.awaitedTypeOfType = mapType(type, mapper);
			}
			var promisedType = getPromisedTypeOfPromise(type);
			if (promisedType) {
				if (
					type.id === promisedType.id || awaitedTypeStack.lastIndexOf(
						promisedType.id,
					) >= 0
				) {
					// Verify that we don't have a bad actor in the form of a promise whose
					// promised type is the same as the promise type, or a mutually recursive
					// promise. If so, we return undefined as we cannot guess the shape. If this
					// were the actual case in the JavaScript, this Promise would never resolve.
					//
					// An example of a bad actor with a singly-recursive promise type might
					// be:
					//
					//  interface BadPromise {
					//      then(
					//          onfulfilled: (value: BadPromise) => any,
					//          onrejected: (error: any) => any): BadPromise;
					//  }
					//
					// The above interface will pass the PromiseLike check, and return a
					// promised type of `BadPromise`. Since this is a self reference, we
					// don't want to keep recursing ad infinitum.
					//
					// An example of a bad actor in the form of a mutually-recursive
					// promise type might be:
					//
					//  interface BadPromiseA {
					//      then(
					//          onfulfilled: (value: BadPromiseB) => any,
					//          onrejected: (error: any) => any): BadPromiseB;
					//  }
					//
					//  interface BadPromiseB {
					//      then(
					//          onfulfilled: (value: BadPromiseA) => any,
					//          onrejected: (error: any) => any): BadPromiseA;
					//  }
					//
					if (errorNode) {
						error(
							errorNode,
							Diagnostics.Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method,
						);
					}
					return undefined;
				}
				// Keep track of the type we're about to unwrap to avoid bad recursive promise types.
				// See the comments above for more information.
				awaitedTypeStack.push(type.id);
				var awaitedType = getAwaitedTypeNoAlias(
					promisedType,
					errorNode,
					diagnosticMessage,
					arg0,
				);
				awaitedTypeStack.pop();
				if (!awaitedType) {
					return undefined;
				}
				return typeAsAwaitable.awaitedTypeOfType = awaitedType;
			}
			// The type was not a promise, so it could not be unwrapped any further.
			// As long as the type does not have a callable "then" property, it is
			// safe to return the type; otherwise, an error is reported and we return
			// undefined.
			//
			// An example of a non-promise "thenable" might be:
			//
			//  await { then(): void {} }
			//
			// The "thenable" does not match the minimal definition for a promise. When
			// a Promise/A+-compatible or ES6 promise tries to adopt this value, the promise
			// will never settle. We treat this as an error to help flag an early indicator
			// of a runtime problem. If the user wants to return this value from an async
			// function, they would need to wrap it in some other value. If they want it to
			// be treated as a promise, they can cast to <any>.
			if (isThenableType(type)) {
				if (errorNode) {
					Debug.assertIsDefined(diagnosticMessage);
					error(errorNode, diagnosticMessage, arg0);
				}
				return undefined;
			}
			return typeAsAwaitable.awaitedTypeOfType = type;
		}
		/**
         * Checks the return type of an async function to ensure it is a compatible
         * Promise implementation.
         *
         * This checks that an async function has a valid Promise-compatible return type.
         * An async function has a valid Promise-compatible return type if the resolved value
         * of the return type has a construct signature that takes in an `initializer` function
         * that in turn supplies a `resolve` function as one of its arguments and results in an
         * object with a callable `then` signature.
         *
         * @param node The signature to check
         */
		function checkAsyncFunctionReturnType(node, returnTypeNode) {
			// As part of our emit for an async function, we will need to emit the entity name of
			// the return type annotation as an expression. To meet the necessary runtime semantics
			// for __awaiter, we must also check that the type of the declaration (e.g. the static
			// side or "constructor" of the promise type) is compatible `PromiseConstructorLike`.
			//
			// An example might be (from lib.es6.d.ts):
			//
			//  interface Promise<T> { ... }
			//  interface PromiseConstructor {
			//      new <T>(...): Promise<T>;
			//  }
			//  declare var Promise: PromiseConstructor;
			//
			// When an async function declares a return type annotation of `Promise<T>`, we
			// need to get the type of the `Promise` variable declaration above, which would
			// be `PromiseConstructor`.
			//
			// The same case applies to a class:
			//
			//  declare class Promise<T> {
			//      constructor(...);
			//      then<U>(...): Promise<U>;
			//  }
			//
			var returnType = getTypeFromTypeNode(returnTypeNode);
			if (languageVersion >= ScriptTarget.ES2015) {
				if (isErrorType(returnType)) {
					return;
				}
				var globalPromiseType = getGlobalPromiseType( /*reportErrors*/ true);
				if (
					globalPromiseType !== emptyGenericType && !isReferenceToType(
						returnType,
						globalPromiseType,
					)
				) {
					// The promise type was not a valid type reference to the global promise type, so we
					// report an error and return the unknown type.
					error(
						returnTypeNode,
						Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_write_Promise_0,
						typeToString(getAwaitedTypeNoAlias(returnType) || voidType),
					);
					return;
				}
			} else {
				// Always mark the type node as referenced if it points to a value
				markTypeNodeAsReferenced(returnTypeNode);
				if (isErrorType(returnType)) {
					return;
				}
				var promiseConstructorName = getEntityNameFromTypeNode(returnTypeNode);
				if (promiseConstructorName === undefined) {
					error(
						returnTypeNode,
						Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value,
						typeToString(returnType),
					);
					return;
				}
				var promiseConstructorSymbol = resolveEntityName(
					promiseConstructorName,
					SymbolFlags.Value, /*ignoreErrors*/
					true,
				);
				var promiseConstructorType = promiseConstructorSymbol ? getTypeOfSymbol(
					promiseConstructorSymbol,
				) : errorType;
				if (isErrorType(promiseConstructorType)) {
					if (
						promiseConstructorName.kind === SyntaxKind.Identifier && promiseConstructorName.escapedText === "Promise" && getTargetType(
							returnType,
						) === getGlobalPromiseType( /*reportErrors*/ false)
					) {
						error(
							returnTypeNode,
							Diagnostics.An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option,
						);
					} else {
						error(
							returnTypeNode,
							Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value,
							entityNameToString(promiseConstructorName),
						);
					}
					return;
				}
				var globalPromiseConstructorLikeType = getGlobalPromiseConstructorLikeType(
					true, /*reportErrors*/
				);
				if (globalPromiseConstructorLikeType === emptyObjectType) {
					// If we couldn't resolve the global PromiseConstructorLike type we cannot verify
					// compatibility with __awaiter.
					error(
						returnTypeNode,
						Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value,
						entityNameToString(promiseConstructorName),
					);
					return;
				}
				if (
					!checkTypeAssignableTo(
						promiseConstructorType,
						globalPromiseConstructorLikeType,
						returnTypeNode,
						Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value,
					)
				) {
					return;
				}
				// Verify there is no local declaration that could collide with the promise constructor.
				var rootName = promiseConstructorName && getFirstIdentifier(
					promiseConstructorName,
				);
				var collidingSymbol = getSymbol(
					node.locals,
					rootName.escapedText,
					SymbolFlags.Value,
				);
				if (collidingSymbol) {
					error(
						collidingSymbol.valueDeclaration,
						Diagnostics.Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions,
						idText(rootName),
						entityNameToString(promiseConstructorName),
					);
					return;
				}
			}
			checkAwaitedType(
				returnType, /*withAlias*/
				false,
				node,
				Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member,
			);
		}
		/** Check a decorator */
		function checkDecorator(node) {
			var signature = getResolvedSignature(node);
			checkDeprecatedSignature(signature, node);
			var returnType = getReturnTypeOfSignature(signature);
			if (returnType.flags & TypeFlags.Any) {
				return;
			}
			var expectedReturnType;
			var headMessage = getDiagnosticHeadMessageForDecoratorResolution(node);
			var errorInfo;
			switch (node.parent.kind) {
				case SyntaxKind.ClassDeclaration:
					var classSymbol = getSymbolOfNode(node.parent);
					var classConstructorType = getTypeOfSymbol(classSymbol);
					expectedReturnType = getUnionType([classConstructorType, voidType]);
					break;
				case SyntaxKind.Parameter:
					expectedReturnType = voidType;
					errorInfo = chainDiagnosticMessages(
						/*details*/ undefined,
						Diagnostics.The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any,
					);
					break;
				case SyntaxKind.PropertyDeclaration:
					expectedReturnType = voidType;
					errorInfo = chainDiagnosticMessages(
						/*details*/ undefined,
						Diagnostics.The_return_type_of_a_property_decorator_function_must_be_either_void_or_any,
					);
					break;
				case SyntaxKind.MethodDeclaration:
				case SyntaxKind.GetAccessor:
				case SyntaxKind.SetAccessor:
					var methodType = getTypeOfNode(node.parent);
					var descriptorType = createTypedPropertyDescriptorType(methodType);
					expectedReturnType = getUnionType([descriptorType, voidType]);
					break;
				default:
					return Debug.fail();
			}
			checkTypeAssignableTo(
				returnType,
				expectedReturnType,
				node,
				headMessage,
				function () {
					return errorInfo;
				},
			);
		}
		/**
         * If a TypeNode can be resolved to a value symbol imported from an external module, it is
         * marked as referenced to prevent import elision.
         */
		function markTypeNodeAsReferenced(node) {
			markEntityNameOrEntityExpressionAsReference(
				node && getEntityNameFromTypeNode(node),
			);
		}
		function markEntityNameOrEntityExpressionAsReference(typeName) {
			if (!typeName) return;
			var rootName = getFirstIdentifier(typeName);
			var meaning = (typeName.kind === SyntaxKind.Identifier ? SymbolFlags.Type : SymbolFlags.Namespace) | SymbolFlags.Alias;
			var rootSymbol = resolveName(
				rootName,
				rootName.escapedText,
				meaning, /*nameNotFoundMessage*/
				undefined, /*nameArg*/
				undefined, /*isReference*/
				true,
			);
			if (
				rootSymbol && rootSymbol.flags & SymbolFlags.Alias && symbolIsValue(
					rootSymbol,
				) && !isConstEnumOrConstEnumOnlyModule(resolveAlias(rootSymbol)) && !getTypeOnlyAliasDeclaration(
					rootSymbol,
				)
			) {
				markAliasSymbolAsReferenced(rootSymbol);
			}
		}
		/**
         * This function marks the type used for metadata decorator as referenced if it is import
         * from external module.
         * This is different from markTypeNodeAsReferenced because it tries to simplify type nodes in
         * union and intersection type
         * @param node
         */
		function markDecoratorMedataDataTypeNodeAsReferenced(node) {
			var entityName = getEntityNameForDecoratorMetadata(node);
			if (entityName && isEntityName(entityName)) {
				markEntityNameOrEntityExpressionAsReference(entityName);
			}
		}
		function getEntityNameForDecoratorMetadata(node) {
			if (node) {
				switch (node.kind) {
					case SyntaxKind.IntersectionType:
					case SyntaxKind.UnionType:
						return getEntityNameForDecoratorMetadataFromTypeList(node.types);
					case SyntaxKind.ConditionalType:
						return getEntityNameForDecoratorMetadataFromTypeList(
							[node.trueType, node.falseType],
						);
					case SyntaxKind.ParenthesizedType:
					case SyntaxKind.NamedTupleMember:
						return getEntityNameForDecoratorMetadata(node.type);
					case SyntaxKind.TypeReference:
						return node.typeName;
				}
			}
		}
		function getEntityNameForDecoratorMetadataFromTypeList(types) {
			var commonEntityName;
			for (var _i = 0, types_22 = types; _i < types_22.length; _i++) {
				var typeNode = types_22[_i];
				while (
					typeNode.kind === SyntaxKind.ParenthesizedType || typeNode.kind === SyntaxKind.NamedTupleMember
				) {
					typeNode = typeNode.type; // Skip parens if need be
				}
				if (typeNode.kind === SyntaxKind.NeverKeyword) {
					continue; // Always elide `never` from the union/intersection if possible
				}
				if (
					!strictNullChecks && (typeNode.kind === SyntaxKind.LiteralType && typeNode.literal.kind === SyntaxKind.NullKeyword || typeNode.kind === SyntaxKind.UndefinedKeyword)
				) {
					continue; // Elide null and undefined from unions for metadata, just like what we did prior to the implementation of strict null checks
				}
				var individualEntityName = getEntityNameForDecoratorMetadata(typeNode);
				if (!individualEntityName) {
					// Individual is something like string number
					// So it would be serialized to either that type or object
					// Safe to return here
					return undefined;
				}
				if (commonEntityName) {
					// Note this is in sync with the transformation that happens for type node.
					// Keep this in sync with serializeUnionOrIntersectionType
					// Verify if they refer to same entity and is identifier
					// return undefined if they dont match because we would emit object
					if (
						!isIdentifier(commonEntityName) || !isIdentifier(
							individualEntityName,
						) || commonEntityName.escapedText !== individualEntityName.escapedText
					) {
						return undefined;
					}
				} else {
					commonEntityName = individualEntityName;
				}
			}
			return commonEntityName;
		}
		function getParameterTypeNodeForDecoratorCheck(node) {
			var typeNode = getEffectiveTypeAnnotationNode(node);
			return isRestParameter(node) ? getRestParameterElementType(typeNode) : typeNode;
		}
		/** Check the decorators of a node */
		function checkDecorators(node) {
			if (!node.decorators) {
				return;
			}
			// skip this check for nodes that cannot have decorators. These should have already had an error reported by
			// checkGrammarDecorators.
			if (!nodeCanBeDecorated(node, node.parent, node.parent.parent)) {
				return;
			}
			if (!compilerOptions.experimentalDecorators) {
				error(
					node,
					Diagnostics.Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Set_the_experimentalDecorators_option_in_your_tsconfig_or_jsconfig_to_remove_this_warning,
				);
			}
			var firstDecorator = node.decorators[0];
			checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpers.Decorate);
			if (node.kind === SyntaxKind.Parameter) {
				checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpers.Param);
			}
			if (compilerOptions.emitDecoratorMetadata) {
				checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpers.Metadata);
				// we only need to perform these checks if we are emitting serialized type metadata for the target of a decorator.
				switch (node.kind) {
					case SyntaxKind.ClassDeclaration:
						var constructor = getFirstConstructorWithBody(node);
						if (constructor) {
							for (var _i = 0, _a = constructor.parameters; _i < _a.length; _i++) {
								var parameter = _a[_i];
								markDecoratorMedataDataTypeNodeAsReferenced(
									getParameterTypeNodeForDecoratorCheck(parameter),
								);
							}
						}
						break;
					case SyntaxKind.GetAccessor:
					case SyntaxKind.SetAccessor:
						var otherKind = node.kind === SyntaxKind.GetAccessor ? SyntaxKind.SetAccessor : SyntaxKind.GetAccessor;
						var otherAccessor = getDeclarationOfKind(
							getSymbolOfNode(node),
							otherKind,
						);
						markDecoratorMedataDataTypeNodeAsReferenced(
							getAnnotatedAccessorTypeNode(node) || otherAccessor && getAnnotatedAccessorTypeNode(
								otherAccessor,
							),
						);
						break;
					case SyntaxKind.MethodDeclaration:
						for (var _b = 0, _c = node.parameters; _b < _c.length; _b++) {
							var parameter = _c[_b];
							markDecoratorMedataDataTypeNodeAsReferenced(
								getParameterTypeNodeForDecoratorCheck(parameter),
							);
						}
						markDecoratorMedataDataTypeNodeAsReferenced(
							getEffectiveReturnTypeNode(node),
						);
						break;
					case SyntaxKind.PropertyDeclaration:
						markDecoratorMedataDataTypeNodeAsReferenced(
							getEffectiveTypeAnnotationNode(node),
						);
						break;
					case SyntaxKind.Parameter:
						markDecoratorMedataDataTypeNodeAsReferenced(
							getParameterTypeNodeForDecoratorCheck(node),
						);
						var containingSignature = node.parent;
						for (
							var _d = 0, _e = containingSignature.parameters;
							_d < _e.length;
							_d++
						) {
							var parameter = _e[_d];
							markDecoratorMedataDataTypeNodeAsReferenced(
								getParameterTypeNodeForDecoratorCheck(parameter),
							);
						}
						break;
				}
			}
			forEach(node.decorators, checkDecorator);
		}
		function checkFunctionDeclaration(node) {
			if (produceDiagnostics) {
				checkFunctionOrMethodDeclaration(node);
				checkGrammarForGenerator(node);
				checkCollisionsForDeclarationName(node, node.name);
			}
		}
		function checkJSDocTypeAliasTag(node) {
			if (!node.typeExpression) {
				// If the node had `@property` tags, `typeExpression` would have been set to the first property tag.
				error(
					node.name,
					Diagnostics.JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags,
				);
			}
			if (node.name) {
				checkTypeNameIsReserved(
					node.name,
					Diagnostics.Type_alias_name_cannot_be_0,
				);
			}
			checkSourceElement(node.typeExpression);
			checkTypeParameters(getEffectiveTypeParameterDeclarations(node));
		}
		function checkJSDocTemplateTag(node) {
			checkSourceElement(node.constraint);
			for (var _i = 0, _a = node.typeParameters; _i < _a.length; _i++) {
				var tp = _a[_i];
				checkSourceElement(tp);
			}
		}
		function checkJSDocTypeTag(node) {
			checkSourceElement(node.typeExpression);
		}
		function checkJSDocParameterTag(node) {
			checkSourceElement(node.typeExpression);
			if (!getParameterSymbolFromJSDoc(node)) {
				var decl = getHostSignatureFromJSDoc(node);
				// don't issue an error for invalid hosts -- just functions --
				// and give a better error message when the host function mentions `arguments`
				// but the tag doesn't have an array type
				if (decl) {
					var i = getJSDocTags(decl).filter(isJSDocParameterTag).indexOf(node);
					if (
						i > -1 && i < decl.parameters.length && isBindingPattern(
							decl.parameters[i].name,
						)
					) {
						return;
					}
					if (!containsArgumentsReference(decl)) {
						if (isQualifiedName(node.name)) {
							error(
								node.name,
								Diagnostics.Qualified_name_0_is_not_allowed_without_a_leading_param_object_1,
								entityNameToString(node.name),
								entityNameToString(node.name.left),
							);
						} else {
							error(
								node.name,
								Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name,
								idText(node.name),
							);
						}
					} else if (
						findLast(getJSDocTags(decl), isJSDocParameterTag) === node && node.typeExpression && node.typeExpression.type && !isArrayType(
							getTypeFromTypeNode(node.typeExpression.type),
						)
					) {
						error(
							node.name,
							Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_had_an_array_type,
							idText(
								node.name.kind === SyntaxKind.QualifiedName ? node.name.right : node.name,
							),
						);
					}
				}
			}
		}
		function checkJSDocPropertyTag(node) {
			checkSourceElement(node.typeExpression);
		}
		function checkJSDocFunctionType(node) {
			if (produceDiagnostics && !node.type && !isJSDocConstructSignature(node)) {
				reportImplicitAny(node, anyType);
			}
			checkSignatureDeclaration(node);
		}
		function checkJSDocImplementsTag(node) {
			var classLike = getEffectiveJSDocHost(node);
			if (
				!classLike || !isClassDeclaration(classLike) && !isClassExpression(
					classLike,
				)
			) {
				error(
					classLike,
					Diagnostics.JSDoc_0_is_not_attached_to_a_class,
					idText(node.tagName),
				);
			}
		}
		function checkJSDocAugmentsTag(node) {
			var classLike = getEffectiveJSDocHost(node);
			if (
				!classLike || !isClassDeclaration(classLike) && !isClassExpression(
					classLike,
				)
			) {
				error(
					classLike,
					Diagnostics.JSDoc_0_is_not_attached_to_a_class,
					idText(node.tagName),
				);
				return;
			}
			var augmentsTags = getJSDocTags(classLike).filter(isJSDocAugmentsTag);
			Debug.assert(augmentsTags.length > 0);
			if (augmentsTags.length > 1) {
				error(
					augmentsTags[1],
					Diagnostics.Class_declarations_cannot_have_more_than_one_augments_or_extends_tag,
				);
			}
			var name = getIdentifierFromEntityNameExpression(node["class"].expression);
			var extend = getClassExtendsHeritageElement(classLike);
			if (extend) {
				var className = getIdentifierFromEntityNameExpression(extend.expression);
				if (className && name.escapedText !== className.escapedText) {
					error(
						name,
						Diagnostics.JSDoc_0_1_does_not_match_the_extends_2_clause,
						idText(node.tagName),
						idText(name),
						idText(className),
					);
				}
			}
		}
		function checkJSDocAccessibilityModifiers(node) {
			var host = getJSDocHost(node);
			if (host && isPrivateIdentifierClassElementDeclaration(host)) {
				error(
					node,
					Diagnostics.An_accessibility_modifier_cannot_be_used_with_a_private_identifier,
				);
			}
		}
		function getIdentifierFromEntityNameExpression(node) {
			switch (node.kind) {
				case SyntaxKind.Identifier:
					return node;
				case SyntaxKind.PropertyAccessExpression:
					return node.name;
				default:
					return undefined;
			}
		}
		function checkFunctionOrMethodDeclaration(node) {
			var _a;
			checkDecorators(node);
			checkSignatureDeclaration(node);
			var functionFlags = getFunctionFlags(node);
			// Do not use hasDynamicName here, because that returns false for well known symbols.
			// We want to perform checkComputedPropertyName for all computed properties, including
			// well known symbols.
			if (node.name && node.name.kind === SyntaxKind.ComputedPropertyName) {
				// This check will account for methods in class/interface declarations,
				// as well as accessors in classes/object literals
				checkComputedPropertyName(node.name);
			}
			if (hasBindableName(node)) {
				// first we want to check the local symbol that contain this declaration
				// - if node.localSymbol !== undefined - this is current declaration is exported and localSymbol points to the local symbol
				// - if node.localSymbol === undefined - this node is non-exported so we can just pick the result of getSymbolOfNode
				var symbol = getSymbolOfNode(node);
				var localSymbol = node.localSymbol || symbol;
				// Since the javascript won't do semantic analysis like typescript,
				// if the javascript file comes before the typescript file and both contain same name functions,
				// checkFunctionOrConstructorSymbol wouldn't be called if we didnt ignore javascript function.
				var firstDeclaration = (_a = localSymbol.declarations) === null || _a === void 0 ? void 0 : _a.find(
					// Get first non javascript function declaration
					function (declaration) {
						return declaration.kind === node.kind && !(declaration.flags & NodeFlags.JavaScriptFile);
					},
				);
				// Only type check the symbol once
				if (node === firstDeclaration) {
					checkFunctionOrConstructorSymbol(localSymbol);
				}
				if (symbol.parent) {
					// run check on export symbol to check that modifiers agree across all exported declarations
					checkFunctionOrConstructorSymbol(symbol);
				}
			}
			var body = node.kind === SyntaxKind.MethodSignature ? undefined : node.body;
			checkSourceElement(body);
			checkAllCodePathsInNonVoidFunctionReturnOrThrow(
				node,
				getReturnTypeFromAnnotation(node),
			);
			if (produceDiagnostics && !getEffectiveReturnTypeNode(node)) {
				// Report an implicit any error if there is no body, no explicit return type, and node is not a private method
				// in an ambient context
				if (nodeIsMissing(body) && !isPrivateWithinAmbient(node)) {
					reportImplicitAny(node, anyType);
				}
				if (functionFlags & FunctionFlags.Generator && nodeIsPresent(body)) {
					// A generator with a body and no type annotation can still cause errors. It can error if the
					// yielded values have no common supertype, or it can give an implicit any error if it has no
					// yielded values. The only way to trigger these errors is to try checking its return type.
					getReturnTypeOfSignature(getSignatureFromDeclaration(node));
				}
			}
			// A js function declaration can have a @type tag instead of a return type node, but that type must have a call signature
			if (isInJSFile(node)) {
				var typeTag = getJSDocTypeTag(node);
				if (
					typeTag && typeTag.typeExpression && !getContextualCallSignature(
						getTypeFromTypeNode(typeTag.typeExpression),
						node,
					)
				) {
					error(
						typeTag.typeExpression.type,
						Diagnostics.The_type_of_a_function_declaration_must_match_the_function_s_signature,
					);
				}
			}
		}
		function registerForUnusedIdentifiersCheck(node) {
			// May be in a call such as getTypeOfNode that happened to call this. But potentiallyUnusedIdentifiers is only defined in the scope of `checkSourceFile`.
			if (produceDiagnostics) {
				var sourceFile = getSourceFileOfNode(node);
				var potentiallyUnusedIdentifiers = allPotentiallyUnusedIdentifiers.get(
					sourceFile.path,
				);
				if (!potentiallyUnusedIdentifiers) {
					potentiallyUnusedIdentifiers = [];
					allPotentiallyUnusedIdentifiers.set(
						sourceFile.path,
						potentiallyUnusedIdentifiers,
					);
				}
				// TODO: GH#22580
				// Debug.assert(addToSeen(seenPotentiallyUnusedIdentifiers, getNodeId(node)), "Adding potentially-unused identifier twice");
				potentiallyUnusedIdentifiers.push(node);
			}
		}
		function checkUnusedIdentifiers(potentiallyUnusedIdentifiers, addDiagnostic) {
			for (
				var _i = 0,
					potentiallyUnusedIdentifiers_1 = potentiallyUnusedIdentifiers;
				_i < potentiallyUnusedIdentifiers_1.length;
				_i++
			) {
				var node = potentiallyUnusedIdentifiers_1[_i];
				switch (node.kind) {
					case SyntaxKind.ClassDeclaration:
					case SyntaxKind.ClassExpression:
						checkUnusedClassMembers(node, addDiagnostic);
						checkUnusedTypeParameters(node, addDiagnostic);
						break;
					case SyntaxKind.SourceFile:
					case SyntaxKind.ModuleDeclaration:
					case SyntaxKind.Block:
					case SyntaxKind.CaseBlock:
					case SyntaxKind.ForStatement:
					case SyntaxKind.ForInStatement:
					case SyntaxKind.ForOfStatement:
						checkUnusedLocalsAndParameters(node, addDiagnostic);
						break;
					case SyntaxKind.Constructor:
					case SyntaxKind.FunctionExpression:
					case SyntaxKind.FunctionDeclaration:
					case SyntaxKind.ArrowFunction:
					case SyntaxKind.MethodDeclaration:
					case SyntaxKind.GetAccessor:
					case SyntaxKind.SetAccessor:
						if (node.body) {
							checkUnusedLocalsAndParameters(node, addDiagnostic); // Don't report unused parameters in overloads
						}
						checkUnusedTypeParameters(node, addDiagnostic);
						break;
					case SyntaxKind.MethodSignature:
					case SyntaxKind.CallSignature:
					case SyntaxKind.ConstructSignature:
					case SyntaxKind.FunctionType:
					case SyntaxKind.ConstructorType:
					case SyntaxKind.TypeAliasDeclaration:
					case SyntaxKind.InterfaceDeclaration:
						checkUnusedTypeParameters(node, addDiagnostic);
						break;
					case SyntaxKind.InferType:
						checkUnusedInferTypeParameter(node, addDiagnostic);
						break;
					default:
						Debug.assertNever(
							node,
							"Node should not have been registered for unused identifiers check",
						);
				}
			}
		}
		function errorUnusedLocal(declaration, name, addDiagnostic) {
			var node = getNameOfDeclaration(declaration) || declaration;
			var message = isTypeDeclaration(declaration) ? Diagnostics._0_is_declared_but_never_used : Diagnostics._0_is_declared_but_its_value_is_never_read;
			addDiagnostic(
				declaration,
				0, /* Local */
				createDiagnosticForNode(node, message, name),
			);
		}
		function isIdentifierThatStartsWithUnderscore(node) {
			return isIdentifier(node) && idText(node).charCodeAt(0) === CharacterCodes._;
		}
		function checkUnusedClassMembers(node, addDiagnostic) {
			for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
				var member = _a[_i];
				switch (member.kind) {
					case SyntaxKind.MethodDeclaration:
					case SyntaxKind.PropertyDeclaration:
					case SyntaxKind.GetAccessor:
					case SyntaxKind.SetAccessor:
						if (
							member.kind === SyntaxKind.SetAccessor && member.symbol.flags & SymbolFlags.GetAccessor
						) {
							// Already would have reported an error on the getter.
							break;
						}
						var symbol = getSymbolOfNode(member);
						if (
							!symbol.isReferenced && (hasEffectiveModifier(
								member,
								ModifierFlags.Private,
							) || isNamedDeclaration(member) && isPrivateIdentifier(
								member.name,
							)) && !(member.flags & NodeFlags.Ambient)
						) {
							addDiagnostic(
								member,
								0, /* Local */
								createDiagnosticForNode(
									member.name,
									Diagnostics._0_is_declared_but_its_value_is_never_read,
									symbolToString(symbol),
								),
							);
						}
						break;
					case SyntaxKind.Constructor:
						for (var _b = 0, _c = member.parameters; _b < _c.length; _b++) {
							var parameter = _c[_b];
							if (
								!parameter.symbol.isReferenced && hasSyntacticModifier(
									parameter,
									ModifierFlags.Private,
								)
							) {
								addDiagnostic(
									parameter,
									0, /* Local */
									createDiagnosticForNode(
										parameter.name,
										Diagnostics.Property_0_is_declared_but_its_value_is_never_read,
										symbolName(parameter.symbol),
									),
								);
							}
						}
						break;
					case SyntaxKind.IndexSignature:
					case SyntaxKind.SemicolonClassElement:
					case SyntaxKind.ClassStaticBlockDeclaration:
						// Can't be private
						break;
					default:
						Debug.fail("Unexpected class member");
				}
			}
		}
		function checkUnusedInferTypeParameter(node, addDiagnostic) {
			var typeParameter = node.typeParameter;
			if (isTypeParameterUnused(typeParameter)) {
				addDiagnostic(
					node,
					1, /* Parameter */
					createDiagnosticForNode(
						node,
						Diagnostics._0_is_declared_but_its_value_is_never_read,
						idText(typeParameter.name),
					),
				);
			}
		}
		function checkUnusedTypeParameters(node, addDiagnostic) {
			// Only report errors on the last declaration for the type parameter container;
			// this ensures that all uses have been accounted for.
			var declarations = getSymbolOfNode(node).declarations;
			if (!declarations || last(declarations) !== node) return;
			var typeParameters = getEffectiveTypeParameterDeclarations(node);
			var seenParentsWithEveryUnused = new Set();
			for (
				var _i = 0, typeParameters_3 = typeParameters;
				_i < typeParameters_3.length;
				_i++
			) {
				var typeParameter = typeParameters_3[_i];
				if (!isTypeParameterUnused(typeParameter)) continue;
				var name_32 = idText(typeParameter.name);
				var parent_17 = typeParameter.parent;
				if (
					parent_17.kind !== SyntaxKind.InferType && parent_17.typeParameters.every(
						isTypeParameterUnused,
					)
				) {
					if (tryAddToSet(seenParentsWithEveryUnused, parent_17)) {
						var sourceFile = getSourceFileOfNode(parent_17);
						var range = isJSDocTemplateTag(parent_17) ? rangeOfNode(
							parent_17, // Whole @template tag
						) : rangeOfTypeParameters(sourceFile, parent_17.typeParameters); // Include the `<>` in the error message
						var only = parent_17.typeParameters.length === 1;
						//TODO: following line is possible reason for bug #41974, unusedTypeParameters_TemplateTag
						var message = only ? Diagnostics._0_is_declared_but_its_value_is_never_read : Diagnostics.All_type_parameters_are_unused;
						var arg0 = only ? name_32 : undefined;
						addDiagnostic(
							typeParameter,
							1, /* Parameter */
							createFileDiagnostic(
								sourceFile,
								range.pos,
								range.end - range.pos,
								message,
								arg0,
							),
						);
					}
				} else {
					//TODO: following line is possible reason for bug #41974, unusedTypeParameters_TemplateTag
					addDiagnostic(
						typeParameter,
						1, /* Parameter */
						createDiagnosticForNode(
							typeParameter,
							Diagnostics._0_is_declared_but_its_value_is_never_read,
							name_32,
						),
					);
				}
			}
		}
		function isTypeParameterUnused(typeParameter) {
			return !(getMergedSymbol(typeParameter.symbol).isReferenced & SymbolFlags.TypeParameter) && !isIdentifierThatStartsWithUnderscore(
				typeParameter.name,
			);
		}
		function addToGroup(map, key, value, getKey) {
			var keyString = String(getKey(key));
			var group = map.get(keyString);
			if (group) {
				group[1].push(value);
			} else {
				map.set(keyString, [key, [value]]);
			}
		}
		function tryGetRootParameterDeclaration(node) {
			return tryCast(getRootDeclaration(node), isParameter);
		}
		function isValidUnusedLocalDeclaration(declaration) {
			if (isBindingElement(declaration)) {
				if (isObjectBindingPattern(declaration.parent)) {
					/**
                     * ignore starts with underscore names _
                     * const { a: _a } = { a: 1 }
                     */
					return !!(declaration.propertyName && isIdentifierThatStartsWithUnderscore(
						declaration.name,
					));
				}
				return isIdentifierThatStartsWithUnderscore(declaration.name);
			}
			return isAmbientModule(declaration) || (isVariableDeclaration(declaration) && isForInOrOfStatement(
				declaration.parent.parent,
			) || isImportedDeclaration(declaration)) && isIdentifierThatStartsWithUnderscore(
				declaration.name,
			);
		}
		function checkUnusedLocalsAndParameters(nodeWithLocals, addDiagnostic) {
			// Ideally we could use the ImportClause directly as a key, but must wait until we have full ES6 maps. So must store key along with value.
			var unusedImports = new Map();
			var unusedDestructures = new Map();
			var unusedVariables = new Map();
			nodeWithLocals.locals.forEach(
				function (local) {
					// If it's purely a type parameter, ignore, will be checked in `checkUnusedTypeParameters`.
					// If it's a type parameter merged with a parameter, check if the parameter-side is used.
					if (
						local.flags & SymbolFlags.TypeParameter ? !(local.flags & SymbolFlags.Variable && !(local.isReferenced & SymbolFlags.Variable)) : local.isReferenced || local.exportSymbol
					) {
						return;
					}
					if (local.declarations) {
						for (var _i = 0, _a = local.declarations; _i < _a.length; _i++) {
							var declaration = _a[_i];
							if (isValidUnusedLocalDeclaration(declaration)) {
								continue;
							}
							if (isImportedDeclaration(declaration)) {
								addToGroup(
									unusedImports,
									importClauseFromImported(declaration),
									declaration,
									getNodeId,
								);
							} else if (
								isBindingElement(declaration) && isObjectBindingPattern(
									declaration.parent,
								)
							) {
								// In `{ a, ...b }, `a` is considered used since it removes a property from `b`. `b` may still be unused though.
								var lastElement = last(declaration.parent.elements);
								if (
									declaration === lastElement || !last(
										declaration.parent.elements,
									).dotDotDotToken
								) {
									addToGroup(
										unusedDestructures,
										declaration.parent,
										declaration,
										getNodeId,
									);
								}
							} else if (isVariableDeclaration(declaration)) {
								addToGroup(
									unusedVariables,
									declaration.parent,
									declaration,
									getNodeId,
								);
							} else {
								var parameter = local.valueDeclaration && tryGetRootParameterDeclaration(
									local.valueDeclaration,
								);
								var name_33 = local.valueDeclaration && getNameOfDeclaration(
									local.valueDeclaration,
								);
								if (parameter && name_33) {
									if (
										!isParameterPropertyDeclaration(parameter, parameter.parent) && !parameterIsThisKeyword(
											parameter,
										) && !isIdentifierThatStartsWithUnderscore(name_33)
									) {
										if (
											isBindingElement(declaration) && isArrayBindingPattern(
												declaration.parent,
											)
										) {
											addToGroup(
												unusedDestructures,
												declaration.parent,
												declaration,
												getNodeId,
											);
										} else {
											addDiagnostic(
												parameter,
												1, /* Parameter */
												createDiagnosticForNode(
													name_33,
													Diagnostics._0_is_declared_but_its_value_is_never_read,
													symbolName(local),
												),
											);
										}
									}
								} else {
									errorUnusedLocal(
										declaration,
										symbolName(local),
										addDiagnostic,
									);
								}
							}
						}
					}
				},
			);
			unusedImports.forEach(
				function (_a) {
					var importClause = _a[0], unuseds = _a[1];
					var importDecl = importClause.parent;
					var nDeclarations = (importClause.name ? 1 : 0) + (importClause.namedBindings ? (importClause.namedBindings.kind === SyntaxKind.NamespaceImport ? 1 : importClause.namedBindings.elements.length) : 0);
					if (nDeclarations === unuseds.length) {
						addDiagnostic(
							importDecl,
							0, /* Local */
							unuseds.length === 1 ? createDiagnosticForNode(
								importDecl,
								Diagnostics._0_is_declared_but_its_value_is_never_read,
								idText(first(unuseds).name),
							) : createDiagnosticForNode(
								importDecl,
								Diagnostics.All_imports_in_import_declaration_are_unused,
							),
						);
					} else {
						for (var _i = 0, unuseds_1 = unuseds; _i < unuseds_1.length; _i++) {
							var unused = unuseds_1[_i];
							errorUnusedLocal(unused, idText(unused.name), addDiagnostic);
						}
					}
				},
			);
			unusedDestructures.forEach(
				function (_a) {
					var bindingPattern = _a[0], bindingElements = _a[1];
					var kind = tryGetRootParameterDeclaration(bindingPattern.parent) ? 1 : 0; /* Parameter */ /* Local */
					if (bindingPattern.elements.length === bindingElements.length) {
						if (
							bindingElements.length === 1 && bindingPattern.parent.kind === SyntaxKind.VariableDeclaration && bindingPattern.parent.parent.kind === SyntaxKind.VariableDeclarationList
						) {
							addToGroup(
								unusedVariables,
								bindingPattern.parent.parent,
								bindingPattern.parent,
								getNodeId,
							);
						} else {
							addDiagnostic(
								bindingPattern,
								kind,
								bindingElements.length === 1 ? createDiagnosticForNode(
									bindingPattern,
									Diagnostics._0_is_declared_but_its_value_is_never_read,
									bindingNameText(first(bindingElements).name),
								) : createDiagnosticForNode(
									bindingPattern,
									Diagnostics.All_destructured_elements_are_unused,
								),
							);
						}
					} else {
						for (
							var _i = 0, bindingElements_1 = bindingElements;
							_i < bindingElements_1.length;
							_i++
						) {
							var e = bindingElements_1[_i];
							addDiagnostic(
								e,
								kind,
								createDiagnosticForNode(
									e,
									Diagnostics._0_is_declared_but_its_value_is_never_read,
									bindingNameText(e.name),
								),
							);
						}
					}
				},
			);
			unusedVariables.forEach(
				function (_a) {
					var declarationList = _a[0], declarations = _a[1];
					if (declarationList.declarations.length === declarations.length) {
						addDiagnostic(
							declarationList,
							0, /* Local */
							declarations.length === 1 ? createDiagnosticForNode(
								first(declarations).name,
								Diagnostics._0_is_declared_but_its_value_is_never_read,
								bindingNameText(first(declarations).name),
							) : createDiagnosticForNode(
								declarationList.parent.kind === SyntaxKind.VariableStatement ? declarationList.parent : declarationList,
								Diagnostics.All_variables_are_unused,
							),
						);
					} else {
						for (
							var _i = 0, declarations_4 = declarations;
							_i < declarations_4.length;
							_i++
						) {
							var decl = declarations_4[_i];
							addDiagnostic(
								decl,
								0, /* Local */
								createDiagnosticForNode(
									decl,
									Diagnostics._0_is_declared_but_its_value_is_never_read,
									bindingNameText(decl.name),
								),
							);
						}
					}
				},
			);
		}
		function bindingNameText(name) {
			switch (name.kind) {
				case SyntaxKind.Identifier:
					return idText(name);
				case SyntaxKind.ArrayBindingPattern:
				case SyntaxKind.ObjectBindingPattern:
					return bindingNameText(
						cast(first(name.elements), isBindingElement).name,
					);
				default:
					return Debug.assertNever(name);
			}
		}
		function isImportedDeclaration(node) {
			return node.kind === SyntaxKind.ImportClause || node.kind === SyntaxKind.ImportSpecifier || node.kind === SyntaxKind.NamespaceImport;
		}
		function importClauseFromImported(decl) {
			return decl.kind === SyntaxKind.ImportClause ? decl : decl.kind === SyntaxKind.NamespaceImport ? decl.parent : decl.parent.parent;
		}
		function checkBlock(node) {
			// Grammar checking for SyntaxKind.Block
			if (node.kind === SyntaxKind.Block) {
				checkGrammarStatementInAmbientContext(node);
			}
			if (isFunctionOrModuleBlock(node)) {
				var saveFlowAnalysisDisabled = flowAnalysisDisabled;
				forEach(node.statements, checkSourceElement);
				flowAnalysisDisabled = saveFlowAnalysisDisabled;
			} else {
				forEach(node.statements, checkSourceElement);
			}
			if (node.locals) {
				registerForUnusedIdentifiersCheck(node);
			}
		}
		function checkCollisionWithArgumentsInGeneratedCode(node) {
			// no rest parameters \ declaration context \ overload - no codegen impact
			if (
				languageVersion >= ScriptTarget.ES2015 || !hasRestParameter(node) || node.flags & NodeFlags.Ambient || nodeIsMissing(
					node.body,
				)
			) {
				return;
			}
			forEach(
				node.parameters,
				function (p) {
					if (
						p.name && !isBindingPattern(p.name) && p.name.escapedText === argumentsSymbol.escapedName
					) {
						errorSkippedOn(
							"noEmit",
							p,
							Diagnostics.Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters,
						);
					}
				},
			);
		}
		/**
         * Checks whether an {@link Identifier}, in the context of another {@link Node}, would collide with a runtime value
         * of {@link name} in an outer scope. This is used to check for collisions for downlevel transformations that
         * require names like `Object`, `Promise`, `Reflect`, `require`, `exports`, etc.
         */
		function needCollisionCheckForIdentifier(node, identifier, name) {
			if (
				(identifier === null || identifier === void 0 ? void 0 : identifier.escapedText) !== name
			) {
				return false;
			}
			if (
				node.kind === SyntaxKind.PropertyDeclaration || node.kind === SyntaxKind.PropertySignature || node.kind === SyntaxKind.MethodDeclaration || node.kind === SyntaxKind.MethodSignature || node.kind === SyntaxKind.GetAccessor || node.kind === SyntaxKind.SetAccessor || node.kind === SyntaxKind.PropertyAssignment
			) {
				// it is ok to have member named '_super', '_this', `Promise`, etc. - member access is always qualified
				return false;
			}
			if (node.flags & NodeFlags.Ambient) {
				// ambient context - no codegen impact
				return false;
			}
			if (
				isImportClause(node) || isImportEqualsDeclaration(node) || isImportSpecifier(
					node,
				)
			) {
				// type-only imports do not require collision checks against runtime values.
				if (isTypeOnlyImportOrExportDeclaration(node)) {
					return false;
				}
			}
			var root = getRootDeclaration(node);
			if (isParameter(root) && nodeIsMissing(root.parent.body)) {
				// just an overload - no codegen impact
				return false;
			}
			return true;
		}
		// this function will run after checking the source file so 'CaptureThis' is correct for all nodes
		function checkIfThisIsCapturedInEnclosingScope(node) {
			findAncestor(
				node,
				function (current) {
					if (getNodeCheckFlags(current) & NodeCheckFlags.CaptureThis) {
						var isDeclaration = node.kind !== SyntaxKind.Identifier;
						if (isDeclaration) {
							error(
								getNameOfDeclaration(node),
								Diagnostics.Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference,
							);
						} else {
							error(
								node,
								Diagnostics.Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference,
							);
						}
						return true;
					}
					return false;
				},
			);
		}
		function checkIfNewTargetIsCapturedInEnclosingScope(node) {
			findAncestor(
				node,
				function (current) {
					if (getNodeCheckFlags(current) & NodeCheckFlags.CaptureNewTarget) {
						var isDeclaration = node.kind !== SyntaxKind.Identifier;
						if (isDeclaration) {
							error(
								getNameOfDeclaration(node),
								Diagnostics.Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_meta_property_reference,
							);
						} else {
							error(
								node,
								Diagnostics.Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta_property_reference,
							);
						}
						return true;
					}
					return false;
				},
			);
		}
		function checkCollisionWithRequireExportsInGeneratedCode(node, name) {
			// No need to check for require or exports for ES6 modules and later
			if (
				moduleKind >= ModuleKind.ES2015 && !(moduleKind >= ModuleKind.Node12 && getSourceFileOfNode(
					node,
				).impliedNodeFormat === ModuleKind.CommonJS)
			) {
				return;
			}
			if (
				!name || !needCollisionCheckForIdentifier(node, name, "require") && !needCollisionCheckForIdentifier(
					node,
					name,
					"exports",
				)
			) {
				return;
			}
			// Uninstantiated modules shouldnt do this check
			if (
				isModuleDeclaration(node) && getModuleInstanceState(node) !== ModuleInstanceState.Instantiated
			) {
				return;
			}
			// In case of variable declaration, node.parent is variable statement so look at the variable statement's parent
			var parent = getDeclarationContainer(node);
			if (
				parent.kind === SyntaxKind.SourceFile && isExternalOrCommonJsModule(
					parent,
				)
			) {
				// If the declaration happens to be in external module, report error that require and exports are reserved keywords
				errorSkippedOn(
					"noEmit",
					name,
					Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module,
					declarationNameToString(name),
					declarationNameToString(name),
				);
			}
		}
		function checkCollisionWithGlobalPromiseInGeneratedCode(node, name) {
			if (
				!name || languageVersion >= ScriptTarget.ES2017 || !needCollisionCheckForIdentifier(
					node,
					name,
					"Promise",
				)
			) {
				return;
			}
			// Uninstantiated modules shouldnt do this check
			if (
				isModuleDeclaration(node) && getModuleInstanceState(node) !== ModuleInstanceState.Instantiated
			) {
				return;
			}
			// In case of variable declaration, node.parent is variable statement so look at the variable statement's parent
			var parent = getDeclarationContainer(node);
			if (
				parent.kind === SyntaxKind.SourceFile && isExternalOrCommonJsModule(
					parent,
				) && parent.flags & NodeFlags.HasAsyncFunctions
			) {
				// If the declaration happens to be in external module, report error that Promise is a reserved identifier.
				errorSkippedOn(
					"noEmit",
					name,
					Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_functions,
					declarationNameToString(name),
					declarationNameToString(name),
				);
			}
		}
		function recordPotentialCollisionWithWeakMapSetInGeneratedCode(node, name) {
			if (
				languageVersion <= ScriptTarget.ES2021 && (needCollisionCheckForIdentifier(
					node,
					name,
					"WeakMap",
				) || needCollisionCheckForIdentifier(node, name, "WeakSet"))
			) {
				potentialWeakMapSetCollisions.push(node);
			}
		}
		function checkWeakMapSetCollision(node) {
			var enclosingBlockScope = getEnclosingBlockScopeContainer(node);
			if (
				getNodeCheckFlags(enclosingBlockScope) & NodeCheckFlags.ContainsClassWithPrivateIdentifiers
			) {
				Debug.assert(
					isNamedDeclaration(node) && isIdentifier(node.name) && typeof node.name.escapedText === "string",
					"The target of a WeakMap/WeakSet collision check should be an identifier",
				);
				errorSkippedOn(
					"noEmit",
					node,
					Diagnostics.Compiler_reserves_name_0_when_emitting_private_identifier_downlevel,
					node.name.escapedText,
				);
			}
		}
		function recordPotentialCollisionWithReflectInGeneratedCode(node, name) {
			if (
				name && languageVersion >= ScriptTarget.ES2015 && languageVersion <= ScriptTarget.ES2021 && needCollisionCheckForIdentifier(
					node,
					name,
					"Reflect",
				)
			) {
				potentialReflectCollisions.push(node);
			}
		}
		function checkReflectCollision(node) {
			var hasCollision = false;
			if (isClassExpression(node)) {
				// ClassExpression names don't contribute to their containers, but do matter for any of their block-scoped members.
				for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
					var member = _a[_i];
					if (
						getNodeCheckFlags(member) & NodeCheckFlags.ContainsSuperPropertyInStaticInitializer
					) {
						hasCollision = true;
						break;
					}
				}
			} else if (isFunctionExpression(node)) {
				// FunctionExpression names don't contribute to their containers, but do matter for their contents
				if (
					getNodeCheckFlags(node) & NodeCheckFlags.ContainsSuperPropertyInStaticInitializer
				) {
					hasCollision = true;
				}
			} else {
				var container = getEnclosingBlockScopeContainer(node);
				if (
					container && getNodeCheckFlags(container) & NodeCheckFlags.ContainsSuperPropertyInStaticInitializer
				) {
					hasCollision = true;
				}
			}
			if (hasCollision) {
				Debug.assert(
					isNamedDeclaration(node) && isIdentifier(node.name),
					"The target of a Reflect collision check should be an identifier",
				);
				errorSkippedOn(
					"noEmit",
					node,
					Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_when_emitting_super_references_in_static_initializers,
					declarationNameToString(node.name),
					"Reflect",
				);
			}
		}
		function checkCollisionsForDeclarationName(node, name) {
			if (!name) return;
			checkCollisionWithRequireExportsInGeneratedCode(node, name);
			checkCollisionWithGlobalPromiseInGeneratedCode(node, name);
			recordPotentialCollisionWithWeakMapSetInGeneratedCode(node, name);
			recordPotentialCollisionWithReflectInGeneratedCode(node, name);
			if (isClassLike(node)) {
				checkTypeNameIsReserved(name, Diagnostics.Class_name_cannot_be_0);
				if (!(node.flags & NodeFlags.Ambient)) {
					checkClassNameCollisionWithObject(name);
				}
			} else if (isEnumDeclaration(node)) {
				checkTypeNameIsReserved(name, Diagnostics.Enum_name_cannot_be_0);
			}
		}
		function checkVarDeclaredNamesNotShadowed(node) {
			// - ScriptBody : StatementList
			// It is a Syntax Error if any element of the LexicallyDeclaredNames of StatementList
			// also occurs in the VarDeclaredNames of StatementList.
			// - Block : { StatementList }
			// It is a Syntax Error if any element of the LexicallyDeclaredNames of StatementList
			// also occurs in the VarDeclaredNames of StatementList.
			// Variable declarations are hoisted to the top of their function scope. They can shadow
			// block scoped declarations, which bind tighter. this will not be flagged as duplicate definition
			// by the binder as the declaration scope is different.
			// A non-initialized declaration is a no-op as the block declaration will resolve before the var
			// declaration. the problem is if the declaration has an initializer. this will act as a write to the
			// block declared value. this is fine for let, but not const.
			// Only consider declarations with initializers, uninitialized const declarations will not
			// step on a let/const variable.
			// Do not consider const and const declarations, as duplicate block-scoped declarations
			// are handled by the binder.
			// We are only looking for const declarations that step on let\const declarations from a
			// different scope. e.g.:
			//      {
			//          const x = 0; // localDeclarationSymbol obtained after name resolution will correspond to this declaration
			//          const x = 0; // symbol for this declaration will be 'symbol'
			//      }
			// skip block-scoped variables and parameters
			if (
				(getCombinedNodeFlags(node) & NodeFlags.BlockScoped) !== 0 || isParameterDeclaration(
					node,
				)
			) {
				return;
			}
			// skip variable declarations that don't have initializers
			// NOTE: in ES6 spec initializer is required in variable declarations where name is binding pattern
			// so we'll always treat binding elements as initialized
			if (node.kind === SyntaxKind.VariableDeclaration && !node.initializer) {
				return;
			}
			var symbol = getSymbolOfNode(node);
			if (symbol.flags & SymbolFlags.FunctionScopedVariable) {
				if (!isIdentifier(node.name)) return Debug.fail();
				var localDeclarationSymbol = resolveName(
					node,
					node.name.escapedText,
					SymbolFlags.Variable, /*nodeNotFoundErrorMessage*/
					undefined, /*nameArg*/
					undefined, /*isUse*/
					false,
				);
				if (
					localDeclarationSymbol && localDeclarationSymbol !== symbol && localDeclarationSymbol.flags & SymbolFlags.BlockScopedVariable
				) {
					if (
						getDeclarationNodeFlagsFromSymbol(localDeclarationSymbol) & NodeFlags.BlockScoped
					) {
						var varDeclList = getAncestor(
							localDeclarationSymbol.valueDeclaration,
							SyntaxKind.VariableDeclarationList,
						);
						var container = varDeclList.parent.kind === SyntaxKind.VariableStatement && varDeclList.parent.parent ? varDeclList.parent.parent : undefined;
						// names of block-scoped and function scoped variables can collide only
						// if block scoped variable is defined in the function\module\source file scope (because of variable hoisting)
						var namesShareScope = container && (container.kind === SyntaxKind.Block && isFunctionLike(
							container.parent,
						) || container.kind === SyntaxKind.ModuleBlock || container.kind === SyntaxKind.ModuleDeclaration || container.kind === SyntaxKind.SourceFile);
						// here we know that function scoped variable is shadowed by block scoped one
						// if they are defined in the same scope - binder has already reported redeclaration error
						// otherwise if variable has an initializer - show error that initialization will fail
						// since LHS will be block scoped name instead of function scoped
						if (!namesShareScope) {
							var name_34 = symbolToString(localDeclarationSymbol);
							error(
								node,
								Diagnostics.Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1,
								name_34,
								name_34,
							);
						}
					}
				}
			}
		}
		function convertAutoToAny(type) {
			return type === autoType ? anyType : type === autoArrayType ? anyArrayType : type;
		}
		// Check variable, parameter, or property declaration
		function checkVariableLikeDeclaration(node) {
			var _a;
			checkDecorators(node);
			if (!isBindingElement(node)) {
				checkSourceElement(node.type);
			}
			// JSDoc `function(string, string): string` syntax results in parameters with no name
			if (!node.name) {
				return;
			}
			// For a computed property, just check the initializer and exit
			// Do not use hasDynamicName here, because that returns false for well known symbols.
			// We want to perform checkComputedPropertyName for all computed properties, including
			// well known symbols.
			if (node.name.kind === SyntaxKind.ComputedPropertyName) {
				checkComputedPropertyName(node.name);
				if (node.initializer) {
					checkExpressionCached(node.initializer);
				}
			}
			if (isBindingElement(node)) {
				if (
					isObjectBindingPattern(node.parent) && node.dotDotDotToken && languageVersion < ScriptTarget.ES2018
				) {
					checkExternalEmitHelpers(node, ExternalEmitHelpers.Rest);
				}
				// check computed properties inside property names of binding elements
				if (
					node.propertyName && node.propertyName.kind === SyntaxKind.ComputedPropertyName
				) {
					checkComputedPropertyName(node.propertyName);
				}
				// check private/protected variable access
				var parent_18 = node.parent.parent;
				var parentType = getTypeForBindingElementParent(parent_18);
				var name_35 = node.propertyName || node.name;
				if (parentType && !isBindingPattern(name_35)) {
					var exprType = getLiteralTypeFromPropertyName(name_35);
					if (isTypeUsableAsPropertyName(exprType)) {
						var nameText = getPropertyNameFromType(exprType);
						var property = getPropertyOfType(parentType, nameText);
						if (property) {
							markPropertyAsReferenced(
								property, /*nodeForCheckWriteOnly*/
								undefined, /*isSelfTypeAccess*/
								false,
							); // A destructuring is never a write-only reference.
							checkPropertyAccessibility(
								node,
								!!parent_18.initializer && parent_18.initializer.kind === SyntaxKind.SuperKeyword, /*writing*/
								false,
								parentType,
								property,
							);
						}
					}
				}
			}
			// For a binding pattern, check contained binding elements
			if (isBindingPattern(node.name)) {
				if (
					node.name.kind === SyntaxKind.ArrayBindingPattern && languageVersion < ScriptTarget.ES2015 && compilerOptions.downlevelIteration
				) {
					checkExternalEmitHelpers(node, ExternalEmitHelpers.Read);
				}
				forEach(node.name.elements, checkSourceElement);
			}
			// For a parameter declaration with an initializer, error and exit if the containing function doesn't have a body
			if (
				node.initializer && isParameterDeclaration(node) && nodeIsMissing(
					getContainingFunction(node).body,
				)
			) {
				error(
					node,
					Diagnostics.A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation,
				);
				return;
			}
			// For a binding pattern, validate the initializer and exit
			if (isBindingPattern(node.name)) {
				var needCheckInitializer = node.initializer && node.parent.parent.kind !== SyntaxKind.ForInStatement;
				var needCheckWidenedType = node.name.elements.length === 0;
				if (needCheckInitializer || needCheckWidenedType) {
					// Don't validate for-in initializer as it is already an error
					var widenedType = getWidenedTypeForVariableLikeDeclaration(node);
					if (needCheckInitializer) {
						var initializerType = checkExpressionCached(node.initializer);
						if (strictNullChecks && needCheckWidenedType) {
							checkNonNullNonVoidType(initializerType, node);
						} else {
							checkTypeAssignableToAndOptionallyElaborate(
								initializerType,
								getWidenedTypeForVariableLikeDeclaration(node),
								node,
								node.initializer,
							);
						}
					}
					// check the binding pattern with empty elements
					if (needCheckWidenedType) {
						if (isArrayBindingPattern(node.name)) {
							checkIteratedTypeOrElementType(
								65, /* Destructuring */
								widenedType,
								undefinedType,
								node,
							);
						} else if (strictNullChecks) {
							checkNonNullNonVoidType(widenedType, node);
						}
					}
				}
				return;
			}
			// For a commonjs `const x = require`, validate the alias and exit
			var symbol = getSymbolOfNode(node);
			if (
				symbol.flags & SymbolFlags.Alias && isRequireVariableDeclaration(node)
			) {
				checkAliasSymbol(node);
				return;
			}
			var type = convertAutoToAny(getTypeOfSymbol(symbol));
			if (node === symbol.valueDeclaration) {
				// Node is the primary declaration of the symbol, just validate the initializer
				// Don't validate for-in initializer as it is already an error
				var initializer = getEffectiveInitializer(node);
				if (initializer) {
					var isJSObjectLiteralInitializer = isInJSFile(node) && isObjectLiteralExpression(
						initializer,
					) && (initializer.properties.length === 0 || isPrototypeAccess(
						node.name,
					)) && !!((_a = symbol.exports) === null || _a === void 0 ? void 0 : _a.size);
					if (
						!isJSObjectLiteralInitializer && node.parent.parent.kind !== SyntaxKind.ForInStatement
					) {
						checkTypeAssignableToAndOptionallyElaborate(
							checkExpressionCached(initializer),
							type,
							node,
							initializer, /*headMessage*/
							undefined,
						);
					}
				}
				if (symbol.declarations && symbol.declarations.length > 1) {
					if (
						some(
							symbol.declarations,
							function (d) {
								return d !== node && isVariableLike(d) && !areDeclarationFlagsIdentical(
									d,
									node,
								);
							},
						)
					) {
						error(
							node.name,
							Diagnostics.All_declarations_of_0_must_have_identical_modifiers,
							declarationNameToString(node.name),
						);
					}
				}
			} else {
				// Node is a secondary declaration, check that type is identical to primary declaration and check that
				// initializer is consistent with type associated with the node
				var declarationType = convertAutoToAny(
					getWidenedTypeForVariableLikeDeclaration(node),
				);
				if (
					!isErrorType(type) && !isErrorType(declarationType) && !isTypeIdenticalTo(
						type,
						declarationType,
					) && !(symbol.flags & SymbolFlags.Assignment)
				) {
					errorNextVariableOrPropertyDeclarationMustHaveSameType(
						symbol.valueDeclaration,
						type,
						node,
						declarationType,
					);
				}
				if (node.initializer) {
					checkTypeAssignableToAndOptionallyElaborate(
						checkExpressionCached(node.initializer),
						declarationType,
						node,
						node.initializer, /*headMessage*/
						undefined,
					);
				}
				if (
					symbol.valueDeclaration && !areDeclarationFlagsIdentical(
						node,
						symbol.valueDeclaration,
					)
				) {
					error(
						node.name,
						Diagnostics.All_declarations_of_0_must_have_identical_modifiers,
						declarationNameToString(node.name),
					);
				}
			}
			if (
				node.kind !== SyntaxKind.PropertyDeclaration && node.kind !== SyntaxKind.PropertySignature
			) {
				// We know we don't have a binding pattern or computed name here
				checkExportsOnMergedDeclarations(node);
				if (
					node.kind === SyntaxKind.VariableDeclaration || node.kind === SyntaxKind.BindingElement
				) {
					checkVarDeclaredNamesNotShadowed(node);
				}
				checkCollisionsForDeclarationName(node, node.name);
			}
		}
		function errorNextVariableOrPropertyDeclarationMustHaveSameType(
			firstDeclaration,
			firstType,
			nextDeclaration,
			nextType,
		) {
			var nextDeclarationName = getNameOfDeclaration(nextDeclaration);
			var message = nextDeclaration.kind === SyntaxKind.PropertyDeclaration || nextDeclaration.kind === SyntaxKind.PropertySignature ? Diagnostics.Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_type_2 : Diagnostics.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2;
			var declName = declarationNameToString(nextDeclarationName);
			var err = error(
				nextDeclarationName,
				message,
				declName,
				typeToString(firstType),
				typeToString(nextType),
			);
			if (firstDeclaration) {
				addRelatedInfo(
					err,
					createDiagnosticForNode(
						firstDeclaration,
						Diagnostics._0_was_also_declared_here,
						declName,
					),
				);
			}
		}
		function areDeclarationFlagsIdentical(left, right) {
			if (
				(left.kind === SyntaxKind.Parameter && right.kind === SyntaxKind.VariableDeclaration) || (left.kind === SyntaxKind.VariableDeclaration && right.kind === SyntaxKind.Parameter)
			) {
				// Differences in optionality between parameters and variables are allowed.
				return true;
			}
			if (hasQuestionToken(left) !== hasQuestionToken(right)) {
				return false;
			}
			var interestingFlags = ModifierFlags.Private | ModifierFlags.Protected | ModifierFlags.Async | ModifierFlags.Abstract | ModifierFlags.Readonly | ModifierFlags.Static;
			return getSelectedEffectiveModifierFlags(left, interestingFlags) === getSelectedEffectiveModifierFlags(
				right,
				interestingFlags,
			);
		}
		function checkVariableDeclaration(node) {
			tracing === null || tracing === void 0 ? void 0 : tracing.push(
				tracing.Phase.Check,
				"checkVariableDeclaration",
				{ kind: node.kind, pos: node.pos, end: node.end },
			);
			checkGrammarVariableDeclaration(node);
			checkVariableLikeDeclaration(node);
			tracing === null || tracing === void 0 ? void 0 : tracing.pop();
		}
		function checkBindingElement(node) {
			checkGrammarBindingElement(node);
			return checkVariableLikeDeclaration(node);
		}
		function checkVariableStatement(node) {
			// Grammar checking
			if (
				!checkGrammarDecoratorsAndModifiers(node) && !checkGrammarVariableDeclarationList(
					node.declarationList,
				)
			) checkGrammarForDisallowedLetOrConstStatement(node);
			forEach(node.declarationList.declarations, checkSourceElement);
		}
		function checkExpressionStatement(node) {
			// Grammar checking
			checkGrammarStatementInAmbientContext(node);
			checkExpression(node.expression);
		}
		function checkIfStatement(node) {
			// Grammar checking
			checkGrammarStatementInAmbientContext(node);
			var type = checkTruthinessExpression(node.expression);
			checkTestingKnownTruthyCallableOrAwaitableType(
				node.expression,
				type,
				node.thenStatement,
			);
			checkSourceElement(node.thenStatement);
			if (node.thenStatement.kind === SyntaxKind.EmptyStatement) {
				error(
					node.thenStatement,
					Diagnostics.The_body_of_an_if_statement_cannot_be_the_empty_statement,
				);
			}
			checkSourceElement(node.elseStatement);
		}
		function checkTestingKnownTruthyCallableOrAwaitableType(
			condExpr,
			type,
			body,
		) {
			if (!strictNullChecks) return;
			if (getFalsyFlags(type)) return;
			var location = isBinaryExpression(condExpr) ? condExpr.right : condExpr;
			if (
				isPropertyAccessExpression(location) && isTypeAssertion(
					location.expression,
				)
			) {
				return;
			}
			var testedNode = isIdentifier(location) ? location : isPropertyAccessExpression(
				location,
			) ? location.name : isBinaryExpression(location) && isIdentifier(
				location.right,
			) ? location.right : undefined;
			// While it technically should be invalid for any known-truthy value
			// to be tested, we de-scope to functions and Promises unreferenced in
			// the block as a heuristic to identify the most common bugs. There
			// are too many false positives for values sourced from type
			// definitions without strictNullChecks otherwise.
			var callSignatures = getSignaturesOfType(type, SignatureKind.Call);
			var isPromise = !!getAwaitedTypeOfPromise(type);
			if (callSignatures.length === 0 && !isPromise) {
				return;
			}
			var testedSymbol = testedNode && getSymbolAtLocation(testedNode);
			if (!testedSymbol && !isPromise) {
				return;
			}
			var isUsed = testedSymbol && isBinaryExpression(condExpr.parent) && isSymbolUsedInBinaryExpressionChain(
				condExpr.parent,
				testedSymbol,
			) || testedSymbol && body && isSymbolUsedInConditionBody(
				condExpr,
				body,
				testedNode,
				testedSymbol,
			);
			if (!isUsed) {
				if (isPromise) {
					errorAndMaybeSuggestAwait(
						location,
						/*maybeMissingAwait*/ true,
						Diagnostics.This_condition_will_always_return_true_since_this_0_is_always_defined,
						getTypeNameForErrorDisplay(type),
					);
				} else {
					error(
						location,
						Diagnostics.This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_instead,
					);
				}
			}
		}
		function isSymbolUsedInConditionBody(expr, body, testedNode, testedSymbol) {
			return !!forEachChild(
				body,
				function check(childNode) {
					if (isIdentifier(childNode)) {
						var childSymbol = getSymbolAtLocation(childNode);
						if (childSymbol && childSymbol === testedSymbol) {
							// If the test was a simple identifier, the above check is sufficient
							if (isIdentifier(expr)) {
								return true;
							}
							// Otherwise we need to ensure the symbol is called on the same target
							var testedExpression = testedNode.parent;
							var childExpression = childNode.parent;
							while (testedExpression && childExpression) {
								if (
									isIdentifier(testedExpression) && isIdentifier(
										childExpression,
									) || testedExpression.kind === SyntaxKind.ThisKeyword && childExpression.kind === SyntaxKind.ThisKeyword
								) {
									return getSymbolAtLocation(testedExpression) === getSymbolAtLocation(
										childExpression,
									);
								} else if (
									isPropertyAccessExpression(testedExpression) && isPropertyAccessExpression(
										childExpression,
									)
								) {
									if (
										getSymbolAtLocation(testedExpression.name) !== getSymbolAtLocation(
											childExpression.name,
										)
									) {
										return false;
									}
									childExpression = childExpression.expression;
									testedExpression = testedExpression.expression;
								} else if (
									isCallExpression(testedExpression) && isCallExpression(
										childExpression,
									)
								) {
									childExpression = childExpression.expression;
									testedExpression = testedExpression.expression;
								} else {
									return false;
								}
							}
						}
					}
					return forEachChild(childNode, check);
				},
			);
		}
		function isSymbolUsedInBinaryExpressionChain(node, testedSymbol) {
			while (
				isBinaryExpression(node) && node.operatorToken.kind === SyntaxKind.AmpersandAmpersandToken
			) {
				var isUsed = forEachChild(
					node.right,
					function visit(child) {
						if (isIdentifier(child)) {
							var symbol = getSymbolAtLocation(child);
							if (symbol && symbol === testedSymbol) {
								return true;
							}
						}
						return forEachChild(child, visit);
					},
				);
				if (isUsed) {
					return true;
				}
				node = node.parent;
			}
			return false;
		}
		function checkDoStatement(node) {
			// Grammar checking
			checkGrammarStatementInAmbientContext(node);
			checkSourceElement(node.statement);
			checkTruthinessExpression(node.expression);
		}
		function checkWhileStatement(node) {
			// Grammar checking
			checkGrammarStatementInAmbientContext(node);
			checkTruthinessExpression(node.expression);
			checkSourceElement(node.statement);
		}
		function checkTruthinessOfType(type, node) {
			if (type.flags & TypeFlags.Void) {
				error(
					node,
					Diagnostics.An_expression_of_type_void_cannot_be_tested_for_truthiness,
				);
			}
			return type;
		}
		function checkTruthinessExpression(node, checkMode) {
			return checkTruthinessOfType(checkExpression(node, checkMode), node);
		}
		function checkForStatement(node) {
			// Grammar checking
			if (!checkGrammarStatementInAmbientContext(node)) {
				if (
					node.initializer && node.initializer.kind === SyntaxKind.VariableDeclarationList
				) {
					checkGrammarVariableDeclarationList(node.initializer);
				}
			}
			if (node.initializer) {
				if (node.initializer.kind === SyntaxKind.VariableDeclarationList) {
					forEach(node.initializer.declarations, checkVariableDeclaration);
				} else {
					checkExpression(node.initializer);
				}
			}
			if (node.condition) checkTruthinessExpression(node.condition);
			if (node.incrementor) checkExpression(node.incrementor);
			checkSourceElement(node.statement);
			if (node.locals) {
				registerForUnusedIdentifiersCheck(node);
			}
		}
		function checkForOfStatement(node) {
			checkGrammarForInOrForOfStatement(node);
			var container = getContainingFunctionOrClassStaticBlock(node);
			if (node.awaitModifier) {
				if (container && isClassStaticBlockDeclaration(container)) {
					grammarErrorOnNode(
						node.awaitModifier,
						Diagnostics.For_await_loops_cannot_be_used_inside_a_class_static_block,
					);
				} else {
					var functionFlags = getFunctionFlags(container);
					if (
						(functionFlags & (FunctionFlags.Invalid | FunctionFlags.Async)) === FunctionFlags.Async && languageVersion < ScriptTarget.ESNext
					) {
						// for..await..of in an async function or async generator function prior to ESNext requires the __asyncValues helper
						checkExternalEmitHelpers(
							node,
							ExternalEmitHelpers.ForAwaitOfIncludes,
						);
					}
				}
			} else if (
				compilerOptions.downlevelIteration && languageVersion < ScriptTarget.ES2015
			) {
				// for..of prior to ES2015 requires the __values helper when downlevelIteration is enabled
				checkExternalEmitHelpers(node, ExternalEmitHelpers.ForOfIncludes);
			}
			// Check the LHS and RHS
			// If the LHS is a declaration, just check it as a variable declaration, which will in turn check the RHS
			// via checkRightHandSideOfForOf.
			// If the LHS is an expression, check the LHS, as a destructuring assignment or as a reference.
			// Then check that the RHS is assignable to it.
			if (node.initializer.kind === SyntaxKind.VariableDeclarationList) {
				checkForInOrForOfVariableDeclaration(node);
			} else {
				var varExpr = node.initializer;
				var iteratedType = checkRightHandSideOfForOf(node);
				// There may be a destructuring assignment on the left side
				if (
					varExpr.kind === SyntaxKind.ArrayLiteralExpression || varExpr.kind === SyntaxKind.ObjectLiteralExpression
				) {
					// iteratedType may be undefined. In this case, we still want to check the structure of
					// varExpr, in particular making sure it's a valid LeftHandSideExpression. But we'd like
					// to short circuit the type relation checking as much as possible, so we pass the unknownType.
					checkDestructuringAssignment(varExpr, iteratedType || errorType);
				} else {
					var leftType = checkExpression(varExpr);
					checkReferenceExpression(
						varExpr,
						Diagnostics.The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access,
						Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access,
					);
					// iteratedType will be undefined if the rightType was missing properties/signatures
					// required to get its iteratedType (like [Symbol.iterator] or next). This may be
					// because we accessed properties from anyType, or it may have led to an error inside
					// getElementTypeOfIterable.
					if (iteratedType) {
						checkTypeAssignableToAndOptionallyElaborate(
							iteratedType,
							leftType,
							varExpr,
							node.expression,
						);
					}
				}
			}
			checkSourceElement(node.statement);
			if (node.locals) {
				registerForUnusedIdentifiersCheck(node);
			}
		}
		function checkForInStatement(node) {
			// Grammar checking
			checkGrammarForInOrForOfStatement(node);
			var rightType = getNonNullableTypeIfNeeded(
				checkExpression(node.expression),
			);
			// TypeScript 1.0 spec (April 2014): 5.4
			// In a 'for-in' statement of the form
			// for (let VarDecl in Expr) Statement
			//   VarDecl must be a variable declaration without a type annotation that declares a variable of type Any,
			//   and Expr must be an expression of type Any, an object type, or a type parameter type.
			if (node.initializer.kind === SyntaxKind.VariableDeclarationList) {
				var variable = node.initializer.declarations[0];
				if (variable && isBindingPattern(variable.name)) {
					error(
						variable.name,
						Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern,
					);
				}
				checkForInOrForOfVariableDeclaration(node);
			} else {
				// In a 'for-in' statement of the form
				// for (Var in Expr) Statement
				//   Var must be an expression classified as a reference of type Any or the String primitive type,
				//   and Expr must be an expression of type Any, an object type, or a type parameter type.
				var varExpr = node.initializer;
				var leftType = checkExpression(varExpr);
				if (
					varExpr.kind === SyntaxKind.ArrayLiteralExpression || varExpr.kind === SyntaxKind.ObjectLiteralExpression
				) {
					error(
						varExpr,
						Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern,
					);
				} else if (
					!isTypeAssignableTo(getIndexTypeOrString(rightType), leftType)
				) {
					error(
						varExpr,
						Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any,
					);
				} else {
					// run check only former check succeeded to avoid cascading errors
					checkReferenceExpression(
						varExpr,
						Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access,
						Diagnostics.The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access,
					);
				}
			}
			// unknownType is returned i.e. if node.expression is identifier whose name cannot be resolved
			// in this case error about missing name is already reported - do not report extra one
			if (
				rightType === neverType || !isTypeAssignableToKind(
					rightType,
					TypeFlags.NonPrimitive | TypeFlags.InstantiableNonPrimitive,
				)
			) {
				error(
					node.expression,
					Diagnostics.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_here_has_type_0,
					typeToString(rightType),
				);
			}
			checkSourceElement(node.statement);
			if (node.locals) {
				registerForUnusedIdentifiersCheck(node);
			}
		}
		function checkForInOrForOfVariableDeclaration(iterationStatement) {
			var variableDeclarationList = iterationStatement.initializer;
			// checkGrammarForInOrForOfStatement will check that there is exactly one declaration.
			if (variableDeclarationList.declarations.length >= 1) {
				var decl = variableDeclarationList.declarations[0];
				checkVariableDeclaration(decl);
			}
		}
		function checkRightHandSideOfForOf(statement) {
			var use = statement.awaitModifier ? 15 /* ForAwaitOf */ : 13 /* ForOf */ ;
			return checkIteratedTypeOrElementType(
				use,
				checkNonNullExpression(statement.expression),
				undefinedType,
				statement.expression,
			);
		}
		function checkIteratedTypeOrElementType(use, inputType, sentType, errorNode) {
			if (isTypeAny(inputType)) {
				return inputType;
			}
			return getIteratedTypeOrElementType(
				use,
				inputType,
				sentType,
				errorNode, /*checkAssignability*/
				true,
			) || anyType;
		}
		/**
         * When consuming an iterable type in a for..of, spread, or iterator destructuring assignment
         * we want to get the iterated type of an iterable for ES2015 or later, or the iterated type
         * of a iterable (if defined globally) or element type of an array like for ES2015 or earlier.
         */
		function getIteratedTypeOrElementType(
			use,
			inputType,
			sentType,
			errorNode,
			checkAssignability,
		) {
			var allowAsyncIterables = (use & 2 /* AllowsAsyncIterablesFlag */ ) !== 0;
			if (inputType === neverType) {
				reportTypeNotIterableError(errorNode, inputType, allowAsyncIterables); // TODO: GH#18217
				return undefined;
			}
			var uplevelIteration = languageVersion >= ScriptTarget.ES2015;
			var downlevelIteration = !uplevelIteration && compilerOptions.downlevelIteration;
			var possibleOutOfBounds = compilerOptions.noUncheckedIndexedAccess && !!(use & 128); /* PossiblyOutOfBounds */
			// Get the iterated type of an `Iterable<T>` or `IterableIterator<T>` only in ES2015
			// or higher, when inside of an async generator or for-await-if, or when
			// downlevelIteration is requested.
			if (uplevelIteration || downlevelIteration || allowAsyncIterables) {
				// We only report errors for an invalid iterable type in ES2015 or higher.
				var iterationTypes = getIterationTypesOfIterable(
					inputType,
					use,
					uplevelIteration ? errorNode : undefined,
				);
				if (checkAssignability) {
					if (iterationTypes) {
						var diagnostic = use & 8 ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_send_0 : use & 32 ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_always_send_0 : use & 64 ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring_will_always_send_0 : use & 16 ? Diagnostics.Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_containing_generator_will_always_send_0 : undefined; /* ForOfFlag */ /* SpreadFlag */ /* DestructuringFlag */ /* YieldStarFlag */
						if (diagnostic) {
							checkTypeAssignableTo(
								sentType,
								iterationTypes.nextType,
								errorNode,
								diagnostic,
							);
						}
					}
				}
				if (iterationTypes || uplevelIteration) {
					return possibleOutOfBounds ? includeUndefinedInIndexSignature(
						iterationTypes && iterationTypes.yieldType,
					) : (iterationTypes && iterationTypes.yieldType);
				}
			}
			var arrayType = inputType;
			var reportedError = false;
			var hasStringConstituent = false;
			// If strings are permitted, remove any string-like constituents from the array type.
			// This allows us to find other non-string element types from an array unioned with
			// a string.
			if (use & 4 /* AllowsStringInputFlag */ ) {
				if (arrayType.flags & TypeFlags.Union) {
					// After we remove all types that are StringLike, we will know if there was a string constituent
					// based on whether the result of filter is a new array.
					var arrayTypes = inputType.types;
					var filteredTypes = filter(
						arrayTypes,
						function (t) {
							return !(t.flags & TypeFlags.StringLike);
						},
					);
					if (filteredTypes !== arrayTypes) {
						arrayType = getUnionType(filteredTypes, UnionReduction.Subtype);
					}
				} else if (arrayType.flags & TypeFlags.StringLike) {
					arrayType = neverType;
				}
				hasStringConstituent = arrayType !== inputType;
				if (hasStringConstituent) {
					if (languageVersion < ScriptTarget.ES5) {
						if (errorNode) {
							error(
								errorNode,
								Diagnostics.Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher,
							);
							reportedError = true;
						}
					}
					// Now that we've removed all the StringLike types, if no constituents remain, then the entire
					// arrayOrStringType was a string.
					if (arrayType.flags & TypeFlags.Never) {
						return possibleOutOfBounds ? includeUndefinedInIndexSignature(
							stringType,
						) : stringType;
					}
				}
			}
			if (!isArrayLikeType(arrayType)) {
				if (errorNode && !reportedError) {
					// Which error we report depends on whether we allow strings or if there was a
					// string constituent. For example, if the input type is number | string, we
					// want to say that number is not an array type. But if the input was just
					// number and string input is allowed, we want to say that number is not an
					// array type or a string type.
					var allowsStrings = !!(use & 4) && !hasStringConstituent; /* AllowsStringInputFlag */
					var _a = getIterationDiagnosticDetails(
						allowsStrings,
						downlevelIteration,
					),
						defaultDiagnostic = _a[0],
						maybeMissingAwait = _a[1];
					errorAndMaybeSuggestAwait(
						errorNode,
						maybeMissingAwait && !!getAwaitedTypeOfPromise(arrayType),
						defaultDiagnostic,
						typeToString(arrayType),
					);
				}
				return hasStringConstituent ? possibleOutOfBounds ? includeUndefinedInIndexSignature(
					stringType,
				) : stringType : undefined;
			}
			var arrayElementType = getIndexTypeOfType(arrayType, numberType);
			if (hasStringConstituent && arrayElementType) {
				// This is just an optimization for the case where arrayOrStringType is string | string[]
				if (
					arrayElementType.flags & TypeFlags.StringLike && !compilerOptions.noUncheckedIndexedAccess
				) {
					return stringType;
				}
				return getUnionType(
					possibleOutOfBounds ? [arrayElementType, stringType, undefinedType] : [
						arrayElementType,
						stringType,
					],
					UnionReduction.Subtype,
				);
			}
			return (use & 128) ? includeUndefinedInIndexSignature(arrayElementType) : arrayElementType; /* PossiblyOutOfBounds */
			function getIterationDiagnosticDetails(allowsStrings, downlevelIteration) {
				var _a;
				if (downlevelIteration) {
					return allowsStrings ? [
						Diagnostics.Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator,
						true,
					] : [
						Diagnostics.Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator,
						true,
					];
				}
				var yieldType = getIterationTypeOfIterable(
					use,
					0, /* Yield */
					inputType, /*errorNode*/
					undefined,
				);
				if (yieldType) {
					return [
						Diagnostics.Type_0_is_not_an_array_type_or_a_string_type_Use_compiler_option_downlevelIteration_to_allow_iterating_of_iterators,
						false,
					];
				}
				if (
					isES2015OrLaterIterable(
						(_a = inputType.symbol) === null || _a === void 0 ? void 0 : _a.escapedName,
					)
				) {
					return [
						Diagnostics.Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher,
						true,
					];
				}
				return allowsStrings ? [
					Diagnostics.Type_0_is_not_an_array_type_or_a_string_type,
					true,
				] : [Diagnostics.Type_0_is_not_an_array_type, true];
			}
		}
		function isES2015OrLaterIterable(n) {
			switch (n) {
				case "Float32Array":
				case "Float64Array":
				case "Int16Array":
				case "Int32Array":
				case "Int8Array":
				case "NodeList":
				case "Uint16Array":
				case "Uint32Array":
				case "Uint8Array":
				case "Uint8ClampedArray":
					return true;
			}
			return false;
		}
		/**
         * Gets the requested "iteration type" from an `Iterable`-like or `AsyncIterable`-like type.
         */
		function getIterationTypeOfIterable(use, typeKind, inputType, errorNode) {
			if (isTypeAny(inputType)) {
				return undefined;
			}
			var iterationTypes = getIterationTypesOfIterable(
				inputType,
				use,
				errorNode,
			);
			return iterationTypes && iterationTypes[getIterationTypesKeyFromIterationTypeKind(
				typeKind,
			)];
		}
		function createIterationTypes(yieldType, returnType, nextType) {
			// `yieldType` and `returnType` are defaulted to `neverType` they each will be combined
			// via `getUnionType` when merging iteration types. `nextType` is defined as `unknownType`
			// as it is combined via `getIntersectionType` when merging iteration types.
			if (yieldType === void 0) {
				yieldType = neverType;
			}
			if (returnType === void 0) {
				returnType = neverType;
			}
			if (nextType === void 0) {
				nextType = unknownType;
			}
			// Use the cache only for intrinsic types to keep it small as they are likely to be
			// more frequently created (i.e. `Iterator<number, void, unknown>`). Iteration types
			// are also cached on the type they are requested for, so we shouldn't need to maintain
			// the cache for less-frequently used types.
			if (
				yieldType.flags & TypeFlags.Intrinsic && returnType.flags & (TypeFlags.Any | TypeFlags.Never | TypeFlags.Unknown | TypeFlags.Void | TypeFlags.Undefined) && nextType.flags & (TypeFlags.Any | TypeFlags.Never | TypeFlags.Unknown | TypeFlags.Void | TypeFlags.Undefined)
			) {
				var id = getTypeListId([yieldType, returnType, nextType]);
				var iterationTypes = iterationTypesCache.get(id);
				if (!iterationTypes) {
					iterationTypes = {
						yieldType: yieldType,
						returnType: returnType,
						nextType: nextType,
					};
					iterationTypesCache.set(id, iterationTypes);
				}
				return iterationTypes;
			}
			return {
				yieldType: yieldType,
				returnType: returnType,
				nextType: nextType,
			};
		}
		/**
         * Combines multiple `IterationTypes` records.
         *
         * If `array` is empty or all elements are missing or are references to `noIterationTypes`,
         * then `noIterationTypes` is returned. Otherwise, an `IterationTypes` record is returned
         * for the combined iteration types.
         */
		function combineIterationTypes(array) {
			var yieldTypes;
			var returnTypes;
			var nextTypes;
			for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
				var iterationTypes = array_1[_i];
				if (iterationTypes === undefined || iterationTypes === noIterationTypes) {
					continue;
				}
				if (iterationTypes === anyIterationTypes) {
					return anyIterationTypes;
				}
				yieldTypes = append(yieldTypes, iterationTypes.yieldType);
				returnTypes = append(returnTypes, iterationTypes.returnType);
				nextTypes = append(nextTypes, iterationTypes.nextType);
			}
			if (yieldTypes || returnTypes || nextTypes) {
				return createIterationTypes(
					yieldTypes && getUnionType(yieldTypes),
					returnTypes && getUnionType(returnTypes),
					nextTypes && getIntersectionType(nextTypes),
				);
			}
			return noIterationTypes;
		}
		function getCachedIterationTypes(type, cacheKey) {
			return type[cacheKey];
		}
		function setCachedIterationTypes(type, cacheKey, cachedTypes) {
			return type[cacheKey] = cachedTypes;
		}
		/**
         * Gets the *yield*, *return*, and *next* types from an `Iterable`-like or `AsyncIterable`-like type.
         *
         * At every level that involves analyzing return types of signatures, we union the return types of all the signatures.
         *
         * Another thing to note is that at any step of this process, we could run into a dead end,
         * meaning either the property is missing, or we run into the anyType. If either of these things
         * happens, we return `undefined` to signal that we could not find the iteration type. If a property
         * is missing, and the previous step did not result in `any`, then we also give an error if the
         * caller requested it. Then the caller can decide what to do in the case where there is no iterated
         * type.
         *
         * For a **for-of** statement, `yield*` (in a normal generator), spread, array
         * destructuring, or normal generator we will only ever look for a `[Symbol.iterator]()`
         * method.
         *
         * For an async generator we will only ever look at the `[Symbol.asyncIterator]()` method.
         *
         * For a **for-await-of** statement or a `yield*` in an async generator we will look for
         * the `[Symbol.asyncIterator]()` method first, and then the `[Symbol.iterator]()` method.
         */
		function getIterationTypesOfIterable(type, use, errorNode) {
			if (isTypeAny(type)) {
				return anyIterationTypes;
			}
			if (!(type.flags & TypeFlags.Union)) {
				var iterationTypes_1 = getIterationTypesOfIterableWorker(
					type,
					use,
					errorNode,
				);
				if (iterationTypes_1 === noIterationTypes) {
					if (errorNode) {
						reportTypeNotIterableError(
							errorNode,
							type,
							!!(use & 2), /* AllowsAsyncIterablesFlag */
						);
					}
					return undefined;
				}
				return iterationTypes_1;
			}
			var cacheKey = use & 2 ? "iterationTypesOfAsyncIterable" : "iterationTypesOfIterable"; /* AllowsAsyncIterablesFlag */
			var cachedTypes = getCachedIterationTypes(type, cacheKey);
			if (cachedTypes) return cachedTypes === noIterationTypes ? undefined : cachedTypes;
			var allIterationTypes;
			for (var _i = 0, _a = type.types; _i < _a.length; _i++) {
				var constituent = _a[_i];
				var iterationTypes_2 = getIterationTypesOfIterableWorker(
					constituent,
					use,
					errorNode,
				);
				if (iterationTypes_2 === noIterationTypes) {
					if (errorNode) {
						reportTypeNotIterableError(
							errorNode,
							type,
							!!(use & 2), /* AllowsAsyncIterablesFlag */
						);
					}
					setCachedIterationTypes(type, cacheKey, noIterationTypes);
					return undefined;
				} else {
					allIterationTypes = append(allIterationTypes, iterationTypes_2);
				}
			}
			var iterationTypes = allIterationTypes ? combineIterationTypes(
				allIterationTypes,
			) : noIterationTypes;
			setCachedIterationTypes(type, cacheKey, iterationTypes);
			return iterationTypes === noIterationTypes ? undefined : iterationTypes;
		}
		function getAsyncFromSyncIterationTypes(iterationTypes, errorNode) {
			if (iterationTypes === noIterationTypes) return noIterationTypes;
			if (iterationTypes === anyIterationTypes) return anyIterationTypes;
			var yieldType = iterationTypes.yieldType,
				returnType = iterationTypes.returnType,
				nextType = iterationTypes.nextType;
			// if we're requesting diagnostics, report errors for a missing `Awaited<T>`.
			if (errorNode) {
				getGlobalAwaitedSymbol( /*reportErrors*/ true);
			}
			return createIterationTypes(
				getAwaitedType(yieldType, errorNode) || anyType,
				getAwaitedType(returnType, errorNode) || anyType,
				nextType,
			);
		}
		/**
         * Gets the *yield*, *return*, and *next* types from a non-union type.
         *
         * If we are unable to find the *yield*, *return*, and *next* types, `noIterationTypes` is
         * returned to indicate to the caller that it should report an error. Otherwise, an
         * `IterationTypes` record is returned.
         *
         * NOTE: You probably don't want to call this directly and should be calling
         * `getIterationTypesOfIterable` instead.
         */
		function getIterationTypesOfIterableWorker(type, use, errorNode) {
			if (isTypeAny(type)) {
				return anyIterationTypes;
			}
			if (use & 2 /* AllowsAsyncIterablesFlag */ ) {
				var iterationTypes = getIterationTypesOfIterableCached(
					type,
					asyncIterationTypesResolver,
				) || getIterationTypesOfIterableFast(type, asyncIterationTypesResolver);
				if (iterationTypes) {
					return use & 8 ? getAsyncFromSyncIterationTypes(
						iterationTypes, /* ForOfFlag */
						errorNode,
					) : iterationTypes;
				}
			}
			if (use & 1 /* AllowsSyncIterablesFlag */ ) {
				var iterationTypes = getIterationTypesOfIterableCached(
					type,
					syncIterationTypesResolver,
				) || getIterationTypesOfIterableFast(type, syncIterationTypesResolver);
				if (iterationTypes) {
					if (use & 2 /* AllowsAsyncIterablesFlag */ ) {
						// for a sync iterable in an async context, only use the cached types if they are valid.
						if (iterationTypes !== noIterationTypes) {
							return setCachedIterationTypes(
								type,
								"iterationTypesOfAsyncIterable",
								getAsyncFromSyncIterationTypes(iterationTypes, errorNode),
							);
						}
					} else {
						return iterationTypes;
					}
				}
			}
			if (use & 2 /* AllowsAsyncIterablesFlag */ ) {
				var iterationTypes = getIterationTypesOfIterableSlow(
					type,
					asyncIterationTypesResolver,
					errorNode,
				);
				if (iterationTypes !== noIterationTypes) {
					return iterationTypes;
				}
			}
			if (use & 1 /* AllowsSyncIterablesFlag */ ) {
				var iterationTypes = getIterationTypesOfIterableSlow(
					type,
					syncIterationTypesResolver,
					errorNode,
				);
				if (iterationTypes !== noIterationTypes) {
					if (use & 2 /* AllowsAsyncIterablesFlag */ ) {
						return setCachedIterationTypes(
							type,
							"iterationTypesOfAsyncIterable",
							iterationTypes ? getAsyncFromSyncIterationTypes(
								iterationTypes,
								errorNode,
							) : noIterationTypes,
						);
					} else {
						return iterationTypes;
					}
				}
			}
			return noIterationTypes;
		}
		/**
         * Gets the *yield*, *return*, and *next* types of an `Iterable`-like or
         * `AsyncIterable`-like type from the cache.
         *
         * NOTE: You probably don't want to call this directly and should be calling
         * `getIterationTypesOfIterable` instead.
         */
		function getIterationTypesOfIterableCached(type, resolver) {
			return getCachedIterationTypes(type, resolver.iterableCacheKey);
		}
		function getIterationTypesOfGlobalIterableType(globalType, resolver) {
			var globalIterationTypes = getIterationTypesOfIterableCached(
				globalType,
				resolver,
			) || getIterationTypesOfIterableSlow(
				globalType,
				resolver, /*errorNode*/
				undefined,
			);
			return globalIterationTypes === noIterationTypes ? defaultIterationTypes : globalIterationTypes;
		}
		/**
         * Gets the *yield*, *return*, and *next* types of an `Iterable`-like or `AsyncIterable`-like
         * type from from common heuristics.
         *
         * If we previously analyzed this type and found no iteration types, `noIterationTypes` is
         * returned. If we found iteration types, an `IterationTypes` record is returned.
         * Otherwise, we return `undefined` to indicate to the caller it should perform a more
         * exhaustive analysis.
         *
         * NOTE: You probably don't want to call this directly and should be calling
         * `getIterationTypesOfIterable` instead.
         */
		function getIterationTypesOfIterableFast(type, resolver) {
			// As an optimization, if the type is an instantiation of one of the following global types, then
			// just grab its related type argument:
			// - `Iterable<T>` or `AsyncIterable<T>`
			// - `IterableIterator<T>` or `AsyncIterableIterator<T>`
			var globalType;
			if (
				isReferenceToType(
					type,
					globalType = resolver.getGlobalIterableType( /*reportErrors*/ false),
				) || isReferenceToType(
					type,
					globalType = resolver.getGlobalIterableIteratorType(
						false, /*reportErrors*/
					),
				)
			) {
				var yieldType = getTypeArguments(type)[0];
				// The "return" and "next" types of `Iterable` and `IterableIterator` are defined by the
				// iteration types of their `[Symbol.iterator]()` method. The same is true for their async cousins.
				// While we define these as `any` and `undefined` in our libs by default, a custom lib *could* use
				// different definitions.
				var _a = getIterationTypesOfGlobalIterableType(globalType, resolver),
					returnType = _a.returnType,
					nextType = _a.nextType;
				return setCachedIterationTypes(
					type,
					resolver.iterableCacheKey,
					createIterationTypes(
						resolver.resolveIterationType(yieldType, /*errorNode*/ undefined) || yieldType,
						resolver.resolveIterationType(returnType, /*errorNode*/ undefined) || returnType,
						nextType,
					),
				);
			}
			// As an optimization, if the type is an instantiation of the following global type, then
			// just grab its related type arguments:
			// - `Generator<T, TReturn, TNext>` or `AsyncGenerator<T, TReturn, TNext>`
			if (
				isReferenceToType(
					type,
					resolver.getGlobalGeneratorType( /*reportErrors*/ false),
				)
			) {
				var _b = getTypeArguments(type),
					yieldType = _b[0],
					returnType = _b[1],
					nextType = _b[2];
				return setCachedIterationTypes(
					type,
					resolver.iterableCacheKey,
					createIterationTypes(
						resolver.resolveIterationType(yieldType, /*errorNode*/ undefined) || yieldType,
						resolver.resolveIterationType(returnType, /*errorNode*/ undefined) || returnType,
						nextType,
					),
				);
			}
		}
		function getPropertyNameForKnownSymbolName(symbolName) {
			var ctorType = getGlobalESSymbolConstructorSymbol( /*reportErrors*/ false);
			var uniqueType = ctorType && getTypeOfPropertyOfType(
				getTypeOfSymbol(ctorType),
				escapeLeadingUnderscores(symbolName),
			);
			return uniqueType && isTypeUsableAsPropertyName(uniqueType) ? getPropertyNameFromType(
				uniqueType,
			) : "__@".concat(symbolName);
		}
		/**
         * Gets the *yield*, *return*, and *next* types of an `Iterable`-like or `AsyncIterable`-like
         * type from its members.
         *
         * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
         * record is returned. Otherwise, `noIterationTypes` is returned.
         *
         * NOTE: You probably don't want to call this directly and should be calling
         * `getIterationTypesOfIterable` instead.
         */
		function getIterationTypesOfIterableSlow(type, resolver, errorNode) {
			var _a;
			var method = getPropertyOfType(
				type,
				getPropertyNameForKnownSymbolName(resolver.iteratorSymbolName),
			);
			var methodType = method && !(method.flags & SymbolFlags.Optional) ? getTypeOfSymbol(
				method,
			) : undefined;
			if (isTypeAny(methodType)) {
				return setCachedIterationTypes(
					type,
					resolver.iterableCacheKey,
					anyIterationTypes,
				);
			}
			var signatures = methodType ? getSignaturesOfType(
				methodType,
				SignatureKind.Call,
			) : undefined;
			if (!some(signatures)) {
				return setCachedIterationTypes(
					type,
					resolver.iterableCacheKey,
					noIterationTypes,
				);
			}
			var iteratorType = getIntersectionType(
				map(signatures, getReturnTypeOfSignature),
			);
			var iterationTypes = (_a = getIterationTypesOfIterator(
				iteratorType,
				resolver,
				errorNode,
			)) !== null && _a !== void 0 ? _a : noIterationTypes;
			return setCachedIterationTypes(
				type,
				resolver.iterableCacheKey,
				iterationTypes,
			);
		}
		function reportTypeNotIterableError(errorNode, type, allowAsyncIterables) {
			var message = allowAsyncIterables ? Diagnostics.Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator : Diagnostics.Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator;
			errorAndMaybeSuggestAwait(
				errorNode,
				!!getAwaitedTypeOfPromise(type),
				message,
				typeToString(type),
			);
		}
		/**
         * Gets the *yield*, *return*, and *next* types from an `Iterator`-like or `AsyncIterator`-like type.
         *
         * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
         * record is returned. Otherwise, `undefined` is returned.
         */
		function getIterationTypesOfIterator(type, resolver, errorNode) {
			if (isTypeAny(type)) {
				return anyIterationTypes;
			}
			var iterationTypes = getIterationTypesOfIteratorCached(type, resolver) || getIterationTypesOfIteratorFast(
				type,
				resolver,
			) || getIterationTypesOfIteratorSlow(type, resolver, errorNode);
			return iterationTypes === noIterationTypes ? undefined : iterationTypes;
		}
		/**
         * Gets the iteration types of an `Iterator`-like or `AsyncIterator`-like type from the
         * cache.
         *
         * NOTE: You probably don't want to call this directly and should be calling
         * `getIterationTypesOfIterator` instead.
         */
		function getIterationTypesOfIteratorCached(type, resolver) {
			return getCachedIterationTypes(type, resolver.iteratorCacheKey);
		}
		/**
         * Gets the iteration types of an `Iterator`-like or `AsyncIterator`-like type from the
         * cache or from common heuristics.
         *
         * If we previously analyzed this type and found no iteration types, `noIterationTypes` is
         * returned. If we found iteration types, an `IterationTypes` record is returned.
         * Otherwise, we return `undefined` to indicate to the caller it should perform a more
         * exhaustive analysis.
         *
         * NOTE: You probably don't want to call this directly and should be calling
         * `getIterationTypesOfIterator` instead.
         */
		function getIterationTypesOfIteratorFast(type, resolver) {
			// As an optimization, if the type is an instantiation of one of the following global types,
			// then just grab its related type argument:
			// - `IterableIterator<T>` or `AsyncIterableIterator<T>`
			// - `Iterator<T, TReturn, TNext>` or `AsyncIterator<T, TReturn, TNext>`
			// - `Generator<T, TReturn, TNext>` or `AsyncGenerator<T, TReturn, TNext>`
			var globalType = resolver.getGlobalIterableIteratorType(
				false, /*reportErrors*/
			);
			if (isReferenceToType(type, globalType)) {
				var yieldType = getTypeArguments(type)[0];
				// The "return" and "next" types of `IterableIterator` and `AsyncIterableIterator` are defined by the
				// iteration types of their `next`, `return`, and `throw` methods. While we define these as `any`
				// and `undefined` in our libs by default, a custom lib *could* use different definitions.
				var globalIterationTypes = getIterationTypesOfIteratorCached(
					globalType,
					resolver,
				) || getIterationTypesOfIteratorSlow(
					globalType,
					resolver, /*errorNode*/
					undefined,
				);
				var _a = globalIterationTypes === noIterationTypes ? defaultIterationTypes : globalIterationTypes,
					returnType = _a.returnType,
					nextType = _a.nextType;
				return setCachedIterationTypes(
					type,
					resolver.iteratorCacheKey,
					createIterationTypes(yieldType, returnType, nextType),
				);
			}
			if (
				isReferenceToType(
					type,
					resolver.getGlobalIteratorType( /*reportErrors*/ false),
				) || isReferenceToType(
					type,
					resolver.getGlobalGeneratorType( /*reportErrors*/ false),
				)
			) {
				var _b = getTypeArguments(type),
					yieldType = _b[0],
					returnType = _b[1],
					nextType = _b[2];
				return setCachedIterationTypes(
					type,
					resolver.iteratorCacheKey,
					createIterationTypes(yieldType, returnType, nextType),
				);
			}
		}
		function isIteratorResult(type, kind) {
			// From https://tc39.github.io/ecma262/#sec-iteratorresult-interface:
			// > [done] is the result status of an iterator `next` method call. If the end of the iterator was reached `done` is `true`.
			// > If the end was not reached `done` is `false` and a value is available.
			// > If a `done` property (either own or inherited) does not exist, it is consider to have the value `false`.
			var doneType = getTypeOfPropertyOfType(type, "done") || falseType;
			return isTypeAssignableTo(
				kind === 0 ? falseType : trueType, /* Yield */
				doneType,
			);
		}
		function isYieldIteratorResult(type) {
			return isIteratorResult(type, 0 /* Yield */ );
		}
		function isReturnIteratorResult(type) {
			return isIteratorResult(type, 1 /* Return */ );
		}
		/**
         * Gets the *yield* and *return* types of an `IteratorResult`-like type.
         *
         * If we are unable to determine a *yield* or a *return* type, `noIterationTypes` is
         * returned to indicate to the caller that it should handle the error. Otherwise, an
         * `IterationTypes` record is returned.
         */
		function getIterationTypesOfIteratorResult(type) {
			if (isTypeAny(type)) {
				return anyIterationTypes;
			}
			var cachedTypes = getCachedIterationTypes(
				type,
				"iterationTypesOfIteratorResult",
			);
			if (cachedTypes) {
				return cachedTypes;
			}
			// As an optimization, if the type is an instantiation of one of the global `IteratorYieldResult<T>`
			// or `IteratorReturnResult<TReturn>` types, then just grab its type argument.
			if (
				isReferenceToType(
					type,
					getGlobalIteratorYieldResultType( /*reportErrors*/ false),
				)
			) {
				var yieldType_1 = getTypeArguments(type)[0];
				return setCachedIterationTypes(
					type,
					"iterationTypesOfIteratorResult",
					createIterationTypes(
						yieldType_1, /*returnType*/
						undefined, /*nextType*/
						undefined,
					),
				);
			}
			if (
				isReferenceToType(
					type,
					getGlobalIteratorReturnResultType( /*reportErrors*/ false),
				)
			) {
				var returnType_1 = getTypeArguments(type)[0];
				return setCachedIterationTypes(
					type,
					"iterationTypesOfIteratorResult",
					createIterationTypes(
						undefined, /*yieldType*/
						returnType_1, /*nextType*/
						undefined,
					),
				);
			}
			// Choose any constituents that can produce the requested iteration type.
			var yieldIteratorResult = filterType(type, isYieldIteratorResult);
			var yieldType = yieldIteratorResult !== neverType ? getTypeOfPropertyOfType(
				yieldIteratorResult,
				"value",
			) : undefined;
			var returnIteratorResult = filterType(type, isReturnIteratorResult);
			var returnType = returnIteratorResult !== neverType ? getTypeOfPropertyOfType(
				returnIteratorResult,
				"value",
			) : undefined;
			if (!yieldType && !returnType) {
				return setCachedIterationTypes(
					type,
					"iterationTypesOfIteratorResult",
					noIterationTypes,
				);
			}
			// From https://tc39.github.io/ecma262/#sec-iteratorresult-interface
			// > ... If the iterator does not have a return value, `value` is `undefined`. In that case, the
			// > `value` property may be absent from the conforming object if it does not inherit an explicit
			// > `value` property.
			return setCachedIterationTypes(
				type,
				"iterationTypesOfIteratorResult",
				createIterationTypes(
					yieldType,
					returnType || voidType, /*nextType*/
					undefined,
				),
			);
		}
		/**
         * Gets the *yield*, *return*, and *next* types of a the `next()`, `return()`, or
         * `throw()` method of an `Iterator`-like or `AsyncIterator`-like type.
         *
         * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
         * record is returned. Otherwise, we return `undefined`.
         */
		function getIterationTypesOfMethod(type, resolver, methodName, errorNode) {
			var _a, _b, _c, _d;
			var method = getPropertyOfType(type, methodName);
			// Ignore 'return' or 'throw' if they are missing.
			if (!method && methodName !== "next") {
				return undefined;
			}
			var methodType = method && !(methodName === "next" && (method.flags & SymbolFlags.Optional)) ? methodName === "next" ? getTypeOfSymbol(
				method,
			) : getTypeWithFacts(
				getTypeOfSymbol(method),
				2097152, /* NEUndefinedOrNull */
			) : undefined;
			if (isTypeAny(methodType)) {
				// `return()` and `throw()` don't provide a *next* type.
				return methodName === "next" ? anyIterationTypes : anyIterationTypesExceptNext;
			}
			// Both async and non-async iterators *must* have a `next` method.
			var methodSignatures = methodType ? getSignaturesOfType(
				methodType,
				SignatureKind.Call,
			) : emptyArray;
			if (methodSignatures.length === 0) {
				if (errorNode) {
					var diagnostic = methodName === "next" ? resolver.mustHaveANextMethodDiagnostic : resolver.mustBeAMethodDiagnostic;
					error(errorNode, diagnostic, methodName);
				}
				return methodName === "next" ? anyIterationTypes : undefined;
			}
			// If the method signature comes exclusively from the global iterator or generator type,
			// create iteration types from its type arguments like `getIterationTypesOfIteratorFast`
			// does (so as to remove `undefined` from the next and return types). We arrive here when
			// a contextual type for a generator was not a direct reference to one of those global types,
			// but looking up `methodType` referred to one of them (and nothing else). E.g., in
			// `interface SpecialIterator extends Iterator<number> {}`, `SpecialIterator` is not a
			// reference to `Iterator`, but its `next` member derives exclusively from `Iterator`.
			if (
				(methodType === null || methodType === void 0 ? void 0 : methodType.symbol) && methodSignatures.length === 1
			) {
				var globalGeneratorType = resolver.getGlobalGeneratorType(
					false, /*reportErrors*/
				);
				var globalIteratorType = resolver.getGlobalIteratorType(
					false, /*reportErrors*/
				);
				var isGeneratorMethod = ((_b = (_a = globalGeneratorType.symbol) === null || _a === void 0 ? void 0 : _a.members) === null || _b === void 0 ? void 0 : _b.get(
					methodName,
				)) === methodType.symbol;
				var isIteratorMethod = !isGeneratorMethod && ((_d = (_c = globalIteratorType.symbol) === null || _c === void 0 ? void 0 : _c.members) === null || _d === void 0 ? void 0 : _d.get(
					methodName,
				)) === methodType.symbol;
				if (isGeneratorMethod || isIteratorMethod) {
					var globalType = isGeneratorMethod ? globalGeneratorType : globalIteratorType;
					var mapper = methodType.mapper;
					return createIterationTypes(
						getMappedType(globalType.typeParameters[0], mapper),
						getMappedType(globalType.typeParameters[1], mapper),
						methodName === "next" ? getMappedType(
							globalType.typeParameters[2],
							mapper,
						) : undefined,
					);
				}
			}
			// Extract the first parameter and return type of each signature.
			var methodParameterTypes;
			var methodReturnTypes;
			for (
				var _i = 0, methodSignatures_1 = methodSignatures;
				_i < methodSignatures_1.length;
				_i++
			) {
				var signature = methodSignatures_1[_i];
				if (methodName !== "throw" && some(signature.parameters)) {
					methodParameterTypes = append(
						methodParameterTypes,
						getTypeAtPosition(signature, 0),
					);
				}
				methodReturnTypes = append(
					methodReturnTypes,
					getReturnTypeOfSignature(signature),
				);
			}
			// Resolve the *next* or *return* type from the first parameter of a `next()` or
			// `return()` method, respectively.
			var returnTypes;
			var nextType;
			if (methodName !== "throw") {
				var methodParameterType = methodParameterTypes ? getUnionType(
					methodParameterTypes,
				) : unknownType;
				if (methodName === "next") {
					// The value of `next(value)` is *not* awaited by async generators
					nextType = methodParameterType;
				} else if (methodName === "return") {
					// The value of `return(value)` *is* awaited by async generators
					var resolvedMethodParameterType = resolver.resolveIterationType(
						methodParameterType,
						errorNode,
					) || anyType;
					returnTypes = append(returnTypes, resolvedMethodParameterType);
				}
			}
			// Resolve the *yield* and *return* types from the return type of the method (i.e. `IteratorResult`)
			var yieldType;
			var methodReturnType = methodReturnTypes ? getIntersectionType(
				methodReturnTypes,
			) : neverType;
			var resolvedMethodReturnType = resolver.resolveIterationType(
				methodReturnType,
				errorNode,
			) || anyType;
			var iterationTypes = getIterationTypesOfIteratorResult(
				resolvedMethodReturnType,
			);
			if (iterationTypes === noIterationTypes) {
				if (errorNode) {
					error(errorNode, resolver.mustHaveAValueDiagnostic, methodName);
				}
				yieldType = anyType;
				returnTypes = append(returnTypes, anyType);
			} else {
				yieldType = iterationTypes.yieldType;
				returnTypes = append(returnTypes, iterationTypes.returnType);
			}
			return createIterationTypes(
				yieldType,
				getUnionType(returnTypes),
				nextType,
			);
		}
		/**
         * Gets the *yield*, *return*, and *next* types of an `Iterator`-like or `AsyncIterator`-like
         * type from its members.
         *
         * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
         * record is returned. Otherwise, `noIterationTypes` is returned.
         *
         * NOTE: You probably don't want to call this directly and should be calling
         * `getIterationTypesOfIterator` instead.
         */
		function getIterationTypesOfIteratorSlow(type, resolver, errorNode) {
			var iterationTypes = combineIterationTypes(
				[
					getIterationTypesOfMethod(type, resolver, "next", errorNode),
					getIterationTypesOfMethod(type, resolver, "return", errorNode),
					getIterationTypesOfMethod(type, resolver, "throw", errorNode),
				],
			);
			return setCachedIterationTypes(
				type,
				resolver.iteratorCacheKey,
				iterationTypes,
			);
		}
		/**
         * Gets the requested "iteration type" from a type that is either `Iterable`-like, `Iterator`-like,
         * `IterableIterator`-like, or `Generator`-like (for a non-async generator); or `AsyncIterable`-like,
         * `AsyncIterator`-like, `AsyncIterableIterator`-like, or `AsyncGenerator`-like (for an async generator).
         */
		function getIterationTypeOfGeneratorFunctionReturnType(
			kind,
			returnType,
			isAsyncGenerator,
		) {
			if (isTypeAny(returnType)) {
				return undefined;
			}
			var iterationTypes = getIterationTypesOfGeneratorFunctionReturnType(
				returnType,
				isAsyncGenerator,
			);
			return iterationTypes && iterationTypes[getIterationTypesKeyFromIterationTypeKind(
				kind,
			)];
		}
		function getIterationTypesOfGeneratorFunctionReturnType(
			type,
			isAsyncGenerator,
		) {
			if (isTypeAny(type)) {
				return anyIterationTypes;
			}
			var use = isAsyncGenerator ? 2 : 1; /* AsyncGeneratorReturnType */ /* GeneratorReturnType */
			var resolver = isAsyncGenerator ? asyncIterationTypesResolver : syncIterationTypesResolver;
			return getIterationTypesOfIterable(type, use, /*errorNode*/ undefined) || getIterationTypesOfIterator(
				type,
				resolver, /*errorNode*/
				undefined,
			);
		}
		function checkBreakOrContinueStatement(node) {
			// Grammar checking
			if (!checkGrammarStatementInAmbientContext(node)) checkGrammarBreakOrContinueStatement(
				node,
			); // TODO: Check that target label is valid
		}
		function unwrapReturnType(returnType, functionFlags) {
			var isGenerator = !!(functionFlags & FunctionFlags.Generator);
			var isAsync = !!(functionFlags & FunctionFlags.Async);
			return isGenerator ? getIterationTypeOfGeneratorFunctionReturnType(
				1, /* Return */
				returnType,
				isAsync,
			) || errorType : isAsync ? getAwaitedTypeNoAlias(returnType) || errorType : returnType;
		}
		function isUnwrappedReturnTypeVoidOrAny(func, returnType) {
			var unwrappedReturnType = unwrapReturnType(
				returnType,
				getFunctionFlags(func),
			);
			return !!unwrappedReturnType && maybeTypeOfKind(
				unwrappedReturnType,
				TypeFlags.Void | TypeFlags.AnyOrUnknown,
			);
		}
		function checkReturnStatement(node) {
			var _a;
			// Grammar checking
			if (checkGrammarStatementInAmbientContext(node)) {
				return;
			}
			var container = getContainingFunctionOrClassStaticBlock(node);
			if (container && isClassStaticBlockDeclaration(container)) {
				grammarErrorOnFirstToken(
					node,
					Diagnostics.A_return_statement_cannot_be_used_inside_a_class_static_block,
				);
				return;
			}
			if (!container) {
				grammarErrorOnFirstToken(
					node,
					Diagnostics.A_return_statement_can_only_be_used_within_a_function_body,
				);
				return;
			}
			var signature = getSignatureFromDeclaration(container);
			var returnType = getReturnTypeOfSignature(signature);
			var functionFlags = getFunctionFlags(container);
			if (
				strictNullChecks || node.expression || returnType.flags & TypeFlags.Never
			) {
				var exprType = node.expression ? checkExpressionCached(node.expression) : undefinedType;
				if (container.kind === SyntaxKind.SetAccessor) {
					if (node.expression) {
						error(node, Diagnostics.Setters_cannot_return_a_value);
					}
				} else if (container.kind === SyntaxKind.Constructor) {
					if (
						node.expression && !checkTypeAssignableToAndOptionallyElaborate(
							exprType,
							returnType,
							node,
							node.expression,
						)
					) {
						error(
							node,
							Diagnostics.Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class,
						);
					}
				} else if (getReturnTypeFromAnnotation(container)) {
					var unwrappedReturnType = (_a = unwrapReturnType(
						returnType,
						functionFlags,
					)) !== null && _a !== void 0 ? _a : returnType;
					var unwrappedExprType = functionFlags & FunctionFlags.Async ? checkAwaitedType(
						exprType, /*withAlias*/
						false,
						node,
						Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member,
					) : exprType;
					if (unwrappedReturnType) {
						// If the function has a return type, but promisedType is
						// undefined, an error will be reported in checkAsyncFunctionReturnType
						// so we don't need to report one here.
						checkTypeAssignableToAndOptionallyElaborate(
							unwrappedExprType,
							unwrappedReturnType,
							node,
							node.expression,
						);
					}
				}
			} else if (
				container.kind !== SyntaxKind.Constructor && compilerOptions.noImplicitReturns && !isUnwrappedReturnTypeVoidOrAny(
					container,
					returnType,
				)
			) {
				// The function has a return type, but the return statement doesn't have an expression.
				error(node, Diagnostics.Not_all_code_paths_return_a_value);
			}
		}
		function checkWithStatement(node) {
			// Grammar checking for withStatement
			if (!checkGrammarStatementInAmbientContext(node)) {
				if (node.flags & NodeFlags.AwaitContext) {
					grammarErrorOnFirstToken(
						node,
						Diagnostics.with_statements_are_not_allowed_in_an_async_function_block,
					);
				}
			}
			checkExpression(node.expression);
			var sourceFile = getSourceFileOfNode(node);
			if (!hasParseDiagnostics(sourceFile)) {
				var start = getSpanOfTokenAtPosition(sourceFile, node.pos).start;
				var end = node.statement.pos;
				grammarErrorAtPos(
					sourceFile,
					start,
					end - start,
					Diagnostics.The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any,
				);
			}
		}
		function checkSwitchStatement(node) {
			// Grammar checking
			checkGrammarStatementInAmbientContext(node);
			var firstDefaultClause;
			var hasDuplicateDefaultClause = false;
			var expressionType = checkExpression(node.expression);
			var expressionIsLiteral = isLiteralType(expressionType);
			forEach(
				node.caseBlock.clauses,
				function (clause) {
					// Grammar check for duplicate default clauses, skip if we already report duplicate default clause
					if (
						clause.kind === SyntaxKind.DefaultClause && !hasDuplicateDefaultClause
					) {
						if (firstDefaultClause === undefined) {
							firstDefaultClause = clause;
						} else {
							grammarErrorOnNode(
								clause,
								Diagnostics.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement,
							);
							hasDuplicateDefaultClause = true;
						}
					}
					if (produceDiagnostics && clause.kind === SyntaxKind.CaseClause) {
						// TypeScript 1.0 spec (April 2014): 5.9
						// In a 'switch' statement, each 'case' expression must be of a type that is comparable
						// to or from the type of the 'switch' expression.
						var caseType = checkExpression(clause.expression);
						var caseIsLiteral = isLiteralType(caseType);
						var comparedExpressionType = expressionType;
						if (!caseIsLiteral || !expressionIsLiteral) {
							caseType = caseIsLiteral ? getBaseTypeOfLiteralType(caseType) : caseType;
							comparedExpressionType = getBaseTypeOfLiteralType(expressionType);
						}
						if (!isTypeEqualityComparableTo(comparedExpressionType, caseType)) {
							// expressionType is not comparable to caseType, try the reversed check and report errors if it fails
							checkTypeComparableTo(
								caseType,
								comparedExpressionType,
								clause.expression, /*headMessage*/
								undefined,
							);
						}
					}
					forEach(clause.statements, checkSourceElement);
					if (
						compilerOptions.noFallthroughCasesInSwitch && clause.fallthroughFlowNode && isReachableFlowNode(
							clause.fallthroughFlowNode,
						)
					) {
						error(clause, Diagnostics.Fallthrough_case_in_switch);
					}
				},
			);
			if (node.caseBlock.locals) {
				registerForUnusedIdentifiersCheck(node.caseBlock);
			}
		}
		function checkLabeledStatement(node) {
			// Grammar checking
			if (!checkGrammarStatementInAmbientContext(node)) {
				findAncestor(
					node.parent,
					function (current) {
						if (isFunctionLike(current)) {
							return "quit";
						}
						if (
							current.kind === SyntaxKind.LabeledStatement && current.label.escapedText === node.label.escapedText
						) {
							grammarErrorOnNode(
								node.label,
								Diagnostics.Duplicate_label_0,
								getTextOfNode(node.label),
							);
							return true;
						}
						return false;
					},
				);
			}
			// ensure that label is unique
			checkSourceElement(node.statement);
		}
		function checkThrowStatement(node) {
			// Grammar checking
			if (!checkGrammarStatementInAmbientContext(node)) {
				if (isIdentifier(node.expression) && !node.expression.escapedText) {
					grammarErrorAfterFirstToken(
						node,
						Diagnostics.Line_break_not_permitted_here,
					);
				}
			}
			if (node.expression) {
				checkExpression(node.expression);
			}
		}
		function checkTryStatement(node) {
			// Grammar checking
			checkGrammarStatementInAmbientContext(node);
			checkBlock(node.tryBlock);
			var catchClause = node.catchClause;
			if (catchClause) {
				// Grammar checking
				if (catchClause.variableDeclaration) {
					var declaration = catchClause.variableDeclaration;
					var typeNode = getEffectiveTypeAnnotationNode(
						getRootDeclaration(declaration),
					);
					if (typeNode) {
						var type = getTypeForVariableLikeDeclaration(
							declaration, /*includeOptionality*/
							false,
						);
						if (type && !(type.flags & TypeFlags.AnyOrUnknown)) {
							grammarErrorOnFirstToken(
								typeNode,
								Diagnostics.Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified,
							);
						}
					} else if (declaration.initializer) {
						grammarErrorOnFirstToken(
							declaration.initializer,
							Diagnostics.Catch_clause_variable_cannot_have_an_initializer,
						);
					} else {
						var blockLocals_1 = catchClause.block.locals;
						if (blockLocals_1) {
							forEachKey(
								catchClause.locals,
								function (caughtName) {
									var blockLocal = blockLocals_1.get(caughtName);
									if (
										(blockLocal === null || blockLocal === void 0 ? void 0 : blockLocal.valueDeclaration) && (blockLocal.flags & SymbolFlags.BlockScopedVariable) !== 0
									) {
										grammarErrorOnNode(
											blockLocal.valueDeclaration,
											Diagnostics.Cannot_redeclare_identifier_0_in_catch_clause,
											caughtName,
										);
									}
								},
							);
						}
					}
				}
				checkBlock(catchClause.block);
			}
			if (node.finallyBlock) {
				checkBlock(node.finallyBlock);
			}
		}
		function checkIndexConstraints(type, symbol, isStaticIndex) {
			var indexInfos = getIndexInfosOfType(type);
			if (indexInfos.length === 0) {
				return;
			}
			for (
				var _i = 0, _a = getPropertiesOfObjectType(type);
				_i < _a.length;
				_i++
			) {
				var prop = _a[_i];
				if (!(isStaticIndex && prop.flags & SymbolFlags.Prototype)) {
					checkIndexConstraintForProperty(
						type,
						prop,
						getLiteralTypeFromProperty(
							prop,
							TypeFlags.StringOrNumberLiteralOrUnique, /*includeNonPublic*/
							true,
						),
						getNonMissingTypeOfSymbol(prop),
					);
				}
			}
			var typeDeclaration = symbol.valueDeclaration;
			if (typeDeclaration && isClassLike(typeDeclaration)) {
				for (var _b = 0, _c = typeDeclaration.members; _b < _c.length; _b++) {
					var member = _c[_b];
					// Only process instance properties with computed names here. Static properties cannot be in conflict with indexers,
					// and properties with literal names were already checked.
					if (!isStatic(member) && !hasBindableName(member)) {
						var symbol_3 = getSymbolOfNode(member);
						checkIndexConstraintForProperty(
							type,
							symbol_3,
							getTypeOfExpression(member.name.expression),
							getNonMissingTypeOfSymbol(symbol_3),
						);
					}
				}
			}
			if (indexInfos.length > 1) {
				for (
					var _d = 0, indexInfos_6 = indexInfos;
					_d < indexInfos_6.length;
					_d++
				) {
					var info = indexInfos_6[_d];
					checkIndexConstraintForIndexSignature(type, info);
				}
			}
		}
		function checkIndexConstraintForProperty(type, prop, propNameType, propType) {
			var declaration = prop.valueDeclaration;
			var name = getNameOfDeclaration(declaration);
			if (name && isPrivateIdentifier(name)) {
				return;
			}
			var indexInfos = getApplicableIndexInfos(type, propNameType);
			var interfaceDeclaration = getObjectFlags(type) & ObjectFlags.Interface ? getDeclarationOfKind(
				type.symbol,
				SyntaxKind.InterfaceDeclaration,
			) : undefined;
			var localPropDeclaration = declaration && declaration.kind === SyntaxKind.BinaryExpression || name && name.kind === SyntaxKind.ComputedPropertyName || getParentOfSymbol(
				prop,
			) === type.symbol ? declaration : undefined;
			var _loop_21 = function (info) {
				var localIndexDeclaration = info.declaration && getParentOfSymbol(
					getSymbolOfNode(info.declaration),
				) === type.symbol ? info.declaration : undefined;
				// We check only when (a) the property is declared in the containing type, or (b) the applicable index signature is declared
				// in the containing type, or (c) the containing type is an interface and no base interface contains both the property and
				// the index signature (i.e. property and index signature are declared in separate inherited interfaces).
				var errorNode = localPropDeclaration || localIndexDeclaration || (interfaceDeclaration && !some(
					getBaseTypes(type),
					function (base) {
						return !!getPropertyOfObjectType(base, prop.escapedName) && !!getIndexTypeOfType(
							base,
							info.keyType,
						);
					},
				) ? interfaceDeclaration : undefined);
				if (errorNode && !isTypeAssignableTo(propType, info.type)) {
					error(
						errorNode,
						Diagnostics.Property_0_of_type_1_is_not_assignable_to_2_index_type_3,
						symbolToString(prop),
						typeToString(propType),
						typeToString(info.keyType),
						typeToString(info.type),
					);
				}
			};
			for (var _i = 0, indexInfos_7 = indexInfos; _i < indexInfos_7.length; _i++) {
				var info = indexInfos_7[_i];
				_loop_21(info);
			}
		}
		function checkIndexConstraintForIndexSignature(type, checkInfo) {
			var declaration = checkInfo.declaration;
			var indexInfos = getApplicableIndexInfos(type, checkInfo.keyType);
			var interfaceDeclaration = getObjectFlags(type) & ObjectFlags.Interface ? getDeclarationOfKind(
				type.symbol,
				SyntaxKind.InterfaceDeclaration,
			) : undefined;
			var localCheckDeclaration = declaration && getParentOfSymbol(
				getSymbolOfNode(declaration),
			) === type.symbol ? declaration : undefined;
			var _loop_22 = function (info) {
				if (info === checkInfo) return "continue";
				var localIndexDeclaration = info.declaration && getParentOfSymbol(
					getSymbolOfNode(info.declaration),
				) === type.symbol ? info.declaration : undefined;
				// We check only when (a) the check index signature is declared in the containing type, or (b) the applicable index
				// signature is declared in the containing type, or (c) the containing type is an interface and no base interface contains
				// both index signatures (i.e. the index signatures are declared in separate inherited interfaces).
				var errorNode = localCheckDeclaration || localIndexDeclaration || (interfaceDeclaration && !some(
					getBaseTypes(type),
					function (base) {
						return !!getIndexInfoOfType(base, checkInfo.keyType) && !!getIndexTypeOfType(
							base,
							info.keyType,
						);
					},
				) ? interfaceDeclaration : undefined);
				if (errorNode && !isTypeAssignableTo(checkInfo.type, info.type)) {
					error(
						errorNode,
						Diagnostics._0_index_type_1_is_not_assignable_to_2_index_type_3,
						typeToString(checkInfo.keyType),
						typeToString(checkInfo.type),
						typeToString(info.keyType),
						typeToString(info.type),
					);
				}
			};
			for (var _i = 0, indexInfos_8 = indexInfos; _i < indexInfos_8.length; _i++) {
				var info = indexInfos_8[_i];
				_loop_22(info);
			}
		}
		function checkTypeNameIsReserved(name, message) {
			// TS 1.0 spec (April 2014): 3.6.1
			// The predefined type keywords are reserved and cannot be used as names of user defined types.
			switch (name.escapedText) {
				case "any":
				case "unknown":
				case "never":
				case "number":
				case "bigint":
				case "boolean":
				case "string":
				case "symbol":
				case "void":
				case "object":
					error(name, message, name.escapedText);
			}
		}
		/**
         * The name cannot be used as 'Object' of user defined types with special target.
         */
		function checkClassNameCollisionWithObject(name) {
			if (
				languageVersion >= ScriptTarget.ES5 && name.escapedText === "Object" && (moduleKind < ModuleKind.ES2015 || getSourceFileOfNode(
					name,
				).impliedNodeFormat === ModuleKind.CommonJS)
			) {
				error(
					name,
					Diagnostics.Class_name_cannot_be_Object_when_targeting_ES5_with_module_0,
					ModuleKind[moduleKind],
				); // https://github.com/Microsoft/TypeScript/issues/17494
			}
		}
		/**
         * Check each type parameter and check that type parameters have no duplicate type parameter declarations
         */
		function checkTypeParameters(typeParameterDeclarations) {
			if (typeParameterDeclarations) {
				var seenDefault = false;
				for (var i = 0; i < typeParameterDeclarations.length; i++) {
					var node = typeParameterDeclarations[i];
					checkTypeParameter(node);
					if (produceDiagnostics) {
						if (node["default"]) {
							seenDefault = true;
							checkTypeParametersNotReferenced(
								node["default"],
								typeParameterDeclarations,
								i,
							);
						} else if (seenDefault) {
							error(
								node,
								Diagnostics.Required_type_parameters_may_not_follow_optional_type_parameters,
							);
						}
						for (var j = 0; j < i; j++) {
							if (typeParameterDeclarations[j].symbol === node.symbol) {
								error(
									node.name,
									Diagnostics.Duplicate_identifier_0,
									declarationNameToString(node.name),
								);
							}
						}
					}
				}
			}
		}
		/** Check that type parameter defaults only reference previously declared type parameters */
		function checkTypeParametersNotReferenced(root, typeParameters, index) {
			visit(root);
			function visit(node) {
				if (node.kind === SyntaxKind.TypeReference) {
					var type = getTypeFromTypeReference(node);
					if (type.flags & TypeFlags.TypeParameter) {
						for (var i = index; i < typeParameters.length; i++) {
							if (type.symbol === getSymbolOfNode(typeParameters[i])) {
								error(
									node,
									Diagnostics.Type_parameter_defaults_can_only_reference_previously_declared_type_parameters,
								);
							}
						}
					}
				}
				forEachChild(node, visit);
			}
		}
		/** Check that type parameter lists are identical across multiple declarations */
		function checkTypeParameterListsIdentical(symbol) {
			if (symbol.declarations && symbol.declarations.length === 1) {
				return;
			}
			var links = getSymbolLinks(symbol);
			if (!links.typeParametersChecked) {
				links.typeParametersChecked = true;
				var declarations = getClassOrInterfaceDeclarationsOfSymbol(symbol);
				if (!declarations || declarations.length <= 1) {
					return;
				}
				var type = getDeclaredTypeOfSymbol(symbol);
				if (!areTypeParametersIdentical(declarations, type.localTypeParameters)) {
					// Report an error on every conflicting declaration.
					var name_36 = symbolToString(symbol);
					for (
						var _i = 0, declarations_5 = declarations;
						_i < declarations_5.length;
						_i++
					) {
						var declaration = declarations_5[_i];
						error(
							declaration.name,
							Diagnostics.All_declarations_of_0_must_have_identical_type_parameters,
							name_36,
						);
					}
				}
			}
		}
		function areTypeParametersIdentical(declarations, targetParameters) {
			var maxTypeArgumentCount = length(targetParameters);
			var minTypeArgumentCount = getMinTypeArgumentCount(targetParameters);
			for (
				var _i = 0, declarations_6 = declarations;
				_i < declarations_6.length;
				_i++
			) {
				var declaration = declarations_6[_i];
				// If this declaration has too few or too many type parameters, we report an error
				var sourceParameters = getEffectiveTypeParameterDeclarations(
					declaration,
				);
				var numTypeParameters = sourceParameters.length;
				if (
					numTypeParameters < minTypeArgumentCount || numTypeParameters > maxTypeArgumentCount
				) {
					return false;
				}
				for (var i = 0; i < numTypeParameters; i++) {
					var source = sourceParameters[i];
					var target = targetParameters[i];
					// If the type parameter node does not have the same as the resolved type
					// parameter at this position, we report an error.
					if (source.name.escapedText !== target.symbol.escapedName) {
						return false;
					}
					// If the type parameter node does not have an identical constraint as the resolved
					// type parameter at this position, we report an error.
					var constraint = getEffectiveConstraintOfTypeParameter(source);
					var sourceConstraint = constraint && getTypeFromTypeNode(constraint);
					var targetConstraint = getConstraintOfTypeParameter(target);
					// relax check if later interface augmentation has no constraint, it's more broad and is OK to merge with
					// a more constrained interface (this could be generalized to a full hierarchy check, but that's maybe overkill)
					if (
						sourceConstraint && targetConstraint && !isTypeIdenticalTo(
							sourceConstraint,
							targetConstraint,
						)
					) {
						return false;
					}
					// If the type parameter node has a default and it is not identical to the default
					// for the type parameter at this position, we report an error.
					var sourceDefault = source["default"] && getTypeFromTypeNode(
						source["default"],
					);
					var targetDefault = getDefaultFromTypeParameter(target);
					if (
						sourceDefault && targetDefault && !isTypeIdenticalTo(
							sourceDefault,
							targetDefault,
						)
					) {
						return false;
					}
				}
			}
			return true;
		}
		function checkClassExpression(node) {
			checkClassLikeDeclaration(node);
			checkNodeDeferred(node);
			return getTypeOfSymbol(getSymbolOfNode(node));
		}
		function checkClassExpressionDeferred(node) {
			forEach(node.members, checkSourceElement);
			registerForUnusedIdentifiersCheck(node);
		}
		function checkClassDeclaration(node) {
			if (
				some(node.decorators) && some(
					node.members,
					function (p) {
						return hasStaticModifier(p) && isPrivateIdentifierClassElementDeclaration(
							p,
						);
					},
				)
			) {
				grammarErrorOnNode(
					node.decorators[0],
					Diagnostics.Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_decorator,
				);
			}
			if (!node.name && !hasSyntacticModifier(node, ModifierFlags.Default)) {
				grammarErrorOnFirstToken(
					node,
					Diagnostics.A_class_declaration_without_the_default_modifier_must_have_a_name,
				);
			}
			checkClassLikeDeclaration(node);
			forEach(node.members, checkSourceElement);
			registerForUnusedIdentifiersCheck(node);
		}
		function checkClassLikeDeclaration(node) {
			checkGrammarClassLikeDeclaration(node);
			checkDecorators(node);
			checkCollisionsForDeclarationName(node, node.name);
			checkTypeParameters(getEffectiveTypeParameterDeclarations(node));
			checkExportsOnMergedDeclarations(node);
			var symbol = getSymbolOfNode(node);
			var type = getDeclaredTypeOfSymbol(symbol);
			var typeWithThis = getTypeWithThisArgument(type);
			var staticType = getTypeOfSymbol(symbol);
			checkTypeParameterListsIdentical(symbol);
			checkFunctionOrConstructorSymbol(symbol);
			checkClassForDuplicateDeclarations(node);
			// Only check for reserved static identifiers on non-ambient context.
			var nodeInAmbientContext = !!(node.flags & NodeFlags.Ambient);
			if (!nodeInAmbientContext) {
				checkClassForStaticPropertyNameConflicts(node);
			}
			var baseTypeNode = getEffectiveBaseTypeNode(node);
			if (baseTypeNode) {
				forEach(baseTypeNode.typeArguments, checkSourceElement);
				if (languageVersion < ScriptTarget.ES2015) {
					checkExternalEmitHelpers(
						baseTypeNode.parent,
						ExternalEmitHelpers.Extends,
					);
				}
				// check both @extends and extends if both are specified.
				var extendsNode = getClassExtendsHeritageElement(node);
				if (extendsNode && extendsNode !== baseTypeNode) {
					checkExpression(extendsNode.expression);
				}
				var baseTypes = getBaseTypes(type);
				if (baseTypes.length && produceDiagnostics) {
					var baseType_1 = baseTypes[0];
					var baseConstructorType = getBaseConstructorTypeOfClass(type);
					var staticBaseType = getApparentType(baseConstructorType);
					checkBaseTypeAccessibility(staticBaseType, baseTypeNode);
					checkSourceElement(baseTypeNode.expression);
					if (some(baseTypeNode.typeArguments)) {
						forEach(baseTypeNode.typeArguments, checkSourceElement);
						for (
							var _i = 0,
								_a = getConstructorsForTypeArguments(
									staticBaseType,
									baseTypeNode.typeArguments,
									baseTypeNode,
								);
							_i < _a.length;
							_i++
						) {
							var constructor = _a[_i];
							if (
								!checkTypeArgumentConstraints(
									baseTypeNode,
									constructor.typeParameters,
								)
							) {
								break;
							}
						}
					}
					var baseWithThis = getTypeWithThisArgument(baseType_1, type.thisType);
					if (
						!checkTypeAssignableTo(
							typeWithThis,
							baseWithThis, /*errorNode*/
							undefined,
						)
					) {
						issueMemberSpecificError(
							node,
							typeWithThis,
							baseWithThis,
							Diagnostics.Class_0_incorrectly_extends_base_class_1,
						);
					} else {
						// Report static side error only when instance type is assignable
						checkTypeAssignableTo(
							staticType,
							getTypeWithoutSignatures(staticBaseType),
							node.name || node,
							Diagnostics.Class_static_side_0_incorrectly_extends_base_class_static_side_1,
						);
					}
					if (baseConstructorType.flags & TypeFlags.TypeVariable) {
						if (!isMixinConstructorType(staticType)) {
							error(
								node.name || node,
								Diagnostics.A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any,
							);
						} else {
							var constructSignatures = getSignaturesOfType(
								baseConstructorType,
								SignatureKind.Construct,
							);
							if (
								constructSignatures.some(
									function (signature) {
										return signature.flags & SignatureFlags.Abstract;
									},
								) && !hasSyntacticModifier(node, ModifierFlags.Abstract)
							) {
								error(
									node.name || node,
									Diagnostics.A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_be_declared_abstract,
								);
							}
						}
					}
					if (
						!(staticBaseType.symbol && staticBaseType.symbol.flags & SymbolFlags.Class) && !(baseConstructorType.flags & TypeFlags.TypeVariable)
					) {
						// When the static base type is a "class-like" constructor function (but not actually a class), we verify
						// that all instantiated base constructor signatures return the same type.
						var constructors = getInstantiatedConstructorsForTypeArguments(
							staticBaseType,
							baseTypeNode.typeArguments,
							baseTypeNode,
						);
						if (
							forEach(
								constructors,
								function (sig) {
									return !isJSConstructor(sig.declaration) && !isTypeIdenticalTo(
										getReturnTypeOfSignature(sig),
										baseType_1,
									);
								},
							)
						) {
							error(
								baseTypeNode.expression,
								Diagnostics.Base_constructors_must_all_have_the_same_return_type,
							);
						}
					}
					checkKindsOfPropertyMemberOverrides(type, baseType_1);
				}
			}
			checkMembersForOverrideModifier(node, type, typeWithThis, staticType);
			var implementedTypeNodes = getEffectiveImplementsTypeNodes(node);
			if (implementedTypeNodes) {
				for (
					var _b = 0, implementedTypeNodes_1 = implementedTypeNodes;
					_b < implementedTypeNodes_1.length;
					_b++
				) {
					var typeRefNode = implementedTypeNodes_1[_b];
					if (
						!isEntityNameExpression(typeRefNode.expression) || isOptionalChain(
							typeRefNode.expression,
						)
					) {
						error(
							typeRefNode.expression,
							Diagnostics.A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments,
						);
					}
					checkTypeReferenceNode(typeRefNode);
					if (produceDiagnostics) {
						var t = getReducedType(getTypeFromTypeNode(typeRefNode));
						if (!isErrorType(t)) {
							if (isValidBaseType(t)) {
								var genericDiag = t.symbol && t.symbol.flags & SymbolFlags.Class ? Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass : Diagnostics.Class_0_incorrectly_implements_interface_1;
								var baseWithThis = getTypeWithThisArgument(t, type.thisType);
								if (
									!checkTypeAssignableTo(
										typeWithThis,
										baseWithThis, /*errorNode*/
										undefined,
									)
								) {
									issueMemberSpecificError(
										node,
										typeWithThis,
										baseWithThis,
										genericDiag,
									);
								}
							} else {
								error(
									typeRefNode,
									Diagnostics.A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_members,
								);
							}
						}
					}
				}
			}
			if (produceDiagnostics) {
				checkIndexConstraints(type, symbol);
				checkIndexConstraints(staticType, symbol, /*isStaticIndex*/ true);
				checkTypeForDuplicateIndexSignatures(node);
				checkPropertyInitialization(node);
			}
		}
		function checkMembersForOverrideModifier(
			node,
			type,
			typeWithThis,
			staticType,
		) {
			var baseTypeNode = getEffectiveBaseTypeNode(node);
			var baseTypes = baseTypeNode && getBaseTypes(type);
			var baseWithThis = (baseTypes === null || baseTypes === void 0 ? void 0 : baseTypes.length) ? getTypeWithThisArgument(
				first(baseTypes),
				type.thisType,
			) : undefined;
			var baseStaticType = getBaseConstructorTypeOfClass(type);
			var _loop_23 = function (member) {
				if (hasAmbientModifier(member)) {
					return "continue";
				}
				if (isConstructorDeclaration(member)) {
					forEach(
						member.parameters,
						function (param) {
							if (isParameterPropertyDeclaration(param, member)) {
								checkExistingMemberForOverrideModifier(
									node,
									staticType,
									baseStaticType,
									baseWithThis,
									type,
									typeWithThis,
									param,
									/* memberIsParameterProperty */ true,
								);
							}
						},
					);
				}
				checkExistingMemberForOverrideModifier(
					node,
					staticType,
					baseStaticType,
					baseWithThis,
					type,
					typeWithThis,
					member,
					/* memberIsParameterProperty */ false,
				);
			};
			for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
				var member = _a[_i];
				_loop_23(member);
			}
		}
		/**
         * @param member Existing member node to be checked.
         * Note: `member` cannot be a synthetic node.
         */
		function checkExistingMemberForOverrideModifier(
			node,
			staticType,
			baseStaticType,
			baseWithThis,
			type,
			typeWithThis,
			member,
			memberIsParameterProperty,
			reportErrors,
		) {
			if (reportErrors === void 0) {
				reportErrors = true;
			}
			var declaredProp = member.name && getSymbolAtLocation(member.name) || getSymbolAtLocation(
				member,
			);
			if (!declaredProp) {
				return MemberOverrideStatus.Ok;
			}
			return checkMemberForOverrideModifier(
				node,
				staticType,
				baseStaticType,
				baseWithThis,
				type,
				typeWithThis,
				hasOverrideModifier(member),
				hasAbstractModifier(member),
				isStatic(member),
				memberIsParameterProperty,
				symbolName(declaredProp),
				reportErrors ? member : undefined,
			);
		}
		/**
         * Checks a class member declaration for either a missing or an invalid `override` modifier.
         * Note: this function can be used for speculative checking,
         * i.e. checking a member that does not yet exist in the program.
         * An example of that would be to call this function in a completions scenario,
         * when offering a method declaration as completion.
         * @param errorNode The node where we should report an error, or undefined if we should not report errors.
         */
		function checkMemberForOverrideModifier(
			node,
			staticType,
			baseStaticType,
			baseWithThis,
			type,
			typeWithThis,
			memberHasOverrideModifier,
			memberHasAbstractModifier,
			memberIsStatic,
			memberIsParameterProperty,
			memberName,
			errorNode,
		) {
			var isJs = isInJSFile(node);
			var nodeInAmbientContext = !!(node.flags & NodeFlags.Ambient);
			if (
				baseWithThis && (memberHasOverrideModifier || compilerOptions.noImplicitOverride)
			) {
				var memberEscapedName = escapeLeadingUnderscores(memberName);
				var thisType = memberIsStatic ? staticType : typeWithThis;
				var baseType = memberIsStatic ? baseStaticType : baseWithThis;
				var prop = getPropertyOfType(thisType, memberEscapedName);
				var baseProp = getPropertyOfType(baseType, memberEscapedName);
				var baseClassName = typeToString(baseWithThis);
				if (prop && !baseProp && memberHasOverrideModifier) {
					if (errorNode) {
						var suggestion = getSuggestedSymbolForNonexistentClassMember(
							memberName,
							baseType,
						); // Again, using symbol name: note that's different from `symbol.escapedName`
						suggestion ? error(
							errorNode,
							isJs ? Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1 : Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1,
							baseClassName,
							symbolToString(suggestion),
						) : error(
							errorNode,
							isJs ? Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0 : Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0,
							baseClassName,
						);
					}
					return MemberOverrideStatus.HasInvalidOverride;
				} else if (
					prop && (baseProp === null || baseProp === void 0 ? void 0 : baseProp.declarations) && compilerOptions.noImplicitOverride && !nodeInAmbientContext
				) {
					var baseHasAbstract = some(baseProp.declarations, hasAbstractModifier);
					if (memberHasOverrideModifier) {
						return MemberOverrideStatus.Ok;
					}
					if (!baseHasAbstract) {
						if (errorNode) {
							var diag = memberIsParameterProperty ? isJs ? Diagnostics.This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0 : Diagnostics.This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0 : isJs ? Diagnostics.This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0 : Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0;
							error(errorNode, diag, baseClassName);
						}
						return MemberOverrideStatus.NeedsOverride;
					} else if (memberHasAbstractModifier && baseHasAbstract) {
						if (errorNode) {
							error(
								errorNode,
								Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0,
								baseClassName,
							);
						}
						return MemberOverrideStatus.NeedsOverride;
					}
				}
			} else if (memberHasOverrideModifier) {
				if (errorNode) {
					var className = typeToString(type);
					error(
						errorNode,
						isJs ? Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_extend_another_class : Diagnostics.This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class,
						className,
					);
				}
				return MemberOverrideStatus.HasInvalidOverride;
			}
			return MemberOverrideStatus.Ok;
		}
		function issueMemberSpecificError(
			node,
			typeWithThis,
			baseWithThis,
			broadDiag,
		) {
			// iterate over all implemented properties and issue errors on each one which isn't compatible, rather than the class as a whole, if possible
			var issuedMemberError = false;
			var _loop_24 = function (member) {
				if (isStatic(member)) {
					return "continue";
				}
				var declaredProp = member.name && getSymbolAtLocation(member.name) || getSymbolAtLocation(
					member,
				);
				if (declaredProp) {
					var prop = getPropertyOfType(typeWithThis, declaredProp.escapedName);
					var baseProp = getPropertyOfType(
						baseWithThis,
						declaredProp.escapedName,
					);
					if (prop && baseProp) {
						var rootChain = function () {
							return chainDiagnosticMessages(
								/*details*/ undefined,
								Diagnostics.Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2,
								symbolToString(declaredProp),
								typeToString(typeWithThis),
								typeToString(baseWithThis),
							);
						};
						if (
							!checkTypeAssignableTo(
								getTypeOfSymbol(prop),
								getTypeOfSymbol(baseProp),
								member.name || member, /*message*/
								undefined,
								rootChain,
							)
						) {
							issuedMemberError = true;
						}
					}
				}
			};
			for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
				var member = _a[_i];
				_loop_24(member);
			}
			if (!issuedMemberError) {
				// check again with diagnostics to generate a less-specific error
				checkTypeAssignableTo(
					typeWithThis,
					baseWithThis,
					node.name || node,
					broadDiag,
				);
			}
		}
		function checkBaseTypeAccessibility(type, node) {
			var signatures = getSignaturesOfType(type, SignatureKind.Construct);
			if (signatures.length) {
				var declaration = signatures[0].declaration;
				if (
					declaration && hasEffectiveModifier(
						declaration,
						ModifierFlags.Private,
					)
				) {
					var typeClassDeclaration = getClassLikeDeclarationOfSymbol(
						type.symbol,
					);
					if (!isNodeWithinClass(node, typeClassDeclaration)) {
						error(
							node,
							Diagnostics.Cannot_extend_a_class_0_Class_constructor_is_marked_as_private,
							getFullyQualifiedName(type.symbol),
						);
					}
				}
			}
		}
		/**
         * Checks a member declaration node to see if has a missing or invalid `override` modifier.
         * @param node Class-like node where the member is declared.
         * @param member Member declaration node.
         * Note: `member` can be a synthetic node without a parent.
         */
		function getMemberOverrideModifierStatus(node, member) {
			if (!member.name) {
				return MemberOverrideStatus.Ok;
			}
			var symbol = getSymbolOfNode(node);
			var type = getDeclaredTypeOfSymbol(symbol);
			var typeWithThis = getTypeWithThisArgument(type);
			var staticType = getTypeOfSymbol(symbol);
			var baseTypeNode = getEffectiveBaseTypeNode(node);
			var baseTypes = baseTypeNode && getBaseTypes(type);
			var baseWithThis = (baseTypes === null || baseTypes === void 0 ? void 0 : baseTypes.length) ? getTypeWithThisArgument(
				first(baseTypes),
				type.thisType,
			) : undefined;
			var baseStaticType = getBaseConstructorTypeOfClass(type);
			var memberHasOverrideModifier = member.parent ? hasOverrideModifier(
				member,
			) : hasSyntacticModifier(member, ModifierFlags.Override);
			var memberName = unescapeLeadingUnderscores(
				getTextOfPropertyName(member.name),
			);
			return checkMemberForOverrideModifier(
				node,
				staticType,
				baseStaticType,
				baseWithThis,
				type,
				typeWithThis,
				memberHasOverrideModifier,
				hasAbstractModifier(member),
				isStatic(member),
				/* memberIsParameterProperty */ false,
				memberName,
			);
		}
		function getTargetSymbol(s) {
			// if symbol is instantiated its flags are not copied from the 'target'
			// so we'll need to get back original 'target' symbol to work with correct set of flags
			return getCheckFlags(s) & CheckFlags.Instantiated ? s.target : s;
		}
		function getClassOrInterfaceDeclarationsOfSymbol(symbol) {
			return filter(
				symbol.declarations,
				function (d) {
					return d.kind === SyntaxKind.ClassDeclaration || d.kind === SyntaxKind.InterfaceDeclaration;
				},
			);
		}
		function checkKindsOfPropertyMemberOverrides(type, baseType) {
			// TypeScript 1.0 spec (April 2014): 8.2.3
			// A derived class inherits all members from its base class it doesn't override.
			// Inheritance means that a derived class implicitly contains all non - overridden members of the base class.
			// Both public and private property members are inherited, but only public property members can be overridden.
			// A property member in a derived class is said to override a property member in a base class
			// when the derived class property member has the same name and kind(instance or static)
			// as the base class property member.
			// The type of an overriding property member must be assignable(section 3.8.4)
			// to the type of the overridden property member, or otherwise a compile - time error occurs.
			// Base class instance member functions can be overridden by derived class instance member functions,
			// but not by other kinds of members.
			// Base class instance member variables and accessors can be overridden by
			// derived class instance member variables and accessors, but not by other kinds of members.
			var _a, _b;
			// NOTE: assignability is checked in checkClassDeclaration
			var baseProperties = getPropertiesOfType(baseType);
			basePropertyCheck: for (
				var _i = 0, baseProperties_1 = baseProperties;
				_i < baseProperties_1.length;
				_i++
			) {
				var baseProperty = baseProperties_1[_i];
				var base = getTargetSymbol(baseProperty);
				if (base.flags & SymbolFlags.Prototype) {
					continue;
				}
				var baseSymbol = getPropertyOfObjectType(type, base.escapedName);
				if (!baseSymbol) {
					continue;
				}
				var derived = getTargetSymbol(baseSymbol);
				var baseDeclarationFlags = getDeclarationModifierFlagsFromSymbol(base);
				Debug.assert(
					!!derived,
					"derived should point to something, even if it is the base class' declaration.",
				);
				// In order to resolve whether the inherited method was overridden in the base class or not,
				// we compare the Symbols obtained. Since getTargetSymbol returns the symbol on the *uninstantiated*
				// type declaration, derived and base resolve to the same symbol even in the case of generic classes.
				if (derived === base) {
					// derived class inherits base without override/redeclaration
					var derivedClassDecl = getClassLikeDeclarationOfSymbol(type.symbol);
					// It is an error to inherit an abstract member without implementing it or being declared abstract.
					// If there is no declaration for the derived class (as in the case of class expressions),
					// then the class cannot be declared abstract.
					if (
						baseDeclarationFlags & ModifierFlags.Abstract && (!derivedClassDecl || !hasSyntacticModifier(
							derivedClassDecl,
							ModifierFlags.Abstract,
						))
					) {
						// Searches other base types for a declaration that would satisfy the inherited abstract member.
						// (The class may have more than one base type via declaration merging with an interface with the
						// same name.)
						for (var _c = 0, _d = getBaseTypes(type); _c < _d.length; _c++) {
							var otherBaseType = _d[_c];
							if (otherBaseType === baseType) continue;
							var baseSymbol_1 = getPropertyOfObjectType(
								otherBaseType,
								base.escapedName,
							);
							var derivedElsewhere = baseSymbol_1 && getTargetSymbol(
								baseSymbol_1,
							);
							if (derivedElsewhere && derivedElsewhere !== base) {
								continue basePropertyCheck;
							}
						}
						if (derivedClassDecl.kind === SyntaxKind.ClassExpression) {
							error(
								derivedClassDecl,
								Diagnostics.Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1,
								symbolToString(baseProperty),
								typeToString(baseType),
							);
						} else {
							error(
								derivedClassDecl,
								Diagnostics.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2,
								typeToString(type),
								symbolToString(baseProperty),
								typeToString(baseType),
							);
						}
					}
				} else {
					// derived overrides base.
					var derivedDeclarationFlags = getDeclarationModifierFlagsFromSymbol(
						derived,
					);
					if (
						baseDeclarationFlags & ModifierFlags.Private || derivedDeclarationFlags & ModifierFlags.Private
					) {
						// either base or derived property is private - not override, skip it
						continue;
					}
					var errorMessage = void 0;
					var basePropertyFlags = base.flags & SymbolFlags.PropertyOrAccessor;
					var derivedPropertyFlags = derived.flags & SymbolFlags.PropertyOrAccessor;
					if (basePropertyFlags && derivedPropertyFlags) {
						// property/accessor is overridden with property/accessor
						if (
							baseDeclarationFlags & ModifierFlags.Abstract && !(base.valueDeclaration && isPropertyDeclaration(
								base.valueDeclaration,
							) && base.valueDeclaration.initializer) || base.valueDeclaration && base.valueDeclaration.parent.kind === SyntaxKind.InterfaceDeclaration || derived.valueDeclaration && isBinaryExpression(
								derived.valueDeclaration,
							)
						) {
							// when the base property is abstract or from an interface, base/derived flags don't need to match
							// same when the derived property is from an assignment
							continue;
						}
						var overriddenInstanceProperty = basePropertyFlags !== SymbolFlags.Property && derivedPropertyFlags === SymbolFlags.Property;
						var overriddenInstanceAccessor = basePropertyFlags === SymbolFlags.Property && derivedPropertyFlags !== SymbolFlags.Property;
						if (overriddenInstanceProperty || overriddenInstanceAccessor) {
							var errorMessage_1 = overriddenInstanceProperty ? Diagnostics._0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property : Diagnostics._0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor;
							error(
								getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration,
								errorMessage_1,
								symbolToString(base),
								typeToString(baseType),
								typeToString(type),
							);
						} else if (useDefineForClassFields) {
							var uninitialized = (_a = derived.declarations) === null || _a === void 0 ? void 0 : _a.find(
								function (d) {
									return d.kind === SyntaxKind.PropertyDeclaration && !d.initializer;
								},
							);
							if (
								uninitialized && !(derived.flags & SymbolFlags.Transient) && !(baseDeclarationFlags & ModifierFlags.Abstract) && !(derivedDeclarationFlags & ModifierFlags.Abstract) && !((_b = derived.declarations) === null || _b === void 0 ? void 0 : _b.some(
									function (d) {
										return !!(d.flags & NodeFlags.Ambient);
									},
								))
							) {
								var constructor = findConstructorDeclaration(
									getClassLikeDeclarationOfSymbol(type.symbol),
								);
								var propName = uninitialized.name;
								if (
									uninitialized.exclamationToken || !constructor || !isIdentifier(
										propName,
									) || !strictNullChecks || !isPropertyInitializedInConstructor(
										propName,
										type,
										constructor,
									)
								) {
									var errorMessage_2 = Diagnostics.Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_add_a_declare_modifier_or_remove_the_redundant_declaration;
									error(
										getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration,
										errorMessage_2,
										symbolToString(base),
										typeToString(baseType),
									);
								}
							}
						}
						// correct case
						continue;
					} else if (isPrototypeProperty(base)) {
						if (
							isPrototypeProperty(derived) || derived.flags & SymbolFlags.Property
						) {
							// method is overridden with method or property -- correct case
							continue;
						} else {
							Debug.assert(!!(derived.flags & SymbolFlags.Accessor));
							errorMessage = Diagnostics.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor;
						}
					} else if (base.flags & SymbolFlags.Accessor) {
						errorMessage = Diagnostics.Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function;
					} else {
						errorMessage = Diagnostics.Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function;
					}
					error(
						getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration,
						errorMessage,
						typeToString(baseType),
						symbolToString(base),
						typeToString(type),
					);
				}
			}
		}
		function getNonInterhitedProperties(type, baseTypes, properties) {
			if (!length(baseTypes)) {
				return properties;
			}
			var seen = new Map();
			forEach(
				properties,
				function (p) {
					seen.set(p.escapedName, p);
				},
			);
			for (var _i = 0, baseTypes_2 = baseTypes; _i < baseTypes_2.length; _i++) {
				var base = baseTypes_2[_i];
				var properties_5 = getPropertiesOfType(
					getTypeWithThisArgument(base, type.thisType),
				);
				for (
					var _a = 0, properties_4 = properties_5;
					_a < properties_4.length;
					_a++
				) {
					var prop = properties_4[_a];
					var existing = seen.get(prop.escapedName);
					if (existing && prop.parent === existing.parent) {
						seen["delete"](prop.escapedName);
					}
				}
			}
			return arrayFrom(seen.values());
		}
		function checkInheritedPropertiesAreIdentical(type, typeNode) {
			var baseTypes = getBaseTypes(type);
			if (baseTypes.length < 2) {
				return true;
			}
			var seen = new Map();
			forEach(
				resolveDeclaredMembers(type).declaredProperties,
				function (p) {
					seen.set(p.escapedName, { prop: p, containingType: type });
				},
			);
			var ok = true;
			for (var _i = 0, baseTypes_3 = baseTypes; _i < baseTypes_3.length; _i++) {
				var base = baseTypes_3[_i];
				var properties = getPropertiesOfType(
					getTypeWithThisArgument(base, type.thisType),
				);
				for (
					var _a = 0, properties_6 = properties;
					_a < properties_6.length;
					_a++
				) {
					var prop = properties_6[_a];
					var existing = seen.get(prop.escapedName);
					if (!existing) {
						seen.set(prop.escapedName, { prop: prop, containingType: base });
					} else {
						var isInheritedProperty = existing.containingType !== type;
						if (
							isInheritedProperty && !isPropertyIdenticalTo(existing.prop, prop)
						) {
							ok = false;
							var typeName1 = typeToString(existing.containingType);
							var typeName2 = typeToString(base);
							var errorInfo = chainDiagnosticMessages(
								undefined, /*details*/
								Diagnostics.Named_property_0_of_types_1_and_2_are_not_identical,
								symbolToString(prop),
								typeName1,
								typeName2,
							);
							errorInfo = chainDiagnosticMessages(
								errorInfo,
								Diagnostics.Interface_0_cannot_simultaneously_extend_types_1_and_2,
								typeToString(type),
								typeName1,
								typeName2,
							);
							diagnostics.add(
								createDiagnosticForNodeFromMessageChain(typeNode, errorInfo),
							);
						}
					}
				}
			}
			return ok;
		}
		function checkPropertyInitialization(node) {
			if (
				!strictNullChecks || !strictPropertyInitialization || node.flags & NodeFlags.Ambient
			) {
				return;
			}
			var constructor = findConstructorDeclaration(node);
			for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
				var member = _a[_i];
				if (getEffectiveModifierFlags(member) & ModifierFlags.Ambient) {
					continue;
				}
				if (!isStatic(member) && isPropertyWithoutInitializer(member)) {
					var propName = member.name;
					if (isIdentifier(propName) || isPrivateIdentifier(propName)) {
						var type = getTypeOfSymbol(getSymbolOfNode(member));
						if (
							!(type.flags & TypeFlags.AnyOrUnknown || getFalsyFlags(type) & TypeFlags.Undefined)
						) {
							if (
								!constructor || !isPropertyInitializedInConstructor(
									propName,
									type,
									constructor,
								)
							) {
								error(
									member.name,
									Diagnostics.Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor,
									declarationNameToString(propName),
								);
							}
						}
					}
				}
			}
		}
		function isPropertyWithoutInitializer(node) {
			return node.kind === SyntaxKind.PropertyDeclaration && !hasAbstractModifier(
				node,
			) && !node.exclamationToken && !node.initializer;
		}
		function isPropertyInitializedInStaticBlocks(
			propName,
			propType,
			staticBlocks,
			startPos,
			endPos,
		) {
			for (
				var _i = 0, staticBlocks_2 = staticBlocks;
				_i < staticBlocks_2.length;
				_i++
			) {
				var staticBlock = staticBlocks_2[_i];
				// static block must be within the provided range as they are evaluated in document order (unlike constructors)
				if (staticBlock.pos >= startPos && staticBlock.pos <= endPos) {
					var reference = factory.createPropertyAccessExpression(
						factory.createThis(),
						propName,
					);
					setParent(reference.expression, reference);
					setParent(reference, staticBlock);
					reference.flowNode = staticBlock.returnFlowNode;
					var flowType = getFlowTypeOfReference(
						reference,
						propType,
						getOptionalType(propType),
					);
					if (!(getFalsyFlags(flowType) & TypeFlags.Undefined)) {
						return true;
					}
				}
			}
			return false;
		}
		function isPropertyInitializedInConstructor(propName, propType, constructor) {
			var reference = factory.createPropertyAccessExpression(
				factory.createThis(),
				propName,
			);
			setParent(reference.expression, reference);
			setParent(reference, constructor);
			reference.flowNode = constructor.returnFlowNode;
			var flowType = getFlowTypeOfReference(
				reference,
				propType,
				getOptionalType(propType),
			);
			return !(getFalsyFlags(flowType) & TypeFlags.Undefined);
		}
		function checkInterfaceDeclaration(node) {
			// Grammar checking
			if (!checkGrammarDecoratorsAndModifiers(node)) checkGrammarInterfaceDeclaration(
				node,
			);
			checkTypeParameters(node.typeParameters);
			if (produceDiagnostics) {
				checkTypeNameIsReserved(
					node.name,
					Diagnostics.Interface_name_cannot_be_0,
				);
				checkExportsOnMergedDeclarations(node);
				var symbol = getSymbolOfNode(node);
				checkTypeParameterListsIdentical(symbol);
				// Only check this symbol once
				var firstInterfaceDecl = getDeclarationOfKind(
					symbol,
					SyntaxKind.InterfaceDeclaration,
				);
				if (node === firstInterfaceDecl) {
					var type = getDeclaredTypeOfSymbol(symbol);
					var typeWithThis = getTypeWithThisArgument(type);
					// run subsequent checks only if first set succeeded
					if (checkInheritedPropertiesAreIdentical(type, node.name)) {
						for (var _i = 0, _a = getBaseTypes(type); _i < _a.length; _i++) {
							var baseType = _a[_i];
							checkTypeAssignableTo(
								typeWithThis,
								getTypeWithThisArgument(baseType, type.thisType),
								node.name,
								Diagnostics.Interface_0_incorrectly_extends_interface_1,
							);
						}
						checkIndexConstraints(type, symbol);
					}
				}
				checkObjectTypeForDuplicateDeclarations(node);
			}
			forEach(
				getInterfaceBaseTypeNodes(node),
				function (heritageElement) {
					if (
						!isEntityNameExpression(heritageElement.expression) || isOptionalChain(
							heritageElement.expression,
						)
					) {
						error(
							heritageElement.expression,
							Diagnostics.An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments,
						);
					}
					checkTypeReferenceNode(heritageElement);
				},
			);
			forEach(node.members, checkSourceElement);
			if (produceDiagnostics) {
				checkTypeForDuplicateIndexSignatures(node);
				registerForUnusedIdentifiersCheck(node);
			}
		}
		function checkTypeAliasDeclaration(node) {
			// Grammar checking
			checkGrammarDecoratorsAndModifiers(node);
			checkTypeNameIsReserved(
				node.name,
				Diagnostics.Type_alias_name_cannot_be_0,
			);
			checkExportsOnMergedDeclarations(node);
			checkTypeParameters(node.typeParameters);
			if (node.type.kind === SyntaxKind.IntrinsicKeyword) {
				if (
					!intrinsicTypeKinds.has(node.name.escapedText) || length(
						node.typeParameters,
					) !== 1
				) {
					error(
						node.type,
						Diagnostics.The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types,
					);
				}
			} else {
				checkSourceElement(node.type);
				registerForUnusedIdentifiersCheck(node);
			}
		}
		function computeEnumMemberValues(node) {
			var nodeLinks = getNodeLinks(node);
			if (!(nodeLinks.flags & NodeCheckFlags.EnumValuesComputed)) {
				nodeLinks.flags |= NodeCheckFlags.EnumValuesComputed;
				var autoValue = 0;
				for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
					var member = _a[_i];
					var value = computeMemberValue(member, autoValue);
					getNodeLinks(member).enumMemberValue = value;
					autoValue = typeof value === "number" ? value + 1 : undefined;
				}
			}
		}
		function computeMemberValue(member, autoValue) {
			if (isComputedNonLiteralName(member.name)) {
				error(
					member.name,
					Diagnostics.Computed_property_names_are_not_allowed_in_enums,
				);
			} else {
				var text = getTextOfPropertyName(member.name);
				if (isNumericLiteralName(text) && !isInfinityOrNaNString(text)) {
					error(
						member.name,
						Diagnostics.An_enum_member_cannot_have_a_numeric_name,
					);
				}
			}
			if (member.initializer) {
				return computeConstantValue(member);
			}
			// In ambient non-const numeric enum declarations, enum members without initializers are
			// considered computed members (as opposed to having auto-incremented values).
			if (
				member.parent.flags & NodeFlags.Ambient && !isEnumConst(member.parent) && getEnumKind(
					getSymbolOfNode(member.parent),
				) === EnumKind.Numeric
			) {
				return undefined;
			}
			// If the member declaration specifies no value, the member is considered a constant enum member.
			// If the member is the first member in the enum declaration, it is assigned the value zero.
			// Otherwise, it is assigned the value of the immediately preceding member plus one, and an error
			// occurs if the immediately preceding member is not a constant enum member.
			if (autoValue !== undefined) {
				return autoValue;
			}
			error(member.name, Diagnostics.Enum_member_must_have_initializer);
			return undefined;
		}
		function computeConstantValue(member) {
			var enumKind = getEnumKind(getSymbolOfNode(member.parent));
			var isConstEnum = isEnumConst(member.parent);
			var initializer = member.initializer;
			var value = enumKind === EnumKind.Literal && !isLiteralEnumMember(member) ? undefined : evaluate(
				initializer,
			);
			if (value !== undefined) {
				if (isConstEnum && typeof value === "number" && !isFinite(value)) {
					error(
						initializer,
						isNaN(value) ? Diagnostics.const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN : Diagnostics.const_enum_member_initializer_was_evaluated_to_a_non_finite_value,
					);
				}
			} else if (enumKind === EnumKind.Literal) {
				error(
					initializer,
					Diagnostics.Computed_values_are_not_permitted_in_an_enum_with_string_valued_members,
				);
				return 0;
			} else if (isConstEnum) {
				error(
					initializer,
					Diagnostics.const_enum_member_initializers_can_only_contain_literal_values_and_other_computed_enum_values,
				);
			} else if (member.parent.flags & NodeFlags.Ambient) {
				error(
					initializer,
					Diagnostics.In_ambient_enum_declarations_member_initializer_must_be_constant_expression,
				);
			} else {
				// Only here do we need to check that the initializer is assignable to the enum type.
				var source = checkExpression(initializer);
				if (!isTypeAssignableToKind(source, TypeFlags.NumberLike)) {
					error(
						initializer,
						Diagnostics.Only_numeric_enums_can_have_computed_members_but_this_expression_has_type_0_If_you_do_not_need_exhaustiveness_checks_consider_using_an_object_literal_instead,
						typeToString(source),
					);
				} else {
					checkTypeAssignableTo(
						source,
						getDeclaredTypeOfSymbol(getSymbolOfNode(member.parent)),
						initializer, /*headMessage*/
						undefined,
					);
				}
			}
			return value;
			function evaluate(expr) {
				switch (expr.kind) {
					case SyntaxKind.PrefixUnaryExpression:
						var value_1 = evaluate(expr.operand);
						if (typeof value_1 === "number") {
							switch (expr.operator) {
								case SyntaxKind.PlusToken:
									return value_1;
								case SyntaxKind.MinusToken:
									return -value_1;
								case SyntaxKind.TildeToken:
									return ~value_1;
							}
						}
						break;
					case SyntaxKind.BinaryExpression:
						var left = evaluate(expr.left);
						var right = evaluate(expr.right);
						if (typeof left === "number" && typeof right === "number") {
							switch (expr.operatorToken.kind) {
								case SyntaxKind.BarToken:
									return left | right;
								case SyntaxKind.AmpersandToken:
									return left & right;
								case SyntaxKind.GreaterThanGreaterThanToken:
									return left >> right;
								case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
									return left >>> right;
								case SyntaxKind.LessThanLessThanToken:
									return left << right;
								case SyntaxKind.CaretToken:
									return left ^ right;
								case SyntaxKind.AsteriskToken:
									return left * right;
								case SyntaxKind.SlashToken:
									return left / right;
								case SyntaxKind.PlusToken:
									return left + right;
								case SyntaxKind.MinusToken:
									return left - right;
								case SyntaxKind.PercentToken:
									return left % right;
								case SyntaxKind.AsteriskAsteriskToken:
									return Math.pow(left, right);
							}
						} else if (
							typeof left === "string" && typeof right === "string" && expr.operatorToken.kind === SyntaxKind.PlusToken
						) {
							return left + right;
						}
						break;
					case SyntaxKind.StringLiteral:
					case SyntaxKind.NoSubstitutionTemplateLiteral:
						return expr.text;
					case SyntaxKind.NumericLiteral:
						checkGrammarNumericLiteral(expr);
						return +expr.text;
					case SyntaxKind.ParenthesizedExpression:
						return evaluate(expr.expression);
					case SyntaxKind.Identifier:
						var identifier = expr;
						if (isInfinityOrNaNString(identifier.escapedText)) {
							return +(identifier.escapedText);
						}
						return nodeIsMissing(expr) ? 0 : evaluateEnumMember(
							expr,
							getSymbolOfNode(member.parent),
							identifier.escapedText,
						);
					case SyntaxKind.ElementAccessExpression:
					case SyntaxKind.PropertyAccessExpression:
						var ex = expr;
						if (isConstantMemberAccess(ex)) {
							var type = getTypeOfExpression(ex.expression);
							if (type.symbol && type.symbol.flags & SymbolFlags.Enum) {
								var name_37;
								if (ex.kind === SyntaxKind.PropertyAccessExpression) {
									name_37 = ex.name.escapedText;
								} else {
									name_37 = escapeLeadingUnderscores(
										cast(ex.argumentExpression, isLiteralExpression).text,
									);
								}
								return evaluateEnumMember(expr, type.symbol, name_37);
							}
						}
						break;
				}
				return undefined;
			}
			function evaluateEnumMember(expr, enumSymbol, name) {
				var memberSymbol = enumSymbol.exports.get(name);
				if (memberSymbol) {
					var declaration = memberSymbol.valueDeclaration;
					if (declaration !== member) {
						if (
							declaration && isBlockScopedNameDeclaredBeforeUse(
								declaration,
								member,
							) && isEnumDeclaration(declaration.parent)
						) {
							return getEnumMemberValue(declaration);
						}
						error(
							expr,
							Diagnostics.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums,
						);
						return 0;
					} else {
						error(
							expr,
							Diagnostics.Property_0_is_used_before_being_assigned,
							symbolToString(memberSymbol),
						);
					}
				}
				return undefined;
			}
		}
		function isConstantMemberAccess(node) {
			return node.kind === SyntaxKind.Identifier || node.kind === SyntaxKind.PropertyAccessExpression && isConstantMemberAccess(
				node.expression,
			) || node.kind === SyntaxKind.ElementAccessExpression && isConstantMemberAccess(
				node.expression,
			) && isStringLiteralLike(node.argumentExpression);
		}
		function checkEnumDeclaration(node) {
			if (!produceDiagnostics) {
				return;
			}
			// Grammar checking
			checkGrammarDecoratorsAndModifiers(node);
			checkCollisionsForDeclarationName(node, node.name);
			checkExportsOnMergedDeclarations(node);
			node.members.forEach(checkEnumMember);
			computeEnumMemberValues(node);
			// Spec 2014 - Section 9.3:
			// It isn't possible for one enum declaration to continue the automatic numbering sequence of another,
			// and when an enum type has multiple declarations, only one declaration is permitted to omit a value
			// for the first member.
			//
			// Only perform this check once per symbol
			var enumSymbol = getSymbolOfNode(node);
			var firstDeclaration = getDeclarationOfKind(enumSymbol, node.kind);
			if (node === firstDeclaration) {
				if (enumSymbol.declarations && enumSymbol.declarations.length > 1) {
					var enumIsConst_1 = isEnumConst(node);
					// check that const is placed\omitted on all enum declarations
					forEach(
						enumSymbol.declarations,
						function (decl) {
							if (
								isEnumDeclaration(decl) && isEnumConst(decl) !== enumIsConst_1
							) {
								error(
									getNameOfDeclaration(decl),
									Diagnostics.Enum_declarations_must_all_be_const_or_non_const,
								);
							}
						},
					);
				}
				var seenEnumMissingInitialInitializer_1 = false;
				forEach(
					enumSymbol.declarations,
					function (declaration) {
						// return true if we hit a violation of the rule, false otherwise
						if (declaration.kind !== SyntaxKind.EnumDeclaration) {
							return false;
						}
						var enumDeclaration = declaration;
						if (!enumDeclaration.members.length) {
							return false;
						}
						var firstEnumMember = enumDeclaration.members[0];
						if (!firstEnumMember.initializer) {
							if (seenEnumMissingInitialInitializer_1) {
								error(
									firstEnumMember.name,
									Diagnostics.In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element,
								);
							} else {
								seenEnumMissingInitialInitializer_1 = true;
							}
						}
					},
				);
			}
		}
		function checkEnumMember(node) {
			if (isPrivateIdentifier(node.name)) {
				error(
					node,
					Diagnostics.An_enum_member_cannot_be_named_with_a_private_identifier,
				);
			}
		}
		function getFirstNonAmbientClassOrFunctionDeclaration(symbol) {
			var declarations = symbol.declarations;
			if (declarations) {
				for (
					var _i = 0, declarations_7 = declarations;
					_i < declarations_7.length;
					_i++
				) {
					var declaration = declarations_7[_i];
					if (
						(declaration.kind === SyntaxKind.ClassDeclaration || (declaration.kind === SyntaxKind.FunctionDeclaration && nodeIsPresent(
							declaration.body,
						))) && !(declaration.flags & NodeFlags.Ambient)
					) {
						return declaration;
					}
				}
			}
			return undefined;
		}
		function inSameLexicalScope(node1, node2) {
			var container1 = getEnclosingBlockScopeContainer(node1);
			var container2 = getEnclosingBlockScopeContainer(node2);
			if (isGlobalSourceFile(container1)) {
				return isGlobalSourceFile(container2);
			} else if (isGlobalSourceFile(container2)) {
				return false;
			} else {
				return container1 === container2;
			}
		}
		function checkModuleDeclaration(node) {
			if (produceDiagnostics) {
				// Grammar checking
				var isGlobalAugmentation = isGlobalScopeAugmentation(node);
				var inAmbientContext = node.flags & NodeFlags.Ambient;
				if (isGlobalAugmentation && !inAmbientContext) {
					error(
						node.name,
						Diagnostics.Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context,
					);
				}
				var isAmbientExternalModule = isAmbientModule(node);
				var contextErrorMessage = isAmbientExternalModule ? Diagnostics.An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file : Diagnostics.A_namespace_declaration_is_only_allowed_in_a_namespace_or_module;
				if (checkGrammarModuleElementContext(node, contextErrorMessage)) {
					// If we hit a module declaration in an illegal context, just bail out to avoid cascading errors.
					return;
				}
				if (!checkGrammarDecoratorsAndModifiers(node)) {
					if (!inAmbientContext && node.name.kind === SyntaxKind.StringLiteral) {
						grammarErrorOnNode(
							node.name,
							Diagnostics.Only_ambient_modules_can_use_quoted_names,
						);
					}
				}
				if (isIdentifier(node.name)) {
					checkCollisionsForDeclarationName(node, node.name);
				}
				checkExportsOnMergedDeclarations(node);
				var symbol = getSymbolOfNode(node);
				// The following checks only apply on a non-ambient instantiated module declaration.
				if (
					symbol.flags & SymbolFlags.ValueModule && !inAmbientContext && symbol.declarations && symbol.declarations.length > 1 && isInstantiatedModule(
						node,
						shouldPreserveConstEnums(compilerOptions),
					)
				) {
					var firstNonAmbientClassOrFunc = getFirstNonAmbientClassOrFunctionDeclaration(
						symbol,
					);
					if (firstNonAmbientClassOrFunc) {
						if (
							getSourceFileOfNode(node) !== getSourceFileOfNode(
								firstNonAmbientClassOrFunc,
							)
						) {
							error(
								node.name,
								Diagnostics.A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged,
							);
						} else if (node.pos < firstNonAmbientClassOrFunc.pos) {
							error(
								node.name,
								Diagnostics.A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged,
							);
						}
					}
					// if the module merges with a class declaration in the same lexical scope,
					// we need to track this to ensure the correct emit.
					var mergedClass = getDeclarationOfKind(
						symbol,
						SyntaxKind.ClassDeclaration,
					);
					if (mergedClass && inSameLexicalScope(node, mergedClass)) {
						getNodeLinks(node).flags |= NodeCheckFlags.LexicalModuleMergesWithClass;
					}
				}
				if (isAmbientExternalModule) {
					if (isExternalModuleAugmentation(node)) {
						// body of the augmentation should be checked for consistency only if augmentation was applied to its target (either global scope or module)
						// otherwise we'll be swamped in cascading errors.
						// We can detect if augmentation was applied using following rules:
						// - augmentation for a global scope is always applied
						// - augmentation for some external module is applied if symbol for augmentation is merged (it was combined with target module).
						var checkBody = isGlobalAugmentation || (getSymbolOfNode(node).flags & SymbolFlags.Transient);
						if (checkBody && node.body) {
							for (var _i = 0, _a = node.body.statements; _i < _a.length; _i++) {
								var statement = _a[_i];
								checkModuleAugmentationElement(statement, isGlobalAugmentation);
							}
						}
					} else if (isGlobalSourceFile(node.parent)) {
						if (isGlobalAugmentation) {
							error(
								node.name,
								Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations,
							);
						} else if (
							isExternalModuleNameRelative(
								getTextOfIdentifierOrLiteral(node.name),
							)
						) {
							error(
								node.name,
								Diagnostics.Ambient_module_declaration_cannot_specify_relative_module_name,
							);
						}
					} else {
						if (isGlobalAugmentation) {
							error(
								node.name,
								Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations,
							);
						} else {
							// Node is not an augmentation and is not located on the script level.
							// This means that this is declaration of ambient module that is located in other module or namespace which is prohibited.
							error(
								node.name,
								Diagnostics.Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces,
							);
						}
					}
				}
			}
			if (node.body) {
				checkSourceElement(node.body);
				if (!isGlobalScopeAugmentation(node)) {
					registerForUnusedIdentifiersCheck(node);
				}
			}
		}
		function checkModuleAugmentationElement(node, isGlobalAugmentation) {
			var _a;
			switch (node.kind) {
				case SyntaxKind.VariableStatement:
					// error each individual name in variable statement instead of marking the entire variable statement
					for (
						var _i = 0, _b = node.declarationList.declarations;
						_i < _b.length;
						_i++
					) {
						var decl = _b[_i];
						checkModuleAugmentationElement(decl, isGlobalAugmentation);
					}
					break;
				case SyntaxKind.ExportAssignment:
				case SyntaxKind.ExportDeclaration:
					grammarErrorOnFirstToken(
						node,
						Diagnostics.Exports_and_export_assignments_are_not_permitted_in_module_augmentations,
					);
					break;
				case SyntaxKind.ImportEqualsDeclaration:
				case SyntaxKind.ImportDeclaration:
					grammarErrorOnFirstToken(
						node,
						Diagnostics.Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_module,
					);
					break;
				case SyntaxKind.BindingElement:
				case SyntaxKind.VariableDeclaration:
					var name_38 = node.name;
					if (isBindingPattern(name_38)) {
						for (var _c = 0, _d = name_38.elements; _c < _d.length; _c++) {
							var el = _d[_c];
							// mark individual names in binding pattern
							checkModuleAugmentationElement(el, isGlobalAugmentation);
						}
						break;
					}
				// falls through
				case SyntaxKind.ClassDeclaration:
				case SyntaxKind.EnumDeclaration:
				case SyntaxKind.FunctionDeclaration:
				case SyntaxKind.InterfaceDeclaration:
				case SyntaxKind.ModuleDeclaration:
				case SyntaxKind.TypeAliasDeclaration:
					if (isGlobalAugmentation) {
						return;
					}
					var symbol = getSymbolOfNode(node);
					if (symbol) {
						// module augmentations cannot introduce new names on the top level scope of the module
						// this is done it two steps
						// 1. quick check - if symbol for node is not merged - this is local symbol to this augmentation - report error
						// 2. main check - report error if value declaration of the parent symbol is module augmentation)
						var reportError = !(symbol.flags & SymbolFlags.Transient);
						if (!reportError) {
							// symbol should not originate in augmentation
							reportError = !!((_a = symbol.parent) === null || _a === void 0 ? void 0 : _a.declarations) && isExternalModuleAugmentation(
								symbol.parent.declarations[0],
							);
						}
					}
					break;
			}
		}
		function getFirstNonModuleExportsIdentifier(node) {
			switch (node.kind) {
				case SyntaxKind.Identifier:
					return node;
				case SyntaxKind.QualifiedName:
					do {
						node = node.left;
					} while (node.kind !== SyntaxKind.Identifier);
					return node;
				case SyntaxKind.PropertyAccessExpression:
					do {
						if (
							isModuleExportsAccessExpression(node.expression) && !isPrivateIdentifier(
								node.name,
							)
						) {
							return node.name;
						}
						node = node.expression;
					} while (node.kind !== SyntaxKind.Identifier);
					return node;
			}
		}
		function checkExternalImportOrExportDeclaration(node) {
			var moduleName = getExternalModuleName(node);
			if (!moduleName || nodeIsMissing(moduleName)) {
				// Should be a parse error.
				return false;
			}
			if (!isStringLiteral(moduleName)) {
				error(moduleName, Diagnostics.String_literal_expected);
				return false;
			}
			var inAmbientExternalModule = node.parent.kind === SyntaxKind.ModuleBlock && isAmbientModule(
				node.parent.parent,
			);
			if (
				node.parent.kind !== SyntaxKind.SourceFile && !inAmbientExternalModule
			) {
				error(
					moduleName,
					node.kind === SyntaxKind.ExportDeclaration ? Diagnostics.Export_declarations_are_not_permitted_in_a_namespace : Diagnostics.Import_declarations_in_a_namespace_cannot_reference_a_module,
				);
				return false;
			}
			if (
				inAmbientExternalModule && isExternalModuleNameRelative(moduleName.text)
			) {
				// we have already reported errors on top level imports/exports in external module augmentations in checkModuleDeclaration
				// no need to do this again.
				if (!isTopLevelInExternalModuleAugmentation(node)) {
					// TypeScript 1.0 spec (April 2013): 12.1.6
					// An ExternalImportDeclaration in an AmbientExternalModuleDeclaration may reference
					// other external modules only through top - level external module names.
					// Relative external module names are not permitted.
					error(
						node,
						Diagnostics.Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name,
					);
					return false;
				}
			}
			return true;
		}
		function checkAliasSymbol(node) {
			var _a;
			var symbol = getSymbolOfNode(node);
			var target = resolveAlias(symbol);
			if (target !== unknownSymbol) {
				// For external modules, `symbol` represents the local symbol for an alias.
				// This local symbol will merge any other local declarations (excluding other aliases)
				// and symbol.flags will contains combined representation for all merged declaration.
				// Based on symbol.flags we can compute a set of excluded meanings (meaning that resolved alias should not have,
				// otherwise it will conflict with some local declaration). Note that in addition to normal flags we include matching SymbolFlags.Export*
				// in order to prevent collisions with declarations that were exported from the current module (they still contribute to local names).
				symbol = getMergedSymbol(symbol.exportSymbol || symbol);
				var excludedMeanings = (symbol.flags & (SymbolFlags.Value | SymbolFlags.ExportValue) ? SymbolFlags.Value : 0) | (symbol.flags & SymbolFlags.Type ? SymbolFlags.Type : 0) | (symbol.flags & SymbolFlags.Namespace ? SymbolFlags.Namespace : 0);
				if (target.flags & excludedMeanings) {
					var message = node.kind === SyntaxKind.ExportSpecifier ? Diagnostics.Export_declaration_conflicts_with_exported_declaration_of_0 : Diagnostics.Import_declaration_conflicts_with_local_declaration_of_0;
					error(node, message, symbolToString(symbol));
				}
				if (
					compilerOptions.isolatedModules && !isTypeOnlyImportOrExportDeclaration(
						node,
					) && !(node.flags & NodeFlags.Ambient)
				) {
					var typeOnlyAlias = getTypeOnlyAliasDeclaration(symbol);
					var isType = !(target.flags & SymbolFlags.Value);
					if (isType || typeOnlyAlias) {
						switch (node.kind) {
							case SyntaxKind.ImportClause:
							case SyntaxKind.ImportSpecifier:
							case SyntaxKind.ImportEqualsDeclaration:
								{
									if (compilerOptions.preserveValueImports) {
										Debug.assertIsDefined(
											node.name,
											"An ImportClause with a symbol should have a name",
										);
										var message = isType ? Diagnostics._0_is_a_type_and_must_be_imported_using_a_type_only_import_when_preserveValueImports_and_isolatedModules_are_both_enabled : Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_preserveValueImports_and_isolatedModules_are_both_enabled;
										var name_39 = idText(
											node.kind === SyntaxKind.ImportSpecifier ? node.propertyName || node.name : node.name,
										);
										addTypeOnlyDeclarationRelatedInfo(
											error(node, message, name_39),
											isType ? undefined : typeOnlyAlias,
											name_39,
										);
									}
									break;
								}
							case SyntaxKind.ExportSpecifier:
								{
									// Don't allow re-exporting an export that will be elided when `--isolatedModules` is set.
									// The exception is that `import type { A } from './a'; export { A }` is allowed
									// because single-file analysis can determine that the export should be dropped.
									if (
										getSourceFileOfNode(typeOnlyAlias) !== getSourceFileOfNode(
											node,
										)
									) {
										var message = isType ? Diagnostics.Re_exporting_a_type_when_the_isolatedModules_flag_is_provided_requires_using_export_type : Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_isolatedModules_is_enabled;
										var name_40 = idText(node.propertyName || node.name);
										addTypeOnlyDeclarationRelatedInfo(
											error(node, message, name_40),
											isType ? undefined : typeOnlyAlias,
											name_40,
										);
										return;
									}
								}
						}
					}
				}
				if (
					isImportSpecifier(node) && ((_a = target.declarations) === null || _a === void 0 ? void 0 : _a.every(
						function (d) {
							return !!(getCombinedNodeFlags(d) & NodeFlags.Deprecated);
						},
					))
				) {
					addDeprecatedSuggestion(
						node.name,
						target.declarations,
						symbol.escapedName,
					);
				}
			}
		}
		function checkImportBinding(node) {
			checkCollisionsForDeclarationName(node, node.name);
			checkAliasSymbol(node);
			if (
				node.kind === SyntaxKind.ImportSpecifier && idText(
					node.propertyName || node.name,
				) === "default" && getESModuleInterop(compilerOptions) && moduleKind !== ModuleKind.System && (moduleKind < ModuleKind.ES2015 || getSourceFileOfNode(
					node,
				).impliedNodeFormat === ModuleKind.CommonJS)
			) {
				checkExternalEmitHelpers(node, ExternalEmitHelpers.ImportDefault);
			}
		}
		function checkAssertClause(declaration) {
			var _a;
			if (declaration.assertClause) {
				var mode = (moduleKind === ModuleKind.NodeNext) && declaration.moduleSpecifier && getUsageModeForExpression(
					declaration.moduleSpecifier,
				);
				if (mode !== ModuleKind.ESNext && moduleKind !== ModuleKind.ESNext) {
					return grammarErrorOnNode(
						declaration.assertClause,
						moduleKind === ModuleKind.NodeNext ? Diagnostics.Import_assertions_are_not_allowed_on_statements_that_transpile_to_commonjs_require_calls : Diagnostics.Import_assertions_are_only_supported_when_the_module_option_is_set_to_esnext_or_nodenext,
					);
				}
				if (
					isImportDeclaration(declaration) ? (_a = declaration.importClause) === null || _a === void 0 ? void 0 : _a.isTypeOnly : declaration.isTypeOnly
				) {
					return grammarErrorOnNode(
						declaration.assertClause,
						Diagnostics.Import_assertions_cannot_be_used_with_type_only_imports_or_exports,
					);
				}
			}
		}
		function checkImportDeclaration(node) {
			if (
				checkGrammarModuleElementContext(
					node,
					Diagnostics.An_import_declaration_can_only_be_used_in_a_namespace_or_module,
				)
			) {
				// If we hit an import declaration in an illegal context, just bail out to avoid cascading errors.
				return;
			}
			if (
				!checkGrammarDecoratorsAndModifiers(node) && hasEffectiveModifiers(node)
			) {
				grammarErrorOnFirstToken(
					node,
					Diagnostics.An_import_declaration_cannot_have_modifiers,
				);
			}
			if (checkExternalImportOrExportDeclaration(node)) {
				var importClause = node.importClause;
				if (importClause && !checkGrammarImportClause(importClause)) {
					if (importClause.name) {
						checkImportBinding(importClause);
					}
					if (importClause.namedBindings) {
						if (importClause.namedBindings.kind === SyntaxKind.NamespaceImport) {
							checkImportBinding(importClause.namedBindings);
							if (
								moduleKind !== ModuleKind.System && (moduleKind < ModuleKind.ES2015 || getSourceFileOfNode(
									node,
								).impliedNodeFormat === ModuleKind.CommonJS) && getESModuleInterop(
									compilerOptions,
								)
							) {
								// import * as ns from "foo";
								checkExternalEmitHelpers(node, ExternalEmitHelpers.ImportStar);
							}
						} else {
							var moduleExisted = resolveExternalModuleName(
								node,
								node.moduleSpecifier,
							);
							if (moduleExisted) {
								forEach(importClause.namedBindings.elements, checkImportBinding);
							}
						}
					}
				}
			}
			checkAssertClause(node);
		}
		function checkImportEqualsDeclaration(node) {
			if (
				checkGrammarModuleElementContext(
					node,
					Diagnostics.An_import_declaration_can_only_be_used_in_a_namespace_or_module,
				)
			) {
				// If we hit an import declaration in an illegal context, just bail out to avoid cascading errors.
				return;
			}
			checkGrammarDecoratorsAndModifiers(node);
			if (
				isInternalModuleImportEqualsDeclaration(node) || checkExternalImportOrExportDeclaration(
					node,
				)
			) {
				checkImportBinding(node);
				if (hasSyntacticModifier(node, ModifierFlags.Export)) {
					markExportAsReferenced(node);
				}
				if (node.moduleReference.kind !== SyntaxKind.ExternalModuleReference) {
					var target = resolveAlias(getSymbolOfNode(node));
					if (target !== unknownSymbol) {
						if (target.flags & SymbolFlags.Value) {
							// Target is a value symbol, check that it is not hidden by a local declaration with the same name
							var moduleName = getFirstIdentifier(node.moduleReference);
							if (
								!(resolveEntityName(
									moduleName,
									SymbolFlags.Value | SymbolFlags.Namespace,
								).flags & SymbolFlags.Namespace)
							) {
								error(
									moduleName,
									Diagnostics.Module_0_is_hidden_by_a_local_declaration_with_the_same_name,
									declarationNameToString(moduleName),
								);
							}
						}
						if (target.flags & SymbolFlags.Type) {
							checkTypeNameIsReserved(
								node.name,
								Diagnostics.Import_name_cannot_be_0,
							);
						}
					}
					if (node.isTypeOnly) {
						grammarErrorOnNode(
							node,
							Diagnostics.An_import_alias_cannot_use_import_type,
						);
					}
				} else {
					if (
						moduleKind >= ModuleKind.ES2015 && getSourceFileOfNode(node).impliedNodeFormat === undefined && !node.isTypeOnly && !(node.flags & NodeFlags.Ambient)
					) {
						// Import equals declaration is deprecated in es6 or above
						grammarErrorOnNode(
							node,
							Diagnostics.Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_ns_from_mod_import_a_from_mod_import_d_from_mod_or_another_module_format_instead,
						);
					}
				}
			}
		}
		function checkExportDeclaration(node) {
			if (
				checkGrammarModuleElementContext(
					node,
					Diagnostics.An_export_declaration_can_only_be_used_in_a_module,
				)
			) {
				// If we hit an export in an illegal context, just bail out to avoid cascading errors.
				return;
			}
			if (
				!checkGrammarDecoratorsAndModifiers(node) && hasEffectiveModifiers(node)
			) {
				grammarErrorOnFirstToken(
					node,
					Diagnostics.An_export_declaration_cannot_have_modifiers,
				);
			}
			if (
				node.moduleSpecifier && node.exportClause && isNamedExports(
					node.exportClause,
				) && length(node.exportClause.elements) && languageVersion === ScriptTarget.ES3
			) {
				checkExternalEmitHelpers(node, ExternalEmitHelpers.CreateBinding);
			}
			checkGrammarExportDeclaration(node);
			if (!node.moduleSpecifier || checkExternalImportOrExportDeclaration(node)) {
				if (node.exportClause && !isNamespaceExport(node.exportClause)) {
					// export { x, y }
					// export { x, y } from "foo"
					forEach(node.exportClause.elements, checkExportSpecifier);
					var inAmbientExternalModule = node.parent.kind === SyntaxKind.ModuleBlock && isAmbientModule(
						node.parent.parent,
					);
					var inAmbientNamespaceDeclaration = !inAmbientExternalModule && node.parent.kind === SyntaxKind.ModuleBlock && !node.moduleSpecifier && node.flags & NodeFlags.Ambient;
					if (
						node.parent.kind !== SyntaxKind.SourceFile && !inAmbientExternalModule && !inAmbientNamespaceDeclaration
					) {
						error(
							node,
							Diagnostics.Export_declarations_are_not_permitted_in_a_namespace,
						);
					}
				} else {
					// export * from "foo"
					// export * as ns from "foo";
					var moduleSymbol = resolveExternalModuleName(
						node,
						node.moduleSpecifier,
					);
					if (moduleSymbol && hasExportAssignmentSymbol(moduleSymbol)) {
						error(
							node.moduleSpecifier,
							Diagnostics.Module_0_uses_export_and_cannot_be_used_with_export_Asterisk,
							symbolToString(moduleSymbol),
						);
					} else if (node.exportClause) {
						checkAliasSymbol(node.exportClause);
					}
					if (
						moduleKind !== ModuleKind.System && (moduleKind < ModuleKind.ES2015 || getSourceFileOfNode(
							node,
						).impliedNodeFormat === ModuleKind.CommonJS)
					) {
						if (node.exportClause) {
							// export * as ns from "foo";
							// For ES2015 modules, we emit it as a pair of `import * as a_1 ...; export { a_1 as ns }` and don't need the helper.
							// We only use the helper here when in esModuleInterop
							if (getESModuleInterop(compilerOptions)) {
								checkExternalEmitHelpers(node, ExternalEmitHelpers.ImportStar);
							}
						} else {
							// export * from "foo"
							checkExternalEmitHelpers(node, ExternalEmitHelpers.ExportStar);
						}
					}
				}
			}
			checkAssertClause(node);
		}
		function checkGrammarExportDeclaration(node) {
			var _a;
			if (node.isTypeOnly) {
				if (
					((_a = node.exportClause) === null || _a === void 0 ? void 0 : _a.kind) === SyntaxKind.NamedExports
				) {
					return checkGrammarNamedImportsOrExports(node.exportClause);
				} else {
					return grammarErrorOnNode(
						node,
						Diagnostics.Only_named_exports_may_use_export_type,
					);
				}
			}
			return false;
		}
		function checkGrammarModuleElementContext(node, errorMessage) {
			var isInAppropriateContext = node.parent.kind === SyntaxKind.SourceFile || node.parent.kind === SyntaxKind.ModuleBlock || node.parent.kind === SyntaxKind.ModuleDeclaration;
			if (!isInAppropriateContext) {
				grammarErrorOnFirstToken(node, errorMessage);
			}
			return !isInAppropriateContext;
		}
		function importClauseContainsReferencedImport(importClause) {
			return forEachImportClauseDeclaration(
				importClause,
				function (declaration) {
					return !!getSymbolOfNode(declaration).isReferenced;
				},
			);
		}
		function importClauseContainsConstEnumUsedAsValue(importClause) {
			return forEachImportClauseDeclaration(
				importClause,
				function (declaration) {
					return !!getSymbolLinks(getSymbolOfNode(declaration)).constEnumReferenced;
				},
			);
		}
		function canConvertImportDeclarationToTypeOnly(statement) {
			return isImportDeclaration(statement) && statement.importClause && !statement.importClause.isTypeOnly && importClauseContainsReferencedImport(
				statement.importClause,
			) && !isReferencedAliasDeclaration(
				statement.importClause, /*checkChildren*/
				true,
			) && !importClauseContainsConstEnumUsedAsValue(statement.importClause);
		}
		function canConvertImportEqualsDeclarationToTypeOnly(statement) {
			return isImportEqualsDeclaration(statement) && isExternalModuleReference(
				statement.moduleReference,
			) && !statement.isTypeOnly && getSymbolOfNode(statement).isReferenced && !isReferencedAliasDeclaration(
				statement, /*checkChildren*/
				false,
			) && !getSymbolLinks(getSymbolOfNode(statement)).constEnumReferenced;
		}
		function checkImportsForTypeOnlyConversion(sourceFile) {
			for (var _i = 0, _a = sourceFile.statements; _i < _a.length; _i++) {
				var statement = _a[_i];
				if (
					canConvertImportDeclarationToTypeOnly(statement) || canConvertImportEqualsDeclarationToTypeOnly(
						statement,
					)
				) {
					error(
						statement,
						Diagnostics.This_import_is_never_used_as_a_value_and_must_use_import_type_because_importsNotUsedAsValues_is_set_to_error,
					);
				}
			}
		}
		function checkExportSpecifier(node) {
			checkAliasSymbol(node);
			if (getEmitDeclarations(compilerOptions)) {
				collectLinkedAliases(
					node.propertyName || node.name, /*setVisibility*/
					true,
				);
			}
			if (!node.parent.parent.moduleSpecifier) {
				var exportedName = node.propertyName || node.name;
				// find immediate value referenced by exported name (SymbolFlags.Alias is set so we don't chase down aliases)
				var symbol = resolveName(
					exportedName,
					exportedName.escapedText,
					SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias,
					/*nameNotFoundMessage*/ undefined, /*nameArg*/
					undefined, /*isUse*/
					true,
				);
				if (
					symbol && (symbol === undefinedSymbol || symbol === globalThisSymbol || symbol.declarations && isGlobalSourceFile(
						getDeclarationContainer(symbol.declarations[0]),
					))
				) {
					error(
						exportedName,
						Diagnostics.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module,
						idText(exportedName),
					);
				} else {
					markExportAsReferenced(node);
					var target = symbol && (symbol.flags & SymbolFlags.Alias ? resolveAlias(
						symbol,
					) : symbol);
					if (
						!target || target === unknownSymbol || target.flags & SymbolFlags.Value
					) {
						checkExpressionCached(node.propertyName || node.name);
					}
				}
			} else {
				if (
					getESModuleInterop(compilerOptions) && moduleKind !== ModuleKind.System && (moduleKind < ModuleKind.ES2015 || getSourceFileOfNode(
						node,
					).impliedNodeFormat === ModuleKind.CommonJS) && idText(
						node.propertyName || node.name,
					) === "default"
				) {
					checkExternalEmitHelpers(node, ExternalEmitHelpers.ImportDefault);
				}
			}
		}
		function checkExportAssignment(node) {
			var illegalContextMessage = node.isExportEquals ? Diagnostics.An_export_assignment_must_be_at_the_top_level_of_a_file_or_module_declaration : Diagnostics.A_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration;
			if (checkGrammarModuleElementContext(node, illegalContextMessage)) {
				// If we hit an export assignment in an illegal context, just bail out to avoid cascading errors.
				return;
			}
			var container = node.parent.kind === SyntaxKind.SourceFile ? node.parent : node.parent.parent;
			if (
				container.kind === SyntaxKind.ModuleDeclaration && !isAmbientModule(
					container,
				)
			) {
				if (node.isExportEquals) {
					error(
						node,
						Diagnostics.An_export_assignment_cannot_be_used_in_a_namespace,
					);
				} else {
					error(
						node,
						Diagnostics.A_default_export_can_only_be_used_in_an_ECMAScript_style_module,
					);
				}
				return;
			}
			// Grammar checking
			if (
				!checkGrammarDecoratorsAndModifiers(node) && hasEffectiveModifiers(node)
			) {
				grammarErrorOnFirstToken(
					node,
					Diagnostics.An_export_assignment_cannot_have_modifiers,
				);
			}
			var typeAnnotationNode = getEffectiveTypeAnnotationNode(node);
			if (typeAnnotationNode) {
				checkTypeAssignableTo(
					checkExpressionCached(node.expression),
					getTypeFromTypeNode(typeAnnotationNode),
					node.expression,
				);
			}
			if (node.expression.kind === SyntaxKind.Identifier) {
				var id = node.expression;
				var sym = resolveEntityName(
					id,
					SymbolFlags.All, /*ignoreErrors*/
					true, /*dontResolveAlias*/
					true,
					node,
				);
				if (sym) {
					markAliasReferenced(sym, id);
					// If not a value, we're interpreting the identifier as a type export, along the lines of (`export { Id as default }`)
					var target = sym.flags & SymbolFlags.Alias ? resolveAlias(sym) : sym;
					if (target === unknownSymbol || target.flags & SymbolFlags.Value) {
						// However if it is a value, we need to check it's being used correctly
						checkExpressionCached(node.expression);
					}
				} else {
					checkExpressionCached(node.expression); // doesn't resolve, check as expression to mark as error
				}
				if (getEmitDeclarations(compilerOptions)) {
					collectLinkedAliases(node.expression, /*setVisibility*/ true);
				}
			} else {
				checkExpressionCached(node.expression);
			}
			checkExternalModuleExports(container);
			if (
				(node.flags & NodeFlags.Ambient) && !isEntityNameExpression(
					node.expression,
				)
			) {
				grammarErrorOnNode(
					node.expression,
					Diagnostics.The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context,
				);
			}
			if (node.isExportEquals && !(node.flags & NodeFlags.Ambient)) {
				if (
					moduleKind >= ModuleKind.ES2015 && getSourceFileOfNode(node).impliedNodeFormat !== ModuleKind.CommonJS
				) {
					// export assignment is not supported in es6 modules
					grammarErrorOnNode(
						node,
						Diagnostics.Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or_another_module_format_instead,
					);
				} else if (moduleKind === ModuleKind.System) {
					// system modules does not support export assignment
					grammarErrorOnNode(
						node,
						Diagnostics.Export_assignment_is_not_supported_when_module_flag_is_system,
					);
				}
			}
		}
		function hasExportedMembers(moduleSymbol) {
			return forEachEntry(
				moduleSymbol.exports,
				function (_, id) {
					return id !== "export=";
				},
			);
		}
		function checkExternalModuleExports(node) {
			var moduleSymbol = getSymbolOfNode(node);
			var links = getSymbolLinks(moduleSymbol);
			if (!links.exportsChecked) {
				var exportEqualsSymbol = moduleSymbol.exports.get("export=");
				if (exportEqualsSymbol && hasExportedMembers(moduleSymbol)) {
					var declaration = getDeclarationOfAliasSymbol(exportEqualsSymbol) || exportEqualsSymbol.valueDeclaration;
					if (
						declaration && !isTopLevelInExternalModuleAugmentation(declaration) && !isInJSFile(
							declaration,
						)
					) {
						error(
							declaration,
							Diagnostics.An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements,
						);
					}
				}
				// Checks for export * conflicts
				var exports_2 = getExportsOfModule(moduleSymbol);
				if (exports_2) {
					exports_2.forEach(
						function (_a, id) {
							var declarations = _a.declarations, flags = _a.flags;
							if (id === "__export") {
								return;
							}
							// ECMA262: 15.2.1.1 It is a Syntax Error if the ExportedNames of ModuleItemList contains any duplicate entries.
							// (TS Exceptions: namespaces, function overloads, enums, and interfaces)
							if (
								flags & (SymbolFlags.Namespace | SymbolFlags.Interface | SymbolFlags.Enum)
							) {
								return;
							}
							var exportedDeclarationsCount = countWhere(
								declarations,
								isNotOverloadAndNotAccessor,
							);
							if (
								flags & SymbolFlags.TypeAlias && exportedDeclarationsCount <= 2
							) {
								// it is legal to merge type alias with other values
								// so count should be either 1 (just type alias) or 2 (type alias + merged value)
								return;
							}
							if (exportedDeclarationsCount > 1) {
								if (!isDuplicatedCommonJSExport(declarations)) {
									for (var _i = 0, _b = declarations; _i < _b.length; _i++) {
										var declaration = _b[_i];
										if (isNotOverload(declaration)) {
											diagnostics.add(
												createDiagnosticForNode(
													declaration,
													Diagnostics.Cannot_redeclare_exported_variable_0,
													unescapeLeadingUnderscores(id),
												),
											);
										}
									}
								}
							}
						},
					);
				}
				links.exportsChecked = true;
			}
		}
		function isDuplicatedCommonJSExport(declarations) {
			return declarations && declarations.length > 1 && declarations.every(
				function (d) {
					return isInJSFile(d) && isAccessExpression(d) && (isExportsIdentifier(
						d.expression,
					) || isModuleExportsAccessExpression(d.expression));
				},
			);
		}
		function checkSourceElement(node) {
			if (node) {
				var saveCurrentNode = currentNode;
				currentNode = node;
				instantiationCount = 0;
				checkSourceElementWorker(node);
				currentNode = saveCurrentNode;
			}
		}
		function checkSourceElementWorker(node) {
			if (isInJSFile(node)) {
				forEach(
					node.jsDoc,
					function (_a) {
						var tags = _a.tags;
						return forEach(tags, checkSourceElement);
					},
				);
			}
			var kind = node.kind;
			if (cancellationToken) {
				// Only bother checking on a few construct kinds.  We don't want to be excessively
				// hitting the cancellation token on every node we check.
				switch (kind) {
					case SyntaxKind.ModuleDeclaration:
					case SyntaxKind.ClassDeclaration:
					case SyntaxKind.InterfaceDeclaration:
					case SyntaxKind.FunctionDeclaration:
						cancellationToken.throwIfCancellationRequested();
				}
			}
			if (
				kind >= SyntaxKind.FirstStatement && kind <= SyntaxKind.LastStatement && node.flowNode && !isReachableFlowNode(
					node.flowNode,
				)
			) {
				errorOrSuggestion(
					compilerOptions.allowUnreachableCode === false,
					node,
					Diagnostics.Unreachable_code_detected,
				);
			}
			switch (kind) {
				case SyntaxKind.TypeParameter:
					return checkTypeParameter(node);
				case SyntaxKind.Parameter:
					return checkParameter(node);
				case SyntaxKind.PropertyDeclaration:
					return checkPropertyDeclaration(node);
				case SyntaxKind.PropertySignature:
					return checkPropertySignature(node);
				case SyntaxKind.ConstructorType:
				case SyntaxKind.FunctionType:
				case SyntaxKind.CallSignature:
				case SyntaxKind.ConstructSignature:
				case SyntaxKind.IndexSignature:
					return checkSignatureDeclaration(node);
				case SyntaxKind.MethodDeclaration:
				case SyntaxKind.MethodSignature:
					return checkMethodDeclaration(node);
				case SyntaxKind.ClassStaticBlockDeclaration:
					return checkClassStaticBlockDeclaration(node);
				case SyntaxKind.Constructor:
					return checkConstructorDeclaration(node);
				case SyntaxKind.GetAccessor:
				case SyntaxKind.SetAccessor:
					return checkAccessorDeclaration(node);
				case SyntaxKind.TypeReference:
					return checkTypeReferenceNode(node);
				case SyntaxKind.TypePredicate:
					return checkTypePredicate(node);
				case SyntaxKind.TypeQuery:
					return checkTypeQuery(node);
				case SyntaxKind.TypeLiteral:
					return checkTypeLiteral(node);
				case SyntaxKind.ArrayType:
					return checkArrayType(node);
				case SyntaxKind.TupleType:
					return checkTupleType(node);
				case SyntaxKind.UnionType:
				case SyntaxKind.IntersectionType:
					return checkUnionOrIntersectionType(node);
				case SyntaxKind.ParenthesizedType:
				case SyntaxKind.OptionalType:
				case SyntaxKind.RestType:
					return checkSourceElement(node.type);
				case SyntaxKind.ThisType:
					return checkThisType(node);
				case SyntaxKind.TypeOperator:
					return checkTypeOperator(node);
				case SyntaxKind.ConditionalType:
					return checkConditionalType(node);
				case SyntaxKind.InferType:
					return checkInferType(node);
				case SyntaxKind.TemplateLiteralType:
					return checkTemplateLiteralType(node);
				case SyntaxKind.ImportType:
					return checkImportType(node);
				case SyntaxKind.NamedTupleMember:
					return checkNamedTupleMember(node);
				case SyntaxKind.JSDocAugmentsTag:
					return checkJSDocAugmentsTag(node);
				case SyntaxKind.JSDocImplementsTag:
					return checkJSDocImplementsTag(node);
				case SyntaxKind.JSDocTypedefTag:
				case SyntaxKind.JSDocCallbackTag:
				case SyntaxKind.JSDocEnumTag:
					return checkJSDocTypeAliasTag(node);
				case SyntaxKind.JSDocTemplateTag:
					return checkJSDocTemplateTag(node);
				case SyntaxKind.JSDocTypeTag:
					return checkJSDocTypeTag(node);
				case SyntaxKind.JSDocParameterTag:
					return checkJSDocParameterTag(node);
				case SyntaxKind.JSDocPropertyTag:
					return checkJSDocPropertyTag(node);
				case SyntaxKind.JSDocFunctionType:
					checkJSDocFunctionType(node);
				// falls through
				case SyntaxKind.JSDocNonNullableType:
				case SyntaxKind.JSDocNullableType:
				case SyntaxKind.JSDocAllType:
				case SyntaxKind.JSDocUnknownType:
				case SyntaxKind.JSDocTypeLiteral:
					checkJSDocTypeIsInJsFile(node);
					forEachChild(node, checkSourceElement);
					return;
				case SyntaxKind.JSDocVariadicType:
					checkJSDocVariadicType(node);
					return;
				case SyntaxKind.JSDocTypeExpression:
					return checkSourceElement(node.type);
				case SyntaxKind.JSDocPublicTag:
				case SyntaxKind.JSDocProtectedTag:
				case SyntaxKind.JSDocPrivateTag:
					return checkJSDocAccessibilityModifiers(node);
				case SyntaxKind.IndexedAccessType:
					return checkIndexedAccessType(node);
				case SyntaxKind.MappedType:
					return checkMappedType(node);
				case SyntaxKind.FunctionDeclaration:
					return checkFunctionDeclaration(node);
				case SyntaxKind.Block:
				case SyntaxKind.ModuleBlock:
					return checkBlock(node);
				case SyntaxKind.VariableStatement:
					return checkVariableStatement(node);
				case SyntaxKind.ExpressionStatement:
					return checkExpressionStatement(node);
				case SyntaxKind.IfStatement:
					return checkIfStatement(node);
				case SyntaxKind.DoStatement:
					return checkDoStatement(node);
				case SyntaxKind.WhileStatement:
					return checkWhileStatement(node);
				case SyntaxKind.ForStatement:
					return checkForStatement(node);
				case SyntaxKind.ForInStatement:
					return checkForInStatement(node);
				case SyntaxKind.ForOfStatement:
					return checkForOfStatement(node);
				case SyntaxKind.ContinueStatement:
				case SyntaxKind.BreakStatement:
					return checkBreakOrContinueStatement(node);
				case SyntaxKind.ReturnStatement:
					return checkReturnStatement(node);
				case SyntaxKind.WithStatement:
					return checkWithStatement(node);
				case SyntaxKind.SwitchStatement:
					return checkSwitchStatement(node);
				case SyntaxKind.LabeledStatement:
					return checkLabeledStatement(node);
				case SyntaxKind.ThrowStatement:
					return checkThrowStatement(node);
				case SyntaxKind.TryStatement:
					return checkTryStatement(node);
				case SyntaxKind.VariableDeclaration:
					return checkVariableDeclaration(node);
				case SyntaxKind.BindingElement:
					return checkBindingElement(node);
				case SyntaxKind.ClassDeclaration:
					return checkClassDeclaration(node);
				case SyntaxKind.InterfaceDeclaration:
					return checkInterfaceDeclaration(node);
				case SyntaxKind.TypeAliasDeclaration:
					return checkTypeAliasDeclaration(node);
				case SyntaxKind.EnumDeclaration:
					return checkEnumDeclaration(node);
				case SyntaxKind.ModuleDeclaration:
					return checkModuleDeclaration(node);
				case SyntaxKind.ImportDeclaration:
					return checkImportDeclaration(node);
				case SyntaxKind.ImportEqualsDeclaration:
					return checkImportEqualsDeclaration(node);
				case SyntaxKind.ExportDeclaration:
					return checkExportDeclaration(node);
				case SyntaxKind.ExportAssignment:
					return checkExportAssignment(node);
				case SyntaxKind.EmptyStatement:
				case SyntaxKind.DebuggerStatement:
					checkGrammarStatementInAmbientContext(node);
					return;
				case SyntaxKind.MissingDeclaration:
					return checkMissingDeclaration(node);
			}
		}
		function checkJSDocTypeIsInJsFile(node) {
			if (!isInJSFile(node)) {
				grammarErrorOnNode(
					node,
					Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments,
				);
			}
		}
		function checkJSDocVariadicType(node) {
			checkJSDocTypeIsInJsFile(node);
			checkSourceElement(node.type);
			// Only legal location is in the *last* parameter tag or last parameter of a JSDoc function.
			var parent = node.parent;
			if (isParameter(parent) && isJSDocFunctionType(parent.parent)) {
				if (last(parent.parent.parameters) !== parent) {
					error(
						node,
						Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list,
					);
				}
				return;
			}
			if (!isJSDocTypeExpression(parent)) {
				error(
					node,
					Diagnostics.JSDoc_may_only_appear_in_the_last_parameter_of_a_signature,
				);
			}
			var paramTag = node.parent.parent;
			if (!isJSDocParameterTag(paramTag)) {
				error(
					node,
					Diagnostics.JSDoc_may_only_appear_in_the_last_parameter_of_a_signature,
				);
				return;
			}
			var param = getParameterSymbolFromJSDoc(paramTag);
			if (!param) {
				// We will error in `checkJSDocParameterTag`.
				return;
			}
			var host = getHostSignatureFromJSDoc(paramTag);
			if (!host || last(host.parameters).symbol !== param) {
				error(
					node,
					Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list,
				);
			}
		}
		function getTypeFromJSDocVariadicType(node) {
			var type = getTypeFromTypeNode(node.type);
			var parent = node.parent;
			var paramTag = node.parent.parent;
			if (isJSDocTypeExpression(node.parent) && isJSDocParameterTag(paramTag)) {
				// Else we will add a diagnostic, see `checkJSDocVariadicType`.
				var host_1 = getHostSignatureFromJSDoc(paramTag);
				var isCallbackTag = isJSDocCallbackTag(paramTag.parent.parent);
				if (host_1 || isCallbackTag) {
					/*
                    Only return an array type if the corresponding parameter is marked as a rest parameter, or if there are no parameters.
                    So in the following situation we will not create an array type:
                        /** @param {...number} a * /
                        function f(a) {}
                    Because `a` will just be of type `number | undefined`. A synthetic `...args` will also be added, which *will* get an array type.
                    */
					var lastParamDeclaration = isCallbackTag ? lastOrUndefined(
						paramTag.parent.parent.typeExpression.parameters,
					) : lastOrUndefined(host_1.parameters);
					var symbol = getParameterSymbolFromJSDoc(paramTag);
					if (
						!lastParamDeclaration || symbol && lastParamDeclaration.symbol === symbol && isRestParameter(
							lastParamDeclaration,
						)
					) {
						return createArrayType(type);
					}
				}
			}
			if (isParameter(parent) && isJSDocFunctionType(parent.parent)) {
				return createArrayType(type);
			}
			return addOptionality(type);
		}
		// Function and class expression bodies are checked after all statements in the enclosing body. This is
		// to ensure constructs like the following are permitted:
		//     const foo = function () {
		//        const s = foo();
		//        return "hello";
		//     }
		// Here, performing a full type check of the body of the function expression whilst in the process of
		// determining the type of foo would cause foo to be given type any because of the recursive reference.
		// Delaying the type check of the body ensures foo has been assigned a type.
		function checkNodeDeferred(node) {
			var enclosingFile = getSourceFileOfNode(node);
			var links = getNodeLinks(enclosingFile);
			if (!(links.flags & NodeCheckFlags.TypeChecked)) {
				links.deferredNodes || (links.deferredNodes = new Set());
				links.deferredNodes.add(node);
			}
		}
		function checkDeferredNodes(context) {
			var links = getNodeLinks(context);
			if (links.deferredNodes) {
				links.deferredNodes.forEach(checkDeferredNode);
			}
		}
		function checkDeferredNode(node) {
			tracing === null || tracing === void 0 ? void 0 : tracing.push(
				tracing.Phase.Check,
				"checkDeferredNode",
				{ kind: node.kind, pos: node.pos, end: node.end },
			);
			var saveCurrentNode = currentNode;
			currentNode = node;
			instantiationCount = 0;
			switch (node.kind) {
				case SyntaxKind.CallExpression:
				case SyntaxKind.NewExpression:
				case SyntaxKind.TaggedTemplateExpression:
				case SyntaxKind.Decorator:
				case SyntaxKind.JsxOpeningElement:
					// These node kinds are deferred checked when overload resolution fails
					// To save on work, we ensure the arguments are checked just once, in
					// a deferred way
					resolveUntypedCall(node);
					break;
				case SyntaxKind.FunctionExpression:
				case SyntaxKind.ArrowFunction:
				case SyntaxKind.MethodDeclaration:
				case SyntaxKind.MethodSignature:
					checkFunctionExpressionOrObjectLiteralMethodDeferred(node);
					break;
				case SyntaxKind.GetAccessor:
				case SyntaxKind.SetAccessor:
					checkAccessorDeclaration(node);
					break;
				case SyntaxKind.ClassExpression:
					checkClassExpressionDeferred(node);
					break;
				case SyntaxKind.JsxSelfClosingElement:
					checkJsxSelfClosingElementDeferred(node);
					break;
				case SyntaxKind.JsxElement:
					checkJsxElementDeferred(node);
					break;
			}
			currentNode = saveCurrentNode;
			tracing === null || tracing === void 0 ? void 0 : tracing.pop();
		}
		function checkSourceFile(node) {
			tracing === null || tracing === void 0 ? void 0 : tracing.push(
				tracing.Phase.Check,
				"checkSourceFile",
				{ path: node.path }, /*separateBeginAndEnd*/
				true,
			);
			performance.mark("beforeCheck");
			checkSourceFileWorker(node);
			performance.mark("afterCheck");
			performance.measure("Check", "beforeCheck", "afterCheck");
			tracing === null || tracing === void 0 ? void 0 : tracing.pop();
		}
		function unusedIsError(kind, isAmbient) {
			if (isAmbient) {
				return false;
			}
			switch (kind) {
				case 0: /* Local */
					return !!compilerOptions.noUnusedLocals;
				case 1: /* Parameter */
					return !!compilerOptions.noUnusedParameters;
				default:
					return Debug.assertNever(kind);
			}
		}
		function getPotentiallyUnusedIdentifiers(sourceFile) {
			return allPotentiallyUnusedIdentifiers.get(sourceFile.path) || emptyArray;
		}
		// Fully type check a source file and collect the relevant diagnostics.
		function checkSourceFileWorker(node) {
			var links = getNodeLinks(node);
			if (!(links.flags & NodeCheckFlags.TypeChecked)) {
				if (skipTypeChecking(node, compilerOptions, host)) {
					return;
				}
				// Grammar checking
				checkGrammarSourceFile(node);
				clear(potentialThisCollisions);
				clear(potentialNewTargetCollisions);
				clear(potentialWeakMapSetCollisions);
				clear(potentialReflectCollisions);
				forEach(node.statements, checkSourceElement);
				checkSourceElement(node.endOfFileToken);
				checkDeferredNodes(node);
				if (isExternalOrCommonJsModule(node)) {
					registerForUnusedIdentifiersCheck(node);
				}
				if (
					!node.isDeclarationFile && (compilerOptions.noUnusedLocals || compilerOptions.noUnusedParameters)
				) {
					checkUnusedIdentifiers(
						getPotentiallyUnusedIdentifiers(node),
						function (containingNode, kind, diag) {
							if (
								!containsParseError(containingNode) && unusedIsError(
									kind,
									!!(containingNode.flags & NodeFlags.Ambient),
								)
							) {
								diagnostics.add(diag);
							}
						},
					);
				}
				if (
					compilerOptions.importsNotUsedAsValues === ImportsNotUsedAsValues.Error && !node.isDeclarationFile && isExternalModule(
						node,
					)
				) {
					checkImportsForTypeOnlyConversion(node);
				}
				if (isExternalOrCommonJsModule(node)) {
					checkExternalModuleExports(node);
				}
				if (potentialThisCollisions.length) {
					forEach(
						potentialThisCollisions,
						checkIfThisIsCapturedInEnclosingScope,
					);
					clear(potentialThisCollisions);
				}
				if (potentialNewTargetCollisions.length) {
					forEach(
						potentialNewTargetCollisions,
						checkIfNewTargetIsCapturedInEnclosingScope,
					);
					clear(potentialNewTargetCollisions);
				}
				if (potentialWeakMapSetCollisions.length) {
					forEach(potentialWeakMapSetCollisions, checkWeakMapSetCollision);
					clear(potentialWeakMapSetCollisions);
				}
				if (potentialReflectCollisions.length) {
					forEach(potentialReflectCollisions, checkReflectCollision);
					clear(potentialReflectCollisions);
				}
				links.flags |= NodeCheckFlags.TypeChecked;
			}
		}
		function getDiagnostics(sourceFile, ct) {
			try {
				// Record the cancellation token so it can be checked later on during checkSourceElement.
				// Do this in a finally block so we can ensure that it gets reset back to nothing after
				// this call is done.
				cancellationToken = ct;
				return getDiagnosticsWorker(sourceFile);
			} finally {
				cancellationToken = undefined;
			}
		}
		function getDiagnosticsWorker(sourceFile) {
			throwIfNonDiagnosticsProducing();
			if (sourceFile) {
				// Some global diagnostics are deferred until they are needed and
				// may not be reported in the first call to getGlobalDiagnostics.
				// We should catch these changes and report them.
				var previousGlobalDiagnostics = diagnostics.getGlobalDiagnostics();
				var previousGlobalDiagnosticsSize = previousGlobalDiagnostics.length;
				checkSourceFile(sourceFile);
				var semanticDiagnostics = diagnostics.getDiagnostics(
					sourceFile.fileName,
				);
				var currentGlobalDiagnostics = diagnostics.getGlobalDiagnostics();
				if (currentGlobalDiagnostics !== previousGlobalDiagnostics) {
					// If the arrays are not the same reference, new diagnostics were added.
					var deferredGlobalDiagnostics = relativeComplement(
						previousGlobalDiagnostics,
						currentGlobalDiagnostics,
						compareDiagnostics,
					);
					return concatenate(deferredGlobalDiagnostics, semanticDiagnostics);
				} else if (
					previousGlobalDiagnosticsSize === 0 && currentGlobalDiagnostics.length > 0
				) {
					// If the arrays are the same reference, but the length has changed, a single
					// new diagnostic was added as DiagnosticCollection attempts to reuse the
					// same array.
					return concatenate(currentGlobalDiagnostics, semanticDiagnostics);
				}
				return semanticDiagnostics;
			}
			// Global diagnostics are always added when a file is not provided to
			// getDiagnostics
			forEach(host.getSourceFiles(), checkSourceFile);
			return diagnostics.getDiagnostics();
		}
		function getGlobalDiagnostics() {
			throwIfNonDiagnosticsProducing();
			return diagnostics.getGlobalDiagnostics();
		}
		function throwIfNonDiagnosticsProducing() {
			if (!produceDiagnostics) {
				throw new Error(
					"Trying to get diagnostics from a type checker that does not produce them.",
				);
			}
		}
		// Language service support
		function getSymbolsInScope(location, meaning) {
			if (location.flags & NodeFlags.InWithStatement) {
				// We cannot answer semantic questions within a with block, do not proceed any further
				return [];
			}
			var symbols = createSymbolTable();
			var isStaticSymbol = false;
			populateSymbols();
			symbols["delete"](InternalSymbolName.This); // Not a symbol, a keyword
			return symbolsToArray(symbols);
			function populateSymbols() {
				while (location) {
					if (location.locals && !isGlobalSourceFile(location)) {
						copySymbols(location.locals, meaning);
					}
					switch (location.kind) {
						case SyntaxKind.SourceFile:
							if (!isExternalModule(location)) break;
						// falls through
						case SyntaxKind.ModuleDeclaration:
							copyLocallyVisibleExportSymbols(
								getSymbolOfNode(location).exports,
								meaning & SymbolFlags.ModuleMember,
							);
							break;
						case SyntaxKind.EnumDeclaration:
							copySymbols(
								getSymbolOfNode(location).exports,
								meaning & SymbolFlags.EnumMember,
							);
							break;
						case SyntaxKind.ClassExpression:
							var className = location.name;
							if (className) {
								copySymbol(location.symbol, meaning);
							}
						// this fall-through is necessary because we would like to handle
						// type parameter inside class expression similar to how we handle it in classDeclaration and interface Declaration.
						// falls through
						case SyntaxKind.ClassDeclaration:
						case SyntaxKind.InterfaceDeclaration:
							// If we didn't come from static member of class or interface,
							// add the type parameters into the symbol table
							// (type parameters of classDeclaration/classExpression and interface are in member property of the symbol.
							// Note: that the memberFlags come from previous iteration.
							if (!isStaticSymbol) {
								copySymbols(
									getMembersOfSymbol(getSymbolOfNode(location)),
									meaning & SymbolFlags.Type,
								);
							}
							break;
						case SyntaxKind.FunctionExpression:
							var funcName = location.name;
							if (funcName) {
								copySymbol(location.symbol, meaning);
							}
							break;
					}
					if (introducesArgumentsExoticObject(location)) {
						copySymbol(argumentsSymbol, meaning);
					}
					isStaticSymbol = isStatic(location);
					location = location.parent;
				}
				copySymbols(globals, meaning);
			}
			/**
             * Copy the given symbol into symbol tables if the symbol has the given meaning
             * and it doesn't already existed in the symbol table
             * @param key a key for storing in symbol table; if undefined, use symbol.name
             * @param symbol the symbol to be added into symbol table
             * @param meaning meaning of symbol to filter by before adding to symbol table
             */
			function copySymbol(symbol, meaning) {
				if (getCombinedLocalAndExportSymbolFlags(symbol) & meaning) {
					var id = symbol.escapedName;
					// We will copy all symbol regardless of its reserved name because
					// symbolsToArray will check whether the key is a reserved name and
					// it will not copy symbol with reserved name to the array
					if (!symbols.has(id)) {
						symbols.set(id, symbol);
					}
				}
			}
			function copySymbols(source, meaning) {
				if (meaning) {
					source.forEach(
						function (symbol) {
							copySymbol(symbol, meaning);
						},
					);
				}
			}
			function copyLocallyVisibleExportSymbols(source, meaning) {
				if (meaning) {
					source.forEach(
						function (symbol) {
							// Similar condition as in `resolveNameHelper`
							if (
								!getDeclarationOfKind(symbol, SyntaxKind.ExportSpecifier) && !getDeclarationOfKind(
									symbol,
									SyntaxKind.NamespaceExport,
								)
							) {
								copySymbol(symbol, meaning);
							}
						},
					);
				}
			}
		}
		function isTypeDeclarationName(name) {
			return name.kind === SyntaxKind.Identifier && isTypeDeclaration(
				name.parent,
			) && getNameOfDeclaration(name.parent) === name;
		}
		function isTypeDeclaration(node) {
			switch (node.kind) {
				case SyntaxKind.TypeParameter:
				case SyntaxKind.ClassDeclaration:
				case SyntaxKind.InterfaceDeclaration:
				case SyntaxKind.TypeAliasDeclaration:
				case SyntaxKind.EnumDeclaration:
				case SyntaxKind.JSDocTypedefTag:
				case SyntaxKind.JSDocCallbackTag:
				case SyntaxKind.JSDocEnumTag:
					return true;
				case SyntaxKind.ImportClause:
					return node.isTypeOnly;
				case SyntaxKind.ImportSpecifier:
				case SyntaxKind.ExportSpecifier:
					return node.parent.parent.isTypeOnly;
				default:
					return false;
			}
		}
		// True if the given identifier is part of a type reference
		function isTypeReferenceIdentifier(node) {
			while (node.parent.kind === SyntaxKind.QualifiedName) {
				node = node.parent;
			}
			return node.parent.kind === SyntaxKind.TypeReference;
		}
		function isHeritageClauseElementIdentifier(node) {
			while (node.parent.kind === SyntaxKind.PropertyAccessExpression) {
				node = node.parent;
			}
			return node.parent.kind === SyntaxKind.ExpressionWithTypeArguments;
		}
		function forEachEnclosingClass(node, callback) {
			var result;
			while (true) {
				node = getContainingClass(node);
				if (!node) break;
				if (result = callback(node)) break;
			}
			return result;
		}
		function isNodeUsedDuringClassInitialization(node) {
			return !!findAncestor(
				node,
				function (element) {
					if (
						isConstructorDeclaration(element) && nodeIsPresent(element.body) || isPropertyDeclaration(
							element,
						)
					) {
						return true;
					} else if (isClassLike(element) || isFunctionLikeDeclaration(element)) {
						return "quit";
					}
					return false;
				},
			);
		}
		function isNodeWithinClass(node, classDeclaration) {
			return !!forEachEnclosingClass(
				node,
				function (n) {
					return n === classDeclaration;
				},
			);
		}
		function getLeftSideOfImportEqualsOrExportAssignment(nodeOnRightSide) {
			while (nodeOnRightSide.parent.kind === SyntaxKind.QualifiedName) {
				nodeOnRightSide = nodeOnRightSide.parent;
			}
			if (nodeOnRightSide.parent.kind === SyntaxKind.ImportEqualsDeclaration) {
				return nodeOnRightSide.parent.moduleReference === nodeOnRightSide ? nodeOnRightSide.parent : undefined;
			}
			if (nodeOnRightSide.parent.kind === SyntaxKind.ExportAssignment) {
				return nodeOnRightSide.parent.expression === nodeOnRightSide ? nodeOnRightSide.parent : undefined;
			}
			return undefined;
		}
		function isInRightSideOfImportOrExportAssignment(node) {
			return getLeftSideOfImportEqualsOrExportAssignment(node) !== undefined;
		}
		function getSpecialPropertyAssignmentSymbolFromEntityName(entityName) {
			var specialPropertyAssignmentKind = getAssignmentDeclarationKind(
				entityName.parent.parent,
			);
			switch (specialPropertyAssignmentKind) {
				case AssignmentDeclarationKind.ExportsProperty:
				case AssignmentDeclarationKind.PrototypeProperty:
					return getSymbolOfNode(entityName.parent);
				case AssignmentDeclarationKind.ThisProperty:
				case AssignmentDeclarationKind.ModuleExports:
				case AssignmentDeclarationKind.Property:
					return getSymbolOfNode(entityName.parent.parent);
			}
		}
		function isImportTypeQualifierPart(node) {
			var parent = node.parent;
			while (isQualifiedName(parent)) {
				node = parent;
				parent = parent.parent;
			}
			if (
				parent && parent.kind === SyntaxKind.ImportType && parent.qualifier === node
			) {
				return parent;
			}
			return undefined;
		}
		function getSymbolOfNameOrPropertyAccessExpression(name) {
			if (isDeclarationName(name)) {
				return getSymbolOfNode(name.parent);
			}
			if (
				isInJSFile(name) && name.parent.kind === SyntaxKind.PropertyAccessExpression && name.parent === name.parent.parent.left
			) {
				// Check if this is a special property assignment
				if (!isPrivateIdentifier(name) && !isJSDocMemberName(name)) {
					var specialPropertyAssignmentSymbol = getSpecialPropertyAssignmentSymbolFromEntityName(
						name,
					);
					if (specialPropertyAssignmentSymbol) {
						return specialPropertyAssignmentSymbol;
					}
				}
			}
			if (
				name.parent.kind === SyntaxKind.ExportAssignment && isEntityNameExpression(
					name,
				)
			) {
				// Even an entity name expression that doesn't resolve as an entityname may still typecheck as a property access expression
				var success = resolveEntityName(
					name,
					/*all meanings*/ SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias, /*ignoreErrors*/
					true,
				);
				if (success && success !== unknownSymbol) {
					return success;
				}
			} else if (
				isEntityName(name) && isInRightSideOfImportOrExportAssignment(name)
			) {
				// Since we already checked for ExportAssignment, this really could only be an Import
				var importEqualsDeclaration = getAncestor(
					name,
					SyntaxKind.ImportEqualsDeclaration,
				);
				Debug.assert(importEqualsDeclaration !== undefined);
				return getSymbolOfPartOfRightHandSideOfImportEquals(
					name, /*dontResolveAlias*/
					true,
				);
			}
			if (isEntityName(name)) {
				var possibleImportNode = isImportTypeQualifierPart(name);
				if (possibleImportNode) {
					getTypeFromTypeNode(possibleImportNode);
					var sym = getNodeLinks(name).resolvedSymbol;
					return sym === unknownSymbol ? undefined : sym;
				}
			}
			while (isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName(name)) {
				name = name.parent;
			}
			if (isHeritageClauseElementIdentifier(name)) {
				var meaning = SymbolFlags.None;
				// In an interface or class, we're definitely interested in a type.
				if (name.parent.kind === SyntaxKind.ExpressionWithTypeArguments) {
					meaning = SymbolFlags.Type;
					// In a class 'extends' clause we are also looking for a value.
					if (isExpressionWithTypeArgumentsInClassExtendsClause(name.parent)) {
						meaning |= SymbolFlags.Value;
					}
				} else {
					meaning = SymbolFlags.Namespace;
				}
				meaning |= SymbolFlags.Alias;
				var entityNameSymbol = isEntityNameExpression(name) ? resolveEntityName(
					name,
					meaning,
				) : undefined;
				if (entityNameSymbol) {
					return entityNameSymbol;
				}
			}
			if (name.parent.kind === SyntaxKind.JSDocParameterTag) {
				return getParameterSymbolFromJSDoc(name.parent);
			}
			if (
				name.parent.kind === SyntaxKind.TypeParameter && name.parent.parent.kind === SyntaxKind.JSDocTemplateTag
			) {
				Debug.assert(!isInJSFile(name)); // Otherwise `isDeclarationName` would have been true.
				var typeParameter = getTypeParameterFromJsDoc(name.parent);
				return typeParameter && typeParameter.symbol;
			}
			if (isExpressionNode(name)) {
				if (nodeIsMissing(name)) {
					// Missing entity name.
					return undefined;
				}
				var isJSDoc = findAncestor(
					name,
					or(isJSDocLinkLike, isJSDocNameReference, isJSDocMemberName),
				);
				var meaning = isJSDoc ? SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Value : SymbolFlags.Value;
				if (name.kind === SyntaxKind.Identifier) {
					if (isJSXTagName(name) && isJsxIntrinsicIdentifier(name)) {
						var symbol = getIntrinsicTagSymbol(name.parent);
						return symbol === unknownSymbol ? undefined : symbol;
					}
					var result = resolveEntityName(
						name,
						meaning, /*ignoreErrors*/
						false, /*dontResolveAlias*/
						!isJSDoc,
						getHostSignatureFromJSDoc(name),
					);
					if (!result && isJSDoc) {
						var container = findAncestor(
							name,
							or(isClassLike, isInterfaceDeclaration),
						);
						if (container) {
							return resolveJSDocMemberName(name, getSymbolOfNode(container));
						}
					}
					return result;
				} else if (isPrivateIdentifier(name)) {
					return getSymbolForPrivateIdentifierExpression(name);
				} else if (
					name.kind === SyntaxKind.PropertyAccessExpression || name.kind === SyntaxKind.QualifiedName
				) {
					var links = getNodeLinks(name);
					if (links.resolvedSymbol) {
						return links.resolvedSymbol;
					}
					if (name.kind === SyntaxKind.PropertyAccessExpression) {
						checkPropertyAccessExpression(name, 0 /* Normal */ );
					} else {
						checkQualifiedName(name, 0 /* Normal */ );
					}
					if (!links.resolvedSymbol && isJSDoc && isQualifiedName(name)) {
						return resolveJSDocMemberName(name);
					}
					return links.resolvedSymbol;
				} else if (isJSDocMemberName(name)) {
					return resolveJSDocMemberName(name);
				}
			} else if (isTypeReferenceIdentifier(name)) {
				var meaning = name.parent.kind === SyntaxKind.TypeReference ? SymbolFlags.Type : SymbolFlags.Namespace;
				var symbol = resolveEntityName(
					name,
					meaning, /*ignoreErrors*/
					false, /*dontResolveAlias*/
					true,
				);
				return symbol && symbol !== unknownSymbol ? symbol : getUnresolvedSymbolForEntityName(
					name,
				);
			}
			if (name.parent.kind === SyntaxKind.TypePredicate) {
				return resolveEntityName(
					name, /*meaning*/
					SymbolFlags.FunctionScopedVariable,
				);
			}
			return undefined;
		}
		/**
         * Recursively resolve entity names and jsdoc instance references:
         * 1. K#m as K.prototype.m for a class (or other value) K
         * 2. K.m as K.prototype.m
         * 3. I.m as I.m for a type I, or any other I.m that fails to resolve in (1) or (2)
         *
         * For unqualified names, a container K may be provided as a second argument.
         */
		function resolveJSDocMemberName(name, container) {
			if (isEntityName(name)) {
				// resolve static values first
				var meaning = SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Value;
				var symbol = resolveEntityName(
					name,
					meaning, /*ignoreErrors*/
					false, /*dontResolveAlias*/
					true,
					getHostSignatureFromJSDoc(name),
				);
				if (!symbol && isIdentifier(name) && container) {
					symbol = getMergedSymbol(
						getSymbol(getExportsOfSymbol(container), name.escapedText, meaning),
					);
				}
				if (symbol) {
					return symbol;
				}
			}
			var left = isIdentifier(name) ? container : resolveJSDocMemberName(
				name.left,
			);
			var right = isIdentifier(name) ? name.escapedText : name.right.escapedText;
			if (left) {
				var proto = left.flags & SymbolFlags.Value && getPropertyOfType(
					getTypeOfSymbol(left),
					"prototype",
				);
				var t = proto ? getTypeOfSymbol(proto) : getDeclaredTypeOfSymbol(left);
				return getPropertyOfType(t, right);
			}
		}
		function getSymbolAtLocation(node, ignoreErrors) {
			if (node.kind === SyntaxKind.SourceFile) {
				return isExternalModule(node) ? getMergedSymbol(node.symbol) : undefined;
			}
			var parent = node.parent;
			var grandParent = parent.parent;
			if (node.flags & NodeFlags.InWithStatement) {
				// We cannot answer semantic questions within a with block, do not proceed any further
				return undefined;
			}
			if (isDeclarationNameOrImportPropertyName(node)) {
				// This is a declaration, call getSymbolOfNode
				var parentSymbol = getSymbolOfNode(parent);
				return isImportOrExportSpecifier(node.parent) && node.parent.propertyName === node ? getImmediateAliasedSymbol(
					parentSymbol,
				) : parentSymbol;
			} else if (isLiteralComputedPropertyDeclarationName(node)) {
				return getSymbolOfNode(parent.parent);
			}
			if (node.kind === SyntaxKind.Identifier) {
				if (isInRightSideOfImportOrExportAssignment(node)) {
					return getSymbolOfNameOrPropertyAccessExpression(node);
				} else if (
					parent.kind === SyntaxKind.BindingElement && grandParent.kind === SyntaxKind.ObjectBindingPattern && node === parent.propertyName
				) {
					var typeOfPattern = getTypeOfNode(grandParent);
					var propertyDeclaration = getPropertyOfType(
						typeOfPattern,
						node.escapedText,
					);
					if (propertyDeclaration) {
						return propertyDeclaration;
					}
				} else if (isMetaProperty(parent)) {
					var parentType = getTypeOfNode(parent);
					var propertyDeclaration = getPropertyOfType(
						parentType,
						node.escapedText,
					);
					if (propertyDeclaration) {
						return propertyDeclaration;
					}
					if (parent.keywordToken === SyntaxKind.NewKeyword) {
						return checkNewTargetMetaProperty(parent).symbol;
					}
				}
			}
			switch (node.kind) {
				case SyntaxKind.Identifier:
				case SyntaxKind.PrivateIdentifier:
				case SyntaxKind.PropertyAccessExpression:
				case SyntaxKind.QualifiedName:
					return getSymbolOfNameOrPropertyAccessExpression(node);
				case SyntaxKind.ThisKeyword:
					var container = getThisContainer(
						node, /*includeArrowFunctions*/
						false,
					);
					if (isFunctionLike(container)) {
						var sig = getSignatureFromDeclaration(container);
						if (sig.thisParameter) {
							return sig.thisParameter;
						}
					}
					if (isInExpressionContext(node)) {
						return checkExpression(node).symbol;
					}
				// falls through
				case SyntaxKind.ThisType:
					return getTypeFromThisTypeNode(node).symbol;
				case SyntaxKind.SuperKeyword:
					return checkExpression(node).symbol;
				case SyntaxKind.ConstructorKeyword:
					// constructor keyword for an overload, should take us to the definition if it exist
					var constructorDeclaration = node.parent;
					if (
						constructorDeclaration && constructorDeclaration.kind === SyntaxKind.Constructor
					) {
						return constructorDeclaration.parent.symbol;
					}
					return undefined;
				case SyntaxKind.StringLiteral:
				case SyntaxKind.NoSubstitutionTemplateLiteral:
					// 1). import x = require("./mo/*gotToDefinitionHere*/d")
					// 2). External module name in an import declaration
					// 3). Dynamic import call or require in javascript
					// 4). type A = import("./f/*gotToDefinitionHere*/oo")
					if (
						(isExternalModuleImportEqualsDeclaration(node.parent.parent) && getExternalModuleImportEqualsDeclarationExpression(
							node.parent.parent,
						) === node) || ((node.parent.kind === SyntaxKind.ImportDeclaration || node.parent.kind === SyntaxKind.ExportDeclaration) && node.parent.moduleSpecifier === node) || ((isInJSFile(
							node,
						) && isRequireCall(
							node.parent, /*checkArgumentIsStringLiteralLike*/
							false,
						)) || isImportCall(node.parent)) || (isLiteralTypeNode(node.parent) && isLiteralImportTypeNode(
							node.parent.parent,
						) && node.parent.parent.argument === node.parent)
					) {
						return resolveExternalModuleName(node, node, ignoreErrors);
					}
					if (
						isCallExpression(parent) && isBindableObjectDefinePropertyCall(
							parent,
						) && parent.arguments[1] === node
					) {
						return getSymbolOfNode(parent);
					}
				// falls through
				case SyntaxKind.NumericLiteral:
					// index access
					var objectType = isElementAccessExpression(parent) ? parent.argumentExpression === node ? getTypeOfExpression(
						parent.expression,
					) : undefined : isLiteralTypeNode(parent) && isIndexedAccessTypeNode(
						grandParent,
					) ? getTypeFromTypeNode(grandParent.objectType) : undefined;
					return objectType && getPropertyOfType(
						objectType,
						escapeLeadingUnderscores(node.text),
					);
				case SyntaxKind.DefaultKeyword:
				case SyntaxKind.FunctionKeyword:
				case SyntaxKind.EqualsGreaterThanToken:
				case SyntaxKind.ClassKeyword:
					return getSymbolOfNode(node.parent);
				case SyntaxKind.ImportType:
					return isLiteralImportTypeNode(node) ? getSymbolAtLocation(
						node.argument.literal,
						ignoreErrors,
					) : undefined;
				case SyntaxKind.ExportKeyword:
					return isExportAssignment(node.parent) ? Debug.checkDefined(
						node.parent.symbol,
					) : undefined;
				case SyntaxKind.ImportKeyword:
				case SyntaxKind.NewKeyword:
					return isMetaProperty(node.parent) ? checkMetaPropertyKeyword(
						node.parent,
					).symbol : undefined;
				case SyntaxKind.MetaProperty:
					return checkExpression(node).symbol;
				default:
					return undefined;
			}
		}
		function getIndexInfosAtLocation(node) {
			if (
				isIdentifier(node) && isPropertyAccessExpression(node.parent) && node.parent.name === node
			) {
				var keyType_1 = getLiteralTypeFromPropertyName(node);
				var objectType = getTypeOfExpression(node.parent.expression);
				var objectTypes = objectType.flags & TypeFlags.Union ? objectType.types : [
					objectType,
				];
				return flatMap(
					objectTypes,
					function (t) {
						return filter(
							getIndexInfosOfType(t),
							function (info) {
								return isApplicableIndexType(keyType_1, info.keyType);
							},
						);
					},
				);
			}
			return undefined;
		}
		function getShorthandAssignmentValueSymbol(location) {
			if (location && location.kind === SyntaxKind.ShorthandPropertyAssignment) {
				return resolveEntityName(
					location.name,
					SymbolFlags.Value | SymbolFlags.Alias,
				);
			}
			return undefined;
		}
		/** Returns the target of an export specifier without following aliases */
		function getExportSpecifierLocalTargetSymbol(node) {
			if (isExportSpecifier(node)) {
				return node.parent.parent.moduleSpecifier ? getExternalModuleMember(
					node.parent.parent,
					node,
				) : resolveEntityName(
					node.propertyName || node.name,
					SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias,
				);
			} else {
				return resolveEntityName(
					node,
					SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias,
				);
			}
		}
		function getTypeOfNode(node) {
			if (isSourceFile(node) && !isExternalModule(node)) {
				return errorType;
			}
			if (node.flags & NodeFlags.InWithStatement) {
				// We cannot answer semantic questions within a with block, do not proceed any further
				return errorType;
			}
			var classDecl = tryGetClassImplementingOrExtendingExpressionWithTypeArguments(
				node,
			);
			var classType = classDecl && getDeclaredTypeOfClassOrInterface(
				getSymbolOfNode(classDecl["class"]),
			);
			if (isPartOfTypeNode(node)) {
				var typeFromTypeNode = getTypeFromTypeNode(node);
				return classType ? getTypeWithThisArgument(
					typeFromTypeNode,
					classType.thisType,
				) : typeFromTypeNode;
			}
			if (isExpressionNode(node)) {
				return getRegularTypeOfExpression(node);
			}
			if (classType && !classDecl.isImplements) {
				// A SyntaxKind.ExpressionWithTypeArguments is considered a type node, except when it occurs in the
				// extends clause of a class. We handle that case here.
				var baseType = firstOrUndefined(getBaseTypes(classType));
				return baseType ? getTypeWithThisArgument(baseType, classType.thisType) : errorType;
			}
			if (isTypeDeclaration(node)) {
				// In this case, we call getSymbolOfNode instead of getSymbolAtLocation because it is a declaration
				var symbol = getSymbolOfNode(node);
				return getDeclaredTypeOfSymbol(symbol);
			}
			if (isTypeDeclarationName(node)) {
				var symbol = getSymbolAtLocation(node);
				return symbol ? getDeclaredTypeOfSymbol(symbol) : errorType;
			}
			if (isDeclaration(node)) {
				// In this case, we call getSymbolOfNode instead of getSymbolAtLocation because it is a declaration
				var symbol = getSymbolOfNode(node);
				return getTypeOfSymbol(symbol);
			}
			if (isDeclarationNameOrImportPropertyName(node)) {
				var symbol = getSymbolAtLocation(node);
				if (symbol) {
					return getTypeOfSymbol(symbol);
				}
				return errorType;
			}
			if (isBindingPattern(node)) {
				return getTypeForVariableLikeDeclaration(
					node.parent, /*includeOptionality*/
					true,
				) || errorType;
			}
			if (isInRightSideOfImportOrExportAssignment(node)) {
				var symbol = getSymbolAtLocation(node);
				if (symbol) {
					var declaredType = getDeclaredTypeOfSymbol(symbol);
					return !isErrorType(declaredType) ? declaredType : getTypeOfSymbol(
						symbol,
					);
				}
			}
			if (isMetaProperty(node.parent) && node.parent.keywordToken === node.kind) {
				return checkMetaPropertyKeyword(node.parent);
			}
			return errorType;
		}
		// Gets the type of object literal or array literal of destructuring assignment.
		// { a } from
		//     for ( { a } of elems) {
		//     }
		// [ a ] from
		//     [a] = [ some array ...]
		function getTypeOfAssignmentPattern(expr) {
			Debug.assert(
				expr.kind === SyntaxKind.ObjectLiteralExpression || expr.kind === SyntaxKind.ArrayLiteralExpression,
			);
			// If this is from "for of"
			//     for ( { a } of elems) {
			//     }
			if (expr.parent.kind === SyntaxKind.ForOfStatement) {
				var iteratedType = checkRightHandSideOfForOf(expr.parent);
				return checkDestructuringAssignment(expr, iteratedType || errorType);
			}
			// If this is from "for" initializer
			//     for ({a } = elems[0];.....) { }
			if (expr.parent.kind === SyntaxKind.BinaryExpression) {
				var iteratedType = getTypeOfExpression(expr.parent.right);
				return checkDestructuringAssignment(expr, iteratedType || errorType);
			}
			// If this is from nested object binding pattern
			//     for ({ skills: { primary, secondary } } = multiRobot, i = 0; i < 1; i++) {
			if (expr.parent.kind === SyntaxKind.PropertyAssignment) {
				var node_2 = cast(expr.parent.parent, isObjectLiteralExpression);
				var typeOfParentObjectLiteral = getTypeOfAssignmentPattern(node_2) || errorType;
				var propertyIndex = indexOfNode(node_2.properties, expr.parent);
				return checkObjectLiteralDestructuringPropertyAssignment(
					node_2,
					typeOfParentObjectLiteral,
					propertyIndex,
				);
			}
			// Array literal assignment - array destructuring pattern
			var node = cast(expr.parent, isArrayLiteralExpression);
			//    [{ property1: p1, property2 }] = elems;
			var typeOfArrayLiteral = getTypeOfAssignmentPattern(node) || errorType;
			var elementType = checkIteratedTypeOrElementType(
				65, /* Destructuring */
				typeOfArrayLiteral,
				undefinedType,
				expr.parent,
			) || errorType;
			return checkArrayLiteralDestructuringElementAssignment(
				node,
				typeOfArrayLiteral,
				node.elements.indexOf(expr),
				elementType,
			);
		}
		// Gets the property symbol corresponding to the property in destructuring assignment
		// 'property1' from
		//     for ( { property1: a } of elems) {
		//     }
		// 'property1' at location 'a' from:
		//     [a] = [ property1, property2 ]
		function getPropertySymbolOfDestructuringAssignment(location) {
			// Get the type of the object or array literal and then look for property of given name in the type
			var typeOfObjectLiteral = getTypeOfAssignmentPattern(
				cast(location.parent.parent, isAssignmentPattern),
			);
			return typeOfObjectLiteral && getPropertyOfType(
				typeOfObjectLiteral,
				location.escapedText,
			);
		}
		function getRegularTypeOfExpression(expr) {
			if (isRightSideOfQualifiedNameOrPropertyAccess(expr)) {
				expr = expr.parent;
			}
			return getRegularTypeOfLiteralType(getTypeOfExpression(expr));
		}
		/**
         * Gets either the static or instance type of a class element, based on
         * whether the element is declared as "static".
         */
		function getParentTypeOfClassElement(node) {
			var classSymbol = getSymbolOfNode(node.parent);
			return isStatic(node) ? getTypeOfSymbol(classSymbol) : getDeclaredTypeOfSymbol(
				classSymbol,
			);
		}
		function getClassElementPropertyKeyType(element) {
			var name = element.name;
			switch (name.kind) {
				case SyntaxKind.Identifier:
					return getStringLiteralType(idText(name));
				case SyntaxKind.NumericLiteral:
				case SyntaxKind.StringLiteral:
					return getStringLiteralType(name.text);
				case SyntaxKind.ComputedPropertyName:
					var nameType = checkComputedPropertyName(name);
					return isTypeAssignableToKind(nameType, TypeFlags.ESSymbolLike) ? nameType : stringType;
				default:
					return Debug.fail("Unsupported property name.");
			}
		}
		// Return the list of properties of the given type, augmented with properties from Function
		// if the type has call or construct signatures
		function getAugmentedPropertiesOfType(type) {
			type = getApparentType(type);
			var propsByName = createSymbolTable(getPropertiesOfType(type));
			var functionType = getSignaturesOfType(type, SignatureKind.Call).length ? globalCallableFunctionType : getSignaturesOfType(
				type,
				SignatureKind.Construct,
			).length ? globalNewableFunctionType : undefined;
			if (functionType) {
				forEach(
					getPropertiesOfType(functionType),
					function (p) {
						if (!propsByName.has(p.escapedName)) {
							propsByName.set(p.escapedName, p);
						}
					},
				);
			}
			return getNamedMembers(propsByName);
		}
		function typeHasCallOrConstructSignatures(type) {
			return ts.typeHasCallOrConstructSignatures(type, checker);
		}
		function getRootSymbols(symbol) {
			var roots = getImmediateRootSymbols(symbol);
			return roots ? flatMap(roots, getRootSymbols) : [symbol];
		}
		function getImmediateRootSymbols(symbol) {
			if (getCheckFlags(symbol) & CheckFlags.Synthetic) {
				return mapDefined(
					getSymbolLinks(symbol).containingType.types,
					function (type) {
						return getPropertyOfType(type, symbol.escapedName);
					},
				);
			} else if (symbol.flags & SymbolFlags.Transient) {
				var _a = symbol,
					leftSpread = _a.leftSpread,
					rightSpread = _a.rightSpread,
					syntheticOrigin = _a.syntheticOrigin;
				return leftSpread ? [leftSpread, rightSpread] : syntheticOrigin ? [
					syntheticOrigin,
				] : singleElementArray(tryGetAliasTarget(symbol));
			}
			return undefined;
		}
		function tryGetAliasTarget(symbol) {
			var target;
			var next = symbol;
			while (next = getSymbolLinks(next).target) {
				target = next;
			}
			return target;
		}
		// Emitter support
		function isArgumentsLocalBinding(nodeIn) {
			// Note: does not handle isShorthandPropertyAssignment (and probably a few more)
			if (isGeneratedIdentifier(nodeIn)) return false;
			var node = getParseTreeNode(nodeIn, isIdentifier);
			if (!node) return false;
			var parent = node.parent;
			if (!parent) return false;
			var isPropertyName = ((isPropertyAccessExpression(parent) || isPropertyAssignment(
				parent,
			)) && parent.name === node);
			return !isPropertyName && getReferencedValueSymbol(node) === argumentsSymbol;
		}
		function moduleExportsSomeValue(moduleReferenceExpression) {
			var moduleSymbol = resolveExternalModuleName(
				moduleReferenceExpression.parent,
				moduleReferenceExpression,
			);
			if (!moduleSymbol || isShorthandAmbientModuleSymbol(moduleSymbol)) {
				// If the module is not found or is shorthand, assume that it may export a value.
				return true;
			}
			var hasExportAssignment = hasExportAssignmentSymbol(moduleSymbol);
			// if module has export assignment then 'resolveExternalModuleSymbol' will return resolved symbol for export assignment
			// otherwise it will return moduleSymbol itself
			moduleSymbol = resolveExternalModuleSymbol(moduleSymbol);
			var symbolLinks = getSymbolLinks(moduleSymbol);
			if (symbolLinks.exportsSomeValue === undefined) {
				// for export assignments - check if resolved symbol for RHS is itself a value
				// otherwise - check if at least one export is value
				symbolLinks.exportsSomeValue = hasExportAssignment ? !!(moduleSymbol.flags & SymbolFlags.Value) : forEachEntry(
					getExportsOfModule(moduleSymbol),
					isValue,
				);
			}
			return symbolLinks.exportsSomeValue;
			function isValue(s) {
				s = resolveSymbol(s);
				return s && !!(s.flags & SymbolFlags.Value);
			}
		}
		function isNameOfModuleOrEnumDeclaration(node) {
			return isModuleOrEnumDeclaration(node.parent) && node === node.parent.name;
		}
		// When resolved as an expression identifier, if the given node references an exported entity, return the declaration
		// node of the exported entity's container. Otherwise, return undefined.
		function getReferencedExportContainer(nodeIn, prefixLocals) {
			var _a;
			var node = getParseTreeNode(nodeIn, isIdentifier);
			if (node) {
				// When resolving the export container for the name of a module or enum
				// declaration, we need to start resolution at the declaration's container.
				// Otherwise, we could incorrectly resolve the export container as the
				// declaration if it contains an exported member with the same name.
				var symbol = getReferencedValueSymbol(
					node, /*startInDeclarationContainer*/
					isNameOfModuleOrEnumDeclaration(node),
				);
				if (symbol) {
					if (symbol.flags & SymbolFlags.ExportValue) {
						// If we reference an exported entity within the same module declaration, then whether
						// we prefix depends on the kind of entity. SymbolFlags.ExportHasLocal encompasses all the
						// kinds that we do NOT prefix.
						var exportSymbol = getMergedSymbol(symbol.exportSymbol);
						if (
							!prefixLocals && exportSymbol.flags & SymbolFlags.ExportHasLocal && !(exportSymbol.flags & SymbolFlags.Variable)
						) {
							return undefined;
						}
						symbol = exportSymbol;
					}
					var parentSymbol_1 = getParentOfSymbol(symbol);
					if (parentSymbol_1) {
						if (
							parentSymbol_1.flags & SymbolFlags.ValueModule && ((_a = parentSymbol_1.valueDeclaration) === null || _a === void 0 ? void 0 : _a.kind) === SyntaxKind.SourceFile
						) {
							var symbolFile = parentSymbol_1.valueDeclaration;
							var referenceFile = getSourceFileOfNode(node);
							// If `node` accesses an export and that export isn't in the same file, then symbol is a namespace export, so return undefined.
							var symbolIsUmdExport = symbolFile !== referenceFile;
							return symbolIsUmdExport ? undefined : symbolFile;
						}
						return findAncestor(
							node.parent,
							function (n) {
								return isModuleOrEnumDeclaration(n) && getSymbolOfNode(n) === parentSymbol_1;
							},
						);
					}
				}
			}
		}
		// When resolved as an expression identifier, if the given node references an import, return the declaration of
		// that import. Otherwise, return undefined.
		function getReferencedImportDeclaration(nodeIn) {
			if (nodeIn.generatedImportReference) {
				return nodeIn.generatedImportReference;
			}
			var node = getParseTreeNode(nodeIn, isIdentifier);
			if (node) {
				var symbol = getReferencedValueSymbol(node);
				// We should only get the declaration of an alias if there isn't a local value
				// declaration for the symbol
				if (
					isNonLocalAlias(symbol, /*excludes*/ SymbolFlags.Value) && !getTypeOnlyAliasDeclaration(
						symbol,
					)
				) {
					return getDeclarationOfAliasSymbol(symbol);
				}
			}
			return undefined;
		}
		function isSymbolOfDestructuredElementOfCatchBinding(symbol) {
			return symbol.valueDeclaration && isBindingElement(
				symbol.valueDeclaration,
			) && walkUpBindingElementsAndPatterns(symbol.valueDeclaration).parent.kind === SyntaxKind.CatchClause;
		}
		function isSymbolOfDeclarationWithCollidingName(symbol) {
			if (
				symbol.flags & SymbolFlags.BlockScoped && symbol.valueDeclaration && !isSourceFile(
					symbol.valueDeclaration,
				)
			) {
				var links = getSymbolLinks(symbol);
				if (links.isDeclarationWithCollidingName === undefined) {
					var container = getEnclosingBlockScopeContainer(
						symbol.valueDeclaration,
					);
					if (
						isStatementWithLocals(container) || isSymbolOfDestructuredElementOfCatchBinding(
							symbol,
						)
					) {
						var nodeLinks_1 = getNodeLinks(symbol.valueDeclaration);
						if (
							resolveName(
								container.parent,
								symbol.escapedName,
								SymbolFlags.Value, /*nameNotFoundMessage*/
								undefined, /*nameArg*/
								undefined, /*isUse*/
								false,
							)
						) {
							// redeclaration - always should be renamed
							links.isDeclarationWithCollidingName = true;
						} else if (
							nodeLinks_1.flags & NodeCheckFlags.CapturedBlockScopedBinding
						) {
							// binding is captured in the function
							// should be renamed if:
							// - binding is not top level - top level bindings never collide with anything
							// AND
							//   - binding is not declared in loop, should be renamed to avoid name reuse across siblings
							//     let a, b
							//     { let x = 1; a = () => x; }
							//     { let x = 100; b = () => x; }
							//     console.log(a()); // should print '1'
							//     console.log(b()); // should print '100'
							//     OR
							//   - binding is declared inside loop but not in inside initializer of iteration statement or directly inside loop body
							//     * variables from initializer are passed to rewritten loop body as parameters so they are not captured directly
							//     * variables that are declared immediately in loop body will become top level variable after loop is rewritten and thus
							//       they will not collide with anything
							var isDeclaredInLoop = nodeLinks_1.flags & NodeCheckFlags.BlockScopedBindingInLoop;
							var inLoopInitializer = isIterationStatement(
								container, /*lookInLabeledStatements*/
								false,
							);
							var inLoopBodyBlock = container.kind === SyntaxKind.Block && isIterationStatement(
								container.parent, /*lookInLabeledStatements*/
								false,
							);
							links.isDeclarationWithCollidingName = !isBlockScopedContainerTopLevel(
								container,
							) && (!isDeclaredInLoop || (!inLoopInitializer && !inLoopBodyBlock));
						} else {
							links.isDeclarationWithCollidingName = false;
						}
					}
				}
				return links.isDeclarationWithCollidingName;
			}
			return false;
		}
		// When resolved as an expression identifier, if the given node references a nested block scoped entity with
		// a name that either hides an existing name or might hide it when compiled downlevel,
		// return the declaration of that entity. Otherwise, return undefined.
		function getReferencedDeclarationWithCollidingName(nodeIn) {
			if (!isGeneratedIdentifier(nodeIn)) {
				var node = getParseTreeNode(nodeIn, isIdentifier);
				if (node) {
					var symbol = getReferencedValueSymbol(node);
					if (symbol && isSymbolOfDeclarationWithCollidingName(symbol)) {
						return symbol.valueDeclaration;
					}
				}
			}
			return undefined;
		}
		// Return true if the given node is a declaration of a nested block scoped entity with a name that either hides an
		// existing name or might hide a name when compiled downlevel
		function isDeclarationWithCollidingName(nodeIn) {
			var node = getParseTreeNode(nodeIn, isDeclaration);
			if (node) {
				var symbol = getSymbolOfNode(node);
				if (symbol) {
					return isSymbolOfDeclarationWithCollidingName(symbol);
				}
			}
			return false;
		}
		function isValueAliasDeclaration(node) {
			switch (node.kind) {
				case SyntaxKind.ImportEqualsDeclaration:
					return isAliasResolvedToValue(getSymbolOfNode(node));
				case SyntaxKind.ImportClause:
				case SyntaxKind.NamespaceImport:
				case SyntaxKind.ImportSpecifier:
				case SyntaxKind.ExportSpecifier:
					var symbol = getSymbolOfNode(node);
					return !!symbol && isAliasResolvedToValue(symbol) && !getTypeOnlyAliasDeclaration(
						symbol,
					);
				case SyntaxKind.ExportDeclaration:
					var exportClause = node.exportClause;
					return !!exportClause && (isNamespaceExport(exportClause) || some(
						exportClause.elements,
						isValueAliasDeclaration,
					));
				case SyntaxKind.ExportAssignment:
					return node.expression && node.expression.kind === SyntaxKind.Identifier ? isAliasResolvedToValue(
						getSymbolOfNode(node),
					) : true;
			}
			return false;
		}
		function isTopLevelValueImportEqualsWithEntityName(nodeIn) {
			var node = getParseTreeNode(nodeIn, isImportEqualsDeclaration);
			if (
				node === undefined || node.parent.kind !== SyntaxKind.SourceFile || !isInternalModuleImportEqualsDeclaration(
					node,
				)
			) {
				// parent is not source file or it is not reference to internal module
				return false;
			}
			var isValue = isAliasResolvedToValue(getSymbolOfNode(node));
			return isValue && node.moduleReference && !nodeIsMissing(
				node.moduleReference,
			);
		}
		function isAliasResolvedToValue(symbol) {
			if (!symbol) {
				return false;
			}
			var target = getExportSymbolOfValueSymbolIfExported(resolveAlias(symbol));
			if (target === unknownSymbol) {
				return true;
			}
			// const enums and modules that contain only const enums are not considered values from the emit perspective
			// unless 'preserveConstEnums' option is set to true
			return !!(target.flags & SymbolFlags.Value) && (shouldPreserveConstEnums(
				compilerOptions,
			) || !isConstEnumOrConstEnumOnlyModule(target));
		}
		function isConstEnumOrConstEnumOnlyModule(s) {
			return isConstEnumSymbol(s) || !!s.constEnumOnlyModule;
		}
		function isReferencedAliasDeclaration(node, checkChildren) {
			if (isAliasSymbolDeclaration(node)) {
				var symbol = getSymbolOfNode(node);
				var links = symbol && getSymbolLinks(symbol);
				if (links === null || links === void 0 ? void 0 : links.referenced) {
					return true;
				}
				var target = getSymbolLinks(symbol).target; // TODO: GH#18217
				if (
					target && getEffectiveModifierFlags(node) & ModifierFlags.Export && target.flags & SymbolFlags.Value && (shouldPreserveConstEnums(
						compilerOptions,
					) || !isConstEnumOrConstEnumOnlyModule(target))
				) {
					// An `export import ... =` of a value symbol is always considered referenced
					return true;
				}
			}
			if (checkChildren) {
				return !!forEachChild(
					node,
					function (node) {
						return isReferencedAliasDeclaration(node, checkChildren);
					},
				);
			}
			return false;
		}
		function isImplementationOfOverload(node) {
			if (nodeIsPresent(node.body)) {
				if (isGetAccessor(node) || isSetAccessor(node)) return false; // Get or set accessors can never be overload implementations, but can have up to 2 signatures
				var symbol = getSymbolOfNode(node);
				var signaturesOfSymbol = getSignaturesOfSymbol(symbol);
				// If this function body corresponds to function with multiple signature, it is implementation of overload
				// e.g.: function foo(a: string): string;
				//       function foo(a: number): number;
				//       function foo(a: any) { // This is implementation of the overloads
				//           return a;
				//       }
				return signaturesOfSymbol.length > 1 || //       function foo(a: any) { // This is implementation of the overloads // e.g.: function foo(a: string): string; // If there is single signature for the symbol, it is overload if that signature isn't coming from the node
				//           return a;
				//       }
				(signaturesOfSymbol.length === 1 && signaturesOfSymbol[0].declaration !== node);
			}
			return false;
		}
		function isRequiredInitializedParameter(parameter) {
			return !!strictNullChecks && !isOptionalParameter(parameter) && !isJSDocParameterTag(
				parameter,
			) && !!parameter.initializer && !hasSyntacticModifier(
				parameter,
				ModifierFlags.ParameterPropertyModifier,
			);
		}
		function isOptionalUninitializedParameterProperty(parameter) {
			return strictNullChecks && isOptionalParameter(parameter) && !parameter.initializer && hasSyntacticModifier(
				parameter,
				ModifierFlags.ParameterPropertyModifier,
			);
		}
		function isOptionalUninitializedParameter(parameter) {
			return !!strictNullChecks && isOptionalParameter(parameter) && !parameter.initializer;
		}
		function isExpandoFunctionDeclaration(node) {
			var declaration = getParseTreeNode(node, isFunctionDeclaration);
			if (!declaration) {
				return false;
			}
			var symbol = getSymbolOfNode(declaration);
			if (!symbol || !(symbol.flags & SymbolFlags.Function)) {
				return false;
			}
			return !!forEachEntry(
				getExportsOfSymbol(symbol),
				function (p) {
					return p.flags & SymbolFlags.Value && p.valueDeclaration && isPropertyAccessExpression(
						p.valueDeclaration,
					);
				},
			);
		}
		function getPropertiesOfContainerFunction(node) {
			var declaration = getParseTreeNode(node, isFunctionDeclaration);
			if (!declaration) {
				return emptyArray;
			}
			var symbol = getSymbolOfNode(declaration);
			return symbol && getPropertiesOfType(getTypeOfSymbol(symbol)) || emptyArray;
		}
		function getNodeCheckFlags(node) {
			var _a;
			var nodeId = node.id || 0;
			if (nodeId < 0 || nodeId >= nodeLinks.length) return 0;
			return ((_a = nodeLinks[nodeId]) === null || _a === void 0 ? void 0 : _a.flags) || 0;
		}
		function getEnumMemberValue(node) {
			computeEnumMemberValues(node.parent);
			return getNodeLinks(node).enumMemberValue;
		}
		function canHaveConstantValue(node) {
			switch (node.kind) {
				case SyntaxKind.EnumMember:
				case SyntaxKind.PropertyAccessExpression:
				case SyntaxKind.ElementAccessExpression:
					return true;
			}
			return false;
		}
		function getConstantValue(node) {
			if (node.kind === SyntaxKind.EnumMember) {
				return getEnumMemberValue(node);
			}
			var symbol = getNodeLinks(node).resolvedSymbol;
			if (symbol && (symbol.flags & SymbolFlags.EnumMember)) {
				// inline property\index accesses only for const enums
				var member = symbol.valueDeclaration;
				if (isEnumConst(member.parent)) {
					return getEnumMemberValue(member);
				}
			}
			return undefined;
		}
		function isFunctionType(type) {
			return !!(type.flags & TypeFlags.Object) && getSignaturesOfType(
				type,
				SignatureKind.Call,
			).length > 0;
		}
		function getTypeReferenceSerializationKind(typeNameIn, location) {
			var _a, _b;
			// ensure both `typeName` and `location` are parse tree nodes.
			var typeName = getParseTreeNode(typeNameIn, isEntityName);
			if (!typeName) return TypeReferenceSerializationKind.Unknown;
			if (location) {
				location = getParseTreeNode(location);
				if (!location) return TypeReferenceSerializationKind.Unknown;
			}
			// Resolve the symbol as a value to ensure the type can be reached at runtime during emit.
			var isTypeOnly = false;
			if (isQualifiedName(typeName)) {
				var rootValueSymbol = resolveEntityName(
					getFirstIdentifier(typeName),
					SymbolFlags.Value, /*ignoreErrors*/
					true, /*dontResolveAlias*/
					true,
					location,
				);
				isTypeOnly = !!((_a = rootValueSymbol === null || rootValueSymbol === void 0 ? void 0 : rootValueSymbol.declarations) === null || _a === void 0 ? void 0 : _a.every(
					isTypeOnlyImportOrExportDeclaration,
				));
			}
			var valueSymbol = resolveEntityName(
				typeName,
				SymbolFlags.Value, /*ignoreErrors*/
				true, /*dontResolveAlias*/
				true,
				location,
			);
			var resolvedSymbol = valueSymbol && valueSymbol.flags & SymbolFlags.Alias ? resolveAlias(
				valueSymbol,
			) : valueSymbol;
			isTypeOnly || (isTypeOnly = !!((_b = valueSymbol === null || valueSymbol === void 0 ? void 0 : valueSymbol.declarations) === null || _b === void 0 ? void 0 : _b.every(
				isTypeOnlyImportOrExportDeclaration,
			)));
			// Resolve the symbol as a type so that we can provide a more useful hint for the type serializer.
			var typeSymbol = resolveEntityName(
				typeName,
				SymbolFlags.Type, /*ignoreErrors*/
				true, /*dontResolveAlias*/
				false,
				location,
			);
			if (resolvedSymbol && resolvedSymbol === typeSymbol) {
				var globalPromiseSymbol = getGlobalPromiseConstructorSymbol(
					false, /*reportErrors*/
				);
				if (globalPromiseSymbol && resolvedSymbol === globalPromiseSymbol) {
					return TypeReferenceSerializationKind.Promise;
				}
				var constructorType = getTypeOfSymbol(resolvedSymbol);
				if (constructorType && isConstructorType(constructorType)) {
					return isTypeOnly ? TypeReferenceSerializationKind.TypeWithCallSignature : TypeReferenceSerializationKind.TypeWithConstructSignatureAndValue;
				}
			}
			// We might not be able to resolve type symbol so use unknown type in that case (eg error case)
			if (!typeSymbol) {
				return isTypeOnly ? TypeReferenceSerializationKind.ObjectType : TypeReferenceSerializationKind.Unknown;
			}
			var type = getDeclaredTypeOfSymbol(typeSymbol);
			if (isErrorType(type)) {
				return isTypeOnly ? TypeReferenceSerializationKind.ObjectType : TypeReferenceSerializationKind.Unknown;
			} else if (type.flags & TypeFlags.AnyOrUnknown) {
				return TypeReferenceSerializationKind.ObjectType;
			} else if (
				isTypeAssignableToKind(
					type,
					TypeFlags.Void | TypeFlags.Nullable | TypeFlags.Never,
				)
			) {
				return TypeReferenceSerializationKind.VoidNullableOrNeverType;
			} else if (isTypeAssignableToKind(type, TypeFlags.BooleanLike)) {
				return TypeReferenceSerializationKind.BooleanType;
			} else if (isTypeAssignableToKind(type, TypeFlags.NumberLike)) {
				return TypeReferenceSerializationKind.NumberLikeType;
			} else if (isTypeAssignableToKind(type, TypeFlags.BigIntLike)) {
				return TypeReferenceSerializationKind.BigIntLikeType;
			} else if (isTypeAssignableToKind(type, TypeFlags.StringLike)) {
				return TypeReferenceSerializationKind.StringLikeType;
			} else if (isTupleType(type)) {
				return TypeReferenceSerializationKind.ArrayLikeType;
			} else if (isTypeAssignableToKind(type, TypeFlags.ESSymbolLike)) {
				return TypeReferenceSerializationKind.ESSymbolType;
			} else if (isFunctionType(type)) {
				return TypeReferenceSerializationKind.TypeWithCallSignature;
			} else if (isArrayType(type)) {
				return TypeReferenceSerializationKind.ArrayLikeType;
			} else {
				return TypeReferenceSerializationKind.ObjectType;
			}
		}
		function createTypeOfDeclaration(
			declarationIn,
			enclosingDeclaration,
			flags,
			tracker,
			addUndefined,
		) {
			var declaration = getParseTreeNode(
				declarationIn,
				isVariableLikeOrAccessor,
			);
			if (!declaration) {
				return factory.createToken(SyntaxKind.AnyKeyword);
			}
			// Get type of the symbol if this is the valid symbol otherwise get type at location
			var symbol = getSymbolOfNode(declaration);
			var type = symbol && !(symbol.flags & (SymbolFlags.TypeLiteral | SymbolFlags.Signature)) ? getWidenedLiteralType(
				getTypeOfSymbol(symbol),
			) : errorType;
			if (type.flags & TypeFlags.UniqueESSymbol && type.symbol === symbol) {
				flags |= NodeBuilderFlags.AllowUniqueESSymbolType;
			}
			if (addUndefined) {
				type = getOptionalType(type);
			}
			return nodeBuilder.typeToTypeNode(
				type,
				enclosingDeclaration,
				flags | NodeBuilderFlags.MultilineObjectLiterals,
				tracker,
			);
		}
		function createReturnTypeOfSignatureDeclaration(
			signatureDeclarationIn,
			enclosingDeclaration,
			flags,
			tracker,
		) {
			var signatureDeclaration = getParseTreeNode(
				signatureDeclarationIn,
				isFunctionLike,
			);
			if (!signatureDeclaration) {
				return factory.createToken(SyntaxKind.AnyKeyword);
			}
			var signature = getSignatureFromDeclaration(signatureDeclaration);
			return nodeBuilder.typeToTypeNode(
				getReturnTypeOfSignature(signature),
				enclosingDeclaration,
				flags | NodeBuilderFlags.MultilineObjectLiterals,
				tracker,
			);
		}
		function createTypeOfExpression(
			exprIn,
			enclosingDeclaration,
			flags,
			tracker,
		) {
			var expr = getParseTreeNode(exprIn, isExpression);
			if (!expr) {
				return factory.createToken(SyntaxKind.AnyKeyword);
			}
			var type = getWidenedType(getRegularTypeOfExpression(expr));
			return nodeBuilder.typeToTypeNode(
				type,
				enclosingDeclaration,
				flags | NodeBuilderFlags.MultilineObjectLiterals,
				tracker,
			);
		}
		function hasGlobalName(name) {
			return globals.has(escapeLeadingUnderscores(name));
		}
		function getReferencedValueSymbol(reference, startInDeclarationContainer) {
			var resolvedSymbol = getNodeLinks(reference).resolvedSymbol;
			if (resolvedSymbol) {
				return resolvedSymbol;
			}
			var location = reference;
			if (startInDeclarationContainer) {
				// When resolving the name of a declaration as a value, we need to start resolution
				// at a point outside of the declaration.
				var parent_19 = reference.parent;
				if (isDeclaration(parent_19) && reference === parent_19.name) {
					location = getDeclarationContainer(parent_19);
				}
			}
			return resolveName(
				location,
				reference.escapedText,
				SymbolFlags.Value | SymbolFlags.ExportValue | SymbolFlags.Alias, /*nodeNotFoundMessage*/
				undefined, /*nameArg*/
				undefined, /*isUse*/
				true,
			);
		}
		function getReferencedValueDeclaration(referenceIn) {
			if (!isGeneratedIdentifier(referenceIn)) {
				var reference = getParseTreeNode(referenceIn, isIdentifier);
				if (reference) {
					var symbol = getReferencedValueSymbol(reference);
					if (symbol) {
						return getExportSymbolOfValueSymbolIfExported(symbol).valueDeclaration;
					}
				}
			}
			return undefined;
		}
		function isLiteralConstDeclaration(node) {
			if (
				isDeclarationReadonly(node) || isVariableDeclaration(node) && isVarConst(
					node,
				)
			) {
				return isFreshLiteralType(getTypeOfSymbol(getSymbolOfNode(node)));
			}
			return false;
		}
		function literalTypeToNode(type, enclosing, tracker) {
			var enumResult = type.flags & TypeFlags.EnumLiteral ? nodeBuilder.symbolToExpression(
				type.symbol,
				SymbolFlags.Value,
				enclosing, /*flags*/
				undefined,
				tracker,
			) : type === trueType ? factory.createTrue() : type === falseType && factory.createFalse();
			if (enumResult) return enumResult;
			var literalValue = type.value;
			return typeof literalValue === "object" ? factory.createBigIntLiteral(
				literalValue,
			) : typeof literalValue === "number" ? factory.createNumericLiteral(
				literalValue,
			) : factory.createStringLiteral(literalValue);
		}
		function createLiteralConstValue(node, tracker) {
			var type = getTypeOfSymbol(getSymbolOfNode(node));
			return literalTypeToNode(type, node, tracker);
		}
		function getJsxFactoryEntity(location) {
			return location ? (getJsxNamespace(location), (getSourceFileOfNode(
				location,
			).localJsxFactory || _jsxFactoryEntity)) : _jsxFactoryEntity;
		}
		function getJsxFragmentFactoryEntity(location) {
			if (location) {
				var file = getSourceFileOfNode(location);
				if (file) {
					if (file.localJsxFragmentFactory) {
						return file.localJsxFragmentFactory;
					}
					var jsxFragPragmas = file.pragmas.get("jsxfrag");
					var jsxFragPragma = isArray(jsxFragPragmas) ? jsxFragPragmas[0] : jsxFragPragmas;
					if (jsxFragPragma) {
						file.localJsxFragmentFactory = parseIsolatedEntityName(
							jsxFragPragma.arguments.factory,
							languageVersion,
						);
						return file.localJsxFragmentFactory;
					}
				}
			}
			if (compilerOptions.jsxFragmentFactory) {
				return parseIsolatedEntityName(
					compilerOptions.jsxFragmentFactory,
					languageVersion,
				);
			}
		}
		function createResolver() {
			// this variable and functions that use it are deliberately moved here from the outer scope
			// to avoid scope pollution
			var resolvedTypeReferenceDirectives = host.getResolvedTypeReferenceDirectives();
			var fileToDirective;
			if (resolvedTypeReferenceDirectives) {
				// populate reverse mapping: file path -> type reference directive that was resolved to this file
				fileToDirective = new Map();
				resolvedTypeReferenceDirectives.forEach(
					function (resolvedDirective, key) {
						if (!resolvedDirective || !resolvedDirective.resolvedFileName) {
							return;
						}
						var file = host.getSourceFile(resolvedDirective.resolvedFileName);
						if (file) {
							// Add the transitive closure of path references loaded by this file (as long as they are not)
							// part of an existing type reference.
							addReferencedFilesToTypeDirective(file, key);
						}
					},
				);
			}
			return {
				getReferencedExportContainer: getReferencedExportContainer,
				getReferencedImportDeclaration: getReferencedImportDeclaration,
				getReferencedDeclarationWithCollidingName: getReferencedDeclarationWithCollidingName,
				isDeclarationWithCollidingName: isDeclarationWithCollidingName,
				isValueAliasDeclaration: function (nodeIn) {
					var node = getParseTreeNode(nodeIn);
					// Synthesized nodes are always treated like values.
					return node ? isValueAliasDeclaration(node) : true;
				},
				hasGlobalName: hasGlobalName,
				isReferencedAliasDeclaration: function (nodeIn, checkChildren) {
					var node = getParseTreeNode(nodeIn);
					// Synthesized nodes are always treated as referenced.
					return node ? isReferencedAliasDeclaration(node, checkChildren) : true;
				},
				getNodeCheckFlags: function (nodeIn) {
					var node = getParseTreeNode(nodeIn);
					return node ? getNodeCheckFlags(node) : 0;
				},
				isTopLevelValueImportEqualsWithEntityName: isTopLevelValueImportEqualsWithEntityName,
				isDeclarationVisible: isDeclarationVisible,
				isImplementationOfOverload: isImplementationOfOverload,
				isRequiredInitializedParameter: isRequiredInitializedParameter,
				isOptionalUninitializedParameterProperty: isOptionalUninitializedParameterProperty,
				isExpandoFunctionDeclaration: isExpandoFunctionDeclaration,
				getPropertiesOfContainerFunction: getPropertiesOfContainerFunction,
				createTypeOfDeclaration: createTypeOfDeclaration,
				createReturnTypeOfSignatureDeclaration: createReturnTypeOfSignatureDeclaration,
				createTypeOfExpression: createTypeOfExpression,
				createLiteralConstValue: createLiteralConstValue,
				isSymbolAccessible: isSymbolAccessible,
				isEntityNameVisible: isEntityNameVisible,
				getConstantValue: function (nodeIn) {
					var node = getParseTreeNode(nodeIn, canHaveConstantValue);
					return node ? getConstantValue(node) : undefined;
				},
				collectLinkedAliases: collectLinkedAliases,
				getReferencedValueDeclaration: getReferencedValueDeclaration,
				getTypeReferenceSerializationKind: getTypeReferenceSerializationKind,
				isOptionalParameter: isOptionalParameter,
				moduleExportsSomeValue: moduleExportsSomeValue,
				isArgumentsLocalBinding: isArgumentsLocalBinding,
				getExternalModuleFileFromDeclaration: function (nodeIn) {
					var node = getParseTreeNode(
						nodeIn,
						hasPossibleExternalModuleReference,
					);
					return node && getExternalModuleFileFromDeclaration(node);
				},
				getTypeReferenceDirectivesForEntityName: getTypeReferenceDirectivesForEntityName,
				getTypeReferenceDirectivesForSymbol: getTypeReferenceDirectivesForSymbol,
				isLiteralConstDeclaration: isLiteralConstDeclaration,
				isLateBound: function (nodeIn) {
					var node = getParseTreeNode(nodeIn, isDeclaration);
					var symbol = node && getSymbolOfNode(node);
					return !!(symbol && getCheckFlags(symbol) & CheckFlags.Late);
				},
				getJsxFactoryEntity: getJsxFactoryEntity,
				getJsxFragmentFactoryEntity: getJsxFragmentFactoryEntity,
				getAllAccessorDeclarations: function (accessor) {
					accessor = getParseTreeNode(accessor, isGetOrSetAccessorDeclaration); // TODO: GH#18217
					var otherKind = accessor.kind === SyntaxKind.SetAccessor ? SyntaxKind.GetAccessor : SyntaxKind.SetAccessor;
					var otherAccessor = getDeclarationOfKind(
						getSymbolOfNode(accessor),
						otherKind,
					);
					var firstAccessor = otherAccessor && (otherAccessor.pos < accessor.pos) ? otherAccessor : accessor;
					var secondAccessor = otherAccessor && (otherAccessor.pos < accessor.pos) ? accessor : otherAccessor;
					var setAccessor = accessor.kind === SyntaxKind.SetAccessor ? accessor : otherAccessor;
					var getAccessor = accessor.kind === SyntaxKind.GetAccessor ? accessor : otherAccessor;
					return {
						firstAccessor: firstAccessor,
						secondAccessor: secondAccessor,
						setAccessor: setAccessor,
						getAccessor: getAccessor,
					};
				},
				getSymbolOfExternalModuleSpecifier: function (moduleName) {
					return resolveExternalModuleNameWorker(
						moduleName,
						moduleName, /*moduleNotFoundError*/
						undefined,
					);
				},
				isBindingCapturedByNode: function (node, decl) {
					var parseNode = getParseTreeNode(node);
					var parseDecl = getParseTreeNode(decl);
					return !!parseNode && !!parseDecl && (isVariableDeclaration(parseDecl) || isBindingElement(
						parseDecl,
					)) && isBindingCapturedByNode(parseNode, parseDecl);
				},
				getDeclarationStatementsForSourceFile: function (
					node,
					flags,
					tracker,
					bundled,
				) {
					var n = getParseTreeNode(node);
					Debug.assert(
						n && n.kind === SyntaxKind.SourceFile,
						"Non-sourcefile node passed into getDeclarationsForSourceFile",
					);
					var sym = getSymbolOfNode(node);
					if (!sym) {
						return !node.locals ? [] : nodeBuilder.symbolTableToDeclarationStatements(
							node.locals,
							node,
							flags,
							tracker,
							bundled,
						);
					}
					return !sym.exports ? [] : nodeBuilder.symbolTableToDeclarationStatements(
						sym.exports,
						node,
						flags,
						tracker,
						bundled,
					);
				},
				isImportRequiredByAugmentation: isImportRequiredByAugmentation,
			};
			function isImportRequiredByAugmentation(node) {
				var file = getSourceFileOfNode(node);
				if (!file.symbol) return false;
				var importTarget = getExternalModuleFileFromDeclaration(node);
				if (!importTarget) return false;
				if (importTarget === file) return false;
				var exports = getExportsOfModule(file.symbol);
				for (var _i = 0, _a = arrayFrom(exports.values()); _i < _a.length; _i++) {
					var s = _a[_i];
					if (s.mergeId) {
						var merged = getMergedSymbol(s);
						if (merged.declarations) {
							for (var _b = 0, _c = merged.declarations; _b < _c.length; _b++) {
								var d = _c[_b];
								var declFile = getSourceFileOfNode(d);
								if (declFile === importTarget) {
									return true;
								}
							}
						}
					}
				}
				return false;
			}
			function isInHeritageClause(node) {
				return node.parent && node.parent.kind === SyntaxKind.ExpressionWithTypeArguments && node.parent.parent && node.parent.parent.kind === SyntaxKind.HeritageClause;
			}
			// defined here to avoid outer scope pollution
			function getTypeReferenceDirectivesForEntityName(node) {
				// program does not have any files with type reference directives - bail out
				if (!fileToDirective) {
					return undefined;
				}
				// property access can only be used as values, or types when within an expression with type arguments inside a heritage clause
				// qualified names can only be used as types\namespaces
				// identifiers are treated as values only if they appear in type queries
				var meaning = SymbolFlags.Type | SymbolFlags.Namespace;
				if (
					(node.kind === SyntaxKind.Identifier && isInTypeQuery(node)) || (node.kind === SyntaxKind.PropertyAccessExpression && !isInHeritageClause(
						node,
					))
				) {
					meaning = SymbolFlags.Value | SymbolFlags.ExportValue;
				}
				var symbol = resolveEntityName(node, meaning, /*ignoreErrors*/ true);
				return symbol && symbol !== unknownSymbol ? getTypeReferenceDirectivesForSymbol(
					symbol,
					meaning,
				) : undefined;
			}
			// defined here to avoid outer scope pollution
			function getTypeReferenceDirectivesForSymbol(symbol, meaning) {
				// program does not have any files with type reference directives - bail out
				if (!fileToDirective || !isSymbolFromTypeDeclarationFile(symbol)) {
					return undefined;
				}
				// check what declarations in the symbol can contribute to the target meaning
				var typeReferenceDirectives;
				for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
					var decl = _a[_i];
					// check meaning of the local symbol to see if declaration needs to be analyzed further
					if (decl.symbol && decl.symbol.flags & meaning) {
						var file = getSourceFileOfNode(decl);
						var typeReferenceDirective = fileToDirective.get(file.path);
						if (typeReferenceDirective) {
							(typeReferenceDirectives || (typeReferenceDirectives = [])).push(
								typeReferenceDirective,
							);
						} else {
							// found at least one entry that does not originate from type reference directive
							return undefined;
						}
					}
				}
				return typeReferenceDirectives;
			}
			function isSymbolFromTypeDeclarationFile(symbol) {
				// bail out if symbol does not have associated declarations (i.e. this is transient symbol created for property in binding pattern)
				if (!symbol.declarations) {
					return false;
				}
				// walk the parent chain for symbols to make sure that top level parent symbol is in the global scope
				// external modules cannot define or contribute to type declaration files
				var current = symbol;
				while (true) {
					var parent_20 = getParentOfSymbol(current);
					if (parent_20) {
						current = parent_20;
					} else {
						break;
					}
				}
				if (
					current.valueDeclaration && current.valueDeclaration.kind === SyntaxKind.SourceFile && current.flags & SymbolFlags.ValueModule
				) {
					return false;
				}
				// check that at least one declaration of top level symbol originates from type declaration file
				for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
					var decl = _a[_i];
					var file = getSourceFileOfNode(decl);
					if (fileToDirective.has(file.path)) {
						return true;
					}
				}
				return false;
			}
			function addReferencedFilesToTypeDirective(file, key) {
				if (fileToDirective.has(file.path)) return;
				fileToDirective.set(file.path, key);
				for (var _i = 0, _a = file.referencedFiles; _i < _a.length; _i++) {
					var fileName = _a[_i].fileName;
					var resolvedFile = resolveTripleslashReference(
						fileName,
						file.fileName,
					);
					var referencedFile = host.getSourceFile(resolvedFile);
					if (referencedFile) {
						addReferencedFilesToTypeDirective(referencedFile, key);
					}
				}
			}
		}
		function getExternalModuleFileFromDeclaration(declaration) {
			var specifier = declaration.kind === SyntaxKind.ModuleDeclaration ? tryCast(
				declaration.name,
				isStringLiteral,
			) : getExternalModuleName(declaration);
			var moduleSymbol = resolveExternalModuleNameWorker(
				specifier,
				specifier, /*moduleNotFoundError*/
				undefined,
			); // TODO: GH#18217
			if (!moduleSymbol) {
				return undefined;
			}
			return getDeclarationOfKind(moduleSymbol, SyntaxKind.SourceFile);
		}
		function initializeTypeChecker() {
			// Bind all source files and propagate errors
			for (var _i = 0, _a = host.getSourceFiles(); _i < _a.length; _i++) {
				var file = _a[_i];
				bindSourceFile(file, compilerOptions);
			}
			amalgamatedDuplicates = new Map();
			// Initialize global symbol table
			var augmentations;
			for (var _b = 0, _c = host.getSourceFiles(); _b < _c.length; _b++) {
				var file = _c[_b];
				if (file.redirectInfo) {
					continue;
				}
				if (!isExternalOrCommonJsModule(file)) {
					// It is an error for a non-external-module (i.e. script) to declare its own `globalThis`.
					// We can't use `builtinGlobals` for this due to synthetic expando-namespace generation in JS files.
					var fileGlobalThisSymbol = file.locals.get("globalThis");
					if (
						fileGlobalThisSymbol === null || fileGlobalThisSymbol === void 0 ? void 0 : fileGlobalThisSymbol.declarations
					) {
						for (
							var _d = 0, _e = fileGlobalThisSymbol.declarations;
							_d < _e.length;
							_d++
						) {
							var declaration = _e[_d];
							diagnostics.add(
								createDiagnosticForNode(
									declaration,
									Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0,
									"globalThis",
								),
							);
						}
					}
					mergeSymbolTable(globals, file.locals);
				}
				if (file.jsGlobalAugmentations) {
					mergeSymbolTable(globals, file.jsGlobalAugmentations);
				}
				if (file.patternAmbientModules && file.patternAmbientModules.length) {
					patternAmbientModules = concatenate(
						patternAmbientModules,
						file.patternAmbientModules,
					);
				}
				if (file.moduleAugmentations.length) {
					(augmentations || (augmentations = [])).push(file.moduleAugmentations);
				}
				if (file.symbol && file.symbol.globalExports) {
					// Merge in UMD exports with first-in-wins semantics (see #9771)
					var source = file.symbol.globalExports;
					source.forEach(
						function (sourceSymbol, id) {
							if (!globals.has(id)) {
								globals.set(id, sourceSymbol);
							}
						},
					);
				}
			}
			// We do global augmentations separately from module augmentations (and before creating global types) because they
			//  1. Affect global types. We won't have the correct global types until global augmentations are merged. Also,
			//  2. Module augmentation instantiation requires creating the type of a module, which, in turn, can require
			//       checking for an export or property on the module (if export=) which, in turn, can fall back to the
			//       apparent type of the module - either globalObjectType or globalFunctionType - which wouldn't exist if we
			//       did module augmentations prior to finalizing the global types.
			if (augmentations) {
				// merge _global_ module augmentations.
				// this needs to be done after global symbol table is initialized to make sure that all ambient modules are indexed
				for (
					var _f = 0, augmentations_1 = augmentations;
					_f < augmentations_1.length;
					_f++
				) {
					var list = augmentations_1[_f];
					for (var _g = 0, list_1 = list; _g < list_1.length; _g++) {
						var augmentation = list_1[_g];
						if (!isGlobalScopeAugmentation(augmentation.parent)) continue;
						mergeModuleAugmentation(augmentation);
					}
				}
			}
			// Setup global builtins
			addToSymbolTable(
				globals,
				builtinGlobals,
				Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0,
			);
			getSymbolLinks(undefinedSymbol).type = undefinedWideningType;
			getSymbolLinks(argumentsSymbol).type = getGlobalType(
				"IArguments", /*arity*/
				0, /*reportErrors*/
				true,
			);
			getSymbolLinks(unknownSymbol).type = errorType;
			getSymbolLinks(globalThisSymbol).type = createObjectType(
				ObjectFlags.Anonymous,
				globalThisSymbol,
			);
			// Initialize special types
			globalArrayType = getGlobalType(
				"Array", /*arity*/
				1, /*reportErrors*/
				true,
			);
			globalObjectType = getGlobalType(
				"Object", /*arity*/
				0, /*reportErrors*/
				true,
			);
			globalFunctionType = getGlobalType(
				"Function", /*arity*/
				0, /*reportErrors*/
				true,
			);
			globalCallableFunctionType = strictBindCallApply && getGlobalType(
				"CallableFunction", /*arity*/
				0, /*reportErrors*/
				true,
			) || globalFunctionType;
			globalNewableFunctionType = strictBindCallApply && getGlobalType(
				"NewableFunction", /*arity*/
				0, /*reportErrors*/
				true,
			) || globalFunctionType;
			globalStringType = getGlobalType(
				"String", /*arity*/
				0, /*reportErrors*/
				true,
			);
			globalNumberType = getGlobalType(
				"Number", /*arity*/
				0, /*reportErrors*/
				true,
			);
			globalBooleanType = getGlobalType(
				"Boolean", /*arity*/
				0, /*reportErrors*/
				true,
			);
			globalRegExpType = getGlobalType(
				"RegExp", /*arity*/
				0, /*reportErrors*/
				true,
			);
			anyArrayType = createArrayType(anyType);
			autoArrayType = createArrayType(autoType);
			if (autoArrayType === emptyObjectType) {
				// autoArrayType is used as a marker, so even if global Array type is not defined, it needs to be a unique type
				autoArrayType = createAnonymousType(
					undefined,
					emptySymbols,
					emptyArray,
					emptyArray,
					emptyArray,
				);
			}
			globalReadonlyArrayType = getGlobalTypeOrUndefined(
				"ReadonlyArray", /*arity*/
				1,
			) || globalArrayType;
			anyReadonlyArrayType = globalReadonlyArrayType ? createTypeFromGenericGlobalType(
				globalReadonlyArrayType,
				[anyType],
			) : anyArrayType;
			globalThisType = getGlobalTypeOrUndefined("ThisType", /*arity*/ 1);
			if (augmentations) {
				// merge _nonglobal_ module augmentations.
				// this needs to be done after global symbol table is initialized to make sure that all ambient modules are indexed
				for (
					var _h = 0, augmentations_2 = augmentations;
					_h < augmentations_2.length;
					_h++
				) {
					var list = augmentations_2[_h];
					for (var _j = 0, list_2 = list; _j < list_2.length; _j++) {
						var augmentation = list_2[_j];
						if (isGlobalScopeAugmentation(augmentation.parent)) continue;
						mergeModuleAugmentation(augmentation);
					}
				}
			}
			amalgamatedDuplicates.forEach(
				function (_a) {
					var firstFile = _a.firstFile,
						secondFile = _a.secondFile,
						conflictingSymbols = _a.conflictingSymbols;
					// If not many things conflict, issue individual errors
					if (conflictingSymbols.size < 8) {
						conflictingSymbols.forEach(
							function (_a, symbolName) {
								var isBlockScoped = _a.isBlockScoped,
									firstFileLocations = _a.firstFileLocations,
									secondFileLocations = _a.secondFileLocations;
								var message = isBlockScoped ? Diagnostics.Cannot_redeclare_block_scoped_variable_0 : Diagnostics.Duplicate_identifier_0;
								for (
									var _i = 0, firstFileLocations_1 = firstFileLocations;
									_i < firstFileLocations_1.length;
									_i++
								) {
									var node = firstFileLocations_1[_i];
									addDuplicateDeclarationError(
										node,
										message,
										symbolName,
										secondFileLocations,
									);
								}
								for (
									var _b = 0, secondFileLocations_1 = secondFileLocations;
									_b < secondFileLocations_1.length;
									_b++
								) {
									var node = secondFileLocations_1[_b];
									addDuplicateDeclarationError(
										node,
										message,
										symbolName,
										firstFileLocations,
									);
								}
							},
						);
					} else {
						// Otherwise issue top-level error since the files appear very identical in terms of what they contain
						var list = arrayFrom(conflictingSymbols.keys()).join(", ");
						diagnostics.add(
							addRelatedInfo(
								createDiagnosticForNode(
									firstFile,
									Diagnostics.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0,
									list,
								),
								createDiagnosticForNode(
									secondFile,
									Diagnostics.Conflicts_are_in_this_file,
								),
							),
						);
						diagnostics.add(
							addRelatedInfo(
								createDiagnosticForNode(
									secondFile,
									Diagnostics.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0,
									list,
								),
								createDiagnosticForNode(
									firstFile,
									Diagnostics.Conflicts_are_in_this_file,
								),
							),
						);
					}
				},
			);
			amalgamatedDuplicates = undefined;
		}
		function checkExternalEmitHelpers(location, helpers) {
			if (
				(requestedExternalEmitHelpers & helpers) !== helpers && compilerOptions.importHelpers
			) {
				var sourceFile = getSourceFileOfNode(location);
				if (
					isEffectiveExternalModule(sourceFile, compilerOptions) && !(location.flags & NodeFlags.Ambient)
				) {
					var helpersModule = resolveHelpersModule(sourceFile, location);
					if (helpersModule !== unknownSymbol) {
						var uncheckedHelpers = helpers & ~requestedExternalEmitHelpers;
						for (
							var helper = ExternalEmitHelpers.FirstEmitHelper;
							helper <= ExternalEmitHelpers.LastEmitHelper;
							helper <<= 1
						) {
							if (uncheckedHelpers & helper) {
								var name_41 = getHelperName(helper);
								var symbol = getSymbol(
									helpersModule.exports,
									escapeLeadingUnderscores(name_41),
									SymbolFlags.Value,
								);
								if (!symbol) {
									error(
										location,
										Diagnostics.This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_version_of_0,
										externalHelpersModuleNameText,
										name_41,
									);
								} else if (helper & ExternalEmitHelpers.ClassPrivateFieldGet) {
									if (
										!some(
											getSignaturesOfSymbol(symbol),
											function (signature) {
												return getParameterCount(signature) > 3;
											},
										)
									) {
										error(
											location,
											Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0,
											externalHelpersModuleNameText,
											name_41,
											4,
										);
									}
								} else if (helper & ExternalEmitHelpers.ClassPrivateFieldSet) {
									if (
										!some(
											getSignaturesOfSymbol(symbol),
											function (signature) {
												return getParameterCount(signature) > 4;
											},
										)
									) {
										error(
											location,
											Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0,
											externalHelpersModuleNameText,
											name_41,
											5,
										);
									}
								} else if (helper & ExternalEmitHelpers.SpreadArray) {
									if (
										!some(
											getSignaturesOfSymbol(symbol),
											function (signature) {
												return getParameterCount(signature) > 2;
											},
										)
									) {
										error(
											location,
											Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0,
											externalHelpersModuleNameText,
											name_41,
											3,
										);
									}
								}
							}
						}
					}
					requestedExternalEmitHelpers |= helpers;
				}
			}
		}
		function getHelperName(helper) {
			switch (helper) {
				case ExternalEmitHelpers.Extends:
					return "__extends";
				case ExternalEmitHelpers.Assign:
					return "__assign";
				case ExternalEmitHelpers.Rest:
					return "__rest";
				case ExternalEmitHelpers.Decorate:
					return "__decorate";
				case ExternalEmitHelpers.Metadata:
					return "__metadata";
				case ExternalEmitHelpers.Param:
					return "__param";
				case ExternalEmitHelpers.Awaiter:
					return "__awaiter";
				case ExternalEmitHelpers.Generator:
					return "__generator";
				case ExternalEmitHelpers.Values:
					return "__values";
				case ExternalEmitHelpers.Read:
					return "__read";
				case ExternalEmitHelpers.SpreadArray:
					return "__spreadArray";
				case ExternalEmitHelpers.Await:
					return "__await";
				case ExternalEmitHelpers.AsyncGenerator:
					return "__asyncGenerator";
				case ExternalEmitHelpers.AsyncDelegator:
					return "__asyncDelegator";
				case ExternalEmitHelpers.AsyncValues:
					return "__asyncValues";
				case ExternalEmitHelpers.ExportStar:
					return "__exportStar";
				case ExternalEmitHelpers.ImportStar:
					return "__importStar";
				case ExternalEmitHelpers.ImportDefault:
					return "__importDefault";
				case ExternalEmitHelpers.MakeTemplateObject:
					return "__makeTemplateObject";
				case ExternalEmitHelpers.ClassPrivateFieldGet:
					return "__classPrivateFieldGet";
				case ExternalEmitHelpers.ClassPrivateFieldSet:
					return "__classPrivateFieldSet";
				case ExternalEmitHelpers.ClassPrivateFieldIn:
					return "__classPrivateFieldIn";
				case ExternalEmitHelpers.CreateBinding:
					return "__createBinding";
				default:
					return Debug.fail("Unrecognized helper");
			}
		}
		function resolveHelpersModule(node, errorNode) {
			if (!externalHelpersModule) {
				externalHelpersModule = resolveExternalModule(
					node,
					externalHelpersModuleNameText,
					Diagnostics.This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found,
					errorNode,
				) || unknownSymbol;
			}
			return externalHelpersModule;
		}
		// GRAMMAR CHECKING
		function checkGrammarDecoratorsAndModifiers(node) {
			return checkGrammarDecorators(node) || checkGrammarModifiers(node);
		}
		function checkGrammarDecorators(node) {
			if (!node.decorators) {
				return false;
			}
			if (!nodeCanBeDecorated(node, node.parent, node.parent.parent)) {
				if (
					node.kind === SyntaxKind.MethodDeclaration && !nodeIsPresent(
						node.body,
					)
				) {
					return grammarErrorOnFirstToken(
						node,
						Diagnostics.A_decorator_can_only_decorate_a_method_implementation_not_an_overload,
					);
				} else {
					return grammarErrorOnFirstToken(
						node,
						Diagnostics.Decorators_are_not_valid_here,
					);
				}
			} else if (
				node.kind === SyntaxKind.GetAccessor || node.kind === SyntaxKind.SetAccessor
			) {
				var accessors = getAllAccessorDeclarations(node.parent.members, node);
				if (
					accessors.firstAccessor.decorators && node === accessors.secondAccessor
				) {
					return grammarErrorOnFirstToken(
						node,
						Diagnostics.Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name,
					);
				}
			}
			return false;
		}
		function checkGrammarModifiers(node) {
			var quickResult = reportObviousModifierErrors(node);
			if (quickResult !== undefined) {
				return quickResult;
			}
			var lastStatic, lastDeclare, lastAsync, lastReadonly, lastOverride;
			var flags = ModifierFlags.None;
			for (var _i = 0, _a = node.modifiers; _i < _a.length; _i++) {
				var modifier = _a[_i];
				if (modifier.kind !== SyntaxKind.ReadonlyKeyword) {
					if (
						node.kind === SyntaxKind.PropertySignature || node.kind === SyntaxKind.MethodSignature
					) {
						return grammarErrorOnNode(
							modifier,
							Diagnostics._0_modifier_cannot_appear_on_a_type_member,
							tokenToString(modifier.kind),
						);
					}
					if (
						node.kind === SyntaxKind.IndexSignature && (modifier.kind !== SyntaxKind.StaticKeyword || !isClassLike(
							node.parent,
						))
					) {
						return grammarErrorOnNode(
							modifier,
							Diagnostics._0_modifier_cannot_appear_on_an_index_signature,
							tokenToString(modifier.kind),
						);
					}
				}
				switch (modifier.kind) {
					case SyntaxKind.ConstKeyword:
						if (node.kind !== SyntaxKind.EnumDeclaration) {
							return grammarErrorOnNode(
								node,
								Diagnostics.A_class_member_cannot_have_the_0_keyword,
								tokenToString(SyntaxKind.ConstKeyword),
							);
						}
						break;
					case SyntaxKind.OverrideKeyword:
						// If node.kind === SyntaxKind.Parameter, checkParameter reports an error if it's not a parameter property.
						if (flags & ModifierFlags.Override) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_already_seen,
								"override",
							);
						} else if (flags & ModifierFlags.Ambient) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_cannot_be_used_with_1_modifier,
								"override",
								"declare",
							);
						} else if (flags & ModifierFlags.Readonly) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_must_precede_1_modifier,
								"override",
								"readonly",
							);
						} else if (flags & ModifierFlags.Async) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_must_precede_1_modifier,
								"override",
								"async",
							);
						}
						flags |= ModifierFlags.Override;
						lastOverride = modifier;
						break;
					case SyntaxKind.PublicKeyword:
					case SyntaxKind.ProtectedKeyword:
					case SyntaxKind.PrivateKeyword:
						var text = visibilityToString(modifierToFlag(modifier.kind));
						if (flags & ModifierFlags.AccessibilityModifier) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics.Accessibility_modifier_already_seen,
							);
						} else if (flags & ModifierFlags.Override) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_must_precede_1_modifier,
								text,
								"override",
							);
						} else if (flags & ModifierFlags.Static) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_must_precede_1_modifier,
								text,
								"static",
							);
						} else if (flags & ModifierFlags.Readonly) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_must_precede_1_modifier,
								text,
								"readonly",
							);
						} else if (flags & ModifierFlags.Async) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_must_precede_1_modifier,
								text,
								"async",
							);
						} else if (
							node.parent.kind === SyntaxKind.ModuleBlock || node.parent.kind === SyntaxKind.SourceFile
						) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element,
								text,
							);
						} else if (flags & ModifierFlags.Abstract) {
							if (modifier.kind === SyntaxKind.PrivateKeyword) {
								return grammarErrorOnNode(
									modifier,
									Diagnostics._0_modifier_cannot_be_used_with_1_modifier,
									text,
									"abstract",
								);
							} else {
								return grammarErrorOnNode(
									modifier,
									Diagnostics._0_modifier_must_precede_1_modifier,
									text,
									"abstract",
								);
							}
						} else if (isPrivateIdentifierClassElementDeclaration(node)) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics.An_accessibility_modifier_cannot_be_used_with_a_private_identifier,
							);
						}
						flags |= modifierToFlag(modifier.kind);
						break;
					case SyntaxKind.StaticKeyword:
						if (flags & ModifierFlags.Static) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_already_seen,
								"static",
							);
						} else if (flags & ModifierFlags.Readonly) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_must_precede_1_modifier,
								"static",
								"readonly",
							);
						} else if (flags & ModifierFlags.Async) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_must_precede_1_modifier,
								"static",
								"async",
							);
						} else if (
							node.parent.kind === SyntaxKind.ModuleBlock || node.parent.kind === SyntaxKind.SourceFile
						) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element,
								"static",
							);
						} else if (node.kind === SyntaxKind.Parameter) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_cannot_appear_on_a_parameter,
								"static",
							);
						} else if (flags & ModifierFlags.Abstract) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_cannot_be_used_with_1_modifier,
								"static",
								"abstract",
							);
						} else if (flags & ModifierFlags.Override) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_must_precede_1_modifier,
								"static",
								"override",
							);
						}
						flags |= ModifierFlags.Static;
						lastStatic = modifier;
						break;
					case SyntaxKind.ReadonlyKeyword:
						if (flags & ModifierFlags.Readonly) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_already_seen,
								"readonly",
							);
						} else if (
							node.kind !== SyntaxKind.PropertyDeclaration && node.kind !== SyntaxKind.PropertySignature && node.kind !== SyntaxKind.IndexSignature && node.kind !== SyntaxKind.Parameter
						) {
							// If node.kind === SyntaxKind.Parameter, checkParameter reports an error if it's not a parameter property.
							return grammarErrorOnNode(
								modifier,
								Diagnostics.readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature,
							);
						}
						flags |= ModifierFlags.Readonly;
						lastReadonly = modifier;
						break;
					case SyntaxKind.ExportKeyword:
						if (flags & ModifierFlags.Export) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_already_seen,
								"export",
							);
						} else if (flags & ModifierFlags.Ambient) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_must_precede_1_modifier,
								"export",
								"declare",
							);
						} else if (flags & ModifierFlags.Abstract) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_must_precede_1_modifier,
								"export",
								"abstract",
							);
						} else if (flags & ModifierFlags.Async) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_must_precede_1_modifier,
								"export",
								"async",
							);
						} else if (isClassLike(node.parent)) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind,
								"export",
							);
						} else if (node.kind === SyntaxKind.Parameter) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_cannot_appear_on_a_parameter,
								"export",
							);
						}
						flags |= ModifierFlags.Export;
						break;
					case SyntaxKind.DefaultKeyword:
						var container = node.parent.kind === SyntaxKind.SourceFile ? node.parent : node.parent.parent;
						if (
							container.kind === SyntaxKind.ModuleDeclaration && !isAmbientModule(
								container,
							)
						) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics.A_default_export_can_only_be_used_in_an_ECMAScript_style_module,
							);
						} else if (!(flags & ModifierFlags.Export)) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_must_precede_1_modifier,
								"export",
								"default",
							);
						}
						flags |= ModifierFlags.Default;
						break;
					case SyntaxKind.DeclareKeyword:
						if (flags & ModifierFlags.Ambient) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_already_seen,
								"declare",
							);
						} else if (flags & ModifierFlags.Async) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context,
								"async",
							);
						} else if (flags & ModifierFlags.Override) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context,
								"override",
							);
						} else if (isClassLike(node.parent) && !isPropertyDeclaration(node)) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind,
								"declare",
							);
						} else if (node.kind === SyntaxKind.Parameter) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_cannot_appear_on_a_parameter,
								"declare",
							);
						} else if (
							(node.parent.flags & NodeFlags.Ambient) && node.parent.kind === SyntaxKind.ModuleBlock
						) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics.A_declare_modifier_cannot_be_used_in_an_already_ambient_context,
							);
						} else if (isPrivateIdentifierClassElementDeclaration(node)) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_cannot_be_used_with_a_private_identifier,
								"declare",
							);
						}
						flags |= ModifierFlags.Ambient;
						lastDeclare = modifier;
						break;
					case SyntaxKind.AbstractKeyword:
						if (flags & ModifierFlags.Abstract) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_already_seen,
								"abstract",
							);
						}
						if (
							node.kind !== SyntaxKind.ClassDeclaration && node.kind !== SyntaxKind.ConstructorType
						) {
							if (
								node.kind !== SyntaxKind.MethodDeclaration && node.kind !== SyntaxKind.PropertyDeclaration && node.kind !== SyntaxKind.GetAccessor && node.kind !== SyntaxKind.SetAccessor
							) {
								return grammarErrorOnNode(
									modifier,
									Diagnostics.abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration,
								);
							}
							if (
								!(node.parent.kind === SyntaxKind.ClassDeclaration && hasSyntacticModifier(
									node.parent,
									ModifierFlags.Abstract,
								))
							) {
								return grammarErrorOnNode(
									modifier,
									Diagnostics.Abstract_methods_can_only_appear_within_an_abstract_class,
								);
							}
							if (flags & ModifierFlags.Static) {
								return grammarErrorOnNode(
									modifier,
									Diagnostics._0_modifier_cannot_be_used_with_1_modifier,
									"static",
									"abstract",
								);
							}
							if (flags & ModifierFlags.Private) {
								return grammarErrorOnNode(
									modifier,
									Diagnostics._0_modifier_cannot_be_used_with_1_modifier,
									"private",
									"abstract",
								);
							}
							if (flags & ModifierFlags.Async && lastAsync) {
								return grammarErrorOnNode(
									lastAsync,
									Diagnostics._0_modifier_cannot_be_used_with_1_modifier,
									"async",
									"abstract",
								);
							}
							if (flags & ModifierFlags.Override) {
								return grammarErrorOnNode(
									modifier,
									Diagnostics._0_modifier_must_precede_1_modifier,
									"abstract",
									"override",
								);
							}
						}
						if (
							isNamedDeclaration(node) && node.name.kind === SyntaxKind.PrivateIdentifier
						) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_cannot_be_used_with_a_private_identifier,
								"abstract",
							);
						}
						flags |= ModifierFlags.Abstract;
						break;
					case SyntaxKind.AsyncKeyword:
						if (flags & ModifierFlags.Async) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_already_seen,
								"async",
							);
						} else if (
							flags & ModifierFlags.Ambient || node.parent.flags & NodeFlags.Ambient
						) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context,
								"async",
							);
						} else if (node.kind === SyntaxKind.Parameter) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_cannot_appear_on_a_parameter,
								"async",
							);
						}
						if (flags & ModifierFlags.Abstract) {
							return grammarErrorOnNode(
								modifier,
								Diagnostics._0_modifier_cannot_be_used_with_1_modifier,
								"async",
								"abstract",
							);
						}
						flags |= ModifierFlags.Async;
						lastAsync = modifier;
						break;
				}
			}
			if (node.kind === SyntaxKind.Constructor) {
				if (flags & ModifierFlags.Static) {
					return grammarErrorOnNode(
						lastStatic,
						Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration,
						"static",
					);
				}
				if (flags & ModifierFlags.Abstract) {
					return grammarErrorOnNode(
						lastStatic,
						Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration,
						"abstract",
					); // TODO: GH#18217
				}
				if (flags & ModifierFlags.Override) {
					return grammarErrorOnNode(
						lastOverride,
						Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration,
						"override",
					); // TODO: GH#18217
				} else if (flags & ModifierFlags.Async) {
					return grammarErrorOnNode(
						lastAsync,
						Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration,
						"async",
					);
				} else if (flags & ModifierFlags.Readonly) {
					return grammarErrorOnNode(
						lastReadonly,
						Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration,
						"readonly",
					);
				}
				return false;
			} else if (
				(node.kind === SyntaxKind.ImportDeclaration || node.kind === SyntaxKind.ImportEqualsDeclaration) && flags & ModifierFlags.Ambient
			) {
				return grammarErrorOnNode(
					lastDeclare,
					Diagnostics.A_0_modifier_cannot_be_used_with_an_import_declaration,
					"declare",
				);
			} else if (
				node.kind === SyntaxKind.Parameter && (flags & ModifierFlags.ParameterPropertyModifier) && isBindingPattern(
					node.name,
				)
			) {
				return grammarErrorOnNode(
					node,
					Diagnostics.A_parameter_property_may_not_be_declared_using_a_binding_pattern,
				);
			} else if (
				node.kind === SyntaxKind.Parameter && (flags & ModifierFlags.ParameterPropertyModifier) && node.dotDotDotToken
			) {
				return grammarErrorOnNode(
					node,
					Diagnostics.A_parameter_property_cannot_be_declared_using_a_rest_parameter,
				);
			}
			if (flags & ModifierFlags.Async) {
				return checkGrammarAsyncModifier(node, lastAsync);
			}
			return false;
		}
		/**
         * true | false: Early return this value from checkGrammarModifiers.
         * undefined: Need to do full checking on the modifiers.
         */
		function reportObviousModifierErrors(node) {
			return !node.modifiers ? false : shouldReportBadModifier(node) ? grammarErrorOnFirstToken(
				node,
				Diagnostics.Modifiers_cannot_appear_here,
			) : undefined;
		}
		function shouldReportBadModifier(node) {
			switch (node.kind) {
				case SyntaxKind.GetAccessor:
				case SyntaxKind.SetAccessor:
				case SyntaxKind.Constructor:
				case SyntaxKind.PropertyDeclaration:
				case SyntaxKind.PropertySignature:
				case SyntaxKind.MethodDeclaration:
				case SyntaxKind.MethodSignature:
				case SyntaxKind.IndexSignature:
				case SyntaxKind.ModuleDeclaration:
				case SyntaxKind.ImportDeclaration:
				case SyntaxKind.ImportEqualsDeclaration:
				case SyntaxKind.ExportDeclaration:
				case SyntaxKind.ExportAssignment:
				case SyntaxKind.FunctionExpression:
				case SyntaxKind.ArrowFunction:
				case SyntaxKind.Parameter:
					return false;
				default:
					if (
						node.parent.kind === SyntaxKind.ModuleBlock || node.parent.kind === SyntaxKind.SourceFile
					) {
						return false;
					}
					switch (node.kind) {
						case SyntaxKind.FunctionDeclaration:
							return nodeHasAnyModifiersExcept(node, SyntaxKind.AsyncKeyword);
						case SyntaxKind.ClassDeclaration:
						case SyntaxKind.ConstructorType:
							return nodeHasAnyModifiersExcept(node, SyntaxKind.AbstractKeyword);
						case SyntaxKind.InterfaceDeclaration:
						case SyntaxKind.VariableStatement:
						case SyntaxKind.TypeAliasDeclaration:
						case SyntaxKind.ClassStaticBlockDeclaration:
							return true;
						case SyntaxKind.EnumDeclaration:
							return nodeHasAnyModifiersExcept(node, SyntaxKind.ConstKeyword);
						default:
							Debug.fail();
					}
			}
		}
		function nodeHasAnyModifiersExcept(node, allowedModifier) {
			return node.modifiers.length > 1 || node.modifiers[0].kind !== allowedModifier;
		}
		function checkGrammarAsyncModifier(node, asyncModifier) {
			switch (node.kind) {
				case SyntaxKind.MethodDeclaration:
				case SyntaxKind.FunctionDeclaration:
				case SyntaxKind.FunctionExpression:
				case SyntaxKind.ArrowFunction:
					return false;
			}
			return grammarErrorOnNode(
				asyncModifier,
				Diagnostics._0_modifier_cannot_be_used_here,
				"async",
			);
		}
		function checkGrammarForDisallowedTrailingComma(list, diag) {
			if (diag === void 0) {
				diag = Diagnostics.Trailing_comma_not_allowed;
			}
			if (list && list.hasTrailingComma) {
				return grammarErrorAtPos(
					list[0],
					list.end - ",".length,
					",".length,
					diag,
				);
			}
			return false;
		}
		function checkGrammarTypeParameterList(typeParameters, file) {
			if (typeParameters && typeParameters.length === 0) {
				var start = typeParameters.pos - "<".length;
				var end = skipTrivia(file.text, typeParameters.end) + ">".length;
				return grammarErrorAtPos(
					file,
					start,
					end - start,
					Diagnostics.Type_parameter_list_cannot_be_empty,
				);
			}
			return false;
		}
		function checkGrammarParameterList(parameters) {
			var seenOptionalParameter = false;
			var parameterCount = parameters.length;
			for (var i = 0; i < parameterCount; i++) {
				var parameter = parameters[i];
				if (parameter.dotDotDotToken) {
					if (i !== (parameterCount - 1)) {
						return grammarErrorOnNode(
							parameter.dotDotDotToken,
							Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list,
						);
					}
					if (!(parameter.flags & NodeFlags.Ambient)) {
						checkGrammarForDisallowedTrailingComma(
							parameters, // Allow `...foo,` in ambient declarations; see GH#23070
							Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma,
						);
					}
					if (parameter.questionToken) {
						return grammarErrorOnNode(
							parameter.questionToken,
							Diagnostics.A_rest_parameter_cannot_be_optional,
						);
					}
					if (parameter.initializer) {
						return grammarErrorOnNode(
							parameter.name,
							Diagnostics.A_rest_parameter_cannot_have_an_initializer,
						);
					}
				} else if (isOptionalParameter(parameter)) {
					seenOptionalParameter = true;
					if (parameter.questionToken && parameter.initializer) {
						return grammarErrorOnNode(
							parameter.name,
							Diagnostics.Parameter_cannot_have_question_mark_and_initializer,
						);
					}
				} else if (seenOptionalParameter && !parameter.initializer) {
					return grammarErrorOnNode(
						parameter.name,
						Diagnostics.A_required_parameter_cannot_follow_an_optional_parameter,
					);
				}
			}
		}
		function getNonSimpleParameters(parameters) {
			return filter(
				parameters,
				function (parameter) {
					return !!parameter.initializer || isBindingPattern(parameter.name) || isRestParameter(
						parameter,
					);
				},
			);
		}
		function checkGrammarForUseStrictSimpleParameterList(node) {
			if (languageVersion >= ScriptTarget.ES2016) {
				var useStrictDirective_1 = node.body && isBlock(node.body) && findUseStrictPrologue(
					node.body.statements,
				);
				if (useStrictDirective_1) {
					var nonSimpleParameters = getNonSimpleParameters(node.parameters);
					if (length(nonSimpleParameters)) {
						forEach(
							nonSimpleParameters,
							function (parameter) {
								addRelatedInfo(
									error(
										parameter,
										Diagnostics.This_parameter_is_not_allowed_with_use_strict_directive,
									),
									createDiagnosticForNode(
										useStrictDirective_1,
										Diagnostics.use_strict_directive_used_here,
									),
								);
							},
						);
						var diagnostics_1 = nonSimpleParameters.map(
							function (parameter, index) {
								return (index === 0 ? createDiagnosticForNode(
									parameter,
									Diagnostics.Non_simple_parameter_declared_here,
								) : createDiagnosticForNode(parameter, Diagnostics.and_here));
							},
						);
						addRelatedInfo.apply(
							void 0,
							__spreadArray(
								[
									error(
										useStrictDirective_1,
										Diagnostics.use_strict_directive_cannot_be_used_with_non_simple_parameter_list,
									),
								],
								diagnostics_1,
								false,
							),
						);
						return true;
					}
				}
			}
			return false;
		}
		function checkGrammarFunctionLikeDeclaration(node) {
			// Prevent cascading error by short-circuit
			var file = getSourceFileOfNode(node);
			return checkGrammarDecoratorsAndModifiers(node) || checkGrammarTypeParameterList(
				node.typeParameters,
				file,
			) || checkGrammarParameterList(node.parameters) || checkGrammarArrowFunction(
				node,
				file,
			) || (isFunctionLikeDeclaration(node) && checkGrammarForUseStrictSimpleParameterList(
				node,
			));
		}
		function checkGrammarClassLikeDeclaration(node) {
			var file = getSourceFileOfNode(node);
			return checkGrammarClassDeclarationHeritageClauses(node) || checkGrammarTypeParameterList(
				node.typeParameters,
				file,
			);
		}
		function checkGrammarArrowFunction(node, file) {
			if (!isArrowFunction(node)) {
				return false;
			}
			if (
				node.typeParameters && !(length(node.typeParameters) > 1 || node.typeParameters.hasTrailingComma || node.typeParameters[0].constraint)
			) {
				if (
					file && fileExtensionIsOneOf(
						file.fileName,
						[Extension.Mts, Extension.Cts],
					)
				) {
					grammarErrorOnNode(
						node.typeParameters[0],
						Diagnostics.This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Add_a_trailing_comma_or_explicit_constraint,
					);
				}
			}
			var equalsGreaterThanToken = node.equalsGreaterThanToken;
			var startLine = getLineAndCharacterOfPosition(
				file,
				equalsGreaterThanToken.pos,
			).line;
			var endLine = getLineAndCharacterOfPosition(
				file,
				equalsGreaterThanToken.end,
			).line;
			return startLine !== endLine && grammarErrorOnNode(
				equalsGreaterThanToken,
				Diagnostics.Line_terminator_not_permitted_before_arrow,
			);
		}
		function checkGrammarIndexSignatureParameters(node) {
			var parameter = node.parameters[0];
			if (node.parameters.length !== 1) {
				if (parameter) {
					return grammarErrorOnNode(
						parameter.name,
						Diagnostics.An_index_signature_must_have_exactly_one_parameter,
					);
				} else {
					return grammarErrorOnNode(
						node,
						Diagnostics.An_index_signature_must_have_exactly_one_parameter,
					);
				}
			}
			checkGrammarForDisallowedTrailingComma(
				node.parameters,
				Diagnostics.An_index_signature_cannot_have_a_trailing_comma,
			);
			if (parameter.dotDotDotToken) {
				return grammarErrorOnNode(
					parameter.dotDotDotToken,
					Diagnostics.An_index_signature_cannot_have_a_rest_parameter,
				);
			}
			if (hasEffectiveModifiers(parameter)) {
				return grammarErrorOnNode(
					parameter.name,
					Diagnostics.An_index_signature_parameter_cannot_have_an_accessibility_modifier,
				);
			}
			if (parameter.questionToken) {
				return grammarErrorOnNode(
					parameter.questionToken,
					Diagnostics.An_index_signature_parameter_cannot_have_a_question_mark,
				);
			}
			if (parameter.initializer) {
				return grammarErrorOnNode(
					parameter.name,
					Diagnostics.An_index_signature_parameter_cannot_have_an_initializer,
				);
			}
			if (!parameter.type) {
				return grammarErrorOnNode(
					parameter.name,
					Diagnostics.An_index_signature_parameter_must_have_a_type_annotation,
				);
			}
			var type = getTypeFromTypeNode(parameter.type);
			if (
				someType(
					type,
					function (t) {
						return !!(t.flags & TypeFlags.StringOrNumberLiteralOrUnique);
					},
				) || isGenericType(type)
			) {
				return grammarErrorOnNode(
					parameter.name,
					Diagnostics.An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_object_type_instead,
				);
			}
			if (!everyType(type, isValidIndexKeyType)) {
				return grammarErrorOnNode(
					parameter.name,
					Diagnostics.An_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type,
				);
			}
			if (!node.type) {
				return grammarErrorOnNode(
					node,
					Diagnostics.An_index_signature_must_have_a_type_annotation,
				);
			}
			return false;
		}
		function checkGrammarIndexSignature(node) {
			// Prevent cascading error by short-circuit
			return checkGrammarDecoratorsAndModifiers(node) || checkGrammarIndexSignatureParameters(
				node,
			);
		}
		function checkGrammarForAtLeastOneTypeArgument(node, typeArguments) {
			if (typeArguments && typeArguments.length === 0) {
				var sourceFile = getSourceFileOfNode(node);
				var start = typeArguments.pos - "<".length;
				var end = skipTrivia(sourceFile.text, typeArguments.end) + ">".length;
				return grammarErrorAtPos(
					sourceFile,
					start,
					end - start,
					Diagnostics.Type_argument_list_cannot_be_empty,
				);
			}
			return false;
		}
		function checkGrammarTypeArguments(node, typeArguments) {
			return checkGrammarForDisallowedTrailingComma(typeArguments) || checkGrammarForAtLeastOneTypeArgument(
				node,
				typeArguments,
			);
		}
		function checkGrammarTaggedTemplateChain(node) {
			if (node.questionDotToken || node.flags & NodeFlags.OptionalChain) {
				return grammarErrorOnNode(
					node.template,
					Diagnostics.Tagged_template_expressions_are_not_permitted_in_an_optional_chain,
				);
			}
			return false;
		}
		function checkGrammarHeritageClause(node) {
			var types = node.types;
			if (checkGrammarForDisallowedTrailingComma(types)) {
				return true;
			}
			if (types && types.length === 0) {
				var listType = tokenToString(node.token);
				return grammarErrorAtPos(
					node,
					types.pos,
					0,
					Diagnostics._0_list_cannot_be_empty,
					listType,
				);
			}
			return some(types, checkGrammarExpressionWithTypeArguments);
		}
		function checkGrammarExpressionWithTypeArguments(node) {
			return checkGrammarTypeArguments(node, node.typeArguments);
		}
		function checkGrammarClassDeclarationHeritageClauses(node) {
			var seenExtendsClause = false;
			var seenImplementsClause = false;
			if (!checkGrammarDecoratorsAndModifiers(node) && node.heritageClauses) {
				for (var _i = 0, _a = node.heritageClauses; _i < _a.length; _i++) {
					var heritageClause = _a[_i];
					if (heritageClause.token === SyntaxKind.ExtendsKeyword) {
						if (seenExtendsClause) {
							return grammarErrorOnFirstToken(
								heritageClause,
								Diagnostics.extends_clause_already_seen,
							);
						}
						if (seenImplementsClause) {
							return grammarErrorOnFirstToken(
								heritageClause,
								Diagnostics.extends_clause_must_precede_implements_clause,
							);
						}
						if (heritageClause.types.length > 1) {
							return grammarErrorOnFirstToken(
								heritageClause.types[1],
								Diagnostics.Classes_can_only_extend_a_single_class,
							);
						}
						seenExtendsClause = true;
					} else {
						Debug.assert(heritageClause.token === SyntaxKind.ImplementsKeyword);
						if (seenImplementsClause) {
							return grammarErrorOnFirstToken(
								heritageClause,
								Diagnostics.implements_clause_already_seen,
							);
						}
						seenImplementsClause = true;
					}
					// Grammar checking heritageClause inside class declaration
					checkGrammarHeritageClause(heritageClause);
				}
			}
		}
		function checkGrammarInterfaceDeclaration(node) {
			var seenExtendsClause = false;
			if (node.heritageClauses) {
				for (var _i = 0, _a = node.heritageClauses; _i < _a.length; _i++) {
					var heritageClause = _a[_i];
					if (heritageClause.token === SyntaxKind.ExtendsKeyword) {
						if (seenExtendsClause) {
							return grammarErrorOnFirstToken(
								heritageClause,
								Diagnostics.extends_clause_already_seen,
							);
						}
						seenExtendsClause = true;
					} else {
						Debug.assert(heritageClause.token === SyntaxKind.ImplementsKeyword);
						return grammarErrorOnFirstToken(
							heritageClause,
							Diagnostics.Interface_declaration_cannot_have_implements_clause,
						);
					}
					// Grammar checking heritageClause inside class declaration
					checkGrammarHeritageClause(heritageClause);
				}
			}
			return false;
		}
		function checkGrammarComputedPropertyName(node) {
			// If node is not a computedPropertyName, just skip the grammar checking
			if (node.kind !== SyntaxKind.ComputedPropertyName) {
				return false;
			}
			var computedPropertyName = node;
			if (
				computedPropertyName.expression.kind === SyntaxKind.BinaryExpression && computedPropertyName.expression.operatorToken.kind === SyntaxKind.CommaToken
			) {
				return grammarErrorOnNode(
					computedPropertyName.expression,
					Diagnostics.A_comma_expression_is_not_allowed_in_a_computed_property_name,
				);
			}
			return false;
		}
		function checkGrammarForGenerator(node) {
			if (node.asteriskToken) {
				Debug.assert(
					node.kind === SyntaxKind.FunctionDeclaration || node.kind === SyntaxKind.FunctionExpression || node.kind === SyntaxKind.MethodDeclaration,
				);
				if (node.flags & NodeFlags.Ambient) {
					return grammarErrorOnNode(
						node.asteriskToken,
						Diagnostics.Generators_are_not_allowed_in_an_ambient_context,
					);
				}
				if (!node.body) {
					return grammarErrorOnNode(
						node.asteriskToken,
						Diagnostics.An_overload_signature_cannot_be_declared_as_a_generator,
					);
				}
			}
		}
		function checkGrammarForInvalidQuestionMark(questionToken, message) {
			return !!questionToken && grammarErrorOnNode(questionToken, message);
		}
		function checkGrammarForInvalidExclamationToken(exclamationToken, message) {
			return !!exclamationToken && grammarErrorOnNode(exclamationToken, message);
		}
		function checkGrammarObjectLiteralExpression(node, inDestructuring) {
			var seen = new Map();
			for (var _i = 0, _a = node.properties; _i < _a.length; _i++) {
				var prop = _a[_i];
				if (prop.kind === SyntaxKind.SpreadAssignment) {
					if (inDestructuring) {
						// a rest property cannot be destructured any further
						var expression = skipParentheses(prop.expression);
						if (
							isArrayLiteralExpression(expression) || isObjectLiteralExpression(
								expression,
							)
						) {
							return grammarErrorOnNode(
								prop.expression,
								Diagnostics.A_rest_element_cannot_contain_a_binding_pattern,
							);
						}
					}
					continue;
				}
				var name_42 = prop.name;
				if (name_42.kind === SyntaxKind.ComputedPropertyName) {
					// If the name is not a ComputedPropertyName, the grammar checking will skip it
					checkGrammarComputedPropertyName(name_42);
				}
				if (
					prop.kind === SyntaxKind.ShorthandPropertyAssignment && !inDestructuring && prop.objectAssignmentInitializer
				) {
					// having objectAssignmentInitializer is only valid in ObjectAssignmentPattern
					// outside of destructuring it is a syntax error
					grammarErrorOnNode(
						prop.equalsToken,
						Diagnostics.Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_part_of_a_destructuring_pattern,
					);
				}
				if (name_42.kind === SyntaxKind.PrivateIdentifier) {
					grammarErrorOnNode(
						name_42,
						Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies,
					);
				}
				// Modifiers are never allowed on properties except for 'async' on a method declaration
				if (prop.modifiers) {
					for (var _b = 0, _c = prop.modifiers; _b < _c.length; _b++) {
						var mod = _c[_b];
						if (
							mod.kind !== SyntaxKind.AsyncKeyword || prop.kind !== SyntaxKind.MethodDeclaration
						) {
							grammarErrorOnNode(
								mod,
								Diagnostics._0_modifier_cannot_be_used_here,
								getTextOfNode(mod),
							);
						}
					}
				}
				// ECMA-262 11.1.5 Object Initializer
				// If previous is not undefined then throw a SyntaxError exception if any of the following conditions are true
				// a.This production is contained in strict code and IsDataDescriptor(previous) is true and
				// IsDataDescriptor(propId.descriptor) is true.
				//    b.IsDataDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true.
				//    c.IsAccessorDescriptor(previous) is true and IsDataDescriptor(propId.descriptor) is true.
				//    d.IsAccessorDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true
				// and either both previous and propId.descriptor have[[Get]] fields or both previous and propId.descriptor have[[Set]] fields
				var currentKind = void 0;
				switch (prop.kind) {
					case SyntaxKind.ShorthandPropertyAssignment:
						checkGrammarForInvalidExclamationToken(
							prop.exclamationToken,
							Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context,
						);
					// falls through
					case SyntaxKind.PropertyAssignment:
						// Grammar checking for computedPropertyName and shorthandPropertyAssignment
						checkGrammarForInvalidQuestionMark(
							prop.questionToken,
							Diagnostics.An_object_member_cannot_be_declared_optional,
						);
						if (name_42.kind === SyntaxKind.NumericLiteral) {
							checkGrammarNumericLiteral(name_42);
						}
						currentKind = 4; /* PropertyAssignment */
						break;
					case SyntaxKind.MethodDeclaration:
						currentKind = 8; /* Method */
						break;
					case SyntaxKind.GetAccessor:
						currentKind = 1; /* GetAccessor */
						break;
					case SyntaxKind.SetAccessor:
						currentKind = 2; /* SetAccessor */
						break;
					default:
						throw Debug.assertNever(prop, "Unexpected syntax kind:" + prop.kind);
				}
				if (!inDestructuring) {
					var effectiveName = getPropertyNameForPropertyNameNode(name_42);
					if (effectiveName === undefined) {
						continue;
					}
					var existingKind = seen.get(effectiveName);
					if (!existingKind) {
						seen.set(effectiveName, currentKind);
					} else {
						if (
							(currentKind & 8) && (existingKind & 8) /* Method */ /* Method */
						) {
							grammarErrorOnNode(
								name_42,
								Diagnostics.Duplicate_identifier_0,
								getTextOfNode(name_42),
							);
						} else if (
							(currentKind & 4) && (existingKind & 4) /* PropertyAssignment */ /* PropertyAssignment */
						) {
							grammarErrorOnNode(
								name_42,
								Diagnostics.An_object_literal_cannot_have_multiple_properties_with_the_same_name,
								getTextOfNode(name_42),
							);
						} else if (
							(currentKind & 3) && (existingKind & 3) /* GetOrSetAccessor */ /* GetOrSetAccessor */
						) {
							if (
								existingKind !== 3 && currentKind !== existingKind /* GetOrSetAccessor */
							) {
								seen.set(effectiveName, currentKind | existingKind);
							} else {
								return grammarErrorOnNode(
									name_42,
									Diagnostics.An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name,
								);
							}
						} else {
							return grammarErrorOnNode(
								name_42,
								Diagnostics.An_object_literal_cannot_have_property_and_accessor_with_the_same_name,
							);
						}
					}
				}
			}
		}
		function checkGrammarJsxElement(node) {
			checkGrammarJsxName(node.tagName);
			checkGrammarTypeArguments(node, node.typeArguments);
			var seen = new Map();
			for (var _i = 0, _a = node.attributes.properties; _i < _a.length; _i++) {
				var attr = _a[_i];
				if (attr.kind === SyntaxKind.JsxSpreadAttribute) {
					continue;
				}
				var name_43 = attr.name, initializer = attr.initializer;
				if (!seen.get(name_43.escapedText)) {
					seen.set(name_43.escapedText, true);
				} else {
					return grammarErrorOnNode(
						name_43,
						Diagnostics.JSX_elements_cannot_have_multiple_attributes_with_the_same_name,
					);
				}
				if (
					initializer && initializer.kind === SyntaxKind.JsxExpression && !initializer.expression
				) {
					return grammarErrorOnNode(
						initializer,
						Diagnostics.JSX_attributes_must_only_be_assigned_a_non_empty_expression,
					);
				}
			}
		}
		function checkGrammarJsxName(node) {
			if (isPropertyAccessExpression(node)) {
				var propName = node;
				do {
					var check_1 = checkGrammarJsxNestedIdentifier(propName.name);
					if (check_1) {
						return check_1;
					}
					propName = propName.expression;
				} while (isPropertyAccessExpression(propName));
				var check = checkGrammarJsxNestedIdentifier(propName);
				if (check) {
					return check;
				}
			}
			function checkGrammarJsxNestedIdentifier(name) {
				if (isIdentifier(name) && idText(name).indexOf(":") !== -1) {
					return grammarErrorOnNode(
						name,
						Diagnostics.JSX_property_access_expressions_cannot_include_JSX_namespace_names,
					);
				}
			}
		}
		function checkGrammarJsxExpression(node) {
			if (node.expression && isCommaSequence(node.expression)) {
				return grammarErrorOnNode(
					node.expression,
					Diagnostics.JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array,
				);
			}
		}
		function checkGrammarForInOrForOfStatement(forInOrOfStatement) {
			if (checkGrammarStatementInAmbientContext(forInOrOfStatement)) {
				return true;
			}
			if (
				forInOrOfStatement.kind === SyntaxKind.ForOfStatement && forInOrOfStatement.awaitModifier
			) {
				if (!(forInOrOfStatement.flags & NodeFlags.AwaitContext)) {
					var sourceFile = getSourceFileOfNode(forInOrOfStatement);
					if (isInTopLevelContext(forInOrOfStatement)) {
						if (!hasParseDiagnostics(sourceFile)) {
							if (!isEffectiveExternalModule(sourceFile, compilerOptions)) {
								diagnostics.add(
									createDiagnosticForNode(
										forInOrOfStatement.awaitModifier,
										Diagnostics.for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module,
									),
								);
							}
							if (
								(moduleKind !== ModuleKind.ES2022 && moduleKind !== ModuleKind.ESNext && moduleKind !== ModuleKind.System && !(moduleKind === ModuleKind.NodeNext && getSourceFileOfNode(
									forInOrOfStatement,
								).impliedNodeFormat === ModuleKind.ESNext)) || languageVersion < ScriptTarget.ES2017
							) {
								diagnostics.add(
									createDiagnosticForNode(
										forInOrOfStatement.awaitModifier,
										Diagnostics.Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_or_nodenext_and_the_target_option_is_set_to_es2017_or_higher,
									),
								);
							}
						}
					} else {
						// use of 'for-await-of' in non-async function
						if (!hasParseDiagnostics(sourceFile)) {
							var diagnostic = createDiagnosticForNode(
								forInOrOfStatement.awaitModifier,
								Diagnostics.for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules,
							);
							var func = getContainingFunction(forInOrOfStatement);
							if (func && func.kind !== SyntaxKind.Constructor) {
								Debug.assert(
									(getFunctionFlags(func) & FunctionFlags.Async) === 0,
									"Enclosing function should never be an async function.",
								);
								var relatedInfo = createDiagnosticForNode(
									func,
									Diagnostics.Did_you_mean_to_mark_this_function_as_async,
								);
								addRelatedInfo(diagnostic, relatedInfo);
							}
							diagnostics.add(diagnostic);
							return true;
						}
					}
					return false;
				}
			}
			if (
				isForOfStatement(forInOrOfStatement) && !(forInOrOfStatement.flags & NodeFlags.AwaitContext) && isIdentifier(
					forInOrOfStatement.initializer,
				) && forInOrOfStatement.initializer.escapedText === "async"
			) {
				grammarErrorOnNode(
					forInOrOfStatement.initializer,
					Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_async,
				);
				return false;
			}
			if (
				forInOrOfStatement.initializer.kind === SyntaxKind.VariableDeclarationList
			) {
				var variableList = forInOrOfStatement.initializer;
				if (!checkGrammarVariableDeclarationList(variableList)) {
					var declarations = variableList.declarations;
					// declarations.length can be zero if there is an error in variable declaration in for-of or for-in
					// See http://www.ecma-international.org/ecma-262/6.0/#sec-for-in-and-for-of-statements for details
					// For example:
					//      var let = 10;
					//      for (let of [1,2,3]) {} // this is invalid ES6 syntax
					//      for (let in [1,2,3]) {} // this is invalid ES6 syntax
					// We will then want to skip on grammar checking on variableList declaration
					if (!declarations.length) {
						return false;
					}
					if (declarations.length > 1) {
						var diagnostic = forInOrOfStatement.kind === SyntaxKind.ForInStatement ? Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement : Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement;
						return grammarErrorOnFirstToken(
							variableList.declarations[1],
							diagnostic,
						);
					}
					var firstDeclaration = declarations[0];
					if (firstDeclaration.initializer) {
						var diagnostic = forInOrOfStatement.kind === SyntaxKind.ForInStatement ? Diagnostics.The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer : Diagnostics.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer;
						return grammarErrorOnNode(firstDeclaration.name, diagnostic);
					}
					if (firstDeclaration.type) {
						var diagnostic = forInOrOfStatement.kind === SyntaxKind.ForInStatement ? Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation : Diagnostics.The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation;
						return grammarErrorOnNode(firstDeclaration, diagnostic);
					}
				}
			}
			return false;
		}
		function checkGrammarAccessor(accessor) {
			if (
				!(accessor.flags & NodeFlags.Ambient) && (accessor.parent.kind !== SyntaxKind.TypeLiteral) && (accessor.parent.kind !== SyntaxKind.InterfaceDeclaration)
			) {
				if (languageVersion < ScriptTarget.ES5) {
					return grammarErrorOnNode(
						accessor.name,
						Diagnostics.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher,
					);
				}
				if (
					languageVersion < ScriptTarget.ES2015 && isPrivateIdentifier(
						accessor.name,
					)
				) {
					return grammarErrorOnNode(
						accessor.name,
						Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher,
					);
				}
				if (
					accessor.body === undefined && !hasSyntacticModifier(
						accessor,
						ModifierFlags.Abstract,
					)
				) {
					return grammarErrorAtPos(
						accessor,
						accessor.end - 1,
						";".length,
						Diagnostics._0_expected,
						"{",
					);
				}
			}
			if (accessor.body) {
				if (hasSyntacticModifier(accessor, ModifierFlags.Abstract)) {
					return grammarErrorOnNode(
						accessor,
						Diagnostics.An_abstract_accessor_cannot_have_an_implementation,
					);
				}
				if (
					accessor.parent.kind === SyntaxKind.TypeLiteral || accessor.parent.kind === SyntaxKind.InterfaceDeclaration
				) {
					return grammarErrorOnNode(
						accessor.body,
						Diagnostics.An_implementation_cannot_be_declared_in_ambient_contexts,
					);
				}
			}
			if (accessor.typeParameters) {
				return grammarErrorOnNode(
					accessor.name,
					Diagnostics.An_accessor_cannot_have_type_parameters,
				);
			}
			if (!doesAccessorHaveCorrectParameterCount(accessor)) {
				return grammarErrorOnNode(
					accessor.name,
					accessor.kind === SyntaxKind.GetAccessor ? Diagnostics.A_get_accessor_cannot_have_parameters : Diagnostics.A_set_accessor_must_have_exactly_one_parameter,
				);
			}
			if (accessor.kind === SyntaxKind.SetAccessor) {
				if (accessor.type) {
					return grammarErrorOnNode(
						accessor.name,
						Diagnostics.A_set_accessor_cannot_have_a_return_type_annotation,
					);
				}
				var parameter = Debug.checkDefined(
					getSetAccessorValueParameter(accessor),
					"Return value does not match parameter count assertion.",
				);
				if (parameter.dotDotDotToken) {
					return grammarErrorOnNode(
						parameter.dotDotDotToken,
						Diagnostics.A_set_accessor_cannot_have_rest_parameter,
					);
				}
				if (parameter.questionToken) {
					return grammarErrorOnNode(
						parameter.questionToken,
						Diagnostics.A_set_accessor_cannot_have_an_optional_parameter,
					);
				}
				if (parameter.initializer) {
					return grammarErrorOnNode(
						accessor.name,
						Diagnostics.A_set_accessor_parameter_cannot_have_an_initializer,
					);
				}
			}
			return false;
		}
		/** Does the accessor have the right number of parameters?
         * A get accessor has no parameters or a single `this` parameter.
         * A set accessor has one parameter or a `this` parameter and one more parameter.
         */
		function doesAccessorHaveCorrectParameterCount(accessor) {
			return getAccessorThisParameter(accessor) || accessor.parameters.length === (accessor.kind === SyntaxKind.GetAccessor ? 0 : 1);
		}
		function getAccessorThisParameter(accessor) {
			if (
				accessor.parameters.length === (accessor.kind === SyntaxKind.GetAccessor ? 1 : 2)
			) {
				return getThisParameter(accessor);
			}
		}
		function checkGrammarTypeOperatorNode(node) {
			if (node.operator === SyntaxKind.UniqueKeyword) {
				if (node.type.kind !== SyntaxKind.SymbolKeyword) {
					return grammarErrorOnNode(
						node.type,
						Diagnostics._0_expected,
						tokenToString(SyntaxKind.SymbolKeyword),
					);
				}
				var parent_21 = walkUpParenthesizedTypes(node.parent);
				if (isInJSFile(parent_21) && isJSDocTypeExpression(parent_21)) {
					parent_21 = parent_21.parent;
					if (isJSDocTypeTag(parent_21)) {
						// walk up past JSDoc comment node
						parent_21 = parent_21.parent.parent;
					}
				}
				switch (parent_21.kind) {
					case SyntaxKind.VariableDeclaration:
						var decl = parent_21;
						if (decl.name.kind !== SyntaxKind.Identifier) {
							return grammarErrorOnNode(
								node,
								Diagnostics.unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name,
							);
						}
						if (!isVariableDeclarationInVariableStatement(decl)) {
							return grammarErrorOnNode(
								node,
								Diagnostics.unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement,
							);
						}
						if (!(decl.parent.flags & NodeFlags.Const)) {
							return grammarErrorOnNode(
								parent_21.name,
								Diagnostics.A_variable_whose_type_is_a_unique_symbol_type_must_be_const,
							);
						}
						break;
					case SyntaxKind.PropertyDeclaration:
						if (
							!isStatic(parent_21) || !hasEffectiveReadonlyModifier(parent_21)
						) {
							return grammarErrorOnNode(
								parent_21.name,
								Diagnostics.A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly,
							);
						}
						break;
					case SyntaxKind.PropertySignature:
						if (!hasSyntacticModifier(parent_21, ModifierFlags.Readonly)) {
							return grammarErrorOnNode(
								parent_21.name,
								Diagnostics.A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly,
							);
						}
						break;
					default:
						return grammarErrorOnNode(
							node,
							Diagnostics.unique_symbol_types_are_not_allowed_here,
						);
				}
			} else if (node.operator === SyntaxKind.ReadonlyKeyword) {
				if (
					node.type.kind !== SyntaxKind.ArrayType && node.type.kind !== SyntaxKind.TupleType
				) {
					return grammarErrorOnFirstToken(
						node,
						Diagnostics.readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types,
						tokenToString(SyntaxKind.SymbolKeyword),
					);
				}
			}
		}
		function checkGrammarForInvalidDynamicName(node, message) {
			if (isNonBindableDynamicName(node)) {
				return grammarErrorOnNode(node, message);
			}
		}
		function checkGrammarMethod(node) {
			if (checkGrammarFunctionLikeDeclaration(node)) {
				return true;
			}
			if (node.kind === SyntaxKind.MethodDeclaration) {
				if (node.parent.kind === SyntaxKind.ObjectLiteralExpression) {
					// We only disallow modifier on a method declaration if it is a property of object-literal-expression
					if (
						node.modifiers && !(node.modifiers.length === 1 && first(
							node.modifiers,
						).kind === SyntaxKind.AsyncKeyword)
					) {
						return grammarErrorOnFirstToken(
							node,
							Diagnostics.Modifiers_cannot_appear_here,
						);
					} else if (
						checkGrammarForInvalidQuestionMark(
							node.questionToken,
							Diagnostics.An_object_member_cannot_be_declared_optional,
						)
					) {
						return true;
					} else if (
						checkGrammarForInvalidExclamationToken(
							node.exclamationToken,
							Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context,
						)
					) {
						return true;
					} else if (node.body === undefined) {
						return grammarErrorAtPos(
							node,
							node.end - 1,
							";".length,
							Diagnostics._0_expected,
							"{",
						);
					}
				}
				if (checkGrammarForGenerator(node)) {
					return true;
				}
			}
			if (isClassLike(node.parent)) {
				if (
					languageVersion < ScriptTarget.ES2015 && isPrivateIdentifier(
						node.name,
					)
				) {
					return grammarErrorOnNode(
						node.name,
						Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher,
					);
				}
				// Technically, computed properties in ambient contexts is disallowed
				// for property declarations and accessors too, not just methods.
				// However, property declarations disallow computed names in general,
				// and accessors are not allowed in ambient contexts in general,
				// so this error only really matters for methods.
				if (node.flags & NodeFlags.Ambient) {
					return checkGrammarForInvalidDynamicName(
						node.name,
						Diagnostics.A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type,
					);
				} else if (node.kind === SyntaxKind.MethodDeclaration && !node.body) {
					return checkGrammarForInvalidDynamicName(
						node.name,
						Diagnostics.A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type,
					);
				}
			} else if (node.parent.kind === SyntaxKind.InterfaceDeclaration) {
				return checkGrammarForInvalidDynamicName(
					node.name,
					Diagnostics.A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type,
				);
			} else if (node.parent.kind === SyntaxKind.TypeLiteral) {
				return checkGrammarForInvalidDynamicName(
					node.name,
					Diagnostics.A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type,
				);
			}
		}
		function checkGrammarBreakOrContinueStatement(node) {
			var current = node;
			while (current) {
				if (isFunctionLikeOrClassStaticBlockDeclaration(current)) {
					return grammarErrorOnNode(
						node,
						Diagnostics.Jump_target_cannot_cross_function_boundary,
					);
				}
				switch (current.kind) {
					case SyntaxKind.LabeledStatement:
						if (
							node.label && current.label.escapedText === node.label.escapedText
						) {
							// found matching label - verify that label usage is correct
							// continue can only target labels that are on iteration statements
							var isMisplacedContinueLabel = node.kind === SyntaxKind.ContinueStatement && !isIterationStatement(
								current.statement, /*lookInLabeledStatement*/
								true,
							);
							if (isMisplacedContinueLabel) {
								return grammarErrorOnNode(
									node,
									Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement,
								);
							}
							return false;
						}
						break;
					case SyntaxKind.SwitchStatement:
						if (node.kind === SyntaxKind.BreakStatement && !node.label) {
							// unlabeled break within switch statement - ok
							return false;
						}
						break;
					default:
						if (
							isIterationStatement(current, /*lookInLabeledStatement*/ false) && !node.label
						) {
							// unlabeled break or continue within iteration statement - ok
							return false;
						}
						break;
				}
				current = current.parent;
			}
			if (node.label) {
				var message = node.kind === SyntaxKind.BreakStatement ? Diagnostics.A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement : Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement;
				return grammarErrorOnNode(node, message);
			} else {
				var message = node.kind === SyntaxKind.BreakStatement ? Diagnostics.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement : Diagnostics.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement;
				return grammarErrorOnNode(node, message);
			}
		}
		function checkGrammarBindingElement(node) {
			if (node.dotDotDotToken) {
				var elements = node.parent.elements;
				if (node !== last(elements)) {
					return grammarErrorOnNode(
						node,
						Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern,
					);
				}
				checkGrammarForDisallowedTrailingComma(
					elements,
					Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma,
				);
				if (node.propertyName) {
					return grammarErrorOnNode(
						node.name,
						Diagnostics.A_rest_element_cannot_have_a_property_name,
					);
				}
			}
			if (node.dotDotDotToken && node.initializer) {
				// Error on equals token which immediately precedes the initializer
				return grammarErrorAtPos(
					node,
					node.initializer.pos - 1,
					1,
					Diagnostics.A_rest_element_cannot_have_an_initializer,
				);
			}
		}
		function isStringOrNumberLiteralExpression(expr) {
			return isStringOrNumericLiteralLike(expr) || expr.kind === SyntaxKind.PrefixUnaryExpression && expr.operator === SyntaxKind.MinusToken && expr.operand.kind === SyntaxKind.NumericLiteral;
		}
		function isBigIntLiteralExpression(expr) {
			return expr.kind === SyntaxKind.BigIntLiteral || expr.kind === SyntaxKind.PrefixUnaryExpression && expr.operator === SyntaxKind.MinusToken && expr.operand.kind === SyntaxKind.BigIntLiteral;
		}
		function isSimpleLiteralEnumReference(expr) {
			if (
				(isPropertyAccessExpression(expr) || (isElementAccessExpression(expr) && isStringOrNumberLiteralExpression(
					expr.argumentExpression,
				))) && isEntityNameExpression(expr.expression)
			) {
				return !!(checkExpressionCached(expr).flags & TypeFlags.EnumLiteral);
			}
		}
		function checkAmbientInitializer(node) {
			var initializer = node.initializer;
			if (initializer) {
				var isInvalidInitializer = !(isStringOrNumberLiteralExpression(
					initializer,
				) || isSimpleLiteralEnumReference(initializer) || initializer.kind === SyntaxKind.TrueKeyword || initializer.kind === SyntaxKind.FalseKeyword || isBigIntLiteralExpression(
					initializer,
				));
				var isConstOrReadonly = isDeclarationReadonly(node) || isVariableDeclaration(
					node,
				) && isVarConst(node);
				if (isConstOrReadonly && !node.type) {
					if (isInvalidInitializer) {
						return grammarErrorOnNode(
							initializer,
							Diagnostics.A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_reference,
						);
					}
				} else {
					return grammarErrorOnNode(
						initializer,
						Diagnostics.Initializers_are_not_allowed_in_ambient_contexts,
					);
				}
				if (!isConstOrReadonly || isInvalidInitializer) {
					return grammarErrorOnNode(
						initializer,
						Diagnostics.Initializers_are_not_allowed_in_ambient_contexts,
					);
				}
			}
		}
		function checkGrammarVariableDeclaration(node) {
			if (
				node.parent.parent.kind !== SyntaxKind.ForInStatement && node.parent.parent.kind !== SyntaxKind.ForOfStatement
			) {
				if (node.flags & NodeFlags.Ambient) {
					checkAmbientInitializer(node);
				} else if (!node.initializer) {
					if (isBindingPattern(node.name) && !isBindingPattern(node.parent)) {
						return grammarErrorOnNode(
							node,
							Diagnostics.A_destructuring_declaration_must_have_an_initializer,
						);
					}
					if (isVarConst(node)) {
						return grammarErrorOnNode(
							node,
							Diagnostics.const_declarations_must_be_initialized,
						);
					}
				}
			}
			if (
				node.exclamationToken && (node.parent.parent.kind !== SyntaxKind.VariableStatement || !node.type || node.initializer || node.flags & NodeFlags.Ambient)
			) {
				var message = node.initializer ? Diagnostics.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions : !node.type ? Diagnostics.Declarations_with_definite_assignment_assertions_must_also_have_type_annotations : Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context;
				return grammarErrorOnNode(node.exclamationToken, message);
			}
			if (
				(moduleKind < ModuleKind.ES2015 || getSourceFileOfNode(node).impliedNodeFormat === ModuleKind.CommonJS) && moduleKind !== ModuleKind.System && !(node.parent.parent.flags & NodeFlags.Ambient) && hasSyntacticModifier(
					node.parent.parent,
					ModifierFlags.Export,
				)
			) {
				checkESModuleMarker(node.name);
			}
			var checkLetConstNames = (isLet(node) || isVarConst(node));
			// 1. LexicalDeclaration : LetOrConst BindingList ;
			// It is a Syntax Error if the BoundNames of BindingList contains "let".
			// 2. ForDeclaration: ForDeclaration : LetOrConst ForBinding
			// It is a Syntax Error if the BoundNames of ForDeclaration contains "let".
			// It is a SyntaxError if a VariableDeclaration or VariableDeclarationNoIn occurs within strict code
			// and its Identifier is eval or arguments
			return checkLetConstNames && checkGrammarNameInLetOrConstDeclarations(
				node.name,
			);
		}
		function checkESModuleMarker(name) {
			if (name.kind === SyntaxKind.Identifier) {
				if (idText(name) === "__esModule") {
					return grammarErrorOnNodeSkippedOn(
						"noEmit",
						name,
						Diagnostics.Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules,
					);
				}
			} else {
				var elements = name.elements;
				for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
					var element = elements_1[_i];
					if (!isOmittedExpression(element)) {
						return checkESModuleMarker(element.name);
					}
				}
			}
			return false;
		}
		function checkGrammarNameInLetOrConstDeclarations(name) {
			if (name.kind === SyntaxKind.Identifier) {
				if (name.originalKeywordKind === SyntaxKind.LetKeyword) {
					return grammarErrorOnNode(
						name,
						Diagnostics.let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations,
					);
				}
			} else {
				var elements = name.elements;
				for (var _i = 0, elements_2 = elements; _i < elements_2.length; _i++) {
					var element = elements_2[_i];
					if (!isOmittedExpression(element)) {
						checkGrammarNameInLetOrConstDeclarations(element.name);
					}
				}
			}
			return false;
		}
		function checkGrammarVariableDeclarationList(declarationList) {
			var declarations = declarationList.declarations;
			if (checkGrammarForDisallowedTrailingComma(declarationList.declarations)) {
				return true;
			}
			if (!declarationList.declarations.length) {
				return grammarErrorAtPos(
					declarationList,
					declarations.pos,
					declarations.end - declarations.pos,
					Diagnostics.Variable_declaration_list_cannot_be_empty,
				);
			}
			return false;
		}
		function allowLetAndConstDeclarations(parent) {
			switch (parent.kind) {
				case SyntaxKind.IfStatement:
				case SyntaxKind.DoStatement:
				case SyntaxKind.WhileStatement:
				case SyntaxKind.WithStatement:
				case SyntaxKind.ForStatement:
				case SyntaxKind.ForInStatement:
				case SyntaxKind.ForOfStatement:
					return false;
				case SyntaxKind.LabeledStatement:
					return allowLetAndConstDeclarations(parent.parent);
			}
			return true;
		}
		function checkGrammarForDisallowedLetOrConstStatement(node) {
			if (!allowLetAndConstDeclarations(node.parent)) {
				if (isLet(node.declarationList)) {
					return grammarErrorOnNode(
						node,
						Diagnostics.let_declarations_can_only_be_declared_inside_a_block,
					);
				} else if (isVarConst(node.declarationList)) {
					return grammarErrorOnNode(
						node,
						Diagnostics.const_declarations_can_only_be_declared_inside_a_block,
					);
				}
			}
		}
		function checkGrammarMetaProperty(node) {
			var escapedText = node.name.escapedText;
			switch (node.keywordToken) {
				case SyntaxKind.NewKeyword:
					if (escapedText !== "target") {
						return grammarErrorOnNode(
							node.name,
							Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2,
							node.name.escapedText,
							tokenToString(node.keywordToken),
							"target",
						);
					}
					break;
				case SyntaxKind.ImportKeyword:
					if (escapedText !== "meta") {
						return grammarErrorOnNode(
							node.name,
							Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2,
							node.name.escapedText,
							tokenToString(node.keywordToken),
							"meta",
						);
					}
					break;
			}
		}
		function hasParseDiagnostics(sourceFile) {
			return sourceFile.parseDiagnostics.length > 0;
		}
		function grammarErrorOnFirstToken(node, message, arg0, arg1, arg2) {
			var sourceFile = getSourceFileOfNode(node);
			if (!hasParseDiagnostics(sourceFile)) {
				var span = getSpanOfTokenAtPosition(sourceFile, node.pos);
				diagnostics.add(
					createFileDiagnostic(
						sourceFile,
						span.start,
						span.length,
						message,
						arg0,
						arg1,
						arg2,
					),
				);
				return true;
			}
			return false;
		}
		function grammarErrorAtPos(
			nodeForSourceFile,
			start,
			length,
			message,
			arg0,
			arg1,
			arg2,
		) {
			var sourceFile = getSourceFileOfNode(nodeForSourceFile);
			if (!hasParseDiagnostics(sourceFile)) {
				diagnostics.add(
					createFileDiagnostic(
						sourceFile,
						start,
						length,
						message,
						arg0,
						arg1,
						arg2,
					),
				);
				return true;
			}
			return false;
		}
		function grammarErrorOnNodeSkippedOn(key, node, message, arg0, arg1, arg2) {
			var sourceFile = getSourceFileOfNode(node);
			if (!hasParseDiagnostics(sourceFile)) {
				errorSkippedOn(key, node, message, arg0, arg1, arg2);
				return true;
			}
			return false;
		}
		function grammarErrorOnNode(node, message, arg0, arg1, arg2) {
			var sourceFile = getSourceFileOfNode(node);
			if (!hasParseDiagnostics(sourceFile)) {
				diagnostics.add(
					createDiagnosticForNode(node, message, arg0, arg1, arg2),
				);
				return true;
			}
			return false;
		}
		function checkGrammarConstructorTypeParameters(node) {
			var jsdocTypeParameters = isInJSFile(node) ? getJSDocTypeParameterDeclarations(
				node,
			) : undefined;
			var range = node.typeParameters || jsdocTypeParameters && firstOrUndefined(
				jsdocTypeParameters,
			);
			if (range) {
				var pos = range.pos === range.end ? range.pos : skipTrivia(
					getSourceFileOfNode(node).text,
					range.pos,
				);
				return grammarErrorAtPos(
					node,
					pos,
					range.end - pos,
					Diagnostics.Type_parameters_cannot_appear_on_a_constructor_declaration,
				);
			}
		}
		function checkGrammarConstructorTypeAnnotation(node) {
			var type = getEffectiveReturnTypeNode(node);
			if (type) {
				return grammarErrorOnNode(
					type,
					Diagnostics.Type_annotation_cannot_appear_on_a_constructor_declaration,
				);
			}
		}
		function checkGrammarProperty(node) {
			if (
				isComputedPropertyName(node.name) && isBinaryExpression(
					node.name.expression,
				) && node.name.expression.operatorToken.kind === SyntaxKind.InKeyword
			) {
				return grammarErrorOnNode(
					node.parent.members[0],
					Diagnostics.A_mapped_type_may_not_declare_properties_or_methods,
				);
			}
			if (isClassLike(node.parent)) {
				if (isStringLiteral(node.name) && node.name.text === "constructor") {
					return grammarErrorOnNode(
						node.name,
						Diagnostics.Classes_may_not_have_a_field_named_constructor,
					);
				}
				if (
					checkGrammarForInvalidDynamicName(
						node.name,
						Diagnostics.A_computed_property_name_in_a_class_property_declaration_must_have_a_simple_literal_type_or_a_unique_symbol_type,
					)
				) {
					return true;
				}
				if (
					languageVersion < ScriptTarget.ES2015 && isPrivateIdentifier(
						node.name,
					)
				) {
					return grammarErrorOnNode(
						node.name,
						Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher,
					);
				}
			} else if (node.parent.kind === SyntaxKind.InterfaceDeclaration) {
				if (
					checkGrammarForInvalidDynamicName(
						node.name,
						Diagnostics.A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type,
					)
				) {
					return true;
				}
				if (node.initializer) {
					return grammarErrorOnNode(
						node.initializer,
						Diagnostics.An_interface_property_cannot_have_an_initializer,
					);
				}
			} else if (isTypeLiteralNode(node.parent)) {
				if (
					checkGrammarForInvalidDynamicName(
						node.name,
						Diagnostics.A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type,
					)
				) {
					return true;
				}
				if (node.initializer) {
					return grammarErrorOnNode(
						node.initializer,
						Diagnostics.A_type_literal_property_cannot_have_an_initializer,
					);
				}
			}
			if (node.flags & NodeFlags.Ambient) {
				checkAmbientInitializer(node);
			}
			if (
				isPropertyDeclaration(node) && node.exclamationToken && (!isClassLike(
					node.parent,
				) || !node.type || node.initializer || node.flags & NodeFlags.Ambient || isStatic(
					node,
				) || hasAbstractModifier(node))
			) {
				var message = node.initializer ? Diagnostics.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions : !node.type ? Diagnostics.Declarations_with_definite_assignment_assertions_must_also_have_type_annotations : Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context;
				return grammarErrorOnNode(node.exclamationToken, message);
			}
		}
		function checkGrammarTopLevelElementForRequiredDeclareModifier(node) {
			// A declare modifier is required for any top level .d.ts declaration except export=, export default, export as namespace
			// interfaces and imports categories:
			//
			//  DeclarationElement:
			//     ExportAssignment
			//     export_opt   InterfaceDeclaration
			//     export_opt   TypeAliasDeclaration
			//     export_opt   ImportDeclaration
			//     export_opt   ExternalImportDeclaration
			//     export_opt   AmbientDeclaration
			//
			// TODO: The spec needs to be amended to reflect this grammar.
			if (
				node.kind === SyntaxKind.InterfaceDeclaration || node.kind === SyntaxKind.TypeAliasDeclaration || node.kind === SyntaxKind.ImportDeclaration || node.kind === SyntaxKind.ImportEqualsDeclaration || node.kind === SyntaxKind.ExportDeclaration || node.kind === SyntaxKind.ExportAssignment || node.kind === SyntaxKind.NamespaceExportDeclaration || hasSyntacticModifier(
					node,
					ModifierFlags.Ambient | ModifierFlags.Export | ModifierFlags.Default,
				)
			) {
				return false;
			}
			return grammarErrorOnFirstToken(
				node,
				Diagnostics.Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier,
			);
		}
		function checkGrammarTopLevelElementsForRequiredDeclareModifier(file) {
			for (var _i = 0, _a = file.statements; _i < _a.length; _i++) {
				var decl = _a[_i];
				if (isDeclaration(decl) || decl.kind === SyntaxKind.VariableStatement) {
					if (checkGrammarTopLevelElementForRequiredDeclareModifier(decl)) {
						return true;
					}
				}
			}
			return false;
		}
		function checkGrammarSourceFile(node) {
			return !!(node.flags & NodeFlags.Ambient) && checkGrammarTopLevelElementsForRequiredDeclareModifier(
				node,
			);
		}
		function checkGrammarStatementInAmbientContext(node) {
			if (node.flags & NodeFlags.Ambient) {
				// Find containing block which is either Block, ModuleBlock, SourceFile
				var links = getNodeLinks(node);
				if (
					!links.hasReportedStatementInAmbientContext && (isFunctionLike(
						node.parent,
					) || isAccessor(node.parent))
				) {
					return getNodeLinks(node).hasReportedStatementInAmbientContext = grammarErrorOnFirstToken(
						node,
						Diagnostics.An_implementation_cannot_be_declared_in_ambient_contexts,
					);
				}
				// We are either parented by another statement, or some sort of block.
				// If we're in a block, we only want to really report an error once
				// to prevent noisiness.  So use a bit on the block to indicate if
				// this has already been reported, and don't report if it has.
				//
				if (
					node.parent.kind === SyntaxKind.Block || node.parent.kind === SyntaxKind.ModuleBlock || node.parent.kind === SyntaxKind.SourceFile
				) {
					var links_2 = getNodeLinks(node.parent);
					// Check if the containing block ever report this error
					if (!links_2.hasReportedStatementInAmbientContext) {
						return links_2.hasReportedStatementInAmbientContext = grammarErrorOnFirstToken(
							node,
							Diagnostics.Statements_are_not_allowed_in_ambient_contexts,
						);
					}
				} else {
				// We must be parented by a statement.  If so, there's no need
				// to report the error as our parent will have already done it.
				// Debug.assert(isStatement(node.parent));
				}
			}
			return false;
		}
		function checkGrammarNumericLiteral(node) {
			// Grammar checking
			if (node.numericLiteralFlags & TokenFlags.Octal) {
				var diagnosticMessage = void 0;
				if (languageVersion >= ScriptTarget.ES5) {
					diagnosticMessage = Diagnostics.Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher_Use_the_syntax_0;
				} else if (isChildOfNodeWithKind(node, SyntaxKind.LiteralType)) {
					diagnosticMessage = Diagnostics.Octal_literal_types_must_use_ES2015_syntax_Use_the_syntax_0;
				} else if (isChildOfNodeWithKind(node, SyntaxKind.EnumMember)) {
					diagnosticMessage = Diagnostics.Octal_literals_are_not_allowed_in_enums_members_initializer_Use_the_syntax_0;
				}
				if (diagnosticMessage) {
					var withMinus = isPrefixUnaryExpression(node.parent) && node.parent.operator === SyntaxKind.MinusToken;
					var literal = (withMinus ? "-" : "") + "0o" + node.text;
					return grammarErrorOnNode(
						withMinus ? node.parent : node,
						diagnosticMessage,
						literal,
					);
				}
			}
			// Realism (size) checking
			checkNumericLiteralValueSize(node);
			return false;
		}
		function checkNumericLiteralValueSize(node) {
			// We should test against `getTextOfNode(node)` rather than `node.text`, because `node.text` for large numeric literals can contain "."
			// e.g. `node.text` for numeric literal `1100000000000000000000` is `1.1e21`.
			var isFractional = getTextOfNode(node).indexOf(".") !== -1;
			var isScientific = node.numericLiteralFlags & TokenFlags.Scientific;
			// Scientific notation (e.g. 2e54 and 1e00000000010) can't be converted to bigint
			// Fractional numbers (e.g. 9000000000000000.001) are inherently imprecise anyway
			if (isFractional || isScientific) {
				return;
			}
			// Here `node` is guaranteed to be a numeric literal representing an integer.
			// We need to judge whether the integer `node` represents is <= 2 ** 53 - 1, which can be accomplished by comparing to `value` defined below because:
			// 1) when `node` represents an integer <= 2 ** 53 - 1, `node.text` is its exact string representation and thus `value` precisely represents the integer.
			// 2) otherwise, although `node.text` may be imprecise string representation, its mathematical value and consequently `value` cannot be less than 2 ** 53,
			//    thus the result of the predicate won't be affected.
			var value = +node.text;
			if (value <= Math.pow(2, 53) - 1) {
				return;
			}
			addErrorOrSuggestion(
				false, /*isError*/
				createDiagnosticForNode(
					node,
					Diagnostics.Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accurately_as_integers,
				),
			);
		}
		function checkGrammarBigIntLiteral(node) {
			var literalType = isLiteralTypeNode(node.parent) || isPrefixUnaryExpression(
				node.parent,
			) && isLiteralTypeNode(node.parent.parent);
			if (!literalType) {
				if (languageVersion < ScriptTarget.ES2020) {
					if (
						grammarErrorOnNode(
							node,
							Diagnostics.BigInt_literals_are_not_available_when_targeting_lower_than_ES2020,
						)
					) {
						return true;
					}
				}
			}
			return false;
		}
		function grammarErrorAfterFirstToken(node, message, arg0, arg1, arg2) {
			var sourceFile = getSourceFileOfNode(node);
			if (!hasParseDiagnostics(sourceFile)) {
				var span = getSpanOfTokenAtPosition(sourceFile, node.pos);
				diagnostics.add(
					createFileDiagnostic(
						sourceFile,
						textSpanEnd(span), /*length*/
						0,
						message,
						arg0,
						arg1,
						arg2,
					),
				);
				return true;
			}
			return false;
		}
		function getAmbientModules() {
			if (!ambientModulesCache) {
				ambientModulesCache = [];
				globals.forEach(
					function (global, sym) {
						// No need to `unescapeLeadingUnderscores`, an escaped symbol is never an ambient module.
						if (ambientModuleSymbolRegex.test(sym)) {
							ambientModulesCache.push(global);
						}
					},
				);
			}
			return ambientModulesCache;
		}
		function checkGrammarImportClause(node) {
			var _a;
			if (node.isTypeOnly && node.name && node.namedBindings) {
				return grammarErrorOnNode(
					node,
					Diagnostics.A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both,
				);
			}
			if (
				node.isTypeOnly && ((_a = node.namedBindings) === null || _a === void 0 ? void 0 : _a.kind) === SyntaxKind.NamedImports
			) {
				return checkGrammarNamedImportsOrExports(node.namedBindings);
			}
			return false;
		}
		function checkGrammarNamedImportsOrExports(namedBindings) {
			return !!forEach(
				namedBindings.elements,
				function (specifier) {
					if (specifier.isTypeOnly) {
						return grammarErrorOnFirstToken(
							specifier,
							specifier.kind === SyntaxKind.ImportSpecifier ? Diagnostics.The_type_modifier_cannot_be_used_on_a_named_import_when_import_type_is_used_on_its_import_statement : Diagnostics.The_type_modifier_cannot_be_used_on_a_named_export_when_export_type_is_used_on_its_export_statement,
						);
					}
				},
			);
		}
		function checkGrammarImportCallExpression(node) {
			if (moduleKind === ModuleKind.ES2015) {
				return grammarErrorOnNode(
					node,
					Diagnostics.Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_es2022_esnext_commonjs_amd_system_umd_node12_or_nodenext,
				);
			}
			if (node.typeArguments) {
				return grammarErrorOnNode(
					node,
					Diagnostics.Dynamic_import_cannot_have_type_arguments,
				);
			}
			var nodeArguments = node.arguments;
			if (
				moduleKind !== ModuleKind.ESNext && moduleKind !== ModuleKind.NodeNext
			) {
				// We are allowed trailing comma after proposal-import-assertions.
				checkGrammarForDisallowedTrailingComma(nodeArguments);
				if (nodeArguments.length > 1) {
					var assertionArgument = nodeArguments[1];
					return grammarErrorOnNode(
						assertionArgument,
						Diagnostics.Dynamic_imports_only_support_a_second_argument_when_the_module_option_is_set_to_esnext_or_nodenext,
					);
				}
			}
			if (nodeArguments.length === 0 || nodeArguments.length > 2) {
				return grammarErrorOnNode(
					node,
					Diagnostics.Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_assertion_as_arguments,
				);
			}
			// see: parseArgumentOrArrayLiteralElement...we use this function which parse arguments of callExpression to parse specifier for dynamic import.
			// parseArgumentOrArrayLiteralElement allows spread element to be in an argument list which is not allowed as specifier in dynamic import.
			var spreadElement = find(nodeArguments, isSpreadElement);
			if (spreadElement) {
				return grammarErrorOnNode(
					spreadElement,
					Diagnostics.Argument_of_dynamic_import_cannot_be_spread_element,
				);
			}
			return false;
		}
		function findMatchingTypeReferenceOrTypeAliasReference(source, unionTarget) {
			var sourceObjectFlags = getObjectFlags(source);
			if (
				sourceObjectFlags & (ObjectFlags.Reference | ObjectFlags.Anonymous) && unionTarget.flags & TypeFlags.Union
			) {
				return find(
					unionTarget.types,
					function (target) {
						if (target.flags & TypeFlags.Object) {
							var overlapObjFlags = sourceObjectFlags & getObjectFlags(target);
							if (overlapObjFlags & ObjectFlags.Reference) {
								return source.target === target.target;
							}
							if (overlapObjFlags & ObjectFlags.Anonymous) {
								return !!source.aliasSymbol && source.aliasSymbol === target.aliasSymbol;
							}
						}
						return false;
					},
				);
			}
		}
		function findBestTypeForObjectLiteral(source, unionTarget) {
			if (
				getObjectFlags(source) & ObjectFlags.ObjectLiteral && someType(
					unionTarget,
					isArrayLikeType,
				)
			) {
				return find(
					unionTarget.types,
					function (t) {
						return !isArrayLikeType(t);
					},
				);
			}
		}
		function findBestTypeForInvokable(source, unionTarget) {
			var signatureKind = SignatureKind.Call;
			var hasSignatures = getSignaturesOfType(source, signatureKind).length > 0 || (signatureKind = SignatureKind.Construct, getSignaturesOfType(
				source,
				signatureKind,
			).length > 0);
			if (hasSignatures) {
				return find(
					unionTarget.types,
					function (t) {
						return getSignaturesOfType(t, signatureKind).length > 0;
					},
				);
			}
		}
		function findMostOverlappyType(source, unionTarget) {
			var bestMatch;
			var matchingCount = 0;
			for (var _i = 0, _a = unionTarget.types; _i < _a.length; _i++) {
				var target = _a[_i];
				var overlap = getIntersectionType(
					[getIndexType(source), getIndexType(target)],
				);
				if (overlap.flags & TypeFlags.Index) {
					// perfect overlap of keys
					bestMatch = target;
					matchingCount = Infinity;
				} else if (overlap.flags & TypeFlags.Union) {
					// We only want to account for literal types otherwise.
					// If we have a union of index types, it seems likely that we
					// needed to elaborate between two generic mapped types anyway.
					var len = length(filter(overlap.types, isUnitType));
					if (len >= matchingCount) {
						bestMatch = target;
						matchingCount = len;
					}
				} else if (isUnitType(overlap) && 1 >= matchingCount) {
					bestMatch = target;
					matchingCount = 1;
				}
			}
			return bestMatch;
		}
		function filterPrimitivesIfContainsNonPrimitive(type) {
			if (maybeTypeOfKind(type, TypeFlags.NonPrimitive)) {
				var result = filterType(
					type,
					function (t) {
						return !(t.flags & TypeFlags.Primitive);
					},
				);
				if (!(result.flags & TypeFlags.Never)) {
					return result;
				}
			}
			return type;
		}
		// Keep this up-to-date with the same logic within `getApparentTypeOfContextualType`, since they should behave similarly
		function findMatchingDiscriminantType(
			source,
			target,
			isRelatedTo,
			skipPartial,
		) {
			if (
				target.flags & TypeFlags.Union && source.flags & (TypeFlags.Intersection | TypeFlags.Object)
			) {
				var match = getMatchingUnionConstituentForType(target, source);
				if (match) {
					return match;
				}
				var sourceProperties = getPropertiesOfType(source);
				if (sourceProperties) {
					var sourcePropertiesFiltered = findDiscriminantProperties(
						sourceProperties,
						target,
					);
					if (sourcePropertiesFiltered) {
						return discriminateTypeByDiscriminableItems(
							target,
							map(
								sourcePropertiesFiltered,
								function (p) {
									return [
										function () {
											return getTypeOfSymbol(p);
										},
										p.escapedName,
									];
								},
							),
							isRelatedTo, /*defaultValue*/
							undefined,
							skipPartial,
						);
					}
				}
			}
			return undefined;
		}
	}
	ts.createTypeChecker = createTypeChecker;
	function isNotAccessor(declaration) {
		// Accessors check for their own matching duplicates, and in contexts where they are valid, there are already duplicate identifier checks
		return !isAccessor(declaration);
	}
	function isNotOverload(declaration) {
		return (declaration.kind !== SyntaxKind.FunctionDeclaration && declaration.kind !== SyntaxKind.MethodDeclaration) || !!declaration.body;
	}
	/** Like 'isDeclarationName', but returns true for LHS of `import { x as y }` or `export { x as y }`. */
	function isDeclarationNameOrImportPropertyName(name) {
		switch (name.parent.kind) {
			case SyntaxKind.ImportSpecifier:
			case SyntaxKind.ExportSpecifier:
				return isIdentifier(name);
			default:
				return isDeclarationName(name);
		}
	}
	var JsxNames;
	(function (JsxNames) {
		JsxNames.JSX = "JSX";
		JsxNames.IntrinsicElements = "IntrinsicElements";
		JsxNames.ElementClass = "ElementClass";
		JsxNames.ElementAttributesPropertyNameContainer = "ElementAttributesProperty"; // TODO: Deprecate and remove support
		JsxNames.ElementChildrenAttributeNameContainer = "ElementChildrenAttribute";
		JsxNames.Element = "Element";
		JsxNames.IntrinsicAttributes = "IntrinsicAttributes";
		JsxNames.IntrinsicClassAttributes = "IntrinsicClassAttributes";
		JsxNames.LibraryManagedAttributes = "LibraryManagedAttributes";
	})(JsxNames || (JsxNames = {}));
	function getIterationTypesKeyFromIterationTypeKind(typeKind) {
		switch (typeKind) {
			case 0: /* Yield */
				return "yieldType";
			case 1: /* Return */
				return "returnType";
			case 2: /* Next */
				return "nextType";
		}
	}
	function signatureHasRestParameter(s) {
		return !!(s.flags & SignatureFlags.HasRestParameter);
	}
	ts.signatureHasRestParameter = signatureHasRestParameter;
	function signatureHasLiteralTypes(s) {
		return !!(s.flags & SignatureFlags.HasLiteralTypes);
	}
	ts.signatureHasLiteralTypes = signatureHasLiteralTypes;
})(ts || (ts = {}));
